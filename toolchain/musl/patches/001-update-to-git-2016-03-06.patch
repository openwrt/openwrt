commit 636a4799dd5bf11a1fcd209906c088ed948b821c
Author: Rich Felker <dalias@aerifal.cx>
Date:   Sun Mar 6 17:11:29 2016 -0500

    make configure check for unsupported (SPE) powerpc hard-float models
    
    the SPE ABI may be compatible with soft-float, but actually making it
    work requires some additional work, so for now it's best to make sure
    broken builds don't happen.

commit 5a92dd95c77cee81755f1a441ae0b71e3ae2bcdb
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Mon Jan 25 13:20:52 2016 +0100

    add powerpc soft-float support
    
    Some PowerPC CPUs (e.g. Freescale MPC85xx) have a completely different
    instruction set for floating point operations (SPE).
    Executing regular PowerPC floating point instructions results in
    "Illegal instruction" errors.
    
    Make it possible to run these devices in soft-float mode.

commit 9543656cc32fda48fc463f332ee20e91eed2b768
Author: Alexander Monakov <amonakov@ispras.ru>
Date:   Sun Mar 6 20:22:38 2016 +0300

    env: avoid leaving dangling pointers in __env_map
    
    This is the minimal fix for __putenv leaving a pointer to freed heap
    storage in __env_map array, which could later on lead to errors such
    as double-free.

commit 589aefa5b061647e8b9ad9bca3aaa8dc6222460a
Author: Rich Felker <dalias@aerifal.cx>
Date:   Sun Mar 6 17:48:58 2016 +0000

    update documentation files for mips64 port

commit 83933573aff71a5d178ab71912f177d2d844e63e
Author: Rich Felker <dalias@aerifal.cx>
Date:   Sun Mar 6 17:41:56 2016 +0000

    add mips64 port
    
    patch by Mahesh Bodapati and Jaydeep Patil of Imagination
    Technologies.

commit 71392a91c333d47b6b3c8f99c897e3b5a7eb6d58
Author: Rich Felker <dalias@aerifal.cx>
Date:   Sun Mar 6 17:25:52 2016 +0000

    generalize mips-specific reloc code not to hard-code sym/type encoding
    
    this change is made in preparation for adding the mips64 port, which
    needs a 64-bit (and mips64-specific) form of the R_INFO macro, but
    it's a better abstraction anyway.
    
    based on part of the mips64 port patch by Mahesh Bodapati and Jaydeep
    Patil of Imagination Technologies.

commit b023c03b574acdfd73418314a5dcaa83e5cea5a0
Author: Szabolcs Nagy <nsz@port70.net>
Date:   Fri Mar 4 21:23:33 2016 +0000

    math: fix expf(-NAN) and exp2f(-NAN) to return -NAN instead of 0
    
    expf(-NAN) was treated as expf(-large) which unconditionally
    returns +0, so special case +-NAN.
    reported by Petr Hosek.

commit db66ef1f7db7c5b672591a97a97bc789c9efe2f3
Author: Nathan Zadoks <nathan@nathan7.eu>
Date:   Wed Mar 2 17:26:27 2016 +0100

    add sched_getcpu vDSO support
    
    This brings the call to an actually usable speed.
    Quick unscientific benchmark: 14ns : 102ns :: vDSO : syscall

commit 98d335735d64ee34a34cb9c08ea2cb51a076d2a1
Author: Nathan Zadoks <nathan@nathan7.eu>
Date:   Wed Mar 2 17:26:26 2016 +0100

    add sched_getcpu
    
    This is a GNU extension, but a fairly minor one, for a system call that
    otherwise has no libc wrapper.

commit 29b13575376509bb21539711f30c1deaf0823033
Author: Szabolcs Nagy <nsz@port70.net>
Date:   Mon Feb 29 16:36:25 2016 +0000

    fix ^* at the start of a complete BRE
    
    This is a workaround to treat * as literal * at the start of a BRE.
    
    Ideally ^ would be treated as an anchor at the start of any BRE
    subexpression and similarly $ would be an anchor at the end of any
    subexpression.  This is not required by the standard and hard to do
    with the current code, but it's the existing practice.  If it is
    changed, * should be treated as literal after such anchor as well.

commit 39ea71fb8afddda879a1999f2a203dfdaf57a639
Author: Szabolcs Nagy <nsz@port70.net>
Date:   Mon Feb 29 15:04:46 2016 +0000

    fix * at the start of a BRE subexpression
    
    commit 7eaa76fc2e7993582989d3838b1ac32dd8abac09 made * invalid at
    the start of a BRE subexpression, but it should be accepted as
    literal * there according to the standard.
    
    This patch does not fix subexpressions starting with ^*.

commit 6e694d6960d9d50a119e8660c95bf9308e609053
Author: Michael Meeuwisse <mickeymeeuw@gmail.com>
Date:   Tue Feb 23 23:49:57 2016 +0100

    explicitly include stdio.h to get EOF definition needed by wctob

commit 6d70c08a2c37745df637b231711f6dec79dbc6e1
Author: Rich Felker <dalias@aerifal.cx>
Date:   Wed Mar 2 00:34:51 2016 -0500

    handle non-matching address family entries in hosts file
    
    name_from_hosts failed to account for the possibility of an address
    family error from name_from_numeric, wrongly counting such a return as
    success and using the uninitialized address data as part of the
    results passed up to the caller.
    
    non-matching address family entries cannot simply be ignored or
    results would be inconsistent with respect to whether AF_UNSPEC or a
    specific address family is queried. instead, record that a
    non-matching entry was seen, and fail the lookup with EAI_NONAME of no
    matching-family entries are found.

commit fd224a800b68843c4d8d1002b07dd91041a7fa32
Author: Rich Felker <dalias@aerifal.cx>
Date:   Tue Feb 23 13:04:56 2016 -0500

    make aarch64 atomic_arch.h report that it defines pointer-sized ll/sc
    
    at present this is done only for consistency, since this file defines
    its own a_cas_p rather than using the new generic one from atomic.h
    added in commit 225f6a6b5b7173b6655e4f5d49b5b9fea70bf3bb. these
    definitions may however be useful if we ever need to add other
    pointer-sized atomic operations.

commit 225f6a6b5b7173b6655e4f5d49b5b9fea70bf3bb
Author: Bobby Bingham <koorogi@koorogi.info>
Date:   Mon Feb 22 21:14:23 2016 -0600

    allow implementing a_cas_p with pointer-sized ll/sc
    
    No current ports do this, but it will be useful for porting to 64-bit ll/sc
    architectures, such as mips64 and powerpc64.

--- a/COPYRIGHT
+++ b/COPYRIGHT
@@ -43,6 +43,7 @@ Gianluca Anzolin
 Hauke Mehrtens
 Hiltjo Posthuma
 Isaac Dunham
+Jaydeep Patil
 Jens Gustedt
 Jeremy Huntwork
 Jo-Philipp Wich
@@ -55,6 +56,7 @@ Kylie McClain
 Luca Barbato
 Luka Perkov
 M Farkas-Dyck (Strake)
+Mahesh Bodapati
 Michael Forney
 Natanael Copa
 Nicholas J. Kain
@@ -123,6 +125,9 @@ Pennington for use in the ellcc project.
 by Rich Felker for build system and code conventions during upstream
 integration. It is licensed under the standard MIT terms.
 
+The mips64 port was contributed by Imagination Technologies and is
+licensed under the standard MIT terms.
+
 The powerpc port was also originally written by Richard Pennington,
 and later supplemented and integrated by John Spencer. It is licensed
 under the standard MIT terms.
--- a/INSTALL
+++ b/INSTALL
@@ -62,6 +62,12 @@ and ABI combinations:
     * MIPS2 or later, or kernel emulation of ll/sc (standard in Linux)
       is required
 
+* MIPS64
+    * ABI is n64 (LP64)
+    * Big-endian default; little-endian variants also supported
+    * Default ABI variant uses FPU registers; alternate soft-float ABI
+      that does not use FPU registers or instructions is available
+
 * PowerPC
     * Only 32-bit is supported
     * Compiler toolchain must provide 64-bit long double, not IBM
--- a/arch/aarch64/atomic_arch.h
+++ b/arch/aarch64/atomic_arch.h
@@ -34,6 +34,7 @@ static inline int a_cas(volatile int *p,
 	return old;
 }
 
+#define a_ll_p a_ll_p
 static inline void *a_ll_p(volatile void *p)
 {
 	void *v;
@@ -41,6 +42,7 @@ static inline void *a_ll_p(volatile void
 	return v;
 }
 
+#define a_sc_p a_sc_p
 static inline int a_sc_p(volatile int *p, void *v)
 {
 	int r;
--- /dev/null
+++ b/arch/mips64/atomic_arch.h
@@ -0,0 +1,50 @@
+#define a_ll a_ll
+static inline int a_ll(volatile int *p)
+{
+	int v;
+	__asm__ __volatile__ (
+		"ll %0, %1"
+		: "=r"(v) : "m"(*p));
+	return v;
+}
+
+#define a_sc a_sc
+static inline int a_sc(volatile int *p, int v)
+{
+	int r;
+	__asm__ __volatile__ (
+		"sc %0, %1"
+		: "=r"(r), "=m"(*p) : "0"(v) : "memory");
+	return r;
+}
+
+#define a_ll_p a_ll_p
+static inline void *a_ll_p(volatile long *p)
+{
+	void *v;
+	__asm__ __volatile__ (
+		"lld %0, %1"
+		: "=r"(v) : "m"(*p));
+	return v;
+}
+
+#define a_sc_p a_sc_p
+static inline int a_sc_p(volatile long *p, void *v)
+{
+	int r;
+	__asm__ __volatile__ (
+		"scd %0, %1"
+		: "=r"(r), "=m"(*p) : "0"(v) : "memory");
+	return r;
+}
+
+#define a_barrier a_barrier
+static inline void a_barrier()
+{
+	/* mips2 sync, but using too many directives causes
+	 * gcc not to inline it, so encode with .long instead. */
+	__asm__ __volatile__ (".long 0xf" : : : "memory");
+}
+
+#define a_pre_llsc a_barrier
+#define a_post_llsc a_barrier
--- /dev/null
+++ b/arch/mips64/bits/alltypes.h.in
@@ -0,0 +1,28 @@
+#define _Addr long
+#define _Int64 long
+#define _Reg long
+
+TYPEDEF __builtin_va_list va_list;
+TYPEDEF __builtin_va_list __isoc_va_list;
+
+#ifndef __cplusplus
+TYPEDEF int wchar_t;
+#endif
+
+TYPEDEF float float_t;
+TYPEDEF double double_t;
+
+TYPEDEF struct { long long __ll; long double __ld; } max_align_t;
+
+TYPEDEF long time_t;
+TYPEDEF long suseconds_t;
+
+TYPEDEF unsigned nlink_t;
+
+TYPEDEF struct { union { int __i[14]; volatile int __vi[14]; unsigned long __s[7]; } __u; } pthread_attr_t;
+TYPEDEF struct { union { int __i[10]; volatile int __vi[10]; volatile void *volatile __p[5]; } __u; } pthread_mutex_t;
+TYPEDEF struct { union { int __i[10]; volatile int __vi[10]; volatile void *volatile __p[5]; } __u; } mtx_t;
+TYPEDEF struct { union { int __i[12]; volatile int __vi[12]; void *__p[6]; } __u; } pthread_cond_t;
+TYPEDEF struct { union { int __i[12]; volatile int __vi[12]; void *__p[6]; } __u; } cnd_t;
+TYPEDEF struct { union { int __i[14]; volatile int __vi[14]; void *__p[7]; } __u; } pthread_rwlock_t;
+TYPEDEF struct { union { int __i[8]; volatile int __vi[8]; void *__p[4]; } __u; } pthread_barrier_t;
--- /dev/null
+++ b/arch/mips64/bits/endian.h
@@ -0,0 +1,5 @@
+#if _MIPSEL || __MIPSEL || __MIPSEL__
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#else
+#define __BYTE_ORDER __BIG_ENDIAN
+#endif
--- /dev/null
+++ b/arch/mips64/bits/errno.h
@@ -0,0 +1,134 @@
+#define EPERM            1
+#define ENOENT           2
+#define ESRCH            3
+#define EINTR            4
+#define EIO              5
+#define ENXIO            6
+#define E2BIG            7
+#define ENOEXEC          8
+#define EBADF            9
+#define ECHILD          10
+#define EAGAIN          11
+#define ENOMEM          12
+#define EACCES          13
+#define EFAULT          14
+#define ENOTBLK         15
+#define EBUSY           16
+#define EEXIST          17
+#define EXDEV           18
+#define ENODEV          19
+#define ENOTDIR         20
+#define EISDIR          21
+#define EINVAL          22
+#define ENFILE          23
+#define EMFILE          24
+#define ENOTTY          25
+#define ETXTBSY         26
+#define EFBIG           27
+#define ENOSPC          28
+#define ESPIPE          29
+#define EROFS           30
+#define EMLINK          31
+#define EPIPE           32
+#define EDOM            33
+#define ERANGE          34
+#define ENOMSG          35
+#define EIDRM           36
+#define ECHRNG          37
+#define EL2NSYNC        38
+#define EL3HLT          39
+#define EL3RST          40
+#define ELNRNG          41
+#define EUNATCH         42
+#define ENOCSI          43
+#define EL2HLT          44
+#define EDEADLK         45
+#define ENOLCK          46
+#define EBADE           50
+#define EBADR           51
+#define EXFULL          52
+#define ENOANO          53
+#define EBADRQC         54
+#define EBADSLT         55
+#define EDEADLOCK       56
+#define EBFONT          59
+#define ENOSTR          60
+#define ENODATA         61
+#define ETIME           62
+#define ENOSR           63
+#define ENONET          64
+#define ENOPKG          65
+#define EREMOTE         66
+#define ENOLINK         67
+#define EADV            68
+#define ESRMNT          69
+#define ECOMM           70
+#define EPROTO          71
+#define EDOTDOT         73
+#define EMULTIHOP       74
+#define EBADMSG         77
+#define ENAMETOOLONG    78
+#define EOVERFLOW       79
+#define ENOTUNIQ        80
+#define EBADFD          81
+#define EREMCHG         82
+#define ELIBACC         83
+#define ELIBBAD         84
+#define ELIBSCN         85
+#define ELIBMAX         86
+#define ELIBEXEC        87
+#define EILSEQ          88
+#define ENOSYS          89
+#define ELOOP           90
+#define ERESTART        91
+#define ESTRPIPE        92
+#define ENOTEMPTY       93
+#define EUSERS          94
+#define ENOTSOCK        95
+#define EDESTADDRREQ    96
+#define EMSGSIZE        97
+#define EPROTOTYPE      98
+#define ENOPROTOOPT     99
+#define EPROTONOSUPPORT 120
+#define ESOCKTNOSUPPORT 121
+#define EOPNOTSUPP      122
+#define ENOTSUP         EOPNOTSUPP
+#define EPFNOSUPPORT    123
+#define EAFNOSUPPORT    124
+#define EADDRINUSE      125
+#define EADDRNOTAVAIL   126
+#define ENETDOWN        127
+#define ENETUNREACH     128
+#define ENETRESET       129
+#define ECONNABORTED    130
+#define ECONNRESET      131
+#define ENOBUFS         132
+#define EISCONN         133
+#define ENOTCONN        134
+#define EUCLEAN         135
+#define ENOTNAM         137
+#define ENAVAIL         138
+#define EISNAM          139
+#define EREMOTEIO       140
+#define ESHUTDOWN       143
+#define ETOOMANYREFS    144
+#define ETIMEDOUT       145
+#define ECONNREFUSED    146
+#define EHOSTDOWN       147
+#define EHOSTUNREACH    148
+#define EWOULDBLOCK     EAGAIN
+#define EALREADY        149
+#define EINPROGRESS     150
+#define ESTALE          151
+#define ECANCELED       158
+#define ENOMEDIUM       159
+#define EMEDIUMTYPE     160
+#define ENOKEY          161
+#define EKEYEXPIRED     162
+#define EKEYREVOKED     163
+#define EKEYREJECTED    164
+#define EOWNERDEAD      165
+#define ENOTRECOVERABLE 166
+#define ERFKILL         167
+#define EHWPOISON       168
+#define EDQUOT          1133
--- /dev/null
+++ b/arch/mips64/bits/fcntl.h
@@ -0,0 +1,40 @@
+#define O_CREAT        0400
+#define O_EXCL        02000
+#define O_NOCTTY      04000
+#define O_TRUNC       01000
+#define O_APPEND       0010
+#define O_NONBLOCK     0200
+#define O_DSYNC        0020
+#define O_SYNC       040020
+#define O_RSYNC      040020
+#define O_DIRECTORY 0200000
+#define O_NOFOLLOW  0400000
+#define O_CLOEXEC  02000000
+
+#define O_ASYNC      010000
+#define O_DIRECT    0100000
+#define O_LARGEFILE       0
+#define O_NOATIME  01000000
+#define O_PATH    010000000
+#define O_TMPFILE 020200000
+#define O_NDELAY O_NONBLOCK
+
+#define F_DUPFD  0
+#define F_GETFD  1
+#define F_SETFD  2
+#define F_GETFL  3
+#define F_SETFL  4
+
+#define F_SETOWN 24
+#define F_GETOWN 23
+#define F_SETSIG 10
+#define F_GETSIG 11
+
+#define F_GETLK 14
+#define F_SETLK  6
+#define F_SETLKW 7
+
+#define F_SETOWN_EX 15
+#define F_GETOWN_EX 16
+
+#define F_GETOWNER_UIDS 17
--- /dev/null
+++ b/arch/mips64/bits/fenv.h
@@ -0,0 +1,25 @@
+#ifdef __mips_soft_float
+#define FE_ALL_EXCEPT 0
+#define FE_TONEAREST  0
+#else
+#define FE_INEXACT    4
+#define FE_UNDERFLOW  8
+#define FE_OVERFLOW   16
+#define FE_DIVBYZERO  32
+#define FE_INVALID    64
+
+#define FE_ALL_EXCEPT 124
+
+#define FE_TONEAREST  0
+#define FE_TOWARDZERO 1
+#define FE_UPWARD     2
+#define FE_DOWNWARD   3
+#endif
+
+typedef unsigned short fexcept_t;
+
+typedef struct {
+	unsigned __cw;
+} fenv_t;
+
+#define FE_DFL_ENV ((const fenv_t *) -1)
--- /dev/null
+++ b/arch/mips64/bits/float.h
@@ -0,0 +1,16 @@
+#define FLT_EVAL_METHOD 0
+
+#define LDBL_TRUE_MIN 6.47517511943802511092443895822764655e-4966L
+#define LDBL_MIN 3.36210314311209350626267781732175260e-4932L
+#define LDBL_MAX 1.18973149535723176508575932662800702e+4932L
+#define LDBL_EPSILON 1.92592994438723585305597794258492732e-34L
+
+#define LDBL_MANT_DIG 113
+#define LDBL_MIN_EXP (-16381)
+#define LDBL_MAX_EXP 16384
+
+#define LDBL_DIG 33
+#define LDBL_MIN_10_EXP (-4931)
+#define LDBL_MAX_10_EXP 4932
+
+#define DECIMAL_DIG 36
--- /dev/null
+++ b/arch/mips64/bits/ioctl.h
@@ -0,0 +1,210 @@
+#define _IOC(a,b,c,d) ( ((a)<<29) | ((b)<<8) | (c) | ((d)<<16) )
+#define _IOC_NONE  1U
+#define _IOC_READ  2U
+#define _IOC_WRITE 4U
+
+#define _IO(a,b) _IOC(_IOC_NONE,(a),(b),0)
+#define _IOW(a,b,c) _IOC(_IOC_WRITE,(a),(b),sizeof(c))
+#define _IOR(a,b,c) _IOC(_IOC_READ,(a),(b),sizeof(c))
+#define _IOWR(a,b,c) _IOC(_IOC_READ|_IOC_WRITE,(a),(b),sizeof(c))
+
+#define TCGETA		0x5401
+#define TCSETA		0x5402
+#define TCSETAW		0x5403
+#define TCSETAF		0x5404
+#define TCSBRK		0x5405
+#define TCXONC		0x5406
+#define TCFLSH		0x5407
+#define TCGETS		0x540D
+#define TCSETS		0x540E
+#define TCSETSW		0x540F
+#define TCSETSF		0x5410
+
+#define TIOCEXCL	0x740D
+#define TIOCNXCL	0x740E
+#define TIOCOUTQ	0x7472
+#define TIOCSTI		0x5472
+#define TIOCMGET	0x741D
+#define TIOCMBIS	0x741B
+#define TIOCMBIC	0x741C
+#define TIOCMSET	0x741D
+
+#define TIOCPKT		0x5470
+#define TIOCSWINSZ	_IOW('t', 103, struct winsize)
+#define TIOCGWINSZ	_IOR('t', 104, struct winsize)
+#define TIOCNOTTY	0x5471
+#define TIOCSETD	0x7401
+#define TIOCGETD	0x7400
+
+#define FIOCLEX		0x6601
+#define FIONCLEX	0x6602
+#define FIOASYNC	0x667D
+#define FIONBIO		0x667E
+#define FIOQSIZE	0x667F
+
+#define TIOCGLTC        0x7474
+#define TIOCSLTC        0x7475
+#define TIOCSPGRP	_IOW('t', 118, int)
+#define TIOCGPGRP	_IOR('t', 119, int)
+#define TIOCCONS	_IOW('t', 120, int)
+
+#define FIONREAD	0x467F
+#define TIOCINQ		FIONREAD
+
+#define TIOCGETP        0x7408
+#define TIOCSETP        0x7409
+#define TIOCSETN        0x740A
+
+#define TIOCSBRK	0x5427
+#define TIOCCBRK	0x5428
+#define TIOCGSID	0x7416
+#define TIOCGPTN	_IOR('T', 0x30, unsigned int)
+#define TIOCSPTLCK	_IOW('T', 0x31, int)
+
+#define TIOCSCTTY	0x5480
+#define TIOCGSOFTCAR	0x5481
+#define TIOCSSOFTCAR	0x5482
+#define TIOCLINUX	0x5483
+#define TIOCGSERIAL	0x5484
+#define TIOCSSERIAL	0x5485
+#define TCSBRKP		0x5486
+
+#define TIOCSERCONFIG	0x5488
+#define TIOCSERGWILD	0x5489
+#define TIOCSERSWILD	0x548A
+#define TIOCGLCKTRMIOS	0x548B
+#define TIOCSLCKTRMIOS	0x548C
+#define TIOCSERGSTRUCT	0x548D
+#define TIOCSERGETLSR   0x548E
+#define TIOCSERGETMULTI 0x548F
+#define TIOCSERSETMULTI 0x5490
+#define TIOCMIWAIT	0x5491
+#define TIOCGICOUNT	0x5492
+#define TIOCGHAYESESP   0x5493
+#define TIOCSHAYESESP   0x5494
+
+#define TIOCTTYGSTRUCT	0x5426
+#define TCGETX		0x5432
+#define TCSETX		0x5433
+#define TCSETXF		0x5434
+#define TCSETXW		0x5435
+
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+#define TIOCPKT_IOCTL		64
+
+#define TIOCSER_TEMT    0x01
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define TIOCM_LE        0x001
+#define TIOCM_DTR       0x002
+#define TIOCM_RTS       0x004
+#define TIOCM_ST        0x008
+#define TIOCM_SR        0x010
+#define TIOCM_CTS       0x020
+#define TIOCM_CAR       0x040
+#define TIOCM_RNG       0x080
+#define TIOCM_DSR       0x100
+#define TIOCM_CD        TIOCM_CAR
+#define TIOCM_RI        TIOCM_RNG
+#define TIOCM_OUT1      0x2000
+#define TIOCM_OUT2      0x4000
+#define TIOCM_LOOP      0x8000
+#define TIOCM_MODEM_BITS TIOCM_OUT2
+
+#define N_TTY           0
+#define N_SLIP          1
+#define N_MOUSE         2
+#define N_PPP           3
+#define N_STRIP         4
+#define N_AX25          5
+#define N_X25           6
+#define N_6PACK         7
+#define N_MASC          8
+#define N_R3964         9
+#define N_PROFIBUS_FDL  10
+#define N_IRDA          11
+#define N_SMSBLOCK      12
+#define N_HDLC          13
+#define N_SYNC_PPP      14
+#define N_HCI           15
+
+#define FIOSETOWN       0x8901
+#define SIOCSPGRP       0x8902
+#define FIOGETOWN       0x8903
+#define SIOCGPGRP       0x8904
+#define SIOCATMARK      0x8905
+#define SIOCGSTAMP      0x8906
+
+#define SIOCADDRT       0x890B
+#define SIOCDELRT       0x890C
+#define SIOCRTMSG       0x890D
+
+#define SIOCGIFNAME     0x8910
+#define SIOCSIFLINK     0x8911
+#define SIOCGIFCONF     0x8912
+#define SIOCGIFFLAGS    0x8913
+#define SIOCSIFFLAGS    0x8914
+#define SIOCGIFADDR     0x8915
+#define SIOCSIFADDR     0x8916
+#define SIOCGIFDSTADDR  0x8917
+#define SIOCSIFDSTADDR  0x8918
+#define SIOCGIFBRDADDR  0x8919
+#define SIOCSIFBRDADDR  0x891a
+#define SIOCGIFNETMASK  0x891b
+#define SIOCSIFNETMASK  0x891c
+#define SIOCGIFMETRIC   0x891d
+#define SIOCSIFMETRIC   0x891e
+#define SIOCGIFMEM      0x891f
+#define SIOCSIFMEM      0x8920
+#define SIOCGIFMTU      0x8921
+#define SIOCSIFMTU      0x8922
+#define SIOCSIFHWADDR   0x8924
+#define SIOCGIFENCAP    0x8925
+#define SIOCSIFENCAP    0x8926
+#define SIOCGIFHWADDR   0x8927
+#define SIOCGIFSLAVE    0x8929
+#define SIOCSIFSLAVE    0x8930
+#define SIOCADDMULTI    0x8931
+#define SIOCDELMULTI    0x8932
+#define SIOCGIFINDEX    0x8933
+#define SIOGIFINDEX     SIOCGIFINDEX
+#define SIOCSIFPFLAGS   0x8934
+#define SIOCGIFPFLAGS   0x8935
+#define SIOCDIFADDR     0x8936
+#define SIOCSIFHWBROADCAST 0x8937
+#define SIOCGIFCOUNT    0x8938
+
+#define SIOCGIFBR       0x8940
+#define SIOCSIFBR       0x8941
+
+#define SIOCGIFTXQLEN   0x8942
+#define SIOCSIFTXQLEN   0x8943
+
+#define SIOCDARP        0x8953
+#define SIOCGARP        0x8954
+#define SIOCSARP        0x8955
+
+#define SIOCDRARP       0x8960
+#define SIOCGRARP       0x8961
+#define SIOCSRARP       0x8962
+
+#define SIOCGIFMAP      0x8970
+#define SIOCSIFMAP      0x8971
+
+#define SIOCADDDLCI     0x8980
+#define SIOCDELDLCI     0x8981
+
+#define SIOCDEVPRIVATE		0x89F0
+#define SIOCPROTOPRIVATE	0x89E0
--- /dev/null
+++ b/arch/mips64/bits/ipc.h
@@ -0,0 +1,14 @@
+struct ipc_perm {
+	key_t __ipc_perm_key;
+	uid_t uid;
+	gid_t gid;
+	uid_t cuid;
+	gid_t cgid;
+	mode_t mode;
+	int __ipc_perm_seq;
+	int __pad1;
+	unsigned long __unused1;
+	unsigned long __unused2;
+};
+
+#define IPC_64 0x100
--- /dev/null
+++ b/arch/mips64/bits/limits.h
@@ -0,0 +1,7 @@
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define LONG_BIT 64
+#endif
+
+#define LONG_MAX 0x7fffffffffffffffL
+#define LLONG_MAX 0x7fffffffffffffffLL
--- /dev/null
+++ b/arch/mips64/bits/mman.h
@@ -0,0 +1,58 @@
+#define MAP_FAILED ((void *) -1)
+
+#define	PROT_NONE      0
+#define	PROT_READ      1
+#define	PROT_WRITE     2
+#define	PROT_EXEC      4
+#define	PROT_GROWSDOWN 0x01000000
+#define	PROT_GROWSUP   0x02000000
+
+#define	MAP_SHARED     0x01
+#define	MAP_PRIVATE    0x02
+#define	MAP_FIXED      0x10
+
+#define MAP_TYPE       0x0f
+#define MAP_FILE       0x00
+#define MAP_ANON       0x800
+#define MAP_ANONYMOUS  MAP_ANON
+#define MAP_NORESERVE  0x0400
+#define MAP_GROWSDOWN  0x1000
+#define MAP_DENYWRITE  0x2000
+#define MAP_EXECUTABLE 0x4000
+#define MAP_LOCKED     0x8000
+#define MAP_POPULATE   0x10000
+#define MAP_NONBLOCK   0x20000
+#define MAP_STACK      0x40000
+#define MAP_HUGETLB    0x80000
+
+#define POSIX_MADV_NORMAL       0
+#define POSIX_MADV_RANDOM       1
+#define POSIX_MADV_SEQUENTIAL   2
+#define POSIX_MADV_WILLNEED     3
+#define POSIX_MADV_DONTNEED     0
+
+#define MS_ASYNC        1
+#define MS_INVALIDATE   2
+#define MS_SYNC         4
+
+#define MCL_CURRENT     1
+#define MCL_FUTURE      2
+#define MCL_ONFAULT     4
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define MADV_NORMAL      0
+#define MADV_RANDOM      1
+#define MADV_SEQUENTIAL  2
+#define MADV_WILLNEED    3
+#define MADV_DONTNEED    4
+#define MADV_REMOVE      9
+#define MADV_DONTFORK    10
+#define MADV_DOFORK      11
+#define MADV_MERGEABLE   12
+#define MADV_UNMERGEABLE 13
+#define MADV_HUGEPAGE    14
+#define MADV_NOHUGEPAGE  15
+#define MADV_DONTDUMP    16
+#define MADV_DODUMP      17
+#define MADV_HWPOISON    100
+#endif
--- /dev/null
+++ b/arch/mips64/bits/msg.h
@@ -0,0 +1,13 @@
+struct msqid_ds {
+	struct ipc_perm msg_perm;
+	time_t msg_stime;
+	time_t msg_rtime;
+	time_t msg_ctime;
+	unsigned long msg_cbytes;
+	msgqnum_t msg_qnum;
+	msglen_t msg_qbytes;
+	pid_t msg_lspid;
+	pid_t msg_lrpid;
+	unsigned long __pad1;
+	unsigned long __pad2;
+};
--- /dev/null
+++ b/arch/mips64/bits/poll.h
@@ -0,0 +1,2 @@
+#define POLLWRNORM POLLOUT
+#define POLLWRBAND 0x100
--- /dev/null
+++ b/arch/mips64/bits/posix.h
@@ -0,0 +1,2 @@
+#define _POSIX_V6_LP64_OFFBIG 1
+#define _POSIX_V7_LP64_OFFBIG 1
--- /dev/null
+++ b/arch/mips64/bits/reg.h
@@ -0,0 +1,47 @@
+#undef __WORDSIZE
+#define __WORDSIZE 64
+
+#define EF_R0 0
+#define EF_R1 1
+#define EF_R2 2
+#define EF_R3 3
+#define EF_R4 4
+#define EF_R5 5
+#define EF_R6 6
+#define EF_R7 7
+#define EF_R8 8
+#define EF_R9 9
+#define EF_R10 10
+#define EF_R11 11
+#define EF_R12 12
+#define EF_R13 13
+#define EF_R14 14
+#define EF_R15 15
+#define EF_R16 16
+#define EF_R17 17
+#define EF_R18 18
+#define EF_R19 19
+#define EF_R20 20
+#define EF_R21 21
+#define EF_R22 22
+#define EF_R23 23
+#define EF_R24 24
+#define EF_R25 25
+
+#define EF_R26 26
+#define EF_R27 27
+#define EF_R28 28
+#define EF_R29 29
+#define EF_R30 30
+#define EF_R31 31
+
+#define EF_LO 32
+#define EF_HI 33
+
+#define EF_CP0_EPC 34
+#define EF_CP0_BADVADDR 35
+#define EF_CP0_STATUS 36
+#define EF_CP0_CAUSE 37
+#define EF_UNUSED0 38
+
+#define EF_SIZE 304
--- /dev/null
+++ b/arch/mips64/bits/resource.h
@@ -0,0 +1,5 @@
+#define RLIMIT_NOFILE  5
+#define RLIMIT_AS      6
+#define RLIMIT_RSS     7
+#define RLIMIT_NPROC   8
+#define RLIMIT_MEMLOCK 9
--- /dev/null
+++ b/arch/mips64/bits/sem.h
@@ -0,0 +1,14 @@
+struct semid_ds {
+	struct ipc_perm sem_perm;
+	time_t sem_otime;
+	time_t sem_ctime;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned short sem_nsems;
+	char __sem_nsems_pad[sizeof(time_t)-sizeof(short)];
+#else
+	char __sem_nsems_pad[sizeof(time_t)-sizeof(short)];
+	unsigned short sem_nsems;
+#endif
+	time_t __unused3;
+	time_t __unused4;
+};
--- /dev/null
+++ b/arch/mips64/bits/setjmp.h
@@ -0,0 +1 @@
+typedef unsigned long long __jmp_buf[23];
--- /dev/null
+++ b/arch/mips64/bits/shm.h
@@ -0,0 +1,24 @@
+#define SHMLBA 4096
+
+struct shmid_ds {
+	struct ipc_perm shm_perm;
+	size_t shm_segsz;
+	time_t shm_atime;
+	time_t shm_dtime;
+	time_t shm_ctime;
+	pid_t shm_cpid;
+	pid_t shm_lpid;
+	unsigned long shm_nattch;
+	unsigned long __pad1;
+	unsigned long __pad2;
+};
+
+struct shminfo {
+	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, __unused[4];
+};
+
+struct shm_info {
+	int __used_ids;
+	unsigned long shm_tot, shm_rss, shm_swp;
+	unsigned long __swap_attempts, __swap_successes;
+};
--- /dev/null
+++ b/arch/mips64/bits/signal.h
@@ -0,0 +1,143 @@
+#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
+ || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define MINSIGSTKSZ 2048
+#define SIGSTKSZ 8192
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+typedef unsigned long long greg_t, gregset_t[32];
+
+typedef struct {
+	union {
+		double fp_dregs[32];
+		struct {
+			float _fp_fregs;
+			unsigned _fp_pad;
+		} fp_fregs[32];
+	} fp_r;
+} fpregset_t;
+
+struct sigcontext {
+	unsigned long long sc_regs[32];
+	unsigned long long sc_fpregs[32];
+	unsigned long long sc_mdhi;
+	unsigned long long sc_hi1;
+	unsigned long long sc_hi2;
+	unsigned long long sc_hi3;
+	unsigned long long sc_mdlo;
+	unsigned long long sc_lo1;
+	unsigned long long sc_lo2;
+	unsigned long long sc_lo3;
+	unsigned long long sc_pc;
+	unsigned int sc_fpc_csr;
+	unsigned int sc_used_math;
+	unsigned int sc_dsp;
+	unsigned int sc_reserved;
+};
+
+typedef struct {
+	gregset_t gregs;
+	fpregset_t fpregs;
+	greg_t mdhi;
+	greg_t hi1;
+	greg_t hi2;
+	greg_t hi3;
+	greg_t mdlo;
+	greg_t lo1;
+	greg_t lo2;
+	greg_t lo3;
+	greg_t pc;
+	unsigned int fpc_csr;
+	unsigned int used_math;
+	unsigned int dsp;
+	unsigned int reserved;
+} mcontext_t;
+
+#else
+typedef struct {
+	unsigned long long __mc1[32];
+	double __mc2[32];
+	unsigned long long __mc3[9];
+	unsigned __mc4[4];
+} mcontext_t;
+#endif
+
+struct sigaltstack {
+	void *ss_sp;
+	size_t ss_size;
+	int ss_flags;
+};
+
+typedef struct __ucontext {
+	unsigned long uc_flags;
+	struct __ucontext *uc_link;
+	stack_t uc_stack;
+	mcontext_t uc_mcontext;
+	sigset_t uc_sigmask;
+} ucontext_t;
+
+#define SA_NOCLDSTOP  1
+#define SA_NOCLDWAIT  0x10000
+#define SA_SIGINFO    8
+#define SA_ONSTACK    0x08000000
+#define SA_RESTART    0x10000000
+#define SA_NODEFER    0x40000000
+#define SA_RESETHAND  0x80000000
+#define SA_RESTORER   0x04000000
+
+#undef SIG_BLOCK
+#undef SIG_UNBLOCK
+#undef SIG_SETMASK
+#define SIG_BLOCK     1
+#define SIG_UNBLOCK   2
+#define SIG_SETMASK   3
+
+#undef SI_ASYNCIO
+#undef SI_MESGQ
+#undef SI_TIMER
+#define SI_ASYNCIO (-2)
+#define SI_MESGQ (-4)
+#define SI_TIMER (-3)
+
+#define __SI_SWAP_ERRNO_CODE
+
+#endif
+
+#define SIGHUP    1
+#define SIGINT    2
+#define SIGQUIT   3
+#define SIGILL    4
+#define SIGTRAP   5
+#define SIGABRT   6
+#define SIGIOT    SIGABRT
+#define SIGSTKFLT 7
+#define SIGFPE    8
+#define SIGKILL   9
+#define SIGBUS    10
+#define SIGSEGV   11
+#define SIGSYS    12
+#define SIGPIPE   13
+#define SIGALRM   14
+#define SIGTERM   15
+#define SIGUSR1   16
+#define SIGUSR2   17
+#define SIGCHLD   18
+#define SIGPWR    19
+#define SIGWINCH  20
+#define SIGURG    21
+#define SIGIO     22
+#define SIGPOLL   SIGIO
+#define SIGSTOP   23
+#define SIGTSTP   24
+#define SIGCONT   25
+#define SIGTTIN   26
+#define SIGTTOU   27
+#define SIGVTALRM 28
+#define SIGPROF   29
+#define SIGXCPU   30
+#define SIGXFSZ   31
+#define SIGUNUSED SIGSYS
+
+#define _NSIG 128
--- /dev/null
+++ b/arch/mips64/bits/socket.h
@@ -0,0 +1,68 @@
+#include <endian.h>
+
+struct msghdr {
+	void *msg_name;
+	socklen_t msg_namelen;
+	struct iovec *msg_iov;
+#if __BYTE_ORDER == __BIG_ENDIAN
+	int __pad1, msg_iovlen;
+#else
+	int msg_iovlen, __pad1;
+#endif
+	void *msg_control;
+#if __BYTE_ORDER == __BIG_ENDIAN
+	int __pad2;
+	socklen_t msg_controllen;
+#else
+	socklen_t msg_controllen;
+	int __pad2;
+#endif
+	int msg_flags;
+};
+
+struct cmsghdr {
+#if __BYTE_ORDER == __BIG_ENDIAN
+	int __pad1;
+	socklen_t cmsg_len;
+#else
+	socklen_t cmsg_len;
+	int __pad1;
+#endif
+	int cmsg_level;
+	int cmsg_type;
+};
+
+#define SOCK_STREAM    2
+#define SOCK_DGRAM     1
+#define SOL_SOCKET     65535
+#define SO_DEBUG       1
+
+#define SO_REUSEADDR    0x0004
+#define SO_KEEPALIVE    0x0008
+#define SO_DONTROUTE    0x0010
+#define SO_BROADCAST    0x0020
+#define SO_LINGER       0x0080
+#define SO_OOBINLINE    0x0100
+#define SO_REUSEPORT    0x0200
+#define SO_SNDBUF       0x1001
+#define SO_RCVBUF       0x1002
+#define SO_SNDLOWAT     0x1003
+#define SO_RCVLOWAT     0x1004
+#define SO_RCVTIMEO     0x1006
+#define SO_SNDTIMEO     0x1005
+#define SO_ERROR        0x1007
+#define SO_TYPE         0x1008
+#define SO_ACCEPTCONN   0x1009
+#define SO_PROTOCOL     0x1028
+#define SO_DOMAIN       0x1029
+
+#define SO_NO_CHECK     11
+#define SO_PRIORITY     12
+#define SO_BSDCOMPAT    14
+#define SO_PASSCRED     17
+#define SO_PEERCRED     18
+#define SO_SNDBUFFORCE  31
+#define SO_RCVBUFFORCE  33
+
+#define SOCK_NONBLOCK     0200
+#define SOCK_CLOEXEC  02000000
--- /dev/null
+++ b/arch/mips64/bits/stat.h
@@ -0,0 +1,23 @@
+#include <string.h>
+#include <bits/alltypes.h>
+
+struct stat {
+	dev_t st_dev;
+	int __pad1[3];
+	ino_t st_ino;
+	mode_t st_mode;
+	nlink_t st_nlink;
+	uid_t st_uid;
+	gid_t st_gid;
+	dev_t st_rdev;
+	unsigned int __pad2[2];
+	off_t st_size;
+	int __pad3;
+	struct timespec st_atim;
+	struct timespec st_mtim;
+	struct timespec st_ctim;
+	blksize_t st_blksize;
+	unsigned int __pad4;
+	blkcnt_t st_blocks;
+	int __pad5[14];
+};
--- /dev/null
+++ b/arch/mips64/bits/statfs.h
@@ -0,0 +1,8 @@
+struct statfs {
+	unsigned long f_type, f_bsize, f_frsize;
+	fsblkcnt_t f_blocks, f_bfree;
+	fsfilcnt_t f_files, f_ffree;
+	fsblkcnt_t f_bavail;
+	fsid_t f_fsid;
+	unsigned long f_namelen, f_flags, f_spare[5];
+};
--- /dev/null
+++ b/arch/mips64/bits/stdint.h
@@ -0,0 +1,20 @@
+typedef int32_t int_fast16_t;
+typedef int32_t int_fast32_t;
+typedef uint32_t uint_fast16_t;
+typedef uint32_t uint_fast32_t;
+
+#define INT_FAST16_MIN  INT32_MIN
+#define INT_FAST32_MIN  INT32_MIN
+
+#define INT_FAST16_MAX  INT32_MAX
+#define INT_FAST32_MAX  INT32_MAX
+
+#define UINT_FAST16_MAX UINT32_MAX
+#define UINT_FAST32_MAX UINT32_MAX
+
+#define INTPTR_MIN      INT64_MIN
+#define INTPTR_MAX      INT64_MAX
+#define UINTPTR_MAX     UINT64_MAX
+#define PTRDIFF_MIN     INT64_MIN
+#define PTRDIFF_MAX     INT64_MAX
+#define SIZE_MAX        UINT64_MAX
--- /dev/null
+++ b/arch/mips64/bits/syscall.h
@@ -0,0 +1,633 @@
+#define __NR_read			5000
+#define __NR_write			5001
+#define __NR_open			5002
+#define __NR_close			5003
+#define __NR_stat			5004
+#define __NR_fstat			5005
+#define __NR_lstat			5006
+#define __NR_poll			5007
+#define __NR_lseek			5008
+#define __NR_mmap			5009
+#define __NR_mprotect			5010
+#define __NR_munmap			5011
+#define __NR_brk			5012
+#define __NR_rt_sigaction		5013
+#define __NR_rt_sigprocmask		5014
+#define __NR_ioctl			5015
+#define __NR_pread64			5016
+#define __NR_pwrite64			5017
+#define __NR_readv			5018
+#define __NR_writev			5019
+#define __NR_access			5020
+#define __NR_pipe			5021
+#define __NR__newselect			5022
+#define __NR_sched_yield		5023
+#define __NR_mremap			5024
+#define __NR_msync			5025
+#define __NR_mincore			5026
+#define __NR_madvise			5027
+#define __NR_shmget			5028
+#define __NR_shmat			5029
+#define __NR_shmctl			5030
+#define __NR_dup			5031
+#define __NR_dup2			5032
+#define __NR_pause			5033
+#define __NR_nanosleep			5034
+#define __NR_getitimer			5035
+#define __NR_setitimer			5036
+#define __NR_alarm			5037
+#define __NR_getpid			5038
+#define __NR_sendfile			5039
+#define __NR_socket			5040
+#define __NR_connect			5041
+#define __NR_accept			5042
+#define __NR_sendto			5043
+#define __NR_recvfrom			5044
+#define __NR_sendmsg			5045
+#define __NR_recvmsg			5046
+#define __NR_shutdown			5047
+#define __NR_bind			5048
+#define __NR_listen			5049
+#define __NR_getsockname		5050
+#define __NR_getpeername		5051
+#define __NR_socketpair			5052
+#define __NR_setsockopt			5053
+#define __NR_getsockopt			5054
+#define __NR_clone			5055
+#define __NR_fork			5056
+#define __NR_execve			5057
+#define __NR_exit			5058
+#define __NR_wait4			5059
+#define __NR_kill			5060
+#define __NR_uname			5061
+#define __NR_semget			5062
+#define __NR_semop			5063
+#define __NR_semctl			5064
+#define __NR_shmdt			5065
+#define __NR_msgget			5066
+#define __NR_msgsnd			5067
+#define __NR_msgrcv			5068
+#define __NR_msgctl			5069
+#define __NR_fcntl			5070
+#define __NR_flock			5071
+#define __NR_fsync			5072
+#define __NR_fdatasync			5073
+#define __NR_truncate			5074
+#define __NR_ftruncate			5075
+#define __NR_getdents			5076
+#define __NR_getcwd			5077
+#define __NR_chdir			5078
+#define __NR_fchdir			5079
+#define __NR_rename			5080
+#define __NR_mkdir			5081
+#define __NR_rmdir			5082
+#define __NR_creat			5083
+#define __NR_link			5084
+#define __NR_unlink			5085
+#define __NR_symlink			5086
+#define __NR_readlink			5087
+#define __NR_chmod			5088
+#define __NR_fchmod			5089
+#define __NR_chown			5090
+#define __NR_fchown			5091
+#define __NR_lchown			5092
+#define __NR_umask			5093
+#define __NR_gettimeofday		5094
+#define __NR_getrlimit			5095
+#define __NR_getrusage			5096
+#define __NR_sysinfo			5097
+#define __NR_times			5098
+#define __NR_ptrace			5099
+#define __NR_getuid			5100
+#define __NR_syslog			5101
+#define __NR_getgid			5102
+#define __NR_setuid			5103
+#define __NR_setgid			5104
+#define __NR_geteuid			5105
+#define __NR_getegid			5106
+#define __NR_setpgid			5107
+#define __NR_getppid			5108
+#define __NR_getpgrp			5109
+#define __NR_setsid			5110
+#define __NR_setreuid			5111
+#define __NR_setregid			5112
+#define __NR_getgroups			5113
+#define __NR_setgroups			5114
+#define __NR_setresuid			5115
+#define __NR_getresuid			5116
+#define __NR_setresgid			5117
+#define __NR_getresgid			5118
+#define __NR_getpgid			5119
+#define __NR_setfsuid			5120
+#define __NR_setfsgid			5121
+#define __NR_getsid			5122
+#define __NR_capget			5123
+#define __NR_capset			5124
+#define __NR_rt_sigpending		5125
+#define __NR_rt_sigtimedwait		5126
+#define __NR_rt_sigqueueinfo		5127
+#define __NR_rt_sigsuspend		5128
+#define __NR_sigaltstack		5129
+#define __NR_utime			5130
+#define __NR_mknod			5131
+#define __NR_personality		5132
+#define __NR_ustat			5133
+#define __NR_statfs			5134
+#define __NR_fstatfs			5135
+#define __NR_sysfs			5136
+#define __NR_getpriority		5137
+#define __NR_setpriority		5138
+#define __NR_sched_setparam		5139
+#define __NR_sched_getparam		5140
+#define __NR_sched_setscheduler		5141
+#define __NR_sched_getscheduler		5142
+#define __NR_sched_get_priority_max	5143
+#define __NR_sched_get_priority_min	5144
+#define __NR_sched_rr_get_interval	5145
+#define __NR_mlock			5146
+#define __NR_munlock			5147
+#define __NR_mlockall			5148
+#define __NR_munlockall			5149
+#define __NR_vhangup			5150
+#define __NR_pivot_root			5151
+#define __NR__sysctl			5152
+#define __NR_prctl			5153
+#define __NR_adjtimex			5154
+#define __NR_setrlimit			5155
+#define __NR_chroot			5156
+#define __NR_sync			5157
+#define __NR_acct			5158
+#define __NR_settimeofday		5159
+#define __NR_mount			5160
+#define __NR_umount2			5161
+#define __NR_swapon			5162
+#define __NR_swapoff			5163
+#define __NR_reboot			5164
+#define __NR_sethostname		5165
+#define __NR_setdomainname		5166
+#define __NR_create_module		5167
+#define __NR_init_module		5168
+#define __NR_delete_module		5169
+#define __NR_get_kernel_syms		5170
+#define __NR_query_module		5171
+#define __NR_quotactl			5172
+#define __NR_nfsservctl			5173
+#define __NR_getpmsg			5174
+#define __NR_putpmsg			5175
+#define __NR_afs_syscall		5176
+#define __NR_reserved177		5177
+#define __NR_gettid			5178
+#define __NR_readahead			5179
+#define __NR_setxattr			5180
+#define __NR_lsetxattr			5181
+#define __NR_fsetxattr			5182
+#define __NR_getxattr			5183
+#define __NR_lgetxattr			5184
+#define __NR_fgetxattr			5185
+#define __NR_listxattr			5186
+#define __NR_llistxattr			5187
+#define __NR_flistxattr			5188
+#define __NR_removexattr		5189
+#define __NR_lremovexattr		5190
+#define __NR_fremovexattr		5191
+#define __NR_tkill			5192
+#define __NR_reserved193		5193
+#define __NR_futex			5194
+#define __NR_sched_setaffinity		5195
+#define __NR_sched_getaffinity		5196
+#define __NR_cacheflush			5197
+#define __NR_cachectl			5198
+#define __NR_sysmips			5199
+#define __NR_io_setup			5200
+#define __NR_io_destroy			5201
+#define __NR_io_getevents		5202
+#define __NR_io_submit			5203
+#define __NR_io_cancel			5204
+#define __NR_exit_group			5205
+#define __NR_lookup_dcookie		5206
+#define __NR_epoll_create		5207
+#define __NR_epoll_ctl			5208
+#define __NR_epoll_wait			5209
+#define __NR_remap_file_pages		5210
+#define __NR_rt_sigreturn		5211
+#define __NR_set_tid_address		5212
+#define __NR_restart_syscall		5213
+#define __NR_semtimedop			5214
+#define __NR_fadvise64			5215
+#define __NR_timer_create		5216
+#define __NR_timer_settime		5217
+#define __NR_timer_gettime		5218
+#define __NR_timer_getoverrun		5219
+#define __NR_timer_delete		5220
+#define __NR_clock_settime		5221
+#define __NR_clock_gettime		5222
+#define __NR_clock_getres		5223
+#define __NR_clock_nanosleep		5224
+#define __NR_tgkill			5225
+#define __NR_utimes			5226
+#define __NR_mbind			5227
+#define __NR_get_mempolicy		5228
+#define __NR_set_mempolicy		5229
+#define __NR_mq_open			5230
+#define __NR_mq_unlink			5231
+#define __NR_mq_timedsend		5232
+#define __NR_mq_timedreceive		5233
+#define __NR_mq_notify			5234
+#define __NR_mq_getsetattr		5235
+#define __NR_vserver			5236
+#define __NR_waitid			5237
+#define __NR_add_key			5239
+#define __NR_request_key		5240
+#define __NR_keyctl			5241
+#define __NR_set_thread_area		5242
+#define __NR_inotify_init		5243
+#define __NR_inotify_add_watch		5244
+#define __NR_inotify_rm_watch		5245
+#define __NR_migrate_pages		5246
+#define __NR_openat			5247
+#define __NR_mkdirat			5248
+#define __NR_mknodat			5249
+#define __NR_fchownat			5250
+#define __NR_futimesat			5251
+#define __NR_newfstatat			5252
+#define __NR_unlinkat			5253
+#define __NR_renameat			5254
+#define __NR_linkat			5255
+#define __NR_symlinkat			5256
+#define __NR_readlinkat			5257
+#define __NR_fchmodat			5258
+#define __NR_faccessat			5259
+#define __NR_pselect6			5260
+#define __NR_ppoll			5261
+#define __NR_unshare			5262
+#define __NR_splice			5263
+#define __NR_sync_file_range		5264
+#define __NR_tee			5265
+#define __NR_vmsplice			5266
+#define __NR_move_pages			5267
+#define __NR_set_robust_list		5268
+#define __NR_get_robust_list		5269
+#define __NR_kexec_load			5270
+#define __NR_getcpu			5271
+#define __NR_epoll_pwait		5272
+#define __NR_ioprio_set			5273
+#define __NR_ioprio_get			5274
+#define __NR_utimensat			5275
+#define __NR_signalfd			5276
+#define __NR_timerfd			5277
+#define __NR_eventfd			5278
+#define __NR_fallocate			5279
+#define __NR_timerfd_create		5280
+#define __NR_timerfd_gettime		5281
+#define __NR_timerfd_settime		5282
+#define __NR_signalfd4			5283
+#define __NR_eventfd2			5284
+#define __NR_epoll_create1		5285
+#define __NR_dup3			5286
+#define __NR_pipe2			5287
+#define __NR_inotify_init1		5288
+#define __NR_preadv			5289
+#define __NR_pwritev			5290
+#define __NR_rt_tgsigqueueinfo		5291
+#define __NR_perf_event_open		5292
+#define __NR_accept4			5293
+#define __NR_recvmmsg			5294
+#define __NR_fanotify_init		5295
+#define __NR_fanotify_mark		5296
+#define __NR_prlimit64			5297
+#define __NR_name_to_handle_at		5298
+#define __NR_open_by_handle_at		5299
+#define __NR_clock_adjtime		5300
+#define __NR_syncfs			5301
+#define __NR_sendmmsg			5302
+#define __NR_setns			5303
+#define __NR_process_vm_readv		5304
+#define __NR_process_vm_writev		5305
+#define __NR_kcmp			5306
+#define __NR_finit_module		5307
+#define __NR_getdents64			5308
+#define __NR_sched_setattr		5309
+#define __NR_sched_getattr		5310
+#define __NR_renameat2			5311
+#define __NR_seccomp			5312
+#define __NR_getrandom			5313
+#define __NR_memfd_create		5314
+#define __NR_bpf			5315
+#define __NR_execveat			5316
+
+#define SYS_read			5000
+#define SYS_write			5001
+#define SYS_open			5002
+#define SYS_close			5003
+#define SYS_stat			5004
+#define SYS_fstat			5005
+#define SYS_lstat			5006
+#define SYS_poll			5007
+#define SYS_lseek			5008
+#define SYS_mmap			5009
+#define SYS_mprotect			5010
+#define SYS_munmap			5011
+#define SYS_brk				5012
+#define SYS_rt_sigaction		5013
+#define SYS_rt_sigprocmask		5014
+#define SYS_ioctl			5015
+#define SYS_pread64			5016
+#define SYS_pwrite64			5017
+#define SYS_readv			5018
+#define SYS_writev			5019
+#define SYS_access			5020
+#define SYS_pipe			5021
+#define SYS__newselect			5022
+#define SYS_sched_yield			5023
+#define SYS_mremap			5024
+#define SYS_msync			5025
+#define SYS_mincore			5026
+#define SYS_madvise			5027
+#define SYS_shmget			5028
+#define SYS_shmat			5029
+#define SYS_shmctl			5030
+#define SYS_dup				5031
+#define SYS_dup2			5032
+#define SYS_pause			5033
+#define SYS_nanosleep			5034
+#define SYS_getitimer			5035
+#define SYS_setitimer			5036
+#define SYS_alarm			5037
+#define SYS_getpid			5038
+#define SYS_sendfile			5039
+#define SYS_socket			5040
+#define SYS_connect			5041
+#define SYS_accept			5042
+#define SYS_sendto			5043
+#define SYS_recvfrom			5044
+#define SYS_sendmsg			5045
+#define SYS_recvmsg			5046
+#define SYS_shutdown			5047
+#define SYS_bind			5048
+#define SYS_listen			5049
+#define SYS_getsockname			5050
+#define SYS_getpeername			5051
+#define SYS_socketpair			5052
+#define SYS_setsockopt			5053
+#define SYS_getsockopt			5054
+#define SYS_clone			5055
+#define SYS_fork			5056
+#define SYS_execve			5057
+#define SYS_exit			5058
+#define SYS_wait4			5059
+#define SYS_kill			5060
+#define SYS_uname			5061
+#define SYS_semget			5062
+#define SYS_semop			5063
+#define SYS_semctl			5064
+#define SYS_shmdt			5065
+#define SYS_msgget			5066
+#define SYS_msgsnd			5067
+#define SYS_msgrcv			5068
+#define SYS_msgctl			5069
+#define SYS_fcntl			5070
+#define SYS_flock			5071
+#define SYS_fsync			5072
+#define SYS_fdatasync			5073
+#define SYS_truncate			5074
+#define SYS_ftruncate			5075
+#define SYS_getdents			5076
+#define SYS_getcwd			5077
+#define SYS_chdir			5078
+#define SYS_fchdir			5079
+#define SYS_rename			5080
+#define SYS_mkdir			5081
+#define SYS_rmdir			5082
+#define SYS_creat			5083
+#define SYS_link			5084
+#define SYS_unlink			5085
+#define SYS_symlink			5086
+#define SYS_readlink			5087
+#define SYS_chmod			5088
+#define SYS_fchmod			5089
+#define SYS_chown			5090
+#define SYS_fchown			5091
+#define SYS_lchown			5092
+#define SYS_umask			5093
+#define SYS_gettimeofday		5094
+#define SYS_getrlimit			5095
+#define SYS_getrusage			5096
+#define SYS_sysinfo			5097
+#define SYS_times			5098
+#define SYS_ptrace			5099
+#define SYS_getuid			5100
+#define SYS_syslog			5101
+#define SYS_getgid			5102
+#define SYS_setuid			5103
+#define SYS_setgid			5104
+#define SYS_geteuid			5105
+#define SYS_getegid			5106
+#define SYS_setpgid			5107
+#define SYS_getppid			5108
+#define SYS_getpgrp			5109
+#define SYS_setsid			5110
+#define SYS_setreuid			5111
+#define SYS_setregid			5112
+#define SYS_getgroups			5113
+#define SYS_setgroups			5114
+#define SYS_setresuid			5115
+#define SYS_getresuid			5116
+#define SYS_setresgid			5117
+#define SYS_getresgid			5118
+#define SYS_getpgid			5119
+#define SYS_setfsuid			5120
+#define SYS_setfsgid			5121
+#define SYS_getsid			5122
+#define SYS_capget			5123
+#define SYS_capset			5124
+#define SYS_rt_sigpending		5125
+#define SYS_rt_sigtimedwait		5126
+#define SYS_rt_sigqueueinfo		5127
+#define SYS_rt_sigsuspend		5128
+#define SYS_sigaltstack			5129
+#define SYS_utime			5130
+#define SYS_mknod			5131
+#define SYS_personality			5132
+#define SYS_ustat			5133
+#define SYS_statfs			5134
+#define SYS_fstatfs			5135
+#define SYS_sysfs			5136
+#define SYS_getpriority			5137
+#define SYS_setpriority			5138
+#define SYS_sched_setparam		5139
+#define SYS_sched_getparam		5140
+#define SYS_sched_setscheduler		5141
+#define SYS_sched_getscheduler		5142
+#define SYS_sched_get_priority_max	5143
+#define SYS_sched_get_priority_min	5144
+#define SYS_sched_rr_get_interval	5145
+#define SYS_mlock			5146
+#define SYS_munlock			5147
+#define SYS_mlockall			5148
+#define SYS_munlockall			5149
+#define SYS_vhangup			5150
+#define SYS_pivot_root			5151
+#define SYS__sysctl			5152
+#define SYS_prctl			5153
+#define SYS_adjtimex			5154
+#define SYS_setrlimit			5155
+#define SYS_chroot			5156
+#define SYS_sync			5157
+#define SYS_acct			5158
+#define SYS_settimeofday		5159
+#define SYS_mount			5160
+#define SYS_umount2			5161
+#define SYS_swapon			5162
+#define SYS_swapoff			5163
+#define SYS_reboot			5164
+#define SYS_sethostname			5165
+#define SYS_setdomainname		5166
+#define SYS_create_module		5167
+#define SYS_init_module			5168
+#define SYS_delete_module		5169
+#define SYS_get_kernel_syms		5170
+#define SYS_query_module		5171
+#define SYS_quotactl			5172
+#define SYS_nfsservctl			5173
+#define SYS_getpmsg			5174
+#define SYS_putpmsg			5175
+#define SYS_afs_syscall			5176
+#define SYS_reserved177			5177
+#define SYS_gettid			5178
+#define SYS_readahead			5179
+#define SYS_setxattr			5180
+#define SYS_lsetxattr			5181
+#define SYS_fsetxattr			5182
+#define SYS_getxattr			5183
+#define SYS_lgetxattr			5184
+#define SYS_fgetxattr			5185
+#define SYS_listxattr			5186
+#define SYS_llistxattr			5187
+#define SYS_flistxattr			5188
+#define SYS_removexattr			5189
+#define SYS_lremovexattr		5190
+#define SYS_fremovexattr		5191
+#define SYS_tkill			5192
+#define SYS_reserved193			5193
+#define SYS_futex			5194
+#define SYS_sched_setaffinity		5195
+#define SYS_sched_getaffinity		5196
+#define SYS_cacheflush			5197
+#define SYS_cachectl			5198
+#define SYS_sysmips			5199
+#define SYS_io_setup			5200
+#define SYS_io_destroy			5201
+#define SYS_io_getevents		5202
+#define SYS_io_submit			5203
+#define SYS_io_cancel			5204
+#define SYS_exit_group			5205
+#define SYS_lookup_dcookie		5206
+#define SYS_epoll_create		5207
+#define SYS_epoll_ctl			5208
+#define SYS_epoll_wait			5209
+#define SYS_remap_file_pages		5210
+#define SYS_rt_sigreturn		5211
+#define SYS_set_tid_address		5212
+#define SYS_restart_syscall		5213
+#define SYS_semtimedop			5214
+#define SYS_fadvise64			5215
+#define SYS_timer_create		5216
+#define SYS_timer_settime		5217
+#define SYS_timer_gettime		5218
+#define SYS_timer_getoverrun		5219
+#define SYS_timer_delete		5220
+#define SYS_clock_settime		5221
+#define SYS_clock_gettime		5222
+#define SYS_clock_getres		5223
+#define SYS_clock_nanosleep		5224
+#define SYS_tgkill			5225
+#define SYS_utimes			5226
+#define SYS_mbind			5227
+#define SYS_get_mempolicy		5228
+#define SYS_set_mempolicy		5229
+#define SYS_mq_open			5230
+#define SYS_mq_unlink			5231
+#define SYS_mq_timedsend		5232
+#define SYS_mq_timedreceive		5233
+#define SYS_mq_notify			5234
+#define SYS_mq_getsetattr		5235
+#define SYS_vserver			5236
+#define SYS_waitid			5237
+#define SYS_add_key			5239
+#define SYS_request_key			5240
+#define SYS_keyctl			5241
+#define SYS_set_thread_area		5242
+#define SYS_inotify_init		5243
+#define SYS_inotify_add_watch		5244
+#define SYS_inotify_rm_watch		5245
+#define SYS_migrate_pages		5246
+#define SYS_openat			5247
+#define SYS_mkdirat			5248
+#define SYS_mknodat			5249
+#define SYS_fchownat			5250
+#define SYS_futimesat			5251
+#define SYS_newfstatat			5252
+#define SYS_unlinkat			5253
+#define SYS_renameat			5254
+#define SYS_linkat			5255
+#define SYS_symlinkat			5256
+#define SYS_readlinkat			5257
+#define SYS_fchmodat			5258
+#define SYS_faccessat			5259
+#define SYS_pselect6			5260
+#define SYS_ppoll			5261
+#define SYS_unshare			5262
+#define SYS_splice			5263
+#define SYS_sync_file_range		5264
+#define SYS_tee				5265
+#define SYS_vmsplice			5266
+#define SYS_move_pages			5267
+#define SYS_set_robust_list		5268
+#define SYS_get_robust_list		5269
+#define SYS_kexec_load			5270
+#define SYS_getcpu			5271
+#define SYS_epoll_pwait			5272
+#define SYS_ioprio_set			5273
+#define SYS_ioprio_get			5274
+#define SYS_utimensat			5275
+#define SYS_signalfd			5276
+#define SYS_timerfd			5277
+#define SYS_eventfd			5278
+#define SYS_fallocate			5279
+#define SYS_timerfd_create		5280
+#define SYS_timerfd_gettime		5281
+#define SYS_timerfd_settime		5282
+#define SYS_signalfd4			5283
+#define SYS_eventfd2			5284
+#define SYS_epoll_create1		5285
+#define SYS_dup3			5286
+#define SYS_pipe2			5287
+#define SYS_inotify_init1		5288
+#define SYS_preadv			5289
+#define SYS_pwritev			5290
+#define SYS_rt_tgsigqueueinfo		5291
+#define SYS_perf_event_open		5292
+#define SYS_accept4			5293
+#define SYS_recvmmsg			5294
+#define SYS_fanotify_init		5295
+#define SYS_fanotify_mark		5296
+#define SYS_prlimit64			5297
+#define SYS_name_to_handle_at		5298
+#define SYS_open_by_handle_at		5299
+#define SYS_clock_adjtime		5300
+#define SYS_syncfs			5301
+#define SYS_sendmmsg			5302
+#define SYS_setns			5303
+#define SYS_process_vm_readv		5304
+#define SYS_process_vm_writev		5305
+#define SYS_kcmp			5306
+#define SYS_finit_module		5307
+#define SYS_getdents64			5308
+#define SYS_sched_setattr		5309
+#define SYS_sched_getattr		5310
+#define SYS_renameat2			5311
+#define SYS_seccomp			5312
+#define SYS_getrandom			5313
+#define SYS_memfd_create		5314
+#define SYS_bpf				5315
+#define SYS_execveat			5316
--- /dev/null
+++ b/arch/mips64/bits/termios.h
@@ -0,0 +1,166 @@
+struct termios {
+	tcflag_t c_iflag;
+	tcflag_t c_oflag;
+	tcflag_t c_cflag;
+	tcflag_t c_lflag;
+	cc_t c_line;
+	cc_t c_cc[NCCS];
+};
+
+#define VINTR     0
+#define VQUIT     1
+#define VERASE    2
+#define VKILL     3
+#define VMIN      4
+#define VTIME     5
+#define VEOL2     6
+#define VSWTC     7
+#define VSWTCH    7
+#define VSTART    8
+#define VSTOP     9
+#define VSUSP    10
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE  14
+#define VLNEXT   15
+#define VEOF     16
+#define VEOL     17
+
+#define IGNBRK  0000001
+#define BRKINT  0000002
+#define IGNPAR  0000004
+#define PARMRK  0000010
+#define INPCK   0000020
+#define ISTRIP  0000040
+#define INLCR   0000100
+#define IGNCR   0000200
+#define ICRNL   0000400
+#define IUCLC   0001000
+#define IXON    0002000
+#define IXANY   0004000
+#define IXOFF   0010000
+#define IMAXBEL 0020000
+#define IUTF8   0040000
+
+#define OPOST  0000001
+#define OLCUC  0000002
+#define ONLCR  0000004
+#define OCRNL  0000010
+#define ONOCR  0000020
+#define ONLRET 0000040
+#define OFILL  0000100
+#define OFDEL  0000200
+#define NLDLY  0000400
+#define NL0    0000000
+#define NL1    0000400
+#define CRDLY  0003000
+#define CR0    0000000
+#define CR1    0001000
+#define CR2    0002000
+#define CR3    0003000
+#define TABDLY 0014000
+#define TAB0   0000000
+#define TAB1   0004000
+#define TAB2   0010000
+#define TAB3   0014000
+#define BSDLY  0020000
+#define BS0    0000000
+#define BS1    0020000
+#define FFDLY  0100000
+#define FF0    0000000
+#define FF1    0100000
+
+#define VTDLY  0040000
+#define VT0    0000000
+#define VT1    0040000
+
+#define B0       0000000
+#define B50      0000001
+#define B75      0000002
+#define B110     0000003
+#define B134     0000004
+#define B150     0000005
+#define B200     0000006
+#define B300     0000007
+#define B600     0000010
+#define B1200    0000011
+#define B1800    0000012
+#define B2400    0000013
+#define B4800    0000014
+#define B9600    0000015
+#define B19200   0000016
+#define B38400   0000017
+#define EXTA     0000016
+#define EXTB     0000017
+
+#define BOTHER   0010000
+#define B57600   0010001
+#define B115200  0010002
+#define B230400  0010003
+#define B460800  0010004
+#define B500000  0010005
+#define B576000  0010006
+#define B921600  0010007
+#define B1000000 0010010
+#define B1152000 0010011
+#define B1500000 0010012
+#define B2000000 0010013
+#define B2500000 0010014
+#define B3000000 0010015
+#define B3500000 0010016
+#define B4000000 0010017
+
+#define CBAUD    0010017
+
+#define CSIZE  0000060
+#define CS5    0000000
+#define CS6    0000020
+#define CS7    0000040
+#define CS8    0000060
+#define CSTOPB 0000100
+#define CREAD  0000200
+#define PARENB 0000400
+#define PARODD 0001000
+#define HUPCL  0002000
+#define CLOCAL 0004000
+
+#define ISIG   0000001
+#define ICANON 0000002
+#define XCASE  0000004
+#define ECHO   0000010
+#define ECHOE  0000020
+#define ECHOK  0000040
+#define ECHONL 0000100
+#define NOFLSH 0000200
+#define IEXTEN 0000400
+#define ECHOCTL 0001000
+#define ECHOPRT 0002000
+#define ECHOKE 0004000
+#define FLUSHO 0020000
+#define PENDIN 0040000
+#define TOSTOP 0100000
+#define ITOSTOP 0100000
+
+#define TCOOFF 0
+#define TCOON  1
+#define TCIOFF 2
+#define TCION  3
+
+#define TCIFLUSH  0
+#define TCOFLUSH  1
+#define TCIOFLUSH 2
+
+#define TCSANOW   0
+#define TCSADRAIN 1
+#define TCSAFLUSH 2
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define CBAUDEX 0010000
+#define CIBAUD   002003600000
+#define IBSHIFT 16
+#define CMSPAR   010000000000
+#define CRTSCTS  020000000000
+#define EXTPROC 0200000
+#define XTABS  0014000
+#define TIOCSER_TEMT 1
+#endif
--- /dev/null
+++ b/arch/mips64/bits/user.h
@@ -0,0 +1,15 @@
+struct user {
+	unsigned long regs[102];
+	unsigned long u_tsize, u_dsize, u_ssize;
+	unsigned long long start_code, start_data, start_stack;
+	long long signal;
+	unsigned long long *u_ar0;
+	unsigned long long magic;
+	char u_comm[32];
+};
+
+#define ELF_NGREG 45
+#define ELF_NFPREG 33
+
+typedef unsigned long elf_greg_t, elf_gregset_t[ELF_NGREG];
+typedef double elf_fpreg_t, elf_fpregset_t[ELF_NFPREG];
--- /dev/null
+++ b/arch/mips64/crt_arch.h
@@ -0,0 +1,33 @@
+__asm__(
+".set push\n"
+".set noreorder\n"
+".text \n"
+".global _" START "\n"
+".global " START "\n"
+".global " START "_data\n"
+".type   _" START ", @function\n"
+".type   " START ", @function\n"
+".type   " START "_data, @function\n"
+"_" START ":\n"
+"" START ":\n"
+".align 8 \n"
+"	bal 1f \n"
+"	 move $fp, $0 \n"
+"" START "_data: \n"
+"	.gpdword " START "_data \n"
+"	.gpdword " START "_c \n"
+".weak _DYNAMIC \n"
+".hidden _DYNAMIC \n"
+"	.gpdword _DYNAMIC \n"
+"1:	ld $gp, 0($ra) \n"
+"	dsubu $gp, $ra, $gp \n"
+"	move $4, $sp \n"
+"	ld $5, 16($ra) \n"
+"	daddu $5, $5, $gp \n"
+"	ld $25, 8($ra) \n"
+"	daddu $25, $25, $gp \n"
+"	and $sp, $sp, -16 \n"
+"	jalr $25 \n"
+"	nop \n"
+".set pop \n"
+);
--- /dev/null
+++ b/arch/mips64/ksigaction.h
@@ -0,0 +1,8 @@
+struct k_sigaction {
+	unsigned flags;
+	void (*handler)(int);
+	unsigned long mask[2];
+	void (*restorer)();
+};
+
+void __restore(), __restore_rt();
--- /dev/null
+++ b/arch/mips64/pthread_arch.h
@@ -0,0 +1,18 @@
+static inline struct pthread *__pthread_self()
+{
+#ifdef __clang__
+	char *tp;
+	__asm__ __volatile__ (".word 0x7c03e83b ; move %0, $3" : "=r" (tp) : : "$3" );
+#else
+	register char *tp __asm__("$3");
+	__asm__ __volatile__ (".word 0x7c03e83b" : "=r" (tp) );
+#endif
+	return (pthread_t)(tp - 0x7000 - sizeof(struct pthread));
+}
+
+#define TLS_ABOVE_TP
+#define TP_ADJ(p) ((char *)(p) + sizeof(struct pthread) + 0x7000)
+
+#define DTP_OFFSET 0x8000
+
+#define MC_PC pc
--- /dev/null
+++ b/arch/mips64/reloc.h
@@ -0,0 +1,60 @@
+#ifndef __RELOC_H__
+#define __RELOC_H__
+
+#define _GNU_SOURCE
+#include <endian.h>
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define ENDIAN_SUFFIX "el"
+#else
+#define ENDIAN_SUFFIX ""
+#endif
+
+#ifdef __mips_soft_float
+#define FP_SUFFIX "-sf"
+#else
+#define FP_SUFFIX ""
+#endif
+
+#define LDSO_ARCH "mips64" ENDIAN_SUFFIX FP_SUFFIX
+
+#define TPOFF_K (-0x7000)
+
+#define REL_SYM_OR_REL  4611
+#define REL_PLT         R_MIPS_JUMP_SLOT
+#define REL_COPY        R_MIPS_COPY
+#define REL_DTPMOD      R_MIPS_TLS_DTPMOD64
+#define REL_DTPOFF      R_MIPS_TLS_DTPREL64
+#define REL_TPOFF       R_MIPS_TLS_TPREL64
+
+#undef R_TYPE
+#undef R_SYM
+#undef R_INFO
+#define R_TYPE(x) (be64toh(x)&0x7fffffff)
+#define R_SYM(x) (be32toh(be64toh(x)>>32))
+#define R_INFO(s,t) (htobe64((uint64_t)htobe32(s)<<32 | (uint64_t)t))
+
+#define NEED_MIPS_GOT_RELOCS 1
+#define DT_DEBUG_INDIRECT DT_MIPS_RLD_MAP
+#define ARCH_SYM_REJECT_UND(s) (!((s)->st_other & STO_MIPS_PLT))
+
+#define CRTJMP(pc,sp) __asm__ __volatile__( \
+	"move $sp,%1 ; jr %0" : : "r"(pc), "r"(sp) : "memory" )
+
+#define GETFUNCSYM(fp, sym, got) __asm__ ( \
+	".hidden " #sym "\n" \
+	".set push \n" \
+	".set noreorder \n" \
+	".align 8 \n" \
+	"	bal 1f \n" \
+	"	 nop \n" \
+	"	.gpdword . \n" \
+	"	.gpdword " #sym " \n" \
+	"1:	ld %0, ($ra) \n" \
+	"	dsubu %0, $ra, %0 \n" \
+	"	ld $ra, 8($ra) \n" \
+	"	daddu %0, %0, $ra \n" \
+	".set pop \n" \
+	: "=r"(*(fp)) : : "memory", "ra" )
+
+#endif
--- /dev/null
+++ b/arch/mips64/syscall_arch.h
@@ -0,0 +1,281 @@
+#define __SYSCALL_LL_E(x) (x)
+#define __SYSCALL_LL_O(x) (x)
+
+__attribute__((visibility("hidden")))
+long (__syscall)(long, ...);
+
+#define SYSCALL_RLIM_INFINITY (-1UL/2)
+
+#include <sys/stat.h>
+struct kernel_stat {
+	unsigned int st_dev;
+	unsigned int __pad1[3];
+	unsigned long long st_ino;
+	unsigned int st_mode;
+	unsigned int st_nlink;
+	int st_uid;
+	int st_gid;
+	unsigned int st_rdev;
+	unsigned int __pad2[3];
+	long long st_size;
+	unsigned int st_atime_sec;
+	unsigned int st_atime_nsec;
+	unsigned int st_mtime_sec;
+	unsigned int st_mtime_nsec;
+	unsigned int st_ctime_sec;
+	unsigned int st_ctime_nsec;
+	unsigned int st_blksize;
+	unsigned int __pad3;
+	unsigned long long st_blocks;
+};
+
+static void __stat_fix(struct kernel_stat *kst, struct stat *st)
+{
+	st->st_dev = kst->st_dev;
+	st->st_ino = kst->st_ino;
+	st->st_mode = kst->st_mode;
+	st->st_nlink = kst->st_nlink;
+	st->st_uid = kst->st_uid;
+	st->st_gid = kst->st_gid;
+	st->st_rdev = kst->st_rdev;
+	st->st_size = kst->st_size;
+	st->st_atim.tv_sec = kst->st_atime_sec;
+	st->st_atim.tv_nsec = kst->st_atime_nsec;
+	st->st_mtim.tv_sec = kst->st_mtime_sec;
+	st->st_mtim.tv_nsec = kst->st_mtime_nsec;
+	st->st_ctim.tv_sec = kst->st_ctime_sec;
+	st->st_ctim.tv_nsec = kst->st_ctime_nsec;
+	st->st_blksize = kst->st_blksize;
+	st->st_blocks = kst->st_blocks;
+}
+
+#ifndef __clang__
+
+static inline long __syscall0(long n)
+{
+	register long r7 __asm__("$7");
+	register long r2 __asm__("$2");
+	__asm__ __volatile__ (
+		"daddu $2,$0,%2 ; syscall"
+		: "=&r"(r2), "=r"(r7) : "ir"(n), "0"(r2), "1"(r7)
+		: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",
+		  "$14", "$15", "$24", "$25", "hi", "lo", "memory");
+	return r7 ? -r2 : r2;
+}
+
+static inline long __syscall1(long n, long a)
+{
+	register long r4 __asm__("$4") = a;
+	register long r7 __asm__("$7");
+	register long r2 __asm__("$2");
+	__asm__ __volatile__ (
+		"daddu $2,$0,%2 ; syscall"
+		: "=&r"(r2), "=r"(r7) : "ir"(n), "0"(r2), "1"(r7),
+		  "r"(r4)
+		: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",
+		  "$14", "$15", "$24", "$25", "hi", "lo", "memory");
+	return r7 ? -r2 : r2;
+}
+
+static inline long __syscall2(long n, long a, long b)
+{
+	struct kernel_stat kst;
+	long ret;
+	register long r4 __asm__("$4");
+	register long r5 __asm__("$5");
+	register long r7 __asm__("$7");
+	register long r2 __asm__("$2");
+
+	r5 = b;
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		r5 = (long) &kst;
+
+	r4 = a;
+	__asm__ __volatile__ (
+		"daddu $2,$0,%2 ; syscall"
+		: "=&r"(r2), "=r"(r7) : "ir"(n), "0"(r2), "1"(r7),
+		  "r"(r4), "r"(r5)
+		: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",
+		  "$14", "$15", "$24", "$25", "hi", "lo", "memory");
+
+	if (r7) return -r2;
+	ret = r2;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		__stat_fix(&kst, (struct stat *)b);
+
+	return ret;
+}
+
+static inline long __syscall3(long n, long a, long b, long c)
+{
+	struct kernel_stat kst;
+	long ret;
+	register long r4 __asm__("$4");
+	register long r5 __asm__("$5");
+	register long r6 __asm__("$6");
+	register long r7 __asm__("$7");
+	register long r2 __asm__("$2");
+
+	r5 = b;
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		r5 = (long) &kst;
+
+	r4 = a;
+	r6 = c;
+	__asm__ __volatile__ (
+		"daddu $2,$0,%2 ; syscall"
+		: "=&r"(r2), "=r"(r7) : "ir"(n), "0"(r2), "1"(r7),
+		  "r"(r4), "r"(r5), "r"(r6)
+		: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",
+		  "$14", "$15", "$24", "$25", "hi", "lo", "memory");
+
+	if (r7) return -r2;
+	ret = r2;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		__stat_fix(&kst, (struct stat *)b);
+
+	return ret;
+}
+
+static inline long __syscall4(long n, long a, long b, long c, long d)
+{
+	struct kernel_stat kst;
+	long ret;
+	register long r4 __asm__("$4");
+	register long r5 __asm__("$5");
+	register long r6 __asm__("$6");
+	register long r7 __asm__("$7");
+	register long r2 __asm__("$2");
+
+	r5 = b;
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		r5 = (long) &kst;
+
+	r4 = a;
+	r6 = c;
+	r7 = d;
+	__asm__ __volatile__ (
+		"daddu $2,$0,%2 ; syscall"
+		: "=&r"(r2), "=r"(r7) : "ir"(n), "0"(r2), "1"(r7),
+		  "r"(r4), "r"(r5), "r"(r6)
+		: "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13",
+		  "$14", "$15", "$24", "$25", "hi", "lo", "memory");
+
+	if (r7) return -r2;
+	ret = r2;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		__stat_fix(&kst, (struct stat *)b);
+
+	return ret;
+}
+
+#else
+
+static inline long __syscall0(long n)
+{
+	return (__syscall)(n);
+}
+
+static inline long __syscall1(long n, long a)
+{
+	return (__syscall)(n, a);
+}
+
+static inline long __syscall2(long n, long a, long b)
+{
+	long r2;
+	long old_b = b;
+	struct kernel_stat kst;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		b = (long) &kst;
+
+	r2 = (__syscall)(n, a, b);
+	if (r2 > -4096UL) return r2;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		__stat_fix(&kst, (struct stat *)old_b);
+
+	return r2;
+}
+
+static inline long __syscall3(long n, long a, long b, long c)
+{
+	long r2;
+	long old_b = b;
+	struct kernel_stat kst;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		b = (long) &kst;
+
+	r2 = (__syscall)(n, a, b, c);
+	if (r2 > -4096UL) return r2;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		__stat_fix(&kst, (struct stat *)old_b);
+
+	return r2;
+}
+
+static inline long __syscall4(long n, long a, long b, long c, long d)
+{
+	long r2;
+	long old_b = b;
+	struct kernel_stat kst;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		b = (long) &kst;
+
+	r2 = (__syscall)(n, a, b, c, d);
+	if (r2 > -4096UL) return r2;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		__stat_fix(&kst, (struct stat *)old_b);
+
+	return r2;
+}
+
+#endif
+
+static inline long __syscall5(long n, long a, long b, long c, long d, long e)
+{
+	long r2;
+	long old_b = b;
+	struct kernel_stat kst;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		b = (long) &kst;
+
+	r2 = (__syscall)(n, a, b, c, d, e);
+	if (r2 > -4096UL) return r2;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		__stat_fix(&kst, (struct stat *)old_b);
+
+	return r2;
+}
+
+static inline long __syscall6(long n, long a, long b, long c, long d, long e, long f)
+{
+	long r2;
+	long old_b = b;
+	struct kernel_stat kst;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		b = (long) &kst;
+
+	r2 = (__syscall)(n, a, b, c, d, e, f);
+	if (r2 > -4096UL) return r2;
+
+	if (n == SYS_stat || n == SYS_fstat || n == SYS_lstat)
+		__stat_fix(&kst, (struct stat *)old_b);
+
+	return r2;
+}
+
+#define VDSO_USEFUL
+#define VDSO_CGT_SYM "__vdso_clock_gettime"
+#define VDSO_CGT_VER "LINUX_2.6"
--- a/arch/powerpc/bits/fenv.h
+++ b/arch/powerpc/bits/fenv.h
@@ -1,3 +1,7 @@
+#ifdef _SOFT_FLOAT
+#define FE_ALL_EXCEPT 0
+#define FE_TONEAREST  0
+#else
 #define FE_TONEAREST	0
 #define FE_TOWARDZERO	1
 #define FE_UPWARD	2
@@ -24,6 +28,7 @@
 
 #define FE_ALL_INVALID		0x01f80700
 #endif
+#endif
 
 typedef unsigned fexcept_t;
 typedef double fenv_t;
--- a/arch/powerpc/reloc.h
+++ b/arch/powerpc/reloc.h
@@ -1,4 +1,10 @@
-#define LDSO_ARCH "powerpc"
+#ifdef _SOFT_FLOAT
+#define FP_SUFFIX "-sf"
+#else
+#define FP_SUFFIX ""
+#endif
+
+#define LDSO_ARCH "powerpc" FP_SUFFIX
 
 #define TPOFF_K (-0x7000)
 
--- a/arch/x86_64/syscall_arch.h
+++ b/arch/x86_64/syscall_arch.h
@@ -64,3 +64,5 @@ static __inline long __syscall6(long n,
 #define VDSO_USEFUL
 #define VDSO_CGT_SYM "__vdso_clock_gettime"
 #define VDSO_CGT_VER "LINUX_2.6"
+#define VDSO_GETCPU_SYM "__vdso_getcpu"
+#define VDSO_GETCPU_VER "LINUX_2.6"
--- a/configure
+++ b/configure
@@ -299,7 +299,7 @@ printf "%s\n" "$target"
 #
 case "$target" in
 # Catch these early to simplify matching for 32-bit archs
-mips64*|powerpc64*) fail "$0: unsupported target \"$target\"" ;;
+powerpc64*) fail "$0: unsupported target \"$target\"" ;;
 arm*) ARCH=arm ;;
 aarch64*) ARCH=aarch64 ;;
 i?86-nt32*) ARCH=nt32 ;;
@@ -307,6 +307,7 @@ i?86*) ARCH=i386 ;;
 x86_64-x32*|x32*|x86_64*x32) ARCH=x32 ;;
 x86_64-nt64*) ARCH=nt64 ;;
 x86_64*) ARCH=x86_64 ;;
+mips64*) ARCH=mips64 ;;
 mips*) ARCH=mips ;;
 microblaze*) ARCH=microblaze ;;
 or1k*) ARCH=or1k ;;
@@ -615,6 +616,17 @@ trycppif "_MIPSEL || __MIPSEL || __MIPSE
 trycppif __mips_soft_float "$t" && SUBARCH=${SUBARCH}-sf
 fi
 
+if test "$ARCH" = "mips64" ; then
+trycppif "_MIPSEL || __MIPSEL || __MIPSEL__" "$t" && SUBARCH=${SUBARCH}el
+trycppif __mips_soft_float "$t" && SUBARCH=${SUBARCH}-sf
+fi
+
+if test "$ARCH" = "powerpc" ; then
+trycppif "__NO_FPRS__ && !_SOFT_FLOAT" "$t" && fail \
+  "$0: error: compiler's floating point configuration is unsupported"
+trycppif _SOFT_FLOAT "$t" && SUBARCH=${SUBARCH}-sf
+fi
+
 test "$ARCH" = "microblaze" && trycppif __MICROBLAZEEL__ "$t" \
 && SUBARCH=${SUBARCH}el
 
--- /dev/null
+++ b/crt/mips64/crti.s
@@ -0,0 +1,17 @@
+.set noreorder
+
+.section .init
+.global _init
+.align 3
+_init:
+	dsubu	$sp, $sp, 32
+	sd	$gp, 16($sp)
+	sd	$ra, 24($sp)
+
+.section .fini
+.global _fini
+.align 3
+_fini:
+	dsubu	$sp, $sp, 32
+	sd	$gp, 16($sp)
+	sd	$ra, 24($sp)
--- /dev/null
+++ b/crt/mips64/crtn.s
@@ -0,0 +1,13 @@
+.set noreorder
+
+.section .init
+	ld $gp,16($sp)
+	ld $ra,24($sp)
+	j $ra
+	daddu $sp,$sp,32
+
+.section .fini
+	ld $gp,16($sp)
+	ld $ra,24($sp)
+	j $ra
+	daddu $sp,$sp,32
--- a/include/sched.h
+++ b/include/sched.h
@@ -76,6 +76,7 @@ void free(void *);
 
 typedef struct cpu_set_t { unsigned long __bits[128/sizeof(long)]; } cpu_set_t;
 int __sched_cpucount(size_t, const cpu_set_t *);
+int sched_getcpu(void);
 int sched_getaffinity(pid_t, size_t, cpu_set_t *);
 int sched_setaffinity(pid_t, size_t, const cpu_set_t *);
 
--- a/ldso/dynlink.c
+++ b/ldso/dynlink.c
@@ -1134,7 +1134,7 @@ static void do_mips_relocs(struct dso *p
 	Sym *sym = p->syms + j;
 	rel[0] = (unsigned char *)got - base;
 	for (i-=j; i; i--, sym++, rel[0]+=sizeof(size_t)) {
-		rel[1] = sym-p->syms << 8 | R_MIPS_JUMP_SLOT;
+		rel[1] = R_INFO(sym-p->syms, R_MIPS_JUMP_SLOT);
 		do_relocs(p, rel, sizeof rel, 2);
 	}
 }
--- a/src/env/putenv.c
+++ b/src/env/putenv.c
@@ -30,6 +30,7 @@ int __putenv(char *s, int a)
 				}
 			} else {
 				free(__env_map[j]);
+				__env_map[j] = s;
 			}
 		}
 	}
--- /dev/null
+++ b/src/fenv/mips64/fenv-sf.c
@@ -0,0 +1,3 @@
+#ifdef __mips_soft_float
+#include "../fenv.c"
+#endif
--- /dev/null
+++ b/src/fenv/mips64/fenv.S
@@ -0,0 +1,71 @@
+#ifndef __mips_soft_float
+
+.set	noreorder
+
+.global	feclearexcept
+.type	feclearexcept,@function
+feclearexcept:
+	and	$4, $4, 0x7c
+	cfc1	$5, $31
+	or	$5, $5, $4
+	xor	$5, $5, $4
+	ctc1	$5, $31
+	jr	$ra
+	li	$2, 0
+
+.global	feraiseexcept
+.type	feraiseexcept,@function
+feraiseexcept:
+	and	$4, $4, 0x7c
+	cfc1	$5, $31
+	or	$5, $5, $4
+	ctc1	$5, $31
+	jr	$ra
+	li	$2, 0
+
+.global	fetestexcept
+.type	fetestexcept,@function
+fetestexcept:
+	and	$4, $4, 0x7c
+	cfc1	$2, $31
+	jr	$ra
+	and	$2, $2, $4
+
+.global	fegetround
+.type	fegetround,@function
+fegetround:
+	cfc1	$2, $31
+	jr	$ra
+	andi	$2, $2, 3
+
+.global	__fesetround
+.type	__fesetround,@function
+__fesetround:
+	cfc1	$5, $31
+	li	$6, -4
+	and	$5, $5, $6
+	or	$5, $5, $4
+	ctc1	$5, $31
+	jr	$ra
+	li	$2, 0
+
+.global	fegetenv
+.type	fegetenv,@function
+fegetenv:
+	cfc1	$5, $31
+	sw	$5, 0($4)
+	jr	$ra
+	li	$2, 0
+
+.global	fesetenv
+.type	fesetenv,@function
+fesetenv:
+	daddiu	$5, $4, 1
+	beq	$5, $0, 1f
+	nop
+	lw	$5, 0($4)
+1:	ctc1	$5, $31
+	jr	$ra
+	li	$2, 0
+
+#endif
--- /dev/null
+++ b/src/fenv/powerpc/fenv-sf.c
@@ -0,0 +1,3 @@
+#ifdef _SOFT_FLOAT
+#include "../fenv.c"
+#endif
--- /dev/null
+++ b/src/fenv/powerpc/fenv.S
@@ -0,0 +1,129 @@
+#ifndef _SOFT_FLOAT
+.global feclearexcept
+.type feclearexcept,@function
+feclearexcept:
+	andis. 3,3,0x3e00
+	/* if (r3 & FE_INVALID) r3 |= all_invalid_flags */
+	andis. 0,3,0x2000
+	stwu 1,-16(1)
+	beq- 0,1f
+	oris 3,3,0x01f8
+	ori  3,3,0x0700
+1:
+	/*
+	 * note: fpscr contains various fpu status and control
+	 * flags and we dont check if r3 may alter other flags
+	 * than the exception related ones
+	 * ufpscr &= ~r3
+	 */
+	mffs 0
+	stfd 0,8(1)
+	lwz 9,12(1)
+	andc 9,9,3
+	stw 9,12(1)
+	lfd 0,8(1)
+	mtfsf 255,0
+
+	/* return 0 */
+	li 3,0
+	addi 1,1,16
+	blr
+
+.global feraiseexcept
+.type feraiseexcept,@function
+feraiseexcept:
+	andis. 3,3,0x3e00
+	/* if (r3 & FE_INVALID) r3 |= software_invalid_flag */
+	andis. 0,3,0x2000
+	stwu 1,-16(1)
+	beq- 0,1f
+	ori 3,3,0x0400
+1:
+	/* fpscr |= r3 */
+	mffs 0
+	stfd 0,8(1)
+	lwz 9,12(1)
+	or 9,9,3
+	stw 9,12(1)
+	lfd 0,8(1)
+	mtfsf 255,0
+
+	/* return 0 */
+	li 3,0
+	addi 1,1,16
+	blr
+
+.global fetestexcept
+.type fetestexcept,@function
+fetestexcept:
+	andis. 3,3,0x3e00
+	/* return r3 & fpscr */
+	stwu 1,-16(1)
+	mffs 0
+	stfd 0,8(1)
+	lwz 9,12(1)
+	addi 1,1,16
+	and 3,3,9
+	blr
+
+.global fegetround
+.type fegetround,@function
+fegetround:
+	/* return fpscr & 3 */
+	stwu 1,-16(1)
+	mffs 0
+	stfd 0,8(1)
+	lwz 3,12(1)
+	addi 1,1,16
+	clrlwi 3,3,30
+	blr
+
+.global __fesetround
+.type __fesetround,@function
+__fesetround:
+	/*
+	 * note: invalid input is not checked, r3 < 4 must hold
+	 * fpscr = (fpscr & -4U) | r3
+	 */
+	stwu 1,-16(1)
+	mffs 0
+	stfd 0,8(1)
+	lwz 9,12(1)
+	clrrwi 9,9,2
+	or 9,9,3
+	stw 9,12(1)
+	lfd 0,8(1)
+	mtfsf 255,0
+
+	/* return 0 */
+	li 3,0
+	addi 1,1,16
+	blr
+
+.global fegetenv
+.type fegetenv,@function
+fegetenv:
+	/* *r3 = fpscr */
+	mffs 0
+	stfd 0,0(3)
+	/* return 0 */
+	li 3,0
+	blr
+
+.global fesetenv
+.type fesetenv,@function
+fesetenv:
+	cmpwi 3, -1
+	bne 1f
+	mflr 4
+	bl 2f
+	.zero 8
+2:	mflr 3
+	mtlr 4
+1:	/* fpscr = *r3 */
+	lfd 0,0(3)
+	mtfsf 255,0
+	/* return 0 */
+	li 3,0
+	blr
+#endif
--- a/src/fenv/powerpc/fenv.s
+++ /dev/null
@@ -1,123 +0,0 @@
-.global feclearexcept
-.type feclearexcept,@function
-feclearexcept:
-	andis. 3,3,0x3e00
-	# if (r3 & FE_INVALID) r3 |= all_invalid_flags
-	andis. 0,3,0x2000
-	stwu 1,-16(1)
-	beq- 0,1f
-	oris 3,3,0x01f8
-	ori  3,3,0x0700
-1:
-	# note: fpscr contains various fpu status and control
-	# flags and we dont check if r3 may alter other flags
-	# than the exception related ones
-	# fpscr &= ~r3
-	mffs 0
-	stfd 0,8(1)
-	lwz 9,12(1)
-	andc 9,9,3
-	stw 9,12(1)
-	lfd 0,8(1)
-	mtfsf 255,0
-
-	# return 0
-	li 3,0
-	addi 1,1,16
-	blr
-
-.global feraiseexcept
-.type feraiseexcept,@function
-feraiseexcept:
-	andis. 3,3,0x3e00
-	# if (r3 & FE_INVALID) r3 |= software_invalid_flag
-	andis. 0,3,0x2000
-	stwu 1,-16(1)
-	beq- 0,1f
-	ori 3,3,0x0400
-1:
-	# fpscr |= r3
-	mffs 0
-	stfd 0,8(1)
-	lwz 9,12(1)
-	or 9,9,3
-	stw 9,12(1)
-	lfd 0,8(1)
-	mtfsf 255,0
-
-	# return 0
-	li 3,0
-	addi 1,1,16
-	blr
-
-.global fetestexcept
-.type fetestexcept,@function
-fetestexcept:
-	andis. 3,3,0x3e00
-	# return r3 & fpscr
-	stwu 1,-16(1)
-	mffs 0
-	stfd 0,8(1)
-	lwz 9,12(1)
-	addi 1,1,16
-	and 3,3,9
-	blr
-
-.global fegetround
-.type fegetround,@function
-fegetround:
-	# return fpscr & 3
-	stwu 1,-16(1)
-	mffs 0
-	stfd 0,8(1)
-	lwz 3,12(1)
-	addi 1,1,16
-	clrlwi 3,3,30
-	blr
-
-.global __fesetround
-.type __fesetround,@function
-__fesetround:
-	# note: invalid input is not checked, r3 < 4 must hold
-	# fpscr = (fpscr & -4U) | r3
-	stwu 1,-16(1)
-	mffs 0
-	stfd 0,8(1)
-	lwz 9,12(1)
-	clrrwi 9,9,2
-	or 9,9,3
-	stw 9,12(1)
-	lfd 0,8(1)
-	mtfsf 255,0
-
-	# return 0
-	li 3,0
-	addi 1,1,16
-	blr
-
-.global fegetenv
-.type fegetenv,@function
-fegetenv:
-	# *r3 = fpscr
-	mffs 0
-	stfd 0,0(3)
-	# return 0
-	li 3,0
-	blr
-
-.global fesetenv
-.type fesetenv,@function
-fesetenv:
-	cmpwi 3, -1
-	bne 1f
-	mflr 4
-	bl 2f
-	.zero 8
-2:	mflr 3
-	mtlr 4
-1:	# fpscr = *r3
-	lfd 0,0(3)
-	mtfsf 255,0
-	# return 0
-	li 3,0
-	blr
--- a/src/internal/atomic.h
+++ b/src/internal/atomic.h
@@ -82,6 +82,23 @@ static inline int a_fetch_or(volatile in
 
 #endif
 
+#ifdef a_ll_p
+
+#ifndef a_cas_p
+#define a_cas_p a_cas_p
+static inline void *a_cas_p(volatile void *p, void *t, void *s)
+{
+	void *old;
+	a_pre_llsc();
+	do old = a_ll_p(p);
+	while (old==t && !a_sc_p(p, s));
+	a_post_llsc();
+	return old;
+}
+#endif
+
+#endif
+
 #ifndef a_cas
 #error missing definition of a_cas
 #endif
@@ -209,6 +226,7 @@ static inline void a_or_64(volatile uint
 #endif
 
 #ifndef a_cas_p
+typedef char a_cas_p_undefined_but_pointer_not_32bit[-sizeof(char) == 0xffffffff ? 1 : -1];
 #define a_cas_p a_cas_p
 static inline void *a_cas_p(volatile void *p, void *t, void *s)
 {
--- a/src/internal/dynlink.h
+++ b/src/internal/dynlink.h
@@ -11,12 +11,14 @@ typedef Elf32_Phdr Phdr;
 typedef Elf32_Sym Sym;
 #define R_TYPE(x) ((x)&255)
 #define R_SYM(x) ((x)>>8)
+#define R_INFO ELF32_R_INFO
 #else
 typedef Elf64_Ehdr Ehdr;
 typedef Elf64_Phdr Phdr;
 typedef Elf64_Sym Sym;
 #define R_TYPE(x) ((x)&0x7fffffff)
 #define R_SYM(x) ((x)>>32)
+#define R_INFO ELF64_R_INFO
 #endif
 
 /* These enum constants provide unmatchable default values for
--- /dev/null
+++ b/src/internal/mips64/syscall.s
@@ -0,0 +1,19 @@
+.set	noreorder
+.global	__syscall
+.hidden	__syscall
+.type	__syscall,@function
+__syscall:
+	move	$2, $4
+	move	$4, $5
+	move	$5, $6
+	move	$6, $7
+	move	$7, $8
+	move	$8, $9
+	move	$9, $10
+	move	$10, $11
+	syscall
+	beq	$7, $0, 1f
+	nop
+	dsubu	$2, $0, $2
+1:	jr	$ra
+	nop
--- /dev/null
+++ b/src/ldso/mips64/dlsym.s
@@ -0,0 +1,17 @@
+.set	noreorder
+.global	dlsym
+.hidden	__dlsym
+.type	dlsym,@function
+dlsym:
+	lui	$3, %hi(%neg(%gp_rel(dlsym)))
+	daddiu	$3, $3, %lo(%neg(%gp_rel(dlsym)))
+	daddu	$3, $3, $25
+	move	$6, $ra
+	ld	$25, %got_disp(__dlsym)($3)
+	daddiu	$sp, $sp, -32
+	sd	$ra, 24($sp)
+	jalr	$25
+	nop
+	ld	$ra, 24($sp)
+	jr	$ra
+	daddiu	$sp, $sp, 32
--- a/src/math/exp2f.c
+++ b/src/math/exp2f.c
@@ -91,6 +91,8 @@ float exp2f(float x)
 	/* Filter out exceptional cases. */
 	ix = u.i & 0x7fffffff;
 	if (ix > 0x42fc0000) {  /* |x| > 126 */
+		if (ix > 0x7f800000) /* NaN */
+			return x;
 		if (u.i >= 0x43000000 && u.i < 0x80000000) {  /* x >= 128 */
 			x *= 0x1p127f;
 			return x;
--- a/src/math/expf.c
+++ b/src/math/expf.c
@@ -39,6 +39,8 @@ float expf(float x)
 
 	/* special cases */
 	if (hx >= 0x42aeac50) {  /* if |x| >= -87.33655f or NaN */
+		if (hx > 0x7f800000) /* NaN */
+			return x;
 		if (hx >= 0x42b17218 && !sign) {  /* x >= 88.722839f */
 			/* overflow */
 			x *= 0x1p127f;
--- a/src/multibyte/wctob.c
+++ b/src/multibyte/wctob.c
@@ -1,4 +1,5 @@
 #include <wchar.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include "internal.h"
 
--- a/src/network/lookup_name.c
+++ b/src/network/lookup_name.c
@@ -49,7 +49,7 @@ static int name_from_hosts(struct addres
 {
 	char line[512];
 	size_t l = strlen(name);
-	int cnt = 0;
+	int cnt = 0, badfam = 0;
 	unsigned char _buf[1032];
 	FILE _f, *f = __fopen_rb_ca("/etc/hosts", &_f, _buf, sizeof _buf);
 	if (!f) switch (errno) {
@@ -71,8 +71,16 @@ static int name_from_hosts(struct addres
 		/* Isolate IP address to parse */
 		for (p=line; *p && !isspace(*p); p++);
 		*p++ = 0;
-		if (name_from_numeric(buf+cnt, line, family))
+		switch (name_from_numeric(buf+cnt, line, family)) {
+		case 1:
 			cnt++;
+			break;
+		case 0:
+			continue;
+		default:
+			badfam = EAI_NONAME;
+			continue;
+		}
 
 		/* Extract first name as canonical name */
 		for (; *p && isspace(*p); p++);
@@ -81,7 +89,7 @@ static int name_from_hosts(struct addres
 		if (is_valid_hostname(p)) memcpy(canon, p, z-p+1);
 	}
 	__fclose_ca(f);
-	return cnt;
+	return cnt ? cnt : badfam;
 }
 
 struct dpc_ctx {
--- a/src/regex/regcomp.c
+++ b/src/regex/regcomp.c
@@ -889,7 +889,6 @@ static reg_errcode_t parse_atom(tre_pars
 		s++;
 		break;
 	case '*':
-		return REG_BADPAT;
 	case '{':
 	case '+':
 	case '?':
@@ -978,9 +977,6 @@ static reg_errcode_t tre_parse(tre_parse
 		}
 
 	parse_iter:
-		/* extension: repetitions are rejected after an empty node
-		   eg. (+), |*, {2}, but assertions are not treated as empty
-		   so ^* or $? are accepted currently. */
 		for (;;) {
 			int min, max;
 
@@ -998,6 +994,10 @@ static reg_errcode_t tre_parse(tre_parse
 			if (*s=='\\')
 				s++;
 
+			/* handle ^* at the start of a complete BRE. */
+			if (!ere && s==ctx->re+1 && s[-1]=='^')
+				break;
+
 			/* extension: multiple consecutive *+?{,} is unspecified,
 			   but (a+)+ has to be supported so accepting a++ makes
 			   sense, note however that the RE_DUP_MAX limit can be
--- /dev/null
+++ b/src/sched/sched_getcpu.c
@@ -0,0 +1,44 @@
+#define _GNU_SOURCE
+#include <errno.h>
+#include <sched.h>
+#include "syscall.h"
+#include "atomic.h"
+
+#ifdef VDSO_GETCPU_SYM
+
+void *__vdsosym(const char *, const char *);
+
+static void *volatile vdso_func;
+
+typedef long (*getcpu_f)(unsigned *, unsigned *, void *);
+
+static long getcpu_init(unsigned *cpu, unsigned *node, void *unused)
+{
+	void *p = __vdsosym(VDSO_GETCPU_VER, VDSO_GETCPU_SYM);
+	getcpu_f f = (getcpu_f)p;
+	a_cas_p(&vdso_func, (void *)getcpu_init, p);
+	return f ? f(cpu, node, unused) : -ENOSYS;
+}
+
+static void *volatile vdso_func = (void *)getcpu_init;
+
+#endif
+
+int sched_getcpu(void)
+{
+	int r;
+	unsigned cpu;
+
+#ifdef VDSO_GETCPU_SYM
+	getcpu_f f = (getcpu_f)vdso_func;
+	if (f) {
+		r = f(&cpu, 0, 0);
+		if (!r) return cpu;
+		if (r != -ENOSYS) return __syscall_ret(r);
+	}
+#endif
+
+	r = __syscall(SYS_getcpu, &cpu, 0, 0);
+	if (!r) return cpu;
+	return __syscall_ret(r);
+}
--- /dev/null
+++ b/src/setjmp/mips64/longjmp.S
@@ -0,0 +1,37 @@
+.set	noreorder
+.global	_longjmp
+.global	longjmp
+.type	_longjmp,@function
+.type	longjmp,@function
+_longjmp:
+longjmp:
+	move	$2, $5
+
+	bne	$2, $0, 1f
+	nop
+	daddu	$2, $2, 1
+1:
+#ifndef __mips_soft_float
+	ldc1	$24, 96($4)
+	ldc1	$25, 104($4)
+	ldc1	$26, 112($4)
+	ldc1	$27, 120($4)
+	ldc1	$28, 128($4)
+	ldc1	$29, 136($4)
+	ldc1	$30, 144($4)
+	ldc1	$31, 152($4)
+#endif
+	ld	$ra, 0($4)
+	ld	$sp, 8($4)
+	ld	$gp, 16($4)
+	ld	$16, 24($4)
+	ld	$17, 32($4)
+	ld	$18, 40($4)
+	ld	$19, 48($4)
+	ld	$20, 56($4)
+	ld	$21, 64($4)
+	ld	$22, 72($4)
+	ld	$23, 80($4)
+	ld	$30, 88($4)
+	jr	$ra
+	nop
--- /dev/null
+++ b/src/setjmp/mips64/setjmp.S
@@ -0,0 +1,34 @@
+.set	noreorder
+.global	__setjmp
+.global	_setjmp
+.global	setjmp
+.type	__setjmp,@function
+.type	_setjmp,@function
+.type	setjmp,@function
+__setjmp:
+_setjmp:
+setjmp:
+	sd	$ra, 0($4)
+	sd	$sp, 8($4)
+	sd	$gp, 16($4)
+	sd	$16, 24($4)
+	sd	$17, 32($4)
+	sd	$18, 40($4)
+	sd	$19, 48($4)
+	sd	$20, 56($4)
+	sd	$21, 64($4)
+	sd	$22, 72($4)
+	sd	$23, 80($4)
+	sd	$30, 88($4)
+#ifndef __mips_soft_float
+	sdc1	$24, 96($4)
+	sdc1	$25, 104($4)
+	sdc1	$26, 112($4)
+	sdc1	$27, 120($4)
+	sdc1	$28, 128($4)
+	sdc1	$29, 136($4)
+	sdc1	$30, 144($4)
+	sdc1	$31, 152($4)
+#endif
+	jr	$ra
+	li	$2, 0
--- /dev/null
+++ b/src/setjmp/powerpc/longjmp.S
@@ -0,0 +1,69 @@
+	.global _longjmp
+	.global longjmp
+	.type   _longjmp,@function
+	.type   longjmp,@function
+_longjmp:
+longjmp:
+	/*
+	 * void longjmp(jmp_buf env, int val);
+	 * put val into return register and restore the env saved in setjmp
+	 * if val(r4) is 0, put 1 there.
+	 */
+	/* 0) move old return address into r0 */
+	lwz 0, 0(3)
+	/* 1) put it into link reg */
+	mtlr 0
+	/* 2 ) restore stack ptr */
+	lwz 1, 4(3)
+	/* 3) restore control reg */
+	lwz 0, 8(3)
+	mtcr 0
+	/* 4) restore r14-r31 */
+	lwz 14, 12(3)
+	lwz 15, 16(3)
+	lwz 16, 20(3)
+	lwz 17, 24(3)
+	lwz 18, 28(3)
+	lwz 19, 32(3)
+	lwz 20, 36(3)
+	lwz 21, 40(3)
+	lwz 22, 44(3)
+	lwz 23, 48(3)
+	lwz 24, 52(3)
+	lwz 25, 56(3)
+	lwz 26, 60(3)
+	lwz 27, 64(3)
+	lwz 28, 68(3)
+	lwz 29, 72(3)
+	lwz 30, 76(3)
+	lwz 31, 80(3)
+#ifndef _SOFT_FLOAT
+	lfd 14,88(3)
+	lfd 15,96(3)
+	lfd 16,104(3)
+	lfd 17,112(3)
+	lfd 18,120(3)
+	lfd 19,128(3)
+	lfd 20,136(3)
+	lfd 21,144(3)
+	lfd 22,152(3)
+	lfd 23,160(3)
+	lfd 24,168(3)
+	lfd 25,176(3)
+	lfd 26,184(3)
+	lfd 27,192(3)
+	lfd 28,200(3)
+	lfd 29,208(3)
+	lfd 30,216(3)
+	lfd 31,224(3)
+#endif
+	/* 5) put val into return reg r3 */
+	mr 3, 4
+
+	/* 6) check if return value is 0, make it 1 in that case */
+	cmpwi cr7, 4, 0
+	bne cr7, 1f
+	li 3, 1
+1:
+	blr
+
--- a/src/setjmp/powerpc/longjmp.s
+++ /dev/null
@@ -1,65 +0,0 @@
-	.global _longjmp
-	.global longjmp
-	.type   _longjmp,@function
-	.type   longjmp,@function
-_longjmp:
-longjmp:
-# void longjmp(jmp_buf env, int val);
-# put val into return register and restore the env saved in setjmp
-# if val(r4) is 0, put 1 there.
-	# 0) move old return address into r0
-	lwz 0, 0(3)
-	# 1) put it into link reg
-	mtlr 0
-	#2 ) restore stack ptr
-	lwz 1, 4(3)
-	#3) restore control reg
-	lwz 0, 8(3)
-	mtcr 0
-	#4) restore r14-r31
-	lwz 14, 12(3)
-	lwz 15, 16(3)
-	lwz 16, 20(3)
-	lwz 17, 24(3)
-	lwz 18, 28(3)
-	lwz 19, 32(3)
-	lwz 20, 36(3)
-	lwz 21, 40(3)
-	lwz 22, 44(3)
-	lwz 23, 48(3)
-	lwz 24, 52(3)
-	lwz 25, 56(3)
-	lwz 26, 60(3)
-	lwz 27, 64(3)
-	lwz 28, 68(3)
-	lwz 29, 72(3)
-	lwz 30, 76(3)
-	lwz 31, 80(3)
-	lfd 14,88(3)
-	lfd 15,96(3)
-	lfd 16,104(3)
-	lfd 17,112(3)
-	lfd 18,120(3)
-	lfd 19,128(3)
-	lfd 20,136(3)
-	lfd 21,144(3)
-	lfd 22,152(3)
-	lfd 23,160(3)
-	lfd 24,168(3)
-	lfd 25,176(3)
-	lfd 26,184(3)
-	lfd 27,192(3)
-	lfd 28,200(3)
-	lfd 29,208(3)
-	lfd 30,216(3)
-	lfd 31,224(3)
-	#5) put val into return reg r3
-	mr 3, 4
-
-	#6) check if return value is 0, make it 1 in that case
-	cmpwi cr7, 4, 0
-	bne cr7, 1f
-	li 3, 1
-1:
-	blr
-
--- /dev/null
+++ b/src/setjmp/powerpc/setjmp.S
@@ -0,0 +1,63 @@
+	.global ___setjmp
+	.hidden ___setjmp
+	.global __setjmp
+	.global _setjmp
+	.global setjmp
+	.type   __setjmp,@function
+	.type   _setjmp,@function
+	.type   setjmp,@function
+___setjmp:
+__setjmp:
+_setjmp:
+setjmp:
+	/* 0) store IP int 0, then into the jmpbuf pointed to by r3 (first arg) */
+	mflr 0
+	stw 0, 0(3)
+	/* 1) store reg1 (SP) */
+	stw 1, 4(3)
+	/* 2) store cr */
+	mfcr 0
+	stw 0, 8(3)
+	/* 3) store r14-31 */
+	stw 14, 12(3)
+	stw 15, 16(3)
+	stw 16, 20(3)
+	stw 17, 24(3)
+	stw 18, 28(3)
+	stw 19, 32(3)
+	stw 20, 36(3)
+	stw 21, 40(3)
+	stw 22, 44(3)
+	stw 23, 48(3)
+	stw 24, 52(3)
+	stw 25, 56(3)
+	stw 26, 60(3)
+	stw 27, 64(3)
+	stw 28, 68(3)
+	stw 29, 72(3)
+	stw 30, 76(3)
+	stw 31, 80(3)
+#ifndef _SOFT_FLOAT
+	stfd 14,88(3)
+	stfd 15,96(3)
+	stfd 16,104(3)
+	stfd 17,112(3)
+	stfd 18,120(3)
+	stfd 19,128(3)
+	stfd 20,136(3)
+	stfd 21,144(3)
+	stfd 22,152(3)
+	stfd 23,160(3)
+	stfd 24,168(3)
+	stfd 25,176(3)
+	stfd 26,184(3)
+	stfd 27,192(3)
+	stfd 28,200(3)
+	stfd 29,208(3)
+	stfd 30,216(3)
+	stfd 31,224(3)
+#endif
+	/* 4) set return value to 0 */
+	li 3, 0
+	/* 5) return */
+	blr
--- a/src/setjmp/powerpc/setjmp.s
+++ /dev/null
@@ -1,61 +0,0 @@
-	.global ___setjmp
-	.hidden ___setjmp
-	.global __setjmp
-	.global _setjmp
-	.global setjmp
-	.type   __setjmp,@function
-	.type   _setjmp,@function
-	.type   setjmp,@function
-___setjmp:
-__setjmp:
-_setjmp:
-setjmp:
-	# 0) store IP int 0, then into the jmpbuf pointed to by r3 (first arg)
-	mflr 0
-	stw 0, 0(3)
-	# 1) store reg1 (SP)
-	stw 1, 4(3)
-	# 2) store cr
-	mfcr 0
-	stw 0, 8(3)
-	# 3) store r14-31
-	stw 14, 12(3)
-	stw 15, 16(3)
-	stw 16, 20(3)
-	stw 17, 24(3)
-	stw 18, 28(3)
-	stw 19, 32(3)
-	stw 20, 36(3)
-	stw 21, 40(3)
-	stw 22, 44(3)
-	stw 23, 48(3)
-	stw 24, 52(3)
-	stw 25, 56(3)
-	stw 26, 60(3)
-	stw 27, 64(3)
-	stw 28, 68(3)
-	stw 29, 72(3)
-	stw 30, 76(3)
-	stw 31, 80(3)
-	stfd 14,88(3)
-	stfd 15,96(3)
-	stfd 16,104(3)
-	stfd 17,112(3)
-	stfd 18,120(3)
-	stfd 19,128(3)
-	stfd 20,136(3)
-	stfd 21,144(3)
-	stfd 22,152(3)
-	stfd 23,160(3)
-	stfd 24,168(3)
-	stfd 25,176(3)
-	stfd 26,184(3)
-	stfd 27,192(3)
-	stfd 28,200(3)
-	stfd 29,208(3)
-	stfd 30,216(3)
-	stfd 31,224(3)
-	# 4) set return value to 0
-	li 3, 0
-	# 5) return
-	blr
--- /dev/null
+++ b/src/signal/mips64/restore.s
@@ -0,0 +1,9 @@
+.set	noreorder
+.global	__restore_rt
+.global	__restore
+.type	__restore_rt,@function
+.type	__restore,@function
+__restore_rt:
+__restore:
+	li	$2,5211
+	syscall
--- /dev/null
+++ b/src/signal/mips64/sigsetjmp.s
@@ -0,0 +1,38 @@
+.set	noreorder
+.global	sigsetjmp
+.global	__sigsetjmp
+.type	sigsetjmp,@function
+.type	__sigsetjmp,@function
+sigsetjmp:
+__sigsetjmp:
+	lui	$3, %hi(%neg(%gp_rel(sigsetjmp)))
+	daddiu	$3, $3, %lo(%neg(%gp_rel(sigsetjmp)))
+
+	# comparing save mask with 0, if equals to 0 then
+	# sigsetjmp is equal to setjmp.
+	beq	$5, $0, 1f
+	daddu	$3, $3, $25
+	sd	$ra, 160($4)
+	sd	$16, 168($4)
+
+	# save base of got so that we can use it later
+	# once we return from 'longjmp'
+	sd	$3, 176($4)
+	ld	$25, %got_disp(setjmp)($3)
+	jalr	$25
+	move	$16, $4
+
+	move	$5, $2		# Return from 'setjmp' or 'longjmp'
+	move	$4, $16		# Restore the pointer-to-sigjmp_buf
+	ld	$ra, 160($4)	# Restore ra of sigsetjmp
+	ld	$16, 168($4)	# Restore $16 of sigsetjmp
+	ld	$3, 176($4)	# Restore base of got
+
+.hidden	__sigsetjmp_tail
+	ld	$25, %got_disp(__sigsetjmp_tail)($3)
+	jr	$25
+	nop
+1:
+	ld	$25, %got_disp(setjmp)($3)
+	jr	$25
+	nop
--- /dev/null
+++ b/src/thread/mips64/__unmapself.s
@@ -0,0 +1,9 @@
+.set	noreorder
+.global	__unmapself
+.type	__unmapself, @function
+__unmapself:
+	li	$2, 5011
+	syscall
+	li	$4, 0
+	li	$2, 5058
+	syscall
--- /dev/null
+++ b/src/thread/mips64/clone.s
@@ -0,0 +1,30 @@
+.set	noreorder
+.global	__clone
+.type	__clone,@function
+__clone:
+	# Save function pointer and argument pointer on new thread stack
+	and	$5, $5, -16	# aligning stack to double word
+	dsubu	$5, $5, 16
+	sd	$4, 0($5)	# save function pointer
+	sd	$7, 8($5)	# save argument pointer
+
+	# Shuffle (fn,sp,fl,arg,ptid,tls,ctid) to (fl,sp,ptid,tls,ctid)
+	# sys_clone(u64 flags, u64 ustack_base, u64 parent_tidptr, u64 child_tidptr, u64 tls)
+	move	$4, $6
+	move	$6, $8
+	move	$7, $9
+	move	$8, $10
+	li	$2, 5055
+	syscall
+	beq	$7, $0, 1f
+	nop
+	jr	$ra
+	dsubu	$2, $0, $2
+1:	beq	$2, $0, 1f
+	nop
+	jr	$ra
+	nop
+1:	ld	$25, 0($sp)	# function pointer
+	ld	$4, 8($sp)	# argument pointer
+	jr	$25		# call the user's function
+	nop
--- /dev/null
+++ b/src/thread/mips64/syscall_cp.s
@@ -0,0 +1,52 @@
+.set	noreorder
+.global	__cp_begin
+.hidden	__cp_begin
+.type	__cp_begin,@function
+.global	__cp_end
+.hidden	__cp_end
+.type	__cp_end,@function
+.global	__cp_cancel
+.hidden	__cp_cancel
+.type	__cp_cancel,@function
+.global	__cp_cancel_data
+.hidden	__cp_cancel_data
+.type	__cp_cancel_data,@function
+.hidden	__cancel
+.global	__syscall_cp_asm
+.hidden	__syscall_cp_asm
+.type	__syscall_cp_asm,@function
+__syscall_cp_asm:
+__cp_begin:
+	lw	$4, 0($4)
+	bne	$4, $0, __cp_cancel
+	move	$2, $5
+	move	$4, $6
+	move	$5, $7
+	move	$6, $8
+	move	$7, $9
+	move	$8, $10
+	move	$9, $11
+	ld	$10, 0($sp)
+	syscall
+__cp_end:
+	beq	$7, $0, 1f
+	nop
+	dsubu	$2, $0, $2
+1:	jr	$ra
+	nop
+
+	# if cancellation flag is 1 then call __cancel
+__cp_cancel:
+	move	$2, $ra
+.align 8
+	bal	1f
+	nop
+__cp_cancel_data:
+	.gpdword __cp_cancel_data
+	.gpdword __cancel
+1:	ld	$3, ($ra)
+	dsubu	$3, $ra, $3
+	ld	$25, 8($ra)
+	daddu	$25, $25, $3
+	jr	$25
+	move	$ra, $2
--- /dev/null
+++ b/src/unistd/mips64/pipe.s
@@ -0,0 +1,19 @@
+.set	noreorder
+.global	pipe
+.type	pipe,@function
+pipe:
+	lui	$3, %hi(%neg(%gp_rel(pipe)))
+	daddiu	$3, $3, %lo(%neg(%gp_rel(pipe)))
+	daddu	$3, $3, $25
+	li	$2, 5021
+	syscall
+	beq	$7, $0, 1f
+	nop
+	ld	$25, %got_disp(__syscall_ret)($3)
+	jr	$25
+	dsubu	$4, $0, $2
+1:	sw	$2, 0($4)
+	sw	$3, 4($4)
+	move	$2, $0
+	jr	$ra
+	nop
