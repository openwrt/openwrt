diff -Nur a/config/mh-mingw b/config/mh-mingw
--- a/config/mh-mingw	2008-11-21 14:54:41.000000000 +0100
+++ b/config/mh-mingw	2010-01-25 09:50:28.945687353 +0100
@@ -1,6 +1,8 @@
 # Add -D__USE_MINGW_ACCESS to enable the built compiler to work on Windows
 # Vista (see PR33281 for details).
-BOOT_CFLAGS += -D__USE_MINGW_ACCESS -Wno-pedantic-ms-format
-CFLAGS += -D__USE_MINGW_ACCESS
+# Because we wrap access in libiberty/cygpath.c, we do not want to use
+# the MinGW wrappers for access.
+BOOT_CFLAGS += -Wno-pedantic-ms-format
+# CFLAGS += -D__USE_MINGW_ACCESS
 # Increase stack limit to same as Linux default.
 LDFLAGS += -Wl,--stack,8388608
diff -Nur a/config/stdint.m4 b/config/stdint.m4
--- a/config/stdint.m4	2007-04-12 15:06:43.000000000 +0200
+++ b/config/stdint.m4	2010-01-25 09:50:28.945687353 +0100
@@ -115,19 +115,19 @@
 
 # Lacking an uintptr_t?  Test size of void *
 case "$acx_cv_header_stdint:$ac_cv_type_uintptr_t" in
-  stddef.h:* | *:no) AC_CHECK_SIZEOF(void *) ;;
+  stddef.h:* | *:no) AC_CHECK_SIZEOF(void *,,/* no standard headers */) ;;
 esac
 
 # Lacking an uint64_t?  Test size of long
 case "$acx_cv_header_stdint:$ac_cv_type_uint64_t:$ac_cv_type_u_int64_t" in
-  stddef.h:*:* | *:no:no) AC_CHECK_SIZEOF(long) ;;
+  stddef.h:*:* | *:no:no) AC_CHECK_SIZEOF(long,,/* no standard headers */) ;;
 esac
 
 if test $acx_cv_header_stdint = stddef.h; then
   # Lacking a good header?  Test size of everything and deduce all types.
-  AC_CHECK_SIZEOF(int)
-  AC_CHECK_SIZEOF(short)
-  AC_CHECK_SIZEOF(char)
+  AC_CHECK_SIZEOF(int,,/* no standard headers */)
+  AC_CHECK_SIZEOF(short,,/* no standard headers */)
+  AC_CHECK_SIZEOF(char,,/* no standard headers */)
 
   AC_MSG_CHECKING(for type equivalent to int8_t)
   case "$ac_cv_sizeof_char" in
diff -Nur a/config/tls.m4 b/config/tls.m4
--- a/config/tls.m4	2009-01-23 05:58:03.000000000 +0100
+++ b/config/tls.m4	2010-01-25 09:50:28.945687353 +0100
@@ -1,5 +1,6 @@
 dnl Check whether the target supports TLS.
 AC_DEFUN([GCC_CHECK_TLS], [
+  AC_REQUIRE([AC_CANONICAL_HOST])
   GCC_ENABLE(tls, yes, [], [Use thread-local storage])
   AC_CACHE_CHECK([whether the target supports thread-local storage],
 		 gcc_cv_have_tls, [
@@ -66,7 +67,24 @@
       [dnl This is the cross-compiling case. Assume libc supports TLS if the
        dnl binutils and the compiler do.
        AC_LINK_IFELSE([__thread int a; int b; int main() { return a = b; }],
-		      [gcc_cv_have_tls=yes], [gcc_cv_have_tls=no])
+	 [chktls_save_LDFLAGS="$LDFLAGS"
+	  dnl Shared library options may depend on the host; this check
+	  dnl is only known to be needed for GNU/Linux.
+	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  dnl If -shared works, test if TLS works in a shared library.
+	  AC_LINK_IFELSE([int f() { return 0; }],
+	    [AC_LINK_IFELSE([__thread int a; int b; int f() { return a = b; }],
+	      [gcc_cv_have_tls=yes],
+	      [gcc_cv_have_tls=no])],
+	    [gcc_cv_have_tls=yes])
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"], [gcc_cv_have_tls=no])
       ]
     )])
   if test "$enable_tls $gcc_cv_have_tls" = "yes yes"; then
diff -Nur a/configure b/configure
--- a/configure	2009-04-25 06:10:29.000000000 +0200
+++ b/configure	2010-01-25 09:50:28.945687353 +0100
@@ -2277,7 +2277,7 @@
     noconfigdirs="$noconfigdirs target-newlib target-libgloss target-rda ${libgcj}"
     ;;
   *-*-vxworks*)
-    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty ${libgcj}"
     ;;
   alpha*-dec-osf*)
     # ld works, but does not support shared libraries.
diff -Nur a/configure.ac b/configure.ac
--- a/configure.ac	2009-04-25 06:10:29.000000000 +0200
+++ b/configure.ac	2010-01-25 09:50:28.945687353 +0100
@@ -512,7 +512,7 @@
     noconfigdirs="$noconfigdirs target-newlib target-libgloss target-rda ${libgcj}"
     ;;
   *-*-vxworks*)
-    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty ${libgcj}"
     ;;
   alpha*-dec-osf*)
     # ld works, but does not support shared libraries.
diff -Nur a/fixincludes/fixincl.tpl b/fixincludes/fixincl.tpl
--- a/fixincludes/fixincl.tpl	2008-09-06 21:57:26.000000000 +0200
+++ b/fixincludes/fixincl.tpl	2010-01-25 09:50:28.945687353 +0100
@@ -38,7 +38,7 @@
 #ifndef SED_PROGRAM
 #define SED_PROGRAM "/usr/bin/sed"
 #endif
-static char const sed_cmd_z[] = SED_PROGRAM;
+static char const sed_cmd_z[] = "sed";
 [=
 
 FOR fix =]
diff -Nur a/fixincludes/fixincl.x b/fixincludes/fixincl.x
--- a/fixincludes/fixincl.x	2009-02-28 19:13:31.000000000 +0100
+++ b/fixincludes/fixincl.x	2010-01-25 09:50:28.945687353 +0100
@@ -2,11 +2,11 @@
  * 
  * DO NOT EDIT THIS FILE   (fixincl.x)
  * 
- * It has been AutoGen-ed  Saturday February 28, 2009 at 10:11:41 AM PST
+ * It has been AutoGen-ed  Monday July 20, 2009 at 01:53:53 PM PDT
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Sat Feb 28 10:11:41 PST 2009
+/* DO NOT SVN-MERGE THIS FILE, EITHER Mon Jul 20 13:53:53 PDT 2009
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 180 fixup descriptions.
+ * This file contains 181 fixup descriptions.
  *
  * See README for more information.
  *
@@ -39,7 +39,7 @@
 #ifndef SED_PROGRAM
 #define SED_PROGRAM "/usr/bin/sed"
 #endif
-static char const sed_cmd_z[] = SED_PROGRAM;
+static char const sed_cmd_z[] = "sed";
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
@@ -2300,6 +2300,42 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Glibc_String2_Memset fix
+ */
+tSCC zGlibc_String2_MemsetName[] =
+     "glibc_string2_memset";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zGlibc_String2_MemsetList[] =
+  "bits/string2.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+#define apzGlibc_String2_MemsetMachs (const char**)NULL
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zGlibc_String2_MemsetSelect0[] =
+       "#ifndef _HAVE_STRING_ARCH_memset\n\
+# if _STRING_ARCH_unaligned";
+
+#define    GLIBC_STRING2_MEMSET_TEST_CT  1
+static tTestDesc aGlibc_String2_MemsetTests[] = {
+  { TT_EGREP,    zGlibc_String2_MemsetSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Glibc_String2_Memset
+ */
+static const char* apzGlibc_String2_MemsetPatch[] = {
+    "format",
+    "%0 && 0",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Gnu_Types fix
  */
 tSCC zGnu_TypesName[] =
@@ -5617,8 +5653,7 @@
  *  Machine/OS name selection pattern
  */
 tSCC* apzSolaris_Mutex_Init_2Machs[] = {
-        "*-*-solaris2.[0-9]",
-        "*-*-solaris2.[0-9][!0-9]*",
+        "*-*-solaris*",
         (const char*)NULL };
 
 /*
@@ -5627,8 +5662,15 @@
 tSCC zSolaris_Mutex_Init_2Select0[] =
        "@\\(#\\)pthread.h[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
 
-#define    SOLARIS_MUTEX_INIT_2_TEST_CT  1
+/*
+ *  perform the 'test' shell command - do fix on success
+ */
+tSCC zSolaris_Mutex_Init_2Test0[] =
+       " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
+
+#define    SOLARIS_MUTEX_INIT_2_TEST_CT  2
 static tTestDesc aSolaris_Mutex_Init_2Tests[] = {
+  { TT_TEST,     zSolaris_Mutex_Init_2Test0,   0 /* unused */ },
   { TT_EGREP,    zSolaris_Mutex_Init_2Select0, (regex_t*)NULL }, };
 
 /*
@@ -5670,8 +5712,15 @@
 tSCC zSolaris_Rwlock_Init_1Select0[] =
        "@\\(#\\)pthread.h[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
 
-#define    SOLARIS_RWLOCK_INIT_1_TEST_CT  1
+/*
+ *  perform the 'test' shell command - do fix on success
+ */
+tSCC zSolaris_Rwlock_Init_1Test0[] =
+       " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
+
+#define    SOLARIS_RWLOCK_INIT_1_TEST_CT  2
 static tTestDesc aSolaris_Rwlock_Init_1Tests[] = {
+  { TT_TEST,     zSolaris_Rwlock_Init_1Test0,   0 /* unused */ },
   { TT_EGREP,    zSolaris_Rwlock_Init_1Select0, (regex_t*)NULL }, };
 
 /*
@@ -5741,8 +5790,7 @@
  *  Machine/OS name selection pattern
  */
 tSCC* apzSolaris_Once_Init_2Machs[] = {
-        "*-*-solaris2.[0-9]",
-        "*-*-solaris2.[0-9][!0-9]*",
+        "*-*-solaris*",
         (const char*)NULL };
 
 /*
@@ -5751,8 +5799,15 @@
 tSCC zSolaris_Once_Init_2Select0[] =
        "@\\(#\\)pthread.h[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
 
-#define    SOLARIS_ONCE_INIT_2_TEST_CT  1
+/*
+ *  perform the 'test' shell command - do fix on success
+ */
+tSCC zSolaris_Once_Init_2Test0[] =
+       " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
+
+#define    SOLARIS_ONCE_INIT_2_TEST_CT  2
 static tTestDesc aSolaris_Once_Init_2Tests[] = {
+  { TT_TEST,     zSolaris_Once_Init_2Test0,   0 /* unused */ },
   { TT_EGREP,    zSolaris_Once_Init_2Select0, (regex_t*)NULL }, };
 
 /*
@@ -7308,9 +7363,9 @@
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          226
-#define MACH_LIST_SIZE_LIMIT 181
-#define FIX_COUNT            180
+#define REGEX_COUNT          227
+#define MACH_LIST_SIZE_LIMIT 169
+#define FIX_COUNT            181
 
 /*
  *  Enumerate the fixes
@@ -7371,6 +7426,7 @@
     GLIBC_C99_INLINE_3_FIXIDX,
     GLIBC_C99_INLINE_4_FIXIDX,
     GLIBC_MUTEX_INIT_FIXIDX,
+    GLIBC_STRING2_MEMSET_FIXIDX,
     GNU_TYPES_FIXIDX,
     HP_INLINE_FIXIDX,
     HP_SYSFILE_FIXIDX,
@@ -7774,6 +7830,11 @@
      GLIBC_MUTEX_INIT_TEST_CT, FD_MACH_ONLY,
      aGlibc_Mutex_InitTests,   apzGlibc_Mutex_InitPatch, 0 },
 
+  {  zGlibc_String2_MemsetName,    zGlibc_String2_MemsetList,
+     apzGlibc_String2_MemsetMachs,
+     GLIBC_STRING2_MEMSET_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aGlibc_String2_MemsetTests,   apzGlibc_String2_MemsetPatch, 0 },
+
   {  zGnu_TypesName,    zGnu_TypesList,
      apzGnu_TypesMachs,
      GNU_TYPES_TEST_CT, FD_MACH_IFNOT | FD_SUBROUTINE,
diff -Nur a/fixincludes/inclhack.def b/fixincludes/inclhack.def
--- a/fixincludes/inclhack.def	2009-02-28 19:13:31.000000000 +0100
+++ b/fixincludes/inclhack.def	2010-01-25 09:50:28.955687088 +0100
@@ -1302,6 +1302,21 @@
 };
 
 
+/* glibc's bits/string2.h (before 2004-05-26) generates bogus
+   -Wstrict-aliasing warnings from calls to memset.  */
+fix = {
+    hackname  = glibc_string2_memset;
+    files     = "bits/string2.h";
+    select    = "#ifndef _HAVE_STRING_ARCH_memset\n# if _STRING_ARCH_unaligned";
+    c_fix     = format;
+    c_fix_arg = "%0 && 0";
+    test_text = "#ifndef _HAVE_STRING_ARCH_memset\n"
+                "# if _STRING_ARCH_unaligned\n"
+                "# endif\n"
+                "#endif\n";
+};
+
+
 /*
  * Fix these files to use the types we think they should for
  * ptrdiff_t, size_t, and wchar_t.
@@ -2939,24 +2954,32 @@
 };
 
 /*
- * Sun Solaris defines PTHREAD_MUTEX_INITIALIZER with a trailing
- * "0" for the last field of the pthread_mutex_t structure, which is
- * of type upad64_t, which itself is typedef'd to int64_t, but with
- * __STDC__ defined (e.g. by -ansi) it is a union. So change the
- * initializer to "{0}" instead
+ * Sun Solaris defines the last field of the pthread_mutex_t structure
+ * to have type upad64_t.  Whether upad64_t is an integer type or a
+ * union depends on whether or not the headers believe that a 64-bit
+ * integer type is available.  But, PTHREAD_MUTEX_INITIALIZER is not
+ * appropriately conditionalized; it always uses "0", and never "{0}".
+ * In order to avoid warnings/errors from the compiler, we must make
+ * the initializer use braces where appropriate.
+ *
+ * Prior to Solaris 10, if __STDC__ is 1 (as when compiling with
+ * -ansi), the definition would be a union.  Beginning with Solaris
+ * 10, the headers check for __GNUC__, and will never use a union with
+ * GCC.  We check /usr/include/sys/types.h to see if it checks for
+ * __STDC__.
+ *
+ * A "mach" test for Solaris 10 is undesirable because we want to
+ * allow a compiler built for Solaris <10 to be used on Solaris >=10,
+ * but the installed version of fixincludes hard-wires the target
+ * machine to the configure-time $target, rather than automatically
+ * determining it at installation time.
  */
 fix = {
     hackname = solaris_mutex_init_2;
     select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
     files = pthread.h;
-    /*
-     * On Solaris 10, this fix is unnecessary because upad64_t is
-     * always defined correctly regardless of the definition of the
-     * __STDC__ macro.  The first "mach" pattern matches up to
-     * solaris9.  The second "mach" pattern will not match any two (or
-     * more) digit solaris version, but it will match e.g. 2.5.1.
-     */
-    mach = '*-*-solaris2.[0-9]', '*-*-solaris2.[0-9][!0-9]*';
+    mach = '*-*-solaris*';
+    test = " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
     c_fix = format;
     c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                 "%0\n"
@@ -2967,6 +2990,7 @@
                 "(|/\*.*\*/[ \t]*\\\\\n[ \t]*)\\{.*)"
                 ",[ \t]*0\\}" "(|[ \t].*)$";
     test_text =
+    "`mkdir -p sys; echo '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' >> sys/types.h`"
     '#ident "@(#)pthread.h  1.26  98/04/12 SMI"'"\n"
     "#define PTHREAD_MUTEX_INITIALIZER\t{{{0},0}, {{{0}}}, 0}\n"
     "#define PTHREAD_COND_INITIALIZER\t{{{0}, 0}, 0}\t/* DEFAULTCV */\n"
@@ -2978,17 +3002,14 @@
 
 
 /*
- * Sun Solaris defines PTHREAD_RWLOCK_INITIALIZER with a "0" for some
- *  fields of the pthread_rwlock_t structure, which are of type
- *  upad64_t, which itself is typedef'd to int64_t, but with __STDC__
- *  defined (e.g. by -ansi) it is a union. So change the initializer
- *  to "{0}" instead.
+ * See comments for solaris_mutex_init_2 re. upad64_t.
  */
 fix = {
     hackname = solaris_rwlock_init_1;
     select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
     files = pthread.h;
     mach = '*-*-solaris*';
+    test = " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
     c_fix = format;
     c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                 "%0\n"
@@ -3024,24 +3045,14 @@
 
 
 /*
- * Sun Solaris defines PTHREAD_ONCE_INIT with a "0" for some
- *  fields of the pthread_once_t structure, which are of type
- *  upad64_t, which itself is typedef'd to int64_t, but with __STDC__
- *  defined (e.g. by -ansi) it is a union. So change the initializer
- *  to "{0}" instead.  This test relies on solaris_once_init_1.
+ * See comments for solaris_mutex_init_2 re. upad64_t.
  */
 fix = {
     hackname = solaris_once_init_2;
     select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
     files = pthread.h;
-    /*
-     * On Solaris 10, this fix is unnecessary because upad64_t is
-     * always defined correctly regardless of the definition of the
-     * __STDC__ macro.  The first "mach" pattern matches up to
-     * solaris9.  The second "mach" pattern will not match any two (or
-     * more) digit solaris version, but it will match e.g. 2.5.1.
-     */
-    mach = '*-*-solaris2.[0-9]', '*-*-solaris2.[0-9][!0-9]*';
+    mach = '*-*-solaris*';
+    test = " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
     c_fix = format;
     c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                 "%0\n"
diff -Nur a/fixincludes/server.c b/fixincludes/server.c
--- a/fixincludes/server.c	2005-08-15 02:50:43.000000000 +0200
+++ b/fixincludes/server.c	2010-01-25 09:50:28.955687088 +0100
@@ -266,7 +266,7 @@
   /*  Make sure the process will pay attention to us, send the
      supplied command, and then have it output a special marker that
      we can find.  */
-  fprintf (server_pair.pf_write, "cd %s\n%s\n\necho\necho %s\n",
+  fprintf (server_pair.pf_write, "cd '%s'\n%s\n\necho\necho %s\n",
            p_cur_dir, pz_cmd, z_done);
   fflush (server_pair.pf_write);
 
diff -Nur a/fixincludes/tests/base/bits/string2.h b/fixincludes/tests/base/bits/string2.h
--- a/fixincludes/tests/base/bits/string2.h	2007-03-26 15:25:26.000000000 +0200
+++ b/fixincludes/tests/base/bits/string2.h	2010-01-25 09:50:28.955687088 +0100
@@ -16,3 +16,12 @@
 #  define __STRING_INLINE extern __inline
 # endif
 #endif  /* GLIBC_C99_INLINE_3_CHECK */
+
+
+#if defined( GLIBC_STRING2_MEMSET_CHECK )
+#ifndef _HAVE_STRING_ARCH_memset
+# if _STRING_ARCH_unaligned && 0
+# endif
+#endif
+
+#endif  /* GLIBC_STRING2_MEMSET_CHECK */
diff -Nur a/fixincludes/tests/base/sys/types.h b/fixincludes/tests/base/sys/types.h
--- a/fixincludes/tests/base/sys/types.h	2004-08-31 11:27:00.000000000 +0200
+++ b/fixincludes/tests/base/sys/types.h	2010-01-25 09:50:28.955687088 +0100
@@ -28,3 +28,4 @@
 
 #endif /* ushort_t */
 #endif  /* GNU_TYPES_CHECK */
+#if  !defined(__STRICT_ANSI__) && !defined(_NO_LONGLONG)
diff -Nur a/gcc/acinclude.m4 b/gcc/acinclude.m4
--- a/gcc/acinclude.m4	2008-06-02 21:37:45.000000000 +0200
+++ b/gcc/acinclude.m4	2010-01-25 09:50:28.955687088 +0100
@@ -482,3 +482,53 @@
 AC_DEFUN([gcc_AC_BUILD_EXEEXT], [
 ac_executable_extensions="$build_exeext"])
 
+
+# --with-license=PATH
+AC_DEFUN([CSL_AC_LICENSE],[
+  AC_ARG_WITH(license,
+    AC_HELP_STRING([--with-license],
+                   [the path to the installed license component]),
+    [case "$withval" in
+     (yes) AC_MSG_ERROR([license not specified]) ;;
+     (no)  with_license= ;;
+     (*) ;;
+  esac],
+  [with_license=])
+  AC_SUBST(licensedir, $with_license)
+])
+
+# --with-csl-license-feature=FOO
+AC_DEFUN([CSL_AC_LICENSE_FEATURE],[
+  AC_ARG_WITH(csl-license-feature,
+    AC_HELP_STRING([--with-csl-license-feature=FEATURE],
+                   [Use FEATURE to communicate with the license manager]),
+    [case "$withval" in
+      (yes) AC_MSG_ERROR([license feature not specified]) ;;
+      (no)  CSL_LICENSE_FEATURE="" ;; 
+      (*)   CSL_LICENSE_FEATURE="$withval" ;;
+     esac],
+     CSL_LICENSE_FEATURE=""
+  )
+  if test x"$CSL_LICENSE_FEATURE" != x; then
+    AC_DEFINE_UNQUOTED(CSL_LICENSE_FEATURE, "$CSL_LICENSE_FEATURE",
+                       [Required license feature])
+  fi
+])
+
+# --with-csl-license-version=VERSION
+AC_DEFUN([CSL_AC_LICENSE_VERSION],[
+  AC_ARG_WITH(csl-license-version,
+    AC_HELP_STRING([--with-csl-license-version=VERSION],
+                   [Use VERSION to communicate with the license manager]),
+    [case "$withval" in
+      (yes) AC_MSG_ERROR([license version not specified]) ;;
+      (no)  CSL_LICENSE_VERSION="" ;; 
+      (*)   CSL_LICENSE_VERSION="$withval" ;;
+     esac],
+     CSL_LICENSE_VERSION=""
+  )
+  if test x"$CSL_LICENSE_VERSION" != x; then
+    AC_DEFINE_UNQUOTED(CSL_LICENSE_VERSION, "$CSL_LICENSE_VERSION",
+                       [Required license version])
+  fi
+])
diff -Nur a/gcc/addresses.h b/gcc/addresses.h
--- a/gcc/addresses.h	2007-07-26 10:37:01.000000000 +0200
+++ b/gcc/addresses.h	2010-01-25 09:50:28.955687088 +0100
@@ -78,3 +78,42 @@
 
   return ok_for_base_p_1 (regno, mode, outer_code, index_code);
 }
+
+/* Wrapper function to unify target macros MODE_INDEX_REG_CLASS and
+   INDEX_REG_CLASS.  Arguments as for the MODE_INDEX_REG_CLASS macro.  */
+
+static inline enum reg_class
+index_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+#ifdef MODE_INDEX_REG_CLASS
+  return MODE_INDEX_REG_CLASS (mode);
+#else
+  return INDEX_REG_CLASS;
+#endif
+}
+
+/* Wrapper function to unify target macros REGNO_MODE_OK_FOR_INDEX_P
+   and REGNO_OK_FOR_INDEX_P.  Arguments as for the
+   REGNO_MODE_OK_FOR_INDEX_P macro.  */
+
+static inline bool
+ok_for_index_p_1 (unsigned regno, enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+#ifdef REGNO_MODE_OK_FOR_INDEX_P
+  return REGNO_MODE_OK_FOR_INDEX_P (regno, mode);
+#else
+  return REGNO_OK_FOR_INDEX_P (regno);
+#endif
+}
+
+/* Wrapper around ok_for_index_p_1, for use after register allocation is
+   complete.  Arguments as for the called function.  */
+
+static inline bool
+regno_ok_for_index_p (unsigned regno, enum machine_mode mode)
+{
+  if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] >= 0)
+    regno = reg_renumber[regno];
+
+  return ok_for_index_p_1 (regno, mode);
+}
diff -Nur a/gcc/calls.c b/gcc/calls.c
--- a/gcc/calls.c	2009-02-20 12:19:34.000000000 +0100
+++ b/gcc/calls.c	2010-01-25 09:50:28.955687088 +0100
@@ -3803,7 +3803,7 @@
      cse'ing of library calls could delete a call and leave the pop.  */
   NO_DEFER_POP;
   valreg = (mem_value == 0 && outmode != VOIDmode
-	    ? hard_libcall_value (outmode) : NULL_RTX);
+	    ? hard_libcall_value (outmode, orgfun) : NULL_RTX);
 
   /* Stack must be properly aligned now.  */
   gcc_assert (!(stack_pointer_delta
@@ -4048,8 +4048,17 @@
 	      /* We need to make a save area.  */
 	      unsigned int size = arg->locate.size.constant * BITS_PER_UNIT;
 	      enum machine_mode save_mode = mode_for_size (size, MODE_INT, 1);
-	      rtx adr = memory_address (save_mode, XEXP (arg->stack_slot, 0));
-	      rtx stack_area = gen_rtx_MEM (save_mode, adr);
+	      rtx adr;
+	      rtx stack_area;
+
+	      /* We can only use save_mode if the arg is sufficiently
+	         aligned.  */
+	      if (STRICT_ALIGNMENT
+		  && GET_MODE_ALIGNMENT (save_mode) > arg->locate.boundary)
+		save_mode = BLKmode;
+
+	      adr = memory_address (save_mode, XEXP (arg->stack_slot, 0));
+	      stack_area = gen_rtx_MEM (save_mode, adr);
 
 	      if (save_mode == BLKmode)
 		{
diff -Nur a/gcc/c-common.c b/gcc/c-common.c
--- a/gcc/c-common.c	2009-03-30 19:42:27.000000000 +0200
+++ b/gcc/c-common.c	2010-01-25 09:50:28.955687088 +0100
@@ -33,7 +33,6 @@
 #include "varray.h"
 #include "expr.h"
 #include "c-common.h"
-#include "diagnostic.h"
 #include "tm_p.h"
 #include "obstack.h"
 #include "cpplib.h"
@@ -42,6 +41,7 @@
 #include "tree-inline.h"
 #include "c-tree.h"
 #include "toplev.h"
+#include "diagnostic.h"
 #include "tree-iterator.h"
 #include "hashtab.h"
 #include "tree-mudflap.h"
@@ -497,6 +497,10 @@
    This is a count, since unevaluated expressions can nest.  */
 int skip_evaluation;
 
+/* Whether lexing has been completed, so subsequent preprocessor
+   errors should use the compiler's input_location.  */
+bool done_lexing = false;
+
 /* Information about how a function name is generated.  */
 struct fname_var_t
 {
@@ -7522,6 +7526,68 @@
 #undef catenate_messages
 }
 
+/* Callback from cpp_error for PFILE to print diagnostics from the
+   preprocessor.  The diagnostic is of type LEVEL, at location
+   LOCATION unless this is after lexing and the compiler's location
+   should be used instead, with column number possibly overridden by
+   COLUMN_OVERRIDE if not zero; MSG is the translated message and AP
+   the arguments.  Returns true if a diagnostic was emitted, false
+   otherwise.  */
+
+bool
+c_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level,
+	     location_t location, unsigned int column_override,
+	     const char *msg, va_list *ap)
+{
+  diagnostic_info diagnostic;
+  diagnostic_t dlevel;
+  int save_warn_system_headers = warn_system_headers;
+  bool ret;
+
+  switch (level)
+    {
+    case CPP_DL_WARNING_SYSHDR:
+      if (flag_no_output)
+	return false;
+      warn_system_headers = 1;
+      /* Fall through.  */
+    case CPP_DL_WARNING:
+      if (flag_no_output)
+	return false;
+      dlevel = DK_WARNING;
+      break;
+    case CPP_DL_PEDWARN:
+      if (flag_no_output && !flag_pedantic_errors)
+	return false;
+      dlevel = DK_PEDWARN;
+      break;
+    case CPP_DL_ERROR:
+      dlevel = DK_ERROR;
+      break;
+    case CPP_DL_ICE:
+      dlevel = DK_ICE;
+      break;
+    case CPP_DL_NOTE:
+      dlevel = DK_NOTE;
+      break;
+    case CPP_DL_FATAL:
+      dlevel = DK_FATAL;
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  if (done_lexing)
+    location = input_location;
+  diagnostic_set_info_translated (&diagnostic, msg, ap,
+				  location, dlevel);
+  if (column_override)
+    diagnostic_override_column (&diagnostic, column_override);
+  ret = report_diagnostic (&diagnostic);
+  if (level == CPP_DL_WARNING_SYSHDR)
+    warn_system_headers = save_warn_system_headers;
+  return ret;
+}
+
 /* Walk a gimplified function and warn for functions whose return value is
    ignored and attribute((warn_unused_result)) is set.  This is done before
    inlining, so we don't have to worry about that.  */
diff -Nur a/gcc/c-common.h b/gcc/c-common.h
--- a/gcc/c-common.h	2009-03-30 19:42:27.000000000 +0200
+++ b/gcc/c-common.h	2010-01-25 09:50:28.955687088 +0100
@@ -658,6 +658,11 @@
 
 extern int skip_evaluation;
 
+/* Whether lexing has been completed, so subsequent preprocessor
+   errors should use the compiler's input_location.  */
+
+extern bool done_lexing;
+
 /* C types are partitioned into three subsets: object, function, and
    incomplete types.  */
 #define C_TYPE_OBJECT_P(type) \
diff -Nur a/gcc/c-convert.c b/gcc/c-convert.c
--- a/gcc/c-convert.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/c-convert.c	2010-01-25 09:50:28.955687088 +0100
@@ -70,6 +70,7 @@
   tree e = expr;
   enum tree_code code = TREE_CODE (type);
   const char *invalid_conv_diag;
+  tree ret;
 
   if (type == error_mark_node
       || expr == error_mark_node
@@ -85,6 +86,9 @@
 
   if (type == TREE_TYPE (expr))
     return expr;
+  ret = targetm.convert_to_type (type, expr);
+  if (ret)
+      return ret;
 
   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))
     return fold_convert (type, expr);
diff -Nur a/gcc/c-decl.c b/gcc/c-decl.c
--- a/gcc/c-decl.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/c-decl.c	2010-01-25 09:50:28.955687088 +0100
@@ -3994,6 +3994,7 @@
   bool bitfield = width != NULL;
   tree element_type;
   struct c_arg_info *arg_info = 0;
+  const char *errmsg;
 
   if (decl_context == FUNCDEF)
     funcdef_flag = true, decl_context = NORMAL;
@@ -4531,6 +4532,12 @@
 		error ("%qs declared as function returning an array", name);
 		type = integer_type_node;
 	      }
+	    errmsg = targetm.invalid_return_type (type);
+	    if (errmsg)
+	      {
+		error (errmsg);
+		type = integer_type_node;
+	      }
 
 	    /* Construct the function type and go to the next
 	       inner layer of declarator.  */
@@ -5044,6 +5051,7 @@
     {
       tree parm, type, typelt;
       unsigned int parmno;
+      const char *errmsg;
 
       /* If there is a parameter of incomplete type in a definition,
 	 this is an error.  In a declaration this is valid, and a
@@ -5087,6 +5095,14 @@
 		}
 	    }
 
+	  errmsg = targetm.invalid_parameter_type (type);
+	  if (errmsg)
+	    {
+	      error (errmsg);
+	      TREE_VALUE (typelt) = error_mark_node;
+	      TREE_TYPE (parm) = error_mark_node;
+	    }
+
 	  if (DECL_NAME (parm) && TREE_USED (parm))
 	    warn_if_shadowing (parm);
 	}
@@ -8071,7 +8087,7 @@
 
   /* Don't waste time on further processing if -fsyntax-only or we've
      encountered errors.  */
-  if (flag_syntax_only || errorcount || sorrycount || cpp_errors (parse_in))
+  if (flag_syntax_only || errorcount || sorrycount)
     return;
 
   /* Close the external scope.  */
diff -Nur a/gcc/cfgexpand.c b/gcc/cfgexpand.c
--- a/gcc/cfgexpand.c	2009-07-11 21:06:26.000000000 +0200
+++ b/gcc/cfgexpand.c	2010-01-25 09:50:28.955687088 +0100
@@ -488,7 +488,8 @@
 {
   unsigned int align;
 
-  align = LOCAL_DECL_ALIGNMENT (decl);
+  align = alignment_for_aligned_arrays (TREE_TYPE (decl),
+					LOCAL_DECL_ALIGNMENT (decl));
 
   if (align > MAX_SUPPORTED_STACK_ALIGNMENT)
     align = MAX_SUPPORTED_STACK_ALIGNMENT;
diff -Nur a/gcc/cgraph.c b/gcc/cgraph.c
--- a/gcc/cgraph.c	2008-11-16 23:31:58.000000000 +0100
+++ b/gcc/cgraph.c	2010-01-25 09:50:28.955687088 +0100
@@ -475,9 +475,11 @@
   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)
     {
       node->origin = cgraph_node (DECL_CONTEXT (decl));
+      node->origin->ever_was_nested = 1;
       node->next_nested = node->origin->nested;
       node->origin->nested = node;
       node->master_clone = node;
+      node->ever_was_nested = 1;
     }
   if (assembler_name_hash)
     {
diff -Nur a/gcc/cgraph.h b/gcc/cgraph.h
--- a/gcc/cgraph.h	2009-03-23 17:29:33.000000000 +0100
+++ b/gcc/cgraph.h	2010-01-25 09:50:28.955687088 +0100
@@ -185,6 +185,8 @@
   unsigned output : 1;
   /* Set for aliases once they got through assemble_alias.  */
   unsigned alias : 1;
+  /* Set if the function is a nested function or has nested functions.  */
+  unsigned ever_was_nested : 1;
 
   /* In non-unit-at-a-time mode the function body of inline candidates is saved
      into clone before compiling so the function in original form can be
diff -Nur a/gcc/common.opt b/gcc/common.opt
--- a/gcc/common.opt	2009-03-28 18:28:45.000000000 +0100
+++ b/gcc/common.opt	2010-01-25 09:50:28.955687088 +0100
@@ -153,6 +153,10 @@
 Common Var(warn_padded) Warning
 Warn when padding is required to align structure members
 
+Wpoison-system-directories
+Common Var(flag_poison_system_directories) Init(1)
+Warn for -I and -L options using system directories if cross compiling
+
 Wshadow
 Common Var(warn_shadow) Warning
 Warn when one local variable shadows another
@@ -270,6 +274,12 @@
 fabi-version=
 Common Joined UInteger Var(flag_abi_version) Init(2)
 
+falign-arrays
+Target Report Var(flag_align_arrays)
+Set the minimum alignment for array variables to be the largest power
+of two less than or equal to their total storage size, or the biggest
+alignment used on the machine, whichever is smaller.
+
 falign-functions
 Common Report Var(align_functions,0) Optimization UInteger
 Align the start of functions
@@ -467,6 +477,10 @@
 Common Report Var(flag_early_inlining) Init(1) Optimization
 Perform early inlining
 
+feglibc=
+Common Report Joined Undocumented
+EGLIBC configuration specifier, serves multilib purposes.
+
 feliminate-dwarf2-dups
 Common Report Var(flag_eliminate_dwarf2_dups)
 Perform DWARF2 duplicate elimination
@@ -895,6 +909,10 @@
 Common Report Var(flag_profile_values)
 Insert code to profile values of expressions
 
+fpromote-loop-indices
+Common Report Var(flag_promote_loop_indices) Optimization
+Promote loop indices to word-sized indices when safe
+
 frandom-seed
 Common
 
@@ -1227,6 +1245,15 @@
 Common Report Var(flag_tree_pre) Optimization
 Enable SSA-PRE optimization on trees
 
+ftree-pre-partial-partial
+Common Report Var(flag_tree_pre_partial_partial) Optimization
+In SSA-PRE optimization on trees, enable partial-partial redundancy elimination.
+
+ftree-pre-partial-partial-obliviously
+Common Report Var(flag_tree_pre_partial_partial_obliviously) Optimization
+In SSA-PRE optimization on trees, enable partial-partial redundancy
+elimination without regard for the cost of the inserted phi nodes.
+
 ftree-reassoc
 Common Report Var(flag_tree_reassoc) Init(1) Optimization
 Enable reassociation on tree level
diff -Nur a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
--- a/gcc/config/arm/arm.c	2009-06-02 09:18:16.000000000 +0200
+++ b/gcc/config/arm/arm.c	2010-01-25 09:50:28.975687047 +0100
@@ -43,6 +43,7 @@
 #include "optabs.h"
 #include "toplev.h"
 #include "recog.h"
+#include "cgraph.h"
 #include "ggc.h"
 #include "except.h"
 #include "c-pragma.h"
@@ -53,6 +54,8 @@
 #include "debug.h"
 #include "langhooks.h"
 #include "df.h"
+#include "intl.h"
+#include "params.h"
 
 /* Forward definitions of types.  */
 typedef struct minipool_node    Mnode;
@@ -110,6 +113,7 @@
 static unsigned long arm_isr_value (tree);
 static unsigned long arm_compute_func_type (void);
 static tree arm_handle_fndecl_attribute (tree *, tree, tree, int, bool *);
+static tree arm_handle_pcs_attribute (tree *, tree, tree, int, bool *);
 static tree arm_handle_isr_attribute (tree *, tree, tree, int, bool *);
 #if TARGET_DLLIMPORT_DECL_ATTRIBUTES
 static tree arm_handle_notshared_attribute (tree *, tree, tree, int, bool *);
@@ -123,6 +127,10 @@
 static int count_insns_for_constant (HOST_WIDE_INT, int);
 static int arm_get_strip_length (int);
 static bool arm_function_ok_for_sibcall (tree, tree);
+static bool arm_return_in_memory (const_tree, const_tree);
+static rtx arm_function_value (const_tree, const_tree, bool);
+static rtx arm_libcall_value (enum machine_mode, rtx);
+
 static void arm_internal_label (FILE *, const char *, unsigned long);
 static void arm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,
 				 tree);
@@ -148,6 +156,9 @@
 static rtx emit_set_insn (rtx, rtx);
 static int arm_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,
 				  tree, bool);
+static rtx aapcs_allocate_return_reg (enum machine_mode, const_tree,
+				      const_tree);
+static int aapcs_select_return_coproc (const_tree, const_tree);
 
 #ifdef OBJECT_FORMAT_ELF
 static void arm_elf_asm_constructor (rtx, int) ATTRIBUTE_UNUSED;
@@ -175,6 +186,7 @@
 static bool arm_output_ttype (rtx);
 #endif
 static void arm_dwarf_handle_frame_unspec (const char *, rtx, int);
+static rtx arm_dwarf_register_span(rtx);
 
 static tree arm_cxx_guard_type (void);
 static bool arm_cxx_guard_mask_bit (void);
@@ -197,6 +209,15 @@
 static int arm_issue_rate (void);
 static void arm_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;
 static bool arm_allocate_stack_slots_for_args (void);
+static bool arm_warn_func_result (void);
+static int arm_multipass_dfa_lookahead (void);
+static const char *arm_invalid_parameter_type (const_tree t);
+static const char *arm_invalid_return_type (const_tree t);
+static tree arm_promoted_type (const_tree t);
+static tree arm_convert_to_type (tree type, tree expr);
+static bool arm_scalar_mode_supported_p (enum machine_mode);
+static int arm_vector_min_alignment (const_tree type);
+static bool arm_vector_always_misalign(const_tree);
 
 
 /* Initialize the GCC target structure.  */
@@ -256,6 +277,12 @@
 #undef  TARGET_FUNCTION_OK_FOR_SIBCALL
 #define TARGET_FUNCTION_OK_FOR_SIBCALL arm_function_ok_for_sibcall
 
+#undef  TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE arm_function_value
+
+#undef  TARGET_LIBCALL_VALUE
+#define TARGET_LIBCALL_VALUE arm_libcall_value
+
 #undef  TARGET_ASM_OUTPUT_MI_THUNK
 #define TARGET_ASM_OUTPUT_MI_THUNK arm_output_mi_thunk
 #undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK
@@ -299,6 +326,9 @@
 #undef TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS
 #define TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS arm_allocate_stack_slots_for_args
 
+#undef TARGET_WARN_FUNC_RESULT
+#define TARGET_WARN_FUNC_RESULT arm_warn_func_result
+
 #undef TARGET_DEFAULT_SHORT_ENUMS
 #define TARGET_DEFAULT_SHORT_ENUMS arm_default_short_enums
 
@@ -353,6 +383,9 @@
 #undef TARGET_ASM_TTYPE
 #define TARGET_ASM_TTYPE arm_output_ttype
 
+#undef TARGET_CXX_TTYPE_REF_ENCODE
+#define TARGET_CXX_TTYPE_REF_ENCODE hook_cxx_ttype_ref_in_bit0
+
 #undef TARGET_ARM_EABI_UNWINDER
 #define TARGET_ARM_EABI_UNWINDER true
 #endif /* TARGET_UNWIND_INFO */
@@ -360,6 +393,9 @@
 #undef TARGET_DWARF_HANDLE_FRAME_UNSPEC
 #define TARGET_DWARF_HANDLE_FRAME_UNSPEC arm_dwarf_handle_frame_unspec
 
+#undef TARGET_DWARF_REGISTER_SPAN
+#define TARGET_DWARF_REGISTER_SPAN arm_dwarf_register_span
+
 #undef  TARGET_CANNOT_COPY_INSN_P
 #define TARGET_CANNOT_COPY_INSN_P arm_cannot_copy_insn_p
 
@@ -398,6 +434,30 @@
 #define TARGET_ASM_OUTPUT_DWARF_DTPREL arm_output_dwarf_dtprel
 #endif
 
+#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD arm_multipass_dfa_lookahead
+
+#undef TARGET_INVALID_PARAMETER_TYPE
+#define TARGET_INVALID_PARAMETER_TYPE arm_invalid_parameter_type
+
+#undef TARGET_INVALID_RETURN_TYPE
+#define TARGET_INVALID_RETURN_TYPE arm_invalid_return_type
+
+#undef TARGET_PROMOTED_TYPE
+#define TARGET_PROMOTED_TYPE arm_promoted_type
+
+#undef TARGET_CONVERT_TO_TYPE
+#define TARGET_CONVERT_TO_TYPE arm_convert_to_type
+
+#undef TARGET_SCALAR_MODE_SUPPORTED_P
+#define TARGET_SCALAR_MODE_SUPPORTED_P arm_scalar_mode_supported_p
+
+#undef TARGET_VECTOR_MIN_ALIGNMENT
+#define TARGET_VECTOR_MIN_ALIGNMENT arm_vector_min_alignment
+
+#undef TARGET_VECTOR_ALWAYS_MISALIGN
+#define TARGET_VECTOR_ALWAYS_MISALIGN arm_vector_always_misalign
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 /* Obstack for minipool constant handling.  */
@@ -423,18 +483,18 @@
 /* The default processor used if not overridden by commandline.  */
 static enum processor_type arm_default_cpu = arm_none;
 
-/* Which floating point model to use.  */
-enum arm_fp_model arm_fp_model;
-
-/* Which floating point hardware is available.  */
-enum fputype arm_fpu_arch;
-
 /* Which floating point hardware to schedule for.  */
-enum fputype arm_fpu_tune;
+int arm_fpu_attr;
+
+/* Which floating popint hardware to use.  */
+const struct arm_fpu_desc *arm_fpu_desc;
 
 /* Whether to use floating point hardware.  */
 enum float_abi_type arm_float_abi;
 
+/* Which __fp16 format to use.  */
+enum arm_fp16_format_type arm_fp16_format;
+
 /* Which ABI to use.  */
 enum arm_abi_type arm_abi;
 
@@ -473,9 +533,19 @@
 #define FL_DIV	      (1 << 18)	      /* Hardware divide.  */
 #define FL_VFPV3      (1 << 19)       /* Vector Floating Point V3.  */
 #define FL_NEON       (1 << 20)       /* Neon instructions.  */
+#define FL_MARVELL_F  (1 << 21)       /* Marvell Feroceon.  */
+#define FL_ARCH7EM    (1 << 22)	      /* Instructions present in ARMv7E-M.  */
 
 #define FL_IWMMXT     (1 << 29)	      /* XScale v2 or "Intel Wireless MMX technology".  */
 
+/* Some flags are ignored when comparing -mcpu and -march:
+    FL_MARVELL_F so that -mcpu=marvell-f -march=v5te works.
+    FL_LDSCHED and FL_WBUF only effect tuning,
+    FL_CO_PROC, FL_VFPV2, FL_VFPV3 and FL_NEON because FP
+      coprocessors are handled separately.  */
+#define FL_COMPAT (FL_MARVELL_F | FL_LDSCHED | FL_WBUF | FL_CO_PROC | \
+		   FL_VFPV2 | FL_VFPV3 | FL_NEON)
+
 #define FL_FOR_ARCH2	FL_NOTM
 #define FL_FOR_ARCH3	(FL_FOR_ARCH2 | FL_MODE32)
 #define FL_FOR_ARCH3M	(FL_FOR_ARCH3 | FL_ARCH3M)
@@ -497,6 +567,7 @@
 #define FL_FOR_ARCH7A	(FL_FOR_ARCH7 | FL_NOTM)
 #define FL_FOR_ARCH7R	(FL_FOR_ARCH7A | FL_DIV)
 #define FL_FOR_ARCH7M	(FL_FOR_ARCH7 | FL_DIV)
+#define FL_FOR_ARCH7EM  (FL_FOR_ARCH7M | FL_ARCH7EM)
 
 /* The bits in this mask specify which
    instructions we are allowed to generate.  */
@@ -533,6 +604,9 @@
 /* Nonzero if instructions not present in the 'M' profile can be used.  */
 int arm_arch_notm = 0;
 
+/* Nonzero if instructions present in ARMv7E-M can be used.  */
+int arm_arch7em = 0;
+
 /* Nonzero if this chip can benefit from load scheduling.  */
 int arm_ld_sched = 0;
 
@@ -551,6 +625,9 @@
 /* Nonzero if tuning for XScale  */
 int arm_tune_xscale = 0;
 
+/* Nonzero if tuning for Marvell Feroceon.  */
+int arm_tune_marvell_f = 0;
+
 /* Nonzero if we want to tune for stores that access the write-buffer.
    This typically means an ARM6 or ARM7 with MMU or MPU.  */
 int arm_tune_wbuf = 0;
@@ -561,6 +638,9 @@
 /* Nonzero if generating Thumb instructions.  */
 int thumb_code = 0;
 
+/* Nonzero if generating code for Janus2. */
+int janus2_code = 0;
+
 /* Nonzero if we should define __THUMB_INTERWORK__ in the
    preprocessor.
    XXX This is a bit of a hack, it's intended to help work around
@@ -593,6 +673,8 @@
 /* The maximum number of insns to be used when loading a constant.  */
 static int arm_constant_limit = 3;
 
+static enum arm_pcs arm_pcs_default;
+
 /* For an explanation of these variables, see final_prescan_insn below.  */
 int arm_ccfsm_state;
 /* arm_current_cc is also used for Thumb-2 cond_exec blocks.  */
@@ -673,9 +755,11 @@
   {"armv7-a", cortexa8,	  "7A",	 FL_CO_PROC |		  FL_FOR_ARCH7A, NULL},
   {"armv7-r", cortexr4,	  "7R",	 FL_CO_PROC |		  FL_FOR_ARCH7R, NULL},
   {"armv7-m", cortexm3,	  "7M",	 FL_CO_PROC |		  FL_FOR_ARCH7M, NULL},
+  {"armv7e-m",   cortexm3, "7EM", FL_CO_PROC |		  FL_FOR_ARCH7EM, NULL},
   {"ep9312",  ep9312,     "4T",  FL_LDSCHED | FL_CIRRUS | FL_FOR_ARCH4, NULL},
   {"iwmmxt",  iwmmxt,     "5TE", FL_LDSCHED | FL_STRONG | FL_FOR_ARCH5TE | FL_XSCALE | FL_IWMMXT , NULL},
   {"iwmmxt2", iwmmxt2,     "5TE", FL_LDSCHED | FL_STRONG | FL_FOR_ARCH5TE | FL_XSCALE | FL_IWMMXT , NULL},
+  {"marvell-f", marvell_f, "5TE", FL_CO_PROC | FL_FOR_ARCH5TE | FL_MARVELL_F, NULL},
   {NULL, arm_none, NULL, 0 , NULL}
 };
 
@@ -705,49 +789,34 @@
 
 /* The name of the preprocessor macro to define for this architecture.  */
 
-char arm_arch_name[] = "__ARM_ARCH_0UNK__";
-
-struct fpu_desc
-{
-  const char * name;
-  enum fputype fpu;
-};
-
+#define ARM_ARCH_NAME_SIZE 25
+char arm_arch_name[ARM_ARCH_NAME_SIZE] = "__ARM_ARCH_0UNK__";
 
 /* Available values for -mfpu=.  */
 
-static const struct fpu_desc all_fpus[] =
+static const struct arm_fpu_desc all_fpus[] =
 {
-  {"fpa",	FPUTYPE_FPA},
-  {"fpe2",	FPUTYPE_FPA_EMU2},
-  {"fpe3",	FPUTYPE_FPA_EMU2},
-  {"maverick",	FPUTYPE_MAVERICK},
-  {"vfp",	FPUTYPE_VFP},
-  {"vfp3",	FPUTYPE_VFP3},
-  {"vfpv3",	FPUTYPE_VFP3},
-  {"vfpv3-d16",	FPUTYPE_VFP3D16},
-  {"neon",	FPUTYPE_NEON}
+  {"fpa",		ARM_FP_MODEL_FPA, 0, 0, false, false},
+  {"fpe2",		ARM_FP_MODEL_FPA, 2, 0, false, false},
+  {"fpe3",		ARM_FP_MODEL_FPA, 3, 0, false, false},
+  {"maverick",		ARM_FP_MODEL_MAVERICK, 0, 0, false, false},
+  {"vfp",		ARM_FP_MODEL_VFP, 2, VFP_REG_D16, false, false},
+  {"vfpv3",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, false},
+  {"vfpv3-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, true },
+  {"vfpv3-d16",		ARM_FP_MODEL_VFP, 3, VFP_REG_D16, false, false},
+  {"vfpv3xd",		ARM_FP_MODEL_VFP, 3, VFP_REG_SINGLE, false, false},
+  {"vfpv3xd-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_SINGLE, false, true },
+  {"vfpv3-d16-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D16, false, true },
+  {"neon",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, true , false},
+  {"neon-fp16",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, true , true },
+  {"vfpv4",		ARM_FP_MODEL_VFP, 4, VFP_REG_D32, false, true },
+  {"vfpv4-d16",		ARM_FP_MODEL_VFP, 4, VFP_REG_D16, false, true },
+  {"fpv4-sp-d16",	ARM_FP_MODEL_VFP, 4, VFP_REG_SINGLE, false, true },
+  {"neon-vfpv4",	ARM_FP_MODEL_VFP, 4, VFP_REG_D32, true , true },
+  /* Compatibility aliases.  */
+  {"vfp3",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, false},
 };
 
-
-/* Floating point models used by the different hardware.
-   See fputype in arm.h.  */
-
-static const enum fputype fp_model_for_fpu[] =
-{
-  /* No FP hardware.  */
-  ARM_FP_MODEL_UNKNOWN,		/* FPUTYPE_NONE  */
-  ARM_FP_MODEL_FPA,		/* FPUTYPE_FPA  */
-  ARM_FP_MODEL_FPA,		/* FPUTYPE_FPA_EMU2  */
-  ARM_FP_MODEL_FPA,		/* FPUTYPE_FPA_EMU3  */
-  ARM_FP_MODEL_MAVERICK,	/* FPUTYPE_MAVERICK  */
-  ARM_FP_MODEL_VFP,		/* FPUTYPE_VFP  */
-  ARM_FP_MODEL_VFP,		/* FPUTYPE_VFP3D16  */
-  ARM_FP_MODEL_VFP,		/* FPUTYPE_VFP3  */
-  ARM_FP_MODEL_VFP		/* FPUTYPE_NEON  */
-};
-
-
 struct float_abi
 {
   const char * name;
@@ -765,6 +834,23 @@
 };
 
 
+struct fp16_format
+{
+  const char *name;
+  enum arm_fp16_format_type fp16_format_type;
+};
+
+
+/* Available values for -mfp16-format=.  */
+
+static const struct fp16_format all_fp16_formats[] =
+{
+  {"none",		ARM_FP16_FORMAT_NONE},
+  {"ieee",		ARM_FP16_FORMAT_IEEE},
+  {"alternative",	ARM_FP16_FORMAT_ALTERNATIVE}
+};
+
+
 struct abi_name
 {
   const char *name;
@@ -922,6 +1008,44 @@
   set_optab_libfunc (umod_optab, DImode, NULL);
   set_optab_libfunc (smod_optab, SImode, NULL);
   set_optab_libfunc (umod_optab, SImode, NULL);
+
+  /* Half-precision float operations.  The compiler handles all operations
+     with NULL libfuncs by converting the SFmode.  */
+  switch (arm_fp16_format)
+    {
+    case ARM_FP16_FORMAT_IEEE:
+    case ARM_FP16_FORMAT_ALTERNATIVE:
+
+      /* Conversions.  */
+      set_conv_libfunc (trunc_optab, HFmode, SFmode,
+			(arm_fp16_format == ARM_FP16_FORMAT_IEEE
+			 ? "__gnu_f2h_ieee"
+			 : "__gnu_f2h_alternative"));
+      set_conv_libfunc (sext_optab, SFmode, HFmode, 
+			(arm_fp16_format == ARM_FP16_FORMAT_IEEE
+			 ? "__gnu_h2f_ieee"
+			 : "__gnu_h2f_alternative"));
+      
+      /* Arithmetic.  */
+      set_optab_libfunc (add_optab, HFmode, NULL);
+      set_optab_libfunc (sdiv_optab, HFmode, NULL);
+      set_optab_libfunc (smul_optab, HFmode, NULL);
+      set_optab_libfunc (neg_optab, HFmode, NULL);
+      set_optab_libfunc (sub_optab, HFmode, NULL);
+
+      /* Comparisons.  */
+      set_optab_libfunc (eq_optab, HFmode, NULL);
+      set_optab_libfunc (ne_optab, HFmode, NULL);
+      set_optab_libfunc (lt_optab, HFmode, NULL);
+      set_optab_libfunc (le_optab, HFmode, NULL);
+      set_optab_libfunc (ge_optab, HFmode, NULL);
+      set_optab_libfunc (gt_optab, HFmode, NULL);
+      set_optab_libfunc (unord_optab, HFmode, NULL);
+      break;
+
+    default:
+      break;
+    }
 }
 
 /* On AAPCS systems, this is the "struct __va_list".  */
@@ -1135,6 +1259,7 @@
 arm_override_options (void)
 {
   unsigned i;
+  int len;
   enum processor_type target_arch_cpu = arm_none;
   enum processor_type selected_cpu = arm_none;
 
@@ -1152,7 +1277,11 @@
               {
 		/* Set the architecture define.  */
 		if (i != ARM_OPT_SET_TUNE)
-		  sprintf (arm_arch_name, "__ARM_ARCH_%s__", sel->arch);
+		  {
+		    len = snprintf (arm_arch_name, ARM_ARCH_NAME_SIZE,
+				    "__ARM_ARCH_%s__", sel->arch);
+		    gcc_assert (len < ARM_ARCH_NAME_SIZE);
+		  }
 
 		/* Determine the processor core for which we should
 		   tune code-generation.  */
@@ -1178,8 +1307,8 @@
 		       make sure that they are compatible.  We only generate
 		       a warning though, and we prefer the CPU over the
 		       architecture.  */
-		    if (insn_flags != 0 && (insn_flags ^ sel->flags))
-		      warning (0, "switch -mcpu=%s conflicts with -march= switch",
+		    if (insn_flags != 0 && ((insn_flags ^ sel->flags) & ~FL_COMPAT))
+		      warning (0, "switch -mcpu=%s conflicts with -march= switch, assuming CPU feature set",
 			       ptr->string);
 
 		    insn_flags = sel->flags;
@@ -1279,7 +1408,11 @@
 
 	  insn_flags = sel->flags;
 	}
-      sprintf (arm_arch_name, "__ARM_ARCH_%s__", sel->arch);
+
+      len = snprintf (arm_arch_name, ARM_ARCH_NAME_SIZE,
+		      "__ARM_ARCH_%s__", sel->arch);
+      gcc_assert (len < ARM_ARCH_NAME_SIZE);
+
       arm_default_cpu = (enum processor_type) (sel - all_cores);
       if (arm_tune == arm_none)
 	arm_tune = arm_default_cpu;
@@ -1289,8 +1422,35 @@
      chosen.  */
   gcc_assert (arm_tune != arm_none);
 
+  if (arm_tune == cortexa8 && optimize >= 3)
+    {
+      /* These alignments were experimentally determined to improve SPECint
+	 performance on SPECCPU 2000.  */
+      if (align_functions <= 0)
+	align_functions = 16;
+      if (align_jumps <= 0)
+	align_jumps = 16;
+    }
+
   tune_flags = all_cores[(int)arm_tune].flags;
 
+  if (target_fp16_format_name)
+    {
+      for (i = 0; i < ARRAY_SIZE (all_fp16_formats); i++)
+	{
+	  if (streq (all_fp16_formats[i].name, target_fp16_format_name))
+	    {
+	      arm_fp16_format = all_fp16_formats[i].fp16_format_type;
+	      break;
+	    }
+	}
+      if (i == ARRAY_SIZE (all_fp16_formats))
+	error ("invalid __fp16 format option: -mfp16-format=%s",
+	       target_fp16_format_name);
+    }
+  else
+    arm_fp16_format = ARM_FP16_FORMAT_NONE;
+
   if (target_abi_name)
     {
       for (i = 0; i < ARRAY_SIZE (arm_all_abis); i++)
@@ -1383,6 +1543,7 @@
   arm_arch6 = (insn_flags & FL_ARCH6) != 0;
   arm_arch6k = (insn_flags & FL_ARCH6K) != 0;
   arm_arch_notm = (insn_flags & FL_NOTM) != 0;
+  arm_arch7em = (insn_flags & FL_ARCH7EM) != 0;
   arm_arch_thumb2 = (insn_flags & FL_THUMB2) != 0;
   arm_arch_xscale = (insn_flags & FL_XSCALE) != 0;
   arm_arch_cirrus = (insn_flags & FL_CIRRUS) != 0;
@@ -1390,12 +1551,25 @@
   arm_ld_sched = (tune_flags & FL_LDSCHED) != 0;
   arm_tune_strongarm = (tune_flags & FL_STRONG) != 0;
   thumb_code = (TARGET_ARM == 0);
+  janus2_code = (TARGET_FIX_JANUS != 0);
+  if (janus2_code && TARGET_THUMB2)
+    error ("janus2 fix is not applicable when targeting a thumb2 core");
   arm_tune_wbuf = (tune_flags & FL_WBUF) != 0;
   arm_tune_xscale = (tune_flags & FL_XSCALE) != 0;
+  arm_tune_marvell_f = (tune_flags & FL_MARVELL_F) != 0;
   arm_arch_iwmmxt = (insn_flags & FL_IWMMXT) != 0;
-  arm_arch_hwdiv = (insn_flags & FL_DIV) != 0;
   arm_tune_cortex_a9 = (arm_tune == cortexa9) != 0;
 
+ /* Hardware integer division is supported by some variants of the ARM
+    architecture in Thumb-2 mode.  In addition some (but not all) Marvell
+    CPUs support their own hardware integer division instructions.
+    The assembler will pick the correct encoding.  */
+  if (TARGET_MARVELL_DIV && (insn_flags & FL_MARVELL_F) == 0)
+    error ("-mmarvell-div is only supported when targeting a Marvell core");
+
+  arm_arch_hwdiv = (TARGET_ARM && TARGET_MARVELL_DIV)
+		   || (TARGET_THUMB2 && (insn_flags & FL_DIV) != 0);
+
   /* If we are not using the default (ARM mode) section anchor offset
      ranges, then set the correct ranges now.  */
   if (TARGET_THUMB1)
@@ -1434,7 +1608,6 @@
   if (TARGET_IWMMXT_ABI && !TARGET_IWMMXT)
     error ("iwmmxt abi requires an iwmmxt capable cpu");
 
-  arm_fp_model = ARM_FP_MODEL_UNKNOWN;
   if (target_fpu_name == NULL && target_fpe_name != NULL)
     {
       if (streq (target_fpe_name, "2"))
@@ -1445,46 +1618,52 @@
 	error ("invalid floating point emulation option: -mfpe=%s",
 	       target_fpe_name);
     }
-  if (target_fpu_name != NULL)
-    {
-      /* The user specified a FPU.  */
-      for (i = 0; i < ARRAY_SIZE (all_fpus); i++)
-	{
-	  if (streq (all_fpus[i].name, target_fpu_name))
-	    {
-	      arm_fpu_arch = all_fpus[i].fpu;
-	      arm_fpu_tune = arm_fpu_arch;
-	      arm_fp_model = fp_model_for_fpu[arm_fpu_arch];
-	      break;
-	    }
-	}
-      if (arm_fp_model == ARM_FP_MODEL_UNKNOWN)
-	error ("invalid floating point option: -mfpu=%s", target_fpu_name);
-    }
-  else
+
+  if (target_fpu_name == NULL)
     {
 #ifdef FPUTYPE_DEFAULT
-      /* Use the default if it is specified for this platform.  */
-      arm_fpu_arch = FPUTYPE_DEFAULT;
-      arm_fpu_tune = FPUTYPE_DEFAULT;
+      target_fpu_name = FPUTYPE_DEFAULT;
 #else
-      /* Pick one based on CPU type.  */
-      /* ??? Some targets assume FPA is the default.
-      if ((insn_flags & FL_VFP) != 0)
-	arm_fpu_arch = FPUTYPE_VFP;
-      else
-      */
       if (arm_arch_cirrus)
-	arm_fpu_arch = FPUTYPE_MAVERICK;
+	target_fpu_name = "maverick";
       else
-	arm_fpu_arch = FPUTYPE_FPA_EMU2;
+	target_fpu_name = "fpe2";
 #endif
-      if (tune_flags & FL_CO_PROC && arm_fpu_arch == FPUTYPE_FPA_EMU2)
-	arm_fpu_tune = FPUTYPE_FPA;
+    }
+
+  arm_fpu_desc = NULL;
+  for (i = 0; i < ARRAY_SIZE (all_fpus); i++)
+    {
+      if (streq (all_fpus[i].name, target_fpu_name))
+	{
+	  arm_fpu_desc = &all_fpus[i];
+	  break;
+	}
+    }
+  if (!arm_fpu_desc)
+    error ("invalid floating point option: -mfpu=%s", target_fpu_name);
+
+  switch (arm_fpu_desc->model)
+    {
+    case ARM_FP_MODEL_FPA:
+      if (arm_fpu_desc->rev == 2)
+	arm_fpu_attr = FPU_FPE2;
+      else if (arm_fpu_desc->rev == 3)
+	arm_fpu_attr = FPU_FPE3;
       else
-	arm_fpu_tune = arm_fpu_arch;
-      arm_fp_model = fp_model_for_fpu[arm_fpu_arch];
-      gcc_assert (arm_fp_model != ARM_FP_MODEL_UNKNOWN);
+	arm_fpu_attr = FPU_FPA;
+      break;
+
+    case ARM_FP_MODEL_MAVERICK:
+      arm_fpu_attr = FPU_MAVERICK;
+      break;
+
+    case ARM_FP_MODEL_VFP:
+      arm_fpu_attr = FPU_VFP;
+      break;
+
+    default:
+      gcc_unreachable();
     }
 
   if (target_float_abi_name != NULL)
@@ -1505,9 +1684,6 @@
   else
     arm_float_abi = TARGET_DEFAULT_FLOAT_ABI;
 
-  if (arm_float_abi == ARM_FLOAT_ABI_HARD && TARGET_VFP)
-    sorry ("-mfloat-abi=hard and VFP");
-
   /* FPA and iWMMXt are incompatible because the insn encodings overlap.
      VFP and iWMMXt can theoretically coexist, but it's unlikely such silicon
      will ever exist.  GCC makes no attempt to support this combination.  */
@@ -1518,15 +1694,40 @@
   if (TARGET_THUMB2 && TARGET_IWMMXT)
     sorry ("Thumb-2 iWMMXt");
 
+  /* __fp16 support currently assumes the core has ldrh.  */
+  if (!arm_arch4 && arm_fp16_format != ARM_FP16_FORMAT_NONE)
+    sorry ("__fp16 and no ldrh");
+
   /* If soft-float is specified then don't use FPU.  */
   if (TARGET_SOFT_FLOAT)
-    arm_fpu_arch = FPUTYPE_NONE;
+    arm_fpu_attr = FPU_NONE;
+
+  if (TARGET_AAPCS_BASED)
+    {
+      if (arm_abi == ARM_ABI_IWMMXT)
+	arm_pcs_default = ARM_PCS_AAPCS_IWMMXT;
+      else if (arm_float_abi == ARM_FLOAT_ABI_HARD
+	       && TARGET_HARD_FLOAT
+	       && TARGET_VFP)
+	arm_pcs_default = ARM_PCS_AAPCS_VFP;
+      else
+	arm_pcs_default = ARM_PCS_AAPCS;
+    }
+  else
+    {
+      if (arm_float_abi == ARM_FLOAT_ABI_HARD && TARGET_VFP)
+	sorry ("-mfloat-abi=hard and VFP");
+
+      if (arm_abi == ARM_ABI_APCS)
+	arm_pcs_default = ARM_PCS_APCS;
+      else
+	arm_pcs_default = ARM_PCS_ATPCS;
+    }
 
   /* For arm2/3 there is no need to do any scheduling if there is only
      a floating point emulator, or we are doing software floating-point.  */
   if ((TARGET_SOFT_FLOAT
-       || arm_fpu_tune == FPUTYPE_FPA_EMU2
-       || arm_fpu_tune == FPUTYPE_FPA_EMU3)
+       || (TARGET_FPA && arm_fpu_desc->rev))
       && (tune_flags & FL_MODE32) == 0)
     flag_schedule_insns = flag_schedule_insns_after_reload = 0;
 
@@ -1616,8 +1817,7 @@
 	fix_cm3_ldrd = 0;
     }
 
-  /* ??? We might want scheduling for thumb2.  */
-  if (TARGET_THUMB && flag_schedule_insns)
+  if (TARGET_THUMB1 && flag_schedule_insns)
     {
       /* Don't warn since it's on by default in -O2.  */
       flag_schedule_insns = 0;
@@ -1653,6 +1853,36 @@
 
   /* Register global variables with the garbage collector.  */
   arm_add_gc_roots ();
+
+  if (low_irq_latency && TARGET_THUMB)
+    {
+      warning (0, 
+	       "-low-irq-latency has no effect when compiling for the Thumb");
+      low_irq_latency = 0;
+    }
+
+  /* CSL LOCAL */
+  /* Loop unrolling can be a substantial win.  At -O2, limit to 2x
+     unrolling by default to prevent excessive code growth; at -O3,
+     limit to 4x unrolling by default.  We know we are not optimizing
+     for size if this is set (see arm_optimization_options).  */
+  if (flag_unroll_loops == 2)
+    {
+      if (optimize == 2)
+	{
+	  flag_unroll_loops = 1;
+	  if (!PARAM_SET_P (PARAM_MAX_UNROLL_TIMES))
+	    set_param_value ("max-unroll-times", 2);
+	}
+      else if (optimize > 2)
+	{
+	  flag_unroll_loops = 1;
+	  if (!PARAM_SET_P (PARAM_MAX_UNROLL_TIMES))
+	    set_param_value ("max-unroll-times", 4);
+	}
+      else
+	flag_unroll_loops = 0;
+    }
 }
 
 static void
@@ -1782,6 +2012,14 @@
   return !IS_NAKED (arm_current_func_type ());
 }
 
+static bool
+arm_warn_func_result (void)
+{
+  /* Naked functions are implemented entirely in assembly, including the
+     return sequence, so suppress warnings about this.  */
+  return !IS_NAKED (arm_current_func_type ());
+}
+
 
 /* Return 1 if it is possible to return using a single instruction.
    If SIBLING is non-null, this is a test for a return before a sibling
@@ -2873,14 +3111,19 @@
 
 /* Define how to find the value returned by a function.  */
 
-rtx
-arm_function_value(const_tree type, const_tree func ATTRIBUTE_UNUSED)
+static rtx
+arm_function_value(const_tree type, const_tree func,
+		   bool outgoing ATTRIBUTE_UNUSED)
 {
   enum machine_mode mode;
   int unsignedp ATTRIBUTE_UNUSED;
   rtx r ATTRIBUTE_UNUSED;
 
   mode = TYPE_MODE (type);
+
+  if (TARGET_AAPCS_BASED)
+    return aapcs_allocate_return_reg (mode, type, func);
+
   /* Promote integer types.  */
   if (INTEGRAL_TYPE_P (type))
     PROMOTE_FUNCTION_MODE (mode, unsignedp, type);
@@ -2897,7 +3140,36 @@
 	}
     }
 
-  return LIBCALL_VALUE(mode);
+  return LIBCALL_VALUE (mode);
+}
+
+rtx
+arm_libcall_value (enum machine_mode mode, rtx libcall)
+{
+  if (TARGET_AAPCS_BASED && arm_pcs_default != ARM_PCS_AAPCS
+      && GET_MODE_CLASS (mode) == MODE_FLOAT)
+    {
+      /* The following libcalls return their result in integer registers,
+	 even though they return a floating point value.  */
+      if (rtx_equal_p (libcall,
+		       convert_optab_libfunc (sfloat_optab, mode, SImode))
+	  || rtx_equal_p (libcall,
+			  convert_optab_libfunc (ufloat_optab, mode, SImode))
+	  || rtx_equal_p (libcall,
+			  convert_optab_libfunc (sfloat_optab, mode, DImode))
+	  || rtx_equal_p (libcall,
+			  convert_optab_libfunc (ufloat_optab, mode, DImode))
+	  || rtx_equal_p (libcall,
+			  convert_optab_libfunc (trunc_optab, HFmode, SFmode))
+	  || rtx_equal_p (libcall,
+			  convert_optab_libfunc (sext_optab, SFmode, HFmode)))
+	return gen_rtx_REG (mode, ARG_REGISTER(1));
+
+      /* XXX There are other libcalls that return in integer registers,
+	 but I think they are all handled by hard insns.  */
+    }
+
+  return LIBCALL_VALUE (mode);
 }
 
 /* Determine the amount of memory needed to store the possible return
@@ -2907,10 +3179,12 @@
 {
   int size = 16;
 
-  if (TARGET_ARM)
+  if (TARGET_32BIT)
     {
       if (TARGET_HARD_FLOAT_ABI)
 	{
+	  if (TARGET_VFP)
+	    size += 32;
 	  if (TARGET_FPA)
 	    size += 12;
 	  if (TARGET_MAVERICK)
@@ -2923,27 +3197,56 @@
   return size;
 }
 
-/* Decide whether a type should be returned in memory (true)
-   or in a register (false).  This is called as the target hook
-   TARGET_RETURN_IN_MEMORY.  */
+/* Decide whether TYPE should be returned in memory (true)
+   or in a register (false).  FNTYPE is the type of the function making
+   the call.  */
 static bool
-arm_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
+arm_return_in_memory (const_tree type, const_tree fntype)
 {
   HOST_WIDE_INT size;
 
-  size = int_size_in_bytes (type);
+  size = int_size_in_bytes (type);  /* Negative if not fixed size.  */
+
+  if (TARGET_AAPCS_BASED)
+    {
+      /* Simple, non-aggregate types (ie not including vectors and
+	 complex) are always returned in a register (or registers).
+	 We don't care about which register here, so we can short-cut
+	 some of the detail.  */
+      if (!AGGREGATE_TYPE_P (type)
+	  && TREE_CODE (type) != VECTOR_TYPE
+	  && TREE_CODE (type) != COMPLEX_TYPE)
+	return false;
+
+      /* Any return value that is no larger than one word can be
+	 returned in r0.  */
+      if (((unsigned HOST_WIDE_INT) size) <= UNITS_PER_WORD)
+	return false;
+
+      /* Check any available co-processors to see if they accept the
+	 type as a register candidate (VFP, for example, can return
+	 some aggregates in consecutive registers).  These aren't
+	 available if the call is variadic.  */
+      if (aapcs_select_return_coproc (type, fntype) >= 0)
+	return false;
+
+      /* Vector values should be returned using ARM registers, not
+	 memory (unless they're over 16 bytes, which will break since
+	 we only have four call-clobbered registers to play with).  */
+      if (TREE_CODE (type) == VECTOR_TYPE)
+	return (size < 0 || size > (4 * UNITS_PER_WORD));
+
+      /* The rest go in memory.  */
+      return true;
+    }
 
-  /* Vector values should be returned using ARM registers, not memory (unless
-     they're over 16 bytes, which will break since we only have four
-     call-clobbered registers to play with).  */
   if (TREE_CODE (type) == VECTOR_TYPE)
     return (size < 0 || size > (4 * UNITS_PER_WORD));
 
   if (!AGGREGATE_TYPE_P (type) &&
-      !(TARGET_AAPCS_BASED && TREE_CODE (type) == COMPLEX_TYPE))
-    /* All simple types are returned in registers.
-       For AAPCS, complex types are treated the same as aggregates.  */
-    return 0;
+      (TREE_CODE (type) != VECTOR_TYPE))
+    /* All simple types are returned in registers.  */
+    return false;
 
   if (arm_abi != ARM_ABI_APCS)
     {
@@ -2960,7 +3263,7 @@
      the aggregate is either huge or of variable size, and in either case
      we will want to return it via memory and not in a register.  */
   if (size < 0 || size > UNITS_PER_WORD)
-    return 1;
+    return true;
 
   if (TREE_CODE (type) == RECORD_TYPE)
     {
@@ -2980,18 +3283,18 @@
 	continue;
 
       if (field == NULL)
-	return 0; /* An empty structure.  Allowed by an extension to ANSI C.  */
+	return false; /* An empty structure.  Allowed by an extension to ANSI C.  */
 
       /* Check that the first field is valid for returning in a register.  */
 
       /* ... Floats are not allowed */
       if (FLOAT_TYPE_P (TREE_TYPE (field)))
-	return 1;
+	return true;
 
       /* ... Aggregates that are not themselves valid for returning in
 	 a register are not allowed.  */
       if (arm_return_in_memory (TREE_TYPE (field), NULL_TREE))
-	return 1;
+	return true;
 
       /* Now check the remaining fields, if any.  Only bitfields are allowed,
 	 since they are not addressable.  */
@@ -3003,10 +3306,10 @@
 	    continue;
 
 	  if (!DECL_BIT_FIELD_TYPE (field))
-	    return 1;
+	    return true;
 	}
 
-      return 0;
+      return false;
     }
 
   if (TREE_CODE (type) == UNION_TYPE)
@@ -3023,18 +3326,18 @@
 	    continue;
 
 	  if (FLOAT_TYPE_P (TREE_TYPE (field)))
-	    return 1;
+	    return true;
 
 	  if (arm_return_in_memory (TREE_TYPE (field), NULL_TREE))
-	    return 1;
+	    return true;
 	}
 
-      return 0;
+      return false;
     }
 #endif /* not ARM_WINCE */
 
   /* Return all other types in memory.  */
-  return 1;
+  return true;
 }
 
 /* Indicate whether or not words of a double are in big-endian order.  */
@@ -3059,14 +3362,780 @@
   return 1;
 }
 
+const struct pcs_attribute_arg
+{
+  const char *arg;
+  enum arm_pcs value;
+} pcs_attribute_args[] =
+  {
+    {"aapcs", ARM_PCS_AAPCS},
+    {"aapcs-vfp", ARM_PCS_AAPCS_VFP},
+    {"aapcs-iwmmxt", ARM_PCS_AAPCS_IWMMXT},
+    {"atpcs", ARM_PCS_ATPCS},
+    {"apcs", ARM_PCS_APCS},
+    {NULL, ARM_PCS_UNKNOWN}
+  };
+
+static enum arm_pcs
+arm_pcs_from_attribute (tree attr)
+{
+  const struct pcs_attribute_arg *ptr;
+  const char *arg;
+
+  /* Get the value of the argument.  */
+  if (TREE_VALUE (attr) == NULL_TREE
+      || TREE_CODE (TREE_VALUE (attr)) != STRING_CST)
+    return ARM_PCS_UNKNOWN;
+
+  arg = TREE_STRING_POINTER (TREE_VALUE (attr));
+
+  /* Check it against the list of known arguments.  */
+  for (ptr = pcs_attribute_args; ptr->arg != NULL; ptr++)
+    if (streq (arg, ptr->arg))
+      return ptr->value;
+
+  /* An unrecognized interrupt type.  */
+  return ARM_PCS_UNKNOWN;
+}
+
+/* Get the PCS variant to use for this call.  TYPE is the function's type
+   specification, DECL is the specific declartion.  DECL may be null if
+   the call could be indirect or if this is a library call.  */
+static enum arm_pcs
+arm_get_pcs_model (const_tree type, const_tree decl)
+{
+  bool user_convention = false;
+  enum arm_pcs user_pcs = arm_pcs_default;
+  tree attr;
+
+  gcc_assert (type);
+
+  attr = lookup_attribute ("pcs", TYPE_ATTRIBUTES (type));
+  if (attr)
+    {
+      user_pcs = arm_pcs_from_attribute (TREE_VALUE (attr));
+      user_convention = true;
+    }
+
+  if (TARGET_AAPCS_BASED)
+    {
+      /* Detect varargs functions.  These always use the base rules
+	 (no argument is ever a candidate for a co-processor
+	 register).  */
+      bool base_rules = (TYPE_ARG_TYPES (type) != 0
+			 && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (type)))
+			     != void_type_node));
+      
+      if (user_convention)
+	{
+	  if (user_pcs > ARM_PCS_AAPCS_LOCAL)
+	    sorry ("Non-AAPCS derived PCS variant");
+	  else if (base_rules && user_pcs != ARM_PCS_AAPCS)
+	    error ("Variadic functions must use the base AAPCS variant");
+	}
+
+      if (base_rules)
+	return ARM_PCS_AAPCS;
+      else if (user_convention)
+	return user_pcs;
+      else if (decl && flag_unit_at_a_time)
+	{
+	  /* Local functions never leak outside this compilation unit,
+	     so we are free to use whatever conventions are
+	     appropriate.  */
+	  /* FIXME: remove CONST_CAST_TREE when cgraph is constified.  */
+	  struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE(decl));
+	  if (i && i->local)
+	    return ARM_PCS_AAPCS_LOCAL;
+	}
+    }
+  else if (user_convention && user_pcs != arm_pcs_default)
+    sorry ("PCS variant");
+
+  /* For everything else we use the target's default.  */
+  return arm_pcs_default;
+}
+
+
+static void
+aapcs_vfp_cum_init (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,
+		    const_tree fntype ATTRIBUTE_UNUSED,
+		    rtx libcall ATTRIBUTE_UNUSED, 
+		    const_tree fndecl ATTRIBUTE_UNUSED)
+{
+  /* Record the unallocated VFP registers.  */
+  pcum->aapcs_vfp_regs_free = (1 << NUM_VFP_ARG_REGS) - 1;
+  pcum->aapcs_vfp_reg_alloc = 0;
+}
+
+/* Walk down the type tree of TYPE counting consecutive base elements.
+   If *MODEP is VOIDmode, then set it to the first valid floating point
+   type.  If a non-floating point type is found, or if a floating point
+   type that doesn't match a non-VOIDmode *MODEP is found, then return -1,
+   otherwise return the count in the sub-tree.  */
+static int
+aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)
+{
+  enum machine_mode mode;
+  HOST_WIDE_INT size;
+
+  switch (TREE_CODE (type))
+    {
+    case REAL_TYPE:
+      mode = TYPE_MODE (type);
+      if (mode != DFmode && mode != SFmode)
+	return -1;
+
+      if (*modep == VOIDmode)
+	*modep = mode;
+
+      if (*modep == mode)
+	return 1;
+
+      break;
+
+    case COMPLEX_TYPE:
+      mode = TYPE_MODE (TREE_TYPE (type));
+      if (mode != DFmode && mode != SFmode)
+	return -1;
+
+      if (*modep == VOIDmode)
+	*modep = mode;
+
+      if (*modep == mode)
+	return 2;
+
+      break;
+
+    case VECTOR_TYPE:
+      /* Use V2SImode and V4SImode as representatives of all 64-bit
+	 and 128-bit vector types, whether or not those modes are
+	 supported with the present options.  */
+      size = int_size_in_bytes (type);
+      switch (size)
+	{
+	case 8:
+	  mode = V2SImode;
+	  break;
+	case 16:
+	  mode = V4SImode;
+	  break;
+	default:
+	  return -1;
+	}
+
+      if (*modep == VOIDmode)
+	*modep = mode;
+
+      /* Vector modes are considered to be opaque: two vectors are
+	 equivalent for the purposes of being homogeneous aggregates
+	 if they are the same size.  */
+      if (*modep == mode)
+	return 1;
+
+      break;
+
+    case ARRAY_TYPE:
+      {
+	int count;
+	tree index = TYPE_DOMAIN (type);
+
+	/* Can't handle incomplete types.  */
+	if (!COMPLETE_TYPE_P(type))
+	  return -1;
+
+	count = aapcs_vfp_sub_candidate (TREE_TYPE (type), modep);
+	if (count == -1
+	    || !index
+	    || !TYPE_MAX_VALUE (index)
+	    || !host_integerp (TYPE_MAX_VALUE (index), 1)
+	    || !TYPE_MIN_VALUE (index)
+	    || !host_integerp (TYPE_MIN_VALUE (index), 1)
+	    || count < 0)
+	  return -1;
+
+	count *= (1 + tree_low_cst (TYPE_MAX_VALUE (index), 1)
+		      - tree_low_cst (TYPE_MIN_VALUE (index), 1));
+
+	/* There must be no padding.  */
+	if (!host_integerp (TYPE_SIZE (type), 1)
+	    || (tree_low_cst (TYPE_SIZE (type), 1)
+		!= count * GET_MODE_BITSIZE (*modep)))
+	  return -1;
+
+	return count;
+      }
+      
+    case RECORD_TYPE:
+      {
+	int count = 0;
+	int sub_count;
+	tree field;
+
+	/* Can't handle incomplete types.  */
+	if (!COMPLETE_TYPE_P(type))
+	  return -1;
+
+	for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))
+	  {
+	    if (TREE_CODE (field) != FIELD_DECL)
+	      continue;
+
+	    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep);
+	    if (sub_count < 0)
+	      return -1;
+	    count += sub_count;
+	  }
+
+	/* There must be no padding.  */
+	if (!host_integerp (TYPE_SIZE (type), 1)
+	    || (tree_low_cst (TYPE_SIZE (type), 1)
+		!= count * GET_MODE_BITSIZE (*modep)))
+	  return -1;
+
+	return count;
+      }
+
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+      {
+	/* These aren't very interesting except in a degenerate case.  */
+	int count = 0;
+	int sub_count;
+	tree field;
+
+	/* Can't handle incomplete types.  */
+	if (!COMPLETE_TYPE_P(type))
+	  return -1;
+
+	for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))
+	  {
+	    if (TREE_CODE (field) != FIELD_DECL)
+	      continue;
+
+	    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep);
+	    if (sub_count < 0)
+	      return -1;
+	    count = count > sub_count ? count : sub_count;
+	  }
+
+	/* There must be no padding.  */
+	if (!host_integerp (TYPE_SIZE (type), 1)
+	    || (tree_low_cst (TYPE_SIZE (type), 1)
+		!= count * GET_MODE_BITSIZE (*modep)))
+	  return -1;
+
+	return count;
+      }
+
+    default:
+      break;
+    }
+
+  return -1;
+}
+
+/* Return true if PCS_VARIANT should use VFP registers.  */
+static bool
+use_vfp_abi (enum arm_pcs pcs_variant, bool is_double)
+{
+  if (pcs_variant == ARM_PCS_AAPCS_VFP)
+    return true;
+
+  if (pcs_variant != ARM_PCS_AAPCS_LOCAL)
+    return false;
+
+  return (TARGET_32BIT && TARGET_VFP && TARGET_HARD_FLOAT &&
+	  (TARGET_VFP_DOUBLE || !is_double));
+}
+
+static bool
+aapcs_vfp_is_call_or_return_candidate (enum arm_pcs pcs_variant,
+				       enum machine_mode mode, const_tree type,
+				       int *base_mode, int *count)
+{
+  enum machine_mode new_mode = VOIDmode;
+
+  if (GET_MODE_CLASS (mode) == MODE_FLOAT
+      || GET_MODE_CLASS (mode) == MODE_VECTOR_INT
+      || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)
+    {
+      *count = 1;
+      new_mode = mode;
+    }
+  else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)
+    {
+      *count = 2;
+      new_mode = (mode == DCmode ? DFmode : SFmode);
+    }
+  else if (type && (mode == BLKmode || TREE_CODE (type) == VECTOR_TYPE))
+    {
+      int ag_count = aapcs_vfp_sub_candidate (type, &new_mode);
+
+      if (ag_count > 0 && ag_count <= 4)
+	*count = ag_count;
+      else
+	return false;
+    }
+  else
+    return false;
+
+
+  if (!use_vfp_abi (pcs_variant, ARM_NUM_REGS (new_mode) > 1))
+    return false;
+
+  *base_mode = new_mode;
+  return true;
+}
+
+static bool
+aapcs_vfp_is_return_candidate (enum arm_pcs pcs_variant,
+			       enum machine_mode mode, const_tree type)
+{
+  int count ATTRIBUTE_UNUSED;
+  int ag_mode ATTRIBUTE_UNUSED;
+
+  if (!use_vfp_abi (pcs_variant, false))
+    return false;
+  return aapcs_vfp_is_call_or_return_candidate (pcs_variant, mode, type,
+						&ag_mode, &count);
+}
+
+static bool
+aapcs_vfp_is_call_candidate (CUMULATIVE_ARGS *pcum, enum machine_mode mode, 
+			     const_tree type)
+{
+  if (!use_vfp_abi (pcum->pcs_variant, false))
+    return false;
+
+  return aapcs_vfp_is_call_or_return_candidate (pcum->pcs_variant, mode, type,
+						&pcum->aapcs_vfp_rmode,
+						&pcum->aapcs_vfp_rcount);
+}
+
+static bool
+aapcs_vfp_allocate (CUMULATIVE_ARGS *pcum, enum machine_mode mode,
+		    const_tree type  ATTRIBUTE_UNUSED)
+{
+  int shift = GET_MODE_SIZE (pcum->aapcs_vfp_rmode) / GET_MODE_SIZE (SFmode);
+  unsigned mask = (1 << (shift * pcum->aapcs_vfp_rcount)) - 1;
+  int regno;
+  
+  for (regno = 0; regno < NUM_VFP_ARG_REGS; regno += shift)
+    if (((pcum->aapcs_vfp_regs_free >> regno) & mask) == mask)
+      {
+	pcum->aapcs_vfp_reg_alloc = mask << regno;
+	if (mode == BLKmode || (mode == TImode && !TARGET_NEON))
+	  {
+	    int i;
+	    int rcount = pcum->aapcs_vfp_rcount;
+	    int rshift = shift;
+	    enum machine_mode rmode = pcum->aapcs_vfp_rmode;
+	    rtx par;
+	    if (!TARGET_NEON)
+	      {
+		/* Avoid using unsupported vector modes.  */
+		if (rmode == V2SImode)
+		  rmode = DImode;
+		else if (rmode == V4SImode)
+		  {
+		    rmode = DImode;
+		    rcount *= 2;
+		    rshift /= 2;
+		  }
+	      }
+	    par = gen_rtx_PARALLEL (mode, rtvec_alloc (rcount));
+	    for (i = 0; i < rcount; i++)
+	      {
+		rtx tmp = gen_rtx_REG (rmode, 
+				       FIRST_VFP_REGNUM + regno + i * rshift);
+		tmp = gen_rtx_EXPR_LIST
+		  (VOIDmode, tmp, 
+		   GEN_INT (i * GET_MODE_SIZE (rmode)));
+		XVECEXP (par, 0, i) = tmp;
+	      }
+
+	    pcum->aapcs_reg = par;
+	  }
+	else
+	  pcum->aapcs_reg = gen_rtx_REG (mode, FIRST_VFP_REGNUM + regno);
+	return true;
+      }
+  return false;
+}
+
+static rtx
+aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,
+			       enum machine_mode mode,
+			       const_tree type ATTRIBUTE_UNUSED)
+{
+  if (!use_vfp_abi (pcs_variant, false))
+    return false;
+
+  if (mode == BLKmode || (mode == TImode && !TARGET_NEON))
+    {
+      int count;
+      int ag_mode;
+      int i;
+      rtx par;
+      int shift;
+      
+      aapcs_vfp_is_call_or_return_candidate (pcs_variant, mode, type,
+					     &ag_mode, &count);
+
+      if (!TARGET_NEON)
+	{
+	  if (ag_mode == V2SImode)
+	    ag_mode = DImode;
+	  else if (ag_mode == V4SImode)
+	    {
+	      ag_mode = DImode;
+	      count *= 2;
+	    }
+	}
+      shift = GET_MODE_SIZE(ag_mode) / GET_MODE_SIZE(SFmode);
+      par = gen_rtx_PARALLEL (mode, rtvec_alloc (count));
+      for (i = 0; i < count; i++)
+	{
+	  rtx tmp = gen_rtx_REG (ag_mode, FIRST_VFP_REGNUM + i * shift);
+	  tmp = gen_rtx_EXPR_LIST (VOIDmode, tmp, 
+				   GEN_INT (i * GET_MODE_SIZE (ag_mode)));
+	  XVECEXP (par, 0, i) = tmp;
+	}
+
+      return par;
+    }
+
+  return gen_rtx_REG (mode, FIRST_VFP_REGNUM);
+}
+
+static void
+aapcs_vfp_advance (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,
+		   enum machine_mode mode  ATTRIBUTE_UNUSED,
+		   const_tree type  ATTRIBUTE_UNUSED)
+{
+  pcum->aapcs_vfp_regs_free &= ~pcum->aapcs_vfp_reg_alloc;
+  pcum->aapcs_vfp_reg_alloc = 0;
+  return;
+}
+
+#define AAPCS_CP(X)				\
+  {						\
+    aapcs_ ## X ## _cum_init,			\
+    aapcs_ ## X ## _is_call_candidate,		\
+    aapcs_ ## X ## _allocate,			\
+    aapcs_ ## X ## _is_return_candidate,	\
+    aapcs_ ## X ## _allocate_return_reg,	\
+    aapcs_ ## X ## _advance			\
+  }
+
+/* Table of co-processors that can be used to pass arguments in
+   registers.  Idealy no arugment should be a candidate for more than
+   one co-processor table entry, but the table is processed in order
+   and stops after the first match.  If that entry then fails to put
+   the argument into a co-processor register, the argument will go on
+   the stack.  */
+static struct 
+{
+  /* Initialize co-processor related state in CUMULATIVE_ARGS structure.  */
+  void (*cum_init) (CUMULATIVE_ARGS *, const_tree, rtx, const_tree);
+
+  /* Return true if an argument of mode MODE (or type TYPE if MODE is
+     BLKmode) is a candidate for this co-processor's registers; this
+     function should ignore any position-dependent state in
+     CUMULATIVE_ARGS and only use call-type dependent information.  */
+  bool (*is_call_candidate) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);
+
+  /* Return true if the argument does get a co-processor register; it
+     should set aapcs_reg to an RTX of the register allocated as is
+     required for a return from FUNCTION_ARG.  */
+  bool (*allocate) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);
+
+  /* Return true if a result of mode MODE (or type TYPE if MODE is
+     BLKmode) is can be returned in this co-processor's registers.  */
+  bool (*is_return_candidate) (enum arm_pcs, enum machine_mode, const_tree);
+
+  /* Allocate and return an RTX element to hold the return type of a
+     call, this routine must not fail and will only be called if
+     is_return_candidate returned true with the same parameters.  */
+  rtx (*allocate_return_reg) (enum arm_pcs, enum machine_mode, const_tree);
+
+  /* Finish processing this argument and prepare to start processing
+     the next one.  */
+  void (*advance) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);
+} aapcs_cp_arg_layout[ARM_NUM_COPROC_SLOTS] =
+  {
+    AAPCS_CP(vfp)
+  };
+
+#undef AAPCS_CP
+
+static int
+aapcs_select_call_coproc (CUMULATIVE_ARGS *pcum, enum machine_mode mode, 
+			  tree type)
+{
+  int i;
+
+  for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)
+    if (aapcs_cp_arg_layout[i].is_call_candidate (pcum, mode, type))
+      return i;
+
+  return -1;
+}
+
+static int
+aapcs_select_return_coproc (const_tree type, const_tree fntype)
+{
+  /* We aren't passed a decl, so we can't check that a call is local.
+     However, it isn't clear that that would be a win anyway, since it
+     might limit some tail-calling opportunities.  */
+  enum arm_pcs pcs_variant;
+
+  if (fntype)
+    {
+      const_tree fndecl = NULL_TREE;
+
+      if (TREE_CODE (fntype) == FUNCTION_DECL)
+	{
+	  fndecl = fntype;
+	  fntype = TREE_TYPE (fntype);
+	}
+
+      pcs_variant = arm_get_pcs_model (fntype, fndecl);
+    }
+  else
+    pcs_variant = arm_pcs_default;
+
+  if (pcs_variant != ARM_PCS_AAPCS)
+    {
+      int i;
+
+      for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)
+	if (aapcs_cp_arg_layout[i].is_return_candidate (pcs_variant, 
+							TYPE_MODE (type),
+							type))
+	  return i;
+    }
+  return -1;
+}
+
+static rtx
+aapcs_allocate_return_reg (enum machine_mode mode, const_tree type,
+			   const_tree fntype)
+{
+  /* We aren't passed a decl, so we can't check that a call is local.
+     However, it isn't clear that that would be a win anyway, since it
+     might limit some tail-calling opportunities.  */
+  enum arm_pcs pcs_variant;
+
+  if (fntype)
+    {
+      const_tree fndecl = NULL_TREE;
+
+      if (TREE_CODE (fntype) == FUNCTION_DECL)
+	{
+	  fndecl = fntype;
+	  fntype = TREE_TYPE (fntype);
+	}
+
+      pcs_variant = arm_get_pcs_model (fntype, fndecl);
+    }
+  else
+    pcs_variant = arm_pcs_default;
+
+  /* Promote integer types.  */
+  if (type && INTEGRAL_TYPE_P (type))
+    PROMOTE_FUNCTION_MODE (mode, unsignedp, type);
+
+  if (pcs_variant != ARM_PCS_AAPCS)
+    {
+      int i;
+
+      for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)
+	if (aapcs_cp_arg_layout[i].is_return_candidate (pcs_variant, mode,
+							type))
+	  return aapcs_cp_arg_layout[i].allocate_return_reg (pcs_variant,
+							     mode, type);
+    }
+
+  /* Promotes small structs returned in a register to full-word size
+     for big-endian AAPCS.  */
+  if (type && arm_return_in_msb (type))
+    {
+      HOST_WIDE_INT size = int_size_in_bytes (type);
+      if (size % UNITS_PER_WORD != 0)
+	{
+	  size += UNITS_PER_WORD - size % UNITS_PER_WORD;
+	  mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);
+	}
+    }
+
+  return gen_rtx_REG (mode, R0_REGNUM);
+}
+
+rtx
+aapcs_libcall_value (enum machine_mode mode)
+{
+  return aapcs_allocate_return_reg (mode, NULL_TREE, NULL_TREE);
+}
+
+/* Lay out a function argument using the AAPCS rules.  The rule
+   numbers referred to here are those in the AAPCS.  */
+static void
+aapcs_layout_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,
+		  tree type, int named)
+{
+  int nregs, nregs2;
+  int ncrn;
+
+  /* We only need to do this once per argument.  */
+  if (pcum->aapcs_arg_processed)
+    return;
+
+  pcum->aapcs_arg_processed = true;
+
+  /* Special case: if named is false then we are handling an incoming
+     anonymous argument which is on the stack.  */
+  if (!named)
+    return;
+  
+  /* Is this a potential co-processor register candidate?  */
+  if (pcum->pcs_variant != ARM_PCS_AAPCS)
+    {
+      int slot = aapcs_select_call_coproc (pcum, mode, type);
+      pcum->aapcs_cprc_slot = slot;
+
+      /* We don't have to apply any of the rules from part B of the
+	 preparation phase, these are handled elsewhere in the
+	 compiler.  */
+
+      if (slot >= 0)
+	{
+	  /* A Co-processor register candidate goes either in its own
+	     class of registers or on the stack.  */
+	  if (!pcum->aapcs_cprc_failed[slot])
+	    {
+	      /* C1.cp - Try to allocate the argument to co-processor
+		 registers.  */
+	      if (aapcs_cp_arg_layout[slot].allocate (pcum, mode, type))
+		return;
+
+	      /* C2.cp - Put the argument on the stack and note that we
+		 can't assign any more candidates in this slot.  We also
+		 need to note that we have allocated stack space, so that
+		 we won't later try to split a non-cprc candidate between
+		 core registers and the stack.  */
+	      pcum->aapcs_cprc_failed[slot] = true;
+	      pcum->can_split = false;
+	    }
+
+	  /* We didn't get a register, so this argument goes on the
+	     stack.  */
+	  gcc_assert (pcum->can_split == false);
+	  return;
+	}
+    }
+
+  /* C3 - For double-word aligned arguments, round the NCRN up to the
+     next even number.  */
+  ncrn = pcum->aapcs_ncrn;
+  if ((ncrn & 1) && arm_needs_doubleword_align (mode, type))
+    ncrn++;
+
+  nregs = ARM_NUM_REGS2(mode, type);
+
+  /* Sigh, this test should really assert that nregs > 0, but a GCC
+     extension allows empty structs and then gives them empty size; it
+     then allows such a structure to be passed by value.  For some of
+     the code below we have to pretend that such an argument has
+     non-zero size so that we 'locate' it correctly either in
+     registers or on the stack.  */
+  gcc_assert (nregs >= 0);
+
+  nregs2 = nregs ? nregs : 1;
+
+  /* C4 - Argument fits entirely in core registers.  */
+  if (ncrn + nregs2 <= NUM_ARG_REGS)
+    {
+      pcum->aapcs_reg = gen_rtx_REG (mode, ncrn);
+      pcum->aapcs_next_ncrn = ncrn + nregs;
+      return;
+    }
+
+  /* C5 - Some core registers left and there are no arguments already
+     on the stack: split this argument between the remaining core
+     registers and the stack.  */
+  if (ncrn < NUM_ARG_REGS && pcum->can_split)
+    {
+      pcum->aapcs_reg = gen_rtx_REG (mode, ncrn);
+      pcum->aapcs_next_ncrn = NUM_ARG_REGS;
+      pcum->aapcs_partial = (NUM_ARG_REGS - ncrn) * UNITS_PER_WORD;
+      return;
+    }
+
+  /* C6 - NCRN is set to 4.  */
+  pcum->aapcs_next_ncrn = NUM_ARG_REGS;
+
+  /* C7,C8 - arugment goes on the stack.  We have nothing to do here.  */
+  return;
+}
+
 /* Initialize a variable CUM of type CUMULATIVE_ARGS
    for a call to a function whose data type is FNTYPE.
    For a library call, FNTYPE is NULL.  */
 void
 arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,
-			  rtx libname  ATTRIBUTE_UNUSED,
+			  rtx libname,
 			  tree fndecl ATTRIBUTE_UNUSED)
 {
+  /* Long call handling.  */
+  if (fntype)
+    pcum->pcs_variant = arm_get_pcs_model (fntype, fndecl);
+  else
+    pcum->pcs_variant = arm_pcs_default;
+
+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)
+    {
+      /* XXX We should also detect some library calls here and handle
+	 them using the base rules too; for example the floating point
+	 support functions always work this way.  */
+
+       if (rtx_equal_p (libname,
+		       convert_optab_libfunc (sfix_optab, DImode, DFmode))
+	  || rtx_equal_p (libname,
+			  convert_optab_libfunc (ufix_optab, DImode, DFmode))
+	  || rtx_equal_p (libname,
+			  convert_optab_libfunc (sfix_optab, DImode, SFmode))
+	  || rtx_equal_p (libname,
+			  convert_optab_libfunc (ufix_optab, DImode, SFmode))
+	  || rtx_equal_p (libname,
+			  convert_optab_libfunc (trunc_optab, HFmode, SFmode))
+	  || rtx_equal_p (libname,
+			  convert_optab_libfunc (sext_optab, SFmode, HFmode)))
+	pcum->pcs_variant = ARM_PCS_AAPCS;
+ 
+      pcum->aapcs_ncrn = pcum->aapcs_next_ncrn = 0;
+      pcum->aapcs_reg = NULL_RTX;
+      pcum->aapcs_partial = 0;
+      pcum->aapcs_arg_processed = false;
+      pcum->aapcs_cprc_slot = -1;
+      pcum->can_split = true;
+
+      if (pcum->pcs_variant != ARM_PCS_AAPCS)
+	{
+	  int i;
+
+	  for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)
+	    {
+	      pcum->aapcs_cprc_failed[i] = false;
+	      aapcs_cp_arg_layout[i].cum_init (pcum, fntype, libname, fndecl);
+	    }
+	}
+      return;
+    }
+
+  /* Legacy ABIs */
+
   /* On the ARM, the offset starts at 0.  */
   pcum->nregs = 0;
   pcum->iwmmxt_nregs = 0;
@@ -3120,6 +4189,17 @@
 {
   int nregs;
 
+  /* Handle the special case quickly.  Pick an arbitrary value for op2 of
+     a call insn (op3 of a call_value insn).  */
+  if (mode == VOIDmode)
+    return const0_rtx;
+
+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)
+    {
+      aapcs_layout_arg (pcum, mode, type, named);
+      return pcum->aapcs_reg;
+    }
+
   /* Varargs vectors are treated the same as long long.
      named_count avoids having to change the way arm handles 'named' */
   if (TARGET_IWMMXT_ABI
@@ -3161,10 +4241,16 @@
 
 static int
 arm_arg_partial_bytes (CUMULATIVE_ARGS *pcum, enum machine_mode mode,
-		       tree type, bool named ATTRIBUTE_UNUSED)
+		       tree type, bool named)
 {
   int nregs = pcum->nregs;
 
+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)
+    {
+      aapcs_layout_arg (pcum, mode, type, named);
+      return pcum->aapcs_partial;
+    }
+
   if (TARGET_IWMMXT_ABI && arm_vector_mode_supported_p (mode))
     return 0;
 
@@ -3173,7 +4259,40 @@
       && pcum->can_split)
     return (NUM_ARG_REGS - nregs) * UNITS_PER_WORD;
 
-  return 0;
+  return 0;
+}
+
+void
+arm_function_arg_advance (CUMULATIVE_ARGS *pcum, enum machine_mode mode,
+			  tree type, bool named)
+{
+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)
+    {
+      aapcs_layout_arg (pcum, mode, type, named);
+
+      if (pcum->aapcs_cprc_slot >= 0)
+	{
+	  aapcs_cp_arg_layout[pcum->aapcs_cprc_slot].advance (pcum, mode,
+							      type);
+	  pcum->aapcs_cprc_slot = -1;
+	}
+
+      /* Generic stuff.  */
+      pcum->aapcs_arg_processed = false;
+      pcum->aapcs_ncrn = pcum->aapcs_next_ncrn;
+      pcum->aapcs_reg = NULL_RTX;
+      pcum->aapcs_partial = 0;
+    }
+  else
+    {
+      pcum->nargs += 1;
+      if (arm_vector_mode_supported_p (mode)
+	  && pcum->named_count > pcum->nargs
+	  && TARGET_IWMMXT_ABI)
+	pcum->iwmmxt_nregs += 1;
+      else
+	pcum->nregs += ARM_NUM_REGS2 (mode, type);
+    }
 }
 
 /* Variable sized types are passed by reference.  This is a GCC
@@ -3226,6 +4345,8 @@
   /* Whereas these functions are always known to reside within the 26 bit
      addressing range.  */
   { "short_call",   0, 0, false, true,  true,  NULL },
+  /* Specify the procedure call conventions for a function.  */
+  { "pcs",          1, 1, false, true,  true,  arm_handle_pcs_attribute },
   /* Interrupt Service Routines have special prologue and epilogue requirements.  */
   { "isr",          0, 1, false, false, false, arm_handle_isr_attribute },
   { "interrupt",    0, 1, false, false, false, arm_handle_isr_attribute },
@@ -3328,6 +4449,21 @@
   return NULL_TREE;
 }
 
+/* Handle a "pcs" attribute; arguments as in struct
+   attribute_spec.handler.  */
+static tree
+arm_handle_pcs_attribute (tree *node ATTRIBUTE_UNUSED, tree name, tree args,
+			  int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)
+{
+  if (arm_pcs_from_attribute (args) == ARM_PCS_UNKNOWN)
+    {
+      warning (OPT_Wattributes, "%qs attribute ignored",
+	       IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+  return NULL_TREE;
+}
+
 #if TARGET_DLLIMPORT_DECL_ATTRIBUTES
 /* Handle the "notshared" attribute.  This attribute is another way of
    requesting hidden visibility.  ARM's compiler supports
@@ -3489,7 +4625,7 @@
 
 /* Return nonzero if it is ok to make a tail-call to DECL.  */
 static bool
-arm_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)
+arm_function_ok_for_sibcall (tree decl, tree exp)
 {
   unsigned long func_type;
 
@@ -3522,6 +4658,21 @@
   if (IS_INTERRUPT (func_type))
     return false;
 
+  if (!VOID_TYPE_P (TREE_TYPE (DECL_RESULT (cfun->decl))))
+    {
+      /* Check that the return value locations are the same.  For
+	 example that we aren't returning a value from the sibling in
+	 a VFP register but then need to transfer it to a core
+	 register.  */
+      rtx a, b;
+
+      a = arm_function_value (TREE_TYPE (exp), decl, false);
+      b = arm_function_value (TREE_TYPE (DECL_RESULT (cfun->decl)),
+			      cfun->decl, false);
+      if (!rtx_equal_p (a, b))
+	return false;
+    }
+
   /* Never tailcall if function may be called with a misaligned SP.  */
   if (IS_STACKALIGN (func_type))
     return false;
@@ -4120,6 +5271,7 @@
   if (GET_MODE_SIZE (mode) <= 4
       && ! (arm_arch4
 	    && (mode == HImode
+		|| mode == HFmode
 		|| (mode == QImode && outer == SIGN_EXTEND))))
     {
       if (code == MULT)
@@ -4148,13 +5300,15 @@
      load.  */
   if (arm_arch4)
     {
-      if (mode == HImode || (outer == SIGN_EXTEND && mode == QImode))
+      if (mode == HImode
+	  || mode == HFmode
+	  || (outer == SIGN_EXTEND && mode == QImode))
 	range = 256;
       else
 	range = 4096;
     }
   else
-    range = (mode == HImode) ? 4095 : 4096;
+    range = (mode == HImode || mode == HFmode) ? 4095 : 4096;
 
   return (code == CONST_INT
 	  && INTVAL (index) < range
@@ -4325,7 +5479,8 @@
     return 1;
 
   /* This is PC relative data after arm_reorg runs.  */
-  else if (GET_MODE_SIZE (mode) >= 4 && reload_completed
+  else if ((GET_MODE_SIZE (mode) >= 4 || mode == HFmode)
+	   && reload_completed
 	   && (GET_CODE (x) == LABEL_REF
 	       || (GET_CODE (x) == CONST
 		   && GET_CODE (XEXP (x, 0)) == PLUS
@@ -5024,7 +6179,7 @@
     case UMOD:
       if (TARGET_HARD_FLOAT && mode == SFmode)
 	*total = COSTS_N_INSNS (2);
-      else if (TARGET_HARD_FLOAT && mode == DFmode)
+      else if (TARGET_HARD_FLOAT && mode == DFmode && !TARGET_VFP_SINGLE)
 	*total = COSTS_N_INSNS (4);
       else
 	*total = COSTS_N_INSNS (20);
@@ -5063,23 +6218,6 @@
       return true;
 
     case MINUS:
-      if (TARGET_THUMB2)
-	{
-	  if (GET_MODE_CLASS (mode) == MODE_FLOAT)
-	    {
-	      if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
-		*total = COSTS_N_INSNS (1);
-	      else
-		*total = COSTS_N_INSNS (20);
-	    }
-	  else
-	    *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));
-	  /* Thumb2 does not have RSB, so all arguments must be
-	     registers (subtracting a constant is canonicalized as
-	     addition of the negated constant).  */
-	  return false;
-	}
-
       if (mode == DImode)
 	{
 	  *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));
@@ -5102,7 +6240,9 @@
 
       if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      if (GET_CODE (XEXP (x, 0)) == CONST_DOUBLE
@@ -5143,6 +6283,17 @@
 	  return true;
 	}
 
+      /* A shift as a part of RSB costs no more than RSB itself.  */
+      if (GET_CODE (XEXP (x, 0)) == MULT
+	  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT
+	  && ((INTVAL (XEXP (XEXP (x, 0), 1))
+	       & (INTVAL (XEXP (XEXP (x, 0), 1)) - 1)) == 0))
+	{
+	  *total += rtx_cost (XEXP (XEXP (x, 0), 0), code, speed);
+	  *total += rtx_cost (XEXP (x, 1), code, speed);
+	  return true;
+	}
+
       if (subcode == MULT
 	  && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT
 	  && ((INTVAL (XEXP (XEXP (x, 1), 1)) &
@@ -5164,6 +6315,19 @@
 	  return true;
 	}
 
+      /* MLS is just as expensive as its underlying multiplication.
+	 Exclude a shift by a constant, which is expressed as a
+	 multiplication.  */
+      if (TARGET_32BIT && arm_arch_thumb2
+	  && GET_CODE (XEXP (x, 1)) == MULT
+	  && ! (GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT
+		&& ((INTVAL (XEXP (XEXP (x, 1), 1)) &
+		     (INTVAL (XEXP (XEXP (x, 1), 1)) - 1)) == 0)))
+	{
+	  /* The cost comes from the cost of the multiply.  */
+	  return false;
+	}
+
       /* Fall through */
 
     case PLUS:
@@ -5192,7 +6356,9 @@
 
       if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      if (GET_CODE (XEXP (x, 1)) == CONST_DOUBLE
@@ -5307,7 +6473,9 @@
     case NEG:
       if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      return false;
@@ -5460,7 +6628,9 @@
     case ABS:
       if (GET_MODE_CLASS (mode == MODE_FLOAT))
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      return false;
@@ -5563,7 +6733,8 @@
       return true;
 
     case CONST_DOUBLE:
-      if (TARGET_HARD_FLOAT && vfp3_const_double_rtx (x))
+      if (TARGET_HARD_FLOAT && vfp3_const_double_rtx (x)
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
 	*total = COSTS_N_INSNS (1);
       else
 	*total = COSTS_N_INSNS (4);
@@ -5638,7 +6809,8 @@
       return false;
 
     case MINUS:
-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
 	{
 	  *total = COSTS_N_INSNS (1);
 	  return false;
@@ -5668,7 +6840,8 @@
       return false;
 
     case PLUS:
-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
 	{
 	  *total = COSTS_N_INSNS (1);
 	  return false;
@@ -5698,7 +6871,8 @@
       return false;
 
     case NEG:
-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
 	{
 	  *total = COSTS_N_INSNS (1);
 	  return false;
@@ -5722,7 +6896,8 @@
       return false;
 
     case ABS:
-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
 	*total = COSTS_N_INSNS (1);
       else
 	*total = COSTS_N_INSNS (1 + ARM_NUM_REGS (mode));
@@ -5939,7 +7114,9 @@
 
       if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      return false;
@@ -6096,7 +7273,9 @@
 
       if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      return false;
@@ -6919,10 +8098,13 @@
 }
 
 /* Return TRUE if OP is a memory operand which we can load or store a vector
-   to/from. If CORE is true, we're moving from ARM registers not Neon
-   registers.  */
+   to/from. TYPE is one of the following values:
+    0 - Vector load/stor (vldr)
+    1 - Core registers (ldm)
+    2 - Element/structure loads (vld1)
+ */
 int
-neon_vector_mem_operand (rtx op, bool core)
+neon_vector_mem_operand (rtx op, int type)
 {
   rtx ind;
 
@@ -6955,23 +8137,16 @@
     return arm_address_register_rtx_p (ind, 0);
 
   /* Allow post-increment with Neon registers.  */
-  if (!core && GET_CODE (ind) == POST_INC)
+  if ((type != 1 && GET_CODE (ind) == POST_INC)
+      || (type == 0 && GET_CODE (ind) == PRE_DEC))
     return arm_address_register_rtx_p (XEXP (ind, 0), 0);
 
-#if 0
-  /* FIXME: We can support this too if we use VLD1/VST1.  */
-  if (!core
-      && GET_CODE (ind) == POST_MODIFY
-      && arm_address_register_rtx_p (XEXP (ind, 0), 0)
-      && GET_CODE (XEXP (ind, 1)) == PLUS
-      && rtx_equal_p (XEXP (XEXP (ind, 1), 0), XEXP (ind, 0)))
-    ind = XEXP (ind, 1);
-#endif
+  /* FIXME: vld1 allows register post-modify.  */
 
   /* Match:
      (plus (reg)
           (const)).  */
-  if (!core
+  if (type == 0
       && GET_CODE (ind) == PLUS
       && GET_CODE (XEXP (ind, 0)) == REG
       && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)
@@ -7038,10 +8213,19 @@
 enum reg_class
 coproc_secondary_reload_class (enum machine_mode mode, rtx x, bool wb)
 {
+  if (mode == HFmode)
+    {
+      if (!TARGET_NEON_FP16)
+	return GENERAL_REGS;
+      if (s_register_operand (x, mode) || neon_vector_mem_operand (x, 2))
+	return NO_REGS;
+      return GENERAL_REGS;
+    }
+
   if (TARGET_NEON
       && (GET_MODE_CLASS (mode) == MODE_VECTOR_INT
           || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)
-      && neon_vector_mem_operand (x, FALSE))
+      && neon_vector_mem_operand (x, 0))
      return NO_REGS;
 
   if (arm_coproc_mem_operand (x, wb) || s_register_operand (x, mode))
@@ -7438,6 +8622,9 @@
   int base_reg = -1;
   int i;
 
+  if (low_irq_latency)
+    return 0;
+
   /* Can only handle 2, 3, or 4 insns at present,
      though could be easily extended if required.  */
   gcc_assert (nops >= 2 && nops <= 4);
@@ -7667,6 +8854,9 @@
   int base_reg = -1;
   int i;
 
+  if (low_irq_latency)
+    return 0;
+
   /* Can only handle 2, 3, or 4 insns at present, though could be easily
      extended if required.  */
   gcc_assert (nops >= 2 && nops <= 4);
@@ -7874,7 +9064,7 @@
 
      As a compromise, we use ldr for counts of 1 or 2 regs, and ldm
      for counts of 3 or 4 regs.  */
-  if (arm_tune_xscale && count <= 2 && ! optimize_size)
+  if (low_irq_latency || (arm_tune_xscale && count <= 2 && ! optimize_size))
     {
       rtx seq;
 
@@ -7937,7 +9127,7 @@
 
   /* See arm_gen_load_multiple for discussion of
      the pros/cons of ldm/stm usage for XScale.  */
-  if (arm_tune_xscale && count <= 2 && ! optimize_size)
+  if (low_irq_latency || (arm_tune_xscale && count <= 2 && ! optimize_size))
     {
       rtx seq;
 
@@ -9555,7 +10745,10 @@
       gcc_assert (GET_CODE (from) != BARRIER);
 
       /* Count the length of this insn.  */
-      count += get_attr_length (from);
+      if (LABEL_P (from) && (align_jumps > 0 || align_loops > 0))
+        count += MAX (align_jumps, align_loops);
+      else
+        count += get_attr_length (from);
 
       /* If there is a jump table, add its length.  */
       tmp = is_jump_table (from);
@@ -9867,6 +11060,8 @@
 	      insn = table;
 	    }
 	}
+      else if (LABEL_P (insn) && (align_jumps > 0 || align_loops > 0))
+	address += MAX (align_jumps, align_loops);
     }
 
   fix = minipool_fix_head;
@@ -10072,6 +11267,21 @@
 vfp_output_fldmd (FILE * stream, unsigned int base, int reg, int count)
 {
   int i;
+  int offset;
+
+  if (low_irq_latency)
+    {
+      /* Output a sequence of FLDD instructions.  */
+      offset = 0;
+      for (i = reg; i < reg + count; ++i, offset += 8)
+	{
+	  fputc ('\t', stream);
+	  asm_fprintf (stream, "fldd\td%d, [%r,#%d]\n", i, base, offset);
+	}
+      asm_fprintf (stream, "\tadd\tsp, sp, #%d\n", count * 8);
+      return;
+    }
+
 
   /* Workaround ARM10 VFPr1 bug.  */
   if (count == 2 && !arm_arch6)
@@ -10142,6 +11352,56 @@
   rtx tmp, reg;
   int i;
 
+  if (low_irq_latency)
+    {
+      int saved_size;
+      rtx sp_insn;
+
+      if (!count)
+	return 0;
+
+      saved_size = count * GET_MODE_SIZE (DFmode);
+
+      /* Since fstd does not have postdecrement addressing mode,
+	 we first decrement stack pointer and then use base+offset
+	 stores for VFP registers. The ARM EABI unwind information 
+	 can't easily describe base+offset loads, so we attach
+	 a note for the effects of the whole block in the first insn, 
+	 and  avoid marking the subsequent instructions 
+	 with RTX_FRAME_RELATED_P.  */
+      sp_insn = gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
+			    GEN_INT (-saved_size));
+      sp_insn = emit_insn (sp_insn);
+      RTX_FRAME_RELATED_P (sp_insn) = 1;
+
+      dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (count + 1));
+      XVECEXP (dwarf, 0, 0) = 
+	gen_rtx_SET (VOIDmode, stack_pointer_rtx,
+		     plus_constant (stack_pointer_rtx, -saved_size));
+      
+      /* push double VFP registers to stack */
+      for (i = 0; i < count; ++i )
+	{
+	  rtx reg;
+	  rtx mem;
+	  rtx addr;
+	  rtx insn;
+	  reg = gen_rtx_REG (DFmode, base_reg + 2*i);
+	  addr = (i == 0) ? stack_pointer_rtx
+	    : gen_rtx_PLUS (SImode, stack_pointer_rtx,
+			    GEN_INT (i * GET_MODE_SIZE (DFmode)));
+	  mem = gen_frame_mem (DFmode, addr);
+	  insn = emit_move_insn (mem, reg);
+	  XVECEXP (dwarf, 0, i+1) = 
+	    gen_rtx_SET (VOIDmode, mem, reg);
+	}
+
+      REG_NOTES (sp_insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,
+					       REG_NOTES (sp_insn));
+      
+      return saved_size;
+    }
+
   /* Workaround ARM10 VFPr1 bug.  Data corruption can occur when exactly two
      register pairs are stored by a store multiple insn.  We avoid this
      by pushing an extra pair.  */
@@ -10758,7 +12018,7 @@
 }
 
 /* Output a move, load or store for quad-word vectors in ARM registers.  Only
-   handles MEMs accepted by neon_vector_mem_operand with CORE=true.  */
+   handles MEMs accepted by neon_vector_mem_operand with TYPE=1.  */
 
 const char *
 output_move_quad (rtx *operands)
@@ -10954,6 +12214,12 @@
       ops[1] = reg;
       break;
 
+    case PRE_DEC:
+      templ = "v%smdb%%?\t%%0!, %%h1";
+      ops[0] = XEXP (addr, 0);
+      ops[1] = reg;
+      break;
+    
     case POST_MODIFY:
       /* FIXME: Not currently enabled in neon_vector_mem_operand.  */
       gcc_unreachable ();
@@ -10968,7 +12234,7 @@
 	  {
 	    /* We're only using DImode here because it's a convenient size.  */
 	    ops[0] = gen_rtx_REG (DImode, REGNO (reg) + 2 * i);
-	    ops[1] = adjust_address (mem, SImode, 8 * i);
+	    ops[1] = adjust_address (mem, DImode, 8 * i);
 	    if (reg_overlap_mentioned_p (ops[0], mem))
 	      {
 		gcc_assert (overlap == -1);
@@ -11557,7 +12823,7 @@
 	      if (count > 0)
 		{
 		  /* Workaround ARM10 VFPr1 bug.  */
-		  if (count == 2 && !arm_arch6)
+		  if (count == 2 && !arm_arch6 && !low_irq_latency)
 		    count++;
 		  saved += count * 8;
 		}
@@ -11886,6 +13152,41 @@
   return_used_this_function = 0;
 }
 
+/* Generate to STREAM a code sequence that pops registers identified 
+   in REGS_MASK from SP. SP is incremented as the result.
+*/
+static void
+print_pop_reg_by_ldr (FILE *stream, int regs_mask, int rfe)
+{
+  int reg;
+
+  gcc_assert (! (regs_mask & (1 << SP_REGNUM)));
+  
+  for (reg = 0; reg < PC_REGNUM; ++reg)
+    if (regs_mask & (1 << reg))
+      asm_fprintf (stream, "\tldr\t%r, [%r], #4\n",
+		   reg, SP_REGNUM); 
+
+  if (regs_mask & (1 << PC_REGNUM))
+    {
+      if (rfe)
+	/* When returning from exception, we need to
+	   copy SPSR to CPSR.  There are two ways to do
+	   that: the ldm instruction with "^" suffix,
+	   and movs instruction.  The latter would
+	   require that we load from stack to some
+	   scratch register, and then move to PC.
+	   Therefore, we'd need extra instruction and
+	   have to make sure we actually have a spare
+	   register.  Using ldm with a single register
+	   is simler.  */
+	asm_fprintf (stream, "\tldm\tsp!, {pc}^\n");
+      else
+	asm_fprintf (stream, "\tldr\t%r, [%r], #4\n",
+		     PC_REGNUM, SP_REGNUM); 
+    }
+}
+
 const char *
 arm_output_epilogue (rtx sibling)
 {
@@ -11946,7 +13247,7 @@
       /* This variable is for the Virtual Frame Pointer, not VFP regs.  */
       int vfp_offset = offsets->frame;
 
-      if (arm_fpu_arch == FPUTYPE_FPA_EMU2)
+      if (TARGET_FPA_EMU2)
 	{
 	  for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)
 	    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])
@@ -12169,7 +13470,7 @@
 			 SP_REGNUM, HARD_FRAME_POINTER_REGNUM);
 	}
 
-      if (arm_fpu_arch == FPUTYPE_FPA_EMU2)
+      if (TARGET_FPA_EMU2)
 	{
 	  for (reg = FIRST_FPA_REGNUM; reg <= LAST_FPA_REGNUM; reg++)
 	    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])
@@ -12253,22 +13554,19 @@
 	 to load use the LDR instruction - it is faster.  For Thumb-2
 	 always use pop and the assembler will pick the best instruction.*/
       if (TARGET_ARM && saved_regs_mask == (1 << LR_REGNUM)
-	  && !IS_INTERRUPT(func_type))
+	  && !IS_INTERRUPT (func_type))
 	{
 	  asm_fprintf (f, "\tldr\t%r, [%r], #4\n", LR_REGNUM, SP_REGNUM);
 	}
       else if (saved_regs_mask)
 	{
-	  if (saved_regs_mask & (1 << SP_REGNUM))
-	    /* Note - write back to the stack register is not enabled
-	       (i.e. "ldmfd sp!...").  We know that the stack pointer is
-	       in the list of registers and if we add writeback the
-	       instruction becomes UNPREDICTABLE.  */
-	    print_multi_reg (f, "ldmfd\t%r, ", SP_REGNUM, saved_regs_mask,
-			     rfe);
-	  else if (TARGET_ARM)
-	    print_multi_reg (f, "ldmfd\t%r!, ", SP_REGNUM, saved_regs_mask,
-			     rfe);
+	  gcc_assert ( ! (saved_regs_mask & (1 << SP_REGNUM)));
+	  if (TARGET_ARM)
+	    if (low_irq_latency)
+	      print_pop_reg_by_ldr (f, saved_regs_mask, rfe);
+	    else
+	      print_multi_reg (f, "ldmfd\t%r!, ", SP_REGNUM, saved_regs_mask,
+			       rfe);
 	  else
 	    print_multi_reg (f, "pop\t", SP_REGNUM, saved_regs_mask, 0);
 	}
@@ -12389,6 +13687,32 @@
 
   gcc_assert (num_regs && num_regs <= 16);
 
+  if (low_irq_latency)
+    {
+      rtx insn = 0;
+
+      /* Emit a series of ldr instructions rather rather than a single ldm.  */
+      /* TODO: Use ldrd where possible.  */
+      gcc_assert (! (mask & (1 << SP_REGNUM)));
+
+      for (i = LAST_ARM_REGNUM; i >= 0; --i)
+        {
+          if (mask & (1 << i))
+
+            {
+              rtx reg, where, mem;
+
+	      reg = gen_rtx_REG (SImode, i);
+	      where = gen_rtx_PRE_DEC (SImode, stack_pointer_rtx);
+	      mem = gen_rtx_MEM (SImode, where);
+	      insn = emit_move_insn (mem, reg);
+	      RTX_FRAME_RELATED_P (insn) = 1;
+            }
+        }
+
+      return insn;
+    }
+
   /* We don't record the PC in the dwarf frame information.  */
   num_dwarf_regs = num_regs;
   if (mask & (1 << PC_REGNUM))
@@ -12737,22 +14061,23 @@
 	{
 	  int reg = -1;
 
-	  for (i = 4; i <= (TARGET_THUMB1 ? LAST_LO_REGNUM : 11); i++)
-	    {
-	      if ((offsets->saved_regs_mask & (1 << i)) == 0)
-		{
-		  reg = i;
-		  break;
-		}
-	    }
-
-	  if (reg == -1 && arm_size_return_regs () <= 12
-	      && !crtl->tail_call_emit)
+	  /* If it is safe to use r3, then do so.  This sometimes 
+	     generates better code on Thumb-2 by avoiding the need to
+	     use 32-bit push/pop instructions.  */
+	  if (!crtl->tail_call_emit
+	      && arm_size_return_regs () <= 12)
 	    {
-	      /* Push/pop an argument register (r3) if all callee saved
-	         registers are already being pushed.  */
 	      reg = 3;
 	    }
+	  else
+	    for (i = 4; i <= (TARGET_THUMB1 ? LAST_LO_REGNUM : 11); i++)
+	      {
+		if ((offsets->saved_regs_mask & (1 << i)) == 0)
+		  {
+		    reg = i;
+		    break;
+		  }
+	      }
 
 	  if (reg != -1)
 	    {
@@ -12876,7 +14201,7 @@
 
   /* Save any floating point call-saved registers used by this
      function.  */
-  if (arm_fpu_arch == FPUTYPE_FPA_EMU2)
+  if (TARGET_FPA_EMU2)
     {
       for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)
 	if (df_regs_ever_live_p (reg) && !call_used_regs[reg])
@@ -13483,7 +14808,11 @@
 	  {
 	    fprintf (stream, ", %s ", shift);
 	    if (val == -1)
-	      arm_print_operand (stream, XEXP (x, 1), 0);
+              {
+	        arm_print_operand (stream, XEXP (x, 1), 0);
+                if (janus2_code)
+                  fprintf(stream, "\n\tnop");
+              }
 	    else
 	      fprintf (stream, "#" HOST_WIDE_INT_PRINT_DEC, val);
 	  }
@@ -13704,6 +15033,30 @@
 	}
       return;
 
+    /* Print the high single-precision register of a VFP double-precision
+       register.  */
+    case 'p':
+      {
+        int mode = GET_MODE (x);
+        int regno;
+
+        if (GET_MODE_SIZE (mode) != 8 || GET_CODE (x) != REG)
+          {
+	    output_operand_lossage ("invalid operand for code '%c'", code);
+	    return;
+          }
+
+        regno = REGNO (x);
+        if (!VFP_REGNO_OK_FOR_DOUBLE (regno))
+          {
+	    output_operand_lossage ("invalid operand for code '%c'", code);
+	    return;
+          }
+
+	fprintf (stream, "s%d", regno - FIRST_VFP_REGNUM + 1);
+      }
+      return;
+
     /* Print a VFP/Neon double precision or quad precision register name.  */
     case 'P':
     case 'q':
@@ -13821,6 +15174,57 @@
       }
       return;
 
+    /* Memory operand for vld1/vst1 instruction.  */
+    case 'A':
+      {
+	rtx addr;
+	bool postinc = FALSE;
+	unsigned align;
+
+	gcc_assert (GET_CODE (x) == MEM);
+	addr = XEXP (x, 0);
+	if (GET_CODE (addr) == POST_INC)
+	  {
+	    postinc = 1;
+	    addr = XEXP (addr, 0);
+	  }
+	align = MEM_ALIGN (x) >> 3;
+	asm_fprintf (stream, "[%r", REGNO (addr));
+	if (align > GET_MODE_SIZE (GET_MODE (x)))
+	  align = GET_MODE_SIZE (GET_MODE (x));
+	if (align >= 8)
+	  asm_fprintf (stream, ", :%d", align << 3);
+	asm_fprintf (stream, "]");
+	if (postinc)
+	  fputs("!", stream);
+      }
+      return;
+
+    /* Register specifier for vld1.16/vst1.16.  Translate the S register
+       number into a D register number and element index.  */
+    case 'z':
+      {
+        int mode = GET_MODE (x);
+        int regno;
+
+        if (GET_MODE_SIZE (mode) != 2 || GET_CODE (x) != REG)
+          {
+	    output_operand_lossage ("invalid operand for code '%c'", code);
+	    return;
+          }
+
+        regno = REGNO (x);
+        if (!VFP_REGNO_OK_FOR_SINGLE (regno))
+          {
+	    output_operand_lossage ("invalid operand for code '%c'", code);
+	    return;
+          }
+
+	regno = regno - FIRST_VFP_REGNUM;
+	fprintf (stream, "d%d[%d]", regno/2, ((regno % 2) ? 2 : 0));
+      }
+      return;
+      
     default:
       if (x == 0)
 	{
@@ -13854,6 +15258,12 @@
 	default:
 	  gcc_assert (GET_CODE (x) != NEG);
 	  fputc ('#', stream);
+	  if (GET_CODE (x) == HIGH)
+	    {
+	      fputs (":lower16:", stream);
+	      x = XEXP (x, 0);
+	    }
+	    
 	  output_addr_const (stream, x);
 	  break;
 	}
@@ -14245,6 +15655,10 @@
      first insn after the following code_label if REVERSE is true.  */
   rtx start_insn = insn;
 
+  /* Don't do this if we're not considering conditional execution.  */
+  if (TARGET_NO_SINGLE_COND_EXEC)
+    return;
+
   /* If in state 4, check if the target branch is reached, in order to
      change back to state 0.  */
   if (arm_ccfsm_state == 4)
@@ -14618,6 +16032,11 @@
       if (mode == DFmode)
 	return VFP_REGNO_OK_FOR_DOUBLE (regno);
 
+      /* VFP registers can hold HFmode values, but there is no point in
+	 putting them there unless we have hardware conversion insns. */
+      if (mode == HFmode)
+	return TARGET_FP16 && VFP_REGNO_OK_FOR_SINGLE (regno);
+
       if (TARGET_NEON)
         return (VALID_NEON_DREG_MODE (mode) && VFP_REGNO_OK_FOR_DOUBLE (regno))
                || (VALID_NEON_QREG_MODE (mode)
@@ -14637,16 +16056,16 @@
 	return mode == SImode;
 
       if (IS_IWMMXT_REGNUM (regno))
-	return VALID_IWMMXT_REG_MODE (mode);
+	return VALID_IWMMXT_REG_MODE (mode) && mode != SImode;
     }
   
-  /* We allow any value to be stored in the general registers.
+  /* We allow almost any value to be stored in the general registers.
      Restrict doubleword quantities to even register pairs so that we can
-     use ldrd.  Do not allow Neon structure opaque modes in general registers;
-     they would use too many.  */
+     use ldrd.  Do not allow very large Neon structure opaque modes in
+     general registers; they would use too many.  */
   if (regno <= LAST_ARM_REGNUM)
     return !(TARGET_LDRD && GET_MODE_SIZE (mode) > 4 && (regno & 1) != 0)
-      && !VALID_NEON_STRUCT_MODE (mode);
+      && ARM_NUM_REGS (mode) <= 4;
 
   if (regno == FRAME_POINTER_REGNUM
       || regno == ARG_POINTER_REGNUM)
@@ -16103,6 +17522,15 @@
 }
 
 static void
+arm_init_fp16_builtins (void)
+{
+  tree fp16_type = make_node (REAL_TYPE);
+  TYPE_PRECISION (fp16_type) = 16;
+  layout_type (fp16_type);
+  (*lang_hooks.types.register_builtin_type) (fp16_type, "__fp16");
+}
+
+static void
 arm_init_builtins (void)
 {
   arm_init_tls_builtins ();
@@ -16112,6 +17540,71 @@
 
   if (TARGET_NEON)
     arm_init_neon_builtins ();
+
+  if (arm_fp16_format)
+    arm_init_fp16_builtins ();
+}
+
+/* Implement TARGET_INVALID_PARAMETER_TYPE.  */
+
+static const char *
+arm_invalid_parameter_type (const_tree t)
+{
+  if (SCALAR_FLOAT_TYPE_P (t) && TYPE_PRECISION (t) == 16)
+    return N_("function parameters cannot have __fp16 type");
+  return NULL;
+}
+
+/* Implement TARGET_INVALID_PARAMETER_TYPE.  */
+
+static const char *
+arm_invalid_return_type (const_tree t)
+{
+  if (SCALAR_FLOAT_TYPE_P (t) && TYPE_PRECISION (t) == 16)
+    return N_("functions cannot return __fp16 type");
+  return NULL;
+}
+
+/* Implement TARGET_PROMOTED_TYPE.  */
+
+static tree
+arm_promoted_type (const_tree t)
+{
+  if (SCALAR_FLOAT_TYPE_P (t) && TYPE_PRECISION (t) == 16)
+    return float_type_node;
+  return NULL_TREE;
+}
+
+/* Implement TARGET_CONVERT_TO_TYPE.
+   Specifically, this hook implements the peculiarity of the ARM
+   half-precision floating-point C semantics that requires conversions between
+   __fp16 to or from double to do an intermediate conversion to float.  */
+
+static tree
+arm_convert_to_type (tree type, tree expr)
+{
+  tree fromtype = TREE_TYPE (expr);
+  if (!SCALAR_FLOAT_TYPE_P (fromtype) || !SCALAR_FLOAT_TYPE_P (type))
+    return NULL_TREE;
+  if ((TYPE_PRECISION (fromtype) == 16 && TYPE_PRECISION (type) > 32)
+      || (TYPE_PRECISION (type) == 16 && TYPE_PRECISION (fromtype) > 32))
+    return convert (type, convert (float_type_node, expr));
+  return NULL_TREE;
+}
+
+/* Implement TARGET_SCALAR_MODE_SUPPORTED_P.
+   This simply adds HFmode as a supported mode; even though we don't
+   implement arithmetic on this type directly, it's supported by
+   optabs conversions, much the way the double-word arithmetic is
+   special-cased in the default hook.  */
+
+static bool
+arm_scalar_mode_supported_p (enum machine_mode mode)
+{
+  if (mode == HFmode)
+    return (arm_fp16_format != ARM_FP16_FORMAT_NONE);
+  else
+    return default_scalar_mode_supported_p (mode);
 }
 
 /* Errors in the source file can cause expand_expr to return const0_rtx
@@ -17191,6 +18684,7 @@
   unsigned HOST_WIDE_INT mask = 0xff;
   int i;
 
+  val = val & (unsigned HOST_WIDE_INT)0xffffffffu;
   if (val == 0) /* XXX */
     return 0;
 
@@ -18279,40 +19773,8 @@
       else
 	{
 	  int set_float_abi_attributes = 0;
-	  switch (arm_fpu_arch)
-	    {
-	    case FPUTYPE_FPA:
-	      fpu_name = "fpa";
-	      break;
-	    case FPUTYPE_FPA_EMU2:
-	      fpu_name = "fpe2";
-	      break;
-	    case FPUTYPE_FPA_EMU3:
-	      fpu_name = "fpe3";
-	      break;
-	    case FPUTYPE_MAVERICK:
-	      fpu_name = "maverick";
-	      break;
-	    case FPUTYPE_VFP:
-	      fpu_name = "vfp";
-	      set_float_abi_attributes = 1;
-	      break;
-	    case FPUTYPE_VFP3D16:
-	      fpu_name = "vfpv3-d16";
-	      set_float_abi_attributes = 1;
-	      break;
-	    case FPUTYPE_VFP3:
-	      fpu_name = "vfpv3";
-	      set_float_abi_attributes = 1;
-	      break;
-	    case FPUTYPE_NEON:
-	      fpu_name = "neon";
-	      set_float_abi_attributes = 1;
-	      break;
-	    default:
-	      abort();
-	    }
-	  if (set_float_abi_attributes)
+	  fpu_name = arm_fpu_desc->name;
+	  if (arm_fp_model == ARM_FP_MODEL_VFP)
 	    {
 	      if (TARGET_HARD_FLOAT)
 		asm_fprintf (asm_out_file, "\t.eabi_attribute 27, 3\n");
@@ -18362,6 +19824,11 @@
 	val = 6;
       asm_fprintf (asm_out_file, "\t.eabi_attribute 30, %d\n", val);
 
+      /* Tag_ABI_FP_16bit_format.  */
+      if (arm_fp16_format)
+	asm_fprintf (asm_out_file, "\t.eabi_attribute 38, %d\n",
+		     (int)arm_fp16_format);
+
       if (arm_lang_output_object_attributes_hook)
 	arm_lang_output_object_attributes_hook();
     }
@@ -18591,6 +20058,23 @@
   return 1;
 }
 
+/* Emit a fp16 constant appropriately padded to occupy a 4-byte word.
+   HFmode constant pool entries are actually loaded with ldr.  */
+void
+arm_emit_fp16_const (rtx c)
+{
+  REAL_VALUE_TYPE r;
+  long bits;
+
+  REAL_VALUE_FROM_CONST_DOUBLE (r, c);
+  bits = real_to_target (NULL, &r, HFmode);
+  if (WORDS_BIG_ENDIAN)
+    assemble_zeros (2);
+  assemble_integer (GEN_INT (bits), 2, BITS_PER_WORD, 1);
+  if (!WORDS_BIG_ENDIAN)
+    assemble_zeros (2);
+}
+
 const char *
 arm_output_load_gr (rtx *operands)
 {
@@ -18628,19 +20112,24 @@
    that way.  */
 
 static void
-arm_setup_incoming_varargs (CUMULATIVE_ARGS *cum,
+arm_setup_incoming_varargs (CUMULATIVE_ARGS *pcum,
 			    enum machine_mode mode,
 			    tree type,
 			    int *pretend_size,
 			    int second_time ATTRIBUTE_UNUSED)
 {
-  int nregs = cum->nregs;
-  if (nregs & 1
-      && ARM_DOUBLEWORD_ALIGN
-      && arm_needs_doubleword_align (mode, type))
-    nregs++;
-
+  int nregs;
+  
   cfun->machine->uses_anonymous_args = 1;
+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)
+    {
+      nregs = pcum->aapcs_ncrn;
+      if ((nregs & 1) && arm_needs_doubleword_align (mode, type))
+	nregs++;
+    }
+  else
+    nregs = pcum->nregs;
+  
   if (nregs < NUM_ARG_REGS)
     *pretend_size = (NUM_ARG_REGS - nregs) * UNITS_PER_WORD;
 }
@@ -19024,9 +20513,10 @@
       || mode == V16QImode || mode == V4SFmode || mode == V2DImode))
     return true;
 
-  if ((mode == V2SImode)
-      || (mode == V4HImode)
-      || (mode == V8QImode))
+  if ((TARGET_NEON || TARGET_IWMMXT)
+      && ((mode == V2SImode)
+	  || (mode == V4HImode)
+	  || (mode == V8QImode)))
     return true;
 
   return false;
@@ -19057,9 +20547,14 @@
   if (IS_FPA_REGNUM (regno))
     return (TARGET_AAPCS_BASED ? 96 : 16) + regno - FIRST_FPA_REGNUM;
 
-  /* FIXME: VFPv3 register numbering.  */
   if (IS_VFP_REGNUM (regno))
-    return 64 + regno - FIRST_VFP_REGNUM;
+    {
+      /* See comment in arm_dwarf_register_span.  */
+      if (VFP_REGNO_OK_FOR_SINGLE (regno))
+	  return 64 + regno - FIRST_VFP_REGNUM;
+      else
+	  return 256 + (regno - FIRST_VFP_REGNUM) / 2;
+    }
 
   if (IS_IWMMXT_GR_REGNUM (regno))
     return 104 + regno - FIRST_IWMMXT_GR_REGNUM;
@@ -19070,6 +20565,39 @@
   gcc_unreachable ();
 }
 
+/* Dwarf models VFPv3 registers as 32 64-bit registers.
+   GCC models tham as 64 32-bit registers, so we need to describe this to
+   the DWARF generation code.  Other registers can use the default.  */
+static rtx
+arm_dwarf_register_span(rtx rtl)
+{
+    unsigned regno;
+    int nregs;
+    int i;
+    rtx p;
+
+    regno = REGNO (rtl);
+    if (!IS_VFP_REGNUM (regno))
+	return NULL_RTX;
+
+    /* The EABI defines two VFP register ranges:
+	  64-95: Legacy VFPv2 numbering for S0-S31 (obsolescent)
+	  256-287: D0-D31
+       The recommended encodings for s0-s31 is a DW_OP_bit_piece of the
+       corresponding D register.  However gdb6.6 does not support this, so
+       we use the legacy encodings.  We also use these encodings for D0-D15
+       for compatibility with older debuggers.  */
+    if (VFP_REGNO_OK_FOR_SINGLE (regno))
+	return NULL_RTX;
+
+    nregs = GET_MODE_SIZE (GET_MODE (rtl)) / 8;
+    p = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc(nregs));
+    regno = (regno - FIRST_VFP_REGNUM) / 2;
+    for (i = 0; i < nregs; i++)
+      XVECEXP (p, 0, i) = gen_rtx_REG (DImode, 256 + regno + i);
+
+    return p;
+}
 
 #ifdef TARGET_UNWIND_INFO
 /* Emit unwind directives for a store-multiple instruction or stack pointer
@@ -19556,6 +21084,7 @@
     case cortexr4f:
     case cortexa8:
     case cortexa9:
+    case marvell_f:
       return 2;
 
     default:
@@ -19620,6 +21149,10 @@
       return "St9__va_list";
     }
 
+  /* Half-precision float.  */
+  if (TREE_CODE (type) == REAL_TYPE && TYPE_PRECISION (type) == 16)
+    return "Dh";
+
   if (TREE_CODE (type) != VECTOR_TYPE)
     return NULL;
 
@@ -19676,6 +21209,86 @@
      given on the command line.  */
   if (level > 0)
     flag_section_anchors = 2;
+
+  if (size)
+    {
+      /* Select optimizations that are a win for code size.
+
+	 The inlining options set below have two important
+	 consequences for functions not explicitly marked
+	 inline:
+	 - Static functions used once are inlined if
+	 sufficiently small.  Static functions used twice
+	 are not inlined.
+	 - Non-static functions are never inlined.
+	 So in effect, inlining will never cause two copies
+	 of function bodies to be created.  */
+      /* Empirical results show that these options benefit code
+	 size on arm.  */
+      /* FIXME: -fsee seems to be broken for Thumb-2.  */
+      /* flag_see = 1; */
+      flag_move_loop_invariants = 0;
+      /* In Thumb mode the function call code size overhead is typically very
+	 small, and narrow branch instructions have very limited range.
+	 Inlining even medium sized functions tends to bloat the caller and
+	 require the use of long branch instructions. On average the long
+	 branches cost more than eliminating the function call overhead saves,
+	 so we use extremely restrictive automatic inlining heuristics.  In ARM
+	 mode the results are fairly neutral, probably due to better constant
+	 pool placement. */
+      set_param_value ("max-inline-insns-single", 1);
+      set_param_value ("max-inline-insns-auto", 1);
+    }
+  else
+    {
+      /* CSL LOCAL */
+      /* Set flag_unroll_loops to a default value, so that we can tell
+	 if it was specified on the command line; see
+	 arm_override_options.  */
+      flag_unroll_loops = 2;
+      /* Promote loop indices to int where possible.  Consider moving this
+	 to -Os, also.  */
+      flag_promote_loop_indices = 1;
+    }
+}
+ 
+/* Return how many instructions to look ahead for better insn
+   scheduling.  */
+static int
+arm_multipass_dfa_lookahead (void)
+{
+  return (arm_tune == marvell_f) ? 4 : 0;
+}
+
+/* Return the minimum alignment required to load or store a
+   vector of the given type, which may be less than the
+   natural alignment of the type.  */
+
+static int
+arm_vector_min_alignment (const_tree type)
+{
+  if (TARGET_NEON)
+    {
+      /* The NEON element load and store instructions only require the
+	 alignment of the element type.  They can benefit from higher
+	 statically reported alignment, but we do not take advantage
+	 of that yet.  */
+      gcc_assert (TREE_CODE (type) == VECTOR_TYPE);
+      return TYPE_ALIGN_UNIT (TREE_TYPE (type));
+    }
+
+  return default_vector_min_alignment (type);
+}
+
+static bool
+arm_vector_always_misalign(const_tree type ATTRIBUTE_UNUSED)
+{
+  /* On big-endian targets array loads (vld1) and vector loads (vldm)
+     use a different format.  Always use the "misaligned" array variant.
+     FIXME: this still doesn't work for big-endian because of constant
+     loads and other operations using vldm ordering.  See
+     issue 6722.  */
+  return TARGET_NEON && !BYTES_BIG_ENDIAN;
 }
 
 #include "gt-arm.h"
diff -Nur a/gcc/config/arm/arm-cores.def b/gcc/config/arm/arm-cores.def
--- a/gcc/config/arm/arm-cores.def	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/arm/arm-cores.def	2010-01-25 09:50:28.975687047 +0100
@@ -104,6 +104,7 @@
 ARM_CORE("xscale",        xscale,	5TE,	                         FL_LDSCHED | FL_STRONG | FL_XSCALE, xscale)
 ARM_CORE("iwmmxt",        iwmmxt,	5TE,	                         FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_IWMMXT, xscale)
 ARM_CORE("iwmmxt2",       iwmmxt2,	5TE,	                         FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_IWMMXT, xscale)
+ARM_CORE("marvell-f",	  marvell_f,	5TE,				 FL_LDSCHED | FL_VFPV2 | FL_MARVELL_F, 9e)
 
 /* V5TEJ Architecture Processors */
 ARM_CORE("arm926ej-s",    arm926ejs,	5TEJ,	                         FL_LDSCHED, 9e)
@@ -117,9 +118,13 @@
 ARM_CORE("mpcorenovfp",	  mpcorenovfp,	6K,				 FL_LDSCHED, 9e)
 ARM_CORE("mpcore",	  mpcore,	6K,				 FL_LDSCHED | FL_VFPV2, 9e)
 ARM_CORE("arm1156t2-s",	  arm1156t2s,	6T2,				 FL_LDSCHED, 9e)
+
+/* V7 Architecture Processors */
+ARM_CORE("cortex-a5",	  cortexa5,	7A,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-a8",	  cortexa8,	7A,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-a9",	  cortexa9,	7A,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-r4",	  cortexr4,	7R,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-r4f",	  cortexr4f,	7R,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-m3",	  cortexm3,	7M,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-m1",	  cortexm1,	6M,				 FL_LDSCHED, 9e)
+ARM_CORE("cortex-m0",	  cortexm0,	6M,				 FL_LDSCHED, 9e)
diff -Nur a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
--- a/gcc/config/arm/arm.h	2009-04-23 02:31:13.000000000 +0200
+++ b/gcc/config/arm/arm.h	2010-01-25 09:50:28.975687047 +0100
@@ -85,6 +85,10 @@
 	  builtin_define ("__IWMMXT__");		\
 	if (TARGET_AAPCS_BASED)				\
 	  builtin_define ("__ARM_EABI__");		\
+	if (arm_tune_marvell_f)				\
+	  builtin_define ("__ARM_TUNE_MARVELL_F__");	\
+	if (low_irq_latency)				\
+	  builtin_define ("__low_irq_latency__");	\
     } while (0)
 
 /* The various ARM cores.  */
@@ -199,6 +203,13 @@
 #define TARGET_AAPCS_BASED \
     (arm_abi != ARM_ABI_APCS && arm_abi != ARM_ABI_ATPCS)
 
+/* True if we should avoid generating conditional execution instructions.  */
+#define TARGET_NO_COND_EXEC		(arm_tune_marvell_f && !optimize_size)
+/* Avoid most conditional instructions, but allow pairs with opposite
+   conditions and the same destination.  */
+#define TARGET_NO_SINGLE_COND_EXEC \
+  ((arm_tune_cortex_a9 || arm_tune_marvell_f) && !optimize_size)
+
 #define TARGET_HARD_TP			(target_thread_pointer == TP_CP15)
 #define TARGET_SOFT_TP			(target_thread_pointer == TP_SOFT)
 
@@ -211,35 +222,43 @@
 /* Thumb-1 only.  */
 #define TARGET_THUMB1_ONLY		(TARGET_THUMB1 && !arm_arch_notm)
 
+#define TARGET_FPA_EMU2			(TARGET_FPA && arm_fpu_desc->rev == 2)
 /* The following two macros concern the ability to execute coprocessor
    instructions for VFPv3 or NEON.  TARGET_VFP3/TARGET_VFPD32 are currently
    only ever tested when we know we are generating for VFP hardware; we need
    to be more careful with TARGET_NEON as noted below.  */
 
 /* FPU is has the full VFPv3/NEON register file of 32 D registers.  */
-#define TARGET_VFPD32 (arm_fp_model == ARM_FP_MODEL_VFP \
-		       && (arm_fpu_arch == FPUTYPE_VFP3 \
-			   || arm_fpu_arch == FPUTYPE_NEON))
+#define TARGET_VFPD32 (TARGET_VFP && arm_arch_vfp_regs == VFP_REG_D32)
 
 /* FPU supports VFPv3 instructions.  */
-#define TARGET_VFP3 (arm_fp_model == ARM_FP_MODEL_VFP \
-		     && (arm_fpu_arch == FPUTYPE_VFP3D16 \
-			 || TARGET_VFPD32))
+#define TARGET_VFP3 (TARGET_VFP && arm_arch_vfp_rev >= 3)
+
+/* FPU only supports VFP single-precision instructions.  */
+#define TARGET_VFP_SINGLE (TARGET_VFP && arm_arch_vfp_regs == VFP_REG_SINGLE)
+
+/* FPU supports VFP double-precision instructions.  */
+#define TARGET_VFP_DOUBLE (TARGET_VFP && arm_arch_vfp_regs != VFP_REG_SINGLE)
+
+/* FPU supports half-precision floating-point with NEON element load/store.  */
+#define TARGET_NEON_FP16 (TARGET_VFP && arm_arch_vfp_neon && arm_arch_vfp_fp16)
+
+/* FPU supports VFP half-precision floating-point.  */
+#define TARGET_FP16 (TARGET_VFP && arm_arch_vfp_fp16)
 
 /* FPU supports Neon instructions.  The setting of this macro gets
    revealed via __ARM_NEON__ so we add extra guards upon TARGET_32BIT
    and TARGET_HARD_FLOAT to ensure that NEON instructions are
    available.  */
 #define TARGET_NEON (TARGET_32BIT && TARGET_HARD_FLOAT \
-		     && arm_fp_model == ARM_FP_MODEL_VFP \
-		     && arm_fpu_arch == FPUTYPE_NEON)
+		     && TARGET_VFP && arm_arch_vfp_neon)
 
 /* "DSP" multiply instructions, eg. SMULxy.  */
 #define TARGET_DSP_MULTIPLY \
-  (TARGET_32BIT && arm_arch5e && arm_arch_notm)
+  (TARGET_32BIT && arm_arch5e && (arm_arch_notm || arm_arch7em))
 /* Integer SIMD instructions, and extend-accumulate instructions.  */
 #define TARGET_INT_SIMD \
-  (TARGET_32BIT && arm_arch6 && arm_arch_notm)
+  (TARGET_32BIT && arm_arch6 && (arm_arch_notm || arm_arch7em))
 
 /* Should MOVW/MOVT be used in preference to a constant pool.  */
 #define TARGET_USE_MOVT (arm_arch_thumb2 && !optimize_size)
@@ -289,40 +308,30 @@
   ARM_FP_MODEL_VFP
 };
 
-extern enum arm_fp_model arm_fp_model;
-
-/* Which floating point hardware is available.  Also update
-   fp_model_for_fpu in arm.c when adding entries to this list.  */
-enum fputype
-{
-  /* No FP hardware.  */
-  FPUTYPE_NONE,
-  /* Full FPA support.  */
-  FPUTYPE_FPA,
-  /* Emulated FPA hardware, Issue 2 emulator (no LFM/SFM).  */
-  FPUTYPE_FPA_EMU2,
-  /* Emulated FPA hardware, Issue 3 emulator.  */
-  FPUTYPE_FPA_EMU3,
-  /* Cirrus Maverick floating point co-processor.  */
-  FPUTYPE_MAVERICK,
-  /* VFP.  */
-  FPUTYPE_VFP,
-  /* VFPv3-D16.  */
-  FPUTYPE_VFP3D16,
-  /* VFPv3.  */
-  FPUTYPE_VFP3,
-  /* Neon.  */
-  FPUTYPE_NEON
+enum vfp_reg_type {
+    VFP_REG_D16,
+    VFP_REG_D32,
+    VFP_REG_SINGLE
 };
 
-/* Recast the floating point class to be the floating point attribute.  */
-#define arm_fpu_attr ((enum attr_fpu) arm_fpu_tune)
-
-/* What type of floating point to tune for */
-extern enum fputype arm_fpu_tune;
+extern const struct arm_fpu_desc
+{
+  const char *name;
+  enum arm_fp_model model;
+  int rev;
+  enum vfp_reg_type myregs;
+  int neon;
+  int fp16;
+} *arm_fpu_desc;
+
+#define arm_fp_model arm_fpu_desc->model
+#define arm_arch_vfp_rev arm_fpu_desc->rev
+#define arm_arch_vfp_regs arm_fpu_desc->myregs
+#define arm_arch_vfp_neon arm_fpu_desc->neon
+#define arm_arch_vfp_fp16 arm_fpu_desc->fp16
 
-/* What type of floating point instructions are available */
-extern enum fputype arm_fpu_arch;
+/* Which floating point hardware to schedule for.  */
+extern int arm_fpu_attr;
 
 enum float_abi_type
 {
@@ -337,6 +346,21 @@
 #define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_SOFT
 #endif
 
+/* Which __fp16 format to use.
+   The enumeration values correspond to the numbering for the
+   Tag_ABI_FP_16bit_format attribute.
+ */
+enum arm_fp16_format_type
+{
+  ARM_FP16_FORMAT_NONE = 0,
+  ARM_FP16_FORMAT_IEEE = 1,
+  ARM_FP16_FORMAT_ALTERNATIVE = 2
+};
+
+extern enum arm_fp16_format_type arm_fp16_format;
+#define LARGEST_EXPONENT_IS_NORMAL(bits) \
+    ((bits) == 16 && arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)
+
 /* Which ABI to use.  */
 enum arm_abi_type
 {
@@ -383,12 +407,18 @@
 /* Nonzero if instructions not present in the 'M' profile can be used.  */
 extern int arm_arch_notm;
 
+/* Nonzero if instructions present in ARMv7E-M can be used.  */
+extern int arm_arch7em;
+
 /* Nonzero if this chip can benefit from load scheduling.  */
 extern int arm_ld_sched;
 
 /* Nonzero if generating thumb code.  */
 extern int thumb_code;
 
+/* Nonzero if generating Janus2 code. */
+extern int janus2_code;
+
 /* Nonzero if this chip is a StrongARM.  */
 extern int arm_tune_strongarm;
 
@@ -404,6 +434,9 @@
 /* Nonzero if tuning for XScale.  */
 extern int arm_tune_xscale;
 
+/* Nonzero if tuning for Marvell Feroceon.  */
+extern int arm_tune_marvell_f;
+
 /* Nonzero if tuning for stores via the write buffer.  */
 extern int arm_tune_wbuf;
 
@@ -423,6 +456,10 @@
 /* Nonzero if chip supports integer division instruction.  */
 extern int arm_arch_hwdiv;
 
+/* Nonzero if we should minimize interrupt latency of the
+   generated code.  */
+extern int low_irq_latency;
+
 #ifndef TARGET_DEFAULT
 #define TARGET_DEFAULT  (MASK_APCS_FRAME)
 #endif
@@ -757,12 +794,11 @@
 	fixed_regs[regno] = call_used_regs[regno] = 1;		\
     }								\
 								\
-  if (TARGET_THUMB && optimize_size)				\
-    {								\
-      /* When optimizing for size, it's better not to use	\
-	 the HI regs, because of the overhead of stacking 	\
-	 them.  */						\
-      /* ??? Is this still true for thumb2?  */			\
+  if (TARGET_THUMB1 && optimize_size)				\
+    {                                                           \
+      /* When optimizing for size on Thumb-1, it's better not	\
+        to use the HI regs, because of the overhead of		\
+        stacking them.  */                                      \
       for (regno = FIRST_HI_REGNUM;				\
 	   regno <= LAST_HI_REGNUM; ++regno)			\
 	fixed_regs[regno] = call_used_regs[regno] = 1;		\
@@ -881,6 +917,9 @@
 /* The number of (integer) argument register available.  */
 #define NUM_ARG_REGS		4
 
+/* And similarly for the VFP.  */
+#define NUM_VFP_ARG_REGS	16
+
 /* Return the register number of the N'th (integer) argument.  */
 #define ARG_REGISTER(N) 	(N - 1)
 
@@ -1059,7 +1098,7 @@
   (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))
 
 #define VALID_IWMMXT_REG_MODE(MODE) \
- (arm_vector_mode_supported_p (MODE) || (MODE) == DImode)
+ (arm_vector_mode_supported_p (MODE) || (MODE) == DImode || (MODE) == SImode)
 
 /* Modes valid for Neon D registers.  */
 #define VALID_NEON_DREG_MODE(MODE) \
@@ -1230,11 +1269,14 @@
      || reg_classes_intersect_p (VFP_REGS, (CLASS))	\
    : 0)
 
-/* We need to define this for LO_REGS on thumb.  Otherwise we can end up
-   using r0-r4 for function arguments, r7 for the stack frame and don't
-   have enough left over to do doubleword arithmetic.  */
+/* We need to define this for LO_REGS on Thumb-1.  Otherwise we can end up
+   using r0-r4 for function arguments, r7 for the stack frame and don't have
+   enough left over to do doubleword arithmetic.  For Thumb-2 all the
+   potentially problematic instructions accept high registers so this is not
+   necessary.  Care needs to be taken to avoid adding new Thumb-2 patterns
+   that require many low registers.  */
 #define CLASS_LIKELY_SPILLED_P(CLASS)	\
-    ((TARGET_THUMB && (CLASS) == LO_REGS)	\
+    ((TARGET_THUMB1 && (CLASS) == LO_REGS)	\
      || (CLASS) == CC_REG)
 
 /* The class value for index registers, and the one for base regs.  */
@@ -1245,7 +1287,7 @@
    when addressing quantities in QI or HI mode; if we don't know the
    mode, then we must be conservative.  */
 #define MODE_BASE_REG_CLASS(MODE)					\
-    (TARGET_32BIT ? CORE_REGS :					\
+    (TARGET_32BIT ? (TARGET_THUMB2 ? LO_REGS : CORE_REGS) :					\
      (((MODE) == SImode) ? BASE_REGS : LO_REGS))
 
 /* For Thumb we can not support SP+reg addressing, so we return LO_REGS
@@ -1346,6 +1388,9 @@
 	  else if (TARGET_MAVERICK && TARGET_HARD_FLOAT)		   \
 	    /* Need to be careful, -256 is not a valid offset.  */	   \
 	    low = val >= 0 ? (val & 0xff) : -((-val) & 0xff);		   \
+	  else if (TARGET_REALLY_IWMMXT && MODE == SImode)		   \
+	    /* Need to be careful, -1024 is not a valid offset.  */	   \
+	    low = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);		   \
 	  else if (MODE == SImode					   \
 		   || (MODE == SFmode && TARGET_SOFT_FLOAT)		   \
 		   || ((MODE == HImode || MODE == QImode) && ! arm_arch4)) \
@@ -1416,13 +1461,17 @@
 /* If defined, gives a class of registers that cannot be used as the
    operand of a SUBREG that changes the mode of the object illegally.  */
 
-/* Moves between FPA_REGS and GENERAL_REGS are two memory insns.  */
+/* Moves between FPA_REGS and GENERAL_REGS are two memory insns.
+   Moves between VFP_REGS and GENERAL_REGS are a single insn, but
+   it is typically more expensive than a single memory access.  We set
+   the cost to less than two memory accesses so that floating
+   point to integer conversion does not go through memory.  */
 #define REGISTER_MOVE_COST(MODE, FROM, TO)		\
   (TARGET_32BIT ?						\
    ((FROM) == FPA_REGS && (TO) != FPA_REGS ? 20 :	\
     (FROM) != FPA_REGS && (TO) == FPA_REGS ? 20 :	\
-    IS_VFP_CLASS (FROM) && !IS_VFP_CLASS (TO) ? 10 :	\
-    !IS_VFP_CLASS (FROM) && IS_VFP_CLASS (TO) ? 10 :	\
+    IS_VFP_CLASS (FROM) && !IS_VFP_CLASS (TO) ? 15 :	\
+    !IS_VFP_CLASS (FROM) && IS_VFP_CLASS (TO) ? 15 :	\
     (FROM) == IWMMXT_REGS && (TO) != IWMMXT_REGS ? 4 :  \
     (FROM) != IWMMXT_REGS && (TO) == IWMMXT_REGS ? 4 :  \
     (FROM) == IWMMXT_GR_REGS || (TO) == IWMMXT_GR_REGS ? 20 :  \
@@ -1491,9 +1540,10 @@
 
 /* Define how to find the value returned by a library function
    assuming the value has mode MODE.  */
-#define LIBCALL_VALUE(MODE)  \
-  (TARGET_32BIT && TARGET_HARD_FLOAT_ABI && TARGET_FPA			\
-   && GET_MODE_CLASS (MODE) == MODE_FLOAT				\
+#define LIBCALL_VALUE(MODE)  						\
+  (TARGET_AAPCS_BASED ? aapcs_libcall_value (MODE)			\
+   : (TARGET_32BIT && TARGET_HARD_FLOAT_ABI && TARGET_FPA		\
+      && GET_MODE_CLASS (MODE) == MODE_FLOAT)				\
    ? gen_rtx_REG (MODE, FIRST_FPA_REGNUM)				\
    : TARGET_32BIT && TARGET_HARD_FLOAT_ABI && TARGET_MAVERICK		\
      && GET_MODE_CLASS (MODE) == MODE_FLOAT				\
@@ -1502,22 +1552,16 @@
    ? gen_rtx_REG (MODE, FIRST_IWMMXT_REGNUM) 				\
    : gen_rtx_REG (MODE, ARG_REGISTER (1)))
 
-/* Define how to find the value returned by a function.
-   VALTYPE is the data type of the value (as a tree).
-   If the precise function being called is known, FUNC is its FUNCTION_DECL;
-   otherwise, FUNC is 0.  */
-#define FUNCTION_VALUE(VALTYPE, FUNC) \
-  arm_function_value (VALTYPE, FUNC);
-
-/* 1 if N is a possible register number for a function value.
-   On the ARM, only r0 and f0 can return results.  */
-/* On a Cirrus chip, mvf0 can return results.  */
-#define FUNCTION_VALUE_REGNO_P(REGNO)  \
-  ((REGNO) == ARG_REGISTER (1) \
-   || (TARGET_32BIT && ((REGNO) == FIRST_CIRRUS_FP_REGNUM)		\
-       && TARGET_HARD_FLOAT_ABI && TARGET_MAVERICK)			\
-   || ((REGNO) == FIRST_IWMMXT_REGNUM && TARGET_IWMMXT_ABI) \
-   || (TARGET_32BIT && ((REGNO) == FIRST_FPA_REGNUM)			\
+/* 1 if REGNO is a possible register number for a function value.  */
+#define FUNCTION_VALUE_REGNO_P(REGNO)				\
+  ((REGNO) == ARG_REGISTER (1)					\
+   || (TARGET_AAPCS_BASED && TARGET_32BIT 			\
+       && TARGET_VFP && TARGET_HARD_FLOAT			\
+       && (REGNO) == FIRST_VFP_REGNUM)				\
+   || (TARGET_32BIT && ((REGNO) == FIRST_CIRRUS_FP_REGNUM)	\
+       && TARGET_HARD_FLOAT_ABI && TARGET_MAVERICK)		\
+   || ((REGNO) == FIRST_IWMMXT_REGNUM && TARGET_IWMMXT_ABI)	\
+   || (TARGET_32BIT && ((REGNO) == FIRST_FPA_REGNUM)		\
        && TARGET_HARD_FLOAT_ABI && TARGET_FPA))
 
 /* Amount of memory needed for an untyped call to save all possible return
@@ -1617,9 +1661,27 @@
    that is in text_section.  */
 extern GTY(()) rtx thumb_call_via_label[14];
 
+/* The number of potential ways of assigning to a co-processor.  */
+#define ARM_NUM_COPROC_SLOTS 1
+
+/* Enumeration of procedure calling standard variants.  We don't really 
+   support all of these yet.  */
+enum arm_pcs
+{
+  ARM_PCS_AAPCS,	/* Base standard AAPCS.  */
+  ARM_PCS_AAPCS_VFP,	/* Use VFP registers for floating point values.  */
+  ARM_PCS_AAPCS_IWMMXT, /* Use iWMMXT registers for vectors.  */
+  /* This must be the last AAPCS variant.  */
+  ARM_PCS_AAPCS_LOCAL,	/* Private call within this compilation unit.  */
+  ARM_PCS_ATPCS,	/* ATPCS.  */
+  ARM_PCS_APCS,		/* APCS (legacy Linux etc).  */
+  ARM_PCS_UNKNOWN
+};
+
+/* We can't define this inside a generator file because it needs enum
+   machine_mode.  */
 /* A C type for declaring a variable that is used as the first argument of
-   `FUNCTION_ARG' and other related values.  For some target machines, the
-   type `int' suffices and can hold the number of bytes of argument so far.  */
+   `FUNCTION_ARG' and other related values.  */
 typedef struct
 {
   /* This is the number of registers of arguments scanned so far.  */
@@ -1628,9 +1690,33 @@
   int iwmmxt_nregs;
   int named_count;
   int nargs;
-  int can_split;
+  /* Which procedure call variant to use for this call.  */
+  enum arm_pcs pcs_variant;
+
+  /* AAPCS related state tracking.  */
+  int aapcs_arg_processed;  /* No need to lay out this argument again.  */
+  int aapcs_cprc_slot;      /* Index of co-processor rules to handle
+			       this argument, or -1 if using core
+			       registers.  */
+  int aapcs_ncrn;
+  int aapcs_next_ncrn;
+  rtx aapcs_reg;	    /* Register assigned to this argument.  */
+  int aapcs_partial;	    /* How many bytes are passed in regs (if
+			       split between core regs and stack.
+			       Zero otherwise.  */
+  int aapcs_cprc_failed[ARM_NUM_COPROC_SLOTS];
+  int can_split;	    /* Argument can be split between core regs
+			       and the stack.  */
+  /* Private data for tracking VFP register allocation */
+  unsigned aapcs_vfp_regs_free;
+  unsigned aapcs_vfp_reg_alloc;
+  int aapcs_vfp_rcount;
+  /* Can't include insn-modes.h because this header is needed before we
+     generate it.  */
+  int /* enum machine_mode */ aapcs_vfp_rmode;
 } CUMULATIVE_ARGS;
 
+
 /* Define where to put the arguments to a function.
    Value is zero to push the argument on the stack,
    or a hard register in which to store the argument.
@@ -1674,13 +1760,7 @@
    of mode MODE and data type TYPE.
    (TYPE is null for libcalls where that information may not be available.)  */
 #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)	\
-  (CUM).nargs += 1;					\
-  if (arm_vector_mode_supported_p (MODE)		\
-      && (CUM).named_count > (CUM).nargs		\
-      && TARGET_IWMMXT_ABI)				\
-    (CUM).iwmmxt_nregs += 1;				\
-  else							\
-    (CUM).nregs += ARM_NUM_REGS2 (MODE, TYPE)
+  arm_function_arg_advance (&(CUM), (MODE), (TYPE), (NAMED))
 
 /* If defined, a C expression that gives the alignment boundary, in bits, of an
    argument with the specified mode and type.  If it is not defined,
@@ -1692,9 +1772,11 @@
 
 /* 1 if N is a possible register number for function argument passing.
    On the ARM, r0-r3 are used to pass args.  */
-#define FUNCTION_ARG_REGNO_P(REGNO)	\
-   (IN_RANGE ((REGNO), 0, 3)		\
-    || (TARGET_IWMMXT_ABI		\
+#define FUNCTION_ARG_REGNO_P(REGNO)					\
+   (IN_RANGE ((REGNO), 0, 3)						\
+    || (TARGET_AAPCS_BASED && TARGET_VFP && TARGET_HARD_FLOAT		\
+	&& IN_RANGE ((REGNO), FIRST_VFP_REGNUM, FIRST_VFP_REGNUM + 15))	\
+    || (TARGET_IWMMXT_ABI						\
 	&& IN_RANGE ((REGNO), FIRST_IWMMXT_REGNUM, FIRST_IWMMXT_REGNUM + 9)))
 
 
@@ -2324,7 +2406,8 @@
 /* Try to generate sequences that don't involve branches, we can then use
    conditional instructions */
 #define BRANCH_COST(speed_p, predictable_p) \
-  (TARGET_32BIT ? 4 : (optimize > 0 ? 2 : 0))
+  (TARGET_32BIT ? (TARGET_THUMB2 && optimize_size ? 1 : 4) \
+		: (optimize > 0 ? 2 : 0))
 
 /* Position Independent Code.  */
 /* We decide which register to use based on the compilation options and
@@ -2392,6 +2475,7 @@
 
 /* The arm5 clz instruction returns 32.  */
 #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  ((VALUE) = 32, 1)
+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  ((VALUE) = 32, 1)
 
 #undef  ASM_APP_OFF
 #define ASM_APP_OFF (TARGET_THUMB1 ? "\t.code\t16\n" : \
@@ -2404,6 +2488,19 @@
       if (TARGET_ARM)					\
 	asm_fprintf (STREAM,"\tstmfd\t%r!,{%r}\n",	\
 		     STACK_POINTER_REGNUM, REGNO);	\
+      else if (TARGET_THUMB1				\
+	       && (REGNO) == STATIC_CHAIN_REGNUM)	\
+	{						\
+	  /* We can't push STATIC_CHAIN_REGNUM (r12) directly with Thumb-1.
+	     We know that ASM_OUTPUT_REG_PUSH will be matched with
+	     ASM_OUTPUT_REG_POP, and that r7 isn't used by the function
+	     profiler, so we can use it as a scratch reg.  WARNING: This isn't
+	     safe in the general case!  It may be sensitive to future changes
+	     in final.c:profile_function.  */		\
+	  asm_fprintf (STREAM, "\tpush\t{r7}\n");	\
+	  asm_fprintf (STREAM, "\tmov\tr7, %r\n", REGNO);\
+	  asm_fprintf (STREAM, "\tpush\t{r7}\n");	\
+	}						\
       else						\
 	asm_fprintf (STREAM, "\tpush {%r}\n", REGNO);	\
     } while (0)
@@ -2415,6 +2512,14 @@
       if (TARGET_ARM)					\
 	asm_fprintf (STREAM, "\tldmfd\t%r!,{%r}\n",	\
 		     STACK_POINTER_REGNUM, REGNO);	\
+      else if (TARGET_THUMB1				\
+	       && (REGNO) == STATIC_CHAIN_REGNUM)	\
+	{						\
+	  /* See comment in ASM_OUTPUT_REG_PUSH.  */	\
+	  asm_fprintf (STREAM, "\tpop\t{r7}\n");	\
+	  asm_fprintf (STREAM, "\tmov\t%r, r7\n", REGNO);\
+	  asm_fprintf (STREAM, "\tpop\t{r7}\n");	\
+	}						\
       else						\
 	asm_fprintf (STREAM, "\tpop {%r}\n", REGNO);	\
     } while (0)
diff -Nur a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
--- a/gcc/config/arm/arm.md	2009-05-16 15:28:27.000000000 +0200
+++ b/gcc/config/arm/arm.md	2010-01-25 09:50:28.985687200 +0100
@@ -99,6 +99,7 @@
 			  ; correctly for PIC usage.
    (UNSPEC_GOTSYM_OFF 24) ; The offset of the start of the the GOT from a
 			  ; a given symbolic address.
+   (UNSPEC_RBIT 25)	  ; rbit operation.
   ]
 )
 
@@ -131,6 +132,8 @@
    (VUNSPEC_WCMP_EQ  12) ; Used by the iWMMXt WCMPEQ instructions
    (VUNSPEC_WCMP_GTU 13) ; Used by the iWMMXt WCMPGTU instructions
    (VUNSPEC_WCMP_GT  14) ; Used by the iwMMXT WCMPGT instructions
+   (VUNSPEC_ALIGN16  15) ; Used to force 16-byte alignment.
+   (VUNSPEC_ALIGN32  16) ; Used to force 32-byte alignment.
    (VUNSPEC_EH_RETURN 20); Use to override the return address for exception
 			 ; handling.
   ]
@@ -144,6 +147,10 @@
 ; patterns that share the same RTL in both ARM and Thumb code.
 (define_attr "is_thumb" "no,yes" (const (symbol_ref "thumb_code")))
 
+; FIX_JANUS is set to 'yes' when compiling for Janus2, it causes to
+; add a nop after shifts, in order to work around a Janus2 bug
+(define_attr "fix_janus" "no,yes" (const (symbol_ref "janus2_code")))
+
 ; IS_STRONGARM is set to 'yes' when compiling for StrongARM, it affects
 ; scheduling decisions for the load unit and the multiplier.
 (define_attr "is_strongarm" "no,yes" (const (symbol_ref "arm_tune_strongarm")))
@@ -158,7 +165,7 @@
 ; Floating Point Unit.  If we only have floating point emulation, then there
 ; is no point in scheduling the floating point insns.  (Well, for best
 ; performance we should try and group them together).
-(define_attr "fpu" "none,fpa,fpe2,fpe3,maverick,vfp,vfpv3d16,vfpv3,neon"
+(define_attr "fpu" "none,fpa,fpe2,fpe3,maverick,vfp"
   (const (symbol_ref "arm_fpu_attr")))
 
 ; LENGTH of an instruction (in bytes)
@@ -185,7 +192,7 @@
 ;; scheduling information.
 
 (define_attr "insn"
-        "mov,mvn,smulxy,smlaxy,smlalxy,smulwy,smlawx,mul,muls,mla,mlas,umull,umulls,umlal,umlals,smull,smulls,smlal,smlals,smlawy,smuad,smuadx,smlad,smladx,smusd,smusdx,smlsd,smlsdx,smmul,smmulr,smmla,umaal,smlald,smlsld,clz,mrs,msr,xtab,sdiv,udiv,other"
+        "mov,mvn,and,orr,eor,smulxy,smlaxy,smlalxy,smulwy,smlawx,mul,muls,mla,mlas,umull,umulls,umlal,umlals,smull,smulls,smlal,smlals,smlawy,smuad,smuadx,smlad,smladx,smusd,smusdx,smlsd,smlsdx,smmul,smmulr,smmla,umaal,smlald,smlsld,clz,mrs,msr,xtab,sdiv,udiv,other"
         (const_string "other"))
 
 ; TYPE attribute is used to detect floating point instructions which, if
@@ -251,8 +258,6 @@
 (define_attr "ldsched" "no,yes" (const (symbol_ref "arm_ld_sched")))
 
 ;; Classification of NEON instructions for scheduling purposes.
-;; Do not set this attribute and the "type" attribute together in
-;; any one instruction pattern.
 (define_attr "neon_type"
    "neon_int_1,\
    neon_int_2,\
@@ -415,7 +420,7 @@
 
 (define_attr "generic_sched" "yes,no"
   (const (if_then_else 
-          (ior (eq_attr "tune" "arm926ejs,arm1020e,arm1026ejs,arm1136js,arm1136jfs,cortexa8,cortexa9")
+          (ior (eq_attr "tune" "arm926ejs,arm1020e,arm1026ejs,arm1136js,arm1136jfs,cortexa8,cortexa9,marvell_f")
 	      (eq_attr "tune_cortexr4" "yes"))
           (const_string "no")
           (const_string "yes"))))
@@ -423,7 +428,7 @@
 (define_attr "generic_vfp" "yes,no"
   (const (if_then_else
 	  (and (eq_attr "fpu" "vfp")
-	       (eq_attr "tune" "!arm1020e,arm1022e,cortexa8,cortexa9")
+	       (eq_attr "tune" "!arm1020e,arm1022e,cortexa8,cortexa9,marvell_f")
 	       (eq_attr "tune_cortexr4" "no"))
 	  (const_string "yes")
 	  (const_string "no"))))
@@ -437,6 +442,8 @@
 (include "cortex-a9.md")
 (include "cortex-r4.md")
 (include "cortex-r4f.md")
+(include "marvell-f.md")
+(include "marvell-f-vfp.md")
 (include "vfp11.md")
 
 
@@ -472,9 +479,9 @@
   if (TARGET_THUMB1)
     {
       if (GET_CODE (operands[1]) != REG)
-        operands[1] = force_reg (SImode, operands[1]);
+        operands[1] = force_reg (DImode, operands[1]);
       if (GET_CODE (operands[2]) != REG)
-        operands[2] = force_reg (SImode, operands[2]);
+        operands[2] = force_reg (DImode, operands[2]);
      }
   "
 )
@@ -620,10 +627,11 @@
    sub%?\\t%0, %1, #%n2
    sub%?\\t%0, %1, #%n2
    #"
-  "TARGET_32BIT &&
-   GET_CODE (operands[2]) == CONST_INT
+  "TARGET_32BIT
+   && GET_CODE (operands[2]) == CONST_INT
    && !(const_ok_for_arm (INTVAL (operands[2]))
-        || const_ok_for_arm (-INTVAL (operands[2])))"
+        || const_ok_for_arm (-INTVAL (operands[2])))
+   && (reload_completed || !arm_eliminable_register (operands[1]))"
   [(clobber (const_int 0))]
   "
   arm_split_constant (PLUS, SImode, curr_insn,
@@ -639,10 +647,10 @@
 ;; register.  Trying to reload it will always fail catastrophically,
 ;; so never allow those alternatives to match if reloading is needed.
 
-(define_insn "*thumb1_addsi3"
-  [(set (match_operand:SI          0 "register_operand" "=l,l,l,*rk,*hk,l,!k")
-	(plus:SI (match_operand:SI 1 "register_operand" "%0,0,l,*0,*0,!k,!k")
-		 (match_operand:SI 2 "nonmemory_operand" "I,J,lL,*hk,*rk,!M,!O")))]
+(define_insn_and_split "*thumb1_addsi3"
+  [(set (match_operand:SI          0 "register_operand" "=l,l,l,*rk,*hk,l,!k,l,l")
+	(plus:SI (match_operand:SI 1 "register_operand" "%0,0,l,*0,*0,!k,!k,0,l")
+		 (match_operand:SI 2 "nonmemory_operand" "I,J,lL,*hk,*rk,!M,!O,Pa,Pb")))]
   "TARGET_THUMB1"
   "*
    static const char * const asms[] = 
@@ -653,7 +661,9 @@
      \"add\\t%0, %0, %2\",
      \"add\\t%0, %0, %2\",
      \"add\\t%0, %1, %2\",
-     \"add\\t%0, %1, %2\"
+     \"add\\t%0, %1, %2\",
+     \"#\",
+     \"#\"
    };
    if ((which_alternative == 2 || which_alternative == 6)
        && GET_CODE (operands[2]) == CONST_INT
@@ -661,7 +671,22 @@
      return \"sub\\t%0, %1, #%n2\";
    return asms[which_alternative];
   "
-  [(set_attr "length" "2")]
+  "&& reload_completed && CONST_INT_P (operands[2])
+   && operands[1] != stack_pointer_rtx
+   && (INTVAL (operands[2]) > 255 || INTVAL (operands[2]) < -255)"
+  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))
+   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 3)))]
+  {
+    HOST_WIDE_INT offset = INTVAL (operands[2]);
+    if (offset > 255)
+      offset = 255;
+    else if (offset < -255)
+      offset = -255;
+    
+    operands[3] = GEN_INT (offset);
+    operands[2] = GEN_INT (INTVAL (operands[2]) - offset);
+  }
+  [(set_attr "length" "2,2,2,2,2,2,2,4,4")]
 )
 
 ;; Reloading and elimination of the frame pointer can
@@ -854,7 +879,11 @@
   [(set_attr "conds" "use")
    (set (attr "type") (if_then_else (match_operand 4 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*addsi3_carryin_alt1"
@@ -938,7 +967,7 @@
   [(set (match_operand:DF          0 "s_register_operand" "")
 	(plus:DF (match_operand:DF 1 "s_register_operand" "")
 		 (match_operand:DF 2 "arm_float_add_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   if (TARGET_MAVERICK
       && !cirrus_fp_register (operands[2], DFmode))
@@ -1176,7 +1205,7 @@
   [(set (match_operand:DF           0 "s_register_operand" "")
 	(minus:DF (match_operand:DF 1 "arm_float_rhs_operand" "")
 		  (match_operand:DF 2 "arm_float_rhs_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   if (TARGET_MAVERICK)
     {
@@ -1332,6 +1361,49 @@
    (set_attr "predicable" "yes")]
 )
 
+; The combiner cannot combine the first and last insns in the
+; following sequence because of the intervening insn, so help the
+; combiner with this splitter.  The combiner does attempt to split
+; this particular combination but does not know this exact split.
+; Note that the combiner puts the constant at the outermost operation
+; as a part of canonicalization.
+;
+; mul r3, r2, r1
+; <add/sub> r3, r3, <constant>
+; add r3, r3, r4
+
+(define_split
+  [(set (match_operand:SI 0 "s_register_operand" "")
+	(match_operator:SI 1 "plusminus_operator"
+	 [(plus:SI (mult:SI (match_operand:SI 2 "s_register_operand" "")
+			    (match_operand:SI 3 "s_register_operand" ""))
+		   (match_operand:SI 4 "s_register_operand" ""))
+	  (match_operand:SI 5 "arm_immediate_operand" "")]))]
+  "TARGET_32BIT"
+  [(set (match_dup 0)
+	(plus:SI (mult:SI (match_dup 2) (match_dup 3))
+		 (match_dup 4)))
+   (set (match_dup 0)
+	(match_op_dup:SI 1 [(match_dup 0) (match_dup 5)]))]
+  "")
+
+; Likewise for MLS.  MLS is available only on select architectures.
+
+(define_split
+  [(set (match_operand:SI 0 "s_register_operand" "")
+	(match_operator:SI 1 "plusminus_operator"
+	 [(minus:SI (match_operand:SI 2 "s_register_operand" "")
+		    (mult:SI (match_operand:SI 3 "s_register_operand" "")
+			     (match_operand:SI 4 "s_register_operand" "")))
+	  (match_operand:SI 5 "arm_immediate_operand" "")]))]
+  "TARGET_32BIT && arm_arch_thumb2"
+  [(set (match_dup 0)
+	(minus:SI (match_dup 2)
+		  (mult:SI (match_dup 3) (match_dup 4))))
+   (set (match_dup 0)
+	(match_op_dup:SI 1 [(match_dup 0) (match_dup 5)]))]
+  "")
+
 (define_insn "*mulsi3addsi_compare0"
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV
@@ -1713,7 +1785,7 @@
   [(set (match_operand:DF          0 "s_register_operand" "")
 	(mult:DF (match_operand:DF 1 "s_register_operand" "")
 		 (match_operand:DF 2 "arm_float_rhs_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   if (TARGET_MAVERICK
       && !cirrus_fp_register (operands[2], DFmode))
@@ -1733,7 +1805,7 @@
   [(set (match_operand:DF 0 "s_register_operand" "")
 	(div:DF (match_operand:DF 1 "arm_float_rhs_operand" "")
 		(match_operand:DF 2 "arm_float_rhs_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE)"
   "")
 
 ;; Modulo insns
@@ -1960,6 +2032,7 @@
   DONE;
   "
   [(set_attr "length" "4,4,16")
+   (set_attr "insn" "and")
    (set_attr "predicable" "yes")]
 )
 
@@ -1969,7 +2042,8 @@
 		(match_operand:SI 2 "register_operand" "l")))]
   "TARGET_THUMB1"
   "and\\t%0, %0, %2"
-  [(set_attr "length" "2")]
+  [(set_attr "length" "2")
+   (set_attr "insn" "and")]
 )
 
 (define_insn "*andsi3_compare0"
@@ -1984,7 +2058,8 @@
   "@
    and%.\\t%0, %1, %2
    bic%.\\t%0, %1, #%B2"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "and,*")]
 )
 
 (define_insn "*andsi3_compare0_scratch"
@@ -2280,7 +2355,7 @@
 	  }
       }
 
-    target = operands[0];
+    target = copy_rtx (operands[0]);
     /* Avoid using a subreg as a subtarget, and avoid writing a paradoxical 
        subreg as the final target.  */
     if (GET_CODE (target) == SUBREG)
@@ -2528,7 +2603,11 @@
    (set_attr "shift" "2")
    (set (attr "type") (if_then_else (match_operand 3 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*andsi_notsi_si_compare0"
@@ -2576,6 +2655,7 @@
    orr%?\\t%Q0, %Q1, %2
    #"
   [(set_attr "length" "4,8")
+   (set_attr "insn" "orr")
    (set_attr "predicable" "yes")]
 )
 
@@ -2638,7 +2718,8 @@
 		(match_operand:SI 2 "register_operand" "l")))]
   "TARGET_THUMB1"
   "orr\\t%0, %0, %2"
-  [(set_attr "length" "2")]
+  [(set_attr "length" "2")
+   (set_attr "insn" "orr")]
 )
 
 (define_peephole2
@@ -2663,7 +2744,8 @@
 	(ior:SI (match_dup 1) (match_dup 2)))]
   "TARGET_32BIT"
   "orr%.\\t%0, %1, %2"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "orr")]
 )
 
 (define_insn "*iorsi3_compare0_scratch"
@@ -2674,7 +2756,8 @@
    (clobber (match_scratch:SI 0 "=r"))]
   "TARGET_32BIT"
   "orr%.\\t%0, %1, %2"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "orr")]
 )
 
 (define_insn "xordi3"
@@ -2697,7 +2780,8 @@
    eor%?\\t%Q0, %Q1, %2
    #"
   [(set_attr "length" "4,8")
-   (set_attr "predicable" "yes")]
+   (set_attr "predicable" "yes")
+   (set_attr "insn" "eor")]
 )
 
 (define_insn "*xordi_sesidi_di"
@@ -2728,7 +2812,8 @@
 		(match_operand:SI 2 "arm_rhs_operand" "rI")))]
   "TARGET_32BIT"
   "eor%?\\t%0, %1, %2"
-  [(set_attr "predicable" "yes")]
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "eor")]
 )
 
 (define_insn "*thumb1_xorsi3"
@@ -2737,7 +2822,8 @@
 		(match_operand:SI 2 "register_operand" "l")))]
   "TARGET_THUMB1"
   "eor\\t%0, %0, %2"
-  [(set_attr "length" "2")]
+  [(set_attr "length" "2")
+   (set_attr "insn" "eor")]
 )
 
 (define_insn "*xorsi3_compare0"
@@ -2749,7 +2835,8 @@
 	(xor:SI (match_dup 1) (match_dup 2)))]
   "TARGET_32BIT"
   "eor%.\\t%0, %1, %2"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "eor")]
 )
 
 (define_insn "*xorsi3_compare0_scratch"
@@ -2906,7 +2993,7 @@
 	 (smax:SI (match_operand:SI 1 "s_register_operand" "")
 		  (match_operand:SI 2 "arm_rhs_operand" "")))
     (clobber (reg:CC CC_REGNUM))])]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "
   if (operands[2] == const0_rtx || operands[2] == constm1_rtx)
     {
@@ -2933,7 +3020,8 @@
 		 (const_int -1)))]
   "TARGET_32BIT"
   "orr%?\\t%0, %1, %1, asr #31"
-  [(set_attr "predicable" "yes")]
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "orr")]
 )
 
 (define_insn "*arm_smax_insn"
@@ -2941,7 +3029,7 @@
 	(smax:SI (match_operand:SI 1 "s_register_operand"  "%0,?r")
 		 (match_operand:SI 2 "arm_rhs_operand"    "rI,rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_COND_EXEC"
   "@
    cmp\\t%1, %2\;movlt\\t%0, %2
    cmp\\t%1, %2\;movge\\t%0, %1\;movlt\\t%0, %2"
@@ -2955,7 +3043,7 @@
 	 (smin:SI (match_operand:SI 1 "s_register_operand" "")
 		  (match_operand:SI 2 "arm_rhs_operand" "")))
     (clobber (reg:CC CC_REGNUM))])]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "
   if (operands[2] == const0_rtx)
     {
@@ -2973,7 +3061,8 @@
 		 (const_int 0)))]
   "TARGET_32BIT"
   "and%?\\t%0, %1, %1, asr #31"
-  [(set_attr "predicable" "yes")]
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "and")]
 )
 
 (define_insn "*arm_smin_insn"
@@ -2981,7 +3070,7 @@
 	(smin:SI (match_operand:SI 1 "s_register_operand" "%0,?r")
 		 (match_operand:SI 2 "arm_rhs_operand" "rI,rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM  && !TARGET_NO_COND_EXEC"
   "@
    cmp\\t%1, %2\;movge\\t%0, %2
    cmp\\t%1, %2\;movlt\\t%0, %1\;movge\\t%0, %2"
@@ -2995,7 +3084,7 @@
 	 (umax:SI (match_operand:SI 1 "s_register_operand" "")
 		  (match_operand:SI 2 "arm_rhs_operand" "")))
     (clobber (reg:CC CC_REGNUM))])]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   ""
 )
 
@@ -3004,7 +3093,7 @@
 	(umax:SI (match_operand:SI 1 "s_register_operand" "0,r,?r")
 		 (match_operand:SI 2 "arm_rhs_operand" "rI,0,rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM  && !TARGET_NO_COND_EXEC"
   "@
    cmp\\t%1, %2\;movcc\\t%0, %2
    cmp\\t%1, %2\;movcs\\t%0, %1
@@ -3019,7 +3108,7 @@
 	 (umin:SI (match_operand:SI 1 "s_register_operand" "")
 		  (match_operand:SI 2 "arm_rhs_operand" "")))
     (clobber (reg:CC CC_REGNUM))])]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   ""
 )
 
@@ -3028,7 +3117,7 @@
 	(umin:SI (match_operand:SI 1 "s_register_operand" "0,r,?r")
 		 (match_operand:SI 2 "arm_rhs_operand" "rI,0,rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_COND_EXEC"
   "@
    cmp\\t%1, %2\;movcs\\t%0, %2
    cmp\\t%1, %2\;movcc\\t%0, %1
@@ -3043,7 +3132,7 @@
 	 [(match_operand:SI 1 "s_register_operand" "r")
 	  (match_operand:SI 2 "s_register_operand" "r")]))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "*
   operands[3] = gen_rtx_fmt_ee (minmax_code (operands[3]), SImode,
 				operands[1], operands[2]);
@@ -3163,11 +3252,23 @@
   [(set (match_operand:SI            0 "register_operand" "=l,l")
 	(ashift:SI (match_operand:SI 1 "register_operand" "l,0")
 		   (match_operand:SI 2 "nonmemory_operand" "N,l")))]
-  "TARGET_THUMB1"
+  "TARGET_THUMB1 && !janus2_code"
   "lsl\\t%0, %1, %2"
   [(set_attr "length" "2")]
 )
 
+(define_insn "*thumb1_ashlsi3_janus2"
+  [(set (match_operand:SI            0 "register_operand" "=l,l")
+        (ashift:SI (match_operand:SI 1 "register_operand" "l,0")
+                   (match_operand:SI 2 "nonmemory_operand" "N,l")))]
+  "TARGET_THUMB1 && janus2_code"
+  "@
+  lsl\\t%0, %1, %2
+  lsl\\t%0, %1, %2\;nop"
+  [(set_attr "length" "2,4")]
+)
+
+
 (define_expand "ashrdi3"
   [(set (match_operand:DI              0 "s_register_operand" "")
         (ashiftrt:DI (match_operand:DI 1 "s_register_operand" "")
@@ -3200,6 +3301,7 @@
   "TARGET_32BIT"
   "movs\\t%R0, %R1, asr #1\;mov\\t%Q0, %Q1, rrx"
   [(set_attr "conds" "clob")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -3219,11 +3321,22 @@
   [(set (match_operand:SI              0 "register_operand" "=l,l")
 	(ashiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
 		     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
-  "TARGET_THUMB1"
+  "TARGET_THUMB1 && !janus2_code"
   "asr\\t%0, %1, %2"
   [(set_attr "length" "2")]
 )
 
+(define_insn "*thumb1_ashrsi3_janus2"
+  [(set (match_operand:SI              0 "register_operand" "=l,l")
+        (ashiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
+                     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
+  "TARGET_THUMB1 && janus2_code"
+  "@
+  asr\\t%0, %1, %2
+  asr\\t%0, %1, %2\;nop"
+  [(set_attr "length" "2,4")]
+)
+
 (define_expand "lshrdi3"
   [(set (match_operand:DI              0 "s_register_operand" "")
         (lshiftrt:DI (match_operand:DI 1 "s_register_operand" "")
@@ -3256,6 +3369,7 @@
   "TARGET_32BIT"
   "movs\\t%R0, %R1, lsr #1\;mov\\t%Q0, %Q1, rrx"
   [(set_attr "conds" "clob")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -3278,11 +3392,22 @@
   [(set (match_operand:SI              0 "register_operand" "=l,l")
 	(lshiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
 		     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
-  "TARGET_THUMB1"
+  "TARGET_THUMB1 && !janus2_code"
   "lsr\\t%0, %1, %2"
   [(set_attr "length" "2")]
 )
 
+(define_insn "*thumb1_lshrsi3_janus2"
+  [(set (match_operand:SI              0 "register_operand" "=l,l")
+        (lshiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
+                     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
+  "TARGET_THUMB1 && janus2_code"
+  "@
+  lsr\\t%0, %1, %2
+  lsr\\t%0, %1, %2; nop"
+  [(set_attr "length" "2,4")]
+)
+
 (define_expand "rotlsi3"
   [(set (match_operand:SI              0 "s_register_operand" "")
 	(rotatert:SI (match_operand:SI 1 "s_register_operand" "")
@@ -3324,11 +3449,20 @@
   [(set (match_operand:SI              0 "register_operand" "=l")
 	(rotatert:SI (match_operand:SI 1 "register_operand" "0")
 		     (match_operand:SI 2 "register_operand" "l")))]
-  "TARGET_THUMB1"
+  "TARGET_THUMB1 && !janus2_code"
   "ror\\t%0, %0, %2"
   [(set_attr "length" "2")]
 )
 
+(define_insn "*thumb1_rotrsi3_janus2"
+  [(set (match_operand:SI              0 "register_operand" "=l")
+        (rotatert:SI (match_operand:SI 1 "register_operand" "0")
+                     (match_operand:SI 2 "register_operand" "l")))]
+  "TARGET_THUMB1 && janus2_code"
+  "ror\\t%0, %0, %2; nop"
+  [(set_attr "length" "4")]
+)
+
 (define_insn "*arm_shiftsi3"
   [(set (match_operand:SI   0 "s_register_operand" "=r")
 	(match_operator:SI  3 "shift_operator"
@@ -3340,7 +3474,11 @@
    (set_attr "shift" "1")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*shiftsi3_compare0"
@@ -3357,7 +3495,11 @@
    (set_attr "shift" "1")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*shiftsi3_compare0_scratch"
@@ -3370,7 +3512,11 @@
   "TARGET_32BIT"
   "* return arm_output_shift(operands, 1);"
   [(set_attr "conds" "set")
-   (set_attr "shift" "1")]
+   (set_attr "shift" "1")
+   (set (attr "length") (if_then_else (and (match_operand 2 "s_register_operand" "")
+                                           (eq_attr "fix_janus" "yes"))
+                                      (const_int 8)
+                                      (const_int 4)))]
 )
 
 (define_insn "*arm_notsi_shiftsi"
@@ -3382,9 +3528,14 @@
   "mvn%?\\t%0, %1%S3"
   [(set_attr "predicable" "yes")
    (set_attr "shift" "1")
+   (set_attr "insn" "mvn")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*arm_notsi_shiftsi_compare0"
@@ -3399,9 +3550,14 @@
   "mvn%.\\t%0, %1%S3"
   [(set_attr "conds" "set")
    (set_attr "shift" "1")
+   (set_attr "insn" "mvn")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*arm_not_shiftsi_compare0_scratch"
@@ -3415,9 +3571,14 @@
   "mvn%.\\t%0, %1%S3"
   [(set_attr "conds" "set")
    (set_attr "shift" "1")
+   (set_attr "insn" "mvn")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 ;; We don't really have extzv, but defining this using shifts helps
@@ -3550,12 +3711,12 @@
 (define_expand "negdf2"
   [(set (match_operand:DF         0 "s_register_operand" "")
 	(neg:DF (match_operand:DF 1 "s_register_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE)"
   "")
 
 ;; abssi2 doesn't really clobber the condition codes if a different register
 ;; is being set.  To keep things simple, assume during rtl manipulations that
-;; it does, but tell the final scan operator the truth.  Similarly for
+;; it does, and the splitter will eliminate it.  Similarly for
 ;; (neg (abs...))
 
 (define_expand "abssi2"
@@ -3567,22 +3728,28 @@
   "
   if (TARGET_THUMB1)
     operands[2] = gen_rtx_SCRATCH (SImode);
+  else if (TARGET_NO_SINGLE_COND_EXEC)
+    {
+      emit_insn(gen_rtx_SET(VOIDmode, operands[0],
+			    gen_rtx_ABS(SImode, operands[1])));
+      DONE;
+    }
   else
     operands[2] = gen_rtx_REG (CCmode, CC_REGNUM);
 ")
 
 (define_insn "*arm_abssi2"
-  [(set (match_operand:SI 0 "s_register_operand" "=r,&r")
-	(abs:SI (match_operand:SI 1 "s_register_operand" "0,r")))
+  [(set (match_operand:SI         0 "s_register_operand" "=r")
+	(abs:SI (match_operand:SI 1 "s_register_operand" "r")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
-  "@
-   cmp\\t%0, #0\;rsblt\\t%0, %0, #0
-   eor%?\\t%0, %1, %1, asr #31\;sub%?\\t%0, %0, %1, asr #31"
-  [(set_attr "conds" "clob,*")
-   (set_attr "shift" "1")
+  "TARGET_32BIT && !TARGET_NO_SINGLE_COND_EXEC"
+  "#"
+  [(set_attr "shift" "1")
    ;; predicable can't be set based on the variant, so left as no
-   (set_attr "length" "8")]
+   (set (attr "length")
+	(if_then_else (eq_attr "is_thumb" "yes")
+		      (const_int 10)
+		      (const_int 8)))]
 )
 
 (define_insn_and_split "*thumb1_abssi2"
@@ -3600,17 +3767,17 @@
 )
 
 (define_insn "*arm_neg_abssi2"
-  [(set (match_operand:SI 0 "s_register_operand" "=r,&r")
-	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" "0,r"))))
+  [(set (match_operand:SI 0 "s_register_operand" "=r")
+	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" "r"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
-  "@
-   cmp\\t%0, #0\;rsbgt\\t%0, %0, #0
-   eor%?\\t%0, %1, %1, asr #31\;rsb%?\\t%0, %0, %1, asr #31"
-  [(set_attr "conds" "clob,*")
-   (set_attr "shift" "1")
+  "TARGET_32BIT && !TARGET_NO_SINGLE_COND_EXEC"
+  "#"
+  [(set_attr "shift" "1")
    ;; predicable can't be set based on the variant, so left as no
-   (set_attr "length" "8")]
+   (set (attr "length")
+	(if_then_else (eq_attr "is_thumb" "yes")
+		      (const_int 10)
+		      (const_int 8)))]
 )
 
 (define_insn_and_split "*thumb1_neg_abssi2"
@@ -3627,6 +3794,93 @@
   [(set_attr "length" "6")]
 )
 
+;; Simplified version for when avoiding conditional execution
+(define_insn "*arm_nocond_abssi2"
+  [(set (match_operand:SI         0 "s_register_operand" "=&r")
+	(abs:SI (match_operand:SI 1 "s_register_operand" "r")))]
+  "TARGET_32BIT && TARGET_NO_SINGLE_COND_EXEC"
+  "#"
+  [(set_attr "shift" "1")
+   (set_attr "length" "8")
+   (set_attr "predicable" "yes")]
+)
+
+(define_insn "*arm_nocond_neg_abssi2"
+  [(set (match_operand:SI         0 "s_register_operand" "=&r")
+	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" "r"))))]
+  "TARGET_32BIT && TARGET_NO_SINGLE_COND_EXEC"
+  "#"
+  [(set_attr "shift" "1")
+   (set_attr "length" "8")
+   (set_attr "predicable" "yes")]
+)
+
+;; Splitters for ABS patterns.
+
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(abs:SI (match_operand:SI 1 "s_register_operand" "")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_32BIT && reload_completed && rtx_equal_p(operands[0], operands[1])"
+  [(set (reg:CC CC_REGNUM) (compare:CC (match_dup 1) (const_int 0)))
+   (cond_exec (lt (reg:CC CC_REGNUM) (const_int 0))
+	      (set (match_dup 0) (neg:SI (match_dup 1))))]
+)
+
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" ""))))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_32BIT && reload_completed && rtx_equal_p(operands[0], operands[1])"
+  [(set (reg:CC CC_REGNUM) (compare:CC (match_dup 1) (const_int 0)))
+   (cond_exec (gt (reg:CC CC_REGNUM) (const_int 0))
+	      (set (match_dup 0) (neg:SI (match_dup 1))))]
+)
+
+;; GCC does not add/remove clobbers when matching splitters, so we need
+;; variants with and without the CC clobber.
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(abs:SI (match_operand:SI 1 "s_register_operand" "")))]
+  "TARGET_32BIT && reload_completed && !rtx_equal_p(operands[0], operands[1])"
+  [(set (match_dup 0) (xor:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+			      (match_dup 1)))
+   (set (match_dup 0) (minus:SI (match_dup 0)
+				(ashiftrt:SI (match_dup 1) (const_int 31))))]
+)
+
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(abs:SI (match_operand:SI 1 "s_register_operand" "")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_32BIT && reload_completed && !rtx_equal_p(operands[0], operands[1])"
+  [(set (match_dup 0) (xor:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+			      (match_dup 1)))
+   (set (match_dup 0) (minus:SI (match_dup 0)
+				(ashiftrt:SI (match_dup 1) (const_int 31))))]
+)
+
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" ""))))]
+  "TARGET_32BIT && reload_completed && !rtx_equal_p(operands[0], operands[1])"
+  [(set (match_dup 0) (xor:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+			      (match_dup 1)))
+   (set (match_dup 0) (minus:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+				(match_dup 0)))]
+)
+
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" ""))))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_32BIT && reload_completed && !rtx_equal_p(operands[0], operands[1])"
+  [(set (match_dup 0) (xor:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+			      (match_dup 1)))
+   (set (match_dup 0) (minus:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+				(match_dup 0)))]
+)
+
 (define_expand "abssf2"
   [(set (match_operand:SF         0 "s_register_operand" "")
 	(abs:SF (match_operand:SF 1 "s_register_operand" "")))]
@@ -3636,7 +3890,7 @@
 (define_expand "absdf2"
   [(set (match_operand:DF         0 "s_register_operand" "")
 	(abs:DF (match_operand:DF 1 "s_register_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "")
 
 (define_expand "sqrtsf2"
@@ -3648,7 +3902,7 @@
 (define_expand "sqrtdf2"
   [(set (match_operand:DF 0 "s_register_operand" "")
 	(sqrt:DF (match_operand:DF 1 "s_register_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE)"
   "")
 
 (define_insn_and_split "one_cmpldi2"
@@ -3682,7 +3936,8 @@
 	(not:SI (match_operand:SI 1 "s_register_operand"  "r")))]
   "TARGET_32BIT"
   "mvn%?\\t%0, %1"
-  [(set_attr "predicable" "yes")]
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "mvn")]
 )
 
 (define_insn "*thumb1_one_cmplsi2"
@@ -3690,7 +3945,8 @@
 	(not:SI (match_operand:SI 1 "register_operand"  "l")))]
   "TARGET_THUMB1"
   "mvn\\t%0, %1"
-  [(set_attr "length" "2")]
+  [(set_attr "length" "2")
+   (set_attr "insn" "mvn")]
 )
 
 (define_insn "*notsi_compare0"
@@ -3701,7 +3957,8 @@
 	(not:SI (match_dup 1)))]
   "TARGET_32BIT"
   "mvn%.\\t%0, %1"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "mvn")]
 )
 
 (define_insn "*notsi_compare0_scratch"
@@ -3711,11 +3968,40 @@
    (clobber (match_scratch:SI 0 "=r"))]
   "TARGET_32BIT"
   "mvn%.\\t%0, %1"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "mvn")]
 )
 
 ;; Fixed <--> Floating conversion insns
 
+(define_expand "floatsihf2"
+  [(set (match_operand:HF           0 "general_operand" "")
+	(float:HF (match_operand:SI 1 "general_operand" "")))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1 = gen_reg_rtx (SFmode);
+    expand_float (op1, operands[1], 0);
+    op1 = convert_to_mode (HFmode, op1, 0);
+    emit_move_insn (operands[0], op1);
+    DONE;
+  }"
+)
+
+(define_expand "floatdihf2"
+  [(set (match_operand:HF           0 "general_operand" "")
+	(float:HF (match_operand:DI 1 "general_operand" "")))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1 = gen_reg_rtx (SFmode);
+    expand_float (op1, operands[1], 0);
+    op1 = convert_to_mode (HFmode, op1, 0);
+    emit_move_insn (operands[0], op1);
+    DONE;
+  }"
+)
+
 (define_expand "floatsisf2"
   [(set (match_operand:SF           0 "s_register_operand" "")
 	(float:SF (match_operand:SI 1 "s_register_operand" "")))]
@@ -3731,7 +4017,7 @@
 (define_expand "floatsidf2"
   [(set (match_operand:DF           0 "s_register_operand" "")
 	(float:DF (match_operand:SI 1 "s_register_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   if (TARGET_MAVERICK)
     {
@@ -3740,6 +4026,30 @@
     }
 ")
 
+(define_expand "fix_trunchfsi2"
+  [(set (match_operand:SI         0 "general_operand" "")
+	(fix:SI (fix:HF (match_operand:HF 1 "general_operand"  ""))))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1 = convert_to_mode (SFmode, operands[1], 0);
+    expand_fix (operands[0], op1, 0);
+    DONE;
+  }"
+)
+
+(define_expand "fix_trunchfdi2"
+  [(set (match_operand:DI         0 "general_operand" "")
+	(fix:DI (fix:HF (match_operand:HF 1 "general_operand"  ""))))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1 = convert_to_mode (SFmode, operands[1], 0);
+    expand_fix (operands[0], op1, 0);
+    DONE;
+  }"
+)
+
 (define_expand "fix_truncsfsi2"
   [(set (match_operand:SI         0 "s_register_operand" "")
 	(fix:SI (fix:SF (match_operand:SF 1 "s_register_operand"  ""))))]
@@ -3759,7 +4069,7 @@
 (define_expand "fix_truncdfsi2"
   [(set (match_operand:SI         0 "s_register_operand" "")
 	(fix:SI (fix:DF (match_operand:DF 1 "s_register_operand"  ""))))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   if (TARGET_MAVERICK)
     {
@@ -3776,9 +4086,25 @@
   [(set (match_operand:SF  0 "s_register_operand" "")
 	(float_truncate:SF
  	 (match_operand:DF 1 "s_register_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   ""
 )
+
+/* DFmode -> HFmode conversions have to go through SFmode.  */
+(define_expand "truncdfhf2"
+  [(set (match_operand:HF  0 "general_operand" "")
+	(float_truncate:HF
+ 	 (match_operand:DF 1 "general_operand" "")))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1;
+    op1 = convert_to_mode (SFmode, operands[1], 0);
+    op1 = convert_to_mode (HFmode, op1, 0);
+    emit_move_insn (operands[0], op1);
+    DONE;
+  }"
+)
 
 ;; Zero and sign extension instructions.
 
@@ -3800,6 +4126,7 @@
     return \"mov%?\\t%R0, #0\";
   "
   [(set_attr "length" "8")
+   (set_attr "insn" "mov")
    (set_attr "predicable" "yes")]
 )
 
@@ -3843,6 +4170,7 @@
   "
   [(set_attr "length" "8")
    (set_attr "shift" "1")
+   (set_attr "insn" "mov")
    (set_attr "predicable" "yes")]
 )
 
@@ -4123,6 +4451,28 @@
   ""
 )
 
+(define_code_iterator ior_xor [ior xor])
+
+(define_split
+  [(set (match_operand:SI 0 "s_register_operand" "")
+	(ior_xor:SI (and:SI (ashift:SI
+			     (match_operand:SI 1 "s_register_operand" "")
+			     (match_operand:SI 2 "const_int_operand" ""))
+			    (match_operand:SI 3 "const_int_operand" ""))
+		    (zero_extend:SI
+		     (match_operator 5 "subreg_lowpart_operator"
+		      [(match_operand:SI 4 "s_register_operand" "")]))))]
+  "TARGET_32BIT
+   && (INTVAL (operands[3])
+       == (GET_MODE_MASK (GET_MODE (operands[5]))
+           & (GET_MODE_MASK (GET_MODE (operands[5]))
+	      << (INTVAL (operands[2])))))"
+  [(set (match_dup 0) (ior_xor:SI (ashift:SI (match_dup 1) (match_dup 2))
+				  (match_dup 4)))
+   (set (match_dup 0) (zero_extend:SI (match_dup 5)))]
+  "operands[5] = gen_lowpart (GET_MODE (operands[5]), operands[0]);"
+)
+
 (define_insn "*compareqi_eq0"
   [(set (reg:CC_Z CC_REGNUM)
 	(compare:CC_Z (match_operand:QI 0 "s_register_operand" "r")
@@ -4639,9 +4989,24 @@
 (define_expand "extendsfdf2"
   [(set (match_operand:DF                  0 "s_register_operand" "")
 	(float_extend:DF (match_operand:SF 1 "s_register_operand"  "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   ""
 )
+
+/* HFmode -> DFmode conversions have to go through SFmode.  */
+(define_expand "extendhfdf2"
+  [(set (match_operand:DF                  0 "general_operand" "")
+	(float_extend:DF (match_operand:HF 1 "general_operand"  "")))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1;
+    op1 = convert_to_mode (SFmode, operands[1], 0);
+    op1 = convert_to_mode (DFmode, op1, 0);
+    emit_insn (gen_movdf (operands[0], op1));
+    DONE;
+  }"
+)
 
 ;; Move insns (including loads and stores)
 
@@ -4877,6 +5242,7 @@
   }"
   [(set_attr "length" "4,4,6,2,2,6,4,4")
    (set_attr "type" "*,*,*,load2,store2,load2,store2,*")
+   (set_attr "insn" "*,mov,*,*,*,*,*,mov")
    (set_attr "pool_range" "*,*,*,*,*,1020,*,*")]
 )
 
@@ -4903,14 +5269,6 @@
 			       optimize && can_create_pseudo_p ());
           DONE;
         }
-
-      if (TARGET_USE_MOVT && !target_word_relocations
-	  && GET_CODE (operands[1]) == SYMBOL_REF
-	  && !flag_pic && !arm_tls_referenced_p (operands[1]))
-	{
-	  arm_emit_movpair (operands[0], operands[1]);
-	  DONE;
-	}
     }
   else /* TARGET_THUMB1...  */
     {
@@ -4984,18 +5342,9 @@
    (set_attr "length" "4")]
 )
 
-(define_insn "*arm_movw"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=r")
-	(high:SI (match_operand:SI 1 "general_operand"      "i")))]
-  "TARGET_32BIT"
-  "movw%?\t%0, #:lower16:%c1"
-  [(set_attr "predicable" "yes")
-   (set_attr "length" "4")]
-)
-
 (define_insn "*arm_movsi_insn"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,rk,m")
-	(match_operand:SI 1 "general_operand"      "rk, I,K,N,mi,rk"))]
+	(match_operand:SI 1 "general_operand"      "rk, I,K,j,mi,rk"))]
   "TARGET_ARM && ! TARGET_IWMMXT
    && !(TARGET_HARD_FLOAT && TARGET_VFP)
    && (   register_operand (operands[0], SImode)
@@ -5008,6 +5357,7 @@
    ldr%?\\t%0, %1
    str%?\\t%1, %0"
   [(set_attr "type" "*,*,*,*,load1,store1")
+   (set_attr "insn" "mov,mov,mvn,mov,*,*")
    (set_attr "predicable" "yes")
    (set_attr "pool_range" "*,*,*,*,4096,*")
    (set_attr "neg_pool_range" "*,*,*,*,4084,*")]
@@ -5027,6 +5377,19 @@
   "
 )
 
+(define_split
+  [(set (match_operand:SI 0 "arm_general_register_operand" "")
+	(match_operand:SI 1 "general_operand" ""))]
+  "TARGET_32BIT
+   && TARGET_USE_MOVT && GET_CODE (operands[1]) == SYMBOL_REF
+   && !flag_pic && !target_word_relocations
+   && !arm_tls_referenced_p (operands[1])"
+  [(clobber (const_int 0))]
+{
+  arm_emit_movpair (operands[0], operands[1]);
+  DONE;
+})
+
 (define_insn "*thumb1_movsi_insn"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=l,l,l,l,l,>,l, m,*lhk")
 	(match_operand:SI 1 "general_operand"      "l, I,J,K,>,l,mi,l,*lhk"))]
@@ -5065,7 +5428,7 @@
    (set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))]
   "
   {
-    unsigned HOST_WIDE_INT val = INTVAL (operands[1]);
+    unsigned HOST_WIDE_INT val = INTVAL (operands[1]) & 0xffffffffu;
     unsigned HOST_WIDE_INT mask = 0xff;
     int i;
     
@@ -5627,6 +5990,7 @@
    ldr%(h%)\\t%0, %1\\t%@ movhi"
   [(set_attr "type" "*,*,store1,load1")
    (set_attr "predicable" "yes")
+   (set_attr "insn" "mov,mvn,*,*")
    (set_attr "pool_range" "*,*,*,256")
    (set_attr "neg_pool_range" "*,*,*,244")]
 )
@@ -5638,7 +6002,8 @@
   "@
    mov%?\\t%0, %1\\t%@ movhi
    mvn%?\\t%0, #%B1\\t%@ movhi"
-  [(set_attr "predicable" "yes")]
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "mov,mvn")]
 )
 
 (define_expand "thumb_movhi_clobber"
@@ -5769,6 +6134,7 @@
    ldr%(b%)\\t%0, %1
    str%(b%)\\t%1, %0"
   [(set_attr "type" "*,*,load1,store1")
+   (set_attr "insn" "mov,mvn,*,*")
    (set_attr "predicable" "yes")]
 )
 
@@ -5787,9 +6153,111 @@
    mov\\t%0, %1"
   [(set_attr "length" "2")
    (set_attr "type" "*,load1,store1,*,*,*")
+   (set_attr "insn" "*,*,*,mov,mov,mov")
    (set_attr "pool_range" "*,32,*,*,*,*")]
 )
 
+;; HFmode moves
+(define_expand "movhf"
+  [(set (match_operand:HF 0 "general_operand" "")
+	(match_operand:HF 1 "general_operand" ""))]
+  "TARGET_EITHER"
+  "
+  if (TARGET_32BIT)
+    {
+      if (GET_CODE (operands[0]) == MEM)
+        operands[1] = force_reg (HFmode, operands[1]);
+    }
+  else /* TARGET_THUMB1 */
+    {
+      if (can_create_pseudo_p ())
+        {
+           if (GET_CODE (operands[0]) != REG)
+	     operands[1] = force_reg (HFmode, operands[1]);
+        }
+    }
+  "
+)
+
+(define_insn "*arm32_movhf"
+  [(set (match_operand:HF 0 "nonimmediate_operand" "=r,m,r,r")
+	(match_operand:HF 1 "general_operand"	   " m,r,r,F"))]
+  "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_FP16)
+   && (	  s_register_operand (operands[0], HFmode)
+       || s_register_operand (operands[1], HFmode))"
+  "*
+  switch (which_alternative)
+    {
+    case 0:	/* ARM register from memory */
+      return \"ldr%(h%)\\t%0, %1\\t%@ __fp16\";
+    case 1:	/* memory from ARM register */
+      return \"str%(h%)\\t%1, %0\\t%@ __fp16\";
+    case 2:	/* ARM register from ARM register */
+      return \"mov%?\\t%0, %1\\t%@ __fp16\";
+    case 3:	/* ARM register from constant */
+      {
+	REAL_VALUE_TYPE r;
+	long bits;
+	rtx ops[4];
+
+	REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);
+	bits = real_to_target (NULL, &r, HFmode);
+	ops[0] = operands[0];
+	ops[1] = GEN_INT (bits);
+	ops[2] = GEN_INT (bits & 0xff00);
+	ops[3] = GEN_INT (bits & 0x00ff);
+
+	if (arm_arch_thumb2)
+	  output_asm_insn (\"movw%?\\t%0, %1\", ops);
+	else
+	  output_asm_insn (\"mov%?\\t%0, %2\;orr%?\\t%0, %0, %3\", ops);
+	return \"\";
+       }
+    default:
+      gcc_unreachable ();
+    }
+  "
+  [(set_attr "conds" "unconditional")
+   (set_attr "type" "load1,store1,*,*")
+   (set_attr "length" "4,4,4,8")
+   (set_attr "predicable" "yes")
+   ]
+)
+
+(define_insn "*thumb1_movhf"
+  [(set (match_operand:HF     0 "nonimmediate_operand" "=l,l,m,*r,*h")
+	(match_operand:HF     1 "general_operand"      "l,mF,l,*h,*r"))]
+  "TARGET_THUMB1
+   && (	  s_register_operand (operands[0], HFmode) 
+       || s_register_operand (operands[1], HFmode))"
+  "*
+  switch (which_alternative)
+    {
+    case 1:
+      {
+	rtx addr;
+	gcc_assert (GET_CODE(operands[1]) == MEM);
+	addr = XEXP (operands[1], 0);
+	if (GET_CODE (addr) == LABEL_REF
+	    || (GET_CODE (addr) == CONST
+		&& GET_CODE (XEXP (addr, 0)) == PLUS
+		&& GET_CODE (XEXP (XEXP (addr, 0), 0)) == LABEL_REF
+		&& GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT))
+	  {
+	    /* Constant pool entry.  */
+	    return \"ldr\\t%0, %1\";
+	  }
+	return \"ldrh\\t%0, %1\";
+      }
+    case 2: return \"strh\\t%1, %0\";
+    default: return \"mov\\t%0, %1\";
+    }
+  "
+  [(set_attr "length" "2")
+   (set_attr "type" "*,load1,store1,*,*")
+   (set_attr "pool_range" "*,1020,*,*,*")]
+)
+
 (define_expand "movsf"
   [(set (match_operand:SF 0 "general_operand" "")
 	(match_operand:SF 1 "general_operand" ""))]
@@ -5842,6 +6310,7 @@
   [(set_attr "length" "4,4,4")
    (set_attr "predicable" "yes")
    (set_attr "type" "*,load1,store1")
+   (set_attr "insn" "mov,*,*")
    (set_attr "pool_range" "*,4096,*")
    (set_attr "neg_pool_range" "*,4084,*")]
 )
@@ -6297,7 +6766,7 @@
    (match_operand:BLK 1 "general_operand" "")
    (match_operand:SI 2 "const_int_operand" "")
    (match_operand:SI 3 "const_int_operand" "")]
-  "TARGET_EITHER"
+  "TARGET_EITHER && !low_irq_latency"
   "
   if (TARGET_32BIT)
     {
@@ -7476,7 +7945,7 @@
 (define_expand "cmpdf"
   [(match_operand:DF 0 "s_register_operand" "")
    (match_operand:DF 1 "arm_float_compare_operand" "")]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   arm_compare_op0 = operands[0];
   arm_compare_op1 = operands[1];
@@ -7507,7 +7976,11 @@
    (set_attr "shift" "1")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*arm_cmpsi_shiftsi_swp"
@@ -7522,7 +7995,11 @@
    (set_attr "shift" "1")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*arm_cmpsi_negshiftsi_si"
@@ -7537,7 +8014,11 @@
   [(set_attr "conds" "set")
    (set (attr "type") (if_then_else (match_operand 3 "const_int_operand" "")
 				    (const_string "alu_shift")
-				    (const_string "alu_shift_reg")))]
+                                    (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 ;; Cirrus SF compare instruction
@@ -7879,77 +8360,77 @@
 (define_expand "seq"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(eq:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (EQ, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sne"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(ne:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (NE, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sgt"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(gt:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (GT, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sle"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(le:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (LE, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sge"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(ge:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (GE, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "slt"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(lt:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (LT, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sgtu"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(gtu:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (GTU, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sleu"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(leu:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (LEU, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sgeu"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(geu:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (GEU, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sltu"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(ltu:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (LTU, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sunordered"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(unordered:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (UNORDERED, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -7957,7 +8438,7 @@
 (define_expand "sordered"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(ordered:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (ORDERED, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -7965,7 +8446,7 @@
 (define_expand "sungt"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(ungt:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (UNGT, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -7973,7 +8454,7 @@
 (define_expand "sunge"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(unge:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (UNGE, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -7981,7 +8462,7 @@
 (define_expand "sunlt"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(unlt:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (UNLT, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -7989,7 +8470,7 @@
 (define_expand "sunle"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(unle:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (UNLE, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -8018,6 +8499,7 @@
   "TARGET_ARM"
   "mov%D1\\t%0, #0\;mov%d1\\t%0, #1"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -8028,6 +8510,7 @@
   "TARGET_ARM"
   "mov%D1\\t%0, #0\;mvn%d1\\t%0, #0"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -8038,6 +8521,7 @@
   "TARGET_ARM"
   "mov%D1\\t%0, #0\;mvn%d1\\t%0, #1"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -8241,7 +8725,7 @@
 	(if_then_else:SI (match_operand 1 "arm_comparison_operator" "")
 			 (match_operand:SI 2 "arm_not_operand" "")
 			 (match_operand:SI 3 "arm_not_operand" "")))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "
   {
     enum rtx_code code = GET_CODE (operands[1]);
@@ -8260,7 +8744,7 @@
 	(if_then_else:SF (match_operand 1 "arm_comparison_operator" "")
 			 (match_operand:SF 2 "s_register_operand" "")
 			 (match_operand:SF 3 "nonmemory_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_NO_COND_EXEC"
   "
   {
     enum rtx_code code = GET_CODE (operands[1]);
@@ -8285,7 +8769,7 @@
 	(if_then_else:DF (match_operand 1 "arm_comparison_operator" "")
 			 (match_operand:DF 2 "s_register_operand" "")
 			 (match_operand:DF 3 "arm_float_add_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE) && !TARGET_NO_COND_EXEC"
   "
   {
     enum rtx_code code = GET_CODE (operands[1]);
@@ -8317,7 +8801,8 @@
    mvn%d3\\t%0, #%B1\;mov%D3\\t%0, %2
    mvn%d3\\t%0, #%B1\;mvn%D3\\t%0, #%B2"
   [(set_attr "length" "4,4,4,4,8,8,8,8")
-   (set_attr "conds" "use")]
+   (set_attr "conds" "use")
+   (set_attr "insn" "mov,mvn,mov,mvn,mov,mov,mvn,mvn")]
 )
 
 (define_insn "*movsfcc_soft_insn"
@@ -8330,7 +8815,8 @@
   "@
    mov%D3\\t%0, %2
    mov%d3\\t%0, %1"
-  [(set_attr "conds" "use")]
+  [(set_attr "conds" "use")
+   (set_attr "insn" "mov")]
 )
 
 
@@ -8733,7 +9219,7 @@
 		       [(match_operand 1 "cc_register" "") (const_int 0)])
                       (return)
                       (pc)))]
-  "TARGET_ARM && USE_RETURN_INSN (TRUE)"
+  "TARGET_ARM && USE_RETURN_INSN (TRUE) && !TARGET_NO_COND_EXEC"
   "*
   {
     if (arm_ccfsm_state == 2)
@@ -8754,7 +9240,7 @@
 		       [(match_operand 1 "cc_register" "") (const_int 0)])
                       (pc)
 		      (return)))]
-  "TARGET_ARM && USE_RETURN_INSN (TRUE)"
+  "TARGET_ARM && USE_RETURN_INSN (TRUE) && !TARGET_NO_COND_EXEC"
   "*
   {
     if (arm_ccfsm_state == 2)
@@ -9072,7 +9558,11 @@
    (set_attr "shift" "4")
    (set (attr "type") (if_then_else (match_operand 5 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_split
@@ -9110,7 +9600,11 @@
    (set_attr "shift" "4")
    (set (attr "type") (if_then_else (match_operand 5 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*arith_shiftsi_compare0_scratch"
@@ -9128,7 +9622,11 @@
    (set_attr "shift" "4")
    (set (attr "type") (if_then_else (match_operand 5 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*sub_shiftsi"
@@ -9143,7 +9641,11 @@
    (set_attr "shift" "3")
    (set (attr "type") (if_then_else (match_operand 4 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*sub_shiftsi_compare0"
@@ -9163,7 +9665,11 @@
    (set_attr "shift" "3")
    (set (attr "type") (if_then_else (match_operand 4 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*sub_shiftsi_compare0_scratch"
@@ -9181,7 +9687,11 @@
    (set_attr "shift" "3")
    (set (attr "type") (if_then_else (match_operand 4 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 
@@ -9194,6 +9704,7 @@
   "TARGET_ARM"
   "mov%D1\\t%0, #0\;and%d1\\t%0, %2, #1"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -9207,6 +9718,7 @@
    orr%d2\\t%0, %1, #1
    mov%D2\\t%0, %1\;orr%d2\\t%0, %1, #1"
   [(set_attr "conds" "use")
+   (set_attr "insn" "orr")
    (set_attr "length" "4,8")]
 )
 
@@ -9216,7 +9728,7 @@
 	 [(match_operand:SI 2 "s_register_operand" "r,r")
 	  (match_operand:SI 3 "arm_add_operand" "rI,L")]))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_COND_EXEC"
   "*
     if (operands[3] == const0_rtx)
       {
@@ -9271,6 +9783,7 @@
     return \"\";
   "
   [(set_attr "conds" "use")
+   (set_attr "insn" "mov")
    (set_attr "length" "4,4,8")]
 )
 
@@ -9282,7 +9795,7 @@
 	    (match_operand:SI 3 "arm_rhs_operand" "rI,rI")])
           (match_operand:SI 1 "s_register_operand" "0,?r")]))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "*
     if (GET_CODE (operands[4]) == LT && operands[3] == const0_rtx)
       return \"%i5\\t%0, %1, %2, lsr #31\";
@@ -9678,7 +10191,7 @@
 	 (match_operand:SI 1 "arm_rhs_operand" "0,rI,?rI")
 	 (match_operand:SI 2 "arm_rhs_operand" "rI,0,rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_COND_EXEC"
   "*
   if (GET_CODE (operands[5]) == LT
       && (operands[4] == const0_rtx))
@@ -9744,7 +10257,7 @@
 			  (match_operand:SI 3 "arm_add_operand" "rIL,rIL"))
 			 (match_operand:SI 1 "arm_rhs_operand" "0,?rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -9780,7 +10293,7 @@
 			  (match_operand:SI 2 "s_register_operand" "r,r")
 			  (match_operand:SI 3 "arm_add_operand" "rIL,rIL"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -9818,7 +10331,7 @@
 			  [(match_operand:SI 3 "s_register_operand" "r")
 			   (match_operand:SI 4 "arm_rhs_operand" "rI")])))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "12")]
@@ -9968,7 +10481,7 @@
 	 (not:SI
 	  (match_operand:SI 2 "s_register_operand" "r,r"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -9987,6 +10500,7 @@
    mov%d4\\t%0, %1\;mvn%D4\\t%0, %2
    mvn%d4\\t%0, #%B1\;mvn%D4\\t%0, %2"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mvn")
    (set_attr "length" "4,8,8")]
 )
 
@@ -10000,7 +10514,7 @@
 	  (match_operand:SI 2 "s_register_operand" "r,r"))
 	 (match_operand:SI 1 "arm_not_operand" "0,?rIK")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -10019,6 +10533,7 @@
    mov%D4\\t%0, %1\;mvn%d4\\t%0, %2
    mvn%D4\\t%0, #%B1\;mvn%d4\\t%0, %2"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mvn")
    (set_attr "length" "4,8,8")]
 )
 
@@ -10033,7 +10548,7 @@
 	   (match_operand:SI 3 "arm_rhs_operand" "rM,rM")])
 	 (match_operand:SI 1 "arm_not_operand" "0,?rIK")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -10055,10 +10570,23 @@
    mvn%D5\\t%0, #%B1\;mov%d5\\t%0, %2%S4"
   [(set_attr "conds" "use")
    (set_attr "shift" "2")
-   (set_attr "length" "4,8,8")
+   (set_attr "insn" "mov")
    (set (attr "type") (if_then_else (match_operand 3 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set_attr_alternative "length"
+           [(if_then_else (and (eq_attr "type" "alu_shift_reg")
+                               (eq_attr "fix_janus" "yes"))
+                          (const_int 8)
+                          (const_int 4))
+            (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                               (eq_attr "fix_janus" "yes"))
+                          (const_int 12)
+                          (const_int 8))
+            (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                               (eq_attr "fix_janus" "yes"))
+                          (const_int 12)
+                          (const_int 8))])]
 )
 
 (define_insn "*ifcompare_move_shift"
@@ -10072,7 +10600,7 @@
 	  [(match_operand:SI 2 "s_register_operand" "r,r")
 	   (match_operand:SI 3 "arm_rhs_operand" "rM,rM")])))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -10094,10 +10622,24 @@
    mvn%d5\\t%0, #%B1\;mov%D5\\t%0, %2%S4"
   [(set_attr "conds" "use")
    (set_attr "shift" "2")
-   (set_attr "length" "4,8,8")
+   (set_attr "insn" "mov")
    (set (attr "type") (if_then_else (match_operand 3 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set_attr_alternative "length"
+        [(if_then_else (and (eq_attr "type" "alu_shift_reg")
+                            (eq_attr "fix_janus" "yes"))
+                       (const_int 8)
+                       (const_int 4))
+         (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                            (eq_attr "fix_janus" "yes"))
+                       (const_int 12)
+                       (const_int 8))
+         (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                            (eq_attr "fix_janus" "yes"))
+                       (const_int 12)
+                       (const_int 8))])
+     (set_attr "insn" "mov")]
 )
 
 (define_insn "*ifcompare_shift_shift"
@@ -10113,7 +10655,7 @@
 	  [(match_operand:SI 3 "s_register_operand" "r")
 	   (match_operand:SI 4 "arm_rhs_operand" "rM")])))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "12")]
@@ -10134,12 +10676,16 @@
   "mov%d5\\t%0, %1%S6\;mov%D5\\t%0, %3%S7"
   [(set_attr "conds" "use")
    (set_attr "shift" "1")
-   (set_attr "length" "8")
+   (set_attr "insn" "mov")
    (set (attr "type") (if_then_else
 		        (and (match_operand 2 "const_int_operand" "")
                              (match_operand 4 "const_int_operand" ""))
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 16)
+                                        (const_int 8)))]
 )
 
 (define_insn "*ifcompare_not_arith"
@@ -10153,7 +10699,7 @@
 	  [(match_operand:SI 2 "s_register_operand" "r")
 	   (match_operand:SI 3 "arm_rhs_operand" "rI")])))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "12")]
@@ -10171,6 +10717,7 @@
   "TARGET_ARM"
   "mvn%d5\\t%0, %1\;%I6%D5\\t%0, %2, %3"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mvn")
    (set_attr "length" "8")]
 )
 
@@ -10185,7 +10732,7 @@
 	   (match_operand:SI 3 "arm_rhs_operand" "rI")])
 	 (not:SI (match_operand:SI 1 "s_register_operand" "r"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "12")]
@@ -10203,6 +10750,7 @@
   "TARGET_ARM"
   "mvn%D5\\t%0, %1\;%I6%d5\\t%0, %2, %3"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mvn")
    (set_attr "length" "8")]
 )
 
@@ -10215,7 +10763,7 @@
 	 (neg:SI (match_operand:SI 2 "s_register_operand" "r,r"))
 	 (match_operand:SI 1 "arm_not_operand" "0,?rIK")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -10246,7 +10794,7 @@
 	 (match_operand:SI 1 "arm_not_operand" "0,?rIK")
 	 (neg:SI (match_operand:SI 2 "s_register_operand" "r,r"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -10614,7 +11162,7 @@
 			 (match_dup 0)
 			 (match_operand 4 "" "")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM && reload_completed"
+  "TARGET_ARM && reload_completed && !TARGET_NO_SINGLE_COND_EXEC"
   [(set (match_dup 5) (match_dup 6))
    (cond_exec (match_dup 7)
 	      (set (match_dup 0) (match_dup 4)))]
@@ -10642,7 +11190,7 @@
 			 (match_operand 4 "" "")
 			 (match_dup 0)))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM && reload_completed"
+  "TARGET_ARM && reload_completed && !TARGET_NO_SINGLE_COND_EXEC"
   [(set (match_dup 5) (match_dup 6))
    (cond_exec (match_op_dup 1 [(match_dup 5) (const_int 0)])
 	      (set (match_dup 0) (match_dup 4)))]
@@ -10663,7 +11211,7 @@
 			 (match_operand 4 "" "")
 			 (match_operand 5 "" "")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM && reload_completed"
+  "TARGET_ARM && reload_completed && !TARGET_NO_SINGLE_COND_EXEC"
   [(set (match_dup 6) (match_dup 7))
    (cond_exec (match_op_dup 1 [(match_dup 6) (const_int 0)])
 	      (set (match_dup 0) (match_dup 4)))
@@ -10695,7 +11243,7 @@
 			 (not:SI
 			  (match_operand:SI 5 "s_register_operand" ""))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM && reload_completed"
+  "TARGET_ARM && reload_completed && !TARGET_NO_SINGLE_COND_EXEC"
   [(set (match_dup 6) (match_dup 7))
    (cond_exec (match_op_dup 1 [(match_dup 6) (const_int 0)])
 	      (set (match_dup 0) (match_dup 4)))
@@ -10730,6 +11278,7 @@
    mvn%D4\\t%0, %2
    mov%d4\\t%0, %1\;mvn%D4\\t%0, %2"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mvn")
    (set_attr "length" "4,8")]
 )
 
@@ -10864,6 +11413,24 @@
   "
 )
 
+(define_insn "align_16"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_ALIGN16)]
+  "TARGET_EITHER"
+  "*
+  assemble_align (128);
+  return \"\";
+  "
+)
+
+(define_insn "align_32"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_ALIGN32)]
+  "TARGET_EITHER"
+  "*
+  assemble_align (256);
+  return \"\";
+  "
+)
+
 (define_insn "consttable_end"
   [(unspec_volatile [(const_int 0)] VUNSPEC_POOL_END)]
   "TARGET_EITHER"
@@ -10890,6 +11457,7 @@
   "TARGET_THUMB1"
   "*
   making_const_table = TRUE;
+  gcc_assert (GET_MODE_CLASS (GET_MODE (operands[0])) != MODE_FLOAT);
   assemble_integer (operands[0], 2, BITS_PER_WORD, 1);
   assemble_zeros (2);
   return \"\";
@@ -10902,19 +11470,30 @@
   "TARGET_EITHER"
   "*
   {
+    rtx x = operands[0];
     making_const_table = TRUE;
-    switch (GET_MODE_CLASS (GET_MODE (operands[0])))
+    switch (GET_MODE_CLASS (GET_MODE (x)))
       {
       case MODE_FLOAT:
-      {
-        REAL_VALUE_TYPE r;
-        REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);
-        assemble_real (r, GET_MODE (operands[0]), BITS_PER_WORD);
-        break;
-      }
+        if (GET_MODE (x) == HFmode)
+	  arm_emit_fp16_const (x);
+	else
+ 	  {
+	    REAL_VALUE_TYPE r;
+	    REAL_VALUE_FROM_CONST_DOUBLE (r, x);
+	    assemble_real (r, GET_MODE (x), BITS_PER_WORD);
+	  }
+	break;
       default:
-        assemble_integer (operands[0], 4, BITS_PER_WORD, 1);
-	mark_symbol_refs_as_used (operands[0]);
+	/* XXX: Sometimes gcc does something really dumb and ends up with
+	   a HIGH in a constant pool entry, usually because it's trying to
+	   load into a VFP register.  We know this will always be used in
+	   combination with a LO_SUM which ignores the high bits, so just
+	   strip off the HIGH.  */
+	if (GET_CODE (x) == HIGH)
+	  x = XEXP (x, 0);
+        assemble_integer (x, 4, BITS_PER_WORD, 1);
+	mark_symbol_refs_as_used (x);
         break;
       }
     return \"\";
@@ -11008,6 +11587,28 @@
   [(set_attr "predicable" "yes")
    (set_attr "insn" "clz")])
 
+(define_insn "rbitsi2"
+  [(set (match_operand:SI 0 "s_register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "s_register_operand" "r")] UNSPEC_RBIT))]
+  "TARGET_32BIT && arm_arch_thumb2"
+  "rbit%?\\t%0, %1"
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "clz")])
+
+(define_expand "ctzsi2"
+ [(set (match_operand:SI           0 "s_register_operand" "")
+       (ctz:SI (match_operand:SI  1 "s_register_operand" "")))]
+  "TARGET_32BIT && arm_arch_thumb2"
+  "
+   {
+     rtx tmp = gen_reg_rtx (SImode); 
+     emit_insn (gen_rbitsi2 (tmp, operands[1]));
+     emit_insn (gen_clzsi2 (operands[0], tmp));
+   }
+   DONE;
+  "
+)
+
 ;; V5E instructions.
 
 (define_insn "prefetch"
@@ -11017,13 +11618,15 @@
   "TARGET_32BIT && arm_arch5e"
   "pld\\t%a0")
 
-;; General predication pattern
+;; General predication pattern.
+;; Conditional branches are available as both arm_cond_branch and
+;; predicated arm_jump, so it doesn't matter if we disable the latter.
 
 (define_cond_exec
   [(match_operator 0 "arm_comparison_operator"
     [(match_operand 1 "cc_register" "")
      (const_int 0)])]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_SINGLE_COND_EXEC"
   ""
 )
 
diff -Nur a/gcc/config/arm/arm-modes.def b/gcc/config/arm/arm-modes.def
--- a/gcc/config/arm/arm-modes.def	2007-08-02 12:49:31.000000000 +0200
+++ b/gcc/config/arm/arm-modes.def	2010-01-25 09:50:28.985687200 +0100
@@ -25,6 +25,11 @@
    FIXME What format is this?  */
 FLOAT_MODE (XF, 12, 0);
 
+/* Half-precision floating point */
+FLOAT_MODE (HF, 2, 0);
+ADJUST_FLOAT_FORMAT (HF, ((arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)
+			  ? &arm_half_format : &ieee_half_format));
+
 /* CCFPEmode should be used with floating inequalities,
    CCFPmode should be used with floating equalities.
    CC_NOOVmode should be used with SImode integer equalities.
@@ -62,6 +67,4 @@
 INT_MODE (EI, 24);
 INT_MODE (OI, 32);
 INT_MODE (CI, 48);
-/* ??? This should actually have 512 bits but the precision only has 9
-   bits.  */
-FRACTIONAL_INT_MODE (XI, 511, 64);
+INT_MODE (XI, 64);
diff -Nur a/gcc/config/arm/arm_neon.h b/gcc/config/arm/arm_neon.h
--- a/gcc/config/arm/arm_neon.h	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/arm/arm_neon.h	2010-01-25 09:50:28.985687200 +0100
@@ -36,7 +36,11 @@
 extern "C" {
 #endif
 
+#if defined (__vxworks) && defined (_WRS_KERNEL)
+#include <vxWorks.h>
+#else
 #include <stdint.h>
+#endif
 
 typedef __builtin_neon_qi int8x8_t	__attribute__ ((__vector_size__ (8)));
 typedef __builtin_neon_hi int16x4_t	__attribute__ ((__vector_size__ (8)));
@@ -61,7 +65,7 @@
 typedef __builtin_neon_usi uint32x4_t	__attribute__ ((__vector_size__ (16)));
 typedef __builtin_neon_udi uint64x2_t	__attribute__ ((__vector_size__ (16)));
 
-typedef __builtin_neon_sf float32_t;
+typedef float float32_t;
 typedef __builtin_neon_poly8 poly8_t;
 typedef __builtin_neon_poly16 poly16_t;
 
@@ -5085,7 +5089,7 @@
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vset_lane_f32 (float32_t __a, float32x2_t __b, const int __c)
 {
-  return (float32x2_t)__builtin_neon_vset_lanev2sf (__a, __b, __c);
+  return (float32x2_t)__builtin_neon_vset_lanev2sf ((__builtin_neon_sf) __a, __b, __c);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -5151,7 +5155,7 @@
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vsetq_lane_f32 (float32_t __a, float32x4_t __b, const int __c)
 {
-  return (float32x4_t)__builtin_neon_vset_lanev4sf (__a, __b, __c);
+  return (float32x4_t)__builtin_neon_vset_lanev4sf ((__builtin_neon_sf) __a, __b, __c);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -5283,7 +5287,7 @@
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vdup_n_f32 (float32_t __a)
 {
-  return (float32x2_t)__builtin_neon_vdup_nv2sf (__a);
+  return (float32x2_t)__builtin_neon_vdup_nv2sf ((__builtin_neon_sf) __a);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -5349,7 +5353,7 @@
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vdupq_n_f32 (float32_t __a)
 {
-  return (float32x4_t)__builtin_neon_vdup_nv4sf (__a);
+  return (float32x4_t)__builtin_neon_vdup_nv4sf ((__builtin_neon_sf) __a);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -5415,7 +5419,7 @@
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vmov_n_f32 (float32_t __a)
 {
-  return (float32x2_t)__builtin_neon_vdup_nv2sf (__a);
+  return (float32x2_t)__builtin_neon_vdup_nv2sf ((__builtin_neon_sf) __a);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -5481,7 +5485,7 @@
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vmovq_n_f32 (float32_t __a)
 {
-  return (float32x4_t)__builtin_neon_vdup_nv4sf (__a);
+  return (float32x4_t)__builtin_neon_vdup_nv4sf ((__builtin_neon_sf) __a);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -6591,7 +6595,7 @@
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vmul_n_f32 (float32x2_t __a, float32_t __b)
 {
-  return (float32x2_t)__builtin_neon_vmul_nv2sf (__a, __b, 3);
+  return (float32x2_t)__builtin_neon_vmul_nv2sf (__a, (__builtin_neon_sf) __b, 3);
 }
 
 __extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))
@@ -6621,7 +6625,7 @@
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vmulq_n_f32 (float32x4_t __a, float32_t __b)
 {
-  return (float32x4_t)__builtin_neon_vmul_nv4sf (__a, __b, 3);
+  return (float32x4_t)__builtin_neon_vmul_nv4sf (__a, (__builtin_neon_sf) __b, 3);
 }
 
 __extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
@@ -6735,7 +6739,7 @@
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vmla_n_f32 (float32x2_t __a, float32x2_t __b, float32_t __c)
 {
-  return (float32x2_t)__builtin_neon_vmla_nv2sf (__a, __b, __c, 3);
+  return (float32x2_t)__builtin_neon_vmla_nv2sf (__a, __b, (__builtin_neon_sf) __c, 3);
 }
 
 __extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))
@@ -6765,7 +6769,7 @@
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vmlaq_n_f32 (float32x4_t __a, float32x4_t __b, float32_t __c)
 {
-  return (float32x4_t)__builtin_neon_vmla_nv4sf (__a, __b, __c, 3);
+  return (float32x4_t)__builtin_neon_vmla_nv4sf (__a, __b, (__builtin_neon_sf) __c, 3);
 }
 
 __extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
@@ -6831,7 +6835,7 @@
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vmls_n_f32 (float32x2_t __a, float32x2_t __b, float32_t __c)
 {
-  return (float32x2_t)__builtin_neon_vmls_nv2sf (__a, __b, __c, 3);
+  return (float32x2_t)__builtin_neon_vmls_nv2sf (__a, __b, (__builtin_neon_sf) __c, 3);
 }
 
 __extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))
@@ -6861,7 +6865,7 @@
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vmlsq_n_f32 (float32x4_t __a, float32x4_t __b, float32_t __c)
 {
-  return (float32x4_t)__builtin_neon_vmls_nv4sf (__a, __b, __c, 3);
+  return (float32x4_t)__builtin_neon_vmls_nv4sf (__a, __b, (__builtin_neon_sf) __c, 3);
 }
 
 __extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
@@ -7851,7 +7855,7 @@
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_f32 (const float32_t * __a)
 {
-  return (float32x2_t)__builtin_neon_vld1v2sf (__a);
+  return (float32x2_t)__builtin_neon_vld1v2sf ((const __builtin_neon_sf *) __a);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -7917,7 +7921,7 @@
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_f32 (const float32_t * __a)
 {
-  return (float32x4_t)__builtin_neon_vld1v4sf (__a);
+  return (float32x4_t)__builtin_neon_vld1v4sf ((const __builtin_neon_sf *) __a);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -7977,7 +7981,7 @@
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_lane_f32 (const float32_t * __a, float32x2_t __b, const int __c)
 {
-  return (float32x2_t)__builtin_neon_vld1_lanev2sf (__a, __b, __c);
+  return (float32x2_t)__builtin_neon_vld1_lanev2sf ((const __builtin_neon_sf *) __a, __b, __c);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -8043,7 +8047,7 @@
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_lane_f32 (const float32_t * __a, float32x4_t __b, const int __c)
 {
-  return (float32x4_t)__builtin_neon_vld1_lanev4sf (__a, __b, __c);
+  return (float32x4_t)__builtin_neon_vld1_lanev4sf ((const __builtin_neon_sf *) __a, __b, __c);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -8109,7 +8113,7 @@
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_dup_f32 (const float32_t * __a)
 {
-  return (float32x2_t)__builtin_neon_vld1_dupv2sf (__a);
+  return (float32x2_t)__builtin_neon_vld1_dupv2sf ((const __builtin_neon_sf *) __a);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -8175,7 +8179,7 @@
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_dup_f32 (const float32_t * __a)
 {
-  return (float32x4_t)__builtin_neon_vld1_dupv4sf (__a);
+  return (float32x4_t)__builtin_neon_vld1_dupv4sf ((const __builtin_neon_sf *) __a);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -8247,7 +8251,7 @@
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1_f32 (float32_t * __a, float32x2_t __b)
 {
-  __builtin_neon_vst1v2sf (__a, __b);
+  __builtin_neon_vst1v2sf ((__builtin_neon_sf *) __a, __b);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -8313,7 +8317,7 @@
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1q_f32 (float32_t * __a, float32x4_t __b)
 {
-  __builtin_neon_vst1v4sf (__a, __b);
+  __builtin_neon_vst1v4sf ((__builtin_neon_sf *) __a, __b);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -8373,7 +8377,7 @@
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1_lane_f32 (float32_t * __a, float32x2_t __b, const int __c)
 {
-  __builtin_neon_vst1_lanev2sf (__a, __b, __c);
+  __builtin_neon_vst1_lanev2sf ((__builtin_neon_sf *) __a, __b, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -8439,7 +8443,7 @@
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1q_lane_f32 (float32_t * __a, float32x4_t __b, const int __c)
 {
-  __builtin_neon_vst1_lanev4sf (__a, __b, __c);
+  __builtin_neon_vst1_lanev4sf ((__builtin_neon_sf *) __a, __b, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -8512,7 +8516,7 @@
 vld2_f32 (const float32_t * __a)
 {
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __rv;
-  __rv.__o = __builtin_neon_vld2v2sf (__a);
+  __rv.__o = __builtin_neon_vld2v2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -8600,7 +8604,7 @@
 vld2q_f32 (const float32_t * __a)
 {
   union { float32x4x2_t __i; __builtin_neon_oi __o; } __rv;
-  __rv.__o = __builtin_neon_vld2v4sf (__a);
+  __rv.__o = __builtin_neon_vld2v4sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -8676,7 +8680,7 @@
 {
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __bu = { __b };
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __rv;
-  __rv.__o = __builtin_neon_vld2_lanev2sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld2_lanev2sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -8748,7 +8752,7 @@
 {
   union { float32x4x2_t __i; __builtin_neon_oi __o; } __bu = { __b };
   union { float32x4x2_t __i; __builtin_neon_oi __o; } __rv;
-  __rv.__o = __builtin_neon_vld2_lanev4sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld2_lanev4sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -8807,7 +8811,7 @@
 vld2_dup_f32 (const float32_t * __a)
 {
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __rv;
-  __rv.__o = __builtin_neon_vld2_dupv2sf (__a);
+  __rv.__o = __builtin_neon_vld2_dupv2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -8892,7 +8896,7 @@
 vst2_f32 (float32_t * __a, float32x2x2_t __b)
 {
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __bu = { __b };
-  __builtin_neon_vst2v2sf (__a, __bu.__o);
+  __builtin_neon_vst2v2sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -8969,7 +8973,7 @@
 vst2q_f32 (float32_t * __a, float32x4x2_t __b)
 {
   union { float32x4x2_t __i; __builtin_neon_oi __o; } __bu = { __b };
-  __builtin_neon_vst2v4sf (__a, __bu.__o);
+  __builtin_neon_vst2v4sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9032,7 +9036,7 @@
 vst2_lane_f32 (float32_t * __a, float32x2x2_t __b, const int __c)
 {
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __bu = { __b };
-  __builtin_neon_vst2_lanev2sf (__a, __bu.__o, __c);
+  __builtin_neon_vst2_lanev2sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9088,7 +9092,7 @@
 vst2q_lane_f32 (float32_t * __a, float32x4x2_t __b, const int __c)
 {
   union { float32x4x2_t __i; __builtin_neon_oi __o; } __bu = { __b };
-  __builtin_neon_vst2_lanev4sf (__a, __bu.__o, __c);
+  __builtin_neon_vst2_lanev4sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9140,7 +9144,7 @@
 vld3_f32 (const float32_t * __a)
 {
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __rv;
-  __rv.__o = __builtin_neon_vld3v2sf (__a);
+  __rv.__o = __builtin_neon_vld3v2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -9228,7 +9232,7 @@
 vld3q_f32 (const float32_t * __a)
 {
   union { float32x4x3_t __i; __builtin_neon_ci __o; } __rv;
-  __rv.__o = __builtin_neon_vld3v4sf (__a);
+  __rv.__o = __builtin_neon_vld3v4sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -9304,7 +9308,7 @@
 {
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __bu = { __b };
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __rv;
-  __rv.__o = __builtin_neon_vld3_lanev2sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld3_lanev2sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -9376,7 +9380,7 @@
 {
   union { float32x4x3_t __i; __builtin_neon_ci __o; } __bu = { __b };
   union { float32x4x3_t __i; __builtin_neon_ci __o; } __rv;
-  __rv.__o = __builtin_neon_vld3_lanev4sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld3_lanev4sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -9435,7 +9439,7 @@
 vld3_dup_f32 (const float32_t * __a)
 {
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __rv;
-  __rv.__o = __builtin_neon_vld3_dupv2sf (__a);
+  __rv.__o = __builtin_neon_vld3_dupv2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -9520,7 +9524,7 @@
 vst3_f32 (float32_t * __a, float32x2x3_t __b)
 {
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __bu = { __b };
-  __builtin_neon_vst3v2sf (__a, __bu.__o);
+  __builtin_neon_vst3v2sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9597,7 +9601,7 @@
 vst3q_f32 (float32_t * __a, float32x4x3_t __b)
 {
   union { float32x4x3_t __i; __builtin_neon_ci __o; } __bu = { __b };
-  __builtin_neon_vst3v4sf (__a, __bu.__o);
+  __builtin_neon_vst3v4sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9660,7 +9664,7 @@
 vst3_lane_f32 (float32_t * __a, float32x2x3_t __b, const int __c)
 {
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __bu = { __b };
-  __builtin_neon_vst3_lanev2sf (__a, __bu.__o, __c);
+  __builtin_neon_vst3_lanev2sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9716,7 +9720,7 @@
 vst3q_lane_f32 (float32_t * __a, float32x4x3_t __b, const int __c)
 {
   union { float32x4x3_t __i; __builtin_neon_ci __o; } __bu = { __b };
-  __builtin_neon_vst3_lanev4sf (__a, __bu.__o, __c);
+  __builtin_neon_vst3_lanev4sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9768,7 +9772,7 @@
 vld4_f32 (const float32_t * __a)
 {
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __rv;
-  __rv.__o = __builtin_neon_vld4v2sf (__a);
+  __rv.__o = __builtin_neon_vld4v2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -9856,7 +9860,7 @@
 vld4q_f32 (const float32_t * __a)
 {
   union { float32x4x4_t __i; __builtin_neon_xi __o; } __rv;
-  __rv.__o = __builtin_neon_vld4v4sf (__a);
+  __rv.__o = __builtin_neon_vld4v4sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -9932,7 +9936,7 @@
 {
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __bu = { __b };
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __rv;
-  __rv.__o = __builtin_neon_vld4_lanev2sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld4_lanev2sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -10004,7 +10008,7 @@
 {
   union { float32x4x4_t __i; __builtin_neon_xi __o; } __bu = { __b };
   union { float32x4x4_t __i; __builtin_neon_xi __o; } __rv;
-  __rv.__o = __builtin_neon_vld4_lanev4sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld4_lanev4sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -10063,7 +10067,7 @@
 vld4_dup_f32 (const float32_t * __a)
 {
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __rv;
-  __rv.__o = __builtin_neon_vld4_dupv2sf (__a);
+  __rv.__o = __builtin_neon_vld4_dupv2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -10148,7 +10152,7 @@
 vst4_f32 (float32_t * __a, float32x2x4_t __b)
 {
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __bu = { __b };
-  __builtin_neon_vst4v2sf (__a, __bu.__o);
+  __builtin_neon_vst4v2sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -10225,7 +10229,7 @@
 vst4q_f32 (float32_t * __a, float32x4x4_t __b)
 {
   union { float32x4x4_t __i; __builtin_neon_xi __o; } __bu = { __b };
-  __builtin_neon_vst4v4sf (__a, __bu.__o);
+  __builtin_neon_vst4v4sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -10288,7 +10292,7 @@
 vst4_lane_f32 (float32_t * __a, float32x2x4_t __b, const int __c)
 {
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __bu = { __b };
-  __builtin_neon_vst4_lanev2sf (__a, __bu.__o, __c);
+  __builtin_neon_vst4_lanev2sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -10344,7 +10348,7 @@
 vst4q_lane_f32 (float32_t * __a, float32x4x4_t __b, const int __c)
 {
   union { float32x4x4_t __i; __builtin_neon_xi __o; } __bu = { __b };
-  __builtin_neon_vst4_lanev4sf (__a, __bu.__o, __c);
+  __builtin_neon_vst4_lanev4sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
diff -Nur a/gcc/config/arm/arm.opt b/gcc/config/arm/arm.opt
--- a/gcc/config/arm/arm.opt	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/arm/arm.opt	2010-01-25 09:50:28.985687200 +0100
@@ -78,6 +78,10 @@
 mfp=
 Target RejectNegative Joined Undocumented Var(target_fpe_name)
 
+mfp16-format=
+Target RejectNegative Joined Var(target_fp16_format_name)
+Specify the __fp16 floating-point format
+
 ;; Now ignored.
 mfpe
 Target RejectNegative Mask(FPE) Undocumented
@@ -93,6 +97,10 @@
 Target RejectNegative
 Alias for -mfloat-abi=hard
 
+mfix-janus-2cc
+Target Report Mask(FIX_JANUS)
+Work around hardware errata for Avalent Janus 2CC cores.
+
 mlittle-endian
 Target Report RejectNegative InverseMask(BIG_END)
 Assume target CPU is configured as little endian
@@ -101,6 +109,10 @@
 Target Report Mask(LONG_CALLS)
 Generate call insns as indirect calls, if necessary
 
+mmarvell-div
+Target Report Mask(MARVELL_DIV)
+Generate hardware integer division instructions supported by some Marvell cores.
+
 mpic-register=
 Target RejectNegative Joined Var(arm_pic_register_string)
 Specify the register to be used for PIC addressing
@@ -157,6 +169,10 @@
 Target Report Mask(NEON_VECTORIZE_QUAD)
 Use Neon quad-word (rather than double-word) registers for vectorization
 
+mlow-irq-latency
+Target Report Var(low_irq_latency)
+Try to reduce interrupt latency of the generated code
+
 mword-relocations
 Target Report Var(target_word_relocations) Init(TARGET_DEFAULT_WORD_RELOCATIONS)
 Only generate absolute relocations on word sized values.
diff -Nur a/gcc/config/arm/arm-protos.h b/gcc/config/arm/arm-protos.h
--- a/gcc/config/arm/arm-protos.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/arm/arm-protos.h	2010-01-25 09:50:28.985687200 +0100
@@ -88,7 +88,7 @@
 
 extern int cirrus_memory_offset (rtx);
 extern int arm_coproc_mem_operand (rtx, bool);
-extern int neon_vector_mem_operand (rtx, bool);
+extern int neon_vector_mem_operand (rtx, int);
 extern int neon_struct_mem_operand (rtx);
 extern int arm_no_early_store_addr_dep (rtx, rtx);
 extern int arm_no_early_alu_shift_dep (rtx, rtx);
@@ -144,6 +144,7 @@
 extern int arm_debugger_arg_offset (int, rtx);
 extern bool arm_is_long_call_p (tree);
 extern int    arm_emit_vector_const (FILE *, rtx);
+extern void arm_emit_fp16_const (rtx c);
 extern const char * arm_output_load_gr (rtx *);
 extern const char *vfp_output_fstmd (rtx *);
 extern void arm_set_return_address (rtx, rtx);
@@ -154,13 +155,15 @@
 
 #if defined TREE_CODE
 extern rtx arm_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);
+extern void arm_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,
+				      tree, bool);
 extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);
 extern bool arm_pad_arg_upward (enum machine_mode, const_tree);
 extern bool arm_pad_reg_upward (enum machine_mode, tree, int);
 extern bool arm_needs_doubleword_align (enum machine_mode, tree);
-extern rtx arm_function_value(const_tree, const_tree);
 #endif
 extern int arm_apply_result_size (void);
+extern rtx aapcs_libcall_value (enum machine_mode);
 
 #endif /* RTX_CODE */
 
diff -Nur a/gcc/config/arm/arm-tune.md b/gcc/config/arm/arm-tune.md
--- a/gcc/config/arm/arm-tune.md	2009-07-22 09:43:59.000000000 +0200
+++ b/gcc/config/arm/arm-tune.md	2010-01-25 09:50:28.985687200 +0100
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from arm-cores.def
 (define_attr "tune"
-	"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7d,arm7di,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7m,arm7dm,arm7dmi,arm8,arm810,strongarm,strongarm110,strongarm1100,strongarm1110,arm7tdmi,arm7tdmis,arm710t,arm720t,arm740t,arm9,arm9tdmi,arm920,arm920t,arm922t,arm940t,ep9312,arm10tdmi,arm1020t,arm9e,arm946es,arm966es,arm968es,arm10e,arm1020e,arm1022e,xscale,iwmmxt,iwmmxt2,arm926ejs,arm1026ejs,arm1136js,arm1136jfs,arm1176jzs,arm1176jzfs,mpcorenovfp,mpcore,arm1156t2s,cortexa8,cortexa9,cortexr4,cortexr4f,cortexm3,cortexm1"
+	"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7d,arm7di,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7m,arm7dm,arm7dmi,arm8,arm810,strongarm,strongarm110,strongarm1100,strongarm1110,arm7tdmi,arm7tdmis,arm710t,arm720t,arm740t,arm9,arm9tdmi,arm920,arm920t,arm922t,arm940t,ep9312,arm10tdmi,arm1020t,arm9e,arm946es,arm966es,arm968es,arm10e,arm1020e,arm1022e,xscale,iwmmxt,iwmmxt2,marvell_f,arm926ejs,arm1026ejs,arm1136js,arm1136jfs,arm1176jzs,arm1176jzfs,mpcorenovfp,mpcore,arm1156t2s,cortexa5,cortexa8,cortexa9,cortexr4,cortexr4f,cortexm3,cortexm1,cortexm0"
 	(const (symbol_ref "arm_tune")))
diff -Nur a/gcc/config/arm/bpabi.h b/gcc/config/arm/bpabi.h
--- a/gcc/config/arm/bpabi.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/arm/bpabi.h	2010-01-25 09:50:28.985687200 +0100
@@ -30,7 +30,7 @@
 
 /* Section 4.1 of the AAPCS requires the use of VFP format.  */
 #undef  FPUTYPE_DEFAULT
-#define FPUTYPE_DEFAULT FPUTYPE_VFP
+#define FPUTYPE_DEFAULT "vfp"
 
 /* TARGET_BIG_ENDIAN_DEFAULT is set in
    config.gcc for big endian configurations.  */
@@ -53,6 +53,8 @@
 
 #define TARGET_FIX_V4BX_SPEC " %{mcpu=arm8|mcpu=arm810|mcpu=strongarm*|march=armv4:--fix-v4bx}"
 
+#define BE8_LINK_SPEC " %{mbig-endian:%{march=armv7-a|mcpu=cortex-a5|mcpu=cortex-a8|mcpu=cortex-a9:%{!r:--be8}}}"
+
 /* Tell the assembler to build BPABI binaries.  */
 #undef  SUBTARGET_EXTRA_ASM_SPEC
 #define SUBTARGET_EXTRA_ASM_SPEC "%{mabi=apcs-gnu|mabi=atpcs:-meabi=gnu;:-meabi=5}" TARGET_FIX_V4BX_SPEC
@@ -65,7 +67,7 @@
 #define BPABI_LINK_SPEC \
   "%{mbig-endian:-EB} %{mlittle-endian:-EL} "		\
   "%{static:-Bstatic} %{shared:-shared} %{symbolic:-Bsymbolic} "	\
-  "-X" SUBTARGET_EXTRA_LINK_SPEC TARGET_FIX_V4BX_SPEC
+  "-X" SUBTARGET_EXTRA_LINK_SPEC TARGET_FIX_V4BX_SPEC BE8_LINK_SPEC
 
 #undef  LINK_SPEC
 #define LINK_SPEC BPABI_LINK_SPEC
@@ -90,16 +92,22 @@
 #define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (muldi3, lmul)
 #endif
 #ifdef L_fixdfdi
-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixdfdi, d2lz)
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixdfdi, d2lz) \
+  extern DWtype __fixdfdi (DFtype) __attribute__((pcs("aapcs"))); \
+  extern UDWtype __fixunsdfdi (DFtype) __asm__("__aeabi_d2ulz") __attribute__((pcs("aapcs")));
 #endif
 #ifdef L_fixunsdfdi
-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunsdfdi, d2ulz)
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunsdfdi, d2ulz) \
+  extern UDWtype __fixunsdfdi (DFtype) __attribute__((pcs("aapcs")));
 #endif
 #ifdef L_fixsfdi
-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixsfdi, f2lz)
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixsfdi, f2lz) \
+  extern DWtype __fixsfdi (SFtype) __attribute__((pcs("aapcs"))); \
+  extern UDWtype __fixunssfdi (SFtype) __asm__("__aeabi_f2ulz") __attribute__((pcs("aapcs")));
 #endif
 #ifdef L_fixunssfdi
-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunssfdi, f2ulz)
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunssfdi, f2ulz) \
+  extern UDWtype __fixunssfdi (SFtype) __attribute__((pcs("aapcs")));
 #endif
 #ifdef L_floatdidf
 #define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatdidf, l2d)
diff -Nur a/gcc/config/arm/bpabi.S b/gcc/config/arm/bpabi.S
--- a/gcc/config/arm/bpabi.S	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/arm/bpabi.S	2010-01-25 09:50:28.985687200 +0100
@@ -64,20 +64,69 @@
 
 #endif /* L_aeabi_ulcmp */
 
+.macro test_div_by_zero signed
+/* Tail-call to divide-by-zero handlers which may be overridden by the user,
+   so unwinding works properly.  */
+#if defined(__thumb2__)
+	cbnz	yyh, 1f
+	cbnz	yyl, 1f
+	cmp	xxh, #0
+	do_it	eq
+	cmpeq	xxl, #0
+	.ifc \signed, unsigned
+	beq	2f
+	mov	xxh, #0xffffffff
+	mov	xxl, xxh
+2:
+	.else
+	do_it	lt, t
+	movlt	xxl, #0
+	movlt	xxh, #0x80000000
+	do_it	gt, t
+	movgt	xxh, #0x7fffffff
+	movgt	xxl, #0xffffffff
+	.endif
+	b	SYM (__aeabi_ldiv0) __PLT__
+1:
+#else
+	/* Note: Thumb-1 code calls via an ARM shim on processors which
+	   support ARM mode.  */
+	cmp	yyh, #0
+	cmpeq	yyl, #0
+	bne	2f
+	cmp	xxh, #0
+	cmpeq	xxl, #0
+	.ifc \signed, unsigned
+	movne	xxh, #0xffffffff
+	movne	xxl, #0xffffffff
+	.else
+	movlt	xxh, #0x80000000
+	movlt	xxl, #0
+	movgt	xxh, #0x7fffffff
+	movgt	xxl, #0xffffffff
+	.endif
+	b	SYM (__aeabi_ldiv0) __PLT__
+2:
+#endif
+.endm
+
 #ifdef L_aeabi_ldivmod
 
 ARM_FUNC_START aeabi_ldivmod
+	test_div_by_zero signed
+
 	sub sp, sp, #8
-#if defined(__thumb2__)
+/* Low latency and Thumb-2 do_push implementations can't push sp directly.  */
+#if defined(__thumb2__) || defined(__irq_low_latency__)
 	mov ip, sp
-	push {ip, lr}
+	do_push (ip, lr)
 #else
-	do_push {sp, lr}
+	stmfd sp!, {sp, lr}
 #endif
 	bl SYM(__gnu_ldivmod_helper) __PLT__
 	ldr lr, [sp, #4]
 	add sp, sp, #8
-	do_pop {r2, r3}
+	do_pop (r2, r3)
 	RET
 	
 #endif /* L_aeabi_ldivmod */
@@ -85,17 +134,20 @@
 #ifdef L_aeabi_uldivmod
 
 ARM_FUNC_START aeabi_uldivmod
+	test_div_by_zero unsigned
+
 	sub sp, sp, #8
-#if defined(__thumb2__)
+/* Low latency and Thumb-2 do_push implementations can't push sp directly.  */
+#if defined(__thumb2__) || defined(__irq_low_latency__)
 	mov ip, sp
-	push {ip, lr}
+	do_push (ip, lr)
 #else
-	do_push {sp, lr}
+	stmfd sp!, {sp, lr}
 #endif
 	bl SYM(__gnu_uldivmod_helper) __PLT__
 	ldr lr, [sp, #4]
 	add sp, sp, #8
-	do_pop {r2, r3}
+	do_pop (r2, r3)
 	RET
 	
 #endif /* L_aeabi_divmod */
diff -Nur a/gcc/config/arm/bpabi-v6m.S b/gcc/config/arm/bpabi-v6m.S
--- a/gcc/config/arm/bpabi-v6m.S	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/arm/bpabi-v6m.S	2010-01-25 09:50:28.985687200 +0100
@@ -69,9 +69,52 @@
 
 #endif /* L_aeabi_ulcmp */
 
+.macro test_div_by_zero signed
+	cmp	yyh, #0
+	bne	7f
+	cmp	yyl, #0
+	bne	7f
+	cmp	xxh, #0
+	bne	2f
+	cmp	xxl, #0
+2:
+	.ifc	\signed, unsigned
+	beq	3f
+	mov	xxh, #0
+	mvn	xxh, xxh		@ 0xffffffff
+	mov	xxl, xxh
+3:
+	.else
+	beq	5f
+	blt	6f
+	mov	xxl, #0
+	mvn	xxl, xxl		@ 0xffffffff
+	lsr	xxh, xxl, #1		@ 0x7fffffff
+	b	5f
+6:	mov	xxh, #0x80
+	lsl	xxh, xxh, #24		@ 0x80000000
+	mov	xxl, #0
+5:
+	.endif
+	@ tailcalls are tricky on v6-m.
+	push	{r0, r1, r2}
+	ldr	r0, 1f
+	adr	r1, 1f
+	add	r0, r1
+	str	r0, [sp, #8]
+	@ We know we are not on armv4t, so pop pc is safe.
+	pop	{r0, r1, pc}
+	.align	2
+1:
+	.word	__aeabi_ldiv0 - 1b
+7:
+.endm
+
 #ifdef L_aeabi_ldivmod
 
 FUNC_START aeabi_ldivmod
+	test_div_by_zero signed
+
 	push {r0, r1}
 	mov r0, sp
 	push {r0, lr}
@@ -89,6 +132,8 @@
 #ifdef L_aeabi_uldivmod
 
 FUNC_START aeabi_uldivmod
+	test_div_by_zero unsigned
+
 	push {r0, r1}
 	mov r0, sp
 	push {r0, lr}
diff -Nur a/gcc/config/arm/constraints.md b/gcc/config/arm/constraints.md
--- a/gcc/config/arm/constraints.md	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/arm/constraints.md	2010-01-25 09:50:28.985687200 +0100
@@ -25,14 +25,15 @@
 ;; In ARM state, 'l' is an alias for 'r'
 
 ;; The following normal constraints have been used:
-;; in ARM/Thumb-2 state: G, H, I, J, K, L, M
+;; in ARM/Thumb-2 state: G, H, I, j, J, K, L, M
 ;; in Thumb-1 state: I, J, K, L, M, N, O
 
 ;; The following multi-letter normal constraints have been used:
-;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv
+;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv, Dy
+;; in Thumb-1 state: Pa, Pb
 
 ;; The following memory constraints have been used:
-;; in ARM/Thumb-2 state: Q, Ut, Uv, Uy, Un, Us
+;; in ARM/Thumb-2 state: Q, Ut, Uv, Uy, Un, Um, Us
 ;; in ARM state: Uq
 
 
@@ -65,6 +66,13 @@
 (define_register_constraint "h" "TARGET_THUMB ? HI_REGS : NO_REGS"
  "In Thumb state the core registers @code{r8}-@code{r15}.")
 
+(define_constraint "j"
+ "A constant suitable for a MOVW instruction. (ARM/Thumb-2)"
+ (and (match_test "TARGET_32BIT && arm_arch_thumb2")
+      (ior (match_code "high")
+	   (and (match_code "const_int")
+                (match_test "(ival & 0xffff0000) == 0")))))
+
 (define_register_constraint "k" "STACK_REG"
  "@internal The stack register.")
 
@@ -116,11 +124,9 @@
 		   : ((ival >= 0 && ival <= 1020) && ((ival & 3) == 0))")))
 
 (define_constraint "N"
- "In ARM/Thumb-2 state a constant suitable for a MOVW instruction.
-  In Thumb-1 state a constant in the range 0-31."
+ "Thumb-1 state a constant in the range 0-31."
  (and (match_code "const_int")
-      (match_test "TARGET_32BIT ? arm_arch_thumb2 && ((ival & 0xffff0000) == 0)
-				: (ival >= 0 && ival <= 31)")))
+      (match_test "!TARGET_32BIT && (ival >= 0 && ival <= 31)")))
 
 (define_constraint "O"
  "In Thumb-1 state a constant that is a multiple of 4 in the range
@@ -129,6 +135,18 @@
       (match_test "TARGET_THUMB1 && ival >= -508 && ival <= 508
 		   && ((ival & 3) == 0)")))
 
+(define_constraint "Pa"
+  "@internal In Thumb-1 state a constant in the range -510 to +510"
+  (and (match_code "const_int")
+       (match_test "TARGET_THUMB1 && ival >= -510 && ival <= 510
+		    && (ival > 255 || ival < -255)")))
+
+(define_constraint "Pb"
+  "@internal In Thumb-1 state a constant in the range -262 to +262"
+  (and (match_code "const_int")
+       (match_test "TARGET_THUMB1 && ival >= -262 && ival <= 262
+		    && (ival > 255 || ival < -255)")))
+
 (define_constraint "G"
  "In ARM/Thumb-2 state a valid FPA immediate constant."
  (and (match_code "const_double")
@@ -189,10 +207,17 @@
 (define_constraint "Dv"
  "@internal
   In ARM/Thumb-2 state a const_double which can be used with a VFP fconsts
-  or fconstd instruction."
+  instruction."
  (and (match_code "const_double")
       (match_test "TARGET_32BIT && vfp3_const_double_rtx (op)")))
 
+(define_constraint "Dy"
+ "@internal
+  In ARM/Thumb-2 state a const_double which can be used with a VFP fconstd
+  instruction."
+ (and (match_code "const_double")
+      (match_test "TARGET_32BIT && TARGET_VFP_DOUBLE && vfp3_const_double_rtx (op)")))
+
 (define_memory_constraint "Ut"
  "@internal
   In ARM/Thumb-2 state an address valid for loading/storing opaque structure
@@ -214,17 +239,24 @@
 
 (define_memory_constraint "Un"
  "@internal
+  In ARM/Thumb-2 state a valid address for Neon doubleword vector
+  load/store instructions."
+ (and (match_code "mem")
+      (match_test "TARGET_32BIT && neon_vector_mem_operand (op, 0)")))
+
+(define_memory_constraint "Um"
+ "@internal
   In ARM/Thumb-2 state a valid address for Neon element and structure
   load/store instructions."
  (and (match_code "mem")
-      (match_test "TARGET_32BIT && neon_vector_mem_operand (op, FALSE)")))
+      (match_test "TARGET_32BIT && neon_vector_mem_operand (op, 2)")))
 
 (define_memory_constraint "Us"
  "@internal
   In ARM/Thumb-2 state a valid address for non-offset loads/stores of
   quad-word values in four ARM registers."
  (and (match_code "mem")
-      (match_test "TARGET_32BIT && neon_vector_mem_operand (op, TRUE)")))
+      (match_test "TARGET_32BIT && neon_vector_mem_operand (op, 1)")))
 
 (define_memory_constraint "Uq"
  "@internal
diff -Nur a/gcc/config/arm/fp16.c b/gcc/config/arm/fp16.c
--- a/gcc/config/arm/fp16.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/fp16.c	2010-01-25 09:50:28.985687200 +0100
@@ -0,0 +1,145 @@
+/* Half-float conversion routines.
+
+   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+   Contributed by CodeSourcery.
+
+   This file is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 3, or (at your option) any
+   later version.
+
+   This file is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+static inline unsigned short
+__gnu_f2h_internal(unsigned int a, int ieee)
+{
+  unsigned short sign = (a >> 16) & 0x8000;
+  int aexp = (a >> 23) & 0xff;
+  unsigned int mantissa = a & 0x007fffff;
+  unsigned int mask;
+  unsigned int increment;
+
+  if (aexp == 0xff)
+    {
+      if (!ieee)
+	return sign;
+      return sign | 0x7e00 | (mantissa >> 13);
+    }
+  
+  if (aexp == 0 && mantissa == 0)
+    return sign;
+
+  aexp -= 127;
+
+  /* Decimal point between bits 22 and 23.  */
+  mantissa |= 0x00800000;
+  if (aexp < -14)
+    {
+      mask = 0x007fffff;
+      if (aexp < -25)
+	aexp = -26;
+      else if (aexp != -25)
+	mask >>= 24 + aexp;
+    }
+  else
+    mask = 0x00001fff;
+
+  /* Round.  */
+  if (mantissa & mask)
+    {
+      increment = (mask + 1) >> 1;
+      if ((mantissa & mask) == increment)
+	increment = mantissa & (increment << 1);
+      mantissa += increment;
+      if (mantissa >= 0x01000000)
+       	{
+	  mantissa >>= 1;
+	  aexp++;
+	}
+    }
+
+  if (ieee)
+    {
+      if (aexp > 15)
+	return sign | 0x7c00;
+    }
+  else
+    {
+      if (aexp > 16)
+	return sign | 0x7fff;
+    }
+
+  if (aexp < -24)
+    return sign;
+
+  if (aexp < -14)
+    {
+      mantissa >>= -14 - aexp;
+      aexp = -14;
+    }
+
+  /* We leave the leading 1 in the mantissa, and subtract one
+     from the exponent bias to compensate.  */
+  return sign | (((aexp + 14) << 10) + (mantissa >> 13));
+}
+
+unsigned int
+__gnu_h2f_internal(unsigned short a, int ieee)
+{
+  unsigned int sign = (unsigned int)(a & 0x8000) << 16;
+  int aexp = (a >> 10) & 0x1f;
+  unsigned int mantissa = a & 0x3ff;
+
+  if (aexp == 0x1f && ieee)
+    return sign | 0x7f800000 | (mantissa << 13);
+
+  if (aexp == 0)
+    {
+      int shift;
+
+      if (mantissa == 0)
+	return sign;
+
+      shift = __builtin_clz(mantissa) - 21;
+      mantissa <<= shift;
+      aexp = -shift;
+    }
+
+  return sign | (((aexp + 0x70) << 23) + (mantissa << 13));
+}
+
+unsigned short
+__gnu_f2h_ieee(unsigned int a)
+{
+  return __gnu_f2h_internal(a, 1);
+}
+
+unsigned int
+__gnu_h2f_ieee(unsigned short a)
+{
+  return __gnu_h2f_internal(a, 1);
+}
+
+unsigned short
+__gnu_f2h_alternative(unsigned int x)
+{
+  return __gnu_f2h_internal(x, 0);
+}
+
+unsigned int
+__gnu_h2f_alternative(unsigned short a)
+{
+  return __gnu_h2f_internal(a, 0);
+}
diff -Nur a/gcc/config/arm/fpa.md b/gcc/config/arm/fpa.md
--- a/gcc/config/arm/fpa.md	2007-08-02 12:49:31.000000000 +0200
+++ b/gcc/config/arm/fpa.md	2010-01-25 09:50:28.985687200 +0100
@@ -599,10 +599,10 @@
     {
     default:
     case 0: return \"mvf%?e\\t%0, %1\";
-    case 1: if (arm_fpu_arch == FPUTYPE_FPA_EMU2)
+    case 1: if (TARGET_FPA_EMU2)
 	      return \"ldf%?e\\t%0, %1\";
 	    return \"lfm%?\\t%0, 1, %1\";
-    case 2: if (arm_fpu_arch == FPUTYPE_FPA_EMU2)
+    case 2: if (TARGET_FPA_EMU2)
 	      return \"stf%?e\\t%1, %0\";
 	    return \"sfm%?\\t%1, 1, %0\";
     }
diff -Nur a/gcc/config/arm/hwdiv.md b/gcc/config/arm/hwdiv.md
--- a/gcc/config/arm/hwdiv.md	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/hwdiv.md	2010-01-25 09:50:28.985687200 +0100
@@ -0,0 +1,41 @@
+;; ARM instruction patterns for hardware division 
+;; Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
+;; Written by CodeSourcery, LLC.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful, but
+;; WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;; General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+;; Boston, MA 02110-1301, USA.
+
+(define_insn "divsi3"
+  [(set (match_operand:SI	  0 "s_register_operand" "=r")
+	(div:SI (match_operand:SI 1 "s_register_operand"  "r")
+		(match_operand:SI 2 "s_register_operand"  "r")))]
+  "arm_arch_hwdiv"
+  "sdiv%?\t%0, %1, %2"
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "sdiv")]
+)
+
+(define_insn "udivsi3"
+  [(set (match_operand:SI	   0 "s_register_operand" "=r")
+	(udiv:SI (match_operand:SI 1 "s_register_operand"  "r")
+		 (match_operand:SI 2 "s_register_operand"  "r")))]
+  "arm_arch_hwdiv"
+  "udiv%?\t%0, %1, %2"
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "udiv")]
+)
+
diff -Nur a/gcc/config/arm/ieee754-df.S b/gcc/config/arm/ieee754-df.S
--- a/gcc/config/arm/ieee754-df.S	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/arm/ieee754-df.S	2010-01-25 09:50:28.985687200 +0100
@@ -83,7 +83,7 @@
 ARM_FUNC_START adddf3
 ARM_FUNC_ALIAS aeabi_dadd adddf3
 
-1:	do_push	{r4, r5, lr}
+1:	do_push	(r4, r5, lr)
 
 	@ Look for zeroes, equal values, INF, or NAN.
 	shift1	lsl, r4, xh, #1
@@ -427,7 +427,7 @@
 	do_it	eq, t
 	moveq	r1, #0
 	RETc(eq)
-	do_push	{r4, r5, lr}
+	do_push	(r4, r5, lr)
 	mov	r4, #0x400		@ initial exponent
 	add	r4, r4, #(52-1 - 1)
 	mov	r5, #0			@ sign bit is 0
@@ -447,7 +447,7 @@
 	do_it	eq, t
 	moveq	r1, #0
 	RETc(eq)
-	do_push	{r4, r5, lr}
+	do_push	(r4, r5, lr)
 	mov	r4, #0x400		@ initial exponent
 	add	r4, r4, #(52-1 - 1)
 	ands	r5, r0, #0x80000000	@ sign bit in r5
@@ -481,7 +481,7 @@
 	RETc(eq)			@ we are done already.
 
 	@ value was denormalized.  We can normalize it now.
-	do_push	{r4, r5, lr}
+	do_push	(r4, r5, lr)
 	mov	r4, #0x380		@ setup corresponding exponent
 	and	r5, xh, #0x80000000	@ move sign bit in r5
 	bic	xh, xh, #0x80000000
@@ -508,9 +508,9 @@
 	@ compatibility.
 	adr	ip, LSYM(f0_ret)
 	@ Push pc as well so that RETLDM works correctly.
-	do_push	{r4, r5, ip, lr, pc}
+	do_push	(r4, r5, ip, lr, pc)
 #else
-	do_push	{r4, r5, lr}
+	do_push	(r4, r5, lr)
 #endif
 
 	mov	r5, #0
@@ -534,9 +534,9 @@
 	@ compatibility.
 	adr	ip, LSYM(f0_ret)
 	@ Push pc as well so that RETLDM works correctly.
-	do_push	{r4, r5, ip, lr, pc}
+	do_push	(r4, r5, ip, lr, pc)
 #else
-	do_push	{r4, r5, lr}
+	do_push	(r4, r5, lr)
 #endif
 
 	ands	r5, ah, #0x80000000	@ sign bit in r5
@@ -585,7 +585,7 @@
 	@ Legacy code expects the result to be returned in f0.  Copy it
 	@ there as well.
 LSYM(f0_ret):
-	do_push	{r0, r1}
+	do_push	(r0, r1)
 	ldfd	f0, [sp], #8
 	RETLDM
 
@@ -602,7 +602,7 @@
 
 ARM_FUNC_START muldf3
 ARM_FUNC_ALIAS aeabi_dmul muldf3
-	do_push	{r4, r5, r6, lr}
+	do_push	(r4, r5, r6, lr)
 
 	@ Mask out exponents, trap any zero/denormal/INF/NAN.
 	mov	ip, #0xff
@@ -910,7 +910,7 @@
 ARM_FUNC_START divdf3
 ARM_FUNC_ALIAS aeabi_ddiv divdf3
 	
-	do_push	{r4, r5, r6, lr}
+	do_push	(r4, r5, r6, lr)
 
 	@ Mask out exponents, trap any zero/denormal/INF/NAN.
 	mov	ip, #0xff
@@ -1117,7 +1117,7 @@
 ARM_FUNC_ALIAS eqdf2 cmpdf2
 	mov	ip, #1			@ how should we specify unordered here?
 
-1:	str	ip, [sp, #-4]
+1:	str	ip, [sp, #-4]!
 
 	@ Trap any INF/NAN first.
 	mov	ip, xh, lsl #1
@@ -1129,7 +1129,8 @@
 
 	@ Test for equality.
 	@ Note that 0.0 is equal to -0.0.
-2:	orrs	ip, xl, xh, lsl #1	@ if x == 0.0 or -0.0
+2:	add	sp, sp, #4
+	orrs	ip, xl, xh, lsl #1	@ if x == 0.0 or -0.0
 	do_it	eq, e
 	COND(orr,s,eq)	ip, yl, yh, lsl #1	@ and y == 0.0 or -0.0
 	teqne	xh, yh			@ or xh == yh
@@ -1168,7 +1169,7 @@
 	bne	2b
 	orrs	ip, yl, yh, lsl #12
 	beq	2b			@ y is not NAN
-5:	ldr	r0, [sp, #-4]		@ unordered return code
+5:	ldr	r0, [sp], #4		@ unordered return code
 	RET
 
 	FUNC_END gedf2
@@ -1194,7 +1195,7 @@
 
 	@ The status-returning routines are required to preserve all
 	@ registers except ip, lr, and cpsr.
-6:	do_push	{r0, lr}
+6:	do_push	(r0, lr)
 	ARM_CALL cmpdf2
 	@ Set the Z flag correctly, and the C flag unconditionally.
 	cmp	r0, #0
diff -Nur a/gcc/config/arm/ieee754-sf.S b/gcc/config/arm/ieee754-sf.S
--- a/gcc/config/arm/ieee754-sf.S	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/arm/ieee754-sf.S	2010-01-25 09:50:28.985687200 +0100
@@ -481,7 +481,7 @@
 	and	r3, ip, #0x80000000
 
 	@ Well, no way to make it shorter without the umull instruction.
-	do_push	{r3, r4, r5}
+	do_push	(r3, r4, r5)
 	mov	r4, r0, lsr #16
 	mov	r5, r1, lsr #16
 	bic	r0, r0, r4, lsl #16
@@ -492,7 +492,7 @@
 	mla	r0, r4, r1, r0
 	adds	r3, r3, r0, lsl #16
 	adc	r1, ip, r0, lsr #16
-	do_pop	{r0, r4, r5}
+	do_pop	(r0, r4, r5)
 
 #else
 
@@ -822,7 +822,7 @@
 ARM_FUNC_ALIAS eqsf2 cmpsf2
 	mov	ip, #1			@ how should we specify unordered here?
 
-1:	str	ip, [sp, #-4]
+1:	str	ip, [sp, #-4]!
 
 	@ Trap any INF/NAN first.
 	mov	r2, r0, lsl #1
@@ -834,7 +834,8 @@
 
 	@ Compare values.
 	@ Note that 0.0 is equal to -0.0.
-2:	orrs	ip, r2, r3, lsr #1	@ test if both are 0, clear C flag
+2:	add	sp, sp, #4
+	orrs	ip, r2, r3, lsr #1	@ test if both are 0, clear C flag
 	do_it	ne
 	teqne	r0, r1			@ if not 0 compare sign
 	do_it	pl
@@ -858,7 +859,7 @@
 	bne	2b
 	movs	ip, r1, lsl #9
 	beq	2b			@ r1 is not NAN
-5:	ldr	r0, [sp, #-4]		@ return unordered code.
+5:	ldr	r0, [sp], #4		@ return unordered code.
 	RET
 
 	FUNC_END gesf2
@@ -881,7 +882,7 @@
 
 	@ The status-returning routines are required to preserve all
 	@ registers except ip, lr, and cpsr.
-6:	do_push	{r0, r1, r2, r3, lr}
+6:	do_push	(r0, r1, r2, r3, lr)
 	ARM_CALL cmpsf2
 	@ Set the Z flag correctly, and the C flag unconditionally.
 	cmp	r0, #0
diff -Nur a/gcc/config/arm/lib1funcs.asm b/gcc/config/arm/lib1funcs.asm
--- a/gcc/config/arm/lib1funcs.asm	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/arm/lib1funcs.asm	2010-01-25 09:50:28.985687200 +0100
@@ -27,8 +27,17 @@
 #if defined(__ELF__) && defined(__linux__)
 .section .note.GNU-stack,"",%progbits
 .previous
-#endif
+#endif  /* __ELF__ and __linux__ */
 
+#ifdef __ARM_EABI__
+/* Some attributes that are common to all routines in this file.  */
+       /* Tag_ABI_align8_needed: This code does not require 8-byte
+          alignment from the caller.  */
+       /* .eabi_attribute 24, 0  -- default setting.  */
+       /* Tag_ABI_align8_preserved: This code preserves 8-byte 
+          alignment in any callee.  */
+       .eabi_attribute 25, 1
+#endif /* __ARM_EABI__ */
 /* ------------------------------------------------------------------------ */
 
 /* We need to know what prefix to add to function names.  */
@@ -233,8 +242,8 @@
 .macro shift1 op, arg0, arg1, arg2
 	\op	\arg0, \arg1, \arg2
 .endm
-#define do_push	push
-#define do_pop	pop
+#define do_push(...)	push {__VA_ARGS__}
+#define do_pop(...)	pop {__VA_ARGS__}
 #define COND(op1, op2, cond) op1 ## op2 ## cond
 /* Perform an arithmetic operation with a variable shift operand.  This
    requires two instructions and a scratch register on Thumb-2.  */
@@ -248,24 +257,133 @@
 .macro shift1 op, arg0, arg1, arg2
 	mov	\arg0, \arg1, \op \arg2
 .endm
-#define do_push	stmfd sp!,
-#define do_pop	ldmfd sp!,
+#if defined(__low_irq_latency__)        
+#define do_push(...) \
+  _buildN1(do_push, _buildC1(__VA_ARGS__))( __VA_ARGS__)
+#define _buildN1(BASE, X)	_buildN2(BASE, X)
+#define _buildN2(BASE, X)	BASE##X
+#define _buildC1(...)		_buildC2(__VA_ARGS__,9,8,7,6,5,4,3,2,1)
+#define _buildC2(a1,a2,a3,a4,a5,a6,a7,a8,a9,c,...) c
+        
+#define do_push1(r1) str r1, [sp, #-4]!
+#define do_push2(r1, r2) str r2, [sp, #-4]! ; str r1, [sp, #-4]!
+#define do_push3(r1, r2, r3) str r3, [sp, #-4]! ; str r2, [sp, #-4]!; str r1, [sp, #-4]!
+#define do_push4(r1, r2, r3, r4) \
+        do_push3 (r2, r3, r4);\
+        do_push1 (r1)
+#define do_push5(r1, r2, r3, r4, r5) \
+        do_push4 (r2, r3, r4, r5);\
+        do_push1 (r1)
+        
+#define do_pop(...) \
+_buildN1(do_pop, _buildC1(__VA_ARGS__))( __VA_ARGS__)
+        
+#define do_pop1(r1) ldr r1, [sp], #4
+#define do_pop2(r1, r2) ldr r1, [sp], #4 ; ldr r2, [sp], #4
+#define do_pop3(r1, r2, r3) ldr r1, [sp], #4 ; str r2, [sp], #4; str r3, [sp], #4
+#define do_pop4(r1, r2, r3, r4) \
+        do_pop1 (r1);\
+        do_pup3 (r2, r3, r4)
+#define do_pop5(r1, r2, r3, r4, r5) \
+        do_pop1 (r1);\
+        do_pop4 (r2, r3, r4, r5)
+#else
+#define do_push(...)    stmfd sp!, { __VA_ARGS__}
+#define do_pop(...)     ldmfd sp!, {__VA_ARGS__}
+#endif
+
+        
 #define COND(op1, op2, cond) op1 ## cond ## op2
 .macro shiftop name, dest, src1, src2, shiftop, shiftreg, tmp
 	\name \dest, \src1, \src2, \shiftop \shiftreg
 .endm
 #endif
 
-.macro ARM_LDIV0 name
+#ifdef __ARM_EABI__
+.macro ARM_LDIV0 name signed
+	cmp	r0, #0
+	.ifc	\signed, unsigned
+	movne	r0, #0xffffffff
+	.else
+	movgt	r0, #0x7fffffff
+	movlt	r0, #0x80000000
+	.endif
+	b	SYM (__aeabi_idiv0) __PLT__
+.endm
+#else
+.macro ARM_LDIV0 name signed
 	str	lr, [sp, #-8]!
 98:	cfi_push 98b - __\name, 0xe, -0x8, 0x8
 	bl	SYM (__div0) __PLT__
 	mov	r0, #0			@ About as wrong as it could be.
 	RETLDM	unwind=98b
 .endm
+#endif
 
 
-.macro THUMB_LDIV0 name
+#ifdef __ARM_EABI__
+.macro THUMB_LDIV0 name signed
+#if defined(__ARM_ARCH_6M__)
+	.ifc \signed, unsigned
+	cmp	r0, #0
+	beq	1f
+	mov	r0, #0
+	mvn	r0, r0		@ 0xffffffff
+1:
+	.else
+	cmp	r0, #0
+	beq	2f
+	blt	3f
+	mov	r0, #0
+	mvn	r0, r0
+	lsr	r0, r0, #1	@ 0x7fffffff
+	b	2f
+3:	mov	r0, #0x80
+	lsl	r0, r0, #24	@ 0x80000000
+2:
+	.endif
+	push	{r0, r1, r2}
+	ldr	r0, 4f
+	adr	r1, 4f
+	add	r0, r1
+	str	r0, [sp, #8]
+	@ We know we are not on armv4t, so pop pc is safe.
+	pop	{r0, r1, pc}
+	.align	2
+4:
+	.word	__aeabi_idiv0 - 4b
+#elif defined(__thumb2__)
+	.syntax unified
+	.ifc \signed, unsigned
+	cbz	r0, 1f
+	mov	r0, #0xffffffff
+1:
+	.else
+	cmp	r0, #0
+	do_it	gt
+	movgt	r0, #0x7fffffff
+	do_it	lt
+	movlt	r0, #0x80000000
+	.endif
+	b.w	SYM(__aeabi_idiv0) __PLT__
+#else
+	.align	2
+	bx	pc
+	nop
+	.arm
+	cmp	r0, #0
+	.ifc	\signed, unsigned
+	movne	r0, #0xffffffff
+	.else
+	movgt	r0, #0x7fffffff
+	movlt	r0, #0x80000000
+	.endif
+	b	SYM(__aeabi_idiv0) __PLT__
+	.thumb
+#endif
+.endm
+#else
+.macro THUMB_LDIV0 name signed
 	push	{ r1, lr }
 98:	cfi_push 98b - __\name, 0xe, -0x4, 0x8
 	bl	SYM (__div0)
@@ -277,18 +395,19 @@
 	pop	{ r1, pc }
 #endif
 .endm
+#endif
 
 .macro FUNC_END name
 	SIZE (__\name)
 .endm
 
-.macro DIV_FUNC_END name
+.macro DIV_FUNC_END name signed
 	cfi_start	__\name, LSYM(Lend_div0)
 LSYM(Ldiv0):
 #ifdef __thumb__
-	THUMB_LDIV0 \name
+	THUMB_LDIV0 \name \signed
 #else
-	ARM_LDIV0 \name
+	ARM_LDIV0 \name \signed
 #endif
 	cfi_end	LSYM(Lend_div0)
 	FUNC_END \name
@@ -413,6 +532,12 @@
 #define yyl r2
 #endif	
 
+#ifdef __ARM_EABI__
+.macro	WEAK name
+	.weak SYM (__\name)
+.endm
+#endif
+
 #ifdef __thumb__
 /* Register aliases.  */
 
@@ -437,6 +562,43 @@
 
 #if __ARM_ARCH__ >= 5 && ! defined (__OPTIMIZE_SIZE__)
 
+#if defined (__thumb2__)
+	clz	\curbit, \dividend
+	clz	\result, \divisor
+	sub	\curbit, \result, \curbit
+	rsb	\curbit, \curbit, #31
+	adr	\result, 1f
+	add	\curbit, \result, \curbit, lsl #4
+	mov	\result, #0
+	mov	pc, \curbit
+.p2align 3
+1:
+	.set	shift, 32
+	.rept	32
+	.set	shift, shift - 1
+	cmp.w	\dividend, \divisor, lsl #shift
+	nop.n
+	adc.w	\result, \result, \result
+	it	cs
+	subcs.w	\dividend, \dividend, \divisor, lsl #shift
+	.endr
+#elif defined(__ARM_TUNE_MARVELL_F__)
+	clz	\curbit, \dividend
+	clz	\result, \divisor
+	sub	\curbit, \result, \curbit
+	mov	\divisor, \divisor, lsl \curbit
+	rsb	\curbit, \curbit, #31
+	mov	\curbit, \curbit, lsl #2
+	mov	\result, #0
+	add	pc, pc, \curbit, lsl #2
+	nop
+	.rept	32
+	cmp	\dividend, \divisor
+	subcs	\dividend, \dividend, \divisor
+	mov	\divisor, \divisor, lsr #1
+	adc	\result, \result, \result
+	.endr
+#else  /* ! defined(__ARM_TUNE_MARVELL_F__) */
 	clz	\curbit, \dividend
 	clz	\result, \divisor
 	sub	\curbit, \result, \curbit
@@ -452,6 +614,7 @@
 	adc	\result, \result, \result
 	subcs	\dividend, \dividend, \divisor, lsl #shift
 	.endr
+#endif /* defined(__ARM_TUNE_MARVELL_F__) */
 
 #else /* __ARM_ARCH__ < 5 || defined (__OPTIMIZE_SIZE__) */
 #if __ARM_ARCH__ >= 5
@@ -499,18 +662,23 @@
 
 	@ Division loop
 1:	cmp	\dividend, \divisor
+	do_it	hs, t
 	subhs	\dividend, \dividend, \divisor
 	orrhs	\result,   \result,   \curbit
 	cmp	\dividend, \divisor,  lsr #1
+	do_it	hs, t
 	subhs	\dividend, \dividend, \divisor, lsr #1
 	orrhs	\result,   \result,   \curbit,  lsr #1
 	cmp	\dividend, \divisor,  lsr #2
+	do_it	hs, t
 	subhs	\dividend, \dividend, \divisor, lsr #2
 	orrhs	\result,   \result,   \curbit,  lsr #2
 	cmp	\dividend, \divisor,  lsr #3
+	do_it	hs, t
 	subhs	\dividend, \dividend, \divisor, lsr #3
 	orrhs	\result,   \result,   \curbit,  lsr #3
 	cmp	\dividend, #0			@ Early termination?
+	do_it	ne, t
 	movnes	\curbit,   \curbit,  lsr #4	@ No, any more bits to do?
 	movne	\divisor,  \divisor, lsr #4
 	bne	1b
@@ -799,13 +967,14 @@
 /* ------------------------------------------------------------------------ */
 #ifdef L_udivsi3
 
+#if defined(__ARM_ARCH_6M__)
+
 	FUNC_START udivsi3
 	FUNC_ALIAS aeabi_uidiv udivsi3
 
-#ifdef __thumb__
-
 	cmp	divisor, #0
 	beq	LSYM(Ldiv0)
+LSYM(udivsi3_nodiv0):
 	mov	curbit, #1
 	mov	result, #0
 	
@@ -819,9 +988,16 @@
 	pop	{ work }
 	RET
 
-#else /* ARM version.  */
+#else /* ARM/Thumb-2 version.  */
+
+	ARM_FUNC_START udivsi3
+	ARM_FUNC_ALIAS aeabi_uidiv udivsi3
 
+	/* Note: if called via udivsi3_nodiv0, this will unnecessarily check
+	   for division-by-zero a second time.  */
+LSYM(udivsi3_nodiv0):
 	subs	r2, r1, #1
+	do_it	eq
 	RETc(eq)
 	bcc	LSYM(Ldiv0)
 	cmp	r0, r1
@@ -834,7 +1010,8 @@
 	mov	r0, r2
 	RET	
 
-11:	moveq	r0, #1
+11:	do_it	eq, e
+	moveq	r0, #1
 	movne	r0, #0
 	RET
 
@@ -845,19 +1022,24 @@
 
 #endif /* ARM version */
 
-	DIV_FUNC_END udivsi3
+	DIV_FUNC_END udivsi3 unsigned
 
+#if defined(__ARM_ARCH_6M__)
 FUNC_START aeabi_uidivmod
-#ifdef __thumb__
+	cmp	r1, #0
+	beq	LSYM(Ldiv0)
 	push	{r0, r1, lr}
-	bl	SYM(__udivsi3)
+	bl	LSYM(udivsi3_nodiv0)
 	POP	{r1, r2, r3}
 	mul	r2, r0
 	sub	r1, r1, r2
 	bx	r3
 #else
+ARM_FUNC_START aeabi_uidivmod
+	cmp	r1, #0
+	beq	LSYM(Ldiv0)
 	stmfd	sp!, { r0, r1, lr }
-	bl	SYM(__udivsi3)
+	bl	LSYM(udivsi3_nodiv0)
 	ldmfd	sp!, { r1, r2, lr }
 	mul	r3, r2, r0
 	sub	r1, r1, r3
@@ -904,19 +1086,20 @@
 
 #endif /* ARM version.  */
 	
-	DIV_FUNC_END umodsi3
+	DIV_FUNC_END umodsi3 unsigned
 
 #endif /* L_umodsi3 */
 /* ------------------------------------------------------------------------ */
 #ifdef L_divsi3
 
+#if defined(__ARM_ARCH_6M__)
+
 	FUNC_START divsi3	
 	FUNC_ALIAS aeabi_idiv divsi3
 
-#ifdef __thumb__
 	cmp	divisor, #0
 	beq	LSYM(Ldiv0)
-	
+LSYM(divsi3_nodiv0):
 	push	{ work }
 	mov	work, dividend
 	eor	work, divisor		@ Save the sign of the result.
@@ -945,15 +1128,21 @@
 	pop	{ work }
 	RET
 
-#else /* ARM version.  */
+#else /* ARM/Thumb-2 version.  */
 	
+	ARM_FUNC_START divsi3	
+	ARM_FUNC_ALIAS aeabi_idiv divsi3
+
 	cmp	r1, #0
-	eor	ip, r0, r1			@ save the sign of the result.
 	beq	LSYM(Ldiv0)
+LSYM(divsi3_nodiv0):
+	eor	ip, r0, r1			@ save the sign of the result.
+	do_it	mi
 	rsbmi	r1, r1, #0			@ loops below use unsigned.
 	subs	r2, r1, #1			@ division by 1 or -1 ?
 	beq	10f
 	movs	r3, r0
+	do_it	mi
 	rsbmi	r3, r0, #0			@ positive dividend value
 	cmp	r3, r1
 	bls	11f
@@ -963,14 +1152,18 @@
 	ARM_DIV_BODY r3, r1, r0, r2
 	
 	cmp	ip, #0
+	do_it	mi
 	rsbmi	r0, r0, #0
 	RET	
 
 10:	teq	ip, r0				@ same sign ?
+	do_it	mi
 	rsbmi	r0, r0, #0
 	RET	
 
-11:	movlo	r0, #0
+11:	do_it	lo
+	movlo	r0, #0
+	do_it	eq,t
 	moveq	r0, ip, asr #31
 	orreq	r0, r0, #1
 	RET
@@ -979,24 +1172,30 @@
 
 	cmp	ip, #0
 	mov	r0, r3, lsr r2
+	do_it	mi
 	rsbmi	r0, r0, #0
 	RET
 
 #endif /* ARM version */
 	
-	DIV_FUNC_END divsi3
+	DIV_FUNC_END divsi3 signed
 
+#if defined(__ARM_ARCH_6M__)
 FUNC_START aeabi_idivmod
-#ifdef __thumb__
+	cmp	r1, #0
+	beq	LSYM(Ldiv0)
 	push	{r0, r1, lr}
-	bl	SYM(__divsi3)
+	bl	LSYM(divsi3_nodiv0)
 	POP	{r1, r2, r3}
 	mul	r2, r0
 	sub	r1, r1, r2
 	bx	r3
 #else
+ARM_FUNC_START aeabi_idivmod
+	cmp	r1, #0
+	beq	LSYM(Ldiv0)
 	stmfd	sp!, { r0, r1, lr }
-	bl	SYM(__divsi3)
+	bl	LSYM(divsi3_nodiv0)
 	ldmfd	sp!, { r1, r2, lr }
 	mul	r3, r2, r0
 	sub	r1, r1, r3
@@ -1062,21 +1261,25 @@
 
 #endif /* ARM version */
 	
-	DIV_FUNC_END modsi3
+	DIV_FUNC_END modsi3 signed
 
 #endif /* L_modsi3 */
 /* ------------------------------------------------------------------------ */
 #ifdef L_dvmd_tls
 
-	FUNC_START div0
-	FUNC_ALIAS aeabi_idiv0 div0
-	FUNC_ALIAS aeabi_ldiv0 div0
-
+#ifdef __ARM_EABI__
+	WEAK aeabi_idiv0
+	WEAK aeabi_ldiv0
+	FUNC_START aeabi_idiv0
+	FUNC_START aeabi_ldiv0
 	RET
-
 	FUNC_END aeabi_ldiv0
 	FUNC_END aeabi_idiv0
+#else
+	FUNC_START div0
+	RET
 	FUNC_END div0
+#endif
 	
 #endif /* L_divmodsi_tools */
 /* ------------------------------------------------------------------------ */
@@ -1086,16 +1289,49 @@
 /* Constant taken from <asm/signal.h>.  */
 #define SIGFPE	8
 
+#ifdef __ARM_EABI__
+	WEAK aeabi_idiv0
+	WEAK aeabi_ldiv0
+	ARM_FUNC_START aeabi_idiv0
+	ARM_FUNC_START aeabi_ldiv0
+#else
 	ARM_FUNC_START div0
+#endif
 
-	do_push	{r1, lr}
+	do_push	(r1, lr)
 	mov	r0, #SIGFPE
 	bl	SYM(raise) __PLT__
 	RETLDM	r1
 
+#ifdef __ARM_EABI__
+	FUNC_END aeabi_ldiv0
+	FUNC_END aeabi_idiv0
+#else
 	FUNC_END div0
+#endif
 	
 #endif /* L_dvmd_lnx */
+#ifdef L_clear_cache
+#if defined __ARM_EABI__ && defined __linux__
+@ EABI GNU/Linux call to cacheflush syscall.
+	ARM_FUNC_START clear_cache
+	do_push	(r7)
+#if __ARM_ARCH__ >= 7 || defined(__ARM_ARCH_6T2__)
+	movw	r7, #2
+	movt	r7, #0xf
+#else
+	mov	r7, #0xf0000
+	add	r7, r7, #2
+#endif
+	mov	r2, #0
+	swi	0
+	do_pop	(r7)
+	RET
+	FUNC_END clear_cache
+#else
+#error "This is only for ARM EABI GNU/Linux"
+#endif
+#endif /* L_clear_cache */
 /* ------------------------------------------------------------------------ */
 /* Dword shift operations.  */
 /* All the following Dword shift variants rely on the fact that
@@ -1292,7 +1528,7 @@
 	push	{r4, lr}
 # else
 ARM_FUNC_START clzdi2
-	do_push	{r4, lr}
+	do_push	(r4, lr)
 # endif
 	cmp	xxh, #0
 	bne	1f
diff -Nur a/gcc/config/arm/linux-eabi.h b/gcc/config/arm/linux-eabi.h
--- a/gcc/config/arm/linux-eabi.h	2007-11-08 14:44:09.000000000 +0100
+++ b/gcc/config/arm/linux-eabi.h	2010-01-25 09:50:28.995687913 +0100
@@ -66,22 +66,14 @@
 /* At this point, bpabi.h will have clobbered LINK_SPEC.  We want to
    use the GNU/Linux version, not the generic BPABI version.  */
 #undef  LINK_SPEC
-#define LINK_SPEC LINUX_TARGET_LINK_SPEC
+#define LINK_SPEC LINUX_TARGET_LINK_SPEC BE8_LINK_SPEC
 
 /* Use the default LIBGCC_SPEC, not the version in linux-elf.h, as we
    do not use -lfloat.  */
 #undef LIBGCC_SPEC
 
-/* Clear the instruction cache from `beg' to `end'.  This makes an
-   inline system call to SYS_cacheflush.  */
+/* Clear the instruction cache from `beg' to `end'.  This is
+   implemented in lib1funcs.asm, so ensure an error if this definition
+   is used.  */
 #undef  CLEAR_INSN_CACHE
-#define CLEAR_INSN_CACHE(BEG, END)					\
-{									\
-  register unsigned long _beg __asm ("a1") = (unsigned long) (BEG);	\
-  register unsigned long _end __asm ("a2") = (unsigned long) (END);	\
-  register unsigned long _flg __asm ("a3") = 0;				\
-  register unsigned long _scno __asm ("r7") = 0xf0002;			\
-  __asm __volatile ("swi 0		@ sys_cacheflush"		\
-		    : "=r" (_beg)					\
-		    : "0" (_beg), "r" (_end), "r" (_flg), "r" (_scno));	\
-}
+#define CLEAR_INSN_CACHE(BEG, END) not used
diff -Nur a/gcc/config/arm/linux-elf.h b/gcc/config/arm/linux-elf.h
--- a/gcc/config/arm/linux-elf.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/arm/linux-elf.h	2010-01-25 09:50:28.995687913 +0100
@@ -98,7 +98,7 @@
 
 /* NWFPE always understands FPA instructions.  */
 #undef  FPUTYPE_DEFAULT
-#define FPUTYPE_DEFAULT FPUTYPE_FPA_EMU3
+#define FPUTYPE_DEFAULT "fpe3"
 
 /* Call the function profiler with a given profile label.  */
 #undef  ARM_FUNCTION_PROFILER
diff -Nur a/gcc/config/arm/marvell-f.md b/gcc/config/arm/marvell-f.md
--- a/gcc/config/arm/marvell-f.md	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/marvell-f.md	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,365 @@
+;; Marvell 2850 pipeline description
+;; Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
+;; Written by Marvell and CodeSourcery, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 2, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+;; Boston, MA 02110-1301, USA.
+
+;; This automaton provides a pipeline description for the Marvell
+;; 2850 core.
+;;
+;; The model given here assumes that the condition for all conditional
+;; instructions is "true", i.e., that all of the instructions are
+;; actually executed.
+
+(define_automaton "marvell_f")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Pipelines
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; This is a dual-issue processor with three pipelines:
+;;
+;; 1. Arithmetic and load/store pipeline A1.
+;;    Issue | E1 | E2 | OF | WR | WB  for load-store instructions
+;;    Issue | E1 | E2 | WB  for arithmetic instructions
+;;
+;; 2. Arithmetic pipeline A2.
+;;    Issue | E1 | E2 | WB
+;;
+;; 3. Multiply and multiply-accumulate pipeline.
+;;    Issue | MAC1 | MAC2 | MAC3 | WB
+;;
+;; There are various bypasses modelled to a greater or lesser extent.
+;;
+;; Latencies in this file correspond to the number of cycles after
+;; the issue stage that it takes for the result of the instruction to
+;; be computed, or for its side-effects to occur.
+
+(define_cpu_unit "a1_e1,a1_e2,a1_of,a1_wr,a1_wb" "marvell_f") ; ALU 1
+(define_cpu_unit "a2_e1,a2_e2,a2_wb" "marvell_f")             ; ALU 2
+(define_cpu_unit "m_1,m_2,m_3,m_wb" "marvell_f")              ; MAC
+
+;; We define an SRAM cpu unit to enable us to describe conflicts
+;; between loads at the E2 stage and stores at the WR stage.
+
+(define_cpu_unit "sram" "marvell_f")
+
+;; Handling of dual-issue constraints.
+;;
+;; Certain pairs of instructions can be issued in parallel, and certain
+;; pairs cannot.  We divide a subset of the instructions into groups as
+;; follows.
+;;
+;; - data processing 1 (mov, mvn);
+;; - data processing 2 (adc, add, and, bic, cmn, cmp, eor, orr, rsb,
+;;                      rsc, sbc, sub, teq, tst);
+;; - load single (ldr, ldrb, ldrbt, ldrt, ldrh, ldrsb, ldrsh);
+;; - store single (str, strb, strbt, strt, strh);
+;; - swap (swp, swpb);
+;; - pld;
+;; - count leading zeros and DSP add/sub (clz, qadd, qdadd, qsub, qdsub);
+;; - multiply 2 (mul, muls, smull, umull, smulxy, smulls, umulls);
+;; - multiply 3 (mla, mlas, smlal, umlal, smlaxy, smlalxy, smlawx,
+;;               smlawy, smlals, umlals);
+;; - branches (b, bl, blx, bx).
+;;
+;; Ignoring conditional execution, it is a good approximation to the core
+;; to model that two instructions may only be issued in parallel if the
+;; following conditions are met.
+;; I.   The instructions both fall into one of the above groups and their
+;;      corresponding groups have a entry in the matrix below that is not X.
+;; II.  The second instruction does not read any register updated by the
+;;      first instruction (already enforced by the GCC scheduler).
+;; III. The second instruction does not need the carry flag updated by the
+;;      first instruction.  Currently we do not model this.
+;;
+;; First	Second instruction group
+;; insn
+;;		DP1  DP2  L    S    SWP  PLD  CLZ  M2   M3   B
+;;
+;;	DP1	ok   ok   ok   ok   ok   ok   ok   ok   ok   ok
+;;	DP2(1)  ok   ok   ok   ok   ok   ok   ok   ok   ok   ok
+;;	DP2(2)  ok   (2)  ok   (4)  ok   ok   ok   ok   X    ok
+;;	L   }
+;;	SWP }   ok   ok   X    X    X    X    ok   ok   ok   ok
+;;	PLD }
+;;      S(3)	ok   ok   X    X    X    X    ok   ok   ok   ok
+;;      S(4)	ok   (2)  X    X    X    X    ok   ok   X    ok
+;;	CLZ     ok   ok   ok   ok   ok   ok   ok   ok   ok   ok
+;;	M2	ok   ok   ok   ok   ok   ok   ok   X    X    ok
+;;	M3	ok   (2)  ok   (4)  ok   ok   ok   X    X    ok
+;;	B	ok   ok   ok   ok   ok   ok   ok   ok   ok   ok
+;;
+;; (1) without register shift
+;; (2) with register shift
+;; (3) with immediate offset
+;; (4) with register offset
+;;
+;; We define a fake cpu unit "reg_shift_lock" to enforce constraints
+;; between instructions in groups DP2(2) and M3.  All other
+;; constraints are enforced automatically by virtue of the limited
+;; number of pipelines available for the various operations, with
+;; the exception of constraints involving S(4) that we do not model.
+
+(define_cpu_unit "reg_shift_lock" "marvell_f")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; ALU instructions
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; 1. Certain logic operations can be retired after the E1 stage if
+;; the pipeline is not already retiring another instruction.  In this
+;; model we assume this behaviour always holds for mov, mvn, and, orr, eor
+;; instructions.  If a register shift is involved and the instruction is
+;; not mov or mvn, then a dual-issue constraint must be enforced.
+
+;; The first two cases are separate so they can be identified for
+;; bypasses below.
+
+(define_insn_reservation "marvell_f_alu_early_retire" 1
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu")
+            (eq_attr "insn" "mov,mvn,and,orr,eor")))
+  "(a1_e1,a1_wb)|(a2_e1,a2_wb)")
+
+(define_insn_reservation "marvell_f_alu_early_retire_shift" 1
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu_shift_reg")
+            (eq_attr "insn" "mov,mvn,and,orr,eor")))
+  "(a1_e1,a1_wb)|(a2_e1,a2_wb)")
+
+(define_insn_reservation "marvell_f_alu_early_retire_reg_shift1" 1
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu_shift_reg")
+            (eq_attr "insn" "mov,mvn")))
+  "(a1_e1,a1_wb)|(a2_e1,a2_wb)")
+
+(define_insn_reservation "marvell_f_alu_early_retire_reg_shift2" 1
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu_shift_reg")
+            (eq_attr "insn" "and,orr,eor")))
+  "(reg_shift_lock+a1_e1,a1_wb)|(reg_shift_lock+a2_e1,a2_wb)")
+
+;; 2. ALU operations with no shifted operand.  These bypass the E1 stage if
+;; the E2 stage of the corresponding pipeline is clear; here, we always
+;; model this scenario [*].  We give the operation a latency of 1 yet reserve
+;; both E1 and E2 for it (thus preventing the GCC scheduler, in the case
+;; where both E1 and E2 of one pipeline are clear, from issuing one
+;; instruction to each).
+;;
+;; [*] The non-bypass case is a latency of two, reserving E1 on the first
+;;     cycle and E2 on the next.  Due to the way the scheduler works we
+;;     have to choose between taking this as the default and taking the
+;;     above case (with latency one) as the default; we choose the latter.
+
+(define_insn_reservation "marvell_f_alu_op_bypass_e1" 1
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu")
+            (not (eq_attr "insn" "mov,mvn,and,orr,eor"))))
+  "(a1_e1+a1_e2,a1_wb)|(a2_e1+a2_e2,a2_wb)")
+
+;; 3. ALU operations with a shift-by-constant operand.
+
+(define_insn_reservation "marvell_f_alu_shift_op" 2
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu_shift")
+            (not (eq_attr "insn" "mov,mvn,and,orr,eor"))))
+  "(a1_e1,a1_e2,a1_wb)|(a2_e1,a2_e2,a2_wb)")
+
+;; 4. ALU operations with a shift-by-register operand.  Since the
+;; instruction is never mov or mvn, a dual-issue constraint must
+;; be enforced.
+
+(define_insn_reservation "marvell_f_alu_shift_reg_op" 2
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu_shift_reg")
+            (not (eq_attr "insn" "mov,mvn,and,orr,eor"))))
+  "(reg_shift_lock+a1_e1,a1_e2,a1_wb)|(reg_shift_lock+a2_e1,a2_e2,a2_wb)")
+
+;; Given an ALU operation with shift (I1) followed by another ALU
+;; operation (I2), with I2 depending on the destination register Rd of I1
+;; and with I2 not using that value as the amount or the starting value for
+;; a shift, then I1 and I2 may be issued to the same pipeline on
+;; consecutive cycles.  In terms of this model that corresponds to I1
+;; having a latency of one cycle.  There are three cases for various
+;; I1 and I2 as follows.
+
+;; (a) I1 has a constant or register shift and I2 doesn't have a shift at all.
+(define_bypass 1 "marvell_f_alu_shift_op,\
+	          marvell_f_alu_shift_reg_op"
+	       "marvell_f_alu_op_bypass_e1,marvell_f_alu_early_retire")
+
+;; (b) I1 has a constant or register shift and I2 has a constant shift.
+;; Rd must not provide the starting value for the shift.
+(define_bypass 1 "marvell_f_alu_shift_op,\
+	          marvell_f_alu_shift_reg_op"
+	       "marvell_f_alu_shift_op,marvell_f_alu_early_retire_shift"
+	       "arm_no_early_alu_shift_value_dep")
+
+;; (c) I1 has a constant or register shift and I2 has a register shift.
+;; Rd must not provide the amount by which to shift.
+(define_bypass 1 "marvell_f_alu_shift_op,\
+	          marvell_f_alu_shift_reg_op"
+	       "marvell_f_alu_shift_reg_op,\
+	        marvell_f_alu_early_retire_reg_shift1,\
+	        marvell_f_alu_early_retire_reg_shift2"
+	       "arm_no_early_alu_shift_dep")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Multiplication instructions
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; Multiplication instructions in group "Multiply 2".
+
+(define_insn_reservation "marvell_f_multiply_2" 3
+  (and (eq_attr "tune" "marvell_f")
+       (eq_attr "insn" "mul,muls,smull,umull,smulxy,smulls,umulls"))
+  "m_1,m_2,m_3,m_wb")
+
+;; Multiplication instructions in group "Multiply 3".  There is a
+;; dual-issue constraint with non-multiplication ALU instructions
+;; to be respected here.
+
+(define_insn_reservation "marvell_f_multiply_3" 3
+  (and (eq_attr "tune" "marvell_f")
+       (eq_attr "insn" "mla,mlas,smlal,umlal,smlaxy,smlalxy,smlawx,\
+                        smlawy,smlals,umlals"))
+  "reg_shift_lock+m_1,m_2,m_3,m_wb")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Branch instructions
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; Conditional backward b instructions can have a zero-cycle penalty, and
+;; other conditional b and bl instructions have a one-cycle penalty if
+;; predicted correctly.  Currently we model the zero-cycle case for all
+;; branches.
+
+(define_insn_reservation "marvell_f_branches" 0
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "branch"))
+ "nothing")
+
+;; Call latencies are not predictable; a semi-arbitrary very large
+;; number is used as "positive infinity" for such latencies.
+
+(define_insn_reservation "marvell_f_call" 32 
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "call"))
+ "nothing")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Load/store instructions
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; The models for load/store instructions do not accurately describe
+;; the difference between operations with a base register writeback.
+;; These models assume that all memory references hit in dcache.
+
+;; 1. Load/store for single registers.
+
+;; The worst case for a load is when the load result is needed in E1
+;; (for example for a register shift), giving a latency of four.  Loads
+;; skip E1 and access memory at the E2 stage.
+
+(define_insn_reservation "marvell_f_load1" 4
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "load1,load_byte"))
+ "a1_e2+sram,a1_of,a1_wr,a1_wb")
+
+;; The result for a load may be bypassed (to be available at the same
+;; time as the load arrives in the WR stage, so effectively at the OF
+;; stage) to the Rn operand at E2 with a latency of two.  The result may
+;; be bypassed to a non-Rn operand at E2 with a latency of three.  For
+;; instructions without shifts, detection of an Rn bypass situation is
+;; difficult (because some of the instruction patterns switch their
+;; operands), and so we do not model that here.  For instructions with
+;; shifts, the operand used at E2 will always be Rn, and so we can
+;; model the latency-two bypass for these.
+
+(define_bypass 2 "marvell_f_load1"
+               "marvell_f_alu_shift_op"
+	       "arm_no_early_alu_shift_value_dep")
+
+(define_bypass 2 "marvell_f_load1"
+               "marvell_f_alu_shift_reg_op"
+	       "arm_no_early_alu_shift_dep")
+
+;; Stores write at the WR stage and loads read at the E2 stage, giving
+;; a store latency of three.
+
+(define_insn_reservation "marvell_f_store1" 3
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "store1"))
+ "a1_e2,a1_of,a1_wr+sram,a1_wb")
+
+;; 2. Load/store for two consecutive registers.  These may be dealt
+;; with in the same number of cycles as single loads and stores.
+
+(define_insn_reservation "marvell_f_load2" 4
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "load2"))
+ "a1_e2+sram,a1_of,a1_wr,a1_wb")
+
+(define_insn_reservation "marvell_f_store2" 3
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "store2"))
+ "a1_e2,a1_of,a1_wr+sram,a1_wb")
+
+;; The first word of a doubleword load is eligible for the latency-two
+;; bypass described above for single loads, but this is not modelled here.
+;; We do however assume that either word may also be bypassed with
+;; latency three for ALU operations with shifts (where the shift value and
+;; amount do not depend on the loaded value) and latency four for ALU
+;; operations without shifts.  The latency four case is of course the default.
+
+(define_bypass 3 "marvell_f_load2"
+               "marvell_f_alu_shift_op"
+	       "arm_no_early_alu_shift_value_dep")
+
+(define_bypass 3 "marvell_f_load2"
+               "marvell_f_alu_shift_reg_op"
+	       "arm_no_early_alu_shift_dep")
+
+;; 3. Load/store for more than two registers.
+
+;; These instructions stall for an extra cycle in the decode stage;
+;; individual load/store instructions for each register are then issued.
+;; The load/store multiple instruction itself is removed from the decode
+;; stage at the same time as the final load/store instruction is issued.
+;; To complicate matters, pairs of loads/stores referencing two
+;; consecutive registers will be issued together as doubleword operations.
+;; We model a 3-word load as an LDR plus an LDRD, and a 4-word load
+;; as two LDRDs; thus, these are allocated the same latencies (the
+;; latency for two consecutive loads plus one for the setup stall).
+;; The extra stall is modelled by reserving E1.
+
+(define_insn_reservation "marvell_f_load3_4" 6
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "load3,load4"))
+ "a1_e1,a1_e1+a1_e2+sram,a1_e2+sram+a1_of,a1_of+a1_wr,a1_wr+a1_wb,a1_wb")
+
+;; Bypasses are possible for ldm as for single loads, but we do not
+;; model them here since the order of the constituent loads is
+;; difficult to predict.
+
+(define_insn_reservation "marvell_f_store3_4" 5
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "store3,store4"))
+ "a1_e1,a1_e1+a1_e2,a1_e2+a1_of,a1_of+a1_wr+sram,a1_wr+sram+a1_wb,a1_wb")
+
diff -Nur a/gcc/config/arm/marvell-f-vfp.md b/gcc/config/arm/marvell-f-vfp.md
--- a/gcc/config/arm/marvell-f-vfp.md	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/marvell-f-vfp.md	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,153 @@
+;; Marvell 2850 VFP pipeline description
+;; Copyright (C) 2007 Free Software Foundation, Inc.
+;; Written by CodeSourcery, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+;; Boston, MA 02110-1301, USA.
+
+;; This automaton provides a pipeline description for the Marvell
+;; 2850 core.
+;;
+;; The model given here assumes that the condition for all conditional
+;; instructions is "true", i.e., that all of the instructions are
+;; actually executed.
+
+(define_automaton "marvell_f_vfp")
+
+;; This is a single-issue VFPv2 implementation with the following execution
+;; units:
+;;
+;; 1. Addition/subtraction unit; takes three cycles, pipelined.
+;; 2. Multiplication unit; takes four cycles, pipelined.
+;; 3. Add buffer, used for multiply-accumulate (see below).
+;; 4. Divide/square root unit, not pipelined.
+;;    For single-precision: takes sixteen cycles, can accept another insn
+;;			    after fifteen cycles.
+;;    For double-precision: takes thirty-one cycles, can accept another insn
+;;			    after thirty cycles.
+;; 5. Single-cycle unit, pipelined.
+;;    This does absolute value/copy/negate/compare in one cycle and
+;;    conversion in two cycles.
+;;
+;; When all three operands of a multiply-accumulate instruction are ready,
+;; one is issued to the add buffer (which can hold six operands in a FIFO)
+;; and the two to be multiplied are issued to the multiply unit.  After
+;; four cycles in the multiply unit, one cycle is taken to issue the
+;; operand from the add buffer plus the multiplication result to the
+;; addition/subtraction unit.  That issue takes priority over any add/sub
+;; instruction waiting at the normal issue stage, but may be performed in
+;; parallel with the issue of a non-add/sub instruction.  The total time
+;; for a multiply-accumulate instruction to pass through the execution
+;; units is hence eight cycles.
+;;
+;; We do not need to explicitly model the add buffer because it can
+;; always issue the instruction at the head of its FIFO (due to the above
+;; priority rule) and there are more spaces in the add buffer (six) than
+;; there are stages (four) in the multiplication unit.
+;;
+;; Two instructions may be retired at once from the head of an 8-entry
+;; reorder buffer.  Data from these first two instructions only may be
+;; forwarded to the inputs of the issue unit.  We assume that the
+;; pressure on the reorder buffer will be sufficiently low that every
+;; instruction entering it will be eligible for data forwarding.  Since
+;; data is forwarded to the issue unit and not the execution units (so
+;; for example single-cycle instructions cannot be issued back-to-back),
+;; the latencies given below are the cycle counts above plus one.
+
+(define_cpu_unit "mf_vfp_issue" "marvell_f_vfp")
+(define_cpu_unit "mf_vfp_add" "marvell_f_vfp")
+(define_cpu_unit "mf_vfp_mul" "marvell_f_vfp")
+(define_cpu_unit "mf_vfp_div" "marvell_f_vfp")
+(define_cpu_unit "mf_vfp_single_cycle" "marvell_f_vfp")
+
+;; An attribute to indicate whether our reservations are applicable.
+
+(define_attr "marvell_f_vfp" "yes,no"
+  (const (if_then_else (and (eq_attr "tune" "marvell_f")
+                            (eq_attr "fpu" "vfp"))
+                       (const_string "yes") (const_string "no"))))
+
+;; Reservations of functional units.  The nothing*2 reservations at the
+;; start of many of the reservation strings correspond to the decode
+;; stages.  We need to have these reservations so that we can correctly
+;; reserve parts of the core's A1 pipeline for loads and stores.  For
+;; that case (since loads skip E1) the pipelines line up thus:
+;;	A1 pipe:	Issue	E2	OF	WR	WB	 ...
+;;	VFP pipe:	Fetch	Decode1	Decode2	Issue	Execute1 ...
+;; For a load, we need to make a reservation of E2, and thus we must
+;; use Decode1 as the starting point for all VFP reservations here.
+;;
+;; For reservations of pipelined VFP execution units we only reserve
+;; the execution unit for the first execution cycle, omitting any trailing
+;; "nothing" reservations.
+
+(define_insn_reservation "marvell_f_vfp_add" 4
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "farith"))
+  "nothing*2,mf_vfp_issue,mf_vfp_add")
+
+(define_insn_reservation "marvell_f_vfp_mul" 5
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "fmuls,fmuld"))
+  "nothing*2,mf_vfp_issue,mf_vfp_mul")
+
+(define_insn_reservation "marvell_f_vfp_divs" 17
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "fdivs"))
+  "nothing*2,mf_vfp_issue,mf_vfp_div*15")
+
+(define_insn_reservation "marvell_f_vfp_divd" 32
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "fdivd"))
+  "nothing*2,mf_vfp_issue,mf_vfp_div*30")
+
+;; The DFA lookahead is small enough that the "add" reservation here
+;; will always take priority over any addition/subtraction instruction
+;; issued five cycles after the multiply-accumulate instruction, as
+;; required.
+(define_insn_reservation "marvell_f_vfp_mac" 9
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "fmacs,fmacd"))
+  "nothing*2,mf_vfp_issue,mf_vfp_mul,nothing*4,mf_vfp_add")
+
+(define_insn_reservation "marvell_f_vfp_single" 2
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "ffarith"))
+  "nothing*2,mf_vfp_issue,mf_vfp_single_cycle")
+
+(define_insn_reservation "marvell_f_vfp_convert" 3
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "f_cvt"))
+  "nothing*2,mf_vfp_issue,mf_vfp_single_cycle")
+
+(define_insn_reservation "marvell_f_vfp_load" 2
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "f_loads,f_loadd"))
+  "a1_e2+sram,a1_of,a1_wr+mf_vfp_issue,a1_wb+mf_vfp_single_cycle")
+
+(define_insn_reservation "marvell_f_vfp_from_core" 2
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "r_2_f"))
+  "a1_e2,a1_of,a1_wr+mf_vfp_issue,a1_wb+mf_vfp_single_cycle")
+
+;; The interaction between the core and VFP pipelines during VFP
+;; store operations and core <-> VFP moves is not clear, so we guess.
+(define_insn_reservation "marvell_f_vfp_store" 3
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "f_stores,f_stored"))
+  "a1_e2,a1_of,mf_vfp_issue,a1_wr+sram+mf_vfp_single_cycle")
+
+(define_insn_reservation "marvell_f_vfp_to_core" 4
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "f_2_r"))
+  "a1_e2,a1_of,a1_wr+mf_vfp_issue,a1_wb+mf_vfp_single_cycle")
+
diff -Nur a/gcc/config/arm/montavista-linux.h b/gcc/config/arm/montavista-linux.h
--- a/gcc/config/arm/montavista-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/montavista-linux.h	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,33 @@
+/* MontaVista GNU/Linux Configuration.
+   Copyright (C) 2009
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Add -tarmv6 and -tthumb2 options for convenience in generating multilibs.
+*/
+#undef CC1_SPEC
+#define CC1_SPEC "							\
+ %{tarmv6:      -march=armv6 -mfloat-abi=softfp ;			\
+   tthumb2:     -mthumb -march=armv7-a -mfloat-abi=softfp ;             \
+   :            -march=armv5t}"
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC					\
+  "%{tarmv6:/armv6 ;			                        \
+     tthumb2:/thumb2}"
diff -Nur a/gcc/config/arm/neon-gen.ml b/gcc/config/arm/neon-gen.ml
--- a/gcc/config/arm/neon-gen.ml	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/arm/neon-gen.ml	2010-01-25 09:50:28.995687913 +0100
@@ -122,6 +122,7 @@
   | T_uint16 | T_int16 -> T_intHI
   | T_uint32 | T_int32 -> T_intSI
   | T_uint64 | T_int64 -> T_intDI
+  | T_float32 -> T_floatSF
   | T_poly8 -> T_intQI
   | T_poly16 -> T_intHI
   | T_arrayof (n, elt) -> T_arrayof (n, signed_ctype elt)
@@ -320,7 +321,7 @@
     typeinfo;
   Format.print_newline ();
   (* Extra types not in <stdint.h>.  *)
-  Format.printf "typedef __builtin_neon_sf float32_t;\n";
+  Format.printf "typedef float float32_t;\n";
   Format.printf "typedef __builtin_neon_poly8 poly8_t;\n";
   Format.printf "typedef __builtin_neon_poly16 poly16_t;\n"
 
@@ -399,7 +400,11 @@
 "extern \"C\" {";
 "#endif";
 "";
+"#if defined (__vxworks) && defined (_WRS_KERNEL)";
+"#include <vxWorks.h>";
+"#else";
 "#include <stdint.h>";
+"#endif";
 ""];
   deftypes ();
   arrtypes ();
diff -Nur a/gcc/config/arm/neon.md b/gcc/config/arm/neon.md
--- a/gcc/config/arm/neon.md	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/arm/neon.md	2010-01-25 09:50:28.995687913 +0100
@@ -159,7 +159,8 @@
    (UNSPEC_VUZP1		201)
    (UNSPEC_VUZP2		202)
    (UNSPEC_VZIP1		203)
-   (UNSPEC_VZIP2		204)])
+   (UNSPEC_VZIP2		204)
+   (UNSPEC_MISALIGNED_ACCESS	205)])
 
 ;; Double-width vector modes.
 (define_mode_iterator VD [V8QI V4HI V2SI V2SF])
@@ -459,7 +460,9 @@
 	  "=w,Uv,w, w,  ?r,?w,?r,?r, ?Us")
 	(match_operand:VD 1 "general_operand"
 	  " w,w, Dn,Uvi, w, r, r, Usi,r"))]
-  "TARGET_NEON"
+  "TARGET_NEON
+   && (register_operand (operands[0], <MODE>mode)
+       || register_operand (operands[1], <MODE>mode))"
 {
   if (which_alternative == 2)
     {
@@ -481,7 +484,7 @@
 
   /* FIXME: If the memory layout is changed in big-endian mode, output_move_vfp
      below must be changed to output_move_neon (which will use the
-     element/structure loads/stores), and the constraint changed to 'Un' instead
+     element/structure loads/stores), and the constraint changed to 'Um' instead
      of 'Uv'.  */
 
   switch (which_alternative)
@@ -506,7 +509,9 @@
   	  "=w,Un,w, w,  ?r,?w,?r,?r,  ?Us")
 	(match_operand:VQXMOV 1 "general_operand"
 	  " w,w, Dn,Uni, w, r, r, Usi, r"))]
-  "TARGET_NEON"
+  "TARGET_NEON
+   && (register_operand (operands[0], <MODE>mode)
+       || register_operand (operands[1], <MODE>mode))"
 {
   if (which_alternative == 2)
     {
@@ -549,6 +554,11 @@
 	(match_operand:TI 1 "general_operand" ""))]
   "TARGET_NEON"
 {
+  if (can_create_pseudo_p ())
+    {
+      if (GET_CODE (operands[0]) != REG)
+	operands[1] = force_reg (TImode, operands[1]);
+    }
 })
 
 (define_expand "mov<mode>"
@@ -556,12 +566,19 @@
 	(match_operand:VSTRUCT 1 "general_operand" ""))]
   "TARGET_NEON"
 {
+  if (can_create_pseudo_p ())
+    {
+      if (GET_CODE (operands[0]) != REG)
+	operands[1] = force_reg (<MODE>mode, operands[1]);
+    }
 })
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VSTRUCT 0 "nonimmediate_operand"	"=w,Ut,w")
 	(match_operand:VSTRUCT 1 "general_operand"	" w,w, Ut"))]
-  "TARGET_NEON"
+  "TARGET_NEON
+   && (register_operand (operands[0], <MODE>mode)
+       || register_operand (operands[1], <MODE>mode))"
 {
   switch (which_alternative)
     {
@@ -658,6 +675,49 @@
   neon_disambiguate_copy (operands, dest, src, 4);
 })
 
+(define_expand "movmisalign<mode>"
+  [(set (match_operand:VDQX 0 "nonimmediate_operand"	      "")
+	(unspec:VDQX [(match_operand:VDQX 1 "general_operand" "")]
+		     UNSPEC_MISALIGNED_ACCESS))]
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
+{
+  if (!s_register_operand (operands[0], <MODE>mode)
+      && !s_register_operand (operands[1], <MODE>mode))
+    FAIL;
+})
+
+(define_insn "*movmisalign<mode>_neon_store"
+  [(set (match_operand:VDX 0 "memory_operand"                  "=Um")
+	(unspec:VDX [(match_operand:VDX 1 "s_register_operand" " w")]
+		    UNSPEC_MISALIGNED_ACCESS))]
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
+  "vst1.<V_sz_elem>\t{%P1}, %A0"
+  [(set_attr "neon_type" "neon_vst1_1_2_regs_vst2_2_regs")])
+
+(define_insn "*movmisalign<mode>_neon_load"
+  [(set (match_operand:VDX 0 "s_register_operand"          "=w")
+	(unspec:VDX [(match_operand:VDX 1 "memory_operand" " Um")]
+		    UNSPEC_MISALIGNED_ACCESS))]
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
+  "vld1.<V_sz_elem>\t{%P0}, %A1"
+  [(set_attr "neon_type" "neon_vld1_1_2_regs")])
+
+(define_insn "*movmisalign<mode>_neon_store"
+  [(set (match_operand:VQX 0 "memory_operand"                  "=Um")
+	(unspec:VQX [(match_operand:VQX 1 "s_register_operand" " w")]
+		    UNSPEC_MISALIGNED_ACCESS))]
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
+  "vst1.<V_sz_elem>\t{%q1}, %A0"
+  [(set_attr "neon_type" "neon_vst1_1_2_regs_vst2_2_regs")])
+
+(define_insn "*movmisalign<mode>_neon_load"
+  [(set (match_operand:VQX 0 "s_register_operand"           "=w")
+	(unspec:VQX [(match_operand:VQX 1 "general_operand" " Um")]
+		    UNSPEC_MISALIGNED_ACCESS))]
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
+  "vld1.<V_sz_elem>\t{%q0}, %A1"
+  [(set_attr "neon_type" "neon_vld1_1_2_regs")])
+
 (define_insn "vec_set<mode>_internal"
   [(set (match_operand:VD 0 "s_register_operand" "=w")
         (vec_merge:VD
@@ -862,6 +922,50 @@
                                     (const_string "neon_mul_qqq_8_16_32_ddd_32")))))]
 )
 
+(define_insn "*mul<mode>3add<mode>_neon"
+  [(set (match_operand:VDQ 0 "s_register_operand" "=w")
+        (plus:VDQ (mult:VDQ (match_operand:VDQ 2 "s_register_operand" "w")
+                            (match_operand:VDQ 3 "s_register_operand" "w"))
+		  (match_operand:VDQ 1 "s_register_operand" "0")))]
+  "TARGET_NEON"
+  "vmla.<V_if_elem>\t%<V_reg>0, %<V_reg>2, %<V_reg>3"
+  [(set (attr "neon_type")
+      (if_then_else (ne (symbol_ref "<Is_float_mode>") (const_int 0))
+                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
+                                  (const_string "neon_fp_vmla_ddd")
+                                  (const_string "neon_fp_vmla_qqq"))
+                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
+                                  (if_then_else
+                                    (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
+                                    (const_string "neon_mla_ddd_8_16_qdd_16_8_long_32_16_long")
+                                    (const_string "neon_mla_ddd_32_qqd_16_ddd_32_scalar_qdd_64_32_long_scalar_qdd_64_32_long"))
+                                  (if_then_else (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
+                                    (const_string "neon_mla_qqq_8_16")
+                                    (const_string "neon_mla_qqq_32_qqd_32_scalar")))))]
+)
+
+(define_insn "*mul<mode>3neg<mode>add<mode>_neon"
+  [(set (match_operand:VDQ 0 "s_register_operand" "=w")
+        (minus:VDQ (match_operand:VDQ 1 "s_register_operand" "0")
+                   (mult:VDQ (match_operand:VDQ 2 "s_register_operand" "w")
+                             (match_operand:VDQ 3 "s_register_operand" "w"))))]
+  "TARGET_NEON"
+  "vmls.<V_if_elem>\t%<V_reg>0, %<V_reg>2, %<V_reg>3"
+  [(set (attr "neon_type")
+      (if_then_else (ne (symbol_ref "<Is_float_mode>") (const_int 0))
+                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
+                                  (const_string "neon_fp_vmla_ddd")
+                                  (const_string "neon_fp_vmla_qqq"))
+                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
+                                  (if_then_else
+                                    (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
+                                    (const_string "neon_mla_ddd_8_16_qdd_16_8_long_32_16_long")
+                                    (const_string "neon_mla_ddd_32_qqd_16_ddd_32_scalar_qdd_64_32_long_scalar_qdd_64_32_long"))
+                                  (if_then_else (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
+                                    (const_string "neon_mla_qqq_8_16")
+                                    (const_string "neon_mla_qqq_32_qqd_32_scalar")))))]
+)
+
 (define_insn "ior<mode>3"
   [(set (match_operand:VDQ 0 "s_register_operand" "=w,w")
 	(ior:VDQ (match_operand:VDQ 1 "s_register_operand" "w,0")
@@ -3611,7 +3715,8 @@
 			  UNSPEC_VSHLL_N))]
   "TARGET_NEON"
 {
-  neon_const_bounds (operands[2], 0, neon_element_bits (<MODE>mode));
+  /* The boundaries are: 0 < imm <= size.  */
+  neon_const_bounds (operands[2], 0, neon_element_bits (<MODE>mode) + 1);
   return "vshll.%T3%#<V_sz_elem>\t%q0, %P1, %2";
 }
   [(set_attr "neon_type" "neon_shift_1")]
diff -Nur a/gcc/config/arm/neon.ml b/gcc/config/arm/neon.ml
--- a/gcc/config/arm/neon.ml	2007-08-02 12:49:31.000000000 +0200
+++ b/gcc/config/arm/neon.ml	2010-01-25 09:50:28.995687913 +0100
@@ -50,7 +50,7 @@
              | T_ptrto of vectype | T_const of vectype
              | T_void      | T_intQI
              | T_intHI     | T_intSI
-             | T_intDI
+             | T_intDI     | T_floatSF
 
 (* The meanings of the following are:
      TImode : "Tetra", two registers (four words).
@@ -1693,6 +1693,7 @@
   | T_intHI -> "__builtin_neon_hi"
   | T_intSI -> "__builtin_neon_si"
   | T_intDI -> "__builtin_neon_di"
+  | T_floatSF -> "__builtin_neon_sf"
   | T_arrayof (num, base) ->
       let basename = name (fun x -> x) base in
       affix (Printf.sprintf "%sx%d" basename num)
diff -Nur a/gcc/config/arm/neon-testgen.ml b/gcc/config/arm/neon-testgen.ml
--- a/gcc/config/arm/neon-testgen.ml	2007-08-02 12:49:31.000000000 +0200
+++ b/gcc/config/arm/neon-testgen.ml	2010-01-25 09:50:28.995687913 +0100
@@ -51,8 +51,8 @@
   Printf.fprintf chan "/* This file was autogenerated by neon-testgen.  */\n\n";
   Printf.fprintf chan "/* { dg-do assemble } */\n";
   Printf.fprintf chan "/* { dg-require-effective-target arm_neon_ok } */\n";
-  Printf.fprintf chan
-                 "/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n";
+  Printf.fprintf chan "/* { dg-options \"-save-temps -O0\" } */\n";
+  Printf.fprintf chan "/* { dg-add-options arm_neon } */\n";
   Printf.fprintf chan "\n#include \"arm_neon.h\"\n\n";
   Printf.fprintf chan "void test_%s (void)\n{\n" test_name
 
diff -Nur a/gcc/config/arm/netbsd-elf.h b/gcc/config/arm/netbsd-elf.h
--- a/gcc/config/arm/netbsd-elf.h	2007-08-02 12:49:31.000000000 +0200
+++ b/gcc/config/arm/netbsd-elf.h	2010-01-25 09:50:28.995687913 +0100
@@ -153,5 +153,5 @@
 while (0)
 
 #undef FPUTYPE_DEFAULT
-#define FPUTYPE_DEFAULT FPUTYPE_VFP
+#define FPUTYPE_DEFAULT "vfp"
 
diff -Nur a/gcc/config/arm/nocrt0.h b/gcc/config/arm/nocrt0.h
--- a/gcc/config/arm/nocrt0.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/nocrt0.h	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,25 @@
+/* Definitions for generic libgloss based cofigs where crt0 is supplied by
+   the linker script.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC	" crti%O%s crtbegin%O%s"
+
+#undef LIB_SPEC
+#define LIB_SPEC "-lc"
diff -Nur a/gcc/config/arm/predicates.md b/gcc/config/arm/predicates.md
--- a/gcc/config/arm/predicates.md	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/arm/predicates.md	2010-01-25 09:50:28.995687913 +0100
@@ -73,6 +73,10 @@
 	      || REGNO_REG_CLASS (REGNO (op)) == FPA_REGS));
 })
 
+(define_special_predicate "subreg_lowpart_operator"
+  (and (match_code "subreg")
+       (match_test "subreg_lowpart_p (op)")))
+
 ;; Reg, subreg(reg) or const_int.
 (define_predicate "reg_or_int_operand"
   (ior (match_code "const_int")
@@ -168,6 +172,11 @@
   (and (match_code "plus,minus,ior,xor,and")
        (match_test "mode == GET_MODE (op)")))
 
+;; True for plus/minus operators
+(define_special_predicate "plusminus_operator"
+  (and (match_code "plus,minus")
+       (match_test "mode == GET_MODE (op)")))
+
 ;; True for logical binary operators.
 (define_special_predicate "logical_binary_operator"
   (and (match_code "ior,xor,and")
@@ -295,6 +304,9 @@
   HOST_WIDE_INT i = 1, base = 0;
   rtx elt;
 
+  if (low_irq_latency)
+    return false;
+
   if (count <= 1
       || GET_CODE (XVECEXP (op, 0, 0)) != SET)
     return false;
@@ -352,6 +364,9 @@
   HOST_WIDE_INT i = 1, base = 0;
   rtx elt;
 
+  if (low_irq_latency)
+    return false;
+
   if (count <= 1
       || GET_CODE (XVECEXP (op, 0, 0)) != SET)
     return false;
diff -Nur a/gcc/config/arm/sfp-machine.h b/gcc/config/arm/sfp-machine.h
--- a/gcc/config/arm/sfp-machine.h	2008-03-03 15:30:48.000000000 +0100
+++ b/gcc/config/arm/sfp-machine.h	2010-01-25 09:50:28.995687913 +0100
@@ -14,9 +14,11 @@
 #define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
 #define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
 
+#define _FP_NANFRAC_H		((_FP_QNANBIT_H << 1) - 1)
 #define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
 #define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
 #define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_H		0
 #define _FP_NANSIGN_S		0
 #define _FP_NANSIGN_D		0
 #define _FP_NANSIGN_Q		0
@@ -92,5 +94,7 @@
 #define __fixdfdi	__aeabi_d2lz
 #define __fixunsdfdi	__aeabi_d2ulz
 #define __floatdidf	__aeabi_l2d
+#define __extendhfsf2	__gnu_h2f_ieee
+#define __truncsfhf2	__gnu_f2h_ieee
 
 #endif /* __ARM_EABI__ */
diff -Nur a/gcc/config/arm/t-arm b/gcc/config/arm/t-arm
--- a/gcc/config/arm/t-arm	2008-03-27 20:20:18.000000000 +0100
+++ b/gcc/config/arm/t-arm	2010-01-25 09:50:28.995687913 +0100
@@ -13,7 +13,9 @@
 		$(srcdir)/config/arm/iwmmxt.md \
 		$(srcdir)/config/arm/vfp.md \
 		$(srcdir)/config/arm/neon.md \
-		$(srcdir)/config/arm/thumb2.md
+		$(srcdir)/config/arm/thumb2.md \
+		$(srcdir)/config/arm/marvell-f.md \
+		$(srcdir)/config/arm/hwdiv.md
 
 s-config s-conditions s-flags s-codes s-constants s-emit s-recog s-preds \
 	s-opinit s-extract s-peep s-attr s-attrtab s-output: $(MD_INCLUDES)
diff -Nur a/gcc/config/arm/t-arm-elf b/gcc/config/arm/t-arm-elf
--- a/gcc/config/arm/t-arm-elf	2008-06-12 19:29:47.000000000 +0200
+++ b/gcc/config/arm/t-arm-elf	2010-01-25 09:50:28.995687913 +0100
@@ -24,10 +24,18 @@
 #MULTILIB_MATCHES      += march?armv7=march?armv7-a
 #MULTILIB_MATCHES      += march?armv7=march?armv7-r
 #MULTILIB_MATCHES      += march?armv7=march?armv7-m
+#MULTILIB_MATCHES      += march?armv7=march?armv7e-m
 #MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a8
 #MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4
 #MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3
 
+# Not quite true.  We can support hard-vfp calling in Thumb2, but how do we
+# express that here?  Also, we really need architecture v5e or later
+# (mcrr etc).
+MULTILIB_OPTIONS       += mfloat-abi=hard
+MULTILIB_DIRNAMES      += fpu
+MULTILIB_EXCEPTIONS    += *mthumb/*mfloat-abi=hard*
+
 # MULTILIB_OPTIONS    += mcpu=ep9312
 # MULTILIB_DIRNAMES   += ep9312
 # MULTILIB_EXCEPTIONS += *mthumb/*mcpu=ep9312*
diff -Nur a/gcc/config/arm/t-asa b/gcc/config/arm/t-asa
--- a/gcc/config/arm/t-asa	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/t-asa	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,45 @@
+# Overrides for ASA
+
+# Here is the expected output from xgcc -print-multi-lib.
+#
+# .;@fno-omit-frame-pointer@mapcs-frame
+# armv4t;@march=armv4t@fno-omit-frame-pointer@mapcs-frame
+# armv6;@march=armv6@fno-omit-frame-pointer@mapcs-frame
+# armv7a;@march=armv7-a@fno-omit-frame-pointer@mapcs-frame
+# armv6f;@march=armv6@mfloat-abi=softfp@fno-omit-frame-pointer@mapcs-frame
+# armv7af;@march=armv7-a@mfpu=neon@mfloat-abi=softfp@fno-omit-frame-pointer@mapcs-frame
+# thumb2;@mthumb@march=armv7-a@fno-omit-frame-pointer@mapcs-frame
+# thumb2f;@mthumb@march=armv7-a@mfpu=neon@mfloat-abi=softfp@fno-omit-frame-pointer@mapcs-frame
+
+MULTILIB_OPTIONS = mthumb march=armv4t/march=armv6/march=armv7-a mfpu=neon mfloat-abi=softfp
+MULTILIB_DIRNAMES = thumb v4t v6 v7a neon softfp
+MULTILIB_MATCHES =
+
+MULTILIB_EXTRA_OPTS = fno-omit-frame-pointer mapcs-frame
+
+MULTILIB_EXCEPTIONS  = mthumb
+MULTILIB_EXCEPTIONS += mfpu=neon*
+MULTILIB_EXCEPTIONS += mfloat-abi=softfp
+MULTILIB_EXCEPTIONS += *march=armv4t*/*mfpu=neon*
+MULTILIB_EXCEPTIONS += *march=armv4t*/*mfloat-abi=softfp*
+MULTILIB_EXCEPTIONS += march=armv6/*mfpu=neon*
+MULTILIB_EXCEPTIONS += mthumb/mfpu=neon
+MULTILIB_EXCEPTIONS += mthumb/mfloat-abi=softfp
+MULTILIB_EXCEPTIONS += mthumb/mfpu=neon*
+MULTILIB_EXCEPTIONS += mthumb/march=armv6/mfpu=neon*
+
+MULTILIB_OSDIRNAMES  = march.armv4t=!armv4t
+MULTILIB_OSDIRNAMES += march.armv6=!armv6
+MULTILIB_OSDIRNAMES += march.armv6/mfloat-abi.softfp=!armv6f
+MULTILIB_OSDIRNAMES += march.armv7-a=!armv7a
+MULTILIB_OSDIRNAMES += march.armv7-a/mfpu.neon/mfloat-abi.softfp=!armv7af
+MULTILIB_OSDIRNAMES += mthumb/march.armv7-a=!thumb2
+MULTILIB_OSDIRNAMES += mthumb/march.armv7-a/mfpu.neon/mfloat-abi.softfp=!thumb2f
+
+MULTILIB_ALIASES  = march?armv4t=mthumb/march?armv4t
+MULTILIB_ALIASES += march?armv6=mthumb/march?armv6
+MULTILIB_ALIASES += march?armv6/mfloat-abi?softfp=mthumb/march?armv6/mfloat-abi?softfp
+MULTILIB_ALIASES += march?armv7-a/mfpu?neon/mfloat-abi?softfp=march?armv7-a/mfpu?neon
+MULTILIB_ALIASES += march?armv7-a/mfpu?neon/mfloat-abi?softfp=march?armv7-a/mfloat-abi?softfp
+MULTILIB_ALIASES += mthumb/march?armv7-a/mfpu?neon/mfloat-abi?softfp=mthumb/march?armv7-a/mfpu?neon
+MULTILIB_ALIASES += mthumb/march?armv7-a/mfpu?neon/mfloat-abi?softfp=mthumb/march?armv7-a/mfloat-abi?softfp
diff -Nur a/gcc/config/arm/t-bpabi b/gcc/config/arm/t-bpabi
--- a/gcc/config/arm/t-bpabi	2005-11-04 15:51:20.000000000 +0100
+++ b/gcc/config/arm/t-bpabi	2010-01-25 09:50:28.995687913 +0100
@@ -1,10 +1,13 @@
 # Add the bpabi.S functions.
-LIB1ASMFUNCS += _aeabi_lcmp _aeabi_ulcmp _aeabi_ldivmod _aeabi_uldivmod
+LIB1ASMFUNCS += _aeabi_lcmp _aeabi_ulcmp _aeabi_ldivmod _aeabi_uldivmod \
+		_aeabi_idiv0 _aeabi_ldiv0
 
 # Add the BPABI C functions.
 LIB2FUNCS_EXTRA = $(srcdir)/config/arm/bpabi.c \
 		  $(srcdir)/config/arm/unaligned-funcs.c
 
+LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/arm/fp16.c
+
 UNWIND_H = $(srcdir)/config/arm/unwind-arm.h
 LIB2ADDEH = $(srcdir)/config/arm/unwind-arm.c \
   $(srcdir)/config/arm/libunwind.S \
diff -Nur a/gcc/config/arm/t-cs-eabi b/gcc/config/arm/t-cs-eabi
--- a/gcc/config/arm/t-cs-eabi	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/t-cs-eabi	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,198 @@
+# Multilibs for SourceryG++ arm-none-eabi
+
+MULTILIB_OPTIONS     = mthumb
+MULTILIB_DIRNAMES    = t
+MULTILIB_EXCEPTIONS  = 
+MULTILIB_MATCHES     =
+MULTILIB_ALIASES     =
+
+MULTILIB_OPTIONS      += march=armv7/march=armv7-a/march=armv5te/march=armv6-m
+MULTILIB_DIRNAMES     += v7 v7a v5te v6m
+MULTILIB_MATCHES      += march?armv7-a=march?armv7a
+MULTILIB_MATCHES      += march?armv7=march?armv7r
+MULTILIB_MATCHES      += march?armv7=march?armv7m
+MULTILIB_MATCHES      += march?armv7=march?armv7-r
+MULTILIB_MATCHES      += march?armv7=march?armv7-m
+MULTILIB_MATCHES      += march?armv7=march?armv7e-m
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a9
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a8
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a5
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4f
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m1
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m0
+MULTILIB_MATCHES      += march?armv5te=march?armv6
+MULTILIB_MATCHES      += march?armv5te=march?armv6j
+MULTILIB_MATCHES      += march?armv5te=march?armv6k
+MULTILIB_MATCHES      += march?armv5te=march?armv6z
+MULTILIB_MATCHES      += march?armv5te=march?armv6zk
+MULTILIB_MATCHES      += march?armv5te=march?armv6t2
+MULTILIB_MATCHES      += march?armv5te=march?iwmmxt
+MULTILIB_MATCHES      += march?armv5te=march?iwmmxt2
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm9e
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm946e-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm966e-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm968e-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm10e
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1020e
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1022e
+MULTILIB_MATCHES      += march?armv5te=mcpu?xscale
+MULTILIB_MATCHES      += march?armv5te=mcpu?iwmmxt
+MULTILIB_MATCHES      += march?armv5te=mcpu?iwmmxt2
+MULTILIB_MATCHES      += march?armv5te=mcpu?marvell-f
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm926ej-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1026ej-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1136j-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1136jf-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1176jz-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1176jzf-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?mpcorenovfp
+MULTILIB_MATCHES      += march?armv5te=mcpu?mpcore
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1156t2-s
+
+MULTILIB_OPTIONS      += mfloat-abi=softfp/mfloat-abi=hard
+MULTILIB_DIRNAMES     += softfp hard
+MULTILIB_MATCHES      += mfloat-abi?hard=mhard-float
+
+MULTILIB_OPTIONS      += mfpu=neon
+MULTILIB_DIRNAMES     += neon
+MULTILIB_EXCEPTIONS   += mfpu=neon
+MULTILIB_MATCHES      += mfpu?neon=mfpu?neon-fp16
+MULTILIB_MATCHES      += mfpu?neon=mfpu?neon-vfpv4
+
+MULTILIB_ALIASES      += mthumb=mthumb/mfpu?neon
+MULTILIB_ALIASES      += mthumb=mthumb/march?armv5te/mfpu?neon
+MULTILIB_ALIASES      += mbig-endian=mthumb/mfpu?neon/mbig-endian
+#MULTILIB_ALIASES      += mfloat-abi?softfp=mthumb/mfloat-abi?softfp/mfpu?neon
+#MULTILIB_ALIASES      += mfloat-abi?softfp=mfloat-abi?softfp/mfpu?neon
+#MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=mfloat-abi?softfp/mfpu?neon/mbig-endian
+#MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=mthumb/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7-a/mfpu?neon
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7-a/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += march?armv7-a/mfloat-abi?softfp/mfpu?neon=mthumb/march?armv7-a/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv7-a/mfloat-abi?hard/mfpu?neon=mthumb/march?armv7-a/mfloat-abi?hard/mfpu?neon
+
+MULTILIB_OPTIONS      += mbig-endian
+MULTILIB_DIRNAMES     += be
+MULTILIB_ALIASES      += mbig-endian=mfpu?neon/mbig-endian
+
+# ARMv6-M  does not have ARM mode.
+MULTILIB_EXCEPTIONS   += march=armv6-m
+
+# Some ARMv7 variants have ARM mode.  Use the ARM libraries.
+MULTILIB_EXCEPTIONS   += march=armv7 march=armv7/*
+MULTILIB_ALIASES      += mbig-endian=march?armv7/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=march?armv7/mfloat-abi?softfp
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=march?armv7/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=march?armv7/mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=march?armv7/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=march?armv7/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7/mfpu?neon
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7/mfloat-abi?softfp/mfpu?neon/mbig-endian
+
+# ARMv7-A is specially useful used with VFPv3 (enabled by NEON). Rest of the cases behaves as ARMv7.
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7-a
+MULTILIB_ALIASES      += mbig-endian=march?armv7-a/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=march?armv7-a/mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=march?armv7-a/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7-a/mfloat-abi?softfp
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7-a/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7-a/mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7/mfloat-abi?softfp             
+MULTILIB_ALIASES      += march?armv5te=march?armv7-a
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=march?armv7-a/mfloat-abi?softfp
+MULTILIB_ALIASES      += march?armv5te=march?armv7-a/mfpu?neon
+MULTILIB_ALIASES      += mbig-endian=march?armv7-a/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7-a/mfloat-abi?softfp/mfpu?neon/mbig-endian
+
+# ARMv5T thumb uses the ARMv5T ARM libraries (with or without VFP).
+MULTILIB_ALIASES      += mthumb=mthumb/march?armv5te
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=mthumb/march?armv5te/mfloat-abi?softfp
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=march?armv5te/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=mthumb/march?armv5te/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv5te=march?armv5te/mfpu?neon
+MULTILIB_ALIASES      += mbig-endian=march?armv5te/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=march?armv5te/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mthumb/march?armv5te/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=mthumb/march?armv5te/mfloat-abi?softfp/mfpu?neon/mbig-endian
+
+# ARMv6-M and VFP are incompatible.
+# FIXME:  The compiler should probably error.
+MULTILIB_EXCEPTIONS   += *march=armv6-m/mfloat-abi=softfp
+MULTILIB_ALIASES      += mthumb/march?armv6-m=mthumb/march?armv6-m/mfpu?neon
+MULTILIB_EXCEPTIONS   += march=armv6-m*mfpu=neon
+MULTILIB_EXCEPTIONS   += mthumb/march=armv6-m/mfloat-abi=softfp/mfpu=neon
+
+# ARMv4t VFP isn't really supported, so use the soft-float libraries.
+MULTILIB_EXCEPTIONS   += mfloat-abi?softfp
+MULTILIB_EXCEPTIONS   += mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += mthumb=mthumb/mfloat-abi?softfp
+MULTILIB_ALIASES      += mthumb=mthumb/mfloat-abi?softfp/mfpu?neon
+
+MULTILIB_ALIASES      += mbig-endian=mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mthumb/mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mthumb/mfloat-abi?softfp/mfpu?neon/mbig-endian
+
+# We don't have a big-endian ARMv6-M compatible multilibs.
+MULTILIB_EXCEPTIONS   += *march=armv6-m*mbig-endian
+
+# Use the generic libraries for big-endian ARMv5T
+MULTILIB_ALIASES      += mbig-endian=march?armv5te/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mthumb/march?armv5te/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=mthumb/march?armv5te/mfloat-abi?softfp/mbig-endian
+
+# Use ARM libraries for big-endian Thumb.
+MULTILIB_ALIASES      += mbig-endian=mthumb/mbig-endian
+
+# Don't bother with big-endian Thumb-2 VFP.  Use the soft-float libraries
+# for now.
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7/mfloat-abi?softfp/mbig-endian
+
+# The only -mfloat-abi=hard libraries provided are for little-endian
+# v7-A NEON.
+MULTILIB_EXCEPTIONS   += mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *march=armv5te*mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *march=armv7/*mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *march=armv6-m*mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += mthumb/mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *mfloat-abi=hard*mbig-endian
+MULTILIB_EXCEPTIONS   += *mfloat-abi=hard
+
+# FIXME: We need a sane way of doing this.
+# This isn't really a multilib, it's a hack to add an extra option
+# to the v7-m multilib.
+MULTILIB_OPTIONS      += mfix-cortex-m3-ldrd
+MULTILIB_DIRNAMES     += broken_ldrd
+
+MULTILIB_EXCEPTIONS   += mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += mthumb/mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *march=armv6-m*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *march=armv7-a*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *mcpu=*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *mbig-endian*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *mfloat-abi=softfp*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *march=armv5te*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *mfpu=neon*mfix-cortex-m3-ldrd
+
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7-a/mfix-cortex-m3-ldrd
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7/mfpu?neon/mfix-cortex-m3-ldrd
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7-a/mfpu?neon/mfix-cortex-m3-ldrd
+
+# As of at least 4.2, gcc passes the wrong -L options if some multilibs are
+# omitted from MULTILIB_OSDIRNAMES
+MULTILIB_OSDIRNAMES    = mthumb=!thumb
+MULTILIB_OSDIRNAMES   += mbig-endian=!be
+MULTILIB_OSDIRNAMES   += march.armv5te=!armv5te
+MULTILIB_OSDIRNAMES   += march.armv5te/mfloat-abi.softfp=!vfp
+MULTILIB_OSDIRNAMES   += march.armv5te/mfloat-abi.softfp/mbig-endian=!vfp-be
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7/mfix-cortex-m3-ldrd=!thumb2
+MULTILIB_OSDIRNAMES   += march.armv7-a/mfloat-abi.softfp/mfpu.neon=!armv7-a-neon
+MULTILIB_OSDIRNAMES   += march.armv7-a/mfloat-abi.hard/mfpu.neon=!armv7-a-hard
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7/mbig-endian=!thumb2-be
+MULTILIB_OSDIRNAMES   += mthumb/march.armv6-m=!armv6-m
diff -Nur a/gcc/config/arm/t-cs-eabi-lite b/gcc/config/arm/t-cs-eabi-lite
--- a/gcc/config/arm/t-cs-eabi-lite	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/t-cs-eabi-lite	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,47 @@
+# We build 4 multilibs:
+#  ./		  (default)
+#  thumb/	  -mthumb
+#  thumb2/	  -mthumb -march=armv7
+#  armv6-m/	  -mthumb -march=armv6-m
+
+MULTILIB_OPTIONS     = mthumb
+MULTILIB_DIRNAMES    = thumb
+MULTILIB_EXCEPTIONS  =
+MULTILIB_MATCHES     =
+MULTILIB_ALIASES     =
+
+MULTILIB_OPTIONS      += march=armv7/march=armv6-m
+MULTILIB_DIRNAMES     += v7 v6-m
+MULTILIB_EXCEPTIONS   += march=armv7*
+MULTILIB_MATCHES      += march?armv7=march?armv7-a
+MULTILIB_MATCHES      += march?armv7=march?armv7-r
+MULTILIB_MATCHES      += march?armv7=march?armv7-m
+MULTILIB_MATCHES      += march?armv7=march?armv7e-m
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a9
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a8
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a5
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4f
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3
+
+MULTILIB_EXCEPTIONS   += march=armv6-m
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m1
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m0
+
+# FIXME: We need a sane way of doing this.
+# This isn't really a multilib, it's a hack to add an extra option
+# to the v7-m multilib.
+MULTILIB_OPTIONS      += mfix-cortex-m3-ldrd
+MULTILIB_DIRNAMES     += broken_ldrd
+
+MULTILIB_EXCEPTIONS   += mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += mthumb/mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *march=armv6-m*mfix-cortex-m3-ldrd
+
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7
+
+# As of at least 4.2, gcc passes the wrong -L options if some multilibs are
+# omitted from MULTILIB_OSDIRNAMES
+MULTILIB_OSDIRNAMES    = mthumb=!thumb
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7/mfix-cortex-m3-ldrd=!thumb2
+MULTILIB_OSDIRNAMES   += mthumb/march.armv6-m=!armv6-m
diff -Nur a/gcc/config/arm/t-cs-linux b/gcc/config/arm/t-cs-linux
--- a/gcc/config/arm/t-cs-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/t-cs-linux	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,112 @@
+# Multilibs for SourceryG++ arm-none-linux-gnueabi
+
+MULTILIB_OPTIONS     = mthumb
+MULTILIB_DIRNAMES    = t
+MULTILIB_EXCEPTIONS  = 
+MULTILIB_MATCHES     =
+MULTILIB_ALIASES     =
+
+MULTILIB_OPTIONS      += march=armv4t/march=armv7-a
+MULTILIB_DIRNAMES     += v4t v7a
+
+MULTILIB_MATCHES      += march?armv7-a=march?armv7a
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a9
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a8
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a5
+MULTILIB_MATCHES      += march?armv4t=march?ep9312
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm7tdmi
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm7tdmi-s
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm710t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm720t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm740t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm9
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm9tdmi
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm920
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm920t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm922t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm940t
+MULTILIB_MATCHES      += march?armv4t=mcpu?ep9312
+MULTILIB_MATCHES      += march?armv4t=march?armv5
+MULTILIB_MATCHES      += march?armv4t=march?armv5t
+MULTILIB_MATCHES      += march?armv4t=march?arm10tdmi
+MULTILIB_MATCHES      += march?armv4t=march?arm1020t
+
+MULTILIB_OPTIONS      += mfloat-abi=softfp/mfloat-abi=hard
+MULTILIB_DIRNAMES     += softfp hard
+MULTILIB_MATCHES      += mfloat-abi?hard=mhard-float
+
+MULTILIB_OPTIONS      += mfpu=neon
+MULTILIB_DIRNAMES     += neon
+MULTILIB_EXCEPTIONS   += mfpu=neon
+MULTILIB_MATCHES      += mfpu?neon=mfpu?neon-fp16
+MULTILIB_MATCHES      += mfpu?neon=mfpu?neon-vfpv4
+MULTILIB_ALIASES      += mfloat-abi?softfp=mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += mfloat-abi?softfp=mthumb/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv7-a/mfloat-abi?hard/mfpu?neon=mthumb/march?armv7-a/mfloat-abi?hard/mfpu?neon
+
+MULTILIB_OPTIONS      += mbig-endian
+MULTILIB_DIRNAMES     += be
+MULTILIB_ALIASES      += mbig-endian=mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mthumb/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=mthumb/mfloat-abi?softfp/mfpu?neon/mbig-endian
+
+# Do not build Thumb libraries.
+MULTILIB_EXCEPTIONS   += mthumb
+MULTILIB_EXCEPTIONS   += mthumb/mfpu=neon
+
+# Use ARM libraries for ARMv4t Thumb and VFP.
+MULTILIB_ALIASES      += march?armv4t=mthumb/march?armv4t
+MULTILIB_ALIASES      += march?armv4t=march?armv4t/mfloat-abi?softfp
+MULTILIB_ALIASES      += march?armv4t=mthumb/march?armv4t/mfloat-abi?softfp
+MULTILIB_ALIASES      += march?armv4t=march?armv4t/mfpu?neon
+MULTILIB_ALIASES      += march?armv4t=march?armv4t/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv4t=mthumb/march?armv4t/mfpu?neon
+MULTILIB_ALIASES      += march?armv4t=mthumb/march?armv4t/mfloat-abi?softfp/mfpu?neon
+
+# We do not support ARMv4t big-endian.
+MULTILIB_EXCEPTIONS   += *march=armv4t*mbig-endian
+
+# Behave ARMv7-A as ARMv7 for some cases.
+MULTILIB_EXCEPTIONS   += march=armv7-a
+MULTILIB_EXCEPTIONS   += march=armv7-a/mfpu=neon
+MULTILIB_ALIASES      += mfloat-abi?softfp=march?armv7-a/mfloat-abi?softfp
+MULTILIB_ALIASES      += mbig-endian=march?armv7-a/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=march?armv7-a/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=march?armv7-a/mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=march?armv7-a/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7-a=mthumb/march?armv7-a/mfpu?neon
+MULTILIB_ALIASES      += mthumb/march?armv7-a/mbig-endian=mthumb/march?armv7-a/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7-a/mbig-endian=mthumb/march?armv7-a/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7-a=mthumb/march?armv7-a/mfloat-abi?softfp
+
+# Thumb-1 VFP isn't really a meaningful combination.  Use the ARM VFP.
+MULTILIB_ALIASES      += mfloat-abi?softfp=mthumb/mfloat-abi?softfp
+MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=mthumb/mfloat-abi?softfp/mbig-endian
+
+# Use ARM libraries for big-endian Thumb.
+MULTILIB_ALIASES      += mbig-endian=mthumb/mbig-endian
+
+# Don't bother with big-endian Thumb-2 VFP.  Use the soft-float libraries
+# for now.
+MULTILIB_ALIASES      += mthumb/march?armv7-a/mbig-endian=mthumb/march?armv7-a/mfloat-abi?softfp/mbig-endian
+
+# The only -mfloat-abi=hard libraries provided are for little-endian
+# v7-A NEON.
+MULTILIB_EXCEPTIONS   += mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *march=armv4t*mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += mthumb/mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *mfloat-abi=hard*mbig-endian
+MULTILIB_EXCEPTIONS   += *mfloat-abi=hard
+
+# As of at least 4.2, gcc passes the wrong -L options if some multilibs are
+# omitted from MULTILIB_OSDIRNAMES
+MULTILIB_OSDIRNAMES    = march.armv4t=!armv4t
+MULTILIB_OSDIRNAMES   += mbig-endian=!be
+MULTILIB_OSDIRNAMES   += mfloat-abi.softfp=!vfp
+MULTILIB_OSDIRNAMES   += mfloat-abi.softfp/mbig-endian=!vfp-be
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7-a=!thumb2
+MULTILIB_OSDIRNAMES   += march.armv7-a/mfloat-abi.softfp/mfpu.neon=!armv7-a-neon
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7-a/mfloat-abi.softfp/mfpu.neon=!thumb2-neon
+MULTILIB_OSDIRNAMES   += march.armv7-a/mfloat-abi.hard/mfpu.neon=!armv7-a-hard
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7-a/mbig-endian=!thumb2-be
diff -Nur a/gcc/config/arm/t-cs-linux-lite b/gcc/config/arm/t-cs-linux-lite
--- a/gcc/config/arm/t-cs-linux-lite	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/t-cs-linux-lite	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,48 @@
+# We build 3 multilibs:
+#  ./		  (default)
+#  armv4t/	  -march=armv4t [-mthumb]
+#  thumb2/	  -mthumb -march=armv7
+MULTILIB_OPTIONS     = mthumb
+MULTILIB_DIRNAMES    = thumb
+MULTILIB_OPTIONS    += march=armv4t/march=armv7
+MULTILIB_DIRNAMES   += v4t v7
+MULTILIB_EXCEPTIONS += march=armv7
+MULTILIB_EXCEPTIONS += mthumb
+
+MULTILIB_ALIASES     = march?armv4t=mthumb/march?armv4t
+
+# As of at least 4.2, gcc passes the wrong -L options if some multilibs are
+# omitted from MULTILIB_OSDIRNAMES
+MULTILIB_OSDIRNAMES    = march.armv4t=!armv4t
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7=!thumb2
+
+MULTILIB_MATCHES      += march?armv7=march?armv7a
+MULTILIB_MATCHES      += march?armv7=march?armv7r
+MULTILIB_MATCHES      += march?armv7=march?armv7m
+MULTILIB_MATCHES      += march?armv7=march?armv7-a
+MULTILIB_MATCHES      += march?armv7=march?armv7-r
+MULTILIB_MATCHES      += march?armv7=march?armv7-m
+MULTILIB_MATCHES      += march?armv7=march?armv7e-m
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a9
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a8
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a5
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4f
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3
+MULTILIB_MATCHES      += march?armv4t=march?ep9312
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm7tdmi
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm7tdmi-s
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm710t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm720t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm740t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm9
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm9tdmi
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm920
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm920t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm922t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm940t
+MULTILIB_MATCHES      += march?armv4t=mcpu?ep9312
+MULTILIB_MATCHES      += march?armv4t=march?armv5
+MULTILIB_MATCHES      += march?armv4t=march?armv5t
+MULTILIB_MATCHES      += march?armv4t=march?arm10tdmi
+MULTILIB_MATCHES      += march?armv4t=march?arm1020t
diff -Nur a/gcc/config/arm/t-cs-uclinux-eabi b/gcc/config/arm/t-cs-uclinux-eabi
--- a/gcc/config/arm/t-cs-uclinux-eabi	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/t-cs-uclinux-eabi	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,55 @@
+# EABI uClinux multilib selection.  Other setting are inherited from t-arm-elf
+
+# We build 3 multilibs:
+#  .	    (default)
+#  thumb2/  -mthumb -march=armv7 -mfix-cortex-m3-ldrd
+#  armv6-m/ -mthumb -march=armv6-m
+
+MULTILIB_OPTIONS     = mthumb
+MULTILIB_DIRNAMES    = thumb
+MULTILIB_EXCEPTIONS  = 
+MULTILIB_MATCHES     =
+
+MULTILIB_OPTIONS      += march=armv7/march=armv6-m
+MULTILIB_DIRNAMES     += armv7 armv6-m
+
+MULTILIB_EXCEPTIONS   += mthumb
+
+MULTILIB_EXCEPTIONS   += march=armv7
+MULTILIB_MATCHES      += march?armv7=march?armv7a
+MULTILIB_MATCHES      += march?armv7=march?armv7r
+MULTILIB_MATCHES      += march?armv7=march?armv7m
+MULTILIB_MATCHES      += march?armv7=march?armv7-a
+MULTILIB_MATCHES      += march?armv7=march?armv7-r
+MULTILIB_MATCHES      += march?armv7=march?armv7-m
+MULTILIB_MATCHES      += march?armv7=march?armv7e-m
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a9
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a8
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a5
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4f
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3
+
+MULTILIB_EXCEPTIONS   += march=armv6-m
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m1
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m0
+
+MULTILIB_ALIASES       =
+
+# FIXME: We need a sane way of doing this.
+# This isn't really a multilib, it's a hack to add an extra option
+# to the v7-m multilib.
+MULTILIB_OPTIONS      += mfix-cortex-m3-ldrd
+MULTILIB_DIRNAMES     += broken_ldrd
+
+MULTILIB_EXCEPTIONS   += mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += mthumb/mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += march=armv7/mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *march=armv6-m*mfix-cortex-m3-ldrd
+
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7
+
+
+MULTILIB_OSDIRNAMES    = mthumb/march.armv7/mfix-cortex-m3-ldrd=!thumb2
+MULTILIB_OSDIRNAMES   += mthumb/march.armv6-m=!armv6-m
+
diff -Nur a/gcc/config/arm/thumb2.md b/gcc/config/arm/thumb2.md
--- a/gcc/config/arm/thumb2.md	2008-11-21 00:00:00.000000000 +0100
+++ b/gcc/config/arm/thumb2.md	2010-01-25 09:50:28.995687913 +0100
@@ -24,6 +24,8 @@
 ;; changes made in armv5t as "thumb2".  These are considered part
 ;; the 16-bit Thumb-1 instruction set.
 
+(include "hwdiv.md")
+
 (define_insn "*thumb2_incscc"
   [(set (match_operand:SI 0 "s_register_operand" "=r,r")
         (plus:SI (match_operator:SI 2 "arm_comparison_operator"
@@ -172,34 +174,6 @@
    (set_attr "length" "8")]
 )
 
-(define_insn "*thumb2_abssi2"
-  [(set (match_operand:SI         0 "s_register_operand" "=r,&r")
-	(abs:SI (match_operand:SI 1 "s_register_operand" "0,r")))
-   (clobber (reg:CC CC_REGNUM))]
-  "TARGET_THUMB2"
-  "@
-   cmp\\t%0, #0\;it\tlt\;rsblt\\t%0, %0, #0
-   eor%?\\t%0, %1, %1, asr #31\;sub%?\\t%0, %0, %1, asr #31"
-  [(set_attr "conds" "clob,*")
-   (set_attr "shift" "1")
-   ;; predicable can't be set based on the variant, so left as no
-   (set_attr "length" "10,8")]
-)
-
-(define_insn "*thumb2_neg_abssi2"
-  [(set (match_operand:SI 0 "s_register_operand" "=r,&r")
-	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" "0,r"))))
-   (clobber (reg:CC CC_REGNUM))]
-  "TARGET_THUMB2"
-  "@
-   cmp\\t%0, #0\;it\\tgt\;rsbgt\\t%0, %0, #0
-   eor%?\\t%0, %1, %1, asr #31\;rsb%?\\t%0, %0, %1, asr #31"
-  [(set_attr "conds" "clob,*")
-   (set_attr "shift" "1")
-   ;; predicable can't be set based on the variant, so left as no
-   (set_attr "length" "10,8")]
-)
-
 (define_insn "*thumb2_movdi"
   [(set (match_operand:DI 0 "nonimmediate_di_operand" "=r, r, r, r, m")
 	(match_operand:DI 1 "di_operand"              "rDa,Db,Dc,mi,r"))]
@@ -223,9 +197,14 @@
    (set_attr "neg_pool_range" "*,*,*,0,*")]
 )
 
+;; We have two alternatives here for memory loads (and similarly for stores)
+;; to reflect the fact that the permissible constant pool ranges differ
+;; between ldr instructions taking low regs and ldr instructions taking high
+;; regs.  The high register alternatives are not taken into account when
+;; choosing register preferences in order to reflect their expense.
 (define_insn "*thumb2_movsi_insn"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,rk,m")
-	(match_operand:SI 1 "general_operand"	   "rk ,I,K,N,mi,rk"))]
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,l,*hk,m,*m")
+        (match_operand:SI 1 "general_operand"      "rk ,I,K,j,mi,*mi,l,*hk"))]
   "TARGET_THUMB2 && ! TARGET_IWMMXT
    && !(TARGET_HARD_FLOAT && TARGET_VFP)
    && (   register_operand (operands[0], SImode)
@@ -236,11 +215,13 @@
    mvn%?\\t%0, #%B1
    movw%?\\t%0, %1
    ldr%?\\t%0, %1
+   ldr%?\\t%0, %1
+   str%?\\t%1, %0
    str%?\\t%1, %0"
-  [(set_attr "type" "*,*,*,*,load1,store1")
+  [(set_attr "type" "*,*,*,*,load1,load1,store1,store1")
    (set_attr "predicable" "yes")
-   (set_attr "pool_range" "*,*,*,*,4096,*")
-   (set_attr "neg_pool_range" "*,*,*,*,0,*")]
+   (set_attr "pool_range" "*,*,*,*,1020,4096,*,*")
+   (set_attr "neg_pool_range" "*,*,*,*,0,0,*,*")]
 )
 
 ;; ??? We can probably do better with thumb2
@@ -1128,27 +1109,7 @@
       return \"add%!\\t%0, %1, %2\";
   "
   [(set_attr "predicable" "yes")
-   (set_attr "length" "2")]
-)
-
-(define_insn "divsi3"
-  [(set (match_operand:SI	  0 "s_register_operand" "=r")
-	(div:SI (match_operand:SI 1 "s_register_operand"  "r")
-		(match_operand:SI 2 "s_register_operand"  "r")))]
-  "TARGET_THUMB2 && arm_arch_hwdiv"
-  "sdiv%?\t%0, %1, %2"
-  [(set_attr "predicable" "yes")
-   (set_attr "insn" "sdiv")]
-)
-
-(define_insn "udivsi3"
-  [(set (match_operand:SI	   0 "s_register_operand" "=r")
-	(udiv:SI (match_operand:SI 1 "s_register_operand"  "r")
-		 (match_operand:SI 2 "s_register_operand"  "r")))]
-  "TARGET_THUMB2 && arm_arch_hwdiv"
-  "udiv%?\t%0, %1, %2"
-  [(set_attr "predicable" "yes")
-   (set_attr "insn" "udiv")]
+   (set_attr "length" "4")]
 )
 
 (define_insn "*thumb2_subsi_short"
@@ -1162,6 +1123,71 @@
    (set_attr "length" "2")]
 )
 
+;; 16-bit encodings of "muls" and "mul<c>".  We only use these when
+;; optimizing for size since "muls" is slow on all known
+;; implementations and since "mul<c>" will be generated by
+;; "*arm_mulsi3_v6" anyhow.  The assembler will use a 16-bit encoding
+;; for "mul<c>" whenever possible anyhow.
+(define_peephole2
+  [(set (match_operand:SI 0 "low_register_operand" "")
+        (mult:SI (match_operand:SI 1 "low_register_operand" "")
+                 (match_dup 0)))]
+  "TARGET_THUMB2 && optimize_size && peep2_regno_dead_p (0, CC_REGNUM)"
+  [(parallel
+    [(set (match_dup 0)
+           (mult:SI (match_dup 0) (match_dup 1)))
+     (clobber (reg:CC CC_REGNUM))])]
+  ""
+)
+
+(define_peephole2
+  [(set (match_operand:SI 0 "low_register_operand" "")
+        (mult:SI (match_dup 0)
+	         (match_operand:SI 1 "low_register_operand" "")))]
+  "TARGET_THUMB2 && optimize_size && peep2_regno_dead_p (0, CC_REGNUM)"
+  [(parallel
+    [(set (match_dup 0)
+           (mult:SI (match_dup 0) (match_dup 1)))
+     (clobber (reg:CC CC_REGNUM))])]
+  ""
+)
+
+(define_insn "*thumb2_mulsi_short"
+  [(set (match_operand:SI 0 "low_register_operand" "=l")
+        (mult:SI (match_operand:SI 1 "low_register_operand" "%0")
+                 (match_operand:SI 2 "low_register_operand" "l")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_THUMB2 && optimize_size && reload_completed"
+  "mul%!\\t%0, %2, %0"
+  [(set_attr "predicable" "yes")
+   (set_attr "length" "2")
+   (set_attr "insn" "muls")])
+
+(define_insn "*thumb2_mulsi_short_compare0"
+  [(set (reg:CC_NOOV CC_REGNUM)
+        (compare:CC_NOOV
+         (mult:SI (match_operand:SI 1 "register_operand" "%0")
+	          (match_operand:SI 2 "register_operand" "l"))
+         (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=l")
+	(mult:SI (match_dup 1) (match_dup 2)))]
+  "TARGET_THUMB2 && optimize_size"
+  "muls\\t%0, %2, %0"
+  [(set_attr "length" "2")
+   (set_attr "insn" "muls")])
+
+(define_insn "*thumb2_mulsi_short_compare0_scratch"
+  [(set (reg:CC_NOOV CC_REGNUM)
+        (compare:CC_NOOV
+         (mult:SI (match_operand:SI 1 "register_operand" "%0")
+	          (match_operand:SI 2 "register_operand" "l"))
+         (const_int 0)))
+   (clobber (match_scratch:SI 0 "=r"))]
+  "TARGET_THUMB2 && optimize_size"
+  "muls\\t%0, %2, %0"
+  [(set_attr "length" "2")
+   (set_attr "insn" "muls")])
+
 (define_insn "*thumb2_cbz"
   [(set (pc) (if_then_else
 	      (eq (match_operand:SI 0 "s_register_operand" "l,?r")
@@ -1171,7 +1197,7 @@
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_THUMB2"
   "*
-  if (get_attr_length (insn) == 2 && which_alternative == 0)
+  if (get_attr_length (insn) == 2)
     return \"cbz\\t%0, %l1\";
   else
     return \"cmp\\t%0, #0\;beq\\t%l1\";
@@ -1179,7 +1205,8 @@
   [(set (attr "length") 
         (if_then_else
 	    (and (ge (minus (match_dup 1) (pc)) (const_int 2))
-	         (le (minus (match_dup 1) (pc)) (const_int 128)))
+	         (le (minus (match_dup 1) (pc)) (const_int 128))
+	         (eq (symbol_ref ("which_alternative")) (const_int 0)))
 	    (const_int 2)
 	    (const_int 8)))]
 )
@@ -1193,7 +1220,7 @@
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_THUMB2"
   "*
-  if (get_attr_length (insn) == 2 && which_alternative == 0)
+  if (get_attr_length (insn) == 2)
     return \"cbnz\\t%0, %l1\";
   else
     return \"cmp\\t%0, #0\;bne\\t%l1\";
@@ -1201,7 +1228,8 @@
   [(set (attr "length") 
         (if_then_else
 	    (and (ge (minus (match_dup 1) (pc)) (const_int 2))
-	         (le (minus (match_dup 1) (pc)) (const_int 128)))
+	         (le (minus (match_dup 1) (pc)) (const_int 128))
+	         (eq (symbol_ref ("which_alternative")) (const_int 0)))
 	    (const_int 2)
 	    (const_int 8)))]
 )
diff -Nur a/gcc/config/arm/t-linux-eabi b/gcc/config/arm/t-linux-eabi
--- a/gcc/config/arm/t-linux-eabi	2009-01-24 22:06:08.000000000 +0100
+++ b/gcc/config/arm/t-linux-eabi	2010-01-25 09:50:28.995687913 +0100
@@ -6,8 +6,8 @@
 MULTILIB_OPTIONS	=
 MULTILIB_DIRNAMES	=
 
-# Use a version of div0 which raises SIGFPE.
-LIB1ASMFUNCS := $(filter-out _dvmd_tls,$(LIB1ASMFUNCS)) _dvmd_lnx
+# Use a version of div0 which raises SIGFPE, and a special __clear_cache.
+LIB1ASMFUNCS := $(filter-out _dvmd_tls,$(LIB1ASMFUNCS)) _dvmd_lnx _clear_cache
 
 # Multilib the standard Linux files.  Don't include crti.o or crtn.o,
 # which are provided by glibc.
diff -Nur a/gcc/config/arm/t-montavista-linux b/gcc/config/arm/t-montavista-linux
--- a/gcc/config/arm/t-montavista-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/t-montavista-linux	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,33 @@
+# MontaVista GNU/Linux Configuration.
+# Copyright (C) 2009
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS = tarmv6/tthumb2
+MULTILIB_DIRNAMES = armv6 thumb2
+
+MULTILIB_EXCEPTIONS =
+
+MULTILIB_OSDIRNAMES =
+
+MULTILIB_ALIASES =
+
+MULTILIB_MATCHES =
+
+# These files must be built for each multilib.
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
diff -Nur a/gcc/config/arm/t-symbian b/gcc/config/arm/t-symbian
--- a/gcc/config/arm/t-symbian	2008-06-12 19:29:47.000000000 +0200
+++ b/gcc/config/arm/t-symbian	2010-01-25 09:50:28.995687913 +0100
@@ -17,6 +17,9 @@
 LIB2ADDEH = $(srcdir)/unwind-c.c $(srcdir)/config/arm/pr-support.c
 LIB2ADDEHDEP = $(UNWIND_H)
 
+# Include half-float helpers.
+LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/arm/fp16.c
+
 # Create a multilib for processors with VFP floating-point, and a
 # multilib for those without -- using the soft-float ABI in both
 # cases.  Symbian OS object should be compiled with interworking
diff -Nur a/gcc/config/arm/t-wrs-linux b/gcc/config/arm/t-wrs-linux
--- a/gcc/config/arm/t-wrs-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/t-wrs-linux	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,43 @@
+# Wind River GNU/Linux Configuration.
+# Copyright (C) 2006, 2007, 2008
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS = muclibc
+MULTILIB_OPTIONS += tarm926ej-s/tiwmmxt/txscale/tarm920t/tthumb2/tcortex-a8-be8
+MULTILIB_OPTIONS += mfloat-abi=softfp
+MULTILIB_DIRNAMES = uclibc
+MULTILIB_DIRNAMES += tarm926ej-s tiwmmxt txscale tarm920t thumb2 cortex-a8-be8
+MULTILIB_DIRNAMES += softfp
+
+MULTILIB_EXCEPTIONS = *muclibc*/*tarm920t*
+MULTILIB_EXCEPTIONS += *muclibc*/*cortex-a8-be8*
+
+MULTILIB_EXCEPTIONS += *tiwmmxt*/*mfloat-abi=softfp*
+MULTILIB_EXCEPTIONS += *txscale*/*mfloat-abi=softfp*
+MULTILIB_EXCEPTIONS += *tarm920t*/*mfloat-abi=softfp*
+MULTILIB_EXCEPTIONS += *thumb2*/*mfloat-abi=softfp*
+
+MULTILIB_MATCHES = tiwmmxt=tiwmmxt2
+
+MULTILIB_ALIASES = tcortex-a8-be8=tcortex-a8-be8/mfloat-abi?softfp
+MULTILIB_OSDIRNAMES =
+
+# These files must be built for each multilib.
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+
diff -Nur a/gcc/config/arm/uclinux-eabi.h b/gcc/config/arm/uclinux-eabi.h
--- a/gcc/config/arm/uclinux-eabi.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/arm/uclinux-eabi.h	2010-01-25 09:50:28.995687913 +0100
@@ -50,6 +50,10 @@
 #undef ARM_DEFAULT_ABI
 #define ARM_DEFAULT_ABI ARM_ABI_AAPCS_LINUX
 
+#undef LINK_GCC_C_SEQUENCE_SPEC
+#define LINK_GCC_C_SEQUENCE_SPEC \
+  "--start-group %G %L --end-group"
+
 /* Clear the instruction cache from `beg' to `end'.  This makes an
    inline system call to SYS_cacheflush.  */
 #undef CLEAR_INSN_CACHE
diff -Nur a/gcc/config/arm/unwind-arm.c b/gcc/config/arm/unwind-arm.c
--- a/gcc/config/arm/unwind-arm.c	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/arm/unwind-arm.c	2010-01-25 09:50:28.995687913 +0100
@@ -1000,7 +1000,6 @@
   while (code != _URC_END_OF_STACK
 	 && code != _URC_FAILURE);
 
- finish:
   restore_non_core_regs (&saved_vrs);
   return code;
 }
@@ -1168,6 +1167,9 @@
 			{
 			  matched = (void *)(ucbp + 1);
 			  rtti = _Unwind_decode_target2 ((_uw) &data[i + 1]);
+			  /* There is no way to encode an exception
+			     specification for 'class X * &', so
+			     always pass false for is_reference.  */
 			  if (__cxa_type_match (ucbp, (type_info *) rtti, 0,
 						&matched))
 			    break;
@@ -1197,8 +1199,6 @@
 		  ucbp->barrier_cache.bitpattern[4] = (_uw) &data[1];
 
 		  if (data[0] & uint32_highbit)
-		    phase2_call_unexpected_after_unwind = 1;
-		  else
 		    {
 		      data += rtti_count + 1;
 		      /* Setup for entry to the handler.  */
@@ -1208,6 +1208,8 @@
 		      _Unwind_SetGR (context, 0, (_uw) ucbp);
 		      return _URC_INSTALL_CONTEXT;
 		    }
+		  else
+		    phase2_call_unexpected_after_unwind = 1;
 		}
 	      if (data[0] & uint32_highbit)
 		data++;
diff -Nur a/gcc/config/arm/unwind-arm.h b/gcc/config/arm/unwind-arm.h
--- a/gcc/config/arm/unwind-arm.h	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/arm/unwind-arm.h	2010-01-25 09:50:28.995687913 +0100
@@ -229,9 +229,10 @@
 	return 0;
 
 #if (defined(linux) && !defined(__uClinux__)) || defined(__NetBSD__)
-      /* Pc-relative indirect.  */
+      /* Pc-relative indirect.  Propagate the bottom 2 bits, which can
+	 contain referenceness information in gnu unwinding tables.  */
       tmp += ptr;
-      tmp = *(_Unwind_Word *) tmp;
+      tmp = *(_Unwind_Word *) (tmp & ~(_Unwind_Word)3) | (tmp & 3);
 #elif defined(__symbian__) || defined(__uClinux__)
       /* Absolute pointer.  Nothing more to do.  */
 #else
diff -Nur a/gcc/config/arm/vec-common.md b/gcc/config/arm/vec-common.md
--- a/gcc/config/arm/vec-common.md	2007-08-22 22:32:18.000000000 +0200
+++ b/gcc/config/arm/vec-common.md	2010-01-25 09:50:28.995687913 +0100
@@ -38,6 +38,11 @@
   "TARGET_NEON
    || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))"
 {
+  if (can_create_pseudo_p ())
+    {
+      if (GET_CODE (operands[0]) != REG)
+	operands[1] = force_reg (<MODE>mode, operands[1]);
+    }
 })
 
 ;; Vector arithmetic. Expanders are blank, then unnamed insns implement
diff -Nur a/gcc/config/arm/vfp.md b/gcc/config/arm/vfp.md
--- a/gcc/config/arm/vfp.md	2008-09-01 15:40:49.000000000 +0200
+++ b/gcc/config/arm/vfp.md	2010-01-25 09:50:28.995687913 +0100
@@ -51,7 +51,7 @@
 ;; problems because small constants get converted into adds.
 (define_insn "*arm_movsi_vfp"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,rk,m ,*t,r,*t,*t, *Uv")
-      (match_operand:SI 1 "general_operand"	   "rk, I,K,N,mi,rk,r,*t,*t,*Uvi,*t"))]
+      (match_operand:SI 1 "general_operand"	   "rk, I,K,j,mi,rk,r,*t,*t,*Uvi,*t"))]
   "TARGET_ARM && TARGET_VFP && TARGET_HARD_FLOAT
    && (   s_register_operand (operands[0], SImode)
        || s_register_operand (operands[1], SImode))"
@@ -82,13 +82,17 @@
   "
   [(set_attr "predicable" "yes")
    (set_attr "type" "*,*,*,*,load1,store1,r_2_f,f_2_r,fcpys,f_loads,f_stores")
+   (set_attr "neon_type" "*,*,*,*,*,*,neon_mcr,neon_mrc,neon_vmov,*,*")
+   (set_attr "insn" "mov,mov,mvn,mov,*,*,*,*,*,*,*")
    (set_attr "pool_range"     "*,*,*,*,4096,*,*,*,*,1020,*")
    (set_attr "neg_pool_range" "*,*,*,*,4084,*,*,*,*,1008,*")]
 )
 
+;; See thumb2.md:thumb2_movsi_insn for an explanation of the split
+;; high/low register alternatives for loads and stores here.
 (define_insn "*thumb2_movsi_vfp"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,rk,m,*t,r, *t,*t, *Uv")
-      (match_operand:SI 1 "general_operand"	   "rk, I,K,N,mi,rk,r,*t,*t,*Uvi,*t"))]
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,l,*hk,m,*m,*t,r, *t,*t, *Uv")
+      (match_operand:SI 1 "general_operand"	   "rk, I,K,j,mi,*mi,l,*hk,r,*t,*t,*Uvi,*t"))]
   "TARGET_THUMB2 && TARGET_VFP && TARGET_HARD_FLOAT
    && (   s_register_operand (operands[0], SImode)
        || s_register_operand (operands[1], SImode))"
@@ -102,25 +106,29 @@
     case 3:
       return \"movw%?\\t%0, %1\";
     case 4:
-      return \"ldr%?\\t%0, %1\";
     case 5:
-      return \"str%?\\t%1, %0\";
+      return \"ldr%?\\t%0, %1\";
     case 6:
-      return \"fmsr%?\\t%0, %1\\t%@ int\";
     case 7:
-      return \"fmrs%?\\t%0, %1\\t%@ int\";
+      return \"str%?\\t%1, %0\";
     case 8:
+      return \"fmsr%?\\t%0, %1\\t%@ int\";
+    case 9:
+      return \"fmrs%?\\t%0, %1\\t%@ int\";
+    case 10:
       return \"fcpys%?\\t%0, %1\\t%@ int\";
-    case 9: case 10:
+    case 11: case 12:
       return output_move_vfp (operands);
     default:
       gcc_unreachable ();
     }
   "
   [(set_attr "predicable" "yes")
-   (set_attr "type" "*,*,*,*,load1,store1,r_2_f,f_2_r,fcpys,f_load,f_store")
-   (set_attr "pool_range"     "*,*,*,*,4096,*,*,*,*,1020,*")
-   (set_attr "neg_pool_range" "*,*,*,*,   0,*,*,*,*,1008,*")]
+   (set_attr "type" "*,*,*,*,load1,load1,store1,store1,r_2_f,f_2_r,fcpys,f_load,f_store")
+   (set_attr "neon_type" "*,*,*,*,*,*,*,*,neon_mcr,neon_mrc,neon_vmov,*,*")
+   (set_attr "insn" "mov,mov,mvn,mov,*,*,*,*,*,*,*,*,*")
+   (set_attr "pool_range"     "*,*,*,*,1020,4096,*,*,*,*,*,1020,*")
+   (set_attr "neg_pool_range" "*,*,*,*,   0,   0,*,*,*,*,*,1008,*")]
 )
 
 
@@ -145,7 +153,10 @@
     case 4:
       return \"fmrrd%?\\t%Q0, %R0, %P1\\t%@ int\";
     case 5:
-      return \"fcpyd%?\\t%P0, %P1\\t%@ int\";
+      if (TARGET_VFP_SINGLE)
+	return \"fcpys%?\\t%0, %1\\t%@ int\;fcpys%?\\t%p0, %p1\\t%@ int\";
+      else
+	return \"fcpyd%?\\t%P0, %P1\\t%@ int\";
     case 6: case 7:
       return output_move_vfp (operands);
     default:
@@ -153,7 +164,14 @@
     }
   "
   [(set_attr "type" "*,load2,store2,r_2_f,f_2_r,ffarithd,f_loadd,f_stored")
-   (set_attr "length" "8,8,8,4,4,4,4,4")
+   (set_attr "neon_type" "*,*,*,neon_mcr_2_mcrr,neon_mrrc,neon_vmov,*,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "0,1,2") (const_int 8)
+			       (eq_attr "alternative" "5")
+				(if_then_else
+				 (eq (symbol_ref "TARGET_VFP_SINGLE") (const_int 1))
+				 (const_int 8)
+				 (const_int 4))]
+			      (const_int 4)))
    (set_attr "pool_range"     "*,1020,*,*,*,*,1020,*")
    (set_attr "neg_pool_range" "*,1008,*,*,*,*,1008,*")]
 )
@@ -172,7 +190,10 @@
     case 4:
       return \"fmrrd%?\\t%Q0, %R0, %P1\\t%@ int\";
     case 5:
-      return \"fcpyd%?\\t%P0, %P1\\t%@ int\";
+      if (TARGET_VFP_SINGLE)
+	return \"fcpys%?\\t%0, %1\\t%@ int\;fcpys%?\\t%p0, %p1\\t%@ int\";
+      else
+	return \"fcpyd%?\\t%P0, %P1\\t%@ int\";
     case 6: case 7:
       return output_move_vfp (operands);
     default:
@@ -180,11 +201,123 @@
     }
   "
   [(set_attr "type" "*,load2,store2,r_2_f,f_2_r,ffarithd,f_load,f_store")
-   (set_attr "length" "8,8,8,4,4,4,4,4")
+   (set_attr "neon_type" "*,*,*,neon_mcr_2_mcrr,neon_mrrc,neon_vmov,*,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "0,1,2") (const_int 8)
+			       (eq_attr "alternative" "5")
+				(if_then_else
+				 (eq (symbol_ref "TARGET_VFP_SINGLE") (const_int 1))
+				 (const_int 8)
+				 (const_int 4))]
+			      (const_int 4)))
    (set_attr "pool_range"     "*,4096,*,*,*,*,1020,*")
    (set_attr "neg_pool_range" "*,   0,*,*,*,*,1008,*")]
 )
 
+;; HFmode moves
+(define_insn "*movhf_vfp_neon"
+  [(set (match_operand:HF 0 "nonimmediate_operand" "= t,Um,r,m,t,r,t,r,r")
+	(match_operand:HF 1 "general_operand"	   " Um, t,m,r,t,r,r,t,F"))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_NEON_FP16
+   && (   s_register_operand (operands[0], HFmode)
+       || s_register_operand (operands[1], HFmode))"
+  "*
+  switch (which_alternative)
+    {
+    case 0:     /* S register from memory */
+      return \"vld1.16\\t{%z0}, %A1\";
+    case 1:     /* memory from S register */
+      return \"vst1.16\\t{%z1}, %A0\";
+    case 2:     /* ARM register from memory */
+      return \"ldrh\\t%0, %1\\t%@ __fp16\";
+    case 3:     /* memory from ARM register */
+      return \"strh\\t%1, %0\\t%@ __fp16\";
+    case 4:	/* S register from S register */
+      return \"fcpys\\t%0, %1\";
+    case 5:	/* ARM register from ARM register */
+      return \"mov\\t%0, %1\\t%@ __fp16\";
+    case 6:	/* S register from ARM register */
+      return \"fmsr\\t%0, %1\";
+    case 7:	/* ARM register from S register */
+      return \"fmrs\\t%0, %1\";
+    case 8:	/* ARM register from constant */
+      {
+        REAL_VALUE_TYPE r;
+	long bits;
+	rtx ops[4];
+
+        REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);
+	bits = real_to_target (NULL, &r, HFmode);
+	ops[0] = operands[0];
+	ops[1] = GEN_INT (bits);
+	ops[2] = GEN_INT (bits & 0xff00);
+	ops[3] = GEN_INT (bits & 0x00ff);
+
+	if (arm_arch_thumb2)
+	  output_asm_insn (\"movw\\t%0, %1\", ops);
+	else
+	  output_asm_insn (\"mov\\t%0, %2\;orr\\t%0, %0, %3\", ops);
+	return \"\";
+       }
+    default:
+      gcc_unreachable ();
+    }
+  "
+  [(set_attr "conds" "unconditional")
+   (set_attr "type" "*,*,load1,store1,fcpys,*,r_2_f,f_2_r,*")
+   (set_attr "neon_type" "neon_vld1_1_2_regs,neon_vst1_1_2_regs_vst2_2_regs,*,*,*,*,*,*,*")
+   (set_attr "length" "4,4,4,4,4,4,4,4,8")]
+)
+
+;; FP16 without element load/store instructions.
+(define_insn "*movhf_vfp"
+  [(set (match_operand:HF 0 "nonimmediate_operand" "=r,m,t,r,t,r,r")
+	(match_operand:HF 1 "general_operand"	   " m,r,t,r,r,t,F"))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_FP16 && !TARGET_NEON_FP16
+   && (   s_register_operand (operands[0], HFmode)
+       || s_register_operand (operands[1], HFmode))"
+  "*
+  switch (which_alternative)
+    {
+    case 0:     /* ARM register from memory */
+      return \"ldrh\\t%0, %1\\t%@ __fp16\";
+    case 1:     /* memory from ARM register */
+      return \"strh\\t%1, %0\\t%@ __fp16\";
+    case 2:	/* S register from S register */
+      return \"fcpys\\t%0, %1\";
+    case 3:	/* ARM register from ARM register */
+      return \"mov\\t%0, %1\\t%@ __fp16\";
+    case 4:	/* S register from ARM register */
+      return \"fmsr\\t%0, %1\";
+    case 5:	/* ARM register from S register */
+      return \"fmrs\\t%0, %1\";
+    case 6:	/* ARM register from constant */
+      {
+        REAL_VALUE_TYPE r;
+	long bits;
+	rtx ops[4];
+
+        REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);
+	bits = real_to_target (NULL, &r, HFmode);
+	ops[0] = operands[0];
+	ops[1] = GEN_INT (bits);
+	ops[2] = GEN_INT (bits & 0xff00);
+	ops[3] = GEN_INT (bits & 0x00ff);
+
+	if (arm_arch_thumb2)
+	  output_asm_insn (\"movw\\t%0, %1\", ops);
+	else
+	  output_asm_insn (\"mov\\t%0, %2\;orr\\t%0, %0, %3\", ops);
+	return \"\";
+       }
+    default:
+      gcc_unreachable ();
+    }
+  "
+  [(set_attr "conds" "unconditional")
+   (set_attr "type" "load1,store1,fcpys,*,r_2_f,f_2_r,*")
+   (set_attr "length" "4,4,4,4,4,4,8")]
+)
+
 
 ;; SFmode moves
 ;; Disparage the w<->r cases because reloading an invalid address is
@@ -222,6 +355,8 @@
   [(set_attr "predicable" "yes")
    (set_attr "type"
      "r_2_f,f_2_r,fconsts,f_loads,f_stores,load1,store1,fcpys,*")
+   (set_attr "neon_type" "neon_mcr,neon_mrc,*,*,*,*,*,neon_vmov,*")
+   (set_attr "insn" "*,*,*,*,*,*,*,*,mov")
    (set_attr "pool_range" "*,*,*,1020,*,4096,*,*,*")
    (set_attr "neg_pool_range" "*,*,*,1008,*,4080,*,*,*")]
 )
@@ -258,6 +393,8 @@
   [(set_attr "predicable" "yes")
    (set_attr "type"
      "r_2_f,f_2_r,fconsts,f_load,f_store,load1,store1,fcpys,*")
+   (set_attr "neon_type" "neon_mcr,neon_mrc,*,*,*,*,*,neon_vmov,*")
+   (set_attr "insn" "*,*,*,*,*,*,*,*,mov")
    (set_attr "pool_range" "*,*,*,1020,*,4092,*,*,*")
    (set_attr "neg_pool_range" "*,*,*,1008,*,0,*,*,*")]
 )
@@ -267,7 +404,7 @@
 
 (define_insn "*movdf_vfp"
   [(set (match_operand:DF 0 "nonimmediate_soft_df_operand" "=w,?r,w ,r, m,w  ,Uv,w,r")
-	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dv,mF,r,UvF,w, w,r"))]
+	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dy,mF,r,UvF,w, w,r"))]
   "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP
    && (   register_operand (operands[0], DFmode)
        || register_operand (operands[1], DFmode))"
@@ -280,13 +417,17 @@
       case 1:
 	return \"fmrrd%?\\t%Q0, %R0, %P1\";
       case 2:
+	gcc_assert (TARGET_VFP_DOUBLE);
         return \"fconstd%?\\t%P0, #%G1\";
       case 3: case 4:
 	return output_move_double (operands);
       case 5: case 6:
 	return output_move_vfp (operands);
       case 7:
-	return \"fcpyd%?\\t%P0, %P1\";
+	if (TARGET_VFP_SINGLE)
+	  return \"fcpys%?\\t%0, %1\;fcpys%?\\t%p0, %p1\";
+	else
+	  return \"fcpyd%?\\t%P0, %P1\";
       case 8:
         return \"#\";
       default:
@@ -296,14 +437,21 @@
   "
   [(set_attr "type"
      "r_2_f,f_2_r,fconstd,f_loadd,f_stored,load2,store2,ffarithd,*")
-   (set_attr "length" "4,4,4,8,8,4,4,4,8")
+   (set_attr "neon_type" "neon_mcr_2_mcrr,neon_mrrc,*,*,*,*,*,neon_vmov,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "3,4,8") (const_int 8)
+			       (eq_attr "alternative" "7")
+				(if_then_else
+				 (eq (symbol_ref "TARGET_VFP_SINGLE") (const_int 1))
+				 (const_int 8)
+				 (const_int 4))]
+			      (const_int 4)))
    (set_attr "pool_range" "*,*,*,1020,*,1020,*,*,*")
    (set_attr "neg_pool_range" "*,*,*,1008,*,1008,*,*,*")]
 )
 
 (define_insn "*thumb2_movdf_vfp"
   [(set (match_operand:DF 0 "nonimmediate_soft_df_operand" "=w,?r,w ,r, m,w  ,Uv,w,r")
-	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dv,mF,r,UvF,w, w,r"))]
+	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dy,mF,r,UvF,w, w,r"))]
   "TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP"
   "*
   {
@@ -314,13 +462,17 @@
       case 1:
 	return \"fmrrd%?\\t%Q0, %R0, %P1\";
       case 2:
+	gcc_assert (TARGET_VFP_DOUBLE);
 	return \"fconstd%?\\t%P0, #%G1\";
       case 3: case 4: case 8:
 	return output_move_double (operands);
       case 5: case 6:
 	return output_move_vfp (operands);
       case 7:
-	return \"fcpyd%?\\t%P0, %P1\";
+	if (TARGET_VFP_SINGLE)
+	  return \"fcpys%?\\t%0, %1\;fcpys%?\\t%p0, %p1\";
+	else
+	  return \"fcpyd%?\\t%P0, %P1\";
       default:
 	abort ();
       }
@@ -328,7 +480,14 @@
   "
   [(set_attr "type"
      "r_2_f,f_2_r,fconstd,load2,store2,f_load,f_store,ffarithd,*")
-   (set_attr "length" "4,4,4,8,8,4,4,4,8")
+   (set_attr "neon_type" "neon_mcr_2_mcrr,neon_mrrc,*,*,*,*,*,neon_vmov,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "3,4,8") (const_int 8)
+			       (eq_attr "alternative" "7")
+				(if_then_else
+				 (eq (symbol_ref "TARGET_VFP_SINGLE") (const_int 1))
+				 (const_int 8)
+				 (const_int 4))]
+			      (const_int 4)))
    (set_attr "pool_range" "*,*,*,4096,*,1020,*,*,*")
    (set_attr "neg_pool_range" "*,*,*,0,*,1008,*,*,*")]
 )
@@ -356,7 +515,8 @@
    fmrs%D3\\t%0, %2\;fmrs%d3\\t%0, %1"
    [(set_attr "conds" "use")
     (set_attr "length" "4,4,8,4,4,8,4,4,8")
-    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr,neon_mcr,neon_mcr,neon_mrc,neon_mrc,neon_mrc")]
 )
 
 (define_insn "*thumb2_movsfcc_vfp"
@@ -379,7 +539,8 @@
    ite\\t%D3\;fmrs%D3\\t%0, %2\;fmrs%d3\\t%0, %1"
    [(set_attr "conds" "use")
     (set_attr "length" "6,6,10,6,6,10,6,6,10")
-    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr,neon_mcr,neon_mcr,neon_mrc,neon_mrc,neon_mrc")]
 )
 
 (define_insn "*movdfcc_vfp"
@@ -389,7 +550,7 @@
 	    [(match_operand 4 "cc_register" "") (const_int 0)])
 	  (match_operand:DF 1 "s_register_operand" "0,w,w,0,?r,?r,0,w,w")
 	  (match_operand:DF 2 "s_register_operand" "w,0,w,?r,0,?r,w,0,w")))]
-  "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "@
    fcpyd%D3\\t%P0, %P2
    fcpyd%d3\\t%P0, %P1
@@ -402,7 +563,8 @@
    fmrrd%D3\\t%Q0, %R0, %P2\;fmrrd%d3\\t%Q0, %R0, %P1"
    [(set_attr "conds" "use")
     (set_attr "length" "4,4,8,4,4,8,4,4,8")
-    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mrrc,neon_mrrc,neon_mrrc")]
 )
 
 (define_insn "*thumb2_movdfcc_vfp"
@@ -412,7 +574,7 @@
 	    [(match_operand 4 "cc_register" "") (const_int 0)])
 	  (match_operand:DF 1 "s_register_operand" "0,w,w,0,?r,?r,0,w,w")
 	  (match_operand:DF 2 "s_register_operand" "w,0,w,?r,0,?r,w,0,w")))]
-  "TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "@
    it\\t%D3\;fcpyd%D3\\t%P0, %P2
    it\\t%d3\;fcpyd%d3\\t%P0, %P1
@@ -425,7 +587,8 @@
    ite\\t%D3\;fmrrd%D3\\t%Q0, %R0, %P2\;fmrrd%d3\\t%Q0, %R0, %P1"
    [(set_attr "conds" "use")
     (set_attr "length" "6,6,10,6,6,10,6,6,10")
-    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mrrc,neon_mrrc,neon_mrrc")]
 )
 
 
@@ -443,7 +606,7 @@
 (define_insn "*absdf2_vfp"
   [(set (match_operand:DF	  0 "s_register_operand" "=w")
 	(abs:DF (match_operand:DF 1 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fabsd%?\\t%P0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "ffarithd")]
@@ -463,12 +626,12 @@
 (define_insn_and_split "*negdf2_vfp"
   [(set (match_operand:DF	  0 "s_register_operand" "=w,?r,?r")
 	(neg:DF (match_operand:DF 1 "s_register_operand" "w,0,r")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "@
    fnegd%?\\t%P0, %P1
    #
    #"
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP && reload_completed
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE && reload_completed
    && arm_general_register_operand (operands[0], DFmode)"
   [(set (match_dup 0) (match_dup 1))]
   "
@@ -523,7 +686,7 @@
   [(set (match_operand:DF	   0 "s_register_operand" "=w")
 	(plus:DF (match_operand:DF 1 "s_register_operand" "w")
 		 (match_operand:DF 2 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "faddd%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
    (set_attr "type" "faddd")]
@@ -544,7 +707,7 @@
   [(set (match_operand:DF	    0 "s_register_operand" "=w")
 	(minus:DF (match_operand:DF 1 "s_register_operand" "w")
 		  (match_operand:DF 2 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fsubd%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
    (set_attr "type" "faddd")]
@@ -567,7 +730,7 @@
   [(set (match_operand:DF	  0 "s_register_operand" "+w")
 	(div:DF (match_operand:DF 1 "s_register_operand" "w")
 		(match_operand:DF 2 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fdivd%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fdivd")]
@@ -590,7 +753,7 @@
   [(set (match_operand:DF	   0 "s_register_operand" "+w")
 	(mult:DF (match_operand:DF 1 "s_register_operand" "w")
 		 (match_operand:DF 2 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fmuld%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmuld")]
@@ -611,7 +774,7 @@
   [(set (match_operand:DF		   0 "s_register_operand" "+w")
 	(mult:DF (neg:DF (match_operand:DF 1 "s_register_operand" "w"))
 		 (match_operand:DF	   2 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fnmuld%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmuld")]
@@ -626,7 +789,8 @@
 	(plus:SF (mult:SF (match_operand:SF 2 "s_register_operand" "t")
 			  (match_operand:SF 3 "s_register_operand" "t"))
 		 (match_operand:SF	    1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP
+   && (!arm_tune_marvell_f || optimize_size)"
   "fmacs%?\\t%0, %2, %3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacs")]
@@ -637,7 +801,8 @@
 	(plus:DF (mult:DF (match_operand:DF 2 "s_register_operand" "w")
 			  (match_operand:DF 3 "s_register_operand" "w"))
 		 (match_operand:DF	    1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE
+   && (!arm_tune_marvell_f || optimize_size)"
   "fmacd%?\\t%P0, %P2, %P3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacd")]
@@ -649,7 +814,8 @@
 	(minus:SF (mult:SF (match_operand:SF 2 "s_register_operand" "t")
 			   (match_operand:SF 3 "s_register_operand" "t"))
 		  (match_operand:SF	     1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP
+   && (!arm_tune_marvell_f || optimize_size)"
   "fmscs%?\\t%0, %2, %3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacs")]
@@ -660,7 +826,8 @@
 	(minus:DF (mult:DF (match_operand:DF 2 "s_register_operand" "w")
 			   (match_operand:DF 3 "s_register_operand" "w"))
 		  (match_operand:DF	     1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE
+   && (!arm_tune_marvell_f || optimize_size)"
   "fmscd%?\\t%P0, %P2, %P3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacd")]
@@ -672,7 +839,8 @@
 	(minus:SF (match_operand:SF	     1 "s_register_operand" "0")
 		  (mult:SF (match_operand:SF 2 "s_register_operand" "t")
 			   (match_operand:SF 3 "s_register_operand" "t"))))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP
+   && (!arm_tune_marvell_f || optimize_size)"
   "fnmacs%?\\t%0, %2, %3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacs")]
@@ -683,7 +851,8 @@
 	(minus:DF (match_operand:DF	     1 "s_register_operand" "0")
 		  (mult:DF (match_operand:DF 2 "s_register_operand" "w")
 			   (match_operand:DF 3 "s_register_operand" "w"))))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE
+   && (!arm_tune_marvell_f || optimize_size)"
   "fnmacd%?\\t%P0, %P2, %P3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacd")]
@@ -697,7 +866,8 @@
 		    (neg:SF (match_operand:SF 2 "s_register_operand" "t"))
 		    (match_operand:SF	      3 "s_register_operand" "t"))
 		  (match_operand:SF	      1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP
+   && (!arm_tune_marvell_f || optimize_size)"
   "fnmscs%?\\t%0, %2, %3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacs")]
@@ -709,7 +879,8 @@
 		    (neg:DF (match_operand:DF 2 "s_register_operand" "w"))
 		    (match_operand:DF	      3 "s_register_operand" "w"))
 		  (match_operand:DF	      1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE
+   && (!arm_tune_marvell_f || optimize_size)"
   "fnmscd%?\\t%P0, %P2, %P3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacd")]
@@ -721,7 +892,7 @@
 (define_insn "*extendsfdf2_vfp"
   [(set (match_operand:DF		   0 "s_register_operand" "=w")
 	(float_extend:DF (match_operand:SF 1 "s_register_operand" "t")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fcvtds%?\\t%P0, %1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
@@ -730,12 +901,30 @@
 (define_insn "*truncdfsf2_vfp"
   [(set (match_operand:SF		   0 "s_register_operand" "=t")
 	(float_truncate:SF (match_operand:DF 1 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fcvtsd%?\\t%0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
 )
 
+(define_insn "extendhfsf2"
+  [(set (match_operand:SF		   0 "s_register_operand" "=t")
+	(float_extend:SF (match_operand:HF 1 "s_register_operand" "t")))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_FP16"
+  "vcvtb%?.f32.f16\\t%0, %1"
+  [(set_attr "predicable" "yes")
+   (set_attr "type" "f_cvt")]
+)
+
+(define_insn "truncsfhf2"
+  [(set (match_operand:HF		   0 "s_register_operand" "=t")
+	(float_truncate:HF (match_operand:SF 1 "s_register_operand" "t")))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_FP16"
+  "vcvtb%?.f16.f32\\t%0, %1"
+  [(set_attr "predicable" "yes")
+   (set_attr "type" "f_cvt")]
+)
+
 (define_insn "*truncsisf2_vfp"
   [(set (match_operand:SI		  0 "s_register_operand" "=t")
 	(fix:SI (fix:SF (match_operand:SF 1 "s_register_operand" "t"))))]
@@ -748,7 +937,7 @@
 (define_insn "*truncsidf2_vfp"
   [(set (match_operand:SI		  0 "s_register_operand" "=t")
 	(fix:SI (fix:DF (match_operand:DF 1 "s_register_operand" "w"))))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "ftosizd%?\\t%0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
@@ -767,7 +956,7 @@
 (define_insn "fixuns_truncdfsi2"
   [(set (match_operand:SI		  0 "s_register_operand" "=t")
 	(unsigned_fix:SI (fix:DF (match_operand:DF 1 "s_register_operand" "t"))))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "ftouizd%?\\t%0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
@@ -786,7 +975,7 @@
 (define_insn "*floatsidf2_vfp"
   [(set (match_operand:DF	    0 "s_register_operand" "=w")
 	(float:DF (match_operand:SI 1 "s_register_operand" "t")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fsitod%?\\t%P0, %1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
@@ -805,7 +994,7 @@
 (define_insn "floatunssidf2"
   [(set (match_operand:DF	    0 "s_register_operand" "=w")
 	(unsigned_float:DF (match_operand:SI 1 "s_register_operand" "t")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fuitod%?\\t%P0, %1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
@@ -826,7 +1015,7 @@
 (define_insn "*sqrtdf2_vfp"
   [(set (match_operand:DF	   0 "s_register_operand" "=w")
 	(sqrt:DF (match_operand:DF 1 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fsqrtd%?\\t%P0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fdivd")]
@@ -878,9 +1067,9 @@
   [(set (reg:CCFP CC_REGNUM)
 	(compare:CCFP (match_operand:DF 0 "s_register_operand"  "w")
 		      (match_operand:DF 1 "vfp_compare_operand" "wG")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "#"
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   [(set (reg:CCFP VFPCC_REGNUM)
 	(compare:CCFP (match_dup 0)
 		       (match_dup 1)))
@@ -893,9 +1082,9 @@
   [(set (reg:CCFPE CC_REGNUM)
 	(compare:CCFPE (match_operand:DF 0 "s_register_operand"  "w")
 		       (match_operand:DF 1 "vfp_compare_operand" "wG")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "#"
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   [(set (reg:CCFPE VFPCC_REGNUM)
 	(compare:CCFPE (match_dup 0)
 		       (match_dup 1)))
@@ -935,7 +1124,7 @@
   [(set (reg:CCFP VFPCC_REGNUM)
 	(compare:CCFP (match_operand:DF 0 "s_register_operand"  "w,w")
 		      (match_operand:DF 1 "vfp_compare_operand" "w,G")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "@
    fcmpd%?\\t%P0, %P1
    fcmpzd%?\\t%P0"
@@ -947,7 +1136,7 @@
   [(set (reg:CCFPE VFPCC_REGNUM)
 	(compare:CCFPE (match_operand:DF 0 "s_register_operand"  "w,w")
 		       (match_operand:DF 1 "vfp_compare_operand" "w,G")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "@
    fcmped%?\\t%P0, %P1
    fcmpezd%?\\t%P0"
diff -Nur a/gcc/config/arm/vxworks.h b/gcc/config/arm/vxworks.h
--- a/gcc/config/arm/vxworks.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/arm/vxworks.h	2010-01-25 09:50:28.995687913 +0100
@@ -97,7 +97,7 @@
 /* There is no default multilib.  */
 #undef MULTILIB_DEFAULTS
 
-#define FPUTYPE_DEFAULT FPUTYPE_VFP
+#define FPUTYPE_DEFAULT "vfp"
 
 #undef FUNCTION_PROFILER
 #define FUNCTION_PROFILER VXWORKS_FUNCTION_PROFILER
diff -Nur a/gcc/config/arm/wrs-linux.h b/gcc/config/arm/wrs-linux.h
--- a/gcc/config/arm/wrs-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/arm/wrs-linux.h	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,76 @@
+/* Wind River GNU/Linux Configuration.
+   Copyright (C) 2006, 2007, 2008
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Use the ARM926EJ-S by default.  */
+#undef SUBTARGET_CPU_DEFAULT
+#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm926ejs
+
+/* Add a -tiwmmxt option for convenience in generating multilibs.
+   This option generates big-endian IWMMXT code.  */
+#undef CC1_SPEC
+#define CC1_SPEC "							\
+ %{tarm926ej-s:	-mcpu=arm926ej-s ;					\
+   tiwmmxt:     -mcpu=iwmmxt ;						\
+   tiwmmxt2:    -mcpu=iwmmxt ;						\
+   txscale:     -mcpu=xscale -mbig-endian ;				\
+   tarm920t:    -mcpu=arm920t ;						\
+   tthumb2:     %{!mcpu=*:%{!march=*:-march=armv6t2}} -mthumb ;		\
+   tcortex-a8-be8: -mcpu=cortex-a8 -mbig-endian -mfloat-abi=softfp	\
+                   -mfpu=neon }						\
+ %{txscale:%{mfloat-abi=softfp:%eXScale VFP multilib not provided}}	\
+ %{tarm920t:%{mfloat-abi=softfp:%eARM920T VFP multilib not provided}}	\
+ %{profile:-p}"
+
+/* Since the ARM926EJ-S is the default processor, we do not need to
+   provide an explicit multilib for that processor.  */
+#undef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS \
+  { "tarm926ej-s" }
+
+/* The GLIBC headers are in /usr/include, relative to the sysroot; the
+   uClibc headers are in /uclibc/usr/include.  */
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC		\
+  "%{muclibc:/uclibc}" 
+
+/* Translate -tiwmmxt appropriately for the assembler.  The -meabi=5
+   option is the relevant part of SUBTARGET_EXTRA_ASM_SPEC in bpabi.h.  */
+#undef SUBTARGET_EXTRA_ASM_SPEC
+#define SUBTARGET_EXTRA_ASM_SPEC \
+  "%{tiwmmxt2:-mcpu=iwmmxt2} %{tiwmmxt:-mcpu=iwmmxt} %{txscale:-mcpu=xscale -EB} %{tcortex-a8-be8:-mcpu=cortex-a8 -EB} -meabi=5" 
+
+/* Translate -tiwmmxt for the linker.  */
+#undef SUBTARGET_EXTRA_LINK_SPEC
+#define SUBTARGET_EXTRA_LINK_SPEC			\
+  " %{tiwmmxt:-m armelf_linux_eabi ;			\
+     txscale:-m armelfb_linux_eabi ;			\
+     tcortex-a8-be8:-m armelfb_linux_eabi %{!r:--be8} ;	\
+     : -m armelf_linux_eabi}"
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC					\
+  "%{muclibc:/uclibc}%{tiwmmxt:/tiwmmxt ;			\
+     tiwmmxt2:/tiwmmxt ;					\
+     txscale:/txscale ;						\
+     tarm920t:/tarm920t ;					\
+     tthumb2:/thumb2 ;						\
+     tcortex-a8-be8:/cortex-a8-be8}%{!tthumb2:%{!tcortex-a8-be8:%{mfloat-abi=softfp:/softfp}}}"
+
diff -Nur a/gcc/config/i386/atom.md b/gcc/config/i386/atom.md
--- a/gcc/config/i386/atom.md	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/i386/atom.md	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,795 @@
+;; Atom Scheduling
+;; Copyright (C) 2009 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+;;
+;; Atom is an in-order core with two integer pipelines.
+
+
+(define_attr "atom_unit" "sishuf,simul,jeu,complex,other" 
+  (const_string "other"))
+
+(define_attr "atom_sse_attr" "rcp,movdup,lfence,fence,prefetch,sqrt,mxcsr,other"
+  (const_string "other"))
+
+(define_automaton "atom")
+
+;;  Atom has two ports: port 0 and port 1 connecting to all execution units
+(define_cpu_unit "atom-port-0,atom-port-1" "atom")
+
+;;  EU: Execution Unit
+;;  Atom EUs are connected by port 0 or port 1. 
+
+(define_cpu_unit "atom-eu-0, atom-eu-1,
+                  atom-imul-1, atom-imul-2, atom-imul-3, atom-imul-4"
+                  "atom")
+
+;; Some EUs have duplicated copied and can be accessed via either
+;; port 0 or port 1
+;; (define_reservation "atom-port-either" "(atom-port-0 | atom-port-1)")
+
+;;; Some instructions is dual-pipe execution, need both ports
+;;; Complex multi-op macro-instructoins need both ports and all EUs
+(define_reservation "atom-port-dual" "(atom-port-0 + atom-port-1)")
+(define_reservation "atom-all-eu" "(atom-eu-0 + atom-eu-1 + 
+                                    atom-imul-1 + atom-imul-2 + atom-imul-3 +
+                                    atom-imul-4)")
+
+;;; Most of simple instructions have 1 cycle latency. Some of them
+;;; issue in port 0, some in port 0 and some in either port.
+(define_reservation "atom-simple-0" "(atom-port-0 + atom-eu-0)")
+(define_reservation "atom-simple-1" "(atom-port-1 + atom-eu-1)")
+(define_reservation "atom-simple-either" "(atom-simple-0 | atom-simple-1)")
+
+;;; Some insn issues in port 0 with 3 cycle latency and 1 cycle tput
+(define_reservation "atom-eu-0-3-1" "(atom-port-0 + atom-eu-0, nothing*2)")
+
+;;; fmul insn can have 4 or 5 cycles latency
+(define_reservation "atom-fmul-5c" "(atom-port-0 + atom-eu-0), nothing*4")
+(define_reservation "atom-fmul-4c" "(atom-port-0 + atom-eu-0), nothing*3")
+
+;;; fadd can has 5 cycles latency depends on instruction forms
+(define_reservation "atom-fadd-5c" "(atom-port-1 + atom-eu-1), nothing*5")
+
+;;; imul insn has 5 cycles latency
+(define_reservation "atom-imul-32" 
+                    "atom-imul-1, atom-imul-2, atom-imul-3, atom-imul-4, 
+                     atom-port-0")
+;;; imul instruction excludes other non-FP instructions.
+(exclusion_set "atom-eu-0, atom-eu-1" 
+               "atom-imul-1, atom-imul-2, atom-imul-3, atom-imul-4")
+
+;;; dual-execution instructions can have 1,2,4,5 cycles latency depends on 
+;;; instruction forms
+(define_reservation "atom-dual-1c" "(atom-port-dual + atom-eu-0 + atom-eu-1)")
+(define_reservation "atom-dual-2c"
+                    "(atom-port-dual + atom-eu-0 + atom-eu-1, nothing)")
+(define_reservation "atom-dual-5c"
+                    "(atom-port-dual + atom-eu-0 + atom-eu-1, nothing*4)")
+
+;;; Complex macro-instruction has variants of latency, and uses both ports.
+(define_reservation "atom-complex" "(atom-port-dual + atom-all-eu)")
+
+(define_insn_reservation  "atom_other" 9
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "other")
+            (eq_attr "atom_unit" "!jeu")))
+  "atom-complex, atom-all-eu*8")
+
+;; return has type "other" with atom_unit "jeu"
+(define_insn_reservation  "atom_other_2" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "other")
+            (eq_attr "atom_unit" "jeu")))
+  "atom-dual-1c")
+
+(define_insn_reservation  "atom_multi" 9
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "multi"))
+  "atom-complex, atom-all-eu*8")
+
+;; Normal alu insns without carry
+(define_insn_reservation  "atom_alu" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu")
+            (and (eq_attr "memory" "none")
+                 (eq_attr "use_carry" "0"))))
+  "atom-simple-either")
+
+;; Normal alu insns without carry
+(define_insn_reservation  "atom_alu_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu")
+            (and (eq_attr "memory" "!none")
+                 (eq_attr "use_carry" "0"))))
+  "atom-simple-either")
+
+;; Alu insn consuming CF, such as add/sbb
+(define_insn_reservation  "atom_alu_carry" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu")
+            (and (eq_attr "memory" "none")
+                 (eq_attr "use_carry" "1"))))
+  "atom-simple-either")
+
+;; Alu insn consuming CF, such as add/sbb
+(define_insn_reservation  "atom_alu_carry_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu")
+            (and (eq_attr "memory" "!none")
+                (eq_attr "use_carry" "1"))))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_alu1" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu1")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_alu1_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu1")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_negnot" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "negnot")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_negnot_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "negnot")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_imov" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imov")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_imov_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imov")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+;; 16<-16, 32<-32
+(define_insn_reservation  "atom_imovx" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imovx")
+            (and (eq_attr "memory" "none")
+                 (ior (and (match_operand:HI 0 "register_operand")
+                           (match_operand:HI 1 "general_operand"))
+                      (and (match_operand:SI 0 "register_operand")
+                           (match_operand:SI 1 "general_operand"))))))
+  "atom-simple-either")
+
+;; 16<-16, 32<-32, mem
+(define_insn_reservation  "atom_imovx_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imovx")
+            (and (eq_attr "memory" "!none")
+                 (ior (and (match_operand:HI 0 "register_operand")
+                           (match_operand:HI 1 "general_operand"))
+                      (and (match_operand:SI 0 "register_operand")
+                           (match_operand:SI 1 "general_operand"))))))
+  "atom-simple-either")
+
+;; 32<-16, 32<-8, 64<-16, 64<-8, 64<-32, 8<-8
+(define_insn_reservation  "atom_imovx_2" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imovx")
+            (and (eq_attr "memory" "none")
+                 (ior (match_operand:QI 0 "register_operand")
+                      (ior (and (match_operand:SI 0 "register_operand")
+                                (not (match_operand:SI 1 "general_operand")))
+                           (match_operand:DI 0 "register_operand"))))))
+  "atom-simple-0")
+
+;; 32<-16, 32<-8, 64<-16, 64<-8, 64<-32, 8<-8, mem
+(define_insn_reservation  "atom_imovx_2_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imovx")
+            (and (eq_attr "memory" "!none")
+                 (ior (match_operand:QI 0 "register_operand")
+                      (ior (and (match_operand:SI 0 "register_operand")
+                                (not (match_operand:SI 1 "general_operand")))
+                           (match_operand:DI 0 "register_operand"))))))
+  "atom-simple-0")
+
+;; 16<-8
+(define_insn_reservation  "atom_imovx_3" 3
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imovx")
+            (and (match_operand:HI 0 "register_operand")
+                 (match_operand:QI 1 "general_operand"))))
+  "atom-complex, atom-all-eu*2")
+
+(define_insn_reservation  "atom_lea" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "lea")
+            (eq_attr "mode" "!HI")))
+  "atom-simple-either")
+
+;; lea 16bit address is complex insn
+(define_insn_reservation  "atom_lea_2" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "lea")
+            (eq_attr "mode" "HI")))
+  "atom-complex, atom-all-eu")
+
+(define_insn_reservation  "atom_incdec" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "incdec")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_incdec_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "incdec")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+;; simple shift instruction use SHIFT eu, none memory
+(define_insn_reservation  "atom_ishift" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ishift")
+            (and (eq_attr "memory" "none") (eq_attr "prefix_0f" "0"))))
+  "atom-simple-0")
+
+;; simple shift instruction use SHIFT eu, memory
+(define_insn_reservation  "atom_ishift_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ishift")
+            (and (eq_attr "memory" "!none") (eq_attr "prefix_0f" "0"))))
+  "atom-simple-0")
+
+;; DF shift (prefixed with 0f) is complex insn with latency of 7 cycles
+(define_insn_reservation  "atom_ishift_3" 7
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ishift")
+            (eq_attr "prefix_0f" "1")))
+  "atom-complex, atom-all-eu*6")
+
+(define_insn_reservation  "atom_ishift1" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ishift1")
+            (eq_attr "memory" "none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_ishift1_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ishift1")
+            (eq_attr "memory" "!none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_rotate" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "rotate")
+            (eq_attr "memory" "none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_rotate_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "rotate")
+            (eq_attr "memory" "!none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_rotate1" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "rotate1")
+            (eq_attr "memory" "none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_rotate1_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "rotate1")
+            (eq_attr "memory" "!none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_imul" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imul")
+            (and (eq_attr "memory" "none") (eq_attr "mode" "SI"))))
+  "atom-imul-32")
+
+(define_insn_reservation  "atom_imul_mem" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imul")
+            (and (eq_attr "memory" "!none") (eq_attr "mode" "SI"))))
+  "atom-imul-32")
+
+;; latency set to 10 as common 64x64 imul
+(define_insn_reservation  "atom_imul_3" 10
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imul")
+            (eq_attr "mode" "!SI")))
+  "atom-complex, atom-all-eu*9")
+
+(define_insn_reservation  "atom_idiv" 65
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "idiv"))
+  "atom-complex, atom-all-eu*32, nothing*32")
+
+(define_insn_reservation  "atom_icmp" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "icmp")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_icmp_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "icmp")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_test" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "test")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_test_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "test")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_ibr" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ibr")
+            (eq_attr "memory" "!load")))
+  "atom-simple-1")
+
+;; complex if jump target is from address
+(define_insn_reservation  "atom_ibr_2" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ibr")
+            (eq_attr "memory" "load")))
+  "atom-complex, atom-all-eu")
+
+(define_insn_reservation  "atom_setcc" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "setcc")
+            (eq_attr "memory" "!store")))
+  "atom-simple-either")
+
+;; 2 cycles complex if target is in memory
+(define_insn_reservation  "atom_setcc_2" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "setcc")
+            (eq_attr "memory" "store")))
+  "atom-complex, atom-all-eu")
+
+(define_insn_reservation  "atom_icmov" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "icmov")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_icmov_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "icmov")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+;; UCODE if segreg, ignored
+(define_insn_reservation  "atom_push" 2
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "push"))
+  "atom-dual-2c")
+
+;; pop r64 is 1 cycle. UCODE if segreg, ignored
+(define_insn_reservation  "atom_pop" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "pop")
+            (eq_attr "mode" "DI")))
+  "atom-dual-1c")
+
+;; pop non-r64 is 2 cycles. UCODE if segreg, ignored
+(define_insn_reservation  "atom_pop_2" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "pop")
+            (eq_attr "mode" "!DI")))
+  "atom-dual-2c")
+
+;; UCODE if segreg, ignored
+(define_insn_reservation  "atom_call" 1
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "call"))
+  "atom-dual-1c")
+
+(define_insn_reservation  "atom_callv" 1
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "callv"))
+  "atom-dual-1c")
+
+(define_insn_reservation  "atom_leave" 3
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "leave"))
+  "atom-complex, atom-all-eu*2")
+
+(define_insn_reservation  "atom_str" 3
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "str"))
+  "atom-complex, atom-all-eu*2")
+
+(define_insn_reservation  "atom_sselog" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sselog")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_sselog_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sselog")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_sselog1" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sselog1")
+            (eq_attr "memory" "none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_sselog1_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sselog1")
+            (eq_attr "memory" "!none")))
+  "atom-simple-0")
+
+;; not pmad, not psad
+(define_insn_reservation  "atom_sseiadd" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseiadd")
+            (and (not (match_operand:V2DI 0 "register_operand"))
+                 (and (eq_attr "atom_unit" "!simul")
+                      (eq_attr "atom_unit" "!complex")))))
+  "atom-simple-either")
+
+;; pmad, psad and 64
+(define_insn_reservation  "atom_sseiadd_2" 4
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseiadd")
+            (and (not (match_operand:V2DI 0 "register_operand"))
+                 (and (eq_attr "atom_unit" "simul" )
+                      (eq_attr "mode" "DI")))))
+  "atom-fmul-4c")
+
+;; pmad, psad and 128
+(define_insn_reservation  "atom_sseiadd_3" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseiadd")
+            (and (not (match_operand:V2DI 0 "register_operand"))
+                 (and (eq_attr "atom_unit" "simul" )
+                      (eq_attr "mode" "TI")))))
+  "atom-fmul-5c")
+
+;; if paddq(64 bit op), phadd/phsub
+(define_insn_reservation  "atom_sseiadd_4" 6
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseiadd")
+            (ior (match_operand:V2DI 0 "register_operand")
+                 (eq_attr "atom_unit" "complex"))))
+  "atom-complex, atom-all-eu*5")
+
+;; if immediate op. 
+(define_insn_reservation  "atom_sseishft" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseishft")
+            (and (eq_attr "atom_unit" "!sishuf")
+                 (match_operand 2 "immediate_operand"))))
+  "atom-simple-either")
+
+;; if palignr or psrldq
+(define_insn_reservation  "atom_sseishft_2" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseishft")
+            (and (eq_attr "atom_unit" "sishuf")
+                 (match_operand 2 "immediate_operand"))))
+  "atom-simple-0")
+
+;; if reg/mem op
+(define_insn_reservation  "atom_sseishft_3" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseishft")
+            (not (match_operand 2 "immediate_operand"))))
+  "atom-complex, atom-all-eu")
+
+(define_insn_reservation  "atom_sseimul" 1
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "sseimul"))
+  "atom-simple-0")
+
+;; rcpss or rsqrtss
+(define_insn_reservation  "atom_sse" 4
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sse")
+            (and (eq_attr "atom_sse_attr" "rcp") (eq_attr "mode" "SF"))))
+  "atom-fmul-4c")
+
+;; movshdup, movsldup. Suggest to type sseishft
+(define_insn_reservation  "atom_sse_2" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sse")
+            (eq_attr "atom_sse_attr" "movdup")))
+  "atom-simple-0")
+
+;; lfence
+(define_insn_reservation  "atom_sse_3" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sse")
+            (eq_attr "atom_sse_attr" "lfence")))
+  "atom-simple-either")
+
+;; sfence,clflush,mfence, prefetch
+(define_insn_reservation  "atom_sse_4" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sse")
+            (ior (eq_attr "atom_sse_attr" "fence")
+                 (eq_attr "atom_sse_attr" "prefetch"))))
+  "atom-simple-0")
+
+;; rcpps, rsqrtss, sqrt, ldmxcsr
+(define_insn_reservation  "atom_sse_5" 7
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sse")
+            (ior (ior (eq_attr "atom_sse_attr" "sqrt")
+                      (eq_attr "atom_sse_attr" "mxcsr"))
+                 (and (eq_attr "atom_sse_attr" "rcp")
+                      (eq_attr "mode" "V4SF")))))
+  "atom-complex, atom-all-eu*6")
+
+;; xmm->xmm
+(define_insn_reservation  "atom_ssemov" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemov")
+            (and (match_operand 0 "register_operand" "xy") (match_operand 1 "register_operand" "xy"))))
+  "atom-simple-either")
+
+;; reg->xmm
+(define_insn_reservation  "atom_ssemov_2" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemov")
+            (and (match_operand 0 "register_operand" "xy") (match_operand 1 "register_operand" "r"))))
+  "atom-simple-0")
+
+;; xmm->reg
+(define_insn_reservation  "atom_ssemov_3" 3
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemov")
+            (and (match_operand 0 "register_operand" "r") (match_operand 1 "register_operand" "xy"))))
+  "atom-eu-0-3-1")
+
+;; mov mem
+(define_insn_reservation  "atom_ssemov_4" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemov")
+            (and (eq_attr "movu" "0") (eq_attr "memory" "!none"))))
+  "atom-simple-0")
+
+;; movu mem
+(define_insn_reservation  "atom_ssemov_5" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemov")
+            (ior (eq_attr "movu" "1") (eq_attr "memory" "!none"))))
+  "atom-complex, atom-all-eu")
+
+;; no memory simple
+(define_insn_reservation  "atom_sseadd" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseadd")
+            (and (eq_attr "memory" "none")
+                 (and (eq_attr "mode" "!V2DF")
+                      (eq_attr "atom_unit" "!complex")))))
+  "atom-fadd-5c")
+
+;; memory simple
+(define_insn_reservation  "atom_sseadd_mem" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseadd")
+            (and (eq_attr "memory" "!none")
+                 (and (eq_attr "mode" "!V2DF")
+                      (eq_attr "atom_unit" "!complex")))))
+  "atom-dual-5c")
+
+;; maxps, minps, *pd, hadd, hsub
+(define_insn_reservation  "atom_sseadd_3" 8
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseadd")
+            (ior (eq_attr "mode" "V2DF") (eq_attr "atom_unit" "complex"))))
+  "atom-complex, atom-all-eu*7")
+
+;; Except dppd/dpps
+(define_insn_reservation  "atom_ssemul" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemul")
+            (eq_attr "mode" "!SF")))
+  "atom-fmul-5c")
+
+;; Except dppd/dpps, 4 cycle if mulss
+(define_insn_reservation  "atom_ssemul_2" 4
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemul")
+            (eq_attr "mode" "SF")))
+  "atom-fmul-4c")
+
+(define_insn_reservation  "atom_ssecmp" 1
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "ssecmp"))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_ssecomi" 10
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "ssecomi"))
+  "atom-complex, atom-all-eu*9")
+
+;; no memory and cvtpi2ps, cvtps2pi, cvttps2pi
+(define_insn_reservation  "atom_ssecvt" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssecvt")
+            (ior (and (match_operand:V2SI 0 "register_operand")
+                      (match_operand:V4SF 1 "register_operand"))
+                 (and (match_operand:V4SF 0 "register_operand")
+                      (match_operand:V2SI 1 "register_operand")))))
+  "atom-fadd-5c")
+
+;; memory and cvtpi2ps, cvtps2pi, cvttps2pi
+(define_insn_reservation  "atom_ssecvt_2" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssecvt")
+            (ior (and (match_operand:V2SI 0 "register_operand")
+                      (match_operand:V4SF 1 "memory_operand"))
+                 (and (match_operand:V4SF 0 "register_operand")
+                      (match_operand:V2SI 1 "memory_operand")))))
+  "atom-dual-5c")
+
+;; otherwise. 7 cycles average for cvtss2sd
+(define_insn_reservation  "atom_ssecvt_3" 7
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssecvt")
+            (not (ior (and (match_operand:V2SI 0 "register_operand")
+                           (match_operand:V4SF 1 "nonimmediate_operand"))
+                      (and (match_operand:V4SF 0 "register_operand")
+                           (match_operand:V2SI 1 "nonimmediate_operand"))))))
+  "atom-complex, atom-all-eu*6")
+
+;; memory and cvtsi2sd
+(define_insn_reservation  "atom_sseicvt" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseicvt")
+            (and (match_operand:V2DF 0 "register_operand")
+                 (match_operand:SI 1 "memory_operand"))))
+  "atom-dual-5c")
+
+;; otherwise. 8 cycles average for cvtsd2si
+(define_insn_reservation  "atom_sseicvt_2" 8
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseicvt")
+            (not (and (match_operand:V2DF 0 "register_operand")
+                      (match_operand:SI 1 "memory_operand")))))
+  "atom-complex, atom-all-eu*7")
+
+(define_insn_reservation  "atom_ssediv" 62
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "ssediv"))
+  "atom-complex, atom-all-eu*12, nothing*49")
+
+;; simple for fmov
+(define_insn_reservation  "atom_fmov" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "fmov")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+;; simple for fmov
+(define_insn_reservation  "atom_fmov_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "fmov")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+;; Define bypass here
+
+;; There will be no stall from lea to non-mem EX insns
+(define_bypass 0 "atom_lea"
+                 "atom_alu_carry,
+                  atom_alu,atom_alu1,atom_negnot,atom_imov,atom_imovx,
+                  atom_incdec, atom_setcc, atom_icmov, atom_pop")
+
+(define_bypass 0 "atom_lea"
+                 "atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_imovx_mem, atom_imovx_2_mem,
+                  atom_imov_mem, atom_icmov_mem, atom_fmov_mem"
+                 "!ix86_agi_dependent")
+
+;; There will be 3 cycles stall from EX insns to AGAN insns LEA
+(define_bypass 4 "atom_alu_carry,
+                  atom_alu,atom_alu1,atom_negnot,atom_imov,atom_imovx,
+                  atom_incdec,atom_ishift,atom_ishift1,atom_rotate,
+                  atom_rotate1, atom_setcc, atom_icmov, atom_pop,
+                  atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_imovx_mem, atom_imovx_2_mem,
+                  atom_imov_mem, atom_icmov_mem, atom_fmov_mem"
+                 "atom_lea")
+
+;; There will be 3 cycles stall from EX insns to insns need addr calculation
+(define_bypass 4 "atom_alu_carry,
+                  atom_alu,atom_alu1,atom_negnot,atom_imov,atom_imovx,
+                  atom_incdec,atom_ishift,atom_ishift1,atom_rotate,
+                  atom_rotate1, atom_setcc, atom_icmov, atom_pop,
+                  atom_imovx_mem, atom_imovx_2_mem,
+                  atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_imov_mem, atom_icmov_mem, atom_fmov_mem"
+                 "atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_negnot_mem, atom_imov_mem, atom_incdec_mem,
+                  atom_imovx_mem, atom_imovx_2_mem,
+                  atom_imul_mem, atom_icmp_mem,
+                  atom_test_mem, atom_icmov_mem, atom_sselog_mem,
+                  atom_sselog1_mem, atom_fmov_mem, atom_sseadd_mem,
+                  atom_ishift_mem, atom_ishift1_mem, 
+                  atom_rotate_mem, atom_rotate1_mem"
+                  "ix86_agi_dependent")
+
+;; Stall from imul to lea is 8 cycles.
+(define_bypass 9 "atom_imul, atom_imul_mem" "atom_lea")
+
+;; Stall from imul to memory address is 8 cycles.
+(define_bypass 9 "atom_imul, atom_imul_mem" 
+                 "atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_negnot_mem, atom_imov_mem, atom_incdec_mem,
+                  atom_ishift_mem, atom_ishift1_mem, atom_rotate_mem,
+                  atom_rotate1_mem, atom_imul_mem, atom_icmp_mem,
+                  atom_test_mem, atom_icmov_mem, atom_sselog_mem,
+                  atom_sselog1_mem, atom_fmov_mem, atom_sseadd_mem"
+                  "ix86_agi_dependent")
+
+;; There will be 0 cycle stall from cmp/test to jcc
+
+;; There will be 1 cycle stall from flag producer to cmov and adc/sbb
+(define_bypass 2 "atom_icmp, atom_test, atom_alu, atom_alu_carry,
+                  atom_alu1, atom_negnot, atom_incdec, atom_ishift,
+                  atom_ishift1, atom_rotate, atom_rotate1"
+                 "atom_icmov, atom_alu_carry")
+
+;; lea to shift count stall is 2 cycles
+(define_bypass 3 "atom_lea"
+                 "atom_ishift, atom_ishift1, atom_rotate, atom_rotate1,
+                  atom_ishift_mem, atom_ishift1_mem, 
+                  atom_rotate_mem, atom_rotate1_mem"
+                 "ix86_dep_by_shift_count")
+
+;; lea to shift source stall is 1 cycle
+(define_bypass 2 "atom_lea"
+                 "atom_ishift, atom_ishift1, atom_rotate, atom_rotate1"
+                 "!ix86_dep_by_shift_count")
+
+;; non-lea to shift count stall is 1 cycle
+(define_bypass 2 "atom_alu_carry,
+                  atom_alu,atom_alu1,atom_negnot,atom_imov,atom_imovx,
+                  atom_incdec,atom_ishift,atom_ishift1,atom_rotate,
+                  atom_rotate1, atom_setcc, atom_icmov, atom_pop,
+                  atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_imovx_mem, atom_imovx_2_mem,
+                  atom_imov_mem, atom_icmov_mem, atom_fmov_mem"
+                 "atom_ishift, atom_ishift1, atom_rotate, atom_rotate1,
+                  atom_ishift_mem, atom_ishift1_mem, 
+                  atom_rotate_mem, atom_rotate1_mem"
+                 "ix86_dep_by_shift_count")
diff -Nur a/gcc/config/i386/cpuid.h b/gcc/config/i386/cpuid.h
--- a/gcc/config/i386/cpuid.h	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/i386/cpuid.h	2010-01-25 09:50:28.995687913 +0100
@@ -29,6 +29,7 @@
 #define bit_CMPXCHG16B	(1 << 13)
 #define bit_SSE4_1	(1 << 19)
 #define bit_SSE4_2	(1 << 20)
+#define bit_MOVBE	(1 << 22)
 #define bit_POPCNT	(1 << 23)
 #define bit_AES		(1 << 25)
 #define bit_XSAVE	(1 << 26)
diff -Nur a/gcc/config/i386/cs-linux.h b/gcc/config/i386/cs-linux.h
--- a/gcc/config/i386/cs-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/i386/cs-linux.h	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,41 @@
+/* Sourcery G++ IA32 GNU/Linux Configuration.
+   Copyright (C) 2007
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* This configuration may be used either with the system glibc (in
+   system32 and system64 subdirectories) or with the included glibc
+   (in the sgxx-glibc subdirectory).  */
+
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+  "%{msgxx-glibc:/sgxx-glibc ;			\
+     m64:/system64 ;				\
+     mrhel3:/system64 ;				\
+     mrh73:/system32-old ;			\
+     :/system32}"
+
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC SYSROOT_SUFFIX_SPEC
+
+/* See mips/wrs-linux.h for details on this use of
+   STARTFILE_PREFIX_SPEC.  */
+#undef STARTFILE_PREFIX_SPEC
+#define STARTFILE_PREFIX_SPEC				\
+  "%{m64: /usr/local/lib64/ /lib64/ /usr/lib64/}	\
+   %{!m64: /usr/local/lib/ /lib/ /usr/lib/}"
diff -Nur a/gcc/config/i386/cs-linux-lite.h b/gcc/config/i386/cs-linux-lite.h
--- a/gcc/config/i386/cs-linux-lite.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/i386/cs-linux-lite.h	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,31 @@
+/* Sourcery G++ Lite IA32 GNU/Linux Configuration.
+   Copyright (C) 2009
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+  "%{march=atom:%{!m64:/atom} ;			\
+     march=core2:%{m64:/core2}}"
+
+/* See mips/wrs-linux.h for details on this use of
+   STARTFILE_PREFIX_SPEC.  */
+#undef STARTFILE_PREFIX_SPEC
+#define STARTFILE_PREFIX_SPEC				\
+  "%{m64: /usr/local/lib64/ /lib64/ /usr/lib64/}	\
+   %{!m64: /usr/local/lib/ /lib/ /usr/lib/}"
diff -Nur a/gcc/config/i386/cs-linux.opt b/gcc/config/i386/cs-linux.opt
--- a/gcc/config/i386/cs-linux.opt	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/i386/cs-linux.opt	2010-01-25 09:50:28.995687913 +0100
@@ -0,0 +1,11 @@
+; Additional options for Sourcery G++.
+
+mrh73
+Target Undocumented
+
+mrhel3
+Target Undocumented
+
+msgxx-glibc
+Target
+Use included version of GLIBC
diff -Nur a/gcc/config/i386/cygming.h b/gcc/config/i386/cygming.h
--- a/gcc/config/i386/cygming.h	2009-07-12 17:56:41.000000000 +0200
+++ b/gcc/config/i386/cygming.h	2010-01-25 09:50:28.995687913 +0100
@@ -34,7 +34,7 @@
 #endif
 
 #undef TARGET_64BIT_MS_ABI
-#define TARGET_64BIT_MS_ABI (!cfun ? DEFAULT_ABI == MS_ABI : TARGET_64BIT && cfun->machine->call_abi == MS_ABI)
+#define TARGET_64BIT_MS_ABI (!cfun ? ix86_abi == MS_ABI : TARGET_64BIT && cfun->machine->call_abi == MS_ABI)
 
 #undef DEFAULT_ABI
 #define DEFAULT_ABI (TARGET_64BIT ? MS_ABI : SYSV_ABI)
@@ -203,7 +203,7 @@
 #define CHECK_STACK_LIMIT 4000
 
 #undef STACK_BOUNDARY
-#define STACK_BOUNDARY	(DEFAULT_ABI == MS_ABI ? 128 : BITS_PER_WORD)
+#define STACK_BOUNDARY	(ix86_abi == MS_ABI ? 128 : BITS_PER_WORD)
 
 /* By default, target has a 80387, uses IEEE compatible arithmetic,
    returns float values in the 387 and needs stack probes.
diff -Nur a/gcc/config/i386/cygming.opt b/gcc/config/i386/cygming.opt
--- a/gcc/config/i386/cygming.opt	2007-08-02 12:49:31.000000000 +0200
+++ b/gcc/config/i386/cygming.opt	2010-01-25 09:50:28.995687913 +0100
@@ -45,3 +45,7 @@
 mwindows
 Target
 Create GUI application
+
+mpe-aligned-commons
+Target Var(use_pe_aligned_common) Init(HAVE_GAS_ALIGNED_COMM)
+Use the GNU extension to the PE format for aligned common data
diff -Nur a/gcc/config/i386/driver-i386.c b/gcc/config/i386/driver-i386.c
--- a/gcc/config/i386/driver-i386.c	2009-05-27 16:54:00.000000000 +0200
+++ b/gcc/config/i386/driver-i386.c	2010-01-25 09:50:29.005686600 +0100
@@ -378,7 +378,7 @@
   /* Extended features */
   unsigned int has_lahf_lm = 0, has_sse4a = 0;
   unsigned int has_longmode = 0, has_3dnowp = 0, has_3dnow = 0;
-  unsigned int has_sse4_1 = 0, has_sse4_2 = 0;
+  unsigned int has_movbe = 0, has_sse4_1 = 0, has_sse4_2 = 0;
   unsigned int has_popcnt = 0, has_aes = 0, has_avx = 0;
   unsigned int has_pclmul = 0;
 
@@ -398,9 +398,22 @@
 
   __cpuid (1, eax, ebx, ecx, edx);
 
-  /* We don't care for extended family.  */
   model = (eax >> 4) & 0x0f;
   family = (eax >> 8) & 0x0f;
+  if (vendor == SIG_INTEL)
+    {
+      unsigned int extended_model, extended_family;
+
+      extended_model = (eax >> 12) & 0xf0;
+      extended_family = (eax >> 20) & 0xff;
+      if (family == 0x0f)
+	{
+	  family += extended_family;
+	  model += extended_model;
+	}
+      else if (family == 0x06)
+	model += extended_model;
+    }
 
   has_sse3 = ecx & bit_SSE3;
   has_ssse3 = ecx & bit_SSSE3;
@@ -408,6 +421,7 @@
   has_sse4_2 = ecx & bit_SSE4_2;
   has_avx = ecx & bit_AVX;
   has_cmpxchg16b = ecx & bit_CMPXCHG16B;
+  has_movbe = ecx & bit_MOVBE;
   has_popcnt = ecx & bit_POPCNT;
   has_aes = ecx & bit_AES;
   has_pclmul = ecx & bit_PCLMUL;
@@ -505,8 +519,8 @@
       break;
     case PROCESSOR_PENTIUMPRO:
       if (has_longmode)
-	/* It is Core 2 Duo.  */
-	cpu = "core2";
+	/* It is Core 2 or Atom.  */
+	cpu = (model == 28) ? "atom" : "core2";
       else if (arch)
 	{
 	  if (has_sse3)
@@ -597,6 +611,8 @@
 	options = concat (options, "-mcx16 ", NULL);
       if (has_lahf_lm)
 	options = concat (options, "-msahf ", NULL);
+      if (has_movbe)
+	options = concat (options, "-mmovbe ", NULL);
       if (has_aes)
 	options = concat (options, "-maes ", NULL);
       if (has_pclmul)
diff -Nur a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
--- a/gcc/config/i386/i386.c	2009-07-21 09:22:51.000000000 +0200
+++ b/gcc/config/i386/i386.c	2010-01-25 09:50:29.005686600 +0100
@@ -1036,6 +1036,79 @@
   1,                                    /* cond_not_taken_branch_cost.  */
 };
 
+static const
+struct processor_costs atom_cost = {
+  COSTS_N_INSNS (1),			/* cost of an add instruction */
+  COSTS_N_INSNS (1) + 1,		/* cost of a lea instruction */
+  COSTS_N_INSNS (1),			/* variable shift costs */
+  COSTS_N_INSNS (1),			/* constant shift costs */
+  {COSTS_N_INSNS (3),			/* cost of starting multiply for QI */
+   COSTS_N_INSNS (4),			/*                               HI */
+   COSTS_N_INSNS (3),			/*                               SI */
+   COSTS_N_INSNS (4),			/*                               DI */
+   COSTS_N_INSNS (2)},			/*                               other */
+  0,					/* cost of multiply per each bit set */
+  {COSTS_N_INSNS (18),			/* cost of a divide/mod for QI */
+   COSTS_N_INSNS (26),			/*                          HI */
+   COSTS_N_INSNS (42),			/*                          SI */
+   COSTS_N_INSNS (74),			/*                          DI */
+   COSTS_N_INSNS (74)},			/*                          other */
+  COSTS_N_INSNS (1),			/* cost of movsx */
+  COSTS_N_INSNS (1),			/* cost of movzx */
+  8,					/* "large" insn */
+  17,					/* MOVE_RATIO */
+  2,					/* cost for loading QImode using movzbl */
+  {4, 4, 4},				/* cost of loading integer registers
+					   in QImode, HImode and SImode.
+					   Relative to reg-reg move (2).  */
+  {4, 4, 4},				/* cost of storing integer registers */
+  4,					/* cost of reg,reg fld/fst */
+  {12, 12, 12},				/* cost of loading fp registers
+					   in SFmode, DFmode and XFmode */
+  {6, 6, 8},				/* cost of storing fp registers
+					   in SFmode, DFmode and XFmode */
+  2,					/* cost of moving MMX register */
+  {8, 8},				/* cost of loading MMX registers
+					   in SImode and DImode */
+  {8, 8},				/* cost of storing MMX registers
+					   in SImode and DImode */
+  2,					/* cost of moving SSE register */
+  {8, 8, 8},				/* cost of loading SSE registers
+					   in SImode, DImode and TImode */
+  {8, 8, 8},				/* cost of storing SSE registers
+					   in SImode, DImode and TImode */
+  5,					/* MMX or SSE register to integer */
+  32,					/* size of l1 cache.  */
+  256,					/* size of l2 cache.  */
+  64,					/* size of prefetch block */
+  6,					/* number of parallel prefetches */
+  3,					/* Branch cost */
+  COSTS_N_INSNS (8),			/* cost of FADD and FSUB insns.  */
+  COSTS_N_INSNS (8),			/* cost of FMUL instruction.  */
+  COSTS_N_INSNS (20),			/* cost of FDIV instruction.  */
+  COSTS_N_INSNS (8),			/* cost of FABS instruction.  */
+  COSTS_N_INSNS (8),			/* cost of FCHS instruction.  */
+  COSTS_N_INSNS (40),			/* cost of FSQRT instruction.  */
+  {{libcall, {{11, loop}, {-1, rep_prefix_4_byte}}},
+   {libcall, {{32, loop}, {64, rep_prefix_4_byte},
+          {8192, rep_prefix_8_byte}, {-1, libcall}}}},
+  {{libcall, {{8, loop}, {15, unrolled_loop},
+          {2048, rep_prefix_4_byte}, {-1, libcall}}},
+   {libcall, {{24, loop}, {32, unrolled_loop},
+          {8192, rep_prefix_8_byte}, {-1, libcall}}}},
+  1,                                    /* scalar_stmt_cost.  */
+  1,                                    /* scalar load_cost.  */
+  1,                                    /* scalar_store_cost.  */
+  1,                                    /* vec_stmt_cost.  */
+  1,                                    /* vec_to_scalar_cost.  */
+  1,                                    /* scalar_to_vec_cost.  */
+  1,                                    /* vec_align_load_cost.  */
+  2,                                    /* vec_unalign_load_cost.  */
+  1,                                    /* vec_store_cost.  */
+  3,                                    /* cond_taken_branch_cost.  */
+  1,                                    /* cond_not_taken_branch_cost.  */
+};
+
 /* Generic64 should produce code tuned for Nocona and K8.  */
 static const
 struct processor_costs generic64_cost = {
@@ -1194,6 +1267,7 @@
 #define m_PENT4  (1<<PROCESSOR_PENTIUM4)
 #define m_NOCONA  (1<<PROCESSOR_NOCONA)
 #define m_CORE2  (1<<PROCESSOR_CORE2)
+#define m_ATOM  (1<<PROCESSOR_ATOM)
 
 #define m_GEODE  (1<<PROCESSOR_GEODE)
 #define m_K6  (1<<PROCESSOR_K6)
@@ -1231,10 +1305,11 @@
   m_486 | m_PENT,
 
   /* X86_TUNE_UNROLL_STRLEN */
-  m_486 | m_PENT | m_PPRO | m_AMD_MULTIPLE | m_K6 | m_CORE2 | m_GENERIC,
+  m_486 | m_PENT | m_ATOM | m_PPRO | m_AMD_MULTIPLE | m_K6
+  | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_DEEP_BRANCH_PREDICTION */
-  m_PPRO | m_K6_GEODE | m_AMD_MULTIPLE | m_PENT4 | m_GENERIC,
+  m_ATOM | m_PPRO | m_K6_GEODE | m_AMD_MULTIPLE | m_PENT4 | m_GENERIC,
 
   /* X86_TUNE_BRANCH_PREDICTION_HINTS: Branch hints were put in P4 based
      on simulation result. But after P4 was made, no performance benefit
@@ -1246,12 +1321,12 @@
   ~m_386,
 
   /* X86_TUNE_USE_SAHF */
-  m_PPRO | m_K6_GEODE | m_K8 | m_AMDFAM10 | m_PENT4
+  m_ATOM | m_PPRO | m_K6_GEODE | m_K8 | m_AMDFAM10 | m_PENT4
   | m_NOCONA | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_MOVX: Enable to zero extend integer registers to avoid
      partial dependencies.  */
-  m_AMD_MULTIPLE | m_PPRO | m_PENT4 | m_NOCONA
+  m_AMD_MULTIPLE | m_ATOM | m_PPRO | m_PENT4 | m_NOCONA
   | m_CORE2 | m_GENERIC | m_GEODE /* m_386 | m_K6 */,
 
   /* X86_TUNE_PARTIAL_REG_STALL: We probably ought to watch for partial
@@ -1271,13 +1346,13 @@
   m_386 | m_486 | m_K6_GEODE,
 
   /* X86_TUNE_USE_SIMODE_FIOP */
-  ~(m_PPRO | m_AMD_MULTIPLE | m_PENT | m_CORE2 | m_GENERIC),
+  ~(m_PPRO | m_AMD_MULTIPLE | m_PENT | m_ATOM | m_CORE2 | m_GENERIC),
 
   /* X86_TUNE_USE_MOV0 */
   m_K6,
 
   /* X86_TUNE_USE_CLTD */
-  ~(m_PENT | m_K6 | m_CORE2 | m_GENERIC),
+  ~(m_PENT | m_ATOM | m_K6 | m_CORE2 | m_GENERIC),
 
   /* X86_TUNE_USE_XCHGB: Use xchgb %rh,%rl instead of rolw/rorw $8,rx.  */
   m_PENT4,
@@ -1292,8 +1367,8 @@
   ~(m_PENT | m_PPRO),
 
   /* X86_TUNE_PROMOTE_QIMODE */
-  m_K6_GEODE | m_PENT | m_386 | m_486 | m_AMD_MULTIPLE | m_CORE2
-  | m_GENERIC /* | m_PENT4 ? */,
+  m_K6_GEODE | m_PENT | m_ATOM | m_386 | m_486 | m_AMD_MULTIPLE
+  | m_CORE2 | m_GENERIC /* | m_PENT4 ? */,
 
   /* X86_TUNE_FAST_PREFIX */
   ~(m_PENT | m_486 | m_386),
@@ -1317,26 +1392,28 @@
   m_PPRO,
 
   /* X86_TUNE_ADD_ESP_4: Enable if add/sub is preferred over 1/2 push/pop.  */
-  m_AMD_MULTIPLE | m_K6_GEODE | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
+  m_ATOM | m_AMD_MULTIPLE | m_K6_GEODE | m_PENT4 | m_NOCONA
+  | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_ADD_ESP_8 */
-  m_AMD_MULTIPLE | m_PPRO | m_K6_GEODE | m_386
+  m_AMD_MULTIPLE | m_ATOM | m_PPRO | m_K6_GEODE | m_386
   | m_486 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_SUB_ESP_4 */
-  m_AMD_MULTIPLE | m_PPRO | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
+  m_AMD_MULTIPLE | m_ATOM | m_PPRO | m_PENT4 | m_NOCONA | m_CORE2
+  | m_GENERIC,
 
   /* X86_TUNE_SUB_ESP_8 */
-  m_AMD_MULTIPLE | m_PPRO | m_386 | m_486
+  m_AMD_MULTIPLE | m_ATOM | m_PPRO | m_386 | m_486
   | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_INTEGER_DFMODE_MOVES: Enable if integer moves are preferred
      for DFmode copies */
-  ~(m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2
+  ~(m_AMD_MULTIPLE | m_ATOM | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2
     | m_GENERIC | m_GEODE),
 
   /* X86_TUNE_PARTIAL_REG_DEPENDENCY */
-  m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
+  m_AMD_MULTIPLE | m_ATOM | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY: In the Generic model we have a
      conflict here in between PPro/Pentium4 based chips that thread 128bit
@@ -1347,7 +1424,8 @@
      shows that disabling this option on P4 brings over 20% SPECfp regression,
      while enabling it on K8 brings roughly 2.4% regression that can be partly
      masked by careful scheduling of moves.  */
-  m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC | m_AMDFAM10,
+  m_ATOM | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC
+  | m_AMDFAM10,
 
   /* X86_TUNE_SSE_UNALIGNED_MOVE_OPTIMAL */
   m_AMDFAM10,
@@ -1365,13 +1443,13 @@
   m_PPRO | m_PENT4 | m_NOCONA,
 
   /* X86_TUNE_MEMORY_MISMATCH_STALL */
-  m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
+  m_AMD_MULTIPLE | m_ATOM | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_PROLOGUE_USING_MOVE */
-  m_ATHLON_K8 | m_PPRO | m_CORE2 | m_GENERIC,
+  m_ATHLON_K8 | m_ATOM | m_PPRO | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_EPILOGUE_USING_MOVE */
-  m_ATHLON_K8 | m_PPRO | m_CORE2 | m_GENERIC,
+  m_ATHLON_K8 | m_ATOM | m_PPRO | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_SHIFT1 */
   ~m_486,
@@ -1380,29 +1458,32 @@
   m_AMD_MULTIPLE,
 
   /* X86_TUNE_INTER_UNIT_MOVES */
-  ~(m_AMD_MULTIPLE | m_GENERIC),
+  ~(m_AMD_MULTIPLE | m_ATOM | m_GENERIC),
 
   /* X86_TUNE_INTER_UNIT_CONVERSIONS */
   ~(m_AMDFAM10),
 
   /* X86_TUNE_FOUR_JUMP_LIMIT: Some CPU cores are not able to predict more
      than 4 branch instructions in the 16 byte window.  */
-  m_PPRO | m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
+  m_ATOM | m_PPRO | m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_CORE2
+  | m_GENERIC,
 
   /* X86_TUNE_SCHEDULE */
-  m_PPRO | m_AMD_MULTIPLE | m_K6_GEODE | m_PENT | m_CORE2 | m_GENERIC,
+  m_PPRO | m_AMD_MULTIPLE | m_K6_GEODE | m_PENT | m_ATOM | m_CORE2
+  | m_GENERIC,
 
   /* X86_TUNE_USE_BT */
-  m_AMD_MULTIPLE | m_CORE2 | m_GENERIC,
+  m_AMD_MULTIPLE | m_ATOM | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_USE_INCDEC */
-  ~(m_PENT4 | m_NOCONA | m_GENERIC),
+  ~(m_PENT4 | m_NOCONA | m_GENERIC | m_ATOM),
 
   /* X86_TUNE_PAD_RETURNS */
   m_AMD_MULTIPLE | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_EXT_80387_CONSTANTS */
-  m_K6_GEODE | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC,
+  m_K6_GEODE | m_ATHLON_K8 | m_ATOM | m_PENT4 | m_NOCONA | m_PPRO
+  | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_SHORTEN_X87_SSE */
   ~m_K8,
@@ -1447,6 +1528,10 @@
      with a subsequent conditional jump instruction into a single
      compare-and-branch uop.  */
   m_CORE2,
+
+  /* X86_TUNE_OPT_AGU: Optimize for Address Generation Unit. This flag
+     will impact LEA instruction selection. */
+  m_ATOM,
 };
 
 /* Feature tests against the various architecture variations.  */
@@ -1472,10 +1557,11 @@
 };
 
 static const unsigned int x86_accumulate_outgoing_args
-  = m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC;
+  = m_AMD_MULTIPLE | m_ATOM | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2
+    | m_GENERIC;
 
 static const unsigned int x86_arch_always_fancy_math_387
-  = m_PENT | m_PPRO | m_AMD_MULTIPLE | m_PENT4
+  = m_PENT | m_ATOM | m_PPRO | m_AMD_MULTIPLE | m_PENT4
     | m_NOCONA | m_CORE2 | m_GENERIC;
 
 static enum stringop_alg stringop_alg = no_stringop;
@@ -1743,6 +1829,9 @@
 /* Alignment for incoming stack boundary in bits.  */
 unsigned int ix86_incoming_stack_boundary;
 
+/* The abi used by target.  */
+enum calling_abi ix86_abi;
+
 /* Values 1-5: see jump.c */
 int ix86_branch_cost;
 
@@ -1819,6 +1908,8 @@
 static bool ix86_can_inline_p (tree, tree);
 static void ix86_set_current_function (tree);
 
+static enum calling_abi ix86_function_abi (const_tree);
+
 
 /* The svr4 ABI for the i386 says that records and unions are returned
    in memory.  */
@@ -1880,6 +1971,7 @@
 #define OPTION_MASK_ISA_POPCNT_SET OPTION_MASK_ISA_POPCNT
 #define OPTION_MASK_ISA_CX16_SET OPTION_MASK_ISA_CX16
 #define OPTION_MASK_ISA_SAHF_SET OPTION_MASK_ISA_SAHF
+#define OPTION_MASK_ISA_MOVBE_SET OPTION_MASK_ISA_MOVBE
 
 /* Define a set of ISAs which aren't available when a given ISA is
    disabled.  MMX and SSE ISAs are handled separately.  */
@@ -1921,6 +2013,7 @@
 #define OPTION_MASK_ISA_POPCNT_UNSET OPTION_MASK_ISA_POPCNT
 #define OPTION_MASK_ISA_CX16_UNSET OPTION_MASK_ISA_CX16
 #define OPTION_MASK_ISA_SAHF_UNSET OPTION_MASK_ISA_SAHF
+#define OPTION_MASK_ISA_MOVBE_UNSET OPTION_MASK_ISA_MOVBE
 
 /* Vectorization library interface and handlers.  */
 tree (*ix86_veclib_handler)(enum built_in_function, tree, tree) = NULL;
@@ -1953,7 +2046,8 @@
   {&core2_cost, 16, 10, 16, 10, 16},
   {&generic32_cost, 16, 7, 16, 7, 16},
   {&generic64_cost, 16, 10, 16, 10, 16},
-  {&amdfam10_cost, 32, 24, 32, 7, 32}
+  {&amdfam10_cost, 32, 24, 32, 7, 32},
+  {&atom_cost, 16, 7, 16, 7, 16}
 };
 
 static const char *const cpu_names[TARGET_CPU_DEFAULT_max] =
@@ -1971,6 +2065,7 @@
   "prescott",
   "nocona",
   "core2",
+  "atom",
   "geode",
   "k6",
   "k6-2",
@@ -2209,6 +2304,19 @@
 	}
       return true;
 
+    case OPT_mmovbe:
+      if (value)
+	{
+	  ix86_isa_flags |= OPTION_MASK_ISA_MOVBE_SET;
+	  ix86_isa_flags_explicit |= OPTION_MASK_ISA_MOVBE_SET;
+	}
+      else
+	{
+	  ix86_isa_flags &= ~OPTION_MASK_ISA_MOVBE_UNSET;
+	  ix86_isa_flags_explicit |= OPTION_MASK_ISA_MOVBE_UNSET;
+	}
+      return true;
+
     case OPT_maes:
       if (value)
 	{
@@ -2271,6 +2379,7 @@
     { "-mmmx",		OPTION_MASK_ISA_MMX },
     { "-mabm",		OPTION_MASK_ISA_ABM },
     { "-mpopcnt",	OPTION_MASK_ISA_POPCNT },
+    { "-mmovbe",	OPTION_MASK_ISA_MOVBE },
     { "-maes",		OPTION_MASK_ISA_AES },
     { "-mpclmul",	OPTION_MASK_ISA_PCLMUL },
   };
@@ -2487,7 +2596,8 @@
       PTA_AES = 1 << 17,
       PTA_PCLMUL = 1 << 18,
       PTA_AVX = 1 << 19,
-      PTA_FMA = 1 << 20 
+      PTA_FMA = 1 << 20,
+      PTA_MOVBE = 1 << 21
     };
 
   static struct pta
@@ -2529,6 +2639,9 @@
       {"core2", PROCESSOR_CORE2, CPU_CORE2,
 	PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3
 	| PTA_SSSE3 | PTA_CX16},
+      {"atom", PROCESSOR_ATOM, CPU_ATOM,
+	PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3
+	| PTA_SSSE3 | PTA_CX16 | PTA_MOVBE},
       {"geode", PROCESSOR_GEODE, CPU_GEODE,
 	PTA_MMX | PTA_3DNOW | PTA_3DNOW_A |PTA_PREFETCH_SSE},
       {"k6", PROCESSOR_K6, CPU_K6, PTA_MMX},
@@ -2716,6 +2829,20 @@
     error ("bad value (%s) for %sarch=%s %s",
 	   ix86_arch_string, prefix, suffix, sw);
 
+  /* Validate -mabi= value.  */
+  if (ix86_abi_string)
+    {
+      if (strcmp (ix86_abi_string, "sysv") == 0)
+	ix86_abi = SYSV_ABI;
+      else if (strcmp (ix86_abi_string, "ms") == 0)
+	ix86_abi = MS_ABI;
+      else
+	error ("unknown ABI (%s) for %sabi=%s %s",
+	       ix86_abi_string, prefix, suffix, sw);
+    }
+  else
+    ix86_abi = DEFAULT_ABI;
+
   if (ix86_cmodel_string != 0)
     {
       if (!strcmp (ix86_cmodel_string, "small"))
@@ -2828,6 +2955,9 @@
 	if (!(TARGET_64BIT && (processor_alias_table[i].flags & PTA_NO_SAHF))
 	    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SAHF))
 	  ix86_isa_flags |= OPTION_MASK_ISA_SAHF;
+	if (processor_alias_table[i].flags & PTA_MOVBE
+	    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_MOVBE))
+	  ix86_isa_flags |= OPTION_MASK_ISA_MOVBE;
 	if (processor_alias_table[i].flags & PTA_AES
 	    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AES))
 	  ix86_isa_flags |= OPTION_MASK_ISA_AES;
@@ -4592,14 +4722,14 @@
      default ABI.  */
 
   /* RAX is used as hidden argument to va_arg functions.  */
-  if (DEFAULT_ABI == SYSV_ABI && regno == AX_REG)
+  if (ix86_abi == SYSV_ABI && regno == AX_REG)
     return true;
 
-  if (DEFAULT_ABI == MS_ABI)
+  if (ix86_abi == MS_ABI)
     parm_regs = x86_64_ms_abi_int_parameter_registers;
   else
     parm_regs = x86_64_int_parameter_registers;
-  for (i = 0; i < (DEFAULT_ABI == MS_ABI ? X64_REGPARM_MAX
+  for (i = 0; i < (ix86_abi == MS_ABI ? X64_REGPARM_MAX
   					 : X86_64_REGPARM_MAX); i++)
     if (regno == parm_regs[i])
       return true;
@@ -4627,7 +4757,7 @@
 int
 ix86_reg_parm_stack_space (const_tree fndecl)
 {
-  int call_abi = SYSV_ABI;
+  enum calling_abi call_abi = SYSV_ABI;
   if (fndecl != NULL_TREE && TREE_CODE (fndecl) == FUNCTION_DECL)
     call_abi = ix86_function_abi (fndecl);
   else
@@ -4639,37 +4769,39 @@
 
 /* Returns value SYSV_ABI, MS_ABI dependent on fntype, specifying the
    call abi used.  */
-int
+enum calling_abi
 ix86_function_type_abi (const_tree fntype)
 {
   if (TARGET_64BIT && fntype != NULL)
     {
-      int abi;
-      if (DEFAULT_ABI == SYSV_ABI)
-        abi = lookup_attribute ("ms_abi", TYPE_ATTRIBUTES (fntype)) ? MS_ABI : SYSV_ABI;
-      else
-        abi = lookup_attribute ("sysv_abi", TYPE_ATTRIBUTES (fntype)) ? SYSV_ABI : MS_ABI;
-
+      enum calling_abi abi = ix86_abi;
+      if (abi == SYSV_ABI)
+	{
+	  if (lookup_attribute ("ms_abi", TYPE_ATTRIBUTES (fntype)))
+	    abi = MS_ABI;
+	}
+      else if (lookup_attribute ("sysv_abi", TYPE_ATTRIBUTES (fntype)))
+	abi = SYSV_ABI;
       return abi;
     }
-  return DEFAULT_ABI;
+  return ix86_abi;
 }
 
-int
+static enum calling_abi
 ix86_function_abi (const_tree fndecl)
 {
   if (! fndecl)
-    return DEFAULT_ABI;
+    return ix86_abi;
   return ix86_function_type_abi (TREE_TYPE (fndecl));
 }
 
 /* Returns value SYSV_ABI, MS_ABI dependent on cfun, specifying the
    call abi used.  */
-int
+enum calling_abi
 ix86_cfun_abi (void)
 {
   if (! cfun || ! TARGET_64BIT)
-    return DEFAULT_ABI;
+    return ix86_abi;
   return cfun->machine->call_abi;
 }
 
@@ -4683,7 +4815,7 @@
 ix86_call_abi_override (const_tree fndecl)
 {
   if (fndecl == NULL_TREE)
-    cfun->machine->call_abi = DEFAULT_ABI;
+    cfun->machine->call_abi = ix86_abi;
   else
     cfun->machine->call_abi = ix86_function_type_abi (TREE_TYPE (fndecl));
 }
@@ -4724,8 +4856,8 @@
   cum->nregs = ix86_regparm;
   if (TARGET_64BIT)
     {
-      if (cum->call_abi != DEFAULT_ABI)
-        cum->nregs = DEFAULT_ABI != SYSV_ABI ? X86_64_REGPARM_MAX
+      if (cum->call_abi != ix86_abi)
+        cum->nregs = ix86_abi != SYSV_ABI ? X86_64_REGPARM_MAX
         				     : X64_REGPARM_MAX;
     }
   if (TARGET_SSE)
@@ -4733,8 +4865,8 @@
       cum->sse_nregs = SSE_REGPARM_MAX;
       if (TARGET_64BIT)
         {
-          if (cum->call_abi != DEFAULT_ABI)
-            cum->sse_nregs = DEFAULT_ABI != SYSV_ABI ? X86_64_SSE_REGPARM_MAX
+          if (cum->call_abi != ix86_abi)
+            cum->sse_nregs = ix86_abi != SYSV_ABI ? X86_64_SSE_REGPARM_MAX
             					     : X64_SSE_REGPARM_MAX;
         }
     }
@@ -5700,7 +5832,7 @@
   if (type)
     mode = type_natural_mode (type, NULL);
 
-  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)
+  if (TARGET_64BIT && (cum ? cum->call_abi : ix86_abi) == MS_ABI)
     function_arg_advance_ms_64 (cum, bytes, words);
   else if (TARGET_64BIT)
     function_arg_advance_64 (cum, mode, type, words, named);
@@ -5846,9 +5978,9 @@
   if (mode == VOIDmode)
     return GEN_INT (cum->maybe_vaarg
 		    ? (cum->sse_nregs < 0
-		       ? (cum->call_abi == DEFAULT_ABI
+		       ? (cum->call_abi == ix86_abi
 		          ? SSE_REGPARM_MAX
-		          : (DEFAULT_ABI != SYSV_ABI ? X86_64_SSE_REGPARM_MAX
+		          : (ix86_abi != SYSV_ABI ? X86_64_SSE_REGPARM_MAX
 		          			     : X64_SSE_REGPARM_MAX))
  	       : cum->sse_regno)
 		    : -1);
@@ -5942,7 +6074,7 @@
   if (type && TREE_CODE (type) == VECTOR_TYPE)
     mode = type_natural_mode (type, cum);
 
-  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)
+  if (TARGET_64BIT && (cum ? cum->call_abi : ix86_abi) == MS_ABI)
     return function_arg_ms_64 (cum, mode, omode, named, bytes);
   else if (TARGET_64BIT)
     return function_arg_64 (cum, mode, omode, type, named);
@@ -5962,7 +6094,7 @@
 			const_tree type, bool named ATTRIBUTE_UNUSED)
 {
   /* See Windows x64 Software Convention.  */
-  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)
+  if (TARGET_64BIT && (cum ? cum->call_abi : ix86_abi) == MS_ABI)
     {
       int msize = (int) GET_MODE_SIZE (mode);
       if (type)
@@ -6102,7 +6234,7 @@
       /* TODO: The function should depend on current function ABI but
        builtins.c would need updating then. Therefore we use the
        default ABI.  */
-      if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)
+      if (TARGET_64BIT && ix86_abi == MS_ABI)
 	return false;
       return TARGET_FLOAT_RETURNS_IN_80387;
 
@@ -6498,13 +6630,13 @@
 static tree
 ix86_build_builtin_va_list (void)
 {
-  tree ret = ix86_build_builtin_va_list_abi (DEFAULT_ABI);
+  tree ret = ix86_build_builtin_va_list_abi (ix86_abi);
 
   /* Initialize abi specific va_list builtin types.  */
   if (TARGET_64BIT)
     {
       tree t;
-      if (DEFAULT_ABI == MS_ABI)
+      if (ix86_abi == MS_ABI)
         {
           t = ix86_build_builtin_va_list_abi (SYSV_ABI);
           if (TREE_CODE (t) != RECORD_TYPE)
@@ -6518,7 +6650,7 @@
             t = build_variant_type_copy (t);
           sysv_va_list_type_node = t;
         }
-      if (DEFAULT_ABI != MS_ABI)
+      if (ix86_abi != MS_ABI)
         {
           t = ix86_build_builtin_va_list_abi (MS_ABI);
           if (TREE_CODE (t) != RECORD_TYPE)
@@ -6551,8 +6683,8 @@
   int i;
   int regparm = ix86_regparm;
 
-  if (cum->call_abi != DEFAULT_ABI)
-    regparm = DEFAULT_ABI != SYSV_ABI ? X86_64_REGPARM_MAX : X64_REGPARM_MAX;
+  if (cum->call_abi != ix86_abi)
+    regparm = ix86_abi != SYSV_ABI ? X86_64_REGPARM_MAX : X64_REGPARM_MAX;
 
   /* GPR size of varargs save area.  */
   if (cfun->va_list_gpr_size)
@@ -6705,7 +6837,7 @@
     return true;
   canonic = ix86_canonical_va_list_type (type);
   return (canonic == ms_va_list_type_node
-          || (DEFAULT_ABI == MS_ABI && canonic == va_list_type_node));
+          || (ix86_abi == MS_ABI && canonic == va_list_type_node));
 }
 
 /* Implement va_start.  */
@@ -12987,6 +13119,316 @@
     emit_move_insn (operands[0], dst);
 }
 
+#define LEA_SEARCH_THRESHOLD 12
+
+/* Search backward for non-agu definition of register number REGNO1
+   or register number REGNO2 in INSN's basic block until 
+   1. Pass LEA_SEARCH_THRESHOLD instructions, or
+   2. Reach BB boundary, or
+   3. Reach agu definition.
+   Returns the distance between the non-agu definition point and INSN.
+   If no definition point, returns -1.  */
+
+static int
+distance_non_agu_define (unsigned int regno1, unsigned int regno2,
+			 rtx insn)
+{
+  basic_block bb = BLOCK_FOR_INSN (insn);
+  int distance = 0;
+  df_ref *def_rec;
+  enum attr_type insn_type;
+
+  if (insn != BB_HEAD (bb))
+    {
+      rtx prev = PREV_INSN (insn);
+      while (prev && distance < LEA_SEARCH_THRESHOLD)
+	{
+	  if (INSN_P (prev))
+	    {
+	      distance++;
+              for (def_rec = DF_INSN_DEFS (prev); *def_rec; def_rec++)
+                if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF
+                    && !DF_REF_IS_ARTIFICIAL (*def_rec)
+                    && (regno1 == DF_REF_REGNO (*def_rec)
+			|| regno2 == DF_REF_REGNO (*def_rec)))
+		  {
+		    insn_type = get_attr_type (prev);
+		    if (insn_type != TYPE_LEA)
+		      goto done;
+		  }
+	    }
+	  if (prev == BB_HEAD (bb))
+	    break;
+	  prev = PREV_INSN (prev);
+	}
+    }
+  
+  if (distance < LEA_SEARCH_THRESHOLD)
+    {
+      edge e;
+      edge_iterator ei;
+      bool simple_loop = false;
+  
+      FOR_EACH_EDGE (e, ei, bb->preds)
+	if (e->src == bb)
+	  {
+	    simple_loop = true;
+	    break;
+	  }
+  
+      if (simple_loop)
+	{
+	  rtx prev = BB_END (bb);
+	  while (prev
+		 && prev != insn
+		 && distance < LEA_SEARCH_THRESHOLD)
+	    {
+	      if (INSN_P (prev))
+		{
+		  distance++;
+		  for (def_rec = DF_INSN_DEFS (prev); *def_rec; def_rec++)
+		    if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF
+			&& !DF_REF_IS_ARTIFICIAL (*def_rec)
+			&& (regno1 == DF_REF_REGNO (*def_rec)
+			    || regno2 == DF_REF_REGNO (*def_rec)))
+		      {
+			insn_type = get_attr_type (prev);
+			if (insn_type != TYPE_LEA)
+			  goto done;
+		      }
+		}
+	      prev = PREV_INSN (prev);
+	    }
+	}
+    }
+
+  distance = -1;
+
+done:
+  /* get_attr_type may modify recog data.  We want to make sure
+     that recog data is valid for instruction INSN, on which
+     distance_non_agu_define is called.  INSN is unchanged here.  */
+  extract_insn_cached (insn);
+  return distance;
+}
+
+/* Return the distance between INSN and the next insn that uses 
+   register number REGNO0 in memory address.  Return -1 if no such
+   a use is found within LEA_SEARCH_THRESHOLD or REGNO0 is set.  */
+
+static int
+distance_agu_use (unsigned int regno0, rtx insn)
+{
+  basic_block bb = BLOCK_FOR_INSN (insn);
+  int distance = 0;
+  df_ref *def_rec;
+  df_ref *use_rec;
+
+  if (insn != BB_END (bb))
+    {
+      rtx next = NEXT_INSN (insn);
+      while (next && distance < LEA_SEARCH_THRESHOLD)
+	{
+	  if (INSN_P (next))
+	    {
+	      distance++;
+
+	      for (use_rec = DF_INSN_USES (next); *use_rec; use_rec++)
+		if ((DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_LOAD
+		     || DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_STORE)
+		    && regno0 == DF_REF_REGNO (*use_rec))
+		  {
+		    /* Return DISTANCE if OP0 is used in memory
+		       address in NEXT.  */
+		    return distance;
+		  }
+
+	      for (def_rec = DF_INSN_DEFS (next); *def_rec; def_rec++)
+		if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF
+		    && !DF_REF_IS_ARTIFICIAL (*def_rec)
+		    && regno0 == DF_REF_REGNO (*def_rec))
+		  {
+		    /* Return -1 if OP0 is set in NEXT.  */
+		    return -1;
+		  }
+	    }
+	  if (next == BB_END (bb))
+	    break;
+	  next = NEXT_INSN (next);
+	}
+    }
+
+  if (distance < LEA_SEARCH_THRESHOLD)
+    {
+      edge e;
+      edge_iterator ei;
+      bool simple_loop = false;
+  
+      FOR_EACH_EDGE (e, ei, bb->succs)
+        if (e->dest == bb)
+	  {
+	    simple_loop = true;
+	    break;
+	  }
+  
+      if (simple_loop)
+	{
+	  rtx next = BB_HEAD (bb);
+	  while (next
+		 && next != insn
+		 && distance < LEA_SEARCH_THRESHOLD)
+	    {
+	      if (INSN_P (next))
+		{
+		  distance++;
+
+		  for (use_rec = DF_INSN_USES (next); *use_rec; use_rec++)
+		    if ((DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_LOAD
+			 || DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_STORE)
+			&& regno0 == DF_REF_REGNO (*use_rec))
+		      {
+			/* Return DISTANCE if OP0 is used in memory
+			   address in NEXT.  */
+			return distance;
+		      }
+
+		  for (def_rec = DF_INSN_DEFS (next); *def_rec; def_rec++)
+		    if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF
+			&& !DF_REF_IS_ARTIFICIAL (*def_rec)
+			&& regno0 == DF_REF_REGNO (*def_rec))
+		      {
+			/* Return -1 if OP0 is set in NEXT.  */
+			return -1;
+		      }
+
+		}
+	      next = NEXT_INSN (next);
+	    }
+	}
+    }  
+
+  return -1;
+}
+
+/* Define this macro to tune LEA priority vs ADD, it take effect when
+   there is a dilemma of choicing LEA or ADD
+   Negative value: ADD is more preferred than LEA
+   Zero: Netrual
+   Positive value: LEA is more preferred than ADD*/
+#define IX86_LEA_PRIORITY 2
+
+/* Return true if it is ok to optimize an ADD operation to LEA
+   operation to avoid flag register consumation.  For the processors
+   like ATOM, if the destination register of LEA holds an actual
+   address which will be used soon, LEA is better and otherwise ADD
+   is better.  */
+
+bool
+ix86_lea_for_add_ok (enum rtx_code code ATTRIBUTE_UNUSED,
+                     rtx insn, rtx operands[])
+{
+  unsigned int regno0 = true_regnum (operands[0]);
+  unsigned int regno1 = true_regnum (operands[1]);
+  unsigned int regno2;
+
+  if (!TARGET_OPT_AGU || optimize_function_for_size_p (cfun))
+    return regno0 != regno1;
+
+  regno2 = true_regnum (operands[2]);
+
+  /* If a = b + c, (a!=b && a!=c), must use lea form. */
+  if (regno0 != regno1 && regno0 != regno2)
+    return true;
+  else    
+    {
+      int dist_define, dist_use;
+      dist_define = distance_non_agu_define (regno1, regno2, insn);
+      if (dist_define <= 0)
+        return true;
+
+      /* If this insn has both backward non-agu dependence and forward
+         agu dependence, the one with short distance take effect. */
+      dist_use = distance_agu_use (regno0, insn);
+      if (dist_use <= 0
+	  || (dist_define + IX86_LEA_PRIORITY) < dist_use)
+        return false;
+
+      return true;
+    }
+}
+
+/* Return true if destination reg of SET_BODY is shift count of
+   USE_BODY.  */
+
+static bool
+ix86_dep_by_shift_count_body (const_rtx set_body, const_rtx use_body)
+{
+  rtx set_dest;
+  rtx shift_rtx;
+  int i;
+
+  /* Retrieve destination of SET_BODY.  */
+  switch (GET_CODE (set_body))
+    {
+    case SET:
+      set_dest = SET_DEST (set_body);
+      if (!set_dest || !REG_P (set_dest))
+	return false;
+      break;
+    case PARALLEL:
+      for (i = XVECLEN (set_body, 0) - 1; i >= 0; i--)
+	if (ix86_dep_by_shift_count_body (XVECEXP (set_body, 0, i),
+					  use_body))
+	  return true;
+    default:
+      return false;
+      break;
+    }
+
+  /* Retrieve shift count of USE_BODY.  */
+  switch (GET_CODE (use_body))
+    {
+    case SET:
+      shift_rtx = XEXP (use_body, 1);
+      break;
+    case PARALLEL:
+      for (i = XVECLEN (use_body, 0) - 1; i >= 0; i--)
+	if (ix86_dep_by_shift_count_body (set_body,
+					  XVECEXP (use_body, 0, i)))
+	  return true;
+    default:
+      return false;
+      break;
+    }
+
+  if (shift_rtx 
+      && (GET_CODE (shift_rtx) == ASHIFT
+	  || GET_CODE (shift_rtx) == LSHIFTRT
+	  || GET_CODE (shift_rtx) == ASHIFTRT
+	  || GET_CODE (shift_rtx) == ROTATE
+	  || GET_CODE (shift_rtx) == ROTATERT))
+    {
+      rtx shift_count = XEXP (shift_rtx, 1);
+
+      /* Return true if shift count is dest of SET_BODY.  */
+      if (REG_P (shift_count)
+	  && true_regnum (set_dest) == true_regnum (shift_count))
+	return true;
+    }
+
+  return false;
+}
+
+/* Return true if destination reg of SET_INSN is shift count of
+   USE_INSN.  */
+
+bool
+ix86_dep_by_shift_count (const_rtx set_insn, const_rtx use_insn)
+{
+  return ix86_dep_by_shift_count_body (PATTERN (set_insn),
+				       PATTERN (use_insn));
+}
+
 /* Return TRUE or FALSE depending on whether the unary operator meets the
    appropriate constraints.  */
 
@@ -18838,7 +19280,7 @@
   f = GGC_CNEW (struct machine_function);
   f->use_fast_prologue_epilogue_nregs = -1;
   f->tls_descriptor_call_expanded_p = 0;
-  f->call_abi = DEFAULT_ABI;
+  f->call_abi = ix86_abi;
 
   return f;
 }
@@ -19099,6 +19541,7 @@
   switch (ix86_tune)
     {
     case PROCESSOR_PENTIUM:
+    case PROCESSOR_ATOM:
     case PROCESSOR_K6:
       return 2;
 
@@ -19165,41 +19608,21 @@
   return 1;
 }
 
-/* A subroutine of ix86_adjust_cost -- return true iff INSN has a memory
-   address with operands set by DEP_INSN.  */
+/* Return true iff USE_INSN has a memory address with operands set by
+   SET_INSN.  */
 
-static int
-ix86_agi_dependent (rtx insn, rtx dep_insn, enum attr_type insn_type)
+bool
+ix86_agi_dependent (rtx set_insn, rtx use_insn)
 {
-  rtx addr;
-
-  if (insn_type == TYPE_LEA
-      && TARGET_PENTIUM)
-    {
-      addr = PATTERN (insn);
-
-      if (GET_CODE (addr) == PARALLEL)
-	addr = XVECEXP (addr, 0, 0);
-
-      gcc_assert (GET_CODE (addr) == SET);
-
-      addr = SET_SRC (addr);
-    }
-  else
-    {
-      int i;
-      extract_insn_cached (insn);
-      for (i = recog_data.n_operands - 1; i >= 0; --i)
-	if (MEM_P (recog_data.operand[i]))
-	  {
-	    addr = XEXP (recog_data.operand[i], 0);
-	    goto found;
-	  }
-      return 0;
-    found:;
-    }
-
-  return modified_in_p (addr, dep_insn);
+  int i;
+  extract_insn_cached (use_insn);
+  for (i = recog_data.n_operands - 1; i >= 0; --i)
+    if (MEM_P (recog_data.operand[i]))
+      {
+	rtx addr = XEXP (recog_data.operand[i], 0);
+	return modified_in_p (addr, set_insn) != 0;
+      }
+  return false;
 }
 
 static int
@@ -19227,7 +19650,20 @@
     {
     case PROCESSOR_PENTIUM:
       /* Address Generation Interlock adds a cycle of latency.  */
-      if (ix86_agi_dependent (insn, dep_insn, insn_type))
+      if (insn_type == TYPE_LEA)
+	{
+	  rtx addr = PATTERN (insn);
+
+	  if (GET_CODE (addr) == PARALLEL)
+	    addr = XVECEXP (addr, 0, 0);
+
+	  gcc_assert (GET_CODE (addr) == SET);
+
+	  addr = SET_SRC (addr);
+	  if (modified_in_p (addr, dep_insn))
+	    cost += 1;
+	}
+      else if (ix86_agi_dependent (dep_insn, insn))
 	cost += 1;
 
       /* ??? Compares pair with jump/setcc.  */
@@ -19237,7 +19673,7 @@
       /* Floating point stores require value to be ready one cycle earlier.  */
       if (insn_type == TYPE_FMOV
 	  && get_attr_memory (insn) == MEMORY_STORE
-	  && !ix86_agi_dependent (insn, dep_insn, insn_type))
+	  && !ix86_agi_dependent (dep_insn, insn))
 	cost += 1;
       break;
 
@@ -19260,7 +19696,7 @@
 	 in parallel with previous instruction in case
 	 previous instruction is not needed to compute the address.  */
       if ((memory == MEMORY_LOAD || memory == MEMORY_BOTH)
-	  && !ix86_agi_dependent (insn, dep_insn, insn_type))
+	  && !ix86_agi_dependent (dep_insn, insn))
 	{
 	  /* Claim moves to take one cycle, as core can issue one load
 	     at time and the next load can start cycle later.  */
@@ -19289,7 +19725,7 @@
 	 in parallel with previous instruction in case
 	 previous instruction is not needed to compute the address.  */
       if ((memory == MEMORY_LOAD || memory == MEMORY_BOTH)
-	  && !ix86_agi_dependent (insn, dep_insn, insn_type))
+	  && !ix86_agi_dependent (dep_insn, insn))
 	{
 	  /* Claim moves to take one cycle, as core can issue one load
 	     at time and the next load can start cycle later.  */
@@ -19306,6 +19742,7 @@
     case PROCESSOR_ATHLON:
     case PROCESSOR_K8:
     case PROCESSOR_AMDFAM10:
+    case PROCESSOR_ATOM:
     case PROCESSOR_GENERIC32:
     case PROCESSOR_GENERIC64:
       memory = get_attr_memory (insn);
@@ -19314,7 +19751,7 @@
 	 in parallel with previous instruction in case
 	 previous instruction is not needed to compute the address.  */
       if ((memory == MEMORY_LOAD || memory == MEMORY_BOTH)
-	  && !ix86_agi_dependent (insn, dep_insn, insn_type))
+	  && !ix86_agi_dependent (dep_insn, insn))
 	{
 	  enum attr_unit unit = get_attr_unit (insn);
 	  int loadcost = 3;
@@ -29594,14 +30031,11 @@
 tree
 ix86_fn_abi_va_list (tree fndecl)
 {
-  int abi;
-
   if (!TARGET_64BIT)
     return va_list_type_node;
   gcc_assert (fndecl != NULL_TREE);
-  abi = ix86_function_abi ((const_tree) fndecl);
 
-  if (abi == MS_ABI)
+  if (ix86_function_abi ((const_tree) fndecl) == MS_ABI)
     return ms_va_list_type_node;
   else
     return sysv_va_list_type_node;
diff -Nur a/gcc/config/i386/i386-c.c b/gcc/config/i386/i386-c.c
--- a/gcc/config/i386/i386-c.c	2008-08-31 01:50:40.000000000 +0200
+++ b/gcc/config/i386/i386-c.c	2010-01-25 09:50:29.005686600 +0100
@@ -119,6 +119,10 @@
       def_or_undef (parse_in, "__core2");
       def_or_undef (parse_in, "__core2__");
       break;
+    case PROCESSOR_ATOM:
+      def_or_undef (parse_in, "__atom");
+      def_or_undef (parse_in, "__atom__");
+      break;
     /* use PROCESSOR_max to not set/unset the arch macro.  */
     case PROCESSOR_max:
       break;
@@ -187,6 +191,9 @@
     case PROCESSOR_CORE2:
       def_or_undef (parse_in, "__tune_core2__");
       break;
+    case PROCESSOR_ATOM:
+      def_or_undef (parse_in, "__tune_atom__");
+      break;
     case PROCESSOR_GENERIC32:
     case PROCESSOR_GENERIC64:
       break;
diff -Nur a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
--- a/gcc/config/i386/i386.h	2009-07-11 21:06:26.000000000 +0200
+++ b/gcc/config/i386/i386.h	2010-01-25 09:50:29.005686600 +0100
@@ -59,6 +59,7 @@
 #define TARGET_ABM	OPTION_ISA_ABM
 #define TARGET_POPCNT	OPTION_ISA_POPCNT
 #define TARGET_SAHF	OPTION_ISA_SAHF
+#define TARGET_MOVBE	OPTION_ISA_MOVBE
 #define TARGET_AES	OPTION_ISA_AES
 #define TARGET_PCLMUL	OPTION_ISA_PCLMUL
 #define TARGET_CMPXCHG16B OPTION_ISA_CX16
@@ -236,6 +237,7 @@
 #define TARGET_GENERIC64 (ix86_tune == PROCESSOR_GENERIC64)
 #define TARGET_GENERIC (TARGET_GENERIC32 || TARGET_GENERIC64)
 #define TARGET_AMDFAM10 (ix86_tune == PROCESSOR_AMDFAM10)
+#define TARGET_ATOM (ix86_tune == PROCESSOR_ATOM)
 
 /* Feature tests against the various tunings.  */
 enum ix86_tune_indices {
@@ -300,6 +302,7 @@
   X86_TUNE_USE_VECTOR_FP_CONVERTS,
   X86_TUNE_USE_VECTOR_CONVERTS,
   X86_TUNE_FUSE_CMP_AND_BRANCH,
+  X86_TUNE_OPT_AGU,
 
   X86_TUNE_LAST
 };
@@ -387,6 +390,7 @@
 	ix86_tune_features[X86_TUNE_USE_VECTOR_CONVERTS]
 #define TARGET_FUSE_CMP_AND_BRANCH \
 	ix86_tune_features[X86_TUNE_FUSE_CMP_AND_BRANCH]
+#define TARGET_OPT_AGU ix86_tune_features[X86_TUNE_OPT_AGU]
 
 /* Feature tests against the various architecture variations.  */
 enum ix86_arch_indices {
@@ -470,7 +474,10 @@
   MS_ABI = 1
 };
 
-/* The default abi form used by target.  */
+/* The abi used by target.  */
+extern enum calling_abi ix86_abi;
+
+/* The default abi used by target.  */
 #define DEFAULT_ABI SYSV_ABI
 
 /* Subtargets may reset this to 1 in order to enable 96-bit long double
@@ -569,6 +576,7 @@
   TARGET_CPU_DEFAULT_prescott,
   TARGET_CPU_DEFAULT_nocona,
   TARGET_CPU_DEFAULT_core2,
+  TARGET_CPU_DEFAULT_atom,
 
   TARGET_CPU_DEFAULT_geode,
   TARGET_CPU_DEFAULT_k6,
@@ -658,7 +666,7 @@
 
 /* Boundary (in *bits*) on which stack pointer should be aligned.  */
 #define STACK_BOUNDARY \
- (TARGET_64BIT && DEFAULT_ABI == MS_ABI ? 128 : BITS_PER_WORD)
+ (TARGET_64BIT && ix86_abi == MS_ABI ? 128 : BITS_PER_WORD)
 
 /* Stack boundary of the main function guaranteed by OS.  */
 #define MAIN_STACK_BOUNDARY (TARGET_64BIT ? 128 : 32)
@@ -1584,7 +1592,7 @@
   int maybe_vaarg;		/* true for calls to possibly vardic fncts.  */
   int float_in_sse;		/* 1 if in 32-bit mode SFmode (2 for DFmode) should
 				   be passed in SSE registers.  Otherwise 0.  */
-  int call_abi;			/* Set to SYSV_ABI for sysv abi. Otherwise
+  enum calling_abi call_abi;	/* Set to SYSV_ABI for sysv abi. Otherwise
  				   MS_ABI for ms abi.  */
 } CUMULATIVE_ARGS;
 
@@ -2230,6 +2238,7 @@
   PROCESSOR_GENERIC32,
   PROCESSOR_GENERIC64,
   PROCESSOR_AMDFAM10,
+  PROCESSOR_ATOM,
   PROCESSOR_max
 };
 
@@ -2403,7 +2412,7 @@
   int tls_descriptor_call_expanded_p;
   /* This value is used for amd64 targets and specifies the current abi
      to be used. MS_ABI means ms abi. Otherwise SYSV_ABI means sysv abi.  */
-  int call_abi;
+   enum calling_abi call_abi;
 };
 
 #define ix86_stack_locals (cfun->machine->stack_locals)
diff -Nur a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
--- a/gcc/config/i386/i386.md	2009-07-08 18:59:15.000000000 +0200
+++ b/gcc/config/i386/i386.md	2010-01-25 09:50:29.015687523 +0100
@@ -316,7 +316,7 @@
 
 
 ;; Processor type.
-(define_attr "cpu" "none,pentium,pentiumpro,geode,k6,athlon,k8,core2,
+(define_attr "cpu" "none,pentium,pentiumpro,geode,k6,athlon,k8,core2,atom,
 		    generic64,amdfam10"
   (const (symbol_ref "ix86_schedule")))
 
@@ -612,6 +612,12 @@
 (define_attr "i387_cw" "trunc,floor,ceil,mask_pm,uninitialized,any"
   (const_string "any"))
 
+;; Define attribute to classify add/sub insns that consumes carry flag (CF)
+(define_attr "use_carry" "0,1" (const_string "0"))
+
+;; Define attribute to indicate unaligned ssemov insns
+(define_attr "movu" "0,1" (const_string "0"))
+
 ;; Describe a user's asm statement.
 (define_asm_attributes
   [(set_attr "length" "128")
@@ -727,6 +733,7 @@
 (include "k6.md")
 (include "athlon.md")
 (include "geode.md")
+(include "atom.md")
 
 
 ;; Operand and operator predicates and constraints
@@ -5790,6 +5797,7 @@
   "TARGET_64BIT && ix86_binary_operator_ok (PLUS, DImode, operands)"
   "adc{q}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "DI")])
 
@@ -5864,6 +5872,7 @@
   "ix86_binary_operator_ok (PLUS, QImode, operands)"
   "adc{b}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "QI")])
 
@@ -5876,6 +5885,7 @@
   "ix86_binary_operator_ok (PLUS, HImode, operands)"
   "adc{w}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "HI")])
 
@@ -5888,6 +5898,7 @@
   "ix86_binary_operator_ok (PLUS, SImode, operands)"
   "adc{l}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
@@ -5901,6 +5912,7 @@
   "TARGET_64BIT && ix86_binary_operator_ok (PLUS, SImode, operands)"
   "adc{l}\t{%2, %k0|%k0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
@@ -6130,9 +6142,9 @@
    (set_attr "mode" "SI")])
 
 (define_insn "*adddi_1_rex64"
-  [(set (match_operand:DI 0 "nonimmediate_operand" "=r,rm,r")
-	(plus:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0,r")
-		 (match_operand:DI 2 "x86_64_general_operand" "rme,re,le")))
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=r,rm,r,r")
+	(plus:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0,r,r")
+		 (match_operand:DI 2 "x86_64_general_operand" "rme,re,0,le")))
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_64BIT && ix86_binary_operator_ok (PLUS, DImode, operands)"
 {
@@ -6153,6 +6165,10 @@
 	}
 
     default:
+      /* Use add as much as possible to replace lea for AGU optimization. */
+      if (which_alternative == 2 && TARGET_OPT_AGU)
+        return "add{q}\t{%1, %0|%0, %1}";
+        
       gcc_assert (rtx_equal_p (operands[0], operands[1]));
 
       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.
@@ -6171,8 +6187,11 @@
     }
 }
   [(set (attr "type")
-     (cond [(eq_attr "alternative" "2")
+     (cond [(and (eq_attr "alternative" "2") 
+                 (eq (symbol_ref "TARGET_OPT_AGU") (const_int 0)))
 	      (const_string "lea")
+            (eq_attr "alternative" "3")
+              (const_string "lea")
 	    ; Current assemblers are broken and do not allow @GOTOFF in
 	    ; ought but a memory context.
 	    (match_operand:DI 2 "pic_symbolic_operand" "")
@@ -6189,8 +6208,8 @@
 	(plus:DI (match_operand:DI 1 "register_operand" "")
 		 (match_operand:DI 2 "x86_64_nonmemory_operand" "")))
    (clobber (reg:CC FLAGS_REG))]
-  "TARGET_64BIT && reload_completed
-   && true_regnum (operands[0]) != true_regnum (operands[1])"
+  "TARGET_64BIT && reload_completed 
+   && ix86_lea_for_add_ok (PLUS, insn, operands)"
   [(set (match_dup 0)
 	(plus:DI (match_dup 1)
 		 (match_dup 2)))]
@@ -6394,9 +6413,9 @@
 
 
 (define_insn "*addsi_1"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,rm,r")
-	(plus:SI (match_operand:SI 1 "nonimmediate_operand" "%0,0,r")
-		 (match_operand:SI 2 "general_operand" "g,ri,li")))
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,rm,r,r")
+	(plus:SI (match_operand:SI 1 "nonimmediate_operand" "%0,0,r,r")
+		 (match_operand:SI 2 "general_operand" "g,ri,0,li")))
    (clobber (reg:CC FLAGS_REG))]
   "ix86_binary_operator_ok (PLUS, SImode, operands)"
 {
@@ -6417,6 +6436,10 @@
 	}
 
     default:
+      /* Use add as much as possible to replace lea for AGU optimization. */
+      if (which_alternative == 2 && TARGET_OPT_AGU)
+        return "add{l}\t{%1, %0|%0, %1}";
+
       gcc_assert (rtx_equal_p (operands[0], operands[1]));
 
       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.
@@ -6433,7 +6456,10 @@
     }
 }
   [(set (attr "type")
-     (cond [(eq_attr "alternative" "2")
+     (cond [(and (eq_attr "alternative" "2") 
+                 (eq (symbol_ref "TARGET_OPT_AGU") (const_int 0)))
+               (const_string "lea")
+            (eq_attr "alternative" "3")
 	      (const_string "lea")
 	    ; Current assemblers are broken and do not allow @GOTOFF in
 	    ; ought but a memory context.
@@ -6451,8 +6477,7 @@
 	(plus (match_operand 1 "register_operand" "")
               (match_operand 2 "nonmemory_operand" "")))
    (clobber (reg:CC FLAGS_REG))]
-  "reload_completed
-   && true_regnum (operands[0]) != true_regnum (operands[1])"
+  "reload_completed && ix86_lea_for_add_ok (PLUS, insn, operands)" 
   [(const_int 0)]
 {
   rtx pat;
@@ -7553,6 +7578,7 @@
   "TARGET_64BIT && ix86_binary_operator_ok (MINUS, DImode, operands)"
   "sbb{q}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "DI")])
 
@@ -7601,6 +7627,7 @@
   "ix86_binary_operator_ok (MINUS, QImode, operands)"
   "sbb{b}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "QI")])
 
@@ -7613,6 +7640,7 @@
   "ix86_binary_operator_ok (MINUS, HImode, operands)"
   "sbb{w}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "HI")])
 
@@ -7625,6 +7653,7 @@
   "ix86_binary_operator_ok (MINUS, SImode, operands)"
   "sbb{l}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
@@ -15155,7 +15184,7 @@
 		     ? gen_rtx_REG (XCmode, FIRST_FLOAT_REG) : NULL),
 		    operands[0], const0_rtx,
 		    GEN_INT ((TARGET_64BIT
-			      ? (DEFAULT_ABI == SYSV_ABI
+			      ? (ix86_abi == SYSV_ABI
 				 ? X86_64_SSE_REGPARM_MAX
 				 : X64_SSE_REGPARM_MAX)
 			      : X86_32_SSE_REGPARM_MAX)
@@ -15235,6 +15264,7 @@
   "reload_completed"
   "ret"
   [(set_attr "length" "1")
+   (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "0")
    (set_attr "modrm" "0")])
 
@@ -15247,6 +15277,7 @@
   "reload_completed"
   "rep\;ret"
   [(set_attr "length" "1")
+   (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "0")
    (set_attr "prefix_rep" "1")
    (set_attr "modrm" "0")])
@@ -15257,6 +15288,7 @@
   "reload_completed"
   "ret\t%0"
   [(set_attr "length" "3")
+   (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "2")
    (set_attr "modrm" "0")])
 
@@ -15610,7 +15642,7 @@
 	(bswap:SI (match_operand:SI 1 "register_operand" "")))]
   ""
 {
-  if (!TARGET_BSWAP)
+  if (!(TARGET_BSWAP || TARGET_MOVBE))
     {
       rtx x = operands[0];
 
@@ -15622,6 +15654,21 @@
     }
 })
 
+(define_insn "*bswapsi_movbe"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,m")
+	(bswap:SI (match_operand:SI 1 "nonimmediate_operand" "0,m,r")))]
+  "TARGET_MOVBE && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
+  "@
+    bswap\t%0
+    movbe\t{%1, %0|%0, %1}
+    movbe\t{%1, %0|%0, %1}"
+  [(set_attr "type" "*,imov,imov")
+   (set_attr "modrm" "*,1,1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "prefix_extra" "*,1,1")
+   (set_attr "length" "2,*,*")
+   (set_attr "mode" "SI")])
+
 (define_insn "*bswapsi_1"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(bswap:SI (match_operand:SI 1 "register_operand" "0")))]
@@ -15650,7 +15697,29 @@
   [(set_attr "length" "4")
    (set_attr "mode" "HI")])
 
-(define_insn "bswapdi2"
+(define_expand "bswapdi2"
+  [(set (match_operand:DI 0 "register_operand" "")
+	(bswap:DI (match_operand:DI 1 "register_operand" "")))]
+  "TARGET_64BIT"
+  "")
+
+(define_insn "*bswapdi_movbe"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=r,r,m")
+	(bswap:DI (match_operand:DI 1 "nonimmediate_operand" "0,m,r")))]
+  "TARGET_64BIT && TARGET_MOVBE
+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
+  "@
+    bswap\t%0
+    movbe\t{%1, %0|%0, %1}
+    movbe\t{%1, %0|%0, %1}"
+  [(set_attr "type" "*,imov,imov")
+   (set_attr "modrm" "*,1,1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "prefix_extra" "*,1,1")
+   (set_attr "length" "3,*,*")
+   (set_attr "mode" "DI")])
+
+(define_insn "*bswapdi_1"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(bswap:DI (match_operand:DI 1 "register_operand" "0")))]
   "TARGET_64BIT"
@@ -16378,6 +16447,7 @@
   "TARGET_SSE_MATH"
   "%vrcpss\t{%1, %d0|%d0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "rcp")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "SF")])
 
@@ -16729,6 +16799,7 @@
   "TARGET_SSE_MATH"
   "%vrsqrtss\t{%1, %d0|%d0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "rcp")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "SF")])
 
@@ -16749,6 +16820,7 @@
   "SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH"
   "%vsqrts<ssemodefsuffix>\t{%1, %d0|%d0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "sqrt")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "<MODE>")
    (set_attr "athlon_decode" "*")
@@ -19802,6 +19874,7 @@
   ; Since we don't have the proper number of operands for an alu insn,
   ; fill in all the blanks.
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "memory" "none")
    (set_attr "imm_disp" "false")
@@ -19817,6 +19890,7 @@
   ""
   "sbb{q}\t%0, %0"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "memory" "none")
    (set_attr "imm_disp" "false")
@@ -19860,6 +19934,7 @@
   ; Since we don't have the proper number of operands for an alu insn,
   ; fill in all the blanks.
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "memory" "none")
    (set_attr "imm_disp" "false")
@@ -19875,6 +19950,7 @@
   ""
   "sbb{l}\t%0, %0"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "memory" "none")
    (set_attr "imm_disp" "false")
@@ -20207,7 +20283,8 @@
     }
 }
   [(set (attr "type")
-	(cond [(eq_attr "alternative" "0")
+	(cond [(and (eq_attr "alternative" "0") 
+	            (eq (symbol_ref "TARGET_OPT_AGU") (const_int 0)))
 		 (const_string "alu")
 	       (match_operand:SI 2 "const0_operand" "")
 		 (const_string "imov")
@@ -20250,7 +20327,8 @@
     }
 }
   [(set (attr "type")
-	(cond [(eq_attr "alternative" "0")
+	(cond [(and (eq_attr "alternative" "0")
+	            (eq (symbol_ref "TARGET_OPT_AGU") (const_int 0)))
 		 (const_string "alu")
 	       (match_operand:DI 2 "const0_operand" "")
 		 (const_string "imov")
@@ -21734,6 +21812,7 @@
   return patterns[locality];
 }
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "prefetch")
    (set_attr "memory" "none")])
 
 (define_insn "*prefetch_sse_rex"
@@ -21752,6 +21831,7 @@
   return patterns[locality];
 }
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "prefetch")
    (set_attr "memory" "none")])
 
 (define_insn "*prefetch_3dnow"
diff -Nur a/gcc/config/i386/i386.opt b/gcc/config/i386/i386.opt
--- a/gcc/config/i386/i386.opt	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/i386/i386.opt	2010-01-25 09:50:29.015687523 +0100
@@ -228,6 +228,10 @@
 Target RejectNegative Joined Var(ix86_tune_string)
 Schedule code for given CPU
 
+mabi=
+Target RejectNegative Joined Var(ix86_abi_string)
+Generate code that conforms to the given ABI
+
 mveclibabi=
 Target RejectNegative Joined Var(ix86_veclibabi_string)
 Vector library ABI to use
@@ -335,6 +339,10 @@
 Target Report Mask(ISA_SAHF) Var(ix86_isa_flags) VarExists Save
 Support code generation of sahf instruction in 64bit x86-64 code.
 
+mmovbe
+Target Report Mask(ISA_MOVBE) Var(ix86_isa_flags) VarExists Save
+Support code generation of movbe instruction.
+
 maes
 Target Report Mask(ISA_AES) Var(ix86_isa_flags) VarExists Save
 Support AES built-in functions and code generation
diff -Nur a/gcc/config/i386/i386-protos.h b/gcc/config/i386/i386-protos.h
--- a/gcc/config/i386/i386-protos.h	2009-07-11 21:06:26.000000000 +0200
+++ b/gcc/config/i386/i386-protos.h	2010-01-25 09:50:29.015687523 +0100
@@ -86,6 +86,9 @@
 extern void ix86_expand_binary_operator (enum rtx_code,
 					 enum machine_mode, rtx[]);
 extern int ix86_binary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);
+extern bool ix86_lea_for_add_ok (enum rtx_code, rtx, rtx[]);
+extern bool ix86_dep_by_shift_count (const_rtx set_insn, const_rtx use_insn);
+extern bool ix86_agi_dependent (rtx set_insn, rtx use_insn);
 extern void ix86_expand_unary_operator (enum rtx_code, enum machine_mode,
 					rtx[]);
 extern rtx ix86_build_const_vector (enum machine_mode, bool, rtx);
@@ -140,9 +143,8 @@
 extern bool ix86_sol10_return_in_memory (const_tree,const_tree);
 extern rtx ix86_force_to_memory (enum machine_mode, rtx);
 extern void ix86_free_from_memory (enum machine_mode);
-extern int ix86_cfun_abi (void);
-extern int ix86_function_abi (const_tree);
-extern int ix86_function_type_abi (const_tree);
+extern enum calling_abi ix86_cfun_abi (void);
+extern enum calling_abi ix86_function_type_abi (const_tree);
 extern void ix86_call_abi_override (const_tree);
 extern tree ix86_fn_abi_va_list (tree);
 extern tree ix86_canonical_va_list_type (tree);
diff -Nur a/gcc/config/i386/mingw32.h b/gcc/config/i386/mingw32.h
--- a/gcc/config/i386/mingw32.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/i386/mingw32.h	2010-01-25 09:50:29.015687523 +0100
@@ -38,7 +38,7 @@
       builtin_define_std ("WINNT");				\
       builtin_define_with_int_value ("_INTEGRAL_MAX_BITS",	\
 				     TYPE_PRECISION (intmax_type_node));\
-      if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)			\
+      if (TARGET_64BIT && ix86_abi == MS_ABI)			\
 	{							\
 	  builtin_define ("__MINGW64__");			\
 	  builtin_define_std ("WIN64");				\
diff -Nur a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
--- a/gcc/config/i386/sse.md	2009-05-06 15:20:41.000000000 +0200
+++ b/gcc/config/i386/sse.md	2010-01-25 09:50:29.015687523 +0100
@@ -338,6 +338,7 @@
    && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "vmovup<avxmodesuffixf2c>\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "movu" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<MODE>")])
 
@@ -363,6 +364,7 @@
    && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "movup<ssemodesuffixf2c>\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "movu" "1")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "avx_movdqu<avxmodesuffix>"
@@ -373,6 +375,7 @@
   "TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "vmovdqu\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "movu" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<avxvecmode>")])
 
@@ -383,6 +386,7 @@
   "TARGET_SSE2 && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "movdqu\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "movu" "1")
    (set_attr "prefix_data16" "1")
    (set_attr "mode" "TI")])
 
@@ -424,7 +428,7 @@
 		     UNSPEC_MOVNT))]
   "TARGET_SSE2"
   "movntdq\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix_data16" "1")
    (set_attr "mode" "TI")])
 
@@ -434,7 +438,7 @@
 		   UNSPEC_MOVNT))]
   "TARGET_SSE2"
   "movnti\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "mode" "V2DF")])
 
 (define_insn "avx_lddqu<avxmodesuffix>"
@@ -445,6 +449,7 @@
   "TARGET_AVX"
   "vlddqu\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
+   (set_attr "movu" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<avxvecmode>")])
 
@@ -454,7 +459,8 @@
 		      UNSPEC_LDDQU))]
   "TARGET_SSE3"
   "lddqu\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
+   (set_attr "movu" "1")
    (set_attr "prefix_rep" "1")
    (set_attr "mode" "TI")])
 
@@ -761,6 +767,7 @@
   "TARGET_SSE"
   "%vrcpps\t{%1, %0|%0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "rcp")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "V4SF")])
 
@@ -787,6 +794,7 @@
   "TARGET_SSE"
   "rcpss\t{%1, %0|%0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "rcp")
    (set_attr "mode" "SF")])
 
 (define_expand "sqrtv8sf2"
@@ -832,6 +840,7 @@
   "TARGET_SSE"
   "%vsqrtps\t{%1, %0|%0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "sqrt")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "V4SF")])
 
@@ -876,6 +885,7 @@
   "SSE_VEC_FLOAT_MODE_P (<MODE>mode)"
   "sqrts<ssemodesuffixf2c>\t{%1, %0|%0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "sqrt")
    (set_attr "mode" "<ssescalarmode>")])
 
 (define_expand "rsqrtv8sf2"
@@ -1039,7 +1049,7 @@
 	 (const_int 1)))]
   "SSE_VEC_FLOAT_MODE_P (<MODE>mode)"
   "<maxminfprefix>s<ssemodesuffixf2c>\t{%2, %0|%0, %2}"
-  [(set_attr "type" "sse")
+  [(set_attr "type" "sseadd")
    (set_attr "mode" "<ssescalarmode>")])
 
 ;; These versions of the min/max patterns implement exactly the operations
@@ -1175,6 +1185,7 @@
   "TARGET_SSE3"
   "addsubpd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "mode" "V2DF")])
 
 (define_insn "avx_h<plusminus_insn>v4df3"
@@ -1298,6 +1309,7 @@
   "TARGET_SSE3"
   "h<plusminus_mnemonic>ps\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_rep" "1")
    (set_attr "mode" "V4SF")])
 
@@ -5066,6 +5078,7 @@
   "TARGET_SSE2 && ix86_binary_operator_ok (MULT, V8HImode, operands)"
   "pmaddwd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "simul")
    (set_attr "prefix_data16" "1")
    (set_attr "mode" "TI")])
 
@@ -7025,6 +7038,7 @@
    movq\t{%H1, %0|%0, %H1}
    mov{q}\t{%H1, %0|%0, %H1}"
   [(set_attr "type" "ssemov,sseishft,ssemov,imov")
+   (set_attr "atom_unit" "*,sishuf,*,*")
    (set_attr "memory" "*,none,*,*")
    (set_attr "mode" "V2SF,TI,TI,DI")])
 
@@ -7057,6 +7071,7 @@
    psrldq\t{$8, %0|%0, 8}
    movq\t{%H1, %0|%0, %H1}"
   [(set_attr "type" "ssemov,sseishft,ssemov")
+   (set_attr "atom_unit" "*,sishuf,*")
    (set_attr "memory" "*,none,*")
    (set_attr "mode" "V2SF,TI,TI")])
 
@@ -7614,6 +7629,7 @@
   "TARGET_SSE2"
   "psadbw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "simul")
    (set_attr "prefix_data16" "1")
    (set_attr "mode" "TI")])
 
@@ -7635,7 +7651,7 @@
 	  UNSPEC_MOVMSK))]
   "SSE_VEC_FLOAT_MODE_P (<MODE>mode)"
   "%vmovmskp<ssemodesuffixf2c>\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "<MODE>")])
 
@@ -7645,7 +7661,7 @@
 		   UNSPEC_MOVMSK))]
   "TARGET_SSE2"
   "%vpmovmskb\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "SI")])
@@ -7668,7 +7684,7 @@
   "TARGET_SSE2 && !TARGET_64BIT"
   ;; @@@ check ordering of operands in intel/nonintel syntax
   "%vmaskmovdqu\t{%2, %1|%1, %2}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
@@ -7682,7 +7698,7 @@
   "TARGET_SSE2 && TARGET_64BIT"
   ;; @@@ check ordering of operands in intel/nonintel syntax
   "%vmaskmovdqu\t{%2, %1|%1, %2}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
@@ -7693,6 +7709,7 @@
   "TARGET_SSE"
   "%vldmxcsr\t%0"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "mxcsr")
    (set_attr "prefix" "maybe_vex")
    (set_attr "memory" "load")])
 
@@ -7702,6 +7719,7 @@
   "TARGET_SSE"
   "%vstmxcsr\t%0"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "mxcsr")
    (set_attr "prefix" "maybe_vex")
    (set_attr "memory" "store")])
 
@@ -7720,6 +7738,7 @@
   "TARGET_SSE || TARGET_3DNOW_A"
   "sfence"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "fence")
    (set_attr "memory" "unknown")])
 
 (define_insn "sse2_clflush"
@@ -7728,6 +7747,7 @@
   "TARGET_SSE2"
   "clflush\t%a0"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "fence")
    (set_attr "memory" "unknown")])
 
 (define_expand "sse2_mfence"
@@ -7745,6 +7765,7 @@
   "TARGET_64BIT || TARGET_SSE2"
   "mfence"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "fence")
    (set_attr "memory" "unknown")])
 
 (define_expand "sse2_lfence"
@@ -7762,6 +7783,7 @@
   "TARGET_SSE2"
   "lfence"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "lfence")
    (set_attr "memory" "unknown")])
 
 (define_insn "sse3_mwait"
@@ -7885,6 +7907,7 @@
   "TARGET_SSSE3"
   "phaddw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -7913,6 +7936,7 @@
   "TARGET_SSSE3"
   "phaddw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -7967,6 +7991,7 @@
   "TARGET_SSSE3"
   "phaddd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -7987,6 +8012,7 @@
   "TARGET_SSSE3"
   "phaddd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8073,6 +8099,7 @@
   "TARGET_SSSE3"
   "phaddsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8101,6 +8128,7 @@
   "TARGET_SSSE3"
   "phaddsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8187,6 +8215,7 @@
   "TARGET_SSSE3"
   "phsubw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8215,6 +8244,7 @@
   "TARGET_SSSE3"
   "phsubw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8269,6 +8299,7 @@
   "TARGET_SSSE3"
   "phsubd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8289,6 +8320,7 @@
   "TARGET_SSSE3"
   "phsubd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8375,6 +8407,7 @@
   "TARGET_SSSE3"
   "phsubsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8403,6 +8436,7 @@
   "TARGET_SSSE3"
   "phsubsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8509,6 +8543,7 @@
   "TARGET_SSSE3"
   "pmaddubsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "simul")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8547,6 +8582,7 @@
   "TARGET_SSSE3"
   "pmaddubsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "simul")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8754,6 +8790,7 @@
   return "palignr\t{%3, %2, %0|%0, %2, %3}";
 }
   [(set_attr "type" "sseishft")
+   (set_attr "atom_unit" "sishuf")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8770,6 +8807,7 @@
   return "palignr\t{%3, %2, %0|%0, %2, %3}";
 }
   [(set_attr "type" "sseishft")
+   (set_attr "atom_unit" "sishuf")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8956,7 +8994,7 @@
 		     UNSPEC_MOVNTDQA))]
   "TARGET_SSE4_1"
   "%vmovntdqa\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix_extra" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
diff -Nur a/gcc/config/i386/t-cs-linux b/gcc/config/i386/t-cs-linux
--- a/gcc/config/i386/t-cs-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/i386/t-cs-linux	2010-01-25 09:50:29.015687523 +0100
@@ -0,0 +1,25 @@
+# Sourcery G++ IA32 GNU/Linux Configuration.
+# Copyright (C) 2007
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS = m64/m32 msgxx-glibc/mrh73/mrhel3
+MULTILIB_DIRNAMES = 64 32 sgxx-glibc rh73 rhel3
+MULTILIB_OSDIRNAMES = ../lib64 ../lib sgxx-glibc rh73 rhel3
+MULTILIB_EXCEPTIONS = m64/mrh73 m64/mrhel3
+
diff -Nur a/gcc/config/i386/t-cs-linux-lite b/gcc/config/i386/t-cs-linux-lite
--- a/gcc/config/i386/t-cs-linux-lite	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/i386/t-cs-linux-lite	2010-01-25 09:50:29.015687523 +0100
@@ -0,0 +1,26 @@
+# Sourcery G++ Lite IA32 GNU/Linux Configuration.
+# Copyright (C) 2009
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS = m64 march=atom/march=core2
+MULTILIB_DIRNAMES = 64 atom core2
+MULTILIB_EXCEPTIONS = m64/march=atom march=core2
+MULTILIB_ALIASES = m64=m64/march?atom
+MULTILIB_OSDIRNAMES = m64=../lib64 march.atom=atom m64/march.core2=../lib64/core2
+
diff -Nur a/gcc/config/i386/t-wrs-linux b/gcc/config/i386/t-wrs-linux
--- a/gcc/config/i386/t-wrs-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/i386/t-wrs-linux	2010-01-25 09:50:29.015687523 +0100
@@ -0,0 +1,24 @@
+# Wind River GNU/Linux Configuration.
+# Copyright (C) 2009
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS = m64/m32 msystem-glibc
+MULTILIB_DIRNAMES = 64 32 system-glibc
+MULTILIB_OSDIRNAMES = ../lib64 ../lib system-glibc
+MULTILIB_EXCEPTIONS = m64/msystem-glibc
diff -Nur a/gcc/config/i386/winnt.c b/gcc/config/i386/winnt.c
--- a/gcc/config/i386/winnt.c	2009-02-21 04:21:44.000000000 +0100
+++ b/gcc/config/i386/winnt.c	2010-01-25 09:50:29.015687523 +0100
@@ -499,8 +499,11 @@
 {
   HOST_WIDE_INT rounded;
 
-  /* Compute as in assemble_noswitch_variable, since we don't actually
-     support aligned common.  */
+  /* Compute as in assemble_noswitch_variable, since we don't have
+     support for aligned common on older binutils.  We must also
+     avoid emitting a common symbol of size zero, as this is the
+     overloaded representation that indicates an undefined external
+     symbol in the PE object file format.  */
   rounded = size ? size : 1;
   rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;
   rounded = (rounded / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)
@@ -510,9 +513,13 @@
 
   fprintf (stream, "\t.comm\t");
   assemble_name (stream, name);
-  fprintf (stream, ", " HOST_WIDE_INT_PRINT_DEC "\t" ASM_COMMENT_START
-	   " " HOST_WIDE_INT_PRINT_DEC "\n",
-	   rounded, size);
+  if (use_pe_aligned_common)
+    fprintf (stream, ", " HOST_WIDE_INT_PRINT_DEC ", %d\n",
+	   size ? size : (HOST_WIDE_INT) 1,
+	   exact_log2 (align) - exact_log2 (CHAR_BIT));
+  else
+    fprintf (stream, ", " HOST_WIDE_INT_PRINT_DEC "\t" ASM_COMMENT_START
+	   " " HOST_WIDE_INT_PRINT_DEC "\n", rounded, size);
 }
 
 /* The Microsoft linker requires that every function be marked as
diff -Nur a/gcc/config/i386/wrs-linux.h b/gcc/config/i386/wrs-linux.h
--- a/gcc/config/i386/wrs-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/i386/wrs-linux.h	2010-01-25 09:50:29.015687523 +0100
@@ -0,0 +1,33 @@
+/* Wind River IA32 GNU/Linux Configuration.
+   Copyright (C) 2009
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+  "%{msystem-glibc:/system-glibc}"
+
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC SYSROOT_SUFFIX_SPEC
+
+/* See mips/wrs-linux.h for details on this use of
+   STARTFILE_PREFIX_SPEC.  */
+#undef STARTFILE_PREFIX_SPEC
+#define STARTFILE_PREFIX_SPEC				\
+  "%{m64: /usr/local/lib64/ /lib64/ /usr/lib64/}	\
+   %{!m64: /usr/local/lib/ /lib/ /usr/lib/}"
diff -Nur a/gcc/config/i386/wrs-linux.opt b/gcc/config/i386/wrs-linux.opt
--- a/gcc/config/i386/wrs-linux.opt	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/i386/wrs-linux.opt	2010-01-25 09:50:29.015687523 +0100
@@ -0,0 +1,5 @@
+; Additional options for Wind River Linux Sourcery G++.
+
+msystem-glibc
+Target
+Use system version of GLIBC
diff -Nur a/gcc/config/m68k/constraints.md b/gcc/config/m68k/constraints.md
--- a/gcc/config/m68k/constraints.md	2007-09-11 15:56:30.000000000 +0200
+++ b/gcc/config/m68k/constraints.md	2010-01-25 09:50:29.015687523 +0100
@@ -124,6 +124,11 @@
   (and (match_code "const_int")
        (match_test "ival < -0x8000 || ival > 0x7FFF")))
 
+(define_constraint "Cu"
+  "16-bit offset for wrapped symbols"
+  (and (match_code "const")
+       (match_test "m68k_unwrap_symbol (op, false) != op")))
+
 (define_constraint "CQ"
   "Integers valid for mvq."
   (and (match_code "const_int")
diff -Nur a/gcc/config/m68k/lb1sf68.asm b/gcc/config/m68k/lb1sf68.asm
--- a/gcc/config/m68k/lb1sf68.asm	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/m68k/lb1sf68.asm	2010-01-25 09:50:29.015687523 +0100
@@ -163,6 +163,8 @@
 #if defined (__mcoldfire__) && !defined (__mcfisab__) && !defined (__mcfisac__)
 	lea	\addr-.-8,a0
 	jsr	pc@(a0)
+#elif defined (__mcfisab__) || defined (__mcfisac__)
+	bsr.l	\addr
 #else
 	bsr	\addr
 #endif
@@ -202,6 +204,8 @@
 #if defined (__mcoldfire__) && !defined (__mcfisab__) && !defined (__mcfisac__)
 	lea	\addr-.-8,a0
 	jsr	pc@(a0)
+#elif defined (__mcfisab__) || defined (__mcfisac__)
+	bsr.l	\addr
 #else
 	bsr	\addr
 #endif
diff -Nur a/gcc/config/m68k/linux-unwind.h b/gcc/config/m68k/linux-unwind.h
--- a/gcc/config/m68k/linux-unwind.h	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/m68k/linux-unwind.h	2010-01-25 09:50:29.015687523 +0100
@@ -77,9 +77,15 @@
       fs->regs.reg[9].how = REG_SAVED_OFFSET;
       fs->regs.reg[9].loc.offset = (long) &sc->sc_a1 - cfa;
 
+#ifdef __uClinux__
+      fs->regs.reg[13].how = REG_SAVED_OFFSET;
+      fs->regs.reg[13].loc.offset = (long) &sc->sc_a5 - cfa;
+#endif
+
       fs->regs.reg[24].how = REG_SAVED_OFFSET;
       fs->regs.reg[24].loc.offset = (long) &sc->sc_pc - cfa;
 
+#if defined __mcffpu__ && !defined __uClinux__
       if (*(int *) sc->sc_fpstate)
 	{
 	  int *fpregs = (int *) sc->sc_fpregs;
@@ -89,11 +95,19 @@
 	  fs->regs.reg[17].how = REG_SAVED_OFFSET;
 	  fs->regs.reg[17].loc.offset = (long) &fpregs[M68K_FP_SIZE/4] - cfa;
 	}
+#elif defined __mcffpu__
+# error Implement this when uClinux kernel is ported to an FPU architecture
+#endif
     }
 #ifdef __mcoldfire__
   /* move.l #__NR_rt_sigreturn,%d0; trap #0 */
-  else if (pc[0] == 0x203c && pc[1] == 0x0000 &&
-	   pc[2] == 0x00ad && pc[3] == 0x4e40)
+  else if ((pc[0] == 0x203c && pc[1] == 0x0000 &&
+	    pc[2] == 0x00ad && pc[3] == 0x4e40) ||
+	   /* Don't ask me why, this is just what some kernels do:
+	      moveq #-__NR_rt_sigreturn,%d0; andil 0xff,%d0; trap #0;
+	      Sigh...  */
+	   (pc[0] == 0x70ad && pc[1] == 0x0280 && pc[2] == 0x0000 &&
+	    pc[3] == 0x00ff && pc[4] == 0x4e40 && pc[5] == 0x0000))
 #else
   /* moveq #~__NR_rt_sigreturn,%d0; not.b %d0; trap #0 */
   else if (pc[0] == 0x7052 && pc[1] == 0x4600 && pc[2] == 0x4e40)
diff -Nur a/gcc/config/m68k/m68k.c b/gcc/config/m68k/m68k.c
--- a/gcc/config/m68k/m68k.c	2008-11-19 17:24:10.000000000 +0100
+++ b/gcc/config/m68k/m68k.c	2010-01-25 09:50:29.015687523 +0100
@@ -46,6 +46,7 @@
 /* ??? Need to add a dependency between m68k.o and sched-int.h.  */
 #include "sched-int.h"
 #include "insn-codes.h"
+#include "ggc.h"
 
 enum reg_class regno_reg_class[] =
 {
@@ -146,10 +147,12 @@
 static void m68k_compute_frame_layout (void);
 static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);
 static bool m68k_ok_for_sibcall_p (tree, tree);
+static bool m68k_tls_symbol_p (rtx);
 static bool m68k_rtx_costs (rtx, int, int, int *, bool);
 #if M68K_HONOR_TARGET_STRICT_ALIGNMENT
 static bool m68k_return_in_memory (const_tree, const_tree);
 #endif
+static void m68k_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;
 
 
 /* Specify the identification number of the library being built */
@@ -252,6 +255,14 @@
 #define TARGET_RETURN_IN_MEMORY m68k_return_in_memory
 #endif
 
+#ifdef HAVE_AS_TLS
+#undef TARGET_HAVE_TLS
+#define TARGET_HAVE_TLS (true)
+
+#undef TARGET_ASM_OUTPUT_DWARF_DTPREL
+#define TARGET_ASM_OUTPUT_DWARF_DTPREL m68k_output_dwarf_dtprel
+#endif
+
 static const struct attribute_spec m68k_attribute_table[] =
 {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
@@ -1150,8 +1161,7 @@
 			    current_frame.reg_mask, true, true));
     }
 
-  if (flag_pic
-      && !TARGET_SEP_DATA
+  if (!TARGET_SEP_DATA
       && crtl->uses_pic_offset_table)
     insn = emit_insn (gen_load_got (pic_offset_table_rtx));
 }
@@ -1425,6 +1435,86 @@
   return replace_equiv_address (x, gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM));
 }
 
+/* Convert X to a legitimate address and return it if successful.  Otherwise
+   return X.
+
+   For the 68000, we handle X+REG by loading X into a register R and
+   using R+REG.  R will go in an address reg and indexing will be used.
+   However, if REG is a broken-out memory address or multiplication,
+   nothing needs to be done because REG can certainly go in an address reg.  */
+
+rtx
+m68k_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)
+{
+  if (m68k_tls_symbol_p (x))
+    return m68k_legitimize_tls_address (x);
+
+  if (GET_CODE (x) == PLUS)
+    {
+      int ch = (x) != (oldx);
+      int copied = 0;
+
+#define COPY_ONCE(Y) if (!copied) { Y = copy_rtx (Y); copied = ch = 1; }
+
+      if (GET_CODE (XEXP (x, 0)) == MULT)
+	{
+	  COPY_ONCE (x);
+	  XEXP (x, 0) = force_operand (XEXP (x, 0), 0);
+	}
+      if (GET_CODE (XEXP (x, 1)) == MULT)
+	{
+	  COPY_ONCE (x);
+	  XEXP (x, 1) = force_operand (XEXP (x, 1), 0);
+	}
+      if (ch)
+	{
+          if (GET_CODE (XEXP (x, 1)) == REG
+	      && GET_CODE (XEXP (x, 0)) == REG)
+	    {
+	      if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (mode) == MODE_FLOAT)
+	        {
+	          COPY_ONCE (x);
+	          x = force_operand (x, 0);
+	        }
+	      return x;
+	    }
+	  if (memory_address_p (mode, x))
+	    return x;
+	}
+      if (GET_CODE (XEXP (x, 0)) == REG
+	  || (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND
+	      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG
+	      && GET_MODE (XEXP (XEXP (x, 0), 0)) == HImode))
+	{
+	  rtx temp = gen_reg_rtx (Pmode);
+	  rtx val = force_operand (XEXP (x, 1), 0);
+	  emit_move_insn (temp, val);
+	  COPY_ONCE (x);
+	  XEXP (x, 1) = temp;
+	  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (mode) == MODE_FLOAT
+	      && GET_CODE (XEXP (x, 0)) == REG)
+	    x = force_operand (x, 0);
+	}
+      else if (GET_CODE (XEXP (x, 1)) == REG
+	       || (GET_CODE (XEXP (x, 1)) == SIGN_EXTEND
+		   && GET_CODE (XEXP (XEXP (x, 1), 0)) == REG
+		   && GET_MODE (XEXP (XEXP (x, 1), 0)) == HImode))
+	{
+	  rtx temp = gen_reg_rtx (Pmode);
+	  rtx val = force_operand (XEXP (x, 0), 0);
+	  emit_move_insn (temp, val);
+	  COPY_ONCE (x);
+	  XEXP (x, 0) = temp;
+	  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (mode) == MODE_FLOAT
+	      && GET_CODE (XEXP (x, 1)) == REG)
+	    x = force_operand (x, 0);
+	}
+    }
+
+  return x;
+}
+
+
 /* Output a dbCC; jCC sequence.  Note we do not handle the 
    floating point version of this sequence (Fdbcc).  We also
    do not handle alternative conditions when CC_NO_OVERFLOW is
@@ -1713,15 +1803,16 @@
    whether we need strict checking.  */
 
 bool
-m68k_legitimate_index_reg_p (rtx x, bool strict_p)
+m68k_legitimate_index_reg_p (enum machine_mode mode, rtx x, bool strict_p)
 {
   if (!strict_p && GET_CODE (x) == SUBREG)
     x = SUBREG_REG (x);
 
   return (REG_P (x)
 	  && (strict_p
-	      ? REGNO_OK_FOR_INDEX_P (REGNO (x))
-	      : REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO (x))));
+	      ? REGNO_MODE_OK_FOR_INDEX_P (REGNO (x), mode)
+	      : (MODE_OK_FOR_INDEX_P (mode)
+		 && REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO (x)))));
 }
 
 /* Return true if X is a legitimate index expression for a (d8,An,Xn) or
@@ -1729,7 +1820,8 @@
    ADDRESS if so.  STRICT_P says whether we need strict checking.  */
 
 static bool
-m68k_decompose_index (rtx x, bool strict_p, struct m68k_address *address)
+m68k_decompose_index (enum machine_mode mode, rtx x, bool strict_p,
+		      struct m68k_address *address)
 {
   int scale;
 
@@ -1753,7 +1845,7 @@
       && GET_MODE (XEXP (x, 0)) == HImode)
     x = XEXP (x, 0);
 
-  if (m68k_legitimate_index_reg_p (x, strict_p))
+  if (m68k_legitimate_index_reg_p (mode, x, strict_p))
     {
       address->scale = scale;
       address->index = x;
@@ -1777,7 +1869,7 @@
 	  && !offset_within_block_p (base, INTVAL (offset)))
 	return true;
     }
-  return false;
+  return m68k_tls_reference_p (x, false);
 }
 
 /* Return true if X is a legitimate constant address that can reach
@@ -1805,7 +1897,7 @@
 	return false;
     }
 
-  return true;
+  return !m68k_tls_reference_p (x, false);
 }
 
 /* Return true if X is a LABEL_REF for a jump table.  Assume that unplaced
@@ -1872,15 +1964,17 @@
   /* Check for GOT loads.  These are (bd,An,Xn) addresses if
      TARGET_68020 && flag_pic == 2, otherwise they are (d16,An)
      addresses.  */
-  if (flag_pic
-      && GET_CODE (x) == PLUS
-      && XEXP (x, 0) == pic_offset_table_rtx
-      && (GET_CODE (XEXP (x, 1)) == SYMBOL_REF
-	  || GET_CODE (XEXP (x, 1)) == LABEL_REF))
+  if (GET_CODE (x) == PLUS
+      && XEXP (x, 0) == pic_offset_table_rtx)
     {
-      address->base = XEXP (x, 0);
-      address->offset = XEXP (x, 1);
-      return true;
+      /* As we are processing a PLUS, do not unwrap RELOC32 symbols --
+	 they are invalid in this context.  */
+      if (m68k_unwrap_symbol (XEXP (x, 1), false) != XEXP (x, 1))
+	{
+	  address->base = XEXP (x, 0);
+	  address->offset = XEXP (x, 1);
+	  return true;
+	}
     }
 
   /* The ColdFire FPU only accepts addressing modes 2-5.  */
@@ -1905,7 +1999,7 @@
      accesses to unplaced labels in other cases.  */
   if (GET_CODE (x) == PLUS
       && m68k_jump_table_ref_p (XEXP (x, 1))
-      && m68k_decompose_index (XEXP (x, 0), strict_p, address))
+      && m68k_decompose_index (mode, XEXP (x, 0), strict_p, address))
     {
       address->offset = XEXP (x, 1);
       return true;
@@ -1937,7 +2031,7 @@
 	 worse code.  */
       if (address->offset
 	  && symbolic_operand (address->offset, VOIDmode)
-	  && m68k_decompose_index (x, strict_p, address))
+	  && m68k_decompose_index (mode, x, strict_p, address))
 	return true;
     }
   else
@@ -1956,14 +2050,14 @@
   if (GET_CODE (x) == PLUS)
     {
       if (m68k_legitimate_base_reg_p (XEXP (x, 0), strict_p)
-	  && m68k_decompose_index (XEXP (x, 1), strict_p, address))
+	  && m68k_decompose_index (mode, XEXP (x, 1), strict_p, address))
 	{
 	  address->base = XEXP (x, 0);
 	  return true;
 	}
 
       if (m68k_legitimate_base_reg_p (XEXP (x, 1), strict_p)
-	  && m68k_decompose_index (XEXP (x, 0), strict_p, address))
+	  && m68k_decompose_index (mode, XEXP (x, 0), strict_p, address))
 	{
 	  address->base = XEXP (x, 1);
 	  return true;
@@ -2025,6 +2119,243 @@
 	  && !address.index);
 }
 
+/* Return GOT pointer.  */
+
+static rtx
+m68k_get_gp (void)
+{
+  if (pic_offset_table_rtx == NULL_RTX)
+    pic_offset_table_rtx = gen_rtx_REG (Pmode, PIC_REG);
+
+  crtl->uses_pic_offset_table = 1;
+
+  return pic_offset_table_rtx;
+}
+
+/* M68K relocations, used to distinguish GOT and TLS relocations in UNSPEC
+   wrappers.  */
+enum m68k_reloc { RELOC_GOT, RELOC_TLSGD, RELOC_TLSLDM, RELOC_TLSLDO,
+		  RELOC_TLSIE, RELOC_TLSLE };
+
+#define TLS_RELOC_P(RELOC) ((RELOC) != RELOC_GOT)
+
+/* Wrap symbol X into unspec representing relocation RELOC.
+   BASE_REG - register that should be added to the result.
+   TEMP_REG - if non-null, temporary register.  */
+
+static rtx
+m68k_wrap_symbol (rtx x, enum m68k_reloc reloc, rtx base_reg, rtx temp_reg)
+{
+  bool use_x_p;
+
+  use_x_p = (base_reg == pic_offset_table_rtx) ? TARGET_XGOT : TARGET_XTLS;
+
+  if (TARGET_COLDFIRE && use_x_p)
+    /* When compiling with -mx{got, tls} switch the code will look like this:
+
+       move.l <X>@<RELOC>,<TEMP_REG>
+       add.l <BASE_REG>,<TEMP_REG>  */
+    {
+      /* Wrap X in UNSPEC_??? to tip m68k_output_addr_const_extra
+	 to put @RELOC after reference.  */
+      x = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x, GEN_INT (reloc)),
+			  UNSPEC_RELOC32);
+      x = gen_rtx_CONST (Pmode, x);
+
+      if (temp_reg == NULL)
+	{
+	  gcc_assert (can_create_pseudo_p ());
+	  temp_reg = gen_reg_rtx (Pmode);
+	}
+
+      emit_move_insn (temp_reg, x);
+      emit_insn (gen_addsi3 (temp_reg, temp_reg, base_reg));
+      x = temp_reg;
+    }
+  else
+    {
+      x = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x, GEN_INT (reloc)),
+			  UNSPEC_RELOC16);
+      x = gen_rtx_CONST (Pmode, x);
+
+      x = gen_rtx_PLUS (Pmode, base_reg, x);
+    }
+
+  return x;
+}
+
+/* Helper for m68k_unwrap_symbol.
+   Also, if unwrapping was successful (that is if (ORIG != <return value>)),
+   sets *RELOC_PTR to relocation type for the symbol.  */
+
+static rtx
+m68k_unwrap_symbol_1 (rtx orig, bool unwrap_reloc32_p,
+		      enum m68k_reloc *reloc_ptr)
+{
+  if (GET_CODE (orig) == CONST)
+    {
+      rtx x;
+      enum m68k_reloc dummy;
+
+      x = XEXP (orig, 0);
+
+      if (reloc_ptr == NULL)
+	reloc_ptr = &dummy;
+
+      /* Handle an addend.  */
+      if ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS)
+	  && CONST_INT_P (XEXP (x, 1)))
+	x = XEXP (x, 0);
+
+      if (GET_CODE (x) == UNSPEC)
+	{
+	  switch (XINT (x, 1))
+	    {
+	    case UNSPEC_RELOC16:
+	      orig = XVECEXP (x, 0, 0);
+	      *reloc_ptr = (enum m68k_reloc) INTVAL (XVECEXP (x, 0, 1));
+	      break;
+
+	    case UNSPEC_RELOC32:
+	      if (unwrap_reloc32_p)
+		{
+		  orig = XVECEXP (x, 0, 0);
+		  *reloc_ptr = (enum m68k_reloc) INTVAL (XVECEXP (x, 0, 1));
+		}
+	      break;
+
+	    default:
+	      break;
+	    }
+	}
+    }
+
+  return orig;
+}
+
+/* Unwrap symbol from UNSPEC_RELOC16 and, if unwrap_reloc32_p,
+   UNSPEC_RELOC32 wrappers.  */
+
+rtx
+m68k_unwrap_symbol (rtx orig, bool unwrap_reloc32_p)
+{
+  return m68k_unwrap_symbol_1 (orig, unwrap_reloc32_p, NULL);
+}
+
+/* Helper for m68k_final_prescan_insn.  */
+
+static int
+m68k_final_prescan_insn_1 (rtx *x_ptr, void *data ATTRIBUTE_UNUSED)
+{
+  rtx x = *x_ptr;
+
+  if (m68k_unwrap_symbol (x, true) != x)
+    /* For rationale of the below, see comment in m68k_final_prescan_insn.  */
+    {
+      rtx plus;
+
+      gcc_assert (GET_CODE (x) == CONST);
+      plus = XEXP (x, 0);
+
+      if (GET_CODE (plus) == PLUS || GET_CODE (plus) == MINUS)
+	{
+	  rtx unspec;
+	  rtx addend;
+
+	  unspec = XEXP (plus, 0);
+	  gcc_assert (GET_CODE (unspec) == UNSPEC);
+	  addend = XEXP (plus, 1);
+	  gcc_assert (CONST_INT_P (addend));
+
+	  /* We now have all the pieces, rearrange them.  */
+
+	  /* Move symbol to plus.  */
+	  XEXP (plus, 0) = XVECEXP (unspec, 0, 0);
+
+	  /* Move plus inside unspec.  */
+	  XVECEXP (unspec, 0, 0) = plus;
+
+	  /* Move unspec to top level of const.  */
+	  XEXP (x, 0) = unspec;
+	}
+
+      return -1;
+    }
+
+  return 0;
+}
+
+/* Prescan insn before outputing assembler for it.  */
+
+void
+m68k_final_prescan_insn (rtx insn ATTRIBUTE_UNUSED,
+			 rtx *operands, int n_operands)
+{
+  int i;
+
+  /* Combine and, possibly, other optimizations may do good job
+     converting
+       (const (unspec [(symbol)]))
+     into
+       (const (plus (unspec [(symbol)])
+                    (const_int N))).
+     The problem with this is emitting @TLS or @GOT decorations.
+     The decoration is emitted when processing (unspec), so the
+     result would be "#symbol@TLSLE+N" instead of "#symbol+N@TLSLE".
+
+     It seems that the easiest solution to this is to convert such
+     operands to
+       (const (unspec [(plus (symbol)
+                             (const_int N))])).
+     Note, that the top level of operand remains intact, so we don't have
+     to patch up anything outside of the operand.  */
+
+  for (i = 0; i < n_operands; ++i)
+    {
+      rtx op;
+
+      op = operands[i];
+
+      for_each_rtx (&op, m68k_final_prescan_insn_1, NULL);
+    }
+}
+
+/* Move X to a register and add REG_EQUAL note pointing to ORIG.
+   If REG is non-null, use it; generate new pseudo otherwise.  */
+
+static rtx
+m68k_move_to_reg (rtx x, rtx orig, rtx reg)
+{
+  rtx insn;
+
+  if (reg == NULL_RTX)
+    {
+      gcc_assert (can_create_pseudo_p ());
+      reg = gen_reg_rtx (Pmode);
+    }
+
+  insn = emit_move_insn (reg, x);
+  /* Put a REG_EQUAL note on this insn, so that it can be optimized
+     by loop.  */
+  set_unique_reg_note (insn, REG_EQUAL, orig);
+
+  return reg;
+}
+
+/* Does the same as m68k_wrap_symbol, but returns a memory reference to
+   GOT slot.  */
+
+static rtx
+m68k_wrap_symbol_into_got_ref (rtx x, enum m68k_reloc reloc, rtx temp_reg)
+{
+  x = m68k_wrap_symbol (x, reloc, m68k_get_gp (), temp_reg);
+
+  x = gen_rtx_MEM (Pmode, x);
+  MEM_READONLY_P (x) = 1;
+
+  return x;
+}
+
 /* Legitimize PIC addresses.  If the address is already
    position-independent, we return ORIG.  Newly generated
    position-independent addresses go to REG.  If we need more
@@ -2076,42 +2407,15 @@
     {
       gcc_assert (reg);
 
-      if (TARGET_COLDFIRE && TARGET_XGOT)
-	/* When compiling with -mxgot switch the code for the above
-	   example will look like this:
-
-	   movel a5, a0
-	   addl _foo@GOT, a0
-	   movel a0@, a0
-	   movel #12345, a0@  */
-	{
-	  rtx pic_offset;
-
-	  /* Wrap ORIG in UNSPEC_GOTOFF to tip m68k_output_addr_const_extra
-	     to put @GOT after reference.  */
-	  pic_offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, orig),
-				       UNSPEC_GOTOFF);
-	  pic_offset = gen_rtx_CONST (Pmode, pic_offset);
-	  emit_move_insn (reg, pic_offset);
-	  emit_insn (gen_addsi3 (reg, reg, pic_offset_table_rtx));
-	  pic_ref = gen_rtx_MEM (Pmode, reg);
-	}
-      else
-	pic_ref = gen_rtx_MEM (Pmode,
-			       gen_rtx_PLUS (Pmode,
-					     pic_offset_table_rtx, orig));
-      crtl->uses_pic_offset_table = 1;
-      MEM_READONLY_P (pic_ref) = 1;
-      emit_move_insn (reg, pic_ref);
-      return reg;
+      pic_ref = m68k_wrap_symbol_into_got_ref (orig, RELOC_GOT, reg);
+      pic_ref = m68k_move_to_reg (pic_ref, orig, reg);
     }
   else if (GET_CODE (orig) == CONST)
     {
       rtx base;
 
       /* Make sure this has not already been legitimized.  */
-      if (GET_CODE (XEXP (orig, 0)) == PLUS
-	  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)
+      if (m68k_unwrap_symbol (orig, true) != orig)
 	return orig;
 
       gcc_assert (reg);
@@ -2124,13 +2428,257 @@
 				     base == reg ? 0 : reg);
 
       if (GET_CODE (orig) == CONST_INT)
-	return plus_constant (base, INTVAL (orig));
-      pic_ref = gen_rtx_PLUS (Pmode, base, orig);
-      /* Likewise, should we set special REG_NOTEs here?  */
+	pic_ref = plus_constant (base, INTVAL (orig));
+      else
+	pic_ref = gen_rtx_PLUS (Pmode, base, orig);
     }
+
   return pic_ref;
 }
 
+/* The __tls_get_addr symbol.  */
+static GTY(()) rtx m68k_tls_get_addr;
+
+/* Return SYMBOL_REF for __tls_get_addr.  */
+
+static rtx
+m68k_get_tls_get_addr (void)
+{
+  if (m68k_tls_get_addr == NULL_RTX)
+    m68k_tls_get_addr = init_one_libfunc ("__tls_get_addr");
+
+  return m68k_tls_get_addr;
+}
+
+/* Return libcall result in A0 instead of usual D0.  */
+static bool m68k_libcall_value_in_a0_p = false;
+
+/* Emit instruction sequence that calls __tls_get_addr.  X is
+   the TLS symbol we are referencing and RELOC is the symbol type to use
+   (either TLSGD or TLSLDM).  EQV is the REG_EQUAL note for the sequence
+   emitted.  A pseudo register with result of __tls_get_addr call is
+   returned.  */
+
+static rtx
+m68k_call_tls_get_addr (rtx x, rtx eqv, enum m68k_reloc reloc)
+{
+  rtx a0;
+  rtx insns;
+  rtx dest;
+
+  /* Emit the call sequence.  */
+  start_sequence ();
+
+  /* FIXME: Unfortunately, emit_library_call_value does not
+     consider (plus (%a5) (const (unspec))) to be a good enough
+     operand for push, so it forces it into a register.  The bad
+     thing about this is that combiner, due to copy propagation and other
+     optimizations, sometimes can not later fix this.  As a consequence,
+     additional register may be allocated resulting in a spill.
+     For reference, see args processing loops in
+     calls.c:emit_library_call_value_1.
+     For testcase, see gcc.target/m68k/tls-{gd, ld}.c  */
+  x = m68k_wrap_symbol (x, reloc, m68k_get_gp (), NULL_RTX);
+
+  /* __tls_get_addr() is not a libcall, but emitting a libcall_value
+     is the simpliest way of generating a call.  The difference between
+     __tls_get_addr() and libcall is that the result is returned in D0
+     instead of A0.  To workaround this, we use m68k_libcall_value_in_a0_p
+     which temporarily switches returning the result to A0.  */ 
+
+  m68k_libcall_value_in_a0_p = true;
+  a0 = emit_library_call_value (m68k_get_tls_get_addr (), NULL_RTX, LCT_PURE,
+				Pmode, 1, x, Pmode);
+  m68k_libcall_value_in_a0_p = false;
+  
+  insns = get_insns ();
+  end_sequence ();
+
+  gcc_assert (can_create_pseudo_p ());
+  dest = gen_reg_rtx (Pmode);
+  emit_libcall_block (insns, dest, a0, eqv);
+
+  return dest;
+}
+
+/* The __tls_get_addr symbol.  */
+static GTY(()) rtx m68k_read_tp;
+
+/* Return SYMBOL_REF for __m68k_read_tp.  */
+
+static rtx
+m68k_get_m68k_read_tp (void)
+{
+  if (m68k_read_tp == NULL_RTX)
+    m68k_read_tp = init_one_libfunc ("__m68k_read_tp");
+
+  return m68k_read_tp;
+}
+
+/* Emit instruction sequence that calls __m68k_read_tp.
+   A pseudo register with result of __m68k_read_tp call is returned.  */
+
+static rtx 
+m68k_call_m68k_read_tp (void)
+{
+  rtx a0;
+  rtx eqv;
+  rtx insns;
+  rtx dest;
+
+  start_sequence ();
+
+  /* __m68k_read_tp() is not a libcall, but emitting a libcall_value
+     is the simpliest way of generating a call.  The difference between
+     __m68k_read_tp() and libcall is that the result is returned in D0
+     instead of A0.  To workaround this, we use m68k_libcall_value_in_a0_p
+     which temporarily switches returning the result to A0.  */ 
+
+  /* Emit the call sequence.  */
+  m68k_libcall_value_in_a0_p = true;
+  a0 = emit_library_call_value (m68k_get_m68k_read_tp (), NULL_RTX, LCT_PURE,
+				Pmode, 0);
+  m68k_libcall_value_in_a0_p = false;
+  insns = get_insns ();
+  end_sequence ();
+
+  /* Attach a unique REG_EQUIV, to allow the RTL optimizers to
+     share the m68k_read_tp result with other IE/LE model accesses.  */
+  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const1_rtx), UNSPEC_RELOC32);
+
+  gcc_assert (can_create_pseudo_p ());
+  dest = gen_reg_rtx (Pmode);
+  emit_libcall_block (insns, dest, a0, eqv);
+
+  return dest;
+}
+
+/* Return a legitimized address for accessing TLS SYMBOL_REF X.
+   For explanations on instructions sequences see TLS/NPTL ABI for m68k and
+   ColdFire.  */
+
+rtx
+m68k_legitimize_tls_address (rtx orig)
+{
+  switch (SYMBOL_REF_TLS_MODEL (orig))
+    {
+    case TLS_MODEL_GLOBAL_DYNAMIC:
+      orig = m68k_call_tls_get_addr (orig, orig, RELOC_TLSGD);
+      break;
+
+    case TLS_MODEL_LOCAL_DYNAMIC:
+      {
+	rtx eqv;
+	rtx a0;
+	rtx x;
+ 
+	/* Attach a unique REG_EQUIV, to allow the RTL optimizers to
+	   share the LDM result with other LD model accesses.  */
+	eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),
+			      UNSPEC_RELOC32);
+
+	a0 = m68k_call_tls_get_addr (orig, eqv, RELOC_TLSLDM);
+
+	x = m68k_wrap_symbol (orig, RELOC_TLSLDO, a0, NULL_RTX);
+
+	if (can_create_pseudo_p ())
+	  x = m68k_move_to_reg (x, orig, NULL_RTX);
+
+	orig = x;
+	break;
+      }
+
+    case TLS_MODEL_INITIAL_EXEC:
+      {
+	rtx a0;
+	rtx x;
+
+	a0 = m68k_call_m68k_read_tp ();
+
+	x = m68k_wrap_symbol_into_got_ref (orig, RELOC_TLSIE, NULL_RTX);
+	x = gen_rtx_PLUS (Pmode, x, a0);
+
+	if (can_create_pseudo_p ())
+	  x = m68k_move_to_reg (x, orig, NULL_RTX);
+
+	orig = x;
+	break;
+      }
+
+    case TLS_MODEL_LOCAL_EXEC:
+      {
+	rtx a0;
+	rtx x;
+
+	a0 = m68k_call_m68k_read_tp ();
+
+	x = m68k_wrap_symbol (orig, RELOC_TLSLE, a0, NULL_RTX);
+
+	if (can_create_pseudo_p ())
+	  x = m68k_move_to_reg (x, orig, NULL_RTX);
+
+	orig = x;
+	break;
+      }
+
+    default:
+      gcc_unreachable ();
+    }
+
+  return orig;
+}
+
+/* Return true if X is a TLS symbol.  */
+
+static bool
+m68k_tls_symbol_p (rtx x)
+{
+  if (!TARGET_HAVE_TLS)
+    return false;
+
+  if (GET_CODE (x) != SYMBOL_REF)
+    return false;
+
+  return SYMBOL_REF_TLS_MODEL (x) != 0;
+}
+
+/* Helper for m68k_tls_referenced_p.  */
+
+static int
+m68k_tls_reference_p_1 (rtx *x_ptr, void *data ATTRIBUTE_UNUSED)
+{
+  /* Note: this is not the same as m68k_tls_symbol_p.  */
+  if (GET_CODE (*x_ptr) == SYMBOL_REF)
+    return SYMBOL_REF_TLS_MODEL (*x_ptr) != 0 ? 1 : 0;
+
+  /* Don't recurse into legitimate TLS references.  */
+  if (m68k_tls_reference_p (*x_ptr, true))
+    return -1;
+
+  return 0;
+}
+
+/* If !LEGITIMATE_P, return true if X is a TLS symbol reference,
+   though illegitimate one.
+   If LEGITIMATE_P, return true if X is a legitimate TLS symbol reference.  */
+
+bool
+m68k_tls_reference_p (rtx x, bool legitimate_p)
+{
+  if (!TARGET_HAVE_TLS)
+    return false;
+
+  if (!legitimate_p)
+    return for_each_rtx (&x, m68k_tls_reference_p_1, NULL) == 1 ? true : false;
+  else
+    {
+      enum m68k_reloc reloc = RELOC_GOT;
+
+      return (m68k_unwrap_symbol_1 (x, true, &reloc) != x
+	      && TLS_RELOC_P (reloc));
+    }
+}
+
 
 
 #define USE_MOVQ(i)	((unsigned) ((i) + 128) <= 255)
@@ -3918,18 +4466,92 @@
     }
 }
 
+/* Return string for TLS relocation RELOC.  */
+
+static const char *
+m68k_get_reloc_decoration (enum m68k_reloc reloc)
+{
+  /* To my knowledge, !MOTOROLA assemblers don't support TLS.  */
+  gcc_assert (MOTOROLA || reloc == RELOC_GOT);
+
+  switch (reloc)
+    {
+    case RELOC_GOT:
+      if (MOTOROLA)
+	{
+	  if (flag_pic == 1 && TARGET_68020)
+	    return "@GOT.w";
+	  else
+	    return "@GOT";
+	}
+      else
+	{
+	  if (TARGET_68020)
+	    {
+	      switch (flag_pic)
+		{
+		case 1:
+		  return ":w";
+		case 2:
+		  return ":l";
+		default:
+		  return "";
+		}
+	    }
+	}
+
+    case RELOC_TLSGD:
+      return "@TLSGD";
+
+    case RELOC_TLSLDM:
+      return "@TLSLDM";
+
+    case RELOC_TLSLDO:
+      return "@TLSLDO";
+
+    case RELOC_TLSIE:
+      return "@TLSIE";
+
+    case RELOC_TLSLE:
+      return "@TLSLE";
+
+    default:
+      gcc_unreachable ();
+    }
+}
+
 /* m68k implementation of OUTPUT_ADDR_CONST_EXTRA.  */
 
 bool
 m68k_output_addr_const_extra (FILE *file, rtx x)
 {
-  if (GET_CODE (x) != UNSPEC || XINT (x, 1) != UNSPEC_GOTOFF)
-    return false;
+  if (GET_CODE (x) == UNSPEC)
+    {
+      switch (XINT (x, 1))
+	{
+	case UNSPEC_RELOC16:
+	case UNSPEC_RELOC32:
+	  output_addr_const (file, XVECEXP (x, 0, 0));
+	  fputs (m68k_get_reloc_decoration (INTVAL (XVECEXP (x, 0, 1))), file);
+	  return true;
 
-  output_addr_const (file, XVECEXP (x, 0, 0));
-  /* ??? What is the non-MOTOROLA syntax?  */
-  fputs ("@GOT", file);
-  return true;
+	default:
+	  break;
+	}
+    }
+
+  return false;
+}
+
+/* M68K implementation of TARGET_ASM_OUTPUT_DWARF_DTPREL.  */
+
+static void
+m68k_output_dwarf_dtprel (FILE *file, int size, rtx x)
+{
+  gcc_assert (size == 4);
+  fputs ("\t.long\t", file);
+  output_addr_const (file, x);
+  fputs ("@TLSLDO+0x8000", file);
 }
 
 
@@ -4019,15 +4641,8 @@
 	  else
 	    {
 	      if (address.offset)
-		{
-		  output_addr_const (file, address.offset);
-		  if (flag_pic && address.base == pic_offset_table_rtx)
-		    {
-		      fprintf (file, "@GOT");
-		      if (flag_pic == 1 && TARGET_68020)
-			fprintf (file, ".w");
-		    }
-		}
+		output_addr_const (file, address.offset);
+
 	      putc ('(', file);
 	      if (address.base)
 		fputs (M68K_REGNAME (REGNO (address.base)), file);
@@ -4060,19 +4675,7 @@
 		    fputs (M68K_REGNAME (REGNO (address.base)), file);
 		  fprintf (file, "@(");
 		  if (address.offset)
-		    {
-		      output_addr_const (file, address.offset);
-		      if (address.base == pic_offset_table_rtx && TARGET_68020)
-			switch (flag_pic)
-			  {
-			  case 1:
-			    fprintf (file, ":w"); break;
-			  case 2:
-			    fprintf (file, ":l"); break;
-			  default:
-			    break;
-			  }
-		    }
+		    output_addr_const (file, address.offset);
 		}
 	      /* Print the ",index" component, if any.  */
 	      if (address.index)
@@ -4580,7 +5183,8 @@
   default:
     break;
   }
-  return gen_rtx_REG (mode, D0_REG);
+
+  return gen_rtx_REG (mode, m68k_libcall_value_in_a0_p ? A0_REG : D0_REG);
 }
 
 rtx
@@ -4846,9 +5450,8 @@
 	  return OP_TYPE_IMM_L;
 
 	default:
-	  if (GET_CODE (op) == SYMBOL_REF)
-	    /* ??? Just a guess.  Probably we can guess better using length
-	       attribute of the instructions.  */
+	  if (symbolic_operand (m68k_unwrap_symbol (op, false), VOIDmode))
+	    /* Just a guess.  */
 	    return OP_TYPE_IMM_W;
 
 	  return OP_TYPE_IMM_L;
@@ -5793,3 +6396,5 @@
       return 0;
     }
 }
+
+#include "gt-m68k.h"
diff -Nur a/gcc/config/m68k/m68k-devices.def b/gcc/config/m68k/m68k-devices.def
--- a/gcc/config/m68k/m68k-devices.def	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/m68k/m68k-devices.def	2010-01-25 09:50:29.025687257 +0100
@@ -72,8 +72,8 @@
 /* 680x0 series processors.  */
 M68K_DEVICE ("68000", m68000,   "68000", "68000", 68000,    isa_00,    0)
 M68K_DEVICE ("68010", m68010,   "68010", "68000", 68010,    isa_10,    0)
-M68K_DEVICE ("68020", m68020,   "68020", "68020", 68020,    isa_20,    FL_MMU)
-M68K_DEVICE ("68030", m68030,   "68030", "68020", 68030,    isa_20,    FL_MMU)
+M68K_DEVICE ("68020", m68020,   "68020", "68020", 68020,    isa_20,    FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("68030", m68030,   "68030", "68020", 68030,    isa_20,    FL_MMU | FL_UCLINUX)
 M68K_DEVICE ("68040", m68040,   "68040", "68040", 68040,    isa_40,    FL_MMU)
 M68K_DEVICE ("68060", m68060,   "68060", "68060", 68060,    isa_40,    FL_MMU)
 M68K_DEVICE ("68302", m68302,   "68302", "68000", 68000,    isa_00,    FL_MMU)
@@ -81,7 +81,13 @@
 M68K_DEVICE ("cpu32", cpu32,    "cpu32", "cpu32", cpu32,    isa_cpu32, FL_MMU)
 
 /* ColdFire CFV1 processor.  */
-M68K_DEVICE ("51qe",  mcf51qe,  "51qe",  "51qe",  cfv1,     isa_c,     FL_CF_USP)
+/* For historical reasons, the 51 multilib is named 51qe.  */
+M68K_DEVICE ("51",    mcf51,    "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
+M68K_DEVICE ("51ac",  mcf51ac,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
+M68K_DEVICE ("51cn",  mcf51cn,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
+M68K_DEVICE ("51em",  mcf51em,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP | FL_CF_MAC)
+M68K_DEVICE ("51jm",  mcf51jm,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
+M68K_DEVICE ("51qe",  mcf51qe,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
 
 /* ColdFire CFV2 processors.  */
 M68K_DEVICE ("5202",  mcf5202,  "5206",  "5206",  cfv2,     isa_a,     0)
@@ -97,6 +103,7 @@
 M68K_DEVICE ("5213",  mcf5213,  "5213",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("5214",  mcf5214,  "5216",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5216",  mcf5216,  "5216",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("5221x", mcf5221x, "5221x", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("52221", mcf52221, "52223", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("52223", mcf52223, "52223", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("52230", mcf52230, "52235", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
@@ -107,6 +114,14 @@
 M68K_DEVICE ("52235", mcf52235, "52235", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5224",  mcf5224,  "5225",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("5225",  mcf5225,  "5225",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
+M68K_DEVICE ("52252", mcf52252, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52254", mcf52254, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52255", mcf52255, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52256", mcf52256, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52258", mcf52258, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52259", mcf52259, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52274", mcf52274, "52277", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52277", mcf52277, "52277", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5232",  mcf5232,  "5235",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5233",  mcf5233,  "5235",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5234",  mcf5234,  "5235",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
@@ -126,6 +141,13 @@
 M68K_DEVICE ("528x",  mcf528x,  "5282",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 
 /* CFV3 processors.  */
+M68K_DEVICE ("53011", mcf53011, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53012", mcf53012, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53013", mcf53013, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53014", mcf53014, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53015", mcf53015, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53016", mcf53016, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53017", mcf53017, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5307",  mcf5307,  "5307",  "5307",  cfv3,     isa_a,     FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("5327",  mcf5327,  "5329",  "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5328",  mcf5328,  "5329",  "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
@@ -137,12 +159,17 @@
 
 /* CFV4/CFV4e processors.  */
 M68K_DEVICE ("5407",  mcf5407,  "5407",  "5407",  cfv4,     isa_b,     FL_CF_MAC)
-M68K_DEVICE ("54450", mcf54450, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
-M68K_DEVICE ("54451", mcf54451, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
-M68K_DEVICE ("54452", mcf54452, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
-M68K_DEVICE ("54453", mcf54453, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
-M68K_DEVICE ("54454", mcf54454, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
-M68K_DEVICE ("54455", mcf54455, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
+M68K_DEVICE ("54410", mcf54410, "54418", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54415", mcf54415, "54418", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54416", mcf54416, "54418", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54417", mcf54417, "54418", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54418", mcf54418, "54418", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54450", mcf54450, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54451", mcf54451, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54452", mcf54452, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54453", mcf54453, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54454", mcf54454, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54455", mcf54455, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
 M68K_DEVICE ("5470",  mcf5470,  "5475",  "5475",  cfv4e,    isa_b,     FL_CF_USP | FL_CF_EMAC | FL_CF_FPU | FL_MMU)
 M68K_DEVICE ("5471",  mcf5471,  "5475",  "5475",  cfv4e,    isa_b,     FL_CF_USP | FL_CF_EMAC | FL_CF_FPU | FL_MMU)
 M68K_DEVICE ("5472",  mcf5472,  "5475",  "5475",  cfv4e,    isa_b,     FL_CF_USP | FL_CF_EMAC | FL_CF_FPU | FL_MMU)
diff -Nur a/gcc/config/m68k/m68k.h b/gcc/config/m68k/m68k.h
--- a/gcc/config/m68k/m68k.h	2008-11-19 12:23:28.000000000 +0100
+++ b/gcc/config/m68k/m68k.h	2010-01-25 09:50:29.025687257 +0100
@@ -232,6 +232,7 @@
 #define FL_ISA_C     (1 << 16)
 #define FL_FIDOA     (1 << 17)
 #define FL_MMU 	     0   /* Used by multilib machinery.  */
+#define FL_UCLINUX   0   /* Used by multilib machinery.  */
 
 #define TARGET_68010		((m68k_cpu_flags & FL_ISA_68010) != 0)
 #define TARGET_68020		((m68k_cpu_flags & FL_ISA_68020) != 0)
@@ -501,7 +502,8 @@
 
 extern enum reg_class regno_reg_class[];
 #define REGNO_REG_CLASS(REGNO) (regno_reg_class[(REGNO)])
-#define INDEX_REG_CLASS GENERAL_REGS
+#define MODE_INDEX_REG_CLASS(MODE) \
+  (MODE_OK_FOR_INDEX_P (MODE) ? GENERAL_REGS : NO_REGS)
 #define BASE_REG_CLASS ADDR_REGS
 
 #define PREFERRED_RELOAD_CLASS(X,CLASS) \
@@ -644,7 +646,7 @@
    (though the operand list is empty).  */
 #define TRANSFER_FROM_TRAMPOLINE				\
 void								\
-__transfer_from_trampoline ()					\
+__transfer_from_trampoline (void)				\
 {								\
   register char *a0 asm (M68K_STATIC_CHAIN_REG_NAME);		\
   asm (GLOBAL_ASM_OP "___trampoline");				\
@@ -675,6 +677,10 @@
 #define HAVE_POST_INCREMENT 1
 #define HAVE_PRE_DECREMENT 1
 
+/* Return true if addresses of mode MODE can have an index register.  */
+#define MODE_OK_FOR_INDEX_P(MODE) \
+  (!TARGET_COLDFIRE_FPU || GET_MODE_CLASS (MODE) != MODE_FLOAT)
+
 /* Macros to check register numbers against specific register classes.  */
 
 /* True for data registers, D0 through D7.  */
@@ -689,9 +695,10 @@
 /* True for floating point registers, FP0 through FP7.  */
 #define FP_REGNO_P(REGNO)	IN_RANGE (REGNO, 16, 23)
 
-#define REGNO_OK_FOR_INDEX_P(REGNO)			\
-  (INT_REGNO_P (REGNO)					\
-   || INT_REGNO_P (reg_renumber[REGNO]))
+#define REGNO_MODE_OK_FOR_INDEX_P(REGNO, MODE)		\
+  (MODE_OK_FOR_INDEX_P (MODE)				\
+   && (INT_REGNO_P (REGNO)				\
+       || INT_REGNO_P (reg_renumber[REGNO])))
 
 #define REGNO_OK_FOR_BASE_P(REGNO)			\
   (ADDRESS_REGNO_P (REGNO)				\
@@ -751,13 +758,14 @@
 
 #define LEGITIMATE_PIC_OPERAND_P(X)				\
   (!symbolic_operand (X, VOIDmode)				\
-   || (TARGET_PCREL && REG_STRICT_P))
+   || (TARGET_PCREL && REG_STRICT_P)				\
+   || m68k_tls_reference_p (X, true))
 
 #define REG_OK_FOR_BASE_P(X) \
   m68k_legitimate_base_reg_p (X, REG_STRICT_P)
 
-#define REG_OK_FOR_INDEX_P(X) \
-  m68k_legitimate_index_reg_p (X, REG_STRICT_P)
+#define REG_MODE_OK_FOR_INDEX_P(X, MODE)	\
+  m68k_legitimate_index_reg_p (MODE, X, REG_STRICT_P)
 
 #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)				\
   do									\
@@ -770,52 +778,19 @@
 /* This address is OK as it stands.  */
 #define PIC_CASE_VECTOR_ADDRESS(index) index
 
-/* For the 68000, we handle X+REG by loading X into a register R and
-   using R+REG.  R will go in an address reg and indexing will be used.
-   However, if REG is a broken-out memory address or multiplication,
-   nothing needs to be done because REG can certainly go in an address reg.  */
-#define COPY_ONCE(Y) if (!copied) { Y = copy_rtx (Y); copied = ch = 1; }
-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)   \
-{ register int ch = (X) != (OLDX);					\
-  if (GET_CODE (X) == PLUS)						\
-    { int copied = 0;							\
-      if (GET_CODE (XEXP (X, 0)) == MULT)				\
-	{ COPY_ONCE (X); XEXP (X, 0) = force_operand (XEXP (X, 0), 0);}	\
-      if (GET_CODE (XEXP (X, 1)) == MULT)				\
-	{ COPY_ONCE (X); XEXP (X, 1) = force_operand (XEXP (X, 1), 0);}	\
-      if (ch && GET_CODE (XEXP (X, 1)) == REG				\
-	  && GET_CODE (XEXP (X, 0)) == REG)				\
-	{ if (TARGET_COLDFIRE_FPU					\
-	      && GET_MODE_CLASS (MODE) == MODE_FLOAT)			\
-	    { COPY_ONCE (X); X = force_operand (X, 0);}			\
-	  goto WIN; }							\
-      if (ch) { GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN); }		\
-      if (GET_CODE (XEXP (X, 0)) == REG					\
-	       || (GET_CODE (XEXP (X, 0)) == SIGN_EXTEND		\
-		   && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG		\
-		   && GET_MODE (XEXP (XEXP (X, 0), 0)) == HImode))	\
-	{ register rtx temp = gen_reg_rtx (Pmode);			\
-	  register rtx val = force_operand (XEXP (X, 1), 0);		\
-	  emit_move_insn (temp, val);					\
-	  COPY_ONCE (X);						\
-	  XEXP (X, 1) = temp;						\
-	  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT \
-	      && GET_CODE (XEXP (X, 0)) == REG)				\
-	    X = force_operand (X, 0);					\
-	  goto WIN; }							\
-      else if (GET_CODE (XEXP (X, 1)) == REG				\
-	       || (GET_CODE (XEXP (X, 1)) == SIGN_EXTEND		\
-		   && GET_CODE (XEXP (XEXP (X, 1), 0)) == REG		\
-		   && GET_MODE (XEXP (XEXP (X, 1), 0)) == HImode))	\
-	{ register rtx temp = gen_reg_rtx (Pmode);			\
-	  register rtx val = force_operand (XEXP (X, 0), 0);		\
-	  emit_move_insn (temp, val);					\
-	  COPY_ONCE (X);						\
-	  XEXP (X, 0) = temp;						\
-	  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT \
-	      && GET_CODE (XEXP (X, 1)) == REG)				\
-	    X = force_operand (X, 0);					\
-	  goto WIN; }}}
+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)		\
+do {							\
+  rtx __x;						\
+  							\
+  __x = m68k_legitimize_address (X, OLDX, MODE);	\
+  if (__x != NULL_RTX)					\
+    {							\
+      X = __x;						\
+							\
+      if (memory_address_p (MODE, X))			\
+	goto WIN;					\
+    }							\
+} while (0)
 
 /* On the 68000, only predecrement and postincrement address depend thus
    (the amount of decrement or increment being the length of the operand).
@@ -1028,6 +1003,9 @@
   assemble_name ((FILE), (NAME)),		\
   fprintf ((FILE), ",%u\n", (int)(ROUNDED)))
 
+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \
+  m68k_final_prescan_insn (INSN, OPVEC, NOPERANDS)
+
 /* On the 68000, we use several CODE characters:
    '.' for dot needed in Motorola-style opcode names.
    '-' for an operand pushing on the stack:
diff -Nur a/gcc/config/m68k/m68k.md b/gcc/config/m68k/m68k.md
--- a/gcc/config/m68k/m68k.md	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/m68k/m68k.md	2010-01-25 09:50:29.025687257 +0100
@@ -116,7 +116,8 @@
    (UNSPEC_GOT 3)
    (UNSPEC_IB 4)
    (UNSPEC_TIE 5)
-   (UNSPEC_GOTOFF 6)
+   (UNSPEC_RELOC16 6)
+   (UNSPEC_RELOC32 7)
   ])
 
 ;; UNSPEC_VOLATILE usage:
@@ -414,7 +415,7 @@
 
 (define_insn "tst<mode>_cf"
   [(set (cc0)
-	(match_operand:FP 0 "general_operand" "f<FP:dreg><Q>U"))]
+	(match_operand:FP 0 "general_operand" "f<FP:dreg>m"))]
   "TARGET_COLDFIRE_FPU"
 {
   cc_status.flags = CC_IN_68881;
@@ -570,8 +571,8 @@
 
 (define_insn "*cmp<mode>_cf"
   [(set (cc0)
-	(compare (match_operand:FP 0 "fp_src_operand" "f,f,<FP:dreg><Q>U")
-		 (match_operand:FP 1 "fp_src_operand" "f,<FP:dreg><Q>U,f")))]
+	(compare (match_operand:FP 0 "fp_src_operand" "f,f,<FP:dreg>m")
+		 (match_operand:FP 1 "fp_src_operand" "f,<FP:dreg>m,f")))]
   "TARGET_COLDFIRE_FPU
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
@@ -779,7 +780,41 @@
 {
   rtx tmp, base, offset;
 
-  if (flag_pic && !TARGET_PCREL && symbolic_operand (operands[1], SImode))
+  /* Recognize the case where operand[1] is a reference to thread-local
+     data and load its address to a register.  */
+  if (!TARGET_PCREL && m68k_tls_reference_p (operands[1], false))
+    {
+      rtx tmp = operands[1];
+      rtx addend = NULL;
+
+      if (GET_CODE (tmp) == CONST && GET_CODE (XEXP (tmp, 0)) == PLUS)
+        {
+          addend = XEXP (XEXP (tmp, 0), 1);
+          tmp = XEXP (XEXP (tmp, 0), 0);
+        }
+
+      gcc_assert (GET_CODE (tmp) == SYMBOL_REF);
+      gcc_assert (SYMBOL_REF_TLS_MODEL (tmp) != 0);
+
+      tmp = m68k_legitimize_tls_address (tmp);
+
+      if (addend)
+        {
+	  if (!REG_P (tmp))
+	    {
+	      rtx reg;
+
+	      reg = gen_reg_rtx (Pmode);
+	      emit_move_insn (reg, tmp);
+	      tmp = reg;
+	    }
+
+          tmp = gen_rtx_PLUS (SImode, tmp, addend);
+	}
+
+      operands[1] = tmp;
+    }
+  else if (flag_pic && !TARGET_PCREL && symbolic_operand (operands[1], SImode))
     {
       /* The source is an address which requires PIC relocation.
          Call legitimize_pic_address with the source, mode, and a relocation
@@ -1070,10 +1105,8 @@
 ;; SFmode MEMs are restricted to modes 2-4 if TARGET_COLDFIRE_FPU.
 ;; The move instructions can handle all combinations.
 (define_insn "movsf_cf_hard"
-  [(set (match_operand:SF 0 "nonimmediate_operand" "=r<Q>U, f,    f,mr,f,r<Q>,f
-,m")
-        (match_operand:SF 1 "general_operand"      " f,     r<Q>U,f,rm,F,F,   m
-,f"))]
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=rm,f, f,rm,f,r<Q>,f,m")
+        (match_operand:SF 1 "general_operand"      " f, rm,f,rm,F,F,   m,f"))]
   "TARGET_COLDFIRE_FPU"
 {
   if (which_alternative == 4 || which_alternative == 5) {
@@ -1215,8 +1248,8 @@
 })
 
 (define_insn "movdf_cf_hard"
-  [(set (match_operand:DF 0 "nonimmediate_operand" "=f,    <Q>U,r,f,r,r,m,f")
-        (match_operand:DF 1 "general_operand"      " f<Q>U,f,   f,r,r,m,r,E"))]
+  [(set (match_operand:DF 0 "nonimmediate_operand" "=f, m,r,f,r,r,m,f")
+        (match_operand:DF 1 "general_operand"      " fm,f,f,r,r,m,r,E"))]
   "TARGET_COLDFIRE_FPU"
 {
   rtx xoperands[3];
@@ -1857,7 +1890,7 @@
 (define_insn "extendsfdf2_cf"
   [(set (match_operand:DF 0 "nonimmediate_operand" "=f,f")
 	(float_extend:DF
-	 (match_operand:SF 1 "general_operand" "f,<Q>U")))]
+	 (match_operand:SF 1 "general_operand" "f,m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[0]) && FP_REG_P (operands[1]))
@@ -1897,9 +1930,9 @@
 })
 
 (define_insn "truncdfsf2_cf"
-  [(set (match_operand:SF 0 "nonimmediate_operand" "=f,d<Q>U")
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=f,dm")
 	(float_truncate:SF
-	  (match_operand:DF 1 "general_operand" "<Q>U,f")))]
+	  (match_operand:DF 1 "general_operand" "m,f")))]
   "TARGET_COLDFIRE_FPU"
   "@
   fsmove%.d %1,%0
@@ -2045,7 +2078,7 @@
 
 (define_insn "ftrunc<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
-        (fix:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U")))]
+        (fix:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[1]))
@@ -2338,9 +2371,9 @@
   "* return output_addsi3 (operands);")
 
 (define_insn_and_split "*addsi3_5200"
-  [(set (match_operand:SI 0 "nonimmediate_operand"         "=mr,mr,a,m,r,  ?a, ?a,?a,?a")
-	(plus:SI (match_operand:SI 1 "general_operand"     "%0, 0, 0,0,0,   a,  a, r, a")
-		 (match_operand:SI 2 "general_src_operand" " I, L, J,d,mrKi,Cj, r, a, J")))]
+  [(set (match_operand:SI 0 "nonimmediate_operand"         "=mr,mr,a,  m,r,  ?a, ?a,?a,?a")
+	(plus:SI (match_operand:SI 1 "general_operand"     "%0, 0, 0,  0,0,   a,  a, r, a")
+		 (match_operand:SI 2 "general_src_operand" " I, L, JCu,d,mrKi,Cj, r, a, JCu")))]
   "TARGET_COLDFIRE"
 {
   switch (which_alternative)
@@ -2382,9 +2415,9 @@
 	(plus:SI (match_dup 0)
 		 (match_dup 1)))]
   ""
-  [(set_attr "type" "aluq_l,aluq_l,lea,alu_l,alu_l,*,lea,lea,lea")
-   (set_attr "opy" "2,2,*,2,2,*,*,*,*")
-   (set_attr "opy_type" "*,*,mem5,*,*,*,mem6,mem6,mem5")])
+  [(set_attr "type"     "aluq_l,aluq_l,lea, alu_l,alu_l,*,lea, lea, lea")
+   (set_attr "opy"      "2,     2,     *,   2,    2,    *,*,   *,   *")
+   (set_attr "opy_type" "*,     *,     mem5,*,    *,    *,mem6,mem6,mem5")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=a")
@@ -2666,7 +2699,7 @@
 (define_insn "add<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
 	(plus:FP (match_operand:FP 1 "general_operand" "%0")
-		 (match_operand:FP 2 "general_operand" "f<FP:dreg><Q>U")))]
+		 (match_operand:FP 2 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -2889,7 +2922,7 @@
 (define_insn "sub<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
         (minus:FP (match_operand:FP 1 "general_operand" "0")
-                  (match_operand:FP 2 "general_operand" "f<FP:dreg><Q>U")))]
+                  (match_operand:FP 2 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -3245,7 +3278,7 @@
 (define_insn "fmul<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
 	(mult:FP (match_operand:FP 1 "general_operand" "%0")
-		 (match_operand:FP 2 "general_operand" "f<Q>U<FP:dreg>")))]
+		 (match_operand:FP 2 "general_operand" "fm<FP:dreg>")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -3315,7 +3348,7 @@
 (define_insn "div<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
 	(div:FP (match_operand:FP 1 "general_operand" "0")
-		(match_operand:FP 2 "general_operand" "f<Q>U<FP:dreg>")))]
+		(match_operand:FP 2 "general_operand" "fm<FP:dreg>")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -4163,7 +4196,7 @@
 
 (define_insn "neg<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f,d")
-	(neg:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U,0")))]
+	(neg:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m,0")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (DATA_REG_P (operands[0]))
@@ -4197,7 +4230,7 @@
 
 (define_insn "sqrt<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
-	(sqrt:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U")))]
+	(sqrt:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[1]))
@@ -4316,7 +4349,7 @@
 
 (define_insn "abs<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f,d")
-	(abs:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U,0")))]
+	(abs:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m,0")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (DATA_REG_P (operands[0]))
diff -Nur a/gcc/config/m68k/m68k.opt b/gcc/config/m68k/m68k.opt
--- a/gcc/config/m68k/m68k.opt	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/m68k/m68k.opt	2010-01-25 09:50:29.025687257 +0100
@@ -182,3 +182,7 @@
 mxgot
 Target Report Mask(XGOT)
 Support more than 8192 GOT entries on ColdFire
+
+mxtls
+Target Report Mask(XTLS)
+Support TLS segment larger than 64K
diff -Nur a/gcc/config/m68k/m68k-protos.h b/gcc/config/m68k/m68k-protos.h
--- a/gcc/config/m68k/m68k-protos.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/m68k/m68k-protos.h	2010-01-25 09:50:29.025687257 +0100
@@ -54,19 +54,27 @@
 extern bool m68k_output_addr_const_extra (FILE *, rtx);
 extern void notice_update_cc (rtx, rtx);
 extern bool m68k_legitimate_base_reg_p (rtx, bool);
-extern bool m68k_legitimate_index_reg_p (rtx, bool);
+extern bool m68k_legitimate_index_reg_p (enum machine_mode, rtx, bool);
 extern bool m68k_illegitimate_symbolic_constant_p (rtx);
 extern bool m68k_legitimate_address_p (enum machine_mode, rtx, bool);
 extern bool m68k_matches_q_p (rtx);
 extern bool m68k_matches_u_p (rtx);
 extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);
+extern rtx m68k_legitimize_tls_address (rtx);
+extern bool m68k_tls_reference_p (rtx, bool);
+extern rtx m68k_legitimize_address (rtx, rtx, enum machine_mode);
 extern int valid_dbcc_comparison_p_2 (rtx, enum machine_mode);
 extern rtx m68k_libcall_value (enum machine_mode);
 extern rtx m68k_function_value (const_tree, const_tree);
 extern int emit_move_sequence (rtx *, enum machine_mode, rtx);
 extern bool m68k_movem_pattern_p (rtx, rtx, HOST_WIDE_INT, bool);
 extern const char *m68k_output_movem (rtx *, rtx, HOST_WIDE_INT, bool);
+extern void m68k_final_prescan_insn (rtx, rtx *, int);
 
+/* Functions from m68k.c used in constraints.md.  */
+extern rtx m68k_unwrap_symbol (rtx, bool);
+
+/* Functions from m68k.c used in genattrtab.  */
 #ifdef HAVE_ATTR_cpu
 extern enum attr_cpu m68k_sched_cpu;
 extern enum attr_mac m68k_sched_mac;
diff -Nur a/gcc/config/m68k/predicates.md b/gcc/config/m68k/predicates.md
--- a/gcc/config/m68k/predicates.md	2007-09-24 23:00:22.000000000 +0200
+++ b/gcc/config/m68k/predicates.md	2010-01-25 09:50:29.025687257 +0100
@@ -130,7 +130,9 @@
   (match_code "sign_extend,zero_extend"))
 
 ;; Returns true if OP is either a symbol reference or a sum of a
-;; symbol reference and a constant.
+;; symbol reference and a constant.  This predicate is for "raw"
+;; symbol references not yet processed by legitimize*_address,
+;; hence we do not handle UNSPEC_{XGOT, TLS, XTLS} here.
 
 (define_predicate "symbolic_operand"
   (match_code "symbol_ref,label_ref,const")
diff -Nur a/gcc/config/m68k/t-uclinux b/gcc/config/m68k/t-uclinux
--- a/gcc/config/m68k/t-uclinux	2008-04-03 08:12:27.000000000 +0200
+++ b/gcc/config/m68k/t-uclinux	2010-01-25 09:50:29.025687257 +0100
@@ -1,8 +1,8 @@
 # crti and crtn are provided by uClibc.
 EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o
 
-# Only include multilibs for the 68020 and for CPUs without an MMU.
-M68K_MLIB_CPU += && (MLIB == "68020" || !match(FLAGS, "FL_MMU"))
+# Include multilibs for CPUs without an MMU or with FL_UCLINUX
+M68K_MLIB_CPU += && (!match(FLAGS, "FL_MMU") || match(FLAGS, "FL_UCLINUX"))
 
 # Add multilibs for execute-in-place and shared-library code.
 M68K_MLIB_OPTIONS += msep-data/mid-shared-library
diff -Nur a/gcc/config/mips/74k.md b/gcc/config/mips/74k.md
--- a/gcc/config/mips/74k.md	2007-08-02 12:49:31.000000000 +0200
+++ b/gcc/config/mips/74k.md	2010-01-25 09:50:29.025687257 +0100
@@ -118,8 +118,7 @@
 ;; stores
 (define_insn_reservation "r74k_int_store" 1
   (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
-       (and (eq_attr "type" "store")
-            (eq_attr "mode" "!unknown")))
+       (eq_attr "type" "store"))
   "r74k_agen")
 
 
@@ -145,33 +144,123 @@
 ;; load->load base:  4 cycles
 ;; load->store base: 4 cycles
 (define_bypass 4 "r74k_int_load" "r74k_int_load")
-(define_bypass 4 "r74k_int_load" "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 4 "r74k_int_load" "r74k_int_store" "!mips_store_data_bypass_p")
 
 ;; logical/move/slt/signext->next use :  1 cycles (Default)
 ;; logical/move/slt/signext->load base:  2 cycles
 ;; logical/move/slt/signext->store base: 2 cycles
 (define_bypass 2 "r74k_int_logical" "r74k_int_load")
-(define_bypass 2 "r74k_int_logical" "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 2 "r74k_int_logical" "r74k_int_store"
+  "!mips_store_data_bypass_p")
 
 ;; arith->next use :  2 cycles (Default)
 ;; arith->load base:  3 cycles
 ;; arith->store base: 3 cycles
 (define_bypass 3 "r74k_int_arith" "r74k_int_load")
-(define_bypass 3 "r74k_int_arith" "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 3 "r74k_int_arith" "r74k_int_store" "!mips_store_data_bypass_p")
 
 ;; cmove->next use :  4 cycles (Default)
 ;; cmove->load base:  5 cycles
 ;; cmove->store base: 5 cycles
 (define_bypass 5 "r74k_int_cmove"  "r74k_int_load")
-(define_bypass 5 "r74k_int_cmove"  "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 5 "r74k_int_cmove"  "r74k_int_store"
+  "!mips_store_data_bypass_p")
 
 ;; mult/madd/msub->int_mfhilo  : 4 cycles (default)
 ;; mult->madd/msub             : 1 cycles
 ;; madd/msub->madd/msub        : 1 cycles
-(define_bypass 1 "r74k_int_mult,r74k_int_mul3" "r74k_int_madd"
-  "mips_linked_madd_p")
-(define_bypass 1 "r74k_int_madd" "r74k_int_madd"
-  "mips_linked_madd_p")
+(define_bypass 1 "r74k_int_mult" "r74k_int_madd")
+(define_bypass 1 "r74k_int_madd" "r74k_int_madd")
+
+(define_bypass 1 "r74k_int_mul3" "r74k_int_madd"
+  "mips_mult_madd_chain_bypass_p")
+
+
+;; --------------------------------------------------------------
+;; DSP instructins
+;; --------------------------------------------------------------
+
+;; Non-saturating insn have the same latency as normal ALU operations,
+(define_insn_reservation "r74k_dsp_alu" 2
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspalu"))
+  "r74k_alu")
+
+;; Saturating insn takes an extra cycle.
+(define_insn_reservation "r74k_dsp_alu_sat" 3
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspalusat"))
+  "r74k_alu")
+
+;; dpaq_s, dpau, dpsq_s, dpsu, maq_s, mulsaq
+;; - delivers result to hi/lo in 6 cycle (bypass at M4)
+(define_insn_reservation "r74k_dsp_mac" 6
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspmac"))
+  "r74k_alu+r74k_mul")
+
+;; dpaq_sa, dpsq_sa, maq_sa
+;; - delivers result to hi/lo in 7 cycle (bypass at WB)
+(define_insn_reservation "r74k_dsp_mac_sat" 7
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspmacsat"))
+  "r74k_alu+r74k_mul")
+
+;; extp, extpdp, extpdpv, extpv, extr, extrv
+;; - same latency as "mul"
+(define_insn_reservation "r74k_dsp_acc_ext" 7
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "accext"))
+  "r74k_alu+r74k_mul")
+
+;; mthlip, shilo, shilov
+;; - same latency as "mul"
+(define_insn_reservation "r74k_dsp_acc_mod" 7
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "accmod"))
+  "r74k_alu+r74k_mul")
+
+;; dspalu   ->load/store base
+;; dspalusat->load/store base
+;; - we should never see these in real life.
+
+;; dsp_mac->dsp_mac     : 1 cycles (repeat rate of 1)
+;; dsp_mac->dsp_mac_sat : 1 cycles (repeat rate of 1)
+(define_bypass 1 "r74k_dsp_mac" "r74k_dsp_mac")
+(define_bypass 1 "r74k_dsp_mac" "r74k_dsp_mac_sat")
+
+;; dsp_mac_sat->dsp_mac_sat : 2 cycles (repeat rate of 2)
+;; dsp_mac_sat->dsp_mac     : 2 cycles (repeat rate of 2)
+(define_bypass 2 "r74k_dsp_mac_sat" "r74k_dsp_mac_sat")
+(define_bypass 2 "r74k_dsp_mac_sat" "r74k_dsp_mac")
+
+(define_bypass 1 "r74k_int_mult" "r74k_dsp_mac")
+(define_bypass 1 "r74k_int_mult" "r74k_dsp_mac_sat")
+
+;; Before reload, all multiplier is registered as imul3 (which has a long
+;;  latency).  We temporary jig the latency such that the macc groups
+;;  are scheduled closely together during the first scheduler pass.
+(define_bypass 1 "r74k_int_mul3" "r74k_dsp_mac"
+  "mips_mult_madd_chain_bypass_p")
+(define_bypass 1 "r74k_int_mul3" "r74k_dsp_mac_sat"
+  "mips_mult_madd_chain_bypass_p")
+
+;; Assuming the following is true (bypass at M4)
+;;  AP AF AM MB M1 M2 M3 M4 WB GR GC
+;;              AP AF AM MB M1 M2 M3 M4 WB GR GC
+;; dsp_mac->dsp_acc_ext : 4 cycles
+;; dsp_mac->dsp_acc_mod : 4 cycles
+(define_bypass 4 "r74k_dsp_mac" "r74k_dsp_acc_ext")
+(define_bypass 4 "r74k_dsp_mac" "r74k_dsp_acc_mod")
+
+;; Assuming the following is true (bypass at WB)
+;;  AP AF AM MB M1 M2 M3 M4 WB GR GC
+;;                 AP AF AM MB M1 M2 M3 M4 WB GR GC
+;; dsp_mac_sat->dsp_acc_ext : 5 cycles
+;; dsp_mac_sat->dsp_acc_mod : 5 cycles
+(define_bypass 5 "r74k_dsp_mac_sat" "r74k_dsp_acc_ext")
+(define_bypass 5 "r74k_dsp_mac_sat" "r74k_dsp_acc_mod")
+
 
 ;; --------------------------------------------------------------
 ;; Floating Point Instructions
diff -Nur a/gcc/config/mips/crtfastmath.c b/gcc/config/mips/crtfastmath.c
--- a/gcc/config/mips/crtfastmath.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/crtfastmath.c	2010-01-25 09:50:29.025687257 +0100
@@ -0,0 +1,53 @@
+/* Copyright (C) 2008, 2009 Free Software Foundation, Inc. 
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License
+   and a copy of the GCC Runtime Library Exception along with this
+   program; see the files COPYING3 and COPYING.RUNTIME respectively.
+   If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifdef __mips_hard_float
+
+/* flush denormalized numbers to zero */
+#define _FPU_FLUSH_TZ   0x1000000
+
+/* rounding control */
+#define _FPU_RC_NEAREST 0x0     /* RECOMMENDED */
+#define _FPU_RC_ZERO    0x1
+#define _FPU_RC_UP      0x2
+#define _FPU_RC_DOWN    0x3
+
+/* enable interrupts for IEEE exceptions */
+#define _FPU_IEEE     0x00000F80
+
+/* Macros for accessing the hardware control word.  */
+#define _FPU_GETCW(cw) __asm__ ("cfc1 %0,$31" : "=r" (cw))
+#define _FPU_SETCW(cw) __asm__ ("ctc1 %0,$31" : : "r" (cw))
+
+static void __attribute__((constructor))
+set_fast_math (void)
+{
+  unsigned int fcr;
+
+  /* fastmath: flush to zero, round to nearest, ieee exceptions disabled */
+  fcr = _FPU_FLUSH_TZ | _FPU_RC_NEAREST;
+
+  _FPU_SETCW(fcr);
+}
+
+#endif /* __mips_hard_float */
diff -Nur a/gcc/config/mips/cs-sgxx-linux.h b/gcc/config/mips/cs-sgxx-linux.h
--- a/gcc/config/mips/cs-sgxx-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/cs-sgxx-linux.h	2010-01-25 09:50:29.025687257 +0100
@@ -0,0 +1,44 @@
+/* MIPS SourceryG++ GNU/Linux Configuration.
+   Copyright (C) 2008
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* We do not need to provide an explicit big-endian multilib.  */
+#undef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS \
+  { "EB" }
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+"%{muclibc:/uclibc}\
+%{mips2|mips3|mips4|march=mips2|march=mips3|march=mips4|march=r6000|\
+march=r4000|march=vr4100|march=vr4111|march=vr4120|march=vr4130|\
+march=vr4300|march=r4400|march=r4600|march=orion|march=r4650|\
+march=loongson2e|march=loongson2f|march=r8000|march=r10000|\
+march=r12000|march=r14000|march=r16000|\
+march=vr5000|march=vr5400|march=vr5500|march=rm7000|\
+march=rm9000:/mips2;\
+mips32|march=mips32|march=4kc|march=4km|march=4kp|march=4ksc|\
+mips64|march=mips64|march=5kc|march=5kf|march=20kc|march=sb1|march=sb1a|\
+march=sr71000|march=xlr:/mips32}\
+%{msoft-float:/soft-float}%{mel|EL:/el}"
+
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC \
+  "%{muclibc:/uclibc}"
diff -Nur a/gcc/config/mips/cs-sgxxlite-linux.h b/gcc/config/mips/cs-sgxxlite-linux.h
--- a/gcc/config/mips/cs-sgxxlite-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/cs-sgxxlite-linux.h	2010-01-25 09:50:29.025687257 +0100
@@ -0,0 +1,33 @@
+/* MIPS SourceryG++ GNU/Linux Configuration.
+   Copyright (C) 2008
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* We do not need to provide an explicit big-endian multilib.  */
+#undef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS \
+  { "EB" }
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC \
+"%{muclibc:/uclibc}%{msoft-float:/soft-float}%{mel|EL:/el}"
+
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC \
+  "%{muclibc:/uclibc}"
diff -Nur a/gcc/config/mips/linux64.h b/gcc/config/mips/linux64.h
--- a/gcc/config/mips/linux64.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/mips/linux64.h	2010-01-25 09:50:29.025687257 +0100
@@ -69,3 +69,9 @@
    ieee_quad_format is the default, but let's put this here to make
    sure nobody thinks we just forgot to set it to something else.  */
 #define MIPS_TFMODE_FORMAT mips_quad_format
+
+/* Similar to standard Linux, but adding -ffast-math support.  */
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
+   %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
diff -Nur a/gcc/config/mips/linux.h b/gcc/config/mips/linux.h
--- a/gcc/config/mips/linux.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/mips/linux.h	2010-01-25 09:50:29.025687257 +0100
@@ -147,3 +147,17 @@
 #define DRIVER_SELF_SPECS \
   BASE_DRIVER_SELF_SPECS, \
   LINUX_DRIVER_SELF_SPECS
+
+/* Similar to standard Linux, but adding -ffast-math support.  */
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
+   %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
+
+#undef SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS                                      \
+do {                                                                    \
+  /* __thread_support is not supported by uClibc.  */                   \
+  if (linux_uclibc)                                             \
+    targetm.have_tls = 0;                                               \
+} while (0)
diff -Nur a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
--- a/gcc/config/mips/mips.c	2009-03-02 21:26:22.000000000 +0100
+++ b/gcc/config/mips/mips.c	2010-01-25 09:50:29.025687257 +0100
@@ -261,18 +261,29 @@
   /* Likewise FPR X.  */
   unsigned int fmask;
 
-  /* The number of GPRs and FPRs saved.  */
+  /* Likewise doubleword accumulator X ($acX).  */
+  unsigned int acc_mask;
+
+  /* The number of GPRs, FPRs, doubleword accumulators and COP0
+     registers saved.  */
   unsigned int num_gp;
   unsigned int num_fp;
+  unsigned int num_acc;
+  unsigned int num_cop0_regs;
 
-  /* The offset of the topmost GPR and FPR save slots from the top of
-     the frame, or zero if no such slots are needed.  */
+  /* The offset of the topmost GPR, FPR, accumulator and COP0-register
+     save slots from the top of the frame, or zero if no such slots are
+     needed.  */
   HOST_WIDE_INT gp_save_offset;
   HOST_WIDE_INT fp_save_offset;
+  HOST_WIDE_INT acc_save_offset;
+  HOST_WIDE_INT cop0_save_offset;
 
   /* Likewise, but giving offsets from the bottom of the frame.  */
   HOST_WIDE_INT gp_sp_offset;
   HOST_WIDE_INT fp_sp_offset;
+  HOST_WIDE_INT acc_sp_offset;
+  HOST_WIDE_INT cop0_sp_offset;
 
   /* The offset of arg_pointer_rtx from frame_pointer_rtx.  */
   HOST_WIDE_INT arg_pointer_offset;
@@ -310,6 +321,20 @@
   /* True if we have emitted an instruction to initialize
      mips16_gp_pseudo_rtx.  */
   bool initialized_mips16_gp_pseudo_p;
+
+  /* True if this is an interrupt handler.  */
+  bool interrupt_handler_p;
+
+  /* True if this is an interrupt handler that uses shadow registers.  */
+  bool use_shadow_register_set_p;
+
+  /* True if this is an interrupt handler that should keep interrupts
+     masked.  */
+  bool keep_interrupts_masked_p;
+
+  /* True if this is an interrupt handler that should use DERET
+     instead of ERET.  */
+  bool use_debug_exception_return_p;
 };
 
 /* Information about a single argument.  */
@@ -542,9 +567,16 @@
   ALL_REGS,	ALL_REGS,	ALL_REGS,	ALL_REGS
 };
 
+#ifdef CVMX_SHARED_BSS_FLAGS
+static tree octeon_handle_cvmx_shared_attribute (tree *, tree, tree, int, bool *);
+#endif
+
 /* The value of TARGET_ATTRIBUTE_TABLE.  */
 const struct attribute_spec mips_attribute_table[] = {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
+#ifdef CVMX_SHARED_BSS_FLAGS
+  { "cvmx_shared", 0, 0, true, false, false, octeon_handle_cvmx_shared_attribute },
+#endif
   { "long_call",   0, 0, false, true,  true,  NULL },
   { "far",     	   0, 0, false, true,  true,  NULL },
   { "near",        0, 0, false, true,  true,  NULL },
@@ -554,6 +586,11 @@
      code generation but don't carry other semantics.  */
   { "mips16", 	   0, 0, true,  false, false, NULL },
   { "nomips16",    0, 0, true,  false, false, NULL },
+  /* Allow functions to be specified as interrupt handlers */
+  { "interrupt",   0, 0, false, true,  true, NULL },
+  { "use_shadow_register_set",	0, 0, false, true,  true, NULL },
+  { "keep_interrupts_masked",	0, 0, false, true,  true, NULL },
+  { "use_debug_exception_return", 0, 0, false, true,  true, NULL },
   { NULL,	   0, 0, false, false, false, NULL }
 };
 
@@ -659,6 +696,11 @@
   { "74kx", PROCESSOR_74KF1_1, 33, 0 },
   { "74kf3_2", PROCESSOR_74KF3_2, 33, 0 },
 
+  { "1004kc", PROCESSOR_24KC, 33, 0 }, /* 1004K with MT/DSP.  */
+  { "1004kf2_1", PROCESSOR_24KF2_1, 33, 0 },
+  { "1004kf", PROCESSOR_24KF2_1, 33, 0 },
+  { "1004kf1_1", PROCESSOR_24KF1_1, 33, 0 },
+
   /* MIPS64 processors.  */
   { "5kc", PROCESSOR_5KC, 64, 0 },
   { "5kf", PROCESSOR_5KF, 64, 0 },
@@ -1064,13 +1106,7 @@
     DEFAULT_COSTS
   },
   { /* XLR */
-    /* Need to replace first five with the costs of calling the appropriate 
-       libgcc routine.  */
-    COSTS_N_INSNS (256),          /* fp_add */
-    COSTS_N_INSNS (256),          /* fp_mult_sf */
-    COSTS_N_INSNS (256),          /* fp_mult_df */
-    COSTS_N_INSNS (256),          /* fp_div_sf */
-    COSTS_N_INSNS (256),          /* fp_div_df */
+    SOFT_FP_COSTS,
     COSTS_N_INSNS (8),            /* int_mult_si */
     COSTS_N_INSNS (8),            /* int_mult_di */
     COSTS_N_INSNS (72),           /* int_div_si */
@@ -1172,6 +1208,42 @@
   return lookup_attribute ("nomips16", DECL_ATTRIBUTES (decl)) != NULL;
 }
 
+/* Check if the interrupt attribute is set for a function.  */
+
+static bool
+mips_interrupt_type_p (tree type)
+{
+  return lookup_attribute ("interrupt", TYPE_ATTRIBUTES (type)) != NULL;
+}
+
+/* Check if the attribute to use shadow register set is set for a function.  */
+
+static bool
+mips_use_shadow_register_set_p (tree type)
+{
+  return lookup_attribute ("use_shadow_register_set",
+			   TYPE_ATTRIBUTES (type)) != NULL;
+}
+
+/* Check if the attribute to keep interrupts masked is set for a function.  */
+
+static bool
+mips_keep_interrupts_masked_p (tree type)
+{
+  return lookup_attribute ("keep_interrupts_masked",
+			   TYPE_ATTRIBUTES (type)) != NULL;
+}
+
+/* Check if the attribute to use debug exception return is set for
+   a function.  */
+
+static bool
+mips_use_debug_exception_return_p (tree type)
+{
+  return lookup_attribute ("use_debug_exception_return",
+			   TYPE_ATTRIBUTES (type)) != NULL;
+}
+
 /* Return true if function DECL is a MIPS16 function.  Return the ambient
    setting if DECL is null.  */
 
@@ -2795,7 +2867,7 @@
 mips_legitimize_address (rtx *xloc, enum machine_mode mode)
 {
   rtx base, addr;
-  HOST_WIDE_INT offset;
+  HOST_WIDE_INT intval, high, offset;
 
   if (mips_tls_symbol_p (*xloc))
     {
@@ -2820,6 +2892,32 @@
       *xloc = mips_force_address (addr, mode);
       return true;
     }
+
+ /* Handle references to constant addresses by loading the high part
+    into a register and using an offset for the low part.  */
+ if (GET_CODE (base) == CONST_INT)
+   {
+     intval = INTVAL (base);
+     high = trunc_int_for_mode (CONST_HIGH_PART (intval), Pmode);
+     offset = CONST_LOW_PART (intval);
+     /* Ignore cases in which a positive address would be accessed by a
+	negative offset from a negative address.  The required wraparound
+	does not occur for 32-bit addresses on 64-bit targets, and it is
+	very unlikely that such an access would occur in real code anyway.
+
+	If the low offset is not legitimate for MODE, prefer to load
+	the constant normally, instead of using mips_force_address on
+	the legitimized address.  The latter option would cause us to
+	use (D)ADDIU unconditionally, but LUI/ORI is more efficient
+	than LUI/ADDIU on some targets.  */
+     if ((intval < 0 || high > 0)
+	  && mips_valid_offset_p (GEN_INT (offset), mode))
+	{
+	  base = mips_force_temporary (NULL, GEN_INT (high));
+	  *xloc = plus_constant (base, offset);
+	  return true;
+	}
+   }
   return false;
 }
 
@@ -6188,6 +6286,11 @@
   if (!TARGET_SIBCALLS)
     return false;
 
+  /* Interrupt handlers need special epilogue code and therefore can't
+     use sibcalls.  */
+  if (mips_interrupt_type_p (TREE_TYPE (current_function_decl)))
+    return false;
+
   /* We can't do a sibcall if the called function is a MIPS16 function
      because there is no direct "jx" instruction equivalent to "jalx" to
      switch the ISA mode.  We only care about cases where the sibling
@@ -6608,6 +6711,15 @@
   if (!mips_get_unaligned_mem (&src, width, bitpos, &left, &right))
     return false;
 
+  if (ISA_HAS_UL_US)
+    {
+      if (GET_MODE (dest) == DImode)
+	emit_insn (gen_mov_uld (dest, src, left));
+      else
+	emit_insn (gen_mov_ulw (dest, src, left));
+      return true;
+    }
+
   temp = gen_reg_rtx (GET_MODE (dest));
   if (GET_MODE (dest) == DImode)
     {
@@ -6642,6 +6754,16 @@
 
   mode = mode_for_size (width, MODE_INT, 0);
   src = gen_lowpart (mode, src);
+
+  if (ISA_HAS_UL_US)
+    {
+      if (GET_MODE (src) == DImode)
+        emit_insn (gen_mov_usd (dest, src, left));
+      else
+        emit_insn (gen_mov_usw (dest, src, left));
+      return true;
+    }
+
   if (mode == DImode)
     {
       emit_insn (gen_mov_sdl (dest, src, left));
@@ -7229,7 +7351,11 @@
 		|| (letter == 'L' && TARGET_BIG_ENDIAN)
 		|| letter == 'D')
 	      regno++;
-	    fprintf (file, "%s", reg_names[regno]);
+	    /* We need to print $0 .. $31 for COP0 registers.  */
+	    if (COP0_REG_P (regno))
+	      fprintf (file, "$%s", &reg_names[regno][4]);
+	    else
+	      fprintf (file, "%s", reg_names[regno]);
 	  }
 	  break;
 
@@ -7369,6 +7495,12 @@
   if (TARGET_ABICALLS || TARGET_VXWORKS_RTP)
     return false;
 
+#ifdef CVMX_SHARED_BSS_FLAGS
+  if (TARGET_OCTEON && TREE_CODE (decl) == VAR_DECL
+      && lookup_attribute ("cvmx_shared", DECL_ATTRIBUTES (decl)))
+    return false;
+#endif
+
   if (TREE_CODE (decl) == VAR_DECL && DECL_SECTION_NAME (decl) != 0)
     {
       const char *name;
@@ -7595,6 +7727,37 @@
   return NULL_RTX;
 }
 
+/* DSP ALU can bypass data with no delays for the following pairs. */
+enum insn_code dspalu_bypass_table[][2] =
+{
+  {CODE_FOR_mips_addsc, CODE_FOR_mips_addwc},
+  {CODE_FOR_mips_cmpu_eq_qb, CODE_FOR_mips_pick_qb},
+  {CODE_FOR_mips_cmpu_lt_qb, CODE_FOR_mips_pick_qb},
+  {CODE_FOR_mips_cmpu_le_qb, CODE_FOR_mips_pick_qb},
+  {CODE_FOR_mips_cmp_eq_ph, CODE_FOR_mips_pick_ph},
+  {CODE_FOR_mips_cmp_lt_ph, CODE_FOR_mips_pick_ph},
+  {CODE_FOR_mips_cmp_le_ph, CODE_FOR_mips_pick_ph},
+  {CODE_FOR_mips_wrdsp, CODE_FOR_mips_insv}
+};
+
+int
+mips_dspalu_bypass_p (rtx out_insn, rtx in_insn)
+{
+  int i;
+  int num_bypass = (sizeof (dspalu_bypass_table)
+		    / (2 * sizeof (enum insn_code)));
+  enum insn_code out_icode = INSN_CODE (out_insn);
+  enum insn_code in_icode = INSN_CODE (in_insn);
+
+  for (i = 0; i < num_bypass; i++)
+    {
+      if (out_icode == dspalu_bypass_table[i][0]
+	  && in_icode == dspalu_bypass_table[i][1])
+       return true;
+    }
+
+  return false;
+}
 /* Implement ASM_OUTPUT_ASCII.  */
 
 void
@@ -7819,11 +7982,19 @@
 		 "\t.previous\n", TARGET_LONG64 ? 64 : 32);
 
 #ifdef HAVE_AS_GNU_ATTRIBUTE
+#ifdef TARGET_MIPS_SDEMTK
+     fprintf (asm_out_file, "\t.gnu_attribute 4, %d\n",
+             (!TARGET_NO_FLOAT
+              ? (TARGET_HARD_FLOAT
+                 ? (TARGET_DOUBLE_FLOAT
+                    ? ((!TARGET_64BIT && TARGET_FLOAT64) ? 4 : 1) : 2) : 3) : 0));
+#else
       fprintf (asm_out_file, "\t.gnu_attribute 4, %d\n",
 	       (TARGET_HARD_FLOAT_ABI
 		? (TARGET_DOUBLE_FLOAT
 		   ? ((!TARGET_64BIT && TARGET_FLOAT64) ? 4 : 1) : 2) : 3));
 #endif
+#endif
     }
 
   /* If TARGET_ABICALLS, tell GAS to generate -KPIC code.  */
@@ -8436,12 +8607,53 @@
   return GLOBAL_POINTER_REGNUM;
 }
 
+/* Return true if REGNO is a register that is ordinarily call-clobbered
+   but must nevertheless be preserved by an interrupt handler.  */
+
+static bool
+mips_interrupt_extra_call_saved_reg_p (unsigned int regno)
+{
+  if (MD_REG_P (regno))
+    return true;
+
+  if (TARGET_DSP && DSP_ACC_REG_P (regno))
+    return true;
+
+  if (GP_REG_P (regno) && !cfun->machine->use_shadow_register_set_p)
+    {
+      /* $0 is hard-wired.  */
+      if (regno == GP_REG_FIRST)
+	return false;
+
+      /* The interrupt handler can treat kernel registers as
+	 scratch registers.  */
+      if (KERNEL_REG_P (regno))
+	return false;
+
+      /* The function will return the stack pointer to its original value
+	 anyway.  */
+      if (regno == STACK_POINTER_REGNUM)
+	return false;
+
+      /* Otherwise, return true for registers that aren't ordinarily
+	 call-clobbered.  */
+      return call_really_used_regs[regno];
+    }
+
+  return false;
+}
+
 /* Return true if the current function should treat register REGNO
    as call-saved.  */
 
 static bool
 mips_cfun_call_saved_reg_p (unsigned int regno)
 {
+  /* Interrupt handlers need to save extra registers.  */
+  if (cfun->machine->interrupt_handler_p
+      && mips_interrupt_extra_call_saved_reg_p (regno))
+    return true;
+
   /* call_insns preserve $28 unless they explicitly say otherwise,
      so call_really_used_regs[] treats $28 as call-saved.  However,
      we want the ABI property rather than the default call_insn
@@ -8490,6 +8702,13 @@
   if (regno == GP_REG_FIRST + 31 && mips16_cfun_returns_in_fpr_p ())
     return true;
 
+  /* If REGNO is ordinarily call-clobbered, we must assume that any
+     called function could modify it.  */
+  if (cfun->machine->interrupt_handler_p
+      && !current_function_is_leaf
+      && mips_interrupt_extra_call_saved_reg_p (regno))
+    return true;
+
   return false;
 }
 
@@ -8545,6 +8764,14 @@
       C |  callee-allocated save area   |
 	|  for register varargs         |
 	|                               |
+	+-------------------------------+ <-- frame_pointer_rtx
+	|                               |       + cop0_sp_offset
+	|  COP0 reg save area           |	+ UNITS_PER_WORD
+	|                               |
+	+-------------------------------+ <-- frame_pointer_rtx + acc_sp_offset
+	|                               |       + UNITS_PER_WORD
+	|  accumulator save area        |
+	|                               |
 	+-------------------------------+ <-- frame_pointer_rtx + fp_sp_offset
 	|                               |       + UNITS_PER_HWFPVALUE
 	|  FPR save area                |
@@ -8588,6 +8815,28 @@
   HOST_WIDE_INT offset, size;
   unsigned int regno, i;
 
+  /* Set this function's interrupt properties.  */
+  if (mips_interrupt_type_p (TREE_TYPE (current_function_decl)))
+    {
+      if (!ISA_MIPS32R2)
+	error ("the %<interrupt%> attribute requires a MIPS32r2 processor");
+      else if (TARGET_HARD_FLOAT)
+	error ("the %<interrupt%> attribute requires %<-msoft-float%>");
+      else if (TARGET_MIPS16)
+	error ("interrupt handlers cannot be MIPS16 functions");
+      else
+	{
+	  cfun->machine->interrupt_handler_p = true;
+	  cfun->machine->use_shadow_register_set_p =
+	    mips_use_shadow_register_set_p (TREE_TYPE (current_function_decl));
+	  cfun->machine->keep_interrupts_masked_p =
+	    mips_keep_interrupts_masked_p (TREE_TYPE (current_function_decl));
+	  cfun->machine->use_debug_exception_return_p =
+	    mips_use_debug_exception_return_p (TREE_TYPE
+					       (current_function_decl));
+	}
+    }
+
   frame = &cfun->machine->frame;
   memset (frame, 0, sizeof (*frame));
   size = get_frame_size ();
@@ -8657,7 +8906,7 @@
     }
 
   /* Find out which FPRs we need to save.  This loop must iterate over
-     the same space as its companion in mips_for_each_saved_reg.  */
+     the same space as its companion in mips_for_each_saved_gpr_and_fpr.  */
   if (TARGET_HARD_FLOAT)
     for (regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno += MAX_FPRS_PER_FMT)
       if (mips_save_reg_p (regno))
@@ -8673,6 +8922,47 @@
       frame->fp_sp_offset = offset - UNITS_PER_HWFPVALUE;
     }
 
+  /* Add in space for the interrupt context information.  */
+  if (cfun->machine->interrupt_handler_p)
+    {
+      /* Check HI/LO.  */
+      if (mips_save_reg_p (LO_REGNUM) || mips_save_reg_p (HI_REGNUM))
+	{
+	  frame->num_acc++;
+	  frame->acc_mask |= (1 << 0);
+	}
+
+      /* Check accumulators 1, 2, 3.  */
+      for (i = DSP_ACC_REG_FIRST; i <= DSP_ACC_REG_LAST; i += 2)
+	if (mips_save_reg_p (i) || mips_save_reg_p (i + 1))
+	  {
+	    frame->num_acc++;
+	    frame->acc_mask |= 1 << (((i - DSP_ACC_REG_FIRST) / 2) + 1);
+	  }
+
+      /* All interrupt context functions need space to preserve STATUS.  */
+      frame->num_cop0_regs++;
+
+      /* If we don't keep interrupts masked, we need to save EPC.  */
+      if (!cfun->machine->keep_interrupts_masked_p)
+	frame->num_cop0_regs++;
+    }
+
+  /* Move above the accumulator save area.  */
+  if (frame->num_acc > 0)
+    {
+      /* Each accumulator needs 2 words.  */
+      offset += frame->num_acc * 2 * UNITS_PER_WORD;
+      frame->acc_sp_offset = offset - UNITS_PER_WORD;
+    }
+
+  /* Move above the COP0 register save area.  */
+  if (frame->num_cop0_regs > 0)
+    {
+      offset += frame->num_cop0_regs * UNITS_PER_WORD;
+      frame->cop0_sp_offset = offset - UNITS_PER_WORD;
+    }
+
   /* Move above the callee-allocated varargs save area.  */
   offset += MIPS_STACK_ALIGN (cfun->machine->varargs_size);
   frame->arg_pointer_offset = offset;
@@ -8686,6 +8976,10 @@
     frame->gp_save_offset = frame->gp_sp_offset - offset;
   if (frame->fp_sp_offset > 0)
     frame->fp_save_offset = frame->fp_sp_offset - offset;
+  if (frame->acc_sp_offset > 0)
+    frame->acc_save_offset = frame->acc_sp_offset - offset;
+  if (frame->num_cop0_regs > 0)
+    frame->cop0_save_offset = frame->cop0_sp_offset - offset;
 
   /* MIPS16 code offsets the frame pointer by the size of the outgoing
      arguments.  This tends to increase the chances of using unextended
@@ -8882,12 +9176,41 @@
   fn (gen_rtx_REG (mode, regno), mem);
 }
 
+/* Call FN for each accumlator that is saved by the current function.
+   SP_OFFSET is the offset of the current stack pointer from the start
+   of the frame.  */
+
+static void
+mips_for_each_saved_acc (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)
+{
+  HOST_WIDE_INT offset;
+  int regno;
+
+  offset = cfun->machine->frame.acc_sp_offset - sp_offset;
+  if (BITSET_P (cfun->machine->frame.acc_mask, 0))
+    {
+      mips_save_restore_reg (word_mode, LO_REGNUM, offset, fn);
+      offset -= UNITS_PER_WORD;
+      mips_save_restore_reg (word_mode, HI_REGNUM, offset, fn);
+      offset -= UNITS_PER_WORD;
+    }
+
+  for (regno = DSP_ACC_REG_FIRST; regno <= DSP_ACC_REG_LAST; regno++)
+    if (BITSET_P (cfun->machine->frame.acc_mask,
+		  ((regno - DSP_ACC_REG_FIRST) / 2) + 1))
+      {
+	mips_save_restore_reg (word_mode, regno, offset, fn);
+	offset -= UNITS_PER_WORD;
+      }
+}
+
 /* Call FN for each register that is saved by the current function.
    SP_OFFSET is the offset of the current stack pointer from the start
    of the frame.  */
 
 static void
-mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)
+mips_for_each_saved_gpr_and_fpr (HOST_WIDE_INT sp_offset,
+				 mips_save_restore_fn fn)
 {
   enum machine_mode fpr_mode;
   HOST_WIDE_INT offset;
@@ -9075,13 +9398,24 @@
     }
   else
     {
-      if (TARGET_MIPS16
-	  && REGNO (reg) != GP_REG_FIRST + 31
-	  && !M16_REG_P (REGNO (reg)))
-	{
-	  /* Save a non-MIPS16 register by moving it through a temporary.
-	     We don't need to do this for $31 since there's a special
-	     instruction for it.  */
+      if (REGNO (reg) == HI_REGNUM)
+	{
+	  if (TARGET_64BIT)
+	    emit_insn (gen_mfhidi_ti (MIPS_PROLOGUE_TEMP (DImode),
+				      gen_rtx_REG (TImode, MD_REG_FIRST)));
+	  else
+	    emit_insn (gen_mfhisi_di (MIPS_PROLOGUE_TEMP (SImode),
+				      gen_rtx_REG (DImode, MD_REG_FIRST)));
+	  mips_emit_move (mem, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));
+	}
+      else if ((TARGET_MIPS16
+		&& REGNO (reg) != GP_REG_FIRST + 31
+		&& !M16_REG_P (REGNO (reg)))
+	       || ACC_REG_P (REGNO (reg)))
+	{
+	  /* If the register has no direct store instruction, move it
+	     through a temporary.  Note that there's a special MIPS16
+	     instruction to save $31.  */
 	  mips_emit_move (MIPS_PROLOGUE_TEMP (GET_MODE (reg)), reg);
 	  mips_emit_move (mem, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));
 	}
@@ -9153,6 +9487,14 @@
     emit_insn (gen_loadgp_blockage ());
 }
 
+/* A for_each_rtx callback.  Stop the search if *X is a kernel register.  */
+
+static int
+mips_kernel_reg_p (rtx *x, void *data ATTRIBUTE_UNUSED)
+{
+  return GET_CODE (*x) == REG && KERNEL_REG_P (REGNO (*x));
+}
+
 /* Expand the "prologue" pattern.  */
 
 void
@@ -9172,7 +9514,8 @@
   /* Save the registers.  Allocate up to MIPS_MAX_FIRST_STACK_STEP
      bytes beforehand; this is enough to cover the register save area
      without going out of range.  */
-  if ((frame->mask | frame->fmask) != 0)
+  if (((frame->mask | frame->fmask | frame->acc_mask) != 0)
+      || frame->num_cop0_regs > 0)
     {
       HOST_WIDE_INT step1;
 
@@ -9203,12 +9546,97 @@
  	}
       else
  	{
-	  insn = gen_add3_insn (stack_pointer_rtx,
-				stack_pointer_rtx,
-				GEN_INT (-step1));
-	  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
-	  size -= step1;
-	  mips_for_each_saved_reg (size, mips_save_reg);
+	  if (cfun->machine->interrupt_handler_p)
+	    {
+	      HOST_WIDE_INT offset;
+	      rtx mem;
+
+	      /* If this interrupt is using a shadow register set, we need to
+		 get the stack pointer from the previous register set.  */
+	      if (cfun->machine->use_shadow_register_set_p)
+		emit_insn (gen_mips_rdpgpr (stack_pointer_rtx,
+					    stack_pointer_rtx));
+
+	      if (!cfun->machine->keep_interrupts_masked_p)
+		{
+		  /* Move from COP0 Cause to K0.  */
+		  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K0_REG_NUM),
+					    gen_rtx_REG (SImode,
+							 COP0_CAUSE_REG_NUM)));
+		  /* Move from COP0 EPC to K1.  */
+		  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K1_REG_NUM),
+					    gen_rtx_REG (SImode,
+							 COP0_EPC_REG_NUM)));
+		}
+
+	      /* Allocate the first part of the frame.  */
+	      insn = gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,
+				    GEN_INT (-step1));
+	      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
+	      size -= step1;
+
+	      /* Start at the uppermost location for saving.  */
+	      offset = frame->cop0_sp_offset - size;
+	      if (!cfun->machine->keep_interrupts_masked_p)
+		{
+		  /* Push EPC into its stack slot.  */
+		  mem = gen_frame_mem (word_mode,
+				       plus_constant (stack_pointer_rtx,
+						      offset));
+		  mips_emit_move (mem, gen_rtx_REG (word_mode, K1_REG_NUM));
+		  offset -= UNITS_PER_WORD;
+		}
+
+	      /* Move from COP0 Status to K1.  */
+	      emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K1_REG_NUM),
+					gen_rtx_REG (SImode,
+						     COP0_STATUS_REG_NUM)));
+
+	      /* Right justify the RIPL in k0.  */
+	      if (!cfun->machine->keep_interrupts_masked_p)
+		emit_insn (gen_lshrsi3 (gen_rtx_REG (SImode, K0_REG_NUM),
+					gen_rtx_REG (SImode, K0_REG_NUM),
+					GEN_INT (CAUSE_IPL)));
+
+	      /* Push Status into its stack slot.  */
+	      mem = gen_frame_mem (word_mode,
+				   plus_constant (stack_pointer_rtx, offset));
+	      mips_emit_move (mem, gen_rtx_REG (word_mode, K1_REG_NUM));
+	      offset -= UNITS_PER_WORD;
+
+	      /* Insert the RIPL into our copy of SR (k1) as the new IPL.  */
+	      if (!cfun->machine->keep_interrupts_masked_p)
+		emit_insn (gen_insvsi (gen_rtx_REG (SImode, K1_REG_NUM),
+				       GEN_INT (6),
+				       GEN_INT (SR_IPL),
+				       gen_rtx_REG (SImode, K0_REG_NUM)));
+
+	      if (!cfun->machine->keep_interrupts_masked_p)
+		/* Enable interrupts by clearing the KSU ERL and EXL bits.
+		   IE is already the correct value, so we don't have to do
+		   anything explicit.  */
+		emit_insn (gen_insvsi (gen_rtx_REG (SImode, K1_REG_NUM),
+				       GEN_INT (4),
+				       GEN_INT (SR_EXL),
+				       gen_rtx_REG (SImode, GP_REG_FIRST)));
+	      else
+		/* Disable interrupts by clearing the KSU, ERL, EXL,
+		   and IE bits.  */
+		emit_insn (gen_insvsi (gen_rtx_REG (SImode, K1_REG_NUM),
+				       GEN_INT (5),
+				       GEN_INT (SR_IE),
+				       gen_rtx_REG (SImode, GP_REG_FIRST)));
+	    }
+	  else
+	    {
+	      insn = gen_add3_insn (stack_pointer_rtx,
+				    stack_pointer_rtx,
+				    GEN_INT (-step1));
+	      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
+	      size -= step1;
+	    }
+	  mips_for_each_saved_acc (size, mips_save_reg);
+	  mips_for_each_saved_gpr_and_fpr (size, mips_save_reg);
 	}
     }
 
@@ -9293,6 +9721,20 @@
 			pic_offset_table_rtx);
     }
 
+  /* We need to search back to the last use of K0 or K1.  */
+  if (cfun->machine->interrupt_handler_p)
+    {
+      for (insn = get_last_insn (); insn != NULL_RTX; insn = PREV_INSN (insn))
+	if (INSN_P (insn)
+	    && for_each_rtx (&PATTERN (insn), mips_kernel_reg_p, NULL))
+	  break;
+      /* Emit a move from K1 to COP0 Status after insn.  */
+      gcc_assert (insn != NULL_RTX);
+      emit_insn_after (gen_cop0_move (gen_rtx_REG (SImode, COP0_STATUS_REG_NUM),
+				      gen_rtx_REG (SImode, K1_REG_NUM)),
+		       insn);
+    }
+
   /* If we are profiling, make sure no instructions are scheduled before
      the call to mcount.  */
   if (crtl->profile)
@@ -9309,7 +9751,20 @@
   if (TARGET_MIPS16 && REGNO (reg) == GP_REG_FIRST + 31)
     reg = gen_rtx_REG (GET_MODE (reg), GP_REG_FIRST + 7);
 
-  if (TARGET_MIPS16 && !M16_REG_P (REGNO (reg)))
+  if (REGNO (reg) == HI_REGNUM)
+    {
+      mips_emit_move (MIPS_EPILOGUE_TEMP (GET_MODE (reg)), mem);
+      if (TARGET_64BIT)
+	emit_insn (gen_mthisi_di (gen_rtx_REG (TImode, MD_REG_FIRST),
+				  MIPS_EPILOGUE_TEMP (DImode),
+				  gen_rtx_REG (DImode, LO_REGNUM)));
+      else
+	emit_insn (gen_mthisi_di (gen_rtx_REG (DImode, MD_REG_FIRST),
+				  MIPS_EPILOGUE_TEMP (SImode),
+				  gen_rtx_REG (SImode, LO_REGNUM)));
+    }
+  else if ((TARGET_MIPS16 && !M16_REG_P (REGNO (reg)))
+	   || ACC_REG_P (REGNO (reg)))
     {
       /* Can't restore directly; move through a temporary.  */
       mips_emit_move (MIPS_EPILOGUE_TEMP (GET_MODE (reg)), mem);
@@ -9345,7 +9800,7 @@
 {
   const struct mips_frame_info *frame;
   HOST_WIDE_INT step1, step2;
-  rtx base, target;
+  rtx base, target, insn;
 
   if (!sibcall_p && mips_can_use_return_insn ())
     {
@@ -9378,7 +9833,8 @@
 
   /* If we need to restore registers, deallocate as much stack as
      possible in the second step without going out of range.  */
-  if ((frame->mask | frame->fmask) != 0)
+  if ((frame->mask | frame->fmask | frame->acc_mask) != 0
+      || frame->num_cop0_regs > 0)
     {
       step2 = MIN (step1, MIPS_MAX_FIRST_STACK_STEP);
       step1 -= step2;
@@ -9440,13 +9896,53 @@
   else
     {
       /* Restore the registers.  */
-      mips_for_each_saved_reg (frame->total_size - step2, mips_restore_reg);
+      mips_for_each_saved_acc (frame->total_size - step2, mips_restore_reg);
+      mips_for_each_saved_gpr_and_fpr (frame->total_size - step2,
+				       mips_restore_reg);
 
-      /* Deallocate the final bit of the frame.  */
-      if (step2 > 0)
-	emit_insn (gen_add3_insn (stack_pointer_rtx,
-				  stack_pointer_rtx,
-				  GEN_INT (step2)));
+      if (cfun->machine->interrupt_handler_p)
+	{
+	  HOST_WIDE_INT offset;
+	  rtx mem;
+
+	  offset = frame->cop0_sp_offset - (frame->total_size - step2);
+	  if (!cfun->machine->keep_interrupts_masked_p)
+	    {
+	      /* Restore the original EPC.  */
+	      mem = gen_frame_mem (word_mode,
+				   plus_constant (stack_pointer_rtx, offset));
+	      mips_emit_move (gen_rtx_REG (word_mode, K0_REG_NUM), mem);
+	      offset -= UNITS_PER_WORD;
+
+	      /* Move to COP0 EPC.  */
+	      emit_insn (gen_cop0_move (gen_rtx_REG (SImode, COP0_EPC_REG_NUM),
+					gen_rtx_REG (SImode, K0_REG_NUM)));
+	    }
+
+	  /* Restore the original Status.  */
+	  mem = gen_frame_mem (word_mode,
+			       plus_constant (stack_pointer_rtx, offset));
+	  mips_emit_move (gen_rtx_REG (word_mode, K0_REG_NUM), mem);
+	  offset -= UNITS_PER_WORD;
+
+	  /* If we don't use shoadow register set, we need to update SP.  */
+	  if (!cfun->machine->use_shadow_register_set_p && step2 > 0)
+	    emit_insn (gen_add3_insn (stack_pointer_rtx,
+				      stack_pointer_rtx,
+				      GEN_INT (step2)));
+
+	  /* Move to COP0 Status.  */
+	  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, COP0_STATUS_REG_NUM),
+				    gen_rtx_REG (SImode, K0_REG_NUM)));
+	}
+      else
+	{
+	  /* Deallocate the final bit of the frame.  */
+	  if (step2 > 0)
+	    emit_insn (gen_add3_insn (stack_pointer_rtx,
+				      stack_pointer_rtx,
+				      GEN_INT (step2)));
+	}
     }
 
   /* Add in the __builtin_eh_return stack adjustment.  We need to
@@ -9469,18 +9965,44 @@
 
   if (!sibcall_p)
     {
-      unsigned int regno;
-
-      /* When generating MIPS16 code, the normal mips_for_each_saved_reg
-	 path will restore the return address into $7 rather than $31.  */
-      if (TARGET_MIPS16
-	  && !GENERATE_MIPS16E_SAVE_RESTORE
-	  && BITSET_P (frame->mask, 31))
-	regno = GP_REG_FIRST + 7;
-      else
-	regno = GP_REG_FIRST + 31;
       mips_expand_before_return ();
-      emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, regno)));
+      if (cfun->machine->interrupt_handler_p)
+	{
+	  /* Interrupt handlers generate eret or deret.  */
+	  if (cfun->machine->use_debug_exception_return_p)
+	    emit_jump_insn (gen_mips_deret ());
+	  else
+	    emit_jump_insn (gen_mips_eret ());
+	}
+      else
+	{
+	  unsigned int regno;
+
+	  /* When generating MIPS16 code, the normal
+	     mips_for_each_saved_gpr_and_fpr path will restore the return
+	     address into $7 rather than $31.  */
+	  if (TARGET_MIPS16
+	      && !GENERATE_MIPS16E_SAVE_RESTORE
+	      && BITSET_P (frame->mask, 31))
+	    regno = GP_REG_FIRST + 7;
+	  else
+	    regno = GP_REG_FIRST + 31;
+	  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, regno)));
+	}
+    }
+
+  /* Search from the beginning to the first use of K0 or K1.  */
+  if (cfun->machine->interrupt_handler_p
+      && !cfun->machine->keep_interrupts_masked_p)
+    {
+      for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))
+	if (INSN_P (insn)
+	    && for_each_rtx (&PATTERN(insn), mips_kernel_reg_p, NULL))
+	  break;
+      gcc_assert (insn != NULL_RTX);
+      /* Insert disable interrupts before the first use of K0 or K1.  */
+      emit_insn_before (gen_mips_di (), insn);
+      emit_insn_before (gen_mips_ehb (), insn);
     }
 }
 
@@ -9491,6 +10013,10 @@
 bool
 mips_can_use_return_insn (void)
 {
+  /* Interrupt handlers need to go through the epilogue.  */
+  if (cfun->machine->interrupt_handler_p)
+    return false;
+
   if (!reload_completed)
     return false;
 
@@ -10422,10 +10948,15 @@
 	  s = "bnez\t%2,1f\n\tbreak\t7\n1:";
 	}
       else if (GENERATE_DIVIDE_TRAPS)
-        {
-	  output_asm_insn (s, operands);
-	  s = "teq\t%2,%.,7";
-        }
+	{
+	  if (TUNE_74K)
+	    output_asm_insn ("teq\t%2,%.,7", operands);
+	  else
+	    {
+	      output_asm_insn (s, operands);
+	      s = "teq\t%2,%.,7";
+	    }
+	}
       else
 	{
 	  output_asm_insn ("%(bne\t%2,%.,1f", operands);
@@ -10737,7 +11268,17 @@
       ready[pos2] = temp;
     }
 }
-
+
+int
+mips_mult_madd_chain_bypass_p (rtx out_insn ATTRIBUTE_UNUSED,
+			       rtx in_insn ATTRIBUTE_UNUSED)
+{
+  if (reload_completed)
+    return false;
+  else
+    return true;
+}
+
 /* Used by TUNE_MACC_CHAINS to record the last scheduled instruction
    that may clobber hi or lo.  */
 static rtx mips_macc_chains_last_hilo;
@@ -13910,6 +14451,14 @@
        long as any indirect jumps use $25.  */
     flag_pic = 1;
 
+  /* For SDE, switch on ABICALLS mode if -fpic or -fpie were used, and the
+     user hasn't explicitly disabled these modes.  */
+  if (TARGET_MIPS_SDE
+      && (flag_pic || flag_pie) && !TARGET_ABICALLS
+      && !((target_flags_explicit & MASK_ABICALLS))
+      && mips_abi != ABI_EABI)
+    target_flags |= MASK_ABICALLS;
+
   /* -mvr4130-align is a "speed over size" optimization: it usually produces
      faster code, but at the expense of more nops.  Enable it at -O3 and
      above.  */
@@ -13984,26 +14533,46 @@
   if (TARGET_DSPR2)
     target_flags |= MASK_DSP;
 
-  /* .eh_frame addresses should be the same width as a C pointer.
-     Most MIPS ABIs support only one pointer size, so the assembler
-     will usually know exactly how big an .eh_frame address is.
-
-     Unfortunately, this is not true of the 64-bit EABI.  The ABI was
-     originally defined to use 64-bit pointers (i.e. it is LP64), and
-     this is still the default mode.  However, we also support an n32-like
-     ILP32 mode, which is selected by -mlong32.  The problem is that the
-     assembler has traditionally not had an -mlong option, so it has
-     traditionally not known whether we're using the ILP32 or LP64 form.
-
-     As it happens, gas versions up to and including 2.19 use _32-bit_
-     addresses for EABI64 .cfi_* directives.  This is wrong for the
-     default LP64 mode, so we can't use the directives by default.
-     Moreover, since gas's current behavior is at odds with gcc's
-     default behavior, it seems unwise to rely on future versions
-     of gas behaving the same way.  We therefore avoid using .cfi
-     directives for -mlong32 as well.  */
-  if (mips_abi == ABI_EABI && TARGET_64BIT)
-    flag_dwarf2_cfi_asm = 0;
+  /* Use the traditional method of generating .eh_frames.
+     We need this for two reasons:
+
+     - .eh_frame addresses should be the same width as a C pointer.
+       Most MIPS ABIs support only one pointer size, so the assembler
+       will usually know exactly how big an .eh_frame address is.
+
+       Unfortunately, this is not true of the 64-bit EABI.  The ABI was
+       originally defined to use 64-bit pointers (i.e. it is LP64), and
+       this is still the default mode.  However, we also support an n32-like
+       ILP32 mode, which is selected by -mlong32.  The problem is that the
+       assembler has traditionally not had an -mlong option, so it has
+       traditionally not known whether we're using the ILP32 or LP64 form.
+
+       As it happens, gas versions up to and including 2.19 use _32-bit_
+       addresses for EABI64 .cfi_* directives.  This is wrong for the
+       default LP64 mode, so we can't use the directives by default.
+       Moreover, since gas's current behavior is at odds with gcc's
+       default behavior, it seems unwise to rely on future versions
+       of gas behaving the same way.  We therefore avoid using .cfi
+       directives for -mlong32 as well.
+
+     - .cfi* directives generate read-only .eh_frame sections.
+       However, MIPS has traditionally not allowed directives like:
+
+	    .long   x-.
+
+       in cases where "x" is in a different section, or is not defined
+       in the same assembly file.  We have therefore traditionally
+       used absolute addresses and a writable .eh_frame instead.
+
+       The linker is able to convert most of these absolute addresses
+       into PC-relative form where doing so is necessary to avoid
+       relocations.  However, until 2.21, it wasn't able to do this
+       for indirect encodings or personality routines.
+
+       GNU ld 2.21 and GCC 4.5 have support for read-only .eh_frames,
+       but for the time being, we should stick to the approach used
+       in 4.3 and earlier.  */
+  flag_dwarf2_cfi_asm = 0;
 
   mips_init_print_operand_punct ();
 
@@ -14242,6 +14811,178 @@
       reg_alloc_order[24] = 0;
     }
 }
+
+/* Implement EPILOGUE_USES.  */
+
+bool
+mips_epilogue_uses (unsigned int regno)
+{
+  /* Say that the epilogue uses the return address register.  Note that
+     in the case of sibcalls, the values "used by the epilogue" are
+     considered live at the start of the called function.  */
+  if (regno == 31)
+    return true;
+
+  /* If using a GOT, say that the epilogue also uses GOT_VERSION_REGNUM.
+     See the comment above load_call<mode> for details.  */
+  if (TARGET_USE_GOT && (regno) == GOT_VERSION_REGNUM)
+    return true;
+
+  /* An interrupt handler must preserve some registers that are
+     ordinarily call-clobbered.  */
+  if (cfun->machine->interrupt_handler_p
+      && mips_interrupt_extra_call_saved_reg_p (regno))
+    return true;
+
+  return false;
+}
+
+#ifdef CVMX_SHARED_BSS_FLAGS
+/* Handle a "cvmx_shared" attribute; arguments as in 
+   struct attribute_spec.handler.  */
+
+static tree
+octeon_handle_cvmx_shared_attribute (tree *node, tree name, 
+				     tree args ATTRIBUTE_UNUSED, 
+				     int flags ATTRIBUTE_UNUSED, 
+				     bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) != VAR_DECL)
+    {
+      warning (OPT_Wattributes, "%qs attribute only applies to variables",
+              IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
+/* Switch to the appropriate section for output of DECL.
+   DECL is either a `VAR_DECL' node or a constant of some sort.
+   RELOC indicates whether forming the initial value of DECL requires
+   link-time relocations.  */
+
+static section *
+octeon_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)
+{
+  if (decl && TREE_CODE (decl) == VAR_DECL 
+      && lookup_attribute ("cvmx_shared", DECL_ATTRIBUTES (decl)))
+    {
+      const char *sname = NULL;
+      unsigned int flags = SECTION_WRITE;
+
+      switch (categorize_decl_for_section (decl, reloc))
+        {
+	  case SECCAT_DATA:
+	  case SECCAT_SDATA:
+	  case SECCAT_RODATA:
+	  case SECCAT_SRODATA:
+	  case SECCAT_RODATA_MERGE_STR:
+	  case SECCAT_RODATA_MERGE_STR_INIT:
+	  case SECCAT_RODATA_MERGE_CONST:
+	  case SECCAT_DATA_REL:
+	  case SECCAT_DATA_REL_LOCAL:
+	  case SECCAT_DATA_REL_RO:
+	  case SECCAT_DATA_REL_RO_LOCAL:
+	    sname = ".cvmx_shared";
+	    break;
+	  case SECCAT_BSS:
+	  case SECCAT_SBSS:
+	    sname = ".cvmx_shared_bss";
+	    flags |= SECTION_BSS;
+	    break;
+	  case SECCAT_TEXT:
+	  case SECCAT_TDATA:
+	  case SECCAT_TBSS:
+            break;
+        }
+      if (sname)
+	{
+	  return get_section (sname, flags, decl);
+	}
+    }
+  return default_elf_select_section (decl, reloc, align);
+}
+
+/* Build up a unique section name, expressed as a
+   STRING_CST node, and assign it to DECL_SECTION_NAME (decl).
+   RELOC indicates whether the initial value of EXP requires
+   link-time relocations.  */
+
+static void 
+octeon_unique_section (tree decl, int reloc)
+{
+  if (decl && TREE_CODE (decl) == VAR_DECL 
+      && lookup_attribute ("cvmx_shared", DECL_ATTRIBUTES (decl)))
+    {
+      const char *sname = NULL;
+
+      if (! DECL_ONE_ONLY (decl))
+	{
+	  section *sect;
+	  sect = octeon_select_section (decl, reloc, DECL_ALIGN (decl));
+	  DECL_SECTION_NAME (decl) = build_string (strlen (sect->named.name),
+						   sect->named.name);
+	  return;
+	}
+
+      switch (categorize_decl_for_section (decl, reloc))
+        {
+	  case SECCAT_BSS:
+	  case SECCAT_SBSS:
+	    sname = ".cvmx_shared_bss.linkonce."; 
+	    break;
+	  case SECCAT_SDATA:
+	  case SECCAT_DATA:
+	  case SECCAT_DATA_REL:
+	  case SECCAT_DATA_REL_LOCAL:
+	  case SECCAT_DATA_REL_RO:
+	  case SECCAT_DATA_REL_RO_LOCAL:
+	  case SECCAT_RODATA:
+	  case SECCAT_SRODATA:
+	  case SECCAT_RODATA_MERGE_STR:
+	  case SECCAT_RODATA_MERGE_STR_INIT:
+	  case SECCAT_RODATA_MERGE_CONST:
+	    sname = ".cvmx_shared.linkonce.";
+	    break;
+	  case SECCAT_TEXT:
+	  case SECCAT_TDATA:
+	  case SECCAT_TBSS:
+	    break; 
+	}
+      if (sname)
+        {
+	  const char *name;
+	  size_t plen, nlen;
+	  char *string;
+	  plen = strlen (sname);
+
+	  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+	  name = targetm.strip_name_encoding (name);
+	  nlen = strlen (name);
+
+	  string = alloca (plen + nlen + 1);
+	  memcpy (string, sname, plen);
+	  memcpy (string + plen, name, nlen + 1);
+	  DECL_SECTION_NAME (decl) = build_string (nlen + plen, string);
+	  return;
+        }
+    }
+  default_unique_section (decl, reloc);
+}
+
+/* Emit an uninitialized cvmx_shared variable.  */
+void
+octeon_output_shared_variable (FILE *stream, tree decl, const char *name,
+                               unsigned HOST_WIDE_INT size, int align)
+{
+  switch_to_section (get_section (".cvmx_shared_bss", CVMX_SHARED_BSS_FLAGS,
+				  NULL_TREE));
+  ASM_OUTPUT_ALIGN (stream, floor_log2 (align / BITS_PER_UNIT));
+  ASM_DECLARE_OBJECT_NAME (stream, name, decl);
+  ASM_OUTPUT_SKIP (stream, size != 0 ? size : 1);
+}
+#endif
 
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_ALIGNED_HI_OP
diff -Nur a/gcc/config/mips/mips-dsp.md b/gcc/config/mips/mips-dsp.md
--- a/gcc/config/mips/mips-dsp.md	2008-12-21 22:43:51.000000000 +0100
+++ b/gcc/config/mips/mips-dsp.md	2010-01-25 09:50:29.025687257 +0100
@@ -42,9 +42,9 @@
 		     (match_operand:DSPV 2 "register_operand" "d")))
      (set (reg:CCDSP CCDSP_OU_REGNUM)
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDQ))])]
-  ""
+  "ISA_HAS_DSP"
   "add<DSPV:dspfmt1>.<DSPV:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_add<DSP:dspfmt1>_s_<DSP:dspfmt2>"
@@ -55,9 +55,9 @@
 		      UNSPEC_ADDQ_S))
      (set (reg:CCDSP CCDSP_OU_REGNUM)
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDQ_S))])]
-  ""
+  "ISA_HAS_DSP"
   "add<DSP:dspfmt1>_s.<DSP:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; SUBQ*
@@ -70,7 +70,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBQ))])]
   "ISA_HAS_DSP"
   "sub<DSPV:dspfmt1>.<DSPV:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_sub<DSP:dspfmt1>_s_<DSP:dspfmt2>"
@@ -83,7 +83,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBQ_S))])]
   "ISA_HAS_DSP"
   "sub<DSP:dspfmt1>_s.<DSP:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; ADDSC
@@ -97,7 +97,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDSC))])]
   "ISA_HAS_DSP"
   "addsc\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; ADDWC
@@ -112,7 +112,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDWC))])]
   "ISA_HAS_DSP"
   "addwc\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; MODSUB
@@ -123,7 +123,7 @@
 		   UNSPEC_MODSUB))]
   "ISA_HAS_DSP"
   "modsub\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; RADDU*
@@ -133,7 +133,7 @@
 		   UNSPEC_RADDU_W_QB))]
   "ISA_HAS_DSP"
   "raddu.w.qb\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; ABSQ*
@@ -146,7 +146,7 @@
 	  (unspec:CCDSP [(match_dup 1)] UNSPEC_ABSQ_S))])]
   "ISA_HAS_DSP"
   "absq_s.<DSPQ:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; PRECRQ*
@@ -157,7 +157,7 @@
 		     UNSPEC_PRECRQ_QB_PH))]
   "ISA_HAS_DSP"
   "precrq.qb.ph\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precrq_ph_w"
@@ -167,7 +167,7 @@
 		     UNSPEC_PRECRQ_PH_W))]
   "ISA_HAS_DSP"
   "precrq.ph.w\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precrq_rs_ph_w"
@@ -181,7 +181,7 @@
 			UNSPEC_PRECRQ_RS_PH_W))])]
   "ISA_HAS_DSP"
   "precrq_rs.ph.w\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PRECRQU*
@@ -196,7 +196,7 @@
 			UNSPEC_PRECRQU_S_QB_PH))])]
   "ISA_HAS_DSP"
   "precrqu_s.qb.ph\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; PRECEQ*
@@ -206,7 +206,7 @@
 		   UNSPEC_PRECEQ_W_PHL))]
   "ISA_HAS_DSP"
   "preceq.w.phl\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceq_w_phr"
@@ -215,7 +215,7 @@
 		   UNSPEC_PRECEQ_W_PHR))]
   "ISA_HAS_DSP"
   "preceq.w.phr\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PRECEQU*
@@ -225,7 +225,7 @@
 		     UNSPEC_PRECEQU_PH_QBL))]
   "ISA_HAS_DSP"
   "precequ.ph.qbl\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precequ_ph_qbr"
@@ -234,7 +234,7 @@
 		     UNSPEC_PRECEQU_PH_QBR))]
   "ISA_HAS_DSP"
   "precequ.ph.qbr\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precequ_ph_qbla"
@@ -243,7 +243,7 @@
 		     UNSPEC_PRECEQU_PH_QBLA))]
   "ISA_HAS_DSP"
   "precequ.ph.qbla\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precequ_ph_qbra"
@@ -252,7 +252,7 @@
 		     UNSPEC_PRECEQU_PH_QBRA))]
   "ISA_HAS_DSP"
   "precequ.ph.qbra\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PRECEU*
@@ -262,7 +262,7 @@
 		     UNSPEC_PRECEU_PH_QBL))]
   "ISA_HAS_DSP"
   "preceu.ph.qbl\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceu_ph_qbr"
@@ -271,7 +271,7 @@
 		     UNSPEC_PRECEU_PH_QBR))]
   "ISA_HAS_DSP"
   "preceu.ph.qbr\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceu_ph_qbla"
@@ -280,7 +280,7 @@
 		     UNSPEC_PRECEU_PH_QBLA))]
   "ISA_HAS_DSP"
   "preceu.ph.qbla\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceu_ph_qbra"
@@ -289,7 +289,7 @@
 		     UNSPEC_PRECEU_PH_QBRA))]
   "ISA_HAS_DSP"
   "preceu.ph.qbra\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-2. MIPS DSP ASE Instructions: Shift
@@ -313,7 +313,7 @@
     }
   return "shllv.<DSPV:dspfmt2>\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shll_s_<DSPQ:dspfmt2>"
@@ -335,7 +335,7 @@
     }
   return "shllv_s.<DSPQ:dspfmt2>\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; SHRL*
@@ -354,7 +354,7 @@
     }
   return "shrlv.qb\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; SHRA*
@@ -373,7 +373,7 @@
     }
   return "shrav.ph\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shra_r_<DSPQ:dspfmt2>"
@@ -392,7 +392,7 @@
     }
   return "shrav_r.<DSPQ:dspfmt2>\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-3. MIPS DSP ASE Instructions: Multiply
@@ -478,7 +478,7 @@
 		   UNSPEC_DPAU_H_QBL))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpau.h.qbl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpau_h_qbr"
@@ -489,7 +489,7 @@
 		   UNSPEC_DPAU_H_QBR))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpau.h.qbr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPSU*
@@ -501,7 +501,7 @@
 		   UNSPEC_DPSU_H_QBL))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsu.h.qbl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsu_h_qbr"
@@ -512,7 +512,7 @@
 		   UNSPEC_DPSU_H_QBR))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsu.h.qbr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPAQ*
@@ -528,7 +528,7 @@
 			UNSPEC_DPAQ_S_W_PH))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpaq_s.w.ph\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPSQ*
@@ -544,7 +544,7 @@
 			UNSPEC_DPSQ_S_W_PH))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsq_s.w.ph\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; MULSAQ*
@@ -560,7 +560,7 @@
 			UNSPEC_MULSAQ_S_W_PH))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "mulsaq_s.w.ph\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPAQ*
@@ -576,7 +576,7 @@
 			UNSPEC_DPAQ_SA_L_W))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpaq_sa.l.w\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 ;; DPSQ*
@@ -592,7 +592,7 @@
 			UNSPEC_DPSQ_SA_L_W))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsq_sa.l.w\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 ;; MAQ*
@@ -608,7 +608,7 @@
 			UNSPEC_MAQ_S_W_PHL))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_s.w.phl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_maq_s_w_phr"
@@ -623,7 +623,7 @@
 			UNSPEC_MAQ_S_W_PHR))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_s.w.phr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; MAQ_SA*
@@ -639,7 +639,7 @@
 			UNSPEC_MAQ_SA_W_PHL))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_sa.w.phl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_maq_sa_w_phr"
@@ -654,7 +654,7 @@
 			UNSPEC_MAQ_SA_W_PHR))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_sa.w.phr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-4. MIPS DSP ASE Instructions: General Bit/Manipulation
@@ -665,7 +665,7 @@
 		   UNSPEC_BITREV))]
   "ISA_HAS_DSP"
   "bitrev\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; INSV
@@ -678,7 +678,7 @@
 		   UNSPEC_INSV))]
   "ISA_HAS_DSP"
   "insv\t%0,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; REPL*
@@ -696,7 +696,7 @@
     }
   return "replv.qb\t%0,%1";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_repl_ph"
@@ -707,7 +707,7 @@
   "@
    repl.ph\t%0,%1
    replv.ph\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-5. MIPS DSP ASE Instructions: Compare-Pick
@@ -720,7 +720,7 @@
 		      UNSPEC_CMP_EQ))]
   "ISA_HAS_DSP"
   "cmp<DSPV:dspfmt1_1>.eq.<DSPV:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmp<DSPV:dspfmt1_1>_lt_<DSPV:dspfmt2>"
@@ -731,7 +731,7 @@
 		      UNSPEC_CMP_LT))]
   "ISA_HAS_DSP"
   "cmp<DSPV:dspfmt1_1>.lt.<DSPV:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmp<DSPV:dspfmt1_1>_le_<DSPV:dspfmt2>"
@@ -742,7 +742,7 @@
 		      UNSPEC_CMP_LE))]
   "ISA_HAS_DSP"
   "cmp<DSPV:dspfmt1_1>.le.<DSPV:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgu_eq_qb"
@@ -752,7 +752,7 @@
 		   UNSPEC_CMPGU_EQ_QB))]
   "ISA_HAS_DSP"
   "cmpgu.eq.qb\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgu_lt_qb"
@@ -762,7 +762,7 @@
 		   UNSPEC_CMPGU_LT_QB))]
   "ISA_HAS_DSP"
   "cmpgu.lt.qb\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgu_le_qb"
@@ -772,7 +772,7 @@
 		   UNSPEC_CMPGU_LE_QB))]
   "ISA_HAS_DSP"
   "cmpgu.le.qb\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PICK*
@@ -784,7 +784,7 @@
 		     UNSPEC_PICK))]
   "ISA_HAS_DSP"
   "pick.<DSPV:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PACKRL*
@@ -795,7 +795,7 @@
 		     UNSPEC_PACKRL_PH))]
   "ISA_HAS_DSP"
   "packrl.ph\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-6. MIPS DSP ASE Instructions: Accumulator and DSPControl Access
@@ -818,7 +818,7 @@
     }
   return "extrv.w\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_extr_r_w"
@@ -839,7 +839,7 @@
     }
   return "extrv_r.w\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_extr_rs_w"
@@ -860,7 +860,7 @@
     }
   return "extrv_rs.w\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 ;; EXTR*_S.H
@@ -882,7 +882,7 @@
     }
   return "extrv_s.h\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 ;; EXTP*
@@ -905,7 +905,7 @@
     }
   return "extpv\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_extpdp"
@@ -930,7 +930,7 @@
     }
   return "extpdpv\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 ;; SHILO*
@@ -949,7 +949,7 @@
     }
   return "shilov\t%q0,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accmod")
    (set_attr "mode"	"SI")])
 
 ;; MTHLIP*
@@ -965,7 +965,7 @@
 			 (reg:CCDSP CCDSP_PO_REGNUM)] UNSPEC_MTHLIP))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "mthlip\t%2,%q0"
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accmod")
    (set_attr "mode"	"SI")])
 
 ;; WRDSP
@@ -987,7 +987,7 @@
 	  (unspec:CCDSP [(match_dup 0) (match_dup 1)] UNSPEC_WRDSP))])]
   "ISA_HAS_DSP"
   "wrdsp\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; RDDSP
@@ -1003,7 +1003,7 @@
 		   UNSPEC_RDDSP))]
   "ISA_HAS_DSP"
   "rddsp\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-7. MIPS DSP ASE Instructions: Indexed-Load
diff -Nur a/gcc/config/mips/mips-dspr2.md b/gcc/config/mips/mips-dspr2.md
--- a/gcc/config/mips/mips-dspr2.md	2007-09-23 11:24:21.000000000 +0200
+++ b/gcc/config/mips/mips-dspr2.md	2010-01-25 09:50:29.025687257 +0100
@@ -9,7 +9,7 @@
 	  (unspec:CCDSP [(match_dup 1)] UNSPEC_ABSQ_S_QB))])]
   "ISA_HAS_DSPR2"
   "absq_s.qb\t%0,%z1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addu_ph"
@@ -21,7 +21,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDU_PH))])]
   "ISA_HAS_DSPR2"
   "addu.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addu_s_ph"
@@ -34,7 +34,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDU_S_PH))])]
   "ISA_HAS_DSPR2"
   "addu_s.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_adduh_qb"
@@ -44,7 +44,7 @@
 		     UNSPEC_ADDUH_QB))]
   "ISA_HAS_DSPR2"
   "adduh.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_adduh_r_qb"
@@ -54,7 +54,7 @@
 		     UNSPEC_ADDUH_R_QB))]
   "ISA_HAS_DSPR2"
   "adduh_r.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_append"
@@ -69,7 +69,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "append\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_balign"
@@ -84,7 +84,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 3);
   return "balign\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgdu_eq_qb"
@@ -99,7 +99,7 @@
 			UNSPEC_CMPGDU_EQ_QB))])]
   "ISA_HAS_DSPR2"
   "cmpgdu.eq.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgdu_lt_qb"
@@ -114,7 +114,7 @@
 			UNSPEC_CMPGDU_LT_QB))])]
   "ISA_HAS_DSPR2"
   "cmpgdu.lt.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgdu_le_qb"
@@ -129,7 +129,7 @@
 			UNSPEC_CMPGDU_LE_QB))])]
   "ISA_HAS_DSPR2"
   "cmpgdu.le.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpa_w_ph"
@@ -140,7 +140,7 @@
 		   UNSPEC_DPA_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dps_w_ph"
@@ -151,7 +151,7 @@
 		   UNSPEC_DPS_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dps.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_expand "mips_madd<u>"
@@ -247,7 +247,7 @@
 		   UNSPEC_MULSA_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "mulsa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_mult"
@@ -277,7 +277,7 @@
 		     UNSPEC_PRECR_QB_PH))]
   "ISA_HAS_DSPR2"
   "precr.qb.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precr_sra_ph_w"
@@ -292,7 +292,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "precr_sra.ph.w\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precr_sra_r_ph_w"
@@ -307,7 +307,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "precr_sra_r.ph.w\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_prepend"
@@ -322,7 +322,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "prepend\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shra_qb"
@@ -340,7 +340,7 @@
     }
   return "shrav.qb\t%0,%z1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 
@@ -359,7 +359,7 @@
     }
   return "shrav_r.qb\t%0,%z1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shrl_ph"
@@ -377,7 +377,7 @@
     }
   return "shrlv.ph\t%0,%z1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subu_ph"
@@ -390,7 +390,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBU_PH))])]
   "ISA_HAS_DSPR2"
   "subu.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subu_s_ph"
@@ -403,7 +403,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBU_S_PH))])]
   "ISA_HAS_DSPR2"
   "subu_s.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subuh_qb"
@@ -413,7 +413,7 @@
 		     UNSPEC_SUBUH_QB))]
   "ISA_HAS_DSPR2"
   "subuh.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subuh_r_qb"
@@ -423,7 +423,7 @@
 		     UNSPEC_SUBUH_R_QB))]
   "ISA_HAS_DSPR2"
   "subuh_r.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_ph"
@@ -433,7 +433,7 @@
 		     UNSPEC_ADDQH_PH))]
   "ISA_HAS_DSPR2"
   "addqh.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_r_ph"
@@ -443,7 +443,7 @@
 		     UNSPEC_ADDQH_R_PH))]
   "ISA_HAS_DSPR2"
   "addqh_r.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_w"
@@ -453,7 +453,7 @@
 		   UNSPEC_ADDQH_W))]
   "ISA_HAS_DSPR2"
   "addqh.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_r_w"
@@ -463,7 +463,7 @@
 		   UNSPEC_ADDQH_R_W))]
   "ISA_HAS_DSPR2"
   "addqh_r.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_ph"
@@ -473,7 +473,7 @@
 		     UNSPEC_SUBQH_PH))]
   "ISA_HAS_DSPR2"
   "subqh.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_r_ph"
@@ -483,7 +483,7 @@
 		     UNSPEC_SUBQH_R_PH))]
   "ISA_HAS_DSPR2"
   "subqh_r.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_w"
@@ -493,7 +493,7 @@
 		   UNSPEC_SUBQH_W))]
   "ISA_HAS_DSPR2"
   "subqh.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_r_w"
@@ -503,7 +503,7 @@
 		   UNSPEC_SUBQH_R_W))]
   "ISA_HAS_DSPR2"
   "subqh_r.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpax_w_ph"
@@ -514,7 +514,7 @@
 		   UNSPEC_DPAX_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpax.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsx_w_ph"
@@ -525,7 +525,7 @@
 		   UNSPEC_DPSX_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpsx.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpaqx_s_w_ph"
@@ -540,7 +540,7 @@
 			UNSPEC_DPAQX_S_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpaqx_s.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpaqx_sa_w_ph"
@@ -555,7 +555,7 @@
 			UNSPEC_DPAQX_SA_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpaqx_sa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsqx_s_w_ph"
@@ -570,7 +570,7 @@
 			UNSPEC_DPSQX_S_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpsqx_s.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsqx_sa_w_ph"
@@ -585,5 +585,43 @@
 			UNSPEC_DPSQX_SA_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpsqx_sa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
+   (set_attr "mode"	"SI")])
+
+;; Convert  mtlo $ac[1-3],$0  =>  mult $ac[1-3],$0,$0
+;;          mthi $ac[1-3],$0
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(const_int 0))
+   (set (match_operand:SI 1 "register_operand" "")
+	(const_int 0))]
+  "ISA_HAS_DSPR2
+   && !TARGET_MIPS16
+   && !TARGET_64BIT
+   && (((true_regnum (operands[0]) == AC1LO_REGNUM
+		     && true_regnum (operands[1]) == AC1HI_REGNUM)
+	|| (true_regnum (operands[0]) == AC1HI_REGNUM
+			&& true_regnum (operands[1]) == AC1LO_REGNUM))
+       || ((true_regnum (operands[0]) == AC2LO_REGNUM
+			&& true_regnum (operands[1]) == AC2HI_REGNUM)
+	   || (true_regnum (operands[0]) == AC2HI_REGNUM
+			&& true_regnum (operands[1]) == AC2LO_REGNUM))
+       || ((true_regnum (operands[0]) == AC3LO_REGNUM
+		     && true_regnum (operands[1]) == AC3HI_REGNUM)
+	   || (true_regnum (operands[0]) == AC3HI_REGNUM
+			   && true_regnum (operands[1]) == AC3LO_REGNUM)))"
+  [(parallel [(set (match_dup 0) (const_int 0))
+	      (set (match_dup 1) (const_int 0))])]
+)
+
+(define_insn "*mips_acc_init"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "=a")
+	      (const_int 0))
+	      (set (match_operand:SI 1 "register_operand" "=a")
+	      (const_int 0))])]
+  "ISA_HAS_DSPR2
+   && !TARGET_MIPS16
+   && !TARGET_64BIT"
+  "mult\t%q0,$0,$0\t\t# Clear ACC HI/LO"
+  [(set_attr "type"	"imul")
    (set_attr "mode"	"SI")])
diff -Nur a/gcc/config/mips/mips.h b/gcc/config/mips/mips.h
--- a/gcc/config/mips/mips.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/mips/mips.h	2010-01-25 09:50:29.025687257 +0100
@@ -342,6 +342,9 @@
 #define TARGET_IRIX	   0
 #define TARGET_IRIX6	   0
 
+/* SDE specific stuff.  */
+#define TARGET_MIPS_SDE    0
+
 /* Define preprocessor macros for the -march and -mtune options.
    PREFIX is either _MIPS_ARCH or _MIPS_TUNE, INFO is the selected
    processor.  If INFO's canonical name is "foo", define PREFIX to
@@ -708,8 +711,9 @@
        |march=r10000|march=r12000|march=r14000|march=r16000:-mips4} \
      %{march=mips32|march=4kc|march=4km|march=4kp|march=4ksc:-mips32} \
      %{march=mips32r2|march=m4k|march=4ke*|march=4ksd|march=24k* \
-       |march=34k*|march=74k*: -mips32r2} \
-     %{march=mips64|march=5k*|march=20k*|march=sb1*|march=sr71000: -mips64} \
+       |march=34k*|march=74k*|march=1004k*: -mips32r2} \
+     %{march=mips64|march=5k*|march=20k*|march=sb1*|march=sr71000 \
+       |march=xlr: -mips64} \
      %{march=mips64r2|march=octeon: -mips64r2} \
      %{!march=*: -" MULTILIB_ISA_DEFAULT "}}"
 
@@ -720,7 +724,8 @@
 #define MIPS_ARCH_FLOAT_SPEC \
   "%{mhard-float|msoft-float|march=mips*:; \
      march=vr41*|march=m4k|march=4k*|march=24kc|march=24kec \
-     |march=34kc|march=74kc|march=5kc|march=octeon: -msoft-float; \
+     |march=34kc|march=74kc|march=1004kc|march=5kc \
+     |march=octeon|march=xlr: -msoft-float;		  \
      march=*: -mhard-float}"
 
 /* A spec condition that matches 32-bit options.  It only works if
@@ -731,8 +736,9 @@
 
 /* Support for a compile-time default CPU, et cetera.  The rules are:
    --with-arch is ignored if -march is specified or a -mips is specified
-     (other than -mips16).
-   --with-tune is ignored if -mtune is specified.
+     (other than -mips16); likewise --with-arch-32 and --with-arch-64.
+   --with-tune is ignored if -mtune is specified; likewise
+     --with-tune-32 and --with-tune-64.
    --with-abi is ignored if -mabi is specified.
    --with-float is ignored if -mhard-float or -msoft-float are
      specified.
@@ -740,7 +746,11 @@
      specified. */
 #define OPTION_DEFAULT_SPECS \
   {"arch", "%{" MIPS_ARCH_OPTION_SPEC ":;: -march=%(VALUE)}" }, \
+  {"arch_32", "%{!mabi=*|mabi=32:%{" MIPS_ARCH_OPTION_SPEC ":;: -march=%(VALUE)}}" }, \
+  {"arch_64", "%{mabi=n32|mabi=64:%{" MIPS_ARCH_OPTION_SPEC ":;: -march=%(VALUE)}}" }, \
   {"tune", "%{!mtune=*:-mtune=%(VALUE)}" }, \
+  {"tune_32", "%{!mabi=*|mabi=32:%{!mtune=*:-mtune=%(VALUE)}}" }, \
+  {"tune_64", "%{mabi=n32|mabi=64:%{!mtune=*:-mtune=%(VALUE)}}" }, \
   {"abi", "%{!mabi=*:-mabi=%(VALUE)}" }, \
   {"float", "%{!msoft-float:%{!mhard-float:-m%(VALUE)-float}}" }, \
   {"divide", "%{!mdivide-traps:%{!mdivide-breaks:-mdivide-%(VALUE)}}" }, \
@@ -750,7 +760,7 @@
 
 /* A spec that infers the -mdsp setting from an -march argument.  */
 #define BASE_DRIVER_SELF_SPECS \
-  "%{!mno-dsp:%{march=24ke*|march=34k*|march=74k*: -mdsp}}"
+  "%{!mno-dsp:%{march=24ke*|march=34k*|march=74k*|march=1004k*: -mdsp}}"
 
 #define DRIVER_SELF_SPECS BASE_DRIVER_SELF_SPECS
 
@@ -1038,6 +1048,11 @@
 /* ISA includes the bbit* instructions.  */
 #define ISA_HAS_BBIT		(TARGET_OCTEON && !TARGET_MIPS16)
 
+/* ISA has single-instruction unaligned load/store support.  */
+#define ISA_HAS_UL_US          (TARGET_OCTEON \
+                                && TARGET_OCTEON_UNALIGNED \
+                                && !TARGET_MIPS16)
+ 
 /* ISA includes the cins instruction.  */
 #define ISA_HAS_CINS		(TARGET_OCTEON && !TARGET_MIPS16)
 
@@ -1055,6 +1070,7 @@
 
 /* The CACHE instruction is available.  */
 #define ISA_HAS_CACHE (TARGET_CACHE_BUILTIN && !TARGET_MIPS16)
+ 
 
 /* Add -G xx support.  */
 
@@ -1152,6 +1168,7 @@
 %{mshared} %{mno-shared} \
 %{msym32} %{mno-sym32} \
 %{mtune=*} %{v} \
+%{mocteon-useun} %{mno-octeon-useun} \
 %(subtarget_asm_spec)"
 
 /* Extra switches sometimes passed to the linker.  */
@@ -1622,6 +1639,9 @@
 #define GP_REG_LAST  31
 #define GP_REG_NUM   (GP_REG_LAST - GP_REG_FIRST + 1)
 #define GP_DBX_FIRST 0
+#define K0_REG_NUM   (GP_REG_FIRST + 26)
+#define K1_REG_NUM   (GP_REG_FIRST + 27)
+#define KERNEL_REG_P(REGNO)	(IN_RANGE (REGNO, K0_REG_NUM, K1_REG_NUM))
 
 #define FP_REG_FIRST 32
 #define FP_REG_LAST  63
@@ -1649,6 +1669,10 @@
 #define COP0_REG_LAST 111
 #define COP0_REG_NUM (COP0_REG_LAST - COP0_REG_FIRST + 1)
 
+#define COP0_STATUS_REG_NUM	(COP0_REG_FIRST + 12)
+#define COP0_CAUSE_REG_NUM	(COP0_REG_FIRST + 13)
+#define COP0_EPC_REG_NUM	(COP0_REG_FIRST + 14)
+
 #define COP2_REG_FIRST 112
 #define COP2_REG_LAST 143
 #define COP2_REG_NUM (COP2_REG_LAST - COP2_REG_FIRST + 1)
@@ -1666,6 +1690,29 @@
 #define AT_REGNUM	(GP_REG_FIRST + 1)
 #define HI_REGNUM	(TARGET_BIG_ENDIAN ? MD_REG_FIRST : MD_REG_FIRST + 1)
 #define LO_REGNUM	(TARGET_BIG_ENDIAN ? MD_REG_FIRST + 1 : MD_REG_FIRST)
+#define AC1HI_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST : DSP_ACC_REG_FIRST + 1)
+#define AC1LO_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 1 : DSP_ACC_REG_FIRST)
+#define AC2HI_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 2 : DSP_ACC_REG_FIRST + 3)
+#define AC2LO_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 3 : DSP_ACC_REG_FIRST + 2)
+#define AC3HI_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 4 : DSP_ACC_REG_FIRST + 5)
+#define AC3LO_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 5 : DSP_ACC_REG_FIRST + 4)
+
+/* A few bitfield locations for the coprocessor registers.  */
+/* Request Interrupt Priority Level is from bit 10 to bit 15 of
+   the cause register for the EIC interrupt mode.  */
+#define CAUSE_IPL	10
+/* Interrupt Priority Level is from bit 10 to bit 15 of the status register.  */
+#define SR_IPL		10
+/* Exception Level is at bit 1 of the status register.  */
+#define SR_EXL		1
+/* Interrupt Enable is at bit 0 of the status register.  */
+#define SR_IE		0
 
 /* FPSW_REGNUM is the single condition code used if !ISA_HAS_8CC.
    If ISA_HAS_8CC, it should not be used, and an arbitrary ST_REG
@@ -1754,11 +1801,18 @@
    incoming arguments, the static chain pointer, or the frame pointer.
    The epilogue temporary mustn't conflict with the return registers,
    the PIC call register ($25), the frame pointer, the EH stack adjustment,
-   or the EH data registers.  */
+   or the EH data registers.
+
+   If we're generating interrupt handlers, we use K0 as a temporary register
+   in prologue/epilogue code.  */
 
 #define MIPS16_PIC_TEMP_REGNUM (GP_REG_FIRST + 2)
-#define MIPS_PROLOGUE_TEMP_REGNUM (GP_REG_FIRST + 3)
-#define MIPS_EPILOGUE_TEMP_REGNUM (GP_REG_FIRST + (TARGET_MIPS16 ? 6 : 8))
+#define MIPS_PROLOGUE_TEMP_REGNUM \
+  (cfun->machine->interrupt_handler_p ? K0_REG_NUM : GP_REG_FIRST + 3)
+#define MIPS_EPILOGUE_TEMP_REGNUM		\
+  (cfun->machine->interrupt_handler_p		\
+   ? K0_REG_NUM					\
+   : GP_REG_FIRST + (TARGET_MIPS16 ? 6 : 8))
 
 #define MIPS16_PIC_TEMP gen_rtx_REG (Pmode, MIPS16_PIC_TEMP_REGNUM)
 #define MIPS_PROLOGUE_TEMP(MODE) gen_rtx_REG (MODE, MIPS_PROLOGUE_TEMP_REGNUM)
@@ -2284,14 +2338,7 @@
 	(mips_abi == ABI_EABI && UNITS_PER_FPVALUE >= UNITS_PER_DOUBLE)
 
 
-/* Say that the epilogue uses the return address register.  Note that
-   in the case of sibcalls, the values "used by the epilogue" are
-   considered live at the start of the called function.
-
-   If using a GOT, say that the epilogue also uses GOT_VERSION_REGNUM.
-   See the comment above load_call<mode> for details.  */
-#define EPILOGUE_USES(REGNO) \
-  ((REGNO) == 31 || (TARGET_USE_GOT && (REGNO) == GOT_VERSION_REGNUM))
+#define EPILOGUE_USES(REGNO)	mips_epilogue_uses (REGNO)
 
 /* Treat LOC as a byte offset from the stack pointer and round it up
    to the next fully-aligned offset.  */
diff -Nur a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
--- a/gcc/config/mips/mips.md	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/mips/mips.md	2010-01-25 09:50:29.035686224 +0100
@@ -67,7 +67,16 @@
    (UNSPEC_SET_GOT_VERSION	46)
    (UNSPEC_UPDATE_GOT_VERSION	47)
    (UNSPEC_COPYGP		48)
+   (UNSPEC_ERET			49)
+   (UNSPEC_DERET		50)
+   (UNSPEC_DI			51)
+   (UNSPEC_EHB			52)
+   (UNSPEC_RDPGPR		53)
+   (UNSPEC_COP0			54)
    
+   (UNSPEC_UNALIGNED_LOAD	60)
+   (UNSPEC_UNALIGNED_STORE	61)
+
    (UNSPEC_ADDRESS_FIRST	100)
 
    (TLS_GET_TP_REGNUM		3)
@@ -372,6 +381,12 @@
 ;; frsqrt       floating point reciprocal square root
 ;; frsqrt1      floating point reciprocal square root step1
 ;; frsqrt2      floating point reciprocal square root step2
+;; dspmac       DSP MAC instructions not saturating the accumulator
+;; dspmacsat    DSP MAC instructions that saturate the accumulator
+;; accext       DSP accumulator extract instructions
+;; accmod       DSP accumulator modify instructions
+;; dspalu       DSP ALU instructions not saturating the result
+;; dspalusat    DSP ALU instructions that saturate the result
 ;; multi	multiword sequence (or user asm statements)
 ;; nop		no operation
 ;; ghost	an instruction that produces no real code
@@ -380,7 +395,7 @@
    prefetch,prefetchx,condmove,mtc,mfc,mthilo,mfhilo,const,arith,logical,
    shift,slt,signext,clz,pop,trap,imul,imul3,imul3nc,imadd,idiv,idiv3,move,
    fmove,fadd,fmul,fmadd,fdiv,frdiv,frdiv1,frdiv2,fabs,fneg,fcmp,fcvt,fsqrt,
-   frsqrt,frsqrt1,frsqrt2,multi,nop,ghost"
+   frsqrt,frsqrt1,frsqrt2,dspmac,dspmacsat,accext,accmod,dspalu,dspalusat,multi,nop,ghost"
   (cond [(eq_attr "jal" "!unset") (const_string "call")
 	 (eq_attr "got" "load") (const_string "load")
 
@@ -3565,7 +3580,9 @@
 	(unspec:GPR [(match_operand:BLK 1 "memory_operand" "m")
 		     (match_operand:QI 2 "memory_operand" "m")]
 		    UNSPEC_LOAD_LEFT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
+  "!TARGET_MIPS16
+   && !ISA_HAS_UL_US
+   && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
   "<load>l\t%0,%2"
   [(set_attr "move_type" "load")
    (set_attr "mode" "<MODE>")])
@@ -3576,7 +3593,9 @@
 		     (match_operand:QI 2 "memory_operand" "m")
 		     (match_operand:GPR 3 "register_operand" "0")]
 		    UNSPEC_LOAD_RIGHT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
+  "!TARGET_MIPS16
+   && !ISA_HAS_UL_US
+   && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
   "<load>r\t%0,%2"
   [(set_attr "move_type" "load")
    (set_attr "mode" "<MODE>")])
@@ -3586,7 +3605,9 @@
 	(unspec:BLK [(match_operand:GPR 1 "reg_or_0_operand" "dJ")
 		     (match_operand:QI 2 "memory_operand" "m")]
 		    UNSPEC_STORE_LEFT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
+  "!TARGET_MIPS16
+   && !ISA_HAS_UL_US
+   && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
   "<store>l\t%z1,%2"
   [(set_attr "move_type" "store")
    (set_attr "mode" "<MODE>")])
@@ -3602,6 +3623,28 @@
   [(set_attr "move_type" "store")
    (set_attr "mode" "<MODE>")])
 
+;; Unaligned load and store patterns.
+
+(define_insn "mov_u<load>"
+  [(set (match_operand:GPR 0 "register_operand" "=d")
+	(unspec:GPR [(match_operand:BLK 1 "memory_operand" "m")
+		     (match_operand:QI 2 "memory_operand" "m")]
+		    UNSPEC_UNALIGNED_LOAD))]
+  "ISA_HAS_UL_US && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
+  "u<load>\t%0,%2"
+  [(set_attr "type" "load")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "mov_u<store>"
+  [(set (match_operand:BLK 0 "memory_operand" "=m")
+	(unspec:BLK [(match_operand:GPR 1 "reg_or_0_operand" "dJ")
+		     (match_operand:QI 2 "memory_operand" "m")]
+		    UNSPEC_UNALIGNED_STORE))]
+  "ISA_HAS_UL_US && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
+  "u<store>\t%z1,%2"
+  [(set_attr "type" "store")
+   (set_attr "mode" "<MODE>")])
+
 ;; An instruction to calculate the high part of a 64-bit SYMBOL_ABSOLUTE.
 ;; The required value is:
 ;;
@@ -5472,6 +5515,26 @@
 	return "%*b\t%l0%/";
       else
 	{
+	  if (final_sequence && (mips_abi == ABI_32 || mips_abi == ABI_O64))
+	    {
+              /* If the delay slot contains a $gp restore, we need to
+                 do that first, because we need it for the load
+		 label.  Other ABIs do not have caller-save $gp.  */
+	      rtx next = NEXT_INSN (insn);
+	      if (INSN_P (next) && !INSN_DELETED_P (next))
+		{
+		  rtx pat = PATTERN (next);
+		  if (GET_CODE (pat) == SET
+		      && REG_P (SET_DEST (pat))
+		      && REGNO (SET_DEST (pat)) == PIC_OFFSET_TABLE_REGNUM)
+		    {
+		      rtx ops[2];
+		      ops[0] = SET_DEST (pat);
+		      ops[1] = SET_SRC (pat);
+		      output_asm_insn (mips_output_move (ops[0], ops[1]), ops);
+		    }
+		}
+	    }
 	  output_asm_insn (mips_output_load_label (), operands);
 	  return "%*jr\t%@%/%]";
 	}
@@ -5490,7 +5553,13 @@
 	      (lt (abs (minus (match_dup 0)
 			      (plus (pc) (const_int 4))))
 		  (const_int 131072)))
-	 (const_int 4) (const_int 16)))])
+	 (const_int 4)
+         (if_then_else
+	    ;; for these two ABIs we may need to move a restore of $gp
+	    (ior (eq (symbol_ref "mips_abi") (symbol_ref "ABI_32"))
+		 (eq (symbol_ref "mips_abi") (symbol_ref "ABI_O64")))
+	    (const_int 20)
+	    (const_int 16))))])
 
 ;; We need a different insn for the mips16, because a mips16 branch
 ;; does not have a delay slot.
@@ -5679,6 +5748,60 @@
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")])
 
+;; Exception return.
+(define_insn "mips_eret"
+  [(return)
+   (unspec_volatile [(const_int 0)] UNSPEC_ERET)]
+  ""
+  "eret"
+  [(set_attr "type"	"trap")
+   (set_attr "mode"	"none")])
+
+;; Debug exception return.
+(define_insn "mips_deret"
+  [(return)
+   (unspec_volatile [(const_int 0)] UNSPEC_DERET)]
+  ""
+  "deret"
+  [(set_attr "type"	"trap")
+   (set_attr "mode"	"none")])
+
+;; Disable interrupts.
+(define_insn "mips_di"
+  [(unspec_volatile [(const_int 0)] UNSPEC_DI)]
+  ""
+  "di"
+  [(set_attr "type"	"trap")
+   (set_attr "mode"	"none")])
+
+;; Execution hazard barrier.
+(define_insn "mips_ehb"
+  [(unspec_volatile [(const_int 0)] UNSPEC_EHB)]
+  ""
+  "ehb"
+  [(set_attr "type"	"trap")
+   (set_attr "mode"	"none")])
+
+;; Read GPR from previous shadow register set.
+(define_insn "mips_rdpgpr"
+  [(set (match_operand:SI 0 "register_operand" "=d")
+	(unspec_volatile:SI [(match_operand:SI 1 "register_operand" "d")]
+			    UNSPEC_RDPGPR))]
+  ""
+  "rdpgpr\t%0,%1"
+  [(set_attr "type"	"move")
+   (set_attr "mode"	"SI")])
+
+;; Move involving COP0 registers.
+(define_insn "cop0_move"
+  [(set (match_operand:SI 0 "register_operand" "=B,d")
+	(unspec_volatile:SI [(match_operand:SI 1 "register_operand" "d,B")]
+			    UNSPEC_COP0))]
+  ""
+{ return mips_output_move (operands[0], operands[1]); }
+  [(set_attr "type"	"mtc,mfc")
+   (set_attr "mode"	"SI")])
+
 ;; This is used in compiling the unwind routines.
 (define_expand "eh_return"
   [(use (match_operand 0 "general_operand"))]
diff -Nur a/gcc/config/mips/mips.opt b/gcc/config/mips/mips.opt
--- a/gcc/config/mips/mips.opt	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/mips/mips.opt	2010-01-25 09:50:29.035686224 +0100
@@ -184,6 +184,10 @@
 Target Report RejectNegative Mask(MIPS16)
 Generate MIPS16 code
 
+mips16e
+Target Report RejectNegative Mask(MIPS16) MaskExists
+Deprecated; alias for -mips16
+
 mips3d
 Target Report RejectNegative Mask(MIPS3D)
 Use MIPS-3D instructions
@@ -236,6 +240,10 @@
 Target Report RejectNegative InverseMask(MIPS3D)
 Do not use MIPS-3D instructions
 
+mocteon-useun
+Target Report Mask(OCTEON_UNALIGNED)
+Use Octeon-specific unaligned loads/stores for 32/64-bit data
+
 mpaired-single
 Target Report Mask(PAIRED_SINGLE_FLOAT)
 Use paired-single floating-point instructions
diff -Nur a/gcc/config/mips/mips-protos.h b/gcc/config/mips/mips-protos.h
--- a/gcc/config/mips/mips-protos.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/mips/mips-protos.h	2010-01-25 09:50:29.035686224 +0100
@@ -261,6 +261,8 @@
 extern void mips_output_external (FILE *, tree, const char *);
 extern void mips_output_filename (FILE *, const char *);
 extern void mips_output_ascii (FILE *, const char *, size_t);
+extern void octeon_output_shared_variable (FILE *, tree, const char *,
+					   unsigned HOST_WIDE_INT, int);
 extern void mips_output_aligned_decl_common (FILE *, tree, const char *,
 					     unsigned HOST_WIDE_INT,
 					     unsigned int);
@@ -307,6 +309,8 @@
 extern bool mips_linked_madd_p (rtx, rtx);
 extern bool mips_store_data_bypass_p (rtx, rtx);
 extern rtx mips_prefetch_cookie (rtx, rtx);
+extern int mips_mult_madd_chain_bypass_p (rtx, rtx);
+extern int mips_dspalu_bypass_p (rtx, rtx);
 
 extern void irix_asm_output_align (FILE *, unsigned);
 extern const char *current_section_name (void);
@@ -332,4 +336,6 @@
 
 extern void mips_expand_vector_init (rtx, rtx);
 
+extern bool mips_epilogue_uses (unsigned int);
+
 #endif /* ! GCC_MIPS_PROTOS_H */
diff -Nur a/gcc/config/mips/montavista-linux.h b/gcc/config/mips/montavista-linux.h
--- a/gcc/config/mips/montavista-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/montavista-linux.h	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,54 @@
+/* MontaVista GNU/Linux Configuration.
+   Copyright (C) 2009
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Override linux64.h to default to O32.  */
+#undef SUBTARGET_SELF_SPECS
+#define SUBTARGET_SELF_SPECS \
+NO_SHARED_SPECS, \
+"%{!EB:%{!EL:%(endian_spec)}}", \
+"%{!mabi=*: -mabi=32}"
+
+/* We do not need to provide an explicit big-endian multilib.  */
+#undef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS \
+  { "meb", "mabi=32" }
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+  "%{mel:%{msoft-float:/mel/soft-float ;	\
+           :/mel} ;				\
+     msoft-float:/soft-float}"
+
+/* MULTILIB_OSDIRNAMES provides directory names used in two ways:
+   relative to $target/lib/ in the GCC installation, and relative to
+   lib/ and usr/lib/ in a sysroot.  For the latter, we want names such
+   as plain ../lib64, but these cannot be used outside the sysroot
+   because different multilibs would be mapped to the same directory.
+   Directories are searched both with and without the multilib suffix,
+   so it suffices if the directory without the suffix is correct
+   within the sysroot while the directory with the suffix doesn't
+   exist.  We use STARTFILE_PREFIX_SPEC to achieve the desired
+   effect.  */
+#undef STARTFILE_PREFIX_SPEC
+#define STARTFILE_PREFIX_SPEC				\
+  "%{mabi=32: /usr/local/lib/ /lib/ /usr/lib/} 		\
+   %{mabi=n32: /usr/local/lib32/ /lib32/ /usr/lib32/}	\
+   %{mabi=64: /usr/local/lib64/ /lib64/ /usr/lib64/}"
diff -Nur a/gcc/config/mips/octeon-elf.h b/gcc/config/mips/octeon-elf.h
--- a/gcc/config/mips/octeon-elf.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/octeon-elf.h	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,98 @@
+/* Macros for mips*-octeon-elf target.
+   Copyright (C) 2004, 2005, 2006 Cavium Networks.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+/* Add MASK_SOFT_FLOAT and MASK_OCTEON_UNALIGNED.  */
+
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT (MASK_SOFT_FLOAT_ABI | MASK_OCTEON_UNALIGNED)
+
+/* Forward -m*octeon-useun.  */
+
+#undef SUBTARGET_ASM_SPEC
+#define SUBTARGET_ASM_SPEC "%{mno-octeon-useun} %{!mno-octeon-useun:-mocteon-useun}"
+
+/* Enable backtrace including on machine exceptions by default.  */
+
+#undef SUBTARGET_CC1_SPEC
+#define SUBTARGET_CC1_SPEC "%{!fno-asynchronous-unwind-tables:-fasynchronous-unwind-tables}"
+
+/* Without ASM_PREFERRED_EH_DATA_FORMAT, output_call_frame_info emits
+   pointer-sized addresses for FDE addresses.  For 64-bit targets, it does
+   it without properly "switching over" to 64-bit as described in the DWARF3
+   spec. GDB can fall back on .eh_frames and misinterpret FDE addresses.
+   Instead let's be explicit and use augmentation to describe the encoding if
+   pointer size is 64.  */
+
+#undef ASM_PREFERRED_EH_DATA_FORMAT
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
+  ((CODE) == 1 && POINTER_SIZE == 64                                    \
+   ? (ABI_HAS_64BIT_SYMBOLS ? DW_EH_PE_udata8 : DW_EH_PE_udata4)        \
+   : DW_EH_PE_absptr)
+
+/* Link to libc library.  */
+
+#undef LIB_SPEC
+#define LIB_SPEC "-lc"
+
+/* Link to startup file.  */
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "crti%O%s crtbegin%O%s crt0%O%s"
+
+/* Default our test-only n64 configuration to -G0 since that is what
+   the kernel uses.  */
+
+#undef SUBTARGET_SELF_SPECS
+#define SUBTARGET_SELF_SPECS \
+"%{mabi=64:%{!G*: -G0}}"
+
+/* Pass linker emulation mode for N32.  */
+
+#undef LINK_SPEC
+#define LINK_SPEC "\
+%(endian_spec) \
+%{G*} %{mips1} %{mips2} %{mips3} %{mips4} %{mips32} %{mips32r2} %{mips64} \
+%{mips64r2} %{bestGnum} %{shared} %{non_shared} \
+%{mabi=n32:-melf32e%{!EL:b}%{EL:l}octeonn32} \
+%{mabi=64:-melf64e%{!EL:b}%{EL:l}octeon}"
+
+/* Override because of N32.  */
+
+#undef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX ((mips_abi == ABI_N32) ? "." : "$")
+
+/* Append the core number to the GCOV filename FN.  */
+
+#define GCOV_TARGET_SUFFIX_LENGTH 2
+#define ADD_GCOV_TARGET_SUFFIX(FN)		\
+do						\
+  {						\
+    char *fn = FN;				\
+    int core;					\
+    char s[3];					\
+						\
+    asm ("rdhwr %0, $0" : "=r"(core));		\
+    sprintf (s, "%d", core);			\
+    strcat (fn, s);				\
+  }						\
+while (0)
+
+/* Code to unwind through the exception frame.  */
+#define MD_UNWIND_SUPPORT "config/mips/octeon-elf-unwind.h"
diff -Nur a/gcc/config/mips/octeon-elf-unwind.h b/gcc/config/mips/octeon-elf-unwind.h
--- a/gcc/config/mips/octeon-elf-unwind.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/octeon-elf-unwind.h	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,57 @@
+/* Stack unwinding support through the first exception frame.
+   Copyright (C) 2007 Cavium Networks.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+#define MD_FALLBACK_FRAME_STATE_FOR octeon_elf_fallback_frame_state
+
+/* Check whether this is the cvmx_interrupt_stage2 frame.  If the
+   function call was dispatched via k0 assume we are in
+   cvmx_interrupt_stage2.  In this case the sp in point to the saved
+   register array.  */
+
+static _Unwind_Reason_Code
+octeon_elf_fallback_frame_state (struct _Unwind_Context *context,
+				 _Unwind_FrameState *fs)
+{
+  unsigned i;
+  unsigned *pc = context->ra;
+
+  /* Look for "jalr k0".  */
+  if (pc[-2] != 0x0340f809)
+    return _URC_END_OF_STACK;
+  
+  for (i = 0; i < 32; i++)
+    {
+      fs->regs.reg[i].how = REG_SAVED_OFFSET;
+      fs->regs.reg[i].loc.offset = 8 * i;
+    }
+
+  /* Keep the next frame's sp.  This way we have a CFA that points
+     exactly to the register array.  */
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = STACK_POINTER_REGNUM;
+  fs->regs.cfa_offset = 0;
+
+  /* DEPC is saved as the 35. register.  */
+  fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].how = REG_SAVED_OFFSET;
+  fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].loc.offset = 8 * 35;
+  fs->retaddr_column = DWARF_ALT_FRAME_RETURN_COLUMN;
+
+  return _URC_NO_REASON;
+}
diff -Nur a/gcc/config/mips/octeon.h b/gcc/config/mips/octeon.h
--- a/gcc/config/mips/octeon.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/octeon.h	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,68 @@
+/* Macros for mips*-octeon-* target.
+   Copyright (C) 2004, 2005, 2006 Cavium Networks.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+#define CVMX_SHARED_BSS_FLAGS (SECTION_WRITE | SECTION_BSS)
+
+#undef TARGET_ASM_SELECT_SECTION
+#define TARGET_ASM_SELECT_SECTION octeon_select_section
+
+#undef TARGET_ASM_UNIQUE_SECTION
+#define TARGET_ASM_UNIQUE_SECTION octeon_unique_section
+
+/* Implement ASM_OUTPUT_ALIGNED_DECL_LOCAL. This differs from the 
+   generic version only in the use of cvmx_shared attribute.  */
+ 
+#undef ASM_OUTPUT_ALIGNED_DECL_LOCAL
+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(STREAM, DECL, NAME, SIZE, ALIGN) \
+  do									\
+    {									\
+      if ((DECL) && TREE_CODE ((DECL)) == VAR_DECL 			\
+	  && lookup_attribute ("cvmx_shared", DECL_ATTRIBUTES (DECL)))	\
+	{  								\
+           fprintf ((STREAM), "%s", LOCAL_ASM_OP);			\
+           assemble_name ((STREAM), (NAME));				\
+           fprintf ((STREAM), "\n");					\
+	   octeon_output_shared_variable ((STREAM), (DECL), (NAME),     \
+					  (SIZE), (ALIGN));             \
+	 } 								\
+      else 								\
+	ASM_OUTPUT_ALIGNED_LOCAL (STREAM, NAME, SIZE, ALIGN);		\
+    }									\
+  while (0) 
+
+
+/* Implement ASM_OUTPUT_ALIGNED_DECL_COMMON.  This differs from the mips 
+   version only in the use of cvmx_shared attribute.  */
+
+#undef ASM_OUTPUT_ALIGNED_DECL_COMMON
+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(STREAM, DECL, NAME, SIZE, ALIGN)	   \
+  {									   \
+    if (TREE_CODE ((DECL)) == VAR_DECL			   		   \
+        && lookup_attribute ("cvmx_shared", DECL_ATTRIBUTES ((DECL))))	   \
+      {									   \
+	if (TREE_PUBLIC ((DECL)) && DECL_NAME ((DECL)))			   \
+	  targetm.asm_out.globalize_label (asm_out_file, (NAME));	   \
+	octeon_output_shared_variable ((STREAM), (DECL), (NAME),	   \
+				       (SIZE), (ALIGN));		   \
+      }									   \
+    else								   \
+      mips_output_aligned_decl_common ((STREAM), (DECL), (NAME), (SIZE),   \
+				       (ALIGN));			   \
+   }
diff -Nur a/gcc/config/mips/predicates.md b/gcc/config/mips/predicates.md
--- a/gcc/config/mips/predicates.md	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/mips/predicates.md	2010-01-25 09:50:29.035686224 +0100
@@ -211,6 +211,20 @@
     }
 })
 
+(define_predicate "mask_low_and_shift_operator"
+  (and (match_code "and")
+       (match_test "GET_CODE (XEXP (op, 0)) == ASHIFT
+		    && GET_CODE (XEXP (op, 1)) == CONST_INT
+		    && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT"))
+{
+  int len;
+
+  len = mask_low_and_shift_len (GET_MODE (op),
+			        INTVAL (XEXP (XEXP (op, 0), 1)),
+				INTVAL (XEXP (op, 1)));
+  return 0 < len && len <= 32;
+})
+
 (define_predicate "consttable_operand"
   (match_test "CONSTANT_P (op)"))
 
diff -Nur a/gcc/config/mips/sde.h b/gcc/config/mips/sde.h
--- a/gcc/config/mips/sde.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/mips/sde.h	2010-01-25 09:50:29.035686224 +0100
@@ -19,6 +19,9 @@
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#undef TARGET_MIPS_SDE
+#define TARGET_MIPS_SDE 1
+
 #undef DRIVER_SELF_SPECS
 #define DRIVER_SELF_SPECS						\
   /* Make sure a -mips option is present.  This helps us to pick	\
@@ -90,7 +93,8 @@
 
 /* Use $5 as a temporary for both MIPS16 and non-MIPS16.  */
 #undef MIPS_EPILOGUE_TEMP_REGNUM
-#define MIPS_EPILOGUE_TEMP_REGNUM (GP_REG_FIRST + 5)
+#define MIPS_EPILOGUE_TEMP_REGNUM \
+  (cfun->machine->interrupt_handler_p ? K0_REG_NUM : GP_REG_FIRST + 5)
 
 /* Using long will always be right for size_t and ptrdiff_t, since
    sizeof(long) must equal sizeof(void *), following from the setting
diff -Nur a/gcc/config/mips/sdemtk.h b/gcc/config/mips/sdemtk.h
--- a/gcc/config/mips/sdemtk.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/mips/sdemtk.h	2010-01-25 09:50:29.035686224 +0100
@@ -19,6 +19,8 @@
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#define TARGET_MIPS_SDEMTK	1
+
 #define TARGET_OS_CPP_BUILTINS()			\
   do							\
     {							\
@@ -113,3 +115,12 @@
 /* ...nor does the call sequence preserve $31.  */
 #undef MIPS_SAVE_REG_FOR_PROFILING_P
 #define MIPS_SAVE_REG_FOR_PROFILING_P(REGNO) ((REGNO) == GP_REG_FIRST + 31)
+
+/* From mips.h, with mno-float option added.  */
+
+#undef MIPS_ARCH_FLOAT_SPEC
+#define MIPS_ARCH_FLOAT_SPEC \
+  "%{mhard-float|msoft-float|mno-float|march=mips*:; \
+     march=vr41*|march=m4k|march=4k*|march=24kc|march=24kec \
+     |march=34kc|march=74kc|march=1004kc|march=5kc|march=octeon|march=xlr: -msoft-float; \
+     march=*: -mhard-float}"
diff -Nur a/gcc/config/mips/t-crtfm b/gcc/config/mips/t-crtfm
--- a/gcc/config/mips/t-crtfm	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/t-crtfm	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,9 @@
+
+EXTRA_MULTILIB_PARTS += crtfastmath.o
+
+EXTRA_PARTS += crtfastmath.o
+
+$(T)crtfastmath.o: $(srcdir)/config/mips/crtfastmath.c $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crtfastmath.o $(srcdir)/config/mips/crtfastmath.c
+
diff -Nur a/gcc/config/mips/t-montavista-elf b/gcc/config/mips/t-montavista-elf
--- a/gcc/config/mips/t-montavista-elf	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/t-montavista-elf	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,22 @@
+# MontaVista ELF Configuration.
+# Copyright (C) 2009
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS =
+MULTILIB_DIRNAMES =
diff -Nur a/gcc/config/mips/t-montavista-linux b/gcc/config/mips/t-montavista-linux
--- a/gcc/config/mips/t-montavista-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/t-montavista-linux	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,43 @@
+# MontaVista GNU/Linux Configuration.
+# Copyright (C) 2009
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Build big-endian and little-endian support libraries.
+MULTILIB_OPTIONS = mel msoft-float march=octeon mabi=n32/mabi=64
+MULTILIB_DIRNAMES = mel soft-float octeon n32 64
+MULTILIB_EXCEPTIONS = *mel*/*mabi=n32* *mel*/*mabi=64*
+MULTILIB_EXCEPTIONS += *mel*/*march=octeon* march=octeon march=octeon/mabi=n32
+MULTILIB_EXCEPTIONS += march=octeon/mabi=64 msoft-float/march=octeon
+
+# These files must be built for each multilib.
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+
+# See comment in montavista-linux.h on STARTFILE_PREFIX_SPEC for how the real
+# directories used in the sysroots are determined.  These directories
+# are specified so that (a) they are distinct and (b) removing the
+# components that form part of the sysroot suffix leaves the real
+# directory within the sysroot.
+MULTILIB_OSDIRNAMES = msoft-float/mabi.n32=../lib32/soft-float
+MULTILIB_OSDIRNAMES += msoft-float/mabi.64=../lib64/soft-float
+MULTILIB_OSDIRNAMES += msoft-float/march.octeon/mabi.n32=../lib32/soft-float/octeon
+MULTILIB_OSDIRNAMES += msoft-float/march.octeon/mabi.64=../lib64/soft-float/octeon
+MULTILIB_OSDIRNAMES += mel/msoft-float=!mel/soft-float
+MULTILIB_OSDIRNAMES += msoft-float=!soft-float
+MULTILIB_OSDIRNAMES += mabi.64=../lib64
+MULTILIB_OSDIRNAMES += mabi.n32=../lib32
diff -Nur a/gcc/config/mips/t-octeon-elf b/gcc/config/mips/t-octeon-elf
--- a/gcc/config/mips/t-octeon-elf	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/t-octeon-elf	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,41 @@
+# Don't let CTOR_LIST end up in sdata section.
+
+CRTSTUFF_T_CFLAGS = -G 0 -fno-asynchronous-unwind-tables
+
+# Assemble startup files.
+
+$(T)crti.o: $(srcdir)/config/mips/crti.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/mips/crti.asm
+
+$(T)crtn.o: $(srcdir)/config/mips/crtn.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/mips/crtn.asm
+
+# N32 uses TFmode for long double.
+
+TPBIT = tp-bit.c
+
+tp-bit.c: $(srcdir)/config/fp-bit.c
+	echo '#ifdef __MIPSEL__' > tp-bit.c
+	echo '# define FLOAT_BIT_ORDER_MISMATCH' >> tp-bit.c
+	echo '#endif' >> tp-bit.c
+	echo '#if __LDBL_MANT_DIG__ == 113' >> tp-bit.c
+	echo '#define QUIET_NAN_NEGATED' >> tp-bit.c
+	echo '# define TFLOAT' >> tp-bit.c
+	cat $(srcdir)/config/fp-bit.c >> tp-bit.c
+	echo '#endif' >> tp-bit.c
+
+# We must build libgcc2.a with -G 0, in case the user wants to link
+# without the $gp register.
+
+TARGET_LIBGCC2_CFLAGS = -G 0
+ 
+# Build both ABIs.
+
+MULTILIB_OPTIONS = mabi=n32/mabi=eabi/mabi=64
+MULTILIB_DIRNAMES = n32 eabi n64
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o
+
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
diff -Nur a/gcc/config/mips/t-sgxx-linux b/gcc/config/mips/t-sgxx-linux
--- a/gcc/config/mips/t-sgxx-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/t-sgxx-linux	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,13 @@
+MULTILIB_OPTIONS = muclibc march=mips2/march=mips32 msoft-float EL/EB
+MULTILIB_DIRNAMES = uclibc mips2 mips32 soft-float el eb
+MULTILIB_MATCHES := EL=mel EB=meb \
+  march?mips2=mips2 march?mips2=mips3 march?mips2=mips4 \
+  $(foreach cpu,mips3 mips4 r6000 r4000 vr4100 vr4111 vr4120 vr4130 vr4300 \
+                r4400 r4600 orion r4650 loongson2e loongson2f r8000 r10000 \
+                r12000 r14000 r16000 vr5000 vr5400 vr5500 rm7000 \
+                rm9000,march?mips2=march?$(cpu)) \
+  march?mips32=mips32 march?mips32=mips64 \
+  $(foreach cpu,4kc 4km 4kp 4ksc mips64 5kc 5kf 20kc sb1 sb1a sr71000 \
+                xlr,march?mips32=march?$(cpu))
+MULTILIB_EXCEPTIONS = *muclibc*/*march?mips2* *muclibc*/*march?mips32*
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o 
diff -Nur a/gcc/config/mips/t-sgxxlite-linux b/gcc/config/mips/t-sgxxlite-linux
--- a/gcc/config/mips/t-sgxxlite-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/t-sgxxlite-linux	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,5 @@
+MULTILIB_OPTIONS = muclibc msoft-float EL/EB
+MULTILIB_DIRNAMES = uclibc soft-float el eb
+MULTILIB_MATCHES := EL=mel EB=meb
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+
diff -Nur a/gcc/config/mips/t-sgxx-sde b/gcc/config/mips/t-sgxx-sde
--- a/gcc/config/mips/t-sgxx-sde	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/t-sgxx-sde	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,15 @@
+# SourceryG++ overrides for SDE builds
+
+# We must build libgcc2.a with -G 0, in case the user wants to link
+# without the $gp register. Use -fno-optimize-sibling-calls in case
+# we have a mixed mips16/non-mips16 environment where a plain "jump"
+# instuction won't work across the divide (no jx instruction).
+# Compile libraries with -mcode-xonly, so that they are link-compatible
+# with both -mcode-readable=pcrel and -mcode-readable=yes.
+TARGET_LIBGCC2_CFLAGS = -G 0 -fno-optimize-sibling-calls -mcode-xonly
+
+MULTILIB_OPTIONS = EL/EB mips16 mfp64/msoft-float/mno-float mcode-readable=no
+MULTILIB_DIRNAMES = el eb mips16 fp64 sof nof spram
+MULTILIB_MATCHES = EL=mel EB=meb mips16=mips16e
+MULTILIB_EXCLUSIONS = mcode-readable=no/!mips16
+MULTILIB_EXCEPTIONS = 
diff -Nur a/gcc/config/mips/t-wrs-linux b/gcc/config/mips/t-wrs-linux
--- a/gcc/config/mips/t-wrs-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/t-wrs-linux	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,55 @@
+# Wind River GNU/Linux Configuration.
+# Copyright (C) 2006, 2007
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Build big-endian and little-endian support libraries.
+MULTILIB_OPTIONS = muclibc mel mhard-float march=octeon/march=vr5500 mabi=n32/mabi=64
+MULTILIB_DIRNAMES = uclibc mel hard-float octeon vr5500 n32 64
+MULTILIB_EXCEPTIONS = *muclibc*/*mhard-float*
+MULTILIB_EXCEPTIONS += *muclibc*/*mabi=n32*
+MULTILIB_EXCEPTIONS += *muclibc*/*mabi=64*
+MULTILIB_EXCEPTIONS += *muclibc*/*march=vr5500*
+MULTILIB_EXCEPTIONS += *mel*/*march=vr5500*
+MULTILIB_EXCEPTIONS += march=vr5500*
+MULTILIB_EXCEPTIONS += mhard-float/march=vr5500/*
+MULTILIB_EXCEPTIONS += */march=octeon*
+MULTILIB_EXCEPTIONS += march=octeon march=octeon/mabi=32
+MULTILIB_EXCEPTIONS += mel/mabi=n32 mel/mabi=64
+MULTILIB_EXCEPTIONS += mabi=n32
+# These files must be built for each multilib.
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+
+# See comment in wrs-linux.h on STARTFILE_PREFIX_SPEC for how the real
+# directories used in the sysroots are determined.  These directories
+# are specified so that (a) they are distinct and (b) removing the
+# components that form part of the sysroot suffix leaves the real
+# directory within the sysroot.
+MULTILIB_OSDIRNAMES = mel/mhard-float/mabi.n32=../lib32/mel/hard-float
+MULTILIB_OSDIRNAMES += mel/mhard-float/mabi.64=../lib64/mel/hard-float
+MULTILIB_OSDIRNAMES += mhard-float/mabi.n32=../lib32/hard-float
+MULTILIB_OSDIRNAMES += mhard-float/mabi.64=../lib64/hard-float
+MULTILIB_OSDIRNAMES += mel/mhard-float=!mel/hard-float
+MULTILIB_OSDIRNAMES += mhard-float/march.vr5500=!hard-float/vr5500
+MULTILIB_OSDIRNAMES += mhard-float=!hard-float
+MULTILIB_OSDIRNAMES += mabi.64=../lib64
+MULTILIB_OSDIRNAMES += march.octeon/mabi.n32=../lib32/octeon
+MULTILIB_OSDIRNAMES += march.octeon/mabi.64=../lib64/octeon
+MULTILIB_OSDIRNAMES += muclibc/mel=!uclibc/mel
+MULTILIB_OSDIRNAMES += muclibc=!uclibc
+
diff -Nur a/gcc/config/mips/wrs-linux.h b/gcc/config/mips/wrs-linux.h
--- a/gcc/config/mips/wrs-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/mips/wrs-linux.h	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,65 @@
+/* Wind River GNU/Linux Configuration.
+   Copyright (C) 2006, 2007
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Override linux64.h to default to O32.  */
+#undef DRIVER_SELF_SPECS
+#define DRIVER_SELF_SPECS \
+  BASE_DRIVER_SELF_SPECS, \
+  LINUX_DRIVER_SELF_SPECS \
+  " %{!EB:%{!EL:%(endian_spec)}}" \
+  " %{!mabi=*: -mabi=32}"
+
+/* We do not need to provide an explicit big-endian multilib.  */
+#undef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS \
+  { "meb", "mabi=32" }
+
+/* The GLIBC headers are in /usr/include, relative to the sysroot; the
+   uClibc headers are in /uclibc/usr/include.  */
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC		\
+  "%{muclibc:/uclibc}" 
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC				\
+  "%{muclibc:%{mel:/uclibc/mel ;			\
+               :/uclibc} ;				\
+     mel:%{mhard-float:/mel/hard-float ;		\
+           :/mel} ;					\
+     march=octeon:/octeon ;				\
+     march=vr5500:%{mhard-float:/hard-float/vr5500} ;	\
+     mhard-float:/hard-float}"
+
+/* MULTILIB_OSDIRNAMES provides directory names used in two ways:
+   relative to $target/lib/ in the GCC installation, and relative to
+   lib/ and usr/lib/ in a sysroot.  For the latter, we want names such
+   as plain ../lib64, but these cannot be used outside the sysroot
+   because different multilibs would be mapped to the same directory.
+   Directories are searched both with and without the multilib suffix,
+   so it suffices if the directory without the suffix is correct
+   within the sysroot while the directory with the suffix doesn't
+   exist.  We use STARTFILE_PREFIX_SPEC to achieve the desired
+   effect.  */
+#undef STARTFILE_PREFIX_SPEC
+#define STARTFILE_PREFIX_SPEC				\
+  "%{mabi=32: /usr/local/lib/ /lib/ /usr/lib/} 		\
+   %{mabi=n32: /usr/local/lib32/ /lib32/ /usr/lib32/}	\
+   %{mabi=64: /usr/local/lib64/ /lib64/ /usr/lib64/}"
diff -Nur a/gcc/config/mips/xlr.md b/gcc/config/mips/xlr.md
--- a/gcc/config/mips/xlr.md	2008-06-06 16:24:57.000000000 +0200
+++ b/gcc/config/mips/xlr.md	2010-01-25 09:50:29.035686224 +0100
@@ -1,5 +1,5 @@
 ;; DFA-based pipeline description for the XLR.
-;;   Copyright (C) 2008 Free Software Foundation, Inc.
+;;   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
 ;;
 ;; xlr.md   Machine Description for the RMI XLR Microprocessor
 ;; This file is part of GCC.
@@ -31,7 +31,7 @@
 ;; Integer arithmetic instructions.
 (define_insn_reservation "ir_xlr_alu" 1
   (and (eq_attr "cpu" "xlr") 
-       (eq_attr "type" "arith,shift,clz,const,unknown,multi,nop,trap"))
+       (eq_attr "type" "move,arith,shift,clz,logical,signext,const,unknown,multi,nop,trap"))
   "xlr_main_pipe")
 
 ;; Integer arithmetic instructions.
diff -Nur a/gcc/config/print-sysroot-suffix.sh b/gcc/config/print-sysroot-suffix.sh
--- a/gcc/config/print-sysroot-suffix.sh	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/print-sysroot-suffix.sh	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,154 @@
+#! /bin/sh
+# Script to generate SYSROOT_SUFFIX_SPEC equivalent to MULTILIB_OSDIRNAMES
+# Arguments are MULTILIB_OSDIRNAMES, MULTILIB_OPTIONS, MULTILIB_MATCHES
+# and MULTILIB_ALIASES.
+
+# Copyright (C) 2009 Free Software Foundation, Inc.
+
+# This file is part of GCC.
+
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 3, or (at your option) any later
+# version.
+
+# GCC is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.  
+
+# This shell script produces a header file fragment that defines
+# SYSROOT_SUFFIX_SPEC.  It assumes that the sysroots will have the same
+# structure and names used by the multilibs.
+
+# Invocation:
+#   print-sysroot-suffix.sh \
+#          MULTILIB_OSDIRNAMES \
+#          MULTILIB_OPTIONS \
+#          MULTILIB_MATCHES \
+#      > t-sysroot-suffix.h
+
+# The three options exactly correspond to the variables of the same
+# names defined in the tmake_file fragments.
+
+# Example:
+#   sh ./gcc/config/print-sysroot-suffix.sh "a=A" "a b/c/d" ""
+# =>
+#   #undef SYSROOT_SUFFIX_SPEC
+#   #define SYSROOT_SUFFIX_SPEC "" \
+#   "%{a:" \
+#     "%{b:A/b/;" \
+#     "c:A/c/;" \
+#     "d:A/d/;" \
+#     ":A/};" \
+#   ":}"
+
+# The script uses temporary subscripts in order to permit a recursive
+# algorithm without the use of functions.
+
+set -e
+
+dirnames="$1"
+options="$2"
+matches="$3"
+aliases="$4"
+
+cat > print-sysroot-suffix3.sh <<\EOF
+#! /bin/sh
+# Print all the multilib matches for this option
+result="$1"
+EOF
+for x in $matches; do
+  l=`echo $x | sed -e 's/=.*$//' -e 's/?/=/g'`
+  r=`echo $x | sed -e 's/^.*=//' -e 's/?/=/g'`
+  echo "[ \"\$1\" = \"$l\" ] && result=\"\$result|$r\"" >> print-sysroot-suffix3.sh
+done
+echo 'echo $result' >> print-sysroot-suffix3.sh
+chmod +x print-sysroot-suffix3.sh
+
+cat > print-sysroot-suffix2.sh <<\EOF
+#! /bin/sh
+# Recursive script to enumerate all multilib combinations, match against
+# multilib directories and output a spec string of the result.
+# Will fold identical trees.
+
+padding="$1"
+optstring="$2"
+shift 2
+n="\" \\
+$padding\""
+if [ $# = 0 ]; then
+  case $optstring in
+EOF
+for x in $aliases; do
+  l=`echo $x | sed -e 's/=.*$//' -e 's/?/=/g'`
+  r=`echo $x | sed -e 's/^.*=//' -e 's/?/=/g'`
+  echo "/$r/) optstring=\"/$l/\" ;;" >> print-sysroot-suffix2.sh
+done
+echo "  esac" >> print-sysroot-suffix2.sh
+
+pat=
+for x in $dirnames; do
+  p=`echo $x | sed -e 's,=!,/$=/,'`
+  pat="$pat -e 's=^//$p='"
+done
+echo '  optstring=`echo "/$optstring" | sed '"$pat\`" >> print-sysroot-suffix2.sh
+cat >> print-sysroot-suffix2.sh <<\EOF
+  case $optstring in
+  //*)
+    ;;
+  *)
+    echo "$optstring"
+    ;;
+  esac
+else
+  thisopt="$1"
+  shift
+  bit=
+  lastcond=
+  result=
+  for x in `echo "$thisopt" | sed -e 's,/, ,g'`; do
+    case $x in
+EOF
+for x in `echo "$options" | sed -e 's,/, ,g'`; do
+  match=`./print-sysroot-suffix3.sh "$x"`
+  echo "$x) optmatch=\"$match\" ;;" >> print-sysroot-suffix2.sh
+done
+cat >> print-sysroot-suffix2.sh <<\EOF
+    esac
+    bit=`"$0" "$padding  " "$optstring$x/" "$@"`
+    if [ -z "$lastopt" ]; then
+      lastopt="$optmatch"
+    else
+      if [ "$lastbit" = "$bit" ]; then
+	lastopt="$lastopt|$optmatch"
+      else
+	result="$result$lastopt:$lastbit;$n"
+	lastopt="$optmatch"
+      fi
+    fi
+    lastbit="$bit"
+  done
+  bit=`"$0" "$padding  " "$optstring" "$@"`
+  if [ "$bit" = "$lastbit" ]; then
+    if [ -z "$result" ]; then
+      echo "$bit"
+    else
+      echo "$n%{$result:$bit}"
+    fi
+  else
+    echo "$n%{$result$lastopt:$lastbit;$n:$bit}"
+  fi
+fi
+EOF
+
+chmod +x ./print-sysroot-suffix2.sh
+result=`./print-sysroot-suffix2.sh "" "/" $options`
+echo "#undef SYSROOT_SUFFIX_SPEC"
+echo "#define SYSROOT_SUFFIX_SPEC \"$result\""
+rm print-sysroot-suffix2.sh
+rm print-sysroot-suffix3.sh
diff -Nur a/gcc/config/rs6000/e500mc.h b/gcc/config/rs6000/e500mc.h
--- a/gcc/config/rs6000/e500mc.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/rs6000/e500mc.h	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,46 @@
+/* Core target definitions for GNU compiler
+   for IBM RS/6000 PowerPC targeted to embedded ELF systems.
+   Copyright (C) 1995, 1996, 2000, 2003, 2004, 2007 Free Software Foundation, Inc.
+   Contributed by Cygnus Support.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Add -meabi to target flags.  */
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_EABI)
+
+#undef TARGET_VERSION
+#define TARGET_VERSION fprintf (stderr, " (PowerPC Embedded)");
+
+#undef TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()          \
+  do                                      \
+    {                                     \
+      builtin_define_std ("PPC");         \
+      builtin_define ("__embedded__");    \
+      builtin_assert ("system=embedded"); \
+      builtin_assert ("cpu=powerpc");     \
+      builtin_assert ("machine=powerpc"); \
+      TARGET_OS_SYSV_CPP_BUILTINS ();     \
+    }                                     \
+  while (0)
+
+#undef CC1_EXTRA_SPEC
+#define CC1_EXTRA_SPEC "-maix-struct-return"
+
+#undef ASM_DEFAULT_SPEC
+#define ASM_DEFAULT_SPEC "-mppc%{m64:64} -me500mc"
diff -Nur a/gcc/config/rs6000/eabi.asm b/gcc/config/rs6000/eabi.asm
--- a/gcc/config/rs6000/eabi.asm	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/rs6000/eabi.asm	2010-01-25 09:50:29.035686224 +0100
@@ -230,7 +230,7 @@
    r11		has the address of .LCTOC1 in it.
    r12		has the value to add to each pointer
    r13 .. r31	are unchanged */
-	
+#ifdef _RELOCATABLE
 FUNC_START(__eabi_convert)
         cmplw	1,3,4				/* any pointers to convert? */
         subf	5,3,4				/* calculate number of words to convert */
@@ -285,5 +285,5 @@
         blr
 
 FUNC_END(__eabi_uconvert)
-
+#endif
 #endif
diff -Nur a/gcc/config/rs6000/eabi-ci.asm b/gcc/config/rs6000/eabi-ci.asm
--- a/gcc/config/rs6000/eabi-ci.asm	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/rs6000/eabi-ci.asm	2010-01-25 09:50:29.035686224 +0100
@@ -98,6 +98,7 @@
 /* Head of __init function used for static constructors.  */
 	.section ".init","ax"
 	.align 2
+FUNC_START(_init)
 FUNC_START(__init)
 	stwu 1,-16(1)
 	mflr 0
@@ -106,6 +107,7 @@
 /* Head of __fini function used for static destructors.  */
 	.section ".fini","ax"
 	.align 2
+FUNC_START(_fini)
 FUNC_START(__fini)
 	stwu 1,-16(1)
 	mflr 0
diff -Nur a/gcc/config/rs6000/eabi.h b/gcc/config/rs6000/eabi.h
--- a/gcc/config/rs6000/eabi.h	2007-08-02 12:49:31.000000000 +0200
+++ b/gcc/config/rs6000/eabi.h	2010-01-25 09:50:29.035686224 +0100
@@ -23,10 +23,6 @@
 #undef TARGET_DEFAULT
 #define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_EABI)
 
-/* Invoke an initializer function to set up the GOT.  */
-#define NAME__MAIN "__eabi"
-#define INVOKE__main
-
 #undef TARGET_VERSION
 #define TARGET_VERSION fprintf (stderr, " (PowerPC Embedded)");
 
@@ -42,3 +38,20 @@
       TARGET_OS_SYSV_CPP_BUILTINS ();     \
     }                                     \
   while (0)
+
+/* Add -te500v1 and -te500v2 options for convenience in generating
+   multilibs.  */
+#undef CC1_EXTRA_SPEC
+#define CC1_EXTRA_SPEC \
+  "%{te500v1: -mcpu=8540 -mfloat-gprs=single -mspe=yes -mabi=spe} " \
+  "%{te500v2: -mcpu=8548 -mfloat-gprs=double -mspe=yes -mabi=spe} " \
+  "%{te600: -mcpu=7400 -maltivec -mabi=altivec}"		    \
+  "%{te500mc: -mcpu=e500mc -maix-struct-return}"
+
+#undef ASM_DEFAULT_SPEC
+#define ASM_DEFAULT_SPEC			\
+  "%{te500v1:-mppc -mspe -me500 ;		\
+     te500v2:-mppc -mspe -me500 ;		\
+     te600:-mppc -maltivec ;			\
+     te500mc:-mppc -me500mc ;			\
+     :-mppc%{m64:64}}"
diff -Nur a/gcc/config/rs6000/linux.h b/gcc/config/rs6000/linux.h
--- a/gcc/config/rs6000/linux.h	2007-08-02 12:49:31.000000000 +0200
+++ b/gcc/config/rs6000/linux.h	2010-01-25 09:50:29.035686224 +0100
@@ -128,3 +128,29 @@
 #ifdef TARGET_DEFAULT_LONG_DOUBLE_128
 #define RS6000_DEFAULT_LONG_DOUBLE_SIZE 128
 #endif
+
+/* Add -te500v1 and -te500v2 options for convenience in generating
+   multilibs.  */
+#undef CC1_EXTRA_SPEC
+#define CC1_EXTRA_SPEC \
+  "%{te500v1: -mcpu=8540 -mfloat-gprs=single -mspe=yes -mabi=spe} " \
+  "%{te500v2: -mcpu=8548 -mfloat-gprs=double -mspe=yes -mabi=spe} " \
+  "%{te600: -mcpu=7400 -maltivec -mabi=altivec}" \
+  "%{te500mc: -mcpu=e500mc}"
+
+#undef ASM_DEFAULT_SPEC
+#define ASM_DEFAULT_SPEC			\
+  "%{te500v1:-mppc -mspe -me500 ;		\
+     te500v2:-mppc -mspe -me500 ;		\
+     te600:-mppc -maltivec ;			\
+     te500mc:-me500mc ;				\
+     :-mppc%{m64:64}}"
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+  "%{msoft-float:/nof ;				\
+     te600:/te600 ;				\
+     te500v1:/te500v1 ;				\
+     te500v2:/te500v2 ;				\
+     te500mc:/te500mc}"
diff -Nur a/gcc/config/rs6000/montavista-linux.h b/gcc/config/rs6000/montavista-linux.h
--- a/gcc/config/rs6000/montavista-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/rs6000/montavista-linux.h	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,41 @@
+/* MontaVista GNU/Linux Configuration.
+   Copyright (C) 2009
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Add -te500v2 option for convenience in generating multilibs.  */
+#undef CC1_EXTRA_SPEC
+#define CC1_EXTRA_SPEC \
+  "%{te500v2: -mcpu=8548 -mfloat-gprs=double -mspe=yes -mabi=spe} " \
+  "%{te600: -mcpu=7400 -maltivec -mabi=altivec}" \
+  "%{te500mc: -mcpu=e500mc}"
+
+#undef ASM_DEFAULT_SPEC
+#define ASM_DEFAULT_SPEC                        \
+  "%{te500v2:-mppc -mspe -me500 ;               \
+     te600:-mppc -maltivec ;                    \
+     te500mc:-me500mc ;                         \
+     :-mppc}"
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+  "%{msoft-float:/soft-float ;			\
+     te600:/te600 ;                             \
+     te500v2:/te500v2 ;                         \
+     te500mc:/te500mc}"
diff -Nur a/gcc/config/rs6000/option-defaults.h b/gcc/config/rs6000/option-defaults.h
--- a/gcc/config/rs6000/option-defaults.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/rs6000/option-defaults.h	2010-01-25 09:50:29.035686224 +0100
@@ -0,0 +1,64 @@
+/* Definitions of default options for config/rs6000 configurations.
+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This header needs to be included after any other headers affecting
+   TARGET_DEFAULT.  */
+
+#if TARGET_AIX
+#define OPT_64 "maix64"
+#define OPT_32 "maix32"
+#else
+#define OPT_64 "m64"
+#define OPT_32 "m32"
+#endif
+
+#ifndef MASK_64BIT
+#define MASK_64BIT 0
+#endif
+
+#if TARGET_DEFAULT & MASK_64BIT
+#define OPT_ARCH64 "!"OPT_32
+#define OPT_ARCH32 OPT_32
+#else
+#define OPT_ARCH64 OPT_64
+#define OPT_ARCH32 "!"OPT_64
+#endif
+
+/* Support for a compile-time default CPU, et cetera.  The rules are:
+   --with-cpu is ignored if -mcpu is specified; likewise --with-cpu-32
+     and --with-cpu-64.
+   --with-tune is ignored if -mtune is specified; likewise --with-tune-32
+     and --with-tune-64.
+   --with-float is ignored if -mhard-float or -msoft-float are
+    specified.  */
+#define OPTION_DEFAULT_SPECS \
+  {"cpu", "%{mcpu=*|te500mc|te500v1|te500v2|te600:;:-mcpu=%(VALUE)}" }, \
+  {"cpu_32", "%{" OPT_ARCH32 ":%{mcpu=*|te500mc|te500v1|te500v2|te600:;:-mcpu=%(VALUE)}}" }, \
+  {"cpu_64", "%{" OPT_ARCH64 ":%{mcpu=*|te500mc|te500v1|te500v2|te600:;:-mcpu=%(VALUE)}}" }, \
+  {"tune", "%{!mtune=*:-mtune=%(VALUE)}" }, \
+  {"tune_32", "%{" OPT_ARCH32 ":%{!mtune=*:-mtune=%(VALUE)}}" }, \
+  {"tune_64", "%{" OPT_ARCH64 ":%{!mtune=*:-mtune=%(VALUE)}}" }, \
+  {"float", "%{!msoft-float:%{!mhard-float:-m%(VALUE)-float}}" }
diff -Nur a/gcc/config/rs6000/paired.md b/gcc/config/rs6000/paired.md
--- a/gcc/config/rs6000/paired.md	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/rs6000/paired.md	2010-01-25 09:50:29.035686224 +0100
@@ -27,7 +27,7 @@
  (UNSPEC_EXTODD_V2SF      333)
 ])
 
-(define_insn "negv2sf2"
+(define_insn "paired_negv2sf2"
   [(set (match_operand:V2SF 0 "gpc_reg_operand" "=f")
 	(neg:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "f")))]
   "TARGET_PAIRED_FLOAT"
@@ -41,7 +41,7 @@
   "ps_rsqrte %0,%1"
   [(set_attr "type" "fp")])
 
-(define_insn "absv2sf2"
+(define_insn "paired_absv2sf2"
   [(set (match_operand:V2SF 0 "gpc_reg_operand" "=f")
 	(abs:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "f")))]
   "TARGET_PAIRED_FLOAT"
@@ -55,7 +55,7 @@
   "ps_nabs %0,%1"
   [(set_attr "type" "fp")])
 
-(define_insn "addv2sf3"
+(define_insn "paired_addv2sf3"
   [(set (match_operand:V2SF 0 "gpc_reg_operand" "=f")
 	(plus:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "%f")
 		   (match_operand:V2SF 2 "gpc_reg_operand" "f")))]
@@ -63,7 +63,7 @@
   "ps_add %0,%1,%2"
   [(set_attr "type" "fp")])
 
-(define_insn "subv2sf3"
+(define_insn "paired_subv2sf3"
   [(set (match_operand:V2SF 0 "gpc_reg_operand" "=f")
         (minus:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "f")
                     (match_operand:V2SF 2 "gpc_reg_operand" "f")))]
@@ -71,7 +71,7 @@
   "ps_sub %0,%1,%2"
   [(set_attr "type" "fp")])
 
-(define_insn "mulv2sf3"
+(define_insn "paired_mulv2sf3"
   [(set (match_operand:V2SF 0 "gpc_reg_operand" "=f")
 	(mult:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "%f")
 		   (match_operand:V2SF 2 "gpc_reg_operand" "f")))]
@@ -86,7 +86,7 @@
   "ps_res %0,%1"
   [(set_attr "type" "fp")])
 
-(define_insn "divv2sf3"
+(define_insn "paired_divv2sf3"
   [(set (match_operand:V2SF 0 "gpc_reg_operand" "=f")
 	(div:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "f")
 		  (match_operand:V2SF 2 "gpc_reg_operand" "f")))]
diff -Nur a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
--- a/gcc/config/rs6000/rs6000.c	2009-03-17 21:18:21.000000000 +0100
+++ b/gcc/config/rs6000/rs6000.c	2010-01-25 09:50:29.035686224 +0100
@@ -919,6 +919,7 @@
 static bool rs6000_is_opaque_type (const_tree);
 static rtx rs6000_dwarf_register_span (rtx);
 static void rs6000_init_dwarf_reg_sizes_extra (tree);
+static int rs6000_commutative_operand_precedence (const_rtx, int);
 static rtx rs6000_legitimize_tls_address (rtx, enum tls_model);
 static void rs6000_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;
 static rtx rs6000_tls_get_addr (void);
@@ -1194,6 +1195,10 @@
 #undef TARGET_VECTOR_OPAQUE_P
 #define TARGET_VECTOR_OPAQUE_P rs6000_is_opaque_type
 
+#undef TARGET_COMMUTATIVE_OPERAND_PRECEDENCE
+#define TARGET_COMMUTATIVE_OPERAND_PRECEDENCE \
+  rs6000_commutative_operand_precedence
+
 #undef TARGET_DWARF_REGISTER_SPAN
 #define TARGET_DWARF_REGISTER_SPAN rs6000_dwarf_register_span
 
@@ -4682,16 +4687,19 @@
   if (TARGET_ALTIVEC)
     global_regs[VSCR_REGNO] = 1;
 
-  if (TARGET_ALTIVEC_ABI)
-    {
-      for (i = FIRST_ALTIVEC_REGNO; i < FIRST_ALTIVEC_REGNO + 20; ++i)
-	call_used_regs[i] = call_really_used_regs[i] = 1;
+  /* If we are not using the AltiVec ABI, pretend that the normally
+     call-saved registers are also call-used.  We could use them
+     normally if we saved and restored them in the prologue; that
+     would require using the alignment padding around the register
+     save area, and some care with unwinding information.  */
+  if (! TARGET_ALTIVEC_ABI)
+    for (i = FIRST_ALTIVEC_REGNO + 20; i <= LAST_ALTIVEC_REGNO; ++i)
+      call_used_regs[i] = call_really_used_regs[i] = 1;
 
-      /* AIX reserves VR20:31 in non-extended ABI mode.  */
-      if (TARGET_XCOFF)
-	for (i = FIRST_ALTIVEC_REGNO + 20; i < FIRST_ALTIVEC_REGNO + 32; ++i)
-	  fixed_regs[i] = call_used_regs[i] = call_really_used_regs[i] = 1;
-    }
+  if (TARGET_ALTIVEC_ABI && TARGET_XCOFF)
+    /* AIX reserves VR20:31 in non-extended ABI mode.  */
+    for (i = FIRST_ALTIVEC_REGNO + 20; i < FIRST_ALTIVEC_REGNO + 32; ++i)
+      fixed_regs[i] = call_used_regs[i] = call_really_used_regs[i] = 1;
 }
 
 /* Try to output insns to set TARGET equal to the constant C if it can
@@ -7507,10 +7515,10 @@
   { MASK_ALTIVEC, CODE_FOR_nothing, "__builtin_vec_sums", ALTIVEC_BUILTIN_VEC_SUMS },
   { MASK_ALTIVEC, CODE_FOR_nothing, "__builtin_vec_xor", ALTIVEC_BUILTIN_VEC_XOR },
 
-  { 0, CODE_FOR_divv2sf3, "__builtin_paired_divv2sf3", PAIRED_BUILTIN_DIVV2SF3 },
-  { 0, CODE_FOR_addv2sf3, "__builtin_paired_addv2sf3", PAIRED_BUILTIN_ADDV2SF3 },
-  { 0, CODE_FOR_subv2sf3, "__builtin_paired_subv2sf3", PAIRED_BUILTIN_SUBV2SF3 },
-  { 0, CODE_FOR_mulv2sf3, "__builtin_paired_mulv2sf3", PAIRED_BUILTIN_MULV2SF3 },
+  { 0, CODE_FOR_paired_divv2sf3, "__builtin_paired_divv2sf3", PAIRED_BUILTIN_DIVV2SF3 },
+  { 0, CODE_FOR_paired_addv2sf3, "__builtin_paired_addv2sf3", PAIRED_BUILTIN_ADDV2SF3 },
+  { 0, CODE_FOR_paired_subv2sf3, "__builtin_paired_subv2sf3", PAIRED_BUILTIN_SUBV2SF3 },
+  { 0, CODE_FOR_paired_mulv2sf3, "__builtin_paired_mulv2sf3", PAIRED_BUILTIN_MULV2SF3 },
   { 0, CODE_FOR_paired_muls0, "__builtin_paired_muls0", PAIRED_BUILTIN_MULS0 },
   { 0, CODE_FOR_paired_muls1, "__builtin_paired_muls1", PAIRED_BUILTIN_MULS1 },
   { 0, CODE_FOR_paired_merge00, "__builtin_paired_merge00", PAIRED_BUILTIN_MERGE00 },
@@ -7519,10 +7527,10 @@
   { 0, CODE_FOR_paired_merge11, "__builtin_paired_merge11", PAIRED_BUILTIN_MERGE11 },
 
   /* Place holder, leave as first spe builtin.  */
-  { 0, CODE_FOR_spe_evaddw, "__builtin_spe_evaddw", SPE_BUILTIN_EVADDW },
-  { 0, CODE_FOR_spe_evand, "__builtin_spe_evand", SPE_BUILTIN_EVAND },
+  { 0, CODE_FOR_addv2si3, "__builtin_spe_evaddw", SPE_BUILTIN_EVADDW },
+  { 0, CODE_FOR_andv2si3, "__builtin_spe_evand", SPE_BUILTIN_EVAND },
   { 0, CODE_FOR_spe_evandc, "__builtin_spe_evandc", SPE_BUILTIN_EVANDC },
-  { 0, CODE_FOR_spe_evdivws, "__builtin_spe_evdivws", SPE_BUILTIN_EVDIVWS },
+  { 0, CODE_FOR_divv2si3, "__builtin_spe_evdivws", SPE_BUILTIN_EVDIVWS },
   { 0, CODE_FOR_spe_evdivwu, "__builtin_spe_evdivwu", SPE_BUILTIN_EVDIVWU },
   { 0, CODE_FOR_spe_eveqv, "__builtin_spe_eveqv", SPE_BUILTIN_EVEQV },
   { 0, CODE_FOR_spe_evfsadd, "__builtin_spe_evfsadd", SPE_BUILTIN_EVFSADD },
@@ -7798,7 +7806,7 @@
 
   /* The SPE unary builtins must start with SPE_BUILTIN_EVABS and
      end with SPE_BUILTIN_EVSUBFUSIAAW.  */
-  { 0, CODE_FOR_spe_evabs, "__builtin_spe_evabs", SPE_BUILTIN_EVABS },
+  { 0, CODE_FOR_absv2si2, "__builtin_spe_evabs", SPE_BUILTIN_EVABS },
   { 0, CODE_FOR_spe_evaddsmiaaw, "__builtin_spe_evaddsmiaaw", SPE_BUILTIN_EVADDSMIAAW },
   { 0, CODE_FOR_spe_evaddssiaaw, "__builtin_spe_evaddssiaaw", SPE_BUILTIN_EVADDSSIAAW },
   { 0, CODE_FOR_spe_evaddumiaaw, "__builtin_spe_evaddumiaaw", SPE_BUILTIN_EVADDUMIAAW },
@@ -7830,9 +7838,9 @@
   /* Place-holder.  Leave as last unary SPE builtin.  */
   { 0, CODE_FOR_spe_evsubfusiaaw, "__builtin_spe_evsubfusiaaw", SPE_BUILTIN_EVSUBFUSIAAW },
 
-  { 0, CODE_FOR_absv2sf2, "__builtin_paired_absv2sf2", PAIRED_BUILTIN_ABSV2SF2 },
+  { 0, CODE_FOR_paired_absv2sf2, "__builtin_paired_absv2sf2", PAIRED_BUILTIN_ABSV2SF2 },
   { 0, CODE_FOR_nabsv2sf2, "__builtin_paired_nabsv2sf2", PAIRED_BUILTIN_NABSV2SF2 },
-  { 0, CODE_FOR_negv2sf2, "__builtin_paired_negv2sf2", PAIRED_BUILTIN_NEGV2SF2 },
+  { 0, CODE_FOR_paired_negv2sf2, "__builtin_paired_negv2sf2", PAIRED_BUILTIN_NEGV2SF2 },
   { 0, CODE_FOR_sqrtv2sf2, "__builtin_paired_sqrtv2sf2", PAIRED_BUILTIN_SQRTV2SF2 },
   { 0, CODE_FOR_resv2sf2, "__builtin_paired_resv2sf2", PAIRED_BUILTIN_RESV2SF2 }
 };
@@ -9370,6 +9378,8 @@
 static void
 rs6000_init_builtins (void)
 {
+  tree tdecl;
+  
   V2SI_type_node = build_vector_type (intSI_type_node, 2);
   V2SF_type_node = build_vector_type (float_type_node, 2);
   V4HI_type_node = build_vector_type (intHI_type_node, 4);
@@ -9407,60 +9417,75 @@
   float_type_internal_node = float_type_node;
   void_type_internal_node = void_type_node;
 
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__bool char"),
-					    bool_char_type_node));
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__bool short"),
-					    bool_short_type_node));
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__bool int"),
-					    bool_int_type_node));
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__pixel"),
-					    pixel_type_node));
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__bool char"),
+		      bool_char_type_node);
+  TYPE_NAME (bool_char_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__bool short"),
+		      bool_short_type_node);
+  TYPE_NAME (bool_short_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__bool int"),
+		      bool_int_type_node);
+  TYPE_NAME (bool_int_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__pixel"),
+		      pixel_type_node);
+  TYPE_NAME (pixel_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
 
   bool_V16QI_type_node = build_vector_type (bool_char_type_node, 16);
   bool_V8HI_type_node = build_vector_type (bool_short_type_node, 8);
   bool_V4SI_type_node = build_vector_type (bool_int_type_node, 4);
   pixel_V8HI_type_node = build_vector_type (pixel_type_node, 8);
 
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__vector unsigned char"),
-					    unsigned_V16QI_type_node));
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__vector signed char"),
-					    V16QI_type_node));
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__vector __bool char"),
-					    bool_V16QI_type_node));
-
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__vector unsigned short"),
-					    unsigned_V8HI_type_node));
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__vector signed short"),
-					    V8HI_type_node));
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__vector __bool short"),
-					    bool_V8HI_type_node));
-
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__vector unsigned int"),
-					    unsigned_V4SI_type_node));
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__vector signed int"),
-					    V4SI_type_node));
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__vector __bool int"),
-					    bool_V4SI_type_node));
-
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__vector float"),
-					    V4SF_type_node));
-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,
-					    get_identifier ("__vector __pixel"),
-					    pixel_V8HI_type_node));
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__vector unsigned char"),
+		      unsigned_V16QI_type_node);
+  TYPE_NAME (unsigned_V16QI_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__vector signed char"),
+		      V16QI_type_node);
+  TYPE_NAME (V16QI_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__vector __bool char"),
+		      bool_V16QI_type_node);
+  TYPE_NAME ( bool_V16QI_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__vector unsigned short"),
+		      unsigned_V8HI_type_node);
+  TYPE_NAME (unsigned_V8HI_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__vector signed short"),
+		      V8HI_type_node);
+  TYPE_NAME (V8HI_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__vector __bool short"),
+		      bool_V8HI_type_node);
+  TYPE_NAME (bool_V8HI_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__vector unsigned int"),
+		      unsigned_V4SI_type_node);
+  TYPE_NAME (unsigned_V4SI_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__vector signed int"),
+		      V4SI_type_node);
+  TYPE_NAME (V4SI_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__vector __bool int"),
+		      bool_V4SI_type_node);
+  TYPE_NAME (bool_V4SI_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__vector float"),
+		      V4SF_type_node);
+  TYPE_NAME (V4SF_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
+  tdecl = build_decl (TYPE_DECL, get_identifier ("__vector __pixel"),
+		      pixel_V8HI_type_node);
+  TYPE_NAME (pixel_V8HI_type_node) = tdecl;
+  (*lang_hooks.decls.pushdecl) (tdecl);
 
   if (TARGET_PAIRED_FLOAT)
     paired_init_builtins ();
@@ -15843,7 +15868,7 @@
 no_global_regs_above (int first, bool gpr)
 {
   int i;
-  for (i = first; i < gpr ? 32 : 64 ; i++)
+  for (i = first; i < (gpr ? 32 : 64); i++)
     if (global_regs[i])
       return false;
   return true;
@@ -15869,11 +15894,11 @@
   int regno = gpr ? info->first_gp_reg_save : (info->first_fp_reg_save - 32);
   rtx sym;
   int select = ((savep ? 1 : 0) << 2
-		| (gpr
+		| (TARGET_SPE_ABI
 		   /* On the SPE, we never have any FPRs, but we do have
 		      32/64-bit versions of the routines.  */
-		   ? (TARGET_SPE_ABI && info->spe_64bit_regs_used ? 1 : 0)
-		   : 0) << 1
+		   ? (info->spe_64bit_regs_used ? 1 : 0)
+		   : (gpr ? 1 : 0)) << 1
 		| (exitp ? 1: 0));
 
   /* Don't generate bogus routine names.  */
@@ -15908,6 +15933,7 @@
 
       sym = savres_routine_syms[regno-FIRST_SAVRES_REGISTER][select]
 	= gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));
+      SYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_FUNCTION;
     }
 
   return sym;
@@ -16098,6 +16124,14 @@
 	savres_gprs_inline = savres_gprs_inline || using_multiple_p;
     }
 
+  /* Code intended for use in shared libraries cannot be reliably linked
+     with out-of-line prologues and epilogues.  */
+  if (flag_pic)
+    {
+      savres_gprs_inline = 1;
+      savres_fprs_inline = 1;
+    }
+
   return (using_multiple_p
 	  | (savres_fprs_inline << 1)
 	  | (savres_gprs_inline << 2));
@@ -16122,7 +16156,7 @@
   int using_store_multiple;
   int using_static_chain_p = (cfun->static_chain_decl != NULL_TREE
                               && df_regs_ever_live_p (STATIC_CHAIN_REGNUM)
-                              && !call_used_regs[STATIC_CHAIN_REGNUM]);
+                              && call_used_regs[STATIC_CHAIN_REGNUM]);
   HOST_WIDE_INT sp_offset = 0;
 
   if (TARGET_FIX_AND_CONTINUE)
@@ -16924,8 +16958,9 @@
 				 || (cfun->calls_alloca
 				     && !frame_pointer_needed));
   restore_lr = (info->lr_save_p
-		&& restoring_GPRs_inline
-		&& restoring_FPRs_inline);
+		&& (restoring_GPRs_inline
+		    || (restoring_FPRs_inline
+			&& info->first_fp_reg_save < 64)));
 
   if (WORLD_SAVE_P (info))
     {
@@ -17197,7 +17232,7 @@
 
   /* Get the old lr if we saved it.  If we are restoring registers
      out-of-line, then the out-of-line routines can do this for us.  */
-  if (restore_lr)
+  if (restore_lr && restoring_GPRs_inline)
     {
       rtx mem = gen_frame_mem_offset (Pmode, frame_reg_rtx,
 				      info->lr_save_offset + sp_offset);
@@ -17216,7 +17251,7 @@
     }
 
   /* Set LR here to try to overlap restores below.  */
-  if (restore_lr)
+  if (restore_lr && restoring_GPRs_inline)
     emit_move_insn (gen_rtx_REG (Pmode, LR_REGNO),
 		    gen_rtx_REG (Pmode, 0));
 
@@ -17396,6 +17431,18 @@
           }
     }
 
+  if (restore_lr && !restoring_GPRs_inline)
+    {
+      rtx mem = gen_frame_mem_offset (Pmode, frame_reg_rtx,
+				      info->lr_save_offset + sp_offset);
+
+      emit_move_insn (gen_rtx_REG (Pmode, 0), mem);
+    }
+
+  if (restore_lr && !restoring_GPRs_inline)
+    emit_move_insn (gen_rtx_REG (Pmode, LR_REGNO),
+		    gen_rtx_REG (Pmode, 0));
+
   /* Restore fpr's if we need to do it without calling a function.  */
   if (restoring_FPRs_inline)
     for (i = 0; i < 64 - info->first_fp_reg_save; i++)
@@ -22163,6 +22210,30 @@
     return 4 + rs6000_register_move_cost (mode, rclass, GENERAL_REGS);
 }
 
+/* Return a value indicating whether OP, an operand of a commutative
+   operation, is preferred as the first or second operand.  The higher
+   the value, the stronger the preference for being the first operand.
+   We use negative values to indicate a preference for the first operand
+   and positive values for the second operand.
+   VALUE is the default precedence for OP; see rtlanal.c:
+   commutative_operand_precendece.  */
+
+static int
+rs6000_commutative_operand_precedence (const_rtx op, int value)
+{
+  /* Prefer pointer objects over non pointer objects.
+     For rationale see PR28690.  */
+  if (GET_RTX_CLASS (GET_CODE (op)) == RTX_OBJ
+      && ((REG_P (op) && REG_POINTER (op))
+	  || (MEM_P (op) && MEM_POINTER (op))))
+    /* value = -1 */;
+  else
+    /* value = -2 */
+    --value;
+
+  return value;
+}
+
 /* Returns a code for a target-specific builtin that implements
    reciprocal of the function, or NULL_TREE if not available.  */
 
@@ -22686,12 +22757,16 @@
 static rtx
 rs6000_dwarf_register_span (rtx reg)
 {
-  unsigned regno;
+  rtx parts[8];
+  int i, words;
+  unsigned regno = REGNO (reg);
+  enum machine_mode mode = GET_MODE (reg);
 
   if (TARGET_SPE
+      && regno < 32
       && (SPE_VECTOR_MODE (GET_MODE (reg))
-	  || (TARGET_E500_DOUBLE
-	      && (GET_MODE (reg) == DFmode || GET_MODE (reg) == DDmode))))
+	  || (TARGET_E500_DOUBLE && FLOAT_MODE_P (mode)
+	      && mode != SFmode && mode != SDmode && mode != SCmode)))
     ;
   else
     return NULL_RTX;
@@ -22701,15 +22776,23 @@
   /* The duality of the SPE register size wreaks all kinds of havoc.
      This is a way of distinguishing r0 in 32-bits from r0 in
      64-bits.  */
-  return
-    gen_rtx_PARALLEL (VOIDmode,
-		      BYTES_BIG_ENDIAN
-		      ? gen_rtvec (2,
-				   gen_rtx_REG (SImode, regno + 1200),
-				   gen_rtx_REG (SImode, regno))
-		      : gen_rtvec (2,
-				   gen_rtx_REG (SImode, regno),
-				   gen_rtx_REG (SImode, regno + 1200)));
+  words = (GET_MODE_SIZE (mode) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD;
+  gcc_assert (words <= 4);
+  for (i = 0; i < words; i++, regno++)
+    {
+      if (BYTES_BIG_ENDIAN)
+	{
+	  parts[2 * i] = gen_rtx_REG (SImode, regno + 1200);
+	  parts[2 * i + 1] = gen_rtx_REG (SImode, regno);
+	}
+      else
+	{
+	  parts[2 * i] = gen_rtx_REG (SImode, regno);
+	  parts[2 * i + 1] = gen_rtx_REG (SImode, regno + 1200);
+	}
+    }
+
+  return gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (words * 2, parts));
 }
 
 /* Fill in sizes for SPE register high parts in table used by unwinder.  */
diff -Nur a/gcc/config/rs6000/rs6000.h b/gcc/config/rs6000/rs6000.h
--- a/gcc/config/rs6000/rs6000.h	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/rs6000/rs6000.h	2010-01-25 09:50:29.045688403 +0100
@@ -368,16 +368,6 @@
     previous_group
   };
 
-/* Support for a compile-time default CPU, et cetera.  The rules are:
-   --with-cpu is ignored if -mcpu is specified.
-   --with-tune is ignored if -mtune is specified.
-   --with-float is ignored if -mhard-float or -msoft-float are
-    specified.  */
-#define OPTION_DEFAULT_SPECS \
-  {"cpu", "%{!mcpu=*:-mcpu=%(VALUE)}" }, \
-  {"tune", "%{!mtune=*:-mtune=%(VALUE)}" }, \
-  {"float", "%{!msoft-float:%{!mhard-float:-m%(VALUE)-float}}" }
-
 /* rs6000_select[0] is reserved for the default cpu defined via --with-cpu */
 struct rs6000_cpu_select
 {
@@ -794,8 +784,8 @@
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1,	   \
    /* AltiVec registers.  */			   \
-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
+   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    1, 1						   \
    , 1, 1, 1                                       \
 }
@@ -813,8 +803,8 @@
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1,	   \
    /* AltiVec registers.  */			   \
-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
+   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0						   \
    , 0, 0, 0                                       \
 }
diff -Nur a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
--- a/gcc/config/rs6000/rs6000.md	2009-04-01 18:22:17.000000000 +0200
+++ b/gcc/config/rs6000/rs6000.md	2010-01-25 09:50:29.045688403 +0100
@@ -14703,9 +14703,9 @@
   [(match_parallel 0 "any_parallel_operand"
 		   [(clobber (reg:P 65))
 		    (use (match_operand:P 1 "symbol_ref_operand" "s"))
-                    (use (match_operand:P 2 "gpc_reg_operand" "r"))
-		    (set (match_operand:P 3 "memory_operand" "=m")
-			 (match_operand:P 4 "gpc_reg_operand" "r"))])]
+                    (use (reg:P 11))
+		    (set (match_operand:P 2 "memory_operand" "=m")
+			 (match_operand:P 3 "gpc_reg_operand" "r"))])]
   ""
   "bl %z1"
   [(set_attr "type" "branch")
@@ -14715,9 +14715,9 @@
   [(match_parallel 0 "any_parallel_operand"
 		   [(clobber (reg:P 65))
 		    (use (match_operand:P 1 "symbol_ref_operand" "s"))
-                    (use (match_operand:P 2 "gpc_reg_operand" "r"))
-		    (set (match_operand:DF 3 "memory_operand" "=m")
-			 (match_operand:DF 4 "gpc_reg_operand" "f"))])]
+                    (use (reg:P 11))
+		    (set (match_operand:DF 2 "memory_operand" "=m")
+			 (match_operand:DF 3 "gpc_reg_operand" "f"))])]
   ""
   "bl %z1"
   [(set_attr "type" "branch")
@@ -14810,9 +14810,9 @@
  [(match_parallel 0 "any_parallel_operand"
                   [(clobber (match_operand:P 1 "register_operand" "=l"))
                    (use (match_operand:P 2 "symbol_ref_operand" "s"))
-                   (use (match_operand:P 3 "gpc_reg_operand" "r"))
-		   (set (match_operand:P 4 "gpc_reg_operand" "=r")
-			(match_operand:P 5 "memory_operand" "m"))])]
+                   (use (reg:P 11))
+		   (set (match_operand:P 3 "gpc_reg_operand" "=r")
+			(match_operand:P 4 "memory_operand" "m"))])]
  ""
  "bl %z2"
  [(set_attr "type" "branch")
@@ -14823,9 +14823,9 @@
                   [(return)
 		   (clobber (match_operand:P 1 "register_operand" "=l"))
 		   (use (match_operand:P 2 "symbol_ref_operand" "s"))
-                   (use (match_operand:P 3 "gpc_reg_operand" "r"))
-		   (set (match_operand:P 4 "gpc_reg_operand" "=r")
-			(match_operand:P 5 "memory_operand" "m"))])]
+                   (use (reg:P 11))
+		   (set (match_operand:P 3 "gpc_reg_operand" "=r")
+			(match_operand:P 4 "memory_operand" "m"))])]
  ""
  "b %z2"
  [(set_attr "type" "branch")
@@ -14836,9 +14836,9 @@
                   [(return)
 		   (clobber (match_operand:P 1 "register_operand" "=l"))
 		   (use (match_operand:P 2 "symbol_ref_operand" "s"))
-                   (use (match_operand:P 3 "gpc_reg_operand" "r"))
-		   (set (match_operand:DF 4 "gpc_reg_operand" "=f")
-			(match_operand:DF 5 "memory_operand" "m"))])]
+                   (use (reg:P 11))
+		   (set (match_operand:DF 3 "gpc_reg_operand" "=f")
+			(match_operand:DF 4 "memory_operand" "m"))])]
  ""
  "b %z2"
  [(set_attr "type" "branch")
@@ -14889,6 +14889,120 @@
 }"
   [(set_attr "type" "load")])
 
+;;; Expanders for vector insn patterns shared between the SPE and TARGET_PAIRED systems.
+
+(define_expand "absv2sf2"
+  [(set (match_operand:V2SF 0 "gpc_reg_operand" "")
+	(abs:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "")))]
+  "TARGET_PAIRED_FLOAT || TARGET_SPE"
+  "
+{
+  if (TARGET_SPE)
+    {
+      /* We need to make a note that we clobber SPEFSCR.  */
+      emit_insn (gen_rtx_SET (VOIDmode, operands[0],
+                              gen_rtx_ABS (V2SFmode, operands[1])));
+      emit_insn (gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, SPEFSCR_REGNO)));
+      DONE;
+    }
+}")
+
+(define_expand "negv2sf2"
+  [(set (match_operand:V2SF 0 "gpc_reg_operand" "")
+	(neg:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "")))]
+  "TARGET_PAIRED_FLOAT || TARGET_SPE"
+  "
+{
+  if (TARGET_SPE)
+    {
+      /* We need to make a note that we clobber SPEFSCR.  */
+      emit_insn (gen_rtx_SET (VOIDmode, operands[0],
+                              gen_rtx_NEG (V2SFmode, operands[1])));
+      emit_insn (gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, SPEFSCR_REGNO)));
+      DONE;
+    }
+}")
+
+(define_expand "addv2sf3"
+  [(set (match_operand:V2SF 0 "gpc_reg_operand" "")
+	(plus:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "")
+		   (match_operand:V2SF 2 "gpc_reg_operand" "")))]
+  "TARGET_PAIRED_FLOAT || TARGET_SPE"
+  "
+{
+  if (TARGET_SPE)
+    {
+      /* We need to make a note that we clobber SPEFSCR.  */
+      rtx par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
+
+      XVECEXP (par, 0, 0) = gen_rtx_SET (VOIDmode, operands[0],
+                                         gen_rtx_PLUS (V2SFmode, operands[1], operands[2]));
+      XVECEXP (par, 0, 1) = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, SPEFSCR_REGNO));
+      emit_insn (par);
+      DONE;
+    }
+}")
+
+(define_expand "subv2sf3"
+  [(set (match_operand:V2SF 0 "gpc_reg_operand" "")
+	(minus:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "")
+		    (match_operand:V2SF 2 "gpc_reg_operand" "")))]
+  "TARGET_PAIRED_FLOAT || TARGET_SPE"
+  "
+{
+  if (TARGET_SPE)
+    {
+      /* We need to make a note that we clobber SPEFSCR.  */
+      rtx par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
+
+      XVECEXP (par, 0, 0) = gen_rtx_SET (VOIDmode, operands[0],
+                                         gen_rtx_MINUS (V2SFmode, operands[1], operands[2]));
+      XVECEXP (par, 0, 1) = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, SPEFSCR_REGNO));
+      emit_insn (par);
+      DONE;
+    }
+}")
+
+(define_expand "mulv2sf3"
+  [(set (match_operand:V2SF 0 "gpc_reg_operand" "")
+	(mult:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "")
+		   (match_operand:V2SF 2 "gpc_reg_operand" "")))]
+  "TARGET_PAIRED_FLOAT || TARGET_SPE"
+  "
+{
+  if (TARGET_SPE)
+    {
+      /* We need to make a note that we clobber SPEFSCR.  */
+      rtx par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
+
+      XVECEXP (par, 0, 0) = gen_rtx_SET (VOIDmode, operands[0],
+                                         gen_rtx_MULT (V2SFmode, operands[1], operands[2]));
+      XVECEXP (par, 0, 1) = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, SPEFSCR_REGNO));
+      emit_insn (par);
+      DONE;
+    }
+}")
+
+(define_expand "divv2sf3"
+  [(set (match_operand:V2SF 0 "gpc_reg_operand" "")
+	(div:V2SF (match_operand:V2SF 1 "gpc_reg_operand" "")
+		  (match_operand:V2SF 2 "gpc_reg_operand" "")))]
+  "TARGET_PAIRED_FLOAT || TARGET_SPE"
+  "
+{
+  if (TARGET_SPE)
+    {
+      /* We need to make a note that we clobber SPEFSCR.  */
+      rtx par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
+
+      XVECEXP (par, 0, 0) = gen_rtx_SET (VOIDmode, operands[0],
+                                         gen_rtx_DIV (V2SFmode, operands[1], operands[2]));
+      XVECEXP (par, 0, 1) = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, SPEFSCR_REGNO));
+      emit_insn (par);
+      DONE;
+    }
+}")
+
 
 (include "sync.md")
 (include "altivec.md")
diff -Nur a/gcc/config/rs6000/spe.md b/gcc/config/rs6000/spe.md
--- a/gcc/config/rs6000/spe.md	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/rs6000/spe.md	2010-01-25 09:50:29.045688403 +0100
@@ -164,7 +164,7 @@
 
 ;; SPE SIMD instructions
 
-(define_insn "spe_evabs"
+(define_insn "absv2si2"
   [(set (match_operand:V2SI 0 "gpc_reg_operand" "=r")
 	(abs:V2SI (match_operand:V2SI 1 "gpc_reg_operand" "r")))]
   "TARGET_SPE"
@@ -181,7 +181,7 @@
   [(set_attr "type" "vecsimple")
    (set_attr  "length" "4")])
 
-(define_insn "spe_evand"
+(define_insn "andv2si3"
   [(set (match_operand:V2SI 0 "gpc_reg_operand" "=r")
         (and:V2SI (match_operand:V2SI 1 "gpc_reg_operand" "r")
 		  (match_operand:V2SI 2 "gpc_reg_operand" "r")))]
@@ -1898,7 +1898,7 @@
   [(set_attr "type" "veccomplex")
    (set_attr  "length" "4")])
 
-(define_insn "spe_evaddw"
+(define_insn "addv2si3"
   [(set (match_operand:V2SI 0 "gpc_reg_operand" "=r")
         (plus:V2SI (match_operand:V2SI 1 "gpc_reg_operand" "r")
 		   (match_operand:V2SI 2 "gpc_reg_operand" "r")))]
@@ -2028,7 +2028,7 @@
   [(set_attr "type" "veccomplex")
    (set_attr  "length" "4")])
 
-(define_insn "spe_evdivws"
+(define_insn "divv2si3"
   [(set (match_operand:V2SI 0 "gpc_reg_operand" "=r")
         (div:V2SI (match_operand:V2SI 1 "gpc_reg_operand" "r")
 		  (match_operand:V2SI 2 "gpc_reg_operand" "r")))
@@ -3156,9 +3156,9 @@
   [(match_parallel 0 "any_parallel_operand"
 		   [(clobber (reg:P 65))
 		    (use (match_operand:P 1 "symbol_ref_operand" "s"))
-		    (use (match_operand:P 2 "gpc_reg_operand" "r"))
-		    (set (match_operand:V2SI 3 "memory_operand" "=m")
-			 (match_operand:V2SI 4 "gpc_reg_operand" "r"))])]
+		    (use (reg:P 11))
+		    (set (match_operand:V2SI 2 "memory_operand" "=m")
+			 (match_operand:V2SI 3 "gpc_reg_operand" "r"))])]
   "TARGET_SPE_ABI"
   "bl %z1"
   [(set_attr "type" "branch")
@@ -3168,9 +3168,9 @@
  [(match_parallel 0 "any_parallel_operand"
 		  [(clobber (reg:P 65))
 		   (use (match_operand:P 1 "symbol_ref_operand" "s"))
-		   (use (match_operand:P 2 "gpc_reg_operand" "r"))
-		   (set (match_operand:V2SI 3 "gpc_reg_operand" "=r")
-			(match_operand:V2SI 4 "memory_operand" "m"))])]
+		   (use (reg:P 11))
+		   (set (match_operand:V2SI 2 "gpc_reg_operand" "=r")
+			(match_operand:V2SI 3 "memory_operand" "m"))])]
  "TARGET_SPE_ABI"
  "bl %z1"
  [(set_attr "type" "branch")
@@ -3181,9 +3181,9 @@
 		  [(return)
 		   (clobber (reg:P 65))
 		   (use (match_operand:P 1 "symbol_ref_operand" "s"))
-		   (use (match_operand:P 2 "gpc_reg_operand" "r"))
-		   (set (match_operand:V2SI 3 "gpc_reg_operand" "=r")
-			(match_operand:V2SI 4 "memory_operand" "m"))])]
+		   (use (reg:P 11))
+		   (set (match_operand:V2SI 2 "gpc_reg_operand" "=r")
+			(match_operand:V2SI 3 "memory_operand" "m"))])]
  "TARGET_SPE_ABI"
  "b %z1"
  [(set_attr "type" "branch")
diff -Nur a/gcc/config/rs6000/sysv4.h b/gcc/config/rs6000/sysv4.h
--- a/gcc/config/rs6000/sysv4.h	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/rs6000/sysv4.h	2010-01-25 09:50:29.045688403 +0100
@@ -619,6 +619,9 @@
 #define CC1_SECURE_PLT_DEFAULT_SPEC ""
 #endif
 
+#undef CC1_EXTRA_SPEC
+#define CC1_EXTRA_SPEC ""
+
 /* Pass -G xxx to the compiler and set correct endian mode.  */
 #define	CC1_SPEC "%{G*} %(cc1_cpu) \
 %{mlittle|mlittle-endian: %(cc1_endian_little);           \
@@ -643,7 +646,7 @@
 %{msdata: -msdata=default} \
 %{mno-sdata: -msdata=none} \
 %{!mbss-plt: %{!msecure-plt: %(cc1_secure_plt_default)}} \
-%{profile: -p}"
+%{profile: -p}" CC1_EXTRA_SPEC
 
 /* Don't put -Y P,<path> for cross compilers.  */
 #ifndef CROSS_DIRECTORY_STRUCTURE
@@ -843,15 +846,15 @@
 #define CPP_OS_MVME_SPEC ""
 
 /* PowerPC simulator based on netbsd system calls support.  */
-#define LIB_SIM_SPEC "--start-group -lsim -lc --end-group"
+#define LIB_SIM_SPEC LIB_DEFAULT_SPEC
 
-#define	STARTFILE_SIM_SPEC "ecrti.o%s sim-crt0.o%s crtbegin.o%s"
+#define	STARTFILE_SIM_SPEC "ecrti.o%s crtbegin.o%s"
 
-#define	ENDFILE_SIM_SPEC "crtend.o%s ecrtn.o%s"
+#define	ENDFILE_SIM_SPEC "crtend.o%s ecrtn.o%s -Tsim-hosted.ld"
 
 #define LINK_START_SIM_SPEC ""
 
-#define LINK_OS_SIM_SPEC "-m elf32ppcsim"
+#define LINK_OS_SIM_SPEC ""
 
 #define CPP_OS_SIM_SPEC ""
 
diff -Nur a/gcc/config/rs6000/t-cs-eabi b/gcc/config/rs6000/t-cs-eabi
--- a/gcc/config/rs6000/t-cs-eabi	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/rs6000/t-cs-eabi	2010-01-25 09:50:29.045688403 +0100
@@ -0,0 +1,17 @@
+# Multilibs for powerpc embedded ELF targets.
+
+MULTILIB_OPTIONS	= te500v1/te500v2/te600/te500mc \
+			  msoft-float
+
+MULTILIB_DIRNAMES	= te500v1 te500v2 te600 te500mc \
+			  nof
+
+MULTILIB_EXCEPTIONS	= *te600*/*msoft-float* \
+			  *te500v1*/*msoft-float* \
+			  *te500v2*/*msoft-float* \
+			  *te500mc*/*msoft-float*
+
+MULTILIB_EXTRA_OPTS	= mno-eabi mstrict-align
+
+MULTILIB_MATCHES	= ${MULTILIB_MATCHES_FLOAT} \
+			  ${MULTILIB_MATCHES_ENDIAN}
diff -Nur a/gcc/config/rs6000/t-cs-eabi-lite b/gcc/config/rs6000/t-cs-eabi-lite
--- a/gcc/config/rs6000/t-cs-eabi-lite	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/rs6000/t-cs-eabi-lite	2010-01-25 09:50:29.045688403 +0100
@@ -0,0 +1,16 @@
+# Multilibs for powerpc embedded ELF targets.
+
+MULTILIB_OPTIONS	= te500v1/te500v2/te600 \
+			  msoft-float
+
+MULTILIB_DIRNAMES	= te500v1 te500v2 te600 \
+			  nof
+
+MULTILIB_EXCEPTIONS	= *te600*/*msoft-float* \
+			  *te500v1*/*msoft-float* \
+			  *te500v2*/*msoft-float*
+
+MULTILIB_EXTRA_OPTS	= mno-eabi mstrict-align
+
+MULTILIB_MATCHES	= ${MULTILIB_MATCHES_FLOAT} \
+			  ${MULTILIB_MATCHES_ENDIAN}
diff -Nur a/gcc/config/rs6000/t-cs-linux b/gcc/config/rs6000/t-cs-linux
--- a/gcc/config/rs6000/t-cs-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/rs6000/t-cs-linux	2010-01-25 09:50:29.045688403 +0100
@@ -0,0 +1,12 @@
+# Multilibs for powerpc-linux-gnu targets.
+
+MULTILIB_OPTIONS	= te500v1/te500v2/te600/te500mc \
+			  msoft-float
+
+MULTILIB_DIRNAMES	= te500v1 te500v2 te600 te500mc \
+			  nof
+
+MULTILIB_EXCEPTIONS	= *te600*/*msoft-float* \
+			  *te500v1*/*msoft-float* \
+			  *te500v2*/*msoft-float* \
+			  *te500mc*/*msoft-float*
diff -Nur a/gcc/config/rs6000/t-montavista-linux b/gcc/config/rs6000/t-montavista-linux
--- a/gcc/config/rs6000/t-montavista-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/rs6000/t-montavista-linux	2010-01-25 09:50:29.045688403 +0100
@@ -0,0 +1,26 @@
+# MontaVista GNU/Linux Configuration.
+# Copyright (C) 2009
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Build hard-float, soft-float, E500mc, E500v2 and E600
+# libraries.
+MULTILIB_OPTIONS = msoft-float/te500mc/te500v2/te600
+MULTILIB_DIRNAMES = soft-float te500mc te500v2 te600
+MULTILIB_EXCEPTIONS =
+MULTILIB_OSDIRNAMES = msoft-float=!soft-float
diff -Nur a/gcc/config/rs6000/t-ppccomm b/gcc/config/rs6000/t-ppccomm
--- a/gcc/config/rs6000/t-ppccomm	2008-06-26 22:12:41.000000000 +0200
+++ b/gcc/config/rs6000/t-ppccomm	2010-01-25 09:50:29.045688403 +0100
@@ -3,10 +3,23 @@
 LIB2FUNCS_EXTRA += tramp.S $(srcdir)/config/rs6000/darwin-ldouble.c
 
 # These can't end up in shared libgcc
-LIB2FUNCS_STATIC_EXTRA = eabi.S
-
-eabi.S: $(srcdir)/config/rs6000/eabi.asm
-	cat $(srcdir)/config/rs6000/eabi.asm > eabi.S
+LIB2FUNCS_STATIC_EXTRA = \
+  crtsavfpr.S crtresfpr.S \
+  crtsavgpr.S crtresgpr.S \
+  crtresxfpr.S crtresxgpr.S \
+  e500crtres32gpr.S \
+  e500crtres64gpr.S \
+  e500crtres64gprctr.S \
+  e500crtrest32gpr.S \
+  e500crtrest64gpr.S \
+  e500crtresx32gpr.S \
+  e500crtresx64gpr.S \
+  e500crtsav32gpr.S \
+  e500crtsav64gpr.S \
+  e500crtsav64gprctr.S \
+  e500crtsavg32gpr.S \
+  e500crtsavg64gpr.S \
+  e500crtsavg64gprctr.S
 
 tramp.S: $(srcdir)/config/rs6000/tramp.asm
 	cat $(srcdir)/config/rs6000/tramp.asm > tramp.S
@@ -36,6 +49,63 @@
 ncrtn.S: $(srcdir)/config/rs6000/sol-cn.asm
 	cat $(srcdir)/config/rs6000/sol-cn.asm >ncrtn.S
 
+crtsavfpr.S: $(srcdir)/config/rs6000/crtsavfpr.asm
+	cat $(srcdir)/config/rs6000/crtsavfpr.asm >crtsavfpr.S
+
+crtresfpr.S: $(srcdir)/config/rs6000/crtresfpr.asm
+	cat $(srcdir)/config/rs6000/crtresfpr.asm >crtresfpr.S
+
+crtsavgpr.S: $(srcdir)/config/rs6000/crtsavgpr.asm
+	cat $(srcdir)/config/rs6000/crtsavgpr.asm >crtsavgpr.S
+
+crtresgpr.S: $(srcdir)/config/rs6000/crtresgpr.asm
+	cat $(srcdir)/config/rs6000/crtresgpr.asm >crtresgpr.S
+
+crtresxfpr.S: $(srcdir)/config/rs6000/crtresxfpr.asm
+	cat $(srcdir)/config/rs6000/crtresxfpr.asm >crtresxfpr.S
+
+crtresxgpr.S: $(srcdir)/config/rs6000/crtresxgpr.asm
+	cat $(srcdir)/config/rs6000/crtresxgpr.asm >crtresxgpr.S
+
+e500crtres32gpr.S: $(srcdir)/config/rs6000/e500crtres32gpr.asm
+	cat $(srcdir)/config/rs6000/e500crtres32gpr.asm >e500crtres32gpr.S
+
+e500crtres64gpr.S: $(srcdir)/config/rs6000/e500crtres64gpr.asm
+	cat $(srcdir)/config/rs6000/e500crtres64gpr.asm >e500crtres64gpr.S
+
+e500crtres64gprctr.S: $(srcdir)/config/rs6000/e500crtres64gprctr.asm
+	cat $(srcdir)/config/rs6000/e500crtres64gprctr.asm >e500crtres64gprctr.S
+
+e500crtrest32gpr.S: $(srcdir)/config/rs6000/e500crtrest32gpr.asm
+	cat $(srcdir)/config/rs6000/e500crtrest32gpr.asm >e500crtrest32gpr.S
+
+e500crtrest64gpr.S: $(srcdir)/config/rs6000/e500crtrest64gpr.asm
+	cat $(srcdir)/config/rs6000/e500crtrest64gpr.asm >e500crtrest64gpr.S
+
+e500crtresx32gpr.S: $(srcdir)/config/rs6000/e500crtresx32gpr.asm
+	cat $(srcdir)/config/rs6000/e500crtresx32gpr.asm >e500crtresx32gpr.S
+
+e500crtresx64gpr.S: $(srcdir)/config/rs6000/e500crtresx64gpr.asm
+	cat $(srcdir)/config/rs6000/e500crtresx64gpr.asm >e500crtresx64gpr.S
+
+e500crtsav32gpr.S: $(srcdir)/config/rs6000/e500crtsav32gpr.asm
+	cat $(srcdir)/config/rs6000/e500crtsav32gpr.asm >e500crtsav32gpr.S
+
+e500crtsav64gpr.S: $(srcdir)/config/rs6000/e500crtsav64gpr.asm
+	cat $(srcdir)/config/rs6000/e500crtsav64gpr.asm >e500crtsav64gpr.S
+
+e500crtsav64gprctr.S: $(srcdir)/config/rs6000/e500crtsav64gprctr.asm
+	cat $(srcdir)/config/rs6000/e500crtsav64gprctr.asm >e500crtsav64gprctr.S
+
+e500crtsavg32gpr.S: $(srcdir)/config/rs6000/e500crtsavg32gpr.asm
+	cat $(srcdir)/config/rs6000/e500crtsavg32gpr.asm >e500crtsavg32gpr.S
+
+e500crtsavg64gpr.S: $(srcdir)/config/rs6000/e500crtsavg64gpr.asm
+	cat $(srcdir)/config/rs6000/e500crtsavg64gpr.asm >e500crtsavg64gpr.S
+
+e500crtsavg64gprctr.S: $(srcdir)/config/rs6000/e500crtsavg64gprctr.asm
+	cat $(srcdir)/config/rs6000/e500crtsavg64gprctr.asm >e500crtsavg64gprctr.S
+
 # Build multiple copies of ?crt{i,n}.o, one for each target switch.
 $(T)ecrti$(objext): ecrti.S
 	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c ecrti.S -o $(T)ecrti$(objext)
@@ -49,6 +119,63 @@
 $(T)ncrtn$(objext): ncrtn.S
 	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c ncrtn.S -o $(T)ncrtn$(objext)
 
+$(T)crtsavfpr$(objext): crtsavfpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtsavfpr.S -o $(T)crtsavfpr$(objext)
+
+$(T)crtresfpr$(objext): crtresfpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtresfpr.S -o $(T)crtresfpr$(objext)
+
+$(T)crtsavgpr$(objext): crtsavgpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtsavgpr.S -o $(T)crtsavgpr$(objext)
+
+$(T)crtresgpr$(objext): crtresgpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtresgpr.S -o $(T)crtresgpr$(objext)
+
+$(T)crtresxfpr$(objext): crtresxfpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtresxfpr.S -o $(T)crtresxfpr$(objext)
+
+$(T)crtresxgpr$(objext): crtresxgpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtresxgpr.S -o $(T)crtresxgpr$(objext)
+
+$(T)e500crtres32gpr$(objext): e500crtres32gpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtres32gpr.S -o $(T)e500crtres32gpr$(objext)
+
+$(T)e500crtres64gpr$(objext): e500crtres64gpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtres64gpr.S -o $(T)e500crtres64gpr$(objext)
+
+$(T)e500crtres64gprctr$(objext): e500crtres64gprctr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtres64gprctr.S -o $(T)e500crtres64gprctr$(objext)
+
+$(T)e500crtrest32gpr$(objext): e500crtrest32gpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtrest32gpr.S -o $(T)e500crtrest32gpr$(objext)
+
+$(T)e500crtrest64gpr$(objext): e500crtrest64gpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtrest64gpr.S -o $(T)e500crtrest64gpr$(objext)
+
+$(T)e500crtresx32gpr$(objext): e500crtresx32gpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtresx32gpr.S -o $(T)e500crtresx32gpr$(objext)
+
+$(T)e500crtresx64gpr$(objext): e500crtresx64gpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtresx64gpr.S -o $(T)e500crtresx64gpr$(objext)
+
+$(T)e500crtsav32gpr$(objext): e500crtsav32gpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsav32gpr.S -o $(T)e500crtsav32gpr$(objext)
+
+$(T)e500crtsav64gpr$(objext): e500crtsav64gpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsav64gpr.S -o $(T)e500crtsav64gpr$(objext)
+
+$(T)e500crtsav64gprctr$(objext): e500crtsav64gprctr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsav64gprctr.S -o $(T)e500crtsav64gprctr$(objext)
+
+$(T)e500crtsavg32gpr$(objext): e500crtsavg32gpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsavg32gpr.S -o $(T)e500crtsavg32gpr$(objext)
+
+$(T)e500crtsavg64gpr$(objext): e500crtsavg64gpr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsavg64gpr.S -o $(T)e500crtsavg64gpr$(objext)
+
+$(T)e500crtsavg64gprctr$(objext): e500crtsavg64gprctr.S
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsavg64gprctr.S -o $(T)e500crtsavg64gprctr$(objext)
+
 # It is important that crtbegin.o, etc., aren't surprised by stuff in .sdata.
 CRTSTUFF_T_CFLAGS = -msdata=none
 # Make sure crt*.o are built with -fPIC even if configured with 
diff -Nur a/gcc/config/rs6000/t-ppc-e500mc b/gcc/config/rs6000/t-ppc-e500mc
--- a/gcc/config/rs6000/t-ppc-e500mc	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/rs6000/t-ppc-e500mc	2010-01-25 09:50:29.045688403 +0100
@@ -0,0 +1,12 @@
+# Multilibs for powerpc embedded ELF targets.
+
+MULTILIB_OPTIONS	= 
+
+MULTILIB_DIRNAMES	= 
+
+MULTILIB_EXCEPTIONS	= 
+
+MULTILIB_EXTRA_OPTS	= mno-eabi mstrict-align
+
+MULTILIB_MATCHES	= ${MULTILIB_MATCHES_FLOAT} \
+			  ${MULTILIB_MATCHES_ENDIAN}
diff -Nur a/gcc/config/rs6000/t-wrs-linux b/gcc/config/rs6000/t-wrs-linux
--- a/gcc/config/rs6000/t-wrs-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/rs6000/t-wrs-linux	2010-01-25 09:50:29.045688403 +0100
@@ -0,0 +1,30 @@
+# Wind River GNU/Linux Configuration.
+# Copyright (C) 2006, 2007
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Build hard-float (32-bit and 64-bit), soft-float, E500v1 and E500v2
+# libraries.
+MULTILIB_OPTIONS = muclibc m64 msoft-float te500v1 te500v2
+MULTILIB_DIRNAMES = uclibc 64 soft-float te500v1 te500v2
+MULTILIB_EXCEPTIONS = *muclibc*/*m64* *muclibc*/*msoft-float*
+MULTILIB_EXCEPTIONS += *muclibc*/*te500v1* *muclibc*/*te500v2*
+MULTILIB_EXCEPTIONS += *m64*/*msoft-float* *m64*/*te500v1* *m64*/*te500v2*
+MULTILIB_EXCEPTIONS += *msoft-float*/*te500v1* *msoft-float*/*te500v2*
+MULTILIB_EXCEPTIONS += *te500v1*/*te500v2*
+MULTILIB_OSDIRNAMES = muclibc=!uclibc m64=../lib64 msoft-float=!soft-float
diff -Nur a/gcc/config/rs6000/wrs-linux.h b/gcc/config/rs6000/wrs-linux.h
--- a/gcc/config/rs6000/wrs-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/rs6000/wrs-linux.h	2010-01-25 09:50:29.045688403 +0100
@@ -0,0 +1,44 @@
+/* Wind River GNU/Linux Configuration.
+   Copyright (C) 2006, 2007
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Add -te500v1 and -te500v2 options for convenience in generating
+   multilibs.  */
+#undef CC1_EXTRA_SPEC
+#define CC1_EXTRA_SPEC "%{te500v1: -mcpu=8540 -mfloat-gprs=single -mspe=yes -mabi=spe} %{te500v2: -mcpu=8548 -mfloat-gprs=double -mspe=yes -mabi=spe}"
+
+#undef ASM_DEFAULT_SPEC
+#define ASM_DEFAULT_SPEC			\
+  "%{te500v1:-mppc -mspe -me500 ;		\
+     te500v2:-mppc -mspe -me500 ;		\
+     :-mppc%{m64:64}}"
+
+/* The GLIBC headers are in /usr/include, relative to the sysroot; the
+   uClibc headers are in /uclibc/usr/include.  */
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC		\
+  "%{muclibc:/uclibc}" 
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+  "%{muclibc:/uclibc ;				\
+     msoft-float:/soft-float ;			\
+     te500v1:/te500v1 ;				\
+     te500v2:/te500v2}"
diff -Nur a/gcc/config/sh/cs-sgxxlite-linux.h b/gcc/config/sh/cs-sgxxlite-linux.h
--- a/gcc/config/sh/cs-sgxxlite-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/sh/cs-sgxxlite-linux.h	2010-01-25 09:50:29.045688403 +0100
@@ -0,0 +1,31 @@
+/* SH SourceryG++ GNU/Linux Configuration.
+   Copyright (C) 2008
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC \
+  "%{muclibc:/uclibc}"
+
+#undef SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+do {									\
+  /* __thread_support is not supported by uClibc.  */			\
+  if (linux_uclibc)						\
+    targetm.have_tls = 0;						\
+} while (0)
diff -Nur a/gcc/config/sh/cs-sgxxlite-linux.opt b/gcc/config/sh/cs-sgxxlite-linux.opt
--- a/gcc/config/sh/cs-sgxxlite-linux.opt	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/sh/cs-sgxxlite-linux.opt	2010-01-25 09:50:29.045688403 +0100
@@ -0,0 +1,23 @@
+; Options for SH SourceryG++ GNU/Linux
+
+; Copyright (C) 2009 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+muclibc
+Target RejectNegative Var(building_for_uclibc)
+Building with -muclibc
diff -Nur a/gcc/config/sh/lib1funcs.asm b/gcc/config/sh/lib1funcs.asm
--- a/gcc/config/sh/lib1funcs.asm	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/sh/lib1funcs.asm	2010-01-25 09:50:29.045688403 +0100
@@ -2080,8 +2080,9 @@
 GLOBAL(ic_invalidate):
 	ocbwb	@r4
 	synco
-	rts
 	icbi	@r4
+	rts
+	  nop
 	ENDFUNC(GLOBAL(ic_invalidate))
 #elif defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) || (defined(__SH4_NOFPU__) && !defined(__SH5__))
 	/* For system code, we use ic_invalidate_line_i, but user code
@@ -2147,8 +2148,10 @@
 GLOBAL(ic_invalidate_array):
 	add	r1,r4
 	synco
-	rts
 	icbi	@r4
+	rts
+	  nop
+	.align 2
 	.long	0
 	ENDFUNC(GLOBAL(ic_invalidate_array))
 #elif defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) || (defined(__SH4_NOFPU__) && !defined(__SH5__))
diff -Nur a/gcc/config/sh/linux-unwind.h b/gcc/config/sh/linux-unwind.h
--- a/gcc/config/sh/linux-unwind.h	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/config/sh/linux-unwind.h	2010-01-25 09:50:29.045688403 +0100
@@ -24,7 +24,10 @@
 
 
 /* Do code reading to identify a signal frame, and set the frame
-   state data appropriately.  See unwind-dw2.c for the structs.  */
+   state data appropriately.  See unwind-dw2.c for the structs.
+   Don't use this at all if inhibit_libc is used.  */
+
+#ifndef inhibit_libc
 
 #include <signal.h>
 #include <sys/ucontext.h>
@@ -248,3 +251,5 @@
   return _URC_NO_REASON;
 }
 #endif /* defined (__SH5__) */
+
+#endif /* inhibit_libc */
diff -Nur a/gcc/config/sh/sh.h b/gcc/config/sh/sh.h
--- a/gcc/config/sh/sh.h	2008-11-14 12:46:55.000000000 +0100
+++ b/gcc/config/sh/sh.h	2010-01-25 09:50:29.045688403 +0100
@@ -712,8 +712,9 @@
       /* Never run scheduling before reload, since that can		\
 	 break global alloc, and generates slower code anyway due	\
 	 to the pressure on R0.  */					\
-      /* Enable sched1 for SH4; ready queue will be reordered by	\
-	 the target hooks when pressure is high. We can not do this for \
+      /* Enable sched1 for SH4 if the user explicitly requests.		\
+	 When sched1 is enabled, the ready queue will be reordered by	\
+	 the target hooks if pressure is high.  We can not do this for	\
 	 PIC, SH3 and lower as they give spill failures for R0.  */	\
       if (!TARGET_HARD_SH4 || flag_pic)					\
         flag_schedule_insns = 0;		 			\
@@ -728,6 +729,8 @@
 	    warning (0, "ignoring -fschedule-insns because of exception handling bug");	\
 	  flag_schedule_insns = 0;		 			\
 	}								\
+      else if (flag_schedule_insns == 2)				\
+	flag_schedule_insns = 0;		 			\
     }									\
 									\
   if (align_loops == 0)							\
diff -Nur a/gcc/config/sh/t-1e b/gcc/config/sh/t-1e
--- a/gcc/config/sh/t-1e	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-1e	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-MULTILIB_ENDIAN =
diff -Nur a/gcc/config/sh/t-linux b/gcc/config/sh/t-linux
--- a/gcc/config/sh/t-linux	2007-01-09 11:50:23.000000000 +0100
+++ b/gcc/config/sh/t-linux	2010-01-25 09:50:29.075687537 +0100
@@ -4,6 +4,5 @@
 
 MULTILIB_DIRNAMES= 
 MULTILIB_MATCHES = 
-MULTILIB_EXCEPTIONS=
 
 EXTRA_MULTILIB_PARTS= crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
diff -Nur a/gcc/config/sh/t-mlib-sh1 b/gcc/config/sh/t-mlib-sh1
--- a/gcc/config/sh/t-mlib-sh1	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh1	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh1=m1/
diff -Nur a/gcc/config/sh/t-mlib-sh2 b/gcc/config/sh/t-mlib-sh2
--- a/gcc/config/sh/t-mlib-sh2	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh2	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh2=m2/
diff -Nur a/gcc/config/sh/t-mlib-sh2a b/gcc/config/sh/t-mlib-sh2a
--- a/gcc/config/sh/t-mlib-sh2a	2004-07-29 08:10:03.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh2a	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh2a=m2a/
diff -Nur a/gcc/config/sh/t-mlib-sh2a-nofpu b/gcc/config/sh/t-mlib-sh2a-nofpu
--- a/gcc/config/sh/t-mlib-sh2a-nofpu	2004-07-29 08:10:03.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh2a-nofpu	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh2a_nofpu=m2a-nofpu/
diff -Nur a/gcc/config/sh/t-mlib-sh2a-single b/gcc/config/sh/t-mlib-sh2a-single
--- a/gcc/config/sh/t-mlib-sh2a-single	2004-07-29 08:10:03.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh2a-single	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh2a_single=m2a-single/
diff -Nur a/gcc/config/sh/t-mlib-sh2a-single-only b/gcc/config/sh/t-mlib-sh2a-single-only
--- a/gcc/config/sh/t-mlib-sh2a-single-only	2004-07-29 08:10:03.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh2a-single-only	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh2a_single_only=m2a-single-only/
diff -Nur a/gcc/config/sh/t-mlib-sh2e b/gcc/config/sh/t-mlib-sh2e
--- a/gcc/config/sh/t-mlib-sh2e	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh2e	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh2e=m2e/
diff -Nur a/gcc/config/sh/t-mlib-sh3 b/gcc/config/sh/t-mlib-sh3
--- a/gcc/config/sh/t-mlib-sh3	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh3	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh3=m3/
diff -Nur a/gcc/config/sh/t-mlib-sh3e b/gcc/config/sh/t-mlib-sh3e
--- a/gcc/config/sh/t-mlib-sh3e	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh3e	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh3e=m3e/
diff -Nur a/gcc/config/sh/t-mlib-sh4 b/gcc/config/sh/t-mlib-sh4
--- a/gcc/config/sh/t-mlib-sh4	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh4	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh4=m4/
diff -Nur a/gcc/config/sh/t-mlib-sh4a b/gcc/config/sh/t-mlib-sh4a
--- a/gcc/config/sh/t-mlib-sh4a	2004-07-28 11:13:58.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh4a	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh4a=m4a/
diff -Nur a/gcc/config/sh/t-mlib-sh4al b/gcc/config/sh/t-mlib-sh4al
--- a/gcc/config/sh/t-mlib-sh4al	2004-07-28 11:13:58.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh4al	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh4al=m4al/
diff -Nur a/gcc/config/sh/t-mlib-sh4a-nofpu b/gcc/config/sh/t-mlib-sh4a-nofpu
--- a/gcc/config/sh/t-mlib-sh4a-nofpu	2004-07-28 11:13:58.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh4a-nofpu	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh4a_nofpu=m4a-nofpu/
diff -Nur a/gcc/config/sh/t-mlib-sh4a-single b/gcc/config/sh/t-mlib-sh4a-single
--- a/gcc/config/sh/t-mlib-sh4a-single	2004-07-28 11:13:58.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh4a-single	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh4a_single=m4a-single/
diff -Nur a/gcc/config/sh/t-mlib-sh4a-single-only b/gcc/config/sh/t-mlib-sh4a-single-only
--- a/gcc/config/sh/t-mlib-sh4a-single-only	2004-07-28 11:13:58.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh4a-single-only	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh4a_single_only=m4a-single-only/
diff -Nur a/gcc/config/sh/t-mlib-sh4-nofpu b/gcc/config/sh/t-mlib-sh4-nofpu
--- a/gcc/config/sh/t-mlib-sh4-nofpu	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh4-nofpu	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh4_nofpu=m4-nofpu/
diff -Nur a/gcc/config/sh/t-mlib-sh4-single b/gcc/config/sh/t-mlib-sh4-single
--- a/gcc/config/sh/t-mlib-sh4-single	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh4-single	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh4_single=m4-single/
diff -Nur a/gcc/config/sh/t-mlib-sh4-single-only b/gcc/config/sh/t-mlib-sh4-single-only
--- a/gcc/config/sh/t-mlib-sh4-single-only	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh4-single-only	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh4_single_only=m4-single-only/
diff -Nur a/gcc/config/sh/t-mlib-sh5-32media b/gcc/config/sh/t-mlib-sh5-32media
--- a/gcc/config/sh/t-mlib-sh5-32media	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh5-32media	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh5_32media=m5-32media/
diff -Nur a/gcc/config/sh/t-mlib-sh5-32media-nofpu b/gcc/config/sh/t-mlib-sh5-32media-nofpu
--- a/gcc/config/sh/t-mlib-sh5-32media-nofpu	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh5-32media-nofpu	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh5_32media_nofpu=m5-32media-nofpu/
diff -Nur a/gcc/config/sh/t-mlib-sh5-64media b/gcc/config/sh/t-mlib-sh5-64media
--- a/gcc/config/sh/t-mlib-sh5-64media	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh5-64media	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh5_64media=m5-64media/
diff -Nur a/gcc/config/sh/t-mlib-sh5-64media-nofpu b/gcc/config/sh/t-mlib-sh5-64media-nofpu
--- a/gcc/config/sh/t-mlib-sh5-64media-nofpu	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh5-64media-nofpu	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh5_64media_nofpu=m5-64media-nofpu/
diff -Nur a/gcc/config/sh/t-mlib-sh5-compact b/gcc/config/sh/t-mlib-sh5-compact
--- a/gcc/config/sh/t-mlib-sh5-compact	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh5-compact	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh5_compact=m5-compact/
diff -Nur a/gcc/config/sh/t-mlib-sh5-compact-nofpu b/gcc/config/sh/t-mlib-sh5-compact-nofpu
--- a/gcc/config/sh/t-mlib-sh5-compact-nofpu	2004-06-21 20:18:40.000000000 +0200
+++ b/gcc/config/sh/t-mlib-sh5-compact-nofpu	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-ML_sh5_compact_nofpu=m5-compact-nofpu/
diff -Nur a/gcc/config/sh/t-sgxxlite-linux b/gcc/config/sh/t-sgxxlite-linux
--- a/gcc/config/sh/t-sgxxlite-linux	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/sh/t-sgxxlite-linux	2010-01-25 09:50:29.075687537 +0100
@@ -0,0 +1,3 @@
+MULTILIB_OPTIONS += muclibc
+MULTILIB_OSDIRNAMES += muclibc=!uclibc m4al/muclibc=!m4al/uclibc mb/muclibc=!mb/uclibc
+MULTILIB_EXCEPTIONS += mb/m4al/muclibc
diff -Nur a/gcc/config/sh/t-sh b/gcc/config/sh/t-sh
--- a/gcc/config/sh/t-sh	2008-10-25 00:10:52.000000000 +0200
+++ b/gcc/config/sh/t-sh	2010-01-25 09:50:29.075687537 +0100
@@ -27,10 +27,10 @@
 	echo '#endif' 		>> fp-bit.c
 	cat $(srcdir)/config/fp-bit.c >> fp-bit.c
 
-MULTILIB_ENDIAN = ml/mb
-MULTILIB_CPUS= $(ML_sh1)$(ML_sh2a)$(ML_sh2a_nofpu)$(ML_sh2a_single_only)$(ML_sh2a_single)$(ML_sh2e)$(ML_sh2)$(ML_sh3e)$(ML_sh3)$(ML_sh4_nofpu)$(ML_sh4_single_only)$(ML_sh4_single)$(ML_sh4)$(ML_sh4a_nofpu)$(ML_sh4a_single_only)$(ML_sh4a_single)$(ML_sh4a)$(ML_sh5_32media)$(ML_sh5_32media_nofpu)$(ML_sh5_compact)$(ML_sh5_compact_nofpu)$(ML_sh5_64media)$(ML_sh5_64media_nofpu)
+DEFAULT_ENDIAN = $(word 1,$(TM_ENDIAN_CONFIG))
+OTHER_ENDIAN = $(word 2,$(TM_ENDIAN_CONFIG))
 
-MULTILIB_OPTIONS= $(MULTILIB_ENDIAN) $(MULTILIB_CPUS:/=)
+MULTILIB_OPTIONS= $(OTHER_ENDIAN) $(TM_MULTILIB_CONFIG)
 MULTILIB_DIRNAMES= 
 
 # The separate entries for m2a-nofpu and m2a-single-only with
@@ -58,7 +58,34 @@
   done)
 
 # SH1 only supports big endian.
-MULTILIB_EXCEPTIONS = ml/m1 ml/m2a*
+MULTILIB_EXCEPTIONS = ml/m1 ml/m2a* $(TM_MULTILIB_EXCEPTIONS_CONFIG)
+
+MULTILIB_OSDIRNAMES = \
+	$(OTHER_ENDIAN)=!$(OTHER_ENDIAN) \
+	m1=!m1 $(OTHER_ENDIAN)/m1=!$(OTHER_ENDIAN)/m1 \
+	m2a=!m2a $(OTHER_ENDIAN)/m2a=!$(OTHER_ENDIAN)/m2a \
+	m2a-nofpu=!m2a-nofpu $(OTHER_ENDIAN)/m2a-nofpu=!$(OTHER_ENDIAN)/m2a-nofpu \
+	m2a-single-only=!m2a-single-only $(OTHER_ENDIAN)/m2a-single-only=!$(OTHER_ENDIAN)/m2a-single-only \
+	m2a-single=!m2a-single $(OTHER_ENDIAN)/m2a-single=!$(OTHER_ENDIAN)/m2a-single \
+	m2e=!m2e $(OTHER_ENDIAN)/m2e=!$(OTHER_ENDIAN)/m2e \
+	m2=!m2 $(OTHER_ENDIAN)/m2=!$(OTHER_ENDIAN)/m2 \
+	m3e=!m3e $(OTHER_ENDIAN)/m3e=!$(OTHER_ENDIAN)/m3e \
+	m3=!m3 $(OTHER_ENDIAN)/m3=!$(OTHER_ENDIAN)/m3 \
+	m4-nofpu=!m4-nofpu $(OTHER_ENDIAN)/m4-nofpu=!$(OTHER_ENDIAN)/m4-nofpu \
+	m4-single-only=!m4-single-only $(OTHER_ENDIAN)/m4-single-only=!$(OTHER_ENDIAN)/m4-single-only \
+	m4-single=!m4-single $(OTHER_ENDIAN)/m4-single=!$(OTHER_ENDIAN)/m4-single \
+	m4=!m4 $(OTHER_ENDIAN)/m4=!$(OTHER_ENDIAN)/m4 \
+	m4a-nofpu=!m4a-nofpu $(OTHER_ENDIAN)/m4a-nofpu=!$(OTHER_ENDIAN)/m4a-nofpu \
+	m4a-single-only=!m4a-single-only $(OTHER_ENDIAN)/m4a-single-only=!$(OTHER_ENDIAN)/m4a-single-only \
+	m4a-single=!m4a-single $(OTHER_ENDIAN)/m4a-single=!$(OTHER_ENDIAN)/m4a-single \
+	m4a=!m4a $(OTHER_ENDIAN)/m4a=!$(OTHER_ENDIAN)/m4a \
+	m4al=!m4al $(OTHER_ENDIAN)/m4al=!$(OTHER_ENDIAN)/m4al \
+	m5-32media=!m5-32media $(OTHER_ENDIAN)/m5-32media=!$(OTHER_ENDIAN)/m5-32media \
+	m5-32media-nofpu=!m5-32media-nofpu $(OTHER_ENDIAN)/m5-32media-nofpu=!$(OTHER_ENDIAN)/m5-32media-nofpu \
+	m5-compact=!m5-compact $(OTHER_ENDIAN)/m5-compact=!$(OTHER_ENDIAN)/m5-compact \
+	m5-compact-nofpu=!m5-compact-nofpu $(OTHER_ENDIAN)/m5-compact-nofpu=!$(OTHER_ENDIAN)/m5-compact-nofpu \
+	m5-64media=!m5-64media $(OTHER_ENDIAN)/m5-64media=!$(OTHER_ENDIAN)/m5-64media \
+	m5-64media-nofpu=!m5-64media-nofpu $(OTHER_ENDIAN)/m5-64media-nofpu=!$(OTHER_ENDIAN)/m5-64media-nofpu
 
 LIBGCC = stmp-multilib
 INSTALL_LIBGCC = install-multilib
diff -Nur a/gcc/config/sol2.h b/gcc/config/sol2.h
--- a/gcc/config/sol2.h	2008-09-09 18:17:37.000000000 +0200
+++ b/gcc/config/sol2.h	2010-01-25 09:50:29.075687537 +0100
@@ -123,12 +123,12 @@
    %{YP,*} \
    %{R*} \
    %{compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,/usr/ucblib:/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \
-             %{!p:%{!pg:-Y P,/usr/ucblib:/usr/ccs/lib:/usr/lib}}} \
-             -R /usr/ucblib} \
+     %{!YP,*:%{p|pg:-Y P,%R/usr/ucblib:%R/usr/ccs/lib/libp:%R/usr/lib/libp:%R/usr/ccs/lib:%R/usr/lib} \
+             %{!p:%{!pg:-Y P,%R/usr/ucblib:%R/usr/ccs/lib:%R/usr/lib}}} \
+             -R %R/usr/ucblib} \
    %{!compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \
-             %{!p:%{!pg:-Y P,/usr/ccs/lib:/usr/lib}}}}"
+     %{!YP,*:%{p|pg:-Y P,%R/usr/ccs/lib/libp:%R/usr/lib/libp:%R/usr/ccs/lib:%R/usr/lib} \
+             %{!p:%{!pg:-Y P,%R/usr/ccs/lib:%R/usr/lib}}}}"
 
 #undef LINK_ARCH32_SPEC
 #define LINK_ARCH32_SPEC LINK_ARCH32_SPEC_BASE
diff -Nur a/gcc/config/sparc/linux64.h b/gcc/config/sparc/linux64.h
--- a/gcc/config/sparc/linux64.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/sparc/linux64.h	2010-01-25 09:50:29.075687537 +0100
@@ -40,10 +40,15 @@
    in a Medium/Low code model environment.  */
 
 #undef TARGET_DEFAULT
+#ifdef BIARCH_32BIT_DEFAULT
+#define TARGET_DEFAULT \
+  (MASK_APP_REGS + MASK_FPU)
+#else
 #define TARGET_DEFAULT \
   (MASK_V9 + MASK_PTR64 + MASK_64BIT /* + MASK_HARD_QUAD */ \
    + MASK_STACK_BIAS + MASK_APP_REGS + MASK_FPU + MASK_LONG_DOUBLE_128)
 #endif
+#endif
 
 /* This must be v9a not just v9 because by default we enable
    -mvis.  */
diff -Nur a/gcc/config/sparc/sol2-bi.h b/gcc/config/sparc/sol2-bi.h
--- a/gcc/config/sparc/sol2-bi.h	2007-10-19 06:29:38.000000000 +0200
+++ b/gcc/config/sparc/sol2-bi.h	2010-01-25 09:50:29.075687537 +0100
@@ -172,12 +172,12 @@
    %{YP,*} \
    %{R*} \
    %{compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,/usr/ucblib/sparcv9:/usr/lib/libp/sparcv9:/usr/lib/sparcv9} \
-       %{!p:%{!pg:-Y P,/usr/ucblib/sparcv9:/usr/lib/sparcv9}}} \
-     -R /usr/ucblib/sparcv9} \
+     %{!YP,*:%{p|pg:-Y P,%R/usr/ucblib/sparcv9:%R/usr/lib/libp/sparcv9:%R/usr/lib/sparcv9} \
+       %{!p:%{!pg:-Y P,%R/usr/ucblib/sparcv9:%R/usr/lib/sparcv9}}} \
+     -R %R/usr/ucblib/sparcv9} \
    %{!compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,/usr/lib/libp/sparcv9:/usr/lib/sparcv9} \
-       %{!p:%{!pg:-Y P,/usr/lib/sparcv9}}}}"
+     %{!YP,*:%{p|pg:-Y P,%R/usr/lib/libp/sparcv9:%R/usr/lib/sparcv9} \
+       %{!p:%{!pg:-Y P,%R/usr/lib/sparcv9}}}}"
 
 #define LINK_ARCH64_SPEC LINK_ARCH64_SPEC_BASE
 
diff -Nur a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
--- a/gcc/config/sparc/sparc.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/sparc/sparc.c	2010-01-25 09:50:29.075687537 +0100
@@ -6120,7 +6120,7 @@
 sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)
 {
   const char *qpfunc;
-  rtx slot0, slot1, result, tem, tem2;
+  rtx slot0, slot1, result, tem, tem2, libfunc;
   enum machine_mode mode;
   enum rtx_code new_comparison;
 
@@ -6183,7 +6183,8 @@
 	  emit_move_insn (slot1, y);
 	}
 
-      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, qpfunc), LCT_NORMAL,
+      libfunc = gen_rtx_SYMBOL_REF (Pmode, qpfunc);
+      emit_library_call (libfunc, LCT_NORMAL,
 			 DImode, 2,
 			 XEXP (slot0, 0), Pmode,
 			 XEXP (slot1, 0), Pmode);
@@ -6191,7 +6192,8 @@
     }
   else
     {
-      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, qpfunc), LCT_NORMAL,
+      libfunc = gen_rtx_SYMBOL_REF (Pmode, qpfunc);
+      emit_library_call (libfunc, LCT_NORMAL,
 			 SImode, 2,
 			 x, TFmode, y, TFmode);
       mode = SImode;
@@ -6202,7 +6204,7 @@
      register so reload doesn't clobber the value if it needs
      the return register for a spill reg.  */
   result = gen_reg_rtx (mode);
-  emit_move_insn (result, hard_libcall_value (mode));
+  emit_move_insn (result, hard_libcall_value (mode, libfunc));
 
   switch (comparison)
     {
diff -Nur a/gcc/config/spu/spu.h b/gcc/config/spu/spu.h
--- a/gcc/config/spu/spu.h	2009-04-24 00:50:16.000000000 +0200
+++ b/gcc/config/spu/spu.h	2010-01-25 09:50:29.085687411 +0100
@@ -270,7 +270,8 @@
 
 #define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (LINK_REGISTER_REGNUM)
 
-#define ARG_POINTER_CFA_OFFSET(FNDECL) (-STACK_POINTER_OFFSET)
+#define ARG_POINTER_CFA_OFFSET(FNDECL) \
+  (crtl->args.pretend_args_size - STACK_POINTER_OFFSET)
 
 
 /* Stack Checking */
diff -Nur a/gcc/config/t-eglibc b/gcc/config/t-eglibc
--- a/gcc/config/t-eglibc	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/t-eglibc	2010-01-25 09:50:29.085687411 +0100
@@ -0,0 +1,25 @@
+# multilibs  -*- mode:Makefile -*-
+
+MULTILIB_EXCEPTIONS :=
+MULTILIB_MATCHES    :=
+MULTILIB_ALIASES    :=
+
+# For all items in EGLIBC_CONFIGS except for the last one
+# do $1.  For the last one do $2.  The items are separated with ",".
+EGLIBC_AWK = $(shell echo $(EGLIBC_CONFIGS) | $(AWK) \
+	'{ \
+	N=split ($$0, configs, ","); \
+	for (i = 1; i < N; ++i) $1; \
+	$2; \
+	}')
+
+MULTILIB_OPTIONS    := $(call EGLIBC_AWK, \
+	printf ("feglibc=%s/", configs[i]), \
+	printf ("feglibc=%s\n", configs[i]))
+MULTILIB_DIRNAMES   := $(call EGLIBC_AWK, \
+	printf ("%s ", configs[i]), \
+	printf ("%s\n", configs[i]))
+MULTILIB_OSDIRNAMES := $(call EGLIBC_AWK, \
+	printf ("feglibc.%s=!%s ", configs[i], configs[i]), \
+	printf ("feglibc.%s=!%s\n", configs[i], configs[i]))
+
diff -Nur a/gcc/config/t-sysroot-suffix b/gcc/config/t-sysroot-suffix
--- a/gcc/config/t-sysroot-suffix	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/config/t-sysroot-suffix	2010-01-25 09:50:29.085687411 +0100
@@ -0,0 +1,7 @@
+# Generate SYSROOT_SUFFIX_SPEC from MULTILIB_OSDIRNAMES
+
+sysroot-suffix.h: $(srcdir)/config/print-sysroot-suffix.sh
+	$(SHELL) $(srcdir)/config/print-sysroot-suffix.sh \
+	  "$(MULTILIB_OSDIRNAMES)" "$(MULTILIB_OPTIONS)" \
+	  "$(MULTILIB_MATCHES)" "$(MULTILIB_ALIASES)" > tmp-sysroot-suffix.h
+	mv tmp-sysroot-suffix.h $@
diff -Nur a/gcc/config/vx-common.h b/gcc/config/vx-common.h
--- a/gcc/config/vx-common.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/config/vx-common.h	2010-01-25 09:50:29.085687411 +0100
@@ -92,3 +92,6 @@
 /* We occasionally need to distinguish between the VxWorks variants.  */
 #define VXWORKS_KIND_NORMAL  1
 #define VXWORKS_KIND_AE      2
+
+/* Enable get_feature license checking.  */
+#define TARGET_FLEXLM
diff -Nur a/gcc/config.gcc b/gcc/config.gcc
--- a/gcc/config.gcc	2009-04-17 13:58:41.000000000 +0200
+++ b/gcc/config.gcc	2010-01-25 09:50:29.085687411 +0100
@@ -721,6 +721,28 @@
 	    need_64bit_hwint=yes
 	    # The EABI requires the use of __cxa_atexit.
 	    default_use_cxa_atexit=yes
+	    case ${target} in
+	    arm-wrs-linux-gnueabi) 
+		tm_file="$tm_file arm/wrs-linux.h"
+		tmake_file="$tmake_file arm/t-wrs-linux"
+		tm_defines="$tm_defines TARGET_FLEXLM"
+		;;
+	    arm-montavista*-linux-gnueabi)
+		tm_file="$tm_file arm/montavista-linux.h"
+		tmake_file="$tmake_file arm/t-montavista-linux"
+		;;
+	    *)
+		if test x$enable_extra_asa_multilibs = xyes; then
+			tmake_file="${tmake_file} arm/t-asa"
+		elif test x$enable_extra_sgxx_multilibs = xyes; then
+			tmake_file="${tmake_file} arm/t-cs-linux"
+		elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+			tmake_file="${tmake_file} arm/t-cs-linux-lite"
+		fi
+		tm_file="$tm_file ./sysroot-suffix.h"
+		tmake_file="$tmake_file t-sysroot-suffix"
+		;;
+	    esac
 	    ;;
 	*)
 	    tmake_file="$tmake_file arm/t-linux"
@@ -742,6 +764,13 @@
 	    need_64bit_hwint=yes
 	    # The EABI requires the use of __cxa_atexit.
 	    default_use_cxa_atexit=yes
+	    if test x$enable_extra_sgxx_multilibs = xyes; then
+		    tmake_file="${tmake_file} arm/t-cs-uclinux-eabi"
+	    elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+		    tmake_file="${tmake_file} arm/t-cs-uclinux-eabi"
+	    fi
+	    tm_file="$tm_file ./sysroot-suffix.h"
+	    tmake_file="$tmake_file t-sysroot-suffix"
 	esac
 	tm_file="$tm_file arm/aout.h arm/arm.h"
 	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
@@ -762,8 +791,14 @@
 	case ${target} in
 	arm*-*-eabi*)
 	  tm_file="$tm_file arm/eabi.h"
+	  tm_file="${tm_file} arm/nocrt0.h"
 	  tmake_file="${tmake_file} arm/t-bpabi"
 	  extra_options="${extra_options} arm/eabi.opt"
+	  if test x$enable_extra_sgxx_multilibs = xyes; then
+		  tmake_file="${tmake_file} arm/t-cs-eabi"
+	  elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+		  tmake_file="${tmake_file} arm/t-cs-eabi-lite"
+	  fi
 	  ;;
 	arm*-*-symbianelf*)
 	  tm_file="${tm_file} arm/symbian.h"
@@ -1088,7 +1123,7 @@
 			tmake_file="${tmake_file} i386/t-linux64"
 			need_64bit_hwint=yes
 			case X"${with_cpu}" in
-			Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx)
+			Xgeneric|Xatom|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx)
 				;;
 			X)
 				if test x$with_cpu_64 = x; then
@@ -1097,13 +1132,29 @@
 				;;
 			*)
 				echo "Unsupported CPU used in --with-cpu=$with_cpu, supported values:" 1>&2
-				echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx" 1>&2
+				echo "generic atom core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx" 1>&2
 				exit 1
 				;;
 			esac
 		else
 			tm_file="${tm_file} i386/linux.h"
 		fi
+		case ${target} in
+		*-wrs-linux*)
+			tm_file="$tm_file i386/wrs-linux.h"
+			tmake_file="$tmake_file i386/t-wrs-linux"
+			extra_options="${extra_options} i386/wrs-linux.opt"
+			tm_defines="${tm_defines} TARGET_FLEXLM"
+			;;
+		esac
+		if test x$enable_extra_sgxx_multilibs = xyes; then
+			tm_file="${tm_file} i386/cs-linux.h"
+			tmake_file="${tmake_file} i386/t-cs-linux"
+			extra_options="${extra_options} i386/cs-linux.opt"
+		elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+			tm_file="${tm_file} i386/cs-linux-lite.h"
+			tmake_file="${tmake_file} i386/t-cs-linux-lite"
+		fi
 		;;
 	i[34567]86-*-knetbsd*-gnu) tm_file="${tm_file} i386/linux.h knetbsd-gnu.h i386/knetbsd-gnu.h" ;;
 	i[34567]86-*-kfreebsd*-gnu) tm_file="${tm_file} i386/linux.h kfreebsd-gnu.h i386/kfreebsd-gnu.h" ;;
@@ -1202,7 +1253,7 @@
 		# libgcc/configure.ac instead.
 		need_64bit_hwint=yes
 		case X"${with_cpu}" in
-		Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx)
+		Xgeneric|Xatom|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx)
 			;;
 		X)
 			if test x$with_cpu_64 = x; then
@@ -1211,7 +1262,7 @@
 			;;
 		*)
 			echo "Unsupported CPU used in --with-cpu=$with_cpu, supported values:" 1>&2
-			echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx" 1>&2
+			echo "generic atom core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx" 1>&2
 			exit 1
 			;;
 		esac
@@ -1566,6 +1617,7 @@
 			tm_defines="${tm_defines} MIPS_ISA_DEFAULT=65"
 			;;
 	esac
+	tmake_file="$tmake_file mips/t-crtfm"
 	gnu_ld=yes
 	gas=yes
 	test x$with_llsc != x || with_llsc=yes
@@ -1579,8 +1631,28 @@
                 ;;
         mipsisa32*)
 		tm_defines="${tm_defines} MIPS_ISA_DEFAULT=32"
+		;;
+	mips-wrs-linux-gnu) 
+		tmake_file="$tmake_file mips/t-linux64 mips/t-wrs-linux"
+		tm_file="$tm_file mips/linux64.h mips/octeon.h mips/wrs-linux.h"
+		tm_defines="$tm_defines TARGET_FLEXLM"
+		;;
+	mips-montavista*-linux-gnu)
+		tmake_file="$tmake_file mips/t-linux64 mips/t-montavista-linux"
+		tm_file="$tm_file mips/linux64.h mips/octeon.h mips/montavista-linux.h"
+		;;
+	*)
+		if test x$enable_extra_sgxx_multilibs = xyes; then
+		    tmake_file="$tmake_file mips/t-sgxx-linux"
+		    tm_file="$tm_file mips/cs-sgxx-linux.h"
+		elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+		    tmake_file="$tmake_file mips/t-sgxxlite-linux"
+		    tm_file="$tm_file mips/cs-sgxxlite-linux.h"
+		fi
+		;;
         esac
 	test x$with_llsc != x || with_llsc=yes
+	tmake_file="$tmake_file mips/t-crtfm"
 	;;
 mips*-*-openbsd*)
 	tm_defines="${tm_defines} OBSD_HAS_DECLARE_FUNCTION_NAME OBSD_HAS_DECLARE_OBJECT OBSD_HAS_CORRECT_SPECS"
@@ -1625,6 +1697,25 @@
 	    tm_defines="MIPS_ISA_DEFAULT=64 MIPS_ABI_DEFAULT=ABI_N32"
 	    ;;
 	esac
+	if [ "$enable_sgxx_sde_multilibs" = "yes" ]; then
+	  tm_file="$tm_file mips/sdemtk.h"
+	  extra_options="$extra_options mips/sdemtk.opt"
+	  tmake_file="$tmake_file mips/t-sgxx-sde"
+          # SourceryG++ is configured --with-arch=mips32r2.
+	  tm_defines="MIPS_ISA_DEFAULT=33 MIPS_ABI_DEFAULT=ABI_32"
+	fi
+	;;
+mips64octeon*-wrs-elf*)
+	tm_file="elfos.h ${tm_file} mips/elf.h mips/octeon.h mips/octeon-elf.h"
+	tmake_file=mips/t-octeon-elf
+	tm_defines="MIPS_ABI_DEFAULT=ABI_EABI MIPS_CPU_STRING_DEFAULT=\\\"octeon\\\" TARGET_FLEXLM"
+	default_use_cxa_atexit=no
+	;;
+mips64octeon*-montavista-elf*)
+	tm_file="elfos.h ${tm_file} mips/elf.h mips/octeon.h mips/octeon-elf.h"
+	tmake_file="mips/t-octeon-elf mips/t-montavista-elf"
+	tm_defines="MIPS_ABI_DEFAULT=ABI_EABI MIPS_CPU_STRING_DEFAULT=\\\"octeon\\\""
+	default_use_cxa_atexit=no
 	;;
 mipsisa32-*-elf* | mipsisa32el-*-elf* | \
 mipsisa32r2-*-elf* | mipsisa32r2el-*-elf* | \
@@ -1796,6 +1887,10 @@
 	tm_file="${tm_file} dbxelf.h elfos.h usegas.h svr4.h freebsd-spec.h rs6000/sysv4.h"
 	extra_options="${extra_options} rs6000/sysv4.opt"
 	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	if test x$enable_powerpc_e500mc_elf = xyes; then
+	  tm_file="${tm_file} rs6000/e500mc.h"
+	  tmake_file="${tmake_file} rs6000/t-ppc-e500mc"
+	fi
 	;;
 powerpc-*-eabialtivec*)
 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h rs6000/eabialtivec.h"
@@ -1811,6 +1906,11 @@
 	tm_file="${tm_file} dbxelf.h elfos.h usegas.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h"
 	extra_options="${extra_options} rs6000/sysv4.opt"
 	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	if test x$enable_extra_sgxx_multilibs = xyes; then
+	  tmake_file="${tmake_file} rs6000/t-cs-eabi"
+	elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+	  tmake_file="${tmake_file} rs6000/t-cs-eabi-lite"
+	fi
 	;;
 powerpc-*-rtems*)
 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h rs6000/rtems.h rtems.h"
@@ -1853,6 +1953,26 @@
 	if test x${enable_secureplt} = xyes; then
 		tm_file="rs6000/secureplt.h ${tm_file}"
 	fi
+	case ${target} in
+	powerpc-wrs-linux-gnu)
+		tm_file="$tm_file rs6000/wrs-linux.h rs6000/e500.h"
+		tmake_file="$tmake_file rs6000/t-wrs-linux"
+		tm_defines="$tm_defines TARGET_FLEXLM"
+		;;
+        powerpc-montavista*-linux-gnu)
+                tm_file="$tm_file rs6000/montavista-linux.h"
+                tmake_file="$tmake_file rs6000/t-montavista-linux"
+                ;;
+	*)
+		if test x$enable_extra_sgxx_multilibs = xyes; then
+		  tm_file="${tm_file} rs6000/e500.h"
+		  tmake_file="$tmake_file rs6000/t-cs-linux"
+		elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+		  tm_file="${tm_file} rs6000/e500.h"
+		  tmake_file="$tmake_file rs6000/t-cs-linux"
+		fi
+		;;
+	esac
 	;;
 powerpc-*-gnu-gnualtivec*)
 	tm_file="${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxaltivec.h rs6000/gnu.h"
@@ -2009,9 +2129,14 @@
 		*)				   with_endian=big,little ;;
 		esac
 	fi
+	# TM_ENDIAN_CONFIG is used by t-sh to determine multilibs.
+	#  First word : the default endian.
+	#  Second word: the secondary endian (optional).
 	case ${with_endian} in
-	big|little)	tmake_file="${tmake_file} sh/t-1e" ;;
-	big,little|little,big) ;;
+	big)		TM_ENDIAN_CONFIG=mb ;;
+	little)		TM_ENDIAN_CONFIG=ml ;;
+	big,little)	TM_ENDIAN_CONFIG="mb ml" ;;
+	little,big)	TM_ENDIAN_CONFIG="ml mb" ;;
 	*)	echo "with_endian=${with_endian} not supported."; exit 1 ;;
 	esac
 	case ${with_endian} in
@@ -2118,7 +2243,7 @@
 	*)	echo "with_cpu=$with_cpu not supported"; exit 1 ;;
 	esac
 	sh_multilibs=${with_multilib_list}
-	if test x${sh_multilibs} = x ; then
+	if test "$sh_multilibs" = "default" ; then
 		case ${target} in
 		sh64-superh-linux* | \
 		sh[1234]*)	sh_multilibs=${sh_cpu_target} ;;
@@ -2134,28 +2259,43 @@
 	fi
 	target_cpu_default=SELECT_`echo ${sh_cpu_default}|tr abcdefghijklmnopqrstuvwxyz- ABCDEFGHIJKLMNOPQRSTUVWXYZ_`
 	tm_defines=${tm_defines}' SH_MULTILIB_CPU_DEFAULT=\"'`echo $sh_cpu_default|sed s/sh/m/`'\"'
-	sh_multilibs=`echo $sh_multilibs,$sh_cpu_default | sed -e 's/[ 	,/][ 	,]*/ /g' -e 's/ $//' -e 's/^m/sh/' -e 's/ m/ sh/g' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ_ abcdefghijklmnopqrstuvwxyz-`
+	tm_defines="$tm_defines SUPPORT_`echo $sh_cpu_default | sed 's/^m/sh/' | tr abcdefghijklmnopqrstuvwxyz- ABCDEFGHIJKLMNOPQRSTUVWXYZ_`=1"
+	sh_multilibs=`echo $sh_multilibs | sed -e 's/,/ /g' -e 's/^sh/m/i' -e 's/ sh/ m/gi' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ_ abcdefghijklmnopqrstuvwxyz-`
 	for sh_multilib in ${sh_multilibs}; do
 		case ${sh_multilib} in
-		sh1 | sh2 | sh2e | sh3 | sh3e | \
-		sh4 | sh4-single | sh4-single-only | sh4-nofpu | sh4-300 |\
-		sh4a | sh4a-single | sh4a-single-only | sh4a-nofpu | sh4al | \
-		sh2a | sh2a-single | sh2a-single-only | sh2a-nofpu | \
-		sh5-64media | sh5-64media-nofpu | \
-		sh5-32media | sh5-32media-nofpu | \
-		sh5-compact | sh5-compact-nofpu)
-			tmake_file="${tmake_file} sh/t-mlib-${sh_multilib}"
-			tm_defines="$tm_defines SUPPORT_`echo $sh_multilib|tr abcdefghijklmnopqrstuvwxyz- ABCDEFGHIJKLMNOPQRSTUVWXYZ_`=1"
-			;;
+		m1 | m2 | m2e | m3 | m3e | \
+		m4 | m4-single | m4-single-only | m4-nofpu | m4-300 |\
+		m4a | m4a-single | m4a-single-only | m4a-nofpu | m4al | \
+		m2a | m2a-single | m2a-single-only | m2a-nofpu | \
+		m5-64media | m5-64media-nofpu | \
+		m5-32media | m5-32media-nofpu | \
+		m5-compact | m5-compact-nofpu)
+			# TM_MULTILIB_CONFIG is used by t-sh for the non-endian multilib definition
+			# It is passed to MULTIILIB_OPTIONS verbatim.
+			TM_MULTILIB_CONFIG="${TM_MULTILIB_CONFIG}/${sh_multilib}"
+			tm_defines="$tm_defines SUPPORT_`echo $sh_multilib | sed 's/^m/sh/' | tr abcdefghijklmnopqrstuvwxyz- ABCDEFGHIJKLMNOPQRSTUVWXYZ_`=1"
+			;;
+		\!*)	# TM_MULTILIB_EXCEPTIONS_CONFIG is used by t-sh
+			# It is passed the MULTILIB_EXCEPTIONS verbatim.
+			TM_MULTILIB_EXCEPTIONS_CONFIG="${TM_MULTILIB_EXCEPTIONS_CONFIG} `echo $sh_multilib | sed 's/^!//'`" ;;
 		*)
 			echo "with_multilib_list=${sh_multilib} not supported."
 			exit 1
 			;;
 		esac
 	done
+	TM_MULTILIB_CONFIG=`echo $TM_MULTILIB_CONFIG | sed 's:^/::'`
 	if test x${enable_incomplete_targets} = xyes ; then
 		tm_defines="$tm_defines SUPPORT_SH1=1 SUPPORT_SH2E=1 SUPPORT_SH4=1 SUPPORT_SH4_SINGLE=1 SUPPORT_SH2A=1 SUPPORT_SH2A_SINGLE=1 SUPPORT_SH5_32MEDIA=1 SUPPORT_SH5_32MEDIA_NOFPU=1 SUPPORT_SH5_64MEDIA=1 SUPPORT_SH5_64MEDIA_NOFPU=1"
 	fi
+	if test x$enable_extra_sgxxlite_multilibs = xyes \
+	   || test x$enable_extra_sgxx_multilibs = xyes; then
+		# SG++ and Lite do not differ, as yet, so use the Lite files for both
+		tm_file="$tm_file sh/cs-sgxxlite-linux.h"
+		tmake_file="$tmake_file sh/t-sgxxlite-linux"
+	fi
+	tm_file="$tm_file ./sysroot-suffix.h"
+	tmake_file="$tmake_file t-sysroot-suffix"
 	;;
 sh-*-rtems*)
 	tmake_file="sh/t-sh sh/t-elf t-rtems sh/t-rtems"
@@ -2194,6 +2334,11 @@
 		tm_file="${tm_file} sparc/linux.h"
 	fi
 	tmake_file="${tmake_file} sparc/t-crtfm"
+	case ${target} in
+	sparc-wrs-linux-gnu)
+		tm_defines="$tm_defines BIARCH_32BIT_DEFAULT TARGET_FLEXLM"
+		;;
+	esac
 	;;
 sparc-*-rtems*)
 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp-elf.h sparc/rtemself.h rtems.h"
@@ -2420,6 +2565,8 @@
 i[34567]86-*-* | x86_64-*-*)
 	tmake_file="${tmake_file} i386/t-gmm_malloc i386/t-i386"
 	;;
+powerpc*-*-* | rs6000-*-*)
+	tm_file="${tm_file} rs6000/option-defaults.h"
 esac
 
 # Support for --with-cpu and related options (and a few unrelated options,
@@ -2646,8 +2793,8 @@
 		| armv[23456] | armv2a | armv3m | armv4t | armv5t \
 		| armv5te | armv6j |armv6k | armv6z | armv6zk | armv6-m \
 		| armv7 | armv7-a | armv7-r | armv7-m \
-		| iwmmxt | ep9312)
-			# OK
+		| iwmmxt | ep9312 | marvell-f )
+ 			# OK
 			;;
 		*)
 			echo "Unknown arch used in --with-arch=$with_arch" 1>&2
@@ -2668,7 +2815,10 @@
 
 		case "$with_fpu" in
 		"" \
-		| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 | neon )
+		| fpa | fpe2 | fpe3 | maverick \
+		| vfp | vfp3 | vfpv3 | vfpv3-fp16 | vfpv3-d16 \
+		| vfpv3-d16-fp16 | vfpv4 | vfpv4-d16 | fpv4-sp-d16 \
+		| neon | neon-fp16 | neon-vfpv4 )
 			# OK
 			;;
 		*)
@@ -2805,7 +2955,7 @@
 				esac
 				# OK
 				;;
-			"" | amdfam10 | barcelona | k8 | opteron | athlon64 | athlon-fx | nocona | core2 | generic)
+			"" | amdfam10 | barcelona | k8 | opteron | athlon64 | athlon-fx | nocona | core2 | atom | generic)
 				# OK
 				;;
 			*)
@@ -2817,7 +2967,7 @@
 		;;
 
 	mips*-*-*)
-		supported_defaults="abi arch float tune divide llsc mips-plt"
+		supported_defaults="abi arch arch_32 arch_64 float tune tune_32 tune_64 divide llsc mips-plt"
 
 		case ${with_float} in
 		"" | soft | hard)
@@ -2882,12 +3032,20 @@
 		;;
 
 	powerpc*-*-* | rs6000-*-*)
-		supported_defaults="cpu float tune"
+		supported_defaults="cpu cpu_32 cpu_64 float tune tune_32 tune_64"
 
-		for which in cpu tune; do
+		for which in cpu cpu_32 cpu_64 tune tune_32 tune_64; do
 			eval "val=\$with_$which"
 			case ${val} in
 			default32 | default64)
+				case $which in
+				cpu | tune)
+					;;
+				*)
+					echo "$val only valid for --with-cpu and --with-tune." 1>&2
+					exit 1
+					;;
+				esac
 				with_which="with_$which"
 				eval $with_which=
 				;;
@@ -3133,6 +3291,22 @@
 		;;
 esac
 
+case ${target} in
+    *-eglibc-*-*)
+	tmake_file="${tmake_file} t-eglibc"
+
+	case ${target} in
+	    arm-*)
+	     # ARM already includes below.
+		;;
+	    *)
+		tmake_file="${tmake_file} t-sysroot-suffix"
+		tm_file="${tm_file} ./sysroot-suffix.h"
+		;;
+	esac
+	;;
+esac
+
 t=
 all_defaults="abi cpu cpu_32 cpu_64 arch arch_32 arch_64 tune tune_32 tune_64 schedule float mode fpu divide llsc mips-plt"
 for option in $all_defaults
diff -Nur a/gcc/config.in b/gcc/config.in
--- a/gcc/config.in	2009-07-22 09:43:59.000000000 +0200
+++ b/gcc/config.in	2010-01-25 09:50:29.085687411 +0100
@@ -12,6 +12,18 @@
 #endif
 
 
+/* Required license feature */
+#ifndef USED_FOR_TARGET
+#undef CSL_LICENSE_FEATURE
+#endif
+
+
+/* Required license version */
+#ifndef USED_FOR_TARGET
+#undef CSL_LICENSE_VERSION
+#endif
+
+
 /* Define to enable the use of a default assembler. */
 #ifndef USED_FOR_TARGET
 #undef DEFAULT_ASSEMBLER
@@ -108,6 +120,12 @@
 #endif
 
 
+/* Define to warn for use of native system header directories */
+#ifndef USED_FOR_TARGET
+#undef ENABLE_POISON_SYSTEM_DIRECTORIES
+#endif
+
+
 /* Define if you want all operations on RTL (the basic data structure of the
    optimizer and back end) to be checked for dynamic type safety at runtime.
    This is quite expensive. */
@@ -821,6 +839,13 @@
 #endif
 
 
+/* Define if your assembler supports specifying the alignment of objects
+   allocated using the GAS .comm command. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_GAS_ALIGNED_COMM
+#endif
+
+
 /* Define if your assembler supports .balign and .p2align. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_GAS_BALIGN_AND_P2ALIGN
diff -Nur a/gcc/configure b/gcc/configure
--- a/gcc/configure	2009-03-24 18:46:03.000000000 +0100
+++ b/gcc/configure	2010-01-25 09:50:29.085687411 +0100
@@ -458,7 +458,7 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_libsubdir build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP EGREP loose_warn strict_warn warn_cflags nocommon_flag TREEBROWSER valgrind_path valgrind_path_defines valgrind_command coverage_flags enable_multilib enable_decimal_float enable_fixed_point enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR onestep PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI datarootdir docdir htmldir SET_MAKE AWK LN_S LN RANLIB ac_ct_RANLIB ranlib_flags INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON NM AR COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB TARGET_GETGROUPS_T LIBICONV LTLIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file extra_opt_files USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CROSS ALL SYSTEM_HEADER_DIR inhibit_libc CC_FOR_BUILD BUILD_CFLAGS BUILD_LDFLAGS STMP_FIXINC STMP_FIXPROTO collect2 LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN OBJDUMP ac_ct_OBJDUMP ac_ct_AR STRIP ac_ct_STRIP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 objdir enable_fast_install gcc_cv_as ORIGINAL_AS_FOR_TARGET gcc_cv_ld ORIGINAL_LD_FOR_TARGET gcc_cv_nm ORIGINAL_NM_FOR_TARGET gcc_cv_objdump gcc_cv_readelf libgcc_visibility GGC zlibdir zlibinc MAINT gcc_tooldir dollar slibdir subdirs srcdir all_compilers all_gtfiles all_lang_makefrags all_lang_makefiles all_languages all_selected_languages build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines build_file_translate check_languages cpp_install_dir xmake_file tmake_file extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines c_target_objs cxx_target_objs fortran_target_objs target_cpu_default GMPLIBS GMPINC PPLLIBS PPLINC CLOOGLIBS CLOOGINC LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical licensedir build_libsubdir build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP EGREP loose_warn strict_warn warn_cflags nocommon_flag TREEBROWSER valgrind_path valgrind_path_defines valgrind_command coverage_flags enable_multilib enable_decimal_float enable_fixed_point enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR EGLIBC_CONFIGS CONFIGURE_SPECS onestep PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI datarootdir docdir htmldir SET_MAKE AWK LN_S LN RANLIB ac_ct_RANLIB ranlib_flags INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON NM AR COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB TARGET_GETGROUPS_T LIBICONV LTLIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file extra_opt_files USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CROSS ALL SYSTEM_HEADER_DIR inhibit_libc CC_FOR_BUILD BUILD_CFLAGS BUILD_LDFLAGS STMP_FIXINC STMP_FIXPROTO collect2 LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN OBJDUMP ac_ct_OBJDUMP ac_ct_AR STRIP ac_ct_STRIP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 objdir enable_fast_install gcc_cv_as ORIGINAL_AS_FOR_TARGET gcc_cv_ld ORIGINAL_LD_FOR_TARGET gcc_cv_nm ORIGINAL_NM_FOR_TARGET gcc_cv_objdump gcc_cv_readelf libgcc_visibility GGC zlibdir zlibinc MAINT gcc_tooldir dollar slibdir subdirs srcdir all_compilers all_gtfiles all_lang_makefrags all_lang_makefiles all_languages all_selected_languages build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines build_file_translate check_languages cpp_install_dir xmake_file tmake_file TM_ENDIAN_CONFIG TM_MULTILIB_CONFIG TM_MULTILIB_EXCEPTIONS_CONFIG extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines c_target_objs cxx_target_objs fortran_target_objs target_cpu_default GMPLIBS GMPINC PPLLIBS PPLINC CLOOGLIBS CLOOGINC LIBOBJS LTLIBOBJS'
 ac_subst_files='language_hooks'
 ac_pwd=`pwd`
 
@@ -1084,10 +1084,17 @@
   --enable-version-specific-runtime-libs
                           specify that runtime libraries should be
                           installed in a compiler-specific directory
+  --enable-poison-system-directories
+                          warn for use of native system header directories
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-csl-license-version=VERSION
+                          Use VERSION to communicate with the license manager
+  --with-license          the path to the installed license component
+  --with-csl-license-feature=FEATURE
+                          Use FEATURE to communicate with the license manager
   --with-build-libsubdir=DIR  Directory where to find libraries for build system
   --with-local-prefix=DIR specifies directory to put local include
   --with-gxx-include-dir=DIR
@@ -1105,8 +1112,12 @@
   --with-build-sysroot=sysroot
                           use sysroot as the system root during the build
   --with-sysroot=DIR Search for usr/lib, usr/include, et al, within DIR.
+  --with-eglibc-configs=CONFIGS
+                          build multilibs for these EGLIBC configurations
+  --with-specs=SPECS      add SPECS to driver command-line processing
   --with-pkgversion=PKG   Use PKG in the version string in place of "GCC"
   --with-bugurl=URL       Direct users to URL to report a bug
+  --with-multilib-list    Select multilibs (SH only)
   --with-gnu-ld           assume the C compiler uses GNU ld default=no
   --with-libiconv-prefix[=DIR]  search for libiconv in DIR/include and DIR/lib
   --without-libiconv-prefix     don't search for libiconv in includedir and libdir
@@ -1724,6 +1735,73 @@
 
 
 
+
+
+# Check whether --with-csl-license-version or --without-csl-license-version was given.
+if test "${with_csl_license_version+set}" = set; then
+  withval="$with_csl_license_version"
+  case "$withval" in
+      (yes) { { echo "$as_me:$LINENO: error: license version not specified" >&5
+echo "$as_me: error: license version not specified" >&2;}
+   { (exit 1); exit 1; }; } ;;
+      (no)  CSL_LICENSE_VERSION="" ;;
+      (*)   CSL_LICENSE_VERSION="$withval" ;;
+     esac
+else
+  CSL_LICENSE_VERSION=""
+
+fi;
+  if test x"$CSL_LICENSE_VERSION" != x; then
+
+cat >>confdefs.h <<_ACEOF
+#define CSL_LICENSE_VERSION "$CSL_LICENSE_VERSION"
+_ACEOF
+
+  fi
+
+
+
+# Check whether --with-license or --without-license was given.
+if test "${with_license+set}" = set; then
+  withval="$with_license"
+  case "$withval" in
+     (yes) { { echo "$as_me:$LINENO: error: license not specified" >&5
+echo "$as_me: error: license not specified" >&2;}
+   { (exit 1); exit 1; }; } ;;
+     (no)  with_license= ;;
+     (*) ;;
+  esac
+else
+  with_license=
+fi;
+  licensedir=$with_license
+
+
+
+
+# Check whether --with-csl-license-feature or --without-csl-license-feature was given.
+if test "${with_csl_license_feature+set}" = set; then
+  withval="$with_csl_license_feature"
+  case "$withval" in
+      (yes) { { echo "$as_me:$LINENO: error: license feature not specified" >&5
+echo "$as_me: error: license feature not specified" >&2;}
+   { (exit 1); exit 1; }; } ;;
+      (no)  CSL_LICENSE_FEATURE="" ;;
+      (*)   CSL_LICENSE_FEATURE="$withval" ;;
+     esac
+else
+  CSL_LICENSE_FEATURE=""
+
+fi;
+  if test x"$CSL_LICENSE_FEATURE" != x; then
+
+cat >>confdefs.h <<_ACEOF
+#define CSL_LICENSE_FEATURE "$CSL_LICENSE_FEATURE"
+_ACEOF
+
+  fi
+
+
 # Determine the target- and build-specific subdirectories
 
 # post-stage1 host modules use a different CC_FOR_BUILD so, in order to
@@ -8042,6 +8120,28 @@
 
 
 
+
+# Check whether --with-eglibc-configs or --without-eglibc-configs was given.
+if test "${with_eglibc_configs+set}" = set; then
+  withval="$with_eglibc_configs"
+  EGLIBC_CONFIGS=$withval
+else
+  EGLIBC_CONFIGS=
+
+fi;
+
+
+
+# Check whether --with-specs or --without-specs was given.
+if test "${with_specs+set}" = set; then
+  withval="$with_specs"
+  CONFIGURE_SPECS=$withval
+else
+  CONFIGURE_SPECS=
+
+fi;
+
+
 # Build with intermodule optimisations
 # Check whether --enable-intermodule or --disable-intermodule was given.
 if test "${enable_intermodule+set}" = set; then
@@ -8137,6 +8237,15 @@
 
 
 
+
+# Check whether --with-multilib-list or --without-multilib-list was given.
+if test "${with_multilib_list+set}" = set; then
+  withval="$with_multilib_list"
+  :
+else
+  with_multilib_list=default
+fi;
+
 # -------------------------
 # Checks for other programs
 # -------------------------
@@ -14509,13 +14618,13 @@
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:14512: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:14621: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:14515: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:14624: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:14518: output\"" >&5)
+  (eval echo "\"\$as_me:14627: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
@@ -15672,7 +15781,7 @@
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 15675 "configure"' > conftest.$ac_ext
+  echo '#line 15784 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -16971,11 +17080,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:16974: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17083: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:16978: \$? = $ac_status" >&5
+   echo "$as_me:17087: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -17310,11 +17419,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17313: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17422: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:17317: \$? = $ac_status" >&5
+   echo "$as_me:17426: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -17415,11 +17524,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17418: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17527: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:17422: \$? = $ac_status" >&5
+   echo "$as_me:17531: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -17470,11 +17579,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17473: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17582: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:17477: \$? = $ac_status" >&5
+   echo "$as_me:17586: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -20282,7 +20391,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 20285 "configure"
+#line 20394 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -20378,7 +20487,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 20381 "configure"
+#line 20490 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -22108,6 +22217,22 @@
 	tls_first_minor=16
 	tls_as_opt='-32 --fatal-warnings'
 	;;
+  m68k-*-*)
+    conftest_s='
+	.section .tdata,"awT",@progbits
+x:
+	.word 2
+	.text
+foo:
+	move.l x@TLSGD(%a5),%a0
+	move.l x@TLSLDM(%a5),%a0
+	move.l x@TLSLDO(%a5),%a0
+	move.l x@TLSIE(%a5),%a0
+	move.l x@TLSLE(%a5),%a0'
+	tls_first_major=2
+	tls_first_minor=19
+	tls_as_opt='--fatal-warnings'
+	;;
   powerpc-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
@@ -22739,6 +22864,44 @@
   i[34567]86-*-* | x86_64-*-*)
     case $target_os in
       cygwin* | pe | mingw32*)
+	# Recent binutils allows the three-operand form of ".comm" on PE.  This
+	# definition is used unconditionally to initialise the default state of
+	# the target option variable that governs usage of the feature.
+	echo "$as_me:$LINENO: checking assembler for .comm with alignment" >&5
+echo $ECHO_N "checking assembler for .comm with alignment... $ECHO_C" >&6
+if test "${gcc_cv_as_comm_has_align+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  gcc_cv_as_comm_has_align=no
+    if test $in_tree_gas = yes; then
+    if test $gcc_cv_gas_vers -ge `expr \( \( 2 \* 1000 \) + 19 \) \* 1000 + 52`
+  then gcc_cv_as_comm_has_align=yes
+fi
+  elif test x$gcc_cv_as != x; then
+    echo '.comm foo,1,32' > conftest.s
+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }
+    then
+	gcc_cv_as_comm_has_align=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+echo "$as_me:$LINENO: result: $gcc_cv_as_comm_has_align" >&5
+echo "${ECHO_T}$gcc_cv_as_comm_has_align" >&6
+
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_GAS_ALIGNED_COMM `if test $gcc_cv_as_comm_has_align = yes; then echo 1; else echo 0; fi`
+_ACEOF
+
 	# Used for DWARF 2 in PE
 	echo "$as_me:$LINENO: checking assembler for .secrel32 relocs" >&5
 echo $ECHO_N "checking assembler for .secrel32 relocs... $ECHO_C" >&6
@@ -24711,6 +24874,21 @@
 fi;
 
 
+# Check whether --enable-poison-system-directories or --disable-poison-system-directories was given.
+if test "${enable_poison_system_directories+set}" = set; then
+  enableval="$enable_poison_system_directories"
+
+else
+  enable_poison_system_directories=no
+fi;
+if test "x${enable_poison_system_directories}" = "xyes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_POISON_SYSTEM_DIRECTORIES 1
+_ACEOF
+
+fi
+
 # Substitute configuration variables
 
 
@@ -25451,6 +25629,7 @@
 s,@target_vendor@,$target_vendor,;t t
 s,@target_os@,$target_os,;t t
 s,@target_noncanonical@,$target_noncanonical,;t t
+s,@licensedir@,$licensedir,;t t
 s,@build_libsubdir@,$build_libsubdir,;t t
 s,@build_subdir@,$build_subdir,;t t
 s,@host_subdir@,$host_subdir,;t t
@@ -25487,6 +25666,8 @@
 s,@TARGET_SYSTEM_ROOT@,$TARGET_SYSTEM_ROOT,;t t
 s,@TARGET_SYSTEM_ROOT_DEFINE@,$TARGET_SYSTEM_ROOT_DEFINE,;t t
 s,@CROSS_SYSTEM_HEADER_DIR@,$CROSS_SYSTEM_HEADER_DIR,;t t
+s,@EGLIBC_CONFIGS@,$EGLIBC_CONFIGS,;t t
+s,@CONFIGURE_SPECS@,$CONFIGURE_SPECS,;t t
 s,@onestep@,$onestep,;t t
 s,@PKGVERSION@,$PKGVERSION,;t t
 s,@REPORT_BUGS_TO@,$REPORT_BUGS_TO,;t t
@@ -25606,6 +25787,9 @@
 s,@cpp_install_dir@,$cpp_install_dir,;t t
 s,@xmake_file@,$xmake_file,;t t
 s,@tmake_file@,$tmake_file,;t t
+s,@TM_ENDIAN_CONFIG@,$TM_ENDIAN_CONFIG,;t t
+s,@TM_MULTILIB_CONFIG@,$TM_MULTILIB_CONFIG,;t t
+s,@TM_MULTILIB_EXCEPTIONS_CONFIG@,$TM_MULTILIB_EXCEPTIONS_CONFIG,;t t
 s,@extra_gcc_objs@,$extra_gcc_objs,;t t
 s,@extra_headers_list@,$extra_headers_list,;t t
 s,@extra_objs@,$extra_objs,;t t
diff -Nur a/gcc/configure.ac b/gcc/configure.ac
--- a/gcc/configure.ac	2009-03-24 18:46:03.000000000 +0100
+++ b/gcc/configure.ac	2010-01-25 09:50:29.085687411 +0100
@@ -39,6 +39,10 @@
 # Determine the noncanonical target name, for directory use.
 ACX_NONCANONICAL_TARGET
 
+CSL_AC_LICENSE_VERSION
+CSL_AC_LICENSE
+CSL_AC_LICENSE_FEATURE
+
 # Determine the target- and build-specific subdirectories
 GCC_TOPLEV_SUBDIRS
 
@@ -770,6 +774,22 @@
 AC_SUBST(TARGET_SYSTEM_ROOT_DEFINE)
 AC_SUBST(CROSS_SYSTEM_HEADER_DIR)
 
+AC_ARG_WITH(eglibc-configs,
+  [AS_HELP_STRING([--with-eglibc-configs=CONFIGS],
+                  [build multilibs for these EGLIBC configurations])],
+  [EGLIBC_CONFIGS=$withval],
+  [EGLIBC_CONFIGS=]
+)
+AC_SUBST(EGLIBC_CONFIGS)
+
+AC_ARG_WITH(specs,
+  [AS_HELP_STRING([--with-specs=SPECS],
+                  [add SPECS to driver command-line processing])],
+  [CONFIGURE_SPECS=$withval],
+  [CONFIGURE_SPECS=]
+)
+AC_SUBST(CONFIGURE_SPECS)
+
 # Build with intermodule optimisations
 AC_ARG_ENABLE(intermodule,
 [  --enable-intermodule    build the compiler in one step],
@@ -810,6 +830,11 @@
 AC_SUBST(docdir)
 AC_SUBST(htmldir)
 
+AC_ARG_WITH(multilib-list,
+[  --with-multilib-list    Select multilibs (SH only)],
+:,
+with_multilib_list=default)
+
 # -------------------------
 # Checks for other programs
 # -------------------------
@@ -2576,6 +2601,22 @@
 	tls_first_minor=16
 	tls_as_opt='-32 --fatal-warnings'
 	;;
+  m68k-*-*)
+    conftest_s='
+	.section .tdata,"awT",@progbits
+x:
+	.word 2
+	.text
+foo:
+	move.l x@TLSGD(%a5),%a0
+	move.l x@TLSLDM(%a5),%a0
+	move.l x@TLSLDO(%a5),%a0
+	move.l x@TLSIE(%a5),%a0
+	move.l x@TLSLE(%a5),%a0'
+	tls_first_major=2
+	tls_first_minor=19
+	tls_as_opt='--fatal-warnings'
+	;;
   powerpc-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
@@ -2944,6 +2985,15 @@
 changequote([,])dnl
     case $target_os in
       cygwin* | pe | mingw32*)
+	# Recent binutils allows the three-operand form of ".comm" on PE.  This
+	# definition is used unconditionally to initialise the default state of
+	# the target option variable that governs usage of the feature.
+	gcc_GAS_CHECK_FEATURE([.comm with alignment], gcc_cv_as_comm_has_align,
+	 [2,19,52],,[.comm foo,1,32])
+	AC_DEFINE_UNQUOTED(HAVE_GAS_ALIGNED_COMM,
+	  [`if test $gcc_cv_as_comm_has_align = yes; then echo 1; else echo 0; fi`],
+	  [Define if your assembler supports specifying the alignment
+	   of objects allocated using the GAS .comm command.])
 	# Used for DWARF 2 in PE
 	gcc_GAS_CHECK_FEATURE([.secrel32 relocs],
 	  gcc_cv_as_ix86_pe_secrel32,
@@ -3891,6 +3941,16 @@
 htmldir='$(docdir)')
 AC_SUBST(htmldir)
 
+AC_ARG_ENABLE([poison-system-directories],
+	      AS_HELP_STRING([--enable-poison-system-directories],
+			     [warn for use of native system header directories]),,
+	      [enable_poison_system_directories=no])
+if test "x${enable_poison_system_directories}" = "xyes"; then
+  AC_DEFINE([ENABLE_POISON_SYSTEM_DIRECTORIES],
+	    [1],
+	    [Define to warn for use of native system header directories])
+fi
+
 # Substitute configuration variables
 AC_SUBST(subdirs)
 AC_SUBST(srcdir)
@@ -3910,6 +3970,9 @@
 AC_SUBST(cpp_install_dir)
 AC_SUBST(xmake_file)
 AC_SUBST(tmake_file)
+AC_SUBST(TM_ENDIAN_CONFIG)
+AC_SUBST(TM_MULTILIB_CONFIG)
+AC_SUBST(TM_MULTILIB_EXCEPTIONS_CONFIG)
 AC_SUBST(extra_gcc_objs)
 AC_SUBST(extra_headers_list)
 AC_SUBST(extra_objs)
diff -Nur a/gcc/c.opt b/gcc/c.opt
--- a/gcc/c.opt	2009-03-18 22:14:53.000000000 +0100
+++ b/gcc/c.opt	2010-01-25 09:50:29.085687411 +0100
@@ -716,6 +716,10 @@
 C ObjC C++ ObjC++
 Treat the input file as already preprocessed
 
+fremove-local-statics
+C C++ Var(flag_remove_local_statics) Optimization
+Convert function-local static variables to automatic variables when it is safe to do so
+
 freplace-objc-classes
 ObjC ObjC++
 Used in Fix-and-Continue mode to indicate that object files may be swapped in at runtime
diff -Nur a/gcc/c-opts.c b/gcc/c-opts.c
--- a/gcc/c-opts.c	2009-02-18 03:16:03.000000000 +0100
+++ b/gcc/c-opts.c	2010-01-25 09:50:29.095687705 +0100
@@ -40,6 +40,7 @@
 #include "mkdeps.h"
 #include "target.h"
 #include "tm_p.h"
+#include "c-tree.h"		/* For c_cpp_error.  */
 
 #ifndef DOLLARS_IN_IDENTIFIERS
 # define DOLLARS_IN_IDENTIFIERS true
@@ -201,6 +202,7 @@
 {
   static const unsigned int lang_flags[] = {CL_C, CL_ObjC, CL_CXX, CL_ObjCXX};
   unsigned int i, result;
+  struct cpp_callbacks *cb;
 
   /* This is conditionalized only because that is the way the front
      ends used to do it.  Maybe this should be unconditional?  */
@@ -216,6 +218,8 @@
 
   parse_in = cpp_create_reader (c_dialect_cxx () ? CLK_GNUCXX: CLK_GNUC89,
 				ident_hash, line_table);
+  cb = cpp_get_callbacks (parse_in);
+  cb->error = c_cpp_error;
 
   cpp_opts = cpp_get_options (parse_in);
   cpp_opts->dollars_in_ident = DOLLARS_IN_IDENTIFIERS;
@@ -333,12 +337,12 @@
 	 or environment var dependency generation is used.  */
       cpp_opts->deps.style = (code == OPT_M ? DEPS_SYSTEM: DEPS_USER);
       flag_no_output = 1;
-      cpp_opts->inhibit_warnings = 1;
       break;
 
     case OPT_MD:
     case OPT_MMD:
       cpp_opts->deps.style = (code == OPT_MD ? DEPS_SYSTEM: DEPS_USER);
+      cpp_opts->deps.need_preprocessor_output = true;
       deps_file = arg;
       break;
 
@@ -444,7 +448,6 @@
       break;
 
     case OPT_Werror:
-      cpp_opts->warnings_are_errors = value;
       global_dc->warning_as_error_requested = value;
       break;
 
@@ -503,10 +506,6 @@
       warn_strict_null_sentinel = value;
       break;
 
-    case OPT_Wsystem_headers:
-      cpp_opts->warn_system_headers = value;
-      break;
-
     case OPT_Wtraditional:
       cpp_opts->warn_traditional = value;
       break;
@@ -895,8 +894,6 @@
 	 c_common_post_options, so that a subsequent -Wno-endif-labels
 	 is not overridden.  */
     case OPT_pedantic_errors:
-      cpp_opts->pedantic_errors = 1;
-      /* Fall through.  */
     case OPT_pedantic:
       cpp_opts->pedantic = 1;
       cpp_opts->warn_endif_labels = 1;
@@ -971,10 +968,6 @@
       flag_undef = 1;
       break;
 
-    case OPT_w:
-      cpp_opts->inhibit_warnings = 1;
-      break;
-
     case OPT_v:
       verbose = true;
       break;
@@ -1159,10 +1152,6 @@
 
   input_location = UNKNOWN_LOCATION;
 
-  /* If an error has occurred in cpplib, note it so we fail
-     immediately.  */
-  errorcount += cpp_errors (parse_in);
-
   *pfilename = this_input_filename
     = cpp_read_main_file (parse_in, in_fnames[0]);
   /* Don't do any compilation or preprocessing if there is no input file.  */
@@ -1274,7 +1263,8 @@
 {
   FILE *deps_stream = NULL;
 
-  if (cpp_opts->deps.style != DEPS_NONE)
+  /* Don't write the deps file if there are errors.  */
+  if (cpp_opts->deps.style != DEPS_NONE && errorcount == 0)
     {
       /* If -M or -MM was seen without -MF, default output to the
 	 output stream.  */
@@ -1290,7 +1280,7 @@
 
   /* For performance, avoid tearing down cpplib's internal structures
      with cpp_destroy ().  */
-  errorcount += cpp_finish (parse_in, deps_stream);
+  cpp_finish (parse_in, deps_stream);
 
   if (deps_stream && deps_stream != out_stream
       && (ferror (deps_stream) || fclose (deps_stream)))
diff -Nur a/gcc/cp/class.c b/gcc/cp/class.c
--- a/gcc/cp/class.c	2009-06-24 19:02:03.000000000 +0200
+++ b/gcc/cp/class.c	2010-01-25 09:50:29.095687705 +0100
@@ -6136,7 +6136,7 @@
       if (flags & tf_error)
 	{
 	  error ("no matches converting function %qD to type %q#T",
-		 DECL_NAME (OVL_FUNCTION (overload)),
+		 DECL_NAME (OVL_CURRENT (overload)),
 		 target_type);
 
 	  /* print_candidates expects a chain with the functions in
@@ -6299,13 +6299,8 @@
      dependent on overload resolution.  */
   gcc_assert (TREE_CODE (rhs) == ADDR_EXPR
 	      || TREE_CODE (rhs) == COMPONENT_REF
-	      || TREE_CODE (rhs) == COMPOUND_EXPR
-	      || really_overloaded_fn (rhs));
-
-  /* We don't overwrite rhs if it is an overloaded function.
-     Copying it would destroy the tree link.  */
-  if (TREE_CODE (rhs) != OVERLOAD)
-    rhs = copy_node (rhs);
+	      || really_overloaded_fn (rhs)
+	      || (flag_ms_extensions && TREE_CODE (rhs) == FUNCTION_DECL));
 
   /* This should really only be used when attempting to distinguish
      what sort of a pointer to function we have.  For now, any
@@ -6357,19 +6352,6 @@
 						/*explicit_targs=*/NULL_TREE,
 						access_path);
 
-    case COMPOUND_EXPR:
-      TREE_OPERAND (rhs, 0)
-	= instantiate_type (lhstype, TREE_OPERAND (rhs, 0), flags);
-      if (TREE_OPERAND (rhs, 0) == error_mark_node)
-	return error_mark_node;
-      TREE_OPERAND (rhs, 1)
-	= instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);
-      if (TREE_OPERAND (rhs, 1) == error_mark_node)
-	return error_mark_node;
-
-      TREE_TYPE (rhs) = lhstype;
-      return rhs;
-
     case ADDR_EXPR:
     {
       if (PTRMEM_OK_P (rhs))
diff -Nur a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
--- a/gcc/cp/cp-tree.h	2009-07-13 08:06:27.000000000 +0200
+++ b/gcc/cp/cp-tree.h	2010-01-25 09:50:29.095687705 +0100
@@ -43,9 +43,6 @@
 #else
 #define ATTRIBUTE_GCC_CXXDIAG(m, n) ATTRIBUTE_NONNULL(m)
 #endif
-extern void cp_cpp_error			(cpp_reader *, int,
-						 const char *, va_list *)
-     ATTRIBUTE_GCC_CXXDIAG(3,0);
 #ifdef GCC_TOPLEV_H
 #error \
 In order for the format checking to accept the C++ front end diagnostic \
diff -Nur a/gcc/cp/cvt.c b/gcc/cp/cvt.c
--- a/gcc/cp/cvt.c	2009-04-23 13:13:57.000000000 +0200
+++ b/gcc/cp/cvt.c	2010-01-25 09:50:29.095687705 +0100
@@ -581,6 +581,7 @@
   tree e = expr;
   enum tree_code code = TREE_CODE (type);
   const char *invalid_conv_diag;
+  tree e1;
 
   if (error_operand_p (e) || type == error_mark_node)
     return error_mark_node;
@@ -629,6 +630,10 @@
 	}
     }
 
+  e1 = targetm.convert_to_type (type, e);
+  if (e1)
+    return e1;
+
   if (code == VOID_TYPE && (convtype & CONV_STATIC))
     {
       e = convert_to_void (e, /*implicit=*/NULL, tf_warning_or_error);
@@ -1231,11 +1236,18 @@
 tree
 type_promotes_to (tree type)
 {
+  tree promoted_type;
+
   if (type == error_mark_node)
     return error_mark_node;
 
   type = TYPE_MAIN_VARIANT (type);
 
+  /* Check for promotions of target-defined types first.  */
+  promoted_type = targetm.promoted_type (type);
+  if (promoted_type)
+    return promoted_type;
+
   /* bool always promotes to int (not unsigned), even if it's the same
      size.  */
   if (type == boolean_type_node)
diff -Nur a/gcc/cp/decl2.c b/gcc/cp/decl2.c
--- a/gcc/cp/decl2.c	2009-06-09 20:20:29.000000000 +0200
+++ b/gcc/cp/decl2.c	2010-01-25 09:50:29.095687705 +0100
@@ -1717,6 +1717,10 @@
       || (DECL_ASSEMBLER_NAME_SET_P (decl)
 	  && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))
       return true;
+  /* Functions marked "dllexport" must be emitted so that they are
+     visible to other DLLs.  */
+  if (lookup_attribute ("dllexport", DECL_ATTRIBUTES (decl)))
+    return true;
   /* Otherwise, DECL does not need to be emitted -- yet.  A subsequent
      reference to DECL might cause it to be emitted later.  */
   return false;
@@ -3802,6 +3806,15 @@
     }
 
   TREE_USED (decl) = 1;
+  if (current_function_decl != NULL_TREE
+      && (TREE_CODE (decl) == VAR_DECL
+	  || TREE_CODE (decl) == PARM_DECL
+	  || TREE_CODE (decl) == FUNCTION_DECL))
+    {
+      tree context = decl_function_context (decl);
+      if (context != NULL_TREE && context != current_function_decl)
+	DECL_NONLOCAL (decl) = 1;
+    }
   if (DECL_CLONED_FUNCTION_P (decl))
     TREE_USED (DECL_CLONED_FUNCTION (decl)) = 1;
   if (TREE_CODE (decl) == FUNCTION_DECL
diff -Nur a/gcc/cp/decl.c b/gcc/cp/decl.c
--- a/gcc/cp/decl.c	2009-07-08 00:08:01.000000000 +0200
+++ b/gcc/cp/decl.c	2010-01-25 09:50:29.095687705 +0100
@@ -4515,7 +4515,7 @@
 
       cp_apply_type_quals_to_decl (cp_type_quals (TREE_TYPE (decl)), decl);
 
-      layout_decl (decl, 0);
+      relayout_decl (decl);
     }
 }
 
@@ -7620,6 +7620,7 @@
   bool parameter_pack_p = declarator? declarator->parameter_pack_p : false;
   bool set_no_warning = false;
   bool template_type_arg = false;
+  const char *errmsg;
 
   signed_p = declspecs->specs[(int)ds_signed];
   unsigned_p = declspecs->specs[(int)ds_unsigned];
@@ -8299,6 +8300,12 @@
 		type_quals = TYPE_UNQUALIFIED;
 		set_no_warning = true;
 	      }
+	    errmsg = targetm.invalid_return_type (type);
+	    if (errmsg)
+	      {
+		error (errmsg);
+		type = integer_type_node;
+	      }
 
 	    /* Error about some types functions can't return.  */
 
@@ -8841,8 +8848,13 @@
 
 	  /* Replace the anonymous name with the real name everywhere.  */
 	  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))
-	    if (TYPE_NAME (t) == oldname)
-	      TYPE_NAME (t) = decl;
+	    {
+	      if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))
+		{
+		  debug_hooks->set_name (t, decl);
+		  TYPE_NAME (t) = decl;
+		}
+	    }
 
 	  if (TYPE_LANG_SPECIFIC (type))
 	    TYPE_WAS_ANONYMOUS (type) = 1;
@@ -9679,6 +9691,7 @@
       tree type = NULL_TREE;
       tree init = TREE_PURPOSE (parm);
       tree decl = TREE_VALUE (parm);
+      const char *errmsg;
 
       if (parm == void_list_node)
 	break;
@@ -9712,6 +9725,14 @@
 	  init = NULL_TREE;
 	}
 
+      if (type != error_mark_node
+	  && (errmsg = targetm.invalid_parameter_type (type)))
+	{
+	  error (errmsg);
+	  type = error_mark_node;
+	  TREE_TYPE (decl) = error_mark_node;
+	}
+
       if (type != error_mark_node)
 	{
 	  if (deprecated_state != DEPRECATED_SUPPRESS)
diff -Nur a/gcc/cp/error.c b/gcc/cp/error.c
--- a/gcc/cp/error.c	2009-07-11 00:31:34.000000000 +0200
+++ b/gcc/cp/error.c	2010-01-25 09:50:29.095687705 +0100
@@ -2667,39 +2667,6 @@
 #undef next_int
 }
 
-/* Callback from cpp_error for PFILE to print diagnostics arising from
-   interpreting strings.  The diagnostic is of type LEVEL; MSG is the
-   translated message and AP the arguments.  */
-
-void
-cp_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level,
-	      const char *msg, va_list *ap)
-{
-  diagnostic_info diagnostic;
-  diagnostic_t dlevel;
-  switch (level)
-    {
-    case CPP_DL_WARNING:
-    case CPP_DL_WARNING_SYSHDR:
-      dlevel = DK_WARNING;
-      break;
-    case CPP_DL_PEDWARN:
-      dlevel = DK_PEDWARN;
-      break;
-    case CPP_DL_ERROR:
-      dlevel = DK_ERROR;
-      break;
-    case CPP_DL_ICE:
-      dlevel = DK_ICE;
-      break;
-    default:
-      gcc_unreachable ();
-    }
-  diagnostic_set_info_translated (&diagnostic, msg, ap,
-				  input_location, dlevel);
-  report_diagnostic (&diagnostic);
-}
-
 /* Warn about the use of C++0x features when appropriate.  */
 void
 maybe_warn_cpp0x (const char* str)
diff -Nur a/gcc/cp/except.c b/gcc/cp/except.c
--- a/gcc/cp/except.c	2008-08-18 13:17:52.000000000 +0200
+++ b/gcc/cp/except.c	2010-01-25 09:50:29.095687705 +0100
@@ -146,14 +146,26 @@
 static tree
 build_eh_type_type (tree type)
 {
-  tree exp = eh_type_info (type);
+  bool is_ref = TREE_CODE (type) == REFERENCE_TYPE;
+  tree exp;
+  
+  if (is_ref)
+    type = TREE_TYPE (type);
+  
+  exp = eh_type_info (type);
 
   if (!exp)
     return NULL;
 
   mark_used (exp);
 
-  return convert (ptr_type_node, build_address (exp));
+  exp = build_address (exp);
+  
+  if (is_ref)
+    exp = targetm.cxx.ttype_ref_encode (exp);
+
+  exp = convert (ptr_type_node, exp);
+  return exp;
 }
 
 tree
@@ -495,6 +507,16 @@
       initialize_handler_parm (decl, exp);
     }
 
+  /* Preserve the reference type on the exception, as this affects
+     derived-to-base conversions in catch matching.  Only do this when
+     the ABI supports it, as originally this case was (incorrectly)
+     treated just as catching a pointer-to-class by value. */
+  if (targetm.cxx.ttype_ref_encode
+      && decl && TREE_CODE (type) == POINTER_TYPE
+      && CLASS_TYPE_P (TREE_TYPE (type))
+      && TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)
+    type = build_reference_type (type);
+
   return type;
 }
 
@@ -538,10 +560,20 @@
        raw_raises && TREE_VALUE (raw_raises);
        raw_raises = TREE_CHAIN (raw_raises))
     {
-      tree type = prepare_eh_type (TREE_VALUE (raw_raises));
+      tree orig_type = TREE_VALUE (raw_raises);
+      tree type = prepare_eh_type (orig_type);
       tree tinfo = eh_type_info (type);
 
       mark_used (tinfo);
+      /* Preserve the reference type on the exception, as this affects
+	 derived-to-base conversions in catch matching.  Only do this when
+	 the ABI supports it, as originally this case was (incorrectly)
+	 treated just as catching a pointer-to-class by value. */
+      if (targetm.cxx.ttype_ref_encode
+	  && TREE_CODE (orig_type) == REFERENCE_TYPE
+	  && TREE_CODE (type) == POINTER_TYPE
+	  && CLASS_TYPE_P (TREE_TYPE (type)))
+	type = build_reference_type (type);
       raises = tree_cons (NULL_TREE, type, raises);
     }
 
@@ -956,24 +988,40 @@
 static int
 can_convert_eh (tree to, tree from)
 {
-  to = non_reference (to);
-  from = non_reference (from);
+  bool to_ref = TREE_CODE (to) == REFERENCE_TYPE;
+  int depth = to_ref;
+  bool outer_const = true;
 
-  if (TREE_CODE (to) == POINTER_TYPE && TREE_CODE (from) == POINTER_TYPE)
+  if (to_ref)
+    to = TREE_TYPE (to);
+  from = non_reference (from);
+  
+  while (TREE_CODE (to) == POINTER_TYPE && TREE_CODE (from) == POINTER_TYPE)
     {
+      unsigned to_quals, from_quals;
+      
+      depth++;
+      
       to = TREE_TYPE (to);
       from = TREE_TYPE (from);
+      to_quals = TYPE_QUALS (to);
+      from_quals = TYPE_QUALS (from);
 
-      if (! at_least_as_qualified_p (to, from))
+      if ((from_quals & ~to_quals)
+	  || (!outer_const && to_quals & ~from_quals))
 	return 0;
-
-      if (TREE_CODE (to) == VOID_TYPE)
-	return 1;
-
-      /* Else fall through.  */
+	
+      if (!(to_quals & TYPE_QUAL_CONST))
+	outer_const = false;
     }
 
-  if (CLASS_TYPE_P (to) && CLASS_TYPE_P (from)
+  if (same_type_ignoring_top_level_qualifiers_p (from, to))
+    return 1;
+
+  if (depth == to_ref + 1 && TREE_CODE (to) == VOID_TYPE)
+    return 1;
+  
+  if (depth < 2 && CLASS_TYPE_P (to) && CLASS_TYPE_P (from)
       && PUBLICLY_UNIQUELY_DERIVED_P (to, from))
     return 1;
 
diff -Nur a/gcc/cp/parser.c b/gcc/cp/parser.c
--- a/gcc/cp/parser.c	2009-06-09 06:23:00.000000000 +0200
+++ b/gcc/cp/parser.c	2010-01-25 09:50:29.105687718 +0100
@@ -309,8 +309,7 @@
 
   /* Subsequent preprocessor diagnostics should use compiler
      diagnostic functions to get the compiler source location.  */
-  cpp_get_options (parse_in)->client_diagnostic = true;
-  cpp_get_callbacks (parse_in)->error = cp_cpp_error;
+  done_lexing = true;
 
   gcc_assert (lexer->next_token->type != CPP_PURGED);
   return lexer;
diff -Nur a/gcc/cp/rtti.c b/gcc/cp/rtti.c
--- a/gcc/cp/rtti.c	2008-09-23 16:55:14.000000000 +0200
+++ b/gcc/cp/rtti.c	2010-01-25 09:50:29.105687718 +0100
@@ -393,6 +393,7 @@
 	return d;
     }
 
+  gcc_assert (TREE_CODE (type) != REFERENCE_TYPE);
   name = mangle_typeinfo_for_type (type);
 
   d = IDENTIFIER_GLOBAL_VALUE (name);
diff -Nur a/gcc/cp/semantics.c b/gcc/cp/semantics.c
--- a/gcc/cp/semantics.c	2009-07-14 20:35:13.000000000 +0200
+++ b/gcc/cp/semantics.c	2010-01-25 09:50:29.105687718 +0100
@@ -1120,7 +1120,11 @@
     type = expand_start_catch_block (decl);
   HANDLER_TYPE (handler) = type;
   if (!processing_template_decl && type)
-    mark_used (eh_type_info (type));
+    {
+      if (TREE_CODE (type) == REFERENCE_TYPE)
+	type = TREE_TYPE (type);
+      mark_used (eh_type_info (type));
+    }
 }
 
 /* Finish a handler, which may be given by HANDLER.  The BLOCKs are
@@ -3243,8 +3247,10 @@
 
       /* If the user wants us to keep all inline functions, then mark
 	 this function as needed so that finish_file will make sure to
-	 output it later.  */
-      if (flag_keep_inline_functions && DECL_DECLARED_INLINE_P (fn))
+	 output it later.  Similarly, all dllexport'd functions must
+	 be emitted; there may be callers in other DLLs.  */
+      if ((flag_keep_inline_functions && DECL_DECLARED_INLINE_P (fn))
+	  || lookup_attribute ("dllexport", DECL_ATTRIBUTES (fn)))
 	mark_needed (fn);
     }
 
diff -Nur a/gcc/cp/typeck.c b/gcc/cp/typeck.c
--- a/gcc/cp/typeck.c	2009-07-13 08:06:27.000000000 +0200
+++ b/gcc/cp/typeck.c	2010-01-25 09:50:29.105687718 +0100
@@ -1707,10 +1707,14 @@
 tree
 default_conversion (tree exp)
 {
+  /* Check for target-specific promotions.  */
+  tree promoted_type = targetm.promoted_type (TREE_TYPE (exp));
+  if (promoted_type)
+    exp = cp_convert (promoted_type, exp);
   /* Perform the integral promotions first so that bitfield
      expressions (which may promote to "int", even if the bitfield is
      declared "unsigned") are promoted correctly.  */
-  if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (exp)))
+  else if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (exp)))
     exp = perform_integral_promotions (exp);
   /* Perform the other conversions.  */
   exp = decay_conversion (exp);
@@ -3389,6 +3393,25 @@
       return error_mark_node;
     }
 
+  /* Issue warnings about peculiar, but valid, uses of NULL.  */
+  if ((orig_op0 == null_node || orig_op1 == null_node)
+      /* It's reasonable to use pointer values as operands of &&
+	 and ||, so NULL is no exception.  */
+      && code != TRUTH_ANDIF_EXPR && code != TRUTH_ORIF_EXPR 
+      && ( /* Both are NULL (or 0) and the operation was not a
+	      comparison or a pointer subtraction.  */
+	  (null_ptr_cst_p (orig_op0) && null_ptr_cst_p (orig_op1) 
+	   && code != EQ_EXPR && code != NE_EXPR && code != MINUS_EXPR) 
+	  /* Or if one of OP0 or OP1 is neither a pointer nor NULL.  */
+	  || (!null_ptr_cst_p (orig_op0)
+	      && !TYPE_PTR_P (type0) && !TYPE_PTR_TO_MEMBER_P (type0))
+	  || (!null_ptr_cst_p (orig_op1) 
+	      && !TYPE_PTR_P (type1) && !TYPE_PTR_TO_MEMBER_P (type1)))
+      && (complain & tf_warning))
+    /* Some sort of arithmetic operation involving NULL was
+       performed.  */
+    warning (OPT_Wpointer_arith, "NULL used in arithmetic");
+
   switch (code)
     {
     case MINUS_EXPR:
@@ -3979,25 +4002,6 @@
 	}
     }
 
-  /* Issue warnings about peculiar, but valid, uses of NULL.  */
-  if ((orig_op0 == null_node || orig_op1 == null_node)
-      /* It's reasonable to use pointer values as operands of &&
-	 and ||, so NULL is no exception.  */
-      && code != TRUTH_ANDIF_EXPR && code != TRUTH_ORIF_EXPR 
-      && ( /* Both are NULL (or 0) and the operation was not a comparison.  */
-	  (null_ptr_cst_p (orig_op0) && null_ptr_cst_p (orig_op1) 
-	   && code != EQ_EXPR && code != NE_EXPR) 
-	  /* Or if one of OP0 or OP1 is neither a pointer nor NULL.  */
-	  || (!null_ptr_cst_p (orig_op0) && TREE_CODE (TREE_TYPE (op0)) != POINTER_TYPE)
-	  || (!null_ptr_cst_p (orig_op1) && TREE_CODE (TREE_TYPE (op1)) != POINTER_TYPE))
-      && (complain & tf_warning))
-    /* Some sort of arithmetic operation involving NULL was
-       performed.  Note that pointer-difference and pointer-addition
-       have already been handled above, and so we don't end up here in
-       that case.  */
-    warning (OPT_Wpointer_arith, "NULL used in arithmetic");
-  
-
   /* If CONVERTED is zero, both args will be converted to type RESULT_TYPE.
      Then the expression will be built.
      It will be given type FINAL_TYPE if that is nonzero;
@@ -5024,6 +5028,12 @@
       return rhs;
     }
 
+  if (type_unknown_p (rhs))
+    {
+      error ("no context to resolve type of %qE", rhs);
+      return error_mark_node;
+    }
+  
   return build2 (COMPOUND_EXPR, TREE_TYPE (rhs), lhs, rhs);
 }
 
diff -Nur a/gcc/c-ppoutput.c b/gcc/c-ppoutput.c
--- a/gcc/c-ppoutput.c	2008-09-23 19:47:32.000000000 +0200
+++ b/gcc/c-ppoutput.c	2010-01-25 09:50:29.105687718 +0100
@@ -521,6 +521,7 @@
 
   if (map != NULL)
     {
+      input_location = map->start_location;
       if (print.first_time)
 	{
 	  /* Avoid printing foo.i when the main file is foo.c.  */
diff -Nur a/gcc/cse.c b/gcc/cse.c
--- a/gcc/cse.c	2009-04-27 13:55:13.000000000 +0200
+++ b/gcc/cse.c	2010-01-25 09:50:29.105687718 +0100
@@ -5754,6 +5754,11 @@
       validate_change (object, &XEXP (x, i),
 		       cse_process_notes (XEXP (x, i), object, changed), 0);
 
+  /* Rebuild a PLUS expression in canonical form if the first operand
+     ends up as a constant.  */
+  if (code == PLUS && GET_CODE (XEXP (x, 0)) == CONST_INT)
+    return plus_constant (XEXP(x, 1), INTVAL (XEXP (x, 0)));
+
   return x;
 }
 
diff -Nur a/gcc/c-tree.h b/gcc/c-tree.h
--- a/gcc/c-tree.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/c-tree.h	2010-01-25 09:50:29.105687718 +0100
@@ -647,4 +647,8 @@
 extern void pedwarn_c90 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_CDIAG(3,4);
 extern void pedwarn_c99 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_CDIAG(3,4);
 
+extern bool c_cpp_error (cpp_reader *, int, location_t, unsigned int,
+			 const char *, va_list *)
+     ATTRIBUTE_GCC_CDIAG(5,0);
+
 #endif /* ! GCC_C_TREE_H */
diff -Nur a/gcc/c-typeck.c b/gcc/c-typeck.c
--- a/gcc/c-typeck.c	2009-04-08 13:59:36.000000000 +0200
+++ b/gcc/c-typeck.c	2010-01-25 09:50:29.105687718 +0100
@@ -1765,6 +1765,7 @@
   tree orig_exp;
   tree type = TREE_TYPE (exp);
   enum tree_code code = TREE_CODE (type);
+  tree promoted_type;
 
   /* Functions and arrays have been converted during parsing.  */
   gcc_assert (code != FUNCTION_TYPE);
@@ -1801,6 +1802,10 @@
   if (exp == error_mark_node)
     return error_mark_node;
 
+  promoted_type = targetm.promoted_type (type);
+  if (promoted_type)
+    return convert (promoted_type, exp);
+
   if (INTEGRAL_TYPE_P (type))
     return perform_integral_promotions (exp);
 
diff -Nur a/gcc/dbxout.c b/gcc/dbxout.c
--- a/gcc/dbxout.c	2009-07-07 22:46:41.000000000 +0200
+++ b/gcc/dbxout.c	2010-01-25 09:50:29.115687383 +0100
@@ -376,6 +376,7 @@
   dbxout_handle_pch,		         /* handle_pch */
   debug_nothing_rtx,		         /* var_location */
   debug_nothing_void,                    /* switch_text_section */
+  debug_nothing_tree_tree,		 /* set_name */
   0                                      /* start_end_main_source_file */
 };
 #endif /* DBX_DEBUGGING_INFO  */
@@ -408,6 +409,7 @@
   dbxout_handle_pch,		         /* handle_pch */
   debug_nothing_rtx,		         /* var_location */
   debug_nothing_void,                    /* switch_text_section */
+  debug_nothing_tree_tree,	         /* set_name */
   0                                      /* start_end_main_source_file */
 };
 #endif /* XCOFF_DEBUGGING_INFO  */
diff -Nur a/gcc/debug.c b/gcc/debug.c
--- a/gcc/debug.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/debug.c	2010-01-25 09:50:29.115687383 +0100
@@ -50,6 +50,7 @@
   debug_nothing_int,		         /* handle_pch */
   debug_nothing_rtx,		         /* var_location */
   debug_nothing_void,                    /* switch_text_section */
+  debug_nothing_tree_tree,		 /* set_name */
   0                                      /* start_end_main_source_file */
 };
 
@@ -67,6 +68,12 @@
 }
 
 void
+debug_nothing_tree_tree (tree t1 ATTRIBUTE_UNUSED,
+			 tree t2 ATTRIBUTE_UNUSED)
+{
+}
+
+void
 debug_nothing_tree_tree_tree_bool (tree t1 ATTRIBUTE_UNUSED,
 				   tree t2 ATTRIBUTE_UNUSED,
 				   tree t3 ATTRIBUTE_UNUSED,
diff -Nur a/gcc/debug.h b/gcc/debug.h
--- a/gcc/debug.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/debug.h	2010-01-25 09:50:29.115687383 +0100
@@ -126,6 +126,10 @@
      text sections.  */
   void (* switch_text_section) (void);
 
+  /* Called from grokdeclarator.  Replaces the anonymous name with the
+     type name.  */
+  void (* set_name) (tree, tree);
+
   /* This is 1 if the debug writer wants to see start and end commands for the
      main source files, and 0 otherwise.  */
   int start_end_main_source_file;
@@ -140,6 +144,7 @@
 extern void debug_nothing_int (unsigned int);
 extern void debug_nothing_int_int (unsigned int, unsigned int);
 extern void debug_nothing_tree (tree);
+extern void debug_nothing_tree_tree (tree, tree);
 extern void debug_nothing_tree_int (tree, int);
 extern void debug_nothing_tree_tree_tree_bool (tree, tree, tree, bool);
 extern bool debug_true_const_tree (const_tree);
diff -Nur a/gcc/defaults.h b/gcc/defaults.h
--- a/gcc/defaults.h	2009-07-11 21:06:26.000000000 +0200
+++ b/gcc/defaults.h	2010-01-25 09:50:29.115687383 +0100
@@ -902,7 +902,8 @@
 
 /* On most machines, the CFA coincides with the first incoming parm.  */
 #ifndef ARG_POINTER_CFA_OFFSET
-#define ARG_POINTER_CFA_OFFSET(FNDECL) FIRST_PARM_OFFSET (FNDECL)
+#define ARG_POINTER_CFA_OFFSET(FNDECL) \
+  (FIRST_PARM_OFFSET (FNDECL) + crtl->args.pretend_args_size)
 #endif
 
 /* On most machines, we use the CFA as DW_AT_frame_base.  */
diff -Nur a/gcc/diagnostic.c b/gcc/diagnostic.c
--- a/gcc/diagnostic.c	2008-09-03 03:00:04.000000000 +0200
+++ b/gcc/diagnostic.c	2010-01-25 09:50:29.115687383 +0100
@@ -126,6 +126,7 @@
   diagnostic->message.args_ptr = args;
   diagnostic->message.format_spec = msg;
   diagnostic->location = location;
+  diagnostic->override_column = 0;
   diagnostic->kind = kind;
   diagnostic->option_index = 0;
 }
@@ -153,6 +154,8 @@
   };
   const char *text = _(diagnostic_kind_text[diagnostic->kind]);
   expanded_location s = expand_location (diagnostic->location);
+  if (diagnostic->override_column)
+    s.column = diagnostic->override_column;
   gcc_assert (diagnostic->kind < DK_LAST_DIAGNOSTIC_KIND);
 
   return
diff -Nur a/gcc/diagnostic.h b/gcc/diagnostic.h
--- a/gcc/diagnostic.h	2008-08-09 01:57:19.000000000 +0200
+++ b/gcc/diagnostic.h	2010-01-25 09:50:29.115687383 +0100
@@ -41,6 +41,7 @@
 {
   text_info message;
   location_t location;
+  unsigned int override_column;
   /* TREE_BLOCK if the diagnostic is to be reported in some inline
      function inlined into other function, otherwise NULL.  */
   tree abstract_origin;
@@ -185,6 +186,10 @@
 
 #define report_diagnostic(D) diagnostic_report_diagnostic (global_dc, D)
 
+/* Override the column number to be used for reporting a
+   diagnostic.  */
+#define diagnostic_override_column(DI, COL) (DI)->override_column = (COL)
+
 /* Diagnostic related functions.  */
 extern void diagnostic_initialize (diagnostic_context *);
 extern void diagnostic_report_current_module (diagnostic_context *);
diff -Nur a/gcc/dwarf2out.c b/gcc/dwarf2out.c
--- a/gcc/dwarf2out.c	2009-06-03 19:32:45.000000000 +0200
+++ b/gcc/dwarf2out.c	2010-01-25 09:50:29.115687383 +0100
@@ -2474,6 +2474,12 @@
     insn = PATTERN (insn);
 
   dwarf2out_frame_debug_expr (insn, label);
+
+  /* Check again.  A parallel can save and update the same register.
+     We could probably check just once, here, but this is safer than
+     removing the check above.  */
+  if (clobbers_queued_reg_save (insn))
+    flush_queued_reg_saves ();
 }
 
 #endif
@@ -4598,6 +4604,7 @@
 static void dwarf2out_abstract_function (tree);
 static void dwarf2out_var_location (rtx);
 static void dwarf2out_begin_function (tree);
+static void dwarf2out_set_name (tree, tree);
 
 /* The debug hooks structure.  */
 
@@ -4631,6 +4638,7 @@
   debug_nothing_int,		/* handle_pch */
   dwarf2out_var_location,
   dwarf2out_switch_text_section,
+  dwarf2out_set_name,
   1                             /* start_end_main_source_file */
 };
 #endif
@@ -5975,12 +5983,9 @@
 		 (const char *)x2) == 0;
 }
 
-/* Add a string attribute value to a DIE.  */
-
-static inline void
-add_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind, const char *str)
+static struct indirect_string_node *
+find_AT_string (const char *str)
 {
-  dw_attr_node attr;
   struct indirect_string_node *node;
   void **slot;
 
@@ -6001,6 +6006,18 @@
     node = (struct indirect_string_node *) *slot;
 
   node->refcount++;
+  return node;
+}
+
+/* Add a string attribute value to a DIE.  */
+
+static inline void
+add_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind, const char *str)
+{
+  dw_attr_node attr;
+  struct indirect_string_node *node;
+
+  node = find_AT_string (str);
 
   attr.dw_attr = attr_kind;
   attr.dw_attr_val.val_class = dw_val_class_str;
@@ -6637,6 +6654,8 @@
 static inline var_loc_list *
 lookup_decl_loc (const_tree decl)
 {
+  if (!decl_loc_table)
+    return NULL;
   return (var_loc_list *)
     htab_find_with_hash (decl_loc_table, decl, DECL_UID (decl));
 }
@@ -13471,6 +13490,7 @@
   tree save_fn;
   tree context;
   int was_abstract = DECL_ABSTRACT (decl);
+  htab_t old_decl_loc_table;
 
   /* Make sure we have the actual abstract inline, not a clone.  */
   decl = DECL_ORIGIN (decl);
@@ -13480,6 +13500,12 @@
     /* We've already generated the abstract instance.  */
     return;
 
+  /* We can be called while recursively when seeing block defining inlined subroutine
+     DIE.  Be sure to not clobber the outer location table nor use it or we would
+     get locations in abstract instantces.  */
+  old_decl_loc_table = decl_loc_table;
+  decl_loc_table = NULL;
+
   /* Be sure we've emitted the in-class declaration DIE (if any) first, so
      we don't get confused by DECL_ABSTRACT.  */
   if (debug_info_level > DINFO_LEVEL_TERSE)
@@ -13501,6 +13527,7 @@
     set_decl_abstract_flags (decl, 0);
 
   current_function_decl = save_fn;
+  decl_loc_table = old_decl_loc_table;
   pop_cfun ();
 }
 
@@ -15796,6 +15823,31 @@
   return fd->emitted_number;
 }
 
+/* Replace DW_AT_name for the decl with name.  */
+ 
+static void
+dwarf2out_set_name (tree decl, tree name)
+{
+  dw_die_ref die;
+  dw_attr_ref attr;
+
+  die = TYPE_SYMTAB_DIE (decl);
+  if (!die)
+    return;
+
+  attr = get_AT (die, DW_AT_name);
+  if (attr)
+    {
+      struct indirect_string_node *node;
+
+      node = find_AT_string (dwarf2_name (name, 0));
+      /* replace the string.  */
+      attr->dw_attr_val.v.val_str = node;
+    }
+
+  else
+    add_name_attribute (die, dwarf2_name (name, 0));
+}
 /* Called by the final INSN scan whenever we see a var location.  We
    use it to drop labels in the right places, and throw the location in
    our lookup table.  */
diff -Nur a/gcc/except.c b/gcc/except.c
--- a/gcc/except.c	2009-03-07 17:02:30.000000000 +0100
+++ b/gcc/except.c	2010-01-25 09:50:29.115687383 +0100
@@ -3567,6 +3567,12 @@
 	 paths below go through assemble_integer, which would take
 	 care of this for us.  */
       STRIP_NOPS (type);
+      if (TREE_CODE (type) == POINTER_PLUS_EXPR)
+	{
+	  gcc_assert (TREE_CODE (TREE_OPERAND (type, 1)) == INTEGER_CST);
+	  type = TREE_OPERAND (type, 0);
+	  STRIP_NOPS (type);
+	}
       if (TREE_CODE (type) == ADDR_EXPR)
 	{
 	  type = TREE_OPERAND (type, 0);
diff -Nur a/gcc/explow.c b/gcc/explow.c
--- a/gcc/explow.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/explow.c	2010-01-25 09:50:29.115687383 +0100
@@ -1491,9 +1491,9 @@
    in which a scalar value of mode MODE was returned by a library call.  */
 
 rtx
-hard_libcall_value (enum machine_mode mode)
+hard_libcall_value (enum machine_mode mode, rtx fun)
 {
-  return LIBCALL_VALUE (mode);
+  return targetm.calls.libcall_value (mode, fun);
 }
 
 /* Look up the tree code for a given rtx code
diff -Nur a/gcc/expmed.c b/gcc/expmed.c
--- a/gcc/expmed.c	2009-01-16 19:56:47.000000000 +0100
+++ b/gcc/expmed.c	2010-01-25 09:50:29.115687383 +0100
@@ -103,7 +103,8 @@
 static int neg_cost[2][NUM_MACHINE_MODES];
 static int shift_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];
 static int shiftadd_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];
-static int shiftsub_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];
+static int shiftsub0_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];
+static int shiftsub1_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];
 static int mul_cost[2][NUM_MACHINE_MODES];
 static int sdiv_cost[2][NUM_MACHINE_MODES];
 static int udiv_cost[2][NUM_MACHINE_MODES];
@@ -130,7 +131,8 @@
     struct rtx_def shift;	rtunion shift_fld1;
     struct rtx_def shift_mult;	rtunion shift_mult_fld1;
     struct rtx_def shift_add;	rtunion shift_add_fld1;
-    struct rtx_def shift_sub;	rtunion shift_sub_fld1;
+    struct rtx_def shift_sub0;	rtunion shift_sub0_fld1;
+    struct rtx_def shift_sub1;	rtunion shift_sub1_fld1;
   } all;
 
   rtx pow2[MAX_BITS_PER_WORD];
@@ -201,9 +203,13 @@
   XEXP (&all.shift_add, 0) = &all.shift_mult;
   XEXP (&all.shift_add, 1) = &all.reg;
 
-  PUT_CODE (&all.shift_sub, MINUS);
-  XEXP (&all.shift_sub, 0) = &all.shift_mult;
-  XEXP (&all.shift_sub, 1) = &all.reg;
+  PUT_CODE (&all.shift_sub0, MINUS);
+  XEXP (&all.shift_sub0, 0) = &all.shift_mult;
+  XEXP (&all.shift_sub0, 1) = &all.reg;
+
+  PUT_CODE (&all.shift_sub1, MINUS);
+  XEXP (&all.shift_sub1, 0) = &all.reg;
+  XEXP (&all.shift_sub1, 1) = &all.shift_mult;
 
   for (speed = 0; speed < 2; speed++)
     {
@@ -226,7 +232,8 @@
 	  PUT_MODE (&all.shift, mode);
 	  PUT_MODE (&all.shift_mult, mode);
 	  PUT_MODE (&all.shift_add, mode);
-	  PUT_MODE (&all.shift_sub, mode);
+	  PUT_MODE (&all.shift_sub0, mode);
+	  PUT_MODE (&all.shift_sub1, mode);
 
 	  add_cost[speed][mode] = rtx_cost (&all.plus, SET, speed);
 	  neg_cost[speed][mode] = rtx_cost (&all.neg, SET, speed);
@@ -254,8 +261,8 @@
 	    }
 
 	  shift_cost[speed][mode][0] = 0;
-	  shiftadd_cost[speed][mode][0] = shiftsub_cost[speed][mode][0]
-	    = add_cost[speed][mode];
+	  shiftadd_cost[speed][mode][0] = shiftsub0_cost[speed][mode][0]
+	    = shiftsub1_cost[speed][mode][0] = add_cost[speed][mode];
 
 	  n = MIN (MAX_BITS_PER_WORD, GET_MODE_BITSIZE (mode));
 	  for (m = 1; m < n; m++)
@@ -265,7 +272,8 @@
 
 	      shift_cost[speed][mode][m] = rtx_cost (&all.shift, SET, speed);
 	      shiftadd_cost[speed][mode][m] = rtx_cost (&all.shift_add, SET, speed);
-	      shiftsub_cost[speed][mode][m] = rtx_cost (&all.shift_sub, SET, speed);
+	      shiftsub0_cost[speed][mode][m] = rtx_cost (&all.shift_sub0, SET, speed);
+	      shiftsub1_cost[speed][mode][m] = rtx_cost (&all.shift_sub1, SET, speed);
 	    }
 	}
     }
@@ -2397,6 +2405,7 @@
   struct mult_cost best_cost;
   struct mult_cost new_limit;
   int op_cost, op_latency;
+  unsigned HOST_WIDE_INT orig_t = t;
   unsigned HOST_WIDE_INT q;
   int maxm = MIN (BITS_PER_WORD, GET_MODE_BITSIZE (mode));
   int hash_index;
@@ -2542,6 +2551,38 @@
 	      best_alg->log[best_alg->ops] = m;
 	      best_alg->op[best_alg->ops] = alg_shift;
 	    }
+
+	  /* See if treating ORIG_T as a signed number yields a better
+	     sequence.  Try this sequence only for a negative ORIG_T
+	     as it would be useless for a non-negative ORIG_T.  */
+	  if ((HOST_WIDE_INT) orig_t < 0)
+	    {
+	      /* Shift ORIG_T as follows because a right shift of a
+		 negative-valued signed type is implementation
+		 defined.  */
+	      q = ~(~orig_t >> m);
+	      /* The function expand_shift will choose between a shift
+		 and a sequence of additions, so the observed cost is
+		 given as MIN (m * add_cost[speed][mode],
+		 shift_cost[speed][mode][m]).  */
+	      op_cost = m * add_cost[speed][mode];
+	      if (shift_cost[speed][mode][m] < op_cost)
+		op_cost = shift_cost[speed][mode][m];
+	      new_limit.cost = best_cost.cost - op_cost;
+	      new_limit.latency = best_cost.latency - op_cost;
+	      synth_mult (alg_in, q, &new_limit, mode);
+
+	      alg_in->cost.cost += op_cost;
+	      alg_in->cost.latency += op_cost;
+	      if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))
+		{
+		  struct algorithm *x;
+		  best_cost = alg_in->cost;
+		  x = alg_in, alg_in = best_alg, best_alg = x;
+		  best_alg->log[best_alg->ops] = m;
+		  best_alg->op[best_alg->ops] = alg_shift;
+		}
+	    }
 	}
       if (cache_hit)
 	goto done;
@@ -2604,6 +2645,29 @@
 	      best_alg->op[best_alg->ops] = alg_add_t_m2;
 	    }
 	}
+
+      /* We may be able to calculate a * -7, a * -15, a * -31, etc
+	 quickly with a - a * n for some appropriate constant n.  */
+      m = exact_log2 (-orig_t + 1);
+      if (m >= 0 && m < maxm)
+	{
+	  op_cost = shiftsub1_cost[speed][mode][m];
+	  new_limit.cost = best_cost.cost - op_cost;
+	  new_limit.latency = best_cost.latency - op_cost;
+	  synth_mult (alg_in, (unsigned HOST_WIDE_INT) (-orig_t + 1) >> m, &new_limit, mode);
+
+	  alg_in->cost.cost += op_cost;
+	  alg_in->cost.latency += op_cost;
+	  if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))
+	    {
+	      struct algorithm *x;
+	      best_cost = alg_in->cost;
+	      x = alg_in, alg_in = best_alg, best_alg = x;
+	      best_alg->log[best_alg->ops] = m;
+	      best_alg->op[best_alg->ops] = alg_sub_t_m2;
+	    }
+	}
+
       if (cache_hit)
 	goto done;
     }
@@ -2673,9 +2737,9 @@
 	     hardware the shift may be executed concurrently with the
 	     earlier steps in the algorithm.  */
 	  op_cost = add_cost[speed][mode] + shift_cost[speed][mode][m];
-	  if (shiftsub_cost[speed][mode][m] < op_cost)
+	  if (shiftsub0_cost[speed][mode][m] < op_cost)
 	    {
-	      op_cost = shiftsub_cost[speed][mode][m];
+	      op_cost = shiftsub0_cost[speed][mode][m];
 	      op_latency = op_cost;
 	    }
 	  else
@@ -2738,7 +2802,7 @@
       m = exact_log2 (q);
       if (m >= 0 && m < maxm)
 	{
-	  op_cost = shiftsub_cost[speed][mode][m];
+	  op_cost = shiftsub0_cost[speed][mode][m];
 	  new_limit.cost = best_cost.cost - op_cost;
 	  new_limit.latency = best_cost.latency - op_cost;
 	  synth_mult (alg_in, (t + 1) >> m, &new_limit, mode);
diff -Nur a/gcc/expr.c b/gcc/expr.c
--- a/gcc/expr.c	2009-06-16 16:28:47.000000000 +0200
+++ b/gcc/expr.c	2010-01-25 09:50:29.115687383 +0100
@@ -4391,6 +4391,29 @@
 
   /* Compute FROM and store the value in the rtx we got.  */
 
+  if (TREE_CODE (to) == MISALIGNED_INDIRECT_REF)
+    {
+      rtx insn;
+      rtx from_rtx;
+      enum insn_code icode;
+      enum machine_mode mode = GET_MODE (to_rtx);
+
+      icode = optab_handler (movmisalign_optab, mode)->insn_code;
+      gcc_assert (icode != CODE_FOR_nothing);
+
+      from_rtx = expand_expr (from, NULL_RTX, mode, EXPAND_NORMAL);
+      insn = GEN_FCN (icode) (to_rtx, from_rtx);
+      /* If that failed then force the source into a reg and try again.  */
+      if (!insn)
+	{
+	  from_rtx = copy_to_mode_reg(mode, from_rtx);
+	  insn = GEN_FCN (icode) (to_rtx, from_rtx);
+	  gcc_assert(insn);
+	}
+      emit_insn (insn);
+      return;
+    }
+
   push_temp_slots ();
   result = store_expr (from, to_rtx, 0, nontemporal);
   preserve_temp_slots (result);
@@ -7291,6 +7314,19 @@
       decl_rtl = DECL_RTL (exp);
       gcc_assert (decl_rtl);
       decl_rtl = copy_rtx (decl_rtl);
+      /* Record writes to register variables.  */
+      if (modifier == EXPAND_WRITE && REG_P(decl_rtl)
+	  && REGNO(decl_rtl) < FIRST_PSEUDO_REGISTER)
+	{
+	    int i = REGNO(decl_rtl);
+	    int nregs = hard_regno_nregs[i][GET_MODE(decl_rtl)];
+	    while (nregs)
+	      {
+		SET_HARD_REG_BIT(crtl->asm_clobbers, i);
+		i++;
+		nregs--;
+	      }
+	}
 
       /* Ensure variable marked as used even if it doesn't go through
 	 a parser.  If it hasn't be used yet, write out an external
@@ -7538,14 +7574,15 @@
 
 	/* Resolve the misalignment now, so that we don't have to remember
 	   to resolve it later.  Of course, this only works for reads.  */
-	/* ??? When we get around to supporting writes, we'll have to handle
-	   this in store_expr directly.  The vectorizer isn't generating
-	   those yet, however.  */
 	if (code == MISALIGNED_INDIRECT_REF)
 	  {
 	    int icode;
 	    rtx reg, insn;
 
+	    /* For writes produce a MEM, and expand_assignment will DTRT.  */
+	    if (modifier == EXPAND_WRITE)
+	      return temp;
+
 	    gcc_assert (modifier == EXPAND_NORMAL
 			|| modifier == EXPAND_STACK_PARM);
 
diff -Nur a/gcc/expr.h b/gcc/expr.h
--- a/gcc/expr.h	2009-03-17 18:46:23.000000000 +0100
+++ b/gcc/expr.h	2010-01-25 09:50:29.125687117 +0100
@@ -757,7 +757,7 @@
 
 /* Return an rtx that refers to the value returned by a library call
    in its original home.  This becomes invalid if any more code is emitted.  */
-extern rtx hard_libcall_value (enum machine_mode);
+extern rtx hard_libcall_value (enum machine_mode, rtx);
 
 /* Return the mode desired by operand N of a particular bitfield
    insert/extract insn, or MAX_MACHINE_MODE if no such insn is
diff -Nur a/gcc/final.c b/gcc/final.c
--- a/gcc/final.c	2008-12-10 09:46:40.000000000 +0100
+++ b/gcc/final.c	2010-01-25 09:50:29.125687117 +0100
@@ -891,6 +891,7 @@
       if (LABEL_P (insn))
 	{
 	  rtx next;
+	  bool next_is_jumptable;
 
 	  /* Merge in alignments computed by compute_alignments.  */
 	  log = LABEL_TO_ALIGNMENT (insn);
@@ -900,31 +901,30 @@
 	      max_skip = LABEL_TO_MAX_SKIP (insn);
 	    }
 
-	  log = LABEL_ALIGN (insn);
-	  if (max_log < log)
+	  next = next_nonnote_insn (insn);
+	  next_is_jumptable = next && JUMP_TABLE_DATA_P (next);
+	  if (!next_is_jumptable)
 	    {
-	      max_log = log;
-	      max_skip = LABEL_ALIGN_MAX_SKIP;
+	      log = LABEL_ALIGN (insn);
+	      if (max_log < log)
+		{
+		  max_log = log;
+		  max_skip = LABEL_ALIGN_MAX_SKIP;
+		}
 	    }
-	  next = next_nonnote_insn (insn);
 	  /* ADDR_VECs only take room if read-only data goes into the text
 	     section.  */
-	  if (JUMP_TABLES_IN_TEXT_SECTION
-	      || readonly_data_section == text_section)
-	    if (next && JUMP_P (next))
-	      {
-		rtx nextbody = PATTERN (next);
-		if (GET_CODE (nextbody) == ADDR_VEC
-		    || GET_CODE (nextbody) == ADDR_DIFF_VEC)
-		  {
-		    log = ADDR_VEC_ALIGN (next);
-		    if (max_log < log)
-		      {
-			max_log = log;
-			max_skip = LABEL_ALIGN_MAX_SKIP;
-		      }
-		  }
-	      }
+	  if ((JUMP_TABLES_IN_TEXT_SECTION
+	       || readonly_data_section == text_section)
+	      && next_is_jumptable)
+	    {
+	      log = ADDR_VEC_ALIGN (next);
+	      if (max_log < log)
+		{
+		  max_log = log;
+		  max_skip = LABEL_ALIGN_MAX_SKIP;
+		}
+	    }
 	  LABEL_TO_ALIGNMENT (insn) = max_log;
 	  LABEL_TO_MAX_SKIP (insn) = max_skip;
 	  max_log = 0;
@@ -2013,48 +2013,41 @@
       app_disable ();
 
       next = next_nonnote_insn (insn);
-      if (next != 0 && JUMP_P (next))
+      /* If this label is followed by a jump-table, make sure we put
+	 the label in the read-only section.  Also possibly write the
+	 label and jump table together.  */
+      if (next != 0 && JUMP_TABLE_DATA_P (next))
 	{
-	  rtx nextbody = PATTERN (next);
-
-	  /* If this label is followed by a jump-table,
-	     make sure we put the label in the read-only section.  Also
-	     possibly write the label and jump table together.  */
-
-	  if (GET_CODE (nextbody) == ADDR_VEC
-	      || GET_CODE (nextbody) == ADDR_DIFF_VEC)
-	    {
 #if defined(ASM_OUTPUT_ADDR_VEC) || defined(ASM_OUTPUT_ADDR_DIFF_VEC)
-	      /* In this case, the case vector is being moved by the
-		 target, so don't output the label at all.  Leave that
-		 to the back end macros.  */
+	  /* In this case, the case vector is being moved by the
+	     target, so don't output the label at all.  Leave that
+	     to the back end macros.  */
 #else
-	      if (! JUMP_TABLES_IN_TEXT_SECTION)
-		{
-		  int log_align;
+	  if (! JUMP_TABLES_IN_TEXT_SECTION)
+	    {
+	      int log_align;
 
-		  switch_to_section (targetm.asm_out.function_rodata_section
-				     (current_function_decl));
+	      switch_to_section (targetm.asm_out.function_rodata_section
+				 (current_function_decl));
 
 #ifdef ADDR_VEC_ALIGN
-		  log_align = ADDR_VEC_ALIGN (next);
+	      log_align = ADDR_VEC_ALIGN (next);
 #else
-		  log_align = exact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT);
+	      log_align = exact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT);
 #endif
-		  ASM_OUTPUT_ALIGN (file, log_align);
-		}
-	      else
-		switch_to_section (current_function_section ());
+	      ASM_OUTPUT_ALIGN (file, log_align);
+	    }
+	  else
+	    switch_to_section (current_function_section ());
 
 #ifdef ASM_OUTPUT_CASE_LABEL
-	      ASM_OUTPUT_CASE_LABEL (file, "L", CODE_LABEL_NUMBER (insn),
-				     next);
+	  ASM_OUTPUT_CASE_LABEL (file, "L", CODE_LABEL_NUMBER (insn),
+				 next);
 #else
-	      targetm.asm_out.internal_label (file, "L", CODE_LABEL_NUMBER (insn));
+	  targetm.asm_out.internal_label (file, "L", CODE_LABEL_NUMBER (insn));
 #endif
 #endif
-	      break;
-	    }
+	  break;
 	}
       if (LABEL_ALT_ENTRY_P (insn))
 	output_alternate_entry_point (file, insn);
diff -Nur a/gcc/fold-const.c b/gcc/fold-const.c
--- a/gcc/fold-const.c	2009-07-15 13:23:22.000000000 +0200
+++ b/gcc/fold-const.c	2010-01-25 09:50:29.125687117 +0100
@@ -2289,7 +2289,24 @@
   real_convert (&value, TYPE_MODE (type), &TREE_REAL_CST (arg1));
   t = build_real (type, value);
 
-  TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1);
+  /* If converting an infinity or NAN to a representation that doesn't
+     have one, set the overflow bit so that we can produce some kind of
+     error message at the appropriate point if necessary.  It's not the
+     most user-friendly message, but it's better than nothing.  */
+  if (REAL_VALUE_ISINF (TREE_REAL_CST (arg1))
+      && !MODE_HAS_INFINITIES (TYPE_MODE (type)))
+    TREE_OVERFLOW (t) = 1;
+  else if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg1))
+	   && !MODE_HAS_NANS (TYPE_MODE (type)))
+    TREE_OVERFLOW (t) = 1;
+  /* Regular overflow, conversion produced an infinity in a mode that
+     can't represent them.  */
+  else if (!MODE_HAS_INFINITIES (TYPE_MODE (type))
+	   && REAL_VALUE_ISINF (value)
+	   && !REAL_VALUE_ISINF (TREE_REAL_CST (arg1)))
+    TREE_OVERFLOW (t) = 1;
+  else
+    TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1);
   return t;
 }
 
diff -Nur a/gcc/fortran/cpp.c b/gcc/fortran/cpp.c
--- a/gcc/fortran/cpp.c	2008-12-09 20:25:55.000000000 +0100
+++ b/gcc/fortran/cpp.c	2010-01-25 09:50:29.125687117 +0100
@@ -137,6 +137,9 @@
 static void cb_ident (cpp_reader *, source_location, const cpp_string *);
 static void cb_used_define (cpp_reader *, source_location, cpp_hashnode *);
 static void cb_used_undef (cpp_reader *, source_location, cpp_hashnode *);
+static bool cb_cpp_error (cpp_reader *, int, location_t, unsigned int,
+			  const char *, va_list *)
+     ATTRIBUTE_GCC_DIAG(5,0);
 void pp_dir_change (cpp_reader *, const char *);
 
 static int dump_macro (cpp_reader *, cpp_hashnode *, void *);
@@ -452,7 +455,6 @@
   cpp_option->cplusplus_comments = 0;
 
   cpp_option->pedantic = pedantic;
-  cpp_option->inhibit_warnings = inhibit_warnings;
 
   cpp_option->dollars_in_ident = gfc_option.flag_dollar_ok;
   cpp_option->discard_comments = gfc_cpp_option.discard_comments;
@@ -465,9 +467,6 @@
 
   cpp_post_options (cpp_in);
 
-  /* If an error has occurred in cpplib, note it so we fail immediately.  */
-  errorcount += cpp_errors (cpp_in);
-
   gfc_cpp_register_include_paths ();
 }
 
@@ -482,6 +481,7 @@
   cb->line_change = cb_line_change;
   cb->ident = cb_ident;
   cb->def_pragma = cb_def_pragma;
+  cb->error = cb_cpp_error;
 
   if (gfc_cpp_option.dump_includes)
     cb->include = cb_include;
@@ -961,6 +961,57 @@
   cpp_define_queue = q;
 }
 
+/* Callback from cpp_error for PFILE to print diagnostics from the
+   preprocessor.  The diagnostic is of type LEVEL, at location
+   LOCATION, with column number possibly overridden by COLUMN_OVERRIDE
+   if not zero; MSG is the translated message and AP the arguments.
+   Returns true if a diagnostic was emitted, false otherwise.  */
+
+static bool
+cb_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level,
+	      location_t location, unsigned int column_override,
+	      const char *msg, va_list *ap)
+{
+  diagnostic_info diagnostic;
+  diagnostic_t dlevel;
+  int save_warn_system_headers = warn_system_headers;
+  bool ret;
+
+  switch (level)
+    {
+    case CPP_DL_WARNING_SYSHDR:
+      warn_system_headers = 1;
+      /* Fall through.  */
+    case CPP_DL_WARNING:
+      dlevel = DK_WARNING;
+      break;
+    case CPP_DL_PEDWARN:
+      dlevel = DK_PEDWARN;
+      break;
+    case CPP_DL_ERROR:
+      dlevel = DK_ERROR;
+      break;
+    case CPP_DL_ICE:
+      dlevel = DK_ICE;
+      break;
+    case CPP_DL_NOTE:
+      dlevel = DK_NOTE;
+      break;
+    case CPP_DL_FATAL:
+      dlevel = DK_FATAL;
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  diagnostic_set_info_translated (&diagnostic, msg, ap,
+				  location, dlevel);
+  if (column_override)
+    diagnostic_override_column (&diagnostic, column_override);
+  ret = report_diagnostic (&diagnostic);
+  if (level == CPP_DL_WARNING_SYSHDR)
+    warn_system_headers = save_warn_system_headers;
+  return ret;
+}
 
 /* Callback called when -fworking-director and -E to emit working
    directory in cpp output file.  */
diff -Nur a/gcc/fortran/gfortran.info b/gcc/fortran/gfortran.info
--- a/gcc/fortran/gfortran.info	2009-07-22 10:33:04.000000000 +0200
+++ b/gcc/fortran/gfortran.info	1970-01-01 01:00:00.000000000 +0100
@@ -1,15040 +0,0 @@
-This is doc/gfortran.info, produced by makeinfo version 4.13 from
-/d/gcc-4.4.1/gcc-4.4.1/gcc/fortran/gfortran.texi.
-
-Copyright (C) 1999-2008 Free Software Foundation, Inc.
-
-   Permission is granted to copy, distribute and/or modify this document
-under the terms of the GNU Free Documentation License, Version 1.2 or
-any later version published by the Free Software Foundation; with the
-Invariant Sections being "Funding Free Software", the Front-Cover Texts
-being (a) (see below), and with the Back-Cover Texts being (b) (see
-below).  A copy of the license is included in the section entitled "GNU
-Free Documentation License".
-
-   (a) The FSF's Front-Cover Text is:
-
-   A GNU Manual
-
-   (b) The FSF's Back-Cover Text is:
-
-   You have freedom to copy and modify this GNU Manual, like GNU
-software.  Copies published by the Free Software Foundation raise
-funds for GNU development.
-
-INFO-DIR-SECTION Software development
-START-INFO-DIR-ENTRY
-* gfortran: (gfortran).                  The GNU Fortran Compiler.
-END-INFO-DIR-ENTRY
-   This file documents the use and the internals of the GNU Fortran
-compiler, (`gfortran').
-
-   Published by the Free Software Foundation 51 Franklin Street, Fifth
-Floor Boston, MA 02110-1301 USA
-
-   Copyright (C) 1999-2008 Free Software Foundation, Inc.
-
-   Permission is granted to copy, distribute and/or modify this document
-under the terms of the GNU Free Documentation License, Version 1.2 or
-any later version published by the Free Software Foundation; with the
-Invariant Sections being "Funding Free Software", the Front-Cover Texts
-being (a) (see below), and with the Back-Cover Texts being (b) (see
-below).  A copy of the license is included in the section entitled "GNU
-Free Documentation License".
-
-   (a) The FSF's Front-Cover Text is:
-
-   A GNU Manual
-
-   (b) The FSF's Back-Cover Text is:
-
-   You have freedom to copy and modify this GNU Manual, like GNU
-software.  Copies published by the Free Software Foundation raise
-funds for GNU development.
-
-
-File: gfortran.info,  Node: Top,  Next: Introduction,  Up: (dir)
-
-Introduction
-************
-
-This manual documents the use of `gfortran', the GNU Fortran compiler.
-You can find in this manual how to invoke `gfortran', as well as its
-features and incompatibilities.
-
-* Menu:
-
-* Introduction::
-
-Part I: Invoking GNU Fortran
-* Invoking GNU Fortran:: Command options supported by `gfortran'.
-* Runtime::              Influencing runtime behavior with environment variables.
-
-Part II: Language Reference
-* Fortran 2003 and 2008 status::  Fortran 2003 and 2008 features supported by GNU Fortran.
-* Compiler Characteristics::      KIND type parameters supported.
-* Extensions::           Language extensions implemented by GNU Fortran.
-* Intrinsic Procedures:: Intrinsic procedures supported by GNU Fortran.
-* Intrinsic Modules::    Intrinsic modules supported by GNU Fortran.
-
-* Contributing::         How you can help.
-* Copying::              GNU General Public License says
-                         how you can copy and share GNU Fortran.
-* GNU Free Documentation License::
-                         How you can copy and share this manual.
-* Funding::              How to help assure continued work for free software.
-* Option Index::         Index of command line options
-* Keyword Index::        Index of concepts
-
-
-File: gfortran.info,  Node: Introduction,  Next: Invoking GNU Fortran,  Prev: Top,  Up: Top
-
-1 Introduction
-**************
-
-The GNU Fortran compiler front end was designed initially as a free
-replacement for, or alternative to, the unix `f95' command; `gfortran'
-is the command you'll use to invoke the compiler.
-
-* Menu:
-
-* About GNU Fortran::    What you should know about the GNU Fortran compiler.
-* GNU Fortran and GCC::  You can compile Fortran, C, or other programs.
-* Preprocessing and conditional compilation:: The Fortran preprocessor
-* GNU Fortran and G77::  Why we chose to start from scratch.
-* Project Status::       Status of GNU Fortran, roadmap, proposed extensions.
-* Standards::            Standards supported by GNU Fortran.
-
-
-File: gfortran.info,  Node: About GNU Fortran,  Next: GNU Fortran and GCC,  Up: Introduction
-
-1.1 About GNU Fortran
-=====================
-
-The GNU Fortran compiler is still in an early state of development.  It
-can generate code for most constructs and expressions, but much work
-remains to be done.
-
-   When the GNU Fortran compiler is finished, it will do everything you
-expect from any decent compiler:
-
-   * Read a user's program, stored in a file and containing
-     instructions written in Fortran 77, Fortran 90, Fortran 95,
-     Fortran 2003 or Fortran 2008.  This file contains "source code".
-
-   * Translate the user's program into instructions a computer can
-     carry out more quickly than it takes to translate the instructions
-     in the first place.  The result after compilation of a program is
-     "machine code", code designed to be efficiently translated and
-     processed by a machine such as your computer.  Humans usually
-     aren't as good writing machine code as they are at writing Fortran
-     (or C++, Ada, or Java), because it is easy to make tiny mistakes
-     writing machine code.
-
-   * Provide the user with information about the reasons why the
-     compiler is unable to create a binary from the source code.
-     Usually this will be the case if the source code is flawed.  The
-     Fortran 90 standard requires that the compiler can point out
-     mistakes to the user.  An incorrect usage of the language causes
-     an "error message".
-
-     The compiler will also attempt to diagnose cases where the user's
-     program contains a correct usage of the language, but instructs
-     the computer to do something questionable.  This kind of
-     diagnostics message is called a "warning message".
-
-   * Provide optional information about the translation passes from the
-     source code to machine code.  This can help a user of the compiler
-     to find the cause of certain bugs which may not be obvious in the
-     source code, but may be more easily found at a lower level
-     compiler output.  It also helps developers to find bugs in the
-     compiler itself.
-
-   * Provide information in the generated machine code that can make it
-     easier to find bugs in the program (using a debugging tool, called
-     a "debugger", such as the GNU Debugger `gdb').
-
-   * Locate and gather machine code already generated to perform
-     actions requested by statements in the user's program.  This
-     machine code is organized into "modules" and is located and
-     "linked" to the user program.
-
-   The GNU Fortran compiler consists of several components:
-
-   * A version of the `gcc' command (which also might be installed as
-     the system's `cc' command) that also understands and accepts
-     Fortran source code.  The `gcc' command is the "driver" program for
-     all the languages in the GNU Compiler Collection (GCC); With `gcc',
-     you can compile the source code of any language for which a front
-     end is available in GCC.
-
-   * The `gfortran' command itself, which also might be installed as the
-     system's `f95' command.  `gfortran' is just another driver program,
-     but specifically for the Fortran compiler only.  The difference
-     with `gcc' is that `gfortran' will automatically link the correct
-     libraries to your program.
-
-   * A collection of run-time libraries.  These libraries contain the
-     machine code needed to support capabilities of the Fortran
-     language that are not directly provided by the machine code
-     generated by the `gfortran' compilation phase, such as intrinsic
-     functions and subroutines, and routines for interaction with files
-     and the operating system.
-
-   * The Fortran compiler itself, (`f951').  This is the GNU Fortran
-     parser and code generator, linked to and interfaced with the GCC
-     backend library.  `f951' "translates" the source code to assembler
-     code.  You would typically not use this program directly; instead,
-     the `gcc' or `gfortran' driver programs will call it for you.
-
-
-File: gfortran.info,  Node: GNU Fortran and GCC,  Next: Preprocessing and conditional compilation,  Prev: About GNU Fortran,  Up: Introduction
-
-1.2 GNU Fortran and GCC
-=======================
-
-GNU Fortran is a part of GCC, the "GNU Compiler Collection".  GCC
-consists of a collection of front ends for various languages, which
-translate the source code into a language-independent form called
-"GENERIC".  This is then processed by a common middle end which
-provides optimization, and then passed to one of a collection of back
-ends which generate code for different computer architectures and
-operating systems.
-
-   Functionally, this is implemented with a driver program (`gcc')
-which provides the command-line interface for the compiler.  It calls
-the relevant compiler front-end program (e.g., `f951' for Fortran) for
-each file in the source code, and then calls the assembler and linker
-as appropriate to produce the compiled output. In a copy of GCC which
-has been compiled with Fortran language support enabled, `gcc' will
-recognize files with `.f', `.for', `.ftn', `.f90', `.f95', `.f03' and
-`.f08' extensions as Fortran source code, and compile it accordingly. A
-`gfortran' driver program is also provided, which is identical to `gcc'
-except that it automatically links the Fortran runtime libraries into
-the compiled program.
-
-   Source files with `.f', `.for', `.fpp', `.ftn', `.F', `.FOR',
-`.FPP', and `.FTN' extensions are treated as fixed form.  Source files
-with `.f90', `.f95', `.f03', `.f08', `.F90', `.F95', `.F03' and `.F08'
-extensions are treated as free form.  The capitalized versions of
-either form are run through preprocessing. Source files with the lower
-case `.fpp' extension are also run through preprocessing.
-
-   This manual specifically documents the Fortran front end, which
-handles the programming language's syntax and semantics.  The aspects
-of GCC which relate to the optimization passes and the back-end code
-generation are documented in the GCC manual; see *note Introduction:
-(gcc)Top.  The two manuals together provide a complete reference for
-the GNU Fortran compiler.
-
-
-File: gfortran.info,  Node: Preprocessing and conditional compilation,  Next: GNU Fortran and G77,  Prev: GNU Fortran and GCC,  Up: Introduction
-
-1.3 Preprocessing and conditional compilation
-=============================================
-
-Many Fortran compilers including GNU Fortran allow passing the source
-code through a C preprocessor (CPP; sometimes also called the Fortran
-preprocessor, FPP) to allow for conditional compilation. In the case of
-GNU Fortran, this is the GNU C Preprocessor in the traditional mode. On
-systems with case-preserving file names, the preprocessor is
-automatically invoked if the filename extension is `.F', `.FOR',
-`.FTN', `.fpp', `.FPP', `.F90', `.F95', `.F03' or `.F08'. To manually
-invoke the preprocessor on any file, use `-cpp', to disable
-preprocessing on files where the preprocessor is run automatically, use
-`-nocpp'.
-
-   If a preprocessed file includes another file with the Fortran
-`INCLUDE' statement, the included file is not preprocessed. To
-preprocess included files, use the equivalent preprocessor statement
-`#include'.
-
-   If GNU Fortran invokes the preprocessor, `__GFORTRAN__' is defined
-and `__GNUC__', `__GNUC_MINOR__' and `__GNUC_PATCHLEVEL__' can be used
-to determine the version of the compiler. See *note Overview: (cpp)Top.
-for details.
-
-   While CPP is the de-facto standard for preprocessing Fortran code,
-Part 3 of the Fortran 95 standard (ISO/IEC 1539-3:1998) defines
-Conditional Compilation, which is not widely used and not directly
-supported by the GNU Fortran compiler. You can use the program coco to
-preprocess such files (`http://users.erols.com/dnagle/coco.html').
-
-
-File: gfortran.info,  Node: GNU Fortran and G77,  Next: Project Status,  Prev: Preprocessing and conditional compilation,  Up: Introduction
-
-1.4 GNU Fortran and G77
-=======================
-
-The GNU Fortran compiler is the successor to `g77', the Fortran 77
-front end included in GCC prior to version 4.  It is an entirely new
-program that has been designed to provide Fortran 95 support and
-extensibility for future Fortran language standards, as well as
-providing backwards compatibility for Fortran 77 and nearly all of the
-GNU language extensions supported by `g77'.
-
-
-File: gfortran.info,  Node: Project Status,  Next: Standards,  Prev: GNU Fortran and G77,  Up: Introduction
-
-1.5 Project Status
-==================
-
-     As soon as `gfortran' can parse all of the statements correctly,
-     it will be in the "larva" state.  When we generate code, the
-     "puppa" state.  When `gfortran' is done, we'll see if it will be a
-     beautiful butterfly, or just a big bug....
-
-     -Andy Vaught, April 2000
-
-   The start of the GNU Fortran 95 project was announced on the GCC
-homepage in March 18, 2000 (even though Andy had already been working
-on it for a while, of course).
-
-   The GNU Fortran compiler is able to compile nearly all
-standard-compliant Fortran 95, Fortran 90, and Fortran 77 programs,
-including a number of standard and non-standard extensions, and can be
-used on real-world programs.  In particular, the supported extensions
-include OpenMP, Cray-style pointers, and several Fortran 2003 and
-Fortran 2008 features such as enumeration, stream I/O, and some of the
-enhancements to allocatable array support from TR 15581.  However, it is
-still under development and has a few remaining rough edges.
-
-   At present, the GNU Fortran compiler passes the NIST Fortran 77 Test
-Suite (http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html), and
-produces acceptable results on the LAPACK Test Suite
-(http://www.netlib.org/lapack/faq.html#1.21).  It also provides
-respectable performance on the Polyhedron Fortran compiler benchmarks
-(http://www.polyhedron.com/pb05.html) and the Livermore Fortran Kernels
-test
-(http://www.llnl.gov/asci_benchmarks/asci/limited/lfk/README.html).  It
-has been used to compile a number of large real-world programs,
-including the HIRLAM weather-forecasting code
-(http://mysite.verizon.net/serveall/moene.pdf) and the Tonto quantum
-chemistry package (http://www.theochem.uwa.edu.au/tonto/); see
-`http://gcc.gnu.org/wiki/GfortranApps' for an extended list.
-
-   Among other things, the GNU Fortran compiler is intended as a
-replacement for G77.  At this point, nearly all programs that could be
-compiled with G77 can be compiled with GNU Fortran, although there are
-a few minor known regressions.
-
-   The primary work remaining to be done on GNU Fortran falls into three
-categories: bug fixing (primarily regarding the treatment of invalid
-code and providing useful error messages), improving the compiler
-optimizations and the performance of compiled code, and extending the
-compiler to support future standards--in particular, Fortran 2003.
-
-
-File: gfortran.info,  Node: Standards,  Prev: Project Status,  Up: Introduction
-
-1.6 Standards
-=============
-
-The GNU Fortran compiler implements ISO/IEC 1539:1997 (Fortran 95).  As
-such, it can also compile essentially all standard-compliant Fortran 90
-and Fortran 77 programs.   It also supports the ISO/IEC TR-15581
-enhancements to allocatable arrays, and the OpenMP Application Program
-Interface v2.5 (http://www.openmp.org/drupal/mp-documents/spec25.pdf)
-specification.
-
-   In the future, the GNU Fortran compiler will also support ISO/IEC
-1539-1:2004 (Fortran 2003) and future Fortran standards. Partial support
-of that standard is already provided; the current status of Fortran 2003
-support is reported in the *note Fortran 2003 status:: section of the
-documentation.
-
-   The next version of the Fortran standard after Fortran 2003 is
-currently being developed and the GNU Fortran compiler supports some of
-its new features. This support is based on the latest draft of the
-standard (available from `http://www.nag.co.uk/sc22wg5/') and no
-guarantee of future compatibility is made, as the final standard might
-differ from the draft. For more information, see the *note Fortran 2008
-status:: section.
-
-
-File: gfortran.info,  Node: Invoking GNU Fortran,  Next: Runtime,  Prev: Introduction,  Up: Top
-
-2 GNU Fortran Command Options
-*****************************
-
-The `gfortran' command supports all the options supported by the `gcc'
-command.  Only options specific to GNU Fortran are documented here.
-
-   *Note GCC Command Options: (gcc)Invoking GCC, for information on the
-non-Fortran-specific aspects of the `gcc' command (and, therefore, the
-`gfortran' command).
-
-   All GCC and GNU Fortran options are accepted both by `gfortran' and
-by `gcc' (as well as any other drivers built at the same time, such as
-`g++'), since adding GNU Fortran to the GCC distribution enables
-acceptance of GNU Fortran options by all of the relevant drivers.
-
-   In some cases, options have positive and negative forms; the
-negative form of `-ffoo' would be `-fno-foo'.  This manual documents
-only one of these two forms, whichever one is not the default.
-
-* Menu:
-
-* Option Summary::      Brief list of all `gfortran' options,
-                        without explanations.
-* Fortran Dialect Options::  Controlling the variant of Fortran language
-                             compiled.
-* Preprocessing Options::  Enable and customize preprocessing.
-* Error and Warning Options::     How picky should the compiler be?
-* Debugging Options::   Symbol tables, measurements, and debugging dumps.
-* Directory Options::   Where to find module files
-* Link Options ::       Influencing the linking step
-* Runtime Options::     Influencing runtime behavior
-* Code Gen Options::    Specifying conventions for function calls, data layout
-                        and register usage.
-* Environment Variables:: Environment variables that affect `gfortran'.
-
-
-File: gfortran.info,  Node: Option Summary,  Next: Fortran Dialect Options,  Up: Invoking GNU Fortran
-
-2.1 Option summary
-==================
-
-Here is a summary of all the options specific to GNU Fortran, grouped
-by type.  Explanations are in the following sections.
-
-_Fortran Language Options_
-     *Note Options controlling Fortran dialect: Fortran Dialect Options.
-          -fall-intrinsics  -ffree-form  -fno-fixed-form
-          -fdollar-ok  -fimplicit-none  -fmax-identifier-length
-          -std=STD -fd-lines-as-code  -fd-lines-as-comments
-          -ffixed-line-length-N  -ffixed-line-length-none
-          -ffree-line-length-N  -ffree-line-length-none
-          -fdefault-double-8  -fdefault-integer-8  -fdefault-real-8
-          -fcray-pointer  -fopenmp  -fno-range-check -fbackslash -fmodule-private
-
-_Preprocessing Options_
-     *Note Enable and customize preprocessing: Preprocessing Options.
-          -cpp -dD -dI -dM -dN -dU -fworking-directory
-          -imultilib DIR -iprefix FILE -isysroot DIR
-          -iquote -isystem DIR -nocpp -nostdinc -undef
-          -AQUESTION=ANSWER -A-QUESTION[=ANSWER]
-          -C -CC -DMACRO[=DEFN] -UMACRO -H -P
-
-_Error and Warning Options_
-     *Note Options to request or suppress errors and warnings: Error
-     and Warning Options.
-          -fmax-errors=N
-          -fsyntax-only  -pedantic  -pedantic-errors
-          -Wall  -Waliasing  -Wampersand  -Warray-bounds -Wcharacter-truncation
-          -Wconversion -Wimplicit-interface  -Wline-truncation  -Wintrinsics-std
-          -Wsurprising -Wno-tabs  -Wunderflow -Wunused-parameter -Wintrinsics-shadow
-          -Wno-align-commons
-
-_Debugging Options_
-     *Note Options for debugging your program or GNU Fortran: Debugging
-     Options.
-          -fdump-parse-tree  -ffpe-trap=LIST
-          -fdump-core -fbacktrace
-
-_Directory Options_
-     *Note Options for directory search: Directory Options.
-          -IDIR  -JDIR  -MDIR
-          -fintrinsic-modules-path DIR
-
-_Link Options_
-     *Note Options for influencing the linking step: Link Options.
-          -static-libgfortran
-
-_Runtime Options_
-     *Note Options for influencing runtime behavior: Runtime Options.
-          -fconvert=CONVERSION  -fno-range-check
-          -frecord-marker=LENGTH   -fmax-subrecord-length=LENGTH
-          -fsign-zero
-
-_Code Generation Options_
-     *Note Options for code generation conventions: Code Gen Options.
-          -fno-automatic  -ff2c  -fno-underscoring
-          -fsecond-underscore
-          -fbounds-check -fcheck-array-temporaries  -fmax-array-constructor =N
-          -fmax-stack-var-size=N
-          -fpack-derived  -frepack-arrays  -fshort-enums  -fexternal-blas
-          -fblas-matmul-limit=N -frecursive -finit-local-zero
-          -finit-integer=N -finit-real=<ZERO|INF|-INF|NAN>
-          -finit-logical=<TRUE|FALSE> -finit-character=N -fno-align-commons
-
-
-* Menu:
-
-* Fortran Dialect Options::  Controlling the variant of Fortran language
-                             compiled.
-* Preprocessing Options::  Enable and customize preprocessing.
-* Error and Warning Options::     How picky should the compiler be?
-* Debugging Options::   Symbol tables, measurements, and debugging dumps.
-* Directory Options::   Where to find module files
-* Link Options ::       Influencing the linking step
-* Runtime Options::     Influencing runtime behavior
-* Code Gen Options::    Specifying conventions for function calls, data layout
-                        and register usage.
-
-
-File: gfortran.info,  Node: Fortran Dialect Options,  Next: Preprocessing Options,  Prev: Option Summary,  Up: Invoking GNU Fortran
-
-2.2 Options controlling Fortran dialect
-=======================================
-
-The following options control the details of the Fortran dialect
-accepted by the compiler:
-
-`-ffree-form'
-
-`-ffixed-form'
-     Specify the layout used by the source file.  The free form layout
-     was introduced in Fortran 90.  Fixed form was traditionally used in
-     older Fortran programs.  When neither option is specified, the
-     source form is determined by the file extension.
-
-`-fall-intrinsics'
-     This option causes all intrinsic procedures (including the
-     GNU-specific extensions) to be accepted.  This can be useful with
-     `-std=f95' to force standard-compliance but get access to the full
-     range of intrinsics available with `gfortran'.  As a consequence,
-     `-Wintrinsics-std' will be ignored and no user-defined procedure
-     with the same name as any intrinsic will be called except when it
-     is explicitly declared `EXTERNAL'.
-
-`-fd-lines-as-code'
-
-`-fd-lines-as-comments'
-     Enable special treatment for lines beginning with `d' or `D' in
-     fixed form sources.  If the `-fd-lines-as-code' option is given
-     they are treated as if the first column contained a blank.  If the
-     `-fd-lines-as-comments' option is given, they are treated as
-     comment lines.
-
-`-fdefault-double-8'
-     Set the `DOUBLE PRECISION' type to an 8 byte wide type.  If
-     `-fdefault-real-8' is given, `DOUBLE PRECISION' would instead be
-     promoted to 16 bytes if possible, and `-fdefault-double-8' can be
-     used to prevent this.  The kind of real constants like `1.d0' will
-     not be changed by `-fdefault-real-8' though, so also
-     `-fdefault-double-8' does not affect it.
-
-`-fdefault-integer-8'
-     Set the default integer and logical types to an 8 byte wide type.
-     Do nothing if this is already the default.  This option also
-     affects the kind of integer constants like `42'.
-
-`-fdefault-real-8'
-     Set the default real type to an 8 byte wide type.  Do nothing if
-     this is already the default.  This option also affects the kind of
-     non-double real constants like `1.0', and does promote the default
-     width of `DOUBLE PRECISION' to 16 bytes if possible, unless
-     `-fdefault-double-8' is given, too.
-
-`-fdollar-ok'
-     Allow `$' as a valid character in a symbol name.
-
-`-fbackslash'
-     Change the interpretation of backslashes in string literals from a
-     single backslash character to "C-style" escape characters. The
-     following combinations are expanded `\a', `\b', `\f', `\n', `\r',
-     `\t', `\v', `\\', and `\0' to the ASCII characters alert,
-     backspace, form feed, newline, carriage return, horizontal tab,
-     vertical tab, backslash, and NUL, respectively.  Additionally,
-     `\x'NN, `\u'NNNN and `\U'NNNNNNNN (where each N is a hexadecimal
-     digit) are translated into the Unicode characters corresponding to
-     the specified code points. All other combinations of a character
-     preceded by \ are unexpanded.
-
-`-fmodule-private'
-     Set the default accessibility of module entities to `PRIVATE'.
-     Use-associated entities will not be accessible unless they are
-     explicitly declared as `PUBLIC'.
-
-`-ffixed-line-length-N'
-     Set column after which characters are ignored in typical fixed-form
-     lines in the source file, and through which spaces are assumed (as
-     if padded to that length) after the ends of short fixed-form lines.
-
-     Popular values for N include 72 (the standard and the default), 80
-     (card image), and 132 (corresponding to "extended-source" options
-     in some popular compilers).  N may also be `none', meaning that
-     the entire line is meaningful and that continued character
-     constants never have implicit spaces appended to them to fill out
-     the line.  `-ffixed-line-length-0' means the same thing as
-     `-ffixed-line-length-none'.
-
-`-ffree-line-length-N'
-     Set column after which characters are ignored in typical free-form
-     lines in the source file. The default value is 132.  N may be
-     `none', meaning that the entire line is meaningful.
-     `-ffree-line-length-0' means the same thing as
-     `-ffree-line-length-none'.
-
-`-fmax-identifier-length=N'
-     Specify the maximum allowed identifier length. Typical values are
-     31 (Fortran 95) and 63 (Fortran 2003 and Fortran 2008).
-
-`-fimplicit-none'
-     Specify that no implicit typing is allowed, unless overridden by
-     explicit `IMPLICIT' statements.  This is the equivalent of adding
-     `implicit none' to the start of every procedure.
-
-`-fcray-pointer'
-     Enable the Cray pointer extension, which provides C-like pointer
-     functionality.
-
-`-fopenmp'
-     Enable the OpenMP extensions.  This includes OpenMP `!$omp'
-     directives in free form and `c$omp', `*$omp' and `!$omp'
-     directives in fixed form, `!$' conditional compilation sentinels
-     in free form and `c$', `*$' and `!$' sentinels in fixed form, and
-     when linking arranges for the OpenMP runtime library to be linked
-     in.  The option `-fopenmp' implies `-frecursive'.
-
-`-fno-range-check'
-     Disable range checking on results of simplification of constant
-     expressions during compilation.  For example, GNU Fortran will give
-     an error at compile time when simplifying `a = 1. / 0'.  With this
-     option, no error will be given and `a' will be assigned the value
-     `+Infinity'.  If an expression evaluates to a value outside of the
-     relevant range of [`-HUGE()':`HUGE()'], then the expression will
-     be replaced by `-Inf' or `+Inf' as appropriate.  Similarly, `DATA
-     i/Z'FFFFFFFF'/' will result in an integer overflow on most
-     systems, but with `-fno-range-check' the value will "wrap around"
-     and `i' will be initialized to -1 instead.
-
-`-std=STD'
-     Specify the standard to which the program is expected to conform,
-     which may be one of `f95', `f2003', `f2008', `gnu', or `legacy'.
-     The default value for STD is `gnu', which specifies a superset of
-     the Fortran 95 standard that includes all of the extensions
-     supported by GNU Fortran, although warnings will be given for
-     obsolete extensions not recommended for use in new code.  The
-     `legacy' value is equivalent but without the warnings for obsolete
-     extensions, and may be useful for old non-standard programs.  The
-     `f95', `f2003' and `f2008' values specify strict conformance to
-     the Fortran 95, Fortran 2003 and Fortran 2008 standards,
-     respectively; errors are given for all extensions beyond the
-     relevant language standard, and warnings are given for the Fortran
-     77 features that are permitted but obsolescent in later standards.
-
-
-
-File: gfortran.info,  Node: Preprocessing Options,  Next: Error and Warning Options,  Prev: Fortran Dialect Options,  Up: Invoking GNU Fortran
-
-2.3 Enable and customize preprocessing
-======================================
-
-Preprocessor related options. See section *note Preprocessing and
-conditional compilation:: for more detailed information on
-preprocessing in `gfortran'.
-
-`-cpp'
-
-`-nocpp'
-     Enable preprocessing. The preprocessor is automatically invoked if
-     the file extension is `.fpp', `.FPP',  `.F', `.FOR', `.FTN',
-     `.F90', `.F95', `.F03' or `.F08'. Use this option to manually
-     enable preprocessing of any kind of Fortran file.
-
-     To disable preprocessing of files with any of the above listed
-     extensions, use the negative form: `-nocpp'.
-
-     The preprocessor is run in traditional mode, be aware that any
-     restrictions of the file-format, e.g. fixed-form line width, apply
-     for preprocessed output as well.
-
-`-dM'
-     Instead of the normal output, generate a list of `'#define''
-     directives for all the macros defined during the execution of the
-     preprocessor, including predefined macros. This gives you a way of
-     finding out what is predefined in your version of the preprocessor.
-     Assuming you have no file `foo.f90', the command
-            touch foo.f90; gfortran -cpp -dM foo.f90
-     will show all the predefined macros.
-
-`-dD'
-     Like `-dM' except in two respects: it does not include the
-     predefined macros, and it outputs both the `#define' directives
-     and the result of preprocessing. Both kinds of output go to the
-     standard output file.
-
-`-dN'
-     Like `-dD', but emit only the macro names, not their expansions.
-
-`-dU'
-     Like `dD' except that only macros that are expanded, or whose
-     definedness is tested in preprocessor directives, are output; the
-     output is delayed until the use or test of the macro; and
-     `'#undef'' directives are also output for macros tested but
-     undefined at the time.
-
-`-dI'
-     Output `'#include'' directives in addition to the result of
-     preprocessing.
-
-`-fworking-directory'
-     Enable generation of linemarkers in the preprocessor output that
-     will let the compiler know the current working directory at the
-     time of preprocessing. When this option is enabled, the
-     preprocessor will emit, after the initial linemarker, a second
-     linemarker with the current working directory followed by two
-     slashes. GCC will use this directory, when it's present in the
-     preprocessed input, as the directory emitted as the current
-     working directory in some debugging information formats.  This
-     option is implicitly enabled if debugging information is enabled,
-     but this can be inhibited with the negated form
-     `-fno-working-directory'. If the `-P' flag is present in the
-     command line, this option has no effect, since no `#line'
-     directives are emitted whatsoever.
-
-`-idirafter DIR'
-     Search DIR for include files, but do it after all directories
-     specified with `-I' and the standard system directories have been
-     exhausted. DIR is treated as a system include directory.  If dir
-     begins with `=', then the `=' will be replaced by the sysroot
-     prefix; see `--sysroot' and `-isysroot'.
-
-`-imultilib DIR'
-     Use DIR as a subdirectory of the directory containing
-     target-specific C++ headers.
-
-`-iprefix PREFIX'
-     Specify PREFIX as the prefix for subsequent `-iwithprefix'
-     options. If the PREFIX represents a directory, you should include
-     the final `'/''.
-
-`-isysroot DIR'
-     This option is like the `--sysroot' option, but applies only to
-     header files. See the `--sysroot' option for more information.
-
-`-iquote DIR'
-     Search DIR only for header files requested with `#include "file"';
-     they are not searched for `#include <file>', before all directories
-     specified by `-I' and before the standard system directories. If
-     DIR begins with `=', then the `=' will be replaced by the sysroot
-     prefix; see `--sysroot' and `-isysroot'.
-
-`-isystem DIR'
-     Search DIR for header files, after all directories specified by
-     `-I' but before the standard system directories. Mark it as a
-     system directory, so that it gets the same special treatment as is
-     applied to the standard system directories. If DIR begins with
-     `=', then the `=' will be replaced by the sysroot prefix; see
-     `--sysroot' and `-isysroot'.
-
-`-nostdinc'
-     Do not search the standard system directories for header files.
-     Only the directories you have specified with `-I' options (and the
-     directory of the current file, if appropriate) are searched.
-
-`-undef'
-     Do not predefine any system-specific or GCC-specific macros.  The
-     standard predefined macros remain defined.
-
-`-APREDICATE=ANSWER'
-     Make an assertion with the predicate PREDICATE and answer ANSWER.
-     This form is preferred to the older form -A predicate(answer),
-     which is still supported, because it does not use shell special
-     characters.
-
-`-A-PREDICATE=ANSWER'
-     Cancel an assertion with the predicate PREDICATE and answer ANSWER.
-
-`-C'
-     Do not discard comments. All comments are passed through to the
-     output file, except for comments in processed directives, which
-     are deleted along with the directive.
-
-     You should be prepared for side effects when using `-C'; it causes
-     the preprocessor to treat comments as tokens in their own right.
-     For example, comments appearing at the start of what would be a
-     directive line have the effect of turning that line into an
-     ordinary source line, since the first token on the line is no
-     longer a `'#''.
-
-     Warning: this currently handles C-Style comments only. The
-     preprocessor does not yet recognize Fortran-style comments.
-
-`-CC'
-     Do not discard comments, including during macro expansion. This is
-     like `-C', except that comments contained within macros are also
-     passed through to the output file where the macro is expanded.
-
-     In addition to the side-effects of the `-C' option, the `-CC'
-     option causes all C++-style comments inside a macro to be
-     converted to C-style comments. This is to prevent later use of
-     that macro from inadvertently commenting out the remainder of the
-     source line. The `-CC' option is generally used to support lint
-     comments.
-
-     Warning: this currently handles C- and C++-Style comments only. The
-     preprocessor does not yet recognize Fortran-style comments.
-
-`-DNAME'
-     Predefine name as a macro, with definition `1'.
-
-`-DNAME=DEFINITION'
-     The contents of DEFINITION are tokenized and processed as if they
-     appeared during translation phase three in a `'#define'' directive.
-     In particular, the definition will be truncated by embedded newline
-     characters.
-
-     If you are invoking the preprocessor from a shell or shell-like
-     program you may need to use the shell's quoting syntax to protect
-     characters such as spaces that have a meaning in the shell syntax.
-
-     If you wish to define a function-like macro on the command line,
-     write its argument list with surrounding parentheses before the
-     equals sign (if any). Parentheses are meaningful to most shells,
-     so you will need to quote the option. With sh and csh,
-     `-D'name(args...)=definition'' works.
-
-     `-D' and `-U' options are processed in the order they are given on
-     the command line. All -imacros file and -include file options are
-     processed after all -D and -U options.
-
-`-H'
-     Print the name of each header file used, in addition to other
-     normal activities. Each name is indented to show how deep in the
-     `'#include'' stack it is.
-
-`-P'
-     Inhibit generation of linemarkers in the output from the
-     preprocessor.  This might be useful when running the preprocessor
-     on something that is not C code, and will be sent to a program
-     which might be confused by the linemarkers.
-
-`-UNAME'
-     Cancel any previous definition of NAME, either built in or provided
-     with a `-D' option.
-
-
-File: gfortran.info,  Node: Error and Warning Options,  Next: Debugging Options,  Prev: Preprocessing Options,  Up: Invoking GNU Fortran
-
-2.4 Options to request or suppress errors and warnings
-======================================================
-
-Errors are diagnostic messages that report that the GNU Fortran compiler
-cannot compile the relevant piece of source code.  The compiler will
-continue to process the program in an attempt to report further errors
-to aid in debugging, but will not produce any compiled output.
-
-   Warnings are diagnostic messages that report constructions which are
-not inherently erroneous but which are risky or suggest there is likely
-to be a bug in the program.  Unless `-Werror' is specified, they do not
-prevent compilation of the program.
-
-   You can request many specific warnings with options beginning `-W',
-for example `-Wimplicit' to request warnings on implicit declarations.
-Each of these specific warning options also has a negative form
-beginning `-Wno-' to turn off warnings; for example, `-Wno-implicit'.
-This manual lists only one of the two forms, whichever is not the
-default.
-
-   These options control the amount and kinds of errors and warnings
-produced by GNU Fortran:
-
-`-fmax-errors=N'
-     Limits the maximum number of error messages to N, at which point
-     GNU Fortran bails out rather than attempting to continue
-     processing the source code.  If N is 0, there is no limit on the
-     number of error messages produced.
-
-`-fsyntax-only'
-     Check the code for syntax errors, but don't actually compile it.
-     This will generate module files for each module present in the
-     code, but no other output file.
-
-`-pedantic'
-     Issue warnings for uses of extensions to Fortran 95.  `-pedantic'
-     also applies to C-language constructs where they occur in GNU
-     Fortran source files, such as use of `\e' in a character constant
-     within a directive like `#include'.
-
-     Valid Fortran 95 programs should compile properly with or without
-     this option.  However, without this option, certain GNU extensions
-     and traditional Fortran features are supported as well.  With this
-     option, many of them are rejected.
-
-     Some users try to use `-pedantic' to check programs for
-     conformance.  They soon find that it does not do quite what they
-     want--it finds some nonstandard practices, but not all.  However,
-     improvements to GNU Fortran in this area are welcome.
-
-     This should be used in conjunction with `-std=f95', `-std=f2003'
-     or `-std=f2008'.
-
-`-pedantic-errors'
-     Like `-pedantic', except that errors are produced rather than
-     warnings.
-
-`-Wall'
-     Enables commonly used warning options pertaining to usage that we
-     recommend avoiding and that we believe are easy to avoid.  This
-     currently includes `-Waliasing', `-Wampersand', `-Wsurprising',
-     `-Wintrinsics-std', `-Wno-tabs', `-Wintrinsic-shadow' and
-     `-Wline-truncation'.
-
-`-Waliasing'
-     Warn about possible aliasing of dummy arguments. Specifically, it
-     warns if the same actual argument is associated with a dummy
-     argument with `INTENT(IN)' and a dummy argument with `INTENT(OUT)'
-     in a call with an explicit interface.
-
-     The following example will trigger the warning.
-            interface
-              subroutine bar(a,b)
-                integer, intent(in) :: a
-                integer, intent(out) :: b
-              end subroutine
-            end interface
-            integer :: a
-
-            call bar(a,a)
-
-`-Wampersand'
-     Warn about missing ampersand in continued character constants. The
-     warning is given with `-Wampersand', `-pedantic', `-std=f95',
-     `-std=f2003' and `-std=f2008'. Note: With no ampersand given in a
-     continued character constant, GNU Fortran assumes continuation at
-     the first non-comment, non-whitespace character after the ampersand
-     that initiated the continuation.
-
-`-Warray-temporaries'
-     Warn about array temporaries generated by the compiler.  The
-     information generated by this warning is sometimes useful in
-     optimization, in order to avoid such temporaries.
-
-`-Wcharacter-truncation'
-     Warn when a character assignment will truncate the assigned string.
-
-`-Wline-truncation'
-     Warn when a source code line will be truncated.
-
-`-Wconversion'
-     Warn about implicit conversions between different types.
-
-`-Wimplicit-interface'
-     Warn if a procedure is called without an explicit interface.  Note
-     this only checks that an explicit interface is present.  It does
-     not check that the declared interfaces are consistent across
-     program units.
-
-`-Wintrinsics-std'
-     Warn if `gfortran' finds a procedure named like an intrinsic not
-     available in the currently selected standard (with `-std') and
-     treats it as `EXTERNAL' procedure because of this.
-     `-fall-intrinsics' can be used to never trigger this behaviour and
-     always link to the intrinsic regardless of the selected standard.
-
-`-Wsurprising'
-     Produce a warning when "suspicious" code constructs are
-     encountered.  While technically legal these usually indicate that
-     an error has been made.
-
-     This currently produces a warning under the following
-     circumstances:
-
-        * An INTEGER SELECT construct has a CASE that can never be
-          matched as its lower value is greater than its upper value.
-
-        * A LOGICAL SELECT construct has three CASE statements.
-
-        * A TRANSFER specifies a source that is shorter than the
-          destination.
-
-        * The type of a function result is declared more than once with
-          the same type.  If `-pedantic' or standard-conforming mode is
-          enabled, this is an error.
-
-`-Wtabs'
-     By default, tabs are accepted as whitespace, but tabs are not
-     members of the Fortran Character Set.  For continuation lines, a
-     tab followed by a digit between 1 and 9 is supported.  `-Wno-tabs'
-     will cause a warning to be issued if a tab is encountered. Note,
-     `-Wno-tabs' is active for `-pedantic', `-std=f95', `-std=f2003',
-     `-std=f2008' and `-Wall'.
-
-`-Wunderflow'
-     Produce a warning when numerical constant expressions are
-     encountered, which yield an UNDERFLOW during compilation.
-
-`-Wintrinsic-shadow'
-     Warn if a user-defined procedure or module procedure has the same
-     name as an intrinsic; in this case, an explicit interface or
-     `EXTERNAL' or `INTRINSIC' declaration might be needed to get calls
-     later resolved to the desired intrinsic/procedure.
-
-`-Wunused-parameter'
-     Contrary to `gcc''s meaning of `-Wunused-parameter', `gfortran''s
-     implementation of this option does not warn about unused dummy
-     arguments, but about unused `PARAMETER' values.
-     `-Wunused-parameter' is not included in `-Wall' but is implied by
-     `-Wall -Wextra'.
-
-`-Walign-commons'
-     By default, `gfortran' warns about any occasion of variables being
-     padded for proper alignment inside a COMMON block. This warning
-     can be turned off via `-Wno-align-commons'. See also
-     `-falign-commons'.
-
-`-Werror'
-     Turns all warnings into errors.
-
-   *Note Options to Request or Suppress Errors and Warnings: (gcc)Error
-and Warning Options, for information on more options offered by the GBE
-shared by `gfortran', `gcc' and other GNU compilers.
-
-   Some of these have no effect when compiling programs written in
-Fortran.
-
-
-File: gfortran.info,  Node: Debugging Options,  Next: Directory Options,  Prev: Error and Warning Options,  Up: Invoking GNU Fortran
-
-2.5 Options for debugging your program or GNU Fortran
-=====================================================
-
-GNU Fortran has various special options that are used for debugging
-either your program or the GNU Fortran compiler.
-
-`-fdump-parse-tree'
-     Output the internal parse tree before starting code generation.
-     Only really useful for debugging the GNU Fortran compiler itself.
-
-`-ffpe-trap=LIST'
-     Specify a list of IEEE exceptions when a Floating Point Exception
-     (FPE) should be raised.  On most systems, this will result in a
-     SIGFPE signal being sent and the program being interrupted,
-     producing a core file useful for debugging.  LIST is a (possibly
-     empty) comma-separated list of the following IEEE exceptions:
-     `invalid' (invalid floating point operation, such as
-     `SQRT(-1.0)'), `zero' (division by zero), `overflow' (overflow in
-     a floating point operation), `underflow' (underflow in a floating
-     point operation), `precision' (loss of precision during operation)
-     and `denormal' (operation produced a denormal value).
-
-     Some of the routines in the Fortran runtime library, like
-     `CPU_TIME', are likely to trigger floating point exceptions when
-     `ffpe-trap=precision' is used. For this reason, the use of
-     `ffpe-trap=precision' is not recommended.
-
-`-fbacktrace'
-     Specify that, when a runtime error is encountered or a deadly
-     signal is emitted (segmentation fault, illegal instruction, bus
-     error or floating-point exception), the Fortran runtime library
-     should output a backtrace of the error.  This option only has
-     influence for compilation of the Fortran main program.
-
-`-fdump-core'
-     Request that a core-dump file is written to disk when a runtime
-     error is encountered on systems that support core dumps. This
-     option is only effective for the compilation of the Fortran main
-     program.
-
-   *Note Options for Debugging Your Program or GCC: (gcc)Debugging
-Options, for more information on debugging options.
-
-
-File: gfortran.info,  Node: Directory Options,  Next: Link Options,  Prev: Debugging Options,  Up: Invoking GNU Fortran
-
-2.6 Options for directory search
-================================
-
-These options affect how GNU Fortran searches for files specified by
-the `INCLUDE' directive and where it searches for previously compiled
-modules.
-
-   It also affects the search paths used by `cpp' when used to
-preprocess Fortran source.
-
-`-IDIR'
-     These affect interpretation of the `INCLUDE' directive (as well as
-     of the `#include' directive of the `cpp' preprocessor).
-
-     Also note that the general behavior of `-I' and `INCLUDE' is
-     pretty much the same as of `-I' with `#include' in the `cpp'
-     preprocessor, with regard to looking for `header.gcc' files and
-     other such things.
-
-     This path is also used to search for `.mod' files when previously
-     compiled modules are required by a `USE' statement.
-
-     *Note Options for Directory Search: (gcc)Directory Options, for
-     information on the `-I' option.
-
-`-JDIR'
-
-`-MDIR'
-     This option specifies where to put `.mod' files for compiled
-     modules.  It is also added to the list of directories to searched
-     by an `USE' statement.
-
-     The default is the current directory.
-
-     `-M' is deprecated to avoid conflicts with existing GCC options.
-
-`-fintrinsic-modules-path DIR'
-     This option specifies the location of pre-compiled intrinsic
-     modules, if they are not in the default location expected by the
-     compiler.
-
-
-File: gfortran.info,  Node: Link Options,  Next: Runtime Options,  Prev: Directory Options,  Up: Invoking GNU Fortran
-
-2.7 Influencing the linking step
-================================
-
-These options come into play when the compiler links object files into
-an executable output file. They are meaningless if the compiler is not
-doing a link step.
-
-`-static-libgfortran'
-     On systems that provide `libgfortran' as a shared and a static
-     library, this option forces the use of the static version. If no
-     shared version of `libgfortran' was built when the compiler was
-     configured, this option has no effect.
-
-
-File: gfortran.info,  Node: Runtime Options,  Next: Code Gen Options,  Prev: Link Options,  Up: Invoking GNU Fortran
-
-2.8 Influencing runtime behavior
-================================
-
-These options affect the runtime behavior of programs compiled with GNU
-Fortran.
-`-fconvert=CONVERSION'
-     Specify the representation of data for unformatted files.  Valid
-     values for conversion are: `native', the default; `swap', swap
-     between big- and little-endian; `big-endian', use big-endian
-     representation for unformatted files; `little-endian', use
-     little-endian representation for unformatted files.
-
-     _This option has an effect only when used in the main program.
-     The `CONVERT' specifier and the GFORTRAN_CONVERT_UNIT environment
-     variable override the default specified by `-fconvert'._
-
-`-fno-range-check'
-     Disable range checking of input values during integer `READ'
-     operations.  For example, GNU Fortran will give an error if an
-     input value is outside of the relevant range of
-     [`-HUGE()':`HUGE()']. In other words, with `INTEGER (kind=4) :: i'
-     , attempting to read -2147483648 will give an error unless
-     `-fno-range-check' is given.
-
-`-frecord-marker=LENGTH'
-     Specify the length of record markers for unformatted files.  Valid
-     values for LENGTH are 4 and 8.  Default is 4.  _This is different
-     from previous versions of `gfortran'_, which specified a default
-     record marker length of 8 on most systems.  If you want to read or
-     write files compatible with earlier versions of `gfortran', use
-     `-frecord-marker=8'.
-
-`-fmax-subrecord-length=LENGTH'
-     Specify the maximum length for a subrecord.  The maximum permitted
-     value for length is 2147483639, which is also the default.  Only
-     really useful for use by the gfortran testsuite.
-
-`-fsign-zero'
-     When writing zero values, show the negative sign if the sign bit
-     is set.  `fno-sign-zero' does not print the negative sign of zero
-     values for compatibility with F77.  Default behavior is to show
-     the negative sign.
-
-
-File: gfortran.info,  Node: Code Gen Options,  Next: Environment Variables,  Prev: Runtime Options,  Up: Invoking GNU Fortran
-
-2.9 Options for code generation conventions
-===========================================
-
-These machine-independent options control the interface conventions
-used in code generation.
-
-   Most of them have both positive and negative forms; the negative form
-of `-ffoo' would be `-fno-foo'.  In the table below, only one of the
-forms is listed--the one which is not the default.  You can figure out
-the other form by either removing `no-' or adding it.
-
-`-fno-automatic'
-     Treat each program unit (except those marked as RECURSIVE) as if
-     the `SAVE' statement were specified for every local variable and
-     array referenced in it. Does not affect common blocks. (Some
-     Fortran compilers provide this option under the name `-static' or
-     `-save'.)  The default, which is `-fautomatic', uses the stack for
-     local variables smaller than the value given by
-     `-fmax-stack-var-size'.  Use the option `-frecursive' to use no
-     static memory.
-
-`-ff2c'
-     Generate code designed to be compatible with code generated by
-     `g77' and `f2c'.
-
-     The calling conventions used by `g77' (originally implemented in
-     `f2c') require functions that return type default `REAL' to
-     actually return the C type `double', and functions that return
-     type `COMPLEX' to return the values via an extra argument in the
-     calling sequence that points to where to store the return value.
-     Under the default GNU calling conventions, such functions simply
-     return their results as they would in GNU C--default `REAL'
-     functions return the C type `float', and `COMPLEX' functions
-     return the GNU C type `complex'.  Additionally, this option
-     implies the `-fsecond-underscore' option, unless
-     `-fno-second-underscore' is explicitly requested.
-
-     This does not affect the generation of code that interfaces with
-     the `libgfortran' library.
-
-     _Caution:_ It is not a good idea to mix Fortran code compiled with
-     `-ff2c' with code compiled with the default `-fno-f2c' calling
-     conventions as, calling `COMPLEX' or default `REAL' functions
-     between program parts which were compiled with different calling
-     conventions will break at execution time.
-
-     _Caution:_ This will break code which passes intrinsic functions
-     of type default `REAL' or `COMPLEX' as actual arguments, as the
-     library implementations use the `-fno-f2c' calling conventions.
-
-`-fno-underscoring'
-     Do not transform names of entities specified in the Fortran source
-     file by appending underscores to them.
-
-     With `-funderscoring' in effect, GNU Fortran appends one
-     underscore to external names with no underscores.  This is done to
-     ensure compatibility with code produced by many UNIX Fortran
-     compilers.
-
-     _Caution_: The default behavior of GNU Fortran is incompatible
-     with `f2c' and `g77', please use the `-ff2c' option if you want
-     object files compiled with GNU Fortran to be compatible with
-     object code created with these tools.
-
-     Use of `-fno-underscoring' is not recommended unless you are
-     experimenting with issues such as integration of GNU Fortran into
-     existing system environments (vis-a`-vis existing libraries, tools,
-     and so on).
-
-     For example, with `-funderscoring', and assuming other defaults
-     like `-fcase-lower' and that `j()' and `max_count()' are external
-     functions while `my_var' and `lvar' are local variables, a
-     statement like
-          I = J() + MAX_COUNT (MY_VAR, LVAR)
-     is implemented as something akin to:
-          i = j_() + max_count__(&my_var__, &lvar);
-
-     With `-fno-underscoring', the same statement is implemented as:
-
-          i = j() + max_count(&my_var, &lvar);
-
-     Use of `-fno-underscoring' allows direct specification of
-     user-defined names while debugging and when interfacing GNU Fortran
-     code with other languages.
-
-     Note that just because the names match does _not_ mean that the
-     interface implemented by GNU Fortran for an external name matches
-     the interface implemented by some other language for that same
-     name.  That is, getting code produced by GNU Fortran to link to
-     code produced by some other compiler using this or any other
-     method can be only a small part of the overall solution--getting
-     the code generated by both compilers to agree on issues other than
-     naming can require significant effort, and, unlike naming
-     disagreements, linkers normally cannot detect disagreements in
-     these other areas.
-
-     Also, note that with `-fno-underscoring', the lack of appended
-     underscores introduces the very real possibility that a
-     user-defined external name will conflict with a name in a system
-     library, which could make finding unresolved-reference bugs quite
-     difficult in some cases--they might occur at program run time, and
-     show up only as buggy behavior at run time.
-
-     In future versions of GNU Fortran we hope to improve naming and
-     linking issues so that debugging always involves using the names
-     as they appear in the source, even if the names as seen by the
-     linker are mangled to prevent accidental linking between
-     procedures with incompatible interfaces.
-
-`-fsecond-underscore'
-     By default, GNU Fortran appends an underscore to external names.
-     If this option is used GNU Fortran appends two underscores to
-     names with underscores and one underscore to external names with
-     no underscores.  GNU Fortran also appends two underscores to
-     internal names with underscores to avoid naming collisions with
-     external names.
-
-     This option has no effect if `-fno-underscoring' is in effect.  It
-     is implied by the `-ff2c' option.
-
-     Otherwise, with this option, an external name such as `MAX_COUNT'
-     is implemented as a reference to the link-time external symbol
-     `max_count__', instead of `max_count_'.  This is required for
-     compatibility with `g77' and `f2c', and is implied by use of the
-     `-ff2c' option.
-
-`-fbounds-check'
-     Enable generation of run-time checks for array subscripts and
-     against the declared minimum and maximum values.  It also checks
-     array indices for assumed and deferred shape arrays against the
-     actual allocated bounds and ensures that all string lengths are
-     equal for character array constructors without an explicit
-     typespec.
-
-     Some checks require that `-fbounds-check' is set for the
-     compilation of the main program.
-
-     Note: In the future this may also include other forms of checking,
-     e.g., checking substring references.
-
-`fcheck-array-temporaries'
-     Warns at run time when for passing an actual argument a temporary
-     array had to be generated. The information generated by this
-     warning is sometimes useful in optimization, in order to avoid
-     such temporaries.
-
-     Note: The warning is only printed once per location.
-
-`-fmax-array-constructor=N'
-     This option can be used to increase the upper limit permitted in
-     array constructors.  The code below requires this option to expand
-     the array at compile time.
-
-          `program test'
-          `implicit none'
-          `integer j'
-          `integer, parameter :: n = 100000'
-          `integer, parameter :: i(n) = (/ (2*j, j = 1, n) /)'
-          `print '(10(I0,1X))', i'
-          `end program test'
-
-     _Caution:  This option can lead to long compile times and
-     excessively large object files._
-
-     The default value for N is 65535.
-
-`-fmax-stack-var-size=N'
-     This option specifies the size in bytes of the largest array that
-     will be put on the stack; if the size is exceeded static memory is
-     used (except in procedures marked as RECURSIVE). Use the option
-     `-frecursive' to allow for recursive procedures which do not have
-     a RECURSIVE attribute or for parallel programs. Use
-     `-fno-automatic' to never use the stack.
-
-     This option currently only affects local arrays declared with
-     constant bounds, and may not apply to all character variables.
-     Future versions of GNU Fortran may improve this behavior.
-
-     The default value for N is 32768.
-
-`-fpack-derived'
-     This option tells GNU Fortran to pack derived type members as
-     closely as possible.  Code compiled with this option is likely to
-     be incompatible with code compiled without this option, and may
-     execute slower.
-
-`-frepack-arrays'
-     In some circumstances GNU Fortran may pass assumed shape array
-     sections via a descriptor describing a noncontiguous area of
-     memory.  This option adds code to the function prologue to repack
-     the data into a contiguous block at runtime.
-
-     This should result in faster accesses to the array.  However it
-     can introduce significant overhead to the function call,
-     especially  when the passed data is noncontiguous.
-
-`-fshort-enums'
-     This option is provided for interoperability with C code that was
-     compiled with the `-fshort-enums' option.  It will make GNU
-     Fortran choose the smallest `INTEGER' kind a given enumerator set
-     will fit in, and give all its enumerators this kind.
-
-`-fexternal-blas'
-     This option will make `gfortran' generate calls to BLAS functions
-     for some matrix operations like `MATMUL', instead of using our own
-     algorithms, if the size of the matrices involved is larger than a
-     given limit (see `-fblas-matmul-limit').  This may be profitable
-     if an optimized vendor BLAS library is available.  The BLAS
-     library will have to be specified at link time.
-
-`-fblas-matmul-limit=N'
-     Only significant when `-fexternal-blas' is in effect.  Matrix
-     multiplication of matrices with size larger than (or equal to) N
-     will be performed by calls to BLAS functions, while others will be
-     handled by `gfortran' internal algorithms. If the matrices
-     involved are not square, the size comparison is performed using the
-     geometric mean of the dimensions of the argument and result
-     matrices.
-
-     The default value for N is 30.
-
-`-frecursive'
-     Allow indirect recursion by forcing all local arrays to be
-     allocated on the stack. This flag cannot be used together with
-     `-fmax-stack-var-size=' or `-fno-automatic'.
-
-`-finit-local-zero'
-
-`-finit-integer=N'
-
-`-finit-real=<ZERO|INF|-INF|NAN>'
-
-`-finit-logical=<TRUE|FALSE>'
-
-`-finit-character=N'
-     The `-finit-local-zero' option instructs the compiler to
-     initialize local `INTEGER', `REAL', and `COMPLEX' variables to
-     zero, `LOGICAL' variables to false, and `CHARACTER' variables to a
-     string of null bytes.  Finer-grained initialization options are
-     provided by the `-finit-integer=N',
-     `-finit-real=<ZERO|INF|-INF|NAN>' (which also initializes the real
-     and imaginary parts of local `COMPLEX' variables),
-     `-finit-logical=<TRUE|FALSE>', and `-finit-character=N' (where N
-     is an ASCII character value) options.  These options do not
-     initialize components of derived type variables, nor do they
-     initialize variables that appear in an `EQUIVALENCE' statement.
-     (This limitation may be removed in future releases).
-
-     Note that the `-finit-real=nan' option initializes `REAL' and
-     `COMPLEX' variables with a quiet NaN.
-
-`-falign-commons'
-     By default, `gfortran' enforces proper alignment of all variables
-     in a COMMON block by padding them as needed. On certain platforms
-     this is mandatory, on others it increases performance. If a COMMON
-     block is not declared with consistent data types everywhere, this
-     padding can cause trouble, and `-fno-align-commons ' can be used
-     to disable automatic alignment. The same form of this option
-     should be used for all files that share a COMMON block.  To avoid
-     potential alignment issues in COMMON blocks, it is recommended to
-     order objects from largests to smallest.
-
-   *Note Options for Code Generation Conventions: (gcc)Code Gen
-Options, for information on more options offered by the GBE shared by
-`gfortran', `gcc', and other GNU compilers.
-
-
-File: gfortran.info,  Node: Environment Variables,  Prev: Code Gen Options,  Up: Invoking GNU Fortran
-
-2.10 Environment variables affecting `gfortran'
-===============================================
-
-The `gfortran' compiler currently does not make use of any environment
-variables to control its operation above and beyond those that affect
-the operation of `gcc'.
-
-   *Note Environment Variables Affecting GCC: (gcc)Environment
-Variables, for information on environment variables.
-
-   *Note Runtime::, for environment variables that affect the run-time
-behavior of programs compiled with GNU Fortran.
-
-
-File: gfortran.info,  Node: Runtime,  Next: Fortran 2003 and 2008 status,  Prev: Invoking GNU Fortran,  Up: Top
-
-3 Runtime:  Influencing runtime behavior with environment variables
-*******************************************************************
-
-The behavior of the `gfortran' can be influenced by environment
-variables.
-
-   Malformed environment variables are silently ignored.
-
-* Menu:
-
-* GFORTRAN_STDIN_UNIT:: Unit number for standard input
-* GFORTRAN_STDOUT_UNIT:: Unit number for standard output
-* GFORTRAN_STDERR_UNIT:: Unit number for standard error
-* GFORTRAN_USE_STDERR:: Send library output to standard error
-* GFORTRAN_TMPDIR:: Directory for scratch files
-* GFORTRAN_UNBUFFERED_ALL:: Don't buffer I/O for all units.
-* GFORTRAN_UNBUFFERED_PRECONNECTED:: Don't buffer I/O for preconnected units.
-* GFORTRAN_SHOW_LOCUS::  Show location for runtime errors
-* GFORTRAN_OPTIONAL_PLUS:: Print leading + where permitted
-* GFORTRAN_DEFAULT_RECL:: Default record length for new files
-* GFORTRAN_LIST_SEPARATOR::  Separator for list output
-* GFORTRAN_CONVERT_UNIT::  Set endianness for unformatted I/O
-* GFORTRAN_ERROR_DUMPCORE:: Dump core on run-time errors
-* GFORTRAN_ERROR_BACKTRACE:: Show backtrace on run-time errors
-
-
-File: gfortran.info,  Node: GFORTRAN_STDIN_UNIT,  Next: GFORTRAN_STDOUT_UNIT,  Up: Runtime
-
-3.1 `GFORTRAN_STDIN_UNIT'--Unit number for standard input
-=========================================================
-
-This environment variable can be used to select the unit number
-preconnected to standard input.  This must be a positive integer.  The
-default value is 5.
-
-
-File: gfortran.info,  Node: GFORTRAN_STDOUT_UNIT,  Next: GFORTRAN_STDERR_UNIT,  Prev: GFORTRAN_STDIN_UNIT,  Up: Runtime
-
-3.2 `GFORTRAN_STDOUT_UNIT'--Unit number for standard output
-===========================================================
-
-This environment variable can be used to select the unit number
-preconnected to standard output.  This must be a positive integer.  The
-default value is 6.
-
-
-File: gfortran.info,  Node: GFORTRAN_STDERR_UNIT,  Next: GFORTRAN_USE_STDERR,  Prev: GFORTRAN_STDOUT_UNIT,  Up: Runtime
-
-3.3 `GFORTRAN_STDERR_UNIT'--Unit number for standard error
-==========================================================
-
-This environment variable can be used to select the unit number
-preconnected to standard error.  This must be a positive integer.  The
-default value is 0.
-
-
-File: gfortran.info,  Node: GFORTRAN_USE_STDERR,  Next: GFORTRAN_TMPDIR,  Prev: GFORTRAN_STDERR_UNIT,  Up: Runtime
-
-3.4 `GFORTRAN_USE_STDERR'--Send library output to standard error
-================================================================
-
-This environment variable controls where library output is sent.  If
-the first letter is `y', `Y' or `1', standard error is used. If the
-first letter is `n', `N' or `0', standard output is used.
-
-
-File: gfortran.info,  Node: GFORTRAN_TMPDIR,  Next: GFORTRAN_UNBUFFERED_ALL,  Prev: GFORTRAN_USE_STDERR,  Up: Runtime
-
-3.5 `GFORTRAN_TMPDIR'--Directory for scratch files
-==================================================
-
-This environment variable controls where scratch files are created.  If
-this environment variable is missing, GNU Fortran searches for the
-environment variable `TMP'.  If this is also missing, the default is
-`/tmp'.
-
-
-File: gfortran.info,  Node: GFORTRAN_UNBUFFERED_ALL,  Next: GFORTRAN_UNBUFFERED_PRECONNECTED,  Prev: GFORTRAN_TMPDIR,  Up: Runtime
-
-3.6 `GFORTRAN_UNBUFFERED_ALL'--Don't buffer I/O on all units
-============================================================
-
-This environment variable controls whether all I/O is unbuffered.  If
-the first letter is `y', `Y' or `1', all I/O is unbuffered. This will
-slow down small sequential reads and writes.  If the first letter is
-`n', `N' or `0', I/O is buffered.  This is the default.
-
-
-File: gfortran.info,  Node: GFORTRAN_UNBUFFERED_PRECONNECTED,  Next: GFORTRAN_SHOW_LOCUS,  Prev: GFORTRAN_UNBUFFERED_ALL,  Up: Runtime
-
-3.7 `GFORTRAN_UNBUFFERED_PRECONNECTED'--Don't buffer I/O on preconnected units
-==============================================================================
-
-The environment variable named `GFORTRAN_UNBUFFERED_PRECONNECTED'
-controls whether I/O on a preconnected unit (i.e. STDOUT or STDERR) is
-unbuffered.  If the first letter is `y', `Y' or `1', I/O is unbuffered.
-This will slow down small sequential reads and writes.  If the first
-letter is `n', `N' or `0', I/O is buffered.  This is the default.
-
-
-File: gfortran.info,  Node: GFORTRAN_SHOW_LOCUS,  Next: GFORTRAN_OPTIONAL_PLUS,  Prev: GFORTRAN_UNBUFFERED_PRECONNECTED,  Up: Runtime
-
-3.8 `GFORTRAN_SHOW_LOCUS'--Show location for runtime errors
-===========================================================
-
-If the first letter is `y', `Y' or `1', filename and line numbers for
-runtime errors are printed.  If the first letter is `n', `N' or `0',
-don't print filename and line numbers for runtime errors. The default
-is to print the location.
-
-
-File: gfortran.info,  Node: GFORTRAN_OPTIONAL_PLUS,  Next: GFORTRAN_DEFAULT_RECL,  Prev: GFORTRAN_SHOW_LOCUS,  Up: Runtime
-
-3.9 `GFORTRAN_OPTIONAL_PLUS'--Print leading + where permitted
-=============================================================
-
-If the first letter is `y', `Y' or `1', a plus sign is printed where
-permitted by the Fortran standard.  If the first letter is `n', `N' or
-`0', a plus sign is not printed in most cases. Default is not to print
-plus signs.
-
-
-File: gfortran.info,  Node: GFORTRAN_DEFAULT_RECL,  Next: GFORTRAN_LIST_SEPARATOR,  Prev: GFORTRAN_OPTIONAL_PLUS,  Up: Runtime
-
-3.10 `GFORTRAN_DEFAULT_RECL'--Default record length for new files
-=================================================================
-
-This environment variable specifies the default record length, in
-bytes, for files which are opened without a `RECL' tag in the `OPEN'
-statement.  This must be a positive integer.  The default value is
-1073741824 bytes (1 GB).
-
-
-File: gfortran.info,  Node: GFORTRAN_LIST_SEPARATOR,  Next: GFORTRAN_CONVERT_UNIT,  Prev: GFORTRAN_DEFAULT_RECL,  Up: Runtime
-
-3.11 `GFORTRAN_LIST_SEPARATOR'--Separator for list output
-=========================================================
-
-This environment variable specifies the separator when writing
-list-directed output.  It may contain any number of spaces and at most
-one comma.  If you specify this on the command line, be sure to quote
-spaces, as in
-     $ GFORTRAN_LIST_SEPARATOR='  ,  ' ./a.out
-   when `a.out' is the compiled Fortran program that you want to run.
-Default is a single space.
-
-
-File: gfortran.info,  Node: GFORTRAN_CONVERT_UNIT,  Next: GFORTRAN_ERROR_DUMPCORE,  Prev: GFORTRAN_LIST_SEPARATOR,  Up: Runtime
-
-3.12 `GFORTRAN_CONVERT_UNIT'--Set endianness for unformatted I/O
-================================================================
-
-By setting the `GFORTRAN_CONVERT_UNIT' variable, it is possible to
-change the representation of data for unformatted files.  The syntax
-for the `GFORTRAN_CONVERT_UNIT' variable is:
-     GFORTRAN_CONVERT_UNIT: mode | mode ';' exception | exception ;
-     mode: 'native' | 'swap' | 'big_endian' | 'little_endian' ;
-     exception: mode ':' unit_list | unit_list ;
-     unit_list: unit_spec | unit_list unit_spec ;
-     unit_spec: INTEGER | INTEGER '-' INTEGER ;
-   The variable consists of an optional default mode, followed by a
-list of optional exceptions, which are separated by semicolons from the
-preceding default and each other.  Each exception consists of a format
-and a comma-separated list of units.  Valid values for the modes are
-the same as for the `CONVERT' specifier:
-
-     `NATIVE' Use the native format.  This is the default.
-
-     `SWAP' Swap between little- and big-endian.
-
-     `LITTLE_ENDIAN' Use the little-endian format for unformatted files.
-
-     `BIG_ENDIAN' Use the big-endian format for unformatted files.
-   A missing mode for an exception is taken to mean `BIG_ENDIAN'.
-Examples of values for `GFORTRAN_CONVERT_UNIT' are:
-     `'big_endian''  Do all unformatted I/O in big_endian mode.
-
-     `'little_endian;native:10-20,25''  Do all unformatted I/O in
-     little_endian mode, except for units 10 to 20 and 25, which are in
-     native format.
-
-     `'10-20''  Units 10 to 20 are big-endian, the rest is native.
-
-   Setting the environment variables should be done on the command line
-or via the `export' command for `sh'-compatible shells and via `setenv'
-for `csh'-compatible shells.
-
-   Example for `sh':
-     $ gfortran foo.f90
-     $ GFORTRAN_CONVERT_UNIT='big_endian;native:10-20' ./a.out
-
-   Example code for `csh':
-     % gfortran foo.f90
-     % setenv GFORTRAN_CONVERT_UNIT 'big_endian;native:10-20'
-     % ./a.out
-
-   Using anything but the native representation for unformatted data
-carries a significant speed overhead.  If speed in this area matters to
-you, it is best if you use this only for data that needs to be portable.
-
-   *Note CONVERT specifier::, for an alternative way to specify the
-data representation for unformatted files.  *Note Runtime Options::, for
-setting a default data representation for the whole program.  The
-`CONVERT' specifier overrides the `-fconvert' compile options.
-
-   _Note that the values specified via the GFORTRAN_CONVERT_UNIT
-environment variable will override the CONVERT specifier in the open
-statement_.  This is to give control over data formats to users who do
-not have the source code of their program available.
-
-
-File: gfortran.info,  Node: GFORTRAN_ERROR_DUMPCORE,  Next: GFORTRAN_ERROR_BACKTRACE,  Prev: GFORTRAN_CONVERT_UNIT,  Up: Runtime
-
-3.13 `GFORTRAN_ERROR_DUMPCORE'--Dump core on run-time errors
-============================================================
-
-If the `GFORTRAN_ERROR_DUMPCORE' variable is set to `y', `Y' or `1'
-(only the first letter is relevant) then library run-time errors cause
-core dumps. To disable the core dumps, set the variable to `n', `N',
-`0'. Default is not to core dump unless the `-fdump-core' compile option
-was used.
-
-
-File: gfortran.info,  Node: GFORTRAN_ERROR_BACKTRACE,  Prev: GFORTRAN_ERROR_DUMPCORE,  Up: Runtime
-
-3.14 `GFORTRAN_ERROR_BACKTRACE'--Show backtrace on run-time errors
-==================================================================
-
-If the `GFORTRAN_ERROR_BACKTRACE' variable is set to `y', `Y' or `1'
-(only the first letter is relevant) then a backtrace is printed when a
-run-time error occurs.  To disable the backtracing, set the variable to
-`n', `N', `0'. Default is not to print a backtrace unless the
-`-fbacktrace' compile option was used.
-
-
-File: gfortran.info,  Node: Fortran 2003 and 2008 status,  Next: Compiler Characteristics,  Prev: Runtime,  Up: Top
-
-4 Fortran 2003 and 2008 Status
-******************************
-
-* Menu:
-
-* Fortran 2003 status::
-* Fortran 2008 status::
-
-
-File: gfortran.info,  Node: Fortran 2003 status,  Next: Fortran 2008 status,  Up: Fortran 2003 and 2008 status
-
-4.1 Fortran 2003 status
-=======================
-
-Although GNU Fortran focuses on implementing the Fortran 95 standard
-for the time being, a few Fortran 2003 features are currently available.
-
-   * Intrinsics `command_argument_count', `get_command',
-     `get_command_argument', `get_environment_variable', and
-     `move_alloc'.
-
-   * Array constructors using square brackets. That is, `[...]' rather
-     than `(/.../)'.
-
-   * `FLUSH' statement.
-
-   * `IOMSG=' specifier for I/O statements.
-
-   * Support for the declaration of enumeration constants via the
-     `ENUM' and `ENUMERATOR' statements.  Interoperability with `gcc'
-     is guaranteed also for the case where the `-fshort-enums' command
-     line option is given.
-
-   * TR 15581:
-        * `ALLOCATABLE' dummy arguments.
-
-        * `ALLOCATABLE' function results
-
-        * `ALLOCATABLE' components of derived types
-
-   * The `OPEN' statement supports the `ACCESS='STREAM'' specifier,
-     allowing I/O without any record structure.
-
-   * Namelist input/output for internal files.
-
-   * The `PROTECTED' statement and attribute.
-
-   * The `VALUE' statement and attribute.
-
-   * The `VOLATILE' statement and attribute.
-
-   * The `IMPORT' statement, allowing to import host-associated derived
-     types.
-
-   * `USE' statement with `INTRINSIC' and `NON_INTRINSIC' attribute;
-     supported intrinsic modules: `ISO_FORTRAN_ENV', `OMP_LIB' and
-     `OMP_LIB_KINDS'.
-
-   * Renaming of operators in the `USE' statement.
-
-   * Interoperability with C (ISO C Bindings)
-
-   * BOZ as argument of INT, REAL, DBLE and CMPLX.
-
-
-
-File: gfortran.info,  Node: Fortran 2008 status,  Prev: Fortran 2003 status,  Up: Fortran 2003 and 2008 status
-
-4.2 Fortran 2008 status
-=======================
-
-The next version of the Fortran standard after Fortran 2003 is currently
-being worked on by the Working Group 5 of Sub-Committee 22 of the Joint
-Technical Committee 1 of the International Organization for
-Standardization (ISO) and the International Electrotechnical Commission
-(IEC). This group is known at WG5 (http://www.nag.co.uk/sc22wg5/).  The
-next revision of the Fortran standard is informally referred to as
-Fortran 2008, reflecting its planned release year. The GNU Fortran
-compiler has support for some of the new features in Fortran 2008. This
-support is based on the latest draft, available from
-`http://www.nag.co.uk/sc22wg5/'. However, as the final standard may
-differ from the drafts, no guarantee of backward compatibility can be
-made and you should only use it for experimental purposes.
-
-
-File: gfortran.info,  Node: Compiler Characteristics,  Next: Extensions,  Prev: Fortran 2003 and 2008 status,  Up: Top
-
-5 Compiler Characteristics
-**************************
-
-This chapter describes certain characteristics of the GNU Fortran
-compiler, namely the KIND type parameter values supported.
-
-* Menu:
-
-* KIND Type Parameters::
-
-
-File: gfortran.info,  Node: KIND Type Parameters,  Up: Compiler Characteristics
-
-5.1 KIND Type Parameters
-========================
-
-The `KIND' type parameters supported by GNU Fortran for the primitive
-data types are:
-
-`INTEGER'
-     1, 2, 4, 8*, 16*, default: 4 (1)
-
-`LOGICAL'
-     1, 2, 4, 8*, 16*, default: 4 (1)
-
-`REAL'
-     4, 8, 10**, 16**, default: 4 (2)
-
-`COMPLEX'
-     4, 8, 10**, 16**, default: 4 (2)
-
-`CHARACTER'
-     1, 4, default: 1
-
-
-* = not available on all systems
-** = not available on all systems; additionally 10 and 16 are never
-available at the same time
-(1) Unless -fdefault-integer-8 is used
-(2) Unless -fdefault-real-8 is used
-
-The `KIND' value matches the storage size in bytes, except for
-`COMPLEX' where the storage size is twice as much (or both real and
-imaginary part are a real value of the given size).  It is recommended
-to use the `SELECT_*_KIND' intrinsics instead of the concrete values.
-
-
-File: gfortran.info,  Node: Extensions,  Next: Intrinsic Procedures,  Prev: Compiler Characteristics,  Up: Top
-
-6 Extensions
-************
-
-The two sections below detail the extensions to standard Fortran that
-are implemented in GNU Fortran, as well as some of the popular or
-historically important extensions that are not (or not yet) implemented.
-For the latter case, we explain the alternatives available to GNU
-Fortran users, including replacement by standard-conforming code or GNU
-extensions.
-
-* Menu:
-
-* Extensions implemented in GNU Fortran::
-* Extensions not implemented in GNU Fortran::
-
-
-File: gfortran.info,  Node: Extensions implemented in GNU Fortran,  Next: Extensions not implemented in GNU Fortran,  Up: Extensions
-
-6.1 Extensions implemented in GNU Fortran
-=========================================
-
-GNU Fortran implements a number of extensions over standard Fortran.
-This chapter contains information on their syntax and meaning.  There
-are currently two categories of GNU Fortran extensions, those that
-provide functionality beyond that provided by any standard, and those
-that are supported by GNU Fortran purely for backward compatibility
-with legacy compilers.  By default, `-std=gnu' allows the compiler to
-accept both types of extensions, but to warn about the use of the
-latter.  Specifying either `-std=f95', `-std=f2003' or `-std=f2008'
-disables both types of extensions, and `-std=legacy' allows both
-without warning.
-
-* Menu:
-
-* Old-style kind specifications::
-* Old-style variable initialization::
-* Extensions to namelist::
-* X format descriptor without count field::
-* Commas in FORMAT specifications::
-* Missing period in FORMAT specifications::
-* I/O item lists::
-* BOZ literal constants::
-* Real array indices::
-* Unary operators::
-* Implicitly convert LOGICAL and INTEGER values::
-* Hollerith constants support::
-* Cray pointers::
-* CONVERT specifier::
-* OpenMP::
-* Argument list functions::
-
-
-File: gfortran.info,  Node: Old-style kind specifications,  Next: Old-style variable initialization,  Up: Extensions implemented in GNU Fortran
-
-6.1.1 Old-style kind specifications
------------------------------------
-
-GNU Fortran allows old-style kind specifications in declarations. These
-look like:
-           TYPESPEC*size x,y,z
-   where `TYPESPEC' is a basic type (`INTEGER', `REAL', etc.), and
-where `size' is a byte count corresponding to the storage size of a
-valid kind for that type.  (For `COMPLEX' variables, `size' is the
-total size of the real and imaginary parts.)  The statement then
-declares `x', `y' and `z' to be of type `TYPESPEC' with the appropriate
-kind.  This is equivalent to the standard-conforming declaration
-           TYPESPEC(k) x,y,z
-   where `k' is the kind parameter suitable for the intended precision.
-As kind parameters are implementation-dependent, use the `KIND',
-`SELECTED_INT_KIND' and `SELECTED_REAL_KIND' intrinsics to retrieve the
-correct value, for instance `REAL*8 x' can be replaced by:
-     INTEGER, PARAMETER :: dbl = KIND(1.0d0)
-     REAL(KIND=dbl) :: x
-
-
-File: gfortran.info,  Node: Old-style variable initialization,  Next: Extensions to namelist,  Prev: Old-style kind specifications,  Up: Extensions implemented in GNU Fortran
-
-6.1.2 Old-style variable initialization
----------------------------------------
-
-GNU Fortran allows old-style initialization of variables of the form:
-           INTEGER i/1/,j/2/
-           REAL x(2,2) /3*0.,1./
-   The syntax for the initializers is as for the `DATA' statement, but
-unlike in a `DATA' statement, an initializer only applies to the
-variable immediately preceding the initialization.  In other words,
-something like `INTEGER I,J/2,3/' is not valid.  This style of
-initialization is only allowed in declarations without double colons
-(`::'); the double colons were introduced in Fortran 90, which also
-introduced a standard syntax for initializing variables in type
-declarations.
-
-   Examples of standard-conforming code equivalent to the above example
-are:
-     ! Fortran 90
-           INTEGER :: i = 1, j = 2
-           REAL :: x(2,2) = RESHAPE((/0.,0.,0.,1./),SHAPE(x))
-     ! Fortran 77
-           INTEGER i, j
-           REAL x(2,2)
-           DATA i/1/, j/2/, x/3*0.,1./
-
-   Note that variables which are explicitly initialized in declarations
-or in `DATA' statements automatically acquire the `SAVE' attribute.
-
-
-File: gfortran.info,  Node: Extensions to namelist,  Next: X format descriptor without count field,  Prev: Old-style variable initialization,  Up: Extensions implemented in GNU Fortran
-
-6.1.3 Extensions to namelist
-----------------------------
-
-GNU Fortran fully supports the Fortran 95 standard for namelist I/O
-including array qualifiers, substrings and fully qualified derived
-types.  The output from a namelist write is compatible with namelist
-read.  The output has all names in upper case and indentation to column
-1 after the namelist name.  Two extensions are permitted:
-
-   Old-style use of `$' instead of `&'
-     $MYNML
-      X(:)%Y(2) = 1.0 2.0 3.0
-      CH(1:4) = "abcd"
-     $END
-
-   It should be noted that the default terminator is `/' rather than
-`&END'.
-
-   Querying of the namelist when inputting from stdin. After at least
-one space, entering `?' sends to stdout the namelist name and the names
-of the variables in the namelist:
-      ?
-
-     &mynml
-      x
-      x%y
-      ch
-     &end
-
-   Entering `=?' outputs the namelist to stdout, as if `WRITE(*,NML =
-mynml)' had been called:
-     =?
-
-     &MYNML
-      X(1)%Y=  0.000000    ,  1.000000    ,  0.000000    ,
-      X(2)%Y=  0.000000    ,  2.000000    ,  0.000000    ,
-      X(3)%Y=  0.000000    ,  3.000000    ,  0.000000    ,
-      CH=abcd,  /
-
-   To aid this dialog, when input is from stdin, errors send their
-messages to stderr and execution continues, even if `IOSTAT' is set.
-
-   `PRINT' namelist is permitted.  This causes an error if `-std=f95'
-is used.
-     PROGRAM test_print
-       REAL, dimension (4)  ::  x = (/1.0, 2.0, 3.0, 4.0/)
-       NAMELIST /mynml/ x
-       PRINT mynml
-     END PROGRAM test_print
-
-   Expanded namelist reads are permitted.  This causes an error if
-`-std=f95' is used.  In the following example, the first element of the
-array will be given the value 0.00 and the two succeeding elements will
-be given the values 1.00 and 2.00.
-     &MYNML
-       X(1,1) = 0.00 , 1.00 , 2.00
-     /
-
-
-File: gfortran.info,  Node: X format descriptor without count field,  Next: Commas in FORMAT specifications,  Prev: Extensions to namelist,  Up: Extensions implemented in GNU Fortran
-
-6.1.4 `X' format descriptor without count field
------------------------------------------------
-
-To support legacy codes, GNU Fortran permits the count field of the `X'
-edit descriptor in `FORMAT' statements to be omitted.  When omitted,
-the count is implicitly assumed to be one.
-
-            PRINT 10, 2, 3
-     10     FORMAT (I1, X, I1)
-
-
-File: gfortran.info,  Node: Commas in FORMAT specifications,  Next: Missing period in FORMAT specifications,  Prev: X format descriptor without count field,  Up: Extensions implemented in GNU Fortran
-
-6.1.5 Commas in `FORMAT' specifications
----------------------------------------
-
-To support legacy codes, GNU Fortran allows the comma separator to be
-omitted immediately before and after character string edit descriptors
-in `FORMAT' statements.
-
-            PRINT 10, 2, 3
-     10     FORMAT ('FOO='I1' BAR='I2)
-
-
-File: gfortran.info,  Node: Missing period in FORMAT specifications,  Next: I/O item lists,  Prev: Commas in FORMAT specifications,  Up: Extensions implemented in GNU Fortran
-
-6.1.6 Missing period in `FORMAT' specifications
------------------------------------------------
-
-To support legacy codes, GNU Fortran allows missing periods in format
-specifications if and only if `-std=legacy' is given on the command
-line.  This is considered non-conforming code and is discouraged.
-
-            REAL :: value
-            READ(*,10) value
-     10     FORMAT ('F4')
-
-
-File: gfortran.info,  Node: I/O item lists,  Next: BOZ literal constants,  Prev: Missing period in FORMAT specifications,  Up: Extensions implemented in GNU Fortran
-
-6.1.7 I/O item lists
---------------------
-
-To support legacy codes, GNU Fortran allows the input item list of the
-`READ' statement, and the output item lists of the `WRITE' and `PRINT'
-statements, to start with a comma.
-
-
-File: gfortran.info,  Node: BOZ literal constants,  Next: Real array indices,  Prev: I/O item lists,  Up: Extensions implemented in GNU Fortran
-
-6.1.8 BOZ literal constants
----------------------------
-
-Besides decimal constants, Fortran also supports binary (`b'), octal
-(`o') and hexadecimal (`z') integer constants. The syntax is: `prefix
-quote digits quote', were the prefix is either `b', `o' or `z', quote
-is either `'' or `"' and the digits are for binary `0' or `1', for
-octal between `0' and `7', and for hexadecimal between `0' and `F'.
-(Example: `b'01011101''.)
-
-   Up to Fortran 95, BOZ literals were only allowed to initialize
-integer variables in DATA statements. Since Fortran 2003 BOZ literals
-are also allowed as argument of `REAL', `DBLE', `INT' and `CMPLX'; the
-result is the same as if the integer BOZ literal had been converted by
-`TRANSFER' to, respectively, `real', `double precision', `integer' or
-`complex'.  As GNU Fortran extension the intrinsic procedures `FLOAT',
-`DFLOAT', `COMPLEX' and `DCMPLX' are treated alike.
-
-   As an extension, GNU Fortran allows hexadecimal BOZ literal
-constants to be specified using the `X' prefix, in addition to the
-standard `Z' prefix. The BOZ literal can also be specified by adding a
-suffix to the string, for example, `Z'ABC'' and `'ABC'Z' are equivalent.
-
-   Furthermore, GNU Fortran allows using BOZ literal constants outside
-DATA statements and the four intrinsic functions allowed by Fortran
-2003.  In DATA statements, in direct assignments, where the right-hand
-side only contains a BOZ literal constant, and for old-style
-initializers of the form `integer i /o'0173'/', the constant is
-transferred as if `TRANSFER' had been used; for `COMPLEX' numbers, only
-the real part is initialized unless `CMPLX' is used. In all other
-cases, the BOZ literal constant is converted to an `INTEGER' value with
-the largest decimal representation.  This value is then converted
-numerically to the type and kind of the variable in question.  (For
-instance `real :: r = b'0000001' + 1' initializes `r' with `2.0'.) As
-different compilers implement the extension differently, one should be
-careful when doing bitwise initialization of non-integer variables.
-
-   Note that initializing an `INTEGER' variable with a statement such
-as `DATA i/Z'FFFFFFFF'/' will give an integer overflow error rather
-than the desired result of -1 when `i' is a 32-bit integer on a system
-that supports 64-bit integers.  The `-fno-range-check' option can be
-used as a workaround for legacy code that initializes integers in this
-manner.
-
-
-File: gfortran.info,  Node: Real array indices,  Next: Unary operators,  Prev: BOZ literal constants,  Up: Extensions implemented in GNU Fortran
-
-6.1.9 Real array indices
-------------------------
-
-As an extension, GNU Fortran allows the use of `REAL' expressions or
-variables as array indices.
-
-
-File: gfortran.info,  Node: Unary operators,  Next: Implicitly convert LOGICAL and INTEGER values,  Prev: Real array indices,  Up: Extensions implemented in GNU Fortran
-
-6.1.10 Unary operators
-----------------------
-
-As an extension, GNU Fortran allows unary plus and unary minus operators
-to appear as the second operand of binary arithmetic operators without
-the need for parenthesis.
-
-            X = Y * -Z
-
-
-File: gfortran.info,  Node: Implicitly convert LOGICAL and INTEGER values,  Next: Hollerith constants support,  Prev: Unary operators,  Up: Extensions implemented in GNU Fortran
-
-6.1.11 Implicitly convert `LOGICAL' and `INTEGER' values
---------------------------------------------------------
-
-As an extension for backwards compatibility with other compilers, GNU
-Fortran allows the implicit conversion of `LOGICAL' values to `INTEGER'
-values and vice versa.  When converting from a `LOGICAL' to an
-`INTEGER', `.FALSE.' is interpreted as zero, and `.TRUE.' is
-interpreted as one.  When converting from `INTEGER' to `LOGICAL', the
-value zero is interpreted as `.FALSE.' and any nonzero value is
-interpreted as `.TRUE.'.
-
-             LOGICAL :: l
-             l = 1
-
-             INTEGER :: i
-             i = .TRUE.
-
-   However, there is no implicit conversion of `INTEGER' values in
-`if'-statements, nor of `LOGICAL' or `INTEGER' values in I/O operations.
-
-
-File: gfortran.info,  Node: Hollerith constants support,  Next: Cray pointers,  Prev: Implicitly convert LOGICAL and INTEGER values,  Up: Extensions implemented in GNU Fortran
-
-6.1.12 Hollerith constants support
-----------------------------------
-
-GNU Fortran supports Hollerith constants in assignments, function
-arguments, and `DATA' and `ASSIGN' statements.  A Hollerith constant is
-written as a string of characters preceded by an integer constant
-indicating the character count, and the letter `H' or `h', and stored
-in bytewise fashion in a numeric (`INTEGER', `REAL', or `complex') or
-`LOGICAL' variable.  The constant will be padded or truncated to fit
-the size of the variable in which it is stored.
-
-   Examples of valid uses of Hollerith constants:
-           complex*16 x(2)
-           data x /16Habcdefghijklmnop, 16Hqrstuvwxyz012345/
-           x(1) = 16HABCDEFGHIJKLMNOP
-           call foo (4h abc)
-
-   Invalid Hollerith constants examples:
-           integer*4 a
-           a = 8H12345678 ! Valid, but the Hollerith constant will be truncated.
-           a = 0H         ! At least one character is needed.
-
-   In general, Hollerith constants were used to provide a rudimentary
-facility for handling character strings in early Fortran compilers,
-prior to the introduction of `CHARACTER' variables in Fortran 77; in
-those cases, the standard-compliant equivalent is to convert the
-program to use proper character strings.  On occasion, there may be a
-case where the intent is specifically to initialize a numeric variable
-with a given byte sequence.  In these cases, the same result can be
-obtained by using the `TRANSFER' statement, as in this example.
-           INTEGER(KIND=4) :: a
-           a = TRANSFER ("abcd", a)     ! equivalent to: a = 4Habcd
-
-
-File: gfortran.info,  Node: Cray pointers,  Next: CONVERT specifier,  Prev: Hollerith constants support,  Up: Extensions implemented in GNU Fortran
-
-6.1.13 Cray pointers
---------------------
-
-Cray pointers are part of a non-standard extension that provides a
-C-like pointer in Fortran.  This is accomplished through a pair of
-variables: an integer "pointer" that holds a memory address, and a
-"pointee" that is used to dereference the pointer.
-
-   Pointer/pointee pairs are declared in statements of the form:
-             pointer ( <pointer> , <pointee> )
-   or,
-             pointer ( <pointer1> , <pointee1> ), ( <pointer2> , <pointee2> ), ...
-   The pointer is an integer that is intended to hold a memory address.
-The pointee may be an array or scalar.  A pointee can be an assumed
-size array--that is, the last dimension may be left unspecified by
-using a `*' in place of a value--but a pointee cannot be an assumed
-shape array.  No space is allocated for the pointee.
-
-   The pointee may have its type declared before or after the pointer
-statement, and its array specification (if any) may be declared before,
-during, or after the pointer statement.  The pointer may be declared as
-an integer prior to the pointer statement.  However, some machines have
-default integer sizes that are different than the size of a pointer,
-and so the following code is not portable:
-             integer ipt
-             pointer (ipt, iarr)
-   If a pointer is declared with a kind that is too small, the compiler
-will issue a warning; the resulting binary will probably not work
-correctly, because the memory addresses stored in the pointers may be
-truncated.  It is safer to omit the first line of the above example; if
-explicit declaration of ipt's type is omitted, then the compiler will
-ensure that ipt is an integer variable large enough to hold a pointer.
-
-   Pointer arithmetic is valid with Cray pointers, but it is not the
-same as C pointer arithmetic.  Cray pointers are just ordinary
-integers, so the user is responsible for determining how many bytes to
-add to a pointer in order to increment it.  Consider the following
-example:
-             real target(10)
-             real pointee(10)
-             pointer (ipt, pointee)
-             ipt = loc (target)
-             ipt = ipt + 1
-   The last statement does not set `ipt' to the address of `target(1)',
-as it would in C pointer arithmetic.  Adding `1' to `ipt' just adds one
-byte to the address stored in `ipt'.
-
-   Any expression involving the pointee will be translated to use the
-value stored in the pointer as the base address.
-
-   To get the address of elements, this extension provides an intrinsic
-function `LOC()'.  The `LOC()' function is equivalent to the `&'
-operator in C, except the address is cast to an integer type:
-             real ar(10)
-             pointer(ipt, arpte(10))
-             real arpte
-             ipt = loc(ar)  ! Makes arpte is an alias for ar
-             arpte(1) = 1.0 ! Sets ar(1) to 1.0
-   The pointer can also be set by a call to the `MALLOC' intrinsic (see
-*note MALLOC::).
-
-   Cray pointees often are used to alias an existing variable.  For
-example:
-             integer target(10)
-             integer iarr(10)
-             pointer (ipt, iarr)
-             ipt = loc(target)
-   As long as `ipt' remains unchanged, `iarr' is now an alias for
-`target'. The optimizer, however, will not detect this aliasing, so it
-is unsafe to use `iarr' and `target' simultaneously.  Using a pointee
-in any way that violates the Fortran aliasing rules or assumptions is
-illegal. It is the user's responsibility to avoid doing this; the
-compiler works under the assumption that no such aliasing occurs.
-
-   Cray pointers will work correctly when there is no aliasing (i.e.,
-when they are used to access a dynamically allocated block of memory),
-and also in any routine where a pointee is used, but any variable with
-which it shares storage is not used.  Code that violates these rules
-may not run as the user intends.  This is not a bug in the optimizer;
-any code that violates the aliasing rules is illegal.  (Note that this
-is not unique to GNU Fortran; any Fortran compiler that supports Cray
-pointers will "incorrectly" optimize code with illegal aliasing.)
-
-   There are a number of restrictions on the attributes that can be
-applied to Cray pointers and pointees.  Pointees may not have the
-`ALLOCATABLE', `INTENT', `OPTIONAL', `DUMMY', `TARGET', `INTRINSIC', or
-`POINTER' attributes. Pointers may not have the `DIMENSION', `POINTER',
-`TARGET', `ALLOCATABLE', `EXTERNAL', or `INTRINSIC' attributes.
-Pointees may not occur in more than one pointer statement.  A pointee
-cannot be a pointer.  Pointees cannot occur in equivalence, common, or
-data statements.
-
-   A Cray pointer may also point to a function or a subroutine.  For
-example, the following excerpt is valid:
-       implicit none
-       external sub
-       pointer (subptr,subpte)
-       external subpte
-       subptr = loc(sub)
-       call subpte()
-       [...]
-       subroutine sub
-       [...]
-       end subroutine sub
-
-   A pointer may be modified during the course of a program, and this
-will change the location to which the pointee refers.  However, when
-pointees are passed as arguments, they are treated as ordinary
-variables in the invoked function.  Subsequent changes to the pointer
-will not change the base address of the array that was passed.
-
-
-File: gfortran.info,  Node: CONVERT specifier,  Next: OpenMP,  Prev: Cray pointers,  Up: Extensions implemented in GNU Fortran
-
-6.1.14 `CONVERT' specifier
---------------------------
-
-GNU Fortran allows the conversion of unformatted data between little-
-and big-endian representation to facilitate moving of data between
-different systems.  The conversion can be indicated with the `CONVERT'
-specifier on the `OPEN' statement.  *Note GFORTRAN_CONVERT_UNIT::, for
-an alternative way of specifying the data format via an environment
-variable.
-
-   Valid values for `CONVERT' are:
-     `CONVERT='NATIVE'' Use the native format.  This is the default.
-
-     `CONVERT='SWAP'' Swap between little- and big-endian.
-
-     `CONVERT='LITTLE_ENDIAN'' Use the little-endian representation for
-     unformatted files.
-
-     `CONVERT='BIG_ENDIAN'' Use the big-endian representation for
-     unformatted files.
-
-   Using the option could look like this:
-       open(file='big.dat',form='unformatted',access='sequential', &
-            convert='big_endian')
-
-   The value of the conversion can be queried by using
-`INQUIRE(CONVERT=ch)'.  The values returned are `'BIG_ENDIAN'' and
-`'LITTLE_ENDIAN''.
-
-   `CONVERT' works between big- and little-endian for `INTEGER' values
-of all supported kinds and for `REAL' on IEEE systems of kinds 4 and 8.
-Conversion between different "extended double" types on different
-architectures such as m68k and x86_64, which GNU Fortran supports as
-`REAL(KIND=10)' and `REAL(KIND=16)', will probably not work.
-
-   _Note that the values specified via the GFORTRAN_CONVERT_UNIT
-environment variable will override the CONVERT specifier in the open
-statement_.  This is to give control over data formats to users who do
-not have the source code of their program available.
-
-   Using anything but the native representation for unformatted data
-carries a significant speed overhead.  If speed in this area matters to
-you, it is best if you use this only for data that needs to be portable.
-
-
-File: gfortran.info,  Node: OpenMP,  Next: Argument list functions,  Prev: CONVERT specifier,  Up: Extensions implemented in GNU Fortran
-
-6.1.15 OpenMP
--------------
-
-OpenMP (Open Multi-Processing) is an application programming interface
-(API) that supports multi-platform shared memory multiprocessing
-programming in C/C++ and Fortran on many architectures, including Unix
-and Microsoft Windows platforms.  It consists of a set of compiler
-directives, library routines, and environment variables that influence
-run-time behavior.
-
-   GNU Fortran strives to be compatible to the OpenMP Application
-Program Interface v2.5
-(http://www.openmp.org/drupal/mp-documents/spec25.pdf).
-
-   To enable the processing of the OpenMP directive `!$omp' in
-free-form source code; the `c$omp', `*$omp' and `!$omp' directives in
-fixed form; the `!$' conditional compilation sentinels in free form;
-and the `c$', `*$' and `!$' sentinels in fixed form, `gfortran' needs
-to be invoked with the `-fopenmp'. This also arranges for automatic
-linking of the GNU OpenMP runtime library *note libgomp: (libgomp)Top.
-
-   The OpenMP Fortran runtime library routines are provided both in a
-form of a Fortran 90 module named `omp_lib' and in a form of a Fortran
-`include' file named `omp_lib.h'.
-
-   An example of a parallelized loop taken from Appendix A.1 of the
-OpenMP Application Program Interface v2.5:
-     SUBROUTINE A1(N, A, B)
-       INTEGER I, N
-       REAL B(N), A(N)
-     !$OMP PARALLEL DO !I is private by default
-       DO I=2,N
-         B(I) = (A(I) + A(I-1)) / 2.0
-       ENDDO
-     !$OMP END PARALLEL DO
-     END SUBROUTINE A1
-
-   Please note:
-   * `-fopenmp' implies `-frecursive', i.e., all local arrays will be
-     allocated on the stack. When porting existing code to OpenMP, this
-     may lead to surprising results, especially to segmentation faults
-     if the stacksize is limited.
-
-   * On glibc-based systems, OpenMP enabled applications can not be
-     statically linked due to limitations of the underlying
-     pthreads-implementation. It might be possible to get a working
-     solution if `-Wl,--whole-archive -lpthread -Wl,--no-whole-archive'
-     is added to the command line. However, this is not supported by
-     `gcc' and thus not recommended.
-
-
-File: gfortran.info,  Node: Argument list functions,  Prev: OpenMP,  Up: Extensions implemented in GNU Fortran
-
-6.1.16 Argument list functions `%VAL', `%REF' and `%LOC'
---------------------------------------------------------
-
-GNU Fortran supports argument list functions `%VAL', `%REF' and `%LOC'
-statements, for backward compatibility with g77.  It is recommended
-that these should be used only for code that is accessing facilities
-outside of GNU Fortran, such as operating system or windowing
-facilities. It is best to constrain such uses to isolated portions of a
-program-portions that deal specifically and exclusively with low-level,
-system-dependent facilities. Such portions might well provide a
-portable interface for use by the program as a whole, but are
-themselves not portable, and should be thoroughly tested each time they
-are rebuilt using a new compiler or version of a compiler.
-
-   `%VAL' passes a scalar argument by value, `%REF' passes it by
-reference and `%LOC' passes its memory location.  Since gfortran
-already passes scalar arguments by reference, `%REF' is in effect a
-do-nothing.  `%LOC' has the same effect as a fortran pointer.
-
-   An example of passing an argument by value to a C subroutine foo.:
-     C
-     C prototype      void foo_ (float x);
-     C
-           external foo
-           real*4 x
-           x = 3.14159
-           call foo (%VAL (x))
-           end
-
-   For details refer to the g77 manual
-`http://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/index.html#Top'.
-
-   Also, the gfortran testsuite c_by_val.f and its partner c_by_val.c
-are worth a look.
-
-
-File: gfortran.info,  Node: Extensions not implemented in GNU Fortran,  Prev: Extensions implemented in GNU Fortran,  Up: Extensions
-
-6.2 Extensions not implemented in GNU Fortran
-=============================================
-
-The long history of the Fortran language, its wide use and broad
-userbase, the large number of different compiler vendors and the lack of
-some features crucial to users in the first standards have lead to the
-existence of a number of important extensions to the language.  While
-some of the most useful or popular extensions are supported by the GNU
-Fortran compiler, not all existing extensions are supported.  This
-section aims at listing these extensions and offering advice on how
-best make code that uses them running with the GNU Fortran compiler.
-
-* Menu:
-
-* STRUCTURE and RECORD::
-* ENCODE and DECODE statements::
-
-
-File: gfortran.info,  Node: STRUCTURE and RECORD,  Next: ENCODE and DECODE statements,  Up: Extensions not implemented in GNU Fortran
-
-6.2.1 `STRUCTURE' and `RECORD'
-------------------------------
-
-Structures are user-defined aggregate data types; this functionality was
-standardized in Fortran 90 with an different syntax, under the name of
-"derived types". Here is an example of code using the non portable
-structure syntax:
-
-     ! Declaring a structure named ``item'' and containing three fields:
-     ! an integer ID, an description string and a floating-point price.
-     STRUCTURE /item/
-       INTEGER id
-       CHARACTER(LEN=200) description
-       REAL price
-     END STRUCTURE
-
-     ! Define two variables, an single record of type ``item''
-     ! named ``pear'', and an array of items named ``store_catalog''
-     RECORD /item/ pear, store_catalog(100)
-
-     ! We can directly access the fields of both variables
-     pear.id = 92316
-     pear.description = "juicy D'Anjou pear"
-     pear.price = 0.15
-     store_catalog(7).id = 7831
-     store_catalog(7).description = "milk bottle"
-     store_catalog(7).price = 1.2
-
-     ! We can also manipulate the whole structure
-     store_catalog(12) = pear
-     print *, store_catalog(12)
-
-This code can easily be rewritten in the Fortran 90 syntax as following:
-
-     ! ``STRUCTURE /name/ ... END STRUCTURE'' becomes
-     ! ``TYPE name ... END TYPE''
-     TYPE item
-       INTEGER id
-       CHARACTER(LEN=200) description
-       REAL price
-     END TYPE
-
-     ! ``RECORD /name/ variable'' becomes ``TYPE(name) variable''
-     TYPE(item) pear, store_catalog(100)
-
-     ! Instead of using a dot (.) to access fields of a record, the
-     ! standard syntax uses a percent sign (%)
-     pear%id = 92316
-     pear%description = "juicy D'Anjou pear"
-     pear%price = 0.15
-     store_catalog(7)%id = 7831
-     store_catalog(7)%description = "milk bottle"
-     store_catalog(7)%price = 1.2
-
-     ! Assignments of a whole variable don't change
-     store_catalog(12) = pear
-     print *, store_catalog(12)
-
-
-File: gfortran.info,  Node: ENCODE and DECODE statements,  Prev: STRUCTURE and RECORD,  Up: Extensions not implemented in GNU Fortran
-
-6.2.2 `ENCODE' and `DECODE' statements
---------------------------------------
-
-GNU Fortran doesn't support the `ENCODE' and `DECODE' statements.
-These statements are best replaced by `READ' and `WRITE' statements
-involving internal files (`CHARACTER' variables and arrays), which have
-been part of the Fortran standard since Fortran 77. For example,
-replace a code fragment like
-
-           INTEGER*1 LINE(80)
-           REAL A, B, C
-     c     ... Code that sets LINE
-           DECODE (80, 9000, LINE) A, B, C
-      9000 FORMAT (1X, 3(F10.5))
-
-with the following:
-
-           CHARACTER(LEN=80) LINE
-           REAL A, B, C
-     c     ... Code that sets LINE
-           READ (UNIT=LINE, FMT=9000) A, B, C
-      9000 FORMAT (1X, 3(F10.5))
-
-   Similarly, replace a code fragment like
-
-           INTEGER*1 LINE(80)
-           REAL A, B, C
-     c     ... Code that sets A, B and C
-           ENCODE (80, 9000, LINE) A, B, C
-      9000 FORMAT (1X, 'OUTPUT IS ', 3(F10.5))
-
-with the following:
-
-           INTEGER*1 LINE(80)
-           REAL A, B, C
-     c     ... Code that sets A, B and C
-           WRITE (UNIT=LINE, FMT=9000) A, B, C
-      9000 FORMAT (1X, 'OUTPUT IS ', 3(F10.5))
-
-
-File: gfortran.info,  Node: Intrinsic Procedures,  Next: Intrinsic Modules,  Prev: Extensions,  Up: Top
-
-7 Intrinsic Procedures
-**********************
-
-* Menu:
-
-* Introduction:         Introduction to Intrinsics
-* `ABORT':         ABORT,     Abort the program
-* `ABS':           ABS,       Absolute value
-* `ACCESS':        ACCESS,    Checks file access modes
-* `ACHAR':         ACHAR,     Character in ASCII collating sequence
-* `ACOS':          ACOS,      Arccosine function
-* `ACOSH':         ACOSH,     Hyperbolic arccosine function
-* `ADJUSTL':       ADJUSTL,   Left adjust a string
-* `ADJUSTR':       ADJUSTR,   Right adjust a string
-* `AIMAG':         AIMAG,     Imaginary part of complex number
-* `AINT':          AINT,      Truncate to a whole number
-* `ALARM':         ALARM,     Set an alarm clock
-* `ALL':           ALL,       Determine if all values are true
-* `ALLOCATED':     ALLOCATED, Status of allocatable entity
-* `AND':           AND,       Bitwise logical AND
-* `ANINT':         ANINT,     Nearest whole number
-* `ANY':           ANY,       Determine if any values are true
-* `ASIN':          ASIN,      Arcsine function
-* `ASINH':         ASINH,     Hyperbolic arcsine function
-* `ASSOCIATED':    ASSOCIATED, Status of a pointer or pointer/target pair
-* `ATAN':          ATAN,      Arctangent function
-* `ATAN2':         ATAN2,     Arctangent function
-* `ATANH':         ATANH,     Hyperbolic arctangent function
-* `BESSEL_J0':     BESSEL_J0, Bessel function of the first kind of order 0
-* `BESSEL_J1':     BESSEL_J1, Bessel function of the first kind of order 1
-* `BESSEL_JN':     BESSEL_JN, Bessel function of the first kind
-* `BESSEL_Y0':     BESSEL_Y0, Bessel function of the second kind of order 0
-* `BESSEL_Y1':     BESSEL_Y1, Bessel function of the second kind of order 1
-* `BESSEL_YN':     BESSEL_YN, Bessel function of the second kind
-* `BIT_SIZE':      BIT_SIZE,  Bit size inquiry function
-* `BTEST':         BTEST,     Bit test function
-* `C_ASSOCIATED':  C_ASSOCIATED, Status of a C pointer
-* `C_F_POINTER':   C_F_POINTER, Convert C into Fortran pointer
-* `C_F_PROCPOINTER': C_F_PROCPOINTER, Convert C into Fortran procedure pointer
-* `C_FUNLOC':      C_FUNLOC,  Obtain the C address of a procedure
-* `C_LOC':         C_LOC,     Obtain the C address of an object
-* `C_SIZEOF':      C_SIZEOF,  Size in bytes of an expression
-* `CEILING':       CEILING,   Integer ceiling function
-* `CHAR':          CHAR,      Integer-to-character conversion function
-* `CHDIR':         CHDIR,     Change working directory
-* `CHMOD':         CHMOD,     Change access permissions of files
-* `CMPLX':         CMPLX,     Complex conversion function
-* `COMMAND_ARGUMENT_COUNT': COMMAND_ARGUMENT_COUNT, Get number of command line arguments
-* `COMPLEX':       COMPLEX,   Complex conversion function
-* `CONJG':         CONJG,     Complex conjugate function
-* `COS':           COS,       Cosine function
-* `COSH':          COSH,      Hyperbolic cosine function
-* `COUNT':         COUNT,     Count occurrences of TRUE in an array
-* `CPU_TIME':      CPU_TIME,  CPU time subroutine
-* `CSHIFT':        CSHIFT,    Circular shift elements of an array
-* `CTIME':         CTIME,     Subroutine (or function) to convert a time into a string
-* `DATE_AND_TIME': DATE_AND_TIME, Date and time subroutine
-* `DBLE':          DBLE,      Double precision conversion function
-* `DCMPLX':        DCMPLX,    Double complex conversion function
-* `DFLOAT':        DFLOAT,    Double precision conversion function
-* `DIGITS':        DIGITS,    Significant digits function
-* `DIM':           DIM,       Positive difference
-* `DOT_PRODUCT':   DOT_PRODUCT, Dot product function
-* `DPROD':         DPROD,     Double product function
-* `DREAL':         DREAL,     Double real part function
-* `DTIME':         DTIME,     Execution time subroutine (or function)
-* `EOSHIFT':       EOSHIFT,   End-off shift elements of an array
-* `EPSILON':       EPSILON,   Epsilon function
-* `ERF':           ERF,       Error function
-* `ERFC':          ERFC,      Complementary error function
-* `ERFC_SCALED':   ERFC_SCALED, Exponentially-scaled complementary error function
-* `ETIME':         ETIME,     Execution time subroutine (or function)
-* `EXIT':          EXIT,      Exit the program with status.
-* `EXP':           EXP,       Exponential function
-* `EXPONENT':      EXPONENT,  Exponent function
-* `FDATE':         FDATE,     Subroutine (or function) to get the current time as a string
-* `FGET':          FGET,      Read a single character in stream mode from stdin
-* `FGETC':         FGETC,     Read a single character in stream mode
-* `FLOAT':         FLOAT,     Convert integer to default real
-* `FLOOR':         FLOOR,     Integer floor function
-* `FLUSH':         FLUSH,     Flush I/O unit(s)
-* `FNUM':          FNUM,      File number function
-* `FPUT':          FPUT,      Write a single character in stream mode to stdout
-* `FPUTC':         FPUTC,     Write a single character in stream mode
-* `FRACTION':      FRACTION,  Fractional part of the model representation
-* `FREE':          FREE,      Memory de-allocation subroutine
-* `FSEEK':         FSEEK,     Low level file positioning subroutine
-* `FSTAT':         FSTAT,     Get file status
-* `FTELL':         FTELL,     Current stream position
-* `GAMMA':         GAMMA,     Gamma function
-* `GERROR':        GERROR,    Get last system error message
-* `GETARG':        GETARG,    Get command line arguments
-* `GET_COMMAND':   GET_COMMAND, Get the entire command line
-* `GET_COMMAND_ARGUMENT': GET_COMMAND_ARGUMENT, Get command line arguments
-* `GETCWD':        GETCWD,    Get current working directory
-* `GETENV':        GETENV,    Get an environmental variable
-* `GET_ENVIRONMENT_VARIABLE': GET_ENVIRONMENT_VARIABLE, Get an environmental variable
-* `GETGID':        GETGID,    Group ID function
-* `GETLOG':        GETLOG,    Get login name
-* `GETPID':        GETPID,    Process ID function
-* `GETUID':        GETUID,    User ID function
-* `GMTIME':        GMTIME,    Convert time to GMT info
-* `HOSTNM':        HOSTNM,    Get system host name
-* `HUGE':          HUGE,      Largest number of a kind
-* `HYPOT':         HYPOT,     Euclidian distance function
-* `IACHAR':        IACHAR,    Code in ASCII collating sequence
-* `IAND':          IAND,      Bitwise logical and
-* `IARGC':         IARGC,     Get the number of command line arguments
-* `IBCLR':         IBCLR,     Clear bit
-* `IBITS':         IBITS,     Bit extraction
-* `IBSET':         IBSET,     Set bit
-* `ICHAR':         ICHAR,     Character-to-integer conversion function
-* `IDATE':         IDATE,     Current local time (day/month/year)
-* `IEOR':          IEOR,      Bitwise logical exclusive or
-* `IERRNO':        IERRNO,    Function to get the last system error number
-* `INDEX':         INDEX intrinsic, Position of a substring within a string
-* `INT':           INT,       Convert to integer type
-* `INT2':          INT2,      Convert to 16-bit integer type
-* `INT8':          INT8,      Convert to 64-bit integer type
-* `IOR':           IOR,       Bitwise logical or
-* `IRAND':         IRAND,     Integer pseudo-random number
-* `IS_IOSTAT_END':  IS_IOSTAT_END, Test for end-of-file value
-* `IS_IOSTAT_EOR':  IS_IOSTAT_EOR, Test for end-of-record value
-* `ISATTY':        ISATTY,    Whether a unit is a terminal device
-* `ISHFT':         ISHFT,     Shift bits
-* `ISHFTC':        ISHFTC,    Shift bits circularly
-* `ISNAN':         ISNAN,     Tests for a NaN
-* `ITIME':         ITIME,     Current local time (hour/minutes/seconds)
-* `KILL':          KILL,      Send a signal to a process
-* `KIND':          KIND,      Kind of an entity
-* `LBOUND':        LBOUND,    Lower dimension bounds of an array
-* `LEADZ':         LEADZ,     Number of leading zero bits of an integer
-* `LEN':           LEN,       Length of a character entity
-* `LEN_TRIM':      LEN_TRIM,  Length of a character entity without trailing blank characters
-* `LOG_GAMMA':     LOG_GAMMA, Logarithm of the Gamma function
-* `LGE':           LGE,       Lexical greater than or equal
-* `LGT':           LGT,       Lexical greater than
-* `LINK':          LINK,      Create a hard link
-* `LLE':           LLE,       Lexical less than or equal
-* `LLT':           LLT,       Lexical less than
-* `LNBLNK':        LNBLNK,    Index of the last non-blank character in a string
-* `LOC':           LOC,       Returns the address of a variable
-* `LOG':           LOG,       Logarithm function
-* `LOG10':         LOG10,     Base 10 logarithm function
-* `LOGICAL':       LOGICAL,   Convert to logical type
-* `LONG':          LONG,      Convert to integer type
-* `LSHIFT':        LSHIFT,    Left shift bits
-* `LSTAT':         LSTAT,     Get file status
-* `LTIME':         LTIME,     Convert time to local time info
-* `MALLOC':        MALLOC,    Dynamic memory allocation function
-* `MATMUL':        MATMUL,    matrix multiplication
-* `MAX':           MAX,       Maximum value of an argument list
-* `MAXEXPONENT':   MAXEXPONENT, Maximum exponent of a real kind
-* `MAXLOC':        MAXLOC,    Location of the maximum value within an array
-* `MAXVAL':        MAXVAL,    Maximum value of an array
-* `MCLOCK':        MCLOCK,    Time function
-* `MCLOCK8':       MCLOCK8,   Time function (64-bit)
-* `MERGE':         MERGE,     Merge arrays
-* `MIN':           MIN,       Minimum value of an argument list
-* `MINEXPONENT':   MINEXPONENT, Minimum exponent of a real kind
-* `MINLOC':        MINLOC,    Location of the minimum value within an array
-* `MINVAL':        MINVAL,    Minimum value of an array
-* `MOD':           MOD,       Remainder function
-* `MODULO':        MODULO,    Modulo function
-* `MOVE_ALLOC':    MOVE_ALLOC, Move allocation from one object to another
-* `MVBITS':        MVBITS,    Move bits from one integer to another
-* `NEAREST':       NEAREST,   Nearest representable number
-* `NEW_LINE':      NEW_LINE,  New line character
-* `NINT':          NINT,      Nearest whole number
-* `NOT':           NOT,       Logical negation
-* `NULL':          NULL,      Function that returns an disassociated pointer
-* `OR':            OR,        Bitwise logical OR
-* `PACK':          PACK,      Pack an array into an array of rank one
-* `PERROR':        PERROR,    Print system error message
-* `PRECISION':     PRECISION, Decimal precision of a real kind
-* `PRESENT':       PRESENT,   Determine whether an optional dummy argument is specified
-* `PRODUCT':       PRODUCT,   Product of array elements
-* `RADIX':         RADIX,     Base of a data model
-* `RANDOM_NUMBER': RANDOM_NUMBER, Pseudo-random number
-* `RANDOM_SEED':   RANDOM_SEED, Initialize a pseudo-random number sequence
-* `RAND':          RAND,      Real pseudo-random number
-* `RANGE':         RANGE,     Decimal exponent range
-* `RAN':           RAN,       Real pseudo-random number
-* `REAL':          REAL,      Convert to real type
-* `RENAME':        RENAME,    Rename a file
-* `REPEAT':        REPEAT,    Repeated string concatenation
-* `RESHAPE':       RESHAPE,   Function to reshape an array
-* `RRSPACING':     RRSPACING, Reciprocal of the relative spacing
-* `RSHIFT':        RSHIFT,    Right shift bits
-* `SCALE':         SCALE,     Scale a real value
-* `SCAN':          SCAN,      Scan a string for the presence of a set of characters
-* `SECNDS':        SECNDS,    Time function
-* `SECOND':        SECOND,    CPU time function
-* `SELECTED_CHAR_KIND': SELECTED_CHAR_KIND,  Choose character kind
-* `SELECTED_INT_KIND': SELECTED_INT_KIND,  Choose integer kind
-* `SELECTED_REAL_KIND': SELECTED_REAL_KIND,  Choose real kind
-* `SET_EXPONENT':  SET_EXPONENT, Set the exponent of the model
-* `SHAPE':         SHAPE,     Determine the shape of an array
-* `SIGN':          SIGN,      Sign copying function
-* `SIGNAL':        SIGNAL,    Signal handling subroutine (or function)
-* `SIN':           SIN,       Sine function
-* `SINH':          SINH,      Hyperbolic sine function
-* `SIZE':          SIZE,      Function to determine the size of an array
-* `SIZEOF':        SIZEOF,    Determine the size in bytes of an expression
-* `SLEEP':         SLEEP,     Sleep for the specified number of seconds
-* `SNGL':          SNGL,      Convert double precision real to default real
-* `SPACING':       SPACING,   Smallest distance between two numbers of a given type
-* `SPREAD':        SPREAD,    Add a dimension to an array
-* `SQRT':          SQRT,      Square-root function
-* `SRAND':         SRAND,     Reinitialize the random number generator
-* `STAT':          STAT,      Get file status
-* `SUM':           SUM,       Sum of array elements
-* `SYMLNK':        SYMLNK,    Create a symbolic link
-* `SYSTEM':        SYSTEM,    Execute a shell command
-* `SYSTEM_CLOCK':  SYSTEM_CLOCK, Time function
-* `TAN':           TAN,       Tangent function
-* `TANH':          TANH,      Hyperbolic tangent function
-* `TIME':          TIME,      Time function
-* `TIME8':         TIME8,     Time function (64-bit)
-* `TINY':          TINY,      Smallest positive number of a real kind
-* `TRAILZ':        TRAILZ,    Number of trailing zero bits of an integer
-* `TRANSFER':      TRANSFER,  Transfer bit patterns
-* `TRANSPOSE':     TRANSPOSE, Transpose an array of rank two
-* `TRIM':          TRIM,      Remove trailing blank characters of a string
-* `TTYNAM':        TTYNAM,    Get the name of a terminal device.
-* `UBOUND':        UBOUND,    Upper dimension bounds of an array
-* `UMASK':         UMASK,     Set the file creation mask
-* `UNLINK':        UNLINK,    Remove a file from the file system
-* `UNPACK':        UNPACK,    Unpack an array of rank one into an array
-* `VERIFY':        VERIFY,    Scan a string for the absence of a set of characters
-* `XOR':           XOR,       Bitwise logical exclusive or
-
-
-File: gfortran.info,  Node: Introduction to Intrinsics,  Next: ABORT,  Up: Intrinsic Procedures
-
-7.1 Introduction to intrinsic procedures
-========================================
-
-The intrinsic procedures provided by GNU Fortran include all of the
-intrinsic procedures required by the Fortran 95 standard, a set of
-intrinsic procedures for backwards compatibility with G77, and a
-selection of intrinsic procedures from the Fortran 2003 and Fortran 2008
-standards.  Any conflict between a description here and a description in
-either the Fortran 95 standard, the Fortran 2003 standard or the Fortran
-2008 standard is unintentional, and the standard(s) should be considered
-authoritative.
-
-   The enumeration of the `KIND' type parameter is processor defined in
-the Fortran 95 standard.  GNU Fortran defines the default integer type
-and default real type by `INTEGER(KIND=4)' and `REAL(KIND=4)',
-respectively.  The standard mandates that both data types shall have
-another kind, which have more precision.  On typical target
-architectures supported by `gfortran', this kind type parameter is
-`KIND=8'.  Hence, `REAL(KIND=8)' and `DOUBLE PRECISION' are equivalent.
-In the description of generic intrinsic procedures, the kind type
-parameter will be specified by `KIND=*', and in the description of
-specific names for an intrinsic procedure the kind type parameter will
-be explicitly given (e.g., `REAL(KIND=4)' or `REAL(KIND=8)').  Finally,
-for brevity the optional `KIND=' syntax will be omitted.
-
-   Many of the intrinsic procedures take one or more optional arguments.
-This document follows the convention used in the Fortran 95 standard,
-and denotes such arguments by square brackets.
-
-   GNU Fortran offers the `-std=f95' and `-std=gnu' options, which can
-be used to restrict the set of intrinsic procedures to a given
-standard.  By default, `gfortran' sets the `-std=gnu' option, and so
-all intrinsic procedures described here are accepted.  There is one
-caveat.  For a select group of intrinsic procedures, `g77' implemented
-both a function and a subroutine.  Both classes have been implemented
-in `gfortran' for backwards compatibility with `g77'.  It is noted here
-that these functions and subroutines cannot be intermixed in a given
-subprogram.  In the descriptions that follow, the applicable standard
-for each intrinsic procedure is noted.
-
-
-File: gfortran.info,  Node: ABORT,  Next: ABS,  Prev: Introduction to Intrinsics,  Up: Intrinsic Procedures
-
-7.2 `ABORT' -- Abort the program
-================================
-
-_Description_:
-     `ABORT' causes immediate termination of the program.  On operating
-     systems that support a core dump, `ABORT' will produce a core dump
-     even if the option `-fno-dump-core' is in effect, which is
-     suitable for debugging purposes.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL ABORT'
-
-_Return value_:
-     Does not return.
-
-_Example_:
-          program test_abort
-            integer :: i = 1, j = 2
-            if (i /= j) call abort
-          end program test_abort
-
-_See also_:
-     *note EXIT::, *note KILL::
-
-
-
-File: gfortran.info,  Node: ABS,  Next: ACCESS,  Prev: ABORT,  Up: Intrinsic Procedures
-
-7.3 `ABS' -- Absolute value
-===========================
-
-_Description_:
-     `ABS(A)' computes the absolute value of `A'.
-
-_Standard_:
-     Fortran 77 and later, has overloads that are GNU extensions
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ABS(A)'
-
-_Arguments_:
-     A          The type of the argument shall be an `INTEGER',
-                `REAL', or `COMPLEX'.
-
-_Return value_:
-     The return value is of the same type and kind as the argument
-     except the return value is `REAL' for a `COMPLEX' argument.
-
-_Example_:
-          program test_abs
-            integer :: i = -1
-            real :: x = -1.e0
-            complex :: z = (-1.e0,0.e0)
-            i = abs(i)
-            x = abs(x)
-            x = abs(z)
-          end program test_abs
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `CABS(A)'     `COMPLEX(4)   `REAL(4)'     Fortran 77 and
-                   Z'                          later
-     `DABS(A)'     `REAL(8)      `REAL(8)'     Fortran 77 and
-                   X'                          later
-     `IABS(A)'     `INTEGER(4)   `INTEGER(4)'  Fortran 77 and
-                   I'                          later
-     `ZABS(A)'     `COMPLEX(8)   `COMPLEX(8)'  GNU extension
-                   Z'                          
-     `CDABS(A)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
-                   Z'                          
-
-
-File: gfortran.info,  Node: ACCESS,  Next: ACHAR,  Prev: ABS,  Up: Intrinsic Procedures
-
-7.4 `ACCESS' -- Checks file access modes
-========================================
-
-_Description_:
-     `ACCESS(NAME, MODE)' checks whether the file NAME exists, is
-     readable, writable or executable. Except for the executable check,
-     `ACCESS' can be replaced by Fortran 95's `INQUIRE'.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = ACCESS(NAME, MODE)'
-
-_Arguments_:
-     NAME       Scalar `CHARACTER' of default kind with the
-                file name. Tailing blank are ignored unless
-                the character `achar(0)' is present, then all
-                characters up to and excluding `achar(0)' are
-                used as file name.
-     MODE       Scalar `CHARACTER' of default kind with the
-                file access mode, may be any concatenation of
-                `"r"' (readable), `"w"' (writable) and `"x"'
-                (executable), or `" "' to check for existence.
-
-_Return value_:
-     Returns a scalar `INTEGER', which is `0' if the file is accessible
-     in the given mode; otherwise or if an invalid argument has been
-     given for `MODE' the value `1' is returned.
-
-_Example_:
-          program access_test
-            implicit none
-            character(len=*), parameter :: file  = 'test.dat'
-            character(len=*), parameter :: file2 = 'test.dat  '//achar(0)
-            if(access(file,' ') == 0) print *, trim(file),' is exists'
-            if(access(file,'r') == 0) print *, trim(file),' is readable'
-            if(access(file,'w') == 0) print *, trim(file),' is writable'
-            if(access(file,'x') == 0) print *, trim(file),' is executable'
-            if(access(file2,'rwx') == 0) &
-              print *, trim(file2),' is readable, writable and executable'
-          end program access_test
-
-_Specific names_:
-
-_See also_:
-
-
-File: gfortran.info,  Node: ACHAR,  Next: ACOS,  Prev: ACCESS,  Up: Intrinsic Procedures
-
-7.5 `ACHAR' -- Character in ASCII collating sequence
-====================================================
-
-_Description_:
-     `ACHAR(I)' returns the character located at position `I' in the
-     ASCII collating sequence.
-
-_Standard_:
-     Fortran 77 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ACHAR(I [, KIND])'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `CHARACTER' with a length of one.  If
-     the KIND argument is present, the return value is of the specified
-     kind and of the default kind otherwise.
-
-_Example_:
-          program test_achar
-            character c
-            c = achar(32)
-          end program test_achar
-
-_Note_:
-     See *note ICHAR:: for a discussion of converting between numerical
-     values and formatted string representations.
-
-_See also_:
-     *note CHAR::, *note IACHAR::, *note ICHAR::
-
-
-
-File: gfortran.info,  Node: ACOS,  Next: ACOSH,  Prev: ACHAR,  Up: Intrinsic Procedures
-
-7.6 `ACOS' -- Arccosine function
-================================
-
-_Description_:
-     `ACOS(X)' computes the arccosine of X (inverse of `COS(X)').
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ACOS(X)'
-
-_Arguments_:
-     X          The type shall be `REAL' with a magnitude that
-                is less than or equal to one.
-
-_Return value_:
-     The return value is of type `REAL' and it lies in the range  0
-     \leq \acos(x) \leq \pi. The return value if of the same kind as X.
-
-_Example_:
-          program test_acos
-            real(8) :: x = 0.866_8
-            x = acos(x)
-          end program test_acos
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DACOS(X)'    `REAL(8) X'   `REAL(8)'     Fortran 77 and
-                                               later
-
-_See also_:
-     Inverse function: *note COS::
-
-
-
-File: gfortran.info,  Node: ACOSH,  Next: ADJUSTL,  Prev: ACOS,  Up: Intrinsic Procedures
-
-7.7 `ACOSH' -- Hyperbolic arccosine function
-============================================
-
-_Description_:
-     `ACOSH(X)' computes the hyperbolic arccosine of X (inverse of
-     `COSH(X)').
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ACOSH(X)'
-
-_Arguments_:
-     X          The type shall be `REAL' or `COMPLEX'.
-
-_Return value_:
-     The return value has the same type and kind as X
-
-_Example_:
-          PROGRAM test_acosh
-            REAL(8), DIMENSION(3) :: x = (/ 1.0, 2.0, 3.0 /)
-            WRITE (*,*) ACOSH(x)
-          END PROGRAM
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DACOSH(X)'   `REAL(8) X'   `REAL(8)'     GNU extension
-
-_See also_:
-     Inverse function: *note COSH::
-
-
-File: gfortran.info,  Node: ADJUSTL,  Next: ADJUSTR,  Prev: ACOSH,  Up: Intrinsic Procedures
-
-7.8 `ADJUSTL' -- Left adjust a string
-=====================================
-
-_Description_:
-     `ADJUSTL(STRING)' will left adjust a string by removing leading
-     spaces.  Spaces are inserted at the end of the string as needed.
-
-_Standard_:
-     Fortran 90 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ADJUSTL(STRING)'
-
-_Arguments_:
-     STRING     The type shall be `CHARACTER'.
-
-_Return value_:
-     The return value is of type `CHARACTER' and of the same kind as
-     STRING where leading spaces are removed and the same number of
-     spaces are inserted on the end of STRING.
-
-_Example_:
-          program test_adjustl
-            character(len=20) :: str = '   gfortran'
-            str = adjustl(str)
-            print *, str
-          end program test_adjustl
-
-_See also_:
-     *note ADJUSTR::, *note TRIM::
-
-
-File: gfortran.info,  Node: ADJUSTR,  Next: AIMAG,  Prev: ADJUSTL,  Up: Intrinsic Procedures
-
-7.9 `ADJUSTR' -- Right adjust a string
-======================================
-
-_Description_:
-     `ADJUSTR(STRING)' will right adjust a string by removing trailing
-     spaces.  Spaces are inserted at the start of the string as needed.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ADJUSTR(STRING)'
-
-_Arguments_:
-     STR        The type shall be `CHARACTER'.
-
-_Return value_:
-     The return value is of type `CHARACTER' and of the same kind as
-     STRING where trailing spaces are removed and the same number of
-     spaces are inserted at the start of STRING.
-
-_Example_:
-          program test_adjustr
-            character(len=20) :: str = 'gfortran'
-            str = adjustr(str)
-            print *, str
-          end program test_adjustr
-
-_See also_:
-     *note ADJUSTL::, *note TRIM::
-
-
-File: gfortran.info,  Node: AIMAG,  Next: AINT,  Prev: ADJUSTR,  Up: Intrinsic Procedures
-
-7.10 `AIMAG' -- Imaginary part of complex number
-================================================
-
-_Description_:
-     `AIMAG(Z)' yields the imaginary part of complex argument `Z'.  The
-     `IMAG(Z)' and `IMAGPART(Z)' intrinsic functions are provided for
-     compatibility with `g77', and their use in new code is strongly
-     discouraged.
-
-_Standard_:
-     Fortran 77 and later, has overloads that are GNU extensions
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = AIMAG(Z)'
-
-_Arguments_:
-     Z          The type of the argument shall be `COMPLEX'.
-
-_Return value_:
-     The return value is of type `REAL' with the kind type parameter of
-     the argument.
-
-_Example_:
-          program test_aimag
-            complex(4) z4
-            complex(8) z8
-            z4 = cmplx(1.e0_4, 0.e0_4)
-            z8 = cmplx(0.e0_8, 1.e0_8)
-            print *, aimag(z4), dimag(z8)
-          end program test_aimag
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DIMAG(Z)'    `COMPLEX(8)   `REAL(8)'     GNU extension
-                   Z'                          
-     `IMAG(Z)'     `COMPLEX Z'   `REAL'        GNU extension
-     `IMAGPART(Z)' `COMPLEX Z'   `REAL'        GNU extension
-
-
-File: gfortran.info,  Node: AINT,  Next: ALARM,  Prev: AIMAG,  Up: Intrinsic Procedures
-
-7.11 `AINT' -- Truncate to a whole number
-=========================================
-
-_Description_:
-     `AINT(A [, KIND])' truncates its argument to a whole number.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = AINT(A [, KIND])'
-
-_Arguments_:
-     A          The type of the argument shall be `REAL'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `REAL' with the kind type parameter of
-     the argument if the optional KIND is absent; otherwise, the kind
-     type parameter will be given by KIND.  If the magnitude of X is
-     less than one, `AINT(X)' returns zero.  If the magnitude is equal
-     to or greater than one then it returns the largest whole number
-     that does not exceed its magnitude.  The sign is the same as the
-     sign of X.
-
-_Example_:
-          program test_aint
-            real(4) x4
-            real(8) x8
-            x4 = 1.234E0_4
-            x8 = 4.321_8
-            print *, aint(x4), dint(x8)
-            x8 = aint(x4,8)
-          end program test_aint
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DINT(X)'     `REAL(8) X'   `REAL(8)'     Fortran 77 and
-                                               later
-
-
-File: gfortran.info,  Node: ALARM,  Next: ALL,  Prev: AINT,  Up: Intrinsic Procedures
-
-7.12 `ALARM' -- Execute a routine after a given delay
-=====================================================
-
-_Description_:
-     `ALARM(SECONDS, HANDLER [, STATUS])' causes external subroutine
-     HANDLER to be executed after a delay of SECONDS by using
-     `alarm(2)' to set up a signal and `signal(2)' to catch it. If
-     STATUS is supplied, it will be returned with the number of seconds
-     remaining until any previously scheduled alarm was due to be
-     delivered, or zero if there was no previously scheduled alarm.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL ALARM(SECONDS, HANDLER [, STATUS])'
-
-_Arguments_:
-     SECONDS    The type of the argument shall be a scalar
-                `INTEGER'. It is `INTENT(IN)'.
-     HANDLER    Signal handler (`INTEGER FUNCTION' or
-                `SUBROUTINE') or dummy/global `INTEGER'
-                scalar. The scalar values may be either
-                `SIG_IGN=1' to ignore the alarm generated or
-                `SIG_DFL=0' to set the default action. It is
-                `INTENT(IN)'.
-     STATUS     (Optional) STATUS shall be a scalar variable
-                of the default `INTEGER' kind. It is
-                `INTENT(OUT)'.
-
-_Example_:
-          program test_alarm
-            external handler_print
-            integer i
-            call alarm (3, handler_print, i)
-            print *, i
-            call sleep(10)
-          end program test_alarm
-     This will cause the external routine HANDLER_PRINT to be called
-     after 3 seconds.
-
-
-File: gfortran.info,  Node: ALL,  Next: ALLOCATED,  Prev: ALARM,  Up: Intrinsic Procedures
-
-7.13 `ALL' -- All values in MASK along DIM are true
-===================================================
-
-_Description_:
-     `ALL(MASK [, DIM])' determines if all the values are true in MASK
-     in the array along dimension DIM.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = ALL(MASK [, DIM])'
-
-_Arguments_:
-     MASK       The type of the argument shall be `LOGICAL' and
-                it shall not be scalar.
-     DIM        (Optional) DIM shall be a scalar integer with
-                a value that lies between one and the rank of
-                MASK.
-
-_Return value_:
-     `ALL(MASK)' returns a scalar value of type `LOGICAL' where the
-     kind type parameter is the same as the kind type parameter of
-     MASK.  If DIM is present, then `ALL(MASK, DIM)' returns an array
-     with the rank of MASK minus 1.  The shape is determined from the
-     shape of MASK where the DIM dimension is elided.
-
-    (A)
-          `ALL(MASK)' is true if all elements of MASK are true.  It
-          also is true if MASK has zero size; otherwise, it is false.
-
-    (B)
-          If the rank of MASK is one, then `ALL(MASK,DIM)' is equivalent
-          to `ALL(MASK)'.  If the rank is greater than one, then
-          `ALL(MASK,DIM)' is determined by applying `ALL' to the array
-          sections.
-
-_Example_:
-          program test_all
-            logical l
-            l = all((/.true., .true., .true./))
-            print *, l
-            call section
-            contains
-              subroutine section
-                integer a(2,3), b(2,3)
-                a = 1
-                b = 1
-                b(2,2) = 2
-                print *, all(a .eq. b, 1)
-                print *, all(a .eq. b, 2)
-              end subroutine section
-          end program test_all
-
-
-File: gfortran.info,  Node: ALLOCATED,  Next: AND,  Prev: ALL,  Up: Intrinsic Procedures
-
-7.14 `ALLOCATED' -- Status of an allocatable entity
-===================================================
-
-_Description_:
-     `ALLOCATED(ARRAY)' checks the status of whether X is allocated.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = ALLOCATED(ARRAY)'
-
-_Arguments_:
-     ARRAY      The argument shall be an `ALLOCATABLE' array.
-
-_Return value_:
-     The return value is a scalar `LOGICAL' with the default logical
-     kind type parameter.  If ARRAY is allocated, `ALLOCATED(ARRAY)' is
-     `.TRUE.'; otherwise, it returns `.FALSE.'
-
-_Example_:
-          program test_allocated
-            integer :: i = 4
-            real(4), allocatable :: x(:)
-            if (.not. allocated(x)) allocate(x(i))
-          end program test_allocated
-
-
-File: gfortran.info,  Node: AND,  Next: ANINT,  Prev: ALLOCATED,  Up: Intrinsic Procedures
-
-7.15 `AND' -- Bitwise logical AND
-=================================
-
-_Description_:
-     Bitwise logical `AND'.
-
-     This intrinsic routine is provided for backwards compatibility with
-     GNU Fortran 77.  For integer arguments, programmers should consider
-     the use of the *note IAND:: intrinsic defined by the Fortran
-     standard.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = AND(I, J)'
-
-_Arguments_:
-     I          The type shall be either a scalar `INTEGER'
-                type or a scalar `LOGICAL' type.
-     J          The type shall be the same as the type of I.
-
-_Return value_:
-     The return type is either a scalar `INTEGER' or a scalar
-     `LOGICAL'.  If the kind type parameters differ, then the smaller
-     kind type is implicitly converted to larger kind, and the return
-     has the larger kind.
-
-_Example_:
-          PROGRAM test_and
-            LOGICAL :: T = .TRUE., F = .FALSE.
-            INTEGER :: a, b
-            DATA a / Z'F' /, b / Z'3' /
-
-            WRITE (*,*) AND(T, T), AND(T, F), AND(F, T), AND(F, F)
-            WRITE (*,*) AND(a, b)
-          END PROGRAM
-
-_See also_:
-     Fortran 95 elemental function: *note IAND::
-
-
-File: gfortran.info,  Node: ANINT,  Next: ANY,  Prev: AND,  Up: Intrinsic Procedures
-
-7.16 `ANINT' -- Nearest whole number
-====================================
-
-_Description_:
-     `ANINT(A [, KIND])' rounds its argument to the nearest whole
-     number.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ANINT(A [, KIND])'
-
-_Arguments_:
-     A          The type of the argument shall be `REAL'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type real with the kind type parameter of
-     the argument if the optional KIND is absent; otherwise, the kind
-     type parameter will be given by KIND.  If A is greater than zero,
-     `ANINT(A)' returns `AINT(X+0.5)'.  If A is less than or equal to
-     zero then it returns `AINT(X-0.5)'.
-
-_Example_:
-          program test_anint
-            real(4) x4
-            real(8) x8
-            x4 = 1.234E0_4
-            x8 = 4.321_8
-            print *, anint(x4), dnint(x8)
-            x8 = anint(x4,8)
-          end program test_anint
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DNINT(A)'    `REAL(8) A'   `REAL(8)'     Fortran 77 and
-                                               later
-
-
-File: gfortran.info,  Node: ANY,  Next: ASIN,  Prev: ANINT,  Up: Intrinsic Procedures
-
-7.17 `ANY' -- Any value in MASK along DIM is true
-=================================================
-
-_Description_:
-     `ANY(MASK [, DIM])' determines if any of the values in the logical
-     array MASK along dimension DIM are `.TRUE.'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = ANY(MASK [, DIM])'
-
-_Arguments_:
-     MASK       The type of the argument shall be `LOGICAL' and
-                it shall not be scalar.
-     DIM        (Optional) DIM shall be a scalar integer with
-                a value that lies between one and the rank of
-                MASK.
-
-_Return value_:
-     `ANY(MASK)' returns a scalar value of type `LOGICAL' where the
-     kind type parameter is the same as the kind type parameter of
-     MASK.  If DIM is present, then `ANY(MASK, DIM)' returns an array
-     with the rank of MASK minus 1.  The shape is determined from the
-     shape of MASK where the DIM dimension is elided.
-
-    (A)
-          `ANY(MASK)' is true if any element of MASK is true;
-          otherwise, it is false.  It also is false if MASK has zero
-          size.
-
-    (B)
-          If the rank of MASK is one, then `ANY(MASK,DIM)' is equivalent
-          to `ANY(MASK)'.  If the rank is greater than one, then
-          `ANY(MASK,DIM)' is determined by applying `ANY' to the array
-          sections.
-
-_Example_:
-          program test_any
-            logical l
-            l = any((/.true., .true., .true./))
-            print *, l
-            call section
-            contains
-              subroutine section
-                integer a(2,3), b(2,3)
-                a = 1
-                b = 1
-                b(2,2) = 2
-                print *, any(a .eq. b, 1)
-                print *, any(a .eq. b, 2)
-              end subroutine section
-          end program test_any
-
-
-File: gfortran.info,  Node: ASIN,  Next: ASINH,  Prev: ANY,  Up: Intrinsic Procedures
-
-7.18 `ASIN' -- Arcsine function
-===============================
-
-_Description_:
-     `ASIN(X)' computes the arcsine of its X (inverse of `SIN(X)').
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ASIN(X)'
-
-_Arguments_:
-     X          The type shall be `REAL', and a magnitude that
-                is less than or equal to one.
-
-_Return value_:
-     The return value is of type `REAL' and it lies in the range -\pi /
-     2 \leq \asin (x) \leq \pi / 2.  The kind type parameter is the
-     same as X.
-
-_Example_:
-          program test_asin
-            real(8) :: x = 0.866_8
-            x = asin(x)
-          end program test_asin
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DASIN(X)'    `REAL(8) X'   `REAL(8)'     Fortran 77 and
-                                               later
-
-_See also_:
-     Inverse function: *note SIN::
-
-
-
-File: gfortran.info,  Node: ASINH,  Next: ASSOCIATED,  Prev: ASIN,  Up: Intrinsic Procedures
-
-7.19 `ASINH' -- Hyperbolic arcsine function
-===========================================
-
-_Description_:
-     `ASINH(X)' computes the hyperbolic arcsine of X (inverse of
-     `SINH(X)').
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ASINH(X)'
-
-_Arguments_:
-     X          The type shall be `REAL' or `COMPLEX'.
-
-_Return value_:
-     The return value is of the same type and kind as  X.
-
-_Example_:
-          PROGRAM test_asinh
-            REAL(8), DIMENSION(3) :: x = (/ -1.0, 0.0, 1.0 /)
-            WRITE (*,*) ASINH(x)
-          END PROGRAM
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DASINH(X)'   `REAL(8) X'   `REAL(8)'     GNU extension.
-
-_See also_:
-     Inverse function: *note SINH::
-
-
-File: gfortran.info,  Node: ASSOCIATED,  Next: ATAN,  Prev: ASINH,  Up: Intrinsic Procedures
-
-7.20 `ASSOCIATED' -- Status of a pointer or pointer/target pair
-===============================================================
-
-_Description_:
-     `ASSOCIATED(POINTER [, TARGET])' determines the status of the
-     pointer POINTER or if POINTER is associated with the target TARGET.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = ASSOCIATED(POINTER [, TARGET])'
-
-_Arguments_:
-     POINTER    POINTER shall have the `POINTER' attribute and
-                it can be of any type.
-     TARGET     (Optional) TARGET shall be a pointer or a
-                target.  It must have the same type, kind type
-                parameter, and array rank as POINTER.
-     The association status of neither POINTER nor TARGET shall be
-     undefined.
-
-_Return value_:
-     `ASSOCIATED(POINTER)' returns a scalar value of type `LOGICAL(4)'.
-     There are several cases:
-    (A) When the optional TARGET is not present then
-          `ASSOCIATED(POINTER)' is true if POINTER is associated with a
-          target; otherwise, it returns false.
-
-    (B) If TARGET is present and a scalar target, the result is true if
-          TARGET is not a zero-sized storage sequence and the target
-          associated with POINTER occupies the same storage units.  If
-          POINTER is disassociated, the result is false.
-
-    (C) If TARGET is present and an array target, the result is true if
-          TARGET and POINTER have the same shape, are not zero-sized
-          arrays, are arrays whose elements are not zero-sized storage
-          sequences, and TARGET and POINTER occupy the same storage
-          units in array element order.  As in case(B), the result is
-          false, if POINTER is disassociated.
-
-    (D) If TARGET is present and an scalar pointer, the result is true
-          if TARGET is associated with POINTER, the target associated
-          with TARGET are not zero-sized storage sequences and occupy
-          the same storage units.  The result is false, if either
-          TARGET or POINTER is disassociated.
-
-    (E) If TARGET is present and an array pointer, the result is true if
-          target associated with POINTER and the target associated with
-          TARGET have the same shape, are not zero-sized arrays, are
-          arrays whose elements are not zero-sized storage sequences,
-          and TARGET and POINTER occupy the same storage units in array
-          element order.  The result is false, if either TARGET or
-          POINTER is disassociated.
-
-_Example_:
-          program test_associated
-             implicit none
-             real, target  :: tgt(2) = (/1., 2./)
-             real, pointer :: ptr(:)
-             ptr => tgt
-             if (associated(ptr)     .eqv. .false.) call abort
-             if (associated(ptr,tgt) .eqv. .false.) call abort
-          end program test_associated
-
-_See also_:
-     *note NULL::
-
-
-File: gfortran.info,  Node: ATAN,  Next: ATAN2,  Prev: ASSOCIATED,  Up: Intrinsic Procedures
-
-7.21 `ATAN' -- Arctangent function
-==================================
-
-_Description_:
-     `ATAN(X)' computes the arctangent of X.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ATAN(X)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of type `REAL' and it lies in the range  - \pi
-     / 2 \leq \atan (x) \leq \pi / 2.
-
-_Example_:
-          program test_atan
-            real(8) :: x = 2.866_8
-            x = atan(x)
-          end program test_atan
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DATAN(X)'    `REAL(8) X'   `REAL(8)'     Fortran 77 and
-                                               later
-
-_See also_:
-     Inverse function: *note TAN::
-
-
-
-File: gfortran.info,  Node: ATAN2,  Next: ATANH,  Prev: ATAN,  Up: Intrinsic Procedures
-
-7.22 `ATAN2' -- Arctangent function
-===================================
-
-_Description_:
-     `ATAN2(Y, X)' computes the arctangent of the complex number X + i
-     Y.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ATAN2(Y, X)'
-
-_Arguments_:
-     Y          The type shall be `REAL'.
-     X          The type and kind type parameter shall be the
-                same as Y.  If Y is zero, then X must be
-                nonzero.
-
-_Return value_:
-     The return value has the same type and kind type parameter as Y.
-     It is the principal value of the complex number X + i Y.  If X is
-     nonzero, then it lies in the range -\pi \le \atan (x) \leq \pi.
-     The sign is positive if Y is positive.  If Y is zero, then the
-     return value is zero if X is positive and \pi if X is negative.
-     Finally, if X is zero, then the magnitude of the result is \pi/2.
-
-_Example_:
-          program test_atan2
-            real(4) :: x = 1.e0_4, y = 0.5e0_4
-            x = atan2(y,x)
-          end program test_atan2
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DATAN2(X)'   `REAL(8) X'   `REAL(8)'     Fortran 77 and
-                                               later
-
-
-File: gfortran.info,  Node: ATANH,  Next: BESSEL_J0,  Prev: ATAN2,  Up: Intrinsic Procedures
-
-7.23 `ATANH' -- Hyperbolic arctangent function
-==============================================
-
-_Description_:
-     `ATANH(X)' computes the hyperbolic arctangent of X (inverse of
-     `TANH(X)').
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ATANH(X)'
-
-_Arguments_:
-     X          The type shall be `REAL' or `COMPLEX'.
-
-_Return value_:
-     The return value has same type and kind as X.
-
-_Example_:
-          PROGRAM test_atanh
-            REAL, DIMENSION(3) :: x = (/ -1.0, 0.0, 1.0 /)
-            WRITE (*,*) ATANH(x)
-          END PROGRAM
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DATANH(X)'   `REAL(8) X'   `REAL(8)'     GNU extension
-
-_See also_:
-     Inverse function: *note TANH::
-
-
-File: gfortran.info,  Node: BESSEL_J0,  Next: BESSEL_J1,  Prev: ATANH,  Up: Intrinsic Procedures
-
-7.24 `BESSEL_J0' -- Bessel function of the first kind of order 0
-================================================================
-
-_Description_:
-     `BESSEL_J0(X)' computes the Bessel function of the first kind of
-     order 0 of X. This function is available under the name `BESJ0' as
-     a GNU extension.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = BESSEL_J0(X)'
-
-_Arguments_:
-     X          The type shall be `REAL', and it shall be
-                scalar.
-
-_Return value_:
-     The return value is of type `REAL' and lies in the range  -
-     0.4027... \leq Bessel (0,x) \leq 1. It has the same kind as X.
-
-_Example_:
-          program test_besj0
-            real(8) :: x = 0.0_8
-            x = bessel_j0(x)
-          end program test_besj0
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DBESJ0(X)'   `REAL(8) X'   `REAL(8)'     GNU extension
-
-
-File: gfortran.info,  Node: BESSEL_J1,  Next: BESSEL_JN,  Prev: BESSEL_J0,  Up: Intrinsic Procedures
-
-7.25 `BESSEL_J1' -- Bessel function of the first kind of order 1
-================================================================
-
-_Description_:
-     `BESSEL_J1(X)' computes the Bessel function of the first kind of
-     order 1 of X. This function is available under the name `BESJ1' as
-     a GNU extension.
-
-_Standard_:
-     Fortran 2008
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = BESSEL_J1(X)'
-
-_Arguments_:
-     X          The type shall be `REAL', and it shall be
-                scalar.
-
-_Return value_:
-     The return value is of type `REAL' and it lies in the range  -
-     0.5818... \leq Bessel (0,x) \leq 0.5818 . It has the same kind as
-     X.
-
-_Example_:
-          program test_besj1
-            real(8) :: x = 1.0_8
-            x = bessel_j1(x)
-          end program test_besj1
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DBESJ1(X)'   `REAL(8) X'   `REAL(8)'     GNU extension
-
-
-File: gfortran.info,  Node: BESSEL_JN,  Next: BESSEL_Y0,  Prev: BESSEL_J1,  Up: Intrinsic Procedures
-
-7.26 `BESSEL_JN' -- Bessel function of the first kind
-=====================================================
-
-_Description_:
-     `BESSEL_JN(N, X)' computes the Bessel function of the first kind of
-     order N of X. This function is available under the name `BESJN' as
-     a GNU extension.
-
-     If both arguments are arrays, their ranks and shapes shall conform.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = BESSEL_JN(N, X)'
-
-_Arguments_:
-     N          Shall be a scalar or an array of type
-                `INTEGER'.
-     X          Shall be a scalar or an array of type  `REAL'.
-
-_Return value_:
-     The return value is a scalar of type `REAL'. It has the same kind
-     as X.
-
-_Example_:
-          program test_besjn
-            real(8) :: x = 1.0_8
-            x = bessel_jn(5,x)
-          end program test_besjn
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DBESJN(X)'   `INTEGER N'   `REAL(8)'     GNU extension
-                   `REAL(8) X'                 
-
-
-File: gfortran.info,  Node: BESSEL_Y0,  Next: BESSEL_Y1,  Prev: BESSEL_JN,  Up: Intrinsic Procedures
-
-7.27 `BESSEL_Y0' -- Bessel function of the second kind of order 0
-=================================================================
-
-_Description_:
-     `BESSEL_Y0(X)' computes the Bessel function of the second kind of
-     order 0 of X. This function is available under the name `BESY0' as
-     a GNU extension.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = BESSEL_Y0(X)'
-
-_Arguments_:
-     X          The type shall be `REAL', and it shall be
-                scalar.
-
-_Return value_:
-     The return value is a scalar of type `REAL'. It has the same kind
-     as X.
-
-_Example_:
-          program test_besy0
-            real(8) :: x = 0.0_8
-            x = bessel_y0(x)
-          end program test_besy0
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DBESY0(X)'   `REAL(8) X'   `REAL(8)'     GNU extension
-
-
-File: gfortran.info,  Node: BESSEL_Y1,  Next: BESSEL_YN,  Prev: BESSEL_Y0,  Up: Intrinsic Procedures
-
-7.28 `BESSEL_Y1' -- Bessel function of the second kind of order 1
-=================================================================
-
-_Description_:
-     `BESSEL_Y1(X)' computes the Bessel function of the second kind of
-     order 1 of X. This function is available under the name `BESY1' as
-     a GNU extension.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = BESSEL_Y1(X)'
-
-_Arguments_:
-     X          The type shall be `REAL', and it shall be
-                scalar.
-
-_Return value_:
-     The return value is a scalar of type `REAL'. It has the same kind
-     as X.
-
-_Example_:
-          program test_besy1
-            real(8) :: x = 1.0_8
-            x = bessel_y1(x)
-          end program test_besy1
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DBESY1(X)'   `REAL(8) X'   `REAL(8)'     GNU extension
-
-
-File: gfortran.info,  Node: BESSEL_YN,  Next: BIT_SIZE,  Prev: BESSEL_Y1,  Up: Intrinsic Procedures
-
-7.29 `BESSEL_YN' -- Bessel function of the second kind
-======================================================
-
-_Description_:
-     `BESSEL_YN(N, X)' computes the Bessel function of the second kind
-     of order N of X. This function is available under the name `BESYN'
-     as a GNU extension.
-
-     If both arguments are arrays, their ranks and shapes shall conform.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = BESSEL_YN(N, X)'
-
-_Arguments_:
-     N          Shall be a scalar or an array of type
-                `INTEGER'.
-     X          Shall be a scalar or an array of type  `REAL'.
-
-_Return value_:
-     The return value is a scalar of type `REAL'. It has the same kind
-     as X.
-
-_Example_:
-          program test_besyn
-            real(8) :: x = 1.0_8
-            x = bessel_yn(5,x)
-          end program test_besyn
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DBESYN(N,X)' `INTEGER N'   `REAL(8)'     GNU extension
-                   `REAL(8)                    
-                   X'                          
-
-
-File: gfortran.info,  Node: BIT_SIZE,  Next: BTEST,  Prev: BESSEL_YN,  Up: Intrinsic Procedures
-
-7.30 `BIT_SIZE' -- Bit size inquiry function
-============================================
-
-_Description_:
-     `BIT_SIZE(I)' returns the number of bits (integer precision plus
-     sign bit) represented by the type of I.  The result of
-     `BIT_SIZE(I)' is independent of the actual value of I.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = BIT_SIZE(I)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type `INTEGER'
-
-_Example_:
-          program test_bit_size
-              integer :: i = 123
-              integer :: size
-              size = bit_size(i)
-              print *, size
-          end program test_bit_size
-
-
-File: gfortran.info,  Node: BTEST,  Next: C_ASSOCIATED,  Prev: BIT_SIZE,  Up: Intrinsic Procedures
-
-7.31 `BTEST' -- Bit test function
-=================================
-
-_Description_:
-     `BTEST(I,POS)' returns logical `.TRUE.' if the bit at POS in I is
-     set.  The counting of the bits starts at 0.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = BTEST(I, POS)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     POS        The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type `LOGICAL'
-
-_Example_:
-          program test_btest
-              integer :: i = 32768 + 1024 + 64
-              integer :: pos
-              logical :: bool
-              do pos=0,16
-                  bool = btest(i, pos)
-                  print *, pos, bool
-              end do
-          end program test_btest
-
-
-File: gfortran.info,  Node: C_ASSOCIATED,  Next: C_F_POINTER,  Prev: BTEST,  Up: Intrinsic Procedures
-
-7.32 `C_ASSOCIATED' -- Status of a C pointer
-============================================
-
-_Description_:
-     `C_ASSOCIATED(c_prt_1[, c_ptr_2])' determines the status of the C
-     pointer C_PTR_1 or if C_PTR_1 is associated with the target
-     C_PTR_2.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = C_ASSOCIATED(c_prt_1[, c_ptr_2])'
-
-_Arguments_:
-     C_PTR_1    Scalar of the type `C_PTR' or `C_FUNPTR'.
-     C_PTR_2    (Optional) Scalar of the same type as C_PTR_1.
-
-_Return value_:
-     The return value is of type `LOGICAL'; it is `.false.' if either
-     C_PTR_1 is a C NULL pointer or if C_PTR1 and C_PTR_2 point to
-     different addresses.
-
-_Example_:
-          subroutine association_test(a,b)
-            use iso_c_binding, only: c_associated, c_loc, c_ptr
-            implicit none
-            real, pointer :: a
-            type(c_ptr) :: b
-            if(c_associated(b, c_loc(a))) &
-               stop 'b and a do not point to same target'
-          end subroutine association_test
-
-_See also_:
-     *note C_LOC::, *note C_FUNLOC::
-
-
-File: gfortran.info,  Node: C_FUNLOC,  Next: C_LOC,  Prev: C_F_PROCPOINTER,  Up: Intrinsic Procedures
-
-7.33 `C_FUNLOC' -- Obtain the C address of a procedure
-======================================================
-
-_Description_:
-     `C_FUNLOC(x)' determines the C address of the argument.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = C_FUNLOC(x)'
-
-_Arguments_:
-     X          Interoperable function or pointer to such
-                function.
-
-_Return value_:
-     The return value is of type `C_FUNPTR' and contains the C address
-     of the argument.
-
-_Example_:
-          module x
-            use iso_c_binding
-            implicit none
-          contains
-            subroutine sub(a) bind(c)
-              real(c_float) :: a
-              a = sqrt(a)+5.0
-            end subroutine sub
-          end module x
-          program main
-            use iso_c_binding
-            use x
-            implicit none
-            interface
-              subroutine my_routine(p) bind(c,name='myC_func')
-                import :: c_funptr
-                type(c_funptr), intent(in) :: p
-              end subroutine
-            end interface
-            call my_routine(c_funloc(sub))
-          end program main
-
-_See also_:
-     *note C_ASSOCIATED::, *note C_LOC::, *note C_F_POINTER::, *note
-     C_F_PROCPOINTER::
-
-
-File: gfortran.info,  Node: C_F_PROCPOINTER,  Next: C_FUNLOC,  Prev: C_F_POINTER,  Up: Intrinsic Procedures
-
-7.34 `C_F_PROCPOINTER' -- Convert C into Fortran procedure pointer
-==================================================================
-
-_Description_:
-     `C_F_PROCPOINTER(CPTR, FPTR)' Assign the target of the C function
-     pointer CPTR to the Fortran procedure pointer FPTR.
-
-     Note: Due to the currently lacking support of procedure pointers
-     in GNU Fortran this function is not fully operable.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL C_F_PROCPOINTER(cptr, fptr)'
-
-_Arguments_:
-     CPTR       scalar of the type `C_FUNPTR'. It is
-                `INTENT(IN)'.
-     FPTR       procedure pointer interoperable with CPTR. It
-                is `INTENT(OUT)'.
-
-_Example_:
-          program main
-            use iso_c_binding
-            implicit none
-            abstract interface
-              function func(a)
-                import :: c_float
-                real(c_float), intent(in) :: a
-                real(c_float) :: func
-              end function
-            end interface
-            interface
-               function getIterFunc() bind(c,name="getIterFunc")
-                 import :: c_funptr
-                 type(c_funptr) :: getIterFunc
-               end function
-            end interface
-            type(c_funptr) :: cfunptr
-            procedure(func), pointer :: myFunc
-            cfunptr = getIterFunc()
-            call c_f_procpointer(cfunptr, myFunc)
-          end program main
-
-_See also_:
-     *note C_LOC::, *note C_F_POINTER::
-
-
-File: gfortran.info,  Node: C_F_POINTER,  Next: C_F_PROCPOINTER,  Prev: C_ASSOCIATED,  Up: Intrinsic Procedures
-
-7.35 `C_F_POINTER' -- Convert C into Fortran pointer
-====================================================
-
-_Description_:
-     `C_F_POINTER(CPTR, FPTR[, SHAPE])' Assign the target the C pointer
-     CPTR to the Fortran pointer FPTR and specify its shape.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL C_F_POINTER(CPTR, FPTR[, SHAPE])'
-
-_Arguments_:
-     CPTR       scalar of the type `C_PTR'. It is `INTENT(IN)'.
-     FPTR       pointer interoperable with CPTR. It is
-                `INTENT(OUT)'.
-     SHAPE      (Optional) Rank-one array of type `INTEGER'
-                with `INTENT(IN)'. It shall be present if and
-                only if FPTR is an array. The size must be
-                equal to the rank of FPTR.
-
-_Example_:
-          program main
-            use iso_c_binding
-            implicit none
-            interface
-              subroutine my_routine(p) bind(c,name='myC_func')
-                import :: c_ptr
-                type(c_ptr), intent(out) :: p
-              end subroutine
-            end interface
-            type(c_ptr) :: cptr
-            real,pointer :: a(:)
-            call my_routine(cptr)
-            call c_f_pointer(cptr, a, [12])
-          end program main
-
-_See also_:
-     *note C_LOC::, *note C_F_PROCPOINTER::
-
-
-File: gfortran.info,  Node: C_LOC,  Next: C_SIZEOF,  Prev: C_FUNLOC,  Up: Intrinsic Procedures
-
-7.36 `C_LOC' -- Obtain the C address of an object
-=================================================
-
-_Description_:
-     `C_LOC(X)' determines the C address of the argument.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = C_LOC(X)'
-
-_Arguments_:
-     X          Associated scalar pointer or interoperable
-                scalar or allocated allocatable variable with
-                `TARGET' attribute.
-
-_Return value_:
-     The return value is of type `C_PTR' and contains the C address of
-     the argument.
-
-_Example_:
-          subroutine association_test(a,b)
-            use iso_c_binding, only: c_associated, c_loc, c_ptr
-            implicit none
-            real, pointer :: a
-            type(c_ptr) :: b
-            if(c_associated(b, c_loc(a))) &
-               stop 'b and a do not point to same target'
-          end subroutine association_test
-
-_See also_:
-     *note C_ASSOCIATED::, *note C_FUNLOC::, *note C_F_POINTER::, *note
-     C_F_PROCPOINTER::
-
-
-File: gfortran.info,  Node: C_SIZEOF,  Next: CEILING,  Prev: C_LOC,  Up: Intrinsic Procedures
-
-7.37 `C_SIZEOF' -- Size in bytes of an expression
-=================================================
-
-_Description_:
-     `C_SIZEOF(X)' calculates the number of bytes of storage the
-     expression `X' occupies.
-
-_Standard_:
-     Fortran 2008
-
-_Class_:
-     Intrinsic function
-
-_Syntax_:
-     `N = C_SIZEOF(X)'
-
-_Arguments_:
-     X          The argument shall be of any type, rank or
-                shape.
-
-_Return value_:
-     The return value is of type integer and of the system-dependent
-     kind C_SIZE_T (from the ISO_C_BINDING module). Its value is the
-     number of bytes occupied by the argument.  If the argument has the
-     `POINTER' attribute, the number of bytes of the storage area
-     pointed to is returned.  If the argument is of a derived type with
-     `POINTER' or `ALLOCATABLE' components, the return value doesn't
-     account for the sizes of the data pointed to by these components.
-
-_Example_:
-             use iso_c_binding
-             integer(c_int) :: i
-             real(c_float) :: r, s(5)
-             print *, (c_sizeof(s)/c_sizeof(r) == 5)
-             end
-     The example will print `.TRUE.' unless you are using a platform
-     where default `REAL' variables are unusually padded.
-
-_See also_:
-     *note SIZEOF::
-
-
-File: gfortran.info,  Node: CEILING,  Next: CHAR,  Prev: C_SIZEOF,  Up: Intrinsic Procedures
-
-7.38 `CEILING' -- Integer ceiling function
-==========================================
-
-_Description_:
-     `CEILING(A)' returns the least integer greater than or equal to A.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = CEILING(A [, KIND])'
-
-_Arguments_:
-     A          The type shall be `REAL'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER(KIND)' if KIND is present and
-     a default-kind `INTEGER' otherwise.
-
-_Example_:
-          program test_ceiling
-              real :: x = 63.29
-              real :: y = -63.59
-              print *, ceiling(x) ! returns 64
-              print *, ceiling(y) ! returns -63
-          end program test_ceiling
-
-_See also_:
-     *note FLOOR::, *note NINT::
-
-
-
-File: gfortran.info,  Node: CHAR,  Next: CHDIR,  Prev: CEILING,  Up: Intrinsic Procedures
-
-7.39 `CHAR' -- Character conversion function
-============================================
-
-_Description_:
-     `CHAR(I [, KIND])' returns the character represented by the
-     integer I.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = CHAR(I [, KIND])'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `CHARACTER(1)'
-
-_Example_:
-          program test_char
-              integer :: i = 74
-              character(1) :: c
-              c = char(i)
-              print *, i, c ! returns 'J'
-          end program test_char
-
-_Note_:
-     See *note ICHAR:: for a discussion of converting between numerical
-     values and formatted string representations.
-
-_See also_:
-     *note ACHAR::, *note IACHAR::, *note ICHAR::
-
-
-
-File: gfortran.info,  Node: CHDIR,  Next: CHMOD,  Prev: CHAR,  Up: Intrinsic Procedures
-
-7.40 `CHDIR' -- Change working directory
-========================================
-
-_Description_:
-     Change current working directory to a specified path.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL CHDIR(NAME [, STATUS])'
-     `STATUS = CHDIR(NAME)'
-
-_Arguments_:
-     NAME       The type shall be `CHARACTER' of default kind
-                and shall specify a valid path within the file
-                system.
-     STATUS     (Optional) `INTEGER' status flag of the default
-                kind.  Returns 0 on success, and a system
-                specific and nonzero error code otherwise.
-
-_Example_:
-          PROGRAM test_chdir
-            CHARACTER(len=255) :: path
-            CALL getcwd(path)
-            WRITE(*,*) TRIM(path)
-            CALL chdir("/tmp")
-            CALL getcwd(path)
-            WRITE(*,*) TRIM(path)
-          END PROGRAM
-
-_See also_:
-     *note GETCWD::
-
-
-File: gfortran.info,  Node: CHMOD,  Next: CMPLX,  Prev: CHDIR,  Up: Intrinsic Procedures
-
-7.41 `CHMOD' -- Change access permissions of files
-==================================================
-
-_Description_:
-     `CHMOD' changes the permissions of a file. This function invokes
-     `/bin/chmod' and might therefore not work on all platforms.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL CHMOD(NAME, MODE[, STATUS])'
-     `STATUS = CHMOD(NAME, MODE)'
-
-_Arguments_:
-     NAME       Scalar `CHARACTER' of default kind with the
-                file name. Trailing blanks are ignored unless
-                the character `achar(0)' is present, then all
-                characters up to and excluding `achar(0)' are
-                used as the file name.
-     MODE       Scalar `CHARACTER' of default kind giving the
-                file permission. MODE uses the same syntax as
-                the MODE argument of `/bin/chmod'.
-     STATUS     (optional) scalar `INTEGER', which is `0' on
-                success and nonzero otherwise.
-
-_Return value_:
-     In either syntax, STATUS is set to `0' on success and nonzero
-     otherwise.
-
-_Example_:
-     `CHMOD' as subroutine
-          program chmod_test
-            implicit none
-            integer :: status
-            call chmod('test.dat','u+x',status)
-            print *, 'Status: ', status
-          end program chmod_test
-     `CHMOD' as function:
-          program chmod_test
-            implicit none
-            integer :: status
-            status = chmod('test.dat','u+x')
-            print *, 'Status: ', status
-          end program chmod_test
-
-
-
-File: gfortran.info,  Node: CMPLX,  Next: COMMAND_ARGUMENT_COUNT,  Prev: CHMOD,  Up: Intrinsic Procedures
-
-7.42 `CMPLX' -- Complex conversion function
-===========================================
-
-_Description_:
-     `CMPLX(X [, Y [, KIND]])' returns a complex number where X is
-     converted to the real component.  If Y is present it is converted
-     to the imaginary component.  If Y is not present then the
-     imaginary component is set to 0.0.  If X is complex then Y must
-     not be present.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = CMPLX(X [, Y [, KIND]])'
-
-_Arguments_:
-     X          The type may be `INTEGER', `REAL', or
-                `COMPLEX'.
-     Y          (Optional; only allowed if X is not
-                `COMPLEX'.)  May be `INTEGER' or `REAL'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of `COMPLEX' type, with a kind equal to KIND
-     if it is specified.  If KIND is not specified, the result is of
-     the default `COMPLEX' kind, regardless of the kinds of X and Y.
-
-_Example_:
-          program test_cmplx
-              integer :: i = 42
-              real :: x = 3.14
-              complex :: z
-              z = cmplx(i, x)
-              print *, z, cmplx(x)
-          end program test_cmplx
-
-_See also_:
-     *note COMPLEX::
-
-
-File: gfortran.info,  Node: COMMAND_ARGUMENT_COUNT,  Next: COMPLEX,  Prev: CMPLX,  Up: Intrinsic Procedures
-
-7.43 `COMMAND_ARGUMENT_COUNT' -- Get number of command line arguments
-=====================================================================
-
-_Description_:
-     `COMMAND_ARGUMENT_COUNT()' returns the number of arguments passed
-     on the command line when the containing program was invoked.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = COMMAND_ARGUMENT_COUNT()'
-
-_Arguments_:
-     None       
-
-_Return value_:
-     The return value is of type `INTEGER(4)'
-
-_Example_:
-          program test_command_argument_count
-              integer :: count
-              count = command_argument_count()
-              print *, count
-          end program test_command_argument_count
-
-_See also_:
-     *note GET_COMMAND::, *note GET_COMMAND_ARGUMENT::
-
-
-File: gfortran.info,  Node: COMPLEX,  Next: CONJG,  Prev: COMMAND_ARGUMENT_COUNT,  Up: Intrinsic Procedures
-
-7.44 `COMPLEX' -- Complex conversion function
-=============================================
-
-_Description_:
-     `COMPLEX(X, Y)' returns a complex number where X is converted to
-     the real component and Y is converted to the imaginary component.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = COMPLEX(X, Y)'
-
-_Arguments_:
-     X          The type may be `INTEGER' or `REAL'.
-     Y          The type may be `INTEGER' or `REAL'.
-
-_Return value_:
-     If X and Y are both of `INTEGER' type, then the return value is of
-     default `COMPLEX' type.
-
-     If X and Y are of `REAL' type, or one is of `REAL' type and one is
-     of `INTEGER' type, then the return value is of `COMPLEX' type with
-     a kind equal to that of the `REAL' argument with the highest
-     precision.
-
-_Example_:
-          program test_complex
-              integer :: i = 42
-              real :: x = 3.14
-              print *, complex(i, x)
-          end program test_complex
-
-_See also_:
-     *note CMPLX::
-
-
-File: gfortran.info,  Node: CONJG,  Next: COS,  Prev: COMPLEX,  Up: Intrinsic Procedures
-
-7.45 `CONJG' -- Complex conjugate function
-==========================================
-
-_Description_:
-     `CONJG(Z)' returns the conjugate of Z.  If Z is `(x, y)' then the
-     result is `(x, -y)'
-
-_Standard_:
-     Fortran 77 and later, has overloads that are GNU extensions
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `Z = CONJG(Z)'
-
-_Arguments_:
-     Z          The type shall be `COMPLEX'.
-
-_Return value_:
-     The return value is of type `COMPLEX'.
-
-_Example_:
-          program test_conjg
-              complex :: z = (2.0, 3.0)
-              complex(8) :: dz = (2.71_8, -3.14_8)
-              z= conjg(z)
-              print *, z
-              dz = dconjg(dz)
-              print *, dz
-          end program test_conjg
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DCONJG(Z)'   `COMPLEX(8)   `COMPLEX(8)'  GNU extension
-                   Z'                          
-
-
-File: gfortran.info,  Node: COS,  Next: COSH,  Prev: CONJG,  Up: Intrinsic Procedures
-
-7.46 `COS' -- Cosine function
-=============================
-
-_Description_:
-     `COS(X)' computes the cosine of X.
-
-_Standard_:
-     Fortran 77 and later, has overloads that are GNU extensions
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = COS(X)'
-
-_Arguments_:
-     X          The type shall be `REAL' or `COMPLEX'.
-
-_Return value_:
-     The return value is of type `REAL' and it lies in the range  -1
-     \leq \cos (x) \leq 1.  The kind type parameter is the same as X.
-
-_Example_:
-          program test_cos
-            real :: x = 0.0
-            x = cos(x)
-          end program test_cos
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DCOS(X)'     `REAL(8) X'   `REAL(8)'     Fortran 77 and
-                                               later
-     `CCOS(X)'     `COMPLEX(4)   `COMPLEX(4)'  Fortran 77 and
-                   X'                          later
-     `ZCOS(X)'     `COMPLEX(8)   `COMPLEX(8)'  GNU extension
-                   X'                          
-     `CDCOS(X)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
-                   X'                          
-
-_See also_:
-     Inverse function: *note ACOS::
-
-
-
-File: gfortran.info,  Node: COSH,  Next: COUNT,  Prev: COS,  Up: Intrinsic Procedures
-
-7.47 `COSH' -- Hyperbolic cosine function
-=========================================
-
-_Description_:
-     `COSH(X)' computes the hyperbolic cosine of X.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `X = COSH(X)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of type `REAL' and it is positive ( \cosh (x)
-     \geq 0 ).  For a `REAL' argument X,  \cosh (x) \geq 1 .  The
-     return value is of the same kind as X.
-
-_Example_:
-          program test_cosh
-            real(8) :: x = 1.0_8
-            x = cosh(x)
-          end program test_cosh
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DCOSH(X)'    `REAL(8) X'   `REAL(8)'     Fortran 77 and
-                                               later
-
-_See also_:
-     Inverse function: *note ACOSH::
-
-
-
-File: gfortran.info,  Node: COUNT,  Next: CPU_TIME,  Prev: COSH,  Up: Intrinsic Procedures
-
-7.48 `COUNT' -- Count function
-==============================
-
-_Description_:
-     `COUNT(MASK [, DIM [, KIND]])' counts the number of `.TRUE.'
-     elements of MASK along the dimension of DIM.  If DIM is omitted it
-     is taken to be `1'.  DIM is a scalar of type `INTEGER' in the
-     range of 1 /leq DIM /leq n) where n is the rank of MASK.
-
-_Standard_:
-     Fortran 95 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = COUNT(MASK [, DIM [, KIND]])'
-
-_Arguments_:
-     MASK       The type shall be `LOGICAL'.
-     DIM        (Optional) The type shall be `INTEGER'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER' and of kind KIND. If KIND is
-     absent, the return value is of default integer kind.  The result
-     has a rank equal to that of MASK.
-
-_Example_:
-          program test_count
-              integer, dimension(2,3) :: a, b
-              logical, dimension(2,3) :: mask
-              a = reshape( (/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /))
-              b = reshape( (/ 0, 7, 3, 4, 5, 8 /), (/ 2, 3 /))
-              print '(3i3)', a(1,:)
-              print '(3i3)', a(2,:)
-              print *
-              print '(3i3)', b(1,:)
-              print '(3i3)', b(2,:)
-              print *
-              mask = a.ne.b
-              print '(3l3)', mask(1,:)
-              print '(3l3)', mask(2,:)
-              print *
-              print '(3i3)', count(mask)
-              print *
-              print '(3i3)', count(mask, 1)
-              print *
-              print '(3i3)', count(mask, 2)
-          end program test_count
-
-
-File: gfortran.info,  Node: CPU_TIME,  Next: CSHIFT,  Prev: COUNT,  Up: Intrinsic Procedures
-
-7.49 `CPU_TIME' -- CPU elapsed time in seconds
-==============================================
-
-_Description_:
-     Returns a `REAL' value representing the elapsed CPU time in
-     seconds.  This is useful for testing segments of code to determine
-     execution time.
-
-     If a time source is available, time will be reported with
-     microsecond resolution. If no time source is available, TIME is
-     set to `-1.0'.
-
-     Note that TIME may contain a, system dependent, arbitrary offset
-     and may not start with `0.0'. For `CPU_TIME', the absolute value
-     is meaningless, only differences between subsequent calls to this
-     subroutine, as shown in the example below, should be used.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL CPU_TIME(TIME)'
-
-_Arguments_:
-     TIME       The type shall be `REAL' with `INTENT(OUT)'.
-
-_Return value_:
-     None
-
-_Example_:
-          program test_cpu_time
-              real :: start, finish
-              call cpu_time(start)
-                  ! put code to test here
-              call cpu_time(finish)
-              print '("Time = ",f6.3," seconds.")',finish-start
-          end program test_cpu_time
-
-_See also_:
-     *note SYSTEM_CLOCK::, *note DATE_AND_TIME::
-
-
-File: gfortran.info,  Node: CSHIFT,  Next: CTIME,  Prev: CPU_TIME,  Up: Intrinsic Procedures
-
-7.50 `CSHIFT' -- Circular shift elements of an array
-====================================================
-
-_Description_:
-     `CSHIFT(ARRAY, SHIFT [, DIM])' performs a circular shift on
-     elements of ARRAY along the dimension of DIM.  If DIM is omitted
-     it is taken to be `1'.  DIM is a scalar of type `INTEGER' in the
-     range of 1 /leq DIM /leq n) where n is the rank of ARRAY.  If the
-     rank of ARRAY is one, then all elements of ARRAY are shifted by
-     SHIFT places.  If rank is greater than one, then all complete rank
-     one sections of ARRAY along the given dimension are shifted.
-     Elements shifted out one end of each rank one section are shifted
-     back in the other end.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = CSHIFT(ARRAY, SHIFT [, DIM])'
-
-_Arguments_:
-     ARRAY      Shall be an array of any type.
-     SHIFT      The type shall be `INTEGER'.
-     DIM        The type shall be `INTEGER'.
-
-_Return value_:
-     Returns an array of same type and rank as the ARRAY argument.
-
-_Example_:
-          program test_cshift
-              integer, dimension(3,3) :: a
-              a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
-              print '(3i3)', a(1,:)
-              print '(3i3)', a(2,:)
-              print '(3i3)', a(3,:)
-              a = cshift(a, SHIFT=(/1, 2, -1/), DIM=2)
-              print *
-              print '(3i3)', a(1,:)
-              print '(3i3)', a(2,:)
-              print '(3i3)', a(3,:)
-          end program test_cshift
-
-
-File: gfortran.info,  Node: CTIME,  Next: DATE_AND_TIME,  Prev: CSHIFT,  Up: Intrinsic Procedures
-
-7.51 `CTIME' -- Convert a time into a string
-============================================
-
-_Description_:
-     `CTIME' converts a system time value, such as returned by
-     `TIME8()', to a string of the form `Sat Aug 19 18:13:14 1995'.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL CTIME(TIME, RESULT)'.
-     `RESULT = CTIME(TIME)', (not recommended).
-
-_Arguments_:
-     TIME       The type shall be of type `INTEGER(KIND=8)'.
-     RESULT     The type shall be of type `CHARACTER' and of
-                default kind.
-
-_Return value_:
-     The converted date and time as a string.
-
-_Example_:
-          program test_ctime
-              integer(8) :: i
-              character(len=30) :: date
-              i = time8()
-
-              ! Do something, main part of the program
-
-              call ctime(i,date)
-              print *, 'Program was started on ', date
-          end program test_ctime
-
-_See Also_:
-     *note GMTIME::, *note LTIME::, *note TIME::, *note TIME8::
-
-
-File: gfortran.info,  Node: DATE_AND_TIME,  Next: DBLE,  Prev: CTIME,  Up: Intrinsic Procedures
-
-7.52 `DATE_AND_TIME' -- Date and time subroutine
-================================================
-
-_Description_:
-     `DATE_AND_TIME(DATE, TIME, ZONE, VALUES)' gets the corresponding
-     date and time information from the real-time system clock.  DATE is
-     `INTENT(OUT)' and has form ccyymmdd.  TIME is `INTENT(OUT)' and
-     has form hhmmss.sss.  ZONE is `INTENT(OUT)' and has form (+-)hhmm,
-     representing the difference with respect to Coordinated Universal
-     Time (UTC).  Unavailable time and date parameters return blanks.
-
-     VALUES is `INTENT(OUT)' and provides the following:
-
-                `VALUE(1)':          The year
-                `VALUE(2)':          The month
-                `VALUE(3)':          The day of the month
-                `VALUE(4)':          Time difference with UTC
-                                     in minutes
-                `VALUE(5)':          The hour of the day
-                `VALUE(6)':          The minutes of the hour
-                `VALUE(7)':          The seconds of the minute
-                `VALUE(8)':          The milliseconds of the
-                                     second
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL DATE_AND_TIME([DATE, TIME, ZONE, VALUES])'
-
-_Arguments_:
-     DATE       (Optional) The type shall be `CHARACTER(LEN=8)'
-                or larger, and of default kind.
-     TIME       (Optional) The type shall be
-                `CHARACTER(LEN=10)' or larger, and of default
-                kind.
-     ZONE       (Optional) The type shall be `CHARACTER(LEN=5)'
-                or larger, and of default kind.
-     VALUES     (Optional) The type shall be `INTEGER(8)'.
-
-_Return value_:
-     None
-
-_Example_:
-          program test_time_and_date
-              character(8)  :: date
-              character(10) :: time
-              character(5)  :: zone
-              integer,dimension(8) :: values
-              ! using keyword arguments
-              call date_and_time(date,time,zone,values)
-              call date_and_time(DATE=date,ZONE=zone)
-              call date_and_time(TIME=time)
-              call date_and_time(VALUES=values)
-              print '(a,2x,a,2x,a)', date, time, zone
-              print '(8i5))', values
-          end program test_time_and_date
-
-_See also_:
-     *note CPU_TIME::, *note SYSTEM_CLOCK::
-
-
-File: gfortran.info,  Node: DBLE,  Next: DCMPLX,  Prev: DATE_AND_TIME,  Up: Intrinsic Procedures
-
-7.53 `DBLE' -- Double conversion function
-=========================================
-
-_Description_:
-     `DBLE(A)' Converts A to double precision real type.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = DBLE(A)'
-
-_Arguments_:
-     A          The type shall be `INTEGER', `REAL', or
-                `COMPLEX'.
-
-_Return value_:
-     The return value is of type double precision real.
-
-_Example_:
-          program test_dble
-              real    :: x = 2.18
-              integer :: i = 5
-              complex :: z = (2.3,1.14)
-              print *, dble(x), dble(i), dble(z)
-          end program test_dble
-
-_See also_:
-     *note DFLOAT::, *note FLOAT::, *note REAL::
-
-
-File: gfortran.info,  Node: DCMPLX,  Next: DFLOAT,  Prev: DBLE,  Up: Intrinsic Procedures
-
-7.54 `DCMPLX' -- Double complex conversion function
-===================================================
-
-_Description_:
-     `DCMPLX(X [,Y])' returns a double complex number where X is
-     converted to the real component.  If Y is present it is converted
-     to the imaginary component.  If Y is not present then the
-     imaginary component is set to 0.0.  If X is complex then Y must
-     not be present.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = DCMPLX(X [, Y])'
-
-_Arguments_:
-     X          The type may be `INTEGER', `REAL', or
-                `COMPLEX'.
-     Y          (Optional if X is not `COMPLEX'.) May be
-                `INTEGER' or `REAL'.
-
-_Return value_:
-     The return value is of type `COMPLEX(8)'
-
-_Example_:
-          program test_dcmplx
-              integer :: i = 42
-              real :: x = 3.14
-              complex :: z
-              z = cmplx(i, x)
-              print *, dcmplx(i)
-              print *, dcmplx(x)
-              print *, dcmplx(z)
-              print *, dcmplx(x,i)
-          end program test_dcmplx
-
-
-File: gfortran.info,  Node: DFLOAT,  Next: DIGITS,  Prev: DCMPLX,  Up: Intrinsic Procedures
-
-7.55 `DFLOAT' -- Double conversion function
-===========================================
-
-_Description_:
-     `DFLOAT(A)' Converts A to double precision real type.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = DFLOAT(A)'
-
-_Arguments_:
-     A          The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type double precision real.
-
-_Example_:
-          program test_dfloat
-              integer :: i = 5
-              print *, dfloat(i)
-          end program test_dfloat
-
-_See also_:
-     *note DBLE::, *note FLOAT::, *note REAL::
-
-
-File: gfortran.info,  Node: DIGITS,  Next: DIM,  Prev: DFLOAT,  Up: Intrinsic Procedures
-
-7.56 `DIGITS' -- Significant binary digits function
-===================================================
-
-_Description_:
-     `DIGITS(X)' returns the number of significant binary digits of the
-     internal model representation of X.  For example, on a system
-     using a 32-bit floating point representation, a default real
-     number would likely return 24.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = DIGITS(X)'
-
-_Arguments_:
-     X          The type may be `INTEGER' or `REAL'.
-
-_Return value_:
-     The return value is of type `INTEGER'.
-
-_Example_:
-          program test_digits
-              integer :: i = 12345
-              real :: x = 3.143
-              real(8) :: y = 2.33
-              print *, digits(i)
-              print *, digits(x)
-              print *, digits(y)
-          end program test_digits
-
-
-File: gfortran.info,  Node: DIM,  Next: DOT_PRODUCT,  Prev: DIGITS,  Up: Intrinsic Procedures
-
-7.57 `DIM' -- Positive difference
-=================================
-
-_Description_:
-     `DIM(X,Y)' returns the difference `X-Y' if the result is positive;
-     otherwise returns zero.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = DIM(X, Y)'
-
-_Arguments_:
-     X          The type shall be `INTEGER' or `REAL'
-     Y          The type shall be the same type and kind as X.
-
-_Return value_:
-     The return value is of type `INTEGER' or `REAL'.
-
-_Example_:
-          program test_dim
-              integer :: i
-              real(8) :: x
-              i = dim(4, 15)
-              x = dim(4.345_8, 2.111_8)
-              print *, i
-              print *, x
-          end program test_dim
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `IDIM(X,Y)'   `INTEGER(4)   `INTEGER(4)'  Fortran 77 and
-                   X,Y'                        later
-     `DDIM(X,Y)'   `REAL(8)      `REAL(8)'     Fortran 77 and
-                   X,Y'                        later
-
-
-File: gfortran.info,  Node: DOT_PRODUCT,  Next: DPROD,  Prev: DIM,  Up: Intrinsic Procedures
-
-7.58 `DOT_PRODUCT' -- Dot product function
-==========================================
-
-_Description_:
-     `DOT_PRODUCT(VECTOR_A, VECTOR_B)' computes the dot product
-     multiplication of two vectors VECTOR_A and VECTOR_B.  The two
-     vectors may be either numeric or logical and must be arrays of
-     rank one and of equal size. If the vectors are `INTEGER' or
-     `REAL', the result is `SUM(VECTOR_A*VECTOR_B)'. If the vectors are
-     `COMPLEX', the result is `SUM(CONJG(VECTOR_A)*VECTOR_B)'. If the
-     vectors are `LOGICAL', the result is `ANY(VECTOR_A .AND.
-     VECTOR_B)'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = DOT_PRODUCT(VECTOR_A, VECTOR_B)'
-
-_Arguments_:
-     VECTOR_A   The type shall be numeric or `LOGICAL', rank 1.
-     VECTOR_B   The type shall be numeric if VECTOR_A is of
-                numeric type or `LOGICAL' if VECTOR_A is of
-                type `LOGICAL'. VECTOR_B shall be a rank-one
-                array.
-
-_Return value_:
-     If the arguments are numeric, the return value is a scalar of
-     numeric type, `INTEGER', `REAL', or `COMPLEX'.  If the arguments
-     are `LOGICAL', the return value is `.TRUE.' or `.FALSE.'.
-
-_Example_:
-          program test_dot_prod
-              integer, dimension(3) :: a, b
-              a = (/ 1, 2, 3 /)
-              b = (/ 4, 5, 6 /)
-              print '(3i3)', a
-              print *
-              print '(3i3)', b
-              print *
-              print *, dot_product(a,b)
-          end program test_dot_prod
-
-
-File: gfortran.info,  Node: DPROD,  Next: DREAL,  Prev: DOT_PRODUCT,  Up: Intrinsic Procedures
-
-7.59 `DPROD' -- Double product function
-=======================================
-
-_Description_:
-     `DPROD(X,Y)' returns the product `X*Y'.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = DPROD(X, Y)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-     Y          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of type `REAL(8)'.
-
-_Example_:
-          program test_dprod
-              real :: x = 5.2
-              real :: y = 2.3
-              real(8) :: d
-              d = dprod(x,y)
-              print *, d
-          end program test_dprod
-
-
-File: gfortran.info,  Node: DREAL,  Next: DTIME,  Prev: DPROD,  Up: Intrinsic Procedures
-
-7.60 `DREAL' -- Double real part function
-=========================================
-
-_Description_:
-     `DREAL(Z)' returns the real part of complex variable Z.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = DREAL(A)'
-
-_Arguments_:
-     A          The type shall be `COMPLEX(8)'.
-
-_Return value_:
-     The return value is of type `REAL(8)'.
-
-_Example_:
-          program test_dreal
-              complex(8) :: z = (1.3_8,7.2_8)
-              print *, dreal(z)
-          end program test_dreal
-
-_See also_:
-     *note AIMAG::
-
-
-
-File: gfortran.info,  Node: DTIME,  Next: EOSHIFT,  Prev: DREAL,  Up: Intrinsic Procedures
-
-7.61 `DTIME' -- Execution time subroutine (or function)
-=======================================================
-
-_Description_:
-     `DTIME(TARRAY, RESULT)' initially returns the number of seconds of
-     runtime since the start of the process's execution in RESULT.
-     TARRAY returns the user and system components of this time in
-     `TARRAY(1)' and `TARRAY(2)' respectively. RESULT is equal to
-     `TARRAY(1) + TARRAY(2)'.
-
-     Subsequent invocations of `DTIME' return values accumulated since
-     the previous invocation.
-
-     On some systems, the underlying timings are represented using
-     types with sufficiently small limits that overflows (wrap around)
-     are possible, such as 32-bit types. Therefore, the values returned
-     by this intrinsic might be, or become, negative, or numerically
-     less than previous values, during a single run of the compiled
-     program.
-
-     Please note, that this implementation is thread safe if used
-     within OpenMP directives, i.e., its state will be consistent while
-     called from multiple threads. However, if `DTIME' is called from
-     multiple threads, the result is still the time since the last
-     invocation. This may not give the intended results. If possible,
-     use `CPU_TIME' instead.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-     TARRAY and RESULT are `INTENT(OUT)' and provide the following:
-
-                `TARRAY(1)':         User time in seconds.
-                `TARRAY(2)':         System time in seconds.
-                `RESULT':            Run time since start in
-                                     seconds.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL DTIME(TARRAY, RESULT)'.
-     `RESULT = DTIME(TARRAY)', (not recommended).
-
-_Arguments_:
-     TARRAY     The type shall be `REAL, DIMENSION(2)'.
-     RESULT     The type shall be `REAL'.
-
-_Return value_:
-     Elapsed time in seconds since the last invocation or since the
-     start of program execution if not called before.
-
-_Example_:
-          program test_dtime
-              integer(8) :: i, j
-              real, dimension(2) :: tarray
-              real :: result
-              call dtime(tarray, result)
-              print *, result
-              print *, tarray(1)
-              print *, tarray(2)
-              do i=1,100000000    ! Just a delay
-                  j = i * i - i
-              end do
-              call dtime(tarray, result)
-              print *, result
-              print *, tarray(1)
-              print *, tarray(2)
-          end program test_dtime
-
-_See also_:
-     *note CPU_TIME::
-
-
-
-File: gfortran.info,  Node: EOSHIFT,  Next: EPSILON,  Prev: DTIME,  Up: Intrinsic Procedures
-
-7.62 `EOSHIFT' -- End-off shift elements of an array
-====================================================
-
-_Description_:
-     `EOSHIFT(ARRAY, SHIFT[, BOUNDARY, DIM])' performs an end-off shift
-     on elements of ARRAY along the dimension of DIM.  If DIM is
-     omitted it is taken to be `1'.  DIM is a scalar of type `INTEGER'
-     in the range of 1 /leq DIM /leq n) where n is the rank of ARRAY.
-     If the rank of ARRAY is one, then all elements of ARRAY are
-     shifted by SHIFT places.  If rank is greater than one, then all
-     complete rank one sections of ARRAY along the given dimension are
-     shifted.  Elements shifted out one end of each rank one section
-     are dropped.  If BOUNDARY is present then the corresponding value
-     of from BOUNDARY is copied back in the other end.  If BOUNDARY is
-     not present then the following are copied in depending on the type
-     of ARRAY.
-
-     _Array     _Boundary Value_
-     Type_      
-     Numeric    0 of the type and kind of ARRAY.
-     Logical    `.FALSE.'.
-     Character(LEN)LEN blanks.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = EOSHIFT(ARRAY, SHIFT [, BOUNDARY, DIM])'
-
-_Arguments_:
-     ARRAY      May be any type, not scalar.
-     SHIFT      The type shall be `INTEGER'.
-     BOUNDARY   Same type as ARRAY.
-     DIM        The type shall be `INTEGER'.
-
-_Return value_:
-     Returns an array of same type and rank as the ARRAY argument.
-
-_Example_:
-          program test_eoshift
-              integer, dimension(3,3) :: a
-              a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
-              print '(3i3)', a(1,:)
-              print '(3i3)', a(2,:)
-              print '(3i3)', a(3,:)
-              a = EOSHIFT(a, SHIFT=(/1, 2, 1/), BOUNDARY=-5, DIM=2)
-              print *
-              print '(3i3)', a(1,:)
-              print '(3i3)', a(2,:)
-              print '(3i3)', a(3,:)
-          end program test_eoshift
-
-
-File: gfortran.info,  Node: EPSILON,  Next: ERF,  Prev: EOSHIFT,  Up: Intrinsic Procedures
-
-7.63 `EPSILON' -- Epsilon function
-==================================
-
-_Description_:
-     `EPSILON(X)' returns the smallest number E of the same kind as X
-     such that 1 + E > 1.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = EPSILON(X)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of same type as the argument.
-
-_Example_:
-          program test_epsilon
-              real :: x = 3.143
-              real(8) :: y = 2.33
-              print *, EPSILON(x)
-              print *, EPSILON(y)
-          end program test_epsilon
-
-
-File: gfortran.info,  Node: ERF,  Next: ERFC,  Prev: EPSILON,  Up: Intrinsic Procedures
-
-7.64 `ERF' -- Error function
-============================
-
-_Description_:
-     `ERF(X)' computes the error function of X.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ERF(X)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of type `REAL', of the same kind as X and lies
-     in the range -1 \leq erf (x) \leq 1 .
-
-_Example_:
-          program test_erf
-            real(8) :: x = 0.17_8
-            x = erf(x)
-          end program test_erf
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DERF(X)'     `REAL(8) X'   `REAL(8)'     GNU extension
-
-
-File: gfortran.info,  Node: ERFC,  Next: ERFC_SCALED,  Prev: ERF,  Up: Intrinsic Procedures
-
-7.65 `ERFC' -- Error function
-=============================
-
-_Description_:
-     `ERFC(X)' computes the complementary error function of X.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ERFC(X)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of type `REAL' and of the same kind as X.  It
-     lies in the range  0 \leq erfc (x) \leq 2 .
-
-_Example_:
-          program test_erfc
-            real(8) :: x = 0.17_8
-            x = erfc(x)
-          end program test_erfc
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DERFC(X)'    `REAL(8) X'   `REAL(8)'     GNU extension
-
-
-File: gfortran.info,  Node: ERFC_SCALED,  Next: ETIME,  Prev: ERFC,  Up: Intrinsic Procedures
-
-7.66 `ERFC_SCALED' -- Error function
-====================================
-
-_Description_:
-     `ERFC_SCALED(X)' computes the exponentially-scaled complementary
-     error function of X.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ERFC_SCALED(X)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of type `REAL' and of the same kind as X.
-
-_Example_:
-          program test_erfc_scaled
-            real(8) :: x = 0.17_8
-            x = erfc_scaled(x)
-          end program test_erfc_scaled
-
-
-File: gfortran.info,  Node: ETIME,  Next: EXIT,  Prev: ERFC_SCALED,  Up: Intrinsic Procedures
-
-7.67 `ETIME' -- Execution time subroutine (or function)
-=======================================================
-
-_Description_:
-     `ETIME(TARRAY, RESULT)' returns the number of seconds of runtime
-     since the start of the process's execution in RESULT.  TARRAY
-     returns the user and system components of this time in `TARRAY(1)'
-     and `TARRAY(2)' respectively. RESULT is equal to `TARRAY(1) +
-     TARRAY(2)'.
-
-     On some systems, the underlying timings are represented using
-     types with sufficiently small limits that overflows (wrap around)
-     are possible, such as 32-bit types. Therefore, the values returned
-     by this intrinsic might be, or become, negative, or numerically
-     less than previous values, during a single run of the compiled
-     program.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-     TARRAY and RESULT are `INTENT(OUT)' and provide the following:
-
-                `TARRAY(1)':         User time in seconds.
-                `TARRAY(2)':         System time in seconds.
-                `RESULT':            Run time since start in seconds.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL ETIME(TARRAY, RESULT)'.
-     `RESULT = ETIME(TARRAY)', (not recommended).
-
-_Arguments_:
-     TARRAY     The type shall be `REAL, DIMENSION(2)'.
-     RESULT     The type shall be `REAL'.
-
-_Return value_:
-     Elapsed time in seconds since the start of program execution.
-
-_Example_:
-          program test_etime
-              integer(8) :: i, j
-              real, dimension(2) :: tarray
-              real :: result
-              call ETIME(tarray, result)
-              print *, result
-              print *, tarray(1)
-              print *, tarray(2)
-              do i=1,100000000    ! Just a delay
-                  j = i * i - i
-              end do
-              call ETIME(tarray, result)
-              print *, result
-              print *, tarray(1)
-              print *, tarray(2)
-          end program test_etime
-
-_See also_:
-     *note CPU_TIME::
-
-
-
-File: gfortran.info,  Node: EXIT,  Next: EXP,  Prev: ETIME,  Up: Intrinsic Procedures
-
-7.68 `EXIT' -- Exit the program with status.
-============================================
-
-_Description_:
-     `EXIT' causes immediate termination of the program with status.
-     If status is omitted it returns the canonical _success_ for the
-     system.  All Fortran I/O units are closed.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL EXIT([STATUS])'
-
-_Arguments_:
-     STATUS     Shall be an `INTEGER' of the default kind.
-
-_Return value_:
-     `STATUS' is passed to the parent process on exit.
-
-_Example_:
-          program test_exit
-            integer :: STATUS = 0
-            print *, 'This program is going to exit.'
-            call EXIT(STATUS)
-          end program test_exit
-
-_See also_:
-     *note ABORT::, *note KILL::
-
-
-File: gfortran.info,  Node: EXP,  Next: EXPONENT,  Prev: EXIT,  Up: Intrinsic Procedures
-
-7.69 `EXP' -- Exponential function
-==================================
-
-_Description_:
-     `EXP(X)' computes the base e exponential of X.
-
-_Standard_:
-     Fortran 77 and later, has overloads that are GNU extensions
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = EXP(X)'
-
-_Arguments_:
-     X          The type shall be `REAL' or `COMPLEX'.
-
-_Return value_:
-     The return value has same type and kind as X.
-
-_Example_:
-          program test_exp
-            real :: x = 1.0
-            x = exp(x)
-          end program test_exp
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DEXP(X)'     `REAL(8) X'   `REAL(8)'     Fortran 77 and
-                                               later
-     `CEXP(X)'     `COMPLEX(4)   `COMPLEX(4)'  Fortran 77 and
-                   X'                          later
-     `ZEXP(X)'     `COMPLEX(8)   `COMPLEX(8)'  GNU extension
-                   X'                          
-     `CDEXP(X)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
-                   X'                          
-
-
-File: gfortran.info,  Node: EXPONENT,  Next: FDATE,  Prev: EXP,  Up: Intrinsic Procedures
-
-7.70 `EXPONENT' -- Exponent function
-====================================
-
-_Description_:
-     `EXPONENT(X)' returns the value of the exponent part of X. If X is
-     zero the value returned is zero.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = EXPONENT(X)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of type default `INTEGER'.
-
-_Example_:
-          program test_exponent
-            real :: x = 1.0
-            integer :: i
-            i = exponent(x)
-            print *, i
-            print *, exponent(0.0)
-          end program test_exponent
-
-
-File: gfortran.info,  Node: FDATE,  Next: FGET,  Prev: EXPONENT,  Up: Intrinsic Procedures
-
-7.71 `FDATE' -- Get the current time as a string
-================================================
-
-_Description_:
-     `FDATE(DATE)' returns the current date (using the same format as
-     `CTIME') in DATE. It is equivalent to `CALL CTIME(DATE, TIME())'.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-     DATE is an `INTENT(OUT)' `CHARACTER' variable of the default kind.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL FDATE(DATE)'.
-     `DATE = FDATE()', (not recommended).
-
-_Arguments_:
-     DATE       The type shall be of type `CHARACTER' of the
-                default kind
-
-_Return value_:
-     The current date as a string.
-
-_Example_:
-          program test_fdate
-              integer(8) :: i, j
-              character(len=30) :: date
-              call fdate(date)
-              print *, 'Program started on ', date
-              do i = 1, 100000000 ! Just a delay
-                  j = i * i - i
-              end do
-              call fdate(date)
-              print *, 'Program ended on ', date
-          end program test_fdate
-
-
-File: gfortran.info,  Node: FLOAT,  Next: FLOOR,  Prev: FGETC,  Up: Intrinsic Procedures
-
-7.72 `FLOAT' -- Convert integer to default real
-===============================================
-
-_Description_:
-     `FLOAT(A)' converts the integer A to a default real value.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = FLOAT(A)'
-
-_Arguments_:
-     A          The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type default `REAL'.
-
-_Example_:
-          program test_float
-              integer :: i = 1
-              if (float(i) /= 1.) call abort
-          end program test_float
-
-_See also_:
-     *note DBLE::, *note DFLOAT::, *note REAL::
-
-
-File: gfortran.info,  Node: FGET,  Next: FGETC,  Prev: FDATE,  Up: Intrinsic Procedures
-
-7.73 `FGET' -- Read a single character in stream mode from stdin
-================================================================
-
-_Description_:
-     Read a single character in stream mode from stdin by bypassing
-     normal formatted output. Stream I/O should not be mixed with
-     normal record-oriented (formatted or unformatted) I/O on the same
-     unit; the results are unpredictable.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-     Note that the `FGET' intrinsic is provided for backwards
-     compatibility with `g77'.  GNU Fortran provides the Fortran 2003
-     Stream facility.  Programmers should consider the use of new
-     stream IO feature in new code for future portability. See also
-     *note Fortran 2003 status::.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL FGET(C [, STATUS])'
-
-_Arguments_:
-     C          The type shall be `CHARACTER' and of default
-                kind.
-     STATUS     (Optional) status flag of type `INTEGER'.
-                Returns 0 on success, -1 on end-of-file, and a
-                system specific positive error code otherwise.
-
-_Example_:
-          PROGRAM test_fget
-            INTEGER, PARAMETER :: strlen = 100
-            INTEGER :: status, i = 1
-            CHARACTER(len=strlen) :: str = ""
-
-            WRITE (*,*) 'Enter text:'
-            DO
-              CALL fget(str(i:i), status)
-              if (status /= 0 .OR. i > strlen) exit
-              i = i + 1
-            END DO
-            WRITE (*,*) TRIM(str)
-          END PROGRAM
-
-_See also_:
-     *note FGETC::, *note FPUT::, *note FPUTC::
-
-
-File: gfortran.info,  Node: FGETC,  Next: FLOAT,  Prev: FGET,  Up: Intrinsic Procedures
-
-7.74 `FGETC' -- Read a single character in stream mode
-======================================================
-
-_Description_:
-     Read a single character in stream mode by bypassing normal
-     formatted output.  Stream I/O should not be mixed with normal
-     record-oriented (formatted or unformatted) I/O on the same unit;
-     the results are unpredictable.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-     Note that the `FGET' intrinsic is provided for backwards
-     compatibility with `g77'.  GNU Fortran provides the Fortran 2003
-     Stream facility.  Programmers should consider the use of new
-     stream IO feature in new code for future portability. See also
-     *note Fortran 2003 status::.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL FGETC(UNIT, C [, STATUS])'
-
-_Arguments_:
-     UNIT       The type shall be `INTEGER'.
-     C          The type shall be `CHARACTER' and of default
-                kind.
-     STATUS     (Optional) status flag of type `INTEGER'.
-                Returns 0 on success, -1 on end-of-file and a
-                system specific positive error code otherwise.
-
-_Example_:
-          PROGRAM test_fgetc
-            INTEGER :: fd = 42, status
-            CHARACTER :: c
-
-            OPEN(UNIT=fd, FILE="/etc/passwd", ACTION="READ", STATUS = "OLD")
-            DO
-              CALL fgetc(fd, c, status)
-              IF (status /= 0) EXIT
-              call fput(c)
-            END DO
-            CLOSE(UNIT=fd)
-          END PROGRAM
-
-_See also_:
-     *note FGET::, *note FPUT::, *note FPUTC::
-
-
-File: gfortran.info,  Node: FLOOR,  Next: FLUSH,  Prev: FLOAT,  Up: Intrinsic Procedures
-
-7.75 `FLOOR' -- Integer floor function
-======================================
-
-_Description_:
-     `FLOOR(A)' returns the greatest integer less than or equal to X.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = FLOOR(A [, KIND])'
-
-_Arguments_:
-     A          The type shall be `REAL'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER(KIND)' if KIND is present and
-     of default-kind `INTEGER' otherwise.
-
-_Example_:
-          program test_floor
-              real :: x = 63.29
-              real :: y = -63.59
-              print *, floor(x) ! returns 63
-              print *, floor(y) ! returns -64
-          end program test_floor
-
-_See also_:
-     *note CEILING::, *note NINT::
-
-
-
-File: gfortran.info,  Node: FLUSH,  Next: FNUM,  Prev: FLOOR,  Up: Intrinsic Procedures
-
-7.76 `FLUSH' -- Flush I/O unit(s)
-=================================
-
-_Description_:
-     Flushes Fortran unit(s) currently open for output. Without the
-     optional argument, all units are flushed, otherwise just the unit
-     specified.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL FLUSH(UNIT)'
-
-_Arguments_:
-     UNIT       (Optional) The type shall be `INTEGER'.
-
-_Note_:
-     Beginning with the Fortran 2003 standard, there is a `FLUSH'
-     statement that should be preferred over the `FLUSH' intrinsic.
-
-
-
-File: gfortran.info,  Node: FNUM,  Next: FPUT,  Prev: FLUSH,  Up: Intrinsic Procedures
-
-7.77 `FNUM' -- File number function
-===================================
-
-_Description_:
-     `FNUM(UNIT)' returns the POSIX file descriptor number
-     corresponding to the open Fortran I/O unit `UNIT'.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = FNUM(UNIT)'
-
-_Arguments_:
-     UNIT       The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type `INTEGER'
-
-_Example_:
-          program test_fnum
-            integer :: i
-            open (unit=10, status = "scratch")
-            i = fnum(10)
-            print *, i
-            close (10)
-          end program test_fnum
-
-
-File: gfortran.info,  Node: FPUT,  Next: FPUTC,  Prev: FNUM,  Up: Intrinsic Procedures
-
-7.78 `FPUT' -- Write a single character in stream mode to stdout
-================================================================
-
-_Description_:
-     Write a single character in stream mode to stdout by bypassing
-     normal formatted output. Stream I/O should not be mixed with
-     normal record-oriented (formatted or unformatted) I/O on the same
-     unit; the results are unpredictable.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-     Note that the `FGET' intrinsic is provided for backwards
-     compatibility with `g77'.  GNU Fortran provides the Fortran 2003
-     Stream facility.  Programmers should consider the use of new
-     stream IO feature in new code for future portability. See also
-     *note Fortran 2003 status::.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL FPUT(C [, STATUS])'
-
-_Arguments_:
-     C          The type shall be `CHARACTER' and of default
-                kind.
-     STATUS     (Optional) status flag of type `INTEGER'.
-                Returns 0 on success, -1 on end-of-file and a
-                system specific positive error code otherwise.
-
-_Example_:
-          PROGRAM test_fput
-            CHARACTER(len=10) :: str = "gfortran"
-            INTEGER :: i
-            DO i = 1, len_trim(str)
-              CALL fput(str(i:i))
-            END DO
-          END PROGRAM
-
-_See also_:
-     *note FPUTC::, *note FGET::, *note FGETC::
-
-
-File: gfortran.info,  Node: FPUTC,  Next: FRACTION,  Prev: FPUT,  Up: Intrinsic Procedures
-
-7.79 `FPUTC' -- Write a single character in stream mode
-=======================================================
-
-_Description_:
-     Write a single character in stream mode by bypassing normal
-     formatted output. Stream I/O should not be mixed with normal
-     record-oriented (formatted or unformatted) I/O on the same unit;
-     the results are unpredictable.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-     Note that the `FGET' intrinsic is provided for backwards
-     compatibility with `g77'.  GNU Fortran provides the Fortran 2003
-     Stream facility.  Programmers should consider the use of new
-     stream IO feature in new code for future portability. See also
-     *note Fortran 2003 status::.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL FPUTC(UNIT, C [, STATUS])'
-
-_Arguments_:
-     UNIT       The type shall be `INTEGER'.
-     C          The type shall be `CHARACTER' and of default
-                kind.
-     STATUS     (Optional) status flag of type `INTEGER'.
-                Returns 0 on success, -1 on end-of-file and a
-                system specific positive error code otherwise.
-
-_Example_:
-          PROGRAM test_fputc
-            CHARACTER(len=10) :: str = "gfortran"
-            INTEGER :: fd = 42, i
-
-            OPEN(UNIT = fd, FILE = "out", ACTION = "WRITE", STATUS="NEW")
-            DO i = 1, len_trim(str)
-              CALL fputc(fd, str(i:i))
-            END DO
-            CLOSE(fd)
-          END PROGRAM
-
-_See also_:
-     *note FPUT::, *note FGET::, *note FGETC::
-
-
-File: gfortran.info,  Node: FRACTION,  Next: FREE,  Prev: FPUTC,  Up: Intrinsic Procedures
-
-7.80 `FRACTION' -- Fractional part of the model representation
-==============================================================
-
-_Description_:
-     `FRACTION(X)' returns the fractional part of the model
-     representation of `X'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `Y = FRACTION(X)'
-
-_Arguments_:
-     X          The type of the argument shall be a `REAL'.
-
-_Return value_:
-     The return value is of the same type and kind as the argument.
-     The fractional part of the model representation of `X' is returned;
-     it is `X * RADIX(X)**(-EXPONENT(X))'.
-
-_Example_:
-          program test_fraction
-            real :: x
-            x = 178.1387e-4
-            print *, fraction(x), x * radix(x)**(-exponent(x))
-          end program test_fraction
-
-
-
-File: gfortran.info,  Node: FREE,  Next: FSEEK,  Prev: FRACTION,  Up: Intrinsic Procedures
-
-7.81 `FREE' -- Frees memory
-===========================
-
-_Description_:
-     Frees memory previously allocated by `MALLOC()'. The `FREE'
-     intrinsic is an extension intended to be used with Cray pointers,
-     and is provided in GNU Fortran to allow user to compile legacy
-     code. For new code using Fortran 95 pointers, the memory
-     de-allocation intrinsic is `DEALLOCATE'.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL FREE(PTR)'
-
-_Arguments_:
-     PTR        The type shall be `INTEGER'. It represents the
-                location of the memory that should be
-                de-allocated.
-
-_Return value_:
-     None
-
-_Example_:
-     See `MALLOC' for an example.
-
-_See also_:
-     *note MALLOC::
-
-
-File: gfortran.info,  Node: FSEEK,  Next: FSTAT,  Prev: FREE,  Up: Intrinsic Procedures
-
-7.82 `FSEEK' -- Low level file positioning subroutine
-=====================================================
-
-_Description_:
-     Moves UNIT to the specified OFFSET. If WHENCE is set to 0, the
-     OFFSET is taken as an absolute value `SEEK_SET', if set to 1,
-     OFFSET is taken to be relative to the current position `SEEK_CUR',
-     and if set to 2 relative to the end of the file `SEEK_END'.  On
-     error, STATUS is set to a nonzero value. If STATUS the seek fails
-     silently.
-
-     This intrinsic routine is not fully backwards compatible with
-     `g77'.  In `g77', the `FSEEK' takes a statement label instead of a
-     STATUS variable. If FSEEK is used in old code, change
-            CALL FSEEK(UNIT, OFFSET, WHENCE, *label)
-     to
-            INTEGER :: status
-            CALL FSEEK(UNIT, OFFSET, WHENCE, status)
-            IF (status /= 0) GOTO label
-
-     Please note that GNU Fortran provides the Fortran 2003 Stream
-     facility.  Programmers should consider the use of new stream IO
-     feature in new code for future portability. See also *note Fortran
-     2003 status::.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL FSEEK(UNIT, OFFSET, WHENCE[, STATUS])'
-
-_Arguments_:
-     UNIT       Shall be a scalar of type `INTEGER'.
-     OFFSET     Shall be a scalar of type `INTEGER'.
-     WHENCE     Shall be a scalar of type `INTEGER'.  Its
-                value shall be either 0, 1 or 2.
-     STATUS     (Optional) shall be a scalar of type
-                `INTEGER(4)'.
-
-_Example_:
-          PROGRAM test_fseek
-            INTEGER, PARAMETER :: SEEK_SET = 0, SEEK_CUR = 1, SEEK_END = 2
-            INTEGER :: fd, offset, ierr
-
-            ierr   = 0
-            offset = 5
-            fd     = 10
-
-            OPEN(UNIT=fd, FILE="fseek.test")
-            CALL FSEEK(fd, offset, SEEK_SET, ierr)  ! move to OFFSET
-            print *, FTELL(fd), ierr
-
-            CALL FSEEK(fd, 0, SEEK_END, ierr)       ! move to end
-            print *, FTELL(fd), ierr
-
-            CALL FSEEK(fd, 0, SEEK_SET, ierr)       ! move to beginning
-            print *, FTELL(fd), ierr
-
-            CLOSE(UNIT=fd)
-          END PROGRAM
-
-_See also_:
-     *note FTELL::
-
-
-File: gfortran.info,  Node: FSTAT,  Next: FTELL,  Prev: FSEEK,  Up: Intrinsic Procedures
-
-7.83 `FSTAT' -- Get file status
-===============================
-
-_Description_:
-     `FSTAT' is identical to *note STAT::, except that information
-     about an already opened file is obtained.
-
-     The elements in `BUFF' are the same as described by *note STAT::.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL FSTAT(UNIT, BUFF [, STATUS])'
-
-_Arguments_:
-     UNIT       An open I/O unit number of type `INTEGER'.
-     BUFF       The type shall be `INTEGER(4), DIMENSION(13)'.
-     STATUS     (Optional) status flag of type `INTEGER(4)'.
-                Returns 0 on success and a system specific
-                error code otherwise.
-
-_Example_:
-     See *note STAT:: for an example.
-
-_See also_:
-     To stat a link: *note LSTAT::, to stat a file: *note STAT::
-
-
-File: gfortran.info,  Node: FTELL,  Next: GAMMA,  Prev: FSTAT,  Up: Intrinsic Procedures
-
-7.84 `FTELL' -- Current stream position
-=======================================
-
-_Description_:
-     Retrieves the current position within an open file.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL FTELL(UNIT, OFFSET)'
-     `OFFSET = FTELL(UNIT)'
-
-_Arguments_:
-     OFFSET     Shall of type `INTEGER'.
-     UNIT       Shall of type `INTEGER'.
-
-_Return value_:
-     In either syntax, OFFSET is set to the current offset of unit
-     number UNIT, or to -1 if the unit is not currently open.
-
-_Example_:
-          PROGRAM test_ftell
-            INTEGER :: i
-            OPEN(10, FILE="temp.dat")
-            CALL ftell(10,i)
-            WRITE(*,*) i
-          END PROGRAM
-
-_See also_:
-     *note FSEEK::
-
-
-File: gfortran.info,  Node: GAMMA,  Next: GERROR,  Prev: FTELL,  Up: Intrinsic Procedures
-
-7.85 `GAMMA' -- Gamma function
-==============================
-
-_Description_:
-     `GAMMA(X)' computes Gamma (\Gamma) of X. For positive, integer
-     values of X the Gamma function simplifies to the factorial
-     function \Gamma(x)=(x-1)!.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `X = GAMMA(X)'
-
-_Arguments_:
-     X          Shall be of type `REAL' and neither zero nor a
-                negative integer.
-
-_Return value_:
-     The return value is of type `REAL' of the same kind as X.
-
-_Example_:
-          program test_gamma
-            real :: x = 1.0
-            x = gamma(x) ! returns 1.0
-          end program test_gamma
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `GAMMA(X)'    `REAL(4) X'   `REAL(4)'     GNU Extension
-     `DGAMMA(X)'   `REAL(8) X'   `REAL(8)'     GNU Extension
-
-_See also_:
-     Logarithm of the Gamma function: *note LOG_GAMMA::
-
-
-
-File: gfortran.info,  Node: GERROR,  Next: GETARG,  Prev: GAMMA,  Up: Intrinsic Procedures
-
-7.86 `GERROR' -- Get last system error message
-==============================================
-
-_Description_:
-     Returns the system error message corresponding to the last system
-     error.  This resembles the functionality of `strerror(3)' in C.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL GERROR(RESULT)'
-
-_Arguments_:
-     RESULT     Shall of type `CHARACTER' and of default
-
-_Example_:
-          PROGRAM test_gerror
-            CHARACTER(len=100) :: msg
-            CALL gerror(msg)
-            WRITE(*,*) msg
-          END PROGRAM
-
-_See also_:
-     *note IERRNO::, *note PERROR::
-
-
-File: gfortran.info,  Node: GETARG,  Next: GET_COMMAND,  Prev: GERROR,  Up: Intrinsic Procedures
-
-7.87 `GETARG' -- Get command line arguments
-===========================================
-
-_Description_:
-     Retrieve the POS-th argument that was passed on the command line
-     when the containing program was invoked.
-
-     This intrinsic routine is provided for backwards compatibility with
-     GNU Fortran 77.  In new code, programmers should consider the use
-     of the *note GET_COMMAND_ARGUMENT:: intrinsic defined by the
-     Fortran 2003 standard.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL GETARG(POS, VALUE)'
-
-_Arguments_:
-     POS        Shall be of type `INTEGER' and not wider than
-                the default integer kind; POS \geq 0
-     VALUE      Shall be of type `CHARACTER' and of default
-                kind.
-     VALUE      Shall be of type `CHARACTER'.
-
-_Return value_:
-     After `GETARG' returns, the VALUE argument holds the POSth command
-     line argument. If VALUE can not hold the argument, it is truncated
-     to fit the length of VALUE. If there are less than POS arguments
-     specified at the command line, VALUE will be filled with blanks.
-     If POS = 0, VALUE is set to the name of the program (on systems
-     that support this feature).
-
-_Example_:
-          PROGRAM test_getarg
-            INTEGER :: i
-            CHARACTER(len=32) :: arg
-
-            DO i = 1, iargc()
-              CALL getarg(i, arg)
-              WRITE (*,*) arg
-            END DO
-          END PROGRAM
-
-_See also_:
-     GNU Fortran 77 compatibility function: *note IARGC::
-
-     Fortran 2003 functions and subroutines: *note GET_COMMAND::, *note
-     GET_COMMAND_ARGUMENT::, *note COMMAND_ARGUMENT_COUNT::
-
-
-File: gfortran.info,  Node: GET_COMMAND,  Next: GET_COMMAND_ARGUMENT,  Prev: GETARG,  Up: Intrinsic Procedures
-
-7.88 `GET_COMMAND' -- Get the entire command line
-=================================================
-
-_Description_:
-     Retrieve the entire command line that was used to invoke the
-     program.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL GET_COMMAND(COMMAND)'
-
-_Arguments_:
-     COMMAND    Shall be of type `CHARACTER' and of default
-                kind.
-
-_Return value_:
-     Stores the entire command line that was used to invoke the program
-     in COMMAND. If COMMAND is not large enough, the command will be
-     truncated.
-
-_Example_:
-          PROGRAM test_get_command
-            CHARACTER(len=255) :: cmd
-            CALL get_command(cmd)
-            WRITE (*,*) TRIM(cmd)
-          END PROGRAM
-
-_See also_:
-     *note GET_COMMAND_ARGUMENT::, *note COMMAND_ARGUMENT_COUNT::
-
-
-File: gfortran.info,  Node: GET_COMMAND_ARGUMENT,  Next: GETCWD,  Prev: GET_COMMAND,  Up: Intrinsic Procedures
-
-7.89 `GET_COMMAND_ARGUMENT' -- Get command line arguments
-=========================================================
-
-_Description_:
-     Retrieve the NUMBER-th argument that was passed on the command
-     line when the containing program was invoked.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL GET_COMMAND_ARGUMENT(NUMBER [, VALUE, LENGTH, STATUS])'
-
-_Arguments_:
-     NUMBER     Shall be a scalar of type `INTEGER(4)', NUMBER
-                \geq 0
-     VALUE      Shall be a scalar of type `CHARACTER' and of
-                default kind.
-     LENGTH     (Option) Shall be a scalar of type
-                `INTEGER(4)'.
-     STATUS     (Option) Shall be a scalar of type
-                `INTEGER(4)'.
-
-_Return value_:
-     After `GET_COMMAND_ARGUMENT' returns, the VALUE argument holds the
-     NUMBER-th command line argument. If VALUE can not hold the
-     argument, it is truncated to fit the length of VALUE. If there are
-     less than NUMBER arguments specified at the command line, VALUE
-     will be filled with blanks.  If NUMBER = 0, VALUE is set to the
-     name of the program (on systems that support this feature). The
-     LENGTH argument contains the length of the NUMBER-th command line
-     argument. If the argument retrieval fails, STATUS is a positive
-     number; if VALUE contains a truncated command line argument,
-     STATUS is -1; and otherwise the STATUS is zero.
-
-_Example_:
-          PROGRAM test_get_command_argument
-            INTEGER :: i
-            CHARACTER(len=32) :: arg
-
-            i = 0
-            DO
-              CALL get_command_argument(i, arg)
-              IF (LEN_TRIM(arg) == 0) EXIT
-
-              WRITE (*,*) TRIM(arg)
-              i = i+1
-            END DO
-          END PROGRAM
-
-_See also_:
-     *note GET_COMMAND::, *note COMMAND_ARGUMENT_COUNT::
-
-
-File: gfortran.info,  Node: GETCWD,  Next: GETENV,  Prev: GET_COMMAND_ARGUMENT,  Up: Intrinsic Procedures
-
-7.90 `GETCWD' -- Get current working directory
-==============================================
-
-_Description_:
-     Get current working directory.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL GETCWD(C [, STATUS])'
-
-_Arguments_:
-     C          The type shall be `CHARACTER' and of default
-                kind.
-     STATUS     (Optional) status flag. Returns 0 on success,
-                a system specific and nonzero error code
-                otherwise.
-
-_Example_:
-          PROGRAM test_getcwd
-            CHARACTER(len=255) :: cwd
-            CALL getcwd(cwd)
-            WRITE(*,*) TRIM(cwd)
-          END PROGRAM
-
-_See also_:
-     *note CHDIR::
-
-
-File: gfortran.info,  Node: GETENV,  Next: GET_ENVIRONMENT_VARIABLE,  Prev: GETCWD,  Up: Intrinsic Procedures
-
-7.91 `GETENV' -- Get an environmental variable
-==============================================
-
-_Description_:
-     Get the VALUE of the environmental variable NAME.
-
-     This intrinsic routine is provided for backwards compatibility with
-     GNU Fortran 77.  In new code, programmers should consider the use
-     of the *note GET_ENVIRONMENT_VARIABLE:: intrinsic defined by the
-     Fortran 2003 standard.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL GETENV(NAME, VALUE)'
-
-_Arguments_:
-     NAME       Shall be of type `CHARACTER' and of default
-                kind.
-     VALUE      Shall be of type `CHARACTER' and of default
-                kind.
-
-_Return value_:
-     Stores the value of NAME in VALUE. If VALUE is not large enough to
-     hold the data, it is truncated. If NAME is not set, VALUE will be
-     filled with blanks.
-
-_Example_:
-          PROGRAM test_getenv
-            CHARACTER(len=255) :: homedir
-            CALL getenv("HOME", homedir)
-            WRITE (*,*) TRIM(homedir)
-          END PROGRAM
-
-_See also_:
-     *note GET_ENVIRONMENT_VARIABLE::
-
-
-File: gfortran.info,  Node: GET_ENVIRONMENT_VARIABLE,  Next: GETGID,  Prev: GETENV,  Up: Intrinsic Procedures
-
-7.92 `GET_ENVIRONMENT_VARIABLE' -- Get an environmental variable
-================================================================
-
-_Description_:
-     Get the VALUE of the environmental variable NAME.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL GET_ENVIRONMENT_VARIABLE(NAME[, VALUE, LENGTH, STATUS,
-     TRIM_NAME)'
-
-_Arguments_:
-     NAME       Shall be a scalar of type `CHARACTER(1)'.
-     VALUE      Shall be a scalar of type `CHARACTER(1)'.
-     LENGTH     Shall be a scalar of type `INTEGER(4)'.
-     STATUS     Shall be a scalar of type `INTEGER(4)'.
-     TRIM_NAME  Shall be a scalar of type `LOGICAL(4)'.
-
-_Return value_:
-     Stores the value of NAME in VALUE. If VALUE is not large enough to
-     hold the data, it is truncated. If NAME is not set, VALUE will be
-     filled with blanks. Argument LENGTH contains the length needed for
-     storing the environment variable NAME or zero if it is not
-     present. STATUS is -1 if VALUE is present but too short for the
-     environment variable; it is 1 if the environment variable does not
-     exist and 2 if the processor does not support environment
-     variables; in all other cases STATUS is zero. If TRIM_NAME is
-     present with the value `.FALSE.', the trailing blanks in NAME are
-     significant; otherwise they are not part of the environment
-     variable name.
-
-_Example_:
-          PROGRAM test_getenv
-            CHARACTER(len=255) :: homedir
-            CALL get_environment_variable("HOME", homedir)
-            WRITE (*,*) TRIM(homedir)
-          END PROGRAM
-
-
-File: gfortran.info,  Node: GETGID,  Next: GETLOG,  Prev: GET_ENVIRONMENT_VARIABLE,  Up: Intrinsic Procedures
-
-7.93 `GETGID' -- Group ID function
-==================================
-
-_Description_:
-     Returns the numerical group ID of the current process.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = GETGID()'
-
-_Return value_:
-     The return value of `GETGID' is an `INTEGER' of the default kind.
-
-_Example_:
-     See `GETPID' for an example.
-
-_See also_:
-     *note GETPID::, *note GETUID::
-
-
-File: gfortran.info,  Node: GETLOG,  Next: GETPID,  Prev: GETGID,  Up: Intrinsic Procedures
-
-7.94 `GETLOG' -- Get login name
-===============================
-
-_Description_:
-     Gets the username under which the program is running.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL GETLOG(C)'
-
-_Arguments_:
-     C          Shall be of type `CHARACTER' and of default
-                kind.
-
-_Return value_:
-     Stores the current user name in LOGIN.  (On systems where POSIX
-     functions `geteuid' and `getpwuid' are not available, and the
-     `getlogin' function is not implemented either, this will return a
-     blank string.)
-
-_Example_:
-          PROGRAM TEST_GETLOG
-            CHARACTER(32) :: login
-            CALL GETLOG(login)
-            WRITE(*,*) login
-          END PROGRAM
-
-_See also_:
-     *note GETUID::
-
-
-File: gfortran.info,  Node: GETPID,  Next: GETUID,  Prev: GETLOG,  Up: Intrinsic Procedures
-
-7.95 `GETPID' -- Process ID function
-====================================
-
-_Description_:
-     Returns the numerical process identifier of the current process.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = GETPID()'
-
-_Return value_:
-     The return value of `GETPID' is an `INTEGER' of the default kind.
-
-_Example_:
-          program info
-            print *, "The current process ID is ", getpid()
-            print *, "Your numerical user ID is ", getuid()
-            print *, "Your numerical group ID is ", getgid()
-          end program info
-
-_See also_:
-     *note GETGID::, *note GETUID::
-
-
-File: gfortran.info,  Node: GETUID,  Next: GMTIME,  Prev: GETPID,  Up: Intrinsic Procedures
-
-7.96 `GETUID' -- User ID function
-=================================
-
-_Description_:
-     Returns the numerical user ID of the current process.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = GETUID()'
-
-_Return value_:
-     The return value of `GETUID' is an `INTEGER' of the default kind.
-
-_Example_:
-     See `GETPID' for an example.
-
-_See also_:
-     *note GETPID::, *note GETLOG::
-
-
-File: gfortran.info,  Node: GMTIME,  Next: HOSTNM,  Prev: GETUID,  Up: Intrinsic Procedures
-
-7.97 `GMTIME' -- Convert time to GMT info
-=========================================
-
-_Description_:
-     Given a system time value TIME (as provided by the `TIME8()'
-     intrinsic), fills VALUES with values extracted from it appropriate
-     to the UTC time zone (Universal Coordinated Time, also known in
-     some countries as GMT, Greenwich Mean Time), using `gmtime(3)'.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL GMTIME(TIME, VALUES)'
-
-_Arguments_:
-     TIME       An `INTEGER' scalar expression corresponding
-                to a system time, with `INTENT(IN)'.
-     VALUES     A default `INTEGER' array with 9 elements,
-                with `INTENT(OUT)'.
-
-_Return value_:
-     The elements of VALUES are assigned as follows:
-       1. Seconds after the minute, range 0-59 or 0-61 to allow for leap
-          seconds
-
-       2. Minutes after the hour, range 0-59
-
-       3. Hours past midnight, range 0-23
-
-       4. Day of month, range 0-31
-
-       5. Number of months since January, range 0-12
-
-       6. Years since 1900
-
-       7. Number of days since Sunday, range 0-6
-
-       8. Days since January 1
-
-       9. Daylight savings indicator: positive if daylight savings is in
-          effect, zero if not, and negative if the information is not
-          available.
-
-_See also_:
-     *note CTIME::, *note LTIME::, *note TIME::, *note TIME8::
-
-
-
-File: gfortran.info,  Node: HOSTNM,  Next: HUGE,  Prev: GMTIME,  Up: Intrinsic Procedures
-
-7.98 `HOSTNM' -- Get system host name
-=====================================
-
-_Description_:
-     Retrieves the host name of the system on which the program is
-     running.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL HOSTNM(C [, STATUS])'
-     `STATUS = HOSTNM(NAME)'
-
-_Arguments_:
-     C          Shall of type `CHARACTER' and of default kind.
-     STATUS     (Optional) status flag of type `INTEGER'.
-                Returns 0 on success, or a system specific
-                error code otherwise.
-
-_Return value_:
-     In either syntax, NAME is set to the current hostname if it can be
-     obtained, or to a blank string otherwise.
-
-
-
-File: gfortran.info,  Node: HUGE,  Next: HYPOT,  Prev: HOSTNM,  Up: Intrinsic Procedures
-
-7.99 `HUGE' -- Largest number of a kind
-=======================================
-
-_Description_:
-     `HUGE(X)' returns the largest number that is not an infinity in
-     the model of the type of `X'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = HUGE(X)'
-
-_Arguments_:
-     X          Shall be of type `REAL' or `INTEGER'.
-
-_Return value_:
-     The return value is of the same type and kind as X
-
-_Example_:
-          program test_huge_tiny
-            print *, huge(0), huge(0.0), huge(0.0d0)
-            print *, tiny(0.0), tiny(0.0d0)
-          end program test_huge_tiny
-
-
-File: gfortran.info,  Node: HYPOT,  Next: IACHAR,  Prev: HUGE,  Up: Intrinsic Procedures
-
-7.100 `HYPOT' -- Euclidean distance function
-============================================
-
-_Description_:
-     `HYPOT(X,Y)' is the Euclidean distance function. It is equal to
-     \sqrtX^2 + Y^2, without undue underflow or overflow.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = HYPOT(X, Y)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-     Y          The type and kind type parameter shall be the
-                same as X.
-
-_Return value_:
-     The return value has the same type and kind type parameter as X.
-
-_Example_:
-          program test_hypot
-            real(4) :: x = 1.e0_4, y = 0.5e0_4
-            x = hypot(x,y)
-          end program test_hypot
-
-
-File: gfortran.info,  Node: IACHAR,  Next: IAND,  Prev: HYPOT,  Up: Intrinsic Procedures
-
-7.101 `IACHAR' -- Code in ASCII collating sequence
-==================================================
-
-_Description_:
-     `IACHAR(C)' returns the code for the ASCII character in the first
-     character position of `C'.
-
-_Standard_:
-     Fortran 95 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = IACHAR(C [, KIND])'
-
-_Arguments_:
-     C          Shall be a scalar `CHARACTER', with
-                `INTENT(IN)'
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER' and of kind KIND. If KIND is
-     absent, the return value is of default integer kind.
-
-_Example_:
-          program test_iachar
-            integer i
-            i = iachar(' ')
-          end program test_iachar
-
-_Note_:
-     See *note ICHAR:: for a discussion of converting between numerical
-     values and formatted string representations.
-
-_See also_:
-     *note ACHAR::, *note CHAR::, *note ICHAR::
-
-
-
-File: gfortran.info,  Node: IAND,  Next: IARGC,  Prev: IACHAR,  Up: Intrinsic Procedures
-
-7.102 `IAND' -- Bitwise logical and
-===================================
-
-_Description_:
-     Bitwise logical `AND'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = IAND(I, J)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     J          The type shall be `INTEGER', of the same kind
-                as I.  (As a GNU extension, different kinds
-                are also permitted.)
-
-_Return value_:
-     The return type is `INTEGER', of the same kind as the arguments.
-     (If the argument kinds differ, it is of the same kind as the
-     larger argument.)
-
-_Example_:
-          PROGRAM test_iand
-            INTEGER :: a, b
-            DATA a / Z'F' /, b / Z'3' /
-            WRITE (*,*) IAND(a, b)
-          END PROGRAM
-
-_See also_:
-     *note IOR::, *note IEOR::, *note IBITS::, *note IBSET::, *note
-     IBCLR::, *note NOT::
-
-
-
-File: gfortran.info,  Node: IARGC,  Next: IBCLR,  Prev: IAND,  Up: Intrinsic Procedures
-
-7.103 `IARGC' -- Get the number of command line arguments
-=========================================================
-
-_Description_:
-     `IARGC()' returns the number of arguments passed on the command
-     line when the containing program was invoked.
-
-     This intrinsic routine is provided for backwards compatibility with
-     GNU Fortran 77.  In new code, programmers should consider the use
-     of the *note COMMAND_ARGUMENT_COUNT:: intrinsic defined by the
-     Fortran 2003 standard.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = IARGC()'
-
-_Arguments_:
-     None.
-
-_Return value_:
-     The number of command line arguments, type `INTEGER(4)'.
-
-_Example_:
-     See *note GETARG::
-
-_See also_:
-     GNU Fortran 77 compatibility subroutine: *note GETARG::
-
-     Fortran 2003 functions and subroutines: *note GET_COMMAND::, *note
-     GET_COMMAND_ARGUMENT::, *note COMMAND_ARGUMENT_COUNT::
-
-
-File: gfortran.info,  Node: IBCLR,  Next: IBITS,  Prev: IARGC,  Up: Intrinsic Procedures
-
-7.104 `IBCLR' -- Clear bit
-==========================
-
-_Description_:
-     `IBCLR' returns the value of I with the bit at position POS set to
-     zero.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = IBCLR(I, POS)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     POS        The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the same kind as I.
-
-_See also_:
-     *note IBITS::, *note IBSET::, *note IAND::, *note IOR::, *note
-     IEOR::, *note MVBITS::
-
-
-
-File: gfortran.info,  Node: IBITS,  Next: IBSET,  Prev: IBCLR,  Up: Intrinsic Procedures
-
-7.105 `IBITS' -- Bit extraction
-===============================
-
-_Description_:
-     `IBITS' extracts a field of length LEN from I, starting from bit
-     position POS and extending left for LEN bits.  The result is
-     right-justified and the remaining bits are zeroed.  The value of
-     `POS+LEN' must be less than or equal to the value `BIT_SIZE(I)'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = IBITS(I, POS, LEN)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     POS        The type shall be `INTEGER'.
-     LEN        The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the same kind as I.
-
-_See also_:
-     *note BIT_SIZE::, *note IBCLR::, *note IBSET::, *note IAND::,
-     *note IOR::, *note IEOR::
-
-
-File: gfortran.info,  Node: IBSET,  Next: ICHAR,  Prev: IBITS,  Up: Intrinsic Procedures
-
-7.106 `IBSET' -- Set bit
-========================
-
-_Description_:
-     `IBSET' returns the value of I with the bit at position POS set to
-     one.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = IBSET(I, POS)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     POS        The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the same kind as I.
-
-_See also_:
-     *note IBCLR::, *note IBITS::, *note IAND::, *note IOR::, *note
-     IEOR::, *note MVBITS::
-
-
-
-File: gfortran.info,  Node: ICHAR,  Next: IDATE,  Prev: IBSET,  Up: Intrinsic Procedures
-
-7.107 `ICHAR' -- Character-to-integer conversion function
-=========================================================
-
-_Description_:
-     `ICHAR(C)' returns the code for the character in the first
-     character position of `C' in the system's native character set.
-     The correspondence between characters and their codes is not
-     necessarily the same across different GNU Fortran implementations.
-
-_Standard_:
-     Fortan 95 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ICHAR(C [, KIND])'
-
-_Arguments_:
-     C          Shall be a scalar `CHARACTER', with
-                `INTENT(IN)'
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER' and of kind KIND. If KIND is
-     absent, the return value is of default integer kind.
-
-_Example_:
-          program test_ichar
-            integer i
-            i = ichar(' ')
-          end program test_ichar
-
-_Note_:
-     No intrinsic exists to convert between a numeric value and a
-     formatted character string representation - for instance, given the
-     `CHARACTER' value `'154'', obtaining an `INTEGER' or `REAL' value
-     with the value 154, or vice versa. Instead, this functionality is
-     provided by internal-file I/O, as in the following example:
-          program read_val
-            integer value
-            character(len=10) string, string2
-            string = '154'
-
-            ! Convert a string to a numeric value
-            read (string,'(I10)') value
-            print *, value
-
-            ! Convert a value to a formatted string
-            write (string2,'(I10)') value
-            print *, string2
-          end program read_val
-
-_See also_:
-     *note ACHAR::, *note CHAR::, *note IACHAR::
-
-
-
-File: gfortran.info,  Node: IDATE,  Next: IEOR,  Prev: ICHAR,  Up: Intrinsic Procedures
-
-7.108 `IDATE' -- Get current local time subroutine (day/month/year)
-===================================================================
-
-_Description_:
-     `IDATE(TARRAY)' Fills TARRAY with the numerical values at the
-     current local time. The day (in the range 1-31), month (in the
-     range 1-12), and year appear in elements 1, 2, and 3 of TARRAY,
-     respectively.  The year has four significant digits.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL IDATE(VALUES)'
-
-_Arguments_:
-     VALUES     The type shall be `INTEGER, DIMENSION(3)' and
-                the kind shall be the default integer kind.
-
-_Return value_:
-     Does not return anything.
-
-_Example_:
-          program test_idate
-            integer, dimension(3) :: tarray
-            call idate(tarray)
-            print *, tarray(1)
-            print *, tarray(2)
-            print *, tarray(3)
-          end program test_idate
-
-
-File: gfortran.info,  Node: IEOR,  Next: IERRNO,  Prev: IDATE,  Up: Intrinsic Procedures
-
-7.109 `IEOR' -- Bitwise logical exclusive or
-============================================
-
-_Description_:
-     `IEOR' returns the bitwise boolean exclusive-OR of I and J.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = IEOR(I, J)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     J          The type shall be `INTEGER', of the same kind
-                as I.  (As a GNU extension, different kinds
-                are also permitted.)
-
-_Return value_:
-     The return type is `INTEGER', of the same kind as the arguments.
-     (If the argument kinds differ, it is of the same kind as the
-     larger argument.)
-
-_See also_:
-     *note IOR::, *note IAND::, *note IBITS::, *note IBSET::, *note
-     IBCLR::, *note NOT::
-
-
-File: gfortran.info,  Node: IERRNO,  Next: INDEX intrinsic,  Prev: IEOR,  Up: Intrinsic Procedures
-
-7.110 `IERRNO' -- Get the last system error number
-==================================================
-
-_Description_:
-     Returns the last system error number, as given by the C `errno()'
-     function.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = IERRNO()'
-
-_Arguments_:
-     None.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the default integer
-     kind.
-
-_See also_:
-     *note PERROR::
-
-
-File: gfortran.info,  Node: INDEX intrinsic,  Next: INT,  Prev: IERRNO,  Up: Intrinsic Procedures
-
-7.111 `INDEX' -- Position of a substring within a string
-========================================================
-
-_Description_:
-     Returns the position of the start of the first occurrence of string
-     SUBSTRING as a substring in STRING, counting from one.  If
-     SUBSTRING is not present in STRING, zero is returned.  If the BACK
-     argument is present and true, the return value is the start of the
-     last occurrence rather than the first.
-
-_Standard_:
-     Fortran 77 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = INDEX(STRING, SUBSTRING [, BACK [, KIND]])'
-
-_Arguments_:
-     STRING     Shall be a scalar `CHARACTER', with
-                `INTENT(IN)'
-     SUBSTRING  Shall be a scalar `CHARACTER', with
-                `INTENT(IN)'
-     BACK       (Optional) Shall be a scalar `LOGICAL', with
-                `INTENT(IN)'
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER' and of kind KIND. If KIND is
-     absent, the return value is of default integer kind.
-
-_See also_:
-     *note SCAN::, *note VERIFY::
-
-
-File: gfortran.info,  Node: INT,  Next: INT2,  Prev: INDEX intrinsic,  Up: Intrinsic Procedures
-
-7.112 `INT' -- Convert to integer type
-======================================
-
-_Description_:
-     Convert to integer type
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = INT(A [, KIND))'
-
-_Arguments_:
-     A          Shall be of type `INTEGER', `REAL', or
-                `COMPLEX'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     These functions return a `INTEGER' variable or array under the
-     following rules:
-
-    (A)
-          If A is of type `INTEGER', `INT(A) = A'
-
-    (B)
-          If A is of type `REAL' and |A| < 1, `INT(A)' equals `0'.  If
-          |A| \geq 1, then `INT(A)' equals the largest integer that
-          does not exceed the range of A and whose sign is the same as
-          the sign of A.
-
-    (C)
-          If A is of type `COMPLEX', rule B is applied to the real part
-          of A.
-
-_Example_:
-          program test_int
-            integer :: i = 42
-            complex :: z = (-3.7, 1.0)
-            print *, int(i)
-            print *, int(z), int(z,8)
-          end program
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `IFIX(A)'     `REAL(4) A'   `INTEGER'     Fortran 77 and
-                                               later
-     `IDINT(A)'    `REAL(8) A'   `INTEGER'     Fortran 77 and
-                                               later
-
-
-
-File: gfortran.info,  Node: INT2,  Next: INT8,  Prev: INT,  Up: Intrinsic Procedures
-
-7.113 `INT2' -- Convert to 16-bit integer type
-==============================================
-
-_Description_:
-     Convert to a `KIND=2' integer type. This is equivalent to the
-     standard `INT' intrinsic with an optional argument of `KIND=2',
-     and is only included for backwards compatibility.
-
-     The `SHORT' intrinsic is equivalent to `INT2'.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = INT2(A)'
-
-_Arguments_:
-     A          Shall be of type `INTEGER', `REAL', or
-                `COMPLEX'.
-
-_Return value_:
-     The return value is a `INTEGER(2)' variable.
-
-_See also_:
-     *note INT::, *note INT8::, *note LONG::
-
-
-File: gfortran.info,  Node: INT8,  Next: IOR,  Prev: INT2,  Up: Intrinsic Procedures
-
-7.114 `INT8' -- Convert to 64-bit integer type
-==============================================
-
-_Description_:
-     Convert to a `KIND=8' integer type. This is equivalent to the
-     standard `INT' intrinsic with an optional argument of `KIND=8',
-     and is only included for backwards compatibility.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = INT8(A)'
-
-_Arguments_:
-     A          Shall be of type `INTEGER', `REAL', or
-                `COMPLEX'.
-
-_Return value_:
-     The return value is a `INTEGER(8)' variable.
-
-_See also_:
-     *note INT::, *note INT2::, *note LONG::
-
-
-File: gfortran.info,  Node: IOR,  Next: IRAND,  Prev: INT8,  Up: Intrinsic Procedures
-
-7.115 `IOR' -- Bitwise logical or
-=================================
-
-_Description_:
-     `IOR' returns the bitwise boolean inclusive-OR of I and J.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = IOR(I, J)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     J          The type shall be `INTEGER', of the same kind
-                as I.  (As a GNU extension, different kinds
-                are also permitted.)
-
-_Return value_:
-     The return type is `INTEGER', of the same kind as the arguments.
-     (If the argument kinds differ, it is of the same kind as the
-     larger argument.)
-
-_See also_:
-     *note IEOR::, *note IAND::, *note IBITS::, *note IBSET::, *note
-     IBCLR::, *note NOT::
-
-
-File: gfortran.info,  Node: IRAND,  Next: IS_IOSTAT_END,  Prev: IOR,  Up: Intrinsic Procedures
-
-7.116 `IRAND' -- Integer pseudo-random number
-=============================================
-
-_Description_:
-     `IRAND(FLAG)' returns a pseudo-random number from a uniform
-     distribution between 0 and a system-dependent limit (which is in
-     most cases 2147483647). If FLAG is 0, the next number in the
-     current sequence is returned; if FLAG is 1, the generator is
-     restarted by `CALL SRAND(0)'; if FLAG has any other value, it is
-     used as a new seed with `SRAND'.
-
-     This intrinsic routine is provided for backwards compatibility with
-     GNU Fortran 77. It implements a simple modulo generator as provided
-     by `g77'. For new code, one should consider the use of *note
-     RANDOM_NUMBER:: as it implements a superior algorithm.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = IRAND(I)'
-
-_Arguments_:
-     I          Shall be a scalar `INTEGER' of kind 4.
-
-_Return value_:
-     The return value is of `INTEGER(kind=4)' type.
-
-_Example_:
-          program test_irand
-            integer,parameter :: seed = 86456
-
-            call srand(seed)
-            print *, irand(), irand(), irand(), irand()
-            print *, irand(seed), irand(), irand(), irand()
-          end program test_irand
-
-
-
-File: gfortran.info,  Node: IS_IOSTAT_END,  Next: IS_IOSTAT_EOR,  Prev: IRAND,  Up: Intrinsic Procedures
-
-7.117 `IS_IOSTAT_END' -- Test for end-of-file value
-===================================================
-
-_Description_:
-     `IS_IOSTAT_END' tests whether an variable has the value of the I/O
-     status "end of file". The function is equivalent to comparing the
-     variable with the `IOSTAT_END' parameter of the intrinsic module
-     `ISO_FORTRAN_ENV'.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = IS_IOSTAT_END(I)'
-
-_Arguments_:
-     I          Shall be of the type `INTEGER'.
-
-_Return value_:
-     Returns a `LOGICAL' of the default kind, which `.TRUE.' if I has
-     the value which indicates an end of file condition for IOSTAT=
-     specifiers, and is `.FALSE.' otherwise.
-
-_Example_:
-          PROGRAM iostat
-            IMPLICIT NONE
-            INTEGER :: stat, i
-            OPEN(88, FILE='test.dat')
-            READ(88, *, IOSTAT=stat) i
-            IF(IS_IOSTAT_END(stat)) STOP 'END OF FILE'
-          END PROGRAM
-
-
-File: gfortran.info,  Node: IS_IOSTAT_EOR,  Next: ISATTY,  Prev: IS_IOSTAT_END,  Up: Intrinsic Procedures
-
-7.118 `IS_IOSTAT_EOR' -- Test for end-of-record value
-=====================================================
-
-_Description_:
-     `IS_IOSTAT_EOR' tests whether an variable has the value of the I/O
-     status "end of record". The function is equivalent to comparing the
-     variable with the `IOSTAT_EOR' parameter of the intrinsic module
-     `ISO_FORTRAN_ENV'.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = IS_IOSTAT_EOR(I)'
-
-_Arguments_:
-     I          Shall be of the type `INTEGER'.
-
-_Return value_:
-     Returns a `LOGICAL' of the default kind, which `.TRUE.' if I has
-     the value which indicates an end of file condition for IOSTAT=
-     specifiers, and is `.FALSE.' otherwise.
-
-_Example_:
-          PROGRAM iostat
-            IMPLICIT NONE
-            INTEGER :: stat, i(50)
-            OPEN(88, FILE='test.dat', FORM='UNFORMATTED')
-            READ(88, IOSTAT=stat) i
-            IF(IS_IOSTAT_EOR(stat)) STOP 'END OF RECORD'
-          END PROGRAM
-
-
-File: gfortran.info,  Node: ISATTY,  Next: ISHFT,  Prev: IS_IOSTAT_EOR,  Up: Intrinsic Procedures
-
-7.119 `ISATTY' -- Whether a unit is a terminal device.
-======================================================
-
-_Description_:
-     Determine whether a unit is connected to a terminal device.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = ISATTY(UNIT)'
-
-_Arguments_:
-     UNIT       Shall be a scalar `INTEGER'.
-
-_Return value_:
-     Returns `.TRUE.' if the UNIT is connected to a terminal device,
-     `.FALSE.' otherwise.
-
-_Example_:
-          PROGRAM test_isatty
-            INTEGER(kind=1) :: unit
-            DO unit = 1, 10
-              write(*,*) isatty(unit=unit)
-            END DO
-          END PROGRAM
-
-_See also_:
-     *note TTYNAM::
-
-
-File: gfortran.info,  Node: ISHFT,  Next: ISHFTC,  Prev: ISATTY,  Up: Intrinsic Procedures
-
-7.120 `ISHFT' -- Shift bits
-===========================
-
-_Description_:
-     `ISHFT' returns a value corresponding to I with all of the bits
-     shifted SHIFT places.  A value of SHIFT greater than zero
-     corresponds to a left shift, a value of zero corresponds to no
-     shift, and a value less than zero corresponds to a right shift.
-     If the absolute value of SHIFT is greater than `BIT_SIZE(I)', the
-     value is undefined.  Bits shifted out from the left end or right
-     end are lost; zeros are shifted in from the opposite end.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ISHFT(I, SHIFT)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     SHIFT      The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the same kind as I.
-
-_See also_:
-     *note ISHFTC::
-
-
-File: gfortran.info,  Node: ISHFTC,  Next: ISNAN,  Prev: ISHFT,  Up: Intrinsic Procedures
-
-7.121 `ISHFTC' -- Shift bits circularly
-=======================================
-
-_Description_:
-     `ISHFTC' returns a value corresponding to I with the rightmost
-     SIZE bits shifted circularly SHIFT places; that is, bits shifted
-     out one end are shifted into the opposite end.  A value of SHIFT
-     greater than zero corresponds to a left shift, a value of zero
-     corresponds to no shift, and a value less than zero corresponds to
-     a right shift.  The absolute value of SHIFT must be less than
-     SIZE.  If the SIZE argument is omitted, it is taken to be
-     equivalent to `BIT_SIZE(I)'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = ISHFTC(I, SHIFT [, SIZE])'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     SHIFT      The type shall be `INTEGER'.
-     SIZE       (Optional) The type shall be `INTEGER'; the
-                value must be greater than zero and less than
-                or equal to `BIT_SIZE(I)'.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the same kind as I.
-
-_See also_:
-     *note ISHFT::
-
-
-File: gfortran.info,  Node: ISNAN,  Next: ITIME,  Prev: ISHFTC,  Up: Intrinsic Procedures
-
-7.122 `ISNAN' -- Test for a NaN
-===============================
-
-_Description_:
-     `ISNAN' tests whether a floating-point value is an IEEE
-     Not-a-Number (NaN).
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `ISNAN(X)'
-
-_Arguments_:
-     X          Variable of the type `REAL'.
-
-_Return value_:
-     Returns a default-kind `LOGICAL'. The returned value is `TRUE' if
-     X is a NaN and `FALSE' otherwise.
-
-_Example_:
-          program test_nan
-            implicit none
-            real :: x
-            x = -1.0
-            x = sqrt(x)
-            if (isnan(x)) stop '"x" is a NaN'
-          end program test_nan
-
-
-File: gfortran.info,  Node: ITIME,  Next: KILL,  Prev: ISNAN,  Up: Intrinsic Procedures
-
-7.123 `ITIME' -- Get current local time subroutine (hour/minutes/seconds)
-=========================================================================
-
-_Description_:
-     `IDATE(VALUES)' Fills VALUES with the numerical values at the
-     current local time. The hour (in the range 1-24), minute (in the
-     range 1-60), and seconds (in the range 1-60) appear in elements 1,
-     2, and 3 of VALUES, respectively.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL ITIME(VALUES)'
-
-_Arguments_:
-     VALUES     The type shall be `INTEGER, DIMENSION(3)' and
-                the kind shall be the default integer kind.
-
-_Return value_:
-     Does not return anything.
-
-_Example_:
-          program test_itime
-            integer, dimension(3) :: tarray
-            call itime(tarray)
-            print *, tarray(1)
-            print *, tarray(2)
-            print *, tarray(3)
-          end program test_itime
-
-
-File: gfortran.info,  Node: KILL,  Next: KIND,  Prev: ITIME,  Up: Intrinsic Procedures
-
-7.124 `KILL' -- Send a signal to a process
-==========================================
-
-_Description_:
-
-_Standard_:
-     Sends the signal specified by SIGNAL to the process PID.  See
-     `kill(2)'.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL KILL(C, VALUE [, STATUS])'
-
-_Arguments_:
-     C          Shall be a scalar `INTEGER', with `INTENT(IN)'
-     VALUE      Shall be a scalar `INTEGER', with `INTENT(IN)'
-     STATUS     (Optional) status flag of type `INTEGER(4)' or
-                `INTEGER(8)'. Returns 0 on success, or a
-                system-specific error code otherwise.
-
-_See also_:
-     *note ABORT::, *note EXIT::
-
-
-File: gfortran.info,  Node: KIND,  Next: LBOUND,  Prev: KILL,  Up: Intrinsic Procedures
-
-7.125 `KIND' -- Kind of an entity
-=================================
-
-_Description_:
-     `KIND(X)' returns the kind value of the entity X.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `K = KIND(X)'
-
-_Arguments_:
-     X          Shall be of type `LOGICAL', `INTEGER', `REAL',
-                `COMPLEX' or `CHARACTER'.
-
-_Return value_:
-     The return value is a scalar of type `INTEGER' and of the default
-     integer kind.
-
-_Example_:
-          program test_kind
-            integer,parameter :: kc = kind(' ')
-            integer,parameter :: kl = kind(.true.)
-
-            print *, "The default character kind is ", kc
-            print *, "The default logical kind is ", kl
-          end program test_kind
-
-
-
-File: gfortran.info,  Node: LBOUND,  Next: LEADZ,  Prev: KIND,  Up: Intrinsic Procedures
-
-7.126 `LBOUND' -- Lower dimension bounds of an array
-====================================================
-
-_Description_:
-     Returns the lower bounds of an array, or a single lower bound
-     along the DIM dimension.
-
-_Standard_:
-     Fortran 95 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = LBOUND(ARRAY [, DIM [, KIND]])'
-
-_Arguments_:
-     ARRAY      Shall be an array, of any type.
-     DIM        (Optional) Shall be a scalar `INTEGER'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER' and of kind KIND. If KIND is
-     absent, the return value is of default integer kind.  If DIM is
-     absent, the result is an array of the lower bounds of ARRAY.  If
-     DIM is present, the result is a scalar corresponding to the lower
-     bound of the array along that dimension.  If ARRAY is an
-     expression rather than a whole array or array structure component,
-     or if it has a zero extent along the relevant dimension, the lower
-     bound is taken to be 1.
-
-_See also_:
-     *note UBOUND::
-
-
-File: gfortran.info,  Node: LEADZ,  Next: LEN,  Prev: LBOUND,  Up: Intrinsic Procedures
-
-7.127 `LEADZ' -- Number of leading zero bits of an integer
-==========================================================
-
-_Description_:
-     `LEADZ' returns the number of leading zero bits of an integer.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LEADZ(I)'
-
-_Arguments_:
-     I          Shall be of type `INTEGER'.
-
-_Return value_:
-     The type of the return value is the default `INTEGER'.  If all the
-     bits of `I' are zero, the result value is `BIT_SIZE(I)'.
-
-_Example_:
-          PROGRAM test_leadz
-            WRITE (*,*) LEADZ(1)  ! prints 8 if BITSIZE(I) has the value 32
-          END PROGRAM
-
-_See also_:
-     *note BIT_SIZE::, *note TRAILZ::
-
-
-File: gfortran.info,  Node: LEN,  Next: LEN_TRIM,  Prev: LEADZ,  Up: Intrinsic Procedures
-
-7.128 `LEN' -- Length of a character entity
-===========================================
-
-_Description_:
-     Returns the length of a character string.  If STRING is an array,
-     the length of an element of STRING is returned.  Note that STRING
-     need not be defined when this intrinsic is invoked, since only the
-     length, not the content, of STRING is needed.
-
-_Standard_:
-     Fortran 77 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `L = LEN(STRING [, KIND])'
-
-_Arguments_:
-     STRING     Shall be a scalar or array of type
-                `CHARACTER', with `INTENT(IN)'
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER' and of kind KIND. If KIND is
-     absent, the return value is of default integer kind.
-
-_See also_:
-     *note LEN_TRIM::, *note ADJUSTL::, *note ADJUSTR::
-
-
-File: gfortran.info,  Node: LEN_TRIM,  Next: LOG_GAMMA,  Prev: LEN,  Up: Intrinsic Procedures
-
-7.129 `LEN_TRIM' -- Length of a character entity without trailing blank characters
-==================================================================================
-
-_Description_:
-     Returns the length of a character string, ignoring any trailing
-     blanks.
-
-_Standard_:
-     Fortran 95 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LEN_TRIM(STRING [, KIND])'
-
-_Arguments_:
-     STRING     Shall be a scalar of type `CHARACTER', with
-                `INTENT(IN)'
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER' and of kind KIND. If KIND is
-     absent, the return value is of default integer kind.
-
-_See also_:
-     *note LEN::, *note ADJUSTL::, *note ADJUSTR::
-
-
-File: gfortran.info,  Node: LGE,  Next: LGT,  Prev: LOG_GAMMA,  Up: Intrinsic Procedures
-
-7.130 `LGE' -- Lexical greater than or equal
-============================================
-
-_Description_:
-     Determines whether one string is lexically greater than or equal to
-     another string, where the two strings are interpreted as containing
-     ASCII character codes.  If the String A and String B are not the
-     same length, the shorter is compared as if spaces were appended to
-     it to form a value that has the same length as the longer.
-
-     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
-     and `LLT' differ from the corresponding intrinsic operators
-     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
-     processor's character ordering (which is not ASCII on some
-     targets), whereas the former always use the ASCII ordering.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LGE(STRING_A, STRING_B)'
-
-_Arguments_:
-     STRING_A   Shall be of default `CHARACTER' type.
-     STRING_B   Shall be of default `CHARACTER' type.
-
-_Return value_:
-     Returns `.TRUE.' if `STRING_A >= STRING_B', and `.FALSE.'
-     otherwise, based on the ASCII ordering.
-
-_See also_:
-     *note LGT::, *note LLE::, *note LLT::
-
-
-File: gfortran.info,  Node: LGT,  Next: LINK,  Prev: LGE,  Up: Intrinsic Procedures
-
-7.131 `LGT' -- Lexical greater than
-===================================
-
-_Description_:
-     Determines whether one string is lexically greater than another
-     string, where the two strings are interpreted as containing ASCII
-     character codes.  If the String A and String B are not the same
-     length, the shorter is compared as if spaces were appended to it
-     to form a value that has the same length as the longer.
-
-     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
-     and `LLT' differ from the corresponding intrinsic operators
-     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
-     processor's character ordering (which is not ASCII on some
-     targets), whereas the former always use the ASCII ordering.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LGT(STRING_A, STRING_B)'
-
-_Arguments_:
-     STRING_A   Shall be of default `CHARACTER' type.
-     STRING_B   Shall be of default `CHARACTER' type.
-
-_Return value_:
-     Returns `.TRUE.' if `STRING_A > STRING_B', and `.FALSE.'
-     otherwise, based on the ASCII ordering.
-
-_See also_:
-     *note LGE::, *note LLE::, *note LLT::
-
-
-File: gfortran.info,  Node: LINK,  Next: LLE,  Prev: LGT,  Up: Intrinsic Procedures
-
-7.132 `LINK' -- Create a hard link
-==================================
-
-_Description_:
-     Makes a (hard) link from file PATH1 to PATH2. A null character
-     (`CHAR(0)') can be used to mark the end of the names in PATH1 and
-     PATH2; otherwise, trailing blanks in the file names are ignored.
-     If the STATUS argument is supplied, it contains 0 on success or a
-     nonzero error code upon return; see `link(2)'.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL LINK(PATH1, PATH2 [, STATUS])'
-     `STATUS = LINK(PATH1, PATH2)'
-
-_Arguments_:
-     PATH1      Shall be of default `CHARACTER' type.
-     PATH2      Shall be of default `CHARACTER' type.
-     STATUS     (Optional) Shall be of default `INTEGER' type.
-
-_See also_:
-     *note SYMLNK::, *note UNLINK::
-
-
-File: gfortran.info,  Node: LLE,  Next: LLT,  Prev: LINK,  Up: Intrinsic Procedures
-
-7.133 `LLE' -- Lexical less than or equal
-=========================================
-
-_Description_:
-     Determines whether one string is lexically less than or equal to
-     another string, where the two strings are interpreted as
-     containing ASCII character codes.  If the String A and String B
-     are not the same length, the shorter is compared as if spaces were
-     appended to it to form a value that has the same length as the
-     longer.
-
-     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
-     and `LLT' differ from the corresponding intrinsic operators
-     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
-     processor's character ordering (which is not ASCII on some
-     targets), whereas the former always use the ASCII ordering.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LLE(STRING_A, STRING_B)'
-
-_Arguments_:
-     STRING_A   Shall be of default `CHARACTER' type.
-     STRING_B   Shall be of default `CHARACTER' type.
-
-_Return value_:
-     Returns `.TRUE.' if `STRING_A <= STRING_B', and `.FALSE.'
-     otherwise, based on the ASCII ordering.
-
-_See also_:
-     *note LGE::, *note LGT::, *note LLT::
-
-
-File: gfortran.info,  Node: LLT,  Next: LNBLNK,  Prev: LLE,  Up: Intrinsic Procedures
-
-7.134 `LLT' -- Lexical less than
-================================
-
-_Description_:
-     Determines whether one string is lexically less than another
-     string, where the two strings are interpreted as containing ASCII
-     character codes.  If the String A and String B are not the same
-     length, the shorter is compared as if spaces were appended to it
-     to form a value that has the same length as the longer.
-
-     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
-     and `LLT' differ from the corresponding intrinsic operators
-     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
-     processor's character ordering (which is not ASCII on some
-     targets), whereas the former always use the ASCII ordering.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LLT(STRING_A, STRING_B)'
-
-_Arguments_:
-     STRING_A   Shall be of default `CHARACTER' type.
-     STRING_B   Shall be of default `CHARACTER' type.
-
-_Return value_:
-     Returns `.TRUE.' if `STRING_A < STRING_B', and `.FALSE.'
-     otherwise, based on the ASCII ordering.
-
-_See also_:
-     *note LGE::, *note LGT::, *note LLE::
-
-
-File: gfortran.info,  Node: LNBLNK,  Next: LOC,  Prev: LLT,  Up: Intrinsic Procedures
-
-7.135 `LNBLNK' -- Index of the last non-blank character in a string
-===================================================================
-
-_Description_:
-     Returns the length of a character string, ignoring any trailing
-     blanks.  This is identical to the standard `LEN_TRIM' intrinsic,
-     and is only included for backwards compatibility.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LNBLNK(STRING)'
-
-_Arguments_:
-     STRING     Shall be a scalar of type `CHARACTER', with
-                `INTENT(IN)'
-
-_Return value_:
-     The return value is of `INTEGER(kind=4)' type.
-
-_See also_:
-     *note INDEX intrinsic::, *note LEN_TRIM::
-
-
-File: gfortran.info,  Node: LOC,  Next: LOG,  Prev: LNBLNK,  Up: Intrinsic Procedures
-
-7.136 `LOC' -- Returns the address of a variable
-================================================
-
-_Description_:
-     `LOC(X)' returns the address of X as an integer.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = LOC(X)'
-
-_Arguments_:
-     X          Variable of any type.
-
-_Return value_:
-     The return value is of type `INTEGER', with a `KIND' corresponding
-     to the size (in bytes) of a memory address on the target machine.
-
-_Example_:
-          program test_loc
-            integer :: i
-            real :: r
-            i = loc(r)
-            print *, i
-          end program test_loc
-
-
-File: gfortran.info,  Node: LOG,  Next: LOG10,  Prev: LOC,  Up: Intrinsic Procedures
-
-7.137 `LOG' -- Logarithm function
-=================================
-
-_Description_:
-     `LOG(X)' computes the logarithm of X.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LOG(X)'
-
-_Arguments_:
-     X          The type shall be `REAL' or `COMPLEX'.
-
-_Return value_:
-     The return value is of type `REAL' or `COMPLEX'.  The kind type
-     parameter is the same as X.  If X is `COMPLEX', the imaginary part
-     \omega is in the range -\pi \leq \omega \leq \pi.
-
-_Example_:
-          program test_log
-            real(8) :: x = 1.0_8
-            complex :: z = (1.0, 2.0)
-            x = log(x)
-            z = log(z)
-          end program test_log
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `ALOG(X)'     `REAL(4) X'   `REAL(4)'     f95, gnu
-     `DLOG(X)'     `REAL(8) X'   `REAL(8)'     f95, gnu
-     `CLOG(X)'     `COMPLEX(4)   `COMPLEX(4)'  f95, gnu
-                   X'                          
-     `ZLOG(X)'     `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
-                   X'                          
-     `CDLOG(X)'    `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
-                   X'                          
-
-
-File: gfortran.info,  Node: LOG10,  Next: LOGICAL,  Prev: LOG,  Up: Intrinsic Procedures
-
-7.138 `LOG10' -- Base 10 logarithm function
-===========================================
-
-_Description_:
-     `LOG10(X)' computes the base 10 logarithm of X.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LOG10(X)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of type `REAL' or `COMPLEX'.  The kind type
-     parameter is the same as X.
-
-_Example_:
-          program test_log10
-            real(8) :: x = 10.0_8
-            x = log10(x)
-          end program test_log10
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `ALOG10(X)'   `REAL(4) X'   `REAL(4)'     Fortran 95 and
-                                               later
-     `DLOG10(X)'   `REAL(8) X'   `REAL(8)'     Fortran 95 and
-                                               later
-
-
-File: gfortran.info,  Node: LOG_GAMMA,  Next: LGE,  Prev: LEN_TRIM,  Up: Intrinsic Procedures
-
-7.139 `LOG_GAMMA' -- Logarithm of the Gamma function
-====================================================
-
-_Description_:
-     `LOG_GAMMA(X)' computes the natural logarithm of the absolute value
-     of the Gamma (\Gamma) function.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `X = LOG_GAMMA(X)'
-
-_Arguments_:
-     X          Shall be of type `REAL' and neither zero nor a
-                negative integer.
-
-_Return value_:
-     The return value is of type `REAL' of the same kind as X.
-
-_Example_:
-          program test_log_gamma
-            real :: x = 1.0
-            x = lgamma(x) ! returns 0.0
-          end program test_log_gamma
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `LGAMMA(X)'   `REAL(4) X'   `REAL(4)'     GNU Extension
-     `ALGAMA(X)'   `REAL(4) X'   `REAL(4)'     GNU Extension
-     `DLGAMA(X)'   `REAL(8) X'   `REAL(8)'     GNU Extension
-
-_See also_:
-     Gamma function: *note GAMMA::
-
-
-
-File: gfortran.info,  Node: LOGICAL,  Next: LONG,  Prev: LOG10,  Up: Intrinsic Procedures
-
-7.140 `LOGICAL' -- Convert to logical type
-==========================================
-
-_Description_:
-     Converts one kind of `LOGICAL' variable to another.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LOGICAL(L [, KIND])'
-
-_Arguments_:
-     L          The type shall be `LOGICAL'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is a `LOGICAL' value equal to L, with a kind
-     corresponding to KIND, or of the default logical kind if KIND is
-     not given.
-
-_See also_:
-     *note INT::, *note REAL::, *note CMPLX::
-
-
-File: gfortran.info,  Node: LONG,  Next: LSHIFT,  Prev: LOGICAL,  Up: Intrinsic Procedures
-
-7.141 `LONG' -- Convert to integer type
-=======================================
-
-_Description_:
-     Convert to a `KIND=4' integer type, which is the same size as a C
-     `long' integer.  This is equivalent to the standard `INT'
-     intrinsic with an optional argument of `KIND=4', and is only
-     included for backwards compatibility.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LONG(A)'
-
-_Arguments_:
-     A          Shall be of type `INTEGER', `REAL', or
-                `COMPLEX'.
-
-_Return value_:
-     The return value is a `INTEGER(4)' variable.
-
-_See also_:
-     *note INT::, *note INT2::, *note INT8::
-
-
-File: gfortran.info,  Node: LSHIFT,  Next: LSTAT,  Prev: LONG,  Up: Intrinsic Procedures
-
-7.142 `LSHIFT' -- Left shift bits
-=================================
-
-_Description_:
-     `LSHIFT' returns a value corresponding to I with all of the bits
-     shifted left by SHIFT places.  If the absolute value of SHIFT is
-     greater than `BIT_SIZE(I)', the value is undefined.  Bits shifted
-     out from the left end are lost; zeros are shifted in from the
-     opposite end.
-
-     This function has been superseded by the `ISHFT' intrinsic, which
-     is standard in Fortran 95 and later.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = LSHIFT(I, SHIFT)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     SHIFT      The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the same kind as I.
-
-_See also_:
-     *note ISHFT::, *note ISHFTC::, *note RSHIFT::
-
-
-
-File: gfortran.info,  Node: LSTAT,  Next: LTIME,  Prev: LSHIFT,  Up: Intrinsic Procedures
-
-7.143 `LSTAT' -- Get file status
-================================
-
-_Description_:
-     `LSTAT' is identical to *note STAT::, except that if path is a
-     symbolic link, then the link itself is statted, not the file that
-     it refers to.
-
-     The elements in `BUFF' are the same as described by *note STAT::.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL LSTAT(FILE, BUFF [, STATUS])'
-
-_Arguments_:
-     FILE       The type shall be `CHARACTER' of the default
-                kind, a valid path within the file system.
-     BUFF       The type shall be `INTEGER(4), DIMENSION(13)'.
-     STATUS     (Optional) status flag of type `INTEGER(4)'.
-                Returns 0 on success and a system specific
-                error code otherwise.
-
-_Example_:
-     See *note STAT:: for an example.
-
-_See also_:
-     To stat an open file: *note FSTAT::, to stat a file: *note STAT::
-
-
-File: gfortran.info,  Node: LTIME,  Next: MALLOC,  Prev: LSTAT,  Up: Intrinsic Procedures
-
-7.144 `LTIME' -- Convert time to local time info
-================================================
-
-_Description_:
-     Given a system time value STIME (as provided by the `TIME8()'
-     intrinsic), fills TARRAY with values extracted from it appropriate
-     to the local time zone using `localtime(3)'.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL LTIME(STIME, TARRAY)'
-
-_Arguments_:
-     STIME      An `INTEGER' scalar expression corresponding
-                to a system time, with `INTENT(IN)'.
-     TARRAY     A default `INTEGER' array with 9 elements,
-                with `INTENT(OUT)'.
-
-_Return value_:
-     The elements of TARRAY are assigned as follows:
-       1. Seconds after the minute, range 0-59 or 0-61 to allow for leap
-          seconds
-
-       2. Minutes after the hour, range 0-59
-
-       3. Hours past midnight, range 0-23
-
-       4. Day of month, range 0-31
-
-       5. Number of months since January, range 0-12
-
-       6. Years since 1900
-
-       7. Number of days since Sunday, range 0-6
-
-       8. Days since January 1
-
-       9. Daylight savings indicator: positive if daylight savings is in
-          effect, zero if not, and negative if the information is not
-          available.
-
-_See also_:
-     *note CTIME::, *note GMTIME::, *note TIME::, *note TIME8::
-
-
-
-File: gfortran.info,  Node: MALLOC,  Next: MATMUL,  Prev: LTIME,  Up: Intrinsic Procedures
-
-7.145 `MALLOC' -- Allocate dynamic memory
-=========================================
-
-_Description_:
-     `MALLOC(SIZE)' allocates SIZE bytes of dynamic memory and returns
-     the address of the allocated memory. The `MALLOC' intrinsic is an
-     extension intended to be used with Cray pointers, and is provided
-     in GNU Fortran to allow the user to compile legacy code. For new
-     code using Fortran 95 pointers, the memory allocation intrinsic is
-     `ALLOCATE'.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `PTR = MALLOC(SIZE)'
-
-_Arguments_:
-     SIZE       The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type `INTEGER(K)', with K such that
-     variables of type `INTEGER(K)' have the same size as C pointers
-     (`sizeof(void *)').
-
-_Example_:
-     The following example demonstrates the use of `MALLOC' and `FREE'
-     with Cray pointers.
-
-          program test_malloc
-            implicit none
-            integer i
-            real*8 x(*), z
-            pointer(ptr_x,x)
-
-            ptr_x = malloc(20*8)
-            do i = 1, 20
-              x(i) = sqrt(1.0d0 / i)
-            end do
-            z = 0
-            do i = 1, 20
-              z = z + x(i)
-              print *, z
-            end do
-            call free(ptr_x)
-          end program test_malloc
-
-_See also_:
-     *note FREE::
-
-
-File: gfortran.info,  Node: MATMUL,  Next: MAX,  Prev: MALLOC,  Up: Intrinsic Procedures
-
-7.146 `MATMUL' -- matrix multiplication
-=======================================
-
-_Description_:
-     Performs a matrix multiplication on numeric or logical arguments.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = MATMUL(MATRIX_A, MATRIX_B)'
-
-_Arguments_:
-     MATRIX_A   An array of `INTEGER', `REAL', `COMPLEX', or
-                `LOGICAL' type, with a rank of one or two.
-     MATRIX_B   An array of `INTEGER', `REAL', or `COMPLEX'
-                type if MATRIX_A is of a numeric type;
-                otherwise, an array of `LOGICAL' type. The
-                rank shall be one or two, and the first (or
-                only) dimension of MATRIX_B shall be equal to
-                the last (or only) dimension of MATRIX_A.
-
-_Return value_:
-     The matrix product of MATRIX_A and MATRIX_B.  The type and kind of
-     the result follow the usual type and kind promotion rules, as for
-     the `*' or `.AND.' operators.
-
-_See also_:
-
-
-File: gfortran.info,  Node: MAX,  Next: MAXEXPONENT,  Prev: MATMUL,  Up: Intrinsic Procedures
-
-7.147 `MAX' -- Maximum value of an argument list
-================================================
-
-_Description_:
-     Returns the argument with the largest (most positive) value.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = MAX(A1, A2 [, A3 [, ...]])'
-
-_Arguments_:
-     A1         The type shall be `INTEGER' or `REAL'.
-     A2, A3,    An expression of the same type and kind as A1.
-     ...        (As a GNU extension, arguments of different
-                kinds are permitted.)
-
-_Return value_:
-     The return value corresponds to the maximum value among the
-     arguments, and has the same type and kind as the first argument.
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `MAX0(I)'     `INTEGER(4)   `INTEGER(4)'  Fortran 77 and
-                   I'                          later
-     `AMAX0(I)'    `INTEGER(4)   `REAL(MAX(X))'Fortran 77 and
-                   I'                          later
-     `MAX1(X)'     `REAL X'      `INT(MAX(X))' Fortran 77 and
-                                               later
-     `AMAX1(X)'    `REAL(4)      `REAL(4)'     Fortran 77 and
-                   X'                          later
-     `DMAX1(X)'    `REAL(8)      `REAL(8)'     Fortran 77 and
-                   X'                          later
-
-_See also_:
-     *note MAXLOC:: *note MAXVAL::, *note MIN::
-
-
-
-File: gfortran.info,  Node: MAXEXPONENT,  Next: MAXLOC,  Prev: MAX,  Up: Intrinsic Procedures
-
-7.148 `MAXEXPONENT' -- Maximum exponent of a real kind
-======================================================
-
-_Description_:
-     `MAXEXPONENT(X)' returns the maximum exponent in the model of the
-     type of `X'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = MAXEXPONENT(X)'
-
-_Arguments_:
-     X          Shall be of type `REAL'.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the default integer
-     kind.
-
-_Example_:
-          program exponents
-            real(kind=4) :: x
-            real(kind=8) :: y
-
-            print *, minexponent(x), maxexponent(x)
-            print *, minexponent(y), maxexponent(y)
-          end program exponents
-
-
-File: gfortran.info,  Node: MAXLOC,  Next: MAXVAL,  Prev: MAXEXPONENT,  Up: Intrinsic Procedures
-
-7.149 `MAXLOC' -- Location of the maximum value within an array
-===============================================================
-
-_Description_:
-     Determines the location of the element in the array with the
-     maximum value, or, if the DIM argument is supplied, determines the
-     locations of the maximum element along each row of the array in the
-     DIM direction.  If MASK is present, only the elements for which
-     MASK is `.TRUE.' are considered.  If more than one element in the
-     array has the maximum value, the location returned is that of the
-     first such element in array element order.  If the array has zero
-     size, or all of the elements of MASK are `.FALSE.', then the
-     result is an array of zeroes.  Similarly, if DIM is supplied and
-     all of the elements of MASK along a given row are zero, the result
-     value for that row is zero.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = MAXLOC(ARRAY, DIM [, MASK])'
-     `RESULT = MAXLOC(ARRAY [, MASK])'
-
-_Arguments_:
-     ARRAY      Shall be an array of type `INTEGER', `REAL',
-                or `CHARACTER'.
-     DIM        (Optional) Shall be a scalar of type
-                `INTEGER', with a value between one and the
-                rank of ARRAY, inclusive.  It may not be an
-                optional dummy argument.
-     MASK       Shall be an array of type `LOGICAL', and
-                conformable with ARRAY.
-
-_Return value_:
-     If DIM is absent, the result is a rank-one array with a length
-     equal to the rank of ARRAY.  If DIM is present, the result is an
-     array with a rank one less than the rank of ARRAY, and a size
-     corresponding to the size of ARRAY with the DIM dimension removed.
-     If DIM is present and ARRAY has a rank of one, the result is a
-     scalar.  In all cases, the result is of default `INTEGER' type.
-
-_See also_:
-     *note MAX::, *note MAXVAL::
-
-
-
-File: gfortran.info,  Node: MAXVAL,  Next: MCLOCK,  Prev: MAXLOC,  Up: Intrinsic Procedures
-
-7.150 `MAXVAL' -- Maximum value of an array
-===========================================
-
-_Description_:
-     Determines the maximum value of the elements in an array value,
-     or, if the DIM argument is supplied, determines the maximum value
-     along each row of the array in the DIM direction.  If MASK is
-     present, only the elements for which MASK is `.TRUE.' are
-     considered.  If the array has zero size, or all of the elements of
-     MASK are `.FALSE.', then the result is `-HUGE(ARRAY)' if ARRAY is
-     numeric, or a string of nulls if ARRAY is of character type.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = MAXVAL(ARRAY, DIM [, MASK])'
-     `RESULT = MAXVAL(ARRAY [, MASK])'
-
-_Arguments_:
-     ARRAY      Shall be an array of type `INTEGER', `REAL',
-                or `CHARACTER'.
-     DIM        (Optional) Shall be a scalar of type
-                `INTEGER', with a value between one and the
-                rank of ARRAY, inclusive.  It may not be an
-                optional dummy argument.
-     MASK       Shall be an array of type `LOGICAL', and
-                conformable with ARRAY.
-
-_Return value_:
-     If DIM is absent, or if ARRAY has a rank of one, the result is a
-     scalar.  If DIM is present, the result is an array with a rank one
-     less than the rank of ARRAY, and a size corresponding to the size
-     of ARRAY with the DIM dimension removed.  In all cases, the result
-     is of the same type and kind as ARRAY.
-
-_See also_:
-     *note MAX::, *note MAXLOC::
-
-
-File: gfortran.info,  Node: MCLOCK,  Next: MCLOCK8,  Prev: MAXVAL,  Up: Intrinsic Procedures
-
-7.151 `MCLOCK' -- Time function
-===============================
-
-_Description_:
-     Returns the number of clock ticks since the start of the process,
-     based on the UNIX function `clock(3)'.
-
-     This intrinsic is not fully portable, such as to systems with
-     32-bit `INTEGER' types but supporting times wider than 32 bits.
-     Therefore, the values returned by this intrinsic might be, or
-     become, negative, or numerically less than previous values, during
-     a single run of the compiled program.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = MCLOCK()'
-
-_Return value_:
-     The return value is a scalar of type `INTEGER(4)', equal to the
-     number of clock ticks since the start of the process, or `-1' if
-     the system does not support `clock(3)'.
-
-_See also_:
-     *note CTIME::, *note GMTIME::, *note LTIME::, *note MCLOCK::,
-     *note TIME::
-
-
-
-File: gfortran.info,  Node: MCLOCK8,  Next: MERGE,  Prev: MCLOCK,  Up: Intrinsic Procedures
-
-7.152 `MCLOCK8' -- Time function (64-bit)
-=========================================
-
-_Description_:
-     Returns the number of clock ticks since the start of the process,
-     based on the UNIX function `clock(3)'.
-
-     _Warning:_ this intrinsic does not increase the range of the timing
-     values over that returned by `clock(3)'. On a system with a 32-bit
-     `clock(3)', `MCLOCK8()' will return a 32-bit value, even though it
-     is converted to a 64-bit `INTEGER(8)' value. That means overflows
-     of the 32-bit value can still occur. Therefore, the values
-     returned by this intrinsic might be or become negative or
-     numerically less than previous values during a single run of the
-     compiled program.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = MCLOCK8()'
-
-_Return value_:
-     The return value is a scalar of type `INTEGER(8)', equal to the
-     number of clock ticks since the start of the process, or `-1' if
-     the system does not support `clock(3)'.
-
-_See also_:
-     *note CTIME::, *note GMTIME::, *note LTIME::, *note MCLOCK::,
-     *note TIME8::
-
-
-
-File: gfortran.info,  Node: MERGE,  Next: MIN,  Prev: MCLOCK8,  Up: Intrinsic Procedures
-
-7.153 `MERGE' -- Merge variables
-================================
-
-_Description_:
-     Select values from two arrays according to a logical mask.  The
-     result is equal to TSOURCE if MASK is `.TRUE.', or equal to
-     FSOURCE if it is `.FALSE.'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = MERGE(TSOURCE, FSOURCE, MASK)'
-
-_Arguments_:
-     TSOURCE    May be of any type.
-     FSOURCE    Shall be of the same type and type parameters
-                as TSOURCE.
-     MASK       Shall be of type `LOGICAL'.
-
-_Return value_:
-     The result is of the same type and type parameters as TSOURCE.
-
-
-
-File: gfortran.info,  Node: MIN,  Next: MINEXPONENT,  Prev: MERGE,  Up: Intrinsic Procedures
-
-7.154 `MIN' -- Minimum value of an argument list
-================================================
-
-_Description_:
-     Returns the argument with the smallest (most negative) value.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = MIN(A1, A2 [, A3, ...])'
-
-_Arguments_:
-     A1         The type shall be `INTEGER' or `REAL'.
-     A2, A3,    An expression of the same type and kind as A1.
-     ...        (As a GNU extension, arguments of different
-                kinds are permitted.)
-
-_Return value_:
-     The return value corresponds to the maximum value among the
-     arguments, and has the same type and kind as the first argument.
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `MIN0(I)'     `INTEGER(4)   `INTEGER(4)'  Fortran 77 and
-                   I'                          later
-     `AMIN0(I)'    `INTEGER(4)   `REAL(MIN(X))'Fortran 77 and
-                   I'                          later
-     `MIN1(X)'     `REAL X'      `INT(MIN(X))' Fortran 77 and
-                                               later
-     `AMIN1(X)'    `REAL(4)      `REAL(4)'     Fortran 77 and
-                   X'                          later
-     `DMIN1(X)'    `REAL(8)      `REAL(8)'     Fortran 77 and
-                   X'                          later
-
-_See also_:
-     *note MAX::, *note MINLOC::, *note MINVAL::
-
-
-File: gfortran.info,  Node: MINEXPONENT,  Next: MINLOC,  Prev: MIN,  Up: Intrinsic Procedures
-
-7.155 `MINEXPONENT' -- Minimum exponent of a real kind
-======================================================
-
-_Description_:
-     `MINEXPONENT(X)' returns the minimum exponent in the model of the
-     type of `X'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = MINEXPONENT(X)'
-
-_Arguments_:
-     X          Shall be of type `REAL'.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the default integer
-     kind.
-
-_Example_:
-     See `MAXEXPONENT' for an example.
-
-
-File: gfortran.info,  Node: MINLOC,  Next: MINVAL,  Prev: MINEXPONENT,  Up: Intrinsic Procedures
-
-7.156 `MINLOC' -- Location of the minimum value within an array
-===============================================================
-
-_Description_:
-     Determines the location of the element in the array with the
-     minimum value, or, if the DIM argument is supplied, determines the
-     locations of the minimum element along each row of the array in the
-     DIM direction.  If MASK is present, only the elements for which
-     MASK is `.TRUE.' are considered.  If more than one element in the
-     array has the minimum value, the location returned is that of the
-     first such element in array element order.  If the array has zero
-     size, or all of the elements of MASK are `.FALSE.', then the
-     result is an array of zeroes.  Similarly, if DIM is supplied and
-     all of the elements of MASK along a given row are zero, the result
-     value for that row is zero.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = MINLOC(ARRAY, DIM [, MASK])'
-     `RESULT = MINLOC(ARRAY [, MASK])'
-
-_Arguments_:
-     ARRAY      Shall be an array of type `INTEGER', `REAL',
-                or `CHARACTER'.
-     DIM        (Optional) Shall be a scalar of type
-                `INTEGER', with a value between one and the
-                rank of ARRAY, inclusive.  It may not be an
-                optional dummy argument.
-     MASK       Shall be an array of type `LOGICAL', and
-                conformable with ARRAY.
-
-_Return value_:
-     If DIM is absent, the result is a rank-one array with a length
-     equal to the rank of ARRAY.  If DIM is present, the result is an
-     array with a rank one less than the rank of ARRAY, and a size
-     corresponding to the size of ARRAY with the DIM dimension removed.
-     If DIM is present and ARRAY has a rank of one, the result is a
-     scalar.  In all cases, the result is of default `INTEGER' type.
-
-_See also_:
-     *note MIN::, *note MINVAL::
-
-
-
-File: gfortran.info,  Node: MINVAL,  Next: MOD,  Prev: MINLOC,  Up: Intrinsic Procedures
-
-7.157 `MINVAL' -- Minimum value of an array
-===========================================
-
-_Description_:
-     Determines the minimum value of the elements in an array value,
-     or, if the DIM argument is supplied, determines the minimum value
-     along each row of the array in the DIM direction.  If MASK is
-     present, only the elements for which MASK is `.TRUE.' are
-     considered.  If the array has zero size, or all of the elements of
-     MASK are `.FALSE.', then the result is `HUGE(ARRAY)' if ARRAY is
-     numeric, or a string of `CHAR(255)' characters if ARRAY is of
-     character type.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = MINVAL(ARRAY, DIM [, MASK])'
-     `RESULT = MINVAL(ARRAY [, MASK])'
-
-_Arguments_:
-     ARRAY      Shall be an array of type `INTEGER', `REAL',
-                or `CHARACTER'.
-     DIM        (Optional) Shall be a scalar of type
-                `INTEGER', with a value between one and the
-                rank of ARRAY, inclusive.  It may not be an
-                optional dummy argument.
-     MASK       Shall be an array of type `LOGICAL', and
-                conformable with ARRAY.
-
-_Return value_:
-     If DIM is absent, or if ARRAY has a rank of one, the result is a
-     scalar.  If DIM is present, the result is an array with a rank one
-     less than the rank of ARRAY, and a size corresponding to the size
-     of ARRAY with the DIM dimension removed.  In all cases, the result
-     is of the same type and kind as ARRAY.
-
-_See also_:
-     *note MIN::, *note MINLOC::
-
-
-
-File: gfortran.info,  Node: MOD,  Next: MODULO,  Prev: MINVAL,  Up: Intrinsic Procedures
-
-7.158 `MOD' -- Remainder function
-=================================
-
-_Description_:
-     `MOD(A,P)' computes the remainder of the division of A by P. It is
-     calculated as `A - (INT(A/P) * P)'.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = MOD(A, P)'
-
-_Arguments_:
-     A          Shall be a scalar of type `INTEGER' or `REAL'
-     P          Shall be a scalar of the same type as A and not
-                equal to zero
-
-_Return value_:
-     The kind of the return value is the result of cross-promoting the
-     kinds of the arguments.
-
-_Example_:
-          program test_mod
-            print *, mod(17,3)
-            print *, mod(17.5,5.5)
-            print *, mod(17.5d0,5.5)
-            print *, mod(17.5,5.5d0)
-
-            print *, mod(-17,3)
-            print *, mod(-17.5,5.5)
-            print *, mod(-17.5d0,5.5)
-            print *, mod(-17.5,5.5d0)
-
-            print *, mod(17,-3)
-            print *, mod(17.5,-5.5)
-            print *, mod(17.5d0,-5.5)
-            print *, mod(17.5,-5.5d0)
-          end program test_mod
-
-_Specific names_:
-     Name          Arguments     Return type   Standard
-     `AMOD(A,P)'   `REAL(4)'     `REAL(4)'     Fortran 95 and
-                                               later
-     `DMOD(A,P)'   `REAL(8)'     `REAL(8)'     Fortran 95 and
-                                               later
-
-
-File: gfortran.info,  Node: MODULO,  Next: MOVE_ALLOC,  Prev: MOD,  Up: Intrinsic Procedures
-
-7.159 `MODULO' -- Modulo function
-=================================
-
-_Description_:
-     `MODULO(A,P)' computes the A modulo P.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = MODULO(A, P)'
-
-_Arguments_:
-     A          Shall be a scalar of type `INTEGER' or `REAL'
-     P          Shall be a scalar of the same type and kind as
-                A
-
-_Return value_:
-     The type and kind of the result are those of the arguments.
-    If A and P are of type `INTEGER':
-          `MODULO(A,P)' has the value R such that `A=Q*P+R', where Q is
-          an integer and R is between 0 (inclusive) and P (exclusive).
-
-    If A and P are of type `REAL':
-          `MODULO(A,P)' has the value of `A - FLOOR (A / P) * P'.
-     In all cases, if P is zero the result is processor-dependent.
-
-_Example_:
-          program test_modulo
-            print *, modulo(17,3)
-            print *, modulo(17.5,5.5)
-
-            print *, modulo(-17,3)
-            print *, modulo(-17.5,5.5)
-
-            print *, modulo(17,-3)
-            print *, modulo(17.5,-5.5)
-          end program
-
-
-
-File: gfortran.info,  Node: MOVE_ALLOC,  Next: MVBITS,  Prev: MODULO,  Up: Intrinsic Procedures
-
-7.160 `MOVE_ALLOC' -- Move allocation from one object to another
-================================================================
-
-_Description_:
-     `MOVE_ALLOC(SRC, DEST)' moves the allocation from SRC to DEST.
-     SRC will become deallocated in the process.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL MOVE_ALLOC(SRC, DEST)'
-
-_Arguments_:
-     SRC        `ALLOCATABLE', `INTENT(INOUT)', may be of any
-                type and kind.
-     DEST       `ALLOCATABLE', `INTENT(OUT)', shall be of the
-                same type, kind and rank as SRC.
-
-_Return value_:
-     None
-
-_Example_:
-          program test_move_alloc
-              integer, allocatable :: a(:), b(:)
-
-              allocate(a(3))
-              a = [ 1, 2, 3 ]
-              call move_alloc(a, b)
-              print *, allocated(a), allocated(b)
-              print *, b
-          end program test_move_alloc
-
-
-File: gfortran.info,  Node: MVBITS,  Next: NEAREST,  Prev: MOVE_ALLOC,  Up: Intrinsic Procedures
-
-7.161 `MVBITS' -- Move bits from one integer to another
-=======================================================
-
-_Description_:
-     Moves LEN bits from positions FROMPOS through `FROMPOS+LEN-1' of
-     FROM to positions TOPOS through `TOPOS+LEN-1' of TO. The portion
-     of argument TO not affected by the movement of bits is unchanged.
-     The values of `FROMPOS+LEN-1' and `TOPOS+LEN-1' must be less than
-     `BIT_SIZE(FROM)'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental subroutine
-
-_Syntax_:
-     `CALL MVBITS(FROM, FROMPOS, LEN, TO, TOPOS)'
-
-_Arguments_:
-     FROM       The type shall be `INTEGER'.
-     FROMPOS    The type shall be `INTEGER'.
-     LEN        The type shall be `INTEGER'.
-     TO         The type shall be `INTEGER', of the same kind
-                as FROM.
-     TOPOS      The type shall be `INTEGER'.
-
-_See also_:
-     *note IBCLR::, *note IBSET::, *note IBITS::, *note IAND::, *note
-     IOR::, *note IEOR::
-
-
-File: gfortran.info,  Node: NEAREST,  Next: NEW_LINE,  Prev: MVBITS,  Up: Intrinsic Procedures
-
-7.162 `NEAREST' -- Nearest representable number
-===============================================
-
-_Description_:
-     `NEAREST(X, S)' returns the processor-representable number nearest
-     to `X' in the direction indicated by the sign of `S'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = NEAREST(X, S)'
-
-_Arguments_:
-     X          Shall be of type `REAL'.
-     S          (Optional) shall be of type `REAL' and not
-                equal to zero.
-
-_Return value_:
-     The return value is of the same type as `X'. If `S' is positive,
-     `NEAREST' returns the processor-representable number greater than
-     `X' and nearest to it. If `S' is negative, `NEAREST' returns the
-     processor-representable number smaller than `X' and nearest to it.
-
-_Example_:
-          program test_nearest
-            real :: x, y
-            x = nearest(42.0, 1.0)
-            y = nearest(42.0, -1.0)
-            write (*,"(3(G20.15))") x, y, x - y
-          end program test_nearest
-
-
-File: gfortran.info,  Node: NEW_LINE,  Next: NINT,  Prev: NEAREST,  Up: Intrinsic Procedures
-
-7.163 `NEW_LINE' -- New line character
-======================================
-
-_Description_:
-     `NEW_LINE(C)' returns the new-line character.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = NEW_LINE(C)'
-
-_Arguments_:
-     C          The argument shall be a scalar or array of the
-                type `CHARACTER'.
-
-_Return value_:
-     Returns a CHARACTER scalar of length one with the new-line
-     character of the same kind as parameter C.
-
-_Example_:
-          program newline
-            implicit none
-            write(*,'(A)') 'This is record 1.'//NEW_LINE('A')//'This is record 2.'
-          end program newline
-
-
-File: gfortran.info,  Node: NINT,  Next: NOT,  Prev: NEW_LINE,  Up: Intrinsic Procedures
-
-7.164 `NINT' -- Nearest whole number
-====================================
-
-_Description_:
-     `NINT(X)' rounds its argument to the nearest whole number.
-
-_Standard_:
-     Fortran 77 and later, with KIND argument Fortran 90 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = NINT(X [, KIND])'
-
-_Arguments_:
-     X          The type of the argument shall be `REAL'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     Returns A with the fractional portion of its magnitude eliminated
-     by rounding to the nearest whole number and with its sign
-     preserved, converted to an `INTEGER' of the default kind.
-
-_Example_:
-          program test_nint
-            real(4) x4
-            real(8) x8
-            x4 = 1.234E0_4
-            x8 = 4.321_8
-            print *, nint(x4), idnint(x8)
-          end program test_nint
-
-_Specific names_:
-     Name              Argument          Standard
-     `IDNINT(X)'       `REAL(8)'         Fortran 95 and
-                                         later
-
-_See also_:
-     *note CEILING::, *note FLOOR::
-
-
-
-File: gfortran.info,  Node: NOT,  Next: NULL,  Prev: NINT,  Up: Intrinsic Procedures
-
-7.165 `NOT' -- Logical negation
-===============================
-
-_Description_:
-     `NOT' returns the bitwise boolean inverse of I.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = NOT(I)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-
-_Return value_:
-     The return type is `INTEGER', of the same kind as the argument.
-
-_See also_:
-     *note IAND::, *note IEOR::, *note IOR::, *note IBITS::, *note
-     IBSET::, *note IBCLR::
-
-
-
-File: gfortran.info,  Node: NULL,  Next: OR,  Prev: NOT,  Up: Intrinsic Procedures
-
-7.166 `NULL' -- Function that returns an disassociated pointer
-==============================================================
-
-_Description_:
-     Returns a disassociated pointer.
-
-     If MOLD is present, a dissassociated pointer of the same type is
-     returned, otherwise the type is determined by context.
-
-     In Fortran 95, MOLD is optional. Please note that Fortran 2003
-     includes cases where it is required.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `PTR => NULL([MOLD])'
-
-_Arguments_:
-     MOLD       (Optional) shall be a pointer of any
-                association status and of any type.
-
-_Return value_:
-     A disassociated pointer.
-
-_Example_:
-          REAL, POINTER, DIMENSION(:) :: VEC => NULL ()
-
-_See also_:
-     *note ASSOCIATED::
-
-
-File: gfortran.info,  Node: OR,  Next: PACK,  Prev: NULL,  Up: Intrinsic Procedures
-
-7.167 `OR' -- Bitwise logical OR
-================================
-
-_Description_:
-     Bitwise logical `OR'.
-
-     This intrinsic routine is provided for backwards compatibility with
-     GNU Fortran 77.  For integer arguments, programmers should consider
-     the use of the *note IOR:: intrinsic defined by the Fortran
-     standard.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = OR(X, Y)'
-
-_Arguments_:
-     X          The type shall be either a scalar `INTEGER'
-                type or a scalar `LOGICAL' type.
-     Y          The type shall be the same as the type of X.
-
-_Return value_:
-     The return type is either a scalar `INTEGER' or a scalar
-     `LOGICAL'.  If the kind type parameters differ, then the smaller
-     kind type is implicitly converted to larger kind, and the return
-     has the larger kind.
-
-_Example_:
-          PROGRAM test_or
-            LOGICAL :: T = .TRUE., F = .FALSE.
-            INTEGER :: a, b
-            DATA a / Z'F' /, b / Z'3' /
-
-            WRITE (*,*) OR(T, T), OR(T, F), OR(F, T), OR(F, F)
-            WRITE (*,*) OR(a, b)
-          END PROGRAM
-
-_See also_:
-     Fortran 95 elemental function: *note IOR::
-
-
-File: gfortran.info,  Node: PACK,  Next: PERROR,  Prev: OR,  Up: Intrinsic Procedures
-
-7.168 `PACK' -- Pack an array into an array of rank one
-=======================================================
-
-_Description_:
-     Stores the elements of ARRAY in an array of rank one.
-
-     The beginning of the resulting array is made up of elements whose
-     MASK equals `TRUE'. Afterwards, positions are filled with elements
-     taken from VECTOR.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = PACK(ARRAY, MASK[,VECTOR]'
-
-_Arguments_:
-     ARRAY      Shall be an array of any type.
-     MASK       Shall be an array of type `LOGICAL' and of the
-                same size as ARRAY. Alternatively, it may be a
-                `LOGICAL' scalar.
-     VECTOR     (Optional) shall be an array of the same type
-                as ARRAY and of rank one. If present, the
-                number of elements in VECTOR shall be equal to
-                or greater than the number of true elements in
-                MASK. If MASK is scalar, the number of
-                elements in VECTOR shall be equal to or
-                greater than the number of elements in ARRAY.
-
-_Return value_:
-     The result is an array of rank one and the same type as that of
-     ARRAY.  If VECTOR is present, the result size is that of VECTOR,
-     the number of `TRUE' values in MASK otherwise.
-
-_Example_:
-     Gathering nonzero elements from an array:
-          PROGRAM test_pack_1
-            INTEGER :: m(6)
-            m = (/ 1, 0, 0, 0, 5, 0 /)
-            WRITE(*, FMT="(6(I0, ' '))") pack(m, m /= 0)  ! "1 5"
-          END PROGRAM
-
-     Gathering nonzero elements from an array and appending elements
-     from VECTOR:
-          PROGRAM test_pack_2
-            INTEGER :: m(4)
-            m = (/ 1, 0, 0, 2 /)
-            WRITE(*, FMT="(4(I0, ' '))") pack(m, m /= 0, (/ 0, 0, 3, 4 /))  ! "1 2 3 4"
-          END PROGRAM
-
-_See also_:
-     *note UNPACK::
-
-
-File: gfortran.info,  Node: PERROR,  Next: PRECISION,  Prev: PACK,  Up: Intrinsic Procedures
-
-7.169 `PERROR' -- Print system error message
-============================================
-
-_Description_:
-     Prints (on the C `stderr' stream) a newline-terminated error
-     message corresponding to the last system error. This is prefixed by
-     STRING, a colon and a space. See `perror(3)'.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL PERROR(STRING)'
-
-_Arguments_:
-     STRING     A scalar of type `CHARACTER' and of the
-                default kind.
-
-_See also_:
-     *note IERRNO::
-
-
-File: gfortran.info,  Node: PRECISION,  Next: PRESENT,  Prev: PERROR,  Up: Intrinsic Procedures
-
-7.170 `PRECISION' -- Decimal precision of a real kind
-=====================================================
-
-_Description_:
-     `PRECISION(X)' returns the decimal precision in the model of the
-     type of `X'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = PRECISION(X)'
-
-_Arguments_:
-     X          Shall be of type `REAL' or `COMPLEX'.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the default integer
-     kind.
-
-_Example_:
-          program prec_and_range
-            real(kind=4) :: x(2)
-            complex(kind=8) :: y
-
-            print *, precision(x), range(x)
-            print *, precision(y), range(y)
-          end program prec_and_range
-
-
-File: gfortran.info,  Node: PRESENT,  Next: PRODUCT,  Prev: PRECISION,  Up: Intrinsic Procedures
-
-7.171 `PRESENT' -- Determine whether an optional dummy argument is specified
-============================================================================
-
-_Description_:
-     Determines whether an optional dummy argument is present.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = PRESENT(A)'
-
-_Arguments_:
-     A          May be of any type and may be a pointer,
-                scalar or array value, or a dummy procedure.
-                It shall be the name of an optional dummy
-                argument accessible within the current
-                subroutine or function.
-
-_Return value_:
-     Returns either `TRUE' if the optional argument A is present, or
-     `FALSE' otherwise.
-
-_Example_:
-          PROGRAM test_present
-            WRITE(*,*) f(), f(42)      ! "F T"
-          CONTAINS
-            LOGICAL FUNCTION f(x)
-              INTEGER, INTENT(IN), OPTIONAL :: x
-              f = PRESENT(x)
-            END FUNCTION
-          END PROGRAM
-
-
-File: gfortran.info,  Node: PRODUCT,  Next: RADIX,  Prev: PRESENT,  Up: Intrinsic Procedures
-
-7.172 `PRODUCT' -- Product of array elements
-============================================
-
-_Description_:
-     Multiplies the elements of ARRAY along dimension DIM if the
-     corresponding element in MASK is `TRUE'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = PRODUCT(ARRAY[, MASK])' `RESULT = PRODUCT(ARRAY, DIM[,
-     MASK])'
-
-_Arguments_:
-     ARRAY      Shall be an array of type `INTEGER', `REAL' or
-                `COMPLEX'.
-     DIM        (Optional) shall be a scalar of type `INTEGER'
-                with a value in the range from 1 to n, where n
-                equals the rank of ARRAY.
-     MASK       (Optional) shall be of type `LOGICAL' and
-                either be a scalar or an array of the same
-                shape as ARRAY.
-
-_Return value_:
-     The result is of the same type as ARRAY.
-
-     If DIM is absent, a scalar with the product of all elements in
-     ARRAY is returned. Otherwise, an array of rank n-1, where n equals
-     the rank of ARRAY, and a shape similar to that of ARRAY with
-     dimension DIM dropped is returned.
-
-_Example_:
-          PROGRAM test_product
-            INTEGER :: x(5) = (/ 1, 2, 3, 4 ,5 /)
-            print *, PRODUCT(x)                    ! all elements, product = 120
-            print *, PRODUCT(x, MASK=MOD(x, 2)==1) ! odd elements, product = 15
-          END PROGRAM
-
-_See also_:
-     *note SUM::
-
-
-File: gfortran.info,  Node: RADIX,  Next: RANDOM_NUMBER,  Prev: PRODUCT,  Up: Intrinsic Procedures
-
-7.173 `RADIX' -- Base of a model number
-=======================================
-
-_Description_:
-     `RADIX(X)' returns the base of the model representing the entity X.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = RADIX(X)'
-
-_Arguments_:
-     X          Shall be of type `INTEGER' or `REAL'
-
-_Return value_:
-     The return value is a scalar of type `INTEGER' and of the default
-     integer kind.
-
-_Example_:
-          program test_radix
-            print *, "The radix for the default integer kind is", radix(0)
-            print *, "The radix for the default real kind is", radix(0.0)
-          end program test_radix
-
-
-
-File: gfortran.info,  Node: RAN,  Next: REAL,  Prev: RANGE,  Up: Intrinsic Procedures
-
-7.174 `RAN' -- Real pseudo-random number
-========================================
-
-_Description_:
-     For compatibility with HP FORTRAN 77/iX, the `RAN' intrinsic is
-     provided as an alias for `RAND'.  See *note RAND:: for complete
-     documentation.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_See also_:
-     *note RAND::, *note RANDOM_NUMBER::
-
-
-File: gfortran.info,  Node: RAND,  Next: RANGE,  Prev: RANDOM_SEED,  Up: Intrinsic Procedures
-
-7.175 `RAND' -- Real pseudo-random number
-=========================================
-
-_Description_:
-     `RAND(FLAG)' returns a pseudo-random number from a uniform
-     distribution between 0 and 1. If FLAG is 0, the next number in the
-     current sequence is returned; if FLAG is 1, the generator is
-     restarted by `CALL SRAND(0)'; if FLAG has any other value, it is
-     used as a new seed with `SRAND'.
-
-     This intrinsic routine is provided for backwards compatibility with
-     GNU Fortran 77. It implements a simple modulo generator as provided
-     by `g77'. For new code, one should consider the use of *note
-     RANDOM_NUMBER:: as it implements a superior algorithm.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = RAND(FLAG)'
-
-_Arguments_:
-     FLAG       Shall be a scalar `INTEGER' of kind 4.
-
-_Return value_:
-     The return value is of `REAL' type and the default kind.
-
-_Example_:
-          program test_rand
-            integer,parameter :: seed = 86456
-
-            call srand(seed)
-            print *, rand(), rand(), rand(), rand()
-            print *, rand(seed), rand(), rand(), rand()
-          end program test_rand
-
-_See also_:
-     *note SRAND::, *note RANDOM_NUMBER::
-
-
-
-File: gfortran.info,  Node: RANDOM_NUMBER,  Next: RANDOM_SEED,  Prev: RADIX,  Up: Intrinsic Procedures
-
-7.176 `RANDOM_NUMBER' -- Pseudo-random number
-=============================================
-
-_Description_:
-     Returns a single pseudorandom number or an array of pseudorandom
-     numbers from the uniform distribution over the range  0 \leq x < 1.
-
-     The runtime-library implements George Marsaglia's KISS (Keep It
-     Simple Stupid) random number generator (RNG). This RNG combines:
-       1. The congruential generator x(n) = 69069 \cdot x(n-1) +
-          1327217885 with a period of 2^32,
-
-       2. A 3-shift shift-register generator with a period of 2^32 - 1,
-
-       3. Two 16-bit multiply-with-carry generators with a period of
-          597273182964842497 > 2^59.
-          The overall period exceeds 2^123.
-
-     Please note, this RNG is thread safe if used within OpenMP
-     directives, i.e., its state will be consistent while called from
-     multiple threads.  However, the KISS generator does not create
-     random numbers in parallel from multiple sources, but in sequence
-     from a single source. If an OpenMP-enabled application heavily
-     relies on random numbers, one should consider employing a
-     dedicated parallel random number generator instead.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `RANDOM_NUMBER(HARVEST)'
-
-_Arguments_:
-     HARVEST    Shall be a scalar or an array of type `REAL'.
-
-_Example_:
-          program test_random_number
-            REAL :: r(5,5)
-            CALL init_random_seed()         ! see example of RANDOM_SEED
-            CALL RANDOM_NUMBER(r)
-          end program
-
-_See also_:
-     *note RANDOM_SEED::
-
-
-File: gfortran.info,  Node: RANDOM_SEED,  Next: RAND,  Prev: RANDOM_NUMBER,  Up: Intrinsic Procedures
-
-7.177 `RANDOM_SEED' -- Initialize a pseudo-random number sequence
-=================================================================
-
-_Description_:
-     Restarts or queries the state of the pseudorandom number generator
-     used by `RANDOM_NUMBER'.
-
-     If `RANDOM_SEED' is called without arguments, it is initialized to
-     a default state. The example below shows how to initialize the
-     random seed based on the system's time.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL RANDOM_SEED(SIZE, PUT, GET)'
-
-_Arguments_:
-     SIZE       (Optional) Shall be a scalar and of type
-                default `INTEGER', with `INTENT(OUT)'. It
-                specifies the minimum size of the arrays used
-                with the PUT and GET arguments.
-     PUT        (Optional) Shall be an array of type default
-                `INTEGER' and rank one. It is `INTENT(IN)' and
-                the size of the array must be larger than or
-                equal to the number returned by the SIZE
-                argument.
-     GET        (Optional) Shall be an array of type default
-                `INTEGER' and rank one. It is `INTENT(OUT)'
-                and the size of the array must be larger than
-                or equal to the number returned by the SIZE
-                argument.
-
-_Example_:
-          SUBROUTINE init_random_seed()
-            INTEGER :: i, n, clock
-            INTEGER, DIMENSION(:), ALLOCATABLE :: seed
-
-            CALL RANDOM_SEED(size = n)
-            ALLOCATE(seed(n))
-
-            CALL SYSTEM_CLOCK(COUNT=clock)
-
-            seed = clock + 37 * (/ (i - 1, i = 1, n) /)
-            CALL RANDOM_SEED(PUT = seed)
-
-            DEALLOCATE(seed)
-          END SUBROUTINE
-
-_See also_:
-     *note RANDOM_NUMBER::
-
-
-File: gfortran.info,  Node: RANGE,  Next: RAN,  Prev: RAND,  Up: Intrinsic Procedures
-
-7.178 `RANGE' -- Decimal exponent range
-=======================================
-
-_Description_:
-     `RANGE(X)' returns the decimal exponent range in the model of the
-     type of `X'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = RANGE(X)'
-
-_Arguments_:
-     X          Shall be of type `INTEGER', `REAL' or
-                `COMPLEX'.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the default integer
-     kind.
-
-_Example_:
-     See `PRECISION' for an example.
-
-
-File: gfortran.info,  Node: REAL,  Next: RENAME,  Prev: RAN,  Up: Intrinsic Procedures
-
-7.179 `REAL' -- Convert to real type
-====================================
-
-_Description_:
-     `REAL(X [, KIND])' converts its argument X to a real type.  The
-     `REALPART(X)' function is provided for compatibility with `g77',
-     and its use is strongly discouraged.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = REAL(X [, KIND])'
-     `RESULT = REALPART(Z)'
-
-_Arguments_:
-     X          Shall be `INTEGER', `REAL', or `COMPLEX'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     These functions return a `REAL' variable or array under the
-     following rules:
-
-    (A)
-          `REAL(X)' is converted to a default real type if X is an
-          integer or real variable.
-
-    (B)
-          `REAL(X)' is converted to a real type with the kind type
-          parameter of X if X is a complex variable.
-
-    (C)
-          `REAL(X, KIND)' is converted to a real type with kind type
-          parameter KIND if X is a complex, integer, or real variable.
-
-_Example_:
-          program test_real
-            complex :: x = (1.0, 2.0)
-            print *, real(x), real(x,8), realpart(x)
-          end program test_real
-
-_See also_:
-     *note DBLE::, *note DFLOAT::, *note FLOAT::
-
-
-
-File: gfortran.info,  Node: RENAME,  Next: REPEAT,  Prev: REAL,  Up: Intrinsic Procedures
-
-7.180 `RENAME' -- Rename a file
-===============================
-
-_Description_:
-     Renames a file from file PATH1 to PATH2. A null character
-     (`CHAR(0)') can be used to mark the end of the names in PATH1 and
-     PATH2; otherwise, trailing blanks in the file names are ignored.
-     If the STATUS argument is supplied, it contains 0 on success or a
-     nonzero error code upon return; see `rename(2)'.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL RENAME(PATH1, PATH2 [, STATUS])'
-     `STATUS = RENAME(PATH1, PATH2)'
-
-_Arguments_:
-     PATH1      Shall be of default `CHARACTER' type.
-     PATH2      Shall be of default `CHARACTER' type.
-     STATUS     (Optional) Shall be of default `INTEGER' type.
-
-_See also_:
-     *note LINK::
-
-
-
-File: gfortran.info,  Node: REPEAT,  Next: RESHAPE,  Prev: RENAME,  Up: Intrinsic Procedures
-
-7.181 `REPEAT' -- Repeated string concatenation
-===============================================
-
-_Description_:
-     Concatenates NCOPIES copies of a string.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = REPEAT(STRING, NCOPIES)'
-
-_Arguments_:
-     STRING     Shall be scalar and of type `CHARACTER'.
-     NCOPIES    Shall be scalar and of type `INTEGER'.
-
-_Return value_:
-     A new scalar of type `CHARACTER' built up from NCOPIES copies of
-     STRING.
-
-_Example_:
-          program test_repeat
-            write(*,*) repeat("x", 5)   ! "xxxxx"
-          end program
-
-
-File: gfortran.info,  Node: RESHAPE,  Next: RRSPACING,  Prev: REPEAT,  Up: Intrinsic Procedures
-
-7.182 `RESHAPE' -- Function to reshape an array
-===============================================
-
-_Description_:
-     Reshapes SOURCE to correspond to SHAPE. If necessary, the new
-     array may be padded with elements from PAD or permuted as defined
-     by ORDER.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = RESHAPE(SOURCE, SHAPE[, PAD, ORDER])'
-
-_Arguments_:
-     SOURCE     Shall be an array of any type.
-     SHAPE      Shall be of type `INTEGER' and an array of
-                rank one. Its values must be positive or zero.
-     PAD        (Optional) shall be an array of the same type
-                as SOURCE.
-     ORDER      (Optional) shall be of type `INTEGER' and an
-                array of the same shape as SHAPE. Its values
-                shall be a permutation of the numbers from 1
-                to n, where n is the size of SHAPE. If ORDER
-                is absent, the natural ordering shall be
-                assumed.
-
-_Return value_:
-     The result is an array of shape SHAPE with the same type as SOURCE.
-
-_Example_:
-          PROGRAM test_reshape
-            INTEGER, DIMENSION(4) :: x
-            WRITE(*,*) SHAPE(x)                       ! prints "4"
-            WRITE(*,*) SHAPE(RESHAPE(x, (/2, 2/)))    ! prints "2 2"
-          END PROGRAM
-
-_See also_:
-     *note SHAPE::
-
-
-File: gfortran.info,  Node: RRSPACING,  Next: RSHIFT,  Prev: RESHAPE,  Up: Intrinsic Procedures
-
-7.183 `RRSPACING' -- Reciprocal of the relative spacing
-=======================================================
-
-_Description_:
-     `RRSPACING(X)' returns the  reciprocal of the relative spacing of
-     model numbers near X.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = RRSPACING(X)'
-
-_Arguments_:
-     X          Shall be of type `REAL'.
-
-_Return value_:
-     The return value is of the same type and kind as X.  The value
-     returned is equal to `ABS(FRACTION(X)) *
-     FLOAT(RADIX(X))**DIGITS(X)'.
-
-_See also_:
-     *note SPACING::
-
-
-File: gfortran.info,  Node: RSHIFT,  Next: SCALE,  Prev: RRSPACING,  Up: Intrinsic Procedures
-
-7.184 `RSHIFT' -- Right shift bits
-==================================
-
-_Description_:
-     `RSHIFT' returns a value corresponding to I with all of the bits
-     shifted right by SHIFT places.  If the absolute value of SHIFT is
-     greater than `BIT_SIZE(I)', the value is undefined.  Bits shifted
-     out from the left end are lost; zeros are shifted in from the
-     opposite end.
-
-     This function has been superseded by the `ISHFT' intrinsic, which
-     is standard in Fortran 95 and later.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = RSHIFT(I, SHIFT)'
-
-_Arguments_:
-     I          The type shall be `INTEGER'.
-     SHIFT      The type shall be `INTEGER'.
-
-_Return value_:
-     The return value is of type `INTEGER' and of the same kind as I.
-
-_See also_:
-     *note ISHFT::, *note ISHFTC::, *note LSHIFT::
-
-
-
-File: gfortran.info,  Node: SCALE,  Next: SCAN,  Prev: RSHIFT,  Up: Intrinsic Procedures
-
-7.185 `SCALE' -- Scale a real value
-===================================
-
-_Description_:
-     `SCALE(X,I)' returns `X * RADIX(X)**I'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = SCALE(X, I)'
-
-_Arguments_:
-     X          The type of the argument shall be a `REAL'.
-     I          The type of the argument shall be a `INTEGER'.
-
-_Return value_:
-     The return value is of the same type and kind as X.  Its value is
-     `X * RADIX(X)**I'.
-
-_Example_:
-          program test_scale
-            real :: x = 178.1387e-4
-            integer :: i = 5
-            print *, scale(x,i), x*radix(x)**i
-          end program test_scale
-
-
-
-File: gfortran.info,  Node: SCAN,  Next: SECNDS,  Prev: SCALE,  Up: Intrinsic Procedures
-
-7.186 `SCAN' -- Scan a string for the presence of a set of characters
-=====================================================================
-
-_Description_:
-     Scans a STRING for any of the characters in a SET of characters.
-
-     If BACK is either absent or equals `FALSE', this function returns
-     the position of the leftmost character of STRING that is in SET.
-     If BACK equals `TRUE', the rightmost position is returned. If no
-     character of SET is found in STRING, the result is zero.
-
-_Standard_:
-     Fortran 95 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = SCAN(STRING, SET[, BACK [, KIND]])'
-
-_Arguments_:
-     STRING     Shall be of type `CHARACTER'.
-     SET        Shall be of type `CHARACTER'.
-     BACK       (Optional) shall be of type `LOGICAL'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER' and of kind KIND. If KIND is
-     absent, the return value is of default integer kind.
-
-_Example_:
-          PROGRAM test_scan
-            WRITE(*,*) SCAN("FORTRAN", "AO")          ! 2, found 'O'
-            WRITE(*,*) SCAN("FORTRAN", "AO", .TRUE.)  ! 6, found 'A'
-            WRITE(*,*) SCAN("FORTRAN", "C++")         ! 0, found none
-          END PROGRAM
-
-_See also_:
-     *note INDEX intrinsic::, *note VERIFY::
-
-
-File: gfortran.info,  Node: SECNDS,  Next: SECOND,  Prev: SCAN,  Up: Intrinsic Procedures
-
-7.187 `SECNDS' -- Time function
-===============================
-
-_Description_:
-     `SECNDS(X)' gets the time in seconds from the real-time system
-     clock.  X is a reference time, also in seconds. If this is zero,
-     the time in seconds from midnight is returned. This function is
-     non-standard and its use is discouraged.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = SECNDS (X)'
-
-_Arguments_:
-     T          Shall be of type `REAL(4)'.
-     X          Shall be of type `REAL(4)'.
-
-_Return value_:
-     None
-
-_Example_:
-          program test_secnds
-              integer :: i
-              real(4) :: t1, t2
-              print *, secnds (0.0)   ! seconds since midnight
-              t1 = secnds (0.0)       ! reference time
-              do i = 1, 10000000      ! do something
-              end do
-              t2 = secnds (t1)        ! elapsed time
-              print *, "Something took ", t2, " seconds."
-          end program test_secnds
-
-
-File: gfortran.info,  Node: SECOND,  Next: SELECTED_CHAR_KIND,  Prev: SECNDS,  Up: Intrinsic Procedures
-
-7.188 `SECOND' -- CPU time function
-===================================
-
-_Description_:
-     Returns a `REAL(4)' value representing the elapsed CPU time in
-     seconds.  This provides the same functionality as the standard
-     `CPU_TIME' intrinsic, and is only included for backwards
-     compatibility.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL SECOND(TIME)'
-     `TIME = SECOND()'
-
-_Arguments_:
-     TIME       Shall be of type `REAL(4)'.
-
-_Return value_:
-     In either syntax, TIME is set to the process's current runtime in
-     seconds.
-
-_See also_:
-     *note CPU_TIME::
-
-
-
-File: gfortran.info,  Node: SELECTED_CHAR_KIND,  Next: SELECTED_INT_KIND,  Prev: SECOND,  Up: Intrinsic Procedures
-
-7.189 `SELECTED_CHAR_KIND' -- Choose character kind
-===================================================
-
-_Description_:
-     `SELECTED_CHAR_KIND(NAME)' returns the kind value for the character
-     set named NAME, if a character set with such a name is supported,
-     or -1 otherwise. Currently, supported character sets include
-     "ASCII" and "DEFAULT", which are equivalent.
-
-_Standard_:
-     Fortran 2003 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = SELECTED_CHAR_KIND(NAME)'
-
-_Arguments_:
-     NAME       Shall be a scalar and of the default character
-                type.
-
-_Example_:
-          program ascii_kind
-            integer,parameter :: ascii = selected_char_kind("ascii")
-            character(kind=ascii, len=26) :: s
-
-            s = ascii_"abcdefghijklmnopqrstuvwxyz"
-            print *, s
-          end program ascii_kind
-
-
-File: gfortran.info,  Node: SELECTED_INT_KIND,  Next: SELECTED_REAL_KIND,  Prev: SELECTED_CHAR_KIND,  Up: Intrinsic Procedures
-
-7.190 `SELECTED_INT_KIND' -- Choose integer kind
-================================================
-
-_Description_:
-     `SELECTED_INT_KIND(I)' return the kind value of the smallest
-     integer type that can represent all values ranging from -10^I
-     (exclusive) to 10^I (exclusive). If there is no integer kind that
-     accommodates this range, `SELECTED_INT_KIND' returns -1.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = SELECTED_INT_KIND(I)'
-
-_Arguments_:
-     I          Shall be a scalar and of type `INTEGER'.
-
-_Example_:
-          program large_integers
-            integer,parameter :: k5 = selected_int_kind(5)
-            integer,parameter :: k15 = selected_int_kind(15)
-            integer(kind=k5) :: i5
-            integer(kind=k15) :: i15
-
-            print *, huge(i5), huge(i15)
-
-            ! The following inequalities are always true
-            print *, huge(i5) >= 10_k5**5-1
-            print *, huge(i15) >= 10_k15**15-1
-          end program large_integers
-
-
-File: gfortran.info,  Node: SELECTED_REAL_KIND,  Next: SET_EXPONENT,  Prev: SELECTED_INT_KIND,  Up: Intrinsic Procedures
-
-7.191 `SELECTED_REAL_KIND' -- Choose real kind
-==============================================
-
-_Description_:
-     `SELECTED_REAL_KIND(P,R)' returns the kind value of a real data
-     type with decimal precision of at least `P' digits and exponent
-     range greater at least `R'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = SELECTED_REAL_KIND(P, R)'
-
-_Arguments_:
-     P          (Optional) shall be a scalar and of type
-                `INTEGER'.
-     R          (Optional) shall be a scalar and of type
-                `INTEGER'.
-     At least one argument shall be present.
-
-_Return value_:
-     `SELECTED_REAL_KIND' returns the value of the kind type parameter
-     of a real data type with decimal precision of at least `P' digits
-     and a decimal exponent range of at least `R'. If more than one
-     real data type meet the criteria, the kind of the data type with
-     the smallest decimal precision is returned. If no real data type
-     matches the criteria, the result is
-    -1 if the processor does not support a real data type with a
-          precision greater than or equal to `P'
-
-    -2 if the processor does not support a real type with an exponent
-          range greater than or equal to `R'
-
-    -3 if neither is supported.
-
-_Example_:
-          program real_kinds
-            integer,parameter :: p6 = selected_real_kind(6)
-            integer,parameter :: p10r100 = selected_real_kind(10,100)
-            integer,parameter :: r400 = selected_real_kind(r=400)
-            real(kind=p6) :: x
-            real(kind=p10r100) :: y
-            real(kind=r400) :: z
-
-            print *, precision(x), range(x)
-            print *, precision(y), range(y)
-            print *, precision(z), range(z)
-          end program real_kinds
-
-
-File: gfortran.info,  Node: SET_EXPONENT,  Next: SHAPE,  Prev: SELECTED_REAL_KIND,  Up: Intrinsic Procedures
-
-7.192 `SET_EXPONENT' -- Set the exponent of the model
-=====================================================
-
-_Description_:
-     `SET_EXPONENT(X, I)' returns the real number whose fractional part
-     is that that of X and whose exponent part is I.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = SET_EXPONENT(X, I)'
-
-_Arguments_:
-     X          Shall be of type `REAL'.
-     I          Shall be of type `INTEGER'.
-
-_Return value_:
-     The return value is of the same type and kind as X.  The real
-     number whose fractional part is that that of X and whose exponent
-     part if I is returned; it is `FRACTION(X) * RADIX(X)**I'.
-
-_Example_:
-          PROGRAM test_setexp
-            REAL :: x = 178.1387e-4
-            INTEGER :: i = 17
-            PRINT *, SET_EXPONENT(x, i), FRACTION(x) * RADIX(x)**i
-          END PROGRAM
-
-
-
-File: gfortran.info,  Node: SHAPE,  Next: SIGN,  Prev: SET_EXPONENT,  Up: Intrinsic Procedures
-
-7.193 `SHAPE' -- Determine the shape of an array
-================================================
-
-_Description_:
-     Determines the shape of an array.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = SHAPE(SOURCE)'
-
-_Arguments_:
-     SOURCE     Shall be an array or scalar of any type.  If
-                SOURCE is a pointer it must be associated and
-                allocatable arrays must be allocated.
-
-_Return value_:
-     An `INTEGER' array of rank one with as many elements as SOURCE has
-     dimensions. The elements of the resulting array correspond to the
-     extend of SOURCE along the respective dimensions. If SOURCE is a
-     scalar, the result is the rank one array of size zero.
-
-_Example_:
-          PROGRAM test_shape
-            INTEGER, DIMENSION(-1:1, -1:2) :: A
-            WRITE(*,*) SHAPE(A)             ! (/ 3, 4 /)
-            WRITE(*,*) SIZE(SHAPE(42))      ! (/ /)
-          END PROGRAM
-
-_See also_:
-     *note RESHAPE::, *note SIZE::
-
-
-File: gfortran.info,  Node: SIGN,  Next: SIGNAL,  Prev: SHAPE,  Up: Intrinsic Procedures
-
-7.194 `SIGN' -- Sign copying function
-=====================================
-
-_Description_:
-     `SIGN(A,B)' returns the value of A with the sign of B.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = SIGN(A, B)'
-
-_Arguments_:
-     A          Shall be of type `INTEGER' or `REAL'
-     B          Shall be of the same type and kind as A
-
-_Return value_:
-     The kind of the return value is that of A and B.  If B\ge 0 then
-     the result is `ABS(A)', else it is `-ABS(A)'.
-
-_Example_:
-          program test_sign
-            print *, sign(-12,1)
-            print *, sign(-12,0)
-            print *, sign(-12,-1)
-
-            print *, sign(-12.,1.)
-            print *, sign(-12.,0.)
-            print *, sign(-12.,-1.)
-          end program test_sign
-
-_Specific names_:
-     Name          Arguments     Return type   Standard
-     `ISIGN(A,P)'  `INTEGER(4)'  `INTEGER(4)'  f95, gnu
-     `DSIGN(A,P)'  `REAL(8)'     `REAL(8)'     f95, gnu
-
-
-File: gfortran.info,  Node: SIGNAL,  Next: SIN,  Prev: SIGN,  Up: Intrinsic Procedures
-
-7.195 `SIGNAL' -- Signal handling subroutine (or function)
-==========================================================
-
-_Description_:
-     `SIGNAL(NUMBER, HANDLER [, STATUS])' causes external subroutine
-     HANDLER to be executed with a single integer argument when signal
-     NUMBER occurs.  If HANDLER is an integer, it can be used to turn
-     off handling of signal NUMBER or revert to its default action.
-     See `signal(2)'.
-
-     If `SIGNAL' is called as a subroutine and the STATUS argument is
-     supplied, it is set to the value returned by `signal(2)'.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL SIGNAL(NUMBER, HANDLER [, STATUS])'
-     `STATUS = SIGNAL(NUMBER, HANDLER)'
-
-_Arguments_:
-     NUMBER     Shall be a scalar integer, with `INTENT(IN)'
-     HANDLER    Signal handler (`INTEGER FUNCTION' or
-                `SUBROUTINE') or dummy/global `INTEGER' scalar.
-                `INTEGER'. It is `INTENT(IN)'.
-     STATUS     (Optional) STATUS shall be a scalar integer.
-                It has `INTENT(OUT)'.
-
-_Return value_:
-     The `SIGNAL' function returns the value returned by `signal(2)'.
-
-_Example_:
-          program test_signal
-            intrinsic signal
-            external handler_print
-
-            call signal (12, handler_print)
-            call signal (10, 1)
-
-            call sleep (30)
-          end program test_signal
-
-
-File: gfortran.info,  Node: SIN,  Next: SINH,  Prev: SIGNAL,  Up: Intrinsic Procedures
-
-7.196 `SIN' -- Sine function
-============================
-
-_Description_:
-     `SIN(X)' computes the sine of X.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = SIN(X)'
-
-_Arguments_:
-     X          The type shall be `REAL' or `COMPLEX'.
-
-_Return value_:
-     The return value has same type and kind as X.
-
-_Example_:
-          program test_sin
-            real :: x = 0.0
-            x = sin(x)
-          end program test_sin
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DSIN(X)'     `REAL(8) X'   `REAL(8)'     f95, gnu
-     `CSIN(X)'     `COMPLEX(4)   `COMPLEX(4)'  f95, gnu
-                   X'                          
-     `ZSIN(X)'     `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
-                   X'                          
-     `CDSIN(X)'    `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
-                   X'                          
-
-_See also_:
-     *note ASIN::
-
-
-File: gfortran.info,  Node: SINH,  Next: SIZE,  Prev: SIN,  Up: Intrinsic Procedures
-
-7.197 `SINH' -- Hyperbolic sine function
-========================================
-
-_Description_:
-     `SINH(X)' computes the hyperbolic sine of X.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = SINH(X)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of type `REAL'.
-
-_Example_:
-          program test_sinh
-            real(8) :: x = - 1.0_8
-            x = sinh(x)
-          end program test_sinh
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DSINH(X)'    `REAL(8) X'   `REAL(8)'     Fortran 95 and
-                                               later
-
-_See also_:
-     *note ASINH::
-
-
-File: gfortran.info,  Node: SIZE,  Next: SIZEOF,  Prev: SINH,  Up: Intrinsic Procedures
-
-7.198 `SIZE' -- Determine the size of an array
-==============================================
-
-_Description_:
-     Determine the extent of ARRAY along a specified dimension DIM, or
-     the total number of elements in ARRAY if DIM is absent.
-
-_Standard_:
-     Fortran 95 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = SIZE(ARRAY[, DIM [, KIND]])'
-
-_Arguments_:
-     ARRAY      Shall be an array of any type. If ARRAY is a
-                pointer it must be associated and allocatable
-                arrays must be allocated.
-     DIM        (Optional) shall be a scalar of type `INTEGER'
-                and its value shall be in the range from 1 to
-                n, where n equals the rank of ARRAY.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER' and of kind KIND. If KIND is
-     absent, the return value is of default integer kind.
-
-_Example_:
-          PROGRAM test_size
-            WRITE(*,*) SIZE((/ 1, 2 /))    ! 2
-          END PROGRAM
-
-_See also_:
-     *note SHAPE::, *note RESHAPE::
-
-
-File: gfortran.info,  Node: SIZEOF,  Next: SLEEP,  Prev: SIZE,  Up: Intrinsic Procedures
-
-7.199 `SIZEOF' -- Size in bytes of an expression
-================================================
-
-_Description_:
-     `SIZEOF(X)' calculates the number of bytes of storage the
-     expression `X' occupies.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Intrinsic function
-
-_Syntax_:
-     `N = SIZEOF(X)'
-
-_Arguments_:
-     X          The argument shall be of any type, rank or
-                shape.
-
-_Return value_:
-     The return value is of type integer and of the system-dependent
-     kind C_SIZE_T (from the ISO_C_BINDING module). Its value is the
-     number of bytes occupied by the argument.  If the argument has the
-     `POINTER' attribute, the number of bytes of the storage area
-     pointed to is returned.  If the argument is of a derived type with
-     `POINTER' or `ALLOCATABLE' components, the return value doesn't
-     account for the sizes of the data pointed to by these components.
-
-_Example_:
-             integer :: i
-             real :: r, s(5)
-             print *, (sizeof(s)/sizeof(r) == 5)
-             end
-     The example will print `.TRUE.' unless you are using a platform
-     where default `REAL' variables are unusually padded.
-
-_See also_:
-     *note C_SIZEOF::
-
-
-File: gfortran.info,  Node: SLEEP,  Next: SNGL,  Prev: SIZEOF,  Up: Intrinsic Procedures
-
-7.200 `SLEEP' -- Sleep for the specified number of seconds
-==========================================================
-
-_Description_:
-     Calling this subroutine causes the process to pause for SECONDS
-     seconds.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL SLEEP(SECONDS)'
-
-_Arguments_:
-     SECONDS    The type shall be of default `INTEGER'.
-
-_Example_:
-          program test_sleep
-            call sleep(5)
-          end
-
-
-File: gfortran.info,  Node: SNGL,  Next: SPACING,  Prev: SLEEP,  Up: Intrinsic Procedures
-
-7.201 `SNGL' -- Convert double precision real to default real
-=============================================================
-
-_Description_:
-     `SNGL(A)' converts the double precision real A to a default real
-     value. This is an archaic form of `REAL' that is specific to one
-     type for A.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = SNGL(A)'
-
-_Arguments_:
-     A          The type shall be a double precision `REAL'.
-
-_Return value_:
-     The return value is of type default `REAL'.
-
-_See also_:
-     *note DBLE::
-
-
-File: gfortran.info,  Node: SPACING,  Next: SPREAD,  Prev: SNGL,  Up: Intrinsic Procedures
-
-7.202 `SPACING' -- Smallest distance between two numbers of a given type
-========================================================================
-
-_Description_:
-     Determines the distance between the argument X and the nearest
-     adjacent number of the same type.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = SPACING(X)'
-
-_Arguments_:
-     X          Shall be of type `REAL'.
-
-_Return value_:
-     The result is of the same type as the input argument X.
-
-_Example_:
-          PROGRAM test_spacing
-            INTEGER, PARAMETER :: SGL = SELECTED_REAL_KIND(p=6, r=37)
-            INTEGER, PARAMETER :: DBL = SELECTED_REAL_KIND(p=13, r=200)
-
-            WRITE(*,*) spacing(1.0_SGL)      ! "1.1920929E-07"          on i686
-            WRITE(*,*) spacing(1.0_DBL)      ! "2.220446049250313E-016" on i686
-          END PROGRAM
-
-_See also_:
-     *note RRSPACING::
-
-
-File: gfortran.info,  Node: SPREAD,  Next: SQRT,  Prev: SPACING,  Up: Intrinsic Procedures
-
-7.203 `SPREAD' -- Add a dimension to an array
-=============================================
-
-_Description_:
-     Replicates a SOURCE array NCOPIES times along a specified
-     dimension DIM.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = SPREAD(SOURCE, DIM, NCOPIES)'
-
-_Arguments_:
-     SOURCE     Shall be a scalar or an array of any type and
-                a rank less than seven.
-     DIM        Shall be a scalar of type `INTEGER' with a
-                value in the range from 1 to n+1, where n
-                equals the rank of SOURCE.
-     NCOPIES    Shall be a scalar of type `INTEGER'.
-
-_Return value_:
-     The result is an array of the same type as SOURCE and has rank n+1
-     where n equals the rank of SOURCE.
-
-_Example_:
-          PROGRAM test_spread
-            INTEGER :: a = 1, b(2) = (/ 1, 2 /)
-            WRITE(*,*) SPREAD(A, 1, 2)            ! "1 1"
-            WRITE(*,*) SPREAD(B, 1, 2)            ! "1 1 2 2"
-          END PROGRAM
-
-_See also_:
-     *note UNPACK::
-
-
-File: gfortran.info,  Node: SQRT,  Next: SRAND,  Prev: SPREAD,  Up: Intrinsic Procedures
-
-7.204 `SQRT' -- Square-root function
-====================================
-
-_Description_:
-     `SQRT(X)' computes the square root of X.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = SQRT(X)'
-
-_Arguments_:
-     X          The type shall be `REAL' or `COMPLEX'.
-
-_Return value_:
-     The return value is of type `REAL' or `COMPLEX'.  The kind type
-     parameter is the same as X.
-
-_Example_:
-          program test_sqrt
-            real(8) :: x = 2.0_8
-            complex :: z = (1.0, 2.0)
-            x = sqrt(x)
-            z = sqrt(z)
-          end program test_sqrt
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DSQRT(X)'    `REAL(8) X'   `REAL(8)'     Fortran 95 and
-                                               later
-     `CSQRT(X)'    `COMPLEX(4)   `COMPLEX(4)'  Fortran 95 and
-                   X'                          later
-     `ZSQRT(X)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
-                   X'                          
-     `CDSQRT(X)'   `COMPLEX(8)   `COMPLEX(8)'  GNU extension
-                   X'                          
-
-
-File: gfortran.info,  Node: SRAND,  Next: STAT,  Prev: SQRT,  Up: Intrinsic Procedures
-
-7.205 `SRAND' -- Reinitialize the random number generator
-=========================================================
-
-_Description_:
-     `SRAND' reinitializes the pseudo-random number generator called by
-     `RAND' and `IRAND'. The new seed used by the generator is
-     specified by the required argument SEED.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL SRAND(SEED)'
-
-_Arguments_:
-     SEED       Shall be a scalar `INTEGER(kind=4)'.
-
-_Return value_:
-     Does not return anything.
-
-_Example_:
-     See `RAND' and `IRAND' for examples.
-
-_Notes_:
-     The Fortran 2003 standard specifies the intrinsic `RANDOM_SEED' to
-     initialize the pseudo-random numbers generator and `RANDOM_NUMBER'
-     to generate pseudo-random numbers. Please note that in GNU
-     Fortran, these two sets of intrinsics (`RAND', `IRAND' and `SRAND'
-     on the one hand, `RANDOM_NUMBER' and `RANDOM_SEED' on the other
-     hand) access two independent pseudo-random number generators.
-
-_See also_:
-     *note RAND::, *note RANDOM_SEED::, *note RANDOM_NUMBER::
-
-
-
-File: gfortran.info,  Node: STAT,  Next: SUM,  Prev: SRAND,  Up: Intrinsic Procedures
-
-7.206 `STAT' -- Get file status
-===============================
-
-_Description_:
-     This function returns information about a file. No permissions are
-     required on the file itself, but execute (search) permission is
-     required on all of the directories in path that lead to the file.
-
-     The elements that are obtained and stored in the array `BUFF':
-     `buff(1)'  Device ID
-     `buff(2)'  Inode number
-     `buff(3)'  File mode
-     `buff(4)'  Number of links
-     `buff(5)'  Owner's uid
-     `buff(6)'  Owner's gid
-     `buff(7)'  ID of device containing directory entry for
-                file (0 if not available)
-     `buff(8)'  File size (bytes)
-     `buff(9)'  Last access time
-     `buff(10)' Last modification time
-     `buff(11)' Last file status change time
-     `buff(12)' Preferred I/O block size (-1 if not available)
-     `buff(13)' Number of blocks allocated (-1 if not
-                available)
-
-     Not all these elements are relevant on all systems.  If an element
-     is not relevant, it is returned as 0.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL STAT(FILE,BUFF[,STATUS])'
-
-_Arguments_:
-     FILE       The type shall be `CHARACTER', of the default
-                kind and a valid path within the file system.
-     BUFF       The type shall be `INTEGER(4), DIMENSION(13)'.
-     STATUS     (Optional) status flag of type `INTEGER(4)'.
-                Returns 0 on success and a system specific
-                error code otherwise.
-
-_Example_:
-          PROGRAM test_stat
-            INTEGER, DIMENSION(13) :: buff
-            INTEGER :: status
-
-            CALL STAT("/etc/passwd", buff, status)
-
-            IF (status == 0) THEN
-              WRITE (*, FMT="('Device ID:',               T30, I19)") buff(1)
-              WRITE (*, FMT="('Inode number:',            T30, I19)") buff(2)
-              WRITE (*, FMT="('File mode (octal):',       T30, O19)") buff(3)
-              WRITE (*, FMT="('Number of links:',         T30, I19)") buff(4)
-              WRITE (*, FMT="('Owner''s uid:',            T30, I19)") buff(5)
-              WRITE (*, FMT="('Owner''s gid:',            T30, I19)") buff(6)
-              WRITE (*, FMT="('Device where located:',    T30, I19)") buff(7)
-              WRITE (*, FMT="('File size:',               T30, I19)") buff(8)
-              WRITE (*, FMT="('Last access time:',        T30, A19)") CTIME(buff(9))
-              WRITE (*, FMT="('Last modification time',   T30, A19)") CTIME(buff(10))
-              WRITE (*, FMT="('Last status change time:', T30, A19)") CTIME(buff(11))
-              WRITE (*, FMT="('Preferred block size:',    T30, I19)") buff(12)
-              WRITE (*, FMT="('No. of blocks allocated:', T30, I19)") buff(13)
-            END IF
-          END PROGRAM
-
-_See also_:
-     To stat an open file: *note FSTAT::, to stat a link: *note LSTAT::
-
-
-File: gfortran.info,  Node: SUM,  Next: SYMLNK,  Prev: STAT,  Up: Intrinsic Procedures
-
-7.207 `SUM' -- Sum of array elements
-====================================
-
-_Description_:
-     Adds the elements of ARRAY along dimension DIM if the
-     corresponding element in MASK is `TRUE'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = SUM(ARRAY[, MASK])' `RESULT = SUM(ARRAY, DIM[, MASK])'
-
-_Arguments_:
-     ARRAY      Shall be an array of type `INTEGER', `REAL' or
-                `COMPLEX'.
-     DIM        (Optional) shall be a scalar of type `INTEGER'
-                with a value in the range from 1 to n, where n
-                equals the rank of ARRAY.
-     MASK       (Optional) shall be of type `LOGICAL' and
-                either be a scalar or an array of the same
-                shape as ARRAY.
-
-_Return value_:
-     The result is of the same type as ARRAY.
-
-     If DIM is absent, a scalar with the sum of all elements in ARRAY
-     is returned. Otherwise, an array of rank n-1, where n equals the
-     rank of ARRAY,and a shape similar to that of ARRAY with dimension
-     DIM dropped is returned.
-
-_Example_:
-          PROGRAM test_sum
-            INTEGER :: x(5) = (/ 1, 2, 3, 4 ,5 /)
-            print *, SUM(x)                        ! all elements, sum = 15
-            print *, SUM(x, MASK=MOD(x, 2)==1)     ! odd elements, sum = 9
-          END PROGRAM
-
-_See also_:
-     *note PRODUCT::
-
-
-File: gfortran.info,  Node: SYMLNK,  Next: SYSTEM,  Prev: SUM,  Up: Intrinsic Procedures
-
-7.208 `SYMLNK' -- Create a symbolic link
-========================================
-
-_Description_:
-     Makes a symbolic link from file PATH1 to PATH2. A null character
-     (`CHAR(0)') can be used to mark the end of the names in PATH1 and
-     PATH2; otherwise, trailing blanks in the file names are ignored.
-     If the STATUS argument is supplied, it contains 0 on success or a
-     nonzero error code upon return; see `symlink(2)'.  If the system
-     does not supply `symlink(2)', `ENOSYS' is returned.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL SYMLNK(PATH1, PATH2 [, STATUS])'
-     `STATUS = SYMLNK(PATH1, PATH2)'
-
-_Arguments_:
-     PATH1      Shall be of default `CHARACTER' type.
-     PATH2      Shall be of default `CHARACTER' type.
-     STATUS     (Optional) Shall be of default `INTEGER' type.
-
-_See also_:
-     *note LINK::, *note UNLINK::
-
-
-
-File: gfortran.info,  Node: SYSTEM,  Next: SYSTEM_CLOCK,  Prev: SYMLNK,  Up: Intrinsic Procedures
-
-7.209 `SYSTEM' -- Execute a shell command
-=========================================
-
-_Description_:
-     Passes the command COMMAND to a shell (see `system(3)'). If
-     argument STATUS is present, it contains the value returned by
-     `system(3)', which is presumably 0 if the shell command succeeded.
-     Note that which shell is used to invoke the command is
-     system-dependent and environment-dependent.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL SYSTEM(COMMAND [, STATUS])'
-     `STATUS = SYSTEM(COMMAND)'
-
-_Arguments_:
-     COMMAND    Shall be of default `CHARACTER' type.
-     STATUS     (Optional) Shall be of default `INTEGER' type.
-
-_See also_:
-
-
-File: gfortran.info,  Node: SYSTEM_CLOCK,  Next: TAN,  Prev: SYSTEM,  Up: Intrinsic Procedures
-
-7.210 `SYSTEM_CLOCK' -- Time function
-=====================================
-
-_Description_:
-     Determines the COUNT of milliseconds of wall clock time since the
-     Epoch (00:00:00 UTC, January 1, 1970) modulo COUNT_MAX, COUNT_RATE
-     determines the number of clock ticks per second.  COUNT_RATE and
-     COUNT_MAX are constant and specific to `gfortran'.
-
-     If there is no clock, COUNT is set to `-HUGE(COUNT)', and
-     COUNT_RATE and COUNT_MAX are set to zero
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL SYSTEM_CLOCK([COUNT, COUNT_RATE, COUNT_MAX])'
-
-_Arguments_:
-
-_Arguments_:
-     COUNT      (Optional) shall be a scalar of type default
-                `INTEGER' with `INTENT(OUT)'.
-     COUNT_RATE (Optional) shall be a scalar of type default
-                `INTEGER' with `INTENT(OUT)'.
-     COUNT_MAX  (Optional) shall be a scalar of type default
-                `INTEGER' with `INTENT(OUT)'.
-
-_Example_:
-          PROGRAM test_system_clock
-            INTEGER :: count, count_rate, count_max
-            CALL SYSTEM_CLOCK(count, count_rate, count_max)
-            WRITE(*,*) count, count_rate, count_max
-          END PROGRAM
-
-_See also_:
-     *note DATE_AND_TIME::, *note CPU_TIME::
-
-
-File: gfortran.info,  Node: TAN,  Next: TANH,  Prev: SYSTEM_CLOCK,  Up: Intrinsic Procedures
-
-7.211 `TAN' -- Tangent function
-===============================
-
-_Description_:
-     `TAN(X)' computes the tangent of X.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = TAN(X)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of type `REAL'.  The kind type parameter is
-     the same as X.
-
-_Example_:
-          program test_tan
-            real(8) :: x = 0.165_8
-            x = tan(x)
-          end program test_tan
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DTAN(X)'     `REAL(8) X'   `REAL(8)'     Fortran 95 and
-                                               later
-
-_See also_:
-     *note ATAN::
-
-
-File: gfortran.info,  Node: TANH,  Next: TIME,  Prev: TAN,  Up: Intrinsic Procedures
-
-7.212 `TANH' -- Hyperbolic tangent function
-===========================================
-
-_Description_:
-     `TANH(X)' computes the hyperbolic tangent of X.
-
-_Standard_:
-     Fortran 77 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `X = TANH(X)'
-
-_Arguments_:
-     X          The type shall be `REAL'.
-
-_Return value_:
-     The return value is of type `REAL' and lies in the range  - 1 \leq
-     tanh(x) \leq 1 .
-
-_Example_:
-          program test_tanh
-            real(8) :: x = 2.1_8
-            x = tanh(x)
-          end program test_tanh
-
-_Specific names_:
-     Name          Argument      Return type   Standard
-     `DTANH(X)'    `REAL(8) X'   `REAL(8)'     Fortran 95 and
-                                               later
-
-_See also_:
-     *note ATANH::
-
-
-File: gfortran.info,  Node: TIME,  Next: TIME8,  Prev: TANH,  Up: Intrinsic Procedures
-
-7.213 `TIME' -- Time function
-=============================
-
-_Description_:
-     Returns the current time encoded as an integer (in the manner of
-     the UNIX function `time(3)'). This value is suitable for passing to
-     `CTIME()', `GMTIME()', and `LTIME()'.
-
-     This intrinsic is not fully portable, such as to systems with
-     32-bit `INTEGER' types but supporting times wider than 32 bits.
-     Therefore, the values returned by this intrinsic might be, or
-     become, negative, or numerically less than previous values, during
-     a single run of the compiled program.
-
-     See *note TIME8::, for information on a similar intrinsic that
-     might be portable to more GNU Fortran implementations, though to
-     fewer Fortran compilers.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = TIME()'
-
-_Return value_:
-     The return value is a scalar of type `INTEGER(4)'.
-
-_See also_:
-     *note CTIME::, *note GMTIME::, *note LTIME::, *note MCLOCK::,
-     *note TIME8::
-
-
-
-File: gfortran.info,  Node: TIME8,  Next: TINY,  Prev: TIME,  Up: Intrinsic Procedures
-
-7.214 `TIME8' -- Time function (64-bit)
-=======================================
-
-_Description_:
-     Returns the current time encoded as an integer (in the manner of
-     the UNIX function `time(3)'). This value is suitable for passing to
-     `CTIME()', `GMTIME()', and `LTIME()'.
-
-     _Warning:_ this intrinsic does not increase the range of the timing
-     values over that returned by `time(3)'. On a system with a 32-bit
-     `time(3)', `TIME8()' will return a 32-bit value, even though it is
-     converted to a 64-bit `INTEGER(8)' value. That means overflows of
-     the 32-bit value can still occur. Therefore, the values returned
-     by this intrinsic might be or become negative or numerically less
-     than previous values during a single run of the compiled program.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = TIME8()'
-
-_Return value_:
-     The return value is a scalar of type `INTEGER(8)'.
-
-_See also_:
-     *note CTIME::, *note GMTIME::, *note LTIME::, *note MCLOCK8::,
-     *note TIME::
-
-
-
-File: gfortran.info,  Node: TINY,  Next: TRAILZ,  Prev: TIME8,  Up: Intrinsic Procedures
-
-7.215 `TINY' -- Smallest positive number of a real kind
-=======================================================
-
-_Description_:
-     `TINY(X)' returns the smallest positive (non zero) number in the
-     model of the type of `X'.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = TINY(X)'
-
-_Arguments_:
-     X          Shall be of type `REAL'.
-
-_Return value_:
-     The return value is of the same type and kind as X
-
-_Example_:
-     See `HUGE' for an example.
-
-
-File: gfortran.info,  Node: TRAILZ,  Next: TRANSFER,  Prev: TINY,  Up: Intrinsic Procedures
-
-7.216 `TRAILZ' -- Number of trailing zero bits of an integer
-============================================================
-
-_Description_:
-     `TRAILZ' returns the number of trailing zero bits of an integer.
-
-_Standard_:
-     Fortran 2008 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = TRAILZ(I)'
-
-_Arguments_:
-     I          Shall be of type `INTEGER'.
-
-_Return value_:
-     The type of the return value is the default `INTEGER'.  If all the
-     bits of `I' are zero, the result value is `BIT_SIZE(I)'.
-
-_Example_:
-          PROGRAM test_trailz
-            WRITE (*,*) TRAILZ(8)  ! prints 3
-          END PROGRAM
-
-_See also_:
-     *note BIT_SIZE::, *note LEADZ::
-
-
-File: gfortran.info,  Node: TRANSFER,  Next: TRANSPOSE,  Prev: TRAILZ,  Up: Intrinsic Procedures
-
-7.217 `TRANSFER' -- Transfer bit patterns
-=========================================
-
-_Description_:
-     Interprets the bitwise representation of SOURCE in memory as if it
-     is the representation of a variable or array of the same type and
-     type parameters as MOLD.
-
-     This is approximately equivalent to the C concept of _casting_ one
-     type to another.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = TRANSFER(SOURCE, MOLD[, SIZE])'
-
-_Arguments_:
-     SOURCE     Shall be a scalar or an array of any type.
-     MOLD       Shall be a scalar or an array of any type.
-     SIZE       (Optional) shall be a scalar of type `INTEGER'.
-
-_Return value_:
-     The result has the same type as MOLD, with the bit level
-     representation of SOURCE.  If SIZE is present, the result is a
-     one-dimensional array of length SIZE.  If SIZE is absent but MOLD
-     is an array (of any size or shape), the result is a one-
-     dimensional array of the minimum length needed to contain the
-     entirety of the bitwise representation of SOURCE.   If SIZE is
-     absent and MOLD is a scalar, the result is a scalar.
-
-     If the bitwise representation of the result is longer than that of
-     SOURCE, then the leading bits of the result correspond to those of
-     SOURCE and any trailing bits are filled arbitrarily.
-
-     When the resulting bit representation does not correspond to a
-     valid representation of a variable of the same type as MOLD, the
-     results are undefined, and subsequent operations on the result
-     cannot be guaranteed to produce sensible behavior.  For example,
-     it is possible to create `LOGICAL' variables for which `VAR' and
-     `.NOT.VAR' both appear to be true.
-
-_Example_:
-          PROGRAM test_transfer
-            integer :: x = 2143289344
-            print *, transfer(x, 1.0)    ! prints "NaN" on i686
-          END PROGRAM
-
-
-File: gfortran.info,  Node: TRANSPOSE,  Next: TRIM,  Prev: TRANSFER,  Up: Intrinsic Procedures
-
-7.218 `TRANSPOSE' -- Transpose an array of rank two
-===================================================
-
-_Description_:
-     Transpose an array of rank two. Element (i, j) of the result has
-     the value `MATRIX(j, i)', for all i, j.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = TRANSPOSE(MATRIX)'
-
-_Arguments_:
-     MATRIX     Shall be an array of any type and have a rank
-                of two.
-
-_Return value_:
-     The result has the same type as MATRIX, and has shape `(/ m, n /)'
-     if MATRIX has shape `(/ n, m /)'.
-
-
-File: gfortran.info,  Node: TRIM,  Next: TTYNAM,  Prev: TRANSPOSE,  Up: Intrinsic Procedures
-
-7.219 `TRIM' -- Remove trailing blank characters of a string
-============================================================
-
-_Description_:
-     Removes trailing blank characters of a string.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = TRIM(STRING)'
-
-_Arguments_:
-     STRING     Shall be a scalar of type `CHARACTER'.
-
-_Return value_:
-     A scalar of type `CHARACTER' which length is that of STRING less
-     the number of trailing blanks.
-
-_Example_:
-          PROGRAM test_trim
-            CHARACTER(len=10), PARAMETER :: s = "GFORTRAN  "
-            WRITE(*,*) LEN(s), LEN(TRIM(s))  ! "10 8", with/without trailing blanks
-          END PROGRAM
-
-_See also_:
-     *note ADJUSTL::, *note ADJUSTR::
-
-
-File: gfortran.info,  Node: TTYNAM,  Next: UBOUND,  Prev: TRIM,  Up: Intrinsic Procedures
-
-7.220 `TTYNAM' -- Get the name of a terminal device.
-====================================================
-
-_Description_:
-     Get the name of a terminal device. For more information, see
-     `ttyname(3)'.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL TTYNAM(UNIT, NAME)'
-     `NAME = TTYNAM(UNIT)'
-
-_Arguments_:
-     UNIT       Shall be a scalar `INTEGER'.
-     NAME       Shall be of type `CHARACTER'.
-
-_Example_:
-          PROGRAM test_ttynam
-            INTEGER :: unit
-            DO unit = 1, 10
-              IF (isatty(unit=unit)) write(*,*) ttynam(unit)
-            END DO
-          END PROGRAM
-
-_See also_:
-     *note ISATTY::
-
-
-File: gfortran.info,  Node: UBOUND,  Next: UMASK,  Prev: TTYNAM,  Up: Intrinsic Procedures
-
-7.221 `UBOUND' -- Upper dimension bounds of an array
-====================================================
-
-_Description_:
-     Returns the upper bounds of an array, or a single upper bound
-     along the DIM dimension.
-
-_Standard_:
-     Fortran 95 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Inquiry function
-
-_Syntax_:
-     `RESULT = UBOUND(ARRAY [, DIM [, KIND]])'
-
-_Arguments_:
-     ARRAY      Shall be an array, of any type.
-     DIM        (Optional) Shall be a scalar `INTEGER'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER' and of kind KIND. If KIND is
-     absent, the return value is of default integer kind.  If DIM is
-     absent, the result is an array of the upper bounds of ARRAY.  If
-     DIM is present, the result is a scalar corresponding to the upper
-     bound of the array along that dimension.  If ARRAY is an
-     expression rather than a whole array or array structure component,
-     or if it has a zero extent along the relevant dimension, the upper
-     bound is taken to be the number of elements along the relevant
-     dimension.
-
-_See also_:
-     *note LBOUND::
-
-
-File: gfortran.info,  Node: UMASK,  Next: UNLINK,  Prev: UBOUND,  Up: Intrinsic Procedures
-
-7.222 `UMASK' -- Set the file creation mask
-===========================================
-
-_Description_:
-     Sets the file creation mask to MASK and returns the old value in
-     argument OLD if it is supplied. See `umask(2)'.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine
-
-_Syntax_:
-     `CALL UMASK(MASK [, OLD])'
-
-_Arguments_:
-     MASK       Shall be a scalar of type `INTEGER'.
-     MASK       (Optional) Shall be a scalar of type `INTEGER'.
-
-
-
-File: gfortran.info,  Node: UNLINK,  Next: UNPACK,  Prev: UMASK,  Up: Intrinsic Procedures
-
-7.223 `UNLINK' -- Remove a file from the file system
-====================================================
-
-_Description_:
-     Unlinks the file PATH. A null character (`CHAR(0)') can be used to
-     mark the end of the name in PATH; otherwise, trailing blanks in
-     the file name are ignored.  If the STATUS argument is supplied, it
-     contains 0 on success or a nonzero error code upon return; see
-     `unlink(2)'.
-
-     This intrinsic is provided in both subroutine and function forms;
-     however, only one form can be used in any given program unit.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Subroutine, function
-
-_Syntax_:
-     `CALL UNLINK(PATH [, STATUS])'
-     `STATUS = UNLINK(PATH)'
-
-_Arguments_:
-     PATH       Shall be of default `CHARACTER' type.
-     STATUS     (Optional) Shall be of default `INTEGER' type.
-
-_See also_:
-     *note LINK::, *note SYMLNK::
-
-
-File: gfortran.info,  Node: UNPACK,  Next: VERIFY,  Prev: UNLINK,  Up: Intrinsic Procedures
-
-7.224 `UNPACK' -- Unpack an array of rank one into an array
-===========================================================
-
-_Description_:
-     Store the elements of VECTOR in an array of higher rank.
-
-_Standard_:
-     Fortran 95 and later
-
-_Class_:
-     Transformational function
-
-_Syntax_:
-     `RESULT = UNPACK(VECTOR, MASK, FIELD)'
-
-_Arguments_:
-     VECTOR     Shall be an array of any type and rank one. It
-                shall have at least as many elements as MASK
-                has `TRUE' values.
-     MASK       Shall be an array of type `LOGICAL'.
-     FIELD      Shall be of the same type as VECTOR and have
-                the same shape as MASK.
-
-_Return value_:
-     The resulting array corresponds to FIELD with `TRUE' elements of
-     MASK replaced by values from VECTOR in array element order.
-
-_Example_:
-          PROGRAM test_unpack
-            integer :: vector(2)  = (/1,1/)
-            logical :: mask(4)  = (/ .TRUE., .FALSE., .FALSE., .TRUE. /)
-            integer :: field(2,2) = 0, unity(2,2)
-
-            ! result: unity matrix
-            unity = unpack(vector, reshape(mask, (/2,2/)), field)
-          END PROGRAM
-
-_See also_:
-     *note PACK::, *note SPREAD::
-
-
-File: gfortran.info,  Node: VERIFY,  Next: XOR,  Prev: UNPACK,  Up: Intrinsic Procedures
-
-7.225 `VERIFY' -- Scan a string for the absence of a set of characters
-======================================================================
-
-_Description_:
-     Verifies that all the characters in a SET are present in a STRING.
-
-     If BACK is either absent or equals `FALSE', this function returns
-     the position of the leftmost character of STRING that is not in
-     SET. If BACK equals `TRUE', the rightmost position is returned. If
-     all characters of SET are found in STRING, the result is zero.
-
-_Standard_:
-     Fortran 95 and later, with KIND argument Fortran 2003 and later
-
-_Class_:
-     Elemental function
-
-_Syntax_:
-     `RESULT = VERIFY(STRING, SET[, BACK [, KIND]])'
-
-_Arguments_:
-     STRING     Shall be of type `CHARACTER'.
-     SET        Shall be of type `CHARACTER'.
-     BACK       (Optional) shall be of type `LOGICAL'.
-     KIND       (Optional) An `INTEGER' initialization
-                expression indicating the kind parameter of
-                the result.
-
-_Return value_:
-     The return value is of type `INTEGER' and of kind KIND. If KIND is
-     absent, the return value is of default integer kind.
-
-_Example_:
-          PROGRAM test_verify
-            WRITE(*,*) VERIFY("FORTRAN", "AO")           ! 1, found 'F'
-            WRITE(*,*) VERIFY("FORTRAN", "FOO")          ! 3, found 'R'
-            WRITE(*,*) VERIFY("FORTRAN", "C++")          ! 1, found 'F'
-            WRITE(*,*) VERIFY("FORTRAN", "C++", .TRUE.)  ! 7, found 'N'
-            WRITE(*,*) VERIFY("FORTRAN", "FORTRAN")      ! 0' found none
-          END PROGRAM
-
-_See also_:
-     *note SCAN::, *note INDEX intrinsic::
-
-
-File: gfortran.info,  Node: XOR,  Prev: VERIFY,  Up: Intrinsic Procedures
-
-7.226 `XOR' -- Bitwise logical exclusive OR
-===========================================
-
-_Description_:
-     Bitwise logical exclusive or.
-
-     This intrinsic routine is provided for backwards compatibility with
-     GNU Fortran 77.  For integer arguments, programmers should consider
-     the use of the *note IEOR:: intrinsic defined by the Fortran
-     standard.
-
-_Standard_:
-     GNU extension
-
-_Class_:
-     Function
-
-_Syntax_:
-     `RESULT = XOR(X, Y)'
-
-_Arguments_:
-     X          The type shall be either  a scalar `INTEGER'
-                type or a scalar `LOGICAL' type.
-     Y          The type shall be the same as the type of I.
-
-_Return value_:
-     The return type is either a scalar `INTEGER' or a scalar
-     `LOGICAL'.  If the kind type parameters differ, then the smaller
-     kind type is implicitly converted to larger kind, and the return
-     has the larger kind.
-
-_Example_:
-          PROGRAM test_xor
-            LOGICAL :: T = .TRUE., F = .FALSE.
-            INTEGER :: a, b
-            DATA a / Z'F' /, b / Z'3' /
-
-            WRITE (*,*) XOR(T, T), XOR(T, F), XOR(F, T), XOR(F, F)
-            WRITE (*,*) XOR(a, b)
-          END PROGRAM
-
-_See also_:
-     Fortran 95 elemental function: *note IEOR::
-
-
-File: gfortran.info,  Node: Intrinsic Modules,  Next: Contributing,  Prev: Intrinsic Procedures,  Up: Top
-
-8 Intrinsic Modules
-*******************
-
-8.1 `ISO_FORTRAN_ENV'
-=====================
-
-_Standard_:
-     Fortran 2003 and later
-
-   The `ISO_FORTRAN_ENV' module provides the following scalar
-default-integer named constants:
-
-`CHARACTER_STORAGE_SIZE':
-     Size in bits of the character storage unit.
-
-`ERROR_UNIT':
-     Identifies the preconnected unit used for error reporting.
-
-`FILE_STORAGE_SIZE':
-     Size in bits of the file-storage unit.
-
-`INPUT_UNIT':
-     Identifies the preconnected unit identified by the asterisk (`*')
-     in `READ' statement.
-
-`IOSTAT_END':
-     The value assigned to the variable passed to the IOSTAT= specifier
-     of an input/output statement if an end-of-file condition occurred.
-
-`IOSTAT_EOR':
-     The value assigned to the variable passed to the IOSTAT= specifier
-     of an input/output statement if an end-of-record condition
-     occurred.
-
-`NUMERIC_STORAGE_SIZE':
-     The size in bits of the numeric storage unit.
-
-`OUTPUT_UNIT':
-     Identifies the preconnected unit identified by the asterisk (`*')
-     in `WRITE' statement.
-
-8.2 `ISO_C_BINDING'
-===================
-
-_Standard_:
-     Fortran 2003 and later, GNU extensions
-
-   The following intrinsic procedures are provided by the module; their
-definition can be found in the section Intrinsic Procedures of this
-manual.
-
-`C_ASSOCIATED'
-
-`C_F_POINTER'
-
-`C_F_PROCPOINTER'
-
-`C_FUNLOC'
-
-`C_LOC'
-
-   The `ISO_C_BINDING' module provides the following named constants of
-the type integer, which can be used as KIND type parameter. Note that
-GNU Fortran currently does not support the `C_INT_FAST...' KIND type
-parameters (marked by an asterisk (`*') in the list below).  The
-`C_INT_FAST...' parameters have therefore the value -2 and cannot be
-used as KIND type parameter of the `INTEGER' type.
-
-   In addition to the integer named constants required by the Fortran
-2003 standard, GNU Fortran provides as an extension named constants for
-the 128-bit integer types supported by the C compiler: `C_INT128_T,
-C_INT_LEAST128_T, C_INT_FAST128_T'.
-
-Fortran     Named constant            C type                    Extension
-Type                                                            
-`INTEGER'   `C_INT'                   `int'                     
-`INTEGER'   `C_SHORT'                 `short int'               
-`INTEGER'   `C_LONG'                  `long int'                
-`INTEGER'   `C_LONG_LONG'             `long long int'           
-`INTEGER'   `C_SIGNED_CHAR'           `signed char'/`unsigned   
-                                      char'                     
-`INTEGER'   `C_SIZE_T'                `size_t'                  
-`INTEGER'   `C_INT8_T'                `int8_t'                  
-`INTEGER'   `C_INT16_T'               `int16_t'                 
-`INTEGER'   `C_INT32_T'               `int32_t'                 
-`INTEGER'   `C_INT64_T'               `int64_t'                 
-`INTEGER'   `C_INT128_T'              `int128_t'                Ext.
-`INTEGER'   `C_INT_LEAST8_T'          `int_least8_t'            
-`INTEGER'   `C_INT_LEAST16_T'         `int_least16_t'           
-`INTEGER'   `C_INT_LEAST32_T'         `int_least32_t'           
-`INTEGER'   `C_INT_LEAST64_T'         `int_least64_t'           
-`INTEGER'   `C_INT_LEAST128_T'        `int_least128_t'          Ext.
-`INTEGER'   `C_INT_FAST8_T'*          `int_fast8_t'             
-`INTEGER'   `C_INT_FAST16_T'*         `int_fast16_t'            
-`INTEGER'   `C_INT_FAST32_T'*         `int_fast32_t'            
-`INTEGER'   `C_INT_FAST64_T'*         `int_fast64_t'            
-`INTEGER'   `C_INT_FAST128_T'*        `int_fast128_t'           Ext.
-`INTEGER'   `C_INTMAX_T'              `intmax_t'                
-`INTEGER'   `C_INTPTR_T'              `intptr_t'                
-`REAL'      `C_FLOAT'                 `float'                   
-`REAL'      `C_DOUBLE'                `double'                  
-`REAL'      `C_LONG_DOUBLE'           `long double'             
-`COMPLEX'   `C_FLOAT_COMPLEX'         `float _Complex'          
-`COMPLEX'   `C_DOUBLE_COMPLEX'        `double _Complex'         
-`COMPLEX'   `C_LONG_DOUBLE_COMPLEX'   `long double _Complex'    
-`LOGICAL'   `C_BOOL'                  `_Bool'                   
-`CHARACTER' `C_CHAR'                  `char'                    
-
-   Additionally, the following `(CHARACTER(KIND=C_CHAR))' are defined.
-
-Name           C definition                     Value
-`C_NULL_CHAR'  null character                   `'\0''
-`C_ALERT'      alert                            `'\a''
-`C_BACKSPACE'  backspace                        `'\b''
-`C_FORM_FEED'  form feed                        `'\f''
-`C_NEW_LINE'   new line                         `'\n''
-`C_CARRIAGE_RETURN'carriage return                  `'\r''
-`C_HORIZONTAL_TAB'horizontal tab                   `'\t''
-`C_VERTICAL_TAB'vertical tab                     `'\v''
-
-8.3 OpenMP Modules `OMP_LIB' and `OMP_LIB_KINDS'
-================================================
-
-_Standard_:
-     OpenMP Application Program Interface v3.0
-
-   The OpenMP Fortran runtime library routines are provided both in a
-form of two Fortran 90 modules, named `OMP_LIB' and `OMP_LIB_KINDS',
-and in a form of a Fortran `include' file named `omp_lib.h'. The
-procedures provided by `OMP_LIB' can be found in the *note
-Introduction: (libgomp)Top. manual, the named constants defined in the
-`OMP_LIB_KINDS' module are listed below.
-
-   For details refer to the actual OpenMP Application Program Interface
-v3.0 (http://www.openmp.org/mp-documents/spec30.pdf).
-
-   `OMP_LIB_KINDS' provides the following scalar default-integer named
-constants:
-
-`omp_integer_kind'
-
-`omp_logical_kind'
-
-`omp_lock_kind'
-
-`omp_nest_lock_kind'
-
-`omp_sched_kind'
-
-
-File: gfortran.info,  Node: Contributing,  Next: Copying,  Prev: Intrinsic Modules,  Up: Top
-
-Contributing
-************
-
-Free software is only possible if people contribute to efforts to
-create it.  We're always in need of more people helping out with ideas
-and comments, writing documentation and contributing code.
-
-   If you want to contribute to GNU Fortran, have a look at the long
-lists of projects you can take on.  Some of these projects are small,
-some of them are large; some are completely orthogonal to the rest of
-what is happening on GNU Fortran, but others are "mainstream" projects
-in need of enthusiastic hackers.  All of these projects are important!
-We'll eventually get around to the things here, but they are also
-things doable by someone who is willing and able.
-
-* Menu:
-
-* Contributors::
-* Projects::
-* Proposed Extensions::
-
-
-File: gfortran.info,  Node: Contributors,  Next: Projects,  Up: Contributing
-
-Contributors to GNU Fortran
-===========================
-
-Most of the parser was hand-crafted by _Andy Vaught_, who is also the
-initiator of the whole project.  Thanks Andy!  Most of the interface
-with GCC was written by _Paul Brook_.
-
-   The following individuals have contributed code and/or ideas and
-significant help to the GNU Fortran project (in alphabetical order):
-
-   - Janne Blomqvist
-
-   - Steven Bosscher
-
-   - Paul Brook
-
-   - Tobias Burnus
-
-   - Franc,ois-Xavier Coudert
-
-   - Bud Davis
-
-   - Jerry DeLisle
-
-   - Erik Edelmann
-
-   - Bernhard Fischer
-
-   - Daniel Franke
-
-   - Richard Guenther
-
-   - Richard Henderson
-
-   - Katherine Holcomb
-
-   - Jakub Jelinek
-
-   - Niels Kristian Bech Jensen
-
-   - Steven Johnson
-
-   - Steven G. Kargl
-
-   - Thomas Koenig
-
-   - Asher Langton
-
-   - H. J. Lu
-
-   - Toon Moene
-
-   - Brooks Moses
-
-   - Andrew Pinski
-
-   - Tim Prince
-
-   - Christopher D. Rickett
-
-   - Richard Sandiford
-
-   - Tobias Schlu"ter
-
-   - Roger Sayle
-
-   - Paul Thomas
-
-   - Andy Vaught
-
-   - Feng Wang
-
-   - Janus Weil
-
-   The following people have contributed bug reports, smaller or larger
-patches, and much needed feedback and encouragement for the GNU Fortran
-project:
-
-   - Bill Clodius
-
-   - Dominique d'Humie`res
-
-   - Kate Hedstrom
-
-   - Erik Schnetter
-
-   Many other individuals have helped debug, test and improve the GNU
-Fortran compiler over the past few years, and we welcome you to do the
-same!  If you already have done so, and you would like to see your name
-listed in the list above, please contact us.
-
-
-File: gfortran.info,  Node: Projects,  Next: Proposed Extensions,  Prev: Contributors,  Up: Contributing
-
-Projects
-========
-
-_Help build the test suite_
-     Solicit more code for donation to the test suite: the more
-     extensive the testsuite, the smaller the risk of breaking things
-     in the future! We can keep code private on request.
-
-_Bug hunting/squishing_
-     Find bugs and write more test cases! Test cases are especially very
-     welcome, because it allows us to concentrate on fixing bugs
-     instead of isolating them. Going through the bugzilla database at
-     `http://gcc.gnu.org/bugzilla/' to reduce testcases posted there and
-     add more information (for example, for which version does the
-     testcase work, for which versions does it fail?) is also very
-     helpful.
-
-
-
-File: gfortran.info,  Node: Proposed Extensions,  Prev: Projects,  Up: Contributing
-
-Proposed Extensions
-===================
-
-Here's a list of proposed extensions for the GNU Fortran compiler, in
-no particular order.  Most of these are necessary to be fully
-compatible with existing Fortran compilers, but they are not part of
-the official J3 Fortran 95 standard.
-
-Compiler extensions:
---------------------
-
-   * User-specified alignment rules for structures.
-
-   * Flag to generate `Makefile' info.
-
-   * Automatically extend single precision constants to double.
-
-   * Compile code that conserves memory by dynamically allocating
-     common and module storage either on stack or heap.
-
-   * Compile flag to generate code for array conformance checking
-     (suggest -CC).
-
-   * User control of symbol names (underscores, etc).
-
-   * Compile setting for maximum size of stack frame size before
-     spilling parts to static or heap.
-
-   * Flag to force local variables into static space.
-
-   * Flag to force local variables onto stack.
-
-Environment Options
--------------------
-
-   * Pluggable library modules for random numbers, linear algebra.  LA
-     should use BLAS calling conventions.
-
-   * Environment variables controlling actions on arithmetic exceptions
-     like overflow, underflow, precision loss--Generate NaN, abort,
-     default.  action.
-
-   * Set precision for fp units that support it (i387).
-
-   * Variable for setting fp rounding mode.
-
-   * Variable to fill uninitialized variables with a user-defined bit
-     pattern.
-
-   * Environment variable controlling filename that is opened for that
-     unit number.
-
-   * Environment variable to clear/trash memory being freed.
-
-   * Environment variable to control tracing of allocations and frees.
-
-   * Environment variable to display allocated memory at normal program
-     end.
-
-   * Environment variable for filename for * IO-unit.
-
-   * Environment variable for temporary file directory.
-
-   * Environment variable forcing standard output to be line buffered
-     (unix).
-
-
-
-File: gfortran.info,  Node: Copying,  Next: GNU Free Documentation License,  Prev: Contributing,  Up: Top
-
-GNU General Public License
-**************************
-
-                        Version 3, 29 June 2007
-
-     Copyright (C) 2007 Free Software Foundation, Inc. `http://fsf.org/'
-
-     Everyone is permitted to copy and distribute verbatim copies of this
-     license document, but changing it is not allowed.
-
-Preamble
-========
-
-The GNU General Public License is a free, copyleft license for software
-and other kinds of works.
-
-   The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program-to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-   When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-   To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you
-have certain responsibilities if you distribute copies of the software,
-or if you modify it: responsibilities to respect the freedom of others.
-
-   For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-   Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-   For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-   Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the
-manufacturer can do so.  This is fundamentally incompatible with the
-aim of protecting users' freedom to change the software.  The
-systematic pattern of such abuse occurs in the area of products for
-individuals to use, which is precisely where it is most unacceptable.
-Therefore, we have designed this version of the GPL to prohibit the
-practice for those products.  If such problems arise substantially in
-other domains, we stand ready to extend this provision to those domains
-in future versions of the GPL, as needed to protect the freedom of
-users.
-
-   Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-   The precise terms and conditions for copying, distribution and
-modification follow.
-
-TERMS AND CONDITIONS
-====================
-
-  0. Definitions.
-
-     "This License" refers to version 3 of the GNU General Public
-     License.
-
-     "Copyright" also means copyright-like laws that apply to other
-     kinds of works, such as semiconductor masks.
-
-     "The Program" refers to any copyrightable work licensed under this
-     License.  Each licensee is addressed as "you".  "Licensees" and
-     "recipients" may be individuals or organizations.
-
-     To "modify" a work means to copy from or adapt all or part of the
-     work in a fashion requiring copyright permission, other than the
-     making of an exact copy.  The resulting work is called a "modified
-     version" of the earlier work or a work "based on" the earlier work.
-
-     A "covered work" means either the unmodified Program or a work
-     based on the Program.
-
-     To "propagate" a work means to do anything with it that, without
-     permission, would make you directly or secondarily liable for
-     infringement under applicable copyright law, except executing it
-     on a computer or modifying a private copy.  Propagation includes
-     copying, distribution (with or without modification), making
-     available to the public, and in some countries other activities as
-     well.
-
-     To "convey" a work means any kind of propagation that enables other
-     parties to make or receive copies.  Mere interaction with a user
-     through a computer network, with no transfer of a copy, is not
-     conveying.
-
-     An interactive user interface displays "Appropriate Legal Notices"
-     to the extent that it includes a convenient and prominently visible
-     feature that (1) displays an appropriate copyright notice, and (2)
-     tells the user that there is no warranty for the work (except to
-     the extent that warranties are provided), that licensees may
-     convey the work under this License, and how to view a copy of this
-     License.  If the interface presents a list of user commands or
-     options, such as a menu, a prominent item in the list meets this
-     criterion.
-
-  1. Source Code.
-
-     The "source code" for a work means the preferred form of the work
-     for making modifications to it.  "Object code" means any
-     non-source form of a work.
-
-     A "Standard Interface" means an interface that either is an
-     official standard defined by a recognized standards body, or, in
-     the case of interfaces specified for a particular programming
-     language, one that is widely used among developers working in that
-     language.
-
-     The "System Libraries" of an executable work include anything,
-     other than the work as a whole, that (a) is included in the normal
-     form of packaging a Major Component, but which is not part of that
-     Major Component, and (b) serves only to enable use of the work
-     with that Major Component, or to implement a Standard Interface
-     for which an implementation is available to the public in source
-     code form.  A "Major Component", in this context, means a major
-     essential component (kernel, window system, and so on) of the
-     specific operating system (if any) on which the executable work
-     runs, or a compiler used to produce the work, or an object code
-     interpreter used to run it.
-
-     The "Corresponding Source" for a work in object code form means all
-     the source code needed to generate, install, and (for an executable
-     work) run the object code and to modify the work, including
-     scripts to control those activities.  However, it does not include
-     the work's System Libraries, or general-purpose tools or generally
-     available free programs which are used unmodified in performing
-     those activities but which are not part of the work.  For example,
-     Corresponding Source includes interface definition files
-     associated with source files for the work, and the source code for
-     shared libraries and dynamically linked subprograms that the work
-     is specifically designed to require, such as by intimate data
-     communication or control flow between those subprograms and other
-     parts of the work.
-
-     The Corresponding Source need not include anything that users can
-     regenerate automatically from other parts of the Corresponding
-     Source.
-
-     The Corresponding Source for a work in source code form is that
-     same work.
-
-  2. Basic Permissions.
-
-     All rights granted under this License are granted for the term of
-     copyright on the Program, and are irrevocable provided the stated
-     conditions are met.  This License explicitly affirms your unlimited
-     permission to run the unmodified Program.  The output from running
-     a covered work is covered by this License only if the output,
-     given its content, constitutes a covered work.  This License
-     acknowledges your rights of fair use or other equivalent, as
-     provided by copyright law.
-
-     You may make, run and propagate covered works that you do not
-     convey, without conditions so long as your license otherwise
-     remains in force.  You may convey covered works to others for the
-     sole purpose of having them make modifications exclusively for
-     you, or provide you with facilities for running those works,
-     provided that you comply with the terms of this License in
-     conveying all material for which you do not control copyright.
-     Those thus making or running the covered works for you must do so
-     exclusively on your behalf, under your direction and control, on
-     terms that prohibit them from making any copies of your
-     copyrighted material outside their relationship with you.
-
-     Conveying under any other circumstances is permitted solely under
-     the conditions stated below.  Sublicensing is not allowed; section
-     10 makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-     No covered work shall be deemed part of an effective technological
-     measure under any applicable law fulfilling obligations under
-     article 11 of the WIPO copyright treaty adopted on 20 December
-     1996, or similar laws prohibiting or restricting circumvention of
-     such measures.
-
-     When you convey a covered work, you waive any legal power to forbid
-     circumvention of technological measures to the extent such
-     circumvention is effected by exercising rights under this License
-     with respect to the covered work, and you disclaim any intention
-     to limit operation or modification of the work as a means of
-     enforcing, against the work's users, your or third parties' legal
-     rights to forbid circumvention of technological measures.
-
-  4. Conveying Verbatim Copies.
-
-     You may convey verbatim copies of the Program's source code as you
-     receive it, in any medium, provided that you conspicuously and
-     appropriately publish on each copy an appropriate copyright notice;
-     keep intact all notices stating that this License and any
-     non-permissive terms added in accord with section 7 apply to the
-     code; keep intact all notices of the absence of any warranty; and
-     give all recipients a copy of this License along with the Program.
-
-     You may charge any price or no price for each copy that you convey,
-     and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-     You may convey a work based on the Program, or the modifications to
-     produce it from the Program, in the form of source code under the
-     terms of section 4, provided that you also meet all of these
-     conditions:
-
-       a. The work must carry prominent notices stating that you
-          modified it, and giving a relevant date.
-
-       b. The work must carry prominent notices stating that it is
-          released under this License and any conditions added under
-          section 7.  This requirement modifies the requirement in
-          section 4 to "keep intact all notices".
-
-       c. You must license the entire work, as a whole, under this
-          License to anyone who comes into possession of a copy.  This
-          License will therefore apply, along with any applicable
-          section 7 additional terms, to the whole of the work, and all
-          its parts, regardless of how they are packaged.  This License
-          gives no permission to license the work in any other way, but
-          it does not invalidate such permission if you have separately
-          received it.
-
-       d. If the work has interactive user interfaces, each must display
-          Appropriate Legal Notices; however, if the Program has
-          interactive interfaces that do not display Appropriate Legal
-          Notices, your work need not make them do so.
-
-     A compilation of a covered work with other separate and independent
-     works, which are not by their nature extensions of the covered
-     work, and which are not combined with it such as to form a larger
-     program, in or on a volume of a storage or distribution medium, is
-     called an "aggregate" if the compilation and its resulting
-     copyright are not used to limit the access or legal rights of the
-     compilation's users beyond what the individual works permit.
-     Inclusion of a covered work in an aggregate does not cause this
-     License to apply to the other parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-     You may convey a covered work in object code form under the terms
-     of sections 4 and 5, provided that you also convey the
-     machine-readable Corresponding Source under the terms of this
-     License, in one of these ways:
-
-       a. Convey the object code in, or embodied in, a physical product
-          (including a physical distribution medium), accompanied by the
-          Corresponding Source fixed on a durable physical medium
-          customarily used for software interchange.
-
-       b. Convey the object code in, or embodied in, a physical product
-          (including a physical distribution medium), accompanied by a
-          written offer, valid for at least three years and valid for
-          as long as you offer spare parts or customer support for that
-          product model, to give anyone who possesses the object code
-          either (1) a copy of the Corresponding Source for all the
-          software in the product that is covered by this License, on a
-          durable physical medium customarily used for software
-          interchange, for a price no more than your reasonable cost of
-          physically performing this conveying of source, or (2) access
-          to copy the Corresponding Source from a network server at no
-          charge.
-
-       c. Convey individual copies of the object code with a copy of
-          the written offer to provide the Corresponding Source.  This
-          alternative is allowed only occasionally and noncommercially,
-          and only if you received the object code with such an offer,
-          in accord with subsection 6b.
-
-       d. Convey the object code by offering access from a designated
-          place (gratis or for a charge), and offer equivalent access
-          to the Corresponding Source in the same way through the same
-          place at no further charge.  You need not require recipients
-          to copy the Corresponding Source along with the object code.
-          If the place to copy the object code is a network server, the
-          Corresponding Source may be on a different server (operated
-          by you or a third party) that supports equivalent copying
-          facilities, provided you maintain clear directions next to
-          the object code saying where to find the Corresponding Source.
-          Regardless of what server hosts the Corresponding Source, you
-          remain obligated to ensure that it is available for as long
-          as needed to satisfy these requirements.
-
-       e. Convey the object code using peer-to-peer transmission,
-          provided you inform other peers where the object code and
-          Corresponding Source of the work are being offered to the
-          general public at no charge under subsection 6d.
-
-
-     A separable portion of the object code, whose source code is
-     excluded from the Corresponding Source as a System Library, need
-     not be included in conveying the object code work.
-
-     A "User Product" is either (1) a "consumer product", which means
-     any tangible personal property which is normally used for personal,
-     family, or household purposes, or (2) anything designed or sold for
-     incorporation into a dwelling.  In determining whether a product
-     is a consumer product, doubtful cases shall be resolved in favor of
-     coverage.  For a particular product received by a particular user,
-     "normally used" refers to a typical or common use of that class of
-     product, regardless of the status of the particular user or of the
-     way in which the particular user actually uses, or expects or is
-     expected to use, the product.  A product is a consumer product
-     regardless of whether the product has substantial commercial,
-     industrial or non-consumer uses, unless such uses represent the
-     only significant mode of use of the product.
-
-     "Installation Information" for a User Product means any methods,
-     procedures, authorization keys, or other information required to
-     install and execute modified versions of a covered work in that
-     User Product from a modified version of its Corresponding Source.
-     The information must suffice to ensure that the continued
-     functioning of the modified object code is in no case prevented or
-     interfered with solely because modification has been made.
-
-     If you convey an object code work under this section in, or with,
-     or specifically for use in, a User Product, and the conveying
-     occurs as part of a transaction in which the right of possession
-     and use of the User Product is transferred to the recipient in
-     perpetuity or for a fixed term (regardless of how the transaction
-     is characterized), the Corresponding Source conveyed under this
-     section must be accompanied by the Installation Information.  But
-     this requirement does not apply if neither you nor any third party
-     retains the ability to install modified object code on the User
-     Product (for example, the work has been installed in ROM).
-
-     The requirement to provide Installation Information does not
-     include a requirement to continue to provide support service,
-     warranty, or updates for a work that has been modified or
-     installed by the recipient, or for the User Product in which it
-     has been modified or installed.  Access to a network may be denied
-     when the modification itself materially and adversely affects the
-     operation of the network or violates the rules and protocols for
-     communication across the network.
-
-     Corresponding Source conveyed, and Installation Information
-     provided, in accord with this section must be in a format that is
-     publicly documented (and with an implementation available to the
-     public in source code form), and must require no special password
-     or key for unpacking, reading or copying.
-
-  7. Additional Terms.
-
-     "Additional permissions" are terms that supplement the terms of
-     this License by making exceptions from one or more of its
-     conditions.  Additional permissions that are applicable to the
-     entire Program shall be treated as though they were included in
-     this License, to the extent that they are valid under applicable
-     law.  If additional permissions apply only to part of the Program,
-     that part may be used separately under those permissions, but the
-     entire Program remains governed by this License without regard to
-     the additional permissions.
-
-     When you convey a copy of a covered work, you may at your option
-     remove any additional permissions from that copy, or from any part
-     of it.  (Additional permissions may be written to require their own
-     removal in certain cases when you modify the work.)  You may place
-     additional permissions on material, added by you to a covered work,
-     for which you have or can give appropriate copyright permission.
-
-     Notwithstanding any other provision of this License, for material
-     you add to a covered work, you may (if authorized by the copyright
-     holders of that material) supplement the terms of this License
-     with terms:
-
-       a. Disclaiming warranty or limiting liability differently from
-          the terms of sections 15 and 16 of this License; or
-
-       b. Requiring preservation of specified reasonable legal notices
-          or author attributions in that material or in the Appropriate
-          Legal Notices displayed by works containing it; or
-
-       c. Prohibiting misrepresentation of the origin of that material,
-          or requiring that modified versions of such material be
-          marked in reasonable ways as different from the original
-          version; or
-
-       d. Limiting the use for publicity purposes of names of licensors
-          or authors of the material; or
-
-       e. Declining to grant rights under trademark law for use of some
-          trade names, trademarks, or service marks; or
-
-       f. Requiring indemnification of licensors and authors of that
-          material by anyone who conveys the material (or modified
-          versions of it) with contractual assumptions of liability to
-          the recipient, for any liability that these contractual
-          assumptions directly impose on those licensors and authors.
-
-     All other non-permissive additional terms are considered "further
-     restrictions" within the meaning of section 10.  If the Program as
-     you received it, or any part of it, contains a notice stating that
-     it is governed by this License along with a term that is a further
-     restriction, you may remove that term.  If a license document
-     contains a further restriction but permits relicensing or
-     conveying under this License, you may add to a covered work
-     material governed by the terms of that license document, provided
-     that the further restriction does not survive such relicensing or
-     conveying.
-
-     If you add terms to a covered work in accord with this section, you
-     must place, in the relevant source files, a statement of the
-     additional terms that apply to those files, or a notice indicating
-     where to find the applicable terms.
-
-     Additional terms, permissive or non-permissive, may be stated in
-     the form of a separately written license, or stated as exceptions;
-     the above requirements apply either way.
-
-  8. Termination.
-
-     You may not propagate or modify a covered work except as expressly
-     provided under this License.  Any attempt otherwise to propagate or
-     modify it is void, and will automatically terminate your rights
-     under this License (including any patent licenses granted under
-     the third paragraph of section 11).
-
-     However, if you cease all violation of this License, then your
-     license from a particular copyright holder is reinstated (a)
-     provisionally, unless and until the copyright holder explicitly
-     and finally terminates your license, and (b) permanently, if the
-     copyright holder fails to notify you of the violation by some
-     reasonable means prior to 60 days after the cessation.
-
-     Moreover, your license from a particular copyright holder is
-     reinstated permanently if the copyright holder notifies you of the
-     violation by some reasonable means, this is the first time you have
-     received notice of violation of this License (for any work) from
-     that copyright holder, and you cure the violation prior to 30 days
-     after your receipt of the notice.
-
-     Termination of your rights under this section does not terminate
-     the licenses of parties who have received copies or rights from
-     you under this License.  If your rights have been terminated and
-     not permanently reinstated, you do not qualify to receive new
-     licenses for the same material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-     You are not required to accept this License in order to receive or
-     run a copy of the Program.  Ancillary propagation of a covered work
-     occurring solely as a consequence of using peer-to-peer
-     transmission to receive a copy likewise does not require
-     acceptance.  However, nothing other than this License grants you
-     permission to propagate or modify any covered work.  These actions
-     infringe copyright if you do not accept this License.  Therefore,
-     by modifying or propagating a covered work, you indicate your
-     acceptance of this License to do so.
-
- 10. Automatic Licensing of Downstream Recipients.
-
-     Each time you convey a covered work, the recipient automatically
-     receives a license from the original licensors, to run, modify and
-     propagate that work, subject to this License.  You are not
-     responsible for enforcing compliance by third parties with this
-     License.
-
-     An "entity transaction" is a transaction transferring control of an
-     organization, or substantially all assets of one, or subdividing an
-     organization, or merging organizations.  If propagation of a
-     covered work results from an entity transaction, each party to that
-     transaction who receives a copy of the work also receives whatever
-     licenses to the work the party's predecessor in interest had or
-     could give under the previous paragraph, plus a right to
-     possession of the Corresponding Source of the work from the
-     predecessor in interest, if the predecessor has it or can get it
-     with reasonable efforts.
-
-     You may not impose any further restrictions on the exercise of the
-     rights granted or affirmed under this License.  For example, you
-     may not impose a license fee, royalty, or other charge for
-     exercise of rights granted under this License, and you may not
-     initiate litigation (including a cross-claim or counterclaim in a
-     lawsuit) alleging that any patent claim is infringed by making,
-     using, selling, offering for sale, or importing the Program or any
-     portion of it.
-
- 11. Patents.
-
-     A "contributor" is a copyright holder who authorizes use under this
-     License of the Program or a work on which the Program is based.
-     The work thus licensed is called the contributor's "contributor
-     version".
-
-     A contributor's "essential patent claims" are all patent claims
-     owned or controlled by the contributor, whether already acquired or
-     hereafter acquired, that would be infringed by some manner,
-     permitted by this License, of making, using, or selling its
-     contributor version, but do not include claims that would be
-     infringed only as a consequence of further modification of the
-     contributor version.  For purposes of this definition, "control"
-     includes the right to grant patent sublicenses in a manner
-     consistent with the requirements of this License.
-
-     Each contributor grants you a non-exclusive, worldwide,
-     royalty-free patent license under the contributor's essential
-     patent claims, to make, use, sell, offer for sale, import and
-     otherwise run, modify and propagate the contents of its
-     contributor version.
-
-     In the following three paragraphs, a "patent license" is any
-     express agreement or commitment, however denominated, not to
-     enforce a patent (such as an express permission to practice a
-     patent or covenant not to sue for patent infringement).  To
-     "grant" such a patent license to a party means to make such an
-     agreement or commitment not to enforce a patent against the party.
-
-     If you convey a covered work, knowingly relying on a patent
-     license, and the Corresponding Source of the work is not available
-     for anyone to copy, free of charge and under the terms of this
-     License, through a publicly available network server or other
-     readily accessible means, then you must either (1) cause the
-     Corresponding Source to be so available, or (2) arrange to deprive
-     yourself of the benefit of the patent license for this particular
-     work, or (3) arrange, in a manner consistent with the requirements
-     of this License, to extend the patent license to downstream
-     recipients.  "Knowingly relying" means you have actual knowledge
-     that, but for the patent license, your conveying the covered work
-     in a country, or your recipient's use of the covered work in a
-     country, would infringe one or more identifiable patents in that
-     country that you have reason to believe are valid.
-
-     If, pursuant to or in connection with a single transaction or
-     arrangement, you convey, or propagate by procuring conveyance of, a
-     covered work, and grant a patent license to some of the parties
-     receiving the covered work authorizing them to use, propagate,
-     modify or convey a specific copy of the covered work, then the
-     patent license you grant is automatically extended to all
-     recipients of the covered work and works based on it.
-
-     A patent license is "discriminatory" if it does not include within
-     the scope of its coverage, prohibits the exercise of, or is
-     conditioned on the non-exercise of one or more of the rights that
-     are specifically granted under this License.  You may not convey a
-     covered work if you are a party to an arrangement with a third
-     party that is in the business of distributing software, under
-     which you make payment to the third party based on the extent of
-     your activity of conveying the work, and under which the third
-     party grants, to any of the parties who would receive the covered
-     work from you, a discriminatory patent license (a) in connection
-     with copies of the covered work conveyed by you (or copies made
-     from those copies), or (b) primarily for and in connection with
-     specific products or compilations that contain the covered work,
-     unless you entered into that arrangement, or that patent license
-     was granted, prior to 28 March 2007.
-
-     Nothing in this License shall be construed as excluding or limiting
-     any implied license or other defenses to infringement that may
-     otherwise be available to you under applicable patent law.
-
- 12. No Surrender of Others' Freedom.
-
-     If conditions are imposed on you (whether by court order,
-     agreement or otherwise) that contradict the conditions of this
-     License, they do not excuse you from the conditions of this
-     License.  If you cannot convey a covered work so as to satisfy
-     simultaneously your obligations under this License and any other
-     pertinent obligations, then as a consequence you may not convey it
-     at all.  For example, if you agree to terms that obligate you to
-     collect a royalty for further conveying from those to whom you
-     convey the Program, the only way you could satisfy both those
-     terms and this License would be to refrain entirely from conveying
-     the Program.
-
- 13. Use with the GNU Affero General Public License.
-
-     Notwithstanding any other provision of this License, you have
-     permission to link or combine any covered work with a work licensed
-     under version 3 of the GNU Affero General Public License into a
-     single combined work, and to convey the resulting work.  The terms
-     of this License will continue to apply to the part which is the
-     covered work, but the special requirements of the GNU Affero
-     General Public License, section 13, concerning interaction through
-     a network will apply to the combination as such.
-
- 14. Revised Versions of this License.
-
-     The Free Software Foundation may publish revised and/or new
-     versions of the GNU General Public License from time to time.
-     Such new versions will be similar in spirit to the present
-     version, but may differ in detail to address new problems or
-     concerns.
-
-     Each version is given a distinguishing version number.  If the
-     Program specifies that a certain numbered version of the GNU
-     General Public License "or any later version" applies to it, you
-     have the option of following the terms and conditions either of
-     that numbered version or of any later version published by the
-     Free Software Foundation.  If the Program does not specify a
-     version number of the GNU General Public License, you may choose
-     any version ever published by the Free Software Foundation.
-
-     If the Program specifies that a proxy can decide which future
-     versions of the GNU General Public License can be used, that
-     proxy's public statement of acceptance of a version permanently
-     authorizes you to choose that version for the Program.
-
-     Later license versions may give you additional or different
-     permissions.  However, no additional obligations are imposed on any
-     author or copyright holder as a result of your choosing to follow a
-     later version.
-
- 15. Disclaimer of Warranty.
-
-     THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-     APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE
-     COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS"
-     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
-     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE
-     RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
-     SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
-     NECESSARY SERVICING, REPAIR OR CORRECTION.
-
- 16. Limitation of Liability.
-
-     IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES
-     AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU
-     FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-     CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
-     THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
-     BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-     PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-     PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF
-     THE POSSIBILITY OF SUCH DAMAGES.
-
- 17. Interpretation of Sections 15 and 16.
-
-     If the disclaimer of warranty and limitation of liability provided
-     above cannot be given local legal effect according to their terms,
-     reviewing courts shall apply local law that most closely
-     approximates an absolute waiver of all civil liability in
-     connection with the Program, unless a warranty or assumption of
-     liability accompanies a copy of the Program in return for a fee.
-
-
-END OF TERMS AND CONDITIONS
-===========================
-
-How to Apply These Terms to Your New Programs
-=============================================
-
-If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these
-terms.
-
-   To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
-     Copyright (C) YEAR NAME OF AUTHOR
-
-     This program is free software: you can redistribute it and/or modify
-     it under the terms of the GNU General Public License as published by
-     the Free Software Foundation, either version 3 of the License, or (at
-     your option) any later version.
-
-     This program is distributed in the hope that it will be useful, but
-     WITHOUT ANY WARRANTY; without even the implied warranty of
-     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-     General Public License for more details.
-
-     You should have received a copy of the GNU General Public License
-     along with this program.  If not, see `http://www.gnu.org/licenses/'.
-
-   Also add information on how to contact you by electronic and paper
-mail.
-
-   If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-     PROGRAM Copyright (C) YEAR NAME OF AUTHOR
-     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-     This is free software, and you are welcome to redistribute it
-     under certain conditions; type `show c' for details.
-
-   The hypothetical commands `show w' and `show c' should show the
-appropriate parts of the General Public License.  Of course, your
-program's commands might be different; for a GUI interface, you would
-use an "about box".
-
-   You should also get your employer (if you work as a programmer) or
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  For more information on this, and how to apply and follow
-the GNU GPL, see `http://www.gnu.org/licenses/'.
-
-   The GNU General Public License does not permit incorporating your
-program into proprietary programs.  If your program is a subroutine
-library, you may consider it more useful to permit linking proprietary
-applications with the library.  If this is what you want to do, use the
-GNU Lesser General Public License instead of this License.  But first,
-please read `http://www.gnu.org/philosophy/why-not-lgpl.html'.
-
-
-File: gfortran.info,  Node: GNU Free Documentation License,  Next: Funding,  Prev: Copying,  Up: Top
-
-GNU Free Documentation License
-******************************
-
-                      Version 1.2, November 2002
-
-     Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
-     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
-
-     Everyone is permitted to copy and distribute verbatim copies
-     of this license document, but changing it is not allowed.
-
-  0. PREAMBLE
-
-     The purpose of this License is to make a manual, textbook, or other
-     functional and useful document "free" in the sense of freedom: to
-     assure everyone the effective freedom to copy and redistribute it,
-     with or without modifying it, either commercially or
-     noncommercially.  Secondarily, this License preserves for the
-     author and publisher a way to get credit for their work, while not
-     being considered responsible for modifications made by others.
-
-     This License is a kind of "copyleft", which means that derivative
-     works of the document must themselves be free in the same sense.
-     It complements the GNU General Public License, which is a copyleft
-     license designed for free software.
-
-     We have designed this License in order to use it for manuals for
-     free software, because free software needs free documentation: a
-     free program should come with manuals providing the same freedoms
-     that the software does.  But this License is not limited to
-     software manuals; it can be used for any textual work, regardless
-     of subject matter or whether it is published as a printed book.
-     We recommend this License principally for works whose purpose is
-     instruction or reference.
-
-  1. APPLICABILITY AND DEFINITIONS
-
-     This License applies to any manual or other work, in any medium,
-     that contains a notice placed by the copyright holder saying it
-     can be distributed under the terms of this License.  Such a notice
-     grants a world-wide, royalty-free license, unlimited in duration,
-     to use that work under the conditions stated herein.  The
-     "Document", below, refers to any such manual or work.  Any member
-     of the public is a licensee, and is addressed as "you".  You
-     accept the license if you copy, modify or distribute the work in a
-     way requiring permission under copyright law.
-
-     A "Modified Version" of the Document means any work containing the
-     Document or a portion of it, either copied verbatim, or with
-     modifications and/or translated into another language.
-
-     A "Secondary Section" is a named appendix or a front-matter section
-     of the Document that deals exclusively with the relationship of the
-     publishers or authors of the Document to the Document's overall
-     subject (or to related matters) and contains nothing that could
-     fall directly within that overall subject.  (Thus, if the Document
-     is in part a textbook of mathematics, a Secondary Section may not
-     explain any mathematics.)  The relationship could be a matter of
-     historical connection with the subject or with related matters, or
-     of legal, commercial, philosophical, ethical or political position
-     regarding them.
-
-     The "Invariant Sections" are certain Secondary Sections whose
-     titles are designated, as being those of Invariant Sections, in
-     the notice that says that the Document is released under this
-     License.  If a section does not fit the above definition of
-     Secondary then it is not allowed to be designated as Invariant.
-     The Document may contain zero Invariant Sections.  If the Document
-     does not identify any Invariant Sections then there are none.
-
-     The "Cover Texts" are certain short passages of text that are
-     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
-     that says that the Document is released under this License.  A
-     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
-     be at most 25 words.
-
-     A "Transparent" copy of the Document means a machine-readable copy,
-     represented in a format whose specification is available to the
-     general public, that is suitable for revising the document
-     straightforwardly with generic text editors or (for images
-     composed of pixels) generic paint programs or (for drawings) some
-     widely available drawing editor, and that is suitable for input to
-     text formatters or for automatic translation to a variety of
-     formats suitable for input to text formatters.  A copy made in an
-     otherwise Transparent file format whose markup, or absence of
-     markup, has been arranged to thwart or discourage subsequent
-     modification by readers is not Transparent.  An image format is
-     not Transparent if used for any substantial amount of text.  A
-     copy that is not "Transparent" is called "Opaque".
-
-     Examples of suitable formats for Transparent copies include plain
-     ASCII without markup, Texinfo input format, LaTeX input format,
-     SGML or XML using a publicly available DTD, and
-     standard-conforming simple HTML, PostScript or PDF designed for
-     human modification.  Examples of transparent image formats include
-     PNG, XCF and JPG.  Opaque formats include proprietary formats that
-     can be read and edited only by proprietary word processors, SGML or
-     XML for which the DTD and/or processing tools are not generally
-     available, and the machine-generated HTML, PostScript or PDF
-     produced by some word processors for output purposes only.
-
-     The "Title Page" means, for a printed book, the title page itself,
-     plus such following pages as are needed to hold, legibly, the
-     material this License requires to appear in the title page.  For
-     works in formats which do not have any title page as such, "Title
-     Page" means the text near the most prominent appearance of the
-     work's title, preceding the beginning of the body of the text.
-
-     A section "Entitled XYZ" means a named subunit of the Document
-     whose title either is precisely XYZ or contains XYZ in parentheses
-     following text that translates XYZ in another language.  (Here XYZ
-     stands for a specific section name mentioned below, such as
-     "Acknowledgements", "Dedications", "Endorsements", or "History".)
-     To "Preserve the Title" of such a section when you modify the
-     Document means that it remains a section "Entitled XYZ" according
-     to this definition.
-
-     The Document may include Warranty Disclaimers next to the notice
-     which states that this License applies to the Document.  These
-     Warranty Disclaimers are considered to be included by reference in
-     this License, but only as regards disclaiming warranties: any other
-     implication that these Warranty Disclaimers may have is void and
-     has no effect on the meaning of this License.
-
-  2. VERBATIM COPYING
-
-     You may copy and distribute the Document in any medium, either
-     commercially or noncommercially, provided that this License, the
-     copyright notices, and the license notice saying this License
-     applies to the Document are reproduced in all copies, and that you
-     add no other conditions whatsoever to those of this License.  You
-     may not use technical measures to obstruct or control the reading
-     or further copying of the copies you make or distribute.  However,
-     you may accept compensation in exchange for copies.  If you
-     distribute a large enough number of copies you must also follow
-     the conditions in section 3.
-
-     You may also lend copies, under the same conditions stated above,
-     and you may publicly display copies.
-
-  3. COPYING IN QUANTITY
-
-     If you publish printed copies (or copies in media that commonly
-     have printed covers) of the Document, numbering more than 100, and
-     the Document's license notice requires Cover Texts, you must
-     enclose the copies in covers that carry, clearly and legibly, all
-     these Cover Texts: Front-Cover Texts on the front cover, and
-     Back-Cover Texts on the back cover.  Both covers must also clearly
-     and legibly identify you as the publisher of these copies.  The
-     front cover must present the full title with all words of the
-     title equally prominent and visible.  You may add other material
-     on the covers in addition.  Copying with changes limited to the
-     covers, as long as they preserve the title of the Document and
-     satisfy these conditions, can be treated as verbatim copying in
-     other respects.
-
-     If the required texts for either cover are too voluminous to fit
-     legibly, you should put the first ones listed (as many as fit
-     reasonably) on the actual cover, and continue the rest onto
-     adjacent pages.
-
-     If you publish or distribute Opaque copies of the Document
-     numbering more than 100, you must either include a
-     machine-readable Transparent copy along with each Opaque copy, or
-     state in or with each Opaque copy a computer-network location from
-     which the general network-using public has access to download
-     using public-standard network protocols a complete Transparent
-     copy of the Document, free of added material.  If you use the
-     latter option, you must take reasonably prudent steps, when you
-     begin distribution of Opaque copies in quantity, to ensure that
-     this Transparent copy will remain thus accessible at the stated
-     location until at least one year after the last time you
-     distribute an Opaque copy (directly or through your agents or
-     retailers) of that edition to the public.
-
-     It is requested, but not required, that you contact the authors of
-     the Document well before redistributing any large number of
-     copies, to give them a chance to provide you with an updated
-     version of the Document.
-
-  4. MODIFICATIONS
-
-     You may copy and distribute a Modified Version of the Document
-     under the conditions of sections 2 and 3 above, provided that you
-     release the Modified Version under precisely this License, with
-     the Modified Version filling the role of the Document, thus
-     licensing distribution and modification of the Modified Version to
-     whoever possesses a copy of it.  In addition, you must do these
-     things in the Modified Version:
-
-       A. Use in the Title Page (and on the covers, if any) a title
-          distinct from that of the Document, and from those of
-          previous versions (which should, if there were any, be listed
-          in the History section of the Document).  You may use the
-          same title as a previous version if the original publisher of
-          that version gives permission.
-
-       B. List on the Title Page, as authors, one or more persons or
-          entities responsible for authorship of the modifications in
-          the Modified Version, together with at least five of the
-          principal authors of the Document (all of its principal
-          authors, if it has fewer than five), unless they release you
-          from this requirement.
-
-       C. State on the Title page the name of the publisher of the
-          Modified Version, as the publisher.
-
-       D. Preserve all the copyright notices of the Document.
-
-       E. Add an appropriate copyright notice for your modifications
-          adjacent to the other copyright notices.
-
-       F. Include, immediately after the copyright notices, a license
-          notice giving the public permission to use the Modified
-          Version under the terms of this License, in the form shown in
-          the Addendum below.
-
-       G. Preserve in that license notice the full lists of Invariant
-          Sections and required Cover Texts given in the Document's
-          license notice.
-
-       H. Include an unaltered copy of this License.
-
-       I. Preserve the section Entitled "History", Preserve its Title,
-          and add to it an item stating at least the title, year, new
-          authors, and publisher of the Modified Version as given on
-          the Title Page.  If there is no section Entitled "History" in
-          the Document, create one stating the title, year, authors,
-          and publisher of the Document as given on its Title Page,
-          then add an item describing the Modified Version as stated in
-          the previous sentence.
-
-       J. Preserve the network location, if any, given in the Document
-          for public access to a Transparent copy of the Document, and
-          likewise the network locations given in the Document for
-          previous versions it was based on.  These may be placed in
-          the "History" section.  You may omit a network location for a
-          work that was published at least four years before the
-          Document itself, or if the original publisher of the version
-          it refers to gives permission.
-
-       K. For any section Entitled "Acknowledgements" or "Dedications",
-          Preserve the Title of the section, and preserve in the
-          section all the substance and tone of each of the contributor
-          acknowledgements and/or dedications given therein.
-
-       L. Preserve all the Invariant Sections of the Document,
-          unaltered in their text and in their titles.  Section numbers
-          or the equivalent are not considered part of the section
-          titles.
-
-       M. Delete any section Entitled "Endorsements".  Such a section
-          may not be included in the Modified Version.
-
-       N. Do not retitle any existing section to be Entitled
-          "Endorsements" or to conflict in title with any Invariant
-          Section.
-
-       O. Preserve any Warranty Disclaimers.
-
-     If the Modified Version includes new front-matter sections or
-     appendices that qualify as Secondary Sections and contain no
-     material copied from the Document, you may at your option
-     designate some or all of these sections as invariant.  To do this,
-     add their titles to the list of Invariant Sections in the Modified
-     Version's license notice.  These titles must be distinct from any
-     other section titles.
-
-     You may add a section Entitled "Endorsements", provided it contains
-     nothing but endorsements of your Modified Version by various
-     parties--for example, statements of peer review or that the text
-     has been approved by an organization as the authoritative
-     definition of a standard.
-
-     You may add a passage of up to five words as a Front-Cover Text,
-     and a passage of up to 25 words as a Back-Cover Text, to the end
-     of the list of Cover Texts in the Modified Version.  Only one
-     passage of Front-Cover Text and one of Back-Cover Text may be
-     added by (or through arrangements made by) any one entity.  If the
-     Document already includes a cover text for the same cover,
-     previously added by you or by arrangement made by the same entity
-     you are acting on behalf of, you may not add another; but you may
-     replace the old one, on explicit permission from the previous
-     publisher that added the old one.
-
-     The author(s) and publisher(s) of the Document do not by this
-     License give permission to use their names for publicity for or to
-     assert or imply endorsement of any Modified Version.
-
-  5. COMBINING DOCUMENTS
-
-     You may combine the Document with other documents released under
-     this License, under the terms defined in section 4 above for
-     modified versions, provided that you include in the combination
-     all of the Invariant Sections of all of the original documents,
-     unmodified, and list them all as Invariant Sections of your
-     combined work in its license notice, and that you preserve all
-     their Warranty Disclaimers.
-
-     The combined work need only contain one copy of this License, and
-     multiple identical Invariant Sections may be replaced with a single
-     copy.  If there are multiple Invariant Sections with the same name
-     but different contents, make the title of each such section unique
-     by adding at the end of it, in parentheses, the name of the
-     original author or publisher of that section if known, or else a
-     unique number.  Make the same adjustment to the section titles in
-     the list of Invariant Sections in the license notice of the
-     combined work.
-
-     In the combination, you must combine any sections Entitled
-     "History" in the various original documents, forming one section
-     Entitled "History"; likewise combine any sections Entitled
-     "Acknowledgements", and any sections Entitled "Dedications".  You
-     must delete all sections Entitled "Endorsements."
-
-  6. COLLECTIONS OF DOCUMENTS
-
-     You may make a collection consisting of the Document and other
-     documents released under this License, and replace the individual
-     copies of this License in the various documents with a single copy
-     that is included in the collection, provided that you follow the
-     rules of this License for verbatim copying of each of the
-     documents in all other respects.
-
-     You may extract a single document from such a collection, and
-     distribute it individually under this License, provided you insert
-     a copy of this License into the extracted document, and follow
-     this License in all other respects regarding verbatim copying of
-     that document.
-
-  7. AGGREGATION WITH INDEPENDENT WORKS
-
-     A compilation of the Document or its derivatives with other
-     separate and independent documents or works, in or on a volume of
-     a storage or distribution medium, is called an "aggregate" if the
-     copyright resulting from the compilation is not used to limit the
-     legal rights of the compilation's users beyond what the individual
-     works permit.  When the Document is included in an aggregate, this
-     License does not apply to the other works in the aggregate which
-     are not themselves derivative works of the Document.
-
-     If the Cover Text requirement of section 3 is applicable to these
-     copies of the Document, then if the Document is less than one half
-     of the entire aggregate, the Document's Cover Texts may be placed
-     on covers that bracket the Document within the aggregate, or the
-     electronic equivalent of covers if the Document is in electronic
-     form.  Otherwise they must appear on printed covers that bracket
-     the whole aggregate.
-
-  8. TRANSLATION
-
-     Translation is considered a kind of modification, so you may
-     distribute translations of the Document under the terms of section
-     4.  Replacing Invariant Sections with translations requires special
-     permission from their copyright holders, but you may include
-     translations of some or all Invariant Sections in addition to the
-     original versions of these Invariant Sections.  You may include a
-     translation of this License, and all the license notices in the
-     Document, and any Warranty Disclaimers, provided that you also
-     include the original English version of this License and the
-     original versions of those notices and disclaimers.  In case of a
-     disagreement between the translation and the original version of
-     this License or a notice or disclaimer, the original version will
-     prevail.
-
-     If a section in the Document is Entitled "Acknowledgements",
-     "Dedications", or "History", the requirement (section 4) to
-     Preserve its Title (section 1) will typically require changing the
-     actual title.
-
-  9. TERMINATION
-
-     You may not copy, modify, sublicense, or distribute the Document
-     except as expressly provided for under this License.  Any other
-     attempt to copy, modify, sublicense or distribute the Document is
-     void, and will automatically terminate your rights under this
-     License.  However, parties who have received copies, or rights,
-     from you under this License will not have their licenses
-     terminated so long as such parties remain in full compliance.
-
- 10. FUTURE REVISIONS OF THIS LICENSE
-
-     The Free Software Foundation may publish new, revised versions of
-     the GNU Free Documentation License from time to time.  Such new
-     versions will be similar in spirit to the present version, but may
-     differ in detail to address new problems or concerns.  See
-     `http://www.gnu.org/copyleft/'.
-
-     Each version of the License is given a distinguishing version
-     number.  If the Document specifies that a particular numbered
-     version of this License "or any later version" applies to it, you
-     have the option of following the terms and conditions either of
-     that specified version or of any later version that has been
-     published (not as a draft) by the Free Software Foundation.  If
-     the Document does not specify a version number of this License,
-     you may choose any version ever published (not as a draft) by the
-     Free Software Foundation.
-
-ADDENDUM: How to use this License for your documents
-====================================================
-
-To use this License in a document you have written, include a copy of
-the License in the document and put the following copyright and license
-notices just after the title page:
-
-       Copyright (C)  YEAR  YOUR NAME.
-       Permission is granted to copy, distribute and/or modify this document
-       under the terms of the GNU Free Documentation License, Version 1.2
-       or any later version published by the Free Software Foundation;
-       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
-       Texts.  A copy of the license is included in the section entitled ``GNU
-       Free Documentation License''.
-
-   If you have Invariant Sections, Front-Cover Texts and Back-Cover
-Texts, replace the "with...Texts." line with this:
-
-         with the Invariant Sections being LIST THEIR TITLES, with
-         the Front-Cover Texts being LIST, and with the Back-Cover Texts
-         being LIST.
-
-   If you have Invariant Sections without Cover Texts, or some other
-combination of the three, merge those two alternatives to suit the
-situation.
-
-   If your document contains nontrivial examples of program code, we
-recommend releasing these examples in parallel under your choice of
-free software license, such as the GNU General Public License, to
-permit their use in free software.
-
-
-File: gfortran.info,  Node: Funding,  Next: Option Index,  Prev: GNU Free Documentation License,  Up: Top
-
-Funding Free Software
-*********************
-
-If you want to have more free software a few years from now, it makes
-sense for you to help encourage people to contribute funds for its
-development.  The most effective approach known is to encourage
-commercial redistributors to donate.
-
-   Users of free software systems can boost the pace of development by
-encouraging for-a-fee distributors to donate part of their selling price
-to free software developers--the Free Software Foundation, and others.
-
-   The way to convince distributors to do this is to demand it and
-expect it from them.  So when you compare distributors, judge them
-partly by how much they give to free software development.  Show
-distributors they must compete to be the one who gives the most.
-
-   To make this approach work, you must insist on numbers that you can
-compare, such as, "We will donate ten dollars to the Frobnitz project
-for each disk sold."  Don't be satisfied with a vague promise, such as
-"A portion of the profits are donated," since it doesn't give a basis
-for comparison.
-
-   Even a precise fraction "of the profits from this disk" is not very
-meaningful, since creative accounting and unrelated business decisions
-can greatly alter what fraction of the sales price counts as profit.
-If the price you pay is $50, ten percent of the profit is probably less
-than a dollar; it might be a few cents, or nothing at all.
-
-   Some redistributors do development work themselves.  This is useful
-too; but to keep everyone honest, you need to inquire how much they do,
-and what kind.  Some kinds of development make much more long-term
-difference than others.  For example, maintaining a separate version of
-a program contributes very little; maintaining the standard version of a
-program for the whole community contributes much.  Easy new ports
-contribute little, since someone else would surely do them; difficult
-ports such as adding a new CPU to the GNU Compiler Collection
-contribute more; major new features or packages contribute the most.
-
-   By establishing the idea that supporting further development is "the
-proper thing to do" when distributing free software for a fee, we can
-assure a steady flow of resources into making more free software.
-
-     Copyright (C) 1994 Free Software Foundation, Inc.
-     Verbatim copying and redistribution of this section is permitted
-     without royalty; alteration is not permitted.
-
-
-File: gfortran.info,  Node: Option Index,  Next: Keyword Index,  Prev: Funding,  Up: Top
-
-Option Index
-************
-
-`gfortran''s command line options are indexed here without any initial
-`-' or `--'. Where an option has both positive and negative forms (such
-as -foption and -fno-option), relevant entries in the manual are
-indexed under the most appropriate form; it may sometimes be useful to
-look up both forms.
-
- [index ]
-* Menu:
-
-* A-PREDICATE=ANSWER:                    Preprocessing Options.
-                                                              (line 120)
-* APREDICATE=ANSWER:                     Preprocessing Options.
-                                                              (line 114)
-* backslash:                             Fortran Dialect Options.
-                                                              (line  59)
-* C:                                     Preprocessing Options.
-                                                              (line 123)
-* CC:                                    Preprocessing Options.
-                                                              (line 138)
-* cpp:                                   Preprocessing Options.
-                                                              (line  13)
-* dD:                                    Preprocessing Options.
-                                                              (line  35)
-* dI:                                    Preprocessing Options.
-                                                              (line  51)
-* dM:                                    Preprocessing Options.
-                                                              (line  26)
-* dN:                                    Preprocessing Options.
-                                                              (line  41)
-* DNAME:                                 Preprocessing Options.
-                                                              (line 153)
-* DNAME=DEFINITION:                      Preprocessing Options.
-                                                              (line 156)
-* dU:                                    Preprocessing Options.
-                                                              (line  44)
-* falign-commons:                        Code Gen Options.    (line 255)
-* fall-intrinsics:                       Fortran Dialect Options.
-                                                              (line  18)
-* fbacktrace:                            Debugging Options.   (line  31)
-* fblas-matmul-limit:                    Code Gen Options.    (line 214)
-* fbounds-check:                         Code Gen Options.    (line 130)
-* fcheck-array-temporaries:              Code Gen Options.    (line 144)
-* fconvert=CONVERSION:                   Runtime Options.     (line   9)
-* fcray-pointer:                         Fortran Dialect Options.
-                                                              (line 105)
-* fd-lines-as-code:                      Fortran Dialect Options.
-                                                              (line  29)
-* fd-lines-as-comments:                  Fortran Dialect Options.
-                                                              (line  29)
-* fdefault-double-8:                     Fortran Dialect Options.
-                                                              (line  36)
-* fdefault-integer-8:                    Fortran Dialect Options.
-                                                              (line  44)
-* fdefault-real-8:                       Fortran Dialect Options.
-                                                              (line  49)
-* fdollar-ok:                            Fortran Dialect Options.
-                                                              (line  56)
-* fdump-core:                            Debugging Options.   (line  38)
-* fdump-parse-tree:                      Debugging Options.   (line  10)
-* fexternal-blas:                        Code Gen Options.    (line 206)
-* ff2c:                                  Code Gen Options.    (line  25)
-* ffixed-line-length-N:                  Fortran Dialect Options.
-                                                              (line  76)
-* ffpe-trap=LIST:                        Debugging Options.   (line  14)
-* ffree-form:                            Fortran Dialect Options.
-                                                              (line  12)
-* ffree-line-length-N:                   Fortran Dialect Options.
-                                                              (line  89)
-* fimplicit-none:                        Fortran Dialect Options.
-                                                              (line 100)
-* finit-character:                       Code Gen Options.    (line 238)
-* finit-integer:                         Code Gen Options.    (line 238)
-* finit-local-zero:                      Code Gen Options.    (line 238)
-* finit-logical:                         Code Gen Options.    (line 238)
-* finit-real:                            Code Gen Options.    (line 238)
-* fintrinsic-modules-path DIR:           Directory Options.   (line  40)
-* fmax-array-constructor:                Code Gen Options.    (line 152)
-* fmax-errors=N:                         Error and Warning Options.
-                                                              (line  27)
-* fmax-identifier-length=N:              Fortran Dialect Options.
-                                                              (line  96)
-* fmax-stack-var-size:                   Code Gen Options.    (line 170)
-* fmax-subrecord-length=LENGTH:          Runtime Options.     (line  36)
-* fmodule-private:                       Fortran Dialect Options.
-                                                              (line  71)
-* fno-automatic:                         Code Gen Options.    (line  15)
-* fno-fixed-form:                        Fortran Dialect Options.
-                                                              (line  12)
-* fno-range-check:                       Runtime Options.     (line  20)
-* fno-underscoring:                      Code Gen Options.    (line  54)
-* fopenmp:                               Fortran Dialect Options.
-                                                              (line 109)
-* fpack-derived:                         Code Gen Options.    (line 184)
-* fpp:                                   Preprocessing Options.
-                                                              (line  13)
-* frange-check:                          Fortran Dialect Options.
-                                                              (line 117)
-* frecord-marker=LENGTH:                 Runtime Options.     (line  28)
-* frecursive:                            Code Gen Options.    (line 225)
-* frepack-arrays:                        Code Gen Options.    (line 190)
-* fsecond-underscore:                    Code Gen Options.    (line 113)
-* fshort-enums <1>:                      Fortran 2003 status. (line  20)
-* fshort-enums:                          Code Gen Options.    (line 200)
-* fsign-zero:                            Runtime Options.     (line  41)
-* fsyntax-only:                          Error and Warning Options.
-                                                              (line  33)
-* fworking-directory:                    Preprocessing Options.
-                                                              (line  55)
-* H:                                     Preprocessing Options.
-                                                              (line 176)
-* IDIR:                                  Directory Options.   (line  14)
-* idirafter DIR:                         Preprocessing Options.
-                                                              (line  70)
-* imultilib DIR:                         Preprocessing Options.
-                                                              (line  77)
-* iprefix PREFIX:                        Preprocessing Options.
-                                                              (line  81)
-* iquote DIR:                            Preprocessing Options.
-                                                              (line  90)
-* isysroot DIR:                          Preprocessing Options.
-                                                              (line  86)
-* isystem DIR:                           Preprocessing Options.
-                                                              (line  97)
-* JDIR:                                  Directory Options.   (line  31)
-* MDIR:                                  Directory Options.   (line  31)
-* nostdinc:                              Preprocessing Options.
-                                                              (line 105)
-* P:                                     Preprocessing Options.
-                                                              (line 181)
-* pedantic:                              Error and Warning Options.
-                                                              (line  38)
-* pedantic-errors:                       Error and Warning Options.
-                                                              (line  57)
-* static-libgfortran:                    Link Options.        (line  11)
-* std=STD option:                        Fortran Dialect Options.
-                                                              (line 129)
-* UNAME:                                 Preprocessing Options.
-                                                              (line 187)
-* undef:                                 Preprocessing Options.
-                                                              (line 110)
-* Waliasing:                             Error and Warning Options.
-                                                              (line  68)
-* Walign-commons:                        Error and Warning Options.
-                                                              (line 165)
-* Wall:                                  Error and Warning Options.
-                                                              (line  61)
-* Wampersand:                            Error and Warning Options.
-                                                              (line  85)
-* Warray-temporaries:                    Error and Warning Options.
-                                                              (line  93)
-* Wcharacter-truncation:                 Error and Warning Options.
-                                                              (line  98)
-* Wconversion:                           Error and Warning Options.
-                                                              (line 104)
-* Werror:                                Error and Warning Options.
-                                                              (line 171)
-* Wimplicit-interface:                   Error and Warning Options.
-                                                              (line 107)
-* Wintrinsic-shadow:                     Error and Warning Options.
-                                                              (line 152)
-* Wintrinsics-std:                       Error and Warning Options.
-                                                              (line 113)
-* Wline-truncation:                      Error and Warning Options.
-                                                              (line 101)
-* Wsurprising:                           Error and Warning Options.
-                                                              (line 120)
-* Wtabs:                                 Error and Warning Options.
-                                                              (line 140)
-* Wunderflow:                            Error and Warning Options.
-                                                              (line 148)
-* Wunused-parameter:                     Error and Warning Options.
-                                                              (line 158)
-
-
-File: gfortran.info,  Node: Keyword Index,  Prev: Option Index,  Up: Top
-
-Keyword Index
-*************
-
- [index ]
-* Menu:
-
-* $:                                     Fortran Dialect Options.
-                                                              (line  56)
-* %LOC:                                  Argument list functions.
-                                                              (line   6)
-* %REF:                                  Argument list functions.
-                                                              (line   6)
-* %VAL:                                  Argument list functions.
-                                                              (line   6)
-* &:                                     Error and Warning Options.
-                                                              (line  85)
-* [...]:                                 Fortran 2003 status. (line  13)
-* ABORT:                                 ABORT.               (line   6)
-* ABS:                                   ABS.                 (line   6)
-* absolute value:                        ABS.                 (line   6)
-* ACCESS:                                ACCESS.              (line   6)
-* ACCESS='STREAM' I/O:                   Fortran 2003 status. (line  32)
-* ACHAR:                                 ACHAR.               (line   6)
-* ACOS:                                  ACOS.                (line   6)
-* ACOSH:                                 ACOSH.               (line   6)
-* adjust string <1>:                     ADJUSTR.             (line   6)
-* adjust string:                         ADJUSTL.             (line   6)
-* ADJUSTL:                               ADJUSTL.             (line   6)
-* ADJUSTR:                               ADJUSTR.             (line   6)
-* AIMAG:                                 AIMAG.               (line   6)
-* AINT:                                  AINT.                (line   6)
-* ALARM:                                 ALARM.               (line   6)
-* ALGAMA:                                LOG_GAMMA.           (line   6)
-* aliasing:                              Error and Warning Options.
-                                                              (line  68)
-* alignment of COMMON blocks <1>:        Code Gen Options.    (line 255)
-* alignment of COMMON blocks:            Error and Warning Options.
-                                                              (line 165)
-* ALL:                                   ALL.                 (line   6)
-* all warnings:                          Error and Warning Options.
-                                                              (line  61)
-* ALLOCATABLE components of derived types: Fortran 2003 status.
-                                                              (line  30)
-* ALLOCATABLE dummy arguments:           Fortran 2003 status. (line  26)
-* ALLOCATABLE function results:          Fortran 2003 status. (line  28)
-* ALLOCATED:                             ALLOCATED.           (line   6)
-* allocation, moving:                    MOVE_ALLOC.          (line   6)
-* allocation, status:                    ALLOCATED.           (line   6)
-* ALOG:                                  LOG.                 (line   6)
-* ALOG10:                                LOG10.               (line   6)
-* AMAX0:                                 MAX.                 (line   6)
-* AMAX1:                                 MAX.                 (line   6)
-* AMIN0:                                 MIN.                 (line   6)
-* AMIN1:                                 MIN.                 (line   6)
-* AMOD:                                  MOD.                 (line   6)
-* AND:                                   AND.                 (line   6)
-* ANINT:                                 ANINT.               (line   6)
-* ANY:                                   ANY.                 (line   6)
-* area hyperbolic cosine:                ACOSH.               (line   6)
-* area hyperbolic sine:                  ASINH.               (line   6)
-* area hyperbolic tangent:               ATANH.               (line   6)
-* argument list functions:               Argument list functions.
-                                                              (line   6)
-* arguments, to program <1>:             IARGC.               (line   6)
-* arguments, to program <2>:             GET_COMMAND_ARGUMENT.
-                                                              (line   6)
-* arguments, to program <3>:             GET_COMMAND.         (line   6)
-* arguments, to program <4>:             GETARG.              (line   6)
-* arguments, to program:                 COMMAND_ARGUMENT_COUNT.
-                                                              (line   6)
-* array, add elements:                   SUM.                 (line   6)
-* array, apply condition <1>:            ANY.                 (line   6)
-* array, apply condition:                ALL.                 (line   6)
-* array, bounds checking:                Code Gen Options.    (line 130)
-* array, change dimensions:              RESHAPE.             (line   6)
-* array, combine arrays:                 MERGE.               (line   6)
-* array, condition testing <1>:          ANY.                 (line   6)
-* array, condition testing:              ALL.                 (line   6)
-* array, conditionally add elements:     SUM.                 (line   6)
-* array, conditionally count elements:   COUNT.               (line   6)
-* array, conditionally multiply elements: PRODUCT.            (line   6)
-* array, constructors:                   Fortran 2003 status. (line  13)
-* array, count elements:                 SIZE.                (line   6)
-* array, duplicate dimensions:           SPREAD.              (line   6)
-* array, duplicate elements:             SPREAD.              (line   6)
-* array, element counting:               COUNT.               (line   6)
-* array, gather elements:                PACK.                (line   6)
-* array, increase dimension <1>:         UNPACK.              (line   6)
-* array, increase dimension:             SPREAD.              (line   6)
-* array, indices of type real:           Real array indices.  (line   6)
-* array, location of maximum element:    MAXLOC.              (line   6)
-* array, location of minimum element:    MINLOC.              (line   6)
-* array, lower bound:                    LBOUND.              (line   6)
-* array, maximum value:                  MAXVAL.              (line   6)
-* array, merge arrays:                   MERGE.               (line   6)
-* array, minimum value:                  MINVAL.              (line   6)
-* array, multiply elements:              PRODUCT.             (line   6)
-* array, number of elements <1>:         SIZE.                (line   6)
-* array, number of elements:             COUNT.               (line   6)
-* array, packing:                        PACK.                (line   6)
-* array, permutation:                    CSHIFT.              (line   6)
-* array, product:                        PRODUCT.             (line   6)
-* array, reduce dimension:               PACK.                (line   6)
-* array, rotate:                         CSHIFT.              (line   6)
-* array, scatter elements:               UNPACK.              (line   6)
-* array, shape:                          SHAPE.               (line   6)
-* array, shift:                          EOSHIFT.             (line   6)
-* array, shift circularly:               CSHIFT.              (line   6)
-* array, size:                           SIZE.                (line   6)
-* array, sum:                            SUM.                 (line   6)
-* array, transmogrify:                   RESHAPE.             (line   6)
-* array, transpose:                      TRANSPOSE.           (line   6)
-* array, unpacking:                      UNPACK.              (line   6)
-* array, upper bound:                    UBOUND.              (line   6)
-* ASCII collating sequence <1>:          IACHAR.              (line   6)
-* ASCII collating sequence:              ACHAR.               (line   6)
-* ASIN:                                  ASIN.                (line   6)
-* ASINH <1>:                             ATANH.               (line   6)
-* ASINH:                                 ASINH.               (line   6)
-* ASSOCIATED:                            ASSOCIATED.          (line   6)
-* association status:                    ASSOCIATED.          (line   6)
-* association status, C pointer:         C_ASSOCIATED.        (line   6)
-* ATAN:                                  ATAN.                (line   6)
-* ATAN2:                                 ATAN2.               (line   6)
-* Authors:                               Contributors.        (line   6)
-* backslash:                             Fortran Dialect Options.
-                                                              (line  59)
-* backtrace:                             Debugging Options.   (line  31)
-* BESJ0:                                 BESSEL_J0.           (line   6)
-* BESJ1:                                 BESSEL_J1.           (line   6)
-* BESJN:                                 BESSEL_JN.           (line   6)
-* Bessel function, first kind <1>:       BESSEL_JN.           (line   6)
-* Bessel function, first kind <2>:       BESSEL_J1.           (line   6)
-* Bessel function, first kind:           BESSEL_J0.           (line   6)
-* Bessel function, second kind <1>:      BESSEL_YN.           (line   6)
-* Bessel function, second kind <2>:      BESSEL_Y1.           (line   6)
-* Bessel function, second kind:          BESSEL_Y0.           (line   6)
-* BESSEL_J0:                             BESSEL_J0.           (line   6)
-* BESSEL_J1:                             BESSEL_J1.           (line   6)
-* BESSEL_JN:                             BESSEL_JN.           (line   6)
-* BESSEL_Y0:                             BESSEL_Y0.           (line   6)
-* BESSEL_Y1:                             BESSEL_Y1.           (line   6)
-* BESSEL_YN:                             BESSEL_YN.           (line   6)
-* BESY0:                                 BESSEL_Y0.           (line   6)
-* BESY1:                                 BESSEL_Y1.           (line   6)
-* BESYN:                                 BESSEL_YN.           (line   6)
-* BIT_SIZE:                              BIT_SIZE.            (line   6)
-* bits, clear:                           IBCLR.               (line   6)
-* bits, extract:                         IBITS.               (line   6)
-* bits, get:                             IBITS.               (line   6)
-* bits, move <1>:                        TRANSFER.            (line   6)
-* bits, move:                            MVBITS.              (line   6)
-* bits, negate:                          NOT.                 (line   6)
-* bits, number of:                       BIT_SIZE.            (line   6)
-* bits, set:                             IBSET.               (line   6)
-* bits, shift:                           ISHFT.               (line   6)
-* bits, shift circular:                  ISHFTC.              (line   6)
-* bits, shift left:                      LSHIFT.              (line   6)
-* bits, shift right:                     RSHIFT.              (line   6)
-* bits, testing:                         BTEST.               (line   6)
-* bits, unset:                           IBCLR.               (line   6)
-* bitwise logical and <1>:               IAND.                (line   6)
-* bitwise logical and:                   AND.                 (line   6)
-* bitwise logical exclusive or <1>:      XOR.                 (line   6)
-* bitwise logical exclusive or:          IEOR.                (line   6)
-* bitwise logical not:                   NOT.                 (line   6)
-* bitwise logical or <1>:                OR.                  (line   6)
-* bitwise logical or:                    IOR.                 (line   6)
-* bounds checking:                       Code Gen Options.    (line 130)
-* BOZ literal constants:                 BOZ literal constants.
-                                                              (line   6)
-* BTEST:                                 BTEST.               (line   6)
-* C_ASSOCIATED:                          C_ASSOCIATED.        (line   6)
-* C_F_POINTER:                           C_F_POINTER.         (line   6)
-* C_F_PROCPOINTER:                       C_F_PROCPOINTER.     (line   6)
-* C_FUNLOC:                              C_FUNLOC.            (line   6)
-* C_LOC:                                 C_LOC.               (line   6)
-* C_SIZEOF:                              C_SIZEOF.            (line   6)
-* CABS:                                  ABS.                 (line   6)
-* calling convention:                    Code Gen Options.    (line  25)
-* CCOS:                                  COS.                 (line   6)
-* CDABS:                                 ABS.                 (line   6)
-* CDCOS:                                 COS.                 (line   6)
-* CDEXP:                                 EXP.                 (line   6)
-* CDLOG:                                 LOG.                 (line   6)
-* CDSIN:                                 SIN.                 (line   6)
-* CDSQRT:                                SQRT.                (line   6)
-* ceiling:                               CEILING.             (line   6)
-* CEILING:                               CEILING.             (line   6)
-* ceiling:                               ANINT.               (line   6)
-* CEXP:                                  EXP.                 (line   6)
-* CHAR:                                  CHAR.                (line   6)
-* character kind:                        SELECTED_CHAR_KIND.  (line   6)
-* character set:                         Fortran Dialect Options.
-                                                              (line  56)
-* CHDIR:                                 CHDIR.               (line   6)
-* checking array temporaries:            Code Gen Options.    (line 144)
-* checking subscripts:                   Code Gen Options.    (line 130)
-* CHMOD:                                 CHMOD.               (line   6)
-* clock ticks <1>:                       SYSTEM_CLOCK.        (line   6)
-* clock ticks <2>:                       MCLOCK8.             (line   6)
-* clock ticks:                           MCLOCK.              (line   6)
-* CLOG:                                  LOG.                 (line   6)
-* CMPLX:                                 CMPLX.               (line   6)
-* code generation, conventions:          Code Gen Options.    (line   6)
-* collating sequence, ASCII <1>:         IACHAR.              (line   6)
-* collating sequence, ASCII:             ACHAR.               (line   6)
-* command options:                       Invoking GNU Fortran.
-                                                              (line   6)
-* command-line arguments <1>:            IARGC.               (line   6)
-* command-line arguments <2>:            GET_COMMAND_ARGUMENT.
-                                                              (line   6)
-* command-line arguments <3>:            GET_COMMAND.         (line   6)
-* command-line arguments <4>:            GETARG.              (line   6)
-* command-line arguments:                COMMAND_ARGUMENT_COUNT.
-                                                              (line   6)
-* command-line arguments, number of <1>: IARGC.               (line   6)
-* command-line arguments, number of:     COMMAND_ARGUMENT_COUNT.
-                                                              (line   6)
-* COMMAND_ARGUMENT_COUNT:                COMMAND_ARGUMENT_COUNT.
-                                                              (line   6)
-* COMPLEX:                               COMPLEX.             (line   6)
-* complex conjugate:                     CONJG.               (line   6)
-* complex numbers, conversion to <1>:    DCMPLX.              (line   6)
-* complex numbers, conversion to <2>:    COMPLEX.             (line   6)
-* complex numbers, conversion to:        CMPLX.               (line   6)
-* complex numbers, imaginary part:       AIMAG.               (line   6)
-* complex numbers, real part <1>:        REAL.                (line   6)
-* complex numbers, real part:            DREAL.               (line   6)
-* Conditional compilation:               Preprocessing and conditional compilation.
-                                                              (line   6)
-* CONJG:                                 CONJG.               (line   6)
-* Contributing:                          Contributing.        (line   6)
-* Contributors:                          Contributors.        (line   6)
-* conversion:                            Error and Warning Options.
-                                                              (line 104)
-* conversion, to character:              CHAR.                (line   6)
-* conversion, to complex <1>:            DCMPLX.              (line   6)
-* conversion, to complex <2>:            COMPLEX.             (line   6)
-* conversion, to complex:                CMPLX.               (line   6)
-* conversion, to integer <1>:            LONG.                (line   6)
-* conversion, to integer <2>:            INT8.                (line   6)
-* conversion, to integer <3>:            INT2.                (line   6)
-* conversion, to integer <4>:            INT.                 (line   6)
-* conversion, to integer <5>:            ICHAR.               (line   6)
-* conversion, to integer <6>:            IACHAR.              (line   6)
-* conversion, to integer:                Implicitly convert LOGICAL and INTEGER values.
-                                                              (line   6)
-* conversion, to logical <1>:            LOGICAL.             (line   6)
-* conversion, to logical:                Implicitly convert LOGICAL and INTEGER values.
-                                                              (line   6)
-* conversion, to real <1>:               SNGL.                (line   6)
-* conversion, to real <2>:               REAL.                (line   6)
-* conversion, to real <3>:               FLOAT.               (line   6)
-* conversion, to real <4>:               DFLOAT.              (line   6)
-* conversion, to real:                   DBLE.                (line   6)
-* conversion, to string:                 CTIME.               (line   6)
-* CONVERT specifier:                     CONVERT specifier.   (line   6)
-* core, dump <1>:                        ABORT.               (line   6)
-* core, dump:                            Debugging Options.   (line  38)
-* COS:                                   COS.                 (line   6)
-* COSH:                                  COSH.                (line   6)
-* cosine:                                COS.                 (line   6)
-* cosine, hyperbolic:                    COSH.                (line   6)
-* cosine, hyperbolic, inverse:           ACOSH.               (line   6)
-* cosine, inverse:                       ACOS.                (line   6)
-* COUNT:                                 COUNT.               (line   6)
-* CPP <1>:                               Preprocessing Options.
-                                                              (line   6)
-* CPP:                                   Preprocessing and conditional compilation.
-                                                              (line   6)
-* CPU_TIME:                              CPU_TIME.            (line   6)
-* Credits:                               Contributors.        (line   6)
-* CSHIFT:                                CSHIFT.              (line   6)
-* CSIN:                                  SIN.                 (line   6)
-* CSQRT:                                 SQRT.                (line   6)
-* CTIME:                                 CTIME.               (line   6)
-* current date <1>:                      IDATE.               (line   6)
-* current date <2>:                      FDATE.               (line   6)
-* current date:                          DATE_AND_TIME.       (line   6)
-* current time <1>:                      TIME8.               (line   6)
-* current time <2>:                      TIME.                (line   6)
-* current time <3>:                      ITIME.               (line   6)
-* current time <4>:                      FDATE.               (line   6)
-* current time:                          DATE_AND_TIME.       (line   6)
-* DABS:                                  ABS.                 (line   6)
-* DACOS:                                 ACOS.                (line   6)
-* DACOSH:                                ACOSH.               (line   6)
-* DASIN:                                 ASIN.                (line   6)
-* DASINH <1>:                            ATANH.               (line   6)
-* DASINH:                                ASINH.               (line   6)
-* DATAN:                                 ATAN.                (line   6)
-* DATAN2:                                ATAN2.               (line   6)
-* date, current <1>:                     IDATE.               (line   6)
-* date, current <2>:                     FDATE.               (line   6)
-* date, current:                         DATE_AND_TIME.       (line   6)
-* DATE_AND_TIME:                         DATE_AND_TIME.       (line   6)
-* DBESJ0:                                BESSEL_J0.           (line   6)
-* DBESJ1:                                BESSEL_J1.           (line   6)
-* DBESJN:                                BESSEL_JN.           (line   6)
-* DBESY0:                                BESSEL_Y0.           (line   6)
-* DBESY1:                                BESSEL_Y1.           (line   6)
-* DBESYN:                                BESSEL_YN.           (line   6)
-* DBLE:                                  DBLE.                (line   6)
-* DCMPLX:                                DCMPLX.              (line   6)
-* DCONJG:                                CONJG.               (line   6)
-* DCOS:                                  COS.                 (line   6)
-* DCOSH:                                 COSH.                (line   6)
-* DDIM:                                  DIM.                 (line   6)
-* debugging information options:         Debugging Options.   (line   6)
-* debugging, preprocessor:               Preprocessing Options.
-                                                              (line  26)
-* DECODE:                                ENCODE and DECODE statements.
-                                                              (line   6)
-* delayed execution <1>:                 SLEEP.               (line   6)
-* delayed execution:                     ALARM.               (line   6)
-* DEXP:                                  EXP.                 (line   6)
-* DFLOAT:                                DFLOAT.              (line   6)
-* DGAMMA:                                GAMMA.               (line   6)
-* dialect options:                       Fortran Dialect Options.
-                                                              (line   6)
-* DIGITS:                                DIGITS.              (line   6)
-* DIM:                                   DIM.                 (line   6)
-* DIMAG:                                 AIMAG.               (line   6)
-* DINT:                                  AINT.                (line   6)
-* directive, INCLUDE:                    Directory Options.   (line   6)
-* directory, options:                    Directory Options.   (line   6)
-* directory, search paths for inclusion: Directory Options.   (line  14)
-* division, modulo:                      MODULO.              (line   6)
-* division, remainder:                   MOD.                 (line   6)
-* DLGAMA:                                LOG_GAMMA.           (line   6)
-* DLOG:                                  LOG.                 (line   6)
-* DLOG10:                                LOG10.               (line   6)
-* DMAX1:                                 MAX.                 (line   6)
-* DMIN1:                                 MIN.                 (line   6)
-* DMOD:                                  MOD.                 (line   6)
-* DNINT:                                 ANINT.               (line   6)
-* dot product:                           DOT_PRODUCT.         (line   6)
-* DOT_PRODUCT:                           DOT_PRODUCT.         (line   6)
-* DPROD:                                 DPROD.               (line   6)
-* DREAL:                                 DREAL.               (line   6)
-* DSIGN:                                 SIGN.                (line   6)
-* DSIN:                                  SIN.                 (line   6)
-* DSINH:                                 SINH.                (line   6)
-* DSQRT:                                 SQRT.                (line   6)
-* DTAN:                                  TAN.                 (line   6)
-* DTANH:                                 TANH.                (line   6)
-* DTIME:                                 DTIME.               (line   6)
-* elapsed time <1>:                      SECOND.              (line   6)
-* elapsed time <2>:                      SECNDS.              (line   6)
-* elapsed time:                          DTIME.               (line   6)
-* ENCODE:                                ENCODE and DECODE statements.
-                                                              (line   6)
-* ENUM statement:                        Fortran 2003 status. (line  20)
-* ENUMERATOR statement:                  Fortran 2003 status. (line  20)
-* environment variable <1>:              GET_ENVIRONMENT_VARIABLE.
-                                                              (line   6)
-* environment variable <2>:              GETENV.              (line   6)
-* environment variable <3>:              Runtime.             (line   6)
-* environment variable:                  Environment Variables.
-                                                              (line   6)
-* EOSHIFT:                               EOSHIFT.             (line   6)
-* EPSILON:                               EPSILON.             (line   6)
-* ERF:                                   ERF.                 (line   6)
-* ERFC:                                  ERFC.                (line   6)
-* ERFC_SCALED:                           ERFC_SCALED.         (line   6)
-* error function:                        ERF.                 (line   6)
-* error function, complementary:         ERFC.                (line   6)
-* error function, complementary, exponentially-scaled: ERFC_SCALED.
-                                                              (line   6)
-* errors, limiting:                      Error and Warning Options.
-                                                              (line  27)
-* escape characters:                     Fortran Dialect Options.
-                                                              (line  59)
-* ETIME:                                 ETIME.               (line   6)
-* Euclidean distance:                    HYPOT.               (line   6)
-* EXIT:                                  EXIT.                (line   6)
-* EXP:                                   EXP.                 (line   6)
-* EXPONENT:                              EXPONENT.            (line   6)
-* exponential function:                  EXP.                 (line   6)
-* exponential function, inverse <1>:     LOG10.               (line   6)
-* exponential function, inverse:         LOG.                 (line   6)
-* expression size <1>:                   SIZEOF.              (line   6)
-* expression size:                       C_SIZEOF.            (line   6)
-* extensions:                            Extensions.          (line   6)
-* extensions, implemented:               Extensions implemented in GNU Fortran.
-                                                              (line   6)
-* extensions, not implemented:           Extensions not implemented in GNU Fortran.
-                                                              (line   6)
-* f2c calling convention:                Code Gen Options.    (line  25)
-* Factorial function:                    GAMMA.               (line   6)
-* FDATE:                                 FDATE.               (line   6)
-* FDL, GNU Free Documentation License:   GNU Free Documentation License.
-                                                              (line   6)
-* FGET:                                  FGET.                (line   6)
-* FGETC:                                 FGETC.               (line   6)
-* file format, fixed:                    Fortran Dialect Options.
-                                                              (line  12)
-* file format, free:                     Fortran Dialect Options.
-                                                              (line  12)
-* file operation, file number:           FNUM.                (line   6)
-* file operation, flush:                 FLUSH.               (line   6)
-* file operation, position <1>:          FTELL.               (line   6)
-* file operation, position:              FSEEK.               (line   6)
-* file operation, read character <1>:    FGETC.               (line   6)
-* file operation, read character:        FGET.                (line   6)
-* file operation, seek:                  FSEEK.               (line   6)
-* file operation, write character <1>:   FPUTC.               (line   6)
-* file operation, write character:       FPUT.                (line   6)
-* file system, access mode:              ACCESS.              (line   6)
-* file system, change access mode:       CHMOD.               (line   6)
-* file system, create link <1>:          SYMLNK.              (line   6)
-* file system, create link:              LINK.                (line   6)
-* file system, file creation mask:       UMASK.               (line   6)
-* file system, file status <1>:          STAT.                (line   6)
-* file system, file status <2>:          LSTAT.               (line   6)
-* file system, file status:              FSTAT.               (line   6)
-* file system, hard link:                LINK.                (line   6)
-* file system, remove file:              UNLINK.              (line   6)
-* file system, rename file:              RENAME.              (line   6)
-* file system, soft link:                SYMLNK.              (line   6)
-* FLOAT:                                 FLOAT.               (line   6)
-* floating point, exponent:              EXPONENT.            (line   6)
-* floating point, fraction:              FRACTION.            (line   6)
-* floating point, nearest different:     NEAREST.             (line   6)
-* floating point, relative spacing <1>:  SPACING.             (line   6)
-* floating point, relative spacing:      RRSPACING.           (line   6)
-* floating point, scale:                 SCALE.               (line   6)
-* floating point, set exponent:          SET_EXPONENT.        (line   6)
-* floor:                                 FLOOR.               (line   6)
-* FLOOR:                                 FLOOR.               (line   6)
-* floor:                                 AINT.                (line   6)
-* FLUSH:                                 FLUSH.               (line   6)
-* FLUSH statement:                       Fortran 2003 status. (line  16)
-* FNUM:                                  FNUM.                (line   6)
-* Fortran 77:                            GNU Fortran and G77. (line   6)
-* FPP:                                   Preprocessing and conditional compilation.
-                                                              (line   6)
-* FPUT:                                  FPUT.                (line   6)
-* FPUTC:                                 FPUTC.               (line   6)
-* FRACTION:                              FRACTION.            (line   6)
-* FREE:                                  FREE.                (line   6)
-* FSEEK:                                 FSEEK.               (line   6)
-* FSTAT:                                 FSTAT.               (line   6)
-* FTELL:                                 FTELL.               (line   6)
-* g77:                                   GNU Fortran and G77. (line   6)
-* g77 calling convention:                Code Gen Options.    (line  25)
-* GAMMA:                                 GAMMA.               (line   6)
-* Gamma function:                        GAMMA.               (line   6)
-* Gamma function, logarithm of:          LOG_GAMMA.           (line   6)
-* GCC:                                   GNU Fortran and GCC. (line   6)
-* GERROR:                                GERROR.              (line   6)
-* GET_COMMAND:                           GET_COMMAND.         (line   6)
-* GET_COMMAND_ARGUMENT:                  GET_COMMAND_ARGUMENT.
-                                                              (line   6)
-* GET_ENVIRONMENT_VARIABLE:              GET_ENVIRONMENT_VARIABLE.
-                                                              (line   6)
-* GETARG:                                GETARG.              (line   6)
-* GETCWD:                                GETCWD.              (line   6)
-* GETENV:                                GETENV.              (line   6)
-* GETGID:                                GETGID.              (line   6)
-* GETLOG:                                GETLOG.              (line   6)
-* GETPID:                                GETPID.              (line   6)
-* GETUID:                                GETUID.              (line   6)
-* GMTIME:                                GMTIME.              (line   6)
-* GNU Compiler Collection:               GNU Fortran and GCC. (line   6)
-* GNU Fortran command options:           Invoking GNU Fortran.
-                                                              (line   6)
-* Hollerith constants:                   Hollerith constants support.
-                                                              (line   6)
-* HOSTNM:                                HOSTNM.              (line   6)
-* HUGE:                                  HUGE.                (line   6)
-* hyperbolic arccosine:                  ACOSH.               (line   6)
-* hyperbolic arcsine:                    ASINH.               (line   6)
-* hyperbolic arctangent:                 ATANH.               (line   6)
-* hyperbolic cosine:                     COSH.                (line   6)
-* hyperbolic function, cosine:           COSH.                (line   6)
-* hyperbolic function, cosine, inverse:  ACOSH.               (line   6)
-* hyperbolic function, sine:             SINH.                (line   6)
-* hyperbolic function, sine, inverse:    ASINH.               (line   6)
-* hyperbolic function, tangent:          TANH.                (line   6)
-* hyperbolic function, tangent, inverse: ATANH.               (line   6)
-* hyperbolic sine:                       SINH.                (line   6)
-* hyperbolic tangent:                    TANH.                (line   6)
-* HYPOT:                                 HYPOT.               (line   6)
-* I/O item lists:                        I/O item lists.      (line   6)
-* IABS:                                  ABS.                 (line   6)
-* IACHAR:                                IACHAR.              (line   6)
-* IAND:                                  IAND.                (line   6)
-* IARGC:                                 IARGC.               (line   6)
-* IBCLR:                                 IBCLR.               (line   6)
-* IBITS:                                 IBITS.               (line   6)
-* IBSET:                                 IBSET.               (line   6)
-* ICHAR:                                 ICHAR.               (line   6)
-* IDATE:                                 IDATE.               (line   6)
-* IDIM:                                  DIM.                 (line   6)
-* IDINT:                                 INT.                 (line   6)
-* IDNINT:                                NINT.                (line   6)
-* IEEE, ISNAN:                           ISNAN.               (line   6)
-* IEOR:                                  IEOR.                (line   6)
-* IERRNO:                                IERRNO.              (line   6)
-* IFIX:                                  INT.                 (line   6)
-* IMAG:                                  AIMAG.               (line   6)
-* IMAGPART:                              AIMAG.               (line   6)
-* IMPORT statement:                      Fortran 2003 status. (line  43)
-* INCLUDE directive:                     Directory Options.   (line   6)
-* inclusion, directory search paths for: Directory Options.   (line  14)
-* INDEX:                                 INDEX intrinsic.     (line   6)
-* INT:                                   INT.                 (line   6)
-* INT2:                                  INT2.                (line   6)
-* INT8:                                  INT8.                (line   6)
-* integer kind:                          SELECTED_INT_KIND.   (line   6)
-* intrinsic:                             Error and Warning Options.
-                                                              (line 152)
-* intrinsic Modules:                     Intrinsic Modules.   (line   6)
-* intrinsic procedures:                  Intrinsic Procedures.
-                                                              (line   6)
-* Introduction:                          Top.                 (line   6)
-* IOMSG= specifier:                      Fortran 2003 status. (line  18)
-* IOR:                                   IOR.                 (line   6)
-* IOSTAT, end of file:                   IS_IOSTAT_END.       (line   6)
-* IOSTAT, end of record:                 IS_IOSTAT_EOR.       (line   6)
-* IRAND:                                 IRAND.               (line   6)
-* IS_IOSTAT_END:                         IS_IOSTAT_END.       (line   6)
-* IS_IOSTAT_EOR:                         IS_IOSTAT_EOR.       (line   6)
-* ISATTY:                                ISATTY.              (line   6)
-* ISHFT:                                 ISHFT.               (line   6)
-* ISHFTC:                                ISHFTC.              (line   6)
-* ISIGN:                                 SIGN.                (line   6)
-* ISNAN:                                 ISNAN.               (line   6)
-* ISO C Bindings:                        Fortran 2003 status. (line  52)
-* ISO_FORTRAN_ENV statement:             Fortran 2003 status. (line  46)
-* ITIME:                                 ITIME.               (line   6)
-* KILL:                                  KILL.                (line   6)
-* kind:                                  KIND.                (line   6)
-* KIND:                                  KIND.                (line   6)
-* kind:                                  KIND Type Parameters.
-                                                              (line   6)
-* kind, character:                       SELECTED_CHAR_KIND.  (line   6)
-* kind, integer:                         SELECTED_INT_KIND.   (line   6)
-* kind, old-style:                       Old-style kind specifications.
-                                                              (line   6)
-* kind, real:                            SELECTED_REAL_KIND.  (line   6)
-* language, dialect options:             Fortran Dialect Options.
-                                                              (line   6)
-* LBOUND:                                LBOUND.              (line   6)
-* LEADZ:                                 LEADZ.               (line   6)
-* LEN:                                   LEN.                 (line   6)
-* LEN_TRIM:                              LEN_TRIM.            (line   6)
-* lexical comparison of strings <1>:     LLT.                 (line   6)
-* lexical comparison of strings <2>:     LLE.                 (line   6)
-* lexical comparison of strings <3>:     LGT.                 (line   6)
-* lexical comparison of strings:         LGE.                 (line   6)
-* LGAMMA:                                LOG_GAMMA.           (line   6)
-* LGE:                                   LGE.                 (line   6)
-* LGT:                                   LGT.                 (line   6)
-* libf2c calling convention:             Code Gen Options.    (line  25)
-* limits, largest number:                HUGE.                (line   6)
-* limits, smallest number:               TINY.                (line   6)
-* LINK:                                  LINK.                (line   6)
-* linking, static:                       Link Options.        (line   6)
-* LLE:                                   LLE.                 (line   6)
-* LLT:                                   LLT.                 (line   6)
-* LNBLNK:                                LNBLNK.              (line   6)
-* LOC:                                   LOC.                 (line   6)
-* location of a variable in memory:      LOC.                 (line   6)
-* LOG:                                   LOG.                 (line   6)
-* LOG10:                                 LOG10.               (line   6)
-* LOG_GAMMA:                             LOG_GAMMA.           (line   6)
-* logarithmic function <1>:              LOG10.               (line   6)
-* logarithmic function:                  LOG.                 (line   6)
-* logarithmic function, inverse:         EXP.                 (line   6)
-* LOGICAL:                               LOGICAL.             (line   6)
-* logical and, bitwise <1>:              IAND.                (line   6)
-* logical and, bitwise:                  AND.                 (line   6)
-* logical exclusive or, bitwise <1>:     XOR.                 (line   6)
-* logical exclusive or, bitwise:         IEOR.                (line   6)
-* logical not, bitwise:                  NOT.                 (line   6)
-* logical or, bitwise <1>:               OR.                  (line   6)
-* logical or, bitwise:                   IOR.                 (line   6)
-* login name:                            GETLOG.              (line   6)
-* LONG:                                  LONG.                (line   6)
-* LSHIFT:                                LSHIFT.              (line   6)
-* LSTAT:                                 LSTAT.               (line   6)
-* LTIME:                                 LTIME.               (line   6)
-* MALLOC:                                MALLOC.              (line   6)
-* MATMUL:                                MATMUL.              (line   6)
-* matrix multiplication:                 MATMUL.              (line   6)
-* matrix, transpose:                     TRANSPOSE.           (line   6)
-* MAX:                                   MAX.                 (line   6)
-* MAX0:                                  MAX.                 (line   6)
-* MAX1:                                  MAX.                 (line   6)
-* MAXEXPONENT:                           MAXEXPONENT.         (line   6)
-* maximum value <1>:                     MAXVAL.              (line   6)
-* maximum value:                         MAX.                 (line   6)
-* MAXLOC:                                MAXLOC.              (line   6)
-* MAXVAL:                                MAXVAL.              (line   6)
-* MCLOCK:                                MCLOCK.              (line   6)
-* MCLOCK8:                               MCLOCK8.             (line   6)
-* MERGE:                                 MERGE.               (line   6)
-* messages, error:                       Error and Warning Options.
-                                                              (line   6)
-* messages, warning:                     Error and Warning Options.
-                                                              (line   6)
-* MIN:                                   MIN.                 (line   6)
-* MIN0:                                  MIN.                 (line   6)
-* MIN1:                                  MIN.                 (line   6)
-* MINEXPONENT:                           MINEXPONENT.         (line   6)
-* minimum value <1>:                     MINVAL.              (line   6)
-* minimum value:                         MIN.                 (line   6)
-* MINLOC:                                MINLOC.              (line   6)
-* MINVAL:                                MINVAL.              (line   6)
-* MOD:                                   MOD.                 (line   6)
-* model representation, base:            RADIX.               (line   6)
-* model representation, epsilon:         EPSILON.             (line   6)
-* model representation, largest number:  HUGE.                (line   6)
-* model representation, maximum exponent: MAXEXPONENT.        (line   6)
-* model representation, minimum exponent: MINEXPONENT.        (line   6)
-* model representation, precision:       PRECISION.           (line   6)
-* model representation, radix:           RADIX.               (line   6)
-* model representation, range:           RANGE.               (line   6)
-* model representation, significant digits: DIGITS.           (line   6)
-* model representation, smallest number: TINY.                (line   6)
-* module entities:                       Fortran Dialect Options.
-                                                              (line  71)
-* module search path:                    Directory Options.   (line  14)
-* modulo:                                MODULO.              (line   6)
-* MODULO:                                MODULO.              (line   6)
-* MOVE_ALLOC:                            MOVE_ALLOC.          (line   6)
-* moving allocation:                     MOVE_ALLOC.          (line   6)
-* multiply array elements:               PRODUCT.             (line   6)
-* MVBITS:                                MVBITS.              (line   6)
-* Namelist:                              Extensions to namelist.
-                                                              (line   6)
-* NEAREST:                               NEAREST.             (line   6)
-* NEW_LINE:                              NEW_LINE.            (line   6)
-* newline:                               NEW_LINE.            (line   6)
-* NINT:                                  NINT.                (line   6)
-* NOT:                                   NOT.                 (line   6)
-* NULL:                                  NULL.                (line   6)
-* OpenMP <1>:                            OpenMP.              (line   6)
-* OpenMP:                                Fortran Dialect Options.
-                                                              (line 109)
-* operators, unary:                      Unary operators.     (line   6)
-* options, code generation:              Code Gen Options.    (line   6)
-* options, debugging:                    Debugging Options.   (line   6)
-* options, dialect:                      Fortran Dialect Options.
-                                                              (line   6)
-* options, directory search:             Directory Options.   (line   6)
-* options, errors:                       Error and Warning Options.
-                                                              (line   6)
-* options, fortran dialect:              Fortran Dialect Options.
-                                                              (line  12)
-* options, gfortran command:             Invoking GNU Fortran.
-                                                              (line   6)
-* options, linking:                      Link Options.        (line   6)
-* options, negative forms:               Invoking GNU Fortran.
-                                                              (line  13)
-* options, preprocessor:                 Preprocessing Options.
-                                                              (line   6)
-* options, run-time:                     Code Gen Options.    (line   6)
-* options, runtime:                      Runtime Options.     (line   6)
-* options, warnings:                     Error and Warning Options.
-                                                              (line   6)
-* OR:                                    OR.                  (line   6)
-* output, newline:                       NEW_LINE.            (line   6)
-* PACK:                                  PACK.                (line   6)
-* paths, search:                         Directory Options.   (line  14)
-* PERROR:                                PERROR.              (line   6)
-* pointer, C address of pointers:        C_F_PROCPOINTER.     (line   6)
-* pointer, C address of procedures:      C_FUNLOC.            (line   6)
-* pointer, C association status:         C_ASSOCIATED.        (line   6)
-* pointer, convert C to Fortran:         C_F_POINTER.         (line   6)
-* pointer, cray <1>:                     MALLOC.              (line   6)
-* pointer, cray:                         FREE.                (line   6)
-* pointer, Cray:                         Cray pointers.       (line   6)
-* pointer, disassociated:                NULL.                (line   6)
-* pointer, status <1>:                   NULL.                (line   6)
-* pointer, status:                       ASSOCIATED.          (line   6)
-* positive difference:                   DIM.                 (line   6)
-* PRECISION:                             PRECISION.           (line   6)
-* Preprocessing:                         Preprocessing and conditional compilation.
-                                                              (line   6)
-* preprocessing, assertation:            Preprocessing Options.
-                                                              (line 114)
-* preprocessing, define macros:          Preprocessing Options.
-                                                              (line 153)
-* preprocessing, include path:           Preprocessing Options.
-                                                              (line  70)
-* preprocessing, keep comments:          Preprocessing Options.
-                                                              (line 123)
-* preprocessing, no linemarkers:         Preprocessing Options.
-                                                              (line 181)
-* preprocessing, undefine macros:        Preprocessing Options.
-                                                              (line 187)
-* preprocessor:                          Preprocessing Options.
-                                                              (line   6)
-* preprocessor, debugging:               Preprocessing Options.
-                                                              (line  26)
-* preprocessor, disable:                 Preprocessing Options.
-                                                              (line  13)
-* preprocessor, enable:                  Preprocessing Options.
-                                                              (line  13)
-* preprocessor, include file handling:   Preprocessing and conditional compilation.
-                                                              (line   6)
-* preprocessor, working directory:       Preprocessing Options.
-                                                              (line  55)
-* PRESENT:                               PRESENT.             (line   6)
-* private:                               Fortran Dialect Options.
-                                                              (line  71)
-* procedure pointer, convert C to Fortran: C_LOC.             (line   6)
-* process id:                            GETPID.              (line   6)
-* PRODUCT:                               PRODUCT.             (line   6)
-* product, double-precision:             DPROD.               (line   6)
-* product, matrix:                       MATMUL.              (line   6)
-* product, vector:                       DOT_PRODUCT.         (line   6)
-* program termination:                   EXIT.                (line   6)
-* program termination, with core dump:   ABORT.               (line   6)
-* PROTECTED statement:                   Fortran 2003 status. (line  37)
-* RADIX:                                 RADIX.               (line   6)
-* RAN:                                   RAN.                 (line   6)
-* RAND:                                  RAND.                (line   6)
-* random number generation <1>:          RANDOM_NUMBER.       (line   6)
-* random number generation <2>:          RAND.                (line   6)
-* random number generation <3>:          RAN.                 (line   6)
-* random number generation:              IRAND.               (line   6)
-* random number generation, seeding <1>: SRAND.               (line   6)
-* random number generation, seeding:     RANDOM_SEED.         (line   6)
-* RANDOM_NUMBER:                         RANDOM_NUMBER.       (line   6)
-* RANDOM_SEED:                           RANDOM_SEED.         (line   6)
-* RANGE:                                 RANGE.               (line   6)
-* range checking:                        Code Gen Options.    (line 130)
-* read character, stream mode <1>:       FGETC.               (line   6)
-* read character, stream mode:           FGET.                (line   6)
-* REAL:                                  REAL.                (line   6)
-* real kind:                             SELECTED_REAL_KIND.  (line   6)
-* real number, exponent:                 EXPONENT.            (line   6)
-* real number, fraction:                 FRACTION.            (line   6)
-* real number, nearest different:        NEAREST.             (line   6)
-* real number, relative spacing <1>:     SPACING.             (line   6)
-* real number, relative spacing:         RRSPACING.           (line   6)
-* real number, scale:                    SCALE.               (line   6)
-* real number, set exponent:             SET_EXPONENT.        (line   6)
-* REALPART:                              REAL.                (line   6)
-* RECORD:                                STRUCTURE and RECORD.
-                                                              (line   6)
-* remainder:                             MOD.                 (line   6)
-* RENAME:                                RENAME.              (line   6)
-* repacking arrays:                      Code Gen Options.    (line 190)
-* REPEAT:                                REPEAT.              (line   6)
-* RESHAPE:                               RESHAPE.             (line   6)
-* root:                                  SQRT.                (line   6)
-* rounding, ceiling <1>:                 CEILING.             (line   6)
-* rounding, ceiling:                     ANINT.               (line   6)
-* rounding, floor <1>:                   FLOOR.               (line   6)
-* rounding, floor:                       AINT.                (line   6)
-* rounding, nearest whole number:        NINT.                (line   6)
-* RRSPACING:                             RRSPACING.           (line   6)
-* RSHIFT:                                RSHIFT.              (line   6)
-* SAVE statement:                        Code Gen Options.    (line  15)
-* SCALE:                                 SCALE.               (line   6)
-* SCAN:                                  SCAN.                (line   6)
-* search path:                           Directory Options.   (line   6)
-* search paths, for included files:      Directory Options.   (line  14)
-* SECNDS:                                SECNDS.              (line   6)
-* SECOND:                                SECOND.              (line   6)
-* seeding a random number generator <1>: SRAND.               (line   6)
-* seeding a random number generator:     RANDOM_SEED.         (line   6)
-* SELECTED_CHAR_KIND:                    SELECTED_CHAR_KIND.  (line   6)
-* SELECTED_INT_KIND:                     SELECTED_INT_KIND.   (line   6)
-* SELECTED_REAL_KIND:                    SELECTED_REAL_KIND.  (line   6)
-* SET_EXPONENT:                          SET_EXPONENT.        (line   6)
-* SHAPE:                                 SHAPE.               (line   6)
-* SHORT:                                 INT2.                (line   6)
-* SIGN:                                  SIGN.                (line   6)
-* sign copying:                          SIGN.                (line   6)
-* SIGNAL:                                SIGNAL.              (line   6)
-* SIN:                                   SIN.                 (line   6)
-* sine:                                  SIN.                 (line   6)
-* sine, hyperbolic:                      SINH.                (line   6)
-* sine, hyperbolic, inverse:             ASINH.               (line   6)
-* sine, inverse:                         ASIN.                (line   6)
-* SINH:                                  SINH.                (line   6)
-* SIZE:                                  SIZE.                (line   6)
-* size of a variable, in bits:           BIT_SIZE.            (line   6)
-* size of an expression <1>:             SIZEOF.              (line   6)
-* size of an expression:                 C_SIZEOF.            (line   6)
-* SIZEOF:                                SIZEOF.              (line   6)
-* SLEEP:                                 SLEEP.               (line   6)
-* SNGL:                                  SNGL.                (line   6)
-* SPACING:                               SPACING.             (line   6)
-* SPREAD:                                SPREAD.              (line   6)
-* SQRT:                                  SQRT.                (line   6)
-* square-root:                           SQRT.                (line   6)
-* SRAND:                                 SRAND.               (line   6)
-* Standards:                             Standards.           (line   6)
-* STAT:                                  STAT.                (line   6)
-* statement, ENUM:                       Fortran 2003 status. (line  20)
-* statement, ENUMERATOR:                 Fortran 2003 status. (line  20)
-* statement, FLUSH:                      Fortran 2003 status. (line  16)
-* statement, IMPORT:                     Fortran 2003 status. (line  43)
-* statement, ISO_FORTRAN_ENV:            Fortran 2003 status. (line  46)
-* statement, PROTECTED:                  Fortran 2003 status. (line  37)
-* statement, SAVE:                       Code Gen Options.    (line  15)
-* statement, USE, INTRINSIC:             Fortran 2003 status. (line  46)
-* statement, VALUE:                      Fortran 2003 status. (line  39)
-* statement, VOLATILE:                   Fortran 2003 status. (line  41)
-* STREAM I/O:                            Fortran 2003 status. (line  32)
-* stream mode, read character <1>:       FGETC.               (line   6)
-* stream mode, read character:           FGET.                (line   6)
-* stream mode, write character <1>:      FPUTC.               (line   6)
-* stream mode, write character:          FPUT.                (line   6)
-* string, adjust left:                   ADJUSTL.             (line   6)
-* string, adjust right:                  ADJUSTR.             (line   6)
-* string, comparison <1>:                LLT.                 (line   6)
-* string, comparison <2>:                LLE.                 (line   6)
-* string, comparison <3>:                LGT.                 (line   6)
-* string, comparison:                    LGE.                 (line   6)
-* string, concatenate:                   REPEAT.              (line   6)
-* string, find missing set:              VERIFY.              (line   6)
-* string, find non-blank character:      LNBLNK.              (line   6)
-* string, find subset:                   SCAN.                (line   6)
-* string, find substring:                INDEX intrinsic.     (line   6)
-* string, length:                        LEN.                 (line   6)
-* string, length, without trailing whitespace: LEN_TRIM.      (line   6)
-* string, remove trailing whitespace:    TRIM.                (line   6)
-* string, repeat:                        REPEAT.              (line   6)
-* STRUCTURE:                             STRUCTURE and RECORD.
-                                                              (line   6)
-* structure packing:                     Code Gen Options.    (line 184)
-* subscript checking:                    Code Gen Options.    (line 130)
-* substring position:                    INDEX intrinsic.     (line   6)
-* SUM:                                   SUM.                 (line   6)
-* sum array elements:                    SUM.                 (line   6)
-* suppressing warnings:                  Error and Warning Options.
-                                                              (line   6)
-* symbol names:                          Fortran Dialect Options.
-                                                              (line  56)
-* symbol names, transforming:            Code Gen Options.    (line  54)
-* symbol names, underscores:             Code Gen Options.    (line  54)
-* SYMLNK:                                SYMLNK.              (line   6)
-* syntax checking:                       Error and Warning Options.
-                                                              (line  33)
-* SYSTEM:                                SYSTEM.              (line   6)
-* system, error handling <1>:            PERROR.              (line   6)
-* system, error handling <2>:            IERRNO.              (line   6)
-* system, error handling:                GERROR.              (line   6)
-* system, group id:                      GETGID.              (line   6)
-* system, host name:                     HOSTNM.              (line   6)
-* system, login name:                    GETLOG.              (line   6)
-* system, process id:                    GETPID.              (line   6)
-* system, signal handling:               SIGNAL.              (line   6)
-* system, system call:                   SYSTEM.              (line   6)
-* system, terminal <1>:                  TTYNAM.              (line   6)
-* system, terminal:                      ISATTY.              (line   6)
-* system, user id:                       GETUID.              (line   6)
-* system, working directory <1>:         GETCWD.              (line   6)
-* system, working directory:             CHDIR.               (line   6)
-* SYSTEM_CLOCK:                          SYSTEM_CLOCK.        (line   6)
-* tabulators:                            Error and Warning Options.
-                                                              (line 140)
-* TAN:                                   TAN.                 (line   6)
-* tangent:                               TAN.                 (line   6)
-* tangent, hyperbolic:                   TANH.                (line   6)
-* tangent, hyperbolic, inverse:          ATANH.               (line   6)
-* tangent, inverse <1>:                  ATAN2.               (line   6)
-* tangent, inverse:                      ATAN.                (line   6)
-* TANH:                                  TANH.                (line   6)
-* terminate program:                     EXIT.                (line   6)
-* terminate program, with core dump:     ABORT.               (line   6)
-* TIME:                                  TIME.                (line   6)
-* time, clock ticks <1>:                 SYSTEM_CLOCK.        (line   6)
-* time, clock ticks <2>:                 MCLOCK8.             (line   6)
-* time, clock ticks:                     MCLOCK.              (line   6)
-* time, conversion to GMT info:          GMTIME.              (line   6)
-* time, conversion to local time info:   LTIME.               (line   6)
-* time, conversion to string:            CTIME.               (line   6)
-* time, current <1>:                     TIME8.               (line   6)
-* time, current <2>:                     TIME.                (line   6)
-* time, current <3>:                     ITIME.               (line   6)
-* time, current <4>:                     FDATE.               (line   6)
-* time, current:                         DATE_AND_TIME.       (line   6)
-* time, elapsed <1>:                     SECOND.              (line   6)
-* time, elapsed <2>:                     SECNDS.              (line   6)
-* time, elapsed <3>:                     ETIME.               (line   6)
-* time, elapsed <4>:                     DTIME.               (line   6)
-* time, elapsed:                         CPU_TIME.            (line   6)
-* TIME8:                                 TIME8.               (line   6)
-* TINY:                                  TINY.                (line   6)
-* TR 15581:                              Fortran 2003 status. (line  25)
-* trace:                                 Debugging Options.   (line  31)
-* TRAILZ:                                TRAILZ.              (line   6)
-* TRANSFER:                              TRANSFER.            (line   6)
-* transforming symbol names:             Code Gen Options.    (line  54)
-* transpose:                             TRANSPOSE.           (line   6)
-* TRANSPOSE:                             TRANSPOSE.           (line   6)
-* trigonometric function, cosine:        COS.                 (line   6)
-* trigonometric function, cosine, inverse: ACOS.              (line   6)
-* trigonometric function, sine:          SIN.                 (line   6)
-* trigonometric function, sine, inverse: ASIN.                (line   6)
-* trigonometric function, tangent:       TAN.                 (line   6)
-* trigonometric function, tangent, inverse <1>: ATAN2.        (line   6)
-* trigonometric function, tangent, inverse: ATAN.             (line   6)
-* TRIM:                                  TRIM.                (line   6)
-* TTYNAM:                                TTYNAM.              (line   6)
-* type cast:                             TRANSFER.            (line   6)
-* UBOUND:                                UBOUND.              (line   6)
-* UMASK:                                 UMASK.               (line   6)
-* underflow:                             Error and Warning Options.
-                                                              (line 148)
-* underscore:                            Code Gen Options.    (line  54)
-* UNLINK:                                UNLINK.              (line   6)
-* UNPACK:                                UNPACK.              (line   6)
-* unused parameter:                      Error and Warning Options.
-                                                              (line 158)
-* USE, INTRINSIC statement:              Fortran 2003 status. (line  46)
-* user id:                               GETUID.              (line   6)
-* VALUE statement:                       Fortran 2003 status. (line  39)
-* vector product:                        DOT_PRODUCT.         (line   6)
-* VERIFY:                                VERIFY.              (line   6)
-* VOLATILE statement:                    Fortran 2003 status. (line  41)
-* warnings, aliasing:                    Error and Warning Options.
-                                                              (line  68)
-* warnings, alignment of COMMON blocks:  Error and Warning Options.
-                                                              (line 165)
-* warnings, all:                         Error and Warning Options.
-                                                              (line  61)
-* warnings, ampersand:                   Error and Warning Options.
-                                                              (line  85)
-* warnings, array temporaries:           Error and Warning Options.
-                                                              (line  93)
-* warnings, character truncation:        Error and Warning Options.
-                                                              (line  98)
-* warnings, conversion:                  Error and Warning Options.
-                                                              (line 104)
-* warnings, implicit interface:          Error and Warning Options.
-                                                              (line 107)
-* warnings, intrinsic:                   Error and Warning Options.
-                                                              (line 152)
-* warnings, intrinsics of other standards: Error and Warning Options.
-                                                              (line 113)
-* warnings, line truncation:             Error and Warning Options.
-                                                              (line 101)
-* warnings, non-standard intrinsics:     Error and Warning Options.
-                                                              (line 113)
-* warnings, suppressing:                 Error and Warning Options.
-                                                              (line   6)
-* warnings, suspicious code:             Error and Warning Options.
-                                                              (line 120)
-* warnings, tabs:                        Error and Warning Options.
-                                                              (line 140)
-* warnings, to errors:                   Error and Warning Options.
-                                                              (line 171)
-* warnings, underflow:                   Error and Warning Options.
-                                                              (line 148)
-* warnings, unused parameter:            Error and Warning Options.
-                                                              (line 158)
-* write character, stream mode <1>:      FPUTC.               (line   6)
-* write character, stream mode:          FPUT.                (line   6)
-* XOR:                                   XOR.                 (line   6)
-* ZABS:                                  ABS.                 (line   6)
-* ZCOS:                                  COS.                 (line   6)
-* zero bits <1>:                         TRAILZ.              (line   6)
-* zero bits:                             LEADZ.               (line   6)
-* ZEXP:                                  EXP.                 (line   6)
-* ZLOG:                                  LOG.                 (line   6)
-* ZSIN:                                  SIN.                 (line   6)
-* ZSQRT:                                 SQRT.                (line   6)
-
-
-
-Tag Table:
-Node: Top1990
-Node: Introduction3305
-Node: About GNU Fortran4052
-Node: GNU Fortran and GCC8080
-Node: Preprocessing and conditional compilation10192
-Node: GNU Fortran and G7711833
-Node: Project Status12406
-Node: Standards14921
-Node: Invoking GNU Fortran16132
-Node: Option Summary17855
-Node: Fortran Dialect Options21343
-Node: Preprocessing Options28153
-Node: Error and Warning Options36279
-Node: Debugging Options43706
-Node: Directory Options45869
-Node: Link Options47384
-Node: Runtime Options48008
-Node: Code Gen Options50088
-Node: Environment Variables62313
-Node: Runtime62918
-Node: GFORTRAN_STDIN_UNIT64146
-Node: GFORTRAN_STDOUT_UNIT64513
-Node: GFORTRAN_STDERR_UNIT64914
-Node: GFORTRAN_USE_STDERR65312
-Node: GFORTRAN_TMPDIR65757
-Node: GFORTRAN_UNBUFFERED_ALL66198
-Node: GFORTRAN_UNBUFFERED_PRECONNECTED66721
-Node: GFORTRAN_SHOW_LOCUS67363
-Node: GFORTRAN_OPTIONAL_PLUS67857
-Node: GFORTRAN_DEFAULT_RECL68332
-Node: GFORTRAN_LIST_SEPARATOR68823
-Node: GFORTRAN_CONVERT_UNIT69432
-Node: GFORTRAN_ERROR_DUMPCORE72294
-Node: GFORTRAN_ERROR_BACKTRACE72841
-Node: Fortran 2003 and 2008 status73392
-Node: Fortran 2003 status73632
-Node: Fortran 2008 status75323
-Node: Compiler Characteristics76292
-Node: KIND Type Parameters76630
-Node: Extensions77557
-Node: Extensions implemented in GNU Fortran78156
-Node: Old-style kind specifications79490
-Node: Old-style variable initialization80596
-Node: Extensions to namelist81908
-Node: X format descriptor without count field83904
-Node: Commas in FORMAT specifications84431
-Node: Missing period in FORMAT specifications84948
-Node: I/O item lists85510
-Node: BOZ literal constants85899
-Node: Real array indices88468
-Node: Unary operators88765
-Node: Implicitly convert LOGICAL and INTEGER values89179
-Node: Hollerith constants support90139
-Node: Cray pointers91911
-Node: CONVERT specifier97321
-Node: OpenMP99319
-Node: Argument list functions101574
-Node: Extensions not implemented in GNU Fortran103168
-Node: STRUCTURE and RECORD104020
-Node: ENCODE and DECODE statements106076
-Node: Intrinsic Procedures107394
-Node: Introduction to Intrinsics121084
-Node: ABORT123436
-Node: ABS124193
-Node: ACCESS125695
-Node: ACHAR127616
-Node: ACOS128817
-Node: ACOSH129815
-Node: ADJUSTL130692
-Node: ADJUSTR131633
-Node: AIMAG132580
-Node: AINT133900
-Node: ALARM135372
-Node: ALL137006
-Node: ALLOCATED138924
-Node: AND139805
-Node: ANINT141102
-Node: ANY142465
-Node: ASIN144395
-Node: ASINH145407
-Node: ASSOCIATED146289
-Node: ATAN149294
-Node: ATAN2150183
-Node: ATANH151527
-Node: BESSEL_J0152407
-Node: BESSEL_J1153451
-Node: BESSEL_JN154503
-Node: BESSEL_Y0155670
-Node: BESSEL_Y1156670
-Node: BESSEL_YN157670
-Node: BIT_SIZE158887
-Node: BTEST159716
-Node: C_ASSOCIATED160604
-Node: C_FUNLOC161813
-Node: C_F_PROCPOINTER163182
-Node: C_F_POINTER164811
-Node: C_LOC166229
-Node: C_SIZEOF167346
-Node: CEILING168699
-Node: CHAR169704
-Node: CHDIR170768
-Node: CHMOD171936
-Node: CMPLX173731
-Node: COMMAND_ARGUMENT_COUNT175195
-Node: COMPLEX176102
-Node: CONJG177245
-Node: COS178255
-Node: COSH179526
-Node: COUNT180495
-Node: CPU_TIME182351
-Node: CSHIFT183705
-Node: CTIME185361
-Node: DATE_AND_TIME186620
-Node: DBLE189081
-Node: DCMPLX189905
-Node: DFLOAT191099
-Node: DIGITS191793
-Node: DIM192759
-Node: DOT_PRODUCT193902
-Node: DPROD195558
-Node: DREAL196284
-Node: DTIME196948
-Node: EOSHIFT199754
-Node: EPSILON201827
-Node: ERF202553
-Node: ERFC203327
-Node: ERFC_SCALED204131
-Node: ETIME204823
-Node: EXIT207054
-Node: EXP207913
-Node: EXPONENT209071
-Node: FDATE209821
-Node: FLOAT211096
-Node: FGET211810
-Node: FGETC213604
-Node: FLOOR215372
-Node: FLUSH216356
-Node: FNUM216994
-Node: FPUT217716
-Node: FPUTC219317
-Node: FRACTION221057
-Node: FREE221958
-Node: FSEEK222795
-Node: FSTAT225089
-Node: FTELL226129
-Node: GAMMA227107
-Node: GERROR228148
-Node: GETARG228867
-Node: GET_COMMAND230631
-Node: GET_COMMAND_ARGUMENT231577
-Node: GETCWD233545
-Node: GETENV234491
-Node: GET_ENVIRONMENT_VARIABLE235713
-Node: GETGID237413
-Node: GETLOG237948
-Node: GETPID238806
-Node: GETUID239534
-Node: GMTIME240048
-Node: HOSTNM241537
-Node: HUGE242453
-Node: HYPOT243172
-Node: IACHAR243992
-Node: IAND245172
-Node: IARGC246159
-Node: IBCLR247182
-Node: IBITS247843
-Node: IBSET248758
-Node: ICHAR249414
-Node: IDATE251395
-Node: IEOR252422
-Node: IERRNO253298
-Node: INDEX intrinsic253853
-Node: INT255199
-Node: INT2256786
-Node: INT8257551
-Node: IOR258263
-Node: IRAND259113
-Node: IS_IOSTAT_END260465
-Node: IS_IOSTAT_EOR261560
-Node: ISATTY262685
-Node: ISHFT263468
-Node: ISHFTC264448
-Node: ISNAN265664
-Node: ITIME266412
-Node: KILL267437
-Node: KIND268310
-Node: LBOUND269155
-Node: LEADZ270467
-Node: LEN271271
-Node: LEN_TRIM272362
-Node: LGE273350
-Node: LGT274663
-Node: LINK275940
-Node: LLE276975
-Node: LLT278279
-Node: LNBLNK279549
-Node: LOC280325
-Node: LOG281056
-Node: LOG10282347
-Node: LOG_GAMMA283319
-Node: LOGICAL284407
-Node: LONG285211
-Node: LSHIFT285967
-Node: LSTAT286921
-Node: LTIME288075
-Node: MALLOC289490
-Node: MATMUL290950
-Node: MAX292040
-Node: MAXEXPONENT293539
-Node: MAXLOC294355
-Node: MAXVAL296404
-Node: MCLOCK298067
-Node: MCLOCK8299070
-Node: MERGE300284
-Node: MIN301026
-Node: MINEXPONENT302522
-Node: MINLOC303152
-Node: MINVAL305201
-Node: MOD306883
-Node: MODULO308375
-Node: MOVE_ALLOC309589
-Node: MVBITS310613
-Node: NEAREST311672
-Node: NEW_LINE312795
-Node: NINT313566
-Node: NOT314834
-Node: NULL315417
-Node: OR316315
-Node: PACK317593
-Node: PERROR319585
-Node: PRECISION320207
-Node: PRESENT321033
-Node: PRODUCT322139
-Node: RADIX323664
-Node: RAN324441
-Node: RAND324897
-Node: RANDOM_NUMBER326232
-Node: RANDOM_SEED327950
-Node: RANGE329833
-Node: REAL330457
-Node: RENAME331899
-Node: REPEAT332918
-Node: RESHAPE333644
-Node: RRSPACING335113
-Node: RSHIFT335806
-Node: SCALE336768
-Node: SCAN337542
-Node: SECNDS339092
-Node: SECOND340180
-Node: SELECTED_CHAR_KIND341056
-Node: SELECTED_INT_KIND342053
-Node: SELECTED_REAL_KIND343228
-Node: SET_EXPONENT345167
-Node: SHAPE346163
-Node: SIGN347276
-Node: SIGNAL348359
-Node: SIN349856
-Node: SINH350898
-Node: SIZE351710
-Node: SIZEOF353018
-Node: SLEEP354312
-Node: SNGL354869
-Node: SPACING355540
-Node: SPREAD356552
-Node: SQRT357697
-Node: SRAND358936
-Node: STAT360104
-Node: SUM363216
-Node: SYMLNK364685
-Node: SYSTEM365817
-Node: SYSTEM_CLOCK366765
-Node: TAN368109
-Node: TANH368945
-Node: TIME369812
-Node: TIME8370916
-Node: TINY372053
-Node: TRAILZ372653
-Node: TRANSFER373438
-Node: TRANSPOSE375472
-Node: TRIM376159
-Node: TTYNAM377016
-Node: UBOUND377931
-Node: UMASK379300
-Node: UNLINK379855
-Node: UNPACK380832
-Node: VERIFY382120
-Node: XOR383836
-Node: Intrinsic Modules385144
-Node: Contributing390935
-Node: Contributors391787
-Node: Projects393410
-Node: Proposed Extensions394213
-Node: Copying396264
-Node: GNU Free Documentation License433828
-Node: Funding456240
-Node: Option Index458765
-Node: Keyword Index470647
-
-End Tag Table
diff -Nur a/gcc/function.c b/gcc/function.c
--- a/gcc/function.c	2009-07-11 21:06:26.000000000 +0200
+++ b/gcc/function.c	2010-01-25 09:50:29.135686643 +0100
@@ -272,7 +272,10 @@
   if (! type)
     type = lang_hooks.types.type_for_mode (mode, 0);
 
-  return STACK_SLOT_ALIGNMENT (type, mode, alignment);
+  return alignment_for_aligned_arrays (type,
+				       STACK_SLOT_ALIGNMENT (type,
+							     mode,
+							     alignment));
 }
 
 /* Allocate a stack slot of SIZE bytes and return a MEM rtx for it
@@ -5359,6 +5362,57 @@
 {
   return IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (cfun->decl));
 }
+
+/* This function adjusts alignments as appropriate according to the
+   setting of -falign-arrays.  If that is specified then the minimum
+   alignment for array variables is set to be the largest power of two
+   less than or equal to their total storage size, or the biggest
+   alignment used on the machine, whichever is smaller.  */
+
+unsigned int
+alignment_for_aligned_arrays (tree ty, unsigned int existing_alignment)
+{
+  unsigned int min_alignment;
+  tree size;
+
+  /* Return the existing alignment if not using -falign-arrays or if
+     the type is not an array type.  */
+  if (!flag_align_arrays || !ty || TREE_CODE (ty) != ARRAY_TYPE)
+    return existing_alignment;
+
+  /* Extract the total storage size of the array in bits.  */
+  size = TYPE_SIZE (ty);
+  gcc_assert (size);
+
+  /* At least for variable-length arrays, TREE_CODE (size) might not be an
+     integer constant; check it now.  If it is not, give the array at
+     least BIGGEST_ALIGNMENT just to be safe.   Furthermore, we assume that
+     alignments always fit into a host integer.  So if we can't fit the
+     size of the array in bits into a host integer, it must also be large
+     enough to deserve at least BIGGEST_ALIGNMENT (see below).  */
+  if (TREE_CODE (size) != INTEGER_CST || !host_integerp (size, 1))
+    min_alignment = BIGGEST_ALIGNMENT;
+  else
+    {
+      unsigned HOST_WIDE_INT bits = TREE_INT_CST_LOW (size);
+      bits = (bits ? bits : 1);
+
+      /* An array with size greater than BIGGEST_ALIGNMENT is assigned
+	 at least that alignment.  In all other cases the minimum
+	 alignment of the array is set to be the largest power of two
+	 less than or equal to the total storage size of the array.
+	 We assume that BIGGEST_ALIGNMENT fits in "unsigned int"; thus,
+	 the shift below will not overflow.  */
+      if (bits >= BIGGEST_ALIGNMENT)
+	min_alignment = BIGGEST_ALIGNMENT;
+      else
+	min_alignment = 1 << (floor_log2 (bits));
+    }
+
+  /* Having computed the minimum permissible alignment, enlarge it
+     if EXISTING_ALIGNMENT is greater.  */
+  return MAX (min_alignment, existing_alignment); 
+}
 
 
 static unsigned int
diff -Nur a/gcc/function.h b/gcc/function.h
--- a/gcc/function.h	2009-03-23 17:29:33.000000000 +0100
+++ b/gcc/function.h	2010-01-25 09:50:29.135686643 +0100
@@ -25,6 +25,7 @@
 #include "tree.h"
 #include "hashtab.h"
 #include "varray.h"
+#include "hard-reg-set.h"
 
 /* Stack of pending (incomplete) sequences saved by `start_sequence'.
    Each element describes one pending sequence.
@@ -441,6 +442,8 @@
 
   /* True if dbr_schedule has already been called for this function.  */
   bool dbr_scheduled_p;
+
+  HARD_REG_SET asm_clobbers;
 };
 
 #define return_label (crtl->x_return_label)
@@ -687,4 +690,7 @@
 extern void used_types_insert (tree);
 
 extern int get_next_funcdef_no (void);
+
+extern unsigned int alignment_for_aligned_arrays (tree, unsigned int);
+
 #endif  /* GCC_FUNCTION_H */
diff -Nur a/gcc/gcc.c b/gcc/gcc.c
--- a/gcc/gcc.c	2009-03-17 22:25:59.000000000 +0100
+++ b/gcc/gcc.c	2010-01-25 09:50:29.135686643 +0100
@@ -83,6 +83,13 @@
 #include "gcc.h"
 #include "flags.h"
 #include "opts.h"
+#ifdef CSL_LICENSE_FEATURE
+#  include <csl/license.h>
+#else
+   /* TARGET_FLEXLM requires the CodeSourcery license library be
+      present.  */
+#  undef TARGET_FLEXLM
+#endif
 
 /* By default there is no special suffix for target executables.  */
 /* FIXME: when autoconf is fixed, remove the host check - dj */
@@ -229,6 +236,37 @@
 
 static int use_pipes;
 
+/* Nonzero means that libgcc is being linked automatically by the
+   compiler from its normal installed location; that is, neither -B,
+   -nostdlib nor -nodefaultlibs was passed.  */
+
+static int using_libgcc = 1;
+
+/* Nonzero means that the current spec is executing the linker.  */
+
+static int executing_linker = 0;
+
+#ifdef CSL_LICENSE_FEATURE
+/* 0 if we have not checked for a license, 1 if a license was
+   obtained, -1 if license checkout failed.  */
+   
+static int license_checked;
+
+# ifdef TARGET_FLEXLM
+/* WRS LOCAL
+   Nonzero means to pay attention to the result of the license manager.  */
+
+static int license_me_flag;
+
+/* WRS LOCAL
+   True if the -p option should be passed to the get_feature command.  */
+
+static int feature_proxy_flag = 1;
+# else
+#  define license_me_flag 1
+# endif /* defined (TARGET_FLELM) */
+#endif /* defined (CSL_LICENSE_FEATURE) */
+
 /* The compiler version.  */
 
 static const char *compiler_version;
@@ -651,8 +689,32 @@
 
 /* config.h can define SWITCHES_NEED_SPACES to control which options
    require spaces between the option and the argument.  */
+/* GCC Bugzilla PR11810 indicates that GCC does not correctly handle
+   "-ofoo.o", in that it records "-ofoo.o" as a temporary file to
+   delete, rather than "foo.o".  
+
+   Unfortunately, Eclipse's makefile generators use the "-ofoo.o"
+   form.  See also CS Issue #3433.  So, although most users probably
+   use "-o foo.o", the "-ofoo.o" form is used in practice.
+
+   See this email thread for additional information:
+
+     http://gcc.gnu.org/ml/gcc/2008-07/msg00395.html
+
+   Therefore, we define SWITCHES_NEED_SPACES to include "o" by
+   default.  This causes "-ofoo.o" to be split into "-o foo.o" during
+   the initial processing of the command-line, before being seen by
+   the specs machinery.
+ 
+   A risk of this change is that tools which *require* the "-ofoo.o"
+   form will no longer work.  However, we know of no such tools, and
+   they would not have worked with the "-o foo.o" form anyhow.  
+
+   If this general strategy is acceptable upstream, the best approach
+   might be simply to eliminate this macro, since the only definitions
+   in target files are also to the value "o".  */
 #ifndef SWITCHES_NEED_SPACES
-#define SWITCHES_NEED_SPACES ""
+#define SWITCHES_NEED_SPACES "o"
 #endif
 
 /* config.h can define ENDFILE_SPEC to override the default crtn files.  */
@@ -728,6 +790,8 @@
 %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
     %(linker) %l " LINK_PIE_SPEC "%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\
     %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\
+    %{Wno-poison-system-directories:--no-poison-system-directories}\
+    %{Werror=poison-system-directories:--error-poison-system-directories}\
     %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\
     %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)} %(mflib)\
     %{fprofile-arcs|fprofile-generate|coverage:-lgcov}\
@@ -882,7 +946,7 @@
 #endif
 
 static const char *const driver_self_specs[] = {
-  DRIVER_SELF_SPECS, GOMP_SELF_SPECS
+  DRIVER_SELF_SPECS, CONFIGURE_SPECS, GOMP_SELF_SPECS
 };
 
 #ifndef OPTION_DEFAULT_SPECS
@@ -2853,6 +2917,29 @@
 
   gcc_assert (!processing_spec_function);
 
+  if (executing_linker && using_libgcc)
+    {
+      const char *libgcc_a_filename;
+
+      /* Verify that the multilib being used is actually installed.  */
+      libgcc_a_filename = (gcc_exec_prefix
+			   ? gcc_exec_prefix
+			   : concat (standard_exec_prefix,
+				     machine_suffix, NULL));
+      if (multilib_dir && strcmp (multilib_dir, ".") != 0)
+	libgcc_a_filename = concat (libgcc_a_filename, multilib_dir,
+				    dir_separator_str, NULL);
+      libgcc_a_filename = concat (libgcc_a_filename, "libgcc.a", NULL);
+      if (access (libgcc_a_filename, R_OK) != 0)
+	{
+	  if (errno == ENOENT)
+	    fatal ("selected multilib '%s' not installed",
+		   multilib_dir ? multilib_dir : ".");
+	  else
+	    pfatal_with_name (libgcc_a_filename);
+	}
+    }
+
   if (wrapper_string)
     {
       string = find_a_file (&exec_prefixes, argbuf[0], X_OK, false);
@@ -3688,6 +3775,16 @@
 	  add_assembler_option ("--target-help", 13);
 	  add_linker_option ("--target-help", 13);
 	}
+      else if (! strcmp (argv[i], "-nodefaultlibs"))
+	{
+	  using_libgcc = 0;
+	  n_switches++;
+	}
+      else if (! strcmp (argv[i], "-nostdlib"))
+	{
+	  using_libgcc = 0;
+	  n_switches++;
+	}
       else if (! strcmp (argv[i], "-pass-exit-codes"))
 	{
 	  pass_exit_codes = 1;
@@ -3852,6 +3949,14 @@
 	  verbose_only_flag++;
 	  verbose_flag++;
 	}
+#ifdef TARGET_FLEXLM
+      else if (strcmp (argv[i], "-flicense-me") == 0)
+	license_me_flag = 1;  /* WRS LOCAL */
+      else if (strcmp (argv[i], "-ffeature-proxy") == 0)
+	feature_proxy_flag = 1;  /* WRS LOCAL */
+      else if (strcmp (argv[i], "-fno-feature-proxy") == 0)
+	feature_proxy_flag = 0;  /* WRS LOCAL */
+#endif
       else if (argv[i][0] == '-' && argv[i][1] != 0)
 	{
 	  const char *p = &argv[i][1];
@@ -3905,6 +4010,7 @@
 			    PREFIX_PRIORITY_B_OPT, 0, 0);
 		add_prefix (&include_prefixes, value, NULL,
 			    PREFIX_PRIORITY_B_OPT, 0, 0);
+		using_libgcc = 0;
 		n_switches++;
 	      }
 	      break;
@@ -3967,6 +4073,21 @@
 #endif
 	      goto normal_switch;
 
+	      /* WRS LOCAL only invoke get_feature if we are running
+		 the compiler proper.  */
+#ifdef TARGET_FLEXLM
+	    case 'E':
+	      if (argv[i][2] == '\0')
+	        license_checked = 1;
+	      goto normal_switch;
+
+	    case 'M':
+	      if (argv[i][2] == '\0'
+		  || (argv[i][2] == 'M' && argv[i][3] == '\0'))
+		license_checked = 1;
+	      goto normal_switch;
+#endif
+
 	    default:
 	    normal_switch:
 
@@ -4153,6 +4274,14 @@
 	;
       else if (! strcmp (argv[i], "-print-sysroot-headers-suffix"))
 	;
+#ifdef TARGET_FLEXLM
+      else if (! strcmp (argv[i], "-flicense-me"))
+	;
+      else if (! strcmp (argv[i], "-ffeature-proxy"))
+	;
+      else if (! strcmp (argv[i], "-fno-feature-proxy"))
+	;
+#endif
       else if (! strncmp (argv[i], "--sysroot=", strlen ("--sysroot=")))
 	{
 	  target_system_root = argv[i] + strlen ("--sysroot=");
@@ -4616,27 +4745,53 @@
 
   if (argbuf_index > 0)
     {
-      int i, first;
+      int i, first, n;
 
       first = n_switches;
-      n_switches += argbuf_index;
-      switches = XRESIZEVEC (struct switchstr, switches, n_switches + 1);
+      n = n_switches + argbuf_index;
+      switches = XRESIZEVEC (struct switchstr, switches, n + 1);
+      switches[n] = switches[first];
 
       switches[n_switches] = switches[first];
       for (i = 0; i < argbuf_index; i++)
 	{
 	  struct switchstr *sw;
+	  const char *p = &argbuf[i][1];
+	  int c = *p;
 
 	  /* Each switch should start with '-'.  */
 	  if (argbuf[i][0] != '-')
 	    fatal ("switch '%s' does not start with '-'", argbuf[i]);
 
-	  sw = &switches[i + first];
+	  sw = &switches[n_switches];
 	  sw->part1 = &argbuf[i][1];
 	  sw->args = 0;
 	  sw->live_cond = 0;
 	  sw->validated = 0;
 	  sw->ordering = 0;
+
+	  /* Deal with option arguments in separate argv elements.  */
+	  if ((SWITCH_TAKES_ARG (c) > (p[1] != 0))
+	      || WORD_SWITCH_TAKES_ARG (p))
+	    {
+	      int j = 0;
+	      int n_args = WORD_SWITCH_TAKES_ARG (p);
+
+	      if (n_args == 0)
+		{
+		  /* Count only the option arguments in separate argv elements.  */
+		  n_args = SWITCH_TAKES_ARG (c) - (p[1] != 0);
+		}
+	      if (i + n_args >= argbuf_index)
+		fatal ("argument to '-%s' is missing", p);
+	      switches[n_switches].args
+		= XNEWVEC (const char *, n_args + 1);
+	      while (j < n_args)
+		switches[n_switches].args[j++] = argbuf[++i];
+	      /* Null-terminate the vector.  */
+	      switches[n_switches].args[j] = 0;
+	    }
+	  n_switches++;
 	}
     }
 }
@@ -6225,6 +6380,10 @@
   const char *p;
   struct user_specs *uptr;
   char **old_argv = argv;
+#ifdef CSL_LICENSE_FEATURE
+  csl_license_impl *license_impl = csl_license_subproc;
+  csl_license *license = NULL;
+#endif
 
   /* Initialize here, not in definition.  The IRIX 6 O32 cc sometimes chokes
      on ?: in file-scope variable initializations.  */
@@ -6792,10 +6951,84 @@
 	    }
 	  else
 	    {
-	      value = do_spec (input_file_compiler->spec);
+	      value = 0;
+
+#ifdef CSL_LICENSE_FEATURE
+	      if (!license_checked)
+		{
+		  const char *subproc, *found_subproc;
+# ifdef TARGET_FLEXLM
+		  const char *subproc_argv[10];
+		  const char **p;
+		  subproc = "get_feature";
+		  p = subproc_argv;
+		  *p++ = subproc;
+		  if (feature_proxy_flag)
+		    *p++ = "-p";
+		  *p++ = "-co";
+		  *p++ = xstrdup (DEFAULT_TARGET_MACHINE);
+		  *p++ = "-v";
+		  *p++ = "3.3";
+		  *p++ = "gnu";
+		  *p++ = infiles[i].language;
+		  *p++ = (license_me_flag ? "-flicense-me" : "");
+		  *p++ = 0;
+# else /* !defined (TARGET_FLEXLM) */
+		  const char **subproc_argv = NULL;
+		  subproc = CSL_LICENSE_PROG;
+# endif /* !defined (TARGET_FLEXLM) */
+		  /* Find the licensing program.  */
+		  found_subproc = find_a_file (&exec_prefixes, 
+					       subproc,
+					       X_OK,
+					       /*multilib=*/false);
+		  if (found_subproc)
+		    subproc = found_subproc;
+		  /* Begin checking out the license.  */
+		  license 
+		    = csl_subproc_license_new (CSL_LICENSE_FEATURE,
+					       CSL_LICENSE_VERSION,
+					       /*argcp=*/NULL,
+					       /*argvp=*/NULL,
+					       subproc,
+					       subproc_argv);
+		  if (!license)
+		    {
+		      error ("could not invoke license program");
+		      license_checked = -1;
+		    }
+		}
+	      if (license_checked == -1 && license_me_flag)
+		value = -1;
+#endif /* defined (CSL_LICENSE_FEATURE) */ 
+	      /* Now do the compile.  */
+	      if (!value)
+		value = do_spec (input_file_compiler->spec);
 	      infiles[i].compiled = true;
 	      if (value < 0)
 		this_file_error = 1;
+#ifdef CSL_LICENSE_FEATURE
+	      if (!license_checked && license)
+		{
+		  /* Finish checking out the license.  */
+		  const csl_license_status *license_status;
+		  if  (!license_impl->license_check (license,
+						     &license_status))
+		    {
+		      if (license_me_flag) /* WRS LOCAL */
+			error ("%s", license_status->msg);
+		      /* Remember that the license check failed so
+			 that we (a) do not check again, and (b) issue
+			 errors about other files as well.  */
+		      license_checked = -1;
+		      if (license_me_flag) /* WRS LOCAL */
+			/* Remove this file.  */
+			this_file_error = 1;
+		    }
+		  else
+		    license_checked = 1;
+		}
+#endif /* defined (CSL_LICENSE_FEATURE) */ 
 	    }
 	}
 
@@ -6873,7 +7106,9 @@
 		    " to the linker.\n\n"));
 	  fflush (stdout);
 	}
+      executing_linker = 1;
       value = do_spec (link_command_spec);
+      executing_linker = 0;
       if (value < 0)
 	error_count = 1;
       linker_was_run = (tmp != execution_count);
@@ -6901,6 +7136,12 @@
       printf ("%s\n", bug_report_url);
     }
 
+#ifdef CSL_LICENSE_FEATURE
+  /* Relinquish the license.  */
+  if (license)
+    license_impl->license_delete (license);
+#endif
+    
   return (signal_count != 0 ? 2
 	  : error_count > 0 ? (pass_exit_codes ? greatest_status : 1)
 	  : 0);
diff -Nur a/gcc/gcse.c b/gcc/gcse.c
--- a/gcc/gcse.c	2009-04-27 13:55:13.000000000 +0200
+++ b/gcc/gcse.c	2010-01-25 09:50:29.145688053 +0100
@@ -172,6 +172,7 @@
 #include "hashtab.h"
 #include "df.h"
 #include "dbgcnt.h"
+#include "target.h"
 
 /* Propagate flow information through back edges and thus enable PRE's
    moving loop invariant calculations out of loops.
@@ -1744,7 +1745,9 @@
 	     REG_EQUIV notes and if the argument slot is used somewhere
 	     explicitly, it means address of parameter has been taken,
 	     so we should not extend the lifetime of the pseudo.  */
-	  && (note == NULL_RTX || ! MEM_P (XEXP (note, 0))))
+	  && (note == NULL_RTX || ! MEM_P (XEXP (note, 0)))
+	  && ! (targetm.cannot_copy_insn_p && INSN_P (insn)
+		&& targetm.cannot_copy_insn_p (insn)))
 	{
 	  /* An expression is not anticipatable if its operands are
 	     modified before this insn or if this is not the only SET in
diff -Nur a/gcc/genautomata.c b/gcc/genautomata.c
--- a/gcc/genautomata.c	2008-09-01 10:57:00.000000000 +0200
+++ b/gcc/genautomata.c	2010-01-25 09:50:29.145688053 +0100
@@ -1,5 +1,5 @@
 /* Pipeline hazard description translator.
-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
    Free Software Foundation, Inc.
 
    Written by Vladimir Makarov <vmakarov@redhat.com>
@@ -22,21 +22,25 @@
 
 /* References:
 
-   1. Detecting pipeline structural hazards quickly. T. Proebsting,
+   1. The finite state automaton based pipeline hazard recognizer and
+      instruction scheduler in GCC.  V. Makarov.  Proceedings of GCC
+      summit, 2003.
+
+   2. Detecting pipeline structural hazards quickly. T. Proebsting,
       C. Fraser. Proceedings of ACM SIGPLAN-SIGACT Symposium on
       Principles of Programming Languages, pages 280--286, 1994.
 
       This article is a good start point to understand usage of finite
       state automata for pipeline hazard recognizers.  But I'd
-      recommend the 2nd article for more deep understanding.
+      recommend the 1st and 3rd article for more deep understanding.
 
-   2. Efficient Instruction Scheduling Using Finite State Automata:
+   3. Efficient Instruction Scheduling Using Finite State Automata:
       V. Bala and N. Rubin, Proceedings of MICRO-28.  This is the best
       article about usage of finite state automata for pipeline hazard
       recognizers.
 
-   The current implementation is different from the 2nd article in the
-   following:
+   The current implementation is described in the 1st article and it
+   is different from the 3rd article in the following:
 
    1. New operator `|' (alternative) is permitted in functional unit
       reservation which can be treated deterministically and
@@ -463,7 +467,10 @@
      insn.  */
   int insn_num;
   /* The following field value is list of bypasses in which given insn
-     is output insn.  */
+     is output insn.  Bypasses with the same input insn stay one after
+     another in the list in the same order as their occurrences in the
+     description but the bypass without a guard stays always the last
+     in a row of bypasses with the same input insn.  */
   struct bypass_decl *bypass_list;
 
   /* The following fields are defined by automaton generator.  */
@@ -2367,18 +2374,67 @@
 }
 
 
-/* The function searches for bypass with given IN_INSN_RESERV in given
-   BYPASS_LIST.  */
-static struct bypass_decl *
-find_bypass (struct bypass_decl *bypass_list,
-	     struct insn_reserv_decl *in_insn_reserv)
-{
-  struct bypass_decl *bypass;
-
-  for (bypass = bypass_list; bypass != NULL; bypass = bypass->next)
-    if (bypass->in_insn_reserv == in_insn_reserv)
-      break;
-  return bypass;
+/* The function inserts BYPASS in the list of bypasses of the
+   corresponding output insn.  The order of bypasses in the list is
+   decribed in a comment for member `bypass_list' (see above).  If
+   there is already the same bypass in the list the function reports
+   this and does nothing.  */
+static void
+insert_bypass (struct bypass_decl *bypass)
+{
+  struct bypass_decl *curr, *last;
+  struct insn_reserv_decl *out_insn_reserv = bypass->out_insn_reserv;
+  struct insn_reserv_decl *in_insn_reserv = bypass->in_insn_reserv;
+  
+  for (curr = out_insn_reserv->bypass_list, last = NULL;
+       curr != NULL;
+       last = curr, curr = curr->next)
+    if (curr->in_insn_reserv == in_insn_reserv)
+      {
+	if ((bypass->bypass_guard_name != NULL
+	     && curr->bypass_guard_name != NULL
+	     && ! strcmp (bypass->bypass_guard_name, curr->bypass_guard_name))
+	    || bypass->bypass_guard_name == curr->bypass_guard_name)
+	  {
+	    if (bypass->bypass_guard_name == NULL)
+	      {
+		if (!w_flag)
+		  error ("the same bypass `%s - %s' is already defined",
+			 bypass->out_insn_name, bypass->in_insn_name);
+		else
+		  warning (0, "the same bypass `%s - %s' is already defined",
+			   bypass->out_insn_name, bypass->in_insn_name);
+	      }
+	    else if (!w_flag)
+	      error ("the same bypass `%s - %s' (guard %s) is already defined",
+		     bypass->out_insn_name, bypass->in_insn_name,
+		     bypass->bypass_guard_name);
+	    else
+	      warning
+		(0, "the same bypass `%s - %s' (guard %s) is already defined",
+		 bypass->out_insn_name, bypass->in_insn_name,
+		 bypass->bypass_guard_name);
+	    return;
+	  }
+	if (curr->bypass_guard_name == NULL)
+	  break;
+	if (curr->next == NULL || curr->next->in_insn_reserv != in_insn_reserv)
+	  {
+	    last = curr;
+	    break;
+	  }
+	  
+      }
+  if (last == NULL)
+    {
+      bypass->next = out_insn_reserv->bypass_list;
+      out_insn_reserv->bypass_list = bypass;
+    }
+  else
+    {
+      bypass->next = last->next;
+      last->next = bypass;
+    }
 }
 
 /* The function processes pipeline description declarations, checks
@@ -2391,7 +2447,6 @@
   decl_t decl_in_table;
   decl_t out_insn_reserv;
   decl_t in_insn_reserv;
-  struct bypass_decl *bypass;
   int automaton_presence;
   int i;
 
@@ -2514,36 +2569,7 @@
 		= DECL_INSN_RESERV (out_insn_reserv);
 	      DECL_BYPASS (decl)->in_insn_reserv
 		= DECL_INSN_RESERV (in_insn_reserv);
-	      bypass
-		= find_bypass (DECL_INSN_RESERV (out_insn_reserv)->bypass_list,
-			       DECL_BYPASS (decl)->in_insn_reserv);
-	      if (bypass != NULL)
-		{
-		  if (DECL_BYPASS (decl)->latency == bypass->latency)
-		    {
-		      if (!w_flag)
-			error
-			  ("the same bypass `%s - %s' is already defined",
-			   DECL_BYPASS (decl)->out_insn_name,
-			   DECL_BYPASS (decl)->in_insn_name);
-		      else
-			warning
-			  (0, "the same bypass `%s - %s' is already defined",
-			   DECL_BYPASS (decl)->out_insn_name,
-			   DECL_BYPASS (decl)->in_insn_name);
-		    }
-		  else
-		    error ("bypass `%s - %s' is already defined",
-			   DECL_BYPASS (decl)->out_insn_name,
-			   DECL_BYPASS (decl)->in_insn_name);
-		}
-	      else
-		{
-		  DECL_BYPASS (decl)->next
-		    = DECL_INSN_RESERV (out_insn_reserv)->bypass_list;
-		  DECL_INSN_RESERV (out_insn_reserv)->bypass_list
-		    = DECL_BYPASS (decl);
-		}
+	      insert_bypass (DECL_BYPASS (decl));
 	    }
 	}
     }
@@ -8159,19 +8185,32 @@
 			    (advance_cycle_insn_decl)->insn_num));
 	    fprintf (output_file, "        case %d:\n",
 		     bypass->in_insn_reserv->insn_num);
-	    if (bypass->bypass_guard_name == NULL)
-	      fprintf (output_file, "          return %d;\n",
-		       bypass->latency);
-	    else
+	    for (;;)
 	      {
-		fprintf (output_file,
-			 "          if (%s (%s, %s))\n",
-			 bypass->bypass_guard_name, INSN_PARAMETER_NAME,
-			 INSN2_PARAMETER_NAME);
-		fprintf (output_file,
-			 "            return %d;\n          break;\n",
-			 bypass->latency);
+		if (bypass->bypass_guard_name == NULL)
+		  {
+		    gcc_assert (bypass->next == NULL
+				|| (bypass->in_insn_reserv
+				    != bypass->next->in_insn_reserv));
+		    fprintf (output_file, "          return %d;\n",
+			     bypass->latency);
+		  }
+		else
+		  {
+		    fprintf (output_file,
+			     "          if (%s (%s, %s))\n",
+			     bypass->bypass_guard_name, INSN_PARAMETER_NAME,
+			     INSN2_PARAMETER_NAME);
+		    fprintf (output_file, "            return %d;\n",
+			     bypass->latency);
+		  }
+		if (bypass->next == NULL
+		    || bypass->in_insn_reserv != bypass->next->in_insn_reserv)
+		  break;
+		bypass = bypass->next;
 	      }
+	    if (bypass->bypass_guard_name != NULL)
+	      fprintf (output_file, "          break;\n");
 	  }
 	fputs ("        }\n      break;\n", output_file);
       }
diff -Nur a/gcc/gengtype-lex.c b/gcc/gengtype-lex.c
--- a/gcc/gengtype-lex.c	2009-07-22 09:46:07.000000000 +0200
+++ b/gcc/gengtype-lex.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2638 +0,0 @@
-#line 2 "gengtype-lex.c"
-
-#line 4 "gengtype-lex.c"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 35
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-#endif /* ! C99 */
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#endif /* ! FLEXINT_H */
-
-#ifdef __cplusplus
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-/* C99 requires __STDC__ to be defined as 1. */
-#if defined (__STDC__)
-
-#define YY_USE_CONST
-
-#endif	/* defined (__STDC__) */
-#endif	/* ! __cplusplus */
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN (yy_start) = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START (((yy_start) - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart(yyin  )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#define YY_BUF_SIZE 16384
-#endif
-
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-extern int yyleng;
-
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-    #define YY_LESS_LINENO(n)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = (yy_hold_char); \
-		YY_RESTORE_YY_MORE_OFFSET \
-		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, (yytext_ptr)  )
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-    
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* Stack of input buffers. */
-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
-                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
-
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 0;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart (FILE *input_file  );
-void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
-void yy_delete_buffer (YY_BUFFER_STATE b  );
-void yy_flush_buffer (YY_BUFFER_STATE b  );
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state (void );
-
-static void yyensure_buffer_stack (void );
-static void yy_load_buffer_state (void );
-static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
-
-#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
-
-YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
-
-void *yyalloc (yy_size_t  );
-void *yyrealloc (void *,yy_size_t  );
-void yyfree (void *  );
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
-
-/* Begin user sect3 */
-
-#define yywrap(n) 1
-#define YY_SKIP_YYWRAP
-
-typedef unsigned char YY_CHAR;
-
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-
-typedef int yy_state_type;
-
-extern int yylineno;
-
-int yylineno = 1;
-
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state (void );
-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
-static int yy_get_next_buffer (void );
-static void yy_fatal_error (yyconst char msg[]  );
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	(yytext_ptr) = yy_bp; \
-	yyleng = (size_t) (yy_cp - yy_bp); \
-	(yy_hold_char) = *yy_cp; \
-	*yy_cp = '\0'; \
-	(yy_c_buf_p) = yy_cp;
-
-#define YY_NUM_RULES 49
-#define YY_END_OF_BUFFER 50
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static yyconst flex_int16_t yy_accept[445] =
-    {   0,
-        0,    0,    0,    0,    0,    0,    0,    0,   50,   36,
-       36,   33,   45,   36,   45,   34,   36,   36,   34,   34,
-       34,   34,   34,   31,   10,   10,   31,   29,   31,   31,
-       31,   20,   31,   31,   31,   31,   31,   31,   31,   31,
-       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
-       31,   10,   31,   41,   39,   46,   46,    0,    0,    0,
-       37,    0,    0,    0,   38,   32,   34,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,   34,   34,   34,   34,
-       34,   10,    0,   25,    0,    0,    0,    0,    9,   20,
-       24,    0,    0,    0,    0,    0,    0,    0,    0,   26,
-
-       11,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,   10,    0,    0,    0,    0,
-       42,   44,   43,    0,   35,    0,    0,    0,    0,    0,
-        0,   34,   34,   34,   34,   34,   34,   27,   28,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,   30,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,   34,   34,   34,   34,   34,   34,
-        0,    0,    0,   13,    0,   14,    0,    0,    0,    0,
-       22,   22,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,   48,    0,    0,    0,    0,    0,    0,
-        0,   34,   34,   34,   34,   34,   34,    0,    0,    0,
-        0,    0,   17,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,   34,
-       34,   34,   34,   34,    3,    0,    0,    0,    0,   12,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,   15,    0,    0,    0,
-        0,    0,    0,    0,   34,    4,    5,    2,   34,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,    0,    0,    0,    0,   16,
-        0,    0,    0,    0,   34,    1,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,   22,   22,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   34,   34,   34,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-       21,    0,    0,    0,    0,    0,    0,   34,    7,    6,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,   18,
-        0,    0,    0,   34,    0,    0,    0,    0,    0,    0,
-        0,    0,   19,    0,    0,   47,   34,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   34,    0,    0,
-
-        0,    0,    0,    0,    0,    0,   34,    0,   24,   24,
-        0,    0,    0,    0,    0,    0,    0,   34,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    8,
-        0,   23,    0,    0,    0,    0,    0,   40,    0,    0,
-        0,    0,    0,    0
-    } ;
-
-static yyconst flex_int32_t yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    1,    4,    5,    1,    6,    1,    7,    8,
-        9,   10,    1,    6,    6,   11,   12,   13,   13,   13,
-       13,   13,   13,   13,   13,   13,   13,    6,    6,    6,
-        6,    6,    1,    1,   14,   15,   16,   17,   18,   19,
-       20,   21,   22,   23,   23,   24,   25,   26,   27,   28,
-       23,   29,   30,   31,   32,   33,   34,   23,   35,   23,
-       36,   37,   38,    1,   39,    1,   40,   41,   42,   43,
-
-       44,   45,   46,   47,   48,   49,   49,   50,   51,   52,
-       53,   54,   49,   55,   56,   57,   58,   59,   49,   60,
-       61,   62,    6,    6,    6,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst flex_int32_t yy_meta[63] =
-    {   0,
-        1,    2,    3,    1,    1,    1,    1,    1,    4,    5,
-        1,    1,    6,    7,    7,    7,    7,    7,    7,    7,
-        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
-        7,    7,    7,    7,    7,    8,    1,    1,    9,    9,
-        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
-        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
-        9,    9
-    } ;
-
-static yyconst flex_int16_t yy_base[483] =
-    {   0,
-        0,   38,   96,   12,   12,   13,   15,   16, 1028, 1444,
-       32,   51,   20,  990, 1016,    0,  157,   18, 1007,  964,
-      966,  961,  969, 1444,   25,   27,   27, 1444,  983, 1008,
-     1008, 1004,  215,  253,    5,   32,   29,  974,   45,  962,
-      996,   35,   38,   39,   40,   41,  134,   42,  136,  137,
-      138,   75,  996,    0, 1444,  985,  984,  166,  964,  162,
-     1444,    0,  987,  990, 1444, 1444,    0,  186,  165,  974,
-      931,  933,  928,  936,  168,  943,  967,  928,  140,  930,
-      935,   87,  167, 1444,  979,  974,  977,  968, 1444,  950,
-     1444,  935,  934,  145,   52,   46,  148,  165,  922, 1444,
-
-     1444,  152,  156,  155,  170,  173,  175,  182,  183,  185,
-      211,  214,  222,  218,  221,  269,  957,  956,  291,    0,
-     1444, 1444, 1444,  922, 1444,  937,  898,  195,  900,  905,
-      907,  912,  906,  892,  890,  903,  893, 1444, 1444,  209,
-      254,  251,  353,  248,  391,  354,  350,  351,  340,  355,
-      341,  429,  339,  356,  344,  347,  360,  390,   43,  361,
-      391,  395,  429, 1444,    0,    0,  280,  906,  900,  886,
-      884,  897,  872,  876,  890,  867,  873,  878,  876,  866,
-      381,  348,  382, 1444,  384, 1444,  389,  397,  491,  398,
-     1444,  528,  418,  399,  420,  477,  478,  422,  421,  480,
-
-      479,    0,  449, 1444,  884,  861,  867,  872,  870,  860,
-      859,  892,  857,  866,  850,  862,  586,  493,  496,  494,
-      484,  624, 1444,    0,  878,  876,  876,  834,  839,  841,
-      832,  830,  199,  830,  490,  499,  486,  492,  488,  489,
-      662,    0,  863,  828,  837,  821,  833,    0,  832,  859,
-      700,  738,  776,  829, 1444,  431,  258,  437,  515, 1444,
-      846,  844,  841,  817,  829,  809,  319,  815,  813,  478,
-      809,  512,  528,  520,  525,  814, 1444,    0,  833,    0,
-        0,    0,  803,  551,  808, 1444, 1444, 1444,  852,  383,
-      521,  530,  539,  822,  829,  813,  793,  787,  802,  801,
-
-      556,  793,  783,  785,  792,  787,  523,  545,  535, 1444,
-        0,  795,    0,  561,  585, 1444,  555,  343,  581,  584,
-      794,  811,  792,  773,  772, 1444,    0,  771,  783,  772,
-      764,  552,  890,  558,    0,  623,  778,  784,  928,  966,
-      583,  593,  594,  613,  792,  792,  771,  761,  746,  591,
-     1444, 1004,    0,  778,    0,    0,  766,  776, 1444, 1444,
-      620,  621,  626,  627,  653,  777,  769,  775, 1042, 1444,
-        0,  772,  787,  767,  556,  577,  615,  649,  629,  762,
-      753,  774, 1444,    0,  763, 1444,  773,  632,  659,  662,
-      656,  654,  754,  742,  753,    0,  754,  729,  665,  688,
-
-      667,  744,  742,  683,    0,  695,  692,  689,  715,  722,
-      699,  711,  701,  666,  673,    0,  705, 1080,  704,  749,
-      751,  753,  756,  663,  658,  618,  593,    0,    0, 1444,
-      758, 1444,  760,  600,  588,  543,  483, 1444,  439,  386,
-      247,  206,  167, 1444, 1118, 1127, 1136, 1145, 1154, 1158,
-     1167, 1176, 1185, 1194, 1202, 1211, 1220, 1229, 1238, 1247,
-     1256, 1265, 1273, 1282, 1290, 1298, 1306, 1314, 1323, 1331,
-     1340, 1349, 1357, 1365, 1374, 1383, 1392, 1400, 1409, 1417,
-     1426, 1435
-    } ;
-
-static yyconst flex_int16_t yy_def[483] =
-    {   0,
-      445,  445,  444,    3,  446,  446,  446,  446,  444,  444,
-      444,  444,  447,  448,  449,  450,  444,  444,  450,  450,
-      450,  450,  450,  444,  444,  444,  451,  444,  452,  444,
-      444,  444,  453,  453,   34,   34,   34,   34,   34,  454,
-      444,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,  444,  455,  456,  444,  457,  457,  444,  444,  447,
-      444,  447,  444,  448,  444,  444,  450,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  450,  450,  450,  450,
-      450,  444,  451,  444,  451,  444,  452,  444,  444,  444,
-      444,   34,   34,   34,   34,   34,   34,   34,  454,  444,
-
-      444,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,  444,  455,  455,  444,  458,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  450,  450,  450,  450,  450,  450,  444,  444,   34,
-       34,   34,  453,   34,  453,   34,   34,   34,   34,   34,
-       34,  453,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,  119,  444,  119,  459,  444,  444,  444,  444,
-      444,  444,  444,  444,  450,  450,  450,  450,  450,  450,
-       34,   34,   34,  444,   34,  444,   34,   34,  453,   34,
-      444,  444,   34,   34,   34,   34,   34,   34,   34,   34,
-
-       34,  460,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  450,  450,  450,  450,  450,  450,   34,   34,   34,
-       34,  453,  444,  192,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,   34,   34,   34,   34,   34,   34,
-      453,  461,  444,  444,  444,  444,  444,  462,  444,  450,
-      450,  450,  450,  450,  444,   34,   34,   34,   34,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,   34,   34,   34,   34,  453,  444,  463,  444,  464,
-      465,  466,  444,  444,  450,  444,  444,  444,  450,   34,
-       34,   34,   34,  444,  444,  444,  444,  444,  444,  444,
-
-      467,  444,  444,  444,  444,  444,   34,   34,   34,  444,
-      468,  444,  469,  444,  450,  444,   34,   34,   34,   34,
-      444,  444,  444,  444,  444,  444,  192,  444,  444,  444,
-      444,   34,  453,   34,  470,  444,  444,  450,  450,  450,
-       34,   34,   34,   34,  444,  444,  444,  444,  444,   34,
-      444,  453,  471,  444,  472,  473,  444,  450,  444,  444,
-       34,   34,   34,   34,   34,  444,  444,  444,  453,  444,
-      474,  444,  444,  450,   34,   34,   34,   34,   34,  444,
-      444,  444,  444,  475,  444,  444,  450,   34,   34,   34,
-       34,   34,  444,  444,  444,  476,  444,  450,   34,   34,
-
-       34,  444,  444,  444,  477,  444,  450,   34,  444,  478,
-       34,  444,  444,  444,  444,  479,  444,  450,   34,  444,
-      478,  478,  480,  444,  444,  444,  444,  481,  482,  444,
-      444,  444,  480,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,    0,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444
-    } ;
-
-static yyconst flex_int16_t yy_nxt[1507] =
-    {   0,
-       10,   11,   12,   13,   10,   10,   14,   10,   10,   10,
-       10,   15,   10,   52,   55,   55,   53,   55,   55,   75,
-      444,   56,   56,   61,   57,   57,   82,   82,   82,   82,
-       84,   92,   94,   58,   58,   10,   10,   10,   10,   17,
-       12,   13,   18,   10,   14,   10,   10,   10,   10,   15,
-       10,   59,   58,   58,   19,   92,   62,   95,   92,   96,
-       76,   92,   98,   85,   92,   92,   92,   92,   92,   92,
-       59,   92,   92,   10,   10,   10,  116,   82,   92,  117,
-      143,   20,  105,  142,  103,  109,  198,  102,   82,   82,
-      104,  106,  107,   21,   22,   23,   24,   25,   26,   27,
-
-       24,   28,   29,   28,   28,   28,   30,   31,   32,   33,
-       34,   35,   33,   36,   33,   37,   38,   33,   33,   33,
-       33,   33,   33,   33,   33,   33,   33,   33,   39,   33,
-       33,   40,   41,   24,   33,   33,   42,   43,   44,   45,
-       33,   33,   33,   46,   33,   47,   33,   48,   33,   49,
-       33,   50,   33,   51,   33,   33,   33,   33,   68,   58,
-       92,   69,   92,   92,   92,   61,   75,   58,   58,   75,
-       84,   92,  141,   70,   92,  110,   59,  144,   92,  134,
-      145,   92,   92,  112,  113,   59,  108,   68,   58,  115,
-       69,   92,  111,  114,  135,  147,   92,  301,   62,   92,
-
-       71,   92,   70,   85,  146,   59,  148,   76,   92,   92,
-       76,   92,   72,   73,   74,   91,   91,   91,   91,   91,
-       91,   91,   91,   91,   91,   91,   91,  151,  149,   71,
-      150,  152,  181,  153,  170,   92,  301,   92,  154,  155,
-       92,   72,   73,   74,   92,  269,  270,   92,   92,  171,
-       91,   91,   91,   91,   91,   91,   91,   91,   91,   91,
-       91,   91,   91,   91,   91,  156,  157,  158,  161,  182,
-      116,   82,  160,  117,   92,  183,  162,   92,  185,   93,
-       92,  203,  203,  159,   92,  443,  291,  204,   91,   91,
-       91,  163,  163,  164,  163,  163,  163,  163,  163,  163,
-
-      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
-      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
-      163,  163,  163,  163,  163,  163,  163,  163,  163,  165,
-      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
-      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
-      165,  165,  165,  184,  184,  184,  184,  184,  184,  184,
-      184,  184,  184,  184,  184,   92,   92,   92,  219,   92,
-       92,  300,  342,   92,   92,  301,   92,   92,  188,  190,
-       92,   92,   92,  194,  152,  195,   92,   92,  184,  184,
-      184,  186,  186,  186,  186,  186,  186,  186,  186,  186,
-
-      186,  186,  186,  152,  152,  189,  187,   92,   92,   92,
-       92,  442,  193,  317,  196,   92,   92,   92,  199,  218,
-      220,   92,  221,   92,   92,   92,  186,  186,  186,  191,
-      192,  192,  191,  191,  191,  191,  191,  191,  191,  191,
-      191,  197,  201,  200,   92,  222,   92,   92,   92,  236,
-      203,  203,  290,  152,  152,  441,  204,   92,  292,  237,
-      239,  235,  240,   92,  191,  191,  191,  163,  163,  163,
-      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
-      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
-      163,  223,  223,  223,  223,  223,  223,  223,  223,  223,
-
-      223,  223,  223,   92,   92,   92,   92,  256,  258,  257,
-       92,  273,   92,  301,   92,   92,   92,  259,   92,   92,
-       92,  238,   92,  304,  158,   92,  223,  223,  223,  224,
-      224,  241,  272,  152,  152,  275,  293,  274,   92,  305,
-      273,   92,  225,  226,  152,  276,   92,   92,  227,   92,
-      307,   92,  314,  314,   92,  320,   92,  327,  327,  318,
-      319,   92,  314,  314,  440,   92,  274,  308,  228,  229,
-      230,   92,  309,  341,  334,  231,  332,  232,   92,  388,
-      337,   92,   92,  233,   92,  234,  255,  255,  255,  255,
-      255,  255,  255,  255,  255,  255,  255,  255,  338,  343,
-
-      333,  344,  389,   92,  361,  439,  339,   92,  350,   92,
-       92,  340,  340,  352,  362,  363,  301,   92,  437,   92,
-       92,  255,  255,  255,  260,  260,  260,  260,  260,  260,
-      260,  260,  260,  260,  260,  260,  354,  375,  390,   92,
-      376,   92,  364,  377,  355,  369,   92,   92,  152,  356,
-      356,  365,   92,   92,  392,   92,  436,  378,   92,  260,
-      260,  260,  277,  277,  277,  277,  277,  277,  277,  277,
-      277,  277,  277,  277,  379,   92,  399,  401,  400,   92,
-       92,  408,   92,  435,  152,   92,  434,  391,   92,  409,
-      409,   92,  411,   92,  427,  410,  426,  277,  277,  277,
-
-      286,  286,  286,  286,  286,  286,  286,  286,  286,  286,
-      286,  286,  414,  418,   92,   92,  420,  420,  418,  418,
-      425,  415,  421,  422,  422,   92,  429,  419,  424,  152,
-       92,  429,  429,  417,  152,  286,  286,  286,  287,  287,
-      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,
-      420,  420,  422,  422,  422,  422,  421,  431,  431,  431,
-      431,  431,  431,  413,  432,  412,  432,  407,  432,  406,
-      404,  403,  402,  287,  287,  287,  288,  288,  288,  288,
-      288,  288,  288,  288,  288,  288,  288,  288,  398,  397,
-      395,  394,  393,  387,  386,  385,  382,  381,  380,  374,
-
-      373,  372,  301,  301,  368,  367,  366,  358,  357,  304,
-      349,  288,  288,  288,  310,  310,  310,  310,  310,  310,
-      310,  310,  310,  310,  310,  310,  348,  301,  301,  301,
-      347,  346,  345,  336,  331,  330,  329,  328,  301,  325,
-      324,  301,  301,  323,  322,  321,  315,  313,  312,  310,
-      310,  310,  316,  316,  316,  316,  316,  316,  316,  316,
-      316,  316,  316,  316,  306,  303,  302,  299,  298,  297,
-      296,  295,  294,  289,  285,  284,  283,  282,  281,  280,
-      279,  271,  268,  267,  266,  265,  264,  316,  316,  316,
-      351,  351,  351,  351,  351,  351,  351,  351,  351,  351,
-
-      351,  351,  263,  262,  261,  254,  253,  252,  251,  250,
-      249,  248,  247,  246,  245,  244,  243,  217,  216,  215,
-      214,  213,  212,  211,  210,  351,  351,  351,  359,  359,
-      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
-      209,  208,  207,  206,  205,  180,  179,  178,  177,  176,
-      175,  174,  173,  172,  169,  168,  167,  118,  118,  100,
-      140,   92,   90,  359,  359,  359,  360,  360,  360,  360,
-      360,  360,  360,  360,  360,  360,  360,  360,  139,  444,
-      138,  444,  137,  136,  133,  132,  131,  130,  129,  128,
-      127,  126,  444,  125,  124,  123,  122,  118,  101,  100,
-
-       97,  360,  360,  360,  370,  370,  370,  370,  370,  370,
-      370,  370,  370,  370,  370,  370,   90,   89,   88,   87,
-       81,   80,   79,   78,   77,   66,   64,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  370,
-      370,  370,  383,  383,  383,  383,  383,  383,  383,  383,
-      383,  383,  383,  383,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  383,  383,  383,
-      430,  430,  430,  430,  430,  430,  430,  430,  430,  430,
-      430,  430,  444,  444,  444,  444,  444,  444,  444,  444,
-
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  430,  430,  430,   16,   16,
-       16,   16,   16,   16,   16,   16,   16,   54,   54,   54,
-       54,   54,   54,   54,   54,   54,   60,   60,   60,   60,
-       60,   60,   60,   60,   60,   63,   63,   63,   63,   63,
-       63,   63,   63,   63,   65,   65,   65,   65,   65,   65,
-       65,   65,   65,   67,   67,  444,   67,   83,   83,   83,
-       83,   83,   83,   83,   83,   83,   86,   86,   86,   86,
-       86,   86,   86,   86,   86,   92,   92,   92,   92,   92,
-       92,   92,   92,   92,   99,   99,   99,   99,   99,   99,
-
-       99,  444,   99,  119,  444,  444,  444,  444,  444,  444,
-      119,  120,  120,  444,  120,  444,  120,  120,  120,  120,
-      121,  121,  121,  121,  121,  121,  121,  121,  121,  166,
-      166,  444,  166,  444,  166,  166,  166,  166,  202,  202,
-      444,  202,  444,  202,  202,  202,  202,  242,  242,  444,
-      242,  444,  242,  242,  242,  242,  278,  278,  444,  278,
-      444,  278,  278,  278,  278,  255,  255,  255,  255,  255,
-      444,  444,  255,  311,  311,  444,  311,  444,  311,  311,
-      311,  311,  286,  286,  286,  286,  286,  444,  444,  286,
-      287,  287,  287,  287,  287,  444,  444,  287,  288,  288,
-
-      288,  288,  288,  444,  444,  288,  326,  326,  326,  326,
-      326,  444,  444,  326,  335,  335,  444,  335,  444,  335,
-      335,  335,  335,  316,  316,  316,  316,  316,  444,  444,
-      316,  353,  353,  444,  353,  444,  353,  353,  353,  353,
-      371,  371,  444,  371,  444,  371,  371,  371,  371,  359,
-      359,  359,  359,  359,  444,  444,  359,  360,  360,  360,
-      360,  360,  444,  444,  360,  384,  384,  444,  384,  444,
-      384,  384,  384,  384,  396,  396,  444,  396,  444,  396,
-      396,  396,  396,  405,  405,  444,  405,  444,  405,  405,
-      405,  405,  416,  416,  444,  416,  444,  416,  416,  416,
-
-      416,  423,  423,  444,  444,  444,  423,  444,  423,  428,
-      428,  444,  428,  444,  428,  428,  428,  428,  433,  433,
-      433,  444,  433,  433,  444,  433,  438,  438,  444,  438,
-      444,  438,  438,  438,  438,  430,  430,  430,  430,  430,
-      444,  444,  430,    9,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-
-      444,  444,  444,  444,  444,  444
-    } ;
-
-static yyconst flex_int16_t yy_chk[1507] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    4,    5,    6,    4,    7,    8,   18,
-        0,    5,    6,   13,    7,    8,   25,   25,   26,   26,
-       27,   35,   35,   11,   11,    1,    1,    1,    2,    2,
-        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
-        2,   11,   12,   12,    2,   37,   13,   36,   36,   37,
-       18,   42,   39,   27,   43,   44,   45,   46,   48,  159,
-       12,   39,   96,    2,    2,    2,   52,   52,   95,   52,
-       96,    2,   44,   95,   43,   48,  159,   42,   82,   82,
-       43,   45,   46,    2,    2,    2,    3,    3,    3,    3,
-
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,   17,   17,
-       47,   17,   49,   50,   51,   60,   69,   58,   58,   75,
-       83,   94,   94,   17,   97,   49,   17,   97,  102,   79,
-       98,  104,  103,   50,   50,   58,   47,   68,   68,   51,
-       68,   98,   49,   50,   79,  103,  105,  443,   60,  106,
-
-       17,  107,   68,   83,  102,   68,  104,   69,  108,  109,
-       75,  110,   17,   17,   17,   33,   33,   33,   33,   33,
-       33,   33,   33,   33,   33,   33,   33,  107,  105,   68,
-      106,  107,  140,  108,  128,  140,  442,  111,  109,  110,
-      112,   68,   68,   68,  114,  233,  233,  115,  113,  128,
-       33,   33,   33,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,  111,  112,  113,  115,  141,
-      116,  116,  114,  116,  144,  142,  115,  142,  144,   34,
-      141,  167,  167,  113,  257,  441,  257,  167,   34,   34,
-       34,  119,  119,  119,  119,  119,  119,  119,  119,  119,
-
-      119,  119,  119,  119,  119,  119,  119,  119,  119,  119,
-      119,  119,  119,  119,  119,  119,  119,  119,  119,  119,
-      119,  119,  119,  119,  119,  119,  119,  119,  119,  119,
-      119,  119,  119,  119,  119,  119,  119,  119,  119,  119,
-      119,  119,  119,  119,  119,  119,  119,  119,  119,  119,
-      119,  119,  119,  143,  143,  143,  143,  143,  143,  143,
-      143,  143,  143,  143,  143,  153,  149,  151,  182,  318,
-      155,  267,  318,  156,  182,  267,  147,  148,  149,  151,
-      146,  150,  154,  155,  153,  156,  157,  160,  143,  143,
-      143,  145,  145,  145,  145,  145,  145,  145,  145,  145,
-
-      145,  145,  145,  146,  147,  150,  148,  181,  183,  290,
-      185,  440,  154,  290,  157,  187,  158,  161,  160,  181,
-      183,  162,  185,  188,  190,  194,  145,  145,  145,  152,
-      152,  152,  152,  152,  152,  152,  152,  152,  152,  152,
-      152,  158,  162,  161,  193,  187,  195,  199,  198,  194,
-      203,  203,  256,  188,  190,  439,  203,  256,  258,  195,
-      198,  193,  199,  258,  152,  152,  152,  163,  163,  163,
-      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
-      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
-      163,  189,  189,  189,  189,  189,  189,  189,  189,  189,
-
-      189,  189,  189,  196,  197,  201,  200,  218,  220,  219,
-      221,  236,  237,  437,  239,  240,  235,  221,  238,  218,
-      220,  197,  219,  270,  201,  236,  189,  189,  189,  192,
-      192,  200,  235,  196,  238,  237,  259,  236,  272,  270,
-      273,  259,  192,  192,  239,  240,  274,  291,  192,  307,
-      272,  275,  284,  284,  273,  293,  292,  301,  301,  291,
-      292,  309,  314,  314,  436,  293,  273,  274,  192,  192,
-      192,  308,  275,  317,  309,  192,  307,  192,  332,  375,
-      314,  317,  375,  192,  334,  192,  217,  217,  217,  217,
-      217,  217,  217,  217,  217,  217,  217,  217,  315,  319,
-
-      308,  320,  376,  376,  341,  435,  315,  319,  332,  341,
-      320,  315,  315,  334,  342,  343,  434,  350,  427,  342,
-      343,  217,  217,  217,  222,  222,  222,  222,  222,  222,
-      222,  222,  222,  222,  222,  222,  336,  361,  377,  344,
-      362,  377,  344,  363,  336,  350,  361,  362,  388,  336,
-      336,  344,  363,  364,  379,  379,  426,  364,  388,  222,
-      222,  222,  241,  241,  241,  241,  241,  241,  241,  241,
-      241,  241,  241,  241,  365,  378,  389,  391,  390,  365,
-      392,  399,  391,  425,  392,  389,  424,  378,  390,  400,
-      400,  399,  401,  401,  415,  400,  414,  241,  241,  241,
-
-      251,  251,  251,  251,  251,  251,  251,  251,  251,  251,
-      251,  251,  404,  407,  400,  408,  409,  409,  407,  407,
-      413,  404,  409,  410,  410,  411,  417,  408,  412,  411,
-      419,  417,  417,  406,  419,  251,  251,  251,  252,  252,
-      252,  252,  252,  252,  252,  252,  252,  252,  252,  252,
-      420,  420,  421,  421,  422,  422,  420,  423,  423,  431,
-      431,  433,  433,  403,  423,  402,  431,  398,  433,  397,
-      395,  394,  393,  252,  252,  252,  253,  253,  253,  253,
-      253,  253,  253,  253,  253,  253,  253,  253,  387,  385,
-      382,  381,  380,  374,  373,  372,  368,  367,  366,  358,
-
-      357,  354,  349,  348,  347,  346,  345,  338,  337,  331,
-      330,  253,  253,  253,  276,  276,  276,  276,  276,  276,
-      276,  276,  276,  276,  276,  276,  329,  328,  325,  324,
-      323,  322,  321,  312,  306,  305,  304,  303,  302,  300,
-      299,  298,  297,  296,  295,  294,  285,  283,  279,  276,
-      276,  276,  289,  289,  289,  289,  289,  289,  289,  289,
-      289,  289,  289,  289,  271,  269,  268,  266,  265,  264,
-      263,  262,  261,  254,  250,  249,  247,  246,  245,  244,
-      243,  234,  232,  231,  230,  229,  228,  289,  289,  289,
-      333,  333,  333,  333,  333,  333,  333,  333,  333,  333,
-
-      333,  333,  227,  226,  225,  216,  215,  214,  213,  212,
-      211,  210,  209,  208,  207,  206,  205,  180,  179,  178,
-      177,  176,  175,  174,  173,  333,  333,  333,  339,  339,
-      339,  339,  339,  339,  339,  339,  339,  339,  339,  339,
-      172,  171,  170,  169,  168,  137,  136,  135,  134,  133,
-      132,  131,  130,  129,  127,  126,  124,  118,  117,   99,
-       93,   92,   90,  339,  339,  339,  340,  340,  340,  340,
-      340,  340,  340,  340,  340,  340,  340,  340,   88,   87,
-       86,   85,   81,   80,   78,   77,   76,   74,   73,   72,
-       71,   70,   64,   63,   59,   57,   56,   53,   41,   40,
-
-       38,  340,  340,  340,  352,  352,  352,  352,  352,  352,
-      352,  352,  352,  352,  352,  352,   32,   31,   30,   29,
-       23,   22,   21,   20,   19,   15,   14,    9,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,  352,
-      352,  352,  369,  369,  369,  369,  369,  369,  369,  369,
-      369,  369,  369,  369,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,  369,  369,  369,
-      418,  418,  418,  418,  418,  418,  418,  418,  418,  418,
-      418,  418,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,  418,  418,  418,  445,  445,
-      445,  445,  445,  445,  445,  445,  445,  446,  446,  446,
-      446,  446,  446,  446,  446,  446,  447,  447,  447,  447,
-      447,  447,  447,  447,  447,  448,  448,  448,  448,  448,
-      448,  448,  448,  448,  449,  449,  449,  449,  449,  449,
-      449,  449,  449,  450,  450,    0,  450,  451,  451,  451,
-      451,  451,  451,  451,  451,  451,  452,  452,  452,  452,
-      452,  452,  452,  452,  452,  453,  453,  453,  453,  453,
-      453,  453,  453,  453,  454,  454,  454,  454,  454,  454,
-
-      454,    0,  454,  455,    0,    0,    0,    0,    0,    0,
-      455,  456,  456,    0,  456,    0,  456,  456,  456,  456,
-      457,  457,  457,  457,  457,  457,  457,  457,  457,  458,
-      458,    0,  458,    0,  458,  458,  458,  458,  459,  459,
-        0,  459,    0,  459,  459,  459,  459,  460,  460,    0,
-      460,    0,  460,  460,  460,  460,  461,  461,    0,  461,
-        0,  461,  461,  461,  461,  462,  462,  462,  462,  462,
-        0,    0,  462,  463,  463,    0,  463,    0,  463,  463,
-      463,  463,  464,  464,  464,  464,  464,    0,    0,  464,
-      465,  465,  465,  465,  465,    0,    0,  465,  466,  466,
-
-      466,  466,  466,    0,    0,  466,  467,  467,  467,  467,
-      467,    0,    0,  467,  468,  468,    0,  468,    0,  468,
-      468,  468,  468,  469,  469,  469,  469,  469,    0,    0,
-      469,  470,  470,    0,  470,    0,  470,  470,  470,  470,
-      471,  471,    0,  471,    0,  471,  471,  471,  471,  472,
-      472,  472,  472,  472,    0,    0,  472,  473,  473,  473,
-      473,  473,    0,    0,  473,  474,  474,    0,  474,    0,
-      474,  474,  474,  474,  475,  475,    0,  475,    0,  475,
-      475,  475,  475,  476,  476,    0,  476,    0,  476,  476,
-      476,  476,  477,  477,    0,  477,    0,  477,  477,  477,
-
-      477,  478,  478,    0,    0,    0,  478,    0,  478,  479,
-      479,    0,  479,    0,  479,  479,  479,  479,  480,  480,
-      480,    0,  480,  480,    0,  480,  481,  481,    0,  481,
-        0,  481,  481,  481,  481,  482,  482,  482,  482,  482,
-        0,    0,  482,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-      444,  444,  444,  444,  444,  444,  444,  444,  444,  444,
-
-      444,  444,  444,  444,  444,  444
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-extern int yy_flex_debug;
-int yy_flex_debug = 0;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-/* -*- indented-text -*- */
-/* Process source files and output type information.
-   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009
-   Free Software Foundation, Inc.
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify it under
-the terms of the GNU General Public License as published by the Free
-Software Foundation; either version 3, or (at your option) any later
-version.
-
-GCC is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
-#line 23 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-#include "bconfig.h"
-#include "system.h"
-
-#define malloc xmalloc
-#define realloc xrealloc
-
-#include "gengtype.h"
-
-#define YY_NO_INPUT
-#define YY_DECL int yylex (const char **yylval)
-#define yyterminate() return EOF_TOKEN
-
-struct fileloc lexer_line;
-int lexer_toplevel_done;
-
-static void 
-update_lineno (const char *l, size_t len)
-{
-  while (len-- > 0)
-    if (*l++ == '\n')
-      lexer_line.line++;
-}
-
-
-#line 986 "gengtype-lex.c"
-
-#define INITIAL 0
-#define in_struct 1
-#define in_struct_comment 2
-#define in_comment 3
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-static int yy_init_globals (void );
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy (void );
-
-int yyget_debug (void );
-
-void yyset_debug (int debug_flag  );
-
-YY_EXTRA_TYPE yyget_extra (void );
-
-void yyset_extra (YY_EXTRA_TYPE user_defined  );
-
-FILE *yyget_in (void );
-
-void yyset_in  (FILE * in_str  );
-
-FILE *yyget_out (void );
-
-void yyset_out  (FILE * out_str  );
-
-int yyget_leng (void );
-
-char *yyget_text (void );
-
-int yyget_lineno (void );
-
-void yyset_lineno (int line_number  );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap (void );
-#else
-extern int yywrap (void );
-#endif
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int );
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * );
-#endif
-
-#ifndef YY_NO_INPUT
-
-#ifdef __cplusplus
-static int yyinput (void );
-#else
-static int input (void );
-#endif
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		unsigned n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* end tables serialization structures and prototypes */
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex (void);
-
-#define YY_DECL int yylex (void)
-#endif /* !YY_DECL */
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	if ( yyleng > 0 ) \
-		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
-				(yytext[yyleng - 1] == '\n'); \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
-    
-#line 58 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-
-  /* Do this on entry to yylex():  */
-  *yylval = 0;
-  if (lexer_toplevel_done)
-    {
-      BEGIN(INITIAL);
-      lexer_toplevel_done = 0;
-    }
-
-  /* Things we look for in skipping mode: */
-#line 1183 "gengtype-lex.c"
-
-	if ( !(yy_init) )
-		{
-		(yy_init) = 1;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! (yy_start) )
-			(yy_start) = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			yyensure_buffer_stack ();
-			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer(yyin,YY_BUF_SIZE );
-		}
-
-		yy_load_buffer_state( );
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = (yy_c_buf_p);
-
-		/* Support of yytext. */
-		*yy_cp = (yy_hold_char);
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = (yy_start);
-		yy_current_state += YY_AT_BOL();
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				(yy_last_accepting_state) = yy_current_state;
-				(yy_last_accepting_cpos) = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 445 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_current_state != 444 );
-		yy_cp = (yy_last_accepting_cpos);
-		yy_current_state = (yy_last_accepting_state);
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-
-		YY_DO_BEFORE_ACTION;
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = (yy_hold_char);
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			goto yy_find_action;
-
-case 1:
-/* rule 1 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 69 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return TYPEDEF;
-}
-	YY_BREAK
-case 2:
-/* rule 2 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 73 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return STRUCT;
-}
-	YY_BREAK
-case 3:
-/* rule 3 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 77 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return UNION;
-}
-	YY_BREAK
-case 4:
-/* rule 4 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 81 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return EXTERN;
-}
-	YY_BREAK
-case 5:
-/* rule 5 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 85 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return STATIC;
-}
-	YY_BREAK
-case 6:
-/* rule 6 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 90 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return DEFVEC_OP;
-}
-	YY_BREAK
-case 7:
-/* rule 7 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 94 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return DEFVEC_I;
-}
-	YY_BREAK
-case 8:
-/* rule 8 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 98 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return DEFVEC_ALLOC;
-}
-	YY_BREAK
-
-
-case 9:
-YY_RULE_SETUP
-#line 106 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ BEGIN(in_struct_comment); }
-	YY_BREAK
-case 10:
-/* rule 10 can match eol */
-YY_RULE_SETUP
-#line 108 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ update_lineno (yytext, yyleng); }
-	YY_BREAK
-case 11:
-/* rule 11 can match eol */
-YY_RULE_SETUP
-#line 109 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 12:
-/* rule 12 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 111 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-/* don't care */
-	YY_BREAK
-case 13:
-/* rule 13 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 3;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 112 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ return GTY_TOKEN; }
-	YY_BREAK
-case 14:
-/* rule 14 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 3;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 113 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ return VEC_TOKEN; }
-	YY_BREAK
-case 15:
-/* rule 15 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 114 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ return UNION; }
-	YY_BREAK
-case 16:
-/* rule 16 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 6;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 115 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ return STRUCT; }
-	YY_BREAK
-case 17:
-/* rule 17 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 4;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 116 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ return ENUM; }
-	YY_BREAK
-case 18:
-/* rule 18 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 9;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 117 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ return PTR_ALIAS; }
-	YY_BREAK
-case 19:
-/* rule 19 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 10;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 118 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ return NESTED_PTR; }
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 119 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ return NUM; }
-	YY_BREAK
-case 21:
-/* rule 21 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 120 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext, yyleng, yyleng+1);
-  return PARAM_IS;
-}
-	YY_BREAK
-case 22:
-/* rule 22 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-#line 126 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-case 23:
-/* rule 23 can match eol */
-YY_RULE_SETUP
-#line 126 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  size_t len;
-
-  for (len = yyleng; ISSPACE (yytext[len-1]); len--)
-    ;
-
-  *yylval = XDUPVAR (const char, yytext, len, len+1);
-  update_lineno (yytext, yyleng);
-  return SCALAR;
-}
-	YY_BREAK
-case 24:
-/* rule 24 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 138 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext, yyleng, yyleng+1);
-  return ID;
-}
-	YY_BREAK
-case 25:
-/* rule 25 can match eol */
-YY_RULE_SETUP
-#line 143 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng-1);
-  return STRING;
-}
-	YY_BREAK
-/* This "terminal" avoids having to parse integer constant expressions.  */
-case 26:
-/* rule 26 can match eol */
-YY_RULE_SETUP
-#line 148 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng-1);
-  return ARRAY;
-}
-	YY_BREAK
-case 27:
-/* rule 27 can match eol */
-YY_RULE_SETUP
-#line 152 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng);
-  return CHAR;
-}
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 157 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ return ELLIPSIS; }
-	YY_BREAK
-case 29:
-YY_RULE_SETUP
-#line 158 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ return yytext[0]; }
-	YY_BREAK
-/* ignore pp-directives */
-case 30:
-/* rule 30 can match eol */
-YY_RULE_SETUP
-#line 161 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{lexer_line.line++;}
-	YY_BREAK
-case 31:
-YY_RULE_SETUP
-#line 163 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  error_at_line (&lexer_line, "unexpected character `%s'", yytext);
-}
-	YY_BREAK
-
-case 32:
-YY_RULE_SETUP
-#line 168 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ BEGIN(in_comment); }
-	YY_BREAK
-case 33:
-/* rule 33 can match eol */
-YY_RULE_SETUP
-#line 169 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 34:
-#line 171 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-case 35:
-/* rule 35 can match eol */
-#line 172 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-case 36:
-/* rule 36 can match eol */
-YY_RULE_SETUP
-#line 172 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-case 37:
-/* rule 37 can match eol */
-YY_RULE_SETUP
-#line 173 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ update_lineno (yytext, yyleng); }
-	YY_BREAK
-case 38:
-/* rule 38 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 174 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-
-case 39:
-/* rule 39 can match eol */
-YY_RULE_SETUP
-#line 177 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 40:
-#line 179 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-case 41:
-YY_RULE_SETUP
-#line 179 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-case 42:
-/* rule 42 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-(yy_c_buf_p) = yy_cp = yy_bp + 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 180 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-
-case 43:
-YY_RULE_SETUP
-#line 182 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ BEGIN(INITIAL); } 
-	YY_BREAK
-case 44:
-YY_RULE_SETUP
-#line 183 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{ BEGIN(in_struct); }
-	YY_BREAK
-case 45:
-#line 186 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-case 46:
-YY_RULE_SETUP
-#line 186 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  error_at_line (&lexer_line, 
-		 "unterminated comment or string; unexpected EOF");
-}
-	YY_BREAK
-case 47:
-/* rule 47 can match eol */
-YY_RULE_SETUP
-#line 191 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-case 48:
-/* rule 48 can match eol */
-YY_RULE_SETUP
-#line 192 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-{
-  error_at_line (&lexer_line, "stray GTY marker");
-}
-	YY_BREAK
-case 49:
-YY_RULE_SETUP
-#line 196 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-YY_FATAL_ERROR( "flex scanner jammed" );
-	YY_BREAK
-#line 1653 "gengtype-lex.c"
-case YY_STATE_EOF(INITIAL):
-case YY_STATE_EOF(in_struct):
-case YY_STATE_EOF(in_struct_comment):
-case YY_STATE_EOF(in_comment):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = (yy_hold_char);
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state(  );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++(yy_c_buf_p);
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = (yy_last_accepting_cpos);
-				yy_current_state = (yy_last_accepting_state);
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer(  ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				(yy_did_buffer_switch_on_eof) = 0;
-
-				if ( yywrap( ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				(yy_c_buf_p) =
-					(yytext_ptr) + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				(yy_c_buf_p) =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-} /* end of yylex */
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (void)
-{
-    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	register char *source = (yytext_ptr);
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
-
-	else
-		{
-			int num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
-
-			int yy_c_buf_p_offset =
-				(int) ((yy_c_buf_p) - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
-						number_to_move - 1;
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			(yy_n_chars), (size_t) num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	if ( (yy_n_chars) == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart(yyin  );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
-		/* Extend the array by 50%, plus the number we really need. */
-		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
-		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
-	}
-
-	(yy_n_chars) += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
-
-	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
-
-	return ret_val;
-}
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-    static yy_state_type yy_get_previous_state (void)
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-    
-	yy_current_state = (yy_start);
-	yy_current_state += YY_AT_BOL();
-
-	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			(yy_last_accepting_state) = yy_current_state;
-			(yy_last_accepting_cpos) = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 445 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-}
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
-{
-	register int yy_is_jam;
-    	register char *yy_cp = (yy_c_buf_p);
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		(yy_last_accepting_state) = yy_current_state;
-		(yy_last_accepting_cpos) = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 445 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 444);
-
-	return yy_is_jam ? 0 : yy_current_state;
-}
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (void)
-#else
-    static int input  (void)
-#endif
-
-{
-	int c;
-    
-	*(yy_c_buf_p) = (yy_hold_char);
-
-	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			/* This was really a NUL. */
-			*(yy_c_buf_p) = '\0';
-
-		else
-			{ /* need more input */
-			int offset = (yy_c_buf_p) - (yytext_ptr);
-			++(yy_c_buf_p);
-
-			switch ( yy_get_next_buffer(  ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart(yyin );
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap( ) )
-						return EOF;
-
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					(yy_c_buf_p) = (yytext_ptr) + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
-	*(yy_c_buf_p) = '\0';	/* preserve yytext */
-	(yy_hold_char) = *++(yy_c_buf_p);
-
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
-
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * 
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void yyrestart  (FILE * input_file )
-{
-    
-	if ( ! YY_CURRENT_BUFFER ){
-        yyensure_buffer_stack ();
-		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer(yyin,YY_BUF_SIZE );
-	}
-
-	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
-	yy_load_buffer_state( );
-}
-
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * 
- */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
-{
-    
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		yypop_buffer_state();
-	 *		yypush_buffer_state(new_buffer);
-     */
-	yyensure_buffer_stack ();
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-static void yy_load_buffer_state  (void)
-{
-    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	(yy_hold_char) = *(yy_c_buf_p);
-}
-
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * 
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer(b,file );
-
-	return b;
-}
-
-/** Destroy the buffer.
- * @param b a buffer created with yy_create_buffer()
- * 
- */
-    void yy_delete_buffer (YY_BUFFER_STATE  b )
-{
-    
-	if ( ! b )
-		return;
-
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yyfree((void *) b->yy_ch_buf  );
-
-	yyfree((void *) b  );
-}
-
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a yyrestart() or at EOF.
- */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
-
-{
-	int oerrno = errno;
-    
-	yy_flush_buffer(b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-    /* If b is the current buffer, then yy_init_buffer was _probably_
-     * called from yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
-
-        b->yy_is_interactive = 0;
-    
-	errno = oerrno;
-}
-
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * 
- */
-    void yy_flush_buffer (YY_BUFFER_STATE  b )
-{
-    	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( );
-}
-
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  
- */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
-{
-    	if (new_buffer == NULL)
-		return;
-
-	yyensure_buffer_stack();
-
-	/* This block is copied from yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		(yy_buffer_stack_top)++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( );
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  
- */
-void yypop_buffer_state (void)
-{
-    	if (!YY_CURRENT_BUFFER)
-		return;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if ((yy_buffer_stack_top) > 0)
-		--(yy_buffer_stack_top);
-
-	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( );
-		(yy_did_buffer_switch_on_eof) = 1;
-	}
-}
-
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void yyensure_buffer_stack (void)
-{
-	int num_to_alloc;
-    
-	if (!(yy_buffer_stack)) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
-         */
-		num_to_alloc = 1;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-								  
-		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
-		(yy_buffer_stack_max) = num_to_alloc;
-		(yy_buffer_stack_top) = 0;
-		return;
-	}
-
-	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		int grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = (yy_buffer_stack_max) + grow_size;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
-								((yy_buffer_stack),
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		/* zero only the new slots.*/
-		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
-		(yy_buffer_stack_max) = num_to_alloc;
-	}
-}
-
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object. 
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer(b  );
-
-	return b;
-}
-
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * 
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
-{
-    
-	return yy_scan_bytes(yystr,strlen(yystr) );
-}
-
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = _yybytes_len + 2;
-	buf = (char *) yyalloc(n  );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
-
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer(buf,n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-}
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-static void yy_fatal_error (yyconst char* msg )
-{
-    	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = (yy_hold_char); \
-		(yy_c_buf_p) = yytext + yyless_macro_arg; \
-		(yy_hold_char) = *(yy_c_buf_p); \
-		*(yy_c_buf_p) = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
-
-/** Get the current line number.
- * 
- */
-int yyget_lineno  (void)
-{
-        
-    return yylineno;
-}
-
-/** Get the input stream.
- * 
- */
-FILE *yyget_in  (void)
-{
-        return yyin;
-}
-
-/** Get the output stream.
- * 
- */
-FILE *yyget_out  (void)
-{
-        return yyout;
-}
-
-/** Get the length of the current token.
- * 
- */
-int yyget_leng  (void)
-{
-        return yyleng;
-}
-
-/** Get the current token.
- * 
- */
-
-char *yyget_text  (void)
-{
-        return yytext;
-}
-
-/** Set the current line number.
- * @param line_number
- * 
- */
-void yyset_lineno (int  line_number )
-{
-    
-    yylineno = line_number;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param in_str A readable stream.
- * 
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  in_str )
-{
-        yyin = in_str ;
-}
-
-void yyset_out (FILE *  out_str )
-{
-        yyout = out_str ;
-}
-
-int yyget_debug  (void)
-{
-        return yy_flex_debug;
-}
-
-void yyset_debug (int  bdebug )
-{
-        yy_flex_debug = bdebug ;
-}
-
-static int yy_init_globals (void)
-{
-        /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    (yy_buffer_stack) = 0;
-    (yy_buffer_stack_top) = 0;
-    (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = (char *) 0;
-    (yy_init) = 0;
-    (yy_start) = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = (FILE *) 0;
-    yyout = (FILE *) 0;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (void)
-{
-    
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer(YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		yypop_buffer_state();
-	}
-
-	/* Destroy the stack itself. */
-	yyfree((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
-
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( );
-
-    return 0;
-}
-
-/*
- * Internal utility routines.
- */
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
-{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * s )
-{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-}
-#endif
-
-void *yyalloc (yy_size_t  size )
-{
-	return (void *) malloc( size );
-}
-
-void *yyrealloc  (void * ptr, yy_size_t  size )
-{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-}
-
-void yyfree (void * ptr )
-{
-	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
-}
-
-#define YYTABLES_NAME "yytables"
-
-#line 196 "/d/gcc-4.4.1/gcc-4.4.1/gcc/gengtype-lex.l"
-
-
-
-void
-yybegin (const char *fname)
-{
-  yyin = fopen (fname, "r");
-  if (yyin == NULL)
-    {
-      perror (fname);
-      exit (1);
-    }
-  lexer_line.file = fname;
-  lexer_line.line = 1;
-}
-
-void
-yyend (void)
-{
-  fclose (yyin);
-}
-
diff -Nur a/gcc/gengtype-lex.l b/gcc/gengtype-lex.l
--- a/gcc/gengtype-lex.l	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/gengtype-lex.l	2010-01-25 09:50:29.145688053 +0100
@@ -48,7 +48,7 @@
 ID	[[:alpha:]_][[:alnum:]_]*
 WS	[[:space:]]+
 HWS	[ \t\r\v\f]*
-IWORD	short|long|(un)?signed|char|int|HOST_WIDE_INT|HOST_WIDEST_INT|bool|size_t|BOOL_BITFIELD|CPPCHAR_SIGNED_T|ino_t|dev_t
+IWORD	short|long|(un)?signed|char|int|HOST_WIDE_INT|HOST_WIDEST_INT|bool|size_t|BOOL_BITFIELD|CPPCHAR_SIGNED_T|ino_t|dev_t|HARD_REG_SET
 ITYPE	{IWORD}({WS}{IWORD})*
 EOID	[^[:alnum:]_]
 
diff -Nur a/gcc/genmultilib b/gcc/genmultilib
--- a/gcc/genmultilib	2007-07-26 10:37:01.000000000 +0200
+++ b/gcc/genmultilib	2010-01-25 09:50:29.145688053 +0100
@@ -73,6 +73,20 @@
 # the os directory names are used exclusively.  Use the mapping when
 # there is no one-to-one equivalence between GCC levels and the OS.
 
+# The optional eighth option is a list of multilib aliases.  This takes the
+# same form as the third argument.  It specifies that the second multilib is
+# a synonym for the first.  This allows a suitable multilib to be selected
+# for all option combinations while only building a subset of all possible
+# multilibs.
+# For example:
+#   genmultilib "mbig-endian mthumb" "eb thumb" "" "" "" "" "" \
+#		"mbig-endian=mbig-endian/mthumb" yes
+# This produces:
+#   ". !mbig-endian !mthumb;",
+#   "be mbig-endian !mthumb;",
+#   "be mbig-endian mthumb;",
+#   "thumb !mbig-endian mthumb;",
+
 # The last option should be "yes" if multilibs are enabled.  If it is not
 # "yes", all GCC multilib dir names will be ".".
 
@@ -121,7 +135,8 @@
 extra=$5
 exclusions=$6
 osdirnames=$7
-enable_multilib=$8
+aliases=$8
+enable_multilib=$9
 
 echo "static const char *const multilib_raw[] = {"
 
@@ -129,6 +144,23 @@
 # Use cd ./foo to avoid CDPATH output.
 cd ./tmpmultilib.$$ || exit 1
 
+# Handle aliases
+cat >tmpmultilib3 <<\EOF
+#!/bin/sh
+# Output a list of aliases (including the original name) for a multilib.
+
+echo $1
+EOF
+for a in ${aliases}; do
+  l=`echo $a | sed -e 's/=.*$//' -e 's/?/=/g'`
+  r=`echo $a | sed -e 's/^.*=//' -e 's/?/=/g'`
+  echo "[ \$1 == /$l/ ] && echo /$r/" >>tmpmultilib3
+  
+  # Also add the alias to the exclusion list
+  exceptions="${exceptions} $r"
+done
+chmod +x tmpmultilib3
+
 # What we want to do is select all combinations of the sets in
 # options.  Each combination which includes a set of mutually
 # exclusive options must then be output multiple times, once for each
@@ -195,6 +227,21 @@
   combinations=`./tmpmultilib2 ${combinations}`
 fi
 
+# Check that all the aliases actually exist
+for a in ${aliases}; do
+  l=`echo $a | sed -e 's/=.*$//' -e 's/?/=/g'`
+  for c in ${combinations}; do
+    if [ "/$l/" = "$c" ]; then
+      l=""
+      break;
+    fi
+  done
+  if [ -n "$l" ] ;then
+    echo "Missing multilib $l for alias $a" 1>&2
+    exit 1
+  fi
+done
+
 # Construct a sed pattern which will convert option names to directory
 # names.
 todirnames=
@@ -343,23 +390,25 @@
     fi
   fi
 
-  # Look through the options.  We must output each option that is
-  # present, and negate each option that is not present.
-  optout=
-  for set in ${options}; do
-    setopts=`echo ${set} | sed -e 's_[/|]_ _g'`
-    for opt in ${setopts}; do
-      if expr "${combo} " : ".*/${opt}/.*" > /dev/null; then
-	optout="${optout} ${opt}"
-      else
-	optout="${optout} !${opt}"
-      fi
+  for optcombo in `./tmpmultilib3 ${combo}`; do
+    # Look through the options.  We must output each option that is
+    # present, and negate each option that is not present.
+    optout=
+    for set in ${options}; do
+      setopts=`echo ${set} | sed -e 's_[/|]_ _g'`
+      for opt in ${setopts}; do
+	if expr "${optcombo} " : ".*/${opt}/.*" > /dev/null; then
+	  optout="${optout} ${opt}"
+	else
+	  optout="${optout} !${opt}"
+	fi
+      done
     done
-  done
-  optout=`echo ${optout} | sed -e 's/^ //'`
+    optout=`echo ${optout} | sed -e 's/^ //'`
 
-  # Output the line with all appropriate matches.
-  dirout="${dirout}" optout="${optout}" ./tmpmultilib2
+    # Output the line with all appropriate matches.
+    dirout="${dirout}" optout="${optout}" ./tmpmultilib2
+  done
 done
 
 # Terminate the list of string.
diff -Nur a/gcc/haifa-sched.c b/gcc/haifa-sched.c
--- a/gcc/haifa-sched.c	2008-10-14 14:52:19.000000000 +0200
+++ b/gcc/haifa-sched.c	2010-01-25 09:50:29.145688053 +0100
@@ -1990,6 +1990,23 @@
   SCHED_GROUP_P (insn) = 0;  
 }
 
+/* Return true if scheduling INSN will finish current clock cycle.  */
+static bool
+insn_finishes_cycle_p (rtx insn)
+{
+  if (SCHED_GROUP_P (insn))
+    /* After issuing INSN, rest of the sched_group will be forced to issue
+       in order.  Don't make any plans for the rest of cycle.  */
+    return true;
+
+  /* Finishing the block will, apparently, finish the cycle.  */
+  if (current_sched_info->insn_finishes_block_p
+      && current_sched_info->insn_finishes_block_p (insn))
+    return true;
+
+  return false;
+}
+
 /* The following structure describe an entry of the stack of choices.  */
 struct choice_entry
 {
@@ -2168,7 +2185,10 @@
 	  delay = state_transition (state, insn);
 	  if (delay < 0)
 	    {
-	      if (state_dead_lock_p (state))
+	      if (state_dead_lock_p (state)
+		  || insn_finishes_cycle_p (insn))
+ 		/* We won't issue any more instructions in the next
+ 		   choice_state.  */
 		top->rest = 0;
 	      else
 		top->rest--;
diff -Nur a/gcc/hooks.c b/gcc/hooks.c
--- a/gcc/hooks.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/hooks.c	2010-01-25 09:50:29.145688053 +0100
@@ -335,3 +335,10 @@
 {
   return NULL;
 }
+
+/* Generic hook that takes a const_tree and returns NULL_TREE.  */
+tree
+hook_tree_const_tree_null (const_tree t ATTRIBUTE_UNUSED)
+{
+  return NULL;
+}
diff -Nur a/gcc/hooks.h b/gcc/hooks.h
--- a/gcc/hooks.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/hooks.h	2010-01-25 09:50:29.145688053 +0100
@@ -64,6 +64,8 @@
 extern int hook_int_size_t_constcharptr_int_0 (size_t, const char *, int);
 extern int hook_int_void_no_regs (void);
 
+extern tree hook_tree_const_tree_null (const_tree);
+
 extern tree hook_tree_tree_tree_null (tree, tree);
 extern tree hook_tree_tree_tree_tree_null (tree, tree, tree);
 extern tree hook_tree_tree_tree_tree_3rd_identity (tree, tree, tree);
diff -Nur a/gcc/incpath.c b/gcc/incpath.c
--- a/gcc/incpath.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/incpath.c	2010-01-25 09:50:29.145688053 +0100
@@ -30,6 +30,8 @@
 #include "intl.h"
 #include "incpath.h"
 #include "cppdefault.h"
+#include "flags.h"
+#include "toplev.h"
 
 /* Microsoft Windows does not natively support inodes.
    VMS has non-numeric inodes.  */
@@ -353,6 +355,24 @@
 	}
       fprintf (stderr, _("End of search list.\n"));
     }
+
+#ifdef ENABLE_POISON_SYSTEM_DIRECTORIES
+  if (flag_poison_system_directories)
+    {
+	struct cpp_dir *p;
+
+	for (p = heads[QUOTE]; p; p = p->next)
+	  {
+	   if ((!strncmp (p->name, "/usr/include", 12))
+	       || (!strncmp (p->name, "/usr/local/include", 18))
+	       || (!strncmp (p->name, "/usr/X11R6/include", 18)))
+	     warning (OPT_Wpoison_system_directories,
+		      "include location \"%s\" is unsafe for "
+		      "cross-compilation",
+		      p->name);
+	  }
+    }
+#endif
 }
 
 /* Use given -I paths for #include "..." but not #include <...>, and
diff -Nur a/gcc/ira.c b/gcc/ira.c
--- a/gcc/ira.c	2009-07-04 00:46:30.000000000 +0200
+++ b/gcc/ira.c	2010-01-25 09:50:29.145688053 +0100
@@ -1349,14 +1349,12 @@
   return for_each_rtx (&insn, insn_contains_asm_1, NULL);
 }
 
-/* Set up regs_asm_clobbered.  */
+/* Add register clobbers from asm statements.  */
 static void
-compute_regs_asm_clobbered (char *regs_asm_clobbered)
+compute_regs_asm_clobbered (void)
 {
   basic_block bb;
 
-  memset (regs_asm_clobbered, 0, sizeof (char) * FIRST_PSEUDO_REGISTER);
-  
   FOR_EACH_BB (bb)
     {
       rtx insn;
@@ -1377,7 +1375,7 @@
 		      + hard_regno_nregs[dregno][mode] - 1;
 
 		    for (i = dregno; i <= end; ++i)
-		      regs_asm_clobbered[i] = 1;
+		      SET_HARD_REG_BIT(crtl->asm_clobbers, i);
 		  }
 	      }
 	}
@@ -1415,7 +1413,8 @@
   COPY_HARD_REG_SET (ira_no_alloc_regs, no_unit_alloc_regs);
   CLEAR_HARD_REG_SET (eliminable_regset);
 
-  compute_regs_asm_clobbered (regs_asm_clobbered);
+  compute_regs_asm_clobbered ();
+
   /* Build the regset of all eliminable registers and show we can't
      use those that we already know won't be eliminated.  */
 #ifdef ELIMINABLE_REGS
@@ -1425,7 +1424,7 @@
 	= (! CAN_ELIMINATE (eliminables[i].from, eliminables[i].to)
 	   || (eliminables[i].to == STACK_POINTER_REGNUM && need_fp));
 
-      if (! regs_asm_clobbered[eliminables[i].from])
+      if (!TEST_HARD_REG_BIT (crtl->asm_clobbers, eliminables[i].from))
 	{
 	    SET_HARD_REG_BIT (eliminable_regset, eliminables[i].from);
 
@@ -1439,7 +1438,7 @@
 	df_set_regs_ever_live (eliminables[i].from, true);
     }
 #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM
-  if (! regs_asm_clobbered[HARD_FRAME_POINTER_REGNUM])
+  if (!TEST_HARD_REG_BIT (crtl->asm_clobbers, HARD_FRAME_POINTER_REGNUM))
     {
       SET_HARD_REG_BIT (eliminable_regset, HARD_FRAME_POINTER_REGNUM);
       if (need_fp)
@@ -1453,7 +1452,7 @@
 #endif
 
 #else
-  if (! regs_asm_clobbered[FRAME_POINTER_REGNUM])
+  if (!TEST_HARD_REG_BIT (crtl->asm_clobbers, HARD_FRAME_POINTER_REGNUM))
     {
       SET_HARD_REG_BIT (eliminable_regset, FRAME_POINTER_REGNUM);
       if (need_fp)
diff -Nur a/gcc/ira-costs.c b/gcc/ira-costs.c
--- a/gcc/ira-costs.c	2009-04-22 22:16:13.000000000 +0200
+++ b/gcc/ira-costs.c	2010-01-25 09:50:29.145688053 +0100
@@ -706,11 +706,11 @@
 
 /* Wrapper around REGNO_OK_FOR_INDEX_P, to allow pseudo registers.  */
 static inline bool
-ok_for_index_p_nonstrict (rtx reg)
+ok_for_index_p_nonstrict (rtx reg, enum machine_mode mode)
 {
   unsigned regno = REGNO (reg);
 
-  return regno >= FIRST_PSEUDO_REGISTER || REGNO_OK_FOR_INDEX_P (regno);
+  return regno >= FIRST_PSEUDO_REGISTER || ok_for_index_p_1 (regno, mode);
 }
 
 /* A version of regno_ok_for_base_p for use here, when all
@@ -748,7 +748,7 @@
   enum reg_class rclass;
 
   if (context == 1)
-    rclass = INDEX_REG_CLASS;
+    rclass = index_reg_class (mode);
   else
     rclass = base_reg_class (mode, outer_code, index_code);
 
@@ -795,7 +795,8 @@
 	   just record registers in any non-constant operands.  We
 	   assume here, as well as in the tests below, that all
 	   addresses are in canonical form.  */
-	else if (INDEX_REG_CLASS == base_reg_class (VOIDmode, PLUS, SCRATCH))
+	else if (index_reg_class (mode)
+		 == base_reg_class (mode, PLUS, SCRATCH))
 	  {
 	    record_address_regs (mode, arg0, context, PLUS, code1, scale);
 	    if (! CONSTANT_P (arg1))
@@ -816,7 +817,7 @@
 	else if (code0 == REG && code1 == REG
 		 && REGNO (arg0) < FIRST_PSEUDO_REGISTER
 		 && (ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)
-		     || ok_for_index_p_nonstrict (arg0)))
+		     || ok_for_index_p_nonstrict (arg0, mode)))
 	  record_address_regs (mode, arg1,
 			       ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)
 			       ? 1 : 0,
@@ -824,7 +825,7 @@
 	else if (code0 == REG && code1 == REG
 		 && REGNO (arg1) < FIRST_PSEUDO_REGISTER
 		 && (ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)
-		     || ok_for_index_p_nonstrict (arg1)))
+		     || ok_for_index_p_nonstrict (arg1, mode)))
 	  record_address_regs (mode, arg0,
 			       ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)
 			       ? 1 : 0,
diff -Nur a/gcc/longlong.h b/gcc/longlong.h
--- a/gcc/longlong.h	2009-02-12 17:30:53.000000000 +0100
+++ b/gcc/longlong.h	2010-01-25 09:50:29.145688053 +0100
@@ -982,7 +982,7 @@
 "	or r1,%0"							\
 	: "=r" (q), "=&z" (r)						\
 	: "1" (n1), "r" (n0), "rm" (d), "r" (&__udiv_qrnnd_16)		\
-	: "r1", "r2", "r4", "r5", "r6", "pr");				\
+	: "r1", "r2", "r4", "r5", "r6", "pr", "t");			\
   } while (0)
 
 #define UDIV_TIME 80
diff -Nur a/gcc/Makefile.in b/gcc/Makefile.in
--- a/gcc/Makefile.in	2009-05-22 01:17:37.000000000 +0200
+++ b/gcc/Makefile.in	2010-01-25 09:50:29.145688053 +0100
@@ -327,6 +327,8 @@
 # It also specifies -isystem ./include to find, e.g., stddef.h.
 GCC_CFLAGS=$(CFLAGS_FOR_TARGET) $(INTERNAL_CFLAGS) $(T_CFLAGS) $(LOOSE_WARN) -Wold-style-definition $($@-warn) -isystem ./include $(TCFLAGS)
 
+EGLIBC_CONFIGS = @EGLIBC_CONFIGS@
+
 # ---------------------------------------------------
 # Programs which produce files for the target machine
 # ---------------------------------------------------
@@ -408,6 +410,9 @@
 
 xmake_file=@xmake_file@
 tmake_file=@tmake_file@
+TM_ENDIAN_CONFIG=@TM_ENDIAN_CONFIG@
+TM_MULTILIB_CONFIG=@TM_MULTILIB_CONFIG@
+TM_MULTILIB_EXCEPTIONS_CONFIG=@TM_MULTILIB_EXCEPTIONS_CONFIG@
 out_file=$(srcdir)/config/@out_file@
 out_object_file=@out_object_file@
 md_file=$(srcdir)/config/@md_file@
@@ -542,6 +547,23 @@
 exeext = @host_exeext@
 build_exeext = @build_exeext@
 
+licensedir = @licensedir@
+ifneq ($(licensedir),) 
+# Header files for licensing.
+CSL_LICENSEINC = -I $(licensedir)/include
+# Libraries for licensing.
+CSL_LICENSELIB = -L$(licensedir)/lib -lcsllicense
+# The licensing program.  If the program does not exist, assume that
+# it is not needed.
+CSL_LICENSE_PROG = cs-license$(exeext)
+$(CSL_LICENSE_PROG):
+	if [ -f "$(licensedir)/libexec/cs-license$(exeext)" ] ; then \
+	  $(LN_S) $(licensedir)/libexec/cs-license$(exeext) . ;  \
+        else \
+	  touch $@; \
+	fi
+endif
+
 # Directory in which to put man pages.
 mandir = @mandir@
 man1dir = $(mandir)/man1
@@ -684,7 +706,7 @@
 
 # List of things which should already be built whenever we try to use xgcc
 # to compile anything (without linking).
-GCC_PASSES=xgcc$(exeext) cc1$(exeext) specs $(EXTRA_PASSES)
+GCC_PASSES=xgcc$(exeext) cc1$(exeext) specs $(EXTRA_PASSES) $(CSL_LICENSE_PROG)
 
 # Directory to link to, when using the target `maketest'.
 DIR = ../gcc
@@ -913,7 +935,7 @@
 
 # How to link with both our special library facilities
 # and the system's installed libraries.
-LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER)
+LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER) $(CSL_LICENSELIB)
 BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS)
 # Any system libraries needed just for GNAT.
 SYSLIBS = @GNAT_LIBEXC@
@@ -943,7 +965,7 @@
 INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \
 	   -I$(srcdir)/../include @INCINTL@ \
 	   $(CPPINC) $(GMPINC) $(DECNUMINC) \
-	   $(PPLINC) $(CLOOGINC)
+	   $(PPLINC) $(CLOOGINC) $(CSL_LICENSEINC)
 
 .c.o:
 	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)
@@ -1249,6 +1271,7 @@
 	tree-ssa-loop-manip.o \
 	tree-ssa-loop-niter.o \
 	tree-ssa-loop-prefetch.o \
+	tree-ssa-loop-promote.o \
 	tree-ssa-loop-unswitch.o \
 	tree-ssa-loop.o \
 	tree-ssa-math-opts.o \
@@ -1258,6 +1281,7 @@
 	tree-ssa-pre.o \
 	tree-ssa-propagate.o \
 	tree-ssa-reassoc.o \
+	tree-ssa-remove-local-statics.o \
 	tree-ssa-sccvn.o \
 	tree-ssa-sink.o \
 	tree-ssa-structalias.o \
@@ -1674,7 +1698,7 @@
 	$(MACHMODE_H) $(FPBIT) $(DPBIT) $(TPBIT) $(LIB2ADD) \
 	$(LIB2ADD_ST) $(LIB2ADDEH) $(srcdir)/emutls.c gcov-iov.h $(SFP_MACHINE)
 
-libgcc.mvars: config.status Makefile $(LIB2ADD) $(LIB2ADD_ST) specs \
+libgcc.mvars: config.status Makefile $(LIB2ADD) $(LIB2ADD_ST) specs $(tmake_file) \
 		xgcc$(exeext)
 	: > tmp-libgcc.mvars
 	echo LIB1ASMFUNCS = '$(LIB1ASMFUNCS)' >> tmp-libgcc.mvars
@@ -1728,7 +1752,7 @@
 # driver program needs to select the library directory based on the
 # switches.
 multilib.h: s-mlib; @true
-s-mlib: $(srcdir)/genmultilib Makefile
+s-mlib: $(srcdir)/genmultilib Makefile $(tmakefile)
 	if test @enable_multilib@ = yes \
 	   || test -n "$(MULTILIB_OSDIRNAMES)"; then \
 	  $(SHELL) $(srcdir)/genmultilib \
@@ -1739,10 +1763,11 @@
 	    "$(MULTILIB_EXTRA_OPTS)" \
 	    "$(MULTILIB_EXCLUSIONS)" \
 	    "$(MULTILIB_OSDIRNAMES)" \
+	    "$(MULTILIB_ALIASES)" \
 	    "@enable_multilib@" \
 	    > tmp-mlib.h; \
 	else \
-	  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' no \
+	  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' '' no \
 	    > tmp-mlib.h; \
 	fi
 	$(SHELL) $(srcdir)/../move-if-change tmp-mlib.h multilib.h
@@ -1816,7 +1841,7 @@
 
 incpath.o: incpath.c incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \
 		intl.h prefix.h coretypes.h $(TM_H) cppdefault.h $(TARGET_H) \
-		$(MACHMODE_H)
+		$(MACHMODE_H) $(FLAGS_H) toplev.h
 
 c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
     $(RTL_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) $(FLAGS_H) $(FUNCTION_H) output.h \
@@ -1900,7 +1925,7 @@
         $(TREE_H) $(C_PRAGMA_H) $(FLAGS_H) $(TOPLEV_H) langhooks.h		\
         $(TREE_INLINE_H) $(DIAGNOSTIC_H) intl.h debug.h $(C_COMMON_H)	\
         opts.h options.h $(MKDEPS_H) incpath.h cppdefault.h $(TARGET_H) \
-	$(TM_P_H) $(VARRAY_H)
+	$(TM_P_H) $(VARRAY_H) $(C_TREE_H)
 	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
 		$< $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@
 
@@ -1953,7 +1978,8 @@
   -DTOOLDIR_BASE_PREFIX=\"$(libsubdir_to_prefix)$(prefix_to_exec_prefix)\" \
   @TARGET_SYSTEM_ROOT_DEFINE@ \
   $(VALGRIND_DRIVER_DEFINES) \
-  `test "X$${SHLIB_LINK}" = "X" || test "@enable_shared@" != "yes" || echo "-DENABLE_SHARED_LIBGCC"`
+  `test "X$${SHLIB_LINK}" = "X" || test "@enable_shared@" != "yes" || echo "-DENABLE_SHARED_LIBGCC"` \
+  -DCONFIGURE_SPECS="\"@CONFIGURE_SPECS@\""
 
 gcc.o: gcc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h multilib.h \
     Makefile $(lang_specs_files) specs.h prefix.h $(GCC_H) $(FLAGS_H) \
@@ -2176,6 +2202,9 @@
    alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) $(HASHTAB_H) $(GIMPLE_H) \
    $(TREE_INLINE_H) tree-iterator.h tree-ssa-sccvn.h $(PARAMS_H) \
    $(DBGCNT_H)
+tree-ssa-remove-local-statics.o: tree-ssa-remove-local-statics.c \
+   coretypes.h $(CONFIG_H) $(SYSTEM_H) $(BASIC_BLOCK_H) tree.h tree-pass.h \
+   $(TM_H) $(HASHTAB_H) $(BASIC_BLOCK_H)
 tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \
    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(FIBHEAP_H) \
    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(CFGLOOP_H) \
@@ -2271,6 +2300,12 @@
    $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \
    tree-chrec.h $(TOPLEV_H) langhooks.h $(TREE_INLINE_H) $(TREE_DATA_REF_H) \
    $(OPTABS_H)
+tree-ssa-loop-promote.o: tree-ssa-loop-promote.c \
+   coretypes.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H) \
+   $(RTL_H) $(TM_P_H) hard-reg-set.h $(OBSTACK_H) $(BASIC_BLOCK_H) \
+   pointer-set.h intl.h $(TREE_H) $(GIMPLE_H) $(HASHTAB_H) $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(FLAGS_H) $(TIMEVAR_H) \
+   tree-pass.h $(TM_H)
 tree-predcom.o: tree-predcom.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_P_H) \
    $(CFGLOOP_H) $(TREE_FLOW_H) $(GGC_H) $(TREE_DATA_REF_H) $(SCEV_H) \
    $(PARAMS_H) $(DIAGNOSTIC_H) tree-pass.h $(TM_H) coretypes.h tree-affine.h \
@@ -2865,7 +2900,7 @@
    $(RTL_H) $(REAL_H) $(FLAGS_H) $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) \
    hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) output.h \
    $(FUNCTION_H) $(TOPLEV_H) cselib.h $(TM_P_H) except.h $(TREE_H) $(MACHMODE_H) \
-   $(OBSTACK_H) $(TIMEVAR_H) tree-pass.h $(DF_H) $(DBGCNT_H)
+   $(OBSTACK_H) $(TIMEVAR_H) tree-pass.h addresses.h $(DF_H) $(DBGCNT_H)
 postreload-gcse.o : postreload-gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(TOPLEV_H) \
@@ -3582,7 +3617,7 @@
 # be rebuilt.
 
 # Build the include directories.
-stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) $(UNWIND_H) fixinc_list
+stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) $(UNWIND_H)
 # Copy in the headers provided with gcc.
 # The sed command gets just the last file name component;
 # this is necessary because VPATH could add a dirname.
@@ -3601,21 +3636,23 @@
 	done
 	rm -f include/unwind.h
 	cp $(UNWIND_H) include/unwind.h
-	set -e; for ml in `cat fixinc_list`; do \
-	  sysroot_headers_suffix=`echo $${ml} | sed -e 's/;.*$$//'`; \
-	  multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \
-	  fix_dir=include-fixed$${multi_dir}; \
-	  if $(LIMITS_H_TEST) ; then \
-	    cat $(srcdir)/limitx.h $(srcdir)/glimits.h $(srcdir)/limity.h > tmp-xlimits.h; \
-	  else \
-	    cat $(srcdir)/glimits.h > tmp-xlimits.h; \
-	  fi; \
-	  $(mkinstalldirs) $${fix_dir}; \
-	  chmod a+rx $${fix_dir} || true; \
-	  rm -f $${fix_dir}/limits.h; \
-	  mv tmp-xlimits.h $${fix_dir}/limits.h; \
-	  chmod a+r $${fix_dir}/limits.h; \
-	done
+	set -e; if [ -f fixinc_list ] ; then \
+	  for ml in `cat fixinc_list`; do \
+	    sysroot_headers_suffix=`echo $${ml} | sed -e 's/;.*$$//'`; \
+	    multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \
+	    fix_dir=include-fixed$${multi_dir}; \
+	    if $(LIMITS_H_TEST) ; then \
+	      cat $(srcdir)/limitx.h $(srcdir)/glimits.h $(srcdir)/limity.h > tmp-xlimits.h; \
+	    else \
+	      cat $(srcdir)/glimits.h > tmp-xlimits.h; \
+	    fi; \
+	    $(mkinstalldirs) $${fix_dir}; \
+	    chmod a+rx $${fix_dir} || true; \
+	    rm -f $${fix_dir}/limits.h; \
+	    mv tmp-xlimits.h $${fix_dir}/limits.h; \
+	    chmod a+r $${fix_dir}/limits.h; \
+	  done; \
+	fi
 # Install the README
 	rm -f include-fixed/README
 	cp $(srcdir)/../fixincludes/README-fixinc include-fixed/README
@@ -4340,16 +4377,18 @@
 
 # Install supporting files for fixincludes to be run later.
 install-mkheaders: stmp-int-hdrs $(STMP_FIXPROTO) install-itoolsdirs \
-  macro_list fixinc_list
+  macro_list
 	$(INSTALL_DATA) $(srcdir)/gsyslimits.h \
 	  $(DESTDIR)$(itoolsdatadir)/gsyslimits.h
 	$(INSTALL_DATA) macro_list $(DESTDIR)$(itoolsdatadir)/macro_list
-	$(INSTALL_DATA) fixinc_list $(DESTDIR)$(itoolsdatadir)/fixinc_list
-	set -e; for ml in `cat fixinc_list`; do \
-	  multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \
-	  $(mkinstalldirs) $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}; \
-	  $(INSTALL_DATA) include-fixed$${multidir}/limits.h $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}/limits.h; \
-	done
+	set -e; if [ -f fixinc_list ] ; then \
+	  $(INSTALL_DATA) fixinc_list $(DESTDIR)$(itoolsdatadir)/fixinc_list; \
+	  for ml in `cat fixinc_list`; do \
+	    multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \
+	    $(mkinstalldirs) $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}; \
+	    $(INSTALL_DATA) include-fixed$${multidir}/limits.h $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}/limits.h; \
+	  done; \
+	fi
 	$(INSTALL_SCRIPT) $(srcdir)/../mkinstalldirs \
 		$(DESTDIR)$(itoolsdir)/mkinstalldirs ; \
 	if [ x$(STMP_FIXPROTO) != x ] ; then \
diff -Nur a/gcc/modulo-sched.c b/gcc/modulo-sched.c
--- a/gcc/modulo-sched.c	2008-09-01 10:57:00.000000000 +0200
+++ b/gcc/modulo-sched.c	2010-01-25 09:50:29.155687438 +0100
@@ -270,6 +270,7 @@
   NULL,
   sms_print_insn,
   NULL,
+  NULL, /* insn_finishes_block_p */
   NULL, NULL,
   NULL, NULL,
   0, 0,
diff -Nur a/gcc/optabs.c b/gcc/optabs.c
--- a/gcc/optabs.c	2009-03-17 18:46:23.000000000 +0100
+++ b/gcc/optabs.c	2010-01-25 09:50:29.155687438 +0100
@@ -3300,7 +3300,8 @@
       if (unoptab == ffs_optab || unoptab == clz_optab || unoptab == ctz_optab
 	  || unoptab == popcount_optab || unoptab == parity_optab)
 	outmode
-	    = GET_MODE (hard_libcall_value (TYPE_MODE (integer_type_node)));
+	  = GET_MODE (hard_libcall_value (TYPE_MODE (integer_type_node),
+					  optab_libfunc (unoptab, mode)));
 
       start_sequence ();
 
@@ -4357,10 +4358,12 @@
        mode != VOIDmode;
        mode = GET_MODE_WIDER_MODE (mode))
     {
-      if ((libfunc = optab_libfunc (code_to_optab[comparison], mode)))
+      if (code_to_optab[comparison]
+	  && (libfunc = optab_libfunc (code_to_optab[comparison], mode)))
 	break;
 
-      if ((libfunc = optab_libfunc (code_to_optab[swapped] , mode)))
+      if (code_to_optab[swapped]
+	  && (libfunc = optab_libfunc (code_to_optab[swapped], mode)))
 	{
 	  rtx tmp;
 	  tmp = x; x = y; y = tmp;
@@ -4368,7 +4371,8 @@
 	  break;
 	}
 
-      if ((libfunc = optab_libfunc (code_to_optab[reversed], mode))
+      if (code_to_optab[reversed]
+	  && (libfunc = optab_libfunc (code_to_optab[reversed], mode))
 	  && FLOAT_LIB_COMPARE_RETURNS_BOOL (mode, reversed))
 	{
 	  comparison = reversed;
diff -Nur a/gcc/opts.c b/gcc/opts.c
--- a/gcc/opts.c	2009-03-28 18:28:45.000000000 +0100
+++ b/gcc/opts.c	2010-01-25 09:50:29.155687438 +0100
@@ -904,7 +904,7 @@
   flag_tree_vrp = opt2;
   flag_tree_builtin_call_dce = opt2;
   flag_tree_pre = opt2;
-  flag_tree_switch_conversion = 1;
+  flag_tree_switch_conversion = opt2;
   flag_ipa_cp = opt2;
 
   /* Allow more virtual operators to increase alias precision.  */
@@ -928,6 +928,7 @@
   flag_gcse_after_reload = opt3;
   flag_tree_vectorize = opt3;
   flag_ipa_cp_clone = opt3;
+  flag_tree_pre_partial_partial = opt3;
   if (flag_ipa_cp_clone)
     flag_ipa_cp = 1;
 
@@ -951,10 +952,13 @@
 	 being declared inline.  */
       flag_inline_functions = 1;
 
-      /* Basic optimization options.  */
-      optimize_size = 1;
+      /* Basic optimization options at -Os are almost the same as -O2.  The
+	 only difference is that we disable PRE, because it sometimes still
+	 increases code size.  If the user want to run PRE with -Os, he/she
+	 will have to indicate so explicitly.  */
       if (optimize > 2)
 	optimize = 2;
+      flag_tree_pre = 0;
 
       /* We want to crossjump as much as possible.  */
       set_param_value ("min-crossjump-insns", 1);
@@ -2060,6 +2064,10 @@
       /* These are no-ops, preserved for backward compatibility.  */
       break;
 
+    case OPT_feglibc_:
+      /* This is a no-op at the moment.  */
+      break;
+
     default:
       /* If the flag was handled in a standard way, assume the lack of
 	 processing here is intentional.  */
diff -Nur a/gcc/passes.c b/gcc/passes.c
--- a/gcc/passes.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/passes.c	2010-01-25 09:50:29.155687438 +0100
@@ -591,6 +591,7 @@
       NEXT_PASS (pass_rename_ssa_copies);
       NEXT_PASS (pass_complete_unrolli);
       NEXT_PASS (pass_ccp);
+      NEXT_PASS (pass_promote_indices);
       NEXT_PASS (pass_forwprop);
       /* Ideally the function call conditional
 	 dead code elimination phase can be delayed
@@ -605,6 +606,7 @@
 	 alias information also rewrites no longer addressed
 	 locals into SSA form if possible.  */
       NEXT_PASS (pass_build_alias);
+      NEXT_PASS (pass_remove_local_statics);
       NEXT_PASS (pass_return_slot);
       NEXT_PASS (pass_phiprop);
       NEXT_PASS (pass_fre);
diff -Nur a/gcc/pointer-set.c b/gcc/pointer-set.c
--- a/gcc/pointer-set.c	2007-08-16 16:31:21.000000000 +0200
+++ b/gcc/pointer-set.c	2010-01-25 09:50:29.155687438 +0100
@@ -181,6 +181,23 @@
       break;
 }
 
+/* Return the number of elements in PSET.  */
+
+size_t
+pointer_set_n_elements (struct pointer_set_t *pset)
+{
+  return pset->n_elements;
+}
+
+/* Remove all entries from PSET.  */
+
+void
+pointer_set_clear (struct pointer_set_t *pset)
+{
+  pset->n_elements = 0;
+  memset (pset->slots, 0, sizeof (pset->slots[0]) * pset->n_slots);
+}
+
 
 /* A pointer map is represented the same way as a pointer_set, so
    the hash code is based on the address of the key, rather than
@@ -301,3 +318,20 @@
     if (pmap->keys[i] && !fn (pmap->keys[i], &pmap->values[i], data))
       break;
 }
+
+/* Return the number of elements in PMAP.  */
+
+size_t
+pointer_map_n_elements (struct pointer_map_t *pmap)
+{
+  return pmap->n_elements;
+}
+
+/* Remove all entries from PMAP.  */
+
+void pointer_map_clear (struct pointer_map_t *pmap)
+{
+  pmap->n_elements = 0;
+  memset (pmap->keys, 0, sizeof (pmap->keys[0]) * pmap->n_slots);
+  memset (pmap->values, 0, sizeof (pmap->values[0]) * pmap->n_slots);
+}
diff -Nur a/gcc/pointer-set.h b/gcc/pointer-set.h
--- a/gcc/pointer-set.h	2007-08-16 16:31:21.000000000 +0200
+++ b/gcc/pointer-set.h	2010-01-25 09:50:29.155687438 +0100
@@ -29,6 +29,8 @@
 void pointer_set_traverse (const struct pointer_set_t *,
 			   bool (*) (const void *, void *),
 			   void *);
+size_t pointer_set_n_elements (struct pointer_set_t *);
+void pointer_set_clear (struct pointer_set_t *);
 
 struct pointer_map_t;
 struct pointer_map_t *pointer_map_create (void);
@@ -38,5 +40,7 @@
 void **pointer_map_insert (struct pointer_map_t *pmap, const void *p);
 void pointer_map_traverse (const struct pointer_map_t *,
 			   bool (*) (const void *, void **, void *), void *);
+size_t pointer_map_n_elements (struct pointer_map_t *);
+void pointer_map_clear (struct pointer_map_t *);
 
 #endif  /* POINTER_SET_H  */
diff -Nur a/gcc/postreload.c b/gcc/postreload.c
--- a/gcc/postreload.c	2008-08-31 11:44:25.000000000 +0200
+++ b/gcc/postreload.c	2010-01-25 09:50:29.155687438 +0100
@@ -46,6 +46,7 @@
 #include "tree.h"
 #include "timevar.h"
 #include "tree-pass.h"
+#include "addresses.h"
 #include "df.h"
 #include "dbgcnt.h"
 
@@ -708,17 +709,19 @@
   int last_label_ruid;
   int min_labelno, n_labels;
   HARD_REG_SET ever_live_at_start, *label_live;
+  enum reg_class index_regs;
 
   /* If reg+reg can be used in offsetable memory addresses, the main chunk of
      reload has already used it where appropriate, so there is no use in
      trying to generate it now.  */
-  if (double_reg_address_ok && INDEX_REG_CLASS != NO_REGS)
+  index_regs = index_reg_class (VOIDmode);
+  if (double_reg_address_ok && index_regs != NO_REGS)
     return;
 
   /* To avoid wasting too much time later searching for an index register,
      determine the minimum and maximum index register numbers.  */
   for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)
-    if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], r))
+    if (TEST_HARD_REG_BIT (reg_class_contents[index_regs], r))
       {
 	if (first_index_reg == -1)
 	  first_index_reg = r;
@@ -826,8 +829,8 @@
 	     substitute uses of REG (typically in MEMs) with.
 	     First check REG and BASE for being index registers;
 	     we can use them even if they are not dead.  */
-	  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], regno)
-	      || TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS],
+	  if (TEST_HARD_REG_BIT (reg_class_contents[index_regs], regno)
+	      || TEST_HARD_REG_BIT (reg_class_contents[index_regs],
 				    REGNO (base)))
 	    {
 	      const_reg = reg;
@@ -841,8 +844,7 @@
 		 two registers.  */
 	      for (i = first_index_reg; i <= last_index_reg; i++)
 		{
-		  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS],
-					 i)
+		  if (TEST_HARD_REG_BIT (reg_class_contents[index_regs], i)
 		      && reg_state[i].use_index == RELOAD_COMBINE_MAX_USES
 		      && reg_state[i].store_ruid <= reg_state[regno].use_ruid
 		      && hard_regno_nregs[i][GET_MODE (reg)] == 1)
diff -Nur a/gcc/real.c b/gcc/real.c
--- a/gcc/real.c	2009-02-06 22:01:46.000000000 +0100
+++ b/gcc/real.c	2010-01-25 09:50:29.155687438 +0100
@@ -4513,6 +4513,167 @@
     false
   };
 
+/* Encode half-precision floats.  This routine is used both for the IEEE
+   ARM alternative encodings.  */
+static void
+encode_ieee_half (const struct real_format *fmt, long *buf,
+		  const REAL_VALUE_TYPE *r)
+{
+  unsigned long image, sig, exp;
+  unsigned long sign = r->sign;
+  bool denormal = (r->sig[SIGSZ-1] & SIG_MSB) == 0;
+
+  image = sign << 15;
+  sig = (r->sig[SIGSZ-1] >> (HOST_BITS_PER_LONG - 11)) & 0x3ff;
+
+  switch (r->cl)
+    {
+    case rvc_zero:
+      break;
+
+    case rvc_inf:
+      if (fmt->has_inf)
+	image |= 31 << 10;
+      else
+	image |= 0x7fff;
+      break;
+
+    case rvc_nan:
+      if (fmt->has_nans)
+	{
+	  if (r->canonical)
+	    sig = (fmt->canonical_nan_lsbs_set ? (1 << 9) - 1 : 0);
+	  if (r->signalling == fmt->qnan_msb_set)
+	    sig &= ~(1 << 9);
+	  else
+	    sig |= 1 << 9;
+	  if (sig == 0)
+	    sig = 1 << 8;
+
+	  image |= 31 << 10;
+	  image |= sig;
+	}
+      else
+	image |= 0x3ff;
+      break;
+
+    case rvc_normal:
+      /* Recall that IEEE numbers are interpreted as 1.F x 2**exp,
+	 whereas the intermediate representation is 0.F x 2**exp.
+	 Which means we're off by one.  */
+      if (denormal)
+	exp = 0;
+      else
+	exp = REAL_EXP (r) + 15 - 1;
+      image |= exp << 10;
+      image |= sig;
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+
+  buf[0] = image;
+}
+
+/* Decode half-precision floats.  This routine is used both for the IEEE
+   ARM alternative encodings.  */
+static void
+decode_ieee_half (const struct real_format *fmt, REAL_VALUE_TYPE *r,
+		  const long *buf)
+{
+  unsigned long image = buf[0] & 0xffff;
+  bool sign = (image >> 15) & 1;
+  int exp = (image >> 10) & 0x1f;
+
+  memset (r, 0, sizeof (*r));
+  image <<= HOST_BITS_PER_LONG - 11;
+  image &= ~SIG_MSB;
+
+  if (exp == 0)
+    {
+      if (image && fmt->has_denorm)
+	{
+	  r->cl = rvc_normal;
+	  r->sign = sign;
+	  SET_REAL_EXP (r, -14);
+	  r->sig[SIGSZ-1] = image << 1;
+	  normalize (r);
+	}
+      else if (fmt->has_signed_zero)
+	r->sign = sign;
+    }
+  else if (exp == 31 && (fmt->has_nans || fmt->has_inf))
+    {
+      if (image)
+	{
+	  r->cl = rvc_nan;
+	  r->sign = sign;
+	  r->signalling = (((image >> (HOST_BITS_PER_LONG - 2)) & 1)
+			   ^ fmt->qnan_msb_set);
+	  r->sig[SIGSZ-1] = image;
+	}
+      else
+	{
+	  r->cl = rvc_inf;
+	  r->sign = sign;
+	}
+    }
+  else
+    {
+      r->cl = rvc_normal;
+      r->sign = sign;
+      SET_REAL_EXP (r, exp - 15 + 1);
+      r->sig[SIGSZ-1] = image | SIG_MSB;
+    }
+}
+
+/* Half-precision format, as specified in IEEE 754R.  */
+const struct real_format ieee_half_format =
+  {
+    encode_ieee_half,
+    decode_ieee_half,
+    2,
+    11,
+    11,
+    -13,
+    16,
+    15,
+    15,
+    false,
+    true,
+    true,
+    true,
+    true,
+    true,
+    true,
+    false
+  };
+
+/* ARM's alternative half-precision format, similar to IEEE but with
+   no reserved exponent value for NaNs and infinities; rather, it just
+   extends the range of exponents by one.  */
+const struct real_format arm_half_format =
+  {
+    encode_ieee_half,
+    decode_ieee_half,
+    2,
+    11,
+    11,
+    -13,
+    17,
+    15,
+    15,
+    false,
+    true,
+    false,
+    false,
+    true,
+    true,
+    false,
+    false
+  };
+
 /* A synthetic "format" for internal arithmetic.  It's the size of the
    internal significand minus the two bits needed for proper rounding.
    The encode and decode routines exist only to satisfy our paranoia
diff -Nur a/gcc/real.h b/gcc/real.h
--- a/gcc/real.h	2008-10-29 18:05:42.000000000 +0100
+++ b/gcc/real.h	2010-01-25 09:50:29.155687438 +0100
@@ -304,6 +304,8 @@
 extern const struct real_format decimal_single_format;
 extern const struct real_format decimal_double_format;
 extern const struct real_format decimal_quad_format;
+extern const struct real_format ieee_half_format;
+extern const struct real_format arm_half_format;
 
 
 /* ====================================================================== */
diff -Nur a/gcc/regrename.c b/gcc/regrename.c
--- a/gcc/regrename.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/regrename.c	2010-01-25 09:50:29.155687438 +0100
@@ -567,14 +567,14 @@
 	    int index_op;
 	    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);
 
-	    if (REGNO_OK_FOR_INDEX_P (regno1)
+	    if (regno_ok_for_index_p (regno1, mode)
 		&& regno_ok_for_base_p (regno0, mode, PLUS, REG))
 	      index_op = 1;
-	    else if (REGNO_OK_FOR_INDEX_P (regno0)
+	    else if (regno_ok_for_index_p (regno0, mode)
 		     && regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
 	    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG)
-		     || REGNO_OK_FOR_INDEX_P (regno1))
+		     || regno_ok_for_index_p (regno1, mode))
 	      index_op = 1;
 	    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
@@ -599,7 +599,7 @@
 	  }
 
 	if (locI)
-	  scan_rtx_address (insn, locI, INDEX_REG_CLASS, action, mode);
+	  scan_rtx_address (insn, locI, index_reg_class (mode), action, mode);
 	if (locB)
 	  scan_rtx_address (insn, locB, base_reg_class (mode, PLUS, index_code),
 			    action, mode);
@@ -1488,14 +1488,14 @@
 	    int index_op;
 	    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);
 
-	    if (REGNO_OK_FOR_INDEX_P (regno1)
+	    if (regno_ok_for_index_p (regno1, mode)
 		&& regno_ok_for_base_p (regno0, mode, PLUS, REG))
 	      index_op = 1;
-	    else if (REGNO_OK_FOR_INDEX_P (regno0)
+	    else if (regno_ok_for_index_p (regno0, mode)
 		     && regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
 	    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG)
-		     || REGNO_OK_FOR_INDEX_P (regno1))
+		     || regno_ok_for_index_p (regno1, mode))
 	      index_op = 1;
 	    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
@@ -1520,8 +1520,8 @@
 	  }
 
 	if (locI)
-	  changed |= replace_oldest_value_addr (locI, INDEX_REG_CLASS, mode,
-						insn, vd);
+	  changed |= replace_oldest_value_addr (locI, index_reg_class (mode),
+						mode, insn, vd);
 	if (locB)
 	  changed |= replace_oldest_value_addr (locB,
 						base_reg_class (mode, PLUS,
diff -Nur a/gcc/reload.c b/gcc/reload.c
--- a/gcc/reload.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/reload.c	2010-01-25 09:50:29.155687438 +0100
@@ -5046,7 +5046,7 @@
 	    loc = &XEXP (*loc, 0);
 	}
 
-      if (double_reg_address_ok)
+      if (double_reg_address_ok && index_reg_class (mode) != NO_REGS)
 	{
 	  /* Unshare the sum as well.  */
 	  *loc = ad = copy_rtx (ad);
@@ -5054,8 +5054,8 @@
 	  /* Reload the displacement into an index reg.
 	     We assume the frame pointer or arg pointer is a base reg.  */
 	  find_reloads_address_part (XEXP (ad, 1), &XEXP (ad, 1),
-				     INDEX_REG_CLASS, GET_MODE (ad), opnum,
-				     type, ind_levels);
+				     index_reg_class (mode), GET_MODE (ad),
+				     opnum, type, ind_levels);
 	  return 0;
 	}
       else
@@ -5448,13 +5448,13 @@
 #define REG_OK_FOR_CONTEXT(CONTEXT, REGNO, MODE, OUTER, INDEX)		\
   ((CONTEXT) == 0							\
    ? regno_ok_for_base_p (REGNO, MODE, OUTER, INDEX)			\
-   : REGNO_OK_FOR_INDEX_P (REGNO))					
+   : regno_ok_for_index_p (REGNO, MODE))
 
   enum reg_class context_reg_class;
   RTX_CODE code = GET_CODE (x);
 
   if (context == 1)
-    context_reg_class = INDEX_REG_CLASS;
+    context_reg_class = index_reg_class (mode);
   else
     context_reg_class = base_reg_class (mode, outer_code, index_code);
 
@@ -5546,17 +5546,17 @@
 
 	else if (code0 == REG && code1 == REG)
 	  {
-	    if (REGNO_OK_FOR_INDEX_P (REGNO (op1))
+	    if (regno_ok_for_index_p (REGNO (op1), mode)
 		&& regno_ok_for_base_p (REGNO (op0), mode, PLUS, REG))
 	      return 0;
-	    else if (REGNO_OK_FOR_INDEX_P (REGNO (op0))
+	    else if (regno_ok_for_index_p (REGNO (op0), mode)
 		     && regno_ok_for_base_p (REGNO (op1), mode, PLUS, REG))
 	      return 0;
 	    else if (regno_ok_for_base_p (REGNO (op0), mode, PLUS, REG))
 	      find_reloads_address_1 (mode, orig_op1, 1, PLUS, SCRATCH,
 				      &XEXP (x, 1), opnum, type, ind_levels,
 				      insn);
-	    else if (REGNO_OK_FOR_INDEX_P (REGNO (op1)))
+	    else if (regno_ok_for_index_p (REGNO (op1), mode))
 	      find_reloads_address_1 (mode, orig_op0, 0, PLUS, REG,
 				      &XEXP (x, 0), opnum, type, ind_levels,
 				      insn);
@@ -5564,7 +5564,7 @@
 	      find_reloads_address_1 (mode, orig_op0, 1, PLUS, SCRATCH,
 				      &XEXP (x, 0), opnum, type, ind_levels,
 				      insn);
-	    else if (REGNO_OK_FOR_INDEX_P (REGNO (op0)))
+	    else if (regno_ok_for_index_p (REGNO (op0), mode))
 	      find_reloads_address_1 (mode, orig_op1, 0, PLUS, REG,
 				      &XEXP (x, 1), opnum, type, ind_levels,
 				      insn);
@@ -5634,7 +5634,7 @@
 	   need to live longer than a TYPE reload normally would, so be
 	   conservative and class it as RELOAD_OTHER.  */
 	if ((REG_P (XEXP (op1, 1))
-	     && !REGNO_OK_FOR_INDEX_P (REGNO (XEXP (op1, 1))))
+	     && !regno_ok_for_index_p (REGNO (XEXP (op1, 1)), mode))
 	    || GET_CODE (XEXP (op1, 1)) == PLUS)
 	  find_reloads_address_1 (mode, XEXP (op1, 1), 1, code, SCRATCH,
 				  &XEXP (op1, 1), opnum, RELOAD_OTHER,
@@ -6128,18 +6128,26 @@
 	      /* For some processors an address may be valid in the
 		 original mode but not in a smaller mode.  For
 		 example, ARM accepts a scaled index register in
-		 SImode but not in HImode.  Similarly, the address may
-		 have been valid before the subreg offset was added,
-		 but not afterwards.  find_reloads_address
-		 assumes that we pass it a valid address, and doesn't
-		 force a reload.  This will probably be fine if
-		 find_reloads_address finds some reloads.  But if it
-		 doesn't find any, then we may have just converted a
-		 valid address into an invalid one.  Check for that
-		 here.  */
+		 SImode but not in HImode.  Note that this is only
+		 a problem if the address in reg_equiv_mem is already
+		 invalid in the new mode; other cases would be fixed
+		 by find_reloads_address as usual.
+
+		 ??? We attempt to handle such cases here by doing an
+		 additional reload of the full address after the
+		 usual processing by find_reloads_address.  Note that
+		 this may not work in the general case, but it seems
+		 to cover the cases where this situation currently
+		 occurs.  A more general fix might be to reload the
+		 *value* instead of the address, but this would not
+		 be expected by the callers of this routine as-is.
+
+		 If find_reloads_address already completed replaced
+		 the address, there is nothing further to do.  */
 	      if (reloaded == 0
-		  && !strict_memory_address_p (GET_MODE (tem),
-					       XEXP (tem, 0)))
+		  && reg_equiv_mem[regno] != 0
+		  && !strict_memory_address_p (GET_MODE (x),
+					       XEXP (reg_equiv_mem[regno], 0)))
 		push_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,
 			     base_reg_class (GET_MODE (tem), MEM, SCRATCH),
 			     GET_MODE (XEXP (tem, 0)), VOIDmode, 0, 0,
diff -Nur a/gcc/rtlanal.c b/gcc/rtlanal.c
--- a/gcc/rtlanal.c	2009-03-14 09:10:55.000000000 +0100
+++ b/gcc/rtlanal.c	2010-01-25 09:50:29.155687438 +0100
@@ -2913,62 +2913,78 @@
 commutative_operand_precedence (rtx op)
 {
   enum rtx_code code = GET_CODE (op);
+  int value;
   
   /* Constants always come the second operand.  Prefer "nice" constants.  */
   if (code == CONST_INT)
-    return -8;
-  if (code == CONST_DOUBLE)
-    return -7;
-  if (code == CONST_FIXED)
-    return -7;
-  op = avoid_constant_pool_reference (op);
-  code = GET_CODE (op);
-
-  switch (GET_RTX_CLASS (code))
-    {
-    case RTX_CONST_OBJ:
-      if (code == CONST_INT)
-        return -6;
-      if (code == CONST_DOUBLE)
-        return -5;
-      if (code == CONST_FIXED)
-        return -5;
-      return -4;
-
-    case RTX_EXTRA:
-      /* SUBREGs of objects should come second.  */
-      if (code == SUBREG && OBJECT_P (SUBREG_REG (op)))
-        return -3;
-      return 0;
+    value = -8;
+  else if (code == CONST_DOUBLE)
+    value = -7;
+  else if (code == CONST_FIXED)
+    value = -7;
+  else
+    {
+      op = avoid_constant_pool_reference (op);
+      code = GET_CODE (op);
+
+      switch (GET_RTX_CLASS (code))
+	{
+	case RTX_CONST_OBJ:
+	  if (code == CONST_INT)
+	    value = -6;
+	  else if (code == CONST_DOUBLE)
+	    value = -5;
+	  else if (code == CONST_FIXED)
+	    value = -5;
+	  else
+	    value = -4;
+	  break;
+
+	case RTX_EXTRA:
+	  /* SUBREGs of objects should come second.  */
+	  if (code == SUBREG && OBJECT_P (SUBREG_REG (op)))
+	    value = -3;
+	  else
+	    value = 0;
+	  break;
+
+	case RTX_OBJ:
+	  /* Complex expressions should be the first, so decrease priority
+	     of objects.  */
+	  value = -1;
+	  break;
 
-    case RTX_OBJ:
-      /* Complex expressions should be the first, so decrease priority
-         of objects.  Prefer pointer objects over non pointer objects.  */
-      if ((REG_P (op) && REG_POINTER (op))
-	  || (MEM_P (op) && MEM_POINTER (op)))
-	return -1;
-      return -2;
-
-    case RTX_COMM_ARITH:
-      /* Prefer operands that are themselves commutative to be first.
-         This helps to make things linear.  In particular,
-         (and (and (reg) (reg)) (not (reg))) is canonical.  */
-      return 4;
-
-    case RTX_BIN_ARITH:
-      /* If only one operand is a binary expression, it will be the first
-         operand.  In particular,  (plus (minus (reg) (reg)) (neg (reg)))
-         is canonical, although it will usually be further simplified.  */
-      return 2;
+	case RTX_COMM_ARITH:
+	  /* Prefer operands that are themselves commutative to be first.
+	     This helps to make things linear.  In particular,
+	     (and (and (reg) (reg)) (not (reg))) is canonical.  */
+	  value = 4;
+	  break;
+
+	case RTX_BIN_ARITH:
+	  /* If only one operand is a binary expression, it will be the first
+	     operand.  In particular,  (plus (minus (reg) (reg)) (neg (reg)))
+	     is canonical, although it will usually be further simplified.  */
+	  value = 2;
+	  break;
   
-    case RTX_UNARY:
-      /* Then prefer NEG and NOT.  */
-      if (code == NEG || code == NOT)
-        return 1;
+	case RTX_UNARY:
+	  /* Then prefer NEG and NOT.  */
+	  if (code == NEG || code == NOT)
+	    value = 1;
+	  else
+	    value = 0;
+	  break;
 
-    default:
-      return 0;
+	default:
+	  value = 0;
+	}
     }
+
+  if (targetm.commutative_operand_precedence)
+    value = targetm.commutative_operand_precedence (op, value);
+
+  return value;
 }
 
 /* Return 1 iff it is necessary to swap operands of commutative operation
diff -Nur a/gcc/rtl.def b/gcc/rtl.def
--- a/gcc/rtl.def	2008-02-26 17:05:24.000000000 +0100
+++ b/gcc/rtl.def	2010-01-25 09:50:29.155687438 +0100
@@ -1088,7 +1088,11 @@
    guard for the bypass.  The function will get the two insns as
    parameters.  If the function returns zero the bypass will be
    ignored for this case.  Additional guard is necessary to recognize
-   complicated bypasses, e.g. when consumer is load address.  */
+   complicated bypasses, e.g. when consumer is load address.  If there
+   are more one bypass with the same output and input insns, the
+   chosen bypass is the first bypass with a guard in description whose
+   guard function returns nonzero.  If there is no such bypass, then
+   bypass without the guard function is chosen.  */
 DEF_RTL_EXPR(DEFINE_BYPASS, "define_bypass", "issS", RTX_EXTRA)
 
 /* (define_automaton string) describes names of automata generated and
diff -Nur a/gcc/sched-ebb.c b/gcc/sched-ebb.c
--- a/gcc/sched-ebb.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/sched-ebb.c	2010-01-25 09:50:29.155687438 +0100
@@ -286,6 +286,7 @@
   rank,
   ebb_print_insn,
   ebb_contributes_to_priority,
+  NULL, /* insn_finishes_block_p */
 
   NULL, NULL,
   NULL, NULL,
diff -Nur a/gcc/sched-int.h b/gcc/sched-int.h
--- a/gcc/sched-int.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/sched-int.h	2010-01-25 09:50:29.155687438 +0100
@@ -558,6 +558,10 @@
      calculations.  */
   int (*contributes_to_priority) (rtx, rtx);
 
+  /* Return true if scheduling insn (passed as the parameter) will trigger
+     finish of scheduling current block.  */
+  bool (*insn_finishes_block_p) (rtx);
+
   /* The boundaries of the set of insns to be scheduled.  */
   rtx prev_head, next_tail;
 
diff -Nur a/gcc/sched-rgn.c b/gcc/sched-rgn.c
--- a/gcc/sched-rgn.c	2008-09-18 10:29:48.000000000 +0200
+++ b/gcc/sched-rgn.c	2010-01-25 09:50:29.155687438 +0100
@@ -2338,6 +2338,19 @@
     0, 0, 0
   };
 
+/* Return true if scheduling INSN will trigger finish of scheduling
+   current block.  */
+static bool
+rgn_insn_finishes_block_p (rtx insn)
+{
+  if (INSN_BB (insn) == target_bb
+      && sched_target_n_insns + 1 == target_n_insns)
+    /* INSN is the last not-scheduled instruction in the current block.  */
+    return true;
+
+  return false;
+}
+
 /* Used in schedule_insns to initialize current_sched_info for scheduling
    regions (or single basic blocks).  */
 
@@ -2350,6 +2363,7 @@
   rgn_rank,
   rgn_print_insn,
   contributes_to_priority,
+  rgn_insn_finishes_block_p,
 
   NULL, NULL,
   NULL, NULL,
diff -Nur a/gcc/sdbout.c b/gcc/sdbout.c
--- a/gcc/sdbout.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/sdbout.c	2010-01-25 09:50:29.155687438 +0100
@@ -337,6 +337,7 @@
   debug_nothing_int,		         /* handle_pch */
   debug_nothing_rtx,		         /* var_location */
   debug_nothing_void,                    /* switch_text_section */
+  debug_nothing_tree_tree,		 /* set_name */
   0                                      /* start_end_main_source_file */
 };
 
diff -Nur a/gcc/sel-sched-ir.c b/gcc/sel-sched-ir.c
--- a/gcc/sel-sched-ir.c	2008-10-12 01:39:21.000000000 +0200
+++ b/gcc/sel-sched-ir.c	2010-01-25 09:50:29.165687452 +0100
@@ -5431,6 +5431,7 @@
   NULL, /* rgn_rank */
   sel_print_insn, /* rgn_print_insn */
   contributes_to_priority,
+  NULL, /* insn_finishes_block_p */
 
   NULL, NULL,
   NULL, NULL,
diff -Nur a/gcc/target-def.h b/gcc/target-def.h
--- a/gcc/target-def.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/target-def.h	2010-01-25 09:50:29.165687452 +0100
@@ -84,7 +84,7 @@
 #define TARGET_ASM_INTERNAL_LABEL default_internal_label
 #endif
 
-#ifndef TARGET_ARM_TTYPE
+#ifndef TARGET_ASM_TTYPE
 #define TARGET_ASM_TTYPE hook_bool_rtx_false
 #endif
 
@@ -208,6 +208,10 @@
 #define TARGET_EXTRA_LIVE_ON_ENTRY hook_void_bitmap
 #endif
 
+#ifndef TARGET_WARN_FUNC_RESULT
+#define TARGET_WARN_FUNC_RESULT hook_bool_void_true
+#endif
+
 #ifndef TARGET_ASM_FILE_START_APP_OFF
 #define TARGET_ASM_FILE_START_APP_OFF false
 #endif
@@ -383,6 +387,9 @@
 #define TARGET_VECTOR_ALIGNMENT_REACHABLE \
   default_builtin_vector_alignment_reachable
 #define TARGET_VECTORIZE_BUILTIN_VEC_PERM 0
+#define TARGET_VECTOR_MIN_ALIGNMENT \
+  default_vector_min_alignment
+#define TARGET_VECTOR_ALWAYS_MISALIGN hook_bool_const_tree_false
 
 #define TARGET_VECTORIZE                                                \
   {									\
@@ -393,7 +400,9 @@
     TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD,				\
     TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST,			\
     TARGET_VECTOR_ALIGNMENT_REACHABLE,                                  \
-    TARGET_VECTORIZE_BUILTIN_VEC_PERM                                   \
+    TARGET_VECTORIZE_BUILTIN_VEC_PERM,                                  \
+    TARGET_VECTOR_MIN_ALIGNMENT,                                        \
+    TARGET_VECTOR_ALWAYS_MISALIGN,                                      \
   }
 
 #define TARGET_DEFAULT_TARGET_FLAGS 0
@@ -504,6 +513,7 @@
 #define TARGET_ALLOCATE_INITIAL_VALUE NULL
 
 #define TARGET_UNSPEC_MAY_TRAP_P default_unspec_may_trap_p
+#define TARGET_COMMUTATIVE_OPERAND_PRECEDENCE NULL
 
 #ifndef TARGET_SET_CURRENT_FUNCTION
 #define TARGET_SET_CURRENT_FUNCTION hook_void_tree
@@ -532,6 +542,10 @@
 #define TARGET_INVALID_CONVERSION hook_constcharptr_const_tree_const_tree_null
 #define TARGET_INVALID_UNARY_OP hook_constcharptr_int_const_tree_null
 #define TARGET_INVALID_BINARY_OP hook_constcharptr_int_const_tree_const_tree_null
+#define TARGET_INVALID_PARAMETER_TYPE hook_constcharptr_const_tree_null
+#define TARGET_INVALID_RETURN_TYPE hook_constcharptr_const_tree_null
+#define TARGET_PROMOTED_TYPE hook_tree_const_tree_null
+#define TARGET_CONVERT_TO_TYPE hook_tree_tree_tree_null
 
 #define TARGET_FIXED_CONDITION_CODE_REGS hook_bool_uintp_uintp_false
 
@@ -590,6 +604,7 @@
 #define TARGET_ARG_PARTIAL_BYTES hook_int_CUMULATIVE_ARGS_mode_tree_bool_0
 
 #define TARGET_FUNCTION_VALUE default_function_value
+#define TARGET_LIBCALL_VALUE default_libcall_value
 #define TARGET_INTERNAL_ARG_POINTER default_internal_arg_pointer
 #define TARGET_UPDATE_STACK_BOUNDARY NULL
 #define TARGET_GET_DRAP_RTX NULL
@@ -613,6 +628,7 @@
    TARGET_ARG_PARTIAL_BYTES,					\
    TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN,			\
    TARGET_FUNCTION_VALUE,					\
+   TARGET_LIBCALL_VALUE,					\
    TARGET_INTERNAL_ARG_POINTER,					\
    TARGET_UPDATE_STACK_BOUNDARY,				\
    TARGET_GET_DRAP_RTX,						\
@@ -716,6 +732,11 @@
 #define TARGET_CXX_ADJUST_CLASS_AT_DEFINITION hook_void_tree
 #endif
 
+
+#ifndef TARGET_CXX_TTYPE_REF_ENCODE
+#define TARGET_CXX_TTYPE_REF_ENCODE NULL
+#endif
+
 #define TARGET_CXX				\
   {						\
     TARGET_CXX_GUARD_TYPE,			\
@@ -730,7 +751,8 @@
     TARGET_CXX_LIBRARY_RTTI_COMDAT,	        \
     TARGET_CXX_USE_AEABI_ATEXIT,		\
     TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT,	\
-    TARGET_CXX_ADJUST_CLASS_AT_DEFINITION	\
+    TARGET_CXX_ADJUST_CLASS_AT_DEFINITION,	\
+    TARGET_CXX_TTYPE_REF_ENCODE			\
   }
 
 /* EMUTLS specific */
@@ -886,6 +908,7 @@
   TARGET_ADDRESS_COST,				\
   TARGET_ALLOCATE_INITIAL_VALUE,		\
   TARGET_UNSPEC_MAY_TRAP_P,                     \
+  TARGET_COMMUTATIVE_OPERAND_PRECEDENCE,        \
   TARGET_DWARF_REGISTER_SPAN,                   \
   TARGET_INIT_DWARF_REG_SIZES_EXTRA,		\
   TARGET_FIXED_CONDITION_CODE_REGS,		\
@@ -913,6 +936,10 @@
   TARGET_INVALID_CONVERSION,			\
   TARGET_INVALID_UNARY_OP,			\
   TARGET_INVALID_BINARY_OP,			\
+  TARGET_INVALID_PARAMETER_TYPE,		\
+  TARGET_INVALID_RETURN_TYPE,			\
+  TARGET_PROMOTED_TYPE,				\
+  TARGET_CONVERT_TO_TYPE,			\
   TARGET_IRA_COVER_CLASSES,			\
   TARGET_SECONDARY_RELOAD,			\
   TARGET_EXPAND_TO_RTL_HOOK,			\
@@ -923,6 +950,7 @@
   TARGET_EMUTLS,				\
   TARGET_OPTION_HOOKS,				\
   TARGET_EXTRA_LIVE_ON_ENTRY,			\
+  TARGET_WARN_FUNC_RESULT,			\
   TARGET_UNWIND_TABLES_DEFAULT,			\
   TARGET_HAVE_NAMED_SECTIONS,			\
   TARGET_HAVE_SWITCHABLE_BSS_SECTIONS,		\
diff -Nur a/gcc/target.h b/gcc/target.h
--- a/gcc/target.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/target.h	2010-01-25 09:50:29.165687452 +0100
@@ -473,7 +473,16 @@
 
     /* Target builtin that implements vector permute.  */
     tree (* builtin_vec_perm) (tree, tree*);
-} vectorize;
+
+    /* Return the minimum alignment required to load or store a
+       vector of the given type, which may be less than the
+       natural alignment of the type.  */
+    int (* vector_min_alignment) (const_tree);
+
+    /* Return true if "movmisalign" patterns should be used for all
+       loads/stores from data arrays.  */
+    bool (* always_misalign) (const_tree);
+  } vectorize;
 
   /* The initial value of target_flags.  */
   int default_target_flags;
@@ -694,6 +703,10 @@
      FLAGS has the same meaning as in rtlanal.c: may_trap_p_1.  */
   int (* unspec_may_trap_p) (const_rtx x, unsigned flags);
 
+  /* Return a value indicating whether an operand of a commutative
+     operation is preferred as the first or second operand.  */
+  int (* commutative_operand_precedence) (const_rtx, int);
+
   /* Given a register, this hook should return a parallel of registers
      to represent where to find the register pieces.  Define this hook
      if the register and its mode are represented in Dwarf in
@@ -870,6 +883,10 @@
     rtx (*function_value) (const_tree ret_type, const_tree fn_decl_or_type,
 			   bool outgoing);
 
+    /* Return the rtx for the result of a libcall of mode MODE,
+       calling the function FN_NAME.  */
+    rtx (*libcall_value) (enum machine_mode, rtx);
+
     /* Return an rtx for the argument pointer incoming to the
        current function.  */
     rtx (*internal_arg_pointer) (void);
@@ -899,6 +916,24 @@
      is not permitted on TYPE1 and TYPE2, NULL otherwise.  */
   const char *(*invalid_binary_op) (int op, const_tree type1, const_tree type2);
 
+  /* Return the diagnostic message string if TYPE is not valid as a
+     function parameter type, NULL otherwise.  */
+  const char *(*invalid_parameter_type) (const_tree type);
+
+  /* Return the diagnostic message string if TYPE is not valid as a
+     function return type, NULL otherwise.  */
+  const char *(*invalid_return_type) (const_tree type);
+
+  /* If values of TYPE are promoted to some other type when used in
+     expressions (analogous to the integer promotions), return that type,
+     or NULL_TREE otherwise.  */
+  tree (*promoted_type) (const_tree type);
+
+  /* Convert EXPR to TYPE, if target-specific types with special conversion
+     rules are involved.  Return the converted expression, or NULL to apply
+     the standard conversion rules.  */
+  tree (*convert_to_type) (tree type, tree expr);
+
   /* Return the array of IRA cover classes for the current target.  */
   const enum reg_class *(*ira_cover_classes) (void);
 
@@ -977,6 +1012,11 @@
        class  (eg, tweak visibility or perform any other required
        target modifications).  */
     void (*adjust_class_at_definition) (tree type);
+    /* Encode a reference type info, used for catching pointer
+       references.  The provided expression will be the address of the
+       type info object of the type to which a reference is being
+       caught.  */
+    tree (* ttype_ref_encode) (tree);
   } cxx;
 
   /* Functions and data for emulated TLS support.  */
@@ -1040,6 +1080,10 @@
      bits in the bitmap passed in. */  
   void (*live_on_entry) (bitmap); 
 
+  /* Return false if warnings about missing return statements or suspect
+     noreturn attributes should be suppressed for the current function.  */
+  bool (*warn_func_result) (void);
+
   /* True if unwinding tables should be generated by default.  */
   bool unwind_tables_default;
 
diff -Nur a/gcc/targhooks.c b/gcc/targhooks.c
--- a/gcc/targhooks.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/targhooks.c	2010-01-25 09:50:29.165687452 +0100
@@ -441,6 +441,15 @@
   return NULL;
 }
 
+tree
+hook_cxx_ttype_ref_in_bit0 (tree exp)
+{
+  exp = convert (build_pointer_type (char_type_node), exp);
+  exp = pointer_int_sum (PLUS_EXPR, exp, integer_one_node);
+  
+  return exp;
+}
+
 /* Initialize the stack protection decls.  */
 
 /* Stack protection related decls living in libgcc.  */
@@ -561,6 +570,12 @@
 }
 
 rtx
+default_libcall_value (enum machine_mode mode, rtx fun ATTRIBUTE_UNUSED)
+{
+  return LIBCALL_VALUE (mode);
+}
+
+rtx
 default_internal_arg_pointer (void)
 {
   /* If the reg that the virtual arg pointer will be translated into is
@@ -712,6 +727,12 @@
   return true;
 }
 
+int
+default_vector_min_alignment (const_tree type)
+{
+  return TYPE_ALIGN_UNIT (type);
+}
+
 bool
 default_hard_regno_scratch_ok (unsigned int regno ATTRIBUTE_UNUSED)
 {
diff -Nur a/gcc/targhooks.h b/gcc/targhooks.h
--- a/gcc/targhooks.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/targhooks.h	2010-01-25 09:50:29.165687452 +0100
@@ -48,6 +48,7 @@
 
 extern tree default_cxx_guard_type (void);
 extern tree default_cxx_get_cookie_size (tree);
+extern tree hook_cxx_ttype_ref_in_bit0 (tree);
 
 extern bool hook_pass_by_reference_must_pass_in_stack
   (CUMULATIVE_ARGS *, enum machine_mode mode, const_tree, bool);
@@ -71,6 +72,8 @@
 
 extern bool default_builtin_vector_alignment_reachable (const_tree, bool);
 
+extern int default_vector_min_alignment (const_tree);
+
 /* These are here, and not in hooks.[ch], because not all users of
    hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */
 
@@ -87,6 +90,7 @@
   (const_tree, const_tree, const_tree);
 extern bool hook_bool_const_rtx_commutative_p (const_rtx, int);
 extern rtx default_function_value (const_tree, const_tree, bool);
+extern rtx default_libcall_value (enum machine_mode, rtx);
 extern rtx default_internal_arg_pointer (void);
 #ifdef IRA_COVER_CLASSES
 extern const enum reg_class *default_ira_cover_classes (void);
diff -Nur a/gcc/testsuite/gcc.c-torture/execute/990208-1.x b/gcc/testsuite/gcc.c-torture/execute/990208-1.x
--- a/gcc/testsuite/gcc.c-torture/execute/990208-1.x	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.c-torture/execute/990208-1.x	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,12 @@
+
+# On ARM, with -Os, some of the functions that this test
+# expects to be inlined are not inlined for code size
+# reasons.  This is not a bug, it's intentional,
+# so stop this test from running.
+set torture_eval_before_compile {
+  if { [istarget "arm-*-*"] && [string match {*-Os*} "$option"] } {
+    continue
+  }
+}
+
+return 0
\ No newline at end of file
diff -Nur a/gcc/testsuite/gcc.c-torture/execute/bcp-1.x b/gcc/testsuite/gcc.c-torture/execute/bcp-1.x
--- a/gcc/testsuite/gcc.c-torture/execute/bcp-1.x	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.c-torture/execute/bcp-1.x	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,12 @@
+
+# On ARM, with -Os, some of the functions that this test
+# expects to be inlined are not inlined for code size
+# reasons.  This is not a bug, it's intentional,
+# so stop this test from running.
+set torture_eval_before_compile {
+  if { [istarget "arm-*-*"] && [string match {*-Os*} "$option"] } {
+    continue
+  }
+}
+
+return 0
\ No newline at end of file
diff -Nur a/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp b/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp
--- a/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp	2009-03-16 22:11:57.000000000 +0100
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp	2010-01-25 09:50:29.165687452 +0100
@@ -54,6 +54,9 @@
      || [istarget "sh*-*-*"] } then {
   lappend additional_flags "-mieee"
 }
+if [istarget "mips*-sde-*"] then {
+  lappend additional_flags "-Wl,--defsym=__cs3_mips_float_type=2" "-lcs3-mips-cp1" "-lcs3-mips-fpemu"
+}
 
 # load support procs
 load_lib c-torture.exp
diff -Nur a/gcc/testsuite/gcc.dg/builtin-redefine.c b/gcc/testsuite/gcc.dg/builtin-redefine.c
--- a/gcc/testsuite/gcc.dg/builtin-redefine.c	2008-09-18 17:39:08.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/builtin-redefine.c	2010-01-25 09:50:29.165687452 +0100
@@ -28,7 +28,7 @@
 #define __TIME__ "X"         /* Re-define while defined.  */
 
 #define __TIME__ "Y"         /* { dg-warning "\"__TIME__\" redefined" } */
-/* { dg-warning "previous definition" "" { target *-*-* } 28 } */
+/* { dg-message "previous definition" "" { target *-*-* } 28 } */
 
 #undef __TIME__              /* Undefine while defined.  */
 
@@ -39,7 +39,7 @@
 #define __DATE__ "X"         /* Re-define while defined.  */
 
 #define __DATE__ "Y"         /* { dg-warning "\"__DATE__\" redefined" } */
-/* { dg-warning "previous definition" "" { target *-*-* } 39 } */
+/* { dg-message "previous definition" "" { target *-*-* } 39 } */
 
 #undef __DATE__              /* Undefine while defined.  */
 
@@ -48,7 +48,7 @@
 #define __TIMESTAMP__ "X"    /* Re-define while defined.  */
 
 #define __TIMESTAMP__ "Y"    /* { dg-warning "\"__TIMESTAMP__\" redefined" } */
-/* { dg-warning "previous definition" "" { target *-*-* } 48 } */
+/* { dg-message "previous definition" "" { target *-*-* } 48 } */
 
 #undef __TIMESTAMP__         /* Undefine while defined.  */
 
diff -Nur a/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c b/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c
--- a/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c	2009-03-19 23:10:22.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c	2010-01-25 09:50:29.165687452 +0100
@@ -46,7 +46,7 @@
 "/* { dg-options \"%s-I%s\" } */\n",
 "/* { dg-options \"%s-I%s -Wno-abi\" } */\n",
 "/* { dg-options \"%s-I%s -mno-mmx -Wno-abi\" { target i?86-*-* x86_64-*-* } } */\n",
-"/* { dg-options \"%s-I%s -fno-common\" { target hppa*-*-hpux* powerpc*-*-darwin* *-*-mingw32* *-*-cygwin* } } */\n",
+"/* { dg-options \"%s-I%s -fno-common\" { target hppa*-*-hpux* powerpc*-*-darwin* } } */\n",
 "/* { dg-options \"%s-I%s -mno-mmx -fno-common -Wno-abi\" { target i?86-*-darwin* x86_64-*-darwin* } } */\n",
 "/* { dg-options \"%s-I%s -mno-base-addresses\" { target mmix-*-* } } */\n",
 "/* { dg-options \"%s-I%s -mlongcalls -mtext-section-literals\" { target xtensa*-*-* } } */\n"
diff -Nur a/gcc/testsuite/gcc.dg/cpp/include2a.c b/gcc/testsuite/gcc.dg/cpp/include2a.c
--- a/gcc/testsuite/gcc.dg/cpp/include2a.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/cpp/include2a.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,16 @@
+/* Copyright (C) 2000 Free Software Foundation, Inc.  */
+
+/* { dg-do preprocess } */
+
+/* Tests that #include does not allow the terminating '>' or '"' to be
+   escaped, as per the standard.  */
+
+/* Source: Neil Booth, 4 Nov 2000.  */
+
+#include "silly\""  /* { dg-error "extra tokens" "" } */
+
+/* These error is No such file or directory, just once.  However, this
+   message is locale-dependent, so don't test for it.  */
+/* { dg-error "silly" "" { target *-*-* } 10 } */
+/* { dg-error "missing" "" { target *-*-* } 10 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff -Nur a/gcc/testsuite/gcc.dg/cpp/include2.c b/gcc/testsuite/gcc.dg/cpp/include2.c
--- a/gcc/testsuite/gcc.dg/cpp/include2.c	2007-05-17 22:58:47.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/cpp/include2.c	2010-01-25 09:50:29.165687452 +0100
@@ -8,9 +8,8 @@
 /* Source: Neil Booth, 4 Nov 2000.  */
 
 #include <silly\>>  /* { dg-error "extra tokens" "" } */
-#include "silly\""  /* { dg-error "extra tokens" "" } */
 
 /* These error is No such file or directory, just once.  However, this
    message is locale-dependent, so don't test for it.  */
 /* { dg-error "silly" "" { target *-*-* } 10 } */
-/* { dg-error "missing" "" { target *-*-* } 11 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff -Nur a/gcc/testsuite/gcc.dg/cpp/missing-header-1.c b/gcc/testsuite/gcc.dg/cpp/missing-header-1.c
--- a/gcc/testsuite/gcc.dg/cpp/missing-header-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/cpp/missing-header-1.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,9 @@
+/* Test that missing headers are fatal errors.  PR 15638.  */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+#include "nonexistent.h" /* { dg-error "nonexistent.h" } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
+
+/* This declaration should not receive any diagnostic.  */
+foo bar;
diff -Nur a/gcc/testsuite/gcc.dg/cpp/missing-header-MD.c b/gcc/testsuite/gcc.dg/cpp/missing-header-MD.c
--- a/gcc/testsuite/gcc.dg/cpp/missing-header-MD.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/cpp/missing-header-MD.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,6 @@
+/* Test that missing user headers are fatal errors with -MD.  */
+/* { dg-do compile } */
+/* { dg-options "-MD" } */
+
+#include "nonexistent.h" /* { dg-error "nonexistent.h" } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff -Nur a/gcc/testsuite/gcc.dg/cpp/missing-header-MMD.c b/gcc/testsuite/gcc.dg/cpp/missing-header-MMD.c
--- a/gcc/testsuite/gcc.dg/cpp/missing-header-MMD.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/cpp/missing-header-MMD.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,6 @@
+/* Test that missing user headers are fatal errors with -MMD.  */
+/* { dg-do compile } */
+/* { dg-options "-MMD" } */
+
+#include "nonexistent.h" /* { dg-error "nonexistent.h" } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff -Nur a/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MD.c b/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MD.c
--- a/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MD.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MD.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,6 @@
+/* Test that missing system headers are fatal errors with -MD.  */
+/* { dg-do compile } */
+/* { dg-options "-MD" } */
+
+#include <nonexistent.h> /* { dg-error "nonexistent.h" } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff -Nur a/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MMD.c b/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MMD.c
--- a/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MMD.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MMD.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,6 @@
+/* Test that missing system headers are fatal errors with -MMD.  */
+/* { dg-do compile } */
+/* { dg-options "-MMD" } */
+
+#include <nonexistent.h> /* { dg-error "nonexistent.h" } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff -Nur a/gcc/testsuite/gcc.dg/cpp/redef2.c b/gcc/testsuite/gcc.dg/cpp/redef2.c
--- a/gcc/testsuite/gcc.dg/cpp/redef2.c	2001-11-23 08:50:42.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/cpp/redef2.c	2010-01-25 09:50:29.165687452 +0100
@@ -23,9 +23,9 @@
    { dg-warning "redefined" "redef ro"      { target *-*-* } 12 }
    { dg-warning "redefined" "redef va"      { target *-*-* } 15 }
 
-   { dg-warning "previous"  "prev def mac"  { target *-*-* } 6  }
-   { dg-warning "previous"  "prev def mac"  { target *-*-* } 7  }
-   { dg-warning "previous"  "prev def mac"  { target *-*-* } 8  }
-   { dg-warning "previous"  "prev def ro"   { target *-*-* } 11 }
-   { dg-warning "previous"  "prev def va"   { target *-*-* } 14 }
+   { dg-message "previous"  "prev def mac"  { target *-*-* } 6  }
+   { dg-message "previous"  "prev def mac"  { target *-*-* } 7  }
+   { dg-message "previous"  "prev def mac"  { target *-*-* } 8  }
+   { dg-message "previous"  "prev def ro"   { target *-*-* } 11 }
+   { dg-message "previous"  "prev def va"   { target *-*-* } 14 }
 */
diff -Nur a/gcc/testsuite/gcc.dg/cpp/redef3.c b/gcc/testsuite/gcc.dg/cpp/redef3.c
--- a/gcc/testsuite/gcc.dg/cpp/redef3.c	2003-06-01 20:55:15.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/cpp/redef3.c	2010-01-25 09:50:29.165687452 +0100
@@ -15,7 +15,7 @@
    { dg-warning "redefined" "redef B"      { target *-*-* } 9  }
    { dg-warning "redefined" "redef D"      { target *-*-* } 11 }
    { dg-warning "redefined" "redef E"      { target *-*-* } 12 }
-   { dg-warning "previous"  "prev def A"   { target *-*-* } 6  }
-   { dg-warning "previous"  "prev def B"   { target *-*-* } 8  }
-   { dg-warning "previous"  "prev def D/E" { target *-*-* } 0  }
+   { dg-message "previous"  "prev def A"   { target *-*-* } 6  }
+   { dg-message "previous"  "prev def B"   { target *-*-* } 8  }
+   { dg-message "previous"  "prev def D/E" { target *-*-* } 0  }
 */
diff -Nur a/gcc/testsuite/gcc.dg/cpp/trad/redef2.c b/gcc/testsuite/gcc.dg/cpp/trad/redef2.c
--- a/gcc/testsuite/gcc.dg/cpp/trad/redef2.c	2002-06-21 07:29:09.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/cpp/trad/redef2.c	2010-01-25 09:50:29.165687452 +0100
@@ -2,31 +2,31 @@
 
 /* { dg-do preprocess } */
 
-#define foo bar    /* { dg-warning "previous def" "foo prev def" } */
+#define foo bar    /* { dg-message "previous def" "foo prev def" } */
 #define foo barr   /* { dg-warning "redefined" "foo redefined" } */
 
 #undef foo
-#define foo bar    /* { dg-warning "previous def" "foo prev def 2" } */
+#define foo bar    /* { dg-message "previous def" "foo prev def 2" } */
 #define foo() bar    /* { dg-warning "redefined" "foo redefined 2" } */
 
 #undef foo
-#define foo() bar    /* { dg-warning "previous def" "foo prev def" } */
+#define foo() bar    /* { dg-message "previous def" "foo prev def" } */
 #define foo() barr   /* { dg-warning "redefined" "foo redefined" } */
 
-#define quux(thud) a thud b /* { dg-warning "previous def" "quux prev def" } */
+#define quux(thud) a thud b /* { dg-message "previous def" "quux prev def" } */
 #define quux(thu) a thud b   /* { dg-warning "redefined" "quux redefined" } */
 
-#define bar(x, y) x+y /* { dg-warning "previous def" "bar prev def" } */
+#define bar(x, y) x+y /* { dg-message "previous def" "bar prev def" } */
 #define bar(x, y) x+x   /* { dg-warning "redefined" "bar redefined" } */
 
-#define bat(x, y) x+y  /* { dg-warning "previous def" "bat prev def" } */
+#define bat(x, y) x+y  /* { dg-message "previous def" "bat prev def" } */
 #define bat(x, y) x+ y   /* { dg-warning "redefined" "bat redefined" } */
 
-#define baz(x, y) x+y  /* { dg-warning "previous def" "baz prev def" } */
+#define baz(x, y) x+y  /* { dg-message "previous def" "baz prev def" } */
 #define baz(x, y) x +y   /* { dg-warning "redefined" "baz redefined" } */
 
-#define f(x, y) "x y"  /* { dg-warning "previous def" "f prev def" } */
+#define f(x, y) "x y"  /* { dg-message "previous def" "f prev def" } */
 #define f(x, y) "x  y"   /* { dg-warning "redefined" "f redefined" } */
 
-#define g(x, y) 'x'  /* { dg-warning "previous def" "g prev def" } */
+#define g(x, y) 'x'  /* { dg-message "previous def" "g prev def" } */
 #define g(x, y) ' x'   /* { dg-warning "redefined" "g redefined" } */
diff -Nur a/gcc/testsuite/gcc.dg/cpp/Wvariadic-1.c b/gcc/testsuite/gcc.dg/cpp/Wvariadic-1.c
--- a/gcc/testsuite/gcc.dg/cpp/Wvariadic-1.c	2004-02-20 19:42:51.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/cpp/Wvariadic-1.c	2010-01-25 09:50:29.165687452 +0100
@@ -4,3 +4,4 @@
 #define f(x,...)	/* { dg-error "variadic" } */
 #define g(x,y...)	/* { dg-error "variadic" } */
 int not_empty;
+/* { dg-message "warnings being treated as errors" "" { target *-*-* } 0 } */
diff -Nur a/gcc/testsuite/gcc.dg/cpp/Wvariadic-3.c b/gcc/testsuite/gcc.dg/cpp/Wvariadic-3.c
--- a/gcc/testsuite/gcc.dg/cpp/Wvariadic-3.c	2004-02-20 19:42:51.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/cpp/Wvariadic-3.c	2010-01-25 09:50:29.165687452 +0100
@@ -4,3 +4,4 @@
 #define f(x,...)
 #define g(x,y...)	/* { dg-error "variadic" } */
 int not_empty;
+/* { dg-message "warnings being treated as errors" "" { target *-*-* } 0 } */
diff -Nur a/gcc/testsuite/gcc.dg/dll-4.c b/gcc/testsuite/gcc.dg/dll-4.c
--- a/gcc/testsuite/gcc.dg/dll-4.c	2005-10-12 22:54:50.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/dll-4.c	2010-01-25 09:50:29.165687452 +0100
@@ -11,5 +11,6 @@
 int f () { return foo1 + foo2; }
 
 /* FIXME: We should scan the output of nm for this case.  */
-/* { dg-final { scan-assembler "(foo2:.*\.comm\[ \t_\]*foo1)" } } */
+/* { dg-final { scan-assembler "(foo2:)" } } */
+/* { dg-final { scan-assembler "(\.comm\[ \t_\]*foo1)" } } */
 /* { dg-final { scan-assembler-not "(__imp_|_imp__)" } } */
diff -Nur a/gcc/testsuite/gcc.dg/dll-6a.c b/gcc/testsuite/gcc.dg/dll-6a.c
--- a/gcc/testsuite/gcc.dg/dll-6a.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/dll-6a.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,21 @@
+extern void i1();
+extern void i3();
+extern void i4();
+extern void i5();
+
+extern void e1();
+extern void e3();
+extern void e4();
+extern void e5();
+
+int main () {
+  i1();
+  i3();
+  i4();
+  i5();
+
+  e1();
+  e3();
+  e4();
+  e5();
+}
diff -Nur a/gcc/testsuite/gcc.dg/dll-6.c b/gcc/testsuite/gcc.dg/dll-6.c
--- a/gcc/testsuite/gcc.dg/dll-6.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/dll-6.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,52 @@
+/* { dg-do link } */
+/* { dg-require-dll "" } */
+/* { dg-additional-sources "dll-6a.c" } */
+/* { dg-options "-w -O2 -std=gnu89" } */
+
+/* Test that inline functions declared "dllexport" appear in object
+   files, even if they are not called.
+
+   This behavior is required by the ARM C++ ABI:
+
+     Exporting a function that can be inlined should force the
+     creation and export of an out-of-line copy of it.
+
+   and should presumably also apply.
+
+   Visual Studio 2005 also honors that rule.  */
+
+__declspec(dllexport) inline void i1() {}
+
+__declspec(dllexport) extern inline void e1() {}
+
+/* It is invalid to declare the function inline after its definition.  */
+#if 0
+__declspec(dllexport) void i2() {}
+inline void i2();
+
+__declspec(dllexport) extern void e2() {}
+inline void e2();
+#endif
+
+__declspec(dllexport) inline void i3() {}
+void i3();
+
+__declspec(dllexport) inline void e3() {}
+extern void e3();
+
+__declspec(dllexport) void i4();
+inline void i4() {};
+
+__declspec(dllexport) extern void e4();
+inline void e4() {};
+
+__declspec(dllexport) inline void i5();
+void i5() {};
+
+__declspec(dllexport) inline void e5();
+extern void e5() {};
+
+/* Make sure that just declaring the function -- without defining it
+   -- does not cause errors.  */
+__declspec(dllexport) inline void i6();
+__declspec(dllexport) extern inline void e6();
diff -Nur a/gcc/testsuite/gcc.dg/dll-7a.c b/gcc/testsuite/gcc.dg/dll-7a.c
--- a/gcc/testsuite/gcc.dg/dll-7a.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/dll-7a.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,21 @@
+extern void i1();
+extern void i3();
+extern void i4();
+extern void i5();
+
+extern void e1();
+extern void e3();
+extern void e4();
+extern void e5();
+
+int main () {
+  i1();
+  i3();
+  i4();
+  i5();
+
+  e1();
+  e3();
+  e4();
+  e5();
+}
diff -Nur a/gcc/testsuite/gcc.dg/dll-7.c b/gcc/testsuite/gcc.dg/dll-7.c
--- a/gcc/testsuite/gcc.dg/dll-7.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/dll-7.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,52 @@
+/* { dg-do link } */
+/* { dg-require-dll "" } */
+/* { dg-additional-sources "dll-7a.c" } */
+/* { dg-options "-w -O2 -std=gnu99" } */
+
+/* Test that inline functions declared "dllexport" appear in object
+   files, even if they are not called.
+
+   This behavior is required by the ARM C++ ABI:
+
+     Exporting a function that can be inlined should force the
+     creation and export of an out-of-line copy of it.
+
+   and should presumably also apply.
+
+   Visual Studio 2005 also honors that rule.  */
+
+__declspec(dllexport) inline void i1() {}
+
+__declspec(dllexport) extern inline void e1() {}
+
+/* It is invalid to declare the function inline after its definition.  */
+#if 0
+__declspec(dllexport) void i2() {}
+inline void i2();
+
+__declspec(dllexport) extern void e2() {}
+inline void e2();
+#endif
+
+__declspec(dllexport) inline void i3() {}
+void i3();
+
+__declspec(dllexport) inline void e3() {}
+extern void e3();
+
+__declspec(dllexport) void i4();
+inline void i4() {};
+
+__declspec(dllexport) extern void e4();
+inline void e4() {};
+
+__declspec(dllexport) inline void i5();
+void i5() {};
+
+__declspec(dllexport) inline void e5();
+extern void e5() {};
+
+/* Make sure that just declaring the function -- without defining it
+   -- does not cause errors.  */
+__declspec(dllexport) inline void i6();
+__declspec(dllexport) extern inline void e6();
diff -Nur a/gcc/testsuite/gcc.dg/falign-labels-1.c b/gcc/testsuite/gcc.dg/falign-labels-1.c
--- a/gcc/testsuite/gcc.dg/falign-labels-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/falign-labels-1.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,39 @@
+/* { dg-do run } */
+/* { dg-options "-falign-labels=8" { target { ! { m68k*-*-* || fido*-*-* } } } } */
+
+/* On ARMv7-A CPUs, this test resulted in incorrect code generation.
+   The code generated for the switch statement expected the jump table
+   to immediately follow the jump instruction, but -falign-labels
+   caused the label preceding the table to be aligned.  */
+/* M68K and fido only support -falign-labels argument <= 2.  */
+
+volatile int x;
+
+int main(void)
+{
+  int y;
+
+  x = 0;
+
+  switch(x)
+    {
+    case 0:
+      y = 2 * x;
+      break;
+    case 1:
+      y = -3 * x;
+      break;
+    case 2:
+      y = x + 5;
+      break;
+    case 3:
+      y = x - 7;
+      break;
+    default:
+      break;
+    }
+
+  x = y;
+
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.dg/fltconst-1.c b/gcc/testsuite/gcc.dg/fltconst-1.c
--- a/gcc/testsuite/gcc.dg/fltconst-1.c	2008-08-21 19:50:01.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/fltconst-1.c	2010-01-25 09:50:29.165687452 +0100
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-std=gnu99" } */
+/* { dg-options "-std=gnu99 -fshow-column" } */
 
 double a = 1.ld;	/* { dg-error "12:invalid suffix" } */
 double b = 1.fd;	/* { dg-error "12:invalid suffix" } */
diff -Nur a/gcc/testsuite/gcc.dg/m68k-fp-1.c b/gcc/testsuite/gcc.dg/m68k-fp-1.c
--- a/gcc/testsuite/gcc.dg/m68k-fp-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/m68k-fp-1.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,13 @@
+/* ColdFire has restricted addressing modes for float operands.  */
+/* { dg-do compile { target m68k-*-* } }  */
+/* { dg-options "-O0 -mcpu=547x -mhard-float" }  */
+
+double Foo (unsigned a)
+{
+  unsigned local_data[16384] __attribute__((unused));
+  double d;
+
+  d = a;
+
+  return d;
+}
diff -Nur a/gcc/testsuite/gcc.dg/pch/counter-2.c b/gcc/testsuite/gcc.dg/pch/counter-2.c
--- a/gcc/testsuite/gcc.dg/pch/counter-2.c	2008-05-21 02:04:45.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/pch/counter-2.c	2010-01-25 09:50:29.165687452 +0100
@@ -10,6 +10,7 @@
 #include "counter-2.h" /* { dg-warning "not used because `__COUNTER__' is invalid" } */
 /* { dg-error "counter-2.h: No such file or directory" "no such file" { target *-*-* } 10 } */
 /* { dg-error "one or more PCH files were found, but they were invalid" "invalid files" { target *-*-* } 10 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
 
 int main(void) 
 {
diff -Nur a/gcc/testsuite/gcc.dg/pch/valid-1.c b/gcc/testsuite/gcc.dg/pch/valid-1.c
--- a/gcc/testsuite/gcc.dg/pch/valid-1.c	2008-05-21 02:04:45.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/pch/valid-1.c	2010-01-25 09:50:29.165687452 +0100
@@ -3,5 +3,6 @@
 #include "valid-1.h"/* { dg-warning "created with -gnone, but used with -g" } */
 /* { dg-error "No such file" "no such file" { target *-*-* } 3 } */
 /* { dg-error "they were invalid" "invalid files" { target *-*-* } 3 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
 
 int x;
diff -Nur a/gcc/testsuite/gcc.dg/pch/valid-2.c b/gcc/testsuite/gcc.dg/pch/valid-2.c
--- a/gcc/testsuite/gcc.dg/pch/valid-2.c	2008-05-21 02:04:45.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/pch/valid-2.c	2010-01-25 09:50:29.165687452 +0100
@@ -3,4 +3,5 @@
 #include "valid-2.h" /* { dg-warning "settings for -fexceptions do not match" } */
 /* { dg-error "No such file" "no such file" { target *-*-* } 3 } */
 /* { dg-error "they were invalid" "invalid files" { target *-*-* } 3 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
 int x;
diff -Nur a/gcc/testsuite/gcc.dg/pch/warn-1.c b/gcc/testsuite/gcc.dg/pch/warn-1.c
--- a/gcc/testsuite/gcc.dg/pch/warn-1.c	2008-05-21 02:04:45.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/pch/warn-1.c	2010-01-25 09:50:29.165687452 +0100
@@ -5,6 +5,7 @@
 #include "warn-1.h"/* { dg-warning "not used because .DEFINED_VALUE. is defined" } */
 /* { dg-error "No such file" "no such file" { target *-*-* } 5 } */
 /* { dg-error "they were invalid" "invalid files" { target *-*-* } 5 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
 
 
 int main(void) 
diff -Nur a/gcc/testsuite/gcc.dg/pr34263.c b/gcc/testsuite/gcc.dg/pr34263.c
--- a/gcc/testsuite/gcc.dg/pr34263.c	2008-01-06 16:24:10.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/pr34263.c	2010-01-25 09:50:29.165687452 +0100
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-options "-O2 -fdump-tree-optimized -fno-unroll-loops" } */
 /* Same test as 990128-1.c.  */
 
 extern int printf (const char *,...);
diff -Nur a/gcc/testsuite/gcc.dg/pragma-isr-trapa2.c b/gcc/testsuite/gcc.dg/pragma-isr-trapa2.c
--- a/gcc/testsuite/gcc.dg/pragma-isr-trapa2.c	2007-08-13 11:24:46.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/pragma-isr-trapa2.c	2010-01-25 09:50:29.165687452 +0100
@@ -1,4 +1,6 @@
 /* { dg-do compile { target { { sh-*-* sh4*-*-* } && nonpic } } } */
+/* { dg-skip-if "FPU Required" { "sh*-*-*" } { "-m*nofpu*" } { "" } } */
+/* { dg-skip-if "FPU Required" { "sh*-*-*" } { "-m4al*" } { "" } } */
 /* { dg-options "-O -m4" } */
 
 extern void foo ();
diff -Nur a/gcc/testsuite/gcc.dg/profile-dir-1.c b/gcc/testsuite/gcc.dg/profile-dir-1.c
--- a/gcc/testsuite/gcc.dg/profile-dir-1.c	2008-04-22 01:35:47.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/profile-dir-1.c	2010-01-25 09:50:29.165687452 +0100
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O -fprofile-generate=. -fdump-tree-tree_profile" } */
+/* { dg-require-host-local "" } */
 /* { dg-final { scan-tree-dump " ./profile-dir-1.gcda" "tree_profile" } } */
 
 int
diff -Nur a/gcc/testsuite/gcc.dg/profile-dir-2.c b/gcc/testsuite/gcc.dg/profile-dir-2.c
--- a/gcc/testsuite/gcc.dg/profile-dir-2.c	2008-04-22 01:35:47.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/profile-dir-2.c	2010-01-25 09:50:29.165687452 +0100
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O -fprofile-generate -fdump-tree-tree_profile" } */
+/* { dg-require-host-local "" } */
 /* { dg-final { scan-tree-dump "/profile-dir-2.gcda" "tree_profile" } } */
 
 int
diff -Nur a/gcc/testsuite/gcc.dg/profile-dir-3.c b/gcc/testsuite/gcc.dg/profile-dir-3.c
--- a/gcc/testsuite/gcc.dg/profile-dir-3.c	2008-04-22 01:35:47.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/profile-dir-3.c	2010-01-25 09:50:29.165687452 +0100
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O -fprofile-generate -fprofile-dir=. -fdump-tree-tree_profile" } */
+/* { dg-require-host-local "" } */
 /* { dg-final { scan-tree-dump " ./profile-dir-3.gcda" "tree_profile" } } */
 
 int
diff -Nur a/gcc/testsuite/gcc.dg/promote-short-10.c b/gcc/testsuite/gcc.dg/promote-short-10.c
--- a/gcc/testsuite/gcc.dg/promote-short-10.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/promote-short-10.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,20 @@
+/* Verify that we do not promote a short loop index variable when its
+   address is taken.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Found 0 candidates" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+extern void outside (short *);
+
+void
+test1 (int n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    {
+      outside (&i);
+    }
+}
diff -Nur a/gcc/testsuite/gcc.dg/promote-short-1.c b/gcc/testsuite/gcc.dg/promote-short-1.c
--- a/gcc/testsuite/gcc.dg/promote-short-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/promote-short-1.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,15 @@
+/* Verify that we promote a short loop index variable.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 1 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (short n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    x[i] = 0;
+}
diff -Nur a/gcc/testsuite/gcc.dg/promote-short-2.c b/gcc/testsuite/gcc.dg/promote-short-2.c
--- a/gcc/testsuite/gcc.dg/promote-short-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/promote-short-2.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,16 @@
+/* Verify that we do not promote a short loop index variable when it is
+   being stored to memory.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 0 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (short n, short *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    x[i] = i;
+}
diff -Nur a/gcc/testsuite/gcc.dg/promote-short-3.c b/gcc/testsuite/gcc.dg/promote-short-3.c
--- a/gcc/testsuite/gcc.dg/promote-short-3.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/promote-short-3.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,18 @@
+/* Verify that we do not promote a short loop index variable when it is
+   being passed as a function parameter.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 0 variables" 1 "promoteshort" { xfail m68k*-*-* fido*-*-* i?86-*-* x86_64-*-* mips*-*-* sh*-*-* } } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+extern void outside (short);
+
+void
+test1 (short n)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    outside (i);
+}
diff -Nur a/gcc/testsuite/gcc.dg/promote-short-4.c b/gcc/testsuite/gcc.dg/promote-short-4.c
--- a/gcc/testsuite/gcc.dg/promote-short-4.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/promote-short-4.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,19 @@
+/* Verify that we do not promote a short loop index variable when it is
+   modified within the loop.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 0 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (short n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    {
+      i++;
+      x[i] = 0;
+    }
+}
diff -Nur a/gcc/testsuite/gcc.dg/promote-short-5.c b/gcc/testsuite/gcc.dg/promote-short-5.c
--- a/gcc/testsuite/gcc.dg/promote-short-5.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/promote-short-5.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,18 @@
+/* Verify that we do not promote a short loop index variable when it has
+   a non-unit-increment.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 0 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (short n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i+=2)
+    {
+      x[i] = 0;
+    }
+}
diff -Nur a/gcc/testsuite/gcc.dg/promote-short-6.c b/gcc/testsuite/gcc.dg/promote-short-6.c
--- a/gcc/testsuite/gcc.dg/promote-short-6.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/promote-short-6.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,18 @@
+/* Verify that we do promote a short loop index variable when it has
+   a non-unit-increment and -funsafe-loop-optimizations is in effect.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -funsafe-loop-optimizations -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 1 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (short n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i+=2)
+    {
+      x[i] = 0;
+    }
+}
diff -Nur a/gcc/testsuite/gcc.dg/promote-short-7.c b/gcc/testsuite/gcc.dg/promote-short-7.c
--- a/gcc/testsuite/gcc.dg/promote-short-7.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/promote-short-7.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,18 @@
+/* Verify that we do not promote a short loop index variable when the
+   loop in which it is used has a bound of wider type.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 0 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (int n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    {
+      x[i] = 0;
+    }
+}
diff -Nur a/gcc/testsuite/gcc.dg/promote-short-8.c b/gcc/testsuite/gcc.dg/promote-short-8.c
--- a/gcc/testsuite/gcc.dg/promote-short-8.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/promote-short-8.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,19 @@
+/* Verify that we do promote a short loop index variable when the loop
+   in which it is used has a bound of wider type and
+   -funsafe-loop-optimizations is in effect.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -funsafe-loop-optimizations -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 1 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (int n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    {
+      x[i] = 0;
+    }
+}
diff -Nur a/gcc/testsuite/gcc.dg/promote-short-9.c b/gcc/testsuite/gcc.dg/promote-short-9.c
--- a/gcc/testsuite/gcc.dg/promote-short-9.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/promote-short-9.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,15 @@
+/* -fpromote-loop-indices used to ICE on this.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices" } */
+
+char
+lookup (char *haystack, char *needle)
+{
+  char x;
+
+  for (x = haystack[-2]; x < *needle; x++)
+    haystack[x] = needle[x];
+
+  return 1;
+}
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-10.c b/gcc/testsuite/gcc.dg/remove-local-statics-10.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-10.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-10.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,32 @@
+/* Verify that we do not eliminate a static local variable when it is
+   live on return from a function call that recursively calls the
+   function in which the variable is defined.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int
+test2 (int x)
+{
+  if (x < 0)
+    return 0;
+  else
+    return test1 (x - 1);
+}
+
+int
+test1 (int x)
+{
+  static int thestatic;
+  int y;
+
+  thestatic = x;
+
+  y = test2 (x - 1);
+
+  y += thestatic;
+
+  return y + x;
+}
+  
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-11.c b/gcc/testsuite/gcc.dg/remove-local-statics-11.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-11.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-11.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,16 @@
+/* Verify that we do not eliminate a static local variable when its
+   address is taken.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int *
+test1 (int x)
+{
+  static int thestatic;
+
+  thestatic = x;
+
+  return &thestatic + x;
+}
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-12.c b/gcc/testsuite/gcc.dg/remove-local-statics-12.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-12.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-12.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,20 @@
+/* Verify that we do not eliminate a static variable when it is declared
+   in a function that has nested functions.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int test1 (int x)
+{
+  static int thestatic;
+
+  int nested_test1 (int x)
+  {
+    return x + thestatic;
+  }
+
+  thestatic = x;
+
+  return thestatic + x + nested_test1 (x);
+}
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-13.c b/gcc/testsuite/gcc.dg/remove-local-statics-13.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-13.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-13.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,24 @@
+/* We used to ICE on this test, because the call to BAR appeared to
+   define both static variables in FOO.  Verify that we no longer do
+   this.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "static1" } } */
+/* { dg-final { scan-assembler-not "static2" } } */
+
+int foo(int i) {
+  static int static1 = 0;
+  static int static2;
+
+  if (static2 = bar(i))
+    static1 = 1;
+  static2 = static1 + 30;
+
+  return static1 + static2;
+}
+
+int bar(int i) {
+  if (i) { foo(i-1); return 0; }
+  return 1;
+}
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-14.c b/gcc/testsuite/gcc.dg/remove-local-statics-14.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-14.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-14.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,29 @@
+/* Verify that we do eliminate a static local variable whose last use is
+   in a statement containing a call expression.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler-not "thestatic" } } */
+
+int
+test2 (int x)
+{
+  if (x < 0)
+    return 0;
+  else
+    return test1 (x - 1);
+}
+
+int
+test1 (int x)
+{
+  static int thestatic;
+  int y;
+
+  thestatic = x;
+
+  y = test2 (thestatic - 1);
+
+  return y + x;
+}
+  
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-15.c b/gcc/testsuite/gcc.dg/remove-local-statics-15.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-15.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-15.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,17 @@
+/* Verify that we do not consider an array variable for local static
+   elimination.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics -fdump-tree-remlocstatic-details" } */
+
+int foo (void)
+{
+  static int a[1];
+
+  a[0] = 0;
+
+  return a[0];
+}
+
+/* { dg-final { scan-tree-dump-times "static variables to consider" 0 "remlocstatic" } } */
+/* { dg-final { cleanup-tree-dump "remlocstatic" } } */
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-16.c b/gcc/testsuite/gcc.dg/remove-local-statics-16.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-16.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-16.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,20 @@
+/* Verify that we do not consider an structure variable for local static
+   elimination.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics -fdump-tree-remlocstatic-details" } */
+
+int foo (void)
+{
+  static struct {
+    int x;
+    int y;
+  } a;
+
+  a.x = 0;
+
+  return a.y;
+}
+
+/* { dg-final { scan-tree-dump-times "static variables to consider" 0 "remlocstatic" } } */
+/* { dg-final { cleanup-tree-dump "remlocstatic" } } */
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-17.c b/gcc/testsuite/gcc.dg/remove-local-statics-17.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-17.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-17.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,19 @@
+/* Verify that we do not eliminate a static variable that is "defined"
+   by an asm that clobbers memory.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics -fdump-tree-remlocstatic-details" } */
+
+int foo (void)
+{
+  static int foo = 0;
+
+  __asm__ __volatile__ ("bogus" : : : "memory");
+
+  foo++;
+
+  return foo;
+}
+
+/* { dg-final { scan-tree-dump-times "static variables to consider" 0 "remlocstatic" } } */
+/* { dg-final { cleanup-tree-dump "remlocstatic" } } */
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-1.c b/gcc/testsuite/gcc.dg/remove-local-statics-1.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-1.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,16 @@
+/* Verify that we eliminate a static local variable where its uses
+   are dominated by a def.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler-not "thestatic" } } */
+
+int
+test1 (int x)
+{
+  static int thestatic;
+
+  thestatic = x;
+
+  return thestatic + x;
+}
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-2.c b/gcc/testsuite/gcc.dg/remove-local-statics-2.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-2.c	2010-01-25 09:50:29.165687452 +0100
@@ -0,0 +1,19 @@
+/* Verify that we do not eliminate a static local variable when its uses
+   are not dominated by a def.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "first_time" } } */
+
+int
+test1 (int x)
+{
+  static int first_time;
+
+  if (x == 1)
+    first_time = 1;
+  else if (x > 0)
+    first_time = 2;
+
+  return first_time + x;
+}
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-3.c b/gcc/testsuite/gcc.dg/remove-local-statics-3.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-3.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-3.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,16 @@
+/* Verify that we do not eliminate a static local variable whose uses
+   are dominated by a def when the variable is volatile.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int
+test1 (int x)
+{
+  static volatile int thestatic;
+
+  thestatic = x;
+
+  return thestatic + x;
+}
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-4.c b/gcc/testsuite/gcc.dg/remove-local-statics-4.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-4.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-4.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,15 @@
+/* Verify that we don't eliminate a global static variable.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "global_static" } } */
+
+static int global_static;
+
+int
+test1 (int x)
+{
+  global_static = x;
+
+  return global_static + x;
+}
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-5.c b/gcc/testsuite/gcc.dg/remove-local-statics-5.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-5.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-5.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,24 @@
+/* Verify that we do not eliminate a static local variable whose uses
+   are dominated by a def when the function calls setjmp.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+#include <setjmp.h>
+
+int
+foo (int x)
+{
+  static int thestatic;
+  int retval;
+  jmp_buf env;
+
+  thestatic = x;
+
+  retval = thestatic + x;
+
+  setjmp (env);
+
+  return retval;
+}
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-6.c b/gcc/testsuite/gcc.dg/remove-local-statics-6.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-6.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-6.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,16 @@
+/* Verify that we do not eliminate a static local variable whose uses
+   are dominated by a def when the variable is addressed.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int *
+test1 (int x)
+{
+  static int thestatic;
+
+  thestatic = x;
+
+  return &thestatic + x;
+}
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-7.c b/gcc/testsuite/gcc.dg/remove-local-statics-7.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-7.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-7.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,21 @@
+/* Verify that we eliminate a static local variable where it is defined
+   along all paths leading to a use.
+
+   XFAIL'd because our analysis is currently too weak.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler-not "thestatic" } } */
+
+int
+test1 (int x)
+{
+  static int thestatic;
+
+  if (x < 0)
+    thestatic = x;
+  else
+    thestatic = -x;
+
+  return thestatic + x;
+}
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-8.c b/gcc/testsuite/gcc.dg/remove-local-statics-8.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-8.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-8.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,33 @@
+/* Verify that we eliminate a static local variable when it is dead on
+   return from a function call that recursively calls the function in
+   which the variable is defined.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler-not "thestatic" } } */
+
+int test1 (int);
+int test2 (int);
+
+int
+test2 (int x)
+{
+  if (x < 0)
+    return 0;
+  else
+    return test1 (x - 1);
+}
+
+int
+test1 (int x)
+{
+  static int thestatic;
+  int y;
+
+  thestatic = x;
+
+  y = thestatic;
+
+  return y + x + test1 (x - 1) + test2 (x - 1);
+}
+  
diff -Nur a/gcc/testsuite/gcc.dg/remove-local-statics-9.c b/gcc/testsuite/gcc.dg/remove-local-statics-9.c
--- a/gcc/testsuite/gcc.dg/remove-local-statics-9.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-9.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,34 @@
+/* Verify that we eliminate a static local variable when it is live
+   on return from a function call that does not recursively call the
+   function in which the variable is defined.  */
+
+/* XFAIL'd because we don't utilize the callgraph properly.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler-not "thestatic" { xfail *-*-* } } } */
+
+static int
+test2 (int x)
+{
+  if (x < 0)
+    return 0;
+  else
+    return x + test2 (x - 1);
+}
+
+int
+test1 (int x)
+{
+  static int thestatic;
+  int y;
+
+  thestatic = x;
+
+  y = test2 (x - 1);
+
+  y += thestatic;
+
+  return y + x;
+}
+  
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-assign.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-assign.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-assign.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-assign.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,29 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Test basic assignments and conversions for __fp16.  */
+
+__fp16 h0 = -1.0;
+__fp16 h1 = 0.0;
+__fp16 h2 = 1234.0;
+__fp16 h3 = 42.0;
+float f1 = 2.0;
+float f2 = -999.9;
+
+void f (__fp16 *p)
+{
+  __fp16 t;
+
+  h0 = 1.0;
+  h1 = h2;
+  h2 = f1;
+  f2 = h2;
+
+  t = *p;
+  *p = h3;
+  h3 = t;
+}
+
+/* Make sure we are not falling through to undefined libcalls.  */
+/* { dg-final { scan-assembler-not "__truncsfhf" } } */
+/* { dg-final { scan-assembler-not "__extendhfsf" } } */
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-convert.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-convert.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-convert.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-convert.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,41 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Test basic assignments and conversions for __fp16.  */
+
+__fp16 h1 = 0.0;
+__fp16 h2 = 1234.0;
+char c1 = 1;
+char c2 = 2;
+short s1 = 10;
+short s2 = 20;
+int i1 = -100;
+int i2 = -200;
+long long l1 = 1000.0;
+long long l2 = 2000.0;
+double d1 = -10000.0;
+double d2 = -20000.0;
+
+void f (void)
+{
+  c1 = h1;
+  h2 = c2;
+
+  h1 = s1;
+  s2 = h2;
+
+  i1 = h1;
+  h2 = i2;
+
+  h1 = l1;
+  l2 = h2;
+  
+  d1 = h1;
+  h2 = d2;
+}
+
+/* Make sure we are not falling through to undefined libcalls.  */
+/* { dg-final { scan-assembler-not "__float.ihf" } } */
+/* { dg-final { scan-assembler-not "__fixhf.i" } } */
+/* { dg-final { scan-assembler-not "__trunc.fhf" } } */
+/* { dg-final { scan-assembler-not "__extendhf.f" } } */
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-alt.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-alt.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-alt.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-alt.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,17 @@
+/* Test floating-point conversions.  Standard types and __fp16.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+#include "fp-int-convert.h"
+#define FP16_MANT_DIG 11
+
+int
+main (void)
+{
+  TEST_I_F(signed char, unsigned char, float, FP16_MANT_DIG);
+  TEST_I_F(signed short, unsigned short, float, FP16_MANT_DIG);
+  TEST_I_F(signed int, unsigned int, float, FP16_MANT_DIG);
+  TEST_I_F(signed long, unsigned long, float, FP16_MANT_DIG);
+  TEST_I_F(signed long long, unsigned long long, float, FP16_MANT_DIG);
+  exit (0);
+}
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-ieee.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-ieee.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-ieee.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-ieee.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,17 @@
+/* Test floating-point conversions.  Standard types and __fp16.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+#include "fp-int-convert.h"
+#define FP16_MANT_DIG 11
+
+int
+main (void)
+{
+  TEST_I_F(signed char, unsigned char, float, FP16_MANT_DIG);
+  TEST_I_F(signed short, unsigned short, float, FP16_MANT_DIG);
+  TEST_I_F(signed int, unsigned int, float, FP16_MANT_DIG);
+  TEST_I_F(signed long, unsigned long, float, FP16_MANT_DIG);
+  TEST_I_F(signed long long, unsigned long long, float, FP16_MANT_DIG);
+  exit (0);
+}
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-1.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-1.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-1.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+#include "arm-fp16-ops.h"
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-2.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-2.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-2.c	2010-01-25 09:50:29.235686709 +0100
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+
+#include "arm-fp16-ops.h"
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-3.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-3.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-3.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-3.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+#include "arm-fp16-ops.h"
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-4.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-4.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-4.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-4.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=alternative -ffast-math" } */
+
+#include "arm-fp16-ops.h"
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-5.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-5.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-5.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-5.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,15 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_fp16_ok } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-add-options arm_neon_fp16 } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, including fp16 support, so
+   we should not see any calls to libfuncs here.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-6.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-6.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-6.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-6.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,15 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_fp16_ok } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+/* { dg-add-options arm_neon_fp16 } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, including fp16 support, so
+   we should not see any calls to libfuncs here.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-7.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-7.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-7.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-7.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,13 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, so we should not see any 
+   calls to libfuncs here except for those to the conversion functions.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-8.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-8.c
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-8.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-8.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,13 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, so we should not see any 
+   calls to libfuncs here except for those to the conversion functions.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
diff -Nur a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops.h b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops.h
--- a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops.h	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,135 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+
+#include <assert.h>
+
+#define CHECK(e,r) assert ((e) == r)
+#define CHECK2(e,r) (assert ((e) == r), temp = (e), assert (temp == r))
+#define TEST(e) assert (e)
+#define TESTNOT(e) assert (!(e))
+
+volatile __fp16 h0 = 0.0;
+volatile __fp16 h1 = 1.0;
+volatile __fp16 h42 = 42.0;
+volatile __fp16 hm2 = -2.0;
+volatile __fp16 temp;
+
+volatile float f0 = 0.0;
+volatile float f1 = 1.0;
+volatile float f42 = 42.0;
+volatile float fm2 = -2.0;
+
+int main (void)
+{
+  TEST (h1);
+  TESTNOT (h0);
+  TEST (!h0);
+  TESTNOT (!h1);
+
+  CHECK2 (-h1, -1.0);
+  CHECK2 (+h1, 1.0);
+
+  CHECK (h1++, 1.0);
+  CHECK (h1, 2.0);
+  CHECK (++h1, 3.0);
+  CHECK (h1, 3.0);
+
+  CHECK (--h1, 2.0);
+  CHECK (h1, 2.0);
+  CHECK (h1--, 2.0);
+  CHECK (h1, 1.0);
+
+  CHECK2 (h42 * hm2, -84.0);
+  CHECK2 (h42 * (__fp16) -2.0, -84.0);
+  CHECK2 (h42 * fm2, -84.0);
+  CHECK2 (f42 * hm2, -84.0);
+
+  CHECK2 (h42 / hm2, -21.0);
+  CHECK2 (h42 / (__fp16) -2.0, -21.0);
+  CHECK2 (h42 / fm2, -21.0);
+  CHECK2 (f42 / hm2, -21.0);
+
+  CHECK2 (hm2 + h42, 40.0);
+  CHECK2 ((__fp16)-2.0 + h42, 40.0);
+  CHECK2 (hm2 + f42, 40.0);
+  CHECK2 (fm2 + h42, 40.0);
+
+  CHECK2 (hm2 - h42, -44.0);
+  CHECK2 ((__fp16)-2.0 - h42, -44.0);
+  CHECK2 (hm2 - f42, -44.0);
+  CHECK2 (fm2 - h42, -44.0);
+
+  TEST (hm2 < h42);
+  TEST (hm2 < (__fp16)42.0);
+  TEST (hm2 < f42);
+  TEST (fm2 < h42);
+
+  TEST (h42 > hm2);
+  TEST ((__fp16)42.0 > hm2);
+  TEST (h42 > fm2);
+  TEST (f42 > hm2);
+
+  TEST (hm2 <= h42);
+  TEST (hm2 <= (__fp16)42.0);
+  TEST (hm2 <= f42);
+  TEST (fm2 <= h42);
+
+  TEST (h42 >= hm2);
+  TEST (h42 >= (__fp16)-2.0);
+  TEST (h42 >= fm2);
+  TEST (f42 >= hm2);
+
+  TESTNOT (h1 == hm2);
+  TEST (h1 == h1);
+  TEST (h1 == (__fp16)1.0);
+  TEST (h1 == f1);
+  TEST (f1 == h1);
+
+  TEST (h1 != hm2);
+  TESTNOT (h1 != h1);
+  TESTNOT (h1 != (__fp16)1.0);
+  TESTNOT (h1 != f1);
+  TESTNOT (f1 != h1);
+
+  CHECK2 ((h1 ? hm2 : h42), -2.0);
+  CHECK2 ((h0 ? hm2 : h42), 42.0);
+
+  CHECK (h0 = h42, 42.0);
+  CHECK (h0, 42.0);
+  CHECK (h0 = (__fp16)-2.0, -2.0);
+  CHECK (h0, -2.0);
+  CHECK (h0 = f0, 0.0);
+  CHECK (h0, 0.0);
+
+  CHECK (h0 += h1, 1.0);
+  CHECK (h0, 1.0);
+  CHECK (h0 += (__fp16)1.0, 2.0);
+  CHECK (h0, 2.0);
+  CHECK (h0 += fm2, 0.0);
+  CHECK (h0, 0.0);
+
+  CHECK (h0 -= h1, -1.0);
+  CHECK (h0, -1.0);
+  CHECK (h0 -= (__fp16)1.0, -2.0);
+  CHECK (h0, -2.0);
+  CHECK (h0 -= fm2, 0.0);
+  CHECK (h0, 0.0);
+
+  h0 = hm2;
+  CHECK (h0 *= hm2, 4.0);
+  CHECK (h0, 4.0);
+  CHECK (h0 *= (__fp16)-2.0, -8.0);
+  CHECK (h0, -8.0);
+  CHECK (h0 *= fm2, 16.0);
+  CHECK (h0, 16.0);
+
+  CHECK (h0 /= hm2, -8.0);
+  CHECK (h0, -8.0);
+  CHECK (h0 /= (__fp16)-2.0, 4.0);
+  CHECK (h0, 4.0);
+  CHECK (h0 /= fm2, -2.0);
+  CHECK (h0, -2.0);
+
+  CHECK ((h0, h1), 1.0);
+
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.dg/torture/type-generic-1.c b/gcc/testsuite/gcc.dg/torture/type-generic-1.c
--- a/gcc/testsuite/gcc.dg/torture/type-generic-1.c	2008-12-10 08:49:40.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/torture/type-generic-1.c	2010-01-25 09:50:29.245686094 +0100
@@ -3,6 +3,7 @@
 
 /* { dg-do run } */
 /* { dg-options "-mieee" { target alpha*-*-* sh*-*-* } } */
+/* { dg-options "-Wl,--defsym=__cs3_mips_float_type=2 -lcs3-mips-cp1 -lcs3-mips-fpemu" { target mips*-*sde*-* } } */
 /* { dg-skip-if "No Inf/NaN support" { spu-*-* } } */
 
 #include "../tg-tests.h"
diff -Nur a/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c b/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c
--- a/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c	2007-07-12 04:20:04.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c	2010-01-25 09:50:29.245686094 +0100
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-vrp1-details" } */
+/* { dg-options "-O2 -fdump-tree-vrp1-details -fno-remove-local-statics" } */
 
 static int blocksize = 4096;
 
diff -Nur a/gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c b/gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c
--- a/gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c	2007-06-10 22:39:22.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c	2010-01-25 09:50:29.245686094 +0100
@@ -1,5 +1,6 @@
 /* { dg-do compile { target i?86-*-* x86_64-*-* } } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=athlon" } } */
 /* { dg-options "-O2 -fprefetch-loop-arrays -march=athlon -msse2 -mfpmath=sse --param simultaneous-prefetches=100 --param max-unrolled-insns=1 -fdump-tree-aprefetch-details -fdump-tree-final_cleanup" } */
 
 #define K 1000000
diff -Nur a/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c b/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c
--- a/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c	2005-04-26 19:15:46.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c	2010-01-25 09:50:29.245686094 +0100
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-dse1" } */
+/* { dg-options "-O2 -fdump-tree-dse1 -fno-remove-local-statics" } */
 
 int foo11 (int c)
 {
diff -Nur a/gcc/testsuite/gcc.dg/vect/aligned-section-anchors-nest-1.c b/gcc/testsuite/gcc.dg/vect/aligned-section-anchors-nest-1.c
--- a/gcc/testsuite/gcc.dg/vect/aligned-section-anchors-nest-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/vect/aligned-section-anchors-nest-1.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target section_anchors } */
+/* { dg-require-effective-target vect_int } */
+
+#include <stdarg.h>
+#include "tree-vect.h"
+
+#define N 32
+
+static int a[N][N];
+static int b[N][N];
+static int c[N][N];
+
+void clobber(int *);
+
+int *foo(void)
+{
+  int i;
+  int j;
+
+  clobber (&a[0][0]);
+  clobber (&b[0][0]);
+  clobber (&c[0][0]);
+
+  for (i = 0; i < N; i++) {
+      for (j = 0; j < N; j++) {
+	  c[j][i] += a[j][i] + c[j][i];
+      }
+  }
+  return &c[0][0];
+}
+
+/* { dg-final { scan-ipa-dump-times "Increasing alignment of decl" 3 "increase_alignment" } } */
+/* { dg-final { cleanup-ipa-dump "increase_alignment" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-31.c b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-31.c
--- a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-31.c	2007-10-30 06:25:10.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-31.c	2010-01-25 09:50:29.245686094 +0100
@@ -88,5 +88,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-64.c b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-64.c
--- a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-64.c	2007-10-30 06:25:10.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-64.c	2010-01-25 09:50:29.245686094 +0100
@@ -84,5 +84,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-66.c b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-66.c
--- a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-66.c	2008-04-27 18:27:08.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-66.c	2010-01-25 09:50:29.245686094 +0100
@@ -79,5 +79,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-68.c b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-68.c
--- a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-68.c	2007-10-30 06:25:10.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-68.c	2010-01-25 09:50:29.245686094 +0100
@@ -88,5 +88,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c
--- a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c	2008-04-27 18:27:08.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c	2010-01-25 09:50:29.245686094 +0100
@@ -114,7 +114,7 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail {! vector_alignment_reachable} } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_element_align || {! vector_alignment_reachable} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target {! vector_alignment_reachable} } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target {! vector_alignment_reachable} } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { { ! vector_alignment_reachable } && { ! vect_element_align } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c b/gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c
--- a/gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c	2007-08-07 21:13:27.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c	2010-01-25 09:50:29.245686094 +0100
@@ -115,6 +115,6 @@
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* Alignment forced using versioning until the pass that increases alignment
   is extended to handle structs.  */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 4 "vect" { target {vect_int && vector_alignment_reachable } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 4 "vect" { target { {vect_int && vector_alignment_reachable } && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 4 "vect" { target {vect_int && {! vector_alignment_reachable} } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/slp-25.c b/gcc/testsuite/gcc.dg/vect/slp-25.c
--- a/gcc/testsuite/gcc.dg/vect/slp-25.c	2008-04-22 01:32:32.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/slp-25.c	2010-01-25 09:50:29.245686094 +0100
@@ -56,5 +56,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-109.c b/gcc/testsuite/gcc.dg/vect/vect-109.c
--- a/gcc/testsuite/gcc.dg/vect/vect-109.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-109.c	2010-01-25 09:50:29.245686094 +0100
@@ -73,6 +73,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 2 "vect" } } */
-/* { dg-final { scan-tree-dump-times "not vectorized: unsupported unaligned store" 2 "vect" } } */
+/* { dg-final { scan-tree-dump-times "not vectorized: unsupported unaligned store" 2 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-26.c b/gcc/testsuite/gcc.dg/vect/vect-26.c
--- a/gcc/testsuite/gcc.dg/vect/vect-26.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-26.c	2010-01-25 09:50:29.245686094 +0100
@@ -37,5 +37,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-27.c b/gcc/testsuite/gcc.dg/vect/vect-27.c
--- a/gcc/testsuite/gcc.dg/vect/vect-27.c	2007-10-30 06:25:10.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/vect/vect-27.c	2010-01-25 09:50:29.245686094 +0100
@@ -45,6 +45,6 @@
 /* The initialization induction loop (with aligned access) is also vectorized.  */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-28.c b/gcc/testsuite/gcc.dg/vect/vect-28.c
--- a/gcc/testsuite/gcc.dg/vect/vect-28.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-28.c	2010-01-25 09:50:29.245686094 +0100
@@ -40,6 +40,6 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { ! vector_alignment_reachable } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-29.c b/gcc/testsuite/gcc.dg/vect/vect-29.c
--- a/gcc/testsuite/gcc.dg/vect/vect-29.c	2007-10-30 06:25:10.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/vect/vect-29.c	2010-01-25 09:50:29.245686094 +0100
@@ -50,7 +50,7 @@
 
 /* The initialization induction loop (with aligned access) is also vectorized.  */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" {target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-33.c b/gcc/testsuite/gcc.dg/vect/vect-33.c
--- a/gcc/testsuite/gcc.dg/vect/vect-33.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-33.c	2010-01-25 09:50:29.245686094 +0100
@@ -39,6 +39,6 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { ! vector_alignment_reachable } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-42.c b/gcc/testsuite/gcc.dg/vect/vect-42.c
--- a/gcc/testsuite/gcc.dg/vect/vect-42.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-42.c	2010-01-25 09:50:29.245686094 +0100
@@ -57,6 +57,6 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { vect_no_align || { ! vector_alignment_reachable } } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || { ! vector_alignment_reachable } } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail {vect_no_align || { ! vector_alignment_reachable } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { { vect_no_align || vect_element_align } || { ! vector_alignment_reachable } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align || vect_element_align } || { ! vector_alignment_reachable } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-44.c b/gcc/testsuite/gcc.dg/vect/vect-44.c
--- a/gcc/testsuite/gcc.dg/vect/vect-44.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-44.c	2010-01-25 09:50:29.245686094 +0100
@@ -65,8 +65,8 @@
    two loads to be aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align || vect_element_align } || {! vector_alignment_reachable} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { {! vector_alignment_reachable} && {! vect_no_align} } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-48.c b/gcc/testsuite/gcc.dg/vect/vect-48.c
--- a/gcc/testsuite/gcc.dg/vect/vect-48.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-48.c	2010-01-25 09:50:29.245686094 +0100
@@ -54,7 +54,7 @@
    (The store is aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-50.c b/gcc/testsuite/gcc.dg/vect/vect-50.c
--- a/gcc/testsuite/gcc.dg/vect/vect-50.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-50.c	2010-01-25 09:50:29.245686094 +0100
@@ -61,8 +61,8 @@
    two loads to be aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align || vect_element_align } || {! vector_alignment_reachable} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { {! vector_alignment_reachable} && {! vect_no_align} } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-52.c b/gcc/testsuite/gcc.dg/vect/vect-52.c
--- a/gcc/testsuite/gcc.dg/vect/vect-52.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-52.c	2010-01-25 09:50:29.245686094 +0100
@@ -55,7 +55,7 @@
    (The store is aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-54.c b/gcc/testsuite/gcc.dg/vect/vect-54.c
--- a/gcc/testsuite/gcc.dg/vect/vect-54.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-54.c	2010-01-25 09:50:29.245686094 +0100
@@ -59,5 +59,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-56.c b/gcc/testsuite/gcc.dg/vect/vect-56.c
--- a/gcc/testsuite/gcc.dg/vect/vect-56.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-56.c	2010-01-25 09:50:29.245686094 +0100
@@ -67,6 +67,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-58.c b/gcc/testsuite/gcc.dg/vect/vect-58.c
--- a/gcc/testsuite/gcc.dg/vect/vect-58.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-58.c	2010-01-25 09:50:29.245686094 +0100
@@ -58,5 +58,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-60.c b/gcc/testsuite/gcc.dg/vect/vect-60.c
--- a/gcc/testsuite/gcc.dg/vect/vect-60.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-60.c	2010-01-25 09:50:29.245686094 +0100
@@ -68,6 +68,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-70.c b/gcc/testsuite/gcc.dg/vect/vect-70.c
--- a/gcc/testsuite/gcc.dg/vect/vect-70.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-70.c	2010-01-25 09:50:29.245686094 +0100
@@ -64,6 +64,6 @@
           
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" {target {! vector_alignment_reachable} } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-72.c b/gcc/testsuite/gcc.dg/vect/vect-72.c
--- a/gcc/testsuite/gcc.dg/vect/vect-72.c	2008-08-12 08:31:57.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-72.c	2010-01-25 09:50:29.245686094 +0100
@@ -46,6 +46,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-75.c b/gcc/testsuite/gcc.dg/vect/vect-75.c
--- a/gcc/testsuite/gcc.dg/vect/vect-75.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-75.c	2010-01-25 09:50:29.245686094 +0100
@@ -45,5 +45,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-87.c b/gcc/testsuite/gcc.dg/vect/vect-87.c
--- a/gcc/testsuite/gcc.dg/vect/vect-87.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-87.c	2010-01-25 09:50:29.245686094 +0100
@@ -51,6 +51,6 @@
 /* Fails for targets that don't vectorize PLUS (e.g alpha).  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" {target {! vector_alignment_reachable} } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-88.c b/gcc/testsuite/gcc.dg/vect/vect-88.c
--- a/gcc/testsuite/gcc.dg/vect/vect-88.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-88.c	2010-01-25 09:50:29.245686094 +0100
@@ -51,6 +51,6 @@
 /* Fails for targets that don't vectorize PLUS (e.g alpha).  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" {target {! vector_alignment_reachable} } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-89.c b/gcc/testsuite/gcc.dg/vect/vect-89.c
--- a/gcc/testsuite/gcc.dg/vect/vect-89.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-89.c	2010-01-25 09:50:29.245686094 +0100
@@ -46,5 +46,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-91.c b/gcc/testsuite/gcc.dg/vect/vect-91.c
--- a/gcc/testsuite/gcc.dg/vect/vect-91.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-91.c	2010-01-25 09:50:29.245686094 +0100
@@ -59,6 +59,6 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 3 "vect" { xfail vect_no_int_add } } } */
 /* { dg-final { scan-tree-dump-times "accesses have the same alignment." 3 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" {target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" {target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" {target {! vector_alignment_reachable} } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-92.c b/gcc/testsuite/gcc.dg/vect/vect-92.c
--- a/gcc/testsuite/gcc.dg/vect/vect-92.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-92.c	2010-01-25 09:50:29.245686094 +0100
@@ -92,5 +92,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 3 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-93.c b/gcc/testsuite/gcc.dg/vect/vect-93.c
--- a/gcc/testsuite/gcc.dg/vect/vect-93.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-93.c	2010-01-25 09:50:29.245686094 +0100
@@ -72,7 +72,7 @@
 /* main && main1 together: */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 2 "vect" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { vect_no_align && {! vector_alignment_reachable} } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" { xfail { { vect_no_align || vect_element_align } || {! vector_alignment_reachable} } } } } */
 
 /* in main1: */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { target !powerpc*-*-* !i?86-*-* !x86_64-*-* } } } */
@@ -80,6 +80,6 @@
 
 /* in main: */
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-95.c b/gcc/testsuite/gcc.dg/vect/vect-95.c
--- a/gcc/testsuite/gcc.dg/vect/vect-95.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-95.c	2010-01-25 09:50:29.245686094 +0100
@@ -62,8 +62,8 @@
    stores and generate misaligned accesses for the loads. For targets that 
    don't support unaligned loads we version for all four accesses.  */
 
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /*  { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target vect_no_align } } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 4 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-align-2.c b/gcc/testsuite/gcc.dg/vect/vect-align-2.c
--- a/gcc/testsuite/gcc.dg/vect/vect-align-2.c	2008-03-13 21:13:29.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/vect/vect-align-2.c	2010-01-25 09:50:29.245686094 +0100
@@ -43,6 +43,6 @@
 
 
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect.exp b/gcc/testsuite/gcc.dg/vect/vect.exp
--- a/gcc/testsuite/gcc.dg/vect/vect.exp	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/vect/vect.exp	2010-01-25 09:50:29.245686094 +0100
@@ -97,7 +97,7 @@
 } elseif [istarget "ia64-*-*"] {
     set dg-do-what-default run
 } elseif [is-effective-target arm_neon_ok] {
-    lappend DEFAULT_VECTCFLAGS "-mfpu=neon" "-mfloat-abi=softfp"
+    eval lappend DEFAULT_VECTCFLAGS [add_options_for_arm_neon ""]
     if [is-effective-target arm_neon_hw] {
       set dg-do-what-default run
     } else {
@@ -183,6 +183,12 @@
 dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/section-anchors-*.\[cS\]]]  \
 	"" $DEFAULT_VECTCFLAGS
 
+# alignment-sensitive -fsection-anchors tests
+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS
+lappend DEFAULT_VECTCFLAGS "-fsection-anchors" "-fdump-ipa-increase_alignment"
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/aligned-section-anchors-*.\[cS\]]]  \
+	"" $DEFAULT_VECTCFLAGS
+
 # -fno-section-anchors tests
 set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS
 lappend DEFAULT_VECTCFLAGS "-fno-section-anchors"
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c	2010-01-25 09:50:29.245686094 +0100
@@ -78,11 +78,11 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail { ! vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c	2010-01-25 09:50:29.245686094 +0100
@@ -54,6 +54,6 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" { target vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" {xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" {xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c	2010-01-25 09:50:29.245686094 +0100
@@ -85,11 +85,11 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail { ! vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 8 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c	2007-09-04 15:05:19.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c	2010-01-25 09:50:29.245686094 +0100
@@ -61,6 +61,6 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 6 "vect" { target vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 6 "vect" {xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 6 "vect" {xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-shift-2.c b/gcc/testsuite/gcc.dg/vect/vect-shift-2.c
--- a/gcc/testsuite/gcc.dg/vect/vect-shift-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/vect/vect-shift-2.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,37 @@
+/* { dg-require-effective-target vect_shift_char } */
+/* { dg-require-effective-target vect_int } */
+
+#include "tree-vect.h"
+
+#define N 32
+
+unsigned char dst[N] __attribute__((aligned(N)));
+unsigned char src[N] __attribute__((aligned(N)));
+
+__attribute__ ((noinline))
+void array_shift(void)
+{
+  int i;
+  for (i = 0; i < N; i++)
+    dst[i] = src[i] >> 3;
+}
+
+int main()
+{
+  volatile int i;
+  check_vect ();
+
+  for (i = 0; i < N; i++)
+    src[i] = i << 3;
+
+  array_shift ();
+
+  for (i = 0; i < N; i++)
+    if (dst[i] != i)
+      abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vect/vect-shift-3.c b/gcc/testsuite/gcc.dg/vect/vect-shift-3.c
--- a/gcc/testsuite/gcc.dg/vect/vect-shift-3.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.dg/vect/vect-shift-3.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,37 @@
+/* { dg-require-effective-target vect_shift } */
+/* { dg-require-effective-target vect_int } */
+
+#include "tree-vect.h"
+
+#define N 32
+
+unsigned short dst[N] __attribute__((aligned(N)));
+unsigned short src[N] __attribute__((aligned(N)));
+
+__attribute__ ((noinline))
+void array_shift(void)
+{
+  int i;
+  for (i = 0; i < N; i++)
+    dst[i] = src[i] >> 3;
+}
+
+int main()
+{
+  volatile int i;
+  check_vect ();
+
+  for (i = 0; i < N; i++)
+    src[i] = i << 3;
+
+  array_shift ();
+
+  for (i = 0; i < N; i++)
+    if (dst[i] != i)
+      abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
diff -Nur a/gcc/testsuite/gcc.dg/vmx/vmx.exp b/gcc/testsuite/gcc.dg/vmx/vmx.exp
--- a/gcc/testsuite/gcc.dg/vmx/vmx.exp	2007-08-01 18:25:11.000000000 +0200
+++ b/gcc/testsuite/gcc.dg/vmx/vmx.exp	2010-01-25 09:50:29.245686094 +0100
@@ -31,7 +31,7 @@
 # nothing but extensions.
 global DEFAULT_VMXCFLAGS
 if ![info exists DEFAULT_VMXCFLAGS] then {
-    set DEFAULT_VMXCFLAGS "-maltivec -mabi=altivec -std=gnu99"
+    set DEFAULT_VMXCFLAGS "-maltivec -std=gnu99"
 }
 
 # If the target system supports AltiVec instructions, the default action
diff -Nur a/gcc/testsuite/gcc.misc-tests/i386-prefetch.exp b/gcc/testsuite/gcc.misc-tests/i386-prefetch.exp
--- a/gcc/testsuite/gcc.misc-tests/i386-prefetch.exp	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/testsuite/gcc.misc-tests/i386-prefetch.exp	2010-01-25 09:50:29.245686094 +0100
@@ -90,6 +90,13 @@
 dg-init
 torture-init
 
+if { [board_info target exists multilib_flags]
+     && [string match "* -march=*" " [board_info target multilib_flags] "] } {
+    # Multilib flags come after the -march flags we pass and override
+    # them, so skip these tests when such flags are passed.
+    return
+}
+
 set-torture-options $PREFETCH_NONE
 gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/i386-pf-none-*.c]] ""
 
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/aapcs.exp b/gcc/testsuite/gcc.target/arm/aapcs/aapcs.exp
--- a/gcc/testsuite/gcc.target/arm/aapcs/aapcs.exp	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/aapcs.exp	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,35 @@
+# Copyright (C) 1997, 2004, 2006, 2007 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Exit immediately if this isn't an ARM target.
+if ![istarget arm*-*-*] then {
+  return
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cCS\]]] \
+	"" ""
+
+# All done.
+dg-finish
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/abitest.h b/gcc/testsuite/gcc.target/arm/aapcs/abitest.h
--- a/gcc/testsuite/gcc.target/arm/aapcs/abitest.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/abitest.h	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,118 @@
+#define IN_FRAMEWORK
+
+#ifdef VFP
+#define D0	0
+#define D1	8
+#define D2	16
+#define D3	24
+#define D4	32
+#define D5	40
+#define D6	48
+#define D7	56
+
+#define S0	64
+#define S1	68
+#define S2	72
+#define S3	76
+#define S4	80
+#define S5	84
+#define S6	88
+#define S7	92
+#define S8      86
+#define S9	100
+#define S10	104
+#define S11	108
+#define S12	112
+#define S13	116
+#define S14	120
+#define S15	124
+
+#define R0	128
+#define R1	132
+#define R2	136
+#define R3	140
+
+#define STACK	144
+
+#else
+
+#define R0	0
+#define R1	4
+#define R2	8
+#define R3	12
+
+#define STACK   16
+
+#endif
+
+extern void abort (void);
+
+__attribute__((naked))  void dumpregs () __asm("myfunc");
+__attribute__((naked))  void dumpregs ()
+{
+  asm(
+      "mov	ip, sp\n\t"
+      "stmfd	sp!, {r0-r3}\n\t"
+#ifdef VFP
+      "fstmdbs	sp!, {s0-s15}\n\t"
+      "fstmdbd	sp!, {d0-d7}\n\t"
+#endif
+      "mov	r0, sp\n\t"
+      "stmfd	sp!, {ip, r14}\n\t"
+      "bl	testfunc\n\t"
+      "ldmfd	sp!, {r0, r14}\n\t"
+      "mov	sp, r0\n\t"
+      "bx	lr");
+}
+
+
+#define LAST_ARG(type,val,offset) { type __x = val; if (memcmp(&__x, stack+offset, sizeof(type)) != 0) abort(); }
+#define ARG(type,val,offset) LAST_ARG(type, val, offset)
+#define ANON(type,val,offset) LAST_ARG(type, val, offset)
+#define LAST_ANON(type,val,offset) LAST_ARG(type, val, offset)
+#define DOTS
+
+void testfunc(char* stack)
+{
+#include TESTFILE
+  return;
+}
+
+#undef LAST_ARG
+#undef ARG
+#undef DOTS
+#undef ANON
+#undef LAST_ANON
+#define LAST_ARG(type,val,offset) type
+#define ARG(type,val,offset) LAST_ARG(type, val, offset),
+#define DOTS ...
+#define ANON(type,val, offset)
+#define LAST_ANON(type,val, offset)
+
+#ifndef MYFUNCTYPE
+#define MYFUNCTYPE void
+#endif
+
+MYFUNCTYPE myfunc(
+#include TESTFILE
+);
+
+#undef LAST_ARG
+#undef ARG
+#undef DOTS
+#undef ANON
+#undef LAST_ANON
+#define LAST_ARG(type,val,offset) val
+#define ARG(type,val,offset) LAST_ARG(type, val, offset),
+#define DOTS
+#define LAST_ANON(type,val,offset) LAST_ARG(type, val, offset)
+#define ANON(type,val,offset) LAST_ARG(type, val, offset),
+
+
+int main()
+{
+  myfunc(
+#include TESTFILE
+);
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp10.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp10.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp10.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp10.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,38 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp10.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  /* A variadic function passes using the base ABI */
+  ARG(double, 11.0, R0)
+  DOTS
+  ANON(struct z, a, R2)
+  ANON(struct z, b, STACK+24)
+  LAST_ANON(double, 0.5, STACK+56)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp11.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp11.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp11.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp11.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,39 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp11.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#define MYFUNCTYPE struct y
+
+#include "abitest.h"
+#else
+  ARG(int, 7, R1)
+  ARG(struct y, v, R2)
+  ARG(struct z, a, D0)
+  ARG(struct z, b, D4)
+  LAST_ARG(double, 0.5, STACK+8)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp12.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp12.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp12.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp12.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,38 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp12.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  ARG(int, 7, R0)
+  ARG(struct y, v, R1)
+  ARG(struct z, a, D0)
+  ARG(double, 1.0, D4)
+  ARG(struct z, b, STACK+8)
+  LAST_ARG(double, 0.5, STACK+40)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp13.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp13.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp13.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp13.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,39 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp13.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  ARG(int, 7, R0)
+  ARG(int, 9, R1)
+  ARG(struct z, a, D0)
+  ARG(double, 1.0, D4)
+  ARG(struct z, b, STACK)
+  ARG(int, 4, R2)
+  LAST_ARG(double, 0.5, STACK+32)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp14.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp14.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp14.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp14.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,24 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp14.c"
+
+#include "abitest.h"
+#else
+  ARG(double, 1.0, D0)
+  ARG(double, 2.0, D1)
+  ARG(double, 3.0, D2)
+  ARG(double, 4.0, D3)
+  ARG(double, 5.0, D4)
+  ARG(double, 6.0, D5)
+  ARG(double, 7.0, D6)
+  ARG(double, 8.0, D7)
+  ARG(double, 9.0, STACK)
+  LAST_ARG(double, 10.0, STACK+8)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp1.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp1.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp1.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,17 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp1.c"
+#include "abitest.h"
+
+#else
+  ARG(int, 4, R0)
+  ARG(double, 4.0, D0)
+  LAST_ARG(int, 3, R1)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp2.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp2.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp2.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,19 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp2.c"
+#include "abitest.h"
+
+#else
+  ARG(float, 1.0f, S0)
+  ARG(double, 4.0, D1)
+  ARG(float, 2.0f, S1)
+  ARG(double, 5.0, D2)
+  LAST_ARG(int, 3, R0)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp3.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp3.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp3.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp3.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,21 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp3.c"
+
+__complex__ x = 1.0+2.0i;
+
+#include "abitest.h"
+#else
+  ARG(float, 1.0f, S0)
+  ARG(__complex__ double, x, D1)
+  ARG(float, 2.0f, S1)
+  ARG(double, 5.0, D3)
+  LAST_ARG(int, 3, R0)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp4.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp4.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp4.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp4.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,20 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp4.c"
+
+__complex__ float x = 1.0f + 2.0fi;
+#include "abitest.h"
+#else
+  ARG(float, 1.0f, S0)
+  ARG(__complex__ float, x, S1)
+  ARG(float, 2.0f, S3)
+  ARG(double, 5.0, D2)
+  LAST_ARG(int, 3, R0)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp5.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp5.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp5.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp5.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,30 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp5.c"
+
+__complex__ float x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+#include "abitest.h"
+#else
+  ARG(float, 1.0f, S0)
+  ARG(__complex__ float, x, S1)
+  ARG(float, 2.0f, S3)
+  ARG(double, 5.0, D2)
+  ARG(struct y, v, R0)
+  LAST_ARG(int, 3, STACK)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp6.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp6.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp6.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp6.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,30 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp6.c"
+
+__complex__ float x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+#include "abitest.h"
+#else
+  ARG(struct y, v, R0)
+  ARG(float, 1.0f, S0)
+  ARG(__complex__ float, x, S1)
+  ARG(float, 2.0f, S3)
+  ARG(double, 5.0, D2)
+  LAST_ARG(int, 3, STACK)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp7.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp7.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp7.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp7.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,37 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp7.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  ARG(struct z, a, D0)
+  ARG(struct z, b, D4)
+  ARG(double, 0.5, STACK)
+  ARG(int, 7, R0)
+  LAST_ARG(struct y, v, STACK+8)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp8.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp8.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp8.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp8.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,37 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp8.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  ARG(int, 7, R0)
+  ARG(struct y, v, R1)
+  ARG(struct z, a, D0)
+  ARG(struct z, b, D4)
+  LAST_ARG(double, 0.5, STACK+8)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/aapcs/vfp9.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp9.c
--- a/gcc/testsuite/gcc.target/arm/aapcs/vfp9.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp9.c	2010-01-25 09:50:29.245686094 +0100
@@ -0,0 +1,38 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp9.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  /* A variadic function passes using the base ABI */
+  ARG(int, 7, R0)
+  DOTS
+  ANON(struct z, a, R2)
+  ANON(struct z, b, STACK+24)
+  LAST_ANON(double, 0.5, STACK+56)
+#endif
diff -Nur a/gcc/testsuite/gcc.target/arm/ctz.c b/gcc/testsuite/gcc.target/arm/ctz.c
--- a/gcc/testsuite/gcc.target/arm/ctz.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/ctz.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O2 -march=armv6t2" } */
+
+unsigned int functest(unsigned int x)
+{
+	return __builtin_ctz(x);
+}
+
+/* { dg-final { scan-assembler "rbit" } } */
+/* { dg-final { scan-assembler "clz" } } */
+/* { dg-final { scan-assembler-not "rsb" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/eabi1.c b/gcc/testsuite/gcc.target/arm/eabi1.c
--- a/gcc/testsuite/gcc.target/arm/eabi1.c	2009-01-14 02:44:39.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/eabi1.c	2010-01-25 09:50:29.265686890 +0100
@@ -30,43 +30,48 @@
 #include <stdlib.h>
 #include <math.h>
 
-#define decl_float(code, type)					\
-  extern type __aeabi_ ## code ## add (type, type);		\
-  extern type __aeabi_ ## code ## div (type, type);		\
-  extern type __aeabi_ ## code ## mul (type, type);		\
-  extern type __aeabi_ ## code ## neg (type);			\
-  extern type __aeabi_ ## code ## rsub (type, type);		\
-  extern type __aeabi_ ## code ## sub (type, type);		\
-  extern int __aeabi_ ## code ## cmpeq (type, type);		\
-  extern int __aeabi_ ## code ## cmplt (type, type);		\
-  extern int __aeabi_ ## code ## cmple (type, type);		\
-  extern int __aeabi_ ## code ## cmpge (type, type);		\
-  extern int __aeabi_ ## code ## cmpgt (type, type);		\
-  extern int __aeabi_ ## code ## cmpun (type, type);		\
-  extern int __aeabi_ ## code ## 2iz (type);			\
-  extern unsigned int __aeabi_ ## code ## 2uiz (type);		\
-  extern long long __aeabi_ ## code ## 2lz (type);		\
-  extern unsigned long long __aeabi_ ## code ## 2ulz (type);	\
-  extern type __aeabi_i2 ## code (int);				\
-  extern type __aeabi_ui2 ## code (int);			\
-  extern type __aeabi_l2 ## code (long long);			\
-  extern type __aeabi_ul2 ## code (unsigned long long);		\
-								\
-  type code ## zero = 0.0;					\
-  type code ## one = 1.0;					\
-  type code ## two = 2.0;					\
-  type code ## four = 4.0;					\
-  type code ## minus_one = -1.0;				\
-  type code ## minus_two = -2.0;				\
-  type code ## minus_four = -4.0;				\
-  type code ## epsilon = 1E-32;					\
-  type code ## NaN = 0.0 / 0.0;				
+/* All these functions are defined to use the base ABI, so use the
+   attribute to ensure the tests use the base ABI to call them even
+   when the VFP ABI is otherwise in effect.  */
+#define PCS __attribute__((pcs("aapcs")))
+
+#define decl_float(code, type)						\
+  extern type __aeabi_ ## code ## add (type, type) PCS;			\
+  extern type __aeabi_ ## code ## div (type, type) PCS;			\
+  extern type __aeabi_ ## code ## mul (type, type) PCS;			\
+  extern type __aeabi_ ## code ## neg (type) PCS;			\
+  extern type __aeabi_ ## code ## rsub (type, type) PCS;		\
+  extern type __aeabi_ ## code ## sub (type, type) PCS;			\
+  extern int __aeabi_ ## code ## cmpeq (type, type) PCS;		\
+  extern int __aeabi_ ## code ## cmplt (type, type) PCS;		\
+  extern int __aeabi_ ## code ## cmple (type, type) PCS;		\
+  extern int __aeabi_ ## code ## cmpge (type, type) PCS;		\
+  extern int __aeabi_ ## code ## cmpgt (type, type) PCS;		\
+  extern int __aeabi_ ## code ## cmpun (type, type) PCS;		\
+  extern int __aeabi_ ## code ## 2iz (type) PCS;			\
+  extern unsigned int __aeabi_ ## code ## 2uiz (type) PCS;		\
+  extern long long __aeabi_ ## code ## 2lz (type) PCS;			\
+  extern unsigned long long __aeabi_ ## code ## 2ulz (type) PCS;	\
+  extern type __aeabi_i2 ## code (int) PCS;				\
+  extern type __aeabi_ui2 ## code (int) PCS;				\
+  extern type __aeabi_l2 ## code (long long) PCS;			\
+  extern type __aeabi_ul2 ## code (unsigned long long) PCS;		\
+									\
+  type code ## zero = 0.0;						\
+  type code ## one = 1.0;						\
+  type code ## two = 2.0;						\
+  type code ## four = 4.0;						\
+  type code ## minus_one = -1.0;					\
+  type code ## minus_two = -2.0;					\
+  type code ## minus_four = -4.0;					\
+  type code ## epsilon = 1E-32;						\
+  type code ## NaN = 0.0 / 0.0;
 
 decl_float (d, double)
 decl_float (f, float)
 
-extern float __aeabi_d2f (double);
-extern double __aeabi_f2d (float);
+extern float __aeabi_d2f (double) PCS;
+extern double __aeabi_f2d (float) PCS;
 extern long long __aeabi_lmul (long long, long long);
 extern long long __aeabi_llsl (long long, int);
 extern long long __aeabi_llsr (long long, int);
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-builtins-1.c b/gcc/testsuite/gcc.target/arm/fp16-builtins-1.c
--- a/gcc/testsuite/gcc.target/arm/fp16-builtins-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-builtins-1.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,92 @@
+/* Test type-generic builtins with __fp16 arguments.
+   Except as otherwise noted, they should behave exactly
+   the same as those with float arguments.  */
+
+/* { dg-do run } */
+/* { dg-options "-mfp16-format=ieee -std=gnu99" } */
+
+#include <stdlib.h>
+#include <math.h>
+
+volatile __fp16 h1, h2;
+volatile float f1, f2;
+
+void
+set1 (double x)
+{
+  h1 = x;
+  f1 = h1;
+}
+
+void
+set2 (double x, double y)
+{
+  h1 = x;
+  f1 = h1;
+  h2 = y;
+  f2 = h2;
+}
+
+#define test1(p,x)				\
+  set1 (x);					\
+  hp = (p (h1) ? 1 : 0);			\
+  fp = (p (f1) ? 1 : 0);			\
+  if (hp ^ fp) abort ()
+
+#define test2(p,x,y)				\
+  set2 (x,y);					\
+  hp = (p (h1, h2) ? 1 : 0);			\
+  fp = (p (f1, f2) ? 1 : 0);			\
+  if (hp ^ fp) abort ()
+
+int
+main (void)
+{
+  int hp, fp;
+
+  test1 (__builtin_isfinite, 17.0);
+  test1 (__builtin_isfinite, INFINITY);
+  test1 (__builtin_isinf, -0.5);
+  test1 (__builtin_isinf, INFINITY);
+  test1 (__builtin_isnan, 493.0);
+  test1 (__builtin_isnan, NAN);
+  test1 (__builtin_isnormal, 3.14159);
+
+  test2 (__builtin_isgreater, 5.0, 3.0);
+  test2 (__builtin_isgreater, 3.0, 5.0);
+  test2 (__builtin_isgreater, 73.5, 73.5);
+  test2 (__builtin_isgreater, 1.0, NAN);
+
+  test2 (__builtin_isgreaterequal, 5.0, 3.0);
+  test2 (__builtin_isgreaterequal, 3.0, 5.0);
+  test2 (__builtin_isgreaterequal, 73.5, 73.5);
+  test2 (__builtin_isgreaterequal, 1.0, NAN);
+
+  test2 (__builtin_isless, 5.0, 3.0);
+  test2 (__builtin_isless, 3.0, 5.0);
+  test2 (__builtin_isless, 73.5, 73.5);
+  test2 (__builtin_isless, 1.0, NAN);
+
+  test2 (__builtin_islessequal, 5.0, 3.0);
+  test2 (__builtin_islessequal, 3.0, 5.0);
+  test2 (__builtin_islessequal, 73.5, 73.5);
+  test2 (__builtin_islessequal, 1.0, NAN);
+
+  test2 (__builtin_islessgreater, 5.0, 3.0);
+  test2 (__builtin_islessgreater, 3.0, 5.0);
+  test2 (__builtin_islessgreater, 73.5, 73.5);
+  test2 (__builtin_islessgreater, 1.0, NAN);
+
+  test2 (__builtin_isunordered, 5.0, 3.0);
+  test2 (__builtin_isunordered, 3.0, 5.0);
+  test2 (__builtin_isunordered, 73.5, 73.5);
+  test2 (__builtin_isunordered, 1.0, NAN);
+
+  /* Test that __builtin_isnormal recognizes a denormalized __fp16 value,
+     even if it's representable as a normalized float.  */
+  h1 = 5.96046E-8;
+  if (__builtin_isnormal (h1))
+    abort ();
+
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-10.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-10.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-10.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-10.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative -pedantic -std=gnu99" } */
+
+#include <math.h>
+
+/* NaNs are not representable in the alternative format; we should get a
+   diagnostic.  */
+__fp16 xx = NAN; /* { dg-warning "overflow" } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-11.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-11.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-11.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-11.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative -pedantic -std=gnu99" } */
+
+#include <math.h>
+
+/* Infinities are not representable in the alternative format;
+   we should get a diagnostic, and the value set to the largest
+   representable value.  */
+/* 0x7fff = 32767 */
+__fp16 xx = INFINITY; /* { dg-warning "overflow" } */
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t32767" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-12.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-12.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-12.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-12.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+float xx __attribute__((mode(HF))) = 0.0;
+
+/* { dg-final { scan-assembler "\t.eabi_attribute 38, 2" } } */
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.space\t2" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-1.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-1.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-1.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+__fp16 xx = 0.0;
+
+/* { dg-final { scan-assembler "\t.eabi_attribute 38, 2" } } */
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.space\t2" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-2.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-2.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-2.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x3c00 = 15360 */
+__fp16 xx = 1.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t15360" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-3.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-3.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-3.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-3.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0xc000 = 49152 */
+__fp16 xx = -2.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t49152" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-4.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-4.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-4.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-4.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x7bff = 31743 */
+__fp16 xx = 65504.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t31743" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-5.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-5.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-5.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-5.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x3555 = 13653 */
+__fp16 xx = (1.0/3.0);
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t13653" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-6.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-6.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-6.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-6.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* This number is the maximum value representable in the alternative
+   encoding.  */
+/* 0x7fff = 32767 */
+__fp16 xx = 131008.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t32767" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-7.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-7.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-7.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-7.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative -pedantic" } */
+
+/* This number overflows the range of the alternative encoding.  Since this
+   encoding doesn't have infinities, we should get a pedantic warning,
+   and the value should be set to the largest representable value.  */
+/* 0x7fff = 32767 */
+__fp16 xx = 123456789.0;  /* { dg-warning "overflow" } */
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t32767" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-8.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-8.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-8.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-8.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This is the minimum normalized value.  */
+/* 0x0400 = 1024 */
+__fp16 xx = 6.10352E-5;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t1024" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-9.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-9.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-9.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-9.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This is the minimum denormalized value.  */
+/* 0x0001 = 1 */
+__fp16 xx = 5.96046E-8;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t1" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-exprtype.c b/gcc/testsuite/gcc.target/arm/fp16-compile-exprtype.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-exprtype.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-exprtype.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,29 @@
+/* Test that expressions involving __fp16 values have the right types.  */
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* This produces a diagnostic if EXPR doesn't have type TYPE.  */
+#define CHECK(expr,type)			\
+  do {						\
+    type v;					\
+    __typeof (expr) *p = &v;			\
+  } while (0);
+
+volatile __fp16 f1;
+volatile __fp16 f2;
+
+int
+main (void)
+{
+  CHECK (f1, __fp16);
+  CHECK (+f1, float);
+  CHECK (-f1, float);
+  CHECK (f1+f2, float);
+  CHECK ((__fp16)(f1+f2), __fp16);
+  CHECK ((__fp16)99.99, __fp16);
+  CHECK ((f1+f2, f1), __fp16);
+}
+
+
+
+
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-10.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-10.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-10.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-10.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee -std=gnu99" } */
+
+#include <math.h>
+
+/* 0x7e00 = 32256 */
+__fp16 xx = NAN;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t32256" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-11.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-11.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-11.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-11.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee -std=gnu99" } */
+
+#include <math.h>
+
+/* 0x7c00 = 31744 */
+__fp16 xx = INFINITY;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t31744" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-12.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-12.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-12.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-12.c	2010-01-25 09:50:29.265686890 +0100
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+float xx __attribute__((mode(HF))) = 0.0;
+
+/* { dg-final { scan-assembler "\t.eabi_attribute 38, 1" } } */
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.space\t2" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-1.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-1.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-1.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+__fp16 xx = 0.0;
+
+/* { dg-final { scan-assembler "\t.eabi_attribute 38, 1" } } */
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.space\t2" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-2.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-2.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-2.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x3c00 = 15360 */
+__fp16 xx = 1.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t15360" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-3.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-3.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-3.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-3.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0xc000 = 49152 */
+__fp16 xx = -2.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t49152" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-4.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-4.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-4.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-4.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x7bff = 31743 */
+__fp16 xx = 65504.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t31743" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-5.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-5.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-5.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-5.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x3555 = 13653 */
+__fp16 xx = (1.0/3.0);
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t13653" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-6.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-6.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-6.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-6.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This number is too big and is represented as infinity.  */
+/* 0x7c00 = 31744 */
+__fp16 xx = 131008.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t31744" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-7.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-7.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-7.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-7.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee -pedantic" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This number is too big and is represented as infinity.  */
+/* We should *not* get an overflow warning here.  */
+/* 0x7c00 = 31744 */
+__fp16 xx = 123456789.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t31744" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-8.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-8.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-8.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-8.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This is the minimum normalized value.  */
+/* 0x0400 = 1024 */
+__fp16 xx = 6.10352E-5;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t1024" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-9.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-9.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-9.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-9.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This is the minimum denormalized value.  */
+/* 0x0001 = 1 */
+__fp16 xx = 5.96046E-8;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t1" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-none-1.c b/gcc/testsuite/gcc.target/arm/fp16-compile-none-1.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-none-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-none-1.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=none" } */
+
+/* __fp16 type name is not recognized unless you explicitly enable it
+   by selecting -mfp16-format=ieee or -mfp16-format=alternative.  */
+__fp16 xx = 0.0;  /* { dg-error "expected" } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-none-2.c b/gcc/testsuite/gcc.target/arm/fp16-compile-none-2.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-none-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-none-2.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=none" } */
+
+/* mode(HF) attributes are not recognized unless you explicitly enable
+   half-precision floating point by selecting -mfp16-format=ieee or
+   -mfp16-format=alternative.  */
+float xx __attribute__((mode(HF))) = 0.0;  /* { dg-error "HF" } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-compile-vcvt.c b/gcc/testsuite/gcc.target/arm/fp16-compile-vcvt.c
--- a/gcc/testsuite/gcc.target/arm/fp16-compile-vcvt.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-vcvt.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_fp16_ok } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-add-options arm_neon_fp16 } */
+
+/* Test generation of VFP __fp16 instructions.  */
+
+__fp16 h1 = 0.0;
+__fp16 h2 = 1234.0;
+float f1 = 2.0;
+float f2 = -999.9;
+
+void f (void)
+{
+  h1 = f1;
+  f2 = h2;
+}
+
+/* { dg-final { scan-assembler "\tvcvtb.f32.f16" } } */
+/* { dg-final { scan-assembler "\tvcvtb.f16.f32" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-param-1.c b/gcc/testsuite/gcc.target/arm/fp16-param-1.c
--- a/gcc/testsuite/gcc.target/arm/fp16-param-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-param-1.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Functions cannot have parameters of type __fp16.  */
+extern void f (__fp16);		/* { dg-error "parameters cannot have __fp16 type" } */
+extern void (*pf) (__fp16);	/* { dg-error "parameters cannot have __fp16 type" } */
+
+/* These should be OK.  */
+extern void g (__fp16 *);
+extern void (*pg) (__fp16 *);
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-return-1.c b/gcc/testsuite/gcc.target/arm/fp16-return-1.c
--- a/gcc/testsuite/gcc.target/arm/fp16-return-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-return-1.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Functions cannot return type __fp16.  */
+extern __fp16 f (void);		/* { dg-error "cannot return __fp16" } */
+extern __fp16 (*pf) (void);	/* { dg-error "cannot return __fp16" } */
+
+/* These should be OK.  */
+extern __fp16 *g (void);
+extern __fp16 *(*pg) (void);
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-rounding-alt-1.c b/gcc/testsuite/gcc.target/arm/fp16-rounding-alt-1.c
--- a/gcc/testsuite/gcc.target/arm/fp16-rounding-alt-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-rounding-alt-1.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,47 @@
+/* Test intermediate rounding of double to float and then to __fp16, using
+   an example of a number that would round differently if it went directly
+   from double to __fp16.  */
+
+/* { dg-do run } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+#include <stdlib.h>
+
+/* The original double value.  */
+#define ORIG 0x1.0020008p0
+
+/* The expected (double)((__fp16)((float)ORIG)) value.  */
+#define ROUNDED 0x1.0000000p0
+
+typedef union u {
+  __fp16 f;
+  unsigned short h;
+} ufh;
+
+ufh s = { ORIG };
+ufh r = { ROUNDED };
+
+double d = ORIG;
+
+int
+main (void)
+{
+  ufh x;
+
+  /* Test that the rounding is correct for static initializers.  */
+  if (s.h != r.h)
+    abort ();
+
+  /* Test that the rounding is correct for a casted constant expression
+     not in a static initializer.  */
+  x.f = (__fp16)ORIG;
+  if (x.h != r.h)
+    abort ();
+
+  /* Test that the rounding is correct for a runtime conversion.  */
+  x.f = (__fp16)d;
+  if (x.h != r.h)
+    abort ();
+
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-rounding-ieee-1.c b/gcc/testsuite/gcc.target/arm/fp16-rounding-ieee-1.c
--- a/gcc/testsuite/gcc.target/arm/fp16-rounding-ieee-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-rounding-ieee-1.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,47 @@
+/* Test intermediate rounding of double to float and then to __fp16, using
+   an example of a number that would round differently if it went directly
+   from double to __fp16.  */
+
+/* { dg-do run } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+#include <stdlib.h>
+
+/* The original double value.  */
+#define ORIG 0x1.0020008p0
+
+/* The expected (double)((__fp16)((float)ORIG)) value.  */
+#define ROUNDED 0x1.0000000p0
+
+typedef union u {
+  __fp16 f;
+  unsigned short h;
+} ufh;
+
+ufh s = { ORIG };
+ufh r = { ROUNDED };
+
+double d = ORIG;
+
+int
+main (void)
+{
+  ufh x;
+
+  /* Test that the rounding is correct for static initializers.  */
+  if (s.h != r.h)
+    abort ();
+
+  /* Test that the rounding is correct for a casted constant expression
+     not in a static initializer.  */
+  x.f = (__fp16)ORIG;
+  if (x.h != r.h)
+    abort ();
+
+  /* Test that the rounding is correct for a runtime conversion.  */
+  x.f = (__fp16)d;
+  if (x.h != r.h)
+    abort ();
+
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-unprototyped-1.c b/gcc/testsuite/gcc.target/arm/fp16-unprototyped-1.c
--- a/gcc/testsuite/gcc.target/arm/fp16-unprototyped-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-unprototyped-1.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,21 @@
+/* Test promotion of __fp16 to double as arguments to unprototyped
+   function in another compilation unit.  */
+
+/* { dg-do run } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-additional-sources "fp16-unprototyped-2.c" } */
+
+#include <stdlib.h>
+
+extern int f ();
+
+static __fp16 x = 42.0;
+static __fp16 y = -42.0;
+
+int
+main (void)
+{
+  if (!f (x, y))
+    abort ();
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-unprototyped-2.c b/gcc/testsuite/gcc.target/arm/fp16-unprototyped-2.c
--- a/gcc/testsuite/gcc.target/arm/fp16-unprototyped-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-unprototyped-2.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+extern int f ();
+
+int
+f (double xx, double yy)
+{
+  if (xx == 42.0 && yy == -42.0)
+    return 1;
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/fp16-variadic-1.c b/gcc/testsuite/gcc.target/arm/fp16-variadic-1.c
--- a/gcc/testsuite/gcc.target/arm/fp16-variadic-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/fp16-variadic-1.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,37 @@
+/* Test promotion of __fp16 to double as arguments to variadic function.  */
+
+/* { dg-do run } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+#include <stdlib.h>
+#include <stdarg.h>
+
+extern int f (int n, ...);
+
+int 
+f (int n, ...)
+{
+  if (n == 2)
+    {
+      double xx, yy;
+      va_list ap;
+      va_start (ap, n);
+      xx = va_arg (ap, double);
+      yy = va_arg (ap, double);
+      va_end (ap);
+      if (xx == 42.0 && yy == -42.0)
+	return 1;
+    }
+  return 0;
+}
+
+static __fp16 x = 42.0;
+static __fp16 y = -42.0;
+
+int
+main (void)
+{
+  if (!f (2, x, y))
+    abort ();
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/frame-pointer-1.c b/gcc/testsuite/gcc.target/arm/frame-pointer-1.c
--- a/gcc/testsuite/gcc.target/arm/frame-pointer-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/frame-pointer-1.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,42 @@
+/* Check local register variables using a register conventionally 
+   used as the frame pointer aren't clobbered under high register pressure.  */
+/* { dg-do run } */
+/* { dg-options "-Os -mthumb -fomit-frame-pointer" } */
+
+#include <stdlib.h>
+
+int global=5;
+
+void __attribute__((noinline)) foo(int p1, int p2, int p3, int p4)
+{
+  if (global != 5 || p1 != 1 || p2 != 2 || p3 != 3 || p4 != 4)
+    abort();
+}
+
+int __attribute__((noinline)) test(int a, int b, int c, int d)
+{
+  register unsigned long r __asm__("r7") = 0xdeadbeef;
+  int e;
+
+  /* ABCD are live after the call which should be enough
+     to cause r7 to be used if it weren't for the register variable.  */
+  foo(a,b,c,d);
+
+  e = 0;
+  __asm__ __volatile__ ("mov %0, %2"
+			: "=r" (e)
+			: "0" (e), "r" (r));
+
+  global = a+b+c+d;
+
+  return e;
+}
+
+int main()
+{
+  if (test(1, 2, 3, 4) != 0xdeadbeef)
+    abort();
+  if (global != 10)
+    abort();
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/janus-2cc-shift-1.c b/gcc/testsuite/gcc.target/arm/janus-2cc-shift-1.c
--- a/gcc/testsuite/gcc.target/arm/janus-2cc-shift-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/janus-2cc-shift-1.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,17 @@
+/* Check that a nop is inserted after a shift taking a register operand.  */
+/* { dg-do compile } */
+/* { dg-options "-mfix-janus-2cc" } */
+/* { dg-require-effective-target arm_not_thumb } */
+int foo(int x)
+{
+  int y;
+  int z;
+  
+  y = x << 4;
+  z = y << x;
+
+  return y+z;
+}
+/* { dg-final { scan-assembler "\tmov\tr\[0-9], r\[0-9], asl r\[0-9]\n\tnop\n" } } */
+/* { dg-final { scan-assembler-not "\tmov\tr\[0-9], r\[0-9], asl #4\n\tnop\n" } } */
+
diff -Nur a/gcc/testsuite/gcc.target/arm/janus-2cc-shift-2.c b/gcc/testsuite/gcc.target/arm/janus-2cc-shift-2.c
--- a/gcc/testsuite/gcc.target/arm/janus-2cc-shift-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/janus-2cc-shift-2.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,17 @@
+/* Check that a nop is inserted after a shift taking a register operand.  */
+/* { dg-do compile } */
+/* { dg-options "-mfix-janus-2cc -mthumb" } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+int foo(int x)
+{
+  int y;
+  int z;
+  
+  y = x << 4;
+  z = y << x;
+
+  return y+z;
+}
+/* { dg-final { scan-assembler "\tlsl\tr\[0-9], r\[0-9], r\[0-9]\n\tnop\n" } } */
+/* { dg-final { scan-assembler-not "\tlsl\tr\[0-9], r\[0-9], #4\n\tnop\n" } } */
+
diff -Nur a/gcc/testsuite/gcc.target/arm/mmx-1.c b/gcc/testsuite/gcc.target/arm/mmx-1.c
--- a/gcc/testsuite/gcc.target/arm/mmx-1.c	2008-09-13 15:26:46.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/mmx-1.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,10 +3,10 @@
 /* { dg-do compile } */
 /* { dg-skip-if "Test is specific to the iWMMXt" { arm*-*-* } { "-mcpu=*" } { "-mcpu=iwmmxt" } } */
 /* { dg-skip-if "Test is specific to the iWMMXt" { arm*-*-* } { "-mabi=*" } { "-mabi=iwmmxt" } } */
-/* { dg-skip-if "Test is specific to the iWMMXt" { arm*-*-* } { "-mfloat-abi=softfp" } { "" } } */
 /* { dg-skip-if "Test is specific to the iWMMXt" { arm*-*-* } { "-march=*" } { "-march=iwmmxt" } } */
 /* { dg-options "-O -mno-apcs-frame -mcpu=iwmmxt -mabi=iwmmxt" } */
 /* { dg-require-effective-target arm32 } */
+/* { dg-require-effective-target arm_iwmmxt_ok } */
 /* { dg-final { scan-assembler "ldmfd\[ 	]sp!.*ip,\[ ]*pc" } } */
 
 /* This function uses all the call-saved registers, namely r4, r5, r6,
diff -Nur a/gcc/testsuite/gcc.target/arm/naked-3.c b/gcc/testsuite/gcc.target/arm/naked-3.c
--- a/gcc/testsuite/gcc.target/arm/naked-3.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/naked-3.c	2010-01-25 09:50:29.275686903 +0100
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall" } */
+/* Check that we do not get warnings about missing return statements
+   or bogus looking noreturn functions.  */
+int __attribute__((naked))
+foo(void)
+{
+  __asm__ volatile ("mov r0, #1\r\nbx lr\n");
+}
+
+int __attribute__((naked,noreturn))
+bar(void)
+{
+  __asm__ volatile ("frob r0\n");
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/polytypes.c b/gcc/testsuite/gcc.target/arm/neon/polytypes.c
--- a/gcc/testsuite/gcc.target/arm/neon/polytypes.c	2008-07-02 21:35:08.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/polytypes.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,7 @@
 
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-add-options arm_neon } */
 
 #include <arm_neon.h>
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabals16.c b/gcc/testsuite/gcc.target/arm/neon/vabals16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabals16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabals16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabals32.c b/gcc/testsuite/gcc.target/arm/neon/vabals32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabals32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabals32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabals8.c b/gcc/testsuite/gcc.target/arm/neon/vabals8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabals8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabals8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabalu16.c b/gcc/testsuite/gcc.target/arm/neon/vabalu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabalu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabalu16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabalu32.c b/gcc/testsuite/gcc.target/arm/neon/vabalu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabalu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabalu32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabalu8.c b/gcc/testsuite/gcc.target/arm/neon/vabalu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabalu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabalu8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c b/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c b/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c b/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c b/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c b/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c b/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabas16.c b/gcc/testsuite/gcc.target/arm/neon/vabas16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabas16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabas16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabas32.c b/gcc/testsuite/gcc.target/arm/neon/vabas32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabas32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabas32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabas8.c b/gcc/testsuite/gcc.target/arm/neon/vabas8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabas8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabas8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabau16.c b/gcc/testsuite/gcc.target/arm/neon/vabau16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabau16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabau16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabau32.c b/gcc/testsuite/gcc.target/arm/neon/vabau32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabau32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabau32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabau8.c b/gcc/testsuite/gcc.target/arm/neon/vabau8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabau8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabau8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdf32.c b/gcc/testsuite/gcc.target/arm/neon/vabdf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdf32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdls16.c b/gcc/testsuite/gcc.target/arm/neon/vabdls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdls16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdls32.c b/gcc/testsuite/gcc.target/arm/neon/vabdls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdls32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdls8.c b/gcc/testsuite/gcc.target/arm/neon/vabdls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdls8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c b/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c b/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c b/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c b/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c b/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c b/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c b/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c b/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c b/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c b/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabds16.c b/gcc/testsuite/gcc.target/arm/neon/vabds16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabds16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabds16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabds32.c b/gcc/testsuite/gcc.target/arm/neon/vabds32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabds32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabds32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabds8.c b/gcc/testsuite/gcc.target/arm/neon/vabds8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabds8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabds8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdu16.c b/gcc/testsuite/gcc.target/arm/neon/vabdu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdu16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdu32.c b/gcc/testsuite/gcc.target/arm/neon/vabdu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdu32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabdu8.c b/gcc/testsuite/gcc.target/arm/neon/vabdu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabdu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdu8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabsf32.c b/gcc/testsuite/gcc.target/arm/neon/vabsf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabsf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabsf32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c b/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c b/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c b/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c b/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabss16.c b/gcc/testsuite/gcc.target/arm/neon/vabss16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabss16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabss16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabss32.c b/gcc/testsuite/gcc.target/arm/neon/vabss32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabss32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabss32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vabss8.c b/gcc/testsuite/gcc.target/arm/neon/vabss8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vabss8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vabss8.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddf32.c b/gcc/testsuite/gcc.target/arm/neon/vaddf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddf32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c b/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c b/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c b/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c b/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c	2010-01-25 09:50:29.275686903 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c b/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c b/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddls16.c b/gcc/testsuite/gcc.target/arm/neon/vaddls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddls16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddls32.c b/gcc/testsuite/gcc.target/arm/neon/vaddls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddls32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddls8.c b/gcc/testsuite/gcc.target/arm/neon/vaddls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddls8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c b/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c b/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c b/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c b/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c b/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c b/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c b/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c b/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c b/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c b/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c b/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c b/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vadds16.c b/gcc/testsuite/gcc.target/arm/neon/vadds16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vadds16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vadds16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vadds32.c b/gcc/testsuite/gcc.target/arm/neon/vadds32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vadds32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vadds32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vadds64.c b/gcc/testsuite/gcc.target/arm/neon/vadds64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vadds64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vadds64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vadds8.c b/gcc/testsuite/gcc.target/arm/neon/vadds8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vadds8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vadds8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddu16.c b/gcc/testsuite/gcc.target/arm/neon/vaddu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddu16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddu32.c b/gcc/testsuite/gcc.target/arm/neon/vaddu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddu32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddu64.c b/gcc/testsuite/gcc.target/arm/neon/vaddu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddu64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddu8.c b/gcc/testsuite/gcc.target/arm/neon/vaddu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddu8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddws16.c b/gcc/testsuite/gcc.target/arm/neon/vaddws16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddws16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddws16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddws32.c b/gcc/testsuite/gcc.target/arm/neon/vaddws32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddws32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddws32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddws8.c b/gcc/testsuite/gcc.target/arm/neon/vaddws8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddws8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddws8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c b/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c b/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c b/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandQs16.c b/gcc/testsuite/gcc.target/arm/neon/vandQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQs16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandQs32.c b/gcc/testsuite/gcc.target/arm/neon/vandQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQs32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandQs64.c b/gcc/testsuite/gcc.target/arm/neon/vandQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQs64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandQs8.c b/gcc/testsuite/gcc.target/arm/neon/vandQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQs8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandQu16.c b/gcc/testsuite/gcc.target/arm/neon/vandQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQu16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandQu32.c b/gcc/testsuite/gcc.target/arm/neon/vandQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQu32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandQu64.c b/gcc/testsuite/gcc.target/arm/neon/vandQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQu64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandQu8.c b/gcc/testsuite/gcc.target/arm/neon/vandQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQu8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vands16.c b/gcc/testsuite/gcc.target/arm/neon/vands16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vands16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vands16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vands32.c b/gcc/testsuite/gcc.target/arm/neon/vands32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vands32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vands32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vands64.c b/gcc/testsuite/gcc.target/arm/neon/vands64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vands64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vands64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vands8.c b/gcc/testsuite/gcc.target/arm/neon/vands8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vands8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vands8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandu16.c b/gcc/testsuite/gcc.target/arm/neon/vandu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandu16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandu32.c b/gcc/testsuite/gcc.target/arm/neon/vandu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandu32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandu64.c b/gcc/testsuite/gcc.target/arm/neon/vandu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandu64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vandu8.c b/gcc/testsuite/gcc.target/arm/neon/vandu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vandu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vandu8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c b/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c b/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c b/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c b/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c b/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c b/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c b/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c b/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbics16.c b/gcc/testsuite/gcc.target/arm/neon/vbics16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbics16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbics16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbics32.c b/gcc/testsuite/gcc.target/arm/neon/vbics32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbics32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbics32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbics64.c b/gcc/testsuite/gcc.target/arm/neon/vbics64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbics64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbics64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbics8.c b/gcc/testsuite/gcc.target/arm/neon/vbics8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbics8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbics8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicu16.c b/gcc/testsuite/gcc.target/arm/neon/vbicu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicu16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicu32.c b/gcc/testsuite/gcc.target/arm/neon/vbicu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicu32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicu64.c b/gcc/testsuite/gcc.target/arm/neon/vbicu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicu64.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbicu8.c b/gcc/testsuite/gcc.target/arm/neon/vbicu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbicu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicu8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslf32.c b/gcc/testsuite/gcc.target/arm/neon/vbslf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslf32.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslp16.c b/gcc/testsuite/gcc.target/arm/neon/vbslp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslp16.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslp8.c b/gcc/testsuite/gcc.target/arm/neon/vbslp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslp8.c	2010-01-25 09:50:29.285687196 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c b/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c b/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c b/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c b/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c b/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c b/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c b/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c b/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c b/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c b/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c b/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbsls16.c b/gcc/testsuite/gcc.target/arm/neon/vbsls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbsls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbsls16.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbsls32.c b/gcc/testsuite/gcc.target/arm/neon/vbsls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbsls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbsls32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbsls64.c b/gcc/testsuite/gcc.target/arm/neon/vbsls64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbsls64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbsls64.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbsls8.c b/gcc/testsuite/gcc.target/arm/neon/vbsls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbsls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbsls8.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslu16.c b/gcc/testsuite/gcc.target/arm/neon/vbslu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslu16.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslu32.c b/gcc/testsuite/gcc.target/arm/neon/vbslu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslu32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslu64.c b/gcc/testsuite/gcc.target/arm/neon/vbslu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslu64.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vbslu8.c b/gcc/testsuite/gcc.target/arm/neon/vbslu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vbslu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslu8.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcagef32.c b/gcc/testsuite/gcc.target/arm/neon/vcagef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcagef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcagef32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c b/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcalef32.c b/gcc/testsuite/gcc.target/arm/neon/vcalef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcalef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcalef32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c b/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c	2010-01-25 09:50:29.295686791 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqf32.c b/gcc/testsuite/gcc.target/arm/neon/vceqf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqf32.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqp8.c b/gcc/testsuite/gcc.target/arm/neon/vceqp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqp8.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c b/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c b/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c b/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c b/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c b/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c b/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c b/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c b/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqs16.c b/gcc/testsuite/gcc.target/arm/neon/vceqs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqs16.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqs32.c b/gcc/testsuite/gcc.target/arm/neon/vceqs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqs32.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vceqs8.c b/gcc/testsuite/gcc.target/arm/neon/vceqs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vceqs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqs8.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcequ16.c b/gcc/testsuite/gcc.target/arm/neon/vcequ16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcequ16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcequ16.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcequ32.c b/gcc/testsuite/gcc.target/arm/neon/vcequ32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcequ32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcequ32.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcequ8.c b/gcc/testsuite/gcc.target/arm/neon/vcequ8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcequ8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcequ8.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgef32.c b/gcc/testsuite/gcc.target/arm/neon/vcgef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgef32.c	2010-01-25 09:50:29.305687083 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcges16.c b/gcc/testsuite/gcc.target/arm/neon/vcges16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcges16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcges16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcges32.c b/gcc/testsuite/gcc.target/arm/neon/vcges32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcges32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcges32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcges8.c b/gcc/testsuite/gcc.target/arm/neon/vcges8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcges8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcges8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c b/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c b/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c b/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c b/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgts16.c b/gcc/testsuite/gcc.target/arm/neon/vcgts16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgts16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgts16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgts32.c b/gcc/testsuite/gcc.target/arm/neon/vcgts32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgts32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgts32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgts8.c b/gcc/testsuite/gcc.target/arm/neon/vcgts8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgts8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgts8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c b/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c b/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c b/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclef32.c b/gcc/testsuite/gcc.target/arm/neon/vclef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclef32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c b/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c b/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c b/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c b/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c b/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c b/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcles16.c b/gcc/testsuite/gcc.target/arm/neon/vcles16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcles16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcles16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcles32.c b/gcc/testsuite/gcc.target/arm/neon/vcles32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcles32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcles32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcles8.c b/gcc/testsuite/gcc.target/arm/neon/vcles8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcles8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcles8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcleu16.c b/gcc/testsuite/gcc.target/arm/neon/vcleu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcleu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleu16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcleu32.c b/gcc/testsuite/gcc.target/arm/neon/vcleu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcleu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleu32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcleu8.c b/gcc/testsuite/gcc.target/arm/neon/vcleu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcleu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleu8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c b/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c b/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c b/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclss16.c b/gcc/testsuite/gcc.target/arm/neon/vclss16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclss16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclss16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclss32.c b/gcc/testsuite/gcc.target/arm/neon/vclss32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclss32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclss32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclss8.c b/gcc/testsuite/gcc.target/arm/neon/vclss8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclss8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclss8.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcltf32.c b/gcc/testsuite/gcc.target/arm/neon/vcltf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcltf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltf32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c b/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c b/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c	2010-01-25 09:50:29.315687027 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c b/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c b/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c b/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c b/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclts16.c b/gcc/testsuite/gcc.target/arm/neon/vclts16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclts16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclts16.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclts32.c b/gcc/testsuite/gcc.target/arm/neon/vclts32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclts32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclts32.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclts8.c b/gcc/testsuite/gcc.target/arm/neon/vclts8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclts8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclts8.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcltu16.c b/gcc/testsuite/gcc.target/arm/neon/vcltu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcltu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltu16.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcltu32.c b/gcc/testsuite/gcc.target/arm/neon/vcltu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcltu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltu32.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcltu8.c b/gcc/testsuite/gcc.target/arm/neon/vcltu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcltu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltu8.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c b/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c b/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c b/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c b/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c b/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c b/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzs16.c b/gcc/testsuite/gcc.target/arm/neon/vclzs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzs16.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzs32.c b/gcc/testsuite/gcc.target/arm/neon/vclzs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzs32.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzs8.c b/gcc/testsuite/gcc.target/arm/neon/vclzs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzs8.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzu16.c b/gcc/testsuite/gcc.target/arm/neon/vclzu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzu16.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzu32.c b/gcc/testsuite/gcc.target/arm/neon/vclzu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzu32.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vclzu8.c b/gcc/testsuite/gcc.target/arm/neon/vclzu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vclzu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzu8.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcntp8.c b/gcc/testsuite/gcc.target/arm/neon/vcntp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcntp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcntp8.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c b/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c	2010-01-25 09:50:29.335686357 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c b/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c b/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcnts8.c b/gcc/testsuite/gcc.target/arm/neon/vcnts8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcnts8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcnts8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcntu8.c b/gcc/testsuite/gcc.target/arm/neon/vcntu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcntu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcntu8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcombinef32.c b/gcc/testsuite/gcc.target/arm/neon/vcombinef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcombinef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombinef32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcombinep16.c b/gcc/testsuite/gcc.target/arm/neon/vcombinep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcombinep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombinep16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcombinep8.c b/gcc/testsuite/gcc.target/arm/neon/vcombinep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcombinep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombinep8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcombines16.c b/gcc/testsuite/gcc.target/arm/neon/vcombines16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcombines16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombines16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcombines32.c b/gcc/testsuite/gcc.target/arm/neon/vcombines32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcombines32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombines32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcombines64.c b/gcc/testsuite/gcc.target/arm/neon/vcombines64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcombines64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombines64.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcombines8.c b/gcc/testsuite/gcc.target/arm/neon/vcombines8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcombines8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombines8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcombineu16.c b/gcc/testsuite/gcc.target/arm/neon/vcombineu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcombineu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombineu16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcombineu32.c b/gcc/testsuite/gcc.target/arm/neon/vcombineu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcombineu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombineu32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcombineu64.c b/gcc/testsuite/gcc.target/arm/neon/vcombineu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcombineu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombineu64.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcombineu8.c b/gcc/testsuite/gcc.target/arm/neon/vcombineu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcombineu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombineu8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcreatef32.c b/gcc/testsuite/gcc.target/arm/neon/vcreatef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcreatef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreatef32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcreatep16.c b/gcc/testsuite/gcc.target/arm/neon/vcreatep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcreatep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreatep16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcreatep8.c b/gcc/testsuite/gcc.target/arm/neon/vcreatep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcreatep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreatep8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcreates16.c b/gcc/testsuite/gcc.target/arm/neon/vcreates16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcreates16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreates16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcreates32.c b/gcc/testsuite/gcc.target/arm/neon/vcreates32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcreates32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreates32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcreates64.c b/gcc/testsuite/gcc.target/arm/neon/vcreates64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcreates64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreates64.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcreates8.c b/gcc/testsuite/gcc.target/arm/neon/vcreates8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcreates8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreates8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcreateu16.c b/gcc/testsuite/gcc.target/arm/neon/vcreateu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcreateu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreateu16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcreateu32.c b/gcc/testsuite/gcc.target/arm/neon/vcreateu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcreateu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreateu32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcreateu64.c b/gcc/testsuite/gcc.target/arm/neon/vcreateu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcreateu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreateu64.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcreateu8.c b/gcc/testsuite/gcc.target/arm/neon/vcreateu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcreateu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreateu8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes64.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu64.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes64.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c	2010-01-25 09:50:29.345686441 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu64.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veorQs16.c b/gcc/testsuite/gcc.target/arm/neon/veorQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/veorQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQs16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veorQs32.c b/gcc/testsuite/gcc.target/arm/neon/veorQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/veorQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQs32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veorQs64.c b/gcc/testsuite/gcc.target/arm/neon/veorQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/veorQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQs64.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veorQs8.c b/gcc/testsuite/gcc.target/arm/neon/veorQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/veorQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQs8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veorQu16.c b/gcc/testsuite/gcc.target/arm/neon/veorQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/veorQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQu16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veorQu32.c b/gcc/testsuite/gcc.target/arm/neon/veorQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/veorQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQu32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veorQu64.c b/gcc/testsuite/gcc.target/arm/neon/veorQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/veorQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQu64.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veorQu8.c b/gcc/testsuite/gcc.target/arm/neon/veorQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/veorQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQu8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veors16.c b/gcc/testsuite/gcc.target/arm/neon/veors16.c
--- a/gcc/testsuite/gcc.target/arm/neon/veors16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veors16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veors32.c b/gcc/testsuite/gcc.target/arm/neon/veors32.c
--- a/gcc/testsuite/gcc.target/arm/neon/veors32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veors32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veors64.c b/gcc/testsuite/gcc.target/arm/neon/veors64.c
--- a/gcc/testsuite/gcc.target/arm/neon/veors64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veors64.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veors8.c b/gcc/testsuite/gcc.target/arm/neon/veors8.c
--- a/gcc/testsuite/gcc.target/arm/neon/veors8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veors8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veoru16.c b/gcc/testsuite/gcc.target/arm/neon/veoru16.c
--- a/gcc/testsuite/gcc.target/arm/neon/veoru16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veoru16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veoru32.c b/gcc/testsuite/gcc.target/arm/neon/veoru32.c
--- a/gcc/testsuite/gcc.target/arm/neon/veoru32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veoru32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veoru64.c b/gcc/testsuite/gcc.target/arm/neon/veoru64.c
--- a/gcc/testsuite/gcc.target/arm/neon/veoru64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veoru64.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/veoru8.c b/gcc/testsuite/gcc.target/arm/neon/veoru8.c
--- a/gcc/testsuite/gcc.target/arm/neon/veoru8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/veoru8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextf32.c b/gcc/testsuite/gcc.target/arm/neon/vextf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextf32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextp16.c b/gcc/testsuite/gcc.target/arm/neon/vextp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextp16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextp8.c b/gcc/testsuite/gcc.target/arm/neon/vextp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextp8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextQf32.c b/gcc/testsuite/gcc.target/arm/neon/vextQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQf32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextQp16.c b/gcc/testsuite/gcc.target/arm/neon/vextQp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextQp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQp16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextQp8.c b/gcc/testsuite/gcc.target/arm/neon/vextQp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextQp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQp8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextQs16.c b/gcc/testsuite/gcc.target/arm/neon/vextQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQs16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextQs32.c b/gcc/testsuite/gcc.target/arm/neon/vextQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQs32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextQs64.c b/gcc/testsuite/gcc.target/arm/neon/vextQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQs64.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextQs8.c b/gcc/testsuite/gcc.target/arm/neon/vextQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQs8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextQu16.c b/gcc/testsuite/gcc.target/arm/neon/vextQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQu16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextQu32.c b/gcc/testsuite/gcc.target/arm/neon/vextQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQu32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextQu64.c b/gcc/testsuite/gcc.target/arm/neon/vextQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQu64.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextQu8.c b/gcc/testsuite/gcc.target/arm/neon/vextQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQu8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vexts16.c b/gcc/testsuite/gcc.target/arm/neon/vexts16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vexts16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vexts16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vexts32.c b/gcc/testsuite/gcc.target/arm/neon/vexts32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vexts32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vexts32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vexts64.c b/gcc/testsuite/gcc.target/arm/neon/vexts64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vexts64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vexts64.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vexts8.c b/gcc/testsuite/gcc.target/arm/neon/vexts8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vexts8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vexts8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextu16.c b/gcc/testsuite/gcc.target/arm/neon/vextu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextu16.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextu32.c b/gcc/testsuite/gcc.target/arm/neon/vextu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextu32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextu64.c b/gcc/testsuite/gcc.target/arm/neon/vextu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextu64.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vextu8.c b/gcc/testsuite/gcc.target/arm/neon/vextu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vextu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vextu8.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c b/gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c
--- a/gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c	2010-01-25 09:50:29.355686315 +0100
@@ -0,0 +1,27 @@
+/* Check that NEON vector shifts support immediate values == size.  /*
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint16x8_t test_vshll_n_u8 (uint8x8_t a)
+{
+    return vshll_n_u8(a, 8);
+}
+
+uint32x4_t test_vshll_n_u16 (uint16x4_t a)
+{   
+    return vshll_n_u16(a, 16);
+}
+
+uint64x2_t test_vshll_n_u32 (uint32x2_t a)
+{
+    return vshll_n_u32(a, 32);
+}
+
+/* { dg-final { scan-assembler "vshll\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_highf32.c b/gcc/testsuite/gcc.target/arm/neon/vget_highf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highf32.c	2010-01-25 09:50:29.355686315 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_highp16.c b/gcc/testsuite/gcc.target/arm/neon/vget_highp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highp16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_highp8.c b/gcc/testsuite/gcc.target/arm/neon/vget_highp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highp8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_highs16.c b/gcc/testsuite/gcc.target/arm/neon/vget_highs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highs16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_highs32.c b/gcc/testsuite/gcc.target/arm/neon/vget_highs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highs32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_highs64.c b/gcc/testsuite/gcc.target/arm/neon/vget_highs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highs64.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_highs8.c b/gcc/testsuite/gcc.target/arm/neon/vget_highs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highs8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_highu16.c b/gcc/testsuite/gcc.target/arm/neon/vget_highu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highu16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_highu32.c b/gcc/testsuite/gcc.target/arm/neon/vget_highu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highu32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_highu64.c b/gcc/testsuite/gcc.target/arm/neon/vget_highu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highu64.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_highu8.c b/gcc/testsuite/gcc.target/arm/neon/vget_highu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highu8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c	2007-07-30 15:48:43.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c	2007-07-30 15:48:43.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c	2007-07-30 15:48:43.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c b/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c b/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lows64.c b/gcc/testsuite/gcc.target/arm/neon/vget_lows64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lows64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lows64.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c b/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c	2007-07-30 15:48:43.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c	2007-07-30 15:48:43.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c	2007-07-30 15:48:43.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhadds16.c b/gcc/testsuite/gcc.target/arm/neon/vhadds16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhadds16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhadds16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhadds32.c b/gcc/testsuite/gcc.target/arm/neon/vhadds32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhadds32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhadds32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhadds8.c b/gcc/testsuite/gcc.target/arm/neon/vhadds8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhadds8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhadds8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c b/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c b/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c b/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c b/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c b/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c b/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c b/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c b/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c b/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c	2010-01-25 09:50:29.365686888 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1f32.c b/gcc/testsuite/gcc.target/arm/neon/vld1f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1f32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1p16.c b/gcc/testsuite/gcc.target/arm/neon/vld1p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1p16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1p8.c b/gcc/testsuite/gcc.target/arm/neon/vld1p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1p8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1s16.c b/gcc/testsuite/gcc.target/arm/neon/vld1s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1s16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1s32.c b/gcc/testsuite/gcc.target/arm/neon/vld1s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1s32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1s64.c b/gcc/testsuite/gcc.target/arm/neon/vld1s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1s64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1s8.c b/gcc/testsuite/gcc.target/arm/neon/vld1s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1s8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1u16.c b/gcc/testsuite/gcc.target/arm/neon/vld1u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1u16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1u32.c b/gcc/testsuite/gcc.target/arm/neon/vld1u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1u32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1u64.c b/gcc/testsuite/gcc.target/arm/neon/vld1u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1u64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld1u8.c b/gcc/testsuite/gcc.target/arm/neon/vld1u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld1u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1u8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2f32.c b/gcc/testsuite/gcc.target/arm/neon/vld2f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2f32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c	2010-01-25 09:50:29.375686623 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2p16.c b/gcc/testsuite/gcc.target/arm/neon/vld2p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2p16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2p8.c b/gcc/testsuite/gcc.target/arm/neon/vld2p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2p8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2s16.c b/gcc/testsuite/gcc.target/arm/neon/vld2s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2s16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2s32.c b/gcc/testsuite/gcc.target/arm/neon/vld2s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2s32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2s64.c b/gcc/testsuite/gcc.target/arm/neon/vld2s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2s64.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2s8.c b/gcc/testsuite/gcc.target/arm/neon/vld2s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2s8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2u16.c b/gcc/testsuite/gcc.target/arm/neon/vld2u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2u16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2u32.c b/gcc/testsuite/gcc.target/arm/neon/vld2u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2u32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2u64.c b/gcc/testsuite/gcc.target/arm/neon/vld2u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2u64.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld2u8.c b/gcc/testsuite/gcc.target/arm/neon/vld2u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld2u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2u8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3f32.c b/gcc/testsuite/gcc.target/arm/neon/vld3f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3f32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3p16.c b/gcc/testsuite/gcc.target/arm/neon/vld3p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3p16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3p8.c b/gcc/testsuite/gcc.target/arm/neon/vld3p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3p8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c	2010-01-25 09:50:29.385686707 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3s16.c b/gcc/testsuite/gcc.target/arm/neon/vld3s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3s16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3s32.c b/gcc/testsuite/gcc.target/arm/neon/vld3s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3s32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3s64.c b/gcc/testsuite/gcc.target/arm/neon/vld3s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3s64.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3s8.c b/gcc/testsuite/gcc.target/arm/neon/vld3s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3s8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3u16.c b/gcc/testsuite/gcc.target/arm/neon/vld3u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3u16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3u32.c b/gcc/testsuite/gcc.target/arm/neon/vld3u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3u32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3u64.c b/gcc/testsuite/gcc.target/arm/neon/vld3u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3u64.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld3u8.c b/gcc/testsuite/gcc.target/arm/neon/vld3u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld3u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3u8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4f32.c b/gcc/testsuite/gcc.target/arm/neon/vld4f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4f32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4p16.c b/gcc/testsuite/gcc.target/arm/neon/vld4p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4p16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4p8.c b/gcc/testsuite/gcc.target/arm/neon/vld4p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4p8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4s16.c b/gcc/testsuite/gcc.target/arm/neon/vld4s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4s16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4s32.c b/gcc/testsuite/gcc.target/arm/neon/vld4s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4s32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4s64.c b/gcc/testsuite/gcc.target/arm/neon/vld4s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4s64.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4s8.c b/gcc/testsuite/gcc.target/arm/neon/vld4s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4s8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4u16.c b/gcc/testsuite/gcc.target/arm/neon/vld4u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4u16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4u32.c b/gcc/testsuite/gcc.target/arm/neon/vld4u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4u32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4u64.c b/gcc/testsuite/gcc.target/arm/neon/vld4u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4u64.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vld4u8.c b/gcc/testsuite/gcc.target/arm/neon/vld4u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vld4u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4u8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c b/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c b/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c b/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c b/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vminf32.c b/gcc/testsuite/gcc.target/arm/neon/vminf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vminf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vminf32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vminQf32.c b/gcc/testsuite/gcc.target/arm/neon/vminQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vminQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQf32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vminQs16.c b/gcc/testsuite/gcc.target/arm/neon/vminQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vminQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQs16.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vminQs32.c b/gcc/testsuite/gcc.target/arm/neon/vminQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vminQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQs32.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vminQs8.c b/gcc/testsuite/gcc.target/arm/neon/vminQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vminQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQs8.c	2010-01-25 09:50:29.395687140 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vminQu16.c b/gcc/testsuite/gcc.target/arm/neon/vminQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vminQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vminQu32.c b/gcc/testsuite/gcc.target/arm/neon/vminQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vminQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vminQu8.c b/gcc/testsuite/gcc.target/arm/neon/vminQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vminQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQu8.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmins16.c b/gcc/testsuite/gcc.target/arm/neon/vmins16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmins16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmins16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmins32.c b/gcc/testsuite/gcc.target/arm/neon/vmins32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmins32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmins32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmins8.c b/gcc/testsuite/gcc.target/arm/neon/vmins8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmins8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmins8.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vminu16.c b/gcc/testsuite/gcc.target/arm/neon/vminu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vminu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vminu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vminu32.c b/gcc/testsuite/gcc.target/arm/neon/vminu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vminu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vminu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vminu8.c b/gcc/testsuite/gcc.target/arm/neon/vminu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vminu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vminu8.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlals16.c b/gcc/testsuite/gcc.target/arm/neon/vmlals16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlals16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlals16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlals32.c b/gcc/testsuite/gcc.target/arm/neon/vmlals32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlals32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlals32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlals8.c b/gcc/testsuite/gcc.target/arm/neon/vmlals8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlals8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlals8.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c b/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlas16.c b/gcc/testsuite/gcc.target/arm/neon/vmlas16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlas16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlas16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlas32.c b/gcc/testsuite/gcc.target/arm/neon/vmlas32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlas32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlas32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlas8.c b/gcc/testsuite/gcc.target/arm/neon/vmlas8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlas8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlas8.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlau16.c b/gcc/testsuite/gcc.target/arm/neon/vmlau16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlau16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlau16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlau32.c b/gcc/testsuite/gcc.target/arm/neon/vmlau32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlau32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlau32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlau8.c b/gcc/testsuite/gcc.target/arm/neon/vmlau8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlau8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlau8.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c b/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c	2010-01-25 09:50:29.405687154 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c b/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlss16.c b/gcc/testsuite/gcc.target/arm/neon/vmlss16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlss16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlss16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlss32.c b/gcc/testsuite/gcc.target/arm/neon/vmlss32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlss32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlss32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlss8.c b/gcc/testsuite/gcc.target/arm/neon/vmlss8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlss8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlss8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c b/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovls16.c b/gcc/testsuite/gcc.target/arm/neon/vmovls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovls16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovls32.c b/gcc/testsuite/gcc.target/arm/neon/vmovls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovls32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovls8.c b/gcc/testsuite/gcc.target/arm/neon/vmovls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovls8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c b/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c b/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c b/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c b/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c b/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovns16.c b/gcc/testsuite/gcc.target/arm/neon/vmovns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovns16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovns32.c b/gcc/testsuite/gcc.target/arm/neon/vmovns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovns32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovns64.c b/gcc/testsuite/gcc.target/arm/neon/vmovns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovns64.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c b/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c b/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c b/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulf32.c b/gcc/testsuite/gcc.target/arm/neon/vmulf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulf32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c	2010-01-25 09:50:29.415686609 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmullp8.c b/gcc/testsuite/gcc.target/arm/neon/vmullp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmullp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmullp8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulls16.c b/gcc/testsuite/gcc.target/arm/neon/vmulls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulls16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulls32.c b/gcc/testsuite/gcc.target/arm/neon/vmulls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulls32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulls8.c b/gcc/testsuite/gcc.target/arm/neon/vmulls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulls8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmullu16.c b/gcc/testsuite/gcc.target/arm/neon/vmullu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmullu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmullu16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmullu32.c b/gcc/testsuite/gcc.target/arm/neon/vmullu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmullu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmullu32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmullu8.c b/gcc/testsuite/gcc.target/arm/neon/vmullu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmullu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmullu8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulp8.c b/gcc/testsuite/gcc.target/arm/neon/vmulp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulp8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c b/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c b/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c b/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmuls16.c b/gcc/testsuite/gcc.target/arm/neon/vmuls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmuls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmuls16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmuls32.c b/gcc/testsuite/gcc.target/arm/neon/vmuls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmuls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmuls32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmuls8.c b/gcc/testsuite/gcc.target/arm/neon/vmuls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmuls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmuls8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulu16.c b/gcc/testsuite/gcc.target/arm/neon/vmulu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulu16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulu32.c b/gcc/testsuite/gcc.target/arm/neon/vmulu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulu32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmulu8.c b/gcc/testsuite/gcc.target/arm/neon/vmulu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmulu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulu8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c b/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvns16.c b/gcc/testsuite/gcc.target/arm/neon/vmvns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvns16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvns32.c b/gcc/testsuite/gcc.target/arm/neon/vmvns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvns32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvns8.c b/gcc/testsuite/gcc.target/arm/neon/vmvns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvns8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c b/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c b/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c b/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vnegf32.c b/gcc/testsuite/gcc.target/arm/neon/vnegf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vnegf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegf32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c b/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c b/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c b/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c b/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vnegs16.c b/gcc/testsuite/gcc.target/arm/neon/vnegs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vnegs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegs16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vnegs32.c b/gcc/testsuite/gcc.target/arm/neon/vnegs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vnegs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegs32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vnegs8.c b/gcc/testsuite/gcc.target/arm/neon/vnegs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vnegs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegs8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornQs16.c b/gcc/testsuite/gcc.target/arm/neon/vornQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQs16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornQs32.c b/gcc/testsuite/gcc.target/arm/neon/vornQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQs32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornQs64.c b/gcc/testsuite/gcc.target/arm/neon/vornQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQs64.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornQs8.c b/gcc/testsuite/gcc.target/arm/neon/vornQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQs8.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornQu16.c b/gcc/testsuite/gcc.target/arm/neon/vornQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQu16.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornQu32.c b/gcc/testsuite/gcc.target/arm/neon/vornQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQu32.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornQu64.c b/gcc/testsuite/gcc.target/arm/neon/vornQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQu64.c	2010-01-25 09:50:29.425686763 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornQu8.c b/gcc/testsuite/gcc.target/arm/neon/vornQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQu8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorns16.c b/gcc/testsuite/gcc.target/arm/neon/vorns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorns16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorns32.c b/gcc/testsuite/gcc.target/arm/neon/vorns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorns32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorns64.c b/gcc/testsuite/gcc.target/arm/neon/vorns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorns64.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorns8.c b/gcc/testsuite/gcc.target/arm/neon/vorns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorns8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornu16.c b/gcc/testsuite/gcc.target/arm/neon/vornu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornu16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornu32.c b/gcc/testsuite/gcc.target/arm/neon/vornu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornu32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornu64.c b/gcc/testsuite/gcc.target/arm/neon/vornu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornu64.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vornu8.c b/gcc/testsuite/gcc.target/arm/neon/vornu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vornu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vornu8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c b/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c b/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c b/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c b/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c b/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c b/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c b/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c b/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrs16.c b/gcc/testsuite/gcc.target/arm/neon/vorrs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrs16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrs32.c b/gcc/testsuite/gcc.target/arm/neon/vorrs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrs32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrs64.c b/gcc/testsuite/gcc.target/arm/neon/vorrs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrs64.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorrs8.c b/gcc/testsuite/gcc.target/arm/neon/vorrs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorrs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrs8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorru16.c b/gcc/testsuite/gcc.target/arm/neon/vorru16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorru16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorru16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorru32.c b/gcc/testsuite/gcc.target/arm/neon/vorru32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorru32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorru32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorru64.c b/gcc/testsuite/gcc.target/arm/neon/vorru64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorru64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorru64.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vorru8.c b/gcc/testsuite/gcc.target/arm/neon/vorru8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vorru8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vorru8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadals16.c b/gcc/testsuite/gcc.target/arm/neon/vpadals16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadals16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadals16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadals32.c b/gcc/testsuite/gcc.target/arm/neon/vpadals32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadals32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadals32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadals8.c b/gcc/testsuite/gcc.target/arm/neon/vpadals8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadals8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadals8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c b/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c b/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c b/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c b/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c b/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadds16.c b/gcc/testsuite/gcc.target/arm/neon/vpadds16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadds16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadds16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadds32.c b/gcc/testsuite/gcc.target/arm/neon/vpadds32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadds32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadds32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpadds8.c b/gcc/testsuite/gcc.target/arm/neon/vpadds8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpadds8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadds8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c b/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c b/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpminf32.c b/gcc/testsuite/gcc.target/arm/neon/vpminf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpminf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpminf32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpmins16.c b/gcc/testsuite/gcc.target/arm/neon/vpmins16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpmins16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmins16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpmins32.c b/gcc/testsuite/gcc.target/arm/neon/vpmins32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpmins32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmins32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpmins8.c b/gcc/testsuite/gcc.target/arm/neon/vpmins8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpmins8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmins8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpminu16.c b/gcc/testsuite/gcc.target/arm/neon/vpminu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpminu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpminu16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpminu32.c b/gcc/testsuite/gcc.target/arm/neon/vpminu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpminu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpminu32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vpminu8.c b/gcc/testsuite/gcc.target/arm/neon/vpminu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vpminu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vpminu8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqabss16.c b/gcc/testsuite/gcc.target/arm/neon/vqabss16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqabss16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabss16.c	2010-01-25 09:50:29.435686987 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqabss32.c b/gcc/testsuite/gcc.target/arm/neon/vqabss32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqabss32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabss32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqabss8.c b/gcc/testsuite/gcc.target/arm/neon/vqabss8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqabss8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabss8.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqadds16.c b/gcc/testsuite/gcc.target/arm/neon/vqadds16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqadds16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqadds16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqadds32.c b/gcc/testsuite/gcc.target/arm/neon/vqadds32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqadds32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqadds32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqadds64.c b/gcc/testsuite/gcc.target/arm/neon/vqadds64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqadds64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqadds64.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqadds8.c b/gcc/testsuite/gcc.target/arm/neon/vqadds8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqadds8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqadds8.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c b/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c b/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c b/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c b/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c b/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c b/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c b/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c b/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c b/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c b/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c b/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c b/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c b/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c b/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c b/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c b/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c	2010-01-25 09:50:29.445687421 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c b/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshls16.c b/gcc/testsuite/gcc.target/arm/neon/vqshls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshls16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshls32.c b/gcc/testsuite/gcc.target/arm/neon/vqshls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshls32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshls64.c b/gcc/testsuite/gcc.target/arm/neon/vqshls64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshls64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshls64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshls8.c b/gcc/testsuite/gcc.target/arm/neon/vqshls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshls8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c	2010-01-25 09:50:29.455686248 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c b/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c b/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c b/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c b/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c b/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c b/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c b/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c b/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_f32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_f32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u16.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u64.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u8.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_f32.c	2010-01-25 09:50:29.465686681 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_f32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_f32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_f32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_f32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_f32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_f32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u64.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_f32.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p8.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s16.c	2010-01-25 09:50:29.475686346 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_f32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_f32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_f32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_f32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_f32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_f32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u64.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_f32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p8.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s16.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s32.c	2010-01-25 09:50:29.485687478 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s64.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u64.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_f32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s64.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u64.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_f32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s64.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_f32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s64.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u64.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c	2010-01-25 09:50:29.495687004 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c b/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c b/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c b/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshls16.c b/gcc/testsuite/gcc.target/arm/neon/vRshls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshls16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshls32.c b/gcc/testsuite/gcc.target/arm/neon/vRshls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshls32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshls64.c b/gcc/testsuite/gcc.target/arm/neon/vRshls64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshls64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshls64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshls8.c b/gcc/testsuite/gcc.target/arm/neon/vRshls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshls8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c b/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c b/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c b/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c b/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c	2010-01-25 09:50:29.505686669 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c b/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c b/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c b/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c b/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c b/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c b/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c b/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c b/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshls16.c b/gcc/testsuite/gcc.target/arm/neon/vshls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshls16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshls32.c b/gcc/testsuite/gcc.target/arm/neon/vshls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshls32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshls64.c b/gcc/testsuite/gcc.target/arm/neon/vshls64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshls64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshls64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshls8.c b/gcc/testsuite/gcc.target/arm/neon/vshls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshls8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlu16.c b/gcc/testsuite/gcc.target/arm/neon/vshlu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlu16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlu32.c b/gcc/testsuite/gcc.target/arm/neon/vshlu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlu32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlu64.c b/gcc/testsuite/gcc.target/arm/neon/vshlu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlu64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshlu8.c b/gcc/testsuite/gcc.target/arm/neon/vshlu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshlu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlu8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c	2010-01-25 09:50:29.515686194 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c b/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c b/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c b/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c b/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1f32.c b/gcc/testsuite/gcc.target/arm/neon/vst1f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1f32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c	2010-01-25 09:50:29.525687396 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1p16.c b/gcc/testsuite/gcc.target/arm/neon/vst1p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1p16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1p8.c b/gcc/testsuite/gcc.target/arm/neon/vst1p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1p8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1s16.c b/gcc/testsuite/gcc.target/arm/neon/vst1s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1s16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1s32.c b/gcc/testsuite/gcc.target/arm/neon/vst1s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1s32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1s64.c b/gcc/testsuite/gcc.target/arm/neon/vst1s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1s64.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1s8.c b/gcc/testsuite/gcc.target/arm/neon/vst1s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1s8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1u16.c b/gcc/testsuite/gcc.target/arm/neon/vst1u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1u16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1u32.c b/gcc/testsuite/gcc.target/arm/neon/vst1u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1u32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1u64.c b/gcc/testsuite/gcc.target/arm/neon/vst1u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1u64.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst1u8.c b/gcc/testsuite/gcc.target/arm/neon/vst1u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst1u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1u8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2f32.c b/gcc/testsuite/gcc.target/arm/neon/vst2f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2f32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2p16.c b/gcc/testsuite/gcc.target/arm/neon/vst2p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2p16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2p8.c b/gcc/testsuite/gcc.target/arm/neon/vst2p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2p8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2s16.c b/gcc/testsuite/gcc.target/arm/neon/vst2s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2s16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2s32.c b/gcc/testsuite/gcc.target/arm/neon/vst2s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2s32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2s64.c b/gcc/testsuite/gcc.target/arm/neon/vst2s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2s64.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2s8.c b/gcc/testsuite/gcc.target/arm/neon/vst2s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2s8.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2u16.c b/gcc/testsuite/gcc.target/arm/neon/vst2u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2u16.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2u32.c b/gcc/testsuite/gcc.target/arm/neon/vst2u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2u32.c	2010-01-25 09:50:29.535686781 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2u64.c b/gcc/testsuite/gcc.target/arm/neon/vst2u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2u64.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst2u8.c b/gcc/testsuite/gcc.target/arm/neon/vst2u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst2u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2u8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3f32.c b/gcc/testsuite/gcc.target/arm/neon/vst3f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3f32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3p16.c b/gcc/testsuite/gcc.target/arm/neon/vst3p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3p16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3p8.c b/gcc/testsuite/gcc.target/arm/neon/vst3p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3p8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3s16.c b/gcc/testsuite/gcc.target/arm/neon/vst3s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3s16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3s32.c b/gcc/testsuite/gcc.target/arm/neon/vst3s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3s32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3s64.c b/gcc/testsuite/gcc.target/arm/neon/vst3s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3s64.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3s8.c b/gcc/testsuite/gcc.target/arm/neon/vst3s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3s8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3u16.c b/gcc/testsuite/gcc.target/arm/neon/vst3u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3u16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3u32.c b/gcc/testsuite/gcc.target/arm/neon/vst3u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3u32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3u64.c b/gcc/testsuite/gcc.target/arm/neon/vst3u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3u64.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst3u8.c b/gcc/testsuite/gcc.target/arm/neon/vst3u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst3u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3u8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4f32.c b/gcc/testsuite/gcc.target/arm/neon/vst4f32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4f32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4f32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4p16.c b/gcc/testsuite/gcc.target/arm/neon/vst4p16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4p16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4p16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4p8.c b/gcc/testsuite/gcc.target/arm/neon/vst4p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4p8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4s16.c b/gcc/testsuite/gcc.target/arm/neon/vst4s16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4s16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4s16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4s32.c b/gcc/testsuite/gcc.target/arm/neon/vst4s32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4s32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4s32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4s64.c b/gcc/testsuite/gcc.target/arm/neon/vst4s64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4s64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4s64.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4s8.c b/gcc/testsuite/gcc.target/arm/neon/vst4s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4s8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4u16.c b/gcc/testsuite/gcc.target/arm/neon/vst4u16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4u16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4u16.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4u32.c b/gcc/testsuite/gcc.target/arm/neon/vst4u32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4u32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4u32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4u64.c b/gcc/testsuite/gcc.target/arm/neon/vst4u64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4u64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4u64.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vst4u8.c b/gcc/testsuite/gcc.target/arm/neon/vst4u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vst4u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4u8.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubf32.c b/gcc/testsuite/gcc.target/arm/neon/vsubf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubf32.c	2010-01-25 09:50:29.545686586 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c b/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c b/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c b/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c b/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c b/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c b/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubls16.c b/gcc/testsuite/gcc.target/arm/neon/vsubls16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubls16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubls16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubls32.c b/gcc/testsuite/gcc.target/arm/neon/vsubls32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubls32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubls32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubls8.c b/gcc/testsuite/gcc.target/arm/neon/vsubls8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubls8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubls8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsublu16.c b/gcc/testsuite/gcc.target/arm/neon/vsublu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsublu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsublu16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsublu32.c b/gcc/testsuite/gcc.target/arm/neon/vsublu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsublu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsublu32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsublu8.c b/gcc/testsuite/gcc.target/arm/neon/vsublu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsublu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsublu8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c b/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c b/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c b/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c b/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c b/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c b/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c b/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c b/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c b/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubs16.c b/gcc/testsuite/gcc.target/arm/neon/vsubs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubs16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubs32.c b/gcc/testsuite/gcc.target/arm/neon/vsubs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubs32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubs64.c b/gcc/testsuite/gcc.target/arm/neon/vsubs64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubs64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubs64.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubs8.c b/gcc/testsuite/gcc.target/arm/neon/vsubs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubs8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubu16.c b/gcc/testsuite/gcc.target/arm/neon/vsubu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubu16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubu32.c b/gcc/testsuite/gcc.target/arm/neon/vsubu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubu32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubu64.c b/gcc/testsuite/gcc.target/arm/neon/vsubu64.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubu64.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubu64.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubu8.c b/gcc/testsuite/gcc.target/arm/neon/vsubu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubu8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubws16.c b/gcc/testsuite/gcc.target/arm/neon/vsubws16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubws16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubws16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubws32.c b/gcc/testsuite/gcc.target/arm/neon/vsubws32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubws32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubws32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubws8.c b/gcc/testsuite/gcc.target/arm/neon/vsubws8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubws8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubws8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c b/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c b/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c b/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c b/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c b/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c b/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c	2010-01-25 09:50:29.555686949 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrns16.c b/gcc/testsuite/gcc.target/arm/neon/vtrns16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrns16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrns16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrns32.c b/gcc/testsuite/gcc.target/arm/neon/vtrns32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrns32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrns32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrns8.c b/gcc/testsuite/gcc.target/arm/neon/vtrns8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrns8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrns8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c b/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c b/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c b/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtstp8.c b/gcc/testsuite/gcc.target/arm/neon/vtstp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtstp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstp8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c b/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c b/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c b/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c b/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c b/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c b/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c b/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtsts16.c b/gcc/testsuite/gcc.target/arm/neon/vtsts16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtsts16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtsts16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtsts32.c b/gcc/testsuite/gcc.target/arm/neon/vtsts32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtsts32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtsts32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtsts8.c b/gcc/testsuite/gcc.target/arm/neon/vtsts8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtsts8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtsts8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtstu16.c b/gcc/testsuite/gcc.target/arm/neon/vtstu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtstu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstu16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtstu32.c b/gcc/testsuite/gcc.target/arm/neon/vtstu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtstu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstu32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vtstu8.c b/gcc/testsuite/gcc.target/arm/neon/vtstu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vtstu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstu8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c b/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c b/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c b/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzps16.c b/gcc/testsuite/gcc.target/arm/neon/vuzps16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzps16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzps16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzps32.c b/gcc/testsuite/gcc.target/arm/neon/vuzps32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzps32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzps32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzps8.c b/gcc/testsuite/gcc.target/arm/neon/vuzps8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzps8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzps8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c b/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c b/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c b/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipf32.c b/gcc/testsuite/gcc.target/arm/neon/vzipf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipf32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipp16.c b/gcc/testsuite/gcc.target/arm/neon/vzipp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipp16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipp8.c b/gcc/testsuite/gcc.target/arm/neon/vzipp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipp8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c b/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c b/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c b/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c b/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c b/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c b/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c b/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c b/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c b/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzips16.c b/gcc/testsuite/gcc.target/arm/neon/vzips16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzips16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzips16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzips32.c b/gcc/testsuite/gcc.target/arm/neon/vzips32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzips32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzips32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzips8.c b/gcc/testsuite/gcc.target/arm/neon/vzips8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzips8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzips8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipu16.c b/gcc/testsuite/gcc.target/arm/neon/vzipu16.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipu16.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipu16.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipu32.c b/gcc/testsuite/gcc.target/arm/neon/vzipu32.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipu32.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipu32.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon/vzipu8.c b/gcc/testsuite/gcc.target/arm/neon/vzipu8.c
--- a/gcc/testsuite/gcc.target/arm/neon/vzipu8.c	2007-07-25 14:28:31.000000000 +0200
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipu8.c	2010-01-25 09:50:29.565686614 +0100
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff -Nur a/gcc/testsuite/gcc.target/arm/neon-cond-1.c b/gcc/testsuite/gcc.target/arm/neon-cond-1.c
--- a/gcc/testsuite/gcc.target/arm/neon-cond-1.c	2009-01-27 17:14:13.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/neon-cond-1.c	2010-01-25 09:50:29.565686614 +0100
@@ -1,6 +1,7 @@
 /* { dg-do run } */
 /* { dg-require-effective-target arm_neon_hw } */
-/* { dg-options "-O2 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
 /* Check that the arm_final_prescan_insn ccfsm code does not try to
  * conditionally execute NEON instructions.  */
 #include <arm_neon.h>
diff -Nur a/gcc/testsuite/gcc.target/arm/neon-modes-1.c b/gcc/testsuite/gcc.target/arm/neon-modes-1.c
--- a/gcc/testsuite/gcc.target/arm/neon-modes-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/neon-modes-1.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O1" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+void neon_internal_error(int *dst, int *src)
+{
+  uint16x8x4_t sval;
+
+  sval = vld4q_u16((void *)src);
+  vst4q_u16((void *)dst,sval);
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/neon-vmla-1.c b/gcc/testsuite/gcc.target/arm/neon-vmla-1.c
--- a/gcc/testsuite/gcc.target/arm/neon-vmla-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/neon-vmla-1.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,11 @@
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O2 -ftree-vectorize" } */
+/* { dg-add-options arm_neon } */
+/* { dg-final { scan-assembler "vmla\\.f32" } } */
+
+/* Verify that VMLA is used.  */
+void f1(int n, float a, float x[], float y[]) {
+  int i;
+  for (i = 0; i < n; ++i)
+    y[i] = a * x[i] + y[i];
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/neon-vmls-1.c b/gcc/testsuite/gcc.target/arm/neon-vmls-1.c
--- a/gcc/testsuite/gcc.target/arm/neon-vmls-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/neon-vmls-1.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,11 @@
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O2 -ftree-vectorize" } */
+/* { dg-add-options arm_neon } */
+/* { dg-final { scan-assembler "vmls\\.f32" } } */
+
+/* Verify that VMLS is used.  */
+void f1(int n, float a, float x[], float y[]) {
+  int i;
+  for (i = 0; i < n; ++i)
+    y[i] = y[i] - a * x[i];
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/pr40482.c b/gcc/testsuite/gcc.target/arm/pr40482.c
--- a/gcc/testsuite/gcc.target/arm/pr40482.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/pr40482.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,7 @@
+/* { dg-options "-mthumb -Os" }  */
+/* { dg-final { scan-assembler-not "ldr" } } */
+
+unsigned int foo (unsigned int i )
+{
+  return i | 0xff000000;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/thumb2-mul-space-2.c b/gcc/testsuite/gcc.target/arm/thumb2-mul-space-2.c
--- a/gcc/testsuite/gcc.target/arm/thumb2-mul-space-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/thumb2-mul-space-2.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,15 @@
+/* In Thumb-2 mode, when optimizing for size, generate a "muls"
+   instruction and use the resulting condition flags rather than a
+   separate compare instruction.  */
+/* { dg-options "-mthumb -Os" }  */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-final { scan-assembler "muls" } } */
+/* { dg-final { scan-assembler-not "cmp" } } */
+
+int x;
+
+void f(int i, int j)
+{
+  if (i * j < 0)
+    x = 1;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/thumb2-mul-space-3.c b/gcc/testsuite/gcc.target/arm/thumb2-mul-space-3.c
--- a/gcc/testsuite/gcc.target/arm/thumb2-mul-space-3.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/thumb2-mul-space-3.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,17 @@
+/* In Thumb-2 mode, when optimizing for size, generate a "muls"
+   instruction and use the resulting condition flags rather than a
+   separate compare instruction.  */
+/* { dg-options "-mthumb -Os" }  */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-final { scan-assembler "muls" } } */
+/* { dg-final { scan-assembler-not "cmp" } } */
+
+int x;
+
+int f(int i, int j)
+{
+  i = i * j;
+  if (i < 0)
+    x = 1;
+  return i;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/thumb2-mul-space.c b/gcc/testsuite/gcc.target/arm/thumb2-mul-space.c
--- a/gcc/testsuite/gcc.target/arm/thumb2-mul-space.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/thumb2-mul-space.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,10 @@
+/* Use 16-bit multiply instruction in Thumb-2 mode when optimizing for
+   size.  */
+/* { dg-options "-mthumb -Os" }  */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-final { scan-assembler "muls" } } */
+
+int f(int i, int j) 
+{
+  return i * j;
+}
diff -Nur a/gcc/testsuite/gcc.target/arm/thumb2-mul-speed.c b/gcc/testsuite/gcc.target/arm/thumb2-mul-speed.c
--- a/gcc/testsuite/gcc.target/arm/thumb2-mul-speed.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/thumb2-mul-speed.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,27 @@
+/* Do not use 16-bit multiply instructions in Thumb-2 mode when
+   optimizing for speed.  */
+/* { dg-options "-mthumb -O2" }  */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-final { scan-assembler-not "muls" } } */
+
+int f(int i, int j) 
+{
+  return i * j;
+}
+
+int x;
+
+void g(int i, int j)
+{
+  if (i * j < 0)
+    x = 1;
+}
+
+int h(int i, int j)
+{
+  i = i * j;
+  if (i < 0)
+    x = 1;
+  return i;
+}
+
diff -Nur a/gcc/testsuite/gcc.target/arm/vfp-ldmdbd.c b/gcc/testsuite/gcc.target/arm/vfp-ldmdbd.c
--- a/gcc/testsuite/gcc.target/arm/vfp-ldmdbd.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/vfp-ldmdbd.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+extern void bar (double);
+
+void
+foo (double *p, double a, int n)
+{
+  do
+    bar (*--p + a);
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fldmdbd" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/vfp-ldmdbs.c b/gcc/testsuite/gcc.target/arm/vfp-ldmdbs.c
--- a/gcc/testsuite/gcc.target/arm/vfp-ldmdbs.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/vfp-ldmdbs.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+extern void baz (float);
+
+void
+foo (float *p, float a, int n)
+{
+  do
+    bar (*--p + a);
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fldmdbs" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/vfp-ldmiad.c b/gcc/testsuite/gcc.target/arm/vfp-ldmiad.c
--- a/gcc/testsuite/gcc.target/arm/vfp-ldmiad.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/vfp-ldmiad.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+extern void bar (double);
+
+void
+foo (double *p, double a, int n)
+{
+  do
+    bar (*p++ + a);
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fldmiad" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/vfp-ldmias.c b/gcc/testsuite/gcc.target/arm/vfp-ldmias.c
--- a/gcc/testsuite/gcc.target/arm/vfp-ldmias.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/vfp-ldmias.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+extern void baz (float);
+
+void
+foo (float *p, float a, int n)
+{
+  do
+    bar (*p++ + a);
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fldmias" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/vfp-stmdbd.c b/gcc/testsuite/gcc.target/arm/vfp-stmdbd.c
--- a/gcc/testsuite/gcc.target/arm/vfp-stmdbd.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/vfp-stmdbd.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+void
+foo (double *p, double a, double b, int n)
+{
+  double c = a + b;
+  do
+    *--p = c;
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fstmdbd" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/vfp-stmdbs.c b/gcc/testsuite/gcc.target/arm/vfp-stmdbs.c
--- a/gcc/testsuite/gcc.target/arm/vfp-stmdbs.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/vfp-stmdbs.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+void
+foo (float *p, float a, float b, int n)
+{
+  float c = a + b;
+  do
+    *--p = c;
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fstmdbs" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/vfp-stmiad.c b/gcc/testsuite/gcc.target/arm/vfp-stmiad.c
--- a/gcc/testsuite/gcc.target/arm/vfp-stmiad.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/vfp-stmiad.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+void
+foo (double *p, double a, double b, int n)
+{
+  double c = a + b;
+  do
+    *p++ = c;
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fstmiad" } } */
diff -Nur a/gcc/testsuite/gcc.target/arm/vfp-stmias.c b/gcc/testsuite/gcc.target/arm/vfp-stmias.c
--- a/gcc/testsuite/gcc.target/arm/vfp-stmias.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/arm/vfp-stmias.c	2010-01-25 09:50:29.565686614 +0100
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+void
+foo (float *p, float a, float b, int n)
+{
+  float c = a + b;
+  do
+    *p++ = c;
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fstmias" } } */
diff -Nur a/gcc/testsuite/gcc.target/i386/387-1.c b/gcc/testsuite/gcc.target/i386/387-1.c
--- a/gcc/testsuite/gcc.target/i386/387-1.c	2007-08-22 11:59:14.000000000 +0200
+++ b/gcc/testsuite/gcc.target/i386/387-1.c	2010-01-25 09:50:29.565686614 +0100
@@ -1,6 +1,7 @@
 /* Verify that -mno-fancy-math-387 works.  */
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-O -ffast-math -mfpmath=387 -mno-fancy-math-387 -march=i386" } */
 /* { dg-final { scan-assembler "call\t(.*)sin" } } */
 /* { dg-final { scan-assembler "call\t(.*)cos" } } */
diff -Nur a/gcc/testsuite/gcc.target/i386/387-5.c b/gcc/testsuite/gcc.target/i386/387-5.c
--- a/gcc/testsuite/gcc.target/i386/387-5.c	2007-08-22 11:59:14.000000000 +0200
+++ b/gcc/testsuite/gcc.target/i386/387-5.c	2010-01-25 09:50:29.565686614 +0100
@@ -1,6 +1,7 @@
 /* Verify that -mno-fancy-math-387 works.  */
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-O -ffast-math -mfpmath=387 -mno-fancy-math-387 -march=i386" } */
 /* { dg-final { scan-assembler "call\t(.*)atan" } } */
 /* { dg-final { scan-assembler "call\t(.*)log1p" } } */
diff -Nur a/gcc/testsuite/gcc.target/i386/cmov7.c b/gcc/testsuite/gcc.target/i386/cmov7.c
--- a/gcc/testsuite/gcc.target/i386/cmov7.c	2008-01-10 19:31:43.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/cmov7.c	2010-01-25 09:50:29.565686614 +0100
@@ -1,6 +1,7 @@
 /* PR middle-end/33187 */
 
 /* { dg-do compile } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=k8" } } */
 /* { dg-options "-O2 -ffast-math -march=k8 -mbranch-cost=5 -mfpmath=387" } */
 /* { dg-final { scan-assembler "fcmov" } } */
 
diff -Nur a/gcc/testsuite/gcc.target/i386/funcspec-1.c b/gcc/testsuite/gcc.target/i386/funcspec-1.c
--- a/gcc/testsuite/gcc.target/i386/funcspec-1.c	2008-08-31 01:50:40.000000000 +0200
+++ b/gcc/testsuite/gcc.target/i386/funcspec-1.c	2010-01-25 09:50:29.575686558 +0100
@@ -3,6 +3,7 @@
    for a function that doesn't use attribute((option)).  */
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-O3 -ftree-vectorize -march=i386" } */
 /* { dg-final { scan-assembler "addps\[ \t\]" } } */
 /* { dg-final { scan-assembler "fsubs\[ \t\]" } } */
diff -Nur a/gcc/testsuite/gcc.target/i386/funcspec-8.c b/gcc/testsuite/gcc.target/i386/funcspec-8.c
--- a/gcc/testsuite/gcc.target/i386/funcspec-8.c	2008-08-31 01:50:40.000000000 +0200
+++ b/gcc/testsuite/gcc.target/i386/funcspec-8.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,6 +1,7 @@
 /* Test whether using target specific options, we can use the x86 builtin
    functions in functions with the appropriate function specific options.  */
 /* { dg-do compile } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=k8" } } */
 /* { dg-options "-O2 -march=k8 -mfpmath=sse" } */
 
 typedef float     __m128  __attribute__ ((__vector_size__ (16), __may_alias__));
diff -Nur a/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-1.c b/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-1.c
--- a/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-1.c	2007-08-22 11:59:14.000000000 +0200
+++ b/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-1.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,5 +1,6 @@
 /* { dg-do preprocess } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-march=i386" } */
 
 #ifdef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1
diff -Nur a/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-2.c b/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-2.c
--- a/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-2.c	2007-08-22 11:59:14.000000000 +0200
+++ b/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-2.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,5 +1,6 @@
 /* { dg-do preprocess } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i486" } } */
 /* { dg-options "-march=i486" } */
 
 #ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1
diff -Nur a/gcc/testsuite/gcc.target/i386/isa-10.c b/gcc/testsuite/gcc.target/i386/isa-10.c
--- a/gcc/testsuite/gcc.target/i386/isa-10.c	2008-03-08 23:33:54.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/isa-10.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=x86-64" } } */
 /* { dg-options "-march=x86-64 -msse5 -mno-sse4" } */
 
 extern void abort (void);
diff -Nur a/gcc/testsuite/gcc.target/i386/isa-6.c b/gcc/testsuite/gcc.target/i386/isa-6.c
--- a/gcc/testsuite/gcc.target/i386/isa-6.c	2008-02-19 02:21:03.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/isa-6.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=amdfam10" } } */
 /* { dg-options "-march=amdfam10 -mno-sse4" } */
 
 extern void abort (void);
diff -Nur a/gcc/testsuite/gcc.target/i386/isa-7.c b/gcc/testsuite/gcc.target/i386/isa-7.c
--- a/gcc/testsuite/gcc.target/i386/isa-7.c	2008-02-19 02:21:03.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/isa-7.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=amdfam10" } } */
 /* { dg-options "-march=amdfam10 -msse5 -mno-sse4" } */
 
 extern void abort (void);
diff -Nur a/gcc/testsuite/gcc.target/i386/isa-8.c b/gcc/testsuite/gcc.target/i386/isa-8.c
--- a/gcc/testsuite/gcc.target/i386/isa-8.c	2008-02-19 02:21:03.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/isa-8.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=amdfam10" } } */
 /* { dg-options "-march=amdfam10 -msse5 -mno-sse4a" } */
 
 extern void abort (void);
diff -Nur a/gcc/testsuite/gcc.target/i386/isa-9.c b/gcc/testsuite/gcc.target/i386/isa-9.c
--- a/gcc/testsuite/gcc.target/i386/isa-9.c	2008-02-19 02:21:03.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/isa-9.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=amdfam10" } } */
 /* { dg-options "-march=amdfam10 -mno-sse5" } */
 
 extern void abort (void);
diff -Nur a/gcc/testsuite/gcc.target/i386/lea.c b/gcc/testsuite/gcc.target/i386/lea.c
--- a/gcc/testsuite/gcc.target/i386/lea.c	2007-08-22 11:59:14.000000000 +0200
+++ b/gcc/testsuite/gcc.target/i386/lea.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=pentiumpro" } } */
 /* { dg-options "-O2 -march=pentiumpro" } */
 /* { dg-final { scan-assembler "leal" } } */
 typedef struct {
diff -Nur a/gcc/testsuite/gcc.target/i386/movbe-1.c b/gcc/testsuite/gcc.target/i386/movbe-1.c
--- a/gcc/testsuite/gcc.target/i386/movbe-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/movbe-1.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mmovbe" } */
+
+extern int x;
+
+void
+foo (int i)
+{
+  x = __builtin_bswap32 (i);
+}
+
+int
+bar ()
+{
+  return __builtin_bswap32 (x);
+}
+
+/* { dg-final { scan-assembler-times "movbe\[ \t\]" 2 } } */
diff -Nur a/gcc/testsuite/gcc.target/i386/movbe-2.c b/gcc/testsuite/gcc.target/i386/movbe-2.c
--- a/gcc/testsuite/gcc.target/i386/movbe-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/movbe-2.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mmovbe" } */
+
+extern long long x;
+
+void
+foo (long long i)
+{
+  x = __builtin_bswap64 (i);
+}
+
+long long
+bar ()
+{
+  return __builtin_bswap64 (x);
+}
+
+/* { dg-final { scan-assembler-times "movbe\[ \t\]" 4 { target ilp32 } } } */
+/* { dg-final { scan-assembler-times "movbe\[ \t\]" 2 { target lp64 } } } */
diff -Nur a/gcc/testsuite/gcc.target/i386/pentium4-not-mull.c b/gcc/testsuite/gcc.target/i386/pentium4-not-mull.c
--- a/gcc/testsuite/gcc.target/i386/pentium4-not-mull.c	2007-08-22 11:59:14.000000000 +0200
+++ b/gcc/testsuite/gcc.target/i386/pentium4-not-mull.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=pentium4" } } */
 /* { dg-options "-O2 -march=pentium4" } */
 /* { dg-final { scan-assembler-not "imull" } } */
 
diff -Nur a/gcc/testsuite/gcc.target/i386/pr37216.c b/gcc/testsuite/gcc.target/i386/pr37216.c
--- a/gcc/testsuite/gcc.target/i386/pr37216.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/pr37216.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,17 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -msse2" } */
+/* { dg-options "-O3 -msse2 -mpe-aligned-commons" { target pe_aligned_commons } } */
+
+#include "sse2-check.h"
+
+int iarr[64];
+int iint = 0;
+
+void
+sse2_test (void)
+{
+  int i;
+
+  for (i = 0; i < 64; i++)
+    iarr[i] = -2;
+}
diff -Nur a/gcc/testsuite/gcc.target/i386/pr37843-1.c b/gcc/testsuite/gcc.target/i386/pr37843-1.c
--- a/gcc/testsuite/gcc.target/i386/pr37843-1.c	2008-11-28 17:30:56.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/pr37843-1.c	2010-01-25 09:50:29.575686558 +0100
@@ -2,8 +2,8 @@
 /* { dg-do compile { target nonpic } } */
 /* { dg-options "-O2 -mpreferred-stack-boundary=6 -mincoming-stack-boundary=5" } */
 /* { dg-final { scan-assembler "and\[lq\]?\[\\t \]*\\$-64,\[\\t \]*%\[re\]?sp" } } */
-/* { dg-final { scan-assembler "call\[\\t \]*foo" } } */
-/* { dg-final { scan-assembler-not "jmp\[\\t \]*foo" } } */
+/* { dg-final { scan-assembler "call\[\\t \]*_?foo" } } */
+/* { dg-final { scan-assembler-not "jmp\[\\t \]*_?foo" } } */
 
 extern int foo (void);
 
diff -Nur a/gcc/testsuite/gcc.target/i386/pr37843-2.c b/gcc/testsuite/gcc.target/i386/pr37843-2.c
--- a/gcc/testsuite/gcc.target/i386/pr37843-2.c	2008-11-28 17:30:56.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/pr37843-2.c	2010-01-25 09:50:29.575686558 +0100
@@ -2,8 +2,8 @@
 /* { dg-do compile { target nonpic } } */
 /* { dg-options "-O2 -mpreferred-stack-boundary=6 -mincoming-stack-boundary=6" } */
 /* { dg-final { scan-assembler-not "and\[lq\]?\[\\t \]*\\$-64,\[\\t \]*%\[re\]?sp" } } */
-/* { dg-final { scan-assembler-not "call\[\\t \]*foo" } } */
-/* { dg-final { scan-assembler "jmp\[\\t \]*foo" } } */
+/* { dg-final { scan-assembler-not "call\[\\t \]*_?foo" } } */
+/* { dg-final { scan-assembler "jmp\[\\t \]*_?foo" } } */
 
 extern int foo (void);
 
diff -Nur a/gcc/testsuite/gcc.target/i386/pr37843-3.c b/gcc/testsuite/gcc.target/i386/pr37843-3.c
--- a/gcc/testsuite/gcc.target/i386/pr37843-3.c	2009-01-15 16:44:41.000000000 +0100
+++ b/gcc/testsuite/gcc.target/i386/pr37843-3.c	2010-01-25 09:50:29.575686558 +0100
@@ -2,8 +2,8 @@
 /* { dg-do compile { target { ilp32 && nonpic } } } */
 /* { dg-options "-O2 -msse2 -mpreferred-stack-boundary=4 -mstackrealign" } */
 /* { dg-final { scan-assembler-not "andl\[\\t \]*\\$-16,\[\\t \]*%\[re\]?sp" } } */
-/* { dg-final { scan-assembler-not "call\[\\t \]*foo" } } */
-/* { dg-final { scan-assembler "jmp\[\\t \]*foo" } } */
+/* { dg-final { scan-assembler-not "call\[\\t \]*_?foo" } } */
+/* { dg-final { scan-assembler "jmp\[\\t \]*_?foo" } } */
 
 #include <emmintrin.h>
 
diff -Nur a/gcc/testsuite/gcc.target/i386/sse-5.c b/gcc/testsuite/gcc.target/i386/sse-5.c
--- a/gcc/testsuite/gcc.target/i386/sse-5.c	2008-09-09 16:48:15.000000000 +0200
+++ b/gcc/testsuite/gcc.target/i386/sse-5.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-Winline -O2 -march=i386" } */
 
 typedef double v2df __attribute__ ((vector_size (16)));
diff -Nur a/gcc/testsuite/gcc.target/i386/ssefn-1.c b/gcc/testsuite/gcc.target/i386/ssefn-1.c
--- a/gcc/testsuite/gcc.target/i386/ssefn-1.c	2007-08-22 11:59:14.000000000 +0200
+++ b/gcc/testsuite/gcc.target/i386/ssefn-1.c	2010-01-25 09:50:29.575686558 +0100
@@ -7,6 +7,7 @@
 /* { dg-final { scan-assembler "mulss" } } */
 /* { dg-final { scan-assembler-not "movsd" } } */
 /* { dg-final { scan-assembler-not "mulsd" } } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-O2 -march=i386 -msse -mfpmath=sse -fno-inline" } */
 
 static float xs (void)
diff -Nur a/gcc/testsuite/gcc.target/m68k/20090709-1.c b/gcc/testsuite/gcc.target/m68k/20090709-1.c
--- a/gcc/testsuite/gcc.target/m68k/20090709-1.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/20090709-1.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* There should be 3 occurrences of .LC0 in the code:
+   one for the definition of "0",
+   one for use in test1() and
+   one for use in test2().
+   FIXME: At the moment m68k GCC does not optimize test1() to nop
+   for some reason.  */
+/* { dg-final { scan-assembler-times ".LC0" 3 } } */
+
+void dummy(char *arg);
+
+void test1(void)
+{
+  char tmp[2] = "0";
+}
+
+void test2(void)
+{
+  dummy("0");
+}
diff -Nur a/gcc/testsuite/gcc.target/m68k/pr36134.c b/gcc/testsuite/gcc.target/m68k/pr36134.c
--- a/gcc/testsuite/gcc.target/m68k/pr36134.c	2008-11-14 11:49:06.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/pr36134.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,10 +1,15 @@
 /* pr36134.c
 
    This test ensures that the shorter LEA instruction is used in preference
-   to the longer ADD instruction.  */
+   to the longer ADD instruction.
+
+   This preference is applicable to ColdFire only.  On CPU32, we can
+   use a sequence of two ADDQ instructions, which is faster than the
+   LEA instruction.  */
 
 /* { dg-do compile }  */
-/* { dg-options "-O2" }  */
+/* { dg-skip-if "" { *-*-* } { "-mcpu=*" } { "-mcpu=5208" } } */
+/* { dg-options "-O2 -mcpu=5208" }  */
 /* { dg-final { scan-assembler "lea" } } */
 /* { dg-final { scan-assembler-not "add" } } */
 
diff -Nur a/gcc/testsuite/gcc.target/m68k/tls-gd.c b/gcc/testsuite/gcc.target/m68k/tls-gd.c
--- a/gcc/testsuite/gcc.target/m68k/tls-gd.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/tls-gd.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic" } */
+/* { dg-final { scan-assembler "foo@TLSGD\\(\%a5\\)" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+
+extern int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff -Nur a/gcc/testsuite/gcc.target/m68k/tls-gd-xgot.c b/gcc/testsuite/gcc.target/m68k/tls-gd-xgot.c
--- a/gcc/testsuite/gcc.target/m68k/tls-gd-xgot.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/tls-gd-xgot.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic -mxgot" } */
+/* { dg-final { scan-assembler "#foo@TLSGD,\%\[ad\]\[0-7\]" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+
+extern int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff -Nur a/gcc/testsuite/gcc.target/m68k/tls-ie.c b/gcc/testsuite/gcc.target/m68k/tls-ie.c
--- a/gcc/testsuite/gcc.target/m68k/tls-ie.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/tls-ie.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler "jsr __m68k_read_tp" } } */
+/* { dg-final { scan-assembler "foo@TLSIE\\(\%a5\\)" } } */
+
+extern int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff -Nur a/gcc/testsuite/gcc.target/m68k/tls-ie-xgot.c b/gcc/testsuite/gcc.target/m68k/tls-ie-xgot.c
--- a/gcc/testsuite/gcc.target/m68k/tls-ie-xgot.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/tls-ie-xgot.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -mxgot" } */
+/* { dg-final { scan-assembler "jsr __m68k_read_tp" } } */
+/* { dg-final { scan-assembler "#foo@TLSIE,\%\[ad\]\[0-7\]" } } */
+
+extern int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff -Nur a/gcc/testsuite/gcc.target/m68k/tls-ld.c b/gcc/testsuite/gcc.target/m68k/tls-ld.c
--- a/gcc/testsuite/gcc.target/m68k/tls-ld.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/tls-ld.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic" } */
+/* { dg-final { scan-assembler "foo@TLSLDM\\(\%a5\\)" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+/* { dg-final { scan-assembler "lea \\(foo@TLSLDO,\%a0\\)" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff -Nur a/gcc/testsuite/gcc.target/m68k/tls-ld-xgot.c b/gcc/testsuite/gcc.target/m68k/tls-ld-xgot.c
--- a/gcc/testsuite/gcc.target/m68k/tls-ld-xgot.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/tls-ld-xgot.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic -mxgot" } */
+/* { dg-final { scan-assembler "#foo@TLSLDM,\%\[ad\]\[0-7\]" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+/* { dg-final { scan-assembler "lea \\(foo@TLSLDO,\%a0\\)" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff -Nur a/gcc/testsuite/gcc.target/m68k/tls-ld-xgot-xtls.c b/gcc/testsuite/gcc.target/m68k/tls-ld-xgot-xtls.c
--- a/gcc/testsuite/gcc.target/m68k/tls-ld-xgot-xtls.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/tls-ld-xgot-xtls.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic -mxgot -mxtls" } */
+/* { dg-final { scan-assembler "#foo@TLSLDM,\%\[ad\]\[0-7\]" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+/* { dg-final { scan-assembler "#foo@TLSLDO,\%\[ad\]\[0-7\]" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff -Nur a/gcc/testsuite/gcc.target/m68k/tls-ld-xtls.c b/gcc/testsuite/gcc.target/m68k/tls-ld-xtls.c
--- a/gcc/testsuite/gcc.target/m68k/tls-ld-xtls.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/tls-ld-xtls.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic -mxtls" } */
+/* { dg-final { scan-assembler "foo@TLSLDM\\(\%a5\\)" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+/* { dg-final { scan-assembler "#foo@TLSLDO,\%\[ad\]\[0-7\]" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff -Nur a/gcc/testsuite/gcc.target/m68k/tls-le.c b/gcc/testsuite/gcc.target/m68k/tls-le.c
--- a/gcc/testsuite/gcc.target/m68k/tls-le.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/tls-le.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler "jsr __m68k_read_tp" } } */
+/* { dg-final { scan-assembler "lea \\(foo@TLSLE,\%a0\\)" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff -Nur a/gcc/testsuite/gcc.target/m68k/tls-le-xtls.c b/gcc/testsuite/gcc.target/m68k/tls-le-xtls.c
--- a/gcc/testsuite/gcc.target/m68k/tls-le-xtls.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/m68k/tls-le-xtls.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -mxtls" } */
+/* { dg-final { scan-assembler "jsr __m68k_read_tp" } } */
+/* { dg-final { scan-assembler "#foo@TLSLE,\%\[ad\]\[0-7\]" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff -Nur a/gcc/testsuite/gcc.target/mips/branch-2.c b/gcc/testsuite/gcc.target/mips/branch-2.c
--- a/gcc/testsuite/gcc.target/mips/branch-2.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/mips/branch-2.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,44 @@
+/* Check that we correctly expand out-of-range branches */
+/* { dg-do run } */
+/* { dg-options "-O2 -mabi=32 -fPIC" } */
+
+#include <stdlib.h>
+
+/* This is weak so the compiler cannot assume that calls from this TU
+   necessarily arrive here.   And hence that $gp may be clobbered in
+   o32 and o64 ABIs.  */
+
+void __attribute__ ((weak)) Foo (int i)
+{
+  static int once = 0;
+
+  if (!i && once++)
+    exit (0);
+
+#if (_ABIO32 || _ABIO64)
+  /* Clobber $gp */
+  __asm volatile ("li $gp,0");
+#endif
+}
+
+#define N1(X)  (Foo (X))
+#define N2(X)  (N1 (X), N1 (X+(1<<0)))
+#define N3(X)  (N2 (X), N2 (X+(1<<1)))
+#define N4(X)  (N3 (X), N3 (X+(1<<2)))
+#define N5(X)  (N4 (X), N4 (X+(1<<3)))
+#define N6(X)  (N5 (X), N5 (X+(1<<4)))
+#define N7(X)  (N6 (X), N6 (X+(1<<5)))
+#define N8(X)  (N7 (X), N7 (X+(1<<6)))
+#define N9(X)  (N8 (X), N8 (X+(1<<7)))
+#define N10(X)  (N9 (X), N9 (X+(1<<8)))
+#define N11(X)  (N10 (X), N10 (X+(1<<9)))
+#define N12(X)  (N11 (X), N11 (X+(1<<10)))
+#define N13(X)  (N12 (X), N12 (X+(1<<11)))
+#define N14(X)  (N13 (X), N13 (X+(1<<12)))
+
+int main (void)
+{
+  while (1)
+    N14 (0);
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/mips/clear-cache-2.c b/gcc/testsuite/gcc.target/mips/clear-cache-2.c
--- a/gcc/testsuite/gcc.target/mips/clear-cache-2.c	2008-12-21 22:47:38.000000000 +0100
+++ b/gcc/testsuite/gcc.target/mips/clear-cache-2.c	2010-01-25 09:50:29.575686558 +0100
@@ -2,7 +2,8 @@
 /* { dg-options "-O2 -mips32" } */
 /* { dg-final { scan-assembler-not "synci" } } */
 /* { dg-final { scan-assembler-not "jr.hb" } } */
-/* { dg-final { scan-assembler "_flush_cache" } } */
+/* { dg-final { scan-assembler "mips_sync_icache" { target { *-sde-* } } } } */
+/* { dg-final { scan-assembler "_flush_cache" { target { ! *-sde-* } } } } */
 
 void f()
 {
diff -Nur a/gcc/testsuite/gcc.target/mips/fpr-moves-5.c b/gcc/testsuite/gcc.target/mips/fpr-moves-5.c
--- a/gcc/testsuite/gcc.target/mips/fpr-moves-5.c	2008-12-21 22:47:38.000000000 +0100
+++ b/gcc/testsuite/gcc.target/mips/fpr-moves-5.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,4 +1,5 @@
 /* { dg-options "-mabi=64 -mhard-float -O2 -EL" } */
+/* { dg-require-effective-target mips_newabi_large_long_double } */
 
 NOMIPS16 void
 foo (long double d, long double *x)
diff -Nur a/gcc/testsuite/gcc.target/mips/fpr-moves-6.c b/gcc/testsuite/gcc.target/mips/fpr-moves-6.c
--- a/gcc/testsuite/gcc.target/mips/fpr-moves-6.c	2008-12-21 22:47:38.000000000 +0100
+++ b/gcc/testsuite/gcc.target/mips/fpr-moves-6.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,4 +1,5 @@
 /* { dg-options "-mabi=64 -mhard-float -O2 -EB" } */
+/* { dg-require-effective-target mips_newabi_large_long_double } */
 
 NOMIPS16 void
 foo (long double d, long double *x)
diff -Nur a/gcc/testsuite/gcc.target/mips/mips.exp b/gcc/testsuite/gcc.target/mips/mips.exp
--- a/gcc/testsuite/gcc.target/mips/mips.exp	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/testsuite/gcc.target/mips/mips.exp	2010-01-25 09:50:29.575686558 +0100
@@ -229,6 +229,7 @@
     gpopt
     local-sdata
     long-calls
+    octeon-useun
     paired-single
     plt
     shared
diff -Nur a/gcc/testsuite/gcc.target/mips/octeon-useun.c b/gcc/testsuite/gcc.target/mips/octeon-useun.c
--- a/gcc/testsuite/gcc.target/mips/octeon-useun.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/mips/octeon-useun.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,16 @@
+/* Check the mov_u[ls][dw] patterns.  */
+/* { dg-options "-march=octeon -O2 -mabi=64 -mocteon-useun -meb" } */
+struct __attribute__((packed)) sl { unsigned long x; };
+struct __attribute__((packed)) si { unsigned int x; };
+unsigned long f1 (struct sl *s) { return s[0].x; };
+unsigned int f2 (struct si *s) { return s[1].x; };
+void f3 (struct sl *s, unsigned long x) { s[10].x = x; }
+void f4 (struct si *s, unsigned int x) { s[11].x = x; }
+void f5 (struct sl *s) { s[100].x = 0; }
+void f6 (struct si *s) { s[101].x = 0; }
+/* { dg-final { scan-assembler "\tjr?\t\\\$31\n\tuld\t\\\$2,0\\(\\\$4\\)\n" } } */
+/* { dg-final { scan-assembler "\tulw\t\\\$2,4\\(\\\$4\\)\n" } } */
+/* { dg-final { scan-assembler "\tjr?\t\\\$31\n\tusd\t\\\$5,80\\(\\\$4\\)\n" } } */
+/* { dg-final { scan-assembler "\tjr?\t\\\$31\n\tusw\t\\\$5,44\\(\\\$4\\)\n" } } */
+/* { dg-final { scan-assembler "\tjr?\t\\\$31\n\tusd\t\\\$0,800\\(\\\$4\\)\n" } } */
+/* { dg-final { scan-assembler "\tjr?\t\\\$31\n\tusw\t\\\$0,404\\(\\\$4\\)\n" } } */
diff -Nur a/gcc/testsuite/gcc.target/powerpc/altivec-consts.c b/gcc/testsuite/gcc.target/powerpc/altivec-consts.c
--- a/gcc/testsuite/gcc.target/powerpc/altivec-consts.c	2009-01-13 18:52:32.000000000 +0100
+++ b/gcc/testsuite/gcc.target/powerpc/altivec-consts.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,7 +1,7 @@
 /* { dg-do run { target { powerpc*-*-* && vmx_hw } } } */
 /* { dg-do compile { target { powerpc*-*-* && { ! vmx_hw } } } } */
 /* { dg-require-effective-target powerpc_altivec_ok } */
-/* { dg-options "-maltivec -mabi=altivec -O2" } */
+/* { dg-options "-maltivec -O2" } */
 
 /* Check that "easy" AltiVec constants are correctly synthesized.  */
 
diff -Nur a/gcc/testsuite/gcc.target/powerpc/altivec-varargs-1.c b/gcc/testsuite/gcc.target/powerpc/altivec-varargs-1.c
--- a/gcc/testsuite/gcc.target/powerpc/altivec-varargs-1.c	2009-01-13 18:52:32.000000000 +0100
+++ b/gcc/testsuite/gcc.target/powerpc/altivec-varargs-1.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,7 +1,7 @@
 /* { dg-do run { target { powerpc*-*-* && vmx_hw } } } */
 /* { dg-do compile { target { powerpc*-*-* && { ! vmx_hw } } } } */
 /* { dg-require-effective-target powerpc_altivec_ok } */
-/* { dg-options "-maltivec -mabi=altivec -fno-inline" } */
+/* { dg-options "-maltivec -fno-inline" } */
 
 #include <stdarg.h>
 
diff -Nur a/gcc/testsuite/gcc.target/sh/20080410-1.c b/gcc/testsuite/gcc.target/sh/20080410-1.c
--- a/gcc/testsuite/gcc.target/sh/20080410-1.c	2008-09-13 15:26:46.000000000 +0200
+++ b/gcc/testsuite/gcc.target/sh/20080410-1.c	2010-01-25 09:50:29.575686558 +0100
@@ -1,5 +1,5 @@
 /* { dg-do compile { target "sh-*-*" } } */
-/* { dg-options "-O0 -m4 -ml -fira" } */
+/* { dg-options "-O0 -m4 -ml" } */
 /* { dg-final { scan-assembler-not "add\tr0,r0" } } */
 
 /* This test checks that chain reloads conflict.  I they don't
diff -Nur a/gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c b/gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c
--- a/gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c	2007-08-27 10:47:33.000000000 +0200
+++ b/gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c	2010-01-25 09:50:29.575686558 +0100
@@ -35,15 +35,15 @@
 }
 
 /* Aligned.  */
-struct u0 { unsigned long long d : 32; } y0;
+struct u0 { unsigned long long d : 32; } y_0;
 unsigned long long g0() {
-  return y0.d;
+  return y_0.d;
 }
 
 /* Unaligned load.  */
-struct u1 { long long c : 8; unsigned long long d : 32; } y1;
+struct u1 { long long c : 8; unsigned long long d : 32; } y_1;
 unsigned long long g1() {
-  return y1.d;
+  return y_1.d;
 }
 
 /* Unaligned load.  */
diff -Nur a/gcc/testsuite/gcc.target/sh/sh4a-memmovua.c b/gcc/testsuite/gcc.target/sh/sh4a-memmovua.c
--- a/gcc/testsuite/gcc.target/sh/sh4a-memmovua.c	2007-08-27 10:47:33.000000000 +0200
+++ b/gcc/testsuite/gcc.target/sh/sh4a-memmovua.c	2010-01-25 09:50:29.575686558 +0100
@@ -5,7 +5,7 @@
 /* { dg-final { scan-assembler-times "\tmovua\\.l\t(.*)+" 2 } } */
 
 #ifdef __SH4A__
-#include <stdlib.h>
+#include <string.h>
 
 struct s { int i; char a[10], b[10]; } x;
 int f() {
diff -Nur a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2a.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2a.c
--- a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2a.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2a.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,27 @@
+/* Test for cross x86_64<->w64 abi standard calls.  */
+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* } } */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -ffast-math -fno-builtin" } */
+/* { dg-additional-sources "func-2b.c" } */
+
+extern void __attribute__ ((sysv_abi)) abort (void);
+long double func_cross (long double, double, float, long, int, char);
+
+long double __attribute__ ((sysv_abi))
+func_native (long double a, double b, float c, long d, int e, char f)
+{
+  long double ret;
+  ret = a + (long double) b + (long double) c;
+  ret *= (long double) (d + (long) e);
+  if (f>0)
+    ret += func_native (a,b,c,d,e,-f);
+  return ret;
+}
+
+int __attribute__ ((sysv_abi))
+main ()
+{
+  if (func_cross (1.0,2.0,3.0,1,2,3)
+      != func_native (1.0,2.0,3.0,1,2,3))
+    abort ();
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2b.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2b.c
--- a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2b.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2b.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,13 @@
+/* Test for cross x86_64<->w64 abi standard calls.  */
+/* { dg-options "-mabi=ms -std=gnu99 -ffast-math -fno-builtin" } */
+
+long double func_cross (long double a, double b, float c, long d, int e,
+			char f)
+{
+  long double ret;
+  ret = a + (long double) b + (long double) c;
+  ret *= (long double) (d + (long) e);
+  if (f>0)
+    ret += func_cross (a,b,c,d,e,-f);
+  return ret;
+}
diff -Nur a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2a.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2a.c
--- a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2a.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2a.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,17 @@
+/* Test for cross x86_64<->w64 abi standard calls via variable.  */
+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* } } */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -ffast-math -fno-builtin" } */
+/* { dg-additional-sources "func-indirect-2b.c" } */
+
+extern void __attribute__ ((sysv_abi)) abort (void);
+typedef int (*func)(void *, char *, char *, short, long long);
+extern func get_callback (void);
+
+int __attribute__ ((sysv_abi))
+main ()
+{
+  func callme = get_callback ();
+  if (callme (0, 0, 0, 0x1234, 0x1234567890abcdefLL))
+    abort ();
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2b.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2b.c
--- a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2b.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2b.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,24 @@
+/* Test for cross x86_64<->w64 abi standard calls via variable.  */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -ffast-math -fno-builtin" } */
+
+typedef int (*func)(void *, char *, char *, short, long long);
+
+static int
+callback (void *ptr, char *string1, char *string2, short number,
+	  long long rand)
+{
+  if (ptr != 0
+      || string1 != 0
+      || string2 != 0
+      || number != 0x1234
+      || rand != 0x1234567890abcdefLL)
+    return 1;
+  else
+    return 0;
+}
+
+func
+get_callback (void)
+{
+  return callback;
+}
diff -Nur a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4a.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4a.c
--- a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4a.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4a.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,24 @@
+/* Test for cross x86_64<->w64 abi va_list calls.  */
+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* } } */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -fno-builtin" } */
+/* { dg-additional-sources "vaarg-4b.c" } */
+
+extern __SIZE_TYPE__ __attribute__ ((sysv_abi)) strlen (const char *);
+extern int __attribute__ ((sysv_abi)) sprintf (char *,const char *, ...);
+extern void __attribute__ ((sysv_abi)) abort (void);
+
+extern void do_cpy (char *, ...);
+
+int __attribute__ ((sysv_abi))
+main ()
+{
+  char s[256];
+
+  do_cpy (s, "1","2","3","4", "5", "6", "7", "");
+
+  if (s[0] != '1' || s[1] !='2' || s[2] != '3' || s[3] != '4'
+      || s[4] != '5' || s[5] != '6' || s[6] != '7' || s[7] != 0)
+    abort ();
+
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4b.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4b.c
--- a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4b.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4b.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,31 @@
+/* Test for cross x86_64<->w64 abi va_list calls.  */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -fno-builtin" } */
+
+#include <stdarg.h>
+
+extern __SIZE_TYPE__ __attribute__ ((sysv_abi)) strlen (const char *);
+extern int __attribute__ ((sysv_abi)) sprintf (char *, const char *, ...);
+
+static void
+vdo_cpy (char *s, va_list argp)
+{
+  __SIZE_TYPE__ len;
+  char *r = s;
+  char *e;
+  *r = 0;
+  for (;;) {
+    e = va_arg (argp, char *);
+    if (*e == 0) break;
+    sprintf (r,"%s", e);
+    r += strlen (r);
+  }
+}
+
+void
+do_cpy (char *s, ...)
+{
+  va_list argp;
+  va_start (argp, s);
+  vdo_cpy (s, argp);
+  va_end (argp);
+}
diff -Nur a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5a.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5a.c
--- a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5a.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5a.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,17 @@
+/* Test for cross x86_64<->w64 abi va_list calls.  */
+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* } } */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -fno-builtin" } */
+/* { dg-additional-sources "vaarg-5b.c" } */
+
+extern void __attribute__ ((sysv_abi)) abort (void);
+extern int fct2 (int, ...);
+
+#define SZ_ARGS	1ll,2ll,3ll,4ll,5ll,6ll,7ll,0ll
+
+int __attribute__ ((sysv_abi))
+main()
+{
+  if (fct2 (-1, SZ_ARGS) != 0)
+    abort ();
+  return 0;
+}
diff -Nur a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5b.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5b.c
--- a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5b.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5b.c	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,37 @@
+/* Test for cross x86_64<->w64 abi va_list calls.  */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -fno-builtin" } */
+
+#include <stdarg.h>
+
+#define SZ_ARGS	1ll,2ll,3ll,4ll,5ll,6ll,7ll,0ll
+
+static int __attribute__ ((sysv_abi))
+fct1 (va_list argp, ...)
+{
+  long long p1,p2;
+  int ret = 1;
+  __builtin_sysv_va_list argp_2;
+
+  __builtin_sysv_va_start (argp_2, argp);
+  do {
+    p1 = va_arg (argp_2, long long);
+    p2 = va_arg (argp, long long);
+    if (p1 != p2)
+      ret = 0;
+  } while (ret && p1 != 0);
+  __builtin_sysv_va_end (argp_2);
+
+  return ret;
+}
+
+int
+fct2 (int dummy, ...)
+{
+  va_list argp;
+  int ret = dummy;
+
+  va_start (argp, dummy);
+  ret += fct1 (argp, SZ_ARGS);
+  va_end (argp);
+  return ret;
+}
diff -Nur a/gcc/testsuite/g++.dg/abi/mangle-neon.C b/gcc/testsuite/g++.dg/abi/mangle-neon.C
--- a/gcc/testsuite/g++.dg/abi/mangle-neon.C	2008-08-30 00:19:24.000000000 +0200
+++ b/gcc/testsuite/g++.dg/abi/mangle-neon.C	2010-01-25 09:50:29.575686558 +0100
@@ -2,7 +2,7 @@
 
 // { dg-do compile }
 // { dg-require-effective-target arm_neon_ok }
-// { dg-options "-mfpu=neon -mfloat-abi=softfp" }
+// { dg-add-options arm_neon }
 
 #include <arm_neon.h>
 
diff -Nur a/gcc/testsuite/g++.dg/eh/ref1.C b/gcc/testsuite/g++.dg/eh/ref1.C
--- a/gcc/testsuite/g++.dg/eh/ref1.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/eh/ref1.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,61 @@
+// { dg-do run { xfail { ! arm-*-*eabi } } }
+
+// catching a pointer to class by reference prohibits derived->base
+// transformation.   The generic C++ ABI gets this wrong.  ARM EABI
+// gets this right, except for exception specifications where a bug is
+// acknowledged. 
+
+#include <stdio.h>
+
+struct A {};
+
+struct B : A {};
+
+int Foo ()
+{
+  B b;
+  
+  try
+    {
+      throw &b;
+    }
+  catch (A *&a)  // { dg-bogus "earlier handler" "" { xfail { ! arm-*-*eabi } } }
+    {
+      printf ("fail, caught A*&%p\n", a);
+      return 1;
+    }
+  catch (B *&b)  // { dg-bogus "will be caught" "" { xfail { ! arm-*-*eabi } } }
+    {
+      printf ("pass, caught B*&%p\n", b);
+    }
+  catch (...)
+    {
+      printf ("fail, caught ...");
+      return 2;
+    }
+  try
+    {
+      throw &b;
+    }
+  catch (A *a) // { dg-warning "by earlier handler" }
+    {
+      printf ("pass, caught A*%p\n", a);
+    }
+  catch (B *b) // { dg-warning "will be caught" }
+    {
+      printf ("fail, caught B*%p\n", b);
+      return 3;
+    }
+  catch (...)
+    {
+      printf ("fail, caught ...");
+      return 4;
+    }
+  return 0;
+}
+
+
+int main ()
+{
+  return Foo ();
+}
diff -Nur a/gcc/testsuite/g++.dg/eh/ref2.C b/gcc/testsuite/g++.dg/eh/ref2.C
--- a/gcc/testsuite/g++.dg/eh/ref2.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/eh/ref2.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,70 @@
+// { dg-do run { xfail { ! arm-*-*eabi } } }
+
+// catching a pointer to class by reference prohibits derived->base
+// transformation.   The generic C++ ABI gets this wrong.  ARM EABI
+// gets this right, except for exception specifications where a bug is
+// acknowledged. 
+
+#include <stdio.h>
+#include <exception>
+#include <stdlib.h>
+
+struct A {};
+
+struct B : A {};
+
+B b;
+
+void One () throw (A *&)
+{
+  throw &b;
+}
+
+void Two () throw (A *&, B *&)
+{
+  throw &b;
+}
+
+void Three () throw (A *)
+{
+  throw &b;
+}
+
+int Foo (void (*fn)())
+{
+  try
+    {
+      fn ();
+    }
+  catch (B *b)
+    {
+      printf ("pass, caught B*%p\n", b);
+    }
+  catch (...)
+    {
+      printf ("fail, caught ...");
+      return 1;
+    }
+  return 0;
+}
+
+void handler ()
+{
+  printf ("pass, got unexpected exception\n");
+  exit (0);
+}
+
+int main ()
+{
+  if (Foo (&Three))
+    return 1;
+
+  if (Foo (&Two))
+    return 2;
+
+  std::set_unexpected (handler);
+  if (Foo (&One))
+    return 3;
+  printf ("fail, did not get unexpected exception\n");
+  return 4;
+}
diff -Nur a/gcc/testsuite/g++.dg/ext/altivec-17.C b/gcc/testsuite/g++.dg/ext/altivec-17.C
--- a/gcc/testsuite/g++.dg/ext/altivec-17.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/altivec-17.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,16 @@
+// { dg-do compile { target powerpc*-*-* } }
+// { dg-require-effective-target powerpc_altivec_ok }
+// { dg-options "-maltivec" }
+
+// Make sure that bool vectors have distinct names to int vectors
+
+#define vector__ __attribute__((altivec (vector__)))
+#define bool__ __attribute__((altivec(bool__)))
+
+typedef vector__ unsigned int simd_type;
+typedef vector__ bool__ int bool_simd_type;
+
+void Foo (bool_simd_type const &a)
+{
+  simd_type const &v = a; // { dg-error "'const unsigned int __vector__&' from expression of type 'const __bool int __vector__'" }
+}
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-1.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-1.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-1.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-1.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+#include "arm-fp16-ops.h"
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-2.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-2.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-2.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-2.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+
+#include "arm-fp16-ops.h"
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-3.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-3.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-3.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-3.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+#include "arm-fp16-ops.h"
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-4.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-4.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-4.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-4.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=alternative -ffast-math" } */
+
+#include "arm-fp16-ops.h"
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-5.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-5.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-5.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-5.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,15 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_fp16_ok } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-add-options arm_neon_fp16 } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, including fp16 support, so
+   we should not see any calls to libfuncs here.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-6.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-6.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-6.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-6.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,15 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_fp16_ok } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+/* { dg-add-options arm_neon_fp16 } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, including fp16 support, so
+   we should not see any calls to libfuncs here.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-7.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-7.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-7.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-7.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,13 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, so we should not see any 
+   calls to libfuncs here except for those to the conversion functions.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-8.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-8.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-8.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-8.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,13 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, so we should not see any 
+   calls to libfuncs here except for those to the conversion functions.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops.h b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops.h
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops.h	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops.h	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,135 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+
+#include <assert.h>
+
+#define CHECK(e,r) assert ((e) == r)
+#define CHECK2(e,r) (assert ((e) == r), temp = (e), assert (temp == r))
+#define TEST(e) assert (e)
+#define TESTNOT(e) assert (!(e))
+
+volatile __fp16 h0 = 0.0;
+volatile __fp16 h1 = 1.0;
+volatile __fp16 h42 = 42.0;
+volatile __fp16 hm2 = -2.0;
+volatile __fp16 temp;
+
+volatile float f0 = 0.0;
+volatile float f1 = 1.0;
+volatile float f42 = 42.0;
+volatile float fm2 = -2.0;
+
+int main (void)
+{
+  TEST (h1);
+  TESTNOT (h0);
+  TEST (!h0);
+  TESTNOT (!h1);
+
+  CHECK2 (-h1, -1.0);
+  CHECK2 (+h1, 1.0);
+
+  CHECK (h1++, 1.0);
+  CHECK (h1, 2.0);
+  CHECK (++h1, 3.0);
+  CHECK (h1, 3.0);
+
+  CHECK (--h1, 2.0);
+  CHECK (h1, 2.0);
+  CHECK (h1--, 2.0);
+  CHECK (h1, 1.0);
+
+  CHECK2 (h42 * hm2, -84.0);
+  CHECK2 (h42 * (__fp16) -2.0, -84.0);
+  CHECK2 (h42 * fm2, -84.0);
+  CHECK2 (f42 * hm2, -84.0);
+
+  CHECK2 (h42 / hm2, -21.0);
+  CHECK2 (h42 / (__fp16) -2.0, -21.0);
+  CHECK2 (h42 / fm2, -21.0);
+  CHECK2 (f42 / hm2, -21.0);
+
+  CHECK2 (hm2 + h42, 40.0);
+  CHECK2 ((__fp16)-2.0 + h42, 40.0);
+  CHECK2 (hm2 + f42, 40.0);
+  CHECK2 (fm2 + h42, 40.0);
+
+  CHECK2 (hm2 - h42, -44.0);
+  CHECK2 ((__fp16)-2.0 - h42, -44.0);
+  CHECK2 (hm2 - f42, -44.0);
+  CHECK2 (fm2 - h42, -44.0);
+
+  TEST (hm2 < h42);
+  TEST (hm2 < (__fp16)42.0);
+  TEST (hm2 < f42);
+  TEST (fm2 < h42);
+
+  TEST (h42 > hm2);
+  TEST ((__fp16)42.0 > hm2);
+  TEST (h42 > fm2);
+  TEST (f42 > hm2);
+
+  TEST (hm2 <= h42);
+  TEST (hm2 <= (__fp16)42.0);
+  TEST (hm2 <= f42);
+  TEST (fm2 <= h42);
+
+  TEST (h42 >= hm2);
+  TEST (h42 >= (__fp16)-2.0);
+  TEST (h42 >= fm2);
+  TEST (f42 >= hm2);
+
+  TESTNOT (h1 == hm2);
+  TEST (h1 == h1);
+  TEST (h1 == (__fp16)1.0);
+  TEST (h1 == f1);
+  TEST (f1 == h1);
+
+  TEST (h1 != hm2);
+  TESTNOT (h1 != h1);
+  TESTNOT (h1 != (__fp16)1.0);
+  TESTNOT (h1 != f1);
+  TESTNOT (f1 != h1);
+
+  CHECK2 ((h1 ? hm2 : h42), -2.0);
+  CHECK2 ((h0 ? hm2 : h42), 42.0);
+
+  CHECK (h0 = h42, 42.0);
+  CHECK (h0, 42.0);
+  CHECK (h0 = (__fp16)-2.0, -2.0);
+  CHECK (h0, -2.0);
+  CHECK (h0 = f0, 0.0);
+  CHECK (h0, 0.0);
+
+  CHECK (h0 += h1, 1.0);
+  CHECK (h0, 1.0);
+  CHECK (h0 += (__fp16)1.0, 2.0);
+  CHECK (h0, 2.0);
+  CHECK (h0 += fm2, 0.0);
+  CHECK (h0, 0.0);
+
+  CHECK (h0 -= h1, -1.0);
+  CHECK (h0, -1.0);
+  CHECK (h0 -= (__fp16)1.0, -2.0);
+  CHECK (h0, -2.0);
+  CHECK (h0 -= fm2, 0.0);
+  CHECK (h0, 0.0);
+
+  h0 = hm2;
+  CHECK (h0 *= hm2, 4.0);
+  CHECK (h0, 4.0);
+  CHECK (h0 *= (__fp16)-2.0, -8.0);
+  CHECK (h0, -8.0);
+  CHECK (h0 *= fm2, 16.0);
+  CHECK (h0, 16.0);
+
+  CHECK (h0 /= hm2, -8.0);
+  CHECK (h0, -8.0);
+  CHECK (h0 /= (__fp16)-2.0, 4.0);
+  CHECK (h0, 4.0);
+  CHECK (h0 /= fm2, -2.0);
+  CHECK (h0, -2.0);
+
+  CHECK ((h0, h1), 1.0);
+
+  return 0;
+}
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-mangle-1.C b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-mangle-1.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-mangle-1.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-mangle-1.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,14 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Test mangling */
+
+/* { dg-final { scan-assembler "\t.global\t_Z1fPDh" } } */
+void f (__fp16 *x) { }
+
+/* { dg-final { scan-assembler "\t.global\t_Z1gPDhS_" } } */
+void g (__fp16 *x, __fp16 *y) { }
+
+/* { dg-final { scan-assembler "\t.global\t_ZN1SIDhDhE1iE" } } */
+template <typename T, typename U> struct S { static int i; }; 
+template <> int S<__fp16, __fp16>::i = 3;
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-overload-1.C b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-overload-1.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-overload-1.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-overload-1.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,16 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* __fp16 values are autoconverted to float and should therefore be treated
+ * just like float for overloading purposes.  */
+
+extern int frobnify (float x);
+extern int frobnify (double x);
+
+int g (void)
+{
+  return frobnify ((__fp16)1.0);
+}
+
+/* { dg-final { scan-assembler "_Z8frobnifyf" } } */
+/* { dg-final { scan-assembler-not " _Z8frobnifyd" } } */
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-param-1.C b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-param-1.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-param-1.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-param-1.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Functions cannot have parameters of type __fp16.  */
+extern void f (__fp16);		/* { dg-error "parameters cannot have __fp16 type" } */
+extern void (*pf) (__fp16);	/* { dg-error "parameters cannot have __fp16 type" } */
+
+/* These should be OK.  */
+extern void g (__fp16 *);
+extern void (*pg) (__fp16 *);
diff -Nur a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-return-1.C b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-return-1.C
--- a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-return-1.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-return-1.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,10 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Functions cannot return type __fp16.  */
+extern __fp16 f (void);		/* { dg-error "cannot return __fp16" } */
+extern __fp16 (*pf) (void);	/* { dg-error "cannot return __fp16" } */
+
+/* These should be OK.  */
+extern __fp16 *g (void);
+extern __fp16 *(*pg) (void);
diff -Nur a/gcc/testsuite/g++.dg/ext/dllexport2a.cc b/gcc/testsuite/g++.dg/ext/dllexport2a.cc
--- a/gcc/testsuite/g++.dg/ext/dllexport2a.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/dllexport2a.cc	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,21 @@
+extern void i1();
+extern void i3();
+extern void i4();
+extern void i5();
+
+extern void e1();
+extern void e3();
+extern void e4();
+extern void e5();
+
+int main () {
+  i1();
+  i3();
+  i4();
+  i5();
+
+  e1();
+  e3();
+  e4();
+  e5();
+}
diff -Nur a/gcc/testsuite/g++.dg/ext/dllexport2.C b/gcc/testsuite/g++.dg/ext/dllexport2.C
--- a/gcc/testsuite/g++.dg/ext/dllexport2.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/dllexport2.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,52 @@
+// { dg-do link }
+// { dg-require-dll "" }
+// { dg-additional-sources "dllexport2a.cc" }
+// { dg-options "-O2" }
+
+/* Test that inline functions declared "dllexport" appear in object
+   files, even if they are not called.
+
+   This behavior is required by the ARM C++ ABI:
+
+     Exporting a function that can be inlined should force the
+     creation and export of an out-of-line copy of it.
+
+   and should presumably also apply.
+
+   Visual Studio 2005 also honors that rule.  */
+
+__declspec(dllexport) inline void i1() {}
+
+__declspec(dllexport) extern inline void e1() {}
+
+/* It is invalid to declare the function inline after its definition.  */
+#if 0
+__declspec(dllexport) void i2() {}
+inline void i2();
+
+__declspec(dllexport) extern void e2() {}
+inline void e2();
+#endif
+
+__declspec(dllexport) inline void i3() {}
+void i3();
+
+__declspec(dllexport) inline void e3() {}
+extern void e3();
+
+__declspec(dllexport) void i4();
+inline void i4() {};
+
+__declspec(dllexport) extern void e4();
+inline void e4() {};
+
+__declspec(dllexport) inline void i5();
+void i5() {};
+
+__declspec(dllexport) inline void e5();
+extern void e5() {};
+
+/* Make sure that just declaring the function -- without defining it
+   -- does not cause errors.  */
+__declspec(dllexport) inline void i6();
+__declspec(dllexport) extern inline void e6();
diff -Nur a/gcc/testsuite/g++.dg/ext/ms-1.C b/gcc/testsuite/g++.dg/ext/ms-1.C
--- a/gcc/testsuite/g++.dg/ext/ms-1.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/ext/ms-1.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,17 @@
+
+// MS allows more things to be pointers to member functions
+// { dg-options "-fms-extensions" }
+
+struct X
+{
+  void Foo (X *);
+  void Bar ();
+};
+
+void Quux (void (X::*) ());
+
+void X::Foo (X *ptr)  // { dg-message "candidates" }
+{
+  Quux (Foo); // { dg-error "no matches" }
+  Quux (Bar);
+}
diff -Nur a/gcc/testsuite/g++.dg/init/ref15.C b/gcc/testsuite/g++.dg/init/ref15.C
--- a/gcc/testsuite/g++.dg/init/ref15.C	2007-10-04 19:58:07.000000000 +0200
+++ b/gcc/testsuite/g++.dg/init/ref15.C	2010-01-25 09:50:29.575686558 +0100
@@ -1,6 +1,8 @@
 // PR c++/20416.  We correctly constructed the temporary S in foo(),
 // but incorrectly destroyed it every time foo() was called.
-// { dg-do run }
+// When using a wrapped target, there is no way to override the exit
+// code after returning from main.
+// { dg-do run { target unwrapped } }
 extern "C" void abort (void);
 extern "C" void _exit (int);
 
diff -Nur a/gcc/testsuite/g++.dg/opt/alias5.C b/gcc/testsuite/g++.dg/opt/alias5.C
--- a/gcc/testsuite/g++.dg/opt/alias5.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/opt/alias5.C	2010-01-25 09:50:29.575686558 +0100
@@ -0,0 +1,24 @@
+// { dg-options "-O2" }
+// ICE in struct-alias
+
+typedef int (*PFN)(void);
+int f (void);
+struct Container
+{
+  PFN ptr;
+};
+
+inline PFN Get (struct Container *tpl)
+{
+  return tpl->ptr;
+}
+void Other (PFN);
+
+inline void Foo (PFN pfn)
+{
+  Other (Get ((struct Container *)&pfn));
+}
+void Bar (void)
+{
+  Foo (f);
+}
diff -Nur a/gcc/testsuite/g++.dg/other/arm-neon-1.C b/gcc/testsuite/g++.dg/other/arm-neon-1.C
--- a/gcc/testsuite/g++.dg/other/arm-neon-1.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/other/arm-neon-1.C	2010-01-25 09:50:29.585686502 +0100
@@ -0,0 +1,18 @@
+/* Basic smoke test for arm_neon.h */
+
+/* { dg-do assemble } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+
+float a[4];
+
+void test(void)
+{
+  float32x2x2_t v;
+  float32x2_t res;
+  v = vld2_f32(a);
+  res = vadd_f32(v.val[0], v.val[1]);
+  vst1_f32(a, res);
+}
diff -Nur a/gcc/testsuite/g++.dg/other/armv7m-1.C b/gcc/testsuite/g++.dg/other/armv7m-1.C
--- a/gcc/testsuite/g++.dg/other/armv7m-1.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/other/armv7m-1.C	2010-01-25 09:50:29.585686502 +0100
@@ -0,0 +1,69 @@
+/* { dg-do run { target arm*-*-* } } */
+/* Test Armv7m interrupt routines.  */
+#include <stdlib.h>
+
+#ifdef __ARM_ARCH_7M__
+void __attribute__((interrupt))
+foo(void)
+{
+  long long n;
+  long p;
+  asm volatile ("" : "=r" (p) : "0" (&n));
+  if (p & 4)
+    abort ();
+  return;
+}
+
+void __attribute__((interrupt))
+bar(void)
+{
+  throw 42;
+}
+
+int main()
+{
+  int a;
+  int before;
+  int after;
+  volatile register int sp asm("sp");
+
+  asm volatile ("mov %0, sp\n"
+		"blx %2\n"
+		"mov %1, sp\n"
+		: "=&r" (before), "=r" (after) : "r" (foo)
+		: "memory", "cc", "r0", "r1", "r2", "r3", "ip", "lr");
+  if (before != after)
+    abort();
+  asm volatile ("mov %0, sp\n"
+		"sub sp, sp, #4\n"
+		"blx %2\n"
+		"add sp, sp, #4\n"
+		"mov %1, sp\n"
+		: "=&r" (before), "=r" (after) : "r" (foo)
+		: "memory", "cc", "r0", "r1", "r2", "r3", "ip", "lr");
+  if (before != after)
+    abort();
+  before = sp;
+  try
+    {
+      bar();
+    }
+  catch (int i)
+    {
+      if (i != 42)
+	abort();
+    }
+  catch (...)
+    {
+      abort();
+    }
+  if (before != sp)
+    abort();
+  exit(0);
+}
+#else
+int main()
+{
+  exit (0);
+}
+#endif
diff -Nur a/gcc/testsuite/g++.dg/remove-local-statics-1.C b/gcc/testsuite/g++.dg/remove-local-statics-1.C
--- a/gcc/testsuite/g++.dg/remove-local-statics-1.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/remove-local-statics-1.C	2010-01-25 09:50:29.585686502 +0100
@@ -0,0 +1,21 @@
+/* Verify that we do not eliminate a static variable in
+   main::Local::Foo.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int
+main (void)
+{
+   static int thestatic = 0;
+   struct Local {
+     __attribute__((__noinline__))
+     static void Foo () { thestatic = 1; }
+   };
+
+   thestatic = 2;
+   Local::Foo();
+
+   return thestatic++;
+}
diff -Nur a/gcc/testsuite/g++.dg/remove-local-statics-2.C b/gcc/testsuite/g++.dg/remove-local-statics-2.C
--- a/gcc/testsuite/g++.dg/remove-local-statics-2.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/remove-local-statics-2.C	2010-01-25 09:50:29.585686502 +0100
@@ -0,0 +1,21 @@
+/* Verify that we do not eliminate a static variable in
+   main due to its use in Local::Foo.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int
+main (void)
+{
+   static int thestatic = 0;
+   struct Local {
+     __attribute__((__noinline__))
+     static int Foo () { return thestatic; }
+   };
+
+   thestatic = 2;
+   thestatic = Local::Foo();
+
+   return thestatic++;
+}
diff -Nur a/gcc/testsuite/g++.dg/template/overload9.C b/gcc/testsuite/g++.dg/template/overload9.C
--- a/gcc/testsuite/g++.dg/template/overload9.C	2008-09-19 00:29:39.000000000 +0200
+++ b/gcc/testsuite/g++.dg/template/overload9.C	2010-01-25 09:50:29.585686502 +0100
@@ -7,12 +7,12 @@
 template <typename T>
 struct A 
 {
-  A<T>& operator<<(A<T>& (*)(A<T>&)); // { dg-message "candidate" }
+  A<T>& operator<<(A<T>& (*)(A<T>&));
 };
 
 template <typename T> A<T>& foo(A<T>&);
 extern A<char> c;
 
 int main () {
-  c << (1, foo); // { dg-error "no match" }
+  c << (1, foo); // { dg-error "no context" }
 }
diff -Nur a/gcc/testsuite/g++.dg/torture/pr36191.C b/gcc/testsuite/g++.dg/torture/pr36191.C
--- a/gcc/testsuite/g++.dg/torture/pr36191.C	2008-12-29 19:25:19.000000000 +0100
+++ b/gcc/testsuite/g++.dg/torture/pr36191.C	2010-01-25 09:50:29.585686502 +0100
@@ -1,6 +1,7 @@
 // PR c++/36191
 // { dg-do compile }
 // { dg-options "-fnon-call-exceptions" }
+// { dg-skip-if "Frame pointer required for unwind tables" { sh*-*-* } "-fomit-frame-pointer" "" }
 
 __complex__ double
 foo (__complex__ double x, double y)
diff -Nur a/gcc/testsuite/g++.dg/tree-ssa/sink-1.C b/gcc/testsuite/g++.dg/tree-ssa/sink-1.C
--- a/gcc/testsuite/g++.dg/tree-ssa/sink-1.C	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/testsuite/g++.dg/tree-ssa/sink-1.C	2010-01-25 09:50:29.585686502 +0100
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-options "-O1" } */
+
+class A {
+ public:
+  A() {}
+  virtual ~A() {}  
+  void * dostuff();
+  
+  virtual int dovirtual() = 0;
+};
+
+
+class B : public A {
+ public:
+  B() {}
+  int dovirtual() { return 0;}
+  virtual ~B() {};
+}; 
+
+class C : public B {
+ public:
+  C() {}
+  virtual ~C() {};
+};
+
+void* A::dostuff()
+{
+  return (void*)dovirtual();
+}
+
+/* tree-ssa-sink was sinking the inlined destructor for STUFF out of
+   the first inner block and into the second one, where it was ending up
+   after the inlined constructor for STUFF2.  This is bad because
+   cfgexpand aliases STUFF and STUFF2 to the same storage at -O1
+   (i.e., without -fstrict-aliasing), with the result that STUFF2's
+   vtable was getting trashed. */
+
+int main() {
+  {
+    B stuff;
+    stuff.dostuff();
+  }
+  {
+    C stuff2;
+    stuff2.dostuff();
+  }
+  return 0;
+}
+
diff -Nur a/gcc/testsuite/g++.dg/vect/vect.exp b/gcc/testsuite/g++.dg/vect/vect.exp
--- a/gcc/testsuite/g++.dg/vect/vect.exp	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/testsuite/g++.dg/vect/vect.exp	2010-01-25 09:50:29.585686502 +0100
@@ -105,7 +105,7 @@
 } elseif [istarget "ia64-*-*"] {
     set dg-do-what-default run
 } elseif [is-effective-target arm_neon_ok] {
-    lappend DEFAULT_VECTCFLAGS "-mfpu=neon" "-mfloat-abi=softfp"
+    eval lappend DEFAULT_VECTCFLAGS [add_options_for_arm_neon ""]
     if [is-effective-target arm_neon_hw] {
       set dg-do-what-default run
     } else {
diff -Nur a/gcc/testsuite/g++.dg/warn/null4.C b/gcc/testsuite/g++.dg/warn/null4.C
--- a/gcc/testsuite/g++.dg/warn/null4.C	2007-01-30 23:29:11.000000000 +0100
+++ b/gcc/testsuite/g++.dg/warn/null4.C	2010-01-25 09:50:29.585686502 +0100
@@ -11,9 +11,22 @@
   if (NULL < NULL) return -1; // { dg-warning "NULL used in arithmetic" } 
   if (NULL >= 0) return -1;   // { dg-warning "NULL used in arithmetic" } 
   if (NULL <= 0) return -1;   // { dg-warning "NULL used in arithmetic" } 
+  // Adding to the NULL pointer, which has no specific type, should
+  // result in a warning; the type of the resulting expression is
+  // actually "int", not a pointer type.
+  if (NULL + 1) return -1;    // { dg-warning "NULL used in arithmetic" }
+  if (1 + NULL) return -1;    // { dg-warning "NULL used in arithmetic" }
   return 0;
 }
 
+int *ip;
+
+struct S {};
+typedef int S::*SPD;
+typedef void (S::*SPF)(void);
+SPD spd;
+SPF spf;
+
 int bar (void) 
 {
   if (NULL) return -1;
@@ -25,5 +38,18 @@
   if (NULL != NULL) return -1;
   if (NULL == 0) return -1;
   if (NULL != 0) return -1;
+  // Subtraction of pointers is vaild, so using NULL is OK.
+  if (ip - NULL) return -1;
+  if (NULL - NULL) return -1;
+  // Comparing NULL with a pointer-to-member is OK.
+  if (NULL == spd) return -1;
+  if (spd == NULL) return -1;
+  if (NULL != spd) return -1;
+  if (spd != NULL) return -1;
+  if (NULL == spf) return -1;
+  if (spf == NULL) return -1;
+  if (NULL != spf) return -1;
+  if (spf != NULL) return -1;
+
   return 0;
 }
diff -Nur a/gcc/testsuite/gfortran.dg/vect/vect.exp b/gcc/testsuite/gfortran.dg/vect/vect.exp
--- a/gcc/testsuite/gfortran.dg/vect/vect.exp	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/testsuite/gfortran.dg/vect/vect.exp	2010-01-25 09:50:29.585686502 +0100
@@ -98,7 +98,7 @@
 } elseif [istarget "ia64-*-*"] {
     set dg-do-what-default run
 } elseif [is-effective-target arm_neon_ok] {
-    lappend DEFAULT_VECTCFLAGS "-mfpu=neon" "-mfloat-abi=softfp"
+    eval lappend DEFAULT_VECTCFLAGS [add_options_for_arm_neon ""]
     if [is-effective-target arm_neon_hw] {
       set dg-do-what-default run
     } else {
diff -Nur a/gcc/testsuite/g++.old-deja/g++.other/overload11.C b/gcc/testsuite/g++.old-deja/g++.other/overload11.C
--- a/gcc/testsuite/g++.old-deja/g++.other/overload11.C	2008-09-19 00:29:39.000000000 +0200
+++ b/gcc/testsuite/g++.old-deja/g++.other/overload11.C	2010-01-25 09:50:29.585686502 +0100
@@ -54,11 +54,10 @@
   
   ptr = (ovl);              // ok
   ptr = (&ovl);             // ok
-  // 13.4 indicates these are ok.
-  ptr = (0, ovl);           // ok { dg-bogus "" "" { xfail *-*-* } }
-  ptr = (0, &ovl);          // ok { dg-bogus "" "" { xfail *-*-* } }
-  ptr = (argc ? ovl : ovl); // ok { dg-bogus "" "" { xfail *-*-* } }
-  ptr = (argc ? &ovl : &ovl);// ok { dg-bogus "" "" { xfail *-*-* } }
+  ptr = (0, ovl);           // ok { dg-error "no context" }
+  ptr = (0, &ovl);          // ok { dg-error "no context" }
+  ptr = (argc ? ovl : ovl); // ok { dg-error "no context" }
+  ptr = (argc ? &ovl : &ovl);// ok { dg-error "no context" }
   
   vptr = (ovl);              // { dg-error "" } no matching candidates
   vptr = (&ovl);             // { dg-error "" } no matching candidates
diff -Nur a/gcc/testsuite/lib/prune.exp b/gcc/testsuite/lib/prune.exp
--- a/gcc/testsuite/lib/prune.exp	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/testsuite/lib/prune.exp	2010-01-25 09:50:29.585686502 +0100
@@ -57,3 +57,34 @@
 	return $text
     }
 }
+
+# Extend prune_warnings (provided by DejaGNU itself) to prune more
+# things.  The prune_gcc_output function above is called only by some
+# tests; prune_warnings is used by all.
+if { [info procs prune_warnings_orig] == "" } {
+    rename prune_warnings prune_warnings_orig
+    
+    proc prune_warnings { text } {
+	set text [prune_warnings_orig $text]
+	
+	if { [ishost "sparc*-*-solaris2*"] } {
+	    # When testing a compiler built for SPARC Solaris 2.9 (or earlier)
+	    # on a host running Solaris 2.10 (or later), we get this warning 
+	    # from the static linker when building with g++:
+	    #
+	    #   libm.so.1, needed by .../libstdc++.so may conflict with
+	    #   libm.so
+	    #
+	    # The warning is issued because libstdc++ is linked against
+	    # libm.so.1 (from the Solaris 2.9 sysroot), whereas Solaris 2.10
+	    # provides both libm.so.2 and libm.so.1.  On Solaris 2.10, libc.so
+	    # depends on libm.so.2, so all programs pull in libm.so.2.
+	    #
+	    # Pulling both libraries must in fact be harmless, as, otherwise,
+	    # programs built for Solaris 2.9 would break on Solaris 2.10.
+	    regsub -all "(^|\n)\[^\n\]*: warning: libm.so.1, needed by \[^\n\]*, may conflict with libm.so.2" $text "" text
+	}
+
+	return $text
+    }
+}
diff -Nur a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
--- a/gcc/testsuite/lib/target-supports.exp	2009-07-21 09:22:51.000000000 +0200
+++ b/gcc/testsuite/lib/target-supports.exp	2010-01-25 09:50:29.585686502 +0100
@@ -491,6 +491,7 @@
 	     || [istarget avr-*-*]
 	     || [istarget bfin-*-*]
 	     || [istarget powerpc-*-eabi*]
+	     || [istarget powerpc-*-elf]
 	     || [istarget cris-*-*]
 	     || [istarget crisv32-*-*]
 	     || [istarget fido-*-elf]
@@ -611,6 +612,18 @@
     } "-pthread"]
 }
 
+# Return 1 if compilation with -mpe-aligned-commons is error-free
+# for trivial code, 0 otherwise.
+
+proc check_effective_target_pe_aligned_commons {} {
+    if { [istarget *-*-cygwin*] || [istarget *-*-mingw*] } {
+	return [check_no_compiler_messages pe_aligned_commons object {
+	    int foo;
+	} "-mpe-aligned-commons"]
+    }
+    return 0
+}
+
 # Return 1 if the target supports -fstack-protector
 proc check_effective_target_fstack_protector {} {
     return [check_runtime fstack_protector {
@@ -720,6 +733,15 @@
     } [add_options_for_mips16_attribute ""]]
 }
 
+# Return 1 if the target supports long double larger than double when
+# using the new ABI, 0 otherwise.
+
+proc check_effective_target_mips_newabi_large_long_double { } {
+    return [check_no_compiler_messages mips_newabi_large_long_double object {
+	int dummy[sizeof(long double) > sizeof(double) ? 1 : -1];
+    } "-mabi=64"]
+}
+
 # Return 1 if the current multilib does not generate PIC by default.
 
 proc check_effective_target_nonpic { } {
@@ -1408,6 +1430,18 @@
     }]
 }
 
+# Return 1 if this is an ARM target that only supports aligned vector accesses
+proc check_effective_target_arm_vect_no_misalign { } {
+    return [check_no_compiler_messages arm_vect_no_misalign assembly {
+	#if !defined(__arm__) \
+	    || (defined(__ARMEL__) \
+	        && (!defined(__thumb__) || defined(__thumb2__)))
+	#error FOO
+	#endif
+    }]
+}
+
+
 # Return 1 if this is an ARM target supporting -mfpu=vfp
 # -mfloat-abi=softfp.  Some multilibs may be incompatible with these
 # options.
@@ -1422,18 +1456,110 @@
     }
 }
 
-# Return 1 if this is an ARM target supporting -mfpu=neon
-# -mfloat-abi=softfp.  Some multilibs may be incompatible with these
+# Return 1 if this is an ARM target supporting -mfpu=vfp
+# -mfloat-abi=hard.  Some multilibs may be incompatible with these
 # options.
 
-proc check_effective_target_arm_neon_ok { } {
+proc check_effective_target_arm_hard_vfp_ok { } {
     if { [check_effective_target_arm32] } {
-        return [check_no_compiler_messages arm_neon_ok object {
-            int dummy;
-        } "-mfpu=neon -mfloat-abi=softfp"]
+	return [check_no_compiler_messages arm_hard_vfp_ok executable {
+	    int main() { return 0;}
+	} "-mfpu=vfp -mfloat-abi=hard"]
     } else {
-        return 0
+	return 0
+    }
+}
+
+# Add the options needed for NEON.  We need either -mfloat-abi=softfp
+# or -mfloat-abi=hard, but if one is already specified by the
+# multilib, use it.  Similarly, if a -mfpu option already enables
+# NEON, do not add -mfpu=neon.
+
+proc add_options_for_arm_neon { flags } {
+    if { ! [check_effective_target_arm_neon_ok] } {
+	return "$flags"
+    }
+    global et_arm_neon_flags
+    return "$flags $et_arm_neon_flags"
+}
+
+# Return 1 if this is an ARM target supporting -mfpu=neon
+# -mfloat-abi=softfp or equivalent options.  Some multilibs may be
+# incompatible with these options.  Also set et_arm_neon_flags to the
+# best options to add.
+
+proc check_effective_target_arm_neon_ok_nocache { } {
+    global et_arm_neon_flags
+    set et_arm_neon_flags ""
+    if { [check_effective_target_arm32] } {
+	foreach flags {"" "-mfloat-abi=softfp" "-mfpu=neon" "-mfpu=neon -mfloat-abi=softfp"} {
+	    if { [check_no_compiler_messages_nocache arm_neon_ok object {
+		#include "arm_neon.h"
+		int dummy;
+	    } "$flags"] } {
+		set et_arm_neon_flags $flags
+		return 1
+	    }
+	}
     }
+
+    return 0
+}
+
+proc check_effective_target_arm_neon_ok { } {
+    return [check_cached_effective_target arm_neon_ok \
+		check_effective_target_arm_neon_ok_nocache]
+}
+
+# Add the options needed for NEON.  We need either -mfloat-abi=softfp
+# or -mfloat-abi=hard, but if one is already specified by the
+# multilib, use it.
+
+proc add_options_for_arm_neon_fp16 { flags } {
+    if { ! [check_effective_target_arm_neon_fp16_ok] } {
+	return "$flags"
+    }
+    global et_arm_neon_fp16_flags
+    return "$flags $et_arm_neon_fp16_flags"
+}
+
+# Return 1 if this is an ARM target supporting -mfpu=neon-fp16
+# -mfloat-abi=softfp or equivalent options.  Some multilibs may be
+# incompatible with these options.  Also set et_arm_neon_flags to the
+# best options to add.
+
+proc check_effective_target_arm_neon_fp16_ok_nocache { } {
+    global et_arm_neon_fp16_flags
+    set et_arm_neon_fp16_flags ""
+    if { [check_effective_target_arm32] } {
+	# Always add -mfpu=neon-fp16, since there is no preprocessor
+	# macro for FP16 support.
+	foreach flags {"-mfpu=neon-fp16" "-mfpu=neon-fp16 -mfloat-abi=softfp"} {
+	    if { [check_no_compiler_messages_nocache arm_neon_fp16_ok object {
+		#include "arm_neon.h"
+		int dummy;
+	    } "$flags"] } {
+		set et_arm_neon_fp16_flags $flags
+		return 1
+	    }
+	}
+    }
+
+    return 0
+}
+
+proc check_effective_target_arm_neon_fp16_ok { } {
+    return [check_cached_effective_target arm_neon_fp16_ok \
+		check_effective_target_arm_neon_fp16_ok_nocache]
+}
+
+# Return 1 if this is an arm target using 32-bit instructions, but not thumb
+proc check_effective_target_arm_not_thumb { } {
+    return [check_no_compiler_messages arm_not_thumb assembly {
+      #if !defined(__arm__) || defined(__thumb__)
+      #error FOO
+      #endif
+    }]
 }
 
 # Return 1 is this is an ARM target where -mthumb causes Thumb-1 to be
@@ -1447,6 +1573,17 @@
     } "-mthumb"]
 }
 
+# Return 1 is this is an ARM target where -mthumb causes Thumb-2 to be
+# used.
+
+proc check_effective_target_arm_thumb2_ok { } {
+    return [check_no_compiler_messages arm_thumb2_ok assembly {
+	#if !defined(__thumb2__)
+	#error FOO
+	#endif
+    } "-mthumb"]
+}
+
 # Return 1 if the target supports executing NEON instructions, 0
 # otherwise.  Cache the result.
 
@@ -1461,7 +1598,7 @@
 	       : "0" (a), "w" (b));
 	  return (a != 1);
 	}
-    } "-mfpu=neon -mfloat-abi=softfp"]
+    } [add_options_for_arm_neon ""]]
 }
 
 # Return 1 if this is a ARM target with NEON enabled.
@@ -1504,6 +1641,19 @@
     }]
 }
 
+# Return 1 if this is an ARM target supporting -mcpu=iwmmxt.
+# Some multilibs may be incompatible with this option.
+
+proc check_effective_target_arm_iwmmxt_ok { } {
+    if { [check_effective_target_arm32] } {
+	return [check_no_compiler_messages arm_iwmmxt_ok object {
+	    int dummy;
+	} "-mcpu=iwmmxt"]
+    } else {
+	return 0
+    }
+}
+
 # Return 1 if this is a PowerPC target with floating-point registers.
 
 proc check_effective_target_powerpc_fprs { } {
@@ -1700,6 +1850,26 @@
     return $et_vect_shift_saved
 }
 
+# Return 1 if the target supports hardware vector shift operation for char.
+
+proc check_effective_target_vect_shift_char { } {
+    global et_vect_shift_char_saved
+
+    if [info exists et_vect_shift_char_saved] {
+	verbose "check_effective_target_vect_shift_char: using cached result" 2
+    } else {
+	set et_vect_shift_char_saved 0
+	if { ([istarget powerpc*-*-*]
+             && ![istarget powerpc-*-linux*paired*])
+	     || [check_effective_target_arm32] } {
+	   set et_vect_shift_char_saved 1
+	}
+    }
+
+    verbose "check_effective_target_vect_shift_char: returning $et_vect_shift_char_saved" 2
+    return $et_vect_shift_char_saved
+}
+
 # Return 1 if the target supports hardware vectors of long, 0 otherwise.
 #
 # This can change for different subtargets so do not cache the result.
@@ -2159,7 +2329,7 @@
 	if { [istarget mipsisa64*-*-*]
 	     || [istarget sparc*-*-*]
 	     || [istarget ia64-*-*]
-	     || [check_effective_target_arm32] } { 
+	     || [check_effective_target_arm_vect_no_misalign] } { 
 	    set et_vect_no_align_saved 1
 	}
     }
@@ -2273,6 +2443,24 @@
     return $et_vector_alignment_reachable_for_64bit_saved
 }
 
+# Return 1 if the target only requires element alignment for vector accesses
+
+proc check_effective_target_vect_element_align { } {
+    global et_vect_element_align
+
+    if [info exists et_vect_element_align] {
+	verbose "check_effective_target_vect_elemetn_align: using cached result" 2
+    } else {
+	set et_vect_element_align 0
+	if { [istarget arm*-*-*] } {
+	   set et_vect_element_align 1
+	}
+    }
+
+    verbose "check_effective_target_vect_element_align: returning $et_vect_element_align" 2
+    return $et_vect_element_align
+}
+
 # Return 1 if the target supports vector conditional operations, 0 otherwise.
 
 proc check_effective_target_vect_condition { } {
@@ -2468,7 +2656,8 @@
         verbose "check_effective_target_section_anchors: using cached result" 2
     } else {
         set et_section_anchors_saved 0
-        if { [istarget powerpc*-*-*] } {
+        if { [istarget powerpc*-*-*] 
+	      || [istarget arm*-*-*] } {
            set et_section_anchors_saved 1
         }
     }
diff -Nur a/gcc/timevar.def b/gcc/timevar.def
--- a/gcc/timevar.def	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/timevar.def	2010-01-25 09:50:29.585686502 +0100
@@ -134,6 +134,7 @@
 DEFTIMEVAR (TV_PREDCOM		     , "predictive commoning")
 DEFTIMEVAR (TV_TREE_LOOP_INIT	     , "tree loop init")
 DEFTIMEVAR (TV_TREE_LOOP_FINI	     , "tree loop fini")
+DEFTIMEVAR (TV_TREE_LOOP_PROMOTE     , "tree loop index promotion")
 DEFTIMEVAR (TV_TREE_CH		     , "tree copy headers")
 DEFTIMEVAR (TV_TREE_SSA_UNCPROP	     , "tree SSA uncprop")
 DEFTIMEVAR (TV_TREE_SSA_TO_NORMAL    , "tree SSA to normal")
@@ -141,6 +142,7 @@
 DEFTIMEVAR (TV_TREE_COPY_RENAME	     , "tree rename SSA copies")
 DEFTIMEVAR (TV_TREE_SSA_VERIFY       , "tree SSA verifier")
 DEFTIMEVAR (TV_TREE_STMT_VERIFY      , "tree STMT verifier")
+DEFTIMEVAR (TV_TREE_RLS              , "tree local static removal")
 DEFTIMEVAR (TV_TREE_SWITCH_CONVERSION, "tree switch initialization conversion")
 DEFTIMEVAR (TV_CGRAPH_VERIFY         , "callgraph verifier")
 DEFTIMEVAR (TV_DOM_FRONTIERS         , "dominance frontiers")
diff -Nur a/gcc/toplev.h b/gcc/toplev.h
--- a/gcc/toplev.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/toplev.h	2010-01-25 09:50:29.585686502 +0100
@@ -139,6 +139,7 @@
 extern int flag_unroll_all_loops;
 extern int flag_unswitch_loops;
 extern int flag_cprop_registers;
+extern int flag_remove_local_statics;
 extern int time_report;
 extern int flag_ira_coalesce;
 extern int flag_ira_move_spills;
diff -Nur a/gcc/tree.c b/gcc/tree.c
--- a/gcc/tree.c	2009-07-20 16:39:32.000000000 +0200
+++ b/gcc/tree.c	2010-01-25 09:50:29.585686502 +0100
@@ -4062,6 +4062,7 @@
 		      bool *no_add_attrs)
 {
   tree node = *pnode;
+  bool is_dllimport;
 
   /* These attributes may apply to structure and union types being created,
      but otherwise should pass to the declaration involved.  */
@@ -4109,9 +4110,11 @@
       return NULL_TREE;
     }
 
+  is_dllimport = is_attribute_p ("dllimport", name);
+
   /* Report error on dllimport ambiguities seen now before they cause
      any damage.  */
-  else if (is_attribute_p ("dllimport", name))
+  if (is_dllimport)
     {
       /* Honor any target-specific overrides. */ 
       if (!targetm.valid_dllimport_attribute_p (node))
@@ -4153,6 +4156,9 @@
       if (*no_add_attrs == false)
         DECL_DLLIMPORT_P (node) = 1;
     }
+  else if (DECL_DECLARED_INLINE_P (node))
+    /* An exported function, even if inline, must be emitted.  */
+    DECL_EXTERNAL (node) = 0;
 
   /*  Report error if symbol is not accessible at global scope.  */
   if (!TREE_PUBLIC (node)
diff -Nur a/gcc/tree-cfg.c b/gcc/tree-cfg.c
--- a/gcc/tree-cfg.c	2009-07-02 14:16:39.000000000 +0200
+++ b/gcc/tree-cfg.c	2010-01-25 09:50:29.585686502 +0100
@@ -47,6 +47,7 @@
 #include "value-prof.h"
 #include "pointer-set.h"
 #include "tree-inline.h"
+#include "target.h"
 
 /* This file contains functions for building the Control Flow Graph (CFG)
    for a function tree.  */
@@ -7052,6 +7053,9 @@
   edge e;
   edge_iterator ei;
 
+  if (!targetm.warn_func_result())
+    return 0;
+
   /* If we have a path to EXIT, then we do return.  */
   if (TREE_THIS_VOLATILE (cfun->decl)
       && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0)
diff -Nur a/gcc/tree.h b/gcc/tree.h
--- a/gcc/tree.h	2009-06-02 09:18:16.000000000 +0200
+++ b/gcc/tree.h	2010-01-25 09:50:29.585686502 +0100
@@ -381,8 +381,10 @@
   unsigned lang_flag_5 : 1;
   unsigned lang_flag_6 : 1;
   unsigned visited : 1;
+  unsigned packed_flag : 1;
+  unsigned user_align : 1;
 
-  unsigned spare : 23;
+  unsigned spare : 21;
 
   union tree_ann_d *ann;
 };
@@ -2140,7 +2142,7 @@
 
 /* 1 if the alignment for this type was requested by "aligned" attribute,
    0 if it is the default for this type.  */
-#define TYPE_USER_ALIGN(NODE) (TYPE_CHECK (NODE)->type.user_align)
+#define TYPE_USER_ALIGN(NODE) (TYPE_CHECK (NODE)->common.base.user_align)
 
 /* The alignment for NODE, in bytes.  */
 #define TYPE_ALIGN_UNIT(NODE) (TYPE_ALIGN (NODE) / BITS_PER_UNIT)
@@ -2246,7 +2248,7 @@
 
 /* Indicated that objects of this type should be laid out in as
    compact a way as possible.  */
-#define TYPE_PACKED(NODE) (TYPE_CHECK (NODE)->type.packed_flag)
+#define TYPE_PACKED(NODE) (TYPE_CHECK (NODE)->common.base.packed_flag)
 
 /* Used by type_contains_placeholder_p to avoid recomputation.
    Values are: 0 (unknown), 1 (false), 2 (true).  Never access
@@ -2265,17 +2267,16 @@
   tree attributes;
   unsigned int uid;
 
-  unsigned int precision : 9;
-  ENUM_BITFIELD(machine_mode) mode : 7;
-
-  unsigned string_flag : 1;
+  unsigned int precision : 10;
   unsigned no_force_blk_flag : 1;
   unsigned needs_constructing_flag : 1;
   unsigned transparent_union_flag : 1;
-  unsigned packed_flag : 1;
   unsigned restrict_flag : 1;
   unsigned contains_placeholder_bits : 2;
 
+  ENUM_BITFIELD(machine_mode) mode : 8;
+
+  unsigned string_flag : 1;
   unsigned lang_flag_0 : 1;
   unsigned lang_flag_1 : 1;
   unsigned lang_flag_2 : 1;
@@ -2283,7 +2284,6 @@
   unsigned lang_flag_4 : 1;
   unsigned lang_flag_5 : 1;
   unsigned lang_flag_6 : 1;
-  unsigned user_align : 1;
 
   unsigned int align;
   alias_set_type alias_set;
@@ -2584,7 +2584,7 @@
 #define DECL_ALIGN_UNIT(NODE) (DECL_ALIGN (NODE) / BITS_PER_UNIT)
 /* Set if the alignment of this DECL has been set by the user, for
    example with an 'aligned' attribute.  */
-#define DECL_USER_ALIGN(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.user_align)
+#define DECL_USER_ALIGN(NODE) (DECL_COMMON_CHECK (NODE)->common.base.user_align)
 /* Holds the machine mode corresponding to the declaration of a variable or
    field.  Always equal to TYPE_MODE (TREE_TYPE (decl)) except for a
    FIELD_DECL.  */
@@ -2621,7 +2621,7 @@
    example, for a FUNCTION_DECL, DECL_SAVED_TREE may be non-NULL and
    DECL_EXTERNAL may be true simultaneously; that can be the case for
    a C99 "extern inline" function.  */
-#define DECL_EXTERNAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.decl_flag_2)
+#define DECL_EXTERNAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.decl_flag_1)
 
 /* Nonzero in a ..._DECL means this variable is ref'd from a nested function.
    For VAR_DECL nodes, PARM_DECL nodes, and FUNCTION_DECL nodes.
@@ -2696,7 +2696,6 @@
   unsigned ignored_flag : 1;
   unsigned abstract_flag : 1;
   unsigned artificial_flag : 1;
-  unsigned user_align : 1;
   unsigned preserve_flag: 1;
   unsigned debug_expr_is_from : 1;
 
@@ -2712,22 +2711,20 @@
   /* In LABEL_DECL, this is DECL_ERROR_ISSUED.
      In VAR_DECL and PARM_DECL, this is DECL_REGISTER.  */
   unsigned decl_flag_0 : 1;
-  /* In FIELD_DECL, this is DECL_PACKED.  */
-  unsigned decl_flag_1 : 1;
   /* In FIELD_DECL, this is DECL_BIT_FIELD
      In VAR_DECL and FUNCTION_DECL, this is DECL_EXTERNAL.
-     In TYPE_DECL, this is TYPE_DECL_SUPRESS_DEBUG.  */
-  unsigned decl_flag_2 : 1;
+     In TYPE_DECL, this is TYPE_DECL_SUPPRESS_DEBUG.  */
+  unsigned decl_flag_1 : 1;
   /* In FIELD_DECL, this is DECL_NONADDRESSABLE_P
-     In VAR_DECL and PARM_DECL, this is DECL_HAS_VALUE_EXPR.  */
-  unsigned decl_flag_3 : 1;
+     In VAR_DECL and PARM_DECL, this is DECL_HAS_VALUE_EXPR_P.  */
+  unsigned decl_flag_2 : 1;
   /* Logically, these two would go in a theoretical base shared by var and
      parm decl. */
   unsigned gimple_reg_flag : 1;
   /* In a DECL with pointer type, set if no TBAA should be done.  */
   unsigned no_tbaa_flag : 1;
   /* Padding so that 'align' can be on a 32-bit boundary.  */
-  unsigned decl_common_unused : 2;
+  unsigned decl_common_unused : 4;
 
   unsigned int align : 24;
   /* DECL_OFFSET_ALIGN, used only for FIELD_DECLs.  */
@@ -2751,7 +2748,7 @@
    decl itself.  This should only be used for debugging; once this field has
    been set, the decl itself may not legitimately appear in the function.  */
 #define DECL_HAS_VALUE_EXPR_P(NODE) \
-  (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)->decl_common.decl_flag_3)
+  (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)->decl_common.decl_flag_2)
 #define DECL_VALUE_EXPR(NODE) \
   (decl_value_expr_lookup (DECL_WRTL_CHECK (NODE)))
 #define SET_DECL_VALUE_EXPR(NODE, VAL)			\
@@ -2830,11 +2827,11 @@
 #define DECL_FCONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.fcontext)
 
 /* In a FIELD_DECL, indicates this field should be bit-packed.  */
-#define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_1)
+#define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)->common.base.packed_flag)
 
 /* Nonzero in a FIELD_DECL means it is a bit field, and must be accessed
    specially.  */
-#define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_2)
+#define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_1)
 
 /* Used in a FIELD_DECL to indicate that we cannot form the address of
    this component.  This makes it possible for Type-Based Alias Analysis
@@ -2852,7 +2849,7 @@
    accesses to s.i must not be given the alias set of the type of 'i'
    (int) but instead directly that of the type of 's' (struct S).  */
 #define DECL_NONADDRESSABLE_P(NODE) \
-  (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_3)
+  (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_2)
 
 struct tree_field_decl GTY(())
 {
@@ -3337,7 +3334,7 @@
    into stabs.  Instead it will generate cross reference ('x') of names.
    This uses the same flag as DECL_EXTERNAL.  */
 #define TYPE_DECL_SUPPRESS_DEBUG(NODE) \
-  (TYPE_DECL_CHECK (NODE)->decl_common.decl_flag_2)
+  (TYPE_DECL_CHECK (NODE)->decl_common.decl_flag_1)
 
 /* Getter of the imported declaration associated to the
    IMPORTED_DECL node.  */
diff -Nur a/gcc/tree-pass.h b/gcc/tree-pass.h
--- a/gcc/tree-pass.h	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/tree-pass.h	2010-01-25 09:50:29.585686502 +0100
@@ -323,6 +323,7 @@
 extern struct gimple_opt_pass pass_empty_loop;
 extern struct gimple_opt_pass pass_record_bounds;
 extern struct gimple_opt_pass pass_graphite_transforms;
+extern struct gimple_opt_pass pass_promote_indices;
 extern struct gimple_opt_pass pass_if_conversion;
 extern struct gimple_opt_pass pass_loop_distribution;
 extern struct gimple_opt_pass pass_vectorize;
@@ -388,6 +389,7 @@
 extern struct gimple_opt_pass pass_rebuild_cgraph_edges;
 extern struct gimple_opt_pass pass_build_cgraph_edges;
 extern struct gimple_opt_pass pass_reset_cc_flags;
+extern struct gimple_opt_pass pass_remove_local_statics;
 
 /* IPA Passes */
 extern struct ipa_opt_pass pass_ipa_inline;
diff -Nur a/gcc/tree-sra.c b/gcc/tree-sra.c
--- a/gcc/tree-sra.c	2009-03-04 10:02:59.000000000 +0100
+++ b/gcc/tree-sra.c	2010-01-25 09:50:29.585686502 +0100
@@ -274,6 +274,12 @@
 		      != TYPE_PRECISION (TREE_TYPE (t))))
 		goto fail;
 
+	      /* Disable optimization of bitfields on BITS_BIG_ENDIAN
+		 architectures.  SRA doesn't properly handle padding bits
+		 at the bottom, see issue6713.  */
+	      if (DECL_BIT_FIELD (t) && BITS_BIG_ENDIAN)
+		goto fail;
+
 	      saw_one_field = true;
 	    }
 
diff -Nur a/gcc/tree-ssa-loop-promote.c b/gcc/tree-ssa-loop-promote.c
--- a/gcc/tree-ssa-loop-promote.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/tree-ssa-loop-promote.c	2010-01-25 09:50:29.585686502 +0100
@@ -0,0 +1,1628 @@
+/* Promotion of shorter-than-word-size loop indices.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   
+This file is part of GCC.
+   
+GCC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3, or (at your option) any
+later version.
+   
+GCC is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+   
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* This pass finds loop indices that are declared as
+   shorter-than-word-size and replaces them with word-sized loop
+   indices.  (It assumes that word-sized quantities are the most
+   efficient type on which to do arithmetic.)  The loop optimization
+   machinery has a difficult time seeing through the casts required to
+   promote such indices to word-sized quantities for memory addressing
+   and/or preserving the semantics of the source language (such as C).
+   The transformation also helps eliminate unnecessary
+   {sign,zero}-extensions required for the same.
+
+   Although this is most naturally expressed as a loop optimization
+   pass, we choose to place this pass some ways before the loop
+   optimization passes proper, so that other scalar optimizations will
+   run on our "cleaned-up" code.  This decision has the negative of
+   requiring us to build and destroy all the loop optimization
+   infrastructure.
+
+   The algorithm is relatively simple.  For each single-exit loop, we
+   identify the loop index variable.  If the loop index variable is
+   shorter than the word size, then we have a candidate for promotion.
+   We determine whether the scalar evolution of the loop index fits a
+   particular pattern (incremented by 1, compared against a
+   similarly-typed loop bound, and only modified by a single increment
+   within the loop), as well as examining the uses of the loop index to
+   ensure we are able to safely promote those uses (e.g. the loop index
+   must not be stored to memory or passed to function calls).  If these
+   conditions are satisfied, we create an appropriate word-sized type
+   and replace all uses and defs of the loop index variable with the new
+   variable.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+
+#include "toplev.h"
+#include "rtl.h"
+#include "tm_p.h"
+#include "hard-reg-set.h"
+#include "obstack.h"
+#include "basic-block.h"
+#include "pointer-set.h"
+#include "intl.h"
+
+#include "tree.h"
+#include "gimple.h"
+#include "hashtab.h"
+#include "diagnostic.h"
+#include "tree-flow.h"
+#include "tree-dump.h"
+#include "cfgloop.h"
+#include "flags.h"
+#include "timevar.h"
+#include "tree-pass.h"
+
+struct promote_info {
+  /* The loop being analyzed.  */
+  struct loop *loop;
+
+  /* The GIMPLE_COND controlling exit from the loop.  */
+  gimple exit_expr;
+
+  /* The loop index variable's SSA_NAME that is defined in a phi node in
+     LOOP->HEADER.  Note that this SSA_NAME may be different than the
+     one appearing in EXIT_EXPR.  */
+  tree loop_index_name;
+
+  /* The bound of the loop.  */
+  tree loop_limit;
+
+  /* Whether we've warned about things with
+     warn_unsafe_loop_optimizations.  */
+  bool warned;
+
+  /* LOOP_INDEX_NAME's underlying VAR_DECL.  */
+  tree var_decl;
+
+  /* The types to which defs/uses of LOOP_INDEX_NAME are cast via
+     NOP_EXPRs.  */
+  VEC(tree, heap) *cast_types;
+
+  /* The number of times we have seen a cast to the corresponding type
+     (as determined by types_compatible_p) in CAST_TYPES.  */
+  VEC(int, heap) *cast_counts;
+
+  /* Whether LOOP_INDEX_NAME is suitable for promotion.  */
+  bool can_be_promoted_p;
+
+  /* If CAN_BE_PROMOTED_P, the promoted type.  */
+  tree promoted_type;
+
+  /* If CAN_BE_PROMOTED_P, the promoted VAR_DECL.  */
+  tree promoted_var;
+};
+
+/* A set of `struct promote_info'.  */
+
+static struct pointer_set_t *promotion_info;
+
+/* A set of all potentially promotable SSA_NAMEs, used for quick
+decision-making during analysis.  */
+
+static struct pointer_set_t *promotable_names;
+
+/* A map from SSA_NAMEs to the VAR_DECL to which they will be
+   promoted.  */
+
+static struct pointer_map_t *variable_map;
+
+/* A set of the stmts that we have already rebuilt with promoted variables.  */
+
+static struct pointer_set_t *promoted_stmts;
+
+
+/* Add CASTED to PI->CAST_TYPES if we haven't seen CASTED before.  */
+
+static void
+add_casted_type (struct promote_info *pi, tree casted)
+{
+  int i;
+  tree type;
+
+  /* For this information to be useful later, CASTED must be wider than
+     the type of the variable.  */
+  if (TYPE_PRECISION (casted) <= TYPE_PRECISION (TREE_TYPE (pi->var_decl)))
+    return;
+
+  for (i = 0; VEC_iterate (tree, pi->cast_types, i, type); i++)
+    if (types_compatible_p (casted, type))
+      {
+       int c = VEC_index(int, pi->cast_counts, i);
+       VEC_replace(int, pi->cast_counts, i, ++c);
+       return;
+      }
+
+  /* Haven't see the type before.  */
+  VEC_safe_push (tree, heap, pi->cast_types, casted);
+  VEC_safe_push (int, heap, pi->cast_counts, 1);
+}
+
+/* Return the most-casted-to type in PI->CAST_TYPES.  Return an
+   appropriately signed variant of size_type_node if the variable wasn't
+   cast in some fashion.  */
+
+static tree
+choose_profitable_promoted_type (struct promote_info *pi)
+{
+  int i;
+  int count;
+  tree type = NULL_TREE;
+  int maxuse = -1;
+
+  for (i = 0; VEC_iterate (int, pi->cast_counts, i, count); i++)
+    if (count > maxuse)
+      {
+       maxuse = count;
+       type = VEC_index (tree, pi->cast_types, i);
+      }
+
+  if (type == NULL_TREE)
+    {
+      if (dump_file)
+       {
+         fprintf (dump_file, "Warning, failed to find upcast type for ");
+         print_generic_expr (dump_file, pi->loop_index_name, 0);
+         fprintf (dump_file, "\n");
+       }
+      return (TYPE_UNSIGNED (TREE_TYPE (pi->var_decl))
+             ? size_type_node
+             : signed_type_for (size_type_node));
+    }
+  else
+    return signed_type_for (type);
+}
+
+/* Intuit the loop index for LOOP from PHI.  There must be a path that
+   only goes through NOP_EXPRs or CONVERT_EXPRs from the result of PHI
+   to one of the operands of COND.  If such a path cannot be found,
+   return NULL_TREE.  If LIMIT is not NULL and a path can be found,
+   store the other operand of COND into LIMIT.  */
+
+static tree
+find_promotion_candidate_from_phi (struct loop *loop, gimple cond,
+                                  gimple phi, tree *limit)
+{
+  tree op0, op1;
+  tree result, candidate;
+
+  result = candidate = PHI_RESULT (phi);
+  /* Must be an integer variable.  */
+  if (TREE_CODE (TREE_TYPE (candidate)) != INTEGER_TYPE)
+    return NULL_TREE;
+
+  op0 = gimple_cond_lhs (cond);
+  op1 = gimple_cond_rhs (cond);
+
+  /* See if there's a path from CANDIDATE to an operand of COND.  */
+  while (true)
+    {
+      use_operand_p use;
+      imm_use_iterator iui;
+      gimple use_stmt = NULL;
+
+      if (candidate == op0)
+       {
+         if (limit) *limit = op1;
+         break;
+       }
+      if (candidate == op1)
+       {
+         if (limit) *limit = op0;
+         break;
+       }
+
+      /* Find a single use in the loop header.  Give up if there's
+        multiple ones.  */
+      FOR_EACH_IMM_USE_FAST (use, iui, candidate)
+       {
+         gimple stmt = USE_STMT (use);
+
+         if (gimple_bb (stmt) == loop->header)
+           {
+             if (use_stmt)
+               {
+                 if (dump_file)
+                   {
+                     fprintf (dump_file, "Rejecting ");
+                     print_generic_expr (dump_file, candidate, 0);
+                     fprintf (dump_file, " because it has multiple uses in the loop header (bb #%d).\n",
+                              loop->header->index);
+                     fprintf (dump_file, "first use: ");
+                     print_gimple_stmt (dump_file, use_stmt, 0, 0);
+                     fprintf (dump_file, "\nsecond use: ");
+                     print_gimple_stmt (dump_file, stmt, 0, 0);
+                     fprintf (dump_file, "\n(possibly more, but unanalyzed)\n");
+                   }
+                 return NULL_TREE;
+               }
+             else
+               use_stmt = stmt;
+           }
+       }
+
+      /* No uses in the loop header, bail.  */
+      if (use_stmt == NULL)
+       return NULL_TREE;
+
+      if (gimple_code (use_stmt) != GIMPLE_ASSIGN
+         || TREE_CODE (gimple_assign_lhs (use_stmt)) != SSA_NAME
+         || (gimple_assign_rhs_code (use_stmt) != NOP_EXPR
+             && gimple_assign_rhs_code (use_stmt) != CONVERT_EXPR))
+       {
+         if (dump_file)
+           {
+             fprintf (dump_file, "Rejecting ");
+             print_generic_expr (dump_file, candidate, 0);
+             fprintf (dump_file, " because of use in ");
+             print_gimple_stmt (dump_file, use_stmt, 0, 0);
+             fprintf (dump_file, "\n");
+           }
+         return NULL_TREE;
+       }
+
+      candidate = gimple_assign_lhs (use_stmt);
+    }
+
+  /* CANDIDATE is now what we believe to be the loop index variable.  There
+     are two possibilities:
+
+     - CANDIDATE is not the "true" loop index variable, but rather is a
+       promoted version of RESULT, done for purposes of satisfying a
+       language's semantics;
+
+     - CANDIDATE is the "true" loop index variable.  */
+  if (!types_compatible_p (TREE_TYPE (result), TREE_TYPE (candidate)))
+    candidate = result;
+
+  /* The type of candidate must be "short" to consider promoting it.  */
+  if (TREE_CODE (TREE_TYPE (candidate)) != INTEGER_TYPE
+      || TYPE_PRECISION (TREE_TYPE (candidate)) >= TYPE_PRECISION (size_type_node))
+    return NULL_TREE;
+
+  return candidate;
+}
+
+/* Find the loop index variable of LOOP.  LOOP's exit is controlled by
+   the COND_EXPR EXPR.  IF we can't determine what the loop index
+   variable is, or EXPR does not appear to be analyzable, then return
+   NULL_TREE.  */
+
+static tree
+find_promotion_candidate (struct loop *loop, gimple cond, tree *limit)
+{
+  tree candidate = NULL_TREE;
+  gimple_stmt_iterator gsi;
+
+  switch (gimple_cond_code (cond))
+    {
+    case GT_EXPR:
+    case GE_EXPR:
+    case NE_EXPR:
+    case LT_EXPR:
+    case LE_EXPR:
+      break;
+
+    default:
+      return NULL_TREE;
+    }
+
+  /* We'd like to examine COND and intuit the loop index variable from
+     there.  Instead, we're going to start from the phi nodes in BB and
+     attempt to work our way forwards to one of the operands of COND,
+     since starting from COND might yield an upcast loop index.  If we
+     find multiple phi nodes whose results reach COND, then give up.  */
+  for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+      gimple phi = gsi_stmt (gsi);
+      tree t = find_promotion_candidate_from_phi (loop, cond, phi, limit);
+
+      if (t == NULL_TREE)
+       continue;
+      else if (candidate == NULL_TREE)
+       candidate = t;
+      else
+       {
+         if (dump_file)
+           {
+             fprintf (dump_file, "Can't find a candidate from ");
+             print_gimple_stmt (dump_file, cond, 0, 0);
+             fprintf (dump_file, "\n  because too many phi node results reach the condition.\n");
+           }
+         return NULL_TREE;
+       }
+    }
+
+  return candidate;
+}
+
+/* Return true if X is something that could be promoted.  */
+
+static bool
+could_be_promoted (tree x)
+{
+  return (TREE_CODE (x) == INTEGER_CST
+         || (TREE_CODE (x) == SSA_NAME
+             && pointer_set_contains (promotable_names, x)));
+}
+
+/* Examine the RHS of STMT's suitability with respect to being able to
+   promote VAR.  */
+
+static bool
+check_rhs_for_promotability (struct promote_info *pi, tree var, gimple stmt,
+                            bool is_assign)
+{
+  enum tree_code subcode = gimple_assign_rhs_code (stmt);
+
+  bool ok = true;
+
+  switch (subcode)
+    {
+    case PLUS_EXPR:
+    case MINUS_EXPR:
+    case MULT_EXPR:
+    case EQ_EXPR:
+    case NE_EXPR:
+    case LT_EXPR:
+    case LE_EXPR:
+    case GT_EXPR:
+    case GE_EXPR:
+      {
+       tree op0 = gimple_assign_rhs1 (stmt);
+       tree op1 = gimple_assign_rhs2 (stmt);
+
+       ok = ((op0 == var && could_be_promoted (op1))
+             || (op1 == var && could_be_promoted (op0)));
+       break;
+      }
+    case COND_EXPR:
+      if (gimple_expr_type (stmt) == NULL
+         || gimple_expr_type (stmt) == void_type_node)
+       ok = true;
+      else
+       /* This is conservative; it's possible that these sorts of nodes
+          could be promoted, but we'd have to be very careful about
+          checking in which parts of the COND_EXPR the promotable
+          variable(s) are.  */
+       ok = false;
+      break;
+    case SSA_NAME:
+      {
+       tree expr = gimple_assign_rhs1 (stmt);
+       ok = (expr == var || could_be_promoted (expr));
+      }
+      break;
+    case INTEGER_CST:
+      break;
+    case NOP_EXPR:
+    case CONVERT_EXPR:
+      if (!is_assign)
+       {
+         add_casted_type (pi, gimple_expr_type (stmt));
+         break;
+       }
+      /* Fallthrough.  */
+    default:
+      ok = false;
+      break;
+    }
+
+  return ok;
+}
+
+/* Analyze the loop index VAR for promotability.  The rules for
+   promotability are:
+
+   For uses:
+
+   - The underlying variable may be used in NOP_EXPRs.
+
+   - The underlying variable may be used in simple arithmmetic
+     expressions so long as the other parts are potentially promotable
+     variables or constants (so we don't go willy-nilly on promoting
+     things).
+
+   - The underlying variable may not be stored to memory.
+
+   - All uses must occur inside the loop.
+
+   For defs:
+
+   - The underlying variable may not be loaded from memory; and
+
+   - The underlying variable may only be formed from expressions
+     involving potentially promotable varibles or constants.
+
+   Note that defs may occur outside of the loop; we do this to handle
+   initial conditions before entering the loop.  */
+
+static void
+analyze_loop_index_uses (tree var, struct promote_info *pi)
+{
+  imm_use_iterator iui;
+  use_operand_p use;
+  gimple bad_stmt = NULL;
+  const char *reason = NULL;
+
+  FOR_EACH_IMM_USE_FAST (use, iui, var)
+    {
+      basic_block bb;
+      gimple use_stmt = USE_STMT (use);
+
+      /* Uses must exist only within the loop.  */
+      bb = gimple_bb (use_stmt);
+
+      if (dump_file)
+       {
+         fprintf (dump_file, "Checking ");
+         print_gimple_stmt (dump_file, use_stmt, 0, 0);
+         fprintf (dump_file, "\n");
+       }
+
+      if (!flow_bb_inside_loop_p (pi->loop, bb))
+       {
+         bad_stmt = use_stmt;
+         reason = " is involved in stmt outside loop ";
+         break;
+       }
+
+      /* We cannot store the index to memory.  */
+      if (gimple_references_memory_p (use_stmt))
+       {
+         bad_stmt = use_stmt;
+         reason = " is stored to memory in ";
+         break;
+       }
+
+      if (gimple_code (use_stmt) == GIMPLE_CALL)
+       {
+         /* We cannot pass the variable to a function.  */
+         bad_stmt = use_stmt;
+         reason = " is passed to function in ";
+         break;
+       }
+      else if (gimple_code (use_stmt) == GIMPLE_ASSIGN)
+       {
+         tree lhs = gimple_assign_lhs (use_stmt);
+
+         if (!check_rhs_for_promotability (pi, var, use_stmt,
+                                           /*is_assign=*/false))
+           {
+             bad_stmt = use_stmt;
+             reason = " is involved in non-promotable expression ";
+             break;
+           }
+         else if ((TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt)) == tcc_binary
+                   || gimple_assign_rhs_code (use_stmt) == SSA_NAME)
+                  && !could_be_promoted (lhs))
+           {
+             bad_stmt = use_stmt;
+             reason = " is being assigned to non-promotable variable ";
+             break;
+           }
+       }
+      else if (gimple_code (use_stmt) != GIMPLE_COND
+              && gimple_code (use_stmt) != GIMPLE_PHI)
+       {
+         /* Use of the variable in some statement we don't know how to
+            analyze.  */
+         bad_stmt = use_stmt;
+         reason = " is used in unanalyzable expression in ";
+         break;
+       }
+    }
+
+  if (bad_stmt && reason)
+    {
+      if (dump_file)
+       {
+         fprintf (dump_file, "Loop index ");
+         print_generic_expr (dump_file, var, 0);
+         fprintf (dump_file, "%s", reason);
+         print_gimple_stmt (dump_file, bad_stmt, 0, 0);
+         fprintf (dump_file, "\n");
+       }
+      pi->can_be_promoted_p = false;
+    }
+}
+
+/* Check that the uses and def of VAR, defined in STMT, conform to the
+   rules given above.  */
+
+static bool
+analyze_loop_index (tree var, gimple stmt, void *data)
+{
+  struct promote_info *pi = (struct promote_info *) data;
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Analyzing loop index ");
+      print_generic_expr (dump_file, var, 0);
+      fprintf (dump_file, " defined in ");
+      print_gimple_stmt (dump_file, stmt, 0, 0);
+      fprintf (dump_file, "\n");
+    }
+
+  /* Check the definition.  */
+  switch (gimple_code (stmt))
+    {
+    case GIMPLE_PHI:
+      /* Phi nodes are OK.  */
+      break;
+
+    case GIMPLE_ASSIGN:
+      if (!check_rhs_for_promotability (pi, var, stmt,
+                                       /*is_assign=*/true))
+       break;
+      /* Fallthrough.  */
+
+    default:
+      /* Something we can't handle or the variable is being loaded from
+        memory.  */
+      pi->can_be_promoted_p = false;
+      goto done;
+    }
+
+  if (gimple_code (stmt) == GIMPLE_PHI)
+    {
+      unsigned int i;
+
+      for (i = 0; i < gimple_phi_num_args (stmt); i++)
+       {
+         tree arg = PHI_ARG_DEF (stmt, i);
+
+         if (TREE_CODE (arg) == SSA_NAME)
+           pointer_set_insert (promotable_names, arg);
+       }
+
+      analyze_loop_index_uses (PHI_RESULT (stmt), pi);
+    }
+  else
+    analyze_loop_index_uses (var, pi);
+
+  /* Only worth continuing if we think the loop index can be
+     promoted.  */
+ done:
+  if (dump_file)
+    {
+      fprintf (dump_file, "Done analyzing ");
+      print_generic_expr (dump_file, var, 0);
+      fprintf (dump_file, " defined in ");
+      print_gimple_stmt (dump_file, stmt, 0, 0);
+      fprintf (dump_file, "...%s to analyze\n\n",
+              pi->can_be_promoted_p ? "continuing" : "not continuing");
+    }
+  return !pi->can_be_promoted_p;
+}
+
+/* Determine whether T is an INTEGER_CST or a single-use SSA_NAME
+   defined as the result of a NOP_EXPR or CONVERT_EXPR.  Return the
+   operand of the NOP_EXPR or CONVERT_EXPR if so.  */
+
+static tree
+upcast_operand_p (tree t)
+{
+  gimple def;
+
+  if (TREE_CODE (t) == INTEGER_CST)
+    return t;
+
+  if (TREE_CODE (t) != SSA_NAME
+      || !has_single_use (t))
+    return NULL_TREE;
+
+  def = SSA_NAME_DEF_STMT (t);
+  if (gimple_code (def) != GIMPLE_ASSIGN)
+    return NULL_TREE;
+
+  if (gimple_assign_rhs_code (def) != CONVERT_EXPR
+      && gimple_assign_rhs_code (def) != NOP_EXPR)
+    return NULL_TREE;
+
+  return gimple_assign_rhs1 (def);
+}
+
+/* Check for the idiom:
+
+     short x, y;
+     unsigned short x.2, y.2, tmp;
+     ...
+     x.2 = (unsigned short) x;
+     y.2 = (unsigned short) y;
+     tmp = x.2 + y.2;
+     x = (short) tmp;
+
+   which is generated by convert for avoiding signed arithmetic
+   overflow.  RHS is TMP in the above statement.  If RHS is
+   defined via such an idiom, store x and y into *OP0 and *OP1,
+   respectively.  We permit y.2 to be a constant if necessary.  */
+
+static bool
+signed_arithmetic_overflow_idiom_p (tree rhs, tree *op0, tree *op1)
+{
+  gimple op_stmt = SSA_NAME_DEF_STMT (rhs);
+  tree x2, y2;
+  bool yes = false;
+  enum tree_code code;
+
+  if (!has_single_use (rhs)
+      || gimple_code (op_stmt) != GIMPLE_ASSIGN)
+    goto done;
+
+  /* This could probably profitably be expanded to consider
+     MINUS_EXPR, MULT_EXPR, etc.  */
+  code = gimple_assign_rhs_code (op_stmt);
+  if (code != PLUS_EXPR)
+    goto done;
+  x2 = gimple_assign_rhs1 (op_stmt);
+  y2 = gimple_assign_rhs2 (op_stmt);
+
+  x2 = upcast_operand_p (x2);
+  if (x2 == NULL_TREE)
+    goto done;
+  y2 = upcast_operand_p (y2);
+  if (y2 == NULL_TREE)
+    goto done;
+
+  *op0 = x2;
+  *op1 = y2;
+  yes = true;
+
+ done:
+  return yes;
+}
+
+/* Simple wrapper around flow_bb_inside_loop_p that handles NULL
+   statements and initial definitions of variables.  */
+
+static bool
+stmt_in_loop_p (gimple t, struct loop *loop)
+{
+  basic_block bb;
+
+  if (t == NULL)
+    return false;
+
+  bb = gimple_bb (t);
+  if (bb == NULL)
+    return false;
+
+  return flow_bb_inside_loop_p (loop, bb);
+}
+
+/* The loop index should have a specific usage pattern:
+
+   - It should be defined in a phi node with two incoming values:
+
+     LI_phi = PHI (LI_out, LI_in)
+
+   - One incoming value, LI_out, should be from outside the loop.
+
+   - The other incoming value, LI_in, should be defined thusly:
+
+     LI_in = LI_phi + increment
+
+   - increment should be 1.  We permit other increments with
+     -funsafe-loop-optimizations.
+
+   - Finally, in the comparison to exit the loop, the loop index must be
+     compared against a variable that has a type at least as precise as
+     the loop index's type.  For instance, something like:
+
+       char limit;
+       short i;
+
+       for (i = 0; i < limit; i++) ... 
+
+     would not be permitted.  */
+
+static bool
+analyze_loop_index_definition_pattern (struct promote_info *pi)
+{
+  gimple phi = SSA_NAME_DEF_STMT (pi->loop_index_name);
+  bool ok = false, warn = false;
+  tree in0, in1;
+  bool inside0, inside1;
+  gimple def0, def1;
+  tree op0, op1, increment = NULL_TREE;
+
+  if (gimple_code (phi) != GIMPLE_PHI
+      || gimple_phi_num_args (phi) != 2)
+    goto done;
+
+  in0 = PHI_ARG_DEF (phi, 0);
+  in1 = PHI_ARG_DEF (phi, 1);
+
+  /* Figure out which value comes from outside the loop.  */
+  def0 = TREE_CODE (in0) == SSA_NAME ? SSA_NAME_DEF_STMT (in0) : NULL;
+  def1 = TREE_CODE (in1) == SSA_NAME ? SSA_NAME_DEF_STMT (in1) : NULL;
+
+  inside0 = stmt_in_loop_p (def0, pi->loop);
+  inside1 = stmt_in_loop_p (def1, pi->loop);
+
+  if (inside0 && inside1)
+    goto done;
+  else if (inside0)
+    {
+      tree t = in0;
+      gimple g;
+      in0 = in1;
+      in1 = t;
+      g = def0;
+      def0 = def1;
+      def1 = g;
+    }
+  else if (!inside1)
+    goto done;
+
+  /* IN0 comes from outside the loop, IN1 from inside.  Analyze IN1.  */
+  if (gimple_code (def1) != GIMPLE_ASSIGN)
+    goto done;
+
+  switch (gimple_assign_rhs_code (def1))
+    {
+    case CONVERT_EXPR:
+    case NOP_EXPR:
+      if (!signed_arithmetic_overflow_idiom_p (gimple_assign_rhs1 (def1),
+                                              &op0, &op1))
+       goto done;
+      goto plus;
+    case PLUS_EXPR:
+      op0 = gimple_assign_rhs1 (def1);
+      op1 = gimple_assign_rhs2 (def1);
+    plus:
+      {
+       bool op0_li = op0 == PHI_RESULT (phi);
+       bool op1_li = op1 == PHI_RESULT (phi);
+       if (op0_li && op1_li)
+         /* This is weird, and definitely is not a case we can support
+            for promotion.  */
+         goto done;
+       else if (op0_li)
+         increment = op1;
+       else if (op1_li)
+         increment = op0;
+       else
+         goto done;
+       break;
+      }
+    default:
+      break;
+    }
+
+
+  /* Check that the exit condition for the loop is OK.  */
+  {
+    enum tree_code code = gimple_cond_code (pi->exit_expr);
+
+    op0 = gimple_cond_lhs (pi->exit_expr);
+    op1 = gimple_cond_rhs (pi->exit_expr);
+
+    if (op0 == pi->loop_limit)
+      {
+       tree t = op0;
+       op0 = op1;
+       op1 = t;
+       code = swap_tree_comparison (code);
+      }
+
+    if (code != LT_EXPR && code != LE_EXPR)
+      goto done;
+
+    if (!types_compatible_p (TREE_TYPE (pi->loop_index_name),
+                            TREE_TYPE (pi->loop_limit)))
+      {
+       switch (TREE_CODE (pi->loop_limit))
+         {
+         case INTEGER_CST:
+           if (!int_fits_type_p (pi->loop_limit,
+                                 TREE_TYPE (pi->loop_index_name)))
+             goto done;
+           break;
+         case SSA_NAME:
+           {
+             tree v = pi->loop_limit;
+             gimple def = SSA_NAME_DEF_STMT (v);
+
+             /* Backtrack through CONVERT_EXPRs and/or NOP_EXPRs to
+                determine if the variables "started out" as the same
+                type.  */
+             while (gimple_code (def) == GIMPLE_ASSIGN)
+               {
+                 enum tree_code rhs_code = gimple_assign_rhs_code (def);
+
+                 if (rhs_code != NOP_EXPR && rhs_code != CONVERT_EXPR)
+                   break;
+
+                 v = gimple_assign_rhs1 (def);
+                 def = SSA_NAME_DEF_STMT (v);
+               }
+             /* Permit comparisons between non-compatible types with
+                flag_unsafe_loop_optimizations, since we can assume the
+                loop index does not overflow.  */
+             if (types_compatible_p (TREE_TYPE (pi->loop_index_name),
+                                     TREE_TYPE (v))
+                 || flag_unsafe_loop_optimizations)
+               break;
+             /* Fallthrough.  */
+           default:
+             goto done;
+           }
+         }
+      }
+  }
+
+  if (increment == NULL_TREE)
+    goto done;
+  if (TREE_CODE (increment) != INTEGER_CST
+      || compare_tree_int (increment, 1) != 0)
+    {
+      warn = true;
+      if (!flag_unsafe_loop_optimizations)
+       goto done;
+    }
+
+  ok = true;
+ done:
+  if (warn && !pi->warned)
+    {
+      pi->warned = true;
+      /* We can promote unsigned indices only if -funsafe-loop-optimizations
+        is in effect, since the user might be depending on the modulo
+        wraparound behavior of unsigned types.  */
+      if (warn_unsafe_loop_optimizations)
+       {
+         const char *wording;
+
+         wording = (flag_unsafe_loop_optimizations
+                    ? N_("assuming that the loop counter does not overflow")
+                    : N_("cannot optimize loop, the loop counter may overflow"));
+         warning (OPT_Wunsafe_loop_optimizations, "%s", gettext (wording));
+       }
+    }
+
+  return ok;
+}
+
+/* Analyze the loop associated with PI_ to see if its loop index can be
+   promoted.  */
+
+static bool
+analyze_loop (const void *pi_, void *data)
+{
+  struct promote_info *pi = CONST_CAST (struct promote_info *,
+                                       (const struct promote_info *) pi_);
+  bool *changed = (bool *) data;
+
+  /* We previously determined we can't promote this; go ahead and
+     continue iterating.  */
+  if (pi->loop_index_name == NULL_TREE)
+    return true;
+
+  /* Assume we can always promote the loop index, even if it doesn't
+     exist.  */
+  pi->can_be_promoted_p = true;
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Analyzing ");
+      print_generic_expr (dump_file, pi->loop_index_name, 0);
+      fprintf (dump_file, "\n");
+    }
+
+  if (pi->loop_index_name
+      && analyze_loop_index_definition_pattern (pi))
+    {
+      /* Clear any previously gathered information.  */
+      VEC_truncate (tree, pi->cast_types, 0);
+      VEC_truncate (int, pi->cast_counts, 0);
+
+      walk_use_def_chains (pi->loop_index_name, analyze_loop_index, pi, false);
+    }
+  else
+    pi->can_be_promoted_p = false;
+
+  /* If we determined the loop index is used in strange ways, clear it
+     so we don't examine it again.  */
+  if (!pi->can_be_promoted_p)
+    pi->loop_index_name = NULL_TREE;
+
+  /* Let our caller know whether to re-do the analysis.  */
+  *changed = *changed || !pi->can_be_promoted_p;
+  /* Continue if PI is promotable.  */
+  return pi->can_be_promoted_p;
+}
+
+/* Add PI_->LOOP_INDEX_NAME to the set of variables, DATA, that we are
+   considering for promotion.  */
+
+static bool
+add_variable (const void *pi_, void *data ATTRIBUTE_UNUSED)
+{
+  const struct promote_info *pi = (const struct promote_info *) pi_;
+  struct pointer_set_t *pset = (struct pointer_set_t *) data;
+  int presentp;
+
+  if (pi->loop_index_name != NULL_TREE)
+    {
+      presentp = pointer_set_insert (pset, pi->loop_index_name);
+      gcc_assert (!presentp);
+    }
+
+  /* Continue traversal.  */
+  return true;
+}
+
+/* For each promotable variable:
+
+   - create a new, promoted VAR_DECL;
+
+   - walk through all the uses and defs and create new statements using
+     the promoted variables.  We don't create new phi nodes; post-pass
+     SSA update will handle those for us.  */
+
+/* Make dump files readable.  */
+#define PROMOTED_VAR_SUFFIX ".promoted"
+
+/* Create a variable NAME with TYPE and do the necessary work to inform
+   the SSA machinery about it.  */
+
+static tree
+create_pli_var (tree type, char *name)
+{
+  tree var = create_tmp_var (type, name);
+  create_var_ann (var);
+  mark_sym_for_renaming (var);
+  add_referenced_var (var);
+  return var;
+}
+
+/* Associate the SSA_NAME VAR with the promoted variable DATA.  */
+
+static bool
+associate_name_with_var (tree var, gimple def_stmt, void *data)
+{
+  tree promoted_var = (tree) data;
+  void **p;
+
+  gcc_assert (promoted_var != NULL_TREE);
+
+  if (gimple_code (def_stmt) == GIMPLE_PHI)
+    var = PHI_RESULT (def_stmt);
+
+  p = pointer_map_insert (variable_map, var);
+
+  if (!*p)
+    {
+      if (dump_file)
+       {
+         fprintf (dump_file, "Associating ");
+         print_generic_expr (dump_file, var, 0);
+         fprintf (dump_file, " with ");
+         print_generic_expr (dump_file, promoted_var, 0);
+         fprintf (dump_file, "\n\n");
+       }
+      *(tree *)p = promoted_var;
+    }
+
+  /* Continue traversal.  */
+  return false;
+}
+
+/* Create a promoted variable for the variable from PI_.  */
+
+static bool
+create_promoted_variable (const void *pi_, void *data ATTRIBUTE_UNUSED)
+{
+  struct promote_info *pi = CONST_CAST (struct promote_info *,
+                                       (const struct promote_info *) pi_);
+
+  if (pi->can_be_promoted_p)
+    {
+      tree type = choose_profitable_promoted_type (pi);
+      tree orig_name = DECL_NAME (pi->var_decl);
+      size_t id_len = IDENTIFIER_LENGTH (orig_name);
+      size_t name_len = id_len + strlen (PROMOTED_VAR_SUFFIX) + 1;
+      char *name;
+
+      name = (char *) alloca (name_len);
+      strcpy (name, IDENTIFIER_POINTER (orig_name));
+      strcpy (name + id_len, PROMOTED_VAR_SUFFIX);
+
+      pi->promoted_type = type;
+      pi->promoted_var = create_pli_var (type, name);
+
+      if (dump_file)
+       {
+         fprintf (dump_file, "Created new variable ");
+         print_generic_expr (dump_file, pi->promoted_var, 0);
+         fprintf (dump_file, " to stand in for ");
+         print_generic_expr (dump_file, pi->loop_index_name, 0);
+         fprintf (dump_file, "\n\n");
+       }
+
+      walk_use_def_chains (pi->loop_index_name,
+                          associate_name_with_var,
+                          pi->promoted_var, false);
+    }
+
+  /* Continue traversal.  */
+  return true;
+}
+
+/* Rebuild T with newly promoted variables; STMT is the original
+   statement in which T appeared and may be equivalent to T.  TYPE is
+   non-null when rebuilding the rhs of a GIMPLE_ASSIGN and indicates the
+   type of the lhs.  */
+
+static tree
+rebuild_tree_with_promotion (tree t, gimple stmt, tree type,
+                            gimple_stmt_iterator gsi,
+                            struct promote_info *pi)
+{
+  tree op0, op1;
+
+  switch (TREE_CODE (t))
+    {
+    case NOP_EXPR:
+    case CONVERT_EXPR:
+      {
+       tree pvar = rebuild_tree_with_promotion (TREE_OPERAND (t, 0), stmt, type, gsi, pi);
+
+       if (types_compatible_p (type, TREE_TYPE (pvar)))
+         return pvar;
+       else
+         return build1 (TREE_CODE (t), type, pvar);
+      }
+    case INTEGER_CST:
+      {
+       return build_int_cst_wide (pi->promoted_type,
+                                  TREE_INT_CST_LOW (t),
+                                  TREE_INT_CST_HIGH (t));
+      }
+    case COND_EXPR:
+      {
+       tree orig_op0 = TREE_OPERAND (t, 0);
+       op0 = rebuild_tree_with_promotion (orig_op0, stmt, type, gsi, pi);
+       gcc_assert (orig_op0 != op0);
+       TREE_OPERAND (t, 0) = op0;
+       return t;
+      }
+    case PLUS_EXPR:
+    case MINUS_EXPR:
+    case MULT_EXPR:
+      type = pi->promoted_type;
+      goto binary_expr;
+    case EQ_EXPR:
+    case NE_EXPR:
+    case LT_EXPR:
+    case LE_EXPR:
+    case GT_EXPR:
+    case GE_EXPR:
+      type = TREE_TYPE (t);
+    binary_expr:
+      op0 = TREE_OPERAND (t, 0);
+      op1 = TREE_OPERAND (t, 1);
+      op0 = rebuild_tree_with_promotion (op0, stmt, type, gsi, pi);
+      op1 = rebuild_tree_with_promotion (op1, stmt, type, gsi, pi);
+      return build2 (TREE_CODE (t), type, op0, op1);
+    case SSA_NAME:
+      {
+       void **p = pointer_map_contains (variable_map, t);
+
+       if (p == NULL)
+         {
+           /* This is unexpected, but it does happen if we were dealing
+              with COND_EXPRs and such.  Just go ahead and create a
+              temporary for it.  */
+           if (types_compatible_p (TREE_TYPE (t), pi->promoted_type)
+               || SSA_NAME_DEF_STMT (t) == stmt)
+             return t;
+           else
+             goto insert_cast;
+         }
+       else
+         return *(tree *)p;
+      }
+    case VAR_DECL:
+      return t;
+    default:
+    insert_cast:
+      {
+       gimple cast;
+       tree tmp, nop;
+       tree to_upcast = t;
+
+       /* If we are dealing with a memory reference, then we can't have
+          wrap it in a NOP_EXPR; we need to load the value from memory
+          first, then convert it.  */
+       if (!is_gimple_reg (to_upcast))
+         {
+           tree tmp = create_pli_var (TREE_TYPE (to_upcast),
+                                      CONST_CAST (char *, "loadtmp"));
+           gimple stmt = gimple_build_assign (tmp, to_upcast);
+           gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
+           to_upcast = tmp;
+         }
+
+       tmp = create_pli_var (pi->promoted_type,
+                             CONST_CAST (char *, "promotetmp"));
+       nop = build1 (NOP_EXPR, pi->promoted_type, to_upcast);
+       cast = gimple_build_assign (tmp, nop);
+       if (dump_file)
+         {
+           fprintf (dump_file, "Inserting cast ");
+           print_gimple_stmt (dump_file, cast, 0, 0);
+           fprintf (dump_file, " prior to ");
+           print_gimple_stmt (dump_file, stmt, 0, 0);
+           fprintf (dump_file, "\n");
+         }
+       gsi_insert_before (&gsi, cast, GSI_SAME_STMT);
+       return tmp;
+      }
+    }
+}
+
+/* Split E and place STMT in the block created by doing so.  */
+
+static void
+insert_along_edge (gimple stmt, edge e)
+{
+  basic_block bb = split_edge (e);
+
+  gimple_set_bb (stmt, bb);
+  set_bb_seq (bb, gimple_seq_alloc_with_stmt (stmt));
+}
+
+/* Rebuild STMT, which contains uses or a def of the promotable variable
+   associated with PI.  */
+
+static void
+rebuild_with_promotion (gimple stmt, struct promote_info *pi)
+{
+  gimple_stmt_iterator gsi;
+
+  if (pointer_set_insert (promoted_stmts, stmt))
+    return;
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Rebuilding stmt ");
+      print_gimple_stmt (dump_file, stmt, 0, 0);
+      fprintf (dump_file, "\n");
+    }
+
+  gsi = gsi_for_stmt (stmt);
+  
+  switch (gimple_code (stmt))
+    {
+    case GIMPLE_ASSIGN:
+      {
+       enum tree_code subcode = gimple_assign_rhs_code (stmt);
+       enum tree_code newcode = subcode;
+       tree lhs = gimple_assign_lhs (stmt);
+       tree rhs1 = gimple_assign_rhs1 (stmt);
+       tree rhs2 = gimple_assign_rhs2 (stmt);
+       tree x, y;
+       void **v;
+
+       /* If we are defining a promotable variable, check for special
+          idioms.  */
+       v = pointer_map_contains (variable_map, lhs);
+       if (v != NULL
+           && *(tree *)v == pi->promoted_var
+           && (subcode == NOP_EXPR || subcode == CONVERT_EXPR)
+           && signed_arithmetic_overflow_idiom_p (rhs1, &x, &y))
+         {
+           void **xp;
+           void **yp;
+           if (TYPE_PRECISION (TREE_TYPE (rhs1))
+               >= TYPE_PRECISION (pi->promoted_type))
+             goto done;
+
+           /* It's possible that we've already promoted the operands of
+              one or both of the NOP_EXPRs.  In that case, we can
+              bypass the logic below and go straight to rebuilding the
+              rhs that we really want to transform.  */
+           if (TREE_CODE (x) == VAR_DECL
+               || TREE_CODE (y) == VAR_DECL)
+             goto build_fake;
+           xp = pointer_map_contains (variable_map, x);
+           yp = pointer_map_contains (variable_map, y);
+
+           /* Nothing to see here.  */
+           if (!types_compatible_p (TREE_TYPE (x),
+                                    TREE_TYPE (y))
+               || (xp == NULL && yp == NULL))
+             goto done;
+           x = (xp == NULL ? NULL_TREE : *(tree *)xp);
+           y = (yp == NULL ? NULL_TREE : *(tree *)yp);
+
+           if (x != pi->promoted_var && y != pi->promoted_var)
+             goto done;
+
+         build_fake:
+           newcode = PLUS_EXPR;
+           rhs1 = x;
+           rhs2 = y;
+           if (dump_file)
+             {
+               fprintf (dump_file, "Substituting ");
+               print_generic_expr (dump_file, x, 0);
+               fprintf (dump_file, " + ");
+               print_generic_expr (dump_file, y, 0);
+               fprintf (dump_file, " for rhs of original statement\n");
+             }
+
+         done:
+           ;
+         }
+
+       lhs = rebuild_tree_with_promotion (lhs, stmt, NULL, gsi, pi);
+       rhs1 = rebuild_tree_with_promotion (rhs1, stmt, NULL, gsi, pi);
+       if (rhs2)
+         rhs2 = rebuild_tree_with_promotion (rhs2, stmt, NULL, gsi, pi);
+
+       if (newcode != subcode)
+         {
+           gimple newstmt = gimple_build_assign_with_ops (newcode,
+                                                          lhs, rhs1, rhs2);
+           gsi_replace (&gsi, newstmt, true);
+           stmt = newstmt;
+         }
+       else
+         {
+           gimple_assign_set_lhs (stmt, lhs);
+           gimple_assign_set_rhs1 (stmt, rhs1);
+           if (rhs2)
+             gimple_assign_set_rhs2 (stmt, rhs2);
+         }
+      }
+      break;
+    case GIMPLE_COND:
+      {
+       tree lhs = gimple_cond_lhs (stmt);
+       tree rhs = gimple_cond_rhs (stmt);
+
+       lhs = rebuild_tree_with_promotion (lhs, stmt, NULL, gsi, pi);
+       rhs = rebuild_tree_with_promotion (rhs, stmt, NULL, gsi, pi);
+
+       gimple_cond_set_lhs (stmt, lhs);
+       gimple_cond_set_rhs (stmt, rhs);
+      }
+      break;
+    case GIMPLE_PHI:
+      {
+	unsigned int i;
+	bool promoted_result = could_be_promoted (PHI_RESULT (stmt));
+
+	for (i = 0; i < gimple_phi_num_args (stmt); i++)
+	  {
+	    tree var = gimple_phi_arg_def (stmt, i);
+	    edge e = gimple_phi_arg_edge (stmt, i);
+	    gimple assign = NULL;
+
+	    if (TREE_CODE (var) == INTEGER_CST && promoted_result)
+	      {
+		tree cst = build_int_cst_wide (pi->promoted_type,
+					       TREE_INT_CST_LOW (var),
+					       TREE_INT_CST_HIGH (var));
+
+		assign = gimple_build_assign (pi->promoted_var, cst);
+		insert_along_edge (assign, e);
+	      }
+	    else if (TREE_CODE (var) == SSA_NAME
+		     && SSA_NAME_VAR (var) == pi->var_decl
+		     && !promoted_result)
+	      {
+		tree t = create_pli_var (TREE_TYPE (PHI_RESULT (stmt)),
+					 CONST_CAST (char *, "promotetmp"));
+		tree name;
+		assign = gimple_build_assign_with_ops (CONVERT_EXPR,
+						       t, pi->promoted_var,
+						       NULL_TREE);
+
+		name = make_ssa_name (t, assign);
+		gimple_assign_set_lhs (assign, name);
+
+		insert_along_edge (assign, e);
+		SET_PHI_ARG_DEF (stmt, i, name);
+	      }
+	  }
+      }
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Converted stmt ");
+      print_gimple_stmt (dump_file, stmt, 0, 0);
+      fprintf (dump_file, "\n\n");
+    }
+  update_stmt (stmt);
+}
+
+/* Helper function for promote_variable that walks over use/def
+   chains.  */
+
+static bool
+promote_variable_1 (tree var, gimple stmt, void *data)
+{
+  struct promote_info *pi = (struct promote_info *) data;
+  imm_use_iterator imi;
+  gimple use_stmt;
+
+  rebuild_with_promotion (stmt, pi);
+
+  if (gimple_code (stmt) == GIMPLE_PHI)
+    var = PHI_RESULT (stmt);
+
+  if (could_be_promoted (var))
+    FOR_EACH_IMM_USE_STMT (use_stmt, imi, var)
+      {
+	rebuild_with_promotion (use_stmt, pi);
+      }
+
+  return false;
+}
+
+/* Convert all uses and defs of PI_->LOOP_INDEX_NAME as linked by
+   use-def chains to uses and defs of PI_->PROMOTED_VAR.  */
+
+static bool
+promote_variable (const void *pi_, void *data ATTRIBUTE_UNUSED)
+{
+  const struct promote_info *pi = (const struct promote_info *) pi_;
+
+  if (pi->can_be_promoted_p)
+    {
+      walk_use_def_chains (pi->loop_index_name, promote_variable_1,
+                          CONST_CAST (struct promote_info *, pi), false);
+    }
+
+  /* Continue traversal.  */
+  return true;
+}
+
+/* Free PI_ and its associated data.  */
+
+static bool
+free_pi_entries (const void *pi_, void *data ATTRIBUTE_UNUSED)
+{
+  struct promote_info *pi = CONST_CAST (struct promote_info *,
+                                       (const struct promote_info *) pi_);
+
+  VEC_free (tree, heap, pi->cast_types);
+  VEC_free (int, heap, pi->cast_counts);
+  free (pi);
+
+  /* Continue traversal.  */
+  return true;
+}
+
+/* Collect information about variables that we believe to be loop
+   indices in PROMOTION_INFO.  */
+
+static void
+collect_promotion_candidates (void)
+{
+  loop_iterator li;
+  struct loop *loop;
+
+  FOR_EACH_LOOP (li, loop, 0)
+    {
+      basic_block header = loop->header;
+      gimple exit_cond = last_stmt (header);
+      
+      if (exit_cond && gimple_code (exit_cond) == GIMPLE_COND)
+       {
+         tree loop_index;
+         tree limit = NULL_TREE;
+         tree decl;
+         struct promote_info *pi;
+
+         loop_index = find_promotion_candidate (loop, exit_cond, &limit);
+         if (loop_index == NULL_TREE)
+           continue;
+         decl = SSA_NAME_VAR (loop_index);
+         if (TREE_ADDRESSABLE (decl))
+           continue;
+
+         if (dump_file)
+           {
+             fprintf (dump_file, "Found loop index ");
+             print_generic_expr (dump_file, loop_index, 0);
+             fprintf (dump_file, " involved in ");
+             print_gimple_stmt (dump_file, exit_cond, 0, 0);
+             fprintf (dump_file, "\n\n");
+           }
+
+         pi = XCNEW (struct promote_info);
+         pi->loop = loop;
+         pi->exit_expr = exit_cond;
+         pi->loop_index_name = loop_index;
+         pi->loop_limit = limit;
+         pi->var_decl = decl;
+         /* We think so, anyway...  */
+         pi->can_be_promoted_p = true;
+         pointer_set_insert (promotion_info, pi);
+       }
+      else if (dump_file)
+       {
+         fprintf (dump_file, "\nSkipping analysis of loop %d (header bb #%d)\n",
+                  loop->num, loop->header->index);
+         if (exit_cond)
+           {
+             fprintf (dump_file, "Exit condition was ");
+             print_gimple_stmt (dump_file, exit_cond, 0, 0);
+             fprintf (dump_file, "\n");
+           }
+       }
+    }
+}
+
+/* Free memory associated with global variables that we used.  */
+
+static void
+pli_cleanup (void)
+{
+  if (promoted_stmts)
+    {
+      pointer_set_destroy (promoted_stmts);
+      promoted_stmts = NULL;
+    }
+  if (variable_map)
+    {
+      pointer_map_destroy (variable_map);
+      variable_map = NULL;
+    }
+  if (promotable_names)
+    {
+      pointer_set_destroy (promotable_names);
+      promotable_names = NULL;
+    }
+  if (promotion_info)
+    {
+      pointer_set_traverse (promotion_info, free_pi_entries, NULL);
+      pointer_set_destroy (promotion_info);
+      promotion_info = NULL;
+    }
+}
+
+/* The guts of the pass.  */
+
+static unsigned int
+promote_short_indices (void)
+{
+  bool did_something = false;
+  bool changed;
+  size_t max_iterations, i, n_promoted;
+
+  promotion_info = pointer_set_create ();
+  collect_promotion_candidates ();
+
+  if (dump_file)
+    fprintf (dump_file, "Found %d candidates for promotion\n",
+            (int) pointer_set_n_elements (promotion_info));
+
+  /* Nothing to do.  */
+  if (pointer_set_n_elements (promotion_info) == 0)
+    goto cleanup;
+
+  /* We have information about which variables are loop index variables.
+     We now need to determine the promotability of the loop indices.
+     Since the promotability of loop indices may depend on other loop
+     indices, we need to repeat this until we reach a fixed point.  */
+  changed = true;
+  max_iterations = pointer_set_n_elements (promotion_info);
+  i = 0;
+
+  promotable_names = pointer_set_create ();
+
+  while (changed)
+    {
+      changed = false;
+      pointer_set_clear (promotable_names);
+      pointer_set_traverse (promotion_info, add_variable,
+                           promotable_names);
+      n_promoted = pointer_set_n_elements (promotable_names);
+
+      if (dump_file)
+       fprintf (dump_file, "\nIteration %d, have %d variables to consider\n",
+                (int) i, (int) n_promoted);
+
+      if (n_promoted == 0)
+       break;
+      gcc_assert (i < max_iterations);
+      pointer_set_traverse (promotion_info, analyze_loop, &changed);
+      i++;
+    }
+
+  if (dump_file)
+    fprintf (dump_file, "Promoting %d variables\n",
+            (int) n_promoted);
+
+  if (n_promoted != 0)
+    {
+      did_something = true;
+      variable_map = pointer_map_create ();
+      promoted_stmts = pointer_set_create ();
+      pointer_set_traverse (promotion_info, create_promoted_variable, NULL);
+      pointer_set_traverse (promotion_info, promote_variable, NULL);
+    }
+
+ cleanup:
+  pli_cleanup ();
+  return did_something ? TODO_update_ssa : 0;
+}
+
+/* Entry point for the short loop index promotion pass.  */
+
+static unsigned int
+tree_short_index_promotion (void)
+{
+  unsigned int changed = 0;
+
+  /* Initialize all the necessary loop infrastructure.  */
+  loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES | LOOPS_HAVE_RECORDED_EXITS);
+  add_noreturn_fake_exit_edges ();
+  connect_infinite_loops_to_exit ();
+
+  if (number_of_loops () > 1)
+    changed = promote_short_indices ();
+
+  /* Tear down loop optimization infrastructure.  */
+  remove_fake_exit_edges ();
+  free_numbers_of_iterations_estimates ();
+  loop_optimizer_finalize ();
+
+  return changed;
+}
+
+static bool
+gate_short_index_promotion (void)
+{
+  return optimize > 0 && flag_promote_loop_indices;
+}
+
+struct gimple_opt_pass pass_promote_indices =
+{
+  {
+    GIMPLE_PASS,
+    "promoteshort",                    /* name */
+    gate_short_index_promotion,                /* gate */
+    tree_short_index_promotion,                /* execute */
+    NULL,                              /* sub */
+    NULL,                              /* next */
+    0,                                 /* static_pass_number */
+    TV_TREE_LOOP_PROMOTE,              /* tv_id */
+    PROP_cfg | PROP_ssa,               /* properties_required */
+    0,                                 /* properties_provided */
+    0,                                 /* properties_destroyed */
+    0,                                 /* todo_flags_start */
+    TODO_dump_func | TODO_verify_loops 
+    | TODO_ggc_collect                 /* todo_flags_finish */
+  }
+};
diff -Nur a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
--- a/gcc/tree-ssa-pre.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/tree-ssa-pre.c	2010-01-25 09:50:29.595686516 +0100
@@ -104,6 +104,10 @@
    In order to make it fully redundant, we insert the expression into
    the predecessors where it is not available, but is ANTIC.
 
+   When optimizing for size, we only eliminate the partial redundancy
+   if we need to insert in only one predecessor.  This avoids almost
+   completely the code size increase that PRE usually causes.
+
    For the partial anticipation case, we only perform insertion if it
    is partially anticipated in some block, and fully available in all
    of the predecessors.
@@ -429,6 +433,7 @@
 static void bitmap_value_insert_into_set (bitmap_set_t, pre_expr);
 static void bitmap_value_replace_in_set (bitmap_set_t, pre_expr);
 static void bitmap_set_copy (bitmap_set_t, bitmap_set_t);
+static void bitmap_set_and (bitmap_set_t, bitmap_set_t);
 static bool bitmap_set_contains_value (bitmap_set_t, unsigned int);
 static void bitmap_insert_into_set (bitmap_set_t, pre_expr);
 static void bitmap_insert_into_set_1 (bitmap_set_t, pre_expr, bool);
@@ -2988,13 +2993,6 @@
   tree temp;
   gimple phi;
 
-  if (dump_file && (dump_flags & TDF_DETAILS))
-    {
-      fprintf (dump_file, "Found partial redundancy for expression ");
-      print_pre_expr (dump_file, expr);
-      fprintf (dump_file, " (%04d)\n", val);
-    }
-
   /* Make sure we aren't creating an induction variable.  */
   if (block->loop_depth > 0 && EDGE_COUNT (block->preds) == 2
       && expr->kind != REFERENCE)
@@ -3192,6 +3190,47 @@
 }
 
 
+/* Indicate if, when optimizing for speed, it is appropriate to make
+   INSERTS_NEEDED insertions in order to make EXPR in BLOCK redundant.  */
+static bool
+ppre_n_insert_for_speed_p (pre_expr expr, basic_block block,
+			   unsigned int inserts_needed)
+{
+  /* The more expensive EXPR is, the more we should be prepared to insert
+     in the predecessors of BLOCK to make EXPR fully redundant.
+     For now, only recognize AND, OR, XOR, PLUS and MINUS of a multiple-use
+     SSA_NAME with a constant as cheap.  */
+  int cost;
+
+  if (flag_tree_pre_partial_partial_obliviously)
+    return true;
+  if (expr->kind == NARY)
+    {
+      vn_nary_op_t nary = PRE_EXPR_NARY (expr);
+      switch (nary->opcode)
+	{
+	  tree name, cnst;
+	case BIT_AND_EXPR: case BIT_IOR_EXPR: case BIT_XOR_EXPR:
+	case PLUS_EXPR: case MINUS_EXPR:
+
+	  gcc_assert (nary->length == 2);
+	  name = nary->op[0];
+	  cnst = nary->op[1];
+	  if (TREE_CODE (name) != SSA_NAME || has_single_use (name))
+	    return true;
+	  if (!is_gimple_min_invariant (cnst))
+	    return true;
+	  cost = 1;
+	  break;
+	default:
+	  return true;
+	}
+    }
+  else
+    return true;
+  return EDGE_COUNT (block->preds) * cost >= inserts_needed;
+
+}
 
 /* Perform insertion of partially redundant values.
    For BLOCK, do the following:
@@ -3226,6 +3265,7 @@
 	  pre_expr *avail;
 	  unsigned int val;
 	  bool by_some = false;
+	  unsigned int inserts_needed = 0;
 	  bool cant_insert = false;
 	  bool all_same = true;
 	  pre_expr first_s = NULL;
@@ -3280,6 +3320,7 @@
 		{
 		  avail[bprime->index] = eprime;
 		  all_same = false;
+		  inserts_needed++;
 		}
 	      else
 		{
@@ -3289,6 +3330,11 @@
 		    first_s = edoubleprime;
 		  else if (!pre_expr_eq (first_s, edoubleprime))
 		    all_same = false;
+		  /* If the available value is not a NAME, PREing this
+		     value will probably result in a copy on the edge
+		     to assign the expression to a register.  */
+		  if (edoubleprime->kind != NAME)
+		    inserts_needed++;
 		}
 	    }
 	  /* If we can insert it, it's not the same value
@@ -3297,9 +3343,27 @@
 	     partially redundant.  */
 	  if (!cant_insert && !all_same && by_some && dbg_cnt (treepre_insert))
 	    {
-	      if (insert_into_preds_of_block (block, get_expression_id (expr),
-					      avail))
-		new_stuff = true;
+  	      if (dump_file && (dump_flags & TDF_DETAILS))
+		{
+		  fprintf (dump_file,
+			   "Found partial redundancy for expression ");
+		  print_pre_expr (dump_file, expr);
+		  fprintf (dump_file, " (%04d)\n", get_expr_value_id (expr));
+		}
+
+	      /* If optimizing for size, insert at most one
+		 new expression to avoid increasing code size.  */
+	      if (optimize_function_for_speed_p (cfun)
+		  ? 1 : EDGE_COUNT (block->preds) - inserts_needed == 1)
+		new_stuff |=
+		  insert_into_preds_of_block (block,
+					      get_expression_id (expr),
+					      avail);
+	      else if (dump_file && (dump_flags & TDF_DETAILS))
+		fprintf (dump_file, "Not inserting (optimizing for %s)\n",
+			 optimize_function_for_speed_p (cfun)
+			 ? "speed" : "size");
+
 	    }
 	  /* If all edges produce the same value and that value is
 	     an invariant, then the PHI has the same value on all
@@ -3428,9 +3492,28 @@
 	  if (!cant_insert && by_all && dbg_cnt (treepre_insert))
 	    {
 	      pre_stats.pa_insert++;
-	      if (insert_into_preds_of_block (block, get_expression_id (expr),
-					      avail))
-		new_stuff = true;
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		{
+		  fprintf (dump_file,
+			   "Found partial redundancy for expression ");
+		  print_pre_expr (dump_file, expr);
+		  fprintf (dump_file, " (%04d)\n", get_expr_value_id (expr));
+		}
+	      /* Assuming the expression is 50% anticipatable, we have to
+		 multiply the number of insertions needed by two for a cost
+		 comparison.  */
+	      if (!optimize_function_for_speed_p (cfun)
+		  || ppre_n_insert_for_speed_p (expr, block,
+						2 * EDGE_COUNT (block->preds)))
+		new_stuff |=
+		  insert_into_preds_of_block (block,
+					      get_expression_id (expr),
+					      avail);
+	      else if (dump_file && (dump_flags & TDF_DETAILS))
+		fprintf (dump_file, "Not inserting (optimizing for %s)\n",
+			 optimize_function_for_speed_p (cfun)
+			 ? "speed" : "size");
+
 	    }
 	  free (avail);
 	}
@@ -3471,7 +3554,9 @@
 	  if (!single_pred_p (block))
 	    {
 	      new_stuff |= do_regular_insertion (block, dom);
-	      if (do_partial_partial)
+	      /* Don't bother with partial-partial redundancies when
+		 optimizing for size.  */
+	      if (do_partial_partial && ! optimize_function_for_size_p (cfun))
 		new_stuff |= do_partial_partial_insertion (block, dom);
 	    }
 	}
@@ -4220,11 +4305,11 @@
    only wants to do full redundancy elimination.  */
 
 static unsigned int
-execute_pre (bool do_fre ATTRIBUTE_UNUSED)
+execute_pre (bool do_fre)
 {
   unsigned int todo = 0;
 
-  do_partial_partial = optimize > 2;
+  do_partial_partial = flag_tree_pre_partial_partial;
 
   /* This has to happen before SCCVN runs because
      loop_optimizer_init may create new phis, etc.  */
@@ -4297,19 +4382,20 @@
   return todo;
 }
 
-/* Gate and execute functions for PRE.  */
+/* Gate and execute functions for FRE/PRE.  */
 
 static unsigned int
 do_pre (void)
 {
-  return TODO_rebuild_alias | execute_pre (false);
+  return TODO_rebuild_alias
+	 | execute_pre (! flag_tree_pre);
 }
 
 static bool
 gate_pre (void)
 {
-  /* PRE tends to generate bigger code.  */
-  return flag_tree_pre != 0 && optimize_function_for_speed_p (cfun);
+  /* Run FRE even if we don't run PRE.  */
+  return (flag_tree_fre || flag_tree_pre);
 }
 
 struct gimple_opt_pass pass_pre =
diff -Nur a/gcc/tree-ssa-remove-local-statics.c b/gcc/tree-ssa-remove-local-statics.c
--- a/gcc/tree-ssa-remove-local-statics.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gcc/tree-ssa-remove-local-statics.c	2010-01-25 09:50:29.595686516 +0100
@@ -0,0 +1,868 @@
+/* Local static variable elimination pass.
+   Copyright (C) 2007 Free Software Foundation, Inc.
+   Contributed by Nathan Froyd <froydnj@codesourcery.com>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3, or (at your option) any
+later version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Converting static function-local variables to automatic variables.
+
+   The motivating example is a function like:
+
+   void
+   foo (unsigned n)
+   {
+     static int var;
+     unsigned i;
+
+     for (i = 0; i != n; i++)
+       {
+         var = ...
+
+         do other things with var...
+       }
+   }
+
+   Because VAR is static, doing things like code motion to loads and
+   stores of VAR is difficult.  Furthermore, accesses to VAR are
+   inefficient.  This pass aims to recognize the cases where it is not
+   necessary for VAR to be static and modify the code so that later
+   passes will do the appropriate optimizations.
+
+   The criteria for a static function-local variable V in a function F
+   being converted to an automatic variable are:
+
+   1. F does not call setjmp; and
+   2. V's address is never taken; and
+   3. V is not declared volatile; and
+   4. V is not used in any nested function;
+   5. V is not an aggregate value (union, struct, array, etc.); and
+   6. Every use of V is defined along all paths leading to the use.
+
+   NOTE: For ease of implementation, we currently treat a function call
+   as killing all previous definitions of static variables, since we
+   could have:
+
+   static void
+   foo (...)
+   {
+     static int x;
+
+     x = ...;       (1)
+
+    f (...);        (2)
+
+     ... = x;       (3)
+   }
+
+   The use at (3) needs to pick up a possible definition made by the
+   call at (2).  If the call at (2) does not call back into 'foo',
+   then the call is not a killing call.  We currently treat it as
+   though it is.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+
+#include "rtl.h"
+#include "tm_p.h"
+#include "hard-reg-set.h"
+#include "obstack.h"
+#include "basic-block.h"
+
+#include "tree.h"
+#include "gimple.h"
+#include "hashtab.h"
+#include "diagnostic.h"
+#include "tree-flow.h"
+#include "tree-dump.h"
+#include "flags.h"
+#include "timevar.h"
+#include "tree-pass.h"
+
+struct rls_decl_info
+{
+  /* The variable declaration.  */
+  tree orig_var;
+
+  /* Its index in rls_block_local_data.  */
+  int index;
+
+  /* Whether we can optimize this variable.  */
+  bool optimizable_p;
+
+  /* The new variable declaration, if we can optimize away the staticness
+     of 'orig_var'.  */
+  tree new_var;
+};
+
+/* Filled with 'struct rls_decl_info'; keyed off ORIG_VAR.  */
+static htab_t static_variables;
+
+struct rls_stmt_info
+{
+  /* The variable declaration.  */
+  tree var;
+
+  /* The statement in which we found a def or a use of the variable.  */
+  gimple stmt;
+
+  /* Whether STMT represents a use of VAR.  */
+  bool use_p;
+
+  /* A bitmap whose entries denote what variables have been defined
+     when execution arrives at STMT.  This field is only used when
+     USE_P is true.  */
+  sbitmap defined;
+};
+
+/* Filled with 'struct rls_stmt_info'; keyed off STMT.  */
+static htab_t defuse_statements;
+
+static struct
+{
+  /* The number of static variables we found.  */
+  size_t n_statics;
+
+  /* The number of optimizable variables we found.  */
+  size_t n_optimizable;
+} stats;
+
+struct rls_block_dataflow_data {
+  /* A bitmap whose entries denote what variables have been defined on
+     entry to this block.  */
+  sbitmap defined_in;
+
+  /* A bitmap whose entries denote what variables have been defined on
+     exit from this block.  */
+  sbitmap defined_out;
+};
+
+/* Parameters for the 'static_variables' hash table.  */
+
+static hashval_t
+rls_hash_decl_info (const void *x)
+{
+  return htab_hash_pointer
+    ((const void *) ((const struct rls_decl_info *) x)->orig_var);
+}
+
+static int
+rls_eq_decl_info (const void *x, const void *y)
+{
+  const struct rls_decl_info *a = (const struct rls_decl_info *) x;
+  const struct rls_decl_info *b = (const struct rls_decl_info *) y;
+
+  return a->orig_var == b->orig_var;
+}
+
+static void
+rls_free_decl_info (void *info)
+{
+  free (info);
+}
+
+/* Parameters for the 'defuse_statements' hash table.  */
+
+static hashval_t
+rls_hash_use_info (const void *x)
+{
+  return htab_hash_pointer
+    ((const void *) ((const struct rls_stmt_info *) x)->stmt);
+}
+
+static int
+rls_eq_use_info (const void *x, const void *y)
+{
+  const struct rls_stmt_info *a = (const struct rls_stmt_info *) x;
+  const struct rls_stmt_info *b = (const struct rls_stmt_info *) y;
+
+  return a->stmt == b->stmt;
+}
+
+static void
+rls_free_use_info (void *info)
+{
+  struct rls_stmt_info *stmt_info = (struct rls_stmt_info *) info;
+
+  if (stmt_info->defined)
+    sbitmap_free (stmt_info->defined);
+
+  free (stmt_info);
+}
+
+/* Initialize data structures and statistics.  */
+
+static void
+rls_init (void)
+{
+  basic_block bb;
+
+  /* We expect relatively few static variables, hence the small
+     initial size for the hash table.  */
+  static_variables = htab_create (8, rls_hash_decl_info,
+                                  rls_eq_decl_info, rls_free_decl_info);
+
+  /* We expect quite a few statements.  */
+  defuse_statements = htab_create (128, rls_hash_use_info,
+                                   rls_eq_use_info, rls_free_use_info);
+
+  FOR_ALL_BB (bb)
+    {
+      struct rls_block_dataflow_data *data;
+
+      data = XNEW (struct rls_block_dataflow_data);
+      memset (data, 0, sizeof (*data));
+      bb->aux = data;
+    }
+
+  stats.n_statics = 0;
+  stats.n_optimizable = 0;
+}
+
+/* Free data structures.  */
+
+static void
+rls_done (void)
+{
+  basic_block bb;
+
+  htab_delete (static_variables);
+  htab_delete (defuse_statements);
+
+  FOR_ALL_BB (bb)
+    {
+      struct rls_block_dataflow_data *data
+	= (struct rls_block_dataflow_data *) bb->aux;
+
+      gcc_assert (data);
+
+      if (data->defined_in)
+	sbitmap_free (data->defined_in);
+      if (data->defined_out)
+	sbitmap_free (data->defined_out);
+      free (data);
+      bb->aux = NULL;
+    }
+}
+
+
+/* Doing the initial work to find static variables.  */
+
+/* Examine the defining statement for VAR and determine whether it is a
+   static variable we could potentially optimize.  If so, stick in it
+   in the 'static_variables' hashtable.
+
+   STMT is the statement in which a definition or use of VAR occurs.
+   USE_P indicates whether VAR is used or defined in STMT.  Enter STMT
+   into 'defuse_statements' as well for use during dataflow
+   analysis.  */
+
+static void
+maybe_discover_new_declaration (tree var, gimple stmt, bool use_p)
+{
+  tree def_stmt = SSA_NAME_VAR (var);
+
+  if (TREE_CODE (def_stmt) == VAR_DECL
+      && DECL_CONTEXT (def_stmt) != NULL_TREE
+      && TREE_CODE (DECL_CONTEXT (def_stmt)) == FUNCTION_DECL
+      /* We cannot optimize away a static used in multiple functions (as
+	 might happen in C++).  */
+      && !DECL_NONLOCAL(def_stmt)
+      && TREE_STATIC (def_stmt)
+      /* We cannot optimize away aggregate statics, as we would have to
+	 prove that definitions of every field of the aggregate dominate
+	 uses.  */
+      && !AGGREGATE_TYPE_P (TREE_TYPE (def_stmt))
+      /* GCC doesn't normally treat vectors as aggregates; we need to,
+	 though, since a user could use intrinsics to read/write
+	 particular fields of the vector, thereby treating it as an
+	 array.  */
+      && TREE_CODE (TREE_TYPE (def_stmt)) != VECTOR_TYPE
+      && !TREE_ADDRESSABLE (def_stmt)
+      && !TREE_THIS_VOLATILE (def_stmt))
+    {
+      struct rls_decl_info dummy;
+      void **slot;
+
+      dummy.orig_var = def_stmt;
+      slot = htab_find_slot (static_variables, &dummy, INSERT);
+
+      if (*slot == NULL)
+        {
+          /* Found a use or a def of a new declaration.  */
+          struct rls_decl_info *info = XNEW (struct rls_decl_info);
+
+          info->orig_var = def_stmt;
+          info->index = stats.n_statics++;
+          /* Optimistically assume that we can optimize.  */
+          info->optimizable_p = true;
+          info->new_var = NULL_TREE;
+          *slot = (void *) info;
+        }
+
+      /* Enter the statement into DEFUSE_STATEMENTS.  */
+      {
+        struct rls_stmt_info dummy;
+        struct rls_stmt_info *info;
+
+        dummy.stmt = stmt;
+        slot = htab_find_slot (defuse_statements, &dummy, INSERT);
+
+        /* We should never insert the same statement into the
+           hashtable twice.  */
+        gcc_assert (*slot == NULL
+		    || ((struct rls_stmt_info *)(*slot))->stmt == stmt);
+
+	if (*slot != NULL && ((struct rls_stmt_info *)(*slot))->stmt == stmt)
+	  return;
+
+        info = XNEW (struct rls_stmt_info);
+        info->var = def_stmt;
+        info->stmt = stmt;
+        if (dump_file)
+          {
+            fprintf (dump_file, "entering as %s ", use_p ? "use" : "def");
+            print_gimple_stmt (dump_file, stmt, 0, TDF_DETAILS | TDF_VOPS);
+          }
+        info->use_p = use_p;
+        /* We don't know how big to make the bitmap yet.  */
+        info->defined = NULL;
+        *slot = (void *) info;
+      }
+    }
+}
+
+/* Grovel through all the statements in the program, looking for
+   SSA_NAMEs whose SSA_NAME_VAR is a VAR_DECL.  We look at both use and
+   def SSA_NAMEs.  */
+
+static void
+find_static_nonvolatile_declarations (void)
+{
+  basic_block bb;
+
+  FOR_EACH_BB (bb)
+    {
+      gimple_stmt_iterator i;
+
+      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))
+        {
+          tree var;
+          ssa_op_iter iter;
+	  gimple stmt = gsi_stmt (i);
+
+	  /* If there's a call expression in STMT, then previous passes
+	     will have determined if the call transitively defines some
+	     static variable.  However, we need more precise
+	     information--we need to know whether static variables are
+	     live out after the call.
+
+	     Since we'll never see something like:
+
+	       staticvar = foo (bar, baz);
+
+	     in GIMPLE (the result of the call will be assigned to a
+	     normal, non-static local variable which is then assigned to
+	     STATICVAR in a subsequent statement), don't bother finding
+	     new declarations if we see a GIMPLE_CALL.
+	     
+	     In a similar fashion, asm statements that clobber memory
+	     will appear to define static variables.  In general,
+	     however, assuming that asm statements define static
+	     variables would cause us to see that in the following
+	     situation:
+
+	       static int foo = 0;
+
+	       __asm__ (... : "memory");
+	       foo++;
+
+	     foo could be unstaticized because the asm has "defined"
+	     foo.  This is likely false.  (Even if the asm does happen
+	     to define foo--and only foo--that situation would be
+	     sufficiently unusual that not optimizing it seems OK.)  */
+	  if (gimple_code (stmt) != GIMPLE_CALL
+	      && gimple_code (stmt) != GIMPLE_ASM)
+	    FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_VDEF)
+	      {
+		maybe_discover_new_declaration (var, stmt, false);
+	      }
+
+          FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_VUSE)
+            {
+              maybe_discover_new_declaration (var, stmt, true);
+            }
+        }
+    }
+}
+
+
+/* Determining if we have anything to optimize.  */
+
+/* Examine *SLOT (which is a 'struct rls_decl_info *') to see whether
+   the associated variable is optimizable.  If it is, create a new,
+   non-static declaration for the variable; this new variable will be
+   used during a subsequent rewrite of the function.  */
+
+#define NEW_VAR_PREFIX ".unstatic"
+
+static int
+maybe_create_new_variable (void **slot, void *data ATTRIBUTE_UNUSED)
+{
+  struct rls_decl_info *info = (struct rls_decl_info *) *slot;
+  tree id_node = DECL_NAME (info->orig_var);
+  size_t id_len = IDENTIFIER_LENGTH (id_node);
+  size_t name_len = id_len + strlen (NEW_VAR_PREFIX) + 1;
+  char *name;
+
+  /* Don't create a new variable multiple times.  */
+  gcc_assert (!info->new_var);
+
+  /* Tie the new name to the old one to aid debugging dumps.  */
+  name = (char *) alloca (name_len);
+  strcpy (name, IDENTIFIER_POINTER (id_node));
+  strcpy (name + id_len, NEW_VAR_PREFIX);
+  info->new_var = create_tmp_var (TREE_TYPE (info->orig_var), name);
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "new variable ");
+      print_generic_expr (dump_file, info->new_var, 0);
+      fprintf (dump_file, "\n");
+    }
+
+  /* Inform SSA about this new variable.  */
+  create_var_ann (info->new_var);
+  mark_sym_for_renaming (info->new_var);
+  /* We need to make sure we rebuild bits for the original variable,
+     such as virtual operands attached to statements.  */
+  mark_sym_for_renaming (info->orig_var);
+  add_referenced_var (info->new_var);
+
+  /* Always continue scanning.  */
+  return 1;
+}
+
+#undef NEW_VAR_PREFIX
+
+/* Traverse the 'defuse_statements' hash table.  For every use,
+   determine if the associated variable is defined along all paths
+   leading to said use.  Remove the associated variable from
+   'static_variables' if it is not.  */
+
+static int
+check_definedness (void **slot, void *data ATTRIBUTE_UNUSED)
+{
+  struct rls_stmt_info *info = (struct rls_stmt_info *) *slot;
+  struct rls_decl_info dummy;
+
+  /* We don't need to look at definitions.  Continue scanning.  */
+  if (!info->use_p)
+    return 1;
+
+  dummy.orig_var = info->var;
+  slot = htab_find_slot (static_variables, &dummy, INSERT);
+
+  /* Might not be there because we deleted it already.  */
+  if (*slot)
+    {
+      struct rls_decl_info *decl = (struct rls_decl_info *) *slot;
+
+      if (!TEST_BIT (info->defined, decl->index))
+        {
+          if (dump_file)
+            {
+              fprintf (dump_file, "not optimizing ");
+              print_generic_expr (dump_file, decl->orig_var, 0);
+              fprintf (dump_file, "due to uncovered use in ");
+              print_gimple_stmt (dump_file, info->stmt, 0, 0);
+              fprintf (dump_file, "\n");
+            }
+
+          htab_clear_slot (static_variables, slot);
+          stats.n_optimizable--;
+        }
+    }
+
+  /* Continue scan.  */
+  return 1;
+}
+
+/* Check all statements in 'defuse_statements' to see if all the
+   statements that use a static variable have that variable defined
+   along all paths leading to the statement.  Once that's done, go
+   through and create new, non-static variables for any static variables
+   that can be optimized.  */
+
+static size_t
+determine_optimizable_statics (void)
+{
+  htab_traverse (defuse_statements, check_definedness, NULL);
+
+  htab_traverse (static_variables, maybe_create_new_variable, NULL);
+
+  return stats.n_optimizable;
+}
+
+/* Look at STMT to see if we have uses or defs of a static variable.
+   STMT is passed in DATA.  Definitions of a static variable are found
+   by the presence of a V_MUST_DEF, while uses are found by the presence
+   of a VUSE.  */
+
+static int
+unstaticize_variable (void **slot, void *data)
+{
+  struct rls_decl_info *info = (struct rls_decl_info *) *slot;
+  gimple stmt = (gimple) data;
+  tree vdef;
+  tree vuse;
+  int continue_scan = 1;
+
+  /* We should have removed unoptimizable variables during an earlier
+     traversal.  */
+  gcc_assert (info->optimizable_p);
+
+  /* Check for virtual definitions first.  */
+  vdef = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_VDEF);
+
+  if (vdef != NULL
+      && ZERO_SSA_OPERANDS (stmt, SSA_OP_DEF)
+      && gimple_code (stmt) == GIMPLE_ASSIGN
+      && TREE_CODE (gimple_assign_lhs (stmt)) == VAR_DECL
+      && gimple_assign_lhs(stmt) == info->orig_var)
+    {
+      /* Make the statement define the new name.  The new name has
+         already been marked for renaming, so no need to do that
+         here.  */
+      gimple_assign_set_lhs (stmt, info->new_var);
+      if (dump_file)
+	{
+	  fprintf (dump_file, "found virtual definition!\n");
+	  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS | TDF_DETAILS);
+	  fprintf (dump_file, "\n");
+	}
+      continue_scan = 0;
+      goto done;
+    }
+
+  /* Check for virtual uses.  */
+  vuse = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_VUSE);
+
+  if (vuse != NULL
+      && gimple_code (stmt) == GIMPLE_ASSIGN
+      && gimple_assign_rhs_code (stmt) == VAR_DECL
+      && gimple_assign_rhs1 (stmt) == info->orig_var)
+    {
+      /* Make the statement use the new name.  */
+      gimple_assign_set_rhs1 (stmt, info->new_var);
+      if (dump_file)
+	{
+	  fprintf (dump_file, "found virtual use!\n");
+	  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS | TDF_DETAILS);
+	  fprintf (dump_file, "\n");
+	}
+      continue_scan = 0;
+      goto done;
+    }
+
+ done:
+  if (!continue_scan)
+    {
+      /* None of the other optimizable static variables can occur
+         in this statement.  Stop the scan.  */
+      update_stmt (stmt);
+
+      if (dump_file)
+	{
+	  fprintf (dump_file, "updated stmt\n");
+	  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS | TDF_DETAILS);
+	}
+    }
+
+  return continue_scan;
+}
+
+/* Determine if we have any static variables we can optimize.  If so,
+   replace any defs or uses of those variables in their defining/using
+   statements.  */
+
+static void
+maybe_remove_static_from_declarations (void)
+{
+  size_t n_optimizable = determine_optimizable_statics ();
+  basic_block bb;
+
+  if (n_optimizable)
+    /* Replace any optimizable variables with new, non-static variables.  */
+    FOR_EACH_BB (bb)
+      {
+        gimple_stmt_iterator gsi;
+
+        for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+          {
+            gimple stmt = gsi_stmt (gsi);
+
+            htab_traverse (static_variables, unstaticize_variable, stmt);
+          }
+      }
+}
+
+/* Callback for htab_traverse to initialize the bitmap for *SLOT, which
+   is a 'struct rls_stmt_info'.  */
+
+static int
+initialize_statement_dataflow (void **slot, void *data ATTRIBUTE_UNUSED)
+{
+  struct rls_stmt_info *info = (struct rls_stmt_info *) *slot;
+
+  gcc_assert (!info->defined);
+
+  if (info->use_p)
+    {
+      info->defined = sbitmap_alloc (stats.n_statics);
+      /* Assume defined along all paths until otherwise informed.  */
+      sbitmap_ones (info->defined);
+    }
+
+  /* Continue traversal.  */
+  return 1;
+}
+
+/* We have N_STATICS static variables to consider.  Go through all the
+   blocks and all the use statements to initialize their bitmaps.  */
+
+static void
+initialize_block_and_statement_dataflow (size_t n_statics)
+{
+  basic_block bb;
+
+  FOR_ALL_BB (bb)
+    {
+      struct rls_block_dataflow_data *data
+	= (struct rls_block_dataflow_data *) bb->aux;
+
+      gcc_assert (data);
+
+      data->defined_in = sbitmap_alloc (n_statics);
+      sbitmap_zero (data->defined_in);
+      data->defined_out = sbitmap_alloc (n_statics);
+      sbitmap_zero (data->defined_out);
+    }
+
+  htab_traverse (defuse_statements, initialize_statement_dataflow, NULL);
+}
+
+/* Apply the individual effects of the stmts in BB to update the
+   dataflow analysis information for BB.  */
+
+static void
+compute_definedness_for_block (basic_block bb)
+{
+  bool changed_p = false;
+  struct rls_block_dataflow_data *data
+	= (struct rls_block_dataflow_data *) bb->aux;
+  gimple_stmt_iterator gsi;
+
+  sbitmap_copy (data->defined_out, data->defined_in);
+
+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+      gimple stmt = gsi_stmt (gsi);
+
+      if (gimple_code (stmt) == GIMPLE_CALL)
+	/* If there's a call expression in STMT, then previous passes
+	   will have determined if the call transitively defines some
+	   static variable.  However, we need more precise
+	   information--we need to know whether static variables are
+	   live out after the call.  In the absence of such information,
+	   simply declare that all static variables are clobbered by the
+	   call.  A better analysis would be interprocedural and compute
+	   the liveness information we require, but for now, we're being
+	   pessimistic.  */
+	sbitmap_zero (data->defined_out);
+      else 
+	{
+	  struct rls_stmt_info dummy;
+	  void **slot;
+
+	  /* See if this statement uses or defines a static variable.  */
+	  dummy.stmt = stmt;
+	  slot = htab_find_slot (defuse_statements, &dummy, INSERT);
+
+	  /* Check for uses.  */
+	  if (*slot != NULL)
+	    {
+	      struct rls_stmt_info *info = (struct rls_stmt_info *) *slot;
+
+	      if (info->use_p)
+		{
+		  gcc_assert (info->defined);
+
+		  /* Found a statement that uses a function-local static
+		     variable.  Copy the current state of definedness.  */
+		  sbitmap_copy (info->defined, data->defined_out);
+		}
+	      else
+		{
+		  struct rls_decl_info dummy;
+		  struct rls_decl_info *decl;
+
+		  gcc_assert (!info->defined);
+
+		  /* Found a statement that defines a function-local static
+		     variable.  Look up the associated variable's information
+		     and mark it as defined in the block.  */
+		  dummy.orig_var = info->var;
+		  slot = htab_find_slot (static_variables, &dummy, INSERT);
+
+		  gcc_assert (*slot);
+
+		  decl = (struct rls_decl_info *) *slot;
+
+		  SET_BIT (data->defined_out, decl->index);
+		  changed_p |= true;
+		}
+	    }
+	}
+    }
+}
+
+/* Solve the dataflow equations:
+
+   DEFINED_IN(b) = intersect DEFINED_OUT(p) for p in preds(b)
+   DEFINED_OUT(b) = VARIABLES_DEFINED (b, DEFINED_IN (b))
+
+   via a simple iterative solver.  VARIABLES_DEFINED is computed by
+   'compute_definedness_for_block'.  */
+
+static void
+compute_definedness (void)
+{
+  basic_block bb;
+  bool changed_p;
+  sbitmap tmp_bitmap = sbitmap_alloc (stats.n_statics);
+
+  /* Compute initial sets.  */
+  FOR_EACH_BB (bb)
+    {
+      compute_definedness_for_block (bb);
+    }
+
+  /* Iterate.  */
+  do {
+    changed_p = false;
+
+    FOR_EACH_BB (bb)
+      {
+        edge e;
+        edge_iterator ei;
+        struct rls_block_dataflow_data *data
+	  = (struct rls_block_dataflow_data *) bb->aux;
+        bool bitmap_changed_p = false;
+
+        sbitmap_ones (tmp_bitmap);
+
+        gcc_assert (data);
+
+        /* We require information about whether a variable was defined
+           over all paths leading to a particular use.  Therefore, we
+           intersect the DEFINED sets of all predecessors.  */
+        FOR_EACH_EDGE (e, ei, bb->preds)
+          {
+            struct rls_block_dataflow_data *pred_data
+	      = (struct rls_block_dataflow_data *) e->src->aux;
+
+            gcc_assert (pred_data);
+
+            sbitmap_a_and_b (tmp_bitmap, tmp_bitmap, pred_data->defined_out);
+          }
+
+        bitmap_changed_p = !sbitmap_equal (tmp_bitmap, data->defined_in);
+
+        if (bitmap_changed_p)
+          {
+            sbitmap_copy (data->defined_in, tmp_bitmap);
+            compute_definedness_for_block (bb);
+          }
+
+        changed_p |= bitmap_changed_p;
+      }
+  } while (changed_p);
+
+  sbitmap_free (tmp_bitmap);
+}
+
+static unsigned int
+execute_rls (void)
+{
+  rls_init ();
+
+  find_static_nonvolatile_declarations ();
+
+  /* Can we optimize anything?  */
+  if (stats.n_statics != 0)
+    {
+      stats.n_optimizable = stats.n_statics;
+
+      if (dump_file)
+        fprintf (dump_file, "found %d static variables to consider\n",
+                 stats.n_statics);
+
+      initialize_block_and_statement_dataflow (stats.n_statics);
+
+      compute_definedness ();
+
+      maybe_remove_static_from_declarations ();
+
+      if (dump_file)
+        fprintf (dump_file, "removed %d static variables\n",
+                 stats.n_optimizable);
+    }
+
+  rls_done ();
+
+  return 0;
+}
+
+static bool
+gate_rls (void)
+{
+  return (flag_remove_local_statics != 0
+          && !cfun->calls_setjmp
+          && !cgraph_node (current_function_decl)->ever_was_nested);
+}
+
+struct gimple_opt_pass pass_remove_local_statics =
+{
+  {
+    GIMPLE_PASS,
+    "remlocstatic",               /* name */
+    gate_rls,                     /* gate */
+    execute_rls,                  /* execute */
+    NULL,                         /* sub */
+    NULL,                         /* next */
+    0,                            /* static_pass_number */
+    TV_TREE_RLS,                  /* tv_id */
+    PROP_cfg | PROP_ssa,          /* properties_required */
+    0,                            /* properties_provided */
+    0,                            /* properties_destroyed */
+    0,                            /* todo_flags_start */
+    TODO_dump_func | TODO_verify_ssa | TODO_verify_stmts
+    | TODO_rebuild_alias | TODO_update_ssa /* todo_flags_finish */
+  }
+};
diff -Nur a/gcc/tree-ssa-sink.c b/gcc/tree-ssa-sink.c
--- a/gcc/tree-ssa-sink.c	2009-02-20 16:20:38.000000000 +0100
+++ b/gcc/tree-ssa-sink.c	2010-01-25 09:50:29.595686516 +0100
@@ -449,6 +449,47 @@
 	  last = false;
 	  continue;
 	}      
+
+      /* We cannot move statements that contain references to block-scope
+	 variables out of that block, as this may lead to incorrect aliasing
+	 when we lay out the stack frame in cfgexpand.c.
+	 In lieu of more sophisticated analysis, be very conservative here
+	 and prohibit moving any statement that references memory out of a
+	 block with variables.  */
+      if (gimple_references_memory_p (stmt))
+	{
+	  tree fromblock = gimple_block (stmt);
+	  while (fromblock
+		 && fromblock != current_function_decl
+		 && !BLOCK_VARS (fromblock))
+	    fromblock = BLOCK_SUPERCONTEXT (fromblock);
+	  if (fromblock && fromblock != current_function_decl)
+	    {
+	      gimple tostmt;
+	      tree toblock;
+
+	      if (gsi_end_p (togsi))
+		tostmt = gimple_seq_last_stmt (gsi_seq (togsi));
+	      else
+		tostmt = gsi_stmt (togsi);
+	      if (tostmt)
+		toblock = gimple_block (tostmt);
+	      else
+		toblock = NULL;
+	      while (toblock
+		     && toblock != current_function_decl
+		     && toblock != fromblock)
+		toblock = BLOCK_SUPERCONTEXT (toblock);
+	      if (!toblock || toblock != fromblock)
+		{
+		  if (!gsi_end_p (gsi))
+		    gsi_prev (&gsi);
+		  last = false;
+		  continue;
+		}
+	    }
+	}
+
       if (dump_file)
 	{
 	  fprintf (dump_file, "Sinking ");
diff -Nur a/gcc/tree-ssa-structalias.c b/gcc/tree-ssa-structalias.c
--- a/gcc/tree-ssa-structalias.c	2009-03-23 17:29:33.000000000 +0100
+++ b/gcc/tree-ssa-structalias.c	2010-01-25 09:50:29.595686516 +0100
@@ -2926,7 +2926,8 @@
   /* Some people like to do cute things like take the address of
      &0->a.b */
   forzero = t;
-  while (!SSA_VAR_P (forzero) && !CONSTANT_CLASS_P (forzero))
+  while (!SSA_VAR_P (forzero) && TREE_CODE (forzero) != FUNCTION_DECL
+	 && !CONSTANT_CLASS_P (forzero))
     forzero = TREE_OPERAND (forzero, 0);
 
   if (CONSTANT_CLASS_P (forzero) && integer_zerop (forzero))
diff -Nur a/gcc/tree-vect-analyze.c b/gcc/tree-vect-analyze.c
--- a/gcc/tree-vect-analyze.c	2009-06-30 13:56:21.000000000 +0200
+++ b/gcc/tree-vect-analyze.c	2010-01-25 09:50:29.595686516 +0100
@@ -1459,7 +1459,7 @@
     }
 
   base = build_fold_indirect_ref (base_addr);
-  alignment = ssize_int (TYPE_ALIGN (vectype)/BITS_PER_UNIT);
+  alignment = ssize_int (targetm.vectorize.vector_min_alignment (vectype));
 
   if ((aligned_to && tree_int_cst_compare (aligned_to, alignment) < 0)
       || !misalign)
@@ -1510,7 +1510,8 @@
   /* At this point we assume that the base is aligned.  */
   gcc_assert (base_aligned
 	      || (TREE_CODE (base) == VAR_DECL 
-		  && DECL_ALIGN (base) >= TYPE_ALIGN (vectype)));
+		  && (DECL_ALIGN (base)
+		      >= targetm.vectorize.vector_min_alignment (vectype))));
 
   /* Modulo alignment.  */
   misalign = size_binop (TRUNC_MOD_EXPR, misalign, alignment);
diff -Nur a/gcc/tree-vectorizer.c b/gcc/tree-vectorizer.c
--- a/gcc/tree-vectorizer.c	2009-03-18 16:29:28.000000000 +0100
+++ b/gcc/tree-vectorizer.c	2010-01-25 09:50:29.595686516 +0100
@@ -2868,11 +2868,13 @@
        vnode = vnode->next_needed)
     {
       tree vectype, decl = vnode->decl;
+      tree t;
       unsigned int alignment;
 
-      if (TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE)
+      t = TREE_TYPE(decl);
+      if (TREE_CODE (t) != ARRAY_TYPE)
 	continue;
-      vectype = get_vectype_for_scalar_type (TREE_TYPE (TREE_TYPE (decl)));
+      vectype = get_vectype_for_scalar_type (strip_array_types (t));
       if (!vectype)
 	continue;
       alignment = TYPE_ALIGN (vectype);
@@ -2887,6 +2889,7 @@
 	    { 
 	      fprintf (dump_file, "Increasing alignment of decl: ");
 	      print_generic_expr (dump_file, decl, TDF_SLIM);
+	      fprintf (dump_file, "\n");
 	    }
 	}
     }
diff -Nur a/gcc/tree-vect-transform.c b/gcc/tree-vect-transform.c
--- a/gcc/tree-vect-transform.c	2009-04-20 09:09:01.000000000 +0200
+++ b/gcc/tree-vect-transform.c	2010-01-25 09:50:29.595686516 +0100
@@ -5442,7 +5442,21 @@
 	       vect_permute_store_chain().  */
 	    vec_oprnd = VEC_index (tree, result_chain, i);
 
-	  data_ref = build_fold_indirect_ref (dataref_ptr);
+	  if (alignment_support_scheme == dr_aligned
+	      && !targetm.vectorize.always_misalign(vectype))
+	    {
+	      data_ref = build_fold_indirect_ref (dataref_ptr);
+	    }
+	  else
+	    {
+	      /* TODO: Record actual alignment in always_misalign case.  */
+	      int mis = DR_MISALIGNMENT (first_dr);
+	      tree tmis;
+	      tmis = (mis == -1 ? size_zero_node : size_int (mis));
+	      tmis = size_binop (MULT_EXPR, tmis, size_int(BITS_PER_UNIT));
+	      data_ref =
+		build2 (MISALIGNED_INDIRECT_REF, vectype, dataref_ptr, tmis);
+	    }
 
 	  /* Arguments are ready. Create the new vector stmt.  */
 	  new_stmt = gimple_build_assign (data_ref, vec_oprnd);
@@ -6621,10 +6635,15 @@
 	    {
 	    case dr_aligned:
 	      gcc_assert (aligned_access_p (first_dr));
-	      data_ref = build_fold_indirect_ref (dataref_ptr);
-	      break;
+	      if (!targetm.vectorize.always_misalign(vectype))
+		{
+		  data_ref = build_fold_indirect_ref (dataref_ptr);
+		  break;
+		}
+	      /* Fall through... */
 	    case dr_unaligned_supported:
 	      {
+		/* TODO: Record actual alignment in always_misalign case.  */
 		int mis = DR_MISALIGNMENT (first_dr);
 		tree tmis = (mis == -1 ? size_zero_node : size_int (mis));
 
@@ -7595,7 +7614,7 @@
   gimple dr_stmt = DR_STMT (dr);
   stmt_vec_info stmt_info = vinfo_for_stmt (dr_stmt);
   tree vectype = STMT_VINFO_VECTYPE (stmt_info);
-  int vectype_align = TYPE_ALIGN (vectype) / BITS_PER_UNIT;
+  int vectype_align = targetm.vectorize.vector_min_alignment (vectype);
   tree niters_type = TREE_TYPE (loop_niters);
   int step = 1;
   int element_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));
diff -Nur a/gcc/unwind-dw2.c b/gcc/unwind-dw2.c
--- a/gcc/unwind-dw2.c	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/unwind-dw2.c	2010-01-25 09:50:29.595686516 +0100
@@ -1414,16 +1414,12 @@
 /* Fill in CONTEXT for top-of-stack.  The only valid registers at this
    level will be the return address and the CFA.  */
 
-#define uw_init_context(CONTEXT)					   \
-  do									   \
-    {									   \
-      /* Do any necessary initialization to access arbitrary stack frames. \
-	 On the SPARC, this means flushing the register windows.  */	   \
-      __builtin_unwind_init ();						   \
-      uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),		   \
-			 __builtin_return_address (0));			   \
-    }									   \
-  while (0)
+#define uw_init_context(CONTEXT)					\
+  /* Do any necessary initialization to access arbitrary stack frames.	\
+     On the SPARC, this means flushing the register windows.  */	\
+  (__builtin_unwind_init (),						\
+   uw_init_context_1 ((CONTEXT), __builtin_dwarf_cfa (),		\
+		      __builtin_return_address (0)))
 
 static inline void
 init_dwarf_reg_size_table (void)
@@ -1431,7 +1427,7 @@
   __builtin_init_dwarf_reg_size_table (dwarf_reg_size_table);
 }
 
-static void
+static _Unwind_Reason_Code
 uw_init_context_1 (struct _Unwind_Context *context,
 		   void *outer_cfa, void *outer_ra)
 {
@@ -1445,7 +1441,8 @@
   context->flags = EXTENDED_CONTEXT_BIT;
 
   code = uw_frame_state_for (context, &fs);
-  gcc_assert (code == _URC_NO_REASON);
+  if (code != _URC_NO_REASON)
+    return code;
 
 #if __GTHREADS
   {
@@ -1471,6 +1468,8 @@
      initialization context, then we can't see it in the given
      call frame data.  So have the initialization context tell us.  */
   context->ra = __builtin_extract_return_addr (outer_ra);
+
+  return _URC_NO_REASON;
 }
 
 
diff -Nur a/gcc/unwind.inc b/gcc/unwind.inc
--- a/gcc/unwind.inc	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/unwind.inc	2010-01-25 09:50:29.595686516 +0100
@@ -85,7 +85,8 @@
   _Unwind_Reason_Code code;
 
   /* Set up this_context to describe the current stack frame.  */
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   /* Phase 1: Search.  Unwind the stack, calling the personality routine
@@ -198,7 +199,8 @@
   struct _Unwind_Context this_context, cur_context;
   _Unwind_Reason_Code code;
 
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   exc->private_1 = (_Unwind_Ptr) stop;
@@ -221,7 +223,8 @@
   struct _Unwind_Context this_context, cur_context;
   _Unwind_Reason_Code code;
 
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   /* Choose between continuing to process _Unwind_RaiseException
@@ -251,7 +254,8 @@
   if (exc->private_1 == 0)
     return _Unwind_RaiseException (exc);
 
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);
@@ -280,7 +284,9 @@
   struct _Unwind_Context context;
   _Unwind_Reason_Code code;
 
-  uw_init_context (&context);
+  code = uw_init_context (&context);
+  if (code != _URC_NO_REASON)
+    return _URC_FATAL_PHASE1_ERROR;
 
   while (1)
     {
diff -Nur a/gcc/unwind-sjlj.c b/gcc/unwind-sjlj.c
--- a/gcc/unwind-sjlj.c	2009-04-10 01:23:07.000000000 +0200
+++ b/gcc/unwind-sjlj.c	2010-01-25 09:50:29.595686516 +0100
@@ -292,10 +292,11 @@
   uw_update_context (context, fs);
 }
 
-static inline void
+static inline _Unwind_Reason_Code
 uw_init_context (struct _Unwind_Context *context)
 {
   context->fc = _Unwind_SjLj_GetContext ();
+  return _URC_NO_REASON;
 }
 
 static void __attribute__((noreturn))
diff -Nur a/gcc/varasm.c b/gcc/varasm.c
--- a/gcc/varasm.c	2009-03-17 21:18:21.000000000 +0100
+++ b/gcc/varasm.c	2010-01-25 09:50:29.595686516 +0100
@@ -1126,11 +1126,14 @@
     {
 #ifdef DATA_ALIGNMENT
       unsigned int data_align = DATA_ALIGNMENT (TREE_TYPE (decl), align);
+#else
+      unsigned int data_align = align;
+#endif
+      data_align = alignment_for_aligned_arrays (TREE_TYPE (decl), data_align);
       /* Don't increase alignment too much for TLS variables - TLS space
 	 is too precious.  */
       if (! DECL_THREAD_LOCAL_P (decl) || data_align <= BITS_PER_WORD)
 	align = data_align;
-#endif
 #ifdef CONSTANT_ALIGNMENT
       if (DECL_INITIAL (decl) != 0 && DECL_INITIAL (decl) != error_mark_node)
 	{
@@ -3196,6 +3199,10 @@
   set_mem_alias_set (rtl, 0);
   set_mem_alias_set (rtl, const_alias_set);
 
+  /* We cannot share RTX'es in pool entries.
+     Mark this piece of RTL as required for unsharing.  */
+  RTX_FLAG (rtl, used) = 1;
+
   /* Set flags or add text to the name to record information, such as
      that it is a local symbol.  If the name is changed, the macro
      ASM_OUTPUT_LABELREF will have to know how to strip this
diff -Nur a/gcc/vmsdbgout.c b/gcc/vmsdbgout.c
--- a/gcc/vmsdbgout.c	2008-08-29 20:41:19.000000000 +0200
+++ b/gcc/vmsdbgout.c	2010-01-25 09:50:29.595686516 +0100
@@ -211,6 +211,7 @@
    debug_nothing_int,		  /* handle_pch */
    debug_nothing_rtx,		  /* var_location */
    debug_nothing_void,            /* switch_text_section */
+   debug_nothing_tree_tree,	  /* set_name */
    0                              /* start_end_main_source_file */
 };
 
diff -Nur a/include/libiberty.h b/include/libiberty.h
--- a/include/libiberty.h	2008-06-24 03:42:31.000000000 +0200
+++ b/include/libiberty.h	2010-01-25 09:50:29.595686516 +0100
@@ -591,6 +591,10 @@
 
 extern int pwait (int, int *, int);
 
+/* Convert a Cygwin path to a Windows path.  */
+
+extern int cygpath (const char *, char []);
+
 #if !HAVE_DECL_ASPRINTF
 /* Like sprintf but provides a pointer to malloc'd storage, which must
    be freed by the caller.  */
diff -Nur a/libcpp/directives.c b/libcpp/directives.c
--- a/libcpp/directives.c	2009-04-10 01:23:07.000000000 +0200
+++ b/libcpp/directives.c	2010-01-25 09:50:29.595686516 +0100
@@ -2299,13 +2299,6 @@
   run_directive (pfile, type, str, count);
 }
 
-/* The number of errors for a given reader.  */
-unsigned int
-cpp_errors (cpp_reader *pfile)
-{
-  return pfile->errors;
-}
-
 /* The options structure.  */
 cpp_options *
 cpp_get_options (cpp_reader *pfile)
diff -Nur a/libcpp/errors.c b/libcpp/errors.c
--- a/libcpp/errors.c	2009-04-10 01:23:07.000000000 +0200
+++ b/libcpp/errors.c	2010-01-25 09:50:29.595686516 +0100
@@ -28,171 +28,69 @@
 #include "cpplib.h"
 #include "internal.h"
 
-static void print_location (cpp_reader *, source_location, unsigned int);
-
-/* Print the logical file location (LINE, COL) in preparation for a
-   diagnostic.  Outputs the #include chain if it has changed.  A line
-   of zero suppresses the include stack, and outputs the program name
-   instead.  */
-static void
-print_location (cpp_reader *pfile, source_location line, unsigned int col)
-{
-  if (line == 0)
-    fprintf (stderr, "%s: ", progname);
-  else
-    {
-      const struct line_map *map;
-      linenum_type lin;
-
-      map = linemap_lookup (pfile->line_table, line);
-      linemap_print_containing_files (pfile->line_table, map);
-
-      lin = SOURCE_LINE (map, line);
-      if (col == 0)
-	{
-	  col = SOURCE_COLUMN (map, line);
-	  if (col == 0)
-	    col = 1;
-	}
-
-      if (lin == 0)
-	fprintf (stderr, "%s:", map->to_file);
-      else if (CPP_OPTION (pfile, show_column) == 0)
-	fprintf (stderr, "%s:%u:", map->to_file, lin);
-      else
-	fprintf (stderr, "%s:%u:%u:", map->to_file, lin, col);
-
-      fputc (' ', stderr);
-    }
-}
-
-/* Set up for a diagnostic: print the file and line, bump the error
-   counter, etc.  SRC_LOC is the logical line number; zero means to print
-   at the location of the previously lexed token, which tends to be
-   the correct place by default.  The column number can be specified either
-   using COLUMN or (if COLUMN==0) extracting SOURCE_COLUMN from SRC_LOC.
-   (This may seem redundant, but is useful when pre-scanning (cleaning) a line,
-   when we haven't yet verified whether the current line_map has a
-   big enough max_column_hint.)
-
-   Returns 0 if the error has been suppressed.  */
-static int
-_cpp_begin_message (cpp_reader *pfile, int code,
-		    source_location src_loc, unsigned int column)
-{
-  int level = CPP_DL_EXTRACT (code);
-
-  switch (level)
-    {
-    case CPP_DL_WARNING:
-    case CPP_DL_PEDWARN:
-      if (cpp_in_system_header (pfile)
-	  && ! CPP_OPTION (pfile, warn_system_headers))
-	return 0;
-      /* Fall through.  */
-
-    case CPP_DL_WARNING_SYSHDR:
-      if (CPP_OPTION (pfile, warnings_are_errors)
-	  || (level == CPP_DL_PEDWARN && CPP_OPTION (pfile, pedantic_errors)))
-	{
-	  if (CPP_OPTION (pfile, inhibit_errors))
-	    return 0;
-	  level = CPP_DL_ERROR;
-	  pfile->errors++;
-	}
-      else if (CPP_OPTION (pfile, inhibit_warnings))
-	return 0;
-      break;
-
-    case CPP_DL_ERROR:
-      if (CPP_OPTION (pfile, inhibit_errors))
-	return 0;
-      /* ICEs cannot be inhibited.  */
-    case CPP_DL_ICE:
-      pfile->errors++;
-      break;
-    }
-
-  print_location (pfile, src_loc, column);
-  if (CPP_DL_WARNING_P (level))
-    fputs (_("warning: "), stderr);
-  else if (level == CPP_DL_ICE)
-    fputs (_("internal error: "), stderr);
-  else
-    fputs (_("error: "), stderr);
-
-  return 1;
-}
-
-/* Don't remove the blank before do, as otherwise the exgettext
-   script will mistake this as a function definition */
-#define v_message(msgid, ap) \
- do { vfprintf (stderr, _(msgid), ap); putc ('\n', stderr); } while (0)
-
-/* Exported interface.  */
-
 /* Print an error at the location of the previously lexed token.  */
-void
+bool
 cpp_error (cpp_reader * pfile, int level, const char *msgid, ...)
 {
   source_location src_loc;
   va_list ap;
-  
+  bool ret;
+
   va_start (ap, msgid);
 
-  if (CPP_OPTION (pfile, client_diagnostic))
-    pfile->cb.error (pfile, level, _(msgid), &ap);
-  else
+  if (CPP_OPTION (pfile, traditional))
     {
-      if (CPP_OPTION (pfile, traditional))
-	{
-	  if (pfile->state.in_directive)
-	    src_loc = pfile->directive_line;
-	  else
-	    src_loc = pfile->line_table->highest_line;
-	}
-      /* We don't want to refer to a token before the beginning of the
-	 current run -- that is invalid.  */
-      else if (pfile->cur_token == pfile->cur_run->base)
-	{
-	  if (pfile->cur_run->prev != NULL)
-	    src_loc = pfile->cur_run->prev->limit->src_loc;
-	  else
-	    src_loc = 0;
-	}
+      if (pfile->state.in_directive)
+	src_loc = pfile->directive_line;
       else
-	{
-	  src_loc = pfile->cur_token[-1].src_loc;
-	}
-
-      if (_cpp_begin_message (pfile, level, src_loc, 0))
-	v_message (msgid, ap);
+	src_loc = pfile->line_table->highest_line;
+    }
+  /* We don't want to refer to a token before the beginning of the
+     current run -- that is invalid.  */
+  else if (pfile->cur_token == pfile->cur_run->base)
+    {
+      if (pfile->cur_run->prev != NULL)
+	src_loc = pfile->cur_run->prev->limit->src_loc;
+      else
+	src_loc = 0;
     }
+  else
+    {
+      src_loc = pfile->cur_token[-1].src_loc;
+    }
+
+  if (!pfile->cb.error)
+    abort ();
+  ret = pfile->cb.error (pfile, level, src_loc, 0, _(msgid), &ap);
 
   va_end (ap);
+  return ret;
 }
 
 /* Print an error at a specific location.  */
-void
+bool
 cpp_error_with_line (cpp_reader *pfile, int level,
 		     source_location src_loc, unsigned int column,
 		     const char *msgid, ...)
 {
   va_list ap;
+  bool ret;
   
   va_start (ap, msgid);
 
-  if (_cpp_begin_message (pfile, level, src_loc, column))
-    v_message (msgid, ap);
+  if (!pfile->cb.error)
+    abort ();
+  ret = pfile->cb.error (pfile, level, src_loc, column, _(msgid), &ap);
 
   va_end (ap);
+  return ret;
 }
 
-void
+bool
 cpp_errno (cpp_reader *pfile, int level, const char *msgid)
 {
   if (msgid[0] == '\0')
     msgid = _("stdout");
 
-  cpp_error (pfile, level, "%s: %s", msgid, xstrerror (errno));
+  return cpp_error (pfile, level, "%s: %s", msgid, xstrerror (errno));
 }
diff -Nur a/libcpp/files.c b/libcpp/files.c
--- a/libcpp/files.c	2009-04-10 01:23:07.000000000 +0200
+++ b/libcpp/files.c	2010-01-25 09:50:29.605686739 +0100
@@ -488,7 +488,6 @@
 	      return file;
 	    }
 
-	  open_file_failed (pfile, file, angle_brackets);
 	  if (invalid_pch)
 	    {
 	      cpp_error (pfile, CPP_DL_ERROR,
@@ -497,6 +496,7 @@
 		cpp_error (pfile, CPP_DL_ERROR,
 			   "use -Winvalid-pch for more information");
 	    }
+	  open_file_failed (pfile, file, angle_brackets);
 	  break;
 	}
 
@@ -934,15 +934,28 @@
 
   errno = file->err_no;
   if (print_dep && CPP_OPTION (pfile, deps.missing_files) && errno == ENOENT)
-    deps_add_dep (pfile->deps, file->name);
+    {
+      deps_add_dep (pfile->deps, file->name);
+      /* If the preprocessor output (other than dependency information) is
+         being used, we must also flag an error.  */
+      if (CPP_OPTION (pfile, deps.need_preprocessor_output))
+	cpp_errno (pfile, CPP_DL_FATAL, file->path);
+    }
   else
     {
-      /* If we are outputting dependencies but not for this file then
-	 don't error because we can still produce correct output.  */
-      if (CPP_OPTION (pfile, deps.style) && ! print_dep)
-	cpp_errno (pfile, CPP_DL_WARNING, file->path);
+      /* If we are not outputting dependencies, or if we are and dependencies
+         were requested for this file, or if preprocessor output is needed
+         in addition to dependency information, this is an error.
+
+         Otherwise (outputting dependencies but not for this file, and not
+         using the preprocessor output), we can still produce correct output
+         so it's only a warning.  */
+      if (CPP_OPTION (pfile, deps.style) == DEPS_NONE
+          || print_dep
+          || CPP_OPTION (pfile, deps.need_preprocessor_output))
+	cpp_errno (pfile, CPP_DL_FATAL, file->path);
       else
-	cpp_errno (pfile, CPP_DL_ERROR, file->path);
+	cpp_errno (pfile, CPP_DL_WARNING, file->path);
     }
 }
 
diff -Nur a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
--- a/libcpp/include/cpplib.h	2009-04-10 01:23:07.000000000 +0200
+++ b/libcpp/include/cpplib.h	2010-01-25 09:50:29.605686739 +0100
@@ -302,22 +302,9 @@
   /* Nonzero means print names of header files (-H).  */
   unsigned char print_include_names;
 
-  /* Nonzero means cpp_pedwarn causes a hard error.  */
-  unsigned char pedantic_errors;
-
-  /* Nonzero means don't print warning messages.  */
-  unsigned char inhibit_warnings;
-
   /* Nonzero means complain about deprecated features.  */
   unsigned char warn_deprecated;
 
-  /* Nonzero means don't suppress warnings from system headers.  */
-  unsigned char warn_system_headers;
-
-  /* Nonzero means don't print error messages.  Has no option to
-     select it, but can be set by a user of cpplib (e.g. fix-header).  */
-  unsigned char inhibit_errors;
-
   /* Nonzero means warn if slash-star appears in a comment.  */
   unsigned char warn_comments;
 
@@ -353,9 +340,6 @@
      explicitly undefined.  */
   unsigned char warn_builtin_macro_redefined;
 
-  /* Nonzero means turn warnings into errors.  */
-  unsigned char warnings_are_errors;
-
   /* Nonzero means we should look for header.gcc files that remap file
      names.  */
   unsigned char remap;
@@ -432,6 +416,10 @@
 
     /* If true, no dependency is generated on the main file.  */
     bool ignore_main_file;
+
+    /* If true, intend to use the preprocessor output (e.g., for compilation)
+       in addition to the dependency info.  */
+    bool need_preprocessor_output;
   } deps;
 
   /* Target-specific features set by the front end or client.  */
@@ -450,9 +438,6 @@
   /* Nonzero means __STDC__ should have the value 0 in system headers.  */
   unsigned char stdc_0_in_system_headers;
 
-  /* True means error callback should be used for diagnostics.  */
-  bool client_diagnostic;
-
   /* True disables tokenization outside of preprocessing directives. */
   bool directives_only;
 };
@@ -492,10 +477,11 @@
      be expanded.  */
   cpp_hashnode * (*macro_to_expand) (cpp_reader *, const cpp_token *);
 
-  /* Called to emit a diagnostic if client_diagnostic option is true.
-     This callback receives the translated message.  */
-  void (*error) (cpp_reader *, int, const char *, va_list *)
-       ATTRIBUTE_FPTR_PRINTF(3,0);
+  /* Called to emit a diagnostic.  This callback receives the
+     translated message.  */
+  bool (*error) (cpp_reader *, int, source_location, unsigned int,
+		 const char *, va_list *)
+       ATTRIBUTE_FPTR_PRINTF(5,0);
 
   /* Callbacks for when a macro is expanded, or tested (whether
      defined or not at the time) in #ifdef, #ifndef or "defined".  */
@@ -697,19 +683,13 @@
 
 /* Call this to finish preprocessing.  If you requested dependency
    generation, pass an open stream to write the information to,
-   otherwise NULL.  It is your responsibility to close the stream.
-
-   Returns cpp_errors (pfile).  */
-extern int cpp_finish (cpp_reader *, FILE *deps_stream);
+   otherwise NULL.  It is your responsibility to close the stream.  */
+extern void cpp_finish (cpp_reader *, FILE *deps_stream);
 
 /* Call this to release the handle at the end of preprocessing.  Any
-   use of the handle after this function returns is invalid.  Returns
-   cpp_errors (pfile).  */
+   use of the handle after this function returns is invalid.  */
 extern void cpp_destroy (cpp_reader *);
 
-/* Error count.  */
-extern unsigned int cpp_errors (cpp_reader *);
-
 extern unsigned int cpp_token_len (const cpp_token *);
 extern unsigned char *cpp_token_as_text (cpp_reader *, const cpp_token *);
 extern unsigned char *cpp_spell_token (cpp_reader *, const cpp_token *,
@@ -835,24 +815,23 @@
 /* An internal consistency check failed.  Prints "internal error: ",
    otherwise the same as CPP_DL_ERROR.  */
 #define CPP_DL_ICE		0x04
-/* Extracts a diagnostic level from an int.  */
-#define CPP_DL_EXTRACT(l)	(l & 0xf)
-/* Nonzero if a diagnostic level is one of the warnings.  */
-#define CPP_DL_WARNING_P(l)	(CPP_DL_EXTRACT (l) >= CPP_DL_WARNING \
-				 && CPP_DL_EXTRACT (l) <= CPP_DL_PEDWARN)
+/* An informative note following a warning.  */
+#define CPP_DL_NOTE		0x05
+/* A fatal error.  */
+#define CPP_DL_FATAL		0x06
 
 /* Output a diagnostic of some kind.  */
-extern void cpp_error (cpp_reader *, int, const char *msgid, ...)
+extern bool cpp_error (cpp_reader *, int, const char *msgid, ...)
   ATTRIBUTE_PRINTF_3;
 
 /* Output a diagnostic with "MSGID: " preceding the
    error string of errno.  No location is printed.  */
-extern void cpp_errno (cpp_reader *, int, const char *msgid);
+extern bool cpp_errno (cpp_reader *, int, const char *msgid);
 
 /* Same as cpp_error, except additionally specifies a position as a
    (translation unit) physical line and physical column.  If the line is
    zero, then no location is printed.  */
-extern void cpp_error_with_line (cpp_reader *, int, source_location, unsigned,
+extern bool cpp_error_with_line (cpp_reader *, int, source_location, unsigned,
 				 const char *msgid, ...) ATTRIBUTE_PRINTF_5;
 
 /* In lex.c */
diff -Nur a/libcpp/include/line-map.h b/libcpp/include/line-map.h
--- a/libcpp/include/line-map.h	2009-04-10 01:23:07.000000000 +0200
+++ b/libcpp/include/line-map.h	2010-01-25 09:50:29.605686739 +0100
@@ -144,12 +144,6 @@
 extern const struct line_map *linemap_lookup
   (struct line_maps *, source_location);
 
-/* Print the file names and line numbers of the #include commands
-   which led to the map MAP, if any, to stderr.  Nothing is output if
-   the most recently listed stack is the same as the current one.  */
-extern void linemap_print_containing_files (struct line_maps *,
-					    const struct line_map *);
-
 /* Converts a map and a source_location to source line.  */
 #define SOURCE_LINE(MAP, LOC) \
   ((((LOC) - (MAP)->start_location) >> (MAP)->column_bits) + (MAP)->to_line)
diff -Nur a/libcpp/init.c b/libcpp/init.c
--- a/libcpp/init.c	2009-04-10 01:23:07.000000000 +0200
+++ b/libcpp/init.c	2010-01-25 09:50:29.605686739 +0100
@@ -616,12 +616,11 @@
 }
 
 /* This is called at the end of preprocessing.  It pops the last
-   buffer and writes dependency output, and returns the number of
-   errors.
+   buffer and writes dependency output.
 
    Maybe it should also reset state, such that you could call
    cpp_start_read with a new filename to restart processing.  */
-int
+void
 cpp_finish (cpp_reader *pfile, FILE *deps_stream)
 {
   /* Warn about unused macros before popping the final buffer.  */
@@ -636,9 +635,8 @@
   while (pfile->buffer)
     _cpp_pop_buffer (pfile);
 
-  /* Don't write the deps file if there are errors.  */
   if (CPP_OPTION (pfile, deps.style) != DEPS_NONE
-      && deps_stream && pfile->errors == 0)
+      && deps_stream)
     {
       deps_write (pfile->deps, deps_stream, 72);
 
@@ -649,8 +647,6 @@
   /* Report on headers that could use multiple include guards.  */
   if (CPP_OPTION (pfile, print_include_names))
     _cpp_report_missing_guards (pfile);
-
-  return pfile->errors;
 }
 
 static void
diff -Nur a/libcpp/internal.h b/libcpp/internal.h
--- a/libcpp/internal.h	2009-04-10 01:23:07.000000000 +0200
+++ b/libcpp/internal.h	2010-01-25 09:50:29.605686739 +0100
@@ -388,9 +388,6 @@
   /* Nonzero prevents the lexer from re-using the token runs.  */
   unsigned int keep_tokens;
 
-  /* Error counter for exit code.  */
-  unsigned int errors;
-
   /* Buffer to hold macro definition string.  */
   unsigned char *macro_buffer;
   unsigned int macro_buffer_len;
diff -Nur a/libcpp/line-map.c b/libcpp/line-map.c
--- a/libcpp/line-map.c	2009-04-10 01:23:07.000000000 +0200
+++ b/libcpp/line-map.c	2010-01-25 09:50:29.605686739 +0100
@@ -302,45 +302,6 @@
   return &set->maps[mn];
 }
 
-/* Print the file names and line numbers of the #include commands
-   which led to the map MAP, if any, to stderr.  Nothing is output if
-   the most recently listed stack is the same as the current one.  */
-
-void
-linemap_print_containing_files (struct line_maps *set,
-				const struct line_map *map)
-{
-  if (MAIN_FILE_P (map) || set->last_listed == map->included_from)
-    return;
-
-  set->last_listed = map->included_from;
-  map = INCLUDED_FROM (set, map);
-
-  fprintf (stderr,  _("In file included from %s:%u"),
-	   map->to_file, LAST_SOURCE_LINE (map));
-
-  while (! MAIN_FILE_P (map))
-    {
-      map = INCLUDED_FROM (set, map);
-      /* Translators note: this message is used in conjunction
-	 with "In file included from %s:%ld" and some other
-	 tricks.  We want something like this:
-
-	 | In file included from sys/select.h:123,
-	 |                  from sys/types.h:234,
-	 |                  from userfile.c:31:
-	 | bits/select.h:45: <error message here>
-
-	 with all the "from"s lined up.
-	 The trailing comma is at the beginning of this message,
-	 and the trailing colon is not translated.  */
-      fprintf (stderr, _(",\n                 from %s:%u"),
-	       map->to_file, LAST_SOURCE_LINE (map));
-    }
-
-  fputs (":\n", stderr);
-}
-
 /* Print an include trace, for e.g. the -H option of the preprocessor.  */
 
 static void
diff -Nur a/libcpp/macro.c b/libcpp/macro.c
--- a/libcpp/macro.c	2009-04-10 01:23:07.000000000 +0200
+++ b/libcpp/macro.c	2010-01-25 09:50:29.605686739 +0100
@@ -1833,11 +1833,13 @@
 
       if (warn_of_redefinition (pfile, node, macro))
 	{
-	  cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->directive_line, 0,
-			       "\"%s\" redefined", NODE_NAME (node));
+	  bool warned;
+	  warned = cpp_error_with_line (pfile, CPP_DL_PEDWARN,
+					pfile->directive_line, 0,
+					"\"%s\" redefined", NODE_NAME (node));
 
-	  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))
-	    cpp_error_with_line (pfile, CPP_DL_PEDWARN,
+	  if (warned && node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))
+	    cpp_error_with_line (pfile, CPP_DL_NOTE,
 				 node->value.macro->line, 0,
 			 "this is the location of the previous definition");
 	}
diff -Nur a/libcpp/makedepend.c b/libcpp/makedepend.c
--- a/libcpp/makedepend.c	2005-06-29 04:34:39.000000000 +0200
+++ b/libcpp/makedepend.c	2010-01-25 09:50:29.605686739 +0100
@@ -1,206 +0,0 @@
-/* Dependency generator utility.
-   Copyright (C) 2004 Free Software Foundation, Inc.
-   Contributed by Zack Weinberg, May 2004
-
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
- In other words, you are welcome to use, share and improve this program.
- You are forbidden to forbid anyone else to use, share and improve
- what you give them.   Help stamp out software-hoarding!  */
-
-#include "config.h"
-#include "system.h"
-#include "line-map.h"
-#include "cpplib.h"
-#include "getopt.h"
-#include "mkdeps.h"
-
-const char *progname;
-const char *vpath;
-
-static const char *output_file;
-static bool had_errors;
-
-/* Option lists, to give to cpplib before each input file.  */
-struct cmd_line_macro
-{
-  struct cmd_line_macro *next;
-  bool is_undef;
-  const char *macro;
-};
-
-static struct cmd_line_macro *cmd_line_macros;
-static cpp_dir *cmd_line_searchpath;
-
-static void
-add_clm (const char *macro, bool is_undef)
-{
-  struct cmd_line_macro *clm = XNEW (struct cmd_line_macro);
-  clm->next = cmd_line_macros;
-  clm->is_undef = is_undef;
-  clm->macro = macro;
-  cmd_line_macros = clm;
-}
-
-static void
-add_dir (char *name, bool sysp)
-{
-  cpp_dir *dir = XNEW (cpp_dir);
-  dir->next = cmd_line_searchpath;
-  dir->name = name;
-  dir->sysp = sysp;
-  dir->construct = 0;
-  dir->user_supplied_p = 1;
-  cmd_line_searchpath = dir;
-}
-
-/* Command line processing.  */
-
-static void ATTRIBUTE_NORETURN
-usage (int errcode)
-{
-  fprintf (stderr,
-"usage: %s [-vh] [-V vpath] [-Dname[=def]...] [-Uname] [-Idir...] [-o file] sources...\n",
-	   progname);
-  exit (errcode);
-}
-
-static int
-parse_options (int argc, char **argv)
-{
-  static const struct option longopts[] = {
-    { "--help", no_argument, 0, 'h' },
-    { 0, 0, 0, 0 }
-  };
-
-  for (;;)
-    switch (getopt_long (argc, argv, "hD:U:I:J:o:V:", longopts, 0))
-      {
-      case 'h': usage (0);
-      case 'D': add_clm (optarg, false); break;
-      case 'U': add_clm (optarg, true);  break;
-      case 'I': add_dir (optarg, false); break;
-      case 'J': add_dir (optarg, true);  break;
-      case 'o':
-	if (output_file)
-	  {
-	    fprintf (stderr, "%s: too many output files\n", progname);
-	    usage (2);
-	  }
-	output_file = optarg;
-	break;
-      case 'V':
-	if (vpath)
-	  {
-	    fprintf (stderr, "%s: too many vpaths\n", progname);
-	    usage (2);
-	  }
-	vpath = optarg;
-	break;
-      case '?':
-	usage (2);  /* getopt has issued the error message.  */
-
-      case -1: /* end of options */
-	if (optind == argc)
-	  {
-	    fprintf (stderr, "%s: no input files\n", progname);
-	    usage (2);
-	  }
-	return optind;
-
-      default:
-	abort ();
-      }
-}
-
-/* Set up cpplib from command line options.  */
-static cpp_reader *
-reader_init (struct line_maps *line_table)
-{
-  cpp_reader *reader;
-  cpp_options *options;
-
-  linemap_init (line_table);
-  reader = cpp_create_reader (CLK_GNUC89, 0, line_table);
-
-  /* Ignore warnings and errors (we don't have access to system
-     headers).  Request dependency output.  */
-  options = cpp_get_options (reader);
-  options->inhibit_warnings = 1;
-  options->inhibit_errors = 1;
-  options->deps.style = DEPS_USER;
-
-  /* Further initialization.  */
-  cpp_post_options (reader);
-  cpp_init_iconv (reader);
-  cpp_set_include_chains (reader, cmd_line_searchpath, cmd_line_searchpath,
-			  false);
-  if (vpath)
-    {
-      struct deps *deps = cpp_get_deps (reader);
-      deps_add_vpath (deps, vpath);
-    }
-
-  return reader;
-}
-
-/* Process one input source file.  */
-static void
-process_file (const char *file)
-{
-  struct line_maps line_table;
-  cpp_reader *reader = reader_init (&line_table);
-
-  if (!cpp_read_main_file (reader, file))
-    had_errors = true;
-  else
-    {
-      struct cmd_line_macro *clm;
-
-      cpp_init_builtins (reader, true);
-      for (clm = cmd_line_macros; clm; clm = clm->next)
-	(clm->is_undef ? cpp_undef : cpp_define) (reader, clm->macro);
-
-      cpp_scan_nooutput (reader);
-      if (cpp_finish (reader, stdout))
-	had_errors = true;
-    }
-  cpp_destroy (reader);
-  linemap_free (&line_table);
-}
-
-/* Master control.  */
-
-int
-main(int argc, char **argv)
-{
-  int first_input, i;
-
-  progname = argv[0];
-  xmalloc_set_program_name (progname);
-
-  first_input = parse_options (argc, argv);
-  if (output_file)
-    if (!freopen (output_file, "w", stdout))
-      {
-	perror (output_file);
-	return 1;
-      }
-
-  for (i = first_input; i < argc; i++)
-    process_file (argv[i]);
-
-  return had_errors;
-}
diff -Nur a/libcpp/Makefile.in b/libcpp/Makefile.in
--- a/libcpp/Makefile.in	2009-07-22 09:43:59.000000000 +0200
+++ b/libcpp/Makefile.in	2010-01-25 09:50:29.605686739 +0100
@@ -72,13 +72,12 @@
 libcpp_a_OBJS = charset.o directives.o directives-only.o errors.o \
 	expr.o files.o identifiers.o init.o lex.o line-map.o macro.o \
 	mkdeps.o pch.o symtab.o traditional.o
-makedepend_OBJS = makedepend.o
 
 libcpp_a_SOURCES = charset.c directives.c directives-only.c errors.c \
 	expr.c files.c identifiers.c init.c lex.c line-map.c macro.c \
 	mkdeps.c pch.c symtab.c traditional.c
 
-all: libcpp.a makedepend$(EXEEXT) $(USED_CATALOGS)
+all: libcpp.a $(USED_CATALOGS)
 
 .SUFFIXES:
 .SUFFIXES: .c .gmo .o .obj .po .pox
@@ -88,12 +87,6 @@
 	$(AR) $(ARFLAGS) libcpp.a $(libcpp_a_OBJS)
 	$(RANLIB) libcpp.a
 
-makedepend$(EXEEXT): $(makedepend_OBJS) libcpp.a ../libiberty/libiberty.a
-	@rm -f makedepend$(EXEEXT)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o makedepend$(EXEEXT) \
-	  $(makedepend_OBJS) libcpp.a ../libiberty/libiberty.a \
-	  $(LIBINTL) $(LIBICONV)
-
 # Rules to rebuild the configuration
 
 Makefile: $(srcdir)/Makefile.in config.status
@@ -165,7 +158,7 @@
 	-rm -f *.o
 
 clean: mostlyclean
-	-rm -rf makedepend$(EXEEXT) libcpp.a $(srcdir)/autom4te.cache
+	-rm -rf libcpp.a $(srcdir)/autom4te.cache
 
 distclean: clean
 	-rm -f config.h stamp-h1 config.status config.cache config.log \
@@ -247,7 +240,7 @@
 	sed 's:$(srcdir)/::g' <po/$(PACKAGE).pot.tmp >po/$(PACKAGE).pot
 	rm po/$(PACKAGE).pot.tmp
 
-TAGS_SOURCES = $(libcpp_a_SOURCES) makedepend.c internal.h ucnid.h \
+TAGS_SOURCES = $(libcpp_a_SOURCES) internal.h ucnid.h \
     include/line-map.h include/symtab.h include/cpp-id-data.h \
     include/cpplib.h include/mkdeps.h system.h
 
@@ -259,7 +252,7 @@
 .NOEXPORT:
 
 # Dependencies
--include $(patsubst %.o, $(DEPDIR)/%.Po, $(libcpp_a_OBJS) $(makedepend_OBJS))
+-include $(patsubst %.o, $(DEPDIR)/%.Po, $(libcpp_a_OBJS))
 
 # Dependencies on generated headers have to be explicit.
 init.o: localedir.h
diff -Nur a/libgcc/config/arm/t-divmod-ef b/libgcc/config/arm/t-divmod-ef
--- a/libgcc/config/arm/t-divmod-ef	1970-01-01 01:00:00.000000000 +0100
+++ b/libgcc/config/arm/t-divmod-ef	2010-01-25 09:50:29.605686739 +0100
@@ -0,0 +1,4 @@
+# On ARM, specifying -fnon-call-exceptions will needlessly pull in
+# the unwinder in simple programs which use 64-bit division.  Omitting
+# the option is safe.
+LIB2_DIVMOD_EXCEPTION_FLAGS := -fexceptions
diff -Nur a/libgcc/config/mips/t-crtfm b/libgcc/config/mips/t-crtfm
--- a/libgcc/config/mips/t-crtfm	1970-01-01 01:00:00.000000000 +0100
+++ b/libgcc/config/mips/t-crtfm	2010-01-25 09:50:29.605686739 +0100
@@ -0,0 +1,3 @@
+crtfastmath.o: $(gcc_srcdir)/config/mips/crtfastmath.c
+	$(gcc_compile) -c $(gcc_srcdir)/config/mips/crtfastmath.c
+
diff -Nur a/libgcc/config/rs6000/t-ppccomm b/libgcc/config/rs6000/t-ppccomm
--- a/libgcc/config/rs6000/t-ppccomm	2008-06-26 16:15:49.000000000 +0200
+++ b/libgcc/config/rs6000/t-ppccomm	2010-01-25 09:50:29.605686739 +0100
@@ -101,3 +101,63 @@
 
 ncrtn$(objext): ncrtn.S
 	$(crt_compile) -c ncrtn.S
+
+crtsavres$(objext): crtsavres.S
+	$(crt_compile) -c crtsavres.S
+
+crtsavfpr$(objext): crtsavfpr.S
+	$(crt_compile) -c crtsavfpr.S
+
+crtresfpr$(objext): crtresfpr.S
+	$(crt_compile) -c crtresfpr.S
+
+crtsavgpr$(objext): crtsavgpr.S
+	$(crt_compile) -c crtsavgpr.S
+
+crtresgpr$(objext): crtresgpr.S
+	$(crt_compile) -c crtresgpr.S
+
+crtresxfpr$(objext): crtresxfpr.S
+	$(crt_compile) -c crtresxfpr.S
+
+crtresxgpr$(objext): crtresxgpr.S
+	$(crt_compile) -c crtresxgpr.S
+
+e500crtres32gpr$(objext): e500crtres32gpr.S
+	$(crt_compile) -c e500crtres32gpr.S
+
+e500crtres64gpr$(objext): e500crtres64gpr.S
+	$(crt_compile) -c e500crtres64gpr.S
+
+e500crtres64gprctr$(objext): e500crtres64gprctr.S
+	$(crt_compile) -c e500crtres64gprctr.S
+
+e500crtrest32gpr$(objext): e500crtrest32gpr.S
+	$(crt_compile) -c e500crtrest32gpr.S
+
+e500crtrest64gpr$(objext): e500crtrest64gpr.S
+	$(crt_compile) -c e500crtrest64gpr.S
+
+e500crtresx32gpr$(objext): e500crtresx32gpr.S
+	$(crt_compile) -c e500crtresx32gpr.S
+
+e500crtresx64gpr$(objext): e500crtresx64gpr.S
+	$(crt_compile) -c e500crtresx64gpr.S
+
+e500crtsav32gpr$(objext): e500crtsav32gpr.S
+	$(crt_compile) -c e500crtsav32gpr.S
+
+e500crtsav64gpr$(objext): e500crtsav64gpr.S
+	$(crt_compile) -c e500crtsav64gpr.S
+
+e500crtsav64gprctr$(objext): e500crtsav64gprctr.S
+	$(crt_compile) -c e500crtsav64gprctr.S
+
+e500crtsavg32gpr$(objext): e500crtsavg32gpr.S
+	$(crt_compile) -c e500crtsavg32gpr.S
+
+e500crtsavg64gpr$(objext): e500crtsavg64gpr.S
+	$(crt_compile) -c e500crtsavg64gpr.S
+
+e500crtsavg64gprctr$(objext): e500crtsavg64gprctr.S
+	$(crt_compile) -c e500crtsavg64gprctr.S
diff -Nur a/libgcc/config.host b/libgcc/config.host
--- a/libgcc/config.host	2009-04-17 13:58:41.000000000 +0200
+++ b/libgcc/config.host	2010-01-25 09:50:29.605686739 +0100
@@ -203,12 +203,15 @@
 arm*-*-netbsd*)
 	;;
 arm*-*-linux*)			# ARM GNU/Linux with ELF
+	tmake_file="${tmake_file} arm/t-divmod-ef"
 	;;
 arm*-*-uclinux*)		# ARM ucLinux
+	tmake_file="${tmake_file} arm/t-divmod-ef"
 	;;
 arm*-*-ecos-elf)
 	;;
 arm*-*-eabi* | arm*-*-symbianelf* )
+	tmake_file="${tmake_file} arm/t-divmod-ef"
 	;;
 arm*-*-rtems*)
 	;;
@@ -394,8 +397,12 @@
 mips*-*-netbsd*)			# NetBSD/mips, either endian.
 	;;
 mips64*-*-linux*)
+	extra_parts="$extra_parts crtfastmath.o"
+	tmake_file="{$tmake_file} mips/t-crtfm"
 	;;
 mips*-*-linux*)				# Linux MIPS, either endian.
+	extra_parts="$extra_parts crtfastmath.o"
+	tmake_file="{$tmake_file} mips/t-crtfm"
 	;;
 mips*-*-openbsd*)
 	;;
@@ -419,6 +426,10 @@
         ;;
 mips64orion-*-elf* | mips64orionel-*-elf*)
 	;;
+mips64octeon-wrs-elf* | mips64octeonel-wrs-elf*)
+	;;
+mips64octeon-montavista-elf*)
+	;;
 mips*-*-rtems*)
 	;;
 mips-wrs-vxworks)
diff -Nur a/libgcc/Makefile.in b/libgcc/Makefile.in
--- a/libgcc/Makefile.in	2009-04-10 01:23:07.000000000 +0200
+++ b/libgcc/Makefile.in	2010-01-25 09:50:29.605686739 +0100
@@ -389,18 +389,24 @@
 endif
 endif
 
+ifeq ($(LIB2_DIVMOD_EXCEPTION_FLAGS),)
+# Provide default flags for compiling divmod functions, if they haven't been
+# set already by a target-specific Makefile fragment.
+LIB2_DIVMOD_EXCEPTION_FLAGS := -fexceptions -fnon-call-exceptions
+endif
+
 # Build LIB2_DIVMOD_FUNCS.
 lib2-divmod-o = $(patsubst %,%$(objext),$(LIB2_DIVMOD_FUNCS))
 $(lib2-divmod-o): %$(objext): $(gcc_srcdir)/libgcc2.c
 	$(gcc_compile) -DL$* -c $(gcc_srcdir)/libgcc2.c \
-	  -fexceptions -fnon-call-exceptions $(vis_hide)
+	  $(LIB2_DIVMOD_EXCEPTION_FLAGS) $(vis_hide)
 libgcc-objects += $(lib2-divmod-o)
 
 ifeq ($(enable_shared),yes)
 lib2-divmod-s-o = $(patsubst %,%_s$(objext),$(LIB2_DIVMOD_FUNCS))
 $(lib2-divmod-s-o): %_s$(objext): $(gcc_srcdir)/libgcc2.c
 	$(gcc_s_compile) -DL$* -c $(gcc_srcdir)/libgcc2.c \
-	  -fexceptions -fnon-call-exceptions
+	  $(LIB2_DIVMOD_EXCEPTION_FLAGS)
 libgcc-s-objects += $(lib2-divmod-s-o)
 endif
 
diff -Nur a/libgcc/shared-object.mk b/libgcc/shared-object.mk
--- a/libgcc/shared-object.mk	2008-07-03 21:22:00.000000000 +0200
+++ b/libgcc/shared-object.mk	2010-01-25 09:50:29.605686739 +0100
@@ -8,11 +8,13 @@
 
 ifeq ($(suffix $o),.c)
 
+c_flags-$(base)$(objext) := $(c_flags)
 $(base)$(objext): $o
-	$(gcc_compile) $(c_flags) -c $< $(vis_hide)
+	$(gcc_compile) $(c_flags-$@) -c $< $(vis_hide)
 
+c_flags-$(base)_s$(objext) := $(c_flags)
 $(base)_s$(objext): $o
-	$(gcc_s_compile) $(c_flags) -c $<
+	$(gcc_s_compile) $(c_flags-$@) -c $<
 
 else
 
diff -Nur a/libgcc/static-object.mk b/libgcc/static-object.mk
--- a/libgcc/static-object.mk	2007-01-04 05:22:37.000000000 +0100
+++ b/libgcc/static-object.mk	2010-01-25 09:50:29.605686739 +0100
@@ -8,8 +8,9 @@
 
 ifeq ($(suffix $o),.c)
 
+c_flags-$(base)$(objext) := $(c_flags)
 $(base)$(objext): $o
-	$(gcc_compile) $(c_flags) -c $< $(vis_hide)
+	$(gcc_compile) $(c_flags-$@) -c $< $(vis_hide)
 
 else
 
diff -Nur a/libgomp/configure b/libgomp/configure
--- a/libgomp/configure	2009-07-22 09:43:59.000000000 +0200
+++ b/libgomp/configure	2010-01-25 09:50:29.605686739 +0100
@@ -457,7 +457,7 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS GENINSRC_TRUE GENINSRC_FALSE build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar multi_basedir toolexecdir toolexeclibdir CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS AR ac_ct_AR RANLIB ac_ct_RANLIB PERL BUILD_INFO_TRUE BUILD_INFO_FALSE LIBTOOL SED EGREP FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM LN_S OBJDUMP ac_ct_OBJDUMP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CPP CPPFLAGS enable_shared enable_static MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT FC FCFLAGS LDFLAGS ac_ct_FC libtool_VERSION SECTION_LDFLAGS OPT_LDFLAGS LIBGOMP_BUILD_VERSIONED_SHLIB_TRUE LIBGOMP_BUILD_VERSIONED_SHLIB_FALSE config_path XCFLAGS XLDFLAGS link_gomp USE_FORTRAN_TRUE USE_FORTRAN_FALSE OMP_LOCK_SIZE OMP_LOCK_ALIGN OMP_NEST_LOCK_SIZE OMP_NEST_LOCK_ALIGN OMP_LOCK_KIND OMP_NEST_LOCK_KIND OMP_LOCK_25_SIZE OMP_LOCK_25_ALIGN OMP_NEST_LOCK_25_SIZE OMP_NEST_LOCK_25_ALIGN OMP_LOCK_25_KIND OMP_NEST_LOCK_25_KIND LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS GENINSRC_TRUE GENINSRC_FALSE build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar multi_basedir toolexecdir toolexeclibdir datarootdir docdir pdfdir htmldir CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS AR ac_ct_AR RANLIB ac_ct_RANLIB PERL BUILD_INFO_TRUE BUILD_INFO_FALSE LIBTOOL SED EGREP FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM LN_S OBJDUMP ac_ct_OBJDUMP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CPP CPPFLAGS enable_shared enable_static MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT FC FCFLAGS LDFLAGS ac_ct_FC libtool_VERSION SECTION_LDFLAGS OPT_LDFLAGS LIBGOMP_BUILD_VERSIONED_SHLIB_TRUE LIBGOMP_BUILD_VERSIONED_SHLIB_FALSE config_path XCFLAGS XLDFLAGS link_gomp USE_FORTRAN_TRUE USE_FORTRAN_FALSE OMP_LOCK_SIZE OMP_LOCK_ALIGN OMP_NEST_LOCK_SIZE OMP_NEST_LOCK_ALIGN OMP_LOCK_KIND OMP_NEST_LOCK_KIND OMP_LOCK_25_SIZE OMP_LOCK_25_ALIGN OMP_NEST_LOCK_25_SIZE OMP_NEST_LOCK_25_ALIGN OMP_LOCK_25_KIND OMP_NEST_LOCK_25_KIND LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 ac_pwd=`pwd`
 
@@ -1029,6 +1029,10 @@
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-datarootdir=DIR  Use DIR as the data root [PREFIX/share]
+  --with-docdir=DIR       Install documentation in DIR [DATAROOTDIR]
+  --with-pdfdir           install pdf in this directory.
+  --with-htmldir=DIR      html documentation in in DIR [DOCDIR]
   --with-pic              try to use only PIC/non-PIC objects [default=use
                           both]
   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
@@ -2201,6 +2205,46 @@
 
 
 
+
+# Check whether --with-datarootdir or --without-datarootdir was given.
+if test "${with_datarootdir+set}" = set; then
+  withval="$with_datarootdir"
+  datarootdir="\${prefix}/$with_datarootdir"
+else
+  datarootdir='$(prefix)/share'
+fi;
+
+
+
+# Check whether --with-docdir or --without-docdir was given.
+if test "${with_docdir+set}" = set; then
+  withval="$with_docdir"
+  docdir="\${prefix}/$with_docdir"
+else
+  docdir='$(datarootdir)'
+fi;
+
+
+
+# Check whether --with-pdfdir or --without-pdfdir was given.
+if test "${with_pdfdir+set}" = set; then
+  withval="$with_pdfdir"
+  pdfdir="\${prefix}/${withval}"
+else
+  pdfdir="\${docdir}"
+fi;
+
+
+
+# Check whether --with-htmldir or --without-htmldir was given.
+if test "${with_htmldir+set}" = set; then
+  withval="$with_htmldir"
+  htmldir="\${prefix}/$with_htmldir"
+else
+  htmldir='$(docdir)'
+fi;
+
+
 # Check the compiler.
 # The same as in boehm-gc and libstdc++. Have to borrow it from there.
 # We must force CC to /not/ be precious variables; otherwise
@@ -4156,13 +4200,13 @@
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:4159: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:4203: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:4162: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:4206: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:4165: output\"" >&5)
+  (eval echo "\"\$as_me:4209: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
@@ -5320,7 +5364,7 @@
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 5323 "configure"' > conftest.$ac_ext
+  echo '#line 5367 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -7101,11 +7145,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7104: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7148: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:7108: \$? = $ac_status" >&5
+   echo "$as_me:7152: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -7440,11 +7484,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7443: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7487: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:7447: \$? = $ac_status" >&5
+   echo "$as_me:7491: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -7545,11 +7589,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7548: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7592: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:7552: \$? = $ac_status" >&5
+   echo "$as_me:7596: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -7600,11 +7644,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7603: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7647: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:7607: \$? = $ac_status" >&5
+   echo "$as_me:7651: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -10412,7 +10456,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10415 "configure"
+#line 10459 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10508,7 +10552,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10511 "configure"
+#line 10555 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10859,7 +10903,7 @@
 
 
 # Provide some information about the compiler.
-echo "$as_me:10862:" \
+echo "$as_me:10906:" \
      "checking for Fortran compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
 { (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
@@ -11095,7 +11139,7 @@
 
 
 # Provide some information about the compiler.
-echo "$as_me:11098:" \
+echo "$as_me:11142:" \
      "checking for Fortran compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
 { (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
@@ -11835,11 +11879,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:11838: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:11882: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:11842: \$? = $ac_status" >&5
+   echo "$as_me:11886: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -11934,11 +11978,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:11937: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:11981: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:11941: \$? = $ac_status" >&5
+   echo "$as_me:11985: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -11986,11 +12030,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:11989: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:12033: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:11993: \$? = $ac_status" >&5
+   echo "$as_me:12037: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -15133,7 +15177,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15197,7 +15242,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15238,7 +15284,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15295,7 +15342,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15336,7 +15384,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15401,7 +15450,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15469,7 +15519,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (void *)); }
 unsigned long ulongval () { return (long) (sizeof (void *)); }
 #include <stdio.h>
@@ -15557,7 +15608,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15621,7 +15673,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15662,7 +15715,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15719,7 +15773,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15760,7 +15815,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15825,7 +15881,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15893,7 +15950,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (long)); }
 unsigned long ulongval () { return (long) (sizeof (long)); }
 #include <stdio.h>
@@ -15981,7 +16039,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16045,7 +16104,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16086,7 +16146,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16143,7 +16204,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16184,7 +16246,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16249,7 +16312,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16317,7 +16381,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (int)); }
 unsigned long ulongval () { return (long) (sizeof (int)); }
 #include <stdio.h>
@@ -16401,7 +16466,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16465,7 +16531,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16506,7 +16573,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16563,7 +16631,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16604,7 +16673,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16669,7 +16739,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16737,7 +16808,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (short)); }
 unsigned long ulongval () { return (long) (sizeof (short)); }
 #include <stdio.h>
@@ -16821,7 +16893,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16885,7 +16958,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16926,7 +17000,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16983,7 +17058,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17024,7 +17100,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17089,7 +17166,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17157,7 +17235,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (char)); }
 unsigned long ulongval () { return (long) (sizeof (char)); }
 #include <stdio.h>
@@ -17906,6 +17985,64 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   gcc_cv_have_tls=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -17915,6 +18052,24 @@
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 
 
 else
@@ -22801,6 +22956,10 @@
 s,@multi_basedir@,$multi_basedir,;t t
 s,@toolexecdir@,$toolexecdir,;t t
 s,@toolexeclibdir@,$toolexeclibdir,;t t
+s,@datarootdir@,$datarootdir,;t t
+s,@docdir@,$docdir,;t t
+s,@pdfdir@,$pdfdir,;t t
+s,@htmldir@,$htmldir,;t t
 s,@CC@,$CC,;t t
 s,@ac_ct_CC@,$ac_ct_CC,;t t
 s,@EXEEXT@,$EXEEXT,;t t
diff -Nur a/libgomp/configure.ac b/libgomp/configure.ac
--- a/libgomp/configure.ac	2008-09-19 22:27:11.000000000 +0200
+++ b/libgomp/configure.ac	2010-01-25 09:50:29.605686739 +0100
@@ -94,6 +94,30 @@
 AC_SUBST(toolexecdir)
 AC_SUBST(toolexeclibdir)
 
+AC_ARG_WITH(datarootdir,
+[  --with-datarootdir=DIR  Use DIR as the data root [[PREFIX/share]]],
+datarootdir="\${prefix}/$with_datarootdir",
+datarootdir='$(prefix)/share')
+AC_SUBST(datarootdir)
+
+AC_ARG_WITH(docdir,
+[  --with-docdir=DIR       Install documentation in DIR [[DATAROOTDIR]]],
+docdir="\${prefix}/$with_docdir",
+docdir='$(datarootdir)')
+AC_SUBST(docdir)
+
+AC_ARG_WITH(pdfdir,
+[  --with-pdfdir           install pdf in this directory.],
+[pdfdir="\${prefix}/${withval}"],
+[pdfdir="\${docdir}"])
+AC_SUBST(pdfdir)
+
+AC_ARG_WITH(htmldir,
+[  --with-htmldir=DIR      html documentation in in DIR [[DOCDIR]]],
+htmldir="\${prefix}/$with_htmldir",
+htmldir='$(docdir)')
+AC_SUBST(htmldir)
+
 # Check the compiler.
 # The same as in boehm-gc and libstdc++. Have to borrow it from there.
 # We must force CC to /not/ be precious variables; otherwise
diff -Nur a/libgomp/libgomp.texi b/libgomp/libgomp.texi
--- a/libgomp/libgomp.texi	2008-11-04 19:16:17.000000000 +0100
+++ b/libgomp/libgomp.texi	2010-01-25 09:50:29.605686739 +0100
@@ -94,7 +94,7 @@
                                How you can copy and share this manual.
 * Funding::                    How to help assure continued work for free 
                                software.
-* Index::                      Index of this documentation.
+* Library Index::              Index of this documentation.
 @end menu
 
 
@@ -1713,8 +1713,8 @@
 @c Index
 @c ---------------------------------------------------------------------
 
-@node Index
-@unnumbered Index
+@node Library Index
+@unnumbered Library Index
 
 @printindex cp
 
diff -Nur a/libgomp/Makefile.am b/libgomp/Makefile.am
--- a/libgomp/Makefile.am	2008-08-31 20:16:09.000000000 +0200
+++ b/libgomp/Makefile.am	2010-01-25 09:50:29.615687242 +0100
@@ -1,5 +1,10 @@
 ## Process this file with automake to produce Makefile.in
 
+datarootdir = @datarootdir@
+docdir = @docdir@
+htmldir = @htmldir@
+pdfdir = @pdfdir@
+
 ACLOCAL_AMFLAGS = -I .. -I ../config
 SUBDIRS = testsuite
 
@@ -41,6 +46,12 @@
 nodist_finclude_HEADERS = omp_lib.h omp_lib.f90 omp_lib.mod omp_lib_kinds.mod
 endif
 
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+
+LINK = $(LIBTOOL) --tag CC --mode=link $(CCLD) $(AM_CCFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LTLDFLAGS) -o $@
+
+
 omp_lib_kinds.mod: omp_lib.mod
 	:
 omp_lib.mod: omp_lib.f90
@@ -50,10 +61,30 @@
 env.lo: libgomp_f.h
 env.o: libgomp_f.h
 
+HTMLS_INSTALL=libgomp
+HTMLS_BUILD=libgomp/index.html
 
-# No install-html or install-pdf support in automake yet
-.PHONY: install-html install-pdf
-install-html:
+$(HTMLS_BUILD): $(info_TEXINFOS)
+	$(TEXI2HTML) $(MAKEINFOFLAGS) -I$(srcdir) -o $(@D) $<
+
+html__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+
+install-html: $(HTMLS_BUILD)
+	@$(NORMAL_INSTALL)
+	test -z "$(htmldir)" || $(mkinstalldirs) "$(DESTDIR)$(htmldir)"
+	@list='$(HTMLS_INSTALL)'; for p in $$list; do \
+	  if test -f "$$p" || test -d "$$p"; then d=""; else d="$(srcdir)/"; fi; \
+	  f=$(html__strip_dir) \
+	  if test -d "$$d$$p"; then \
+	    echo " $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(mkinstalldirs) "$(DESTDIR)$(htmldir)/$$f" || exit 1; \
+	    echo " $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p"/* "$(DESTDIR)$(htmldir)/$$f"; \
+	  else \
+	    echo " $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(htmldir)/$$f"; \
+	  fi; \
+	done
 
 install-pdf: $(PDFS)
 	@$(NORMAL_INSTALL)
@@ -71,6 +102,7 @@
 # `texinfo.tex' for your package. The value of this variable should be
 # the relative path from the current `Makefile.am' to `texinfo.tex'.
 TEXINFO_TEX   = ../gcc/doc/include/texinfo.tex
+TEXI2HTML = $(MAKEINFO) --html
 
 # Defines info, dvi, pdf and html targets
 MAKEINFOFLAGS = -I $(srcdir)/../gcc/doc/include
diff -Nur a/libgomp/Makefile.in b/libgomp/Makefile.in
--- a/libgomp/Makefile.in	2009-07-22 09:43:59.000000000 +0200
+++ b/libgomp/Makefile.in	2010-01-25 09:50:29.615687242 +0100
@@ -97,8 +97,6 @@
 	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
 	$(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 SOURCES = $(libgomp_la_SOURCES)
 DIST_SOURCES = $(libgomp_la_SOURCES)
 MULTISRCTOP = 
@@ -259,6 +257,8 @@
 build_vendor = @build_vendor@
 config_path = @config_path@
 datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
@@ -267,6 +267,7 @@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
+htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
@@ -280,6 +281,7 @@
 mkdir_p = @mkdir_p@
 multi_basedir = @multi_basedir@
 oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 sbindir = @sbindir@
@@ -317,6 +319,13 @@
 nodist_noinst_HEADERS = libgomp_f.h
 nodist_libsubinclude_HEADERS = omp.h
 @USE_FORTRAN_TRUE@nodist_finclude_HEADERS = omp_lib.h omp_lib.f90 omp_lib.mod omp_lib_kinds.mod
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+LINK = $(LIBTOOL) --tag CC --mode=link $(CCLD) $(AM_CCFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LTLDFLAGS) -o $@
+
+HTMLS_INSTALL = libgomp
+HTMLS_BUILD = libgomp/index.html
+html__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
 
 # Automake Documentation:
 # If your package has Texinfo files in many directories, you can use the
@@ -324,6 +333,7 @@
 # `texinfo.tex' for your package. The value of this variable should be
 # the relative path from the current `Makefile.am' to `texinfo.tex'.
 TEXINFO_TEX = ../gcc/doc/include/texinfo.tex
+TEXI2HTML = $(MAKEINFO) --html
 
 # Defines info, dvi, pdf and html targets
 MAKEINFOFLAGS = -I $(srcdir)/../gcc/doc/include
@@ -1085,9 +1095,25 @@
 env.lo: libgomp_f.h
 env.o: libgomp_f.h
 
-# No install-html or install-pdf support in automake yet
-.PHONY: install-html install-pdf
-install-html:
+$(HTMLS_BUILD): $(info_TEXINFOS)
+	$(TEXI2HTML) $(MAKEINFOFLAGS) -I$(srcdir) -o $(@D) $<
+
+install-html: $(HTMLS_BUILD)
+	@$(NORMAL_INSTALL)
+	test -z "$(htmldir)" || $(mkinstalldirs) "$(DESTDIR)$(htmldir)"
+	@list='$(HTMLS_INSTALL)'; for p in $$list; do \
+	  if test -f "$$p" || test -d "$$p"; then d=""; else d="$(srcdir)/"; fi; \
+	  f=$(html__strip_dir) \
+	  if test -d "$$d$$p"; then \
+	    echo " $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(mkinstalldirs) "$(DESTDIR)$(htmldir)/$$f" || exit 1; \
+	    echo " $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p"/* "$(DESTDIR)$(htmldir)/$$f"; \
+	  else \
+	    echo " $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(htmldir)/$$f"; \
+	  fi; \
+	done
 
 install-pdf: $(PDFS)
 	@$(NORMAL_INSTALL)
diff -Nur a/libgomp/testsuite/Makefile.in b/libgomp/testsuite/Makefile.in
--- a/libgomp/testsuite/Makefile.in	2009-07-22 09:43:59.000000000 +0200
+++ b/libgomp/testsuite/Makefile.in	2010-01-25 09:50:29.615687242 +0100
@@ -177,6 +177,8 @@
 build_vendor = @build_vendor@
 config_path = @config_path@
 datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
@@ -185,6 +187,7 @@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
+htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
@@ -198,6 +201,7 @@
 mkdir_p = @mkdir_p@
 multi_basedir = @multi_basedir@
 oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 sbindir = @sbindir@
diff -Nur a/libiberty/argv.c b/libiberty/argv.c
--- a/libiberty/argv.c	2007-07-23 19:29:17.000000000 +0200
+++ b/libiberty/argv.c	2010-01-25 09:50:29.615687242 +0100
@@ -119,6 +119,24 @@
     }
 }
 
+static void
+consume_whitespace (const char **input)
+{
+  while (ISSPACE (**input))
+    {
+      (*input)++;
+    }
+}
+
+static int
+only_whitespace (const char* input)
+{
+  while (*input != EOS && ISSPACE (*input))
+    input++;
+
+  return (*input == EOS);
+}
+
 /*
 
 @deftypefn Extension char** buildargv (char *@var{sp})
@@ -179,10 +197,8 @@
       do
 	{
 	  /* Pick off argv[argc] */
-	  while (ISBLANK (*input))
-	    {
-	      input++;
-	    }
+	  consume_whitespace (&input);
+
 	  if ((maxargc == 0) || (argc >= (maxargc - 1)))
 	    {
 	      /* argv needs initialization, or expansion */
@@ -278,10 +294,7 @@
 	  argc++;
 	  argv[argc] = NULL;
 
-	  while (ISSPACE (*input))
-	    {
-	      input++;
-	    }
+	  consume_whitespace (&input);
 	}
       while (*input != EOS);
     }
@@ -420,8 +433,17 @@
 	goto error;
       /* Add a NUL terminator.  */
       buffer[len] = '\0';
-      /* Parse the string.  */
-      file_argv = buildargv (buffer);
+      /* If the file is empty or contains only whitespace, buildargv would
+	 return a single empty argument.  In this context we want no arguments,
+	 instead.  */
+      if (only_whitespace (buffer))
+	{
+	  file_argv = (char **) xmalloc (sizeof (char *));
+	  file_argv[0] = NULL;
+	}
+      else
+	/* Parse the string.  */
+	file_argv = buildargv (buffer);
       /* If *ARGVP is not already dynamically allocated, copy it.  */
       if (!argv_dynamic)
 	{
@@ -434,7 +456,7 @@
 	}
       /* Count the number of arguments.  */
       file_argc = 0;
-      while (file_argv[file_argc] && *file_argv[file_argc])
+      while (file_argv[file_argc])
 	++file_argc;
       /* Now, insert FILE_ARGV into ARGV.  The "+1" below handles the
 	 NULL terminator at the end of ARGV.  */ 
diff -Nur a/libiberty/configure b/libiberty/configure
--- a/libiberty/configure	2009-04-08 16:18:33.000000000 +0200
+++ b/libiberty/configure	2010-01-25 09:50:29.615687242 +0100
@@ -8891,6 +8891,20 @@
 esac
 
 
+# On MinGW, add support for Cygwin paths.
+case "${host}" in
+     *-*-mingw*)
+	case $LIBOBJS in
+    "cygpath.$ac_objext"   | \
+  *" cygpath.$ac_objext"   | \
+    "cygpath.$ac_objext "* | \
+  *" cygpath.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS cygpath.$ac_objext" ;;
+esac
+
+	;;
+esac
+
 if test x$gcc_no_link = xyes; then
   if test "x${ac_cv_func_mmap_fixed_mapped+set}" != xset; then
     ac_cv_func_mmap_fixed_mapped=no
diff -Nur a/libiberty/configure.ac b/libiberty/configure.ac
--- a/libiberty/configure.ac	2009-04-08 16:18:33.000000000 +0200
+++ b/libiberty/configure.ac	2010-01-25 09:50:29.615687242 +0100
@@ -663,6 +663,13 @@
 esac
 AC_SUBST(pexecute)
 
+# On MinGW, add support for Cygwin paths.
+case "${host}" in
+     *-*-mingw*)
+	AC_LIBOBJ([cygpath])
+	;;
+esac
+
 libiberty_AC_FUNC_STRNCMP
 
 # Install a library built with a cross compiler in $(tooldir) rather
diff -Nur a/libiberty/cygpath.c b/libiberty/cygpath.c
--- a/libiberty/cygpath.c	1970-01-01 01:00:00.000000000 +0100
+++ b/libiberty/cygpath.c	2010-01-25 09:50:29.615687242 +0100
@@ -0,0 +1,591 @@
+/* Support Cygwin paths under MinGW.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   Written by CodeSourcery.
+
+This file is part of the libiberty library.
+Libiberty is free software; you can redistribute it and/or modify it
+under the terms of the GNU Library General Public License as published
+by the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+Libiberty is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with libiberty; see the file COPYING.LIB.  If not, write
+to the Free Software Foundation, Inc., 51 Franklin Street - Fifth
+Floor, Boston, MA 02110-1301, USA.  */
+
+#include <windows.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <io.h>
+#include <process.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "libiberty.h"
+
+/* If non-zero, we have attempted to use cygpath.  CYGPATH_PEX may
+   still be NULL, if cygpath is unavailable.  */
+static int cygpath_initialized;
+
+/* If non-NULL, an instance of cygpath connected via a pipe.  */
+static struct pex_obj *cygpath_pex;
+
+/* The input to cygpath.  */
+static FILE *cygpath_in;
+
+/* The output from cygpath.  */
+static FILE *cygpath_out;
+
+/* If non-NULL, a file to which path translations are logged.  */
+static FILE *cygpath_log;
+
+/* Record MESSAGE in the CYGPATH_LOG.  MESSAGE is a format string,
+   which is expected to have a single "%s" field, to be replaced by
+   ARG.  */
+static void
+cygpath_log_msg_arg (const char *message, const char *arg)
+{
+  if (!cygpath_log)
+    return;
+  fprintf (cygpath_log, "[%d] cygpath: ", _getpid ());
+  fprintf (cygpath_log, message, arg);
+  fprintf (cygpath_log, "\n");
+  fflush (cygpath_log);
+}
+
+/* Record MESSAGE in the CYGPATH_LOG.  */
+static void
+cygpath_log_msg (const char *message)
+{
+  cygpath_log_msg_arg ("%s", message);
+}
+
+/* An error has occured.  Add the MESSAGE to the CYGPATH_LOG, noting
+   the cause of the error based on errno.  */
+static void
+cygpath_perror (const char *message)
+{
+  if (!cygpath_log)
+    return;
+  fprintf (cygpath_log, "[%d] cygpath: error: %s: %s\n",
+	   _getpid(), message, strerror (errno));
+  fflush (cygpath_log);
+}
+
+/* Closes CYGPATH_PEX and frees all associated
+   resoures.  */
+static void
+cygpath_close (void)
+{
+  /* Free resources.  */
+  if (cygpath_out)
+    {
+      fclose (cygpath_out);
+      cygpath_out = NULL;
+    }
+  if (cygpath_in)
+    {
+      fclose (cygpath_in);
+      cygpath_in = NULL;
+    }
+  if (cygpath_pex)
+    {
+      pex_free (cygpath_pex);
+      cygpath_pex = NULL;
+    }
+  if (cygpath_log)
+    {
+      cygpath_log_msg ("end");
+      cygpath_log = NULL;
+    }
+}
+
+/* CYG_PATH is a pointer to a Cygwin path.  This function converts the
+   Cygwin path to a Windows path, storing the result in
+   WIN32_PATH.  Returns true if the conversion was successful; false
+   otherwise.  */
+int
+cygpath (const char *cyg_path, char win32_path[MAX_PATH + 1])
+{
+  bool ok;
+  bool retrying;
+  
+  /* Special-case the empty path.  cygpath cannot handle the empty
+     path correctly.  It ignores the empty line, waiting for a
+     non-empty line, which in turn causes an application using this
+     function to appear stuck.  */
+  if (cyg_path[0] == '\0')
+    {
+      win32_path[0] = '\0';
+      return true;
+    }
+  
+  retrying = false;
+
+ retry:
+  if (!cygpath_initialized) 
+    {
+      const char *argv[] = { "cygpath", "-w", "-f", "-", NULL };
+      const char *cygpath_path;
+      const char *log;
+      int err;
+
+      /* If we are unable to invoke cygpath, we do not want to try
+	 again.  So, we set the initialized flag at this point; if
+	 errors occur during the invocation, it will remain set.  */
+      cygpath_initialized = 1;
+      /* Check to see if the user wants cygpath support.  */
+      cygpath_path = getenv ("CYGPATH");
+      if (!cygpath_path)
+	/* The user doesn't need to support Cygwin paths.  */
+	goto error;
+      /* If debugging, open the log file.  */
+      log = getenv ("CSL_DEBUG_CYGPATH");
+      if (log && log[0])
+	{
+	  /* The log file is opened for "append" so that multiple
+	     processes (perhaps invoked from "make") can share it.  */
+	  cygpath_log = fopen (log, "a");
+	  if (cygpath_log)
+	    cygpath_log_msg ("begin");
+	}
+      /* If the environment variable is set to a non-empty string, use
+	 that string as the path to cygpath.  */ 
+      if (cygpath_path[0] != '\0')
+	argv[0] = cygpath_path;
+      /* Create the pex object.  */
+      cygpath_pex = pex_init (PEX_SEARCH | PEX_USE_PIPES, 
+			      "cygpath", NULL);
+      if (!cygpath_pex)
+	goto error;
+      /* Get the FILE we will use to write to the child.  */
+      cygpath_in = pex_input_pipe (cygpath_pex, /*binary=*/0);
+      if (!cygpath_in)
+	goto error;
+      /* Start the child process.  */
+      if (pex_run (cygpath_pex, PEX_SEARCH | PEX_USE_PIPES, 
+		   argv[0], (char**) argv, 
+		   NULL, NULL,
+		   &err) != NULL)
+	goto error;
+      /* Get the FILE we will use to read from the child.  */
+      cygpath_out = pex_read_output (cygpath_pex, /*binary=*/1);
+      if (!cygpath_out)
+	goto error;
+    }
+  else if (!cygpath_pex) 
+    /* We previously tried to use cygpath, but something went wrong.  */
+    return false;
+
+  /* Write CYG_PATH to the child, on a line by itself.  */
+  cygpath_log_msg_arg ("-> %s", cyg_path);
+  if (fprintf (cygpath_in, "%s\n", cyg_path) < 0)
+    {
+      cygpath_perror ("write failed");
+      goto error;
+    }
+  /* Flush the output.  (We cannot set the stream into line-buffered
+     mode with setvbuf because Windows treats _IOLBF as a synonym for
+     _IOFBF.)  */
+  if (fflush (cygpath_in))
+    cygpath_perror ("flush failed");
+  /* Read the output.  */
+  ok = true;
+  while (1)
+    {
+      size_t pathlen;
+      if (!fgets (win32_path, MAX_PATH, cygpath_out))
+	{
+	  if (ferror (cygpath_out))
+	    cygpath_perror ("read failed");
+	  else
+	    {
+	      cygpath_log_msg ("error: EOF");
+	      /* Unfortunately, cygpath sometimes crashes for no
+		 apparent reason.  We give it two chances... */
+	      if (!retrying)
+		{
+		  retrying = true;
+		  cygpath_log_msg ("retrying");
+		  cygpath_close ();
+		  cygpath_initialized = 0;
+		  goto retry;
+		}
+	    }
+	  goto error;
+	}
+      pathlen = strlen (win32_path);
+      if (pathlen == 0 && ok)
+	/* This isn't a well-formed response from cygpath.  */
+	goto error;
+      if (win32_path[pathlen - 1] == '\n')
+	{
+	  win32_path[pathlen - 1] = '\0';
+	  cygpath_log_msg_arg ("<- %s", win32_path);
+	  break;
+	}
+      /* We didn't reach the end of the line.  There's no point in
+	 trying to use this output, since we know the length of
+	 paths are limited to MAX_PATH characters, but we read the
+	 entire line so that we are still in sync with
+	 cygpath.  */
+      ok = false;
+      if (cygpath_log)
+	cygpath_log_msg_arg ("error: invalid response: %s",
+			     win32_path);
+    }
+  
+  return ok;
+  
+ error:
+  cygpath_close();
+  return false;
+}
+
+/* Returns the handle for the MVCRT DLL, or NULL if it is not
+   available.  */
+static HMODULE
+msvcrt_dll (void)
+{
+  static HMODULE dll = (HMODULE)(-1);
+
+  /* After we call LoadLibrary, DLL will be either a valid handle or
+     NULL, so this check ensures that we only try to load the library
+     once.  */
+  if (dll == (HMODULE)(-1))
+    dll = LoadLibrary ("msvcrt.dll");
+
+  return dll;
+}
+
+/* Call the underlying MSVCRT fopen with PATH and MODE, and return
+   what it returns.  */
+static FILE *
+msvcrt_fopen (const char *path, const char *mode)
+{
+  typedef FILE *(fopen_type)(const char *path, 
+			     const char *mode);
+
+  static fopen_type *f = NULL;
+
+  /* Get the address of "fopen".  */
+  if (!f) 
+    {
+      HMODULE dll = msvcrt_dll ();
+      if (!dll)
+	{
+	  errno = ENOSYS;
+	  return NULL;
+	}
+      f = (fopen_type *) GetProcAddress (dll, "fopen");
+      if (!f)
+	{
+	  errno = ENOSYS;
+	  return NULL;
+	}
+    }
+
+  /* Call fopen.  */
+  return (*f)(path, mode);
+}
+
+FILE *
+fopen (const char *path, const char *mode)
+{
+  FILE *f;
+  char win32_path[MAX_PATH + 1];
+
+  /* Assume PATH is a Windows path.  */
+  f = msvcrt_fopen (path, mode);
+  if (f || errno != ENOENT)
+    return f;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    f = msvcrt_fopen (win32_path, mode);
+  return f;
+}
+
+int 
+open (const char *path, int oflag, ...)
+{
+  int fd;
+  char win32_path[MAX_PATH + 1];
+  int pmode = 0;
+
+  if ((oflag & _O_CREAT))
+    {
+      va_list ap;
+      va_start (ap, oflag);
+      pmode = va_arg (ap, int); 
+      va_end (ap);
+    }
+
+  /* Assume PATH is a Windows path.  */
+  fd = _open (path, oflag, pmode);
+  if (fd != -1 || errno != ENOENT)
+    return fd;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    fd = _open (win32_path, oflag, pmode);
+  return fd;
+}
+
+int
+stat (const char *path, struct stat *buffer)
+{
+  int r;
+  char win32_path[MAX_PATH + 1];
+
+  /* Assume PATH is a Windows path.  */
+  r = _stat (path, (struct _stat *) buffer);
+  if (r != -1 || errno != ENOENT)
+    return r;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    r = _stat (win32_path, (struct _stat *) buffer);
+  return r;
+}
+
+int
+access (const char *path, int mode)
+{
+  int r;
+  char win32_path[MAX_PATH + 1];
+
+#ifdef _WIN32
+  /* Some GNU tools mistakenly defined X_OK to 1 on Windows.  */
+  mode = mode & ~1;
+#endif
+  /* Assume PATH is a Windows path.  */
+  r = _access (path, mode);
+  if (r != -1 || errno != ENOENT)
+    return r;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    r = _access (win32_path, mode);
+  return r;
+}
+
+/* Given the WINDOWS_CODE (typically the result of GetLastError), set
+   ERRNO to the corresponding error code.  If there is no obvious
+   correspondence, ERRNO will be set to EACCES.  */
+static void
+set_errno_from_windows_code (DWORD windows_code)
+{
+  int mapping[][2] = {
+    {ERROR_ACCESS_DENIED, EACCES},
+    {ERROR_ACCOUNT_DISABLED, EACCES},
+    {ERROR_ACCOUNT_RESTRICTION, EACCES},
+    {ERROR_ALREADY_ASSIGNED, EBUSY},
+    {ERROR_ALREADY_EXISTS, EEXIST},
+    {ERROR_ARITHMETIC_OVERFLOW, ERANGE},
+    {ERROR_BAD_COMMAND, EIO},
+    {ERROR_BAD_DEVICE, ENODEV},
+    {ERROR_BAD_DRIVER_LEVEL, ENXIO},
+    {ERROR_BAD_EXE_FORMAT, ENOEXEC},
+    {ERROR_BAD_FORMAT, ENOEXEC},
+    {ERROR_BAD_LENGTH, EINVAL},
+    {ERROR_BAD_PATHNAME, ENOENT},
+    {ERROR_BAD_PIPE, EPIPE},
+    {ERROR_BAD_UNIT, ENODEV},
+    {ERROR_BAD_USERNAME, EINVAL},
+    {ERROR_BROKEN_PIPE, EPIPE},
+    {ERROR_BUFFER_OVERFLOW, ENOMEM},
+    {ERROR_BUSY, EBUSY},
+    {ERROR_BUSY_DRIVE, EBUSY},
+    {ERROR_CALL_NOT_IMPLEMENTED, ENOSYS},
+    {ERROR_CRC, EIO},
+    {ERROR_CURRENT_DIRECTORY, EINVAL},
+    {ERROR_DEVICE_IN_USE, EBUSY},
+    {ERROR_DIR_NOT_EMPTY, EEXIST},
+    {ERROR_DIRECTORY, ENOENT},
+    {ERROR_DISK_CHANGE, EIO},
+    {ERROR_DISK_FULL, ENOSPC},
+    {ERROR_DRIVE_LOCKED, EBUSY},
+    {ERROR_ENVVAR_NOT_FOUND, EINVAL},
+    {ERROR_EXE_MARKED_INVALID, ENOEXEC},
+    {ERROR_FILE_EXISTS, EEXIST},
+    {ERROR_FILE_INVALID, ENODEV},
+    {ERROR_FILE_NOT_FOUND, ENOENT},
+    {ERROR_FILENAME_EXCED_RANGE, ENAMETOOLONG},
+    {ERROR_GEN_FAILURE, EIO},
+    {ERROR_HANDLE_DISK_FULL, ENOSPC},
+    {ERROR_INSUFFICIENT_BUFFER,  ENOMEM},
+    {ERROR_INVALID_ACCESS, EINVAL},
+    {ERROR_INVALID_ADDRESS, EFAULT},
+    {ERROR_INVALID_BLOCK, EFAULT},
+    {ERROR_INVALID_DATA, EINVAL},
+    {ERROR_INVALID_DRIVE, ENODEV},
+    {ERROR_INVALID_EXE_SIGNATURE,  ENOEXEC},
+    {ERROR_INVALID_FLAGS, EINVAL},
+    {ERROR_INVALID_FUNCTION,  ENOSYS},
+    {ERROR_INVALID_HANDLE, EBADF},
+    {ERROR_INVALID_LOGON_HOURS,  EACCES},
+    {ERROR_INVALID_NAME, ENOENT},
+    {ERROR_INVALID_OWNER, EINVAL},
+    {ERROR_INVALID_PARAMETER, EINVAL},
+    {ERROR_INVALID_PASSWORD, EPERM},
+    {ERROR_INVALID_PRIMARY_GROUP, EINVAL},
+    {ERROR_INVALID_SIGNAL_NUMBER, EINVAL},
+    {ERROR_INVALID_TARGET_HANDLE, EIO},
+    {ERROR_INVALID_WORKSTATION, EACCES},
+    {ERROR_IO_DEVICE, EIO},
+    {ERROR_IO_INCOMPLETE, EINTR},
+    {ERROR_LOCKED, EBUSY},
+    {ERROR_LOGON_FAILURE, EACCES},
+    {ERROR_MAPPED_ALIGNMENT, EINVAL},
+    {ERROR_META_EXPANSION_TOO_LONG, E2BIG},
+    {ERROR_MORE_DATA, EPIPE},
+    {ERROR_NEGATIVE_SEEK, ESPIPE},
+    {ERROR_NO_DATA, EPIPE},
+    {ERROR_NO_MORE_SEARCH_HANDLES, EIO},
+    {ERROR_NO_PROC_SLOTS, EAGAIN},
+    {ERROR_NO_SUCH_PRIVILEGE, EACCES},
+    {ERROR_NOACCESS, EFAULT},
+    {ERROR_NONE_MAPPED, EINVAL},
+    {ERROR_NOT_ENOUGH_MEMORY, ENOMEM},
+    {ERROR_NOT_READY, ENODEV},
+    {ERROR_NOT_SAME_DEVICE, EXDEV},
+    {ERROR_OPEN_FAILED, EIO},
+    {ERROR_OPERATION_ABORTED, EINTR},
+    {ERROR_OUTOFMEMORY,  ENOMEM},
+    {ERROR_PASSWORD_EXPIRED, EACCES},
+    {ERROR_PATH_BUSY,  EBUSY},
+    {ERROR_PATH_NOT_FOUND, ENOTDIR},
+    {ERROR_PIPE_BUSY, EBUSY},
+    {ERROR_PIPE_CONNECTED, EPIPE},
+    {ERROR_PIPE_LISTENING, EPIPE},
+    {ERROR_PIPE_NOT_CONNECTED, EPIPE},
+    {ERROR_PRIVILEGE_NOT_HELD, EACCES},
+    {ERROR_READ_FAULT, EIO},
+    {ERROR_SEEK, ESPIPE},
+    {ERROR_SEEK_ON_DEVICE, ESPIPE},
+    {ERROR_SHARING_BUFFER_EXCEEDED, ENFILE},
+    {ERROR_STACK_OVERFLOW, ENOMEM},
+    {ERROR_SWAPERROR, ENOENT},
+    {ERROR_TOO_MANY_MODULES, EMFILE},
+    {ERROR_TOO_MANY_OPEN_FILES, EMFILE},
+    {ERROR_UNRECOGNIZED_MEDIA,  ENXIO},
+    {ERROR_UNRECOGNIZED_VOLUME,  ENODEV},
+    {ERROR_WAIT_NO_CHILDREN,  ECHILD},
+    {ERROR_WRITE_FAULT, EIO},
+    {ERROR_WRITE_PROTECT, EROFS}
+/*  MinGW does not define ETXTBSY as yet.  
+    {ERROR_LOCK_VIOLATION, ETXTBSY},
+    {ERROR_SHARING_VIOLATION, ETXTBSY}, 
+*/
+  };
+
+  size_t i;
+
+  for (i = 0; i < sizeof (mapping)/sizeof (mapping[0]); ++i)
+    if (mapping[i][0] == windows_code)
+      {
+	errno = mapping[i][1];
+	return;
+      }
+
+  /* Unrecognized error. Use EACCESS to have some error code,
+     not misleading "No error" thing.  */
+  errno = EACCES;      
+}
+
+int rename (const char *oldpath, const char *newpath)
+{
+  BOOL r;
+  int oldpath_converted = 0;
+  char win32_oldpath[MAX_PATH + 1];
+  char win32_newpath[MAX_PATH + 1];
+
+  /* Older versions of the cygpath program called FindFirstFile, but
+     not FindClose.  As a result, a long-running cygpath program ends
+     up leaking these handles, and, as a result, the Windows kernel
+     will not let us remove or rename things in directories.  Therefore,
+     we kill the child cygpath program now.
+
+     The defect in cygpath was corrected by this patch:
+
+       http://cygwin.com/ml/cygwin-patches/2007-q1/msg00033.html
+
+     but older versions of cygpath will be in use for the forseeable
+     future.  */
+
+  cygpath_close ();
+  cygpath_initialized = 0;
+
+  /* Assume all paths are Windows paths.  */
+  r = MoveFileEx (oldpath, newpath, MOVEFILE_REPLACE_EXISTING);
+  if (r)
+      return 0;
+  else if (GetLastError () != ERROR_PATH_NOT_FOUND)
+    goto error;
+
+  /* Perhaps the old path is a cygwin path?  */
+  if (cygpath (oldpath, win32_oldpath))
+    {
+      oldpath_converted = 1;
+      r = MoveFileEx (win32_oldpath, newpath, MOVEFILE_REPLACE_EXISTING);      
+      if (r)
+          return 0;
+      else if (GetLastError () != ERROR_PATH_NOT_FOUND)
+          goto error;
+    }
+
+  /* Perhaps the new path is a cygwin path?  */
+  if (cygpath (newpath, win32_newpath))
+    {
+      r = MoveFileEx (oldpath_converted ? win32_oldpath : oldpath,
+		      win32_newpath, MOVEFILE_REPLACE_EXISTING);
+      if (r == TRUE)
+	return 0;
+    }
+error:
+  set_errno_from_windows_code (GetLastError ());
+  return -1;      
+}
+
+int remove (const char *pathname)
+{
+  int r;
+  char win32_path[MAX_PATH + 1];
+
+  cygpath_close ();
+  cygpath_initialized = 0;
+
+  /* Assume PATH is a Windows path.  */
+  r = _unlink (pathname);
+  if (r != -1 || errno != ENOENT)
+    return r;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (pathname, win32_path))
+    r = _unlink (win32_path);
+  return r;
+}
+
+int unlink(const char *pathname)
+{
+    return remove (pathname);
+}
+
+int
+chdir (const char *path)
+{
+  int ret;
+  char win32_path[MAX_PATH + 1];
+
+  /* Assume PATH is a Windows path.  */
+  ret = _chdir (path);
+  if (ret != -1 || errno != ENOENT)
+    return ret;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    ret = _chdir (win32_path);
+  return ret;
+}
diff -Nur a/libiberty/lrealpath.c b/libiberty/lrealpath.c
--- a/libiberty/lrealpath.c	2005-05-24 22:48:25.000000000 +0200
+++ b/libiberty/lrealpath.c	2010-01-25 09:50:29.615687242 +0100
@@ -138,6 +138,17 @@
   {
     char buf[MAX_PATH];
     char* basename;
+
+    if (_access (filename, F_OK) != 0)
+      {
+	char cygbuf[MAX_PATH + 1];
+	/* The file does not exist.  It's fine to call lrealpath
+	   on a non-existing path... but if this would be an existing
+	   path after cygpath conversion, use that instead.  */
+	if (cygpath (filename, cygbuf) && _access (cygbuf, F_OK) == 0)
+	  filename = cygbuf;
+      }
+
     DWORD len = GetFullPathName (filename, MAX_PATH, buf, &basename);
     if (len == 0 || len > MAX_PATH - 1)
       return strdup (filename);
diff -Nur a/libiberty/Makefile.in b/libiberty/Makefile.in
--- a/libiberty/Makefile.in	2008-10-22 15:30:19.000000000 +0200
+++ b/libiberty/Makefile.in	2010-01-25 09:50:29.615687242 +0100
@@ -124,7 +124,7 @@
 CFILES = alloca.c argv.c asprintf.c atexit.c				\
 	basename.c bcmp.c bcopy.c bsearch.c bzero.c			\
 	calloc.c choose-temp.c clock.c concat.c cp-demangle.c		\
-	 cp-demint.c cplus-dem.c					\
+	 cp-demint.c cplus-dem.c cygpath.c				\
 	dyn-string.c							\
 	fdmatch.c ffs.c fibheap.c filename_cmp.c floatformat.c		\
 	fnmatch.c fopen_unlocked.c					\
@@ -182,7 +182,7 @@
 # maint-missing" and "make check".
 CONFIGURED_OFILES = ./asprintf.o ./atexit.o				\
 	./basename.o ./bcmp.o ./bcopy.o ./bsearch.o ./bzero.o		\
-	./calloc.o ./clock.o ./copysign.o				\
+	./calloc.o ./clock.o ./copysign.o ./cygpath.o			\
 	./_doprnt.o							\
 	./ffs.o								\
 	./getcwd.o ./getpagesize.o ./gettimeofday.o			\
@@ -619,6 +619,13 @@
 	else true; fi
 	$(COMPILE.c) $(srcdir)/cplus-dem.c $(OUTPUT_OPTION)
 
+./cygpath.o: $(srcdir)/cygpath.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/cygpath.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/cygpath.c $(OUTPUT_OPTION)
+
 ./dyn-string.o: $(srcdir)/dyn-string.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/dyn-string.h $(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
diff -Nur a/libiberty/pex-win32.c b/libiberty/pex-win32.c
--- a/libiberty/pex-win32.c	2008-08-07 21:30:14.000000000 +0200
+++ b/libiberty/pex-win32.c	2010-01-25 09:50:29.615687242 +0100
@@ -119,7 +119,7 @@
 pex_win32_open_read (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,
 		     int binary)
 {
-  return _open (name, _O_RDONLY | (binary ? _O_BINARY : _O_TEXT));
+  return open (name, _O_RDONLY | (binary ? _O_BINARY : _O_TEXT));
 }
 
 /* Open a file for writing.  */
@@ -130,10 +130,10 @@
 {
   /* Note that we can't use O_EXCL here because gcc may have already
      created the temporary file via make_temp_file.  */
-  return _open (name,
-		(_O_WRONLY | _O_CREAT | _O_TRUNC
-		 | (binary ? _O_BINARY : _O_TEXT)),
-		_S_IREAD | _S_IWRITE);
+  return open (name,
+	       (_O_WRONLY | _O_CREAT | _O_TRUNC
+		| (binary ? _O_BINARY : _O_TEXT)),
+	       _S_IREAD | _S_IWRITE);
 }
 
 /* Close a file.  */
@@ -746,6 +746,28 @@
   OSVERSIONINFO version_info;
   STARTUPINFO si;
   PROCESS_INFORMATION pi;
+  int orig_out, orig_in, orig_err;
+  BOOL separate_stderr = !(flags & PEX_STDERR_TO_STDOUT);
+
+  /* Ensure we have inheritable descriptors to pass to the child, and close the
+     original descriptors.  */
+  orig_in = in;
+  in = _dup (orig_in);
+  if (orig_in != STDIN_FILENO)
+    _close (orig_in);
+  
+  orig_out = out;
+  out = _dup (orig_out);
+  if (orig_out != STDOUT_FILENO)
+    _close (orig_out);
+  
+  if (separate_stderr)
+    {
+      orig_err = errdes;
+      errdes = _dup (orig_err);
+      if (orig_err != STDERR_FILENO)
+	_close (orig_err);
+    }
 
   stdin_handle = INVALID_HANDLE_VALUE;
   stdout_handle = INVALID_HANDLE_VALUE;
@@ -753,7 +775,7 @@
 
   stdin_handle = (HANDLE) _get_osfhandle (in);
   stdout_handle = (HANDLE) _get_osfhandle (out);
-  if (!(flags & PEX_STDERR_TO_STDOUT))
+  if (separate_stderr)
     stderr_handle = (HANDLE) _get_osfhandle (errdes);
   else
     stderr_handle = stdout_handle;
@@ -822,12 +844,13 @@
       *errmsg = "CreateProcess";
     }
 
-  /* Close the standard output and standard error handles in the
-     parent.  */ 
-  if (out != STDOUT_FILENO)
-    obj->funcs->close (obj, out);
-  if (errdes != STDERR_FILENO)
-    obj->funcs->close (obj, errdes);
+  /* Close the standard input, standard output and standard error handles
+     in the parent.  */ 
+
+  _close (in);
+  _close (out);
+  if (separate_stderr)
+    _close (errdes);
 
   return pid;
 }
@@ -883,7 +906,7 @@
 pex_win32_pipe (struct pex_obj *obj ATTRIBUTE_UNUSED, int *p,
 		int binary)
 {
-  return _pipe (p, 256, binary ? _O_BINARY : _O_TEXT);
+  return _pipe (p, 256, (binary ? _O_BINARY : _O_TEXT) | _O_NOINHERIT);
 }
 
 /* Get a FILE pointer to read from a file descriptor.  */
diff -Nur a/libiberty/testsuite/test-expandargv.c b/libiberty/testsuite/test-expandargv.c
--- a/libiberty/testsuite/test-expandargv.c	2006-01-20 23:55:36.000000000 +0100
+++ b/libiberty/testsuite/test-expandargv.c	2010-01-25 09:50:29.615687242 +0100
@@ -107,6 +107,38 @@
   ARGV0,
   0,
 
+  /* Test 4 - Check for options beginning with an empty line.  */
+  "\na\nb",	/* Test 4 data */
+  ARGV0,
+  "@test-expandargv-4.lst",
+  0,
+  ARGV0,
+  "a",
+  "b",
+  0,
+
+  /* Test 5 - Check for options containing an empty argument.  */
+  "a\n''\nb",    /* Test 5 data */
+  ARGV0,
+  "@test-expandargv-5.lst",
+  0,
+  ARGV0,
+  "a",
+  "",
+  "b",
+  0,
+
+  /* Test 6 - Check for options containing a quoted newline.  */
+  "a\n'a\n\nb'\nb",    /* Test 6 data */
+  ARGV0,
+  "@test-expandargv-6.lst",
+  0,
+  ARGV0,
+  "a",
+  "a\n\nb",
+  "b",
+  0,
+
   0 /* Test done marker, don't remove. */
 };
 
@@ -246,7 +278,7 @@
       /* Compare each of the argv's ... */
       else
         for (k = 0; k < argc_after; k++)
-          if (strncmp (argv_before[k], argv_after[k], strlen(argv_after[k])) != 0)
+          if (strcmp (argv_before[k], argv_after[k]) != 0)
             {
               printf ("FAIL: test-expandargv-%d. Arguments don't match.\n", i);
               failed++;
diff -Nur a/libjava/classpath/configure b/libjava/classpath/configure
--- a/libjava/classpath/configure	2009-03-16 13:08:23.000000000 +0100
+++ b/libjava/classpath/configure	2010-01-25 09:50:29.625686976 +0100
@@ -461,7 +461,7 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os JAVA_MAINTAINER_MODE_TRUE JAVA_MAINTAINER_MODE_FALSE GENINSRC_TRUE GENINSRC_FALSE multi_basedir INSTALL_BINARIES_TRUE INSTALL_BINARIES_FALSE LIBVERSION CLASSPATH_MODULE CLASSPATH_CONVENIENCE INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CREATE_COLLECTIONS_TRUE CREATE_COLLECTIONS_FALSE CREATE_JNI_LIBRARIES_TRUE CREATE_JNI_LIBRARIES_FALSE CREATE_CORE_JNI_LIBRARIES_TRUE CREATE_CORE_JNI_LIBRARIES_FALSE CREATE_GCONF_PEER_LIBRARIES_TRUE CREATE_GCONF_PEER_LIBRARIES_FALSE CREATE_GSTREAMER_PEER_LIBRARIES_TRUE CREATE_GSTREAMER_PEER_LIBRARIES_FALSE default_toolkit CREATE_XMLJ_LIBRARY_TRUE CREATE_XMLJ_LIBRARY_FALSE CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CPP EGREP CREATE_ALSA_LIBRARIES_TRUE CREATE_ALSA_LIBRARIES_FALSE CREATE_DSSI_LIBRARIES_TRUE CREATE_DSSI_LIBRARIES_FALSE CREATE_GTK_PEER_LIBRARIES_TRUE CREATE_GTK_PEER_LIBRARIES_FALSE CREATE_QT_PEER_LIBRARIES_TRUE CREATE_QT_PEER_LIBRARIES_FALSE CREATE_PLUGIN_TRUE CREATE_PLUGIN_FALSE CREATE_GJDOC_TRUE CREATE_GJDOC_FALSE toolexeclibdir nativeexeclibdir glibjdir CREATE_JNI_HEADERS_TRUE CREATE_JNI_HEADERS_FALSE CREATE_GJDOC_PARSER_TRUE CREATE_GJDOC_PARSER_FALSE CREATE_WRAPPERS_TRUE CREATE_WRAPPERS_FALSE LN_S LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM OBJDUMP ac_ct_OBJDUMP AR ac_ct_AR RANLIB ac_ct_RANLIB lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE CXXCPP PERL COLLECTIONS_PREFIX LIBMAGIC LIBICONV LTLIBICONV WARNING_CFLAGS EXTRA_CFLAGS STRICT_WARNING_CFLAGS ERROR_CFLAGS PKG_CONFIG XML_CFLAGS XML_LIBS XSLT_CFLAGS XSLT_LIBS X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS GTK_CFLAGS GTK_LIBS FREETYPE2_CFLAGS FREETYPE2_LIBS PANGOFT2_CFLAGS PANGOFT2_LIBS CAIRO_CFLAGS CAIRO_LIBS XTEST_LIBS GCONF_CFLAGS GCONF_LIBS GDK_CFLAGS GDK_LIBS GSTREAMER_CFLAGS GSTREAMER_LIBS GSTREAMER_BASE_CFLAGS GSTREAMER_BASE_LIBS GSTREAMER_PLUGINS_BASE_CFLAGS GSTREAMER_PLUGINS_BASE_LIBS GST_PLUGIN_LDFLAGS GSTREAMER_FILE_READER GSTREAMER_MIXER_PROVIDER QT_CFLAGS QT_LIBS MOC MOZILLA_CFLAGS MOZILLA_LIBS GLIB_CFLAGS GLIB_LIBS PLUGIN_DIR GMP_CFLAGS GMP_LIBS USER_JAVAH CLASSPATH_INCLUDES vm_classes MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LIBDEBUG INIT_LOAD_LIBRARY ECJ_JAR JAVA_LANG_SYSTEM_EXPLICIT_INITIALIZATION REMOVE MKDIR CP DATE FIND ZIP JAR WITH_JAR_TRUE WITH_JAR_FALSE INSTALL_GLIBJ_ZIP_TRUE INSTALL_GLIBJ_ZIP_FALSE INSTALL_CLASS_FILES_TRUE INSTALL_CLASS_FILES_FALSE BUILD_CLASS_FILES_TRUE BUILD_CLASS_FILES_FALSE EXAMPLESDIR TOOLSDIR GJDOC CREATE_API_DOCS_TRUE CREATE_API_DOCS_FALSE JAY JAY_SKELETON REGEN_PARSERS_TRUE REGEN_PARSERS_FALSE USE_PREBUILT_GLIBJ_ZIP_TRUE USE_PREBUILT_GLIBJ_ZIP_FALSE PATH_TO_GLIBJ_ZIP JAVA uudecode JAVAC JAVAC_IS_GCJ GCJ_JAVAC_TRUE GCJ_JAVAC_FALSE ANTLR_JAR ANTLR ac_ct_ANTLR JAVAC_MEM_OPT USE_ESCHER_TRUE USE_ESCHER_FALSE PATH_TO_ESCHER ENABLE_LOCAL_SOCKETS_TRUE ENABLE_LOCAL_SOCKETS_FALSE DEFAULT_PREFS_PEER WANT_NATIVE_BIG_INTEGER CREATE_GMPBI_LIBRARY_TRUE CREATE_GMPBI_LIBRARY_FALSE LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os JAVA_MAINTAINER_MODE_TRUE JAVA_MAINTAINER_MODE_FALSE GENINSRC_TRUE GENINSRC_FALSE multi_basedir INSTALL_BINARIES_TRUE INSTALL_BINARIES_FALSE LIBVERSION CLASSPATH_MODULE CLASSPATH_CONVENIENCE INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CREATE_COLLECTIONS_TRUE CREATE_COLLECTIONS_FALSE CREATE_JNI_LIBRARIES_TRUE CREATE_JNI_LIBRARIES_FALSE CREATE_CORE_JNI_LIBRARIES_TRUE CREATE_CORE_JNI_LIBRARIES_FALSE CREATE_GCONF_PEER_LIBRARIES_TRUE CREATE_GCONF_PEER_LIBRARIES_FALSE CREATE_GSTREAMER_PEER_LIBRARIES_TRUE CREATE_GSTREAMER_PEER_LIBRARIES_FALSE default_toolkit CREATE_XMLJ_LIBRARY_TRUE CREATE_XMLJ_LIBRARY_FALSE CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CPP EGREP CREATE_ALSA_LIBRARIES_TRUE CREATE_ALSA_LIBRARIES_FALSE CREATE_DSSI_LIBRARIES_TRUE CREATE_DSSI_LIBRARIES_FALSE CREATE_GTK_PEER_LIBRARIES_TRUE CREATE_GTK_PEER_LIBRARIES_FALSE CREATE_QT_PEER_LIBRARIES_TRUE CREATE_QT_PEER_LIBRARIES_FALSE CREATE_PLUGIN_TRUE CREATE_PLUGIN_FALSE CREATE_GJDOC_TRUE CREATE_GJDOC_FALSE target_noncanonical toolexecdir toolexecmainlibdir toolexeclibdir nativeexeclibdir glibjdir CREATE_JNI_HEADERS_TRUE CREATE_JNI_HEADERS_FALSE CREATE_GJDOC_PARSER_TRUE CREATE_GJDOC_PARSER_FALSE CREATE_WRAPPERS_TRUE CREATE_WRAPPERS_FALSE LN_S LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM OBJDUMP ac_ct_OBJDUMP AR ac_ct_AR RANLIB ac_ct_RANLIB lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE CXXCPP PERL COLLECTIONS_PREFIX LIBMAGIC LIBICONV LTLIBICONV WARNING_CFLAGS EXTRA_CFLAGS STRICT_WARNING_CFLAGS ERROR_CFLAGS PKG_CONFIG XML_CFLAGS XML_LIBS XSLT_CFLAGS XSLT_LIBS X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS GTK_CFLAGS GTK_LIBS FREETYPE2_CFLAGS FREETYPE2_LIBS PANGOFT2_CFLAGS PANGOFT2_LIBS CAIRO_CFLAGS CAIRO_LIBS XTEST_LIBS GCONF_CFLAGS GCONF_LIBS GDK_CFLAGS GDK_LIBS GSTREAMER_CFLAGS GSTREAMER_LIBS GSTREAMER_BASE_CFLAGS GSTREAMER_BASE_LIBS GSTREAMER_PLUGINS_BASE_CFLAGS GSTREAMER_PLUGINS_BASE_LIBS GST_PLUGIN_LDFLAGS GSTREAMER_FILE_READER GSTREAMER_MIXER_PROVIDER QT_CFLAGS QT_LIBS MOC MOZILLA_CFLAGS MOZILLA_LIBS GLIB_CFLAGS GLIB_LIBS PLUGIN_DIR GMP_CFLAGS GMP_LIBS USER_JAVAH CLASSPATH_INCLUDES vm_classes MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LIBDEBUG INIT_LOAD_LIBRARY ECJ_JAR JAVA_LANG_SYSTEM_EXPLICIT_INITIALIZATION REMOVE MKDIR CP DATE FIND ZIP JAR WITH_JAR_TRUE WITH_JAR_FALSE INSTALL_GLIBJ_ZIP_TRUE INSTALL_GLIBJ_ZIP_FALSE INSTALL_CLASS_FILES_TRUE INSTALL_CLASS_FILES_FALSE BUILD_CLASS_FILES_TRUE BUILD_CLASS_FILES_FALSE EXAMPLESDIR TOOLSDIR GJDOC CREATE_API_DOCS_TRUE CREATE_API_DOCS_FALSE JAY JAY_SKELETON REGEN_PARSERS_TRUE REGEN_PARSERS_FALSE USE_PREBUILT_GLIBJ_ZIP_TRUE USE_PREBUILT_GLIBJ_ZIP_FALSE PATH_TO_GLIBJ_ZIP JAVA uudecode JAVAC JAVAC_IS_GCJ GCJ_JAVAC_TRUE GCJ_JAVAC_FALSE ANTLR_JAR ANTLR ac_ct_ANTLR JAVAC_MEM_OPT USE_ESCHER_TRUE USE_ESCHER_FALSE PATH_TO_ESCHER ENABLE_LOCAL_SOCKETS_TRUE ENABLE_LOCAL_SOCKETS_FALSE DEFAULT_PREFS_PEER WANT_NATIVE_BIG_INTEGER CREATE_GMPBI_LIBRARY_TRUE CREATE_GMPBI_LIBRARY_FALSE LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 ac_pwd=`pwd`
 
@@ -1063,6 +1063,9 @@
                           (disabled by --disable-gmp) default=yes
   --disable-gjdoc         compile GJDoc (disabled by --disable-gjdoc)
                           default=yes
+  --enable-version-specific-runtime-libs
+                          specify that runtime libraries should be installed
+                          in a compiler-specific directory
   --enable-regen-headers  automatically regenerate JNI headers default=yes if
                           headers don't exist
   --enable-regen-gjdoc-parser
@@ -4838,11 +4841,57 @@
 fi
 
 
+# Check whether --enable-version-specific-runtime-libs or --disable-version-specific-runtime-libs was given.
+if test "${enable_version_specific_runtime_libs+set}" = set; then
+  enableval="$enable_version_specific_runtime_libs"
+  case "$enableval" in
+      yes) version_specific_libs=yes ;;
+      no)  version_specific_libs=no ;;
+      *)   { { echo "$as_me:$LINENO: error: Unknown argument to enable/disable version-specific libs" >&5
+echo "$as_me: error: Unknown argument to enable/disable version-specific libs" >&2;}
+   { (exit 1); exit 1; }; };;
+     esac
+else
+  version_specific_libs=no
+
+fi;
+
+  case ${host_alias} in
+    "") host_noncanonical=${build_noncanonical} ;;
+    *) host_noncanonical=${host_alias} ;;
+  esac
+  case ${target_alias} in
+    "") target_noncanonical=${host_noncanonical} ;;
+    *) target_noncanonical=${target_alias} ;;
+  esac
+
 
-  multi_os_directory=`$CC -print-multi-os-directory`
-  case $multi_os_directory in
-    .) toolexeclibdir=${libdir} ;; # Avoid trailing /.
-    *) toolexeclibdir=${libdir}/${multi_os_directory} ;;
+  case ${version_specific_libs} in
+    yes)
+      # Need the gcc compiler version to know where to install libraries
+      # and header files if --enable-version-specific-runtime-libs option
+      # is selected.
+      includedir='$(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include/'
+      toolexecdir='$(libdir)/gcc/$(target_noncanonical)'
+      toolexecmainlibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+      toolexeclibdir=$toolexecmainlibdir
+      ;;
+    no)
+      if test -n "$with_cross_host" &&
+	 test x"$with_cross_host" != x"no"; then
+	# Install a library built with a cross compiler in tooldir, not libdir.
+	toolexecdir='$(exec_prefix)/$(target_noncanonical)'
+	toolexecmainlibdir='$(toolexecdir)/lib'
+      else
+	toolexecdir='$(libdir)/gcc-lib/$(target_noncanonical)'
+	toolexecmainlibdir='$(libdir)'
+      fi
+      multi_os_directory=`$CC -print-multi-os-directory`
+      case $multi_os_directory in
+	.) toolexeclibdir=$toolexecmainlibdir ;; # Avoid trailing /.
+	*) toolexeclibdir=$toolexecmainlibdir/$multi_os_directory ;;
+      esac
+      ;;
   esac
 
 
@@ -5753,13 +5802,13 @@
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:5756: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:5807: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:5759: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:5810: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:5762: output\"" >&5)
+  (eval echo "\"\$as_me:5813: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
@@ -6905,7 +6954,7 @@
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 6908 "configure"' > conftest.$ac_ext
+  echo '#line 6959 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -8191,11 +8240,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8194: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8245: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8198: \$? = $ac_status" >&5
+   echo "$as_me:8249: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8530,11 +8579,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8533: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8584: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8537: \$? = $ac_status" >&5
+   echo "$as_me:8588: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8635,11 +8684,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8638: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8689: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8642: \$? = $ac_status" >&5
+   echo "$as_me:8693: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -8690,11 +8739,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8693: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8744: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8697: \$? = $ac_status" >&5
+   echo "$as_me:8748: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -11557,7 +11606,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11560 "configure"
+#line 11611 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11653,7 +11702,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11656 "configure"
+#line 11707 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -16084,11 +16133,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:16087: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:16138: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:16091: \$? = $ac_status" >&5
+   echo "$as_me:16142: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -16183,11 +16232,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:16186: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:16237: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:16190: \$? = $ac_status" >&5
+   echo "$as_me:16241: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -16235,11 +16284,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:16238: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:16289: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:16242: \$? = $ac_status" >&5
+   echo "$as_me:16293: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -29270,7 +29319,7 @@
 if uudecode$EXEEXT Test.uue; then
         ac_cv_prog_uudecode_base64=yes
 else
-        echo "configure: 29273: uudecode had trouble decoding base 64 file 'Test.uue'" >&5
+        echo "configure: 29324: uudecode had trouble decoding base 64 file 'Test.uue'" >&5
         echo "configure: failed file was:" >&5
         cat Test.uue >&5
         ac_cv_prog_uudecode_base64=no
@@ -29417,7 +29466,7 @@
 JAVA_TEST=Object.java
 CLASS_TEST=Object.class
 cat << \EOF > $JAVA_TEST
-/* #line 29420 "configure" */
+/* #line 29471 "configure" */
 package java.lang;
 
 public class Object
@@ -29466,7 +29515,7 @@
 CLASS_TEST=Test.class
 TEST=Test
 cat << \EOF > $JAVA_TEST
-/* [#]line 29469 "configure" */
+/* [#]line 29520 "configure" */
 public class Test {
 public static void main (String args[]) {
         System.exit (0);
@@ -29786,7 +29835,7 @@
 JAVA_TEST=Object.java
 CLASS_TEST=Object.class
 cat << \EOF > $JAVA_TEST
-/* #line 29789 "configure" */
+/* #line 29840 "configure" */
 package java.lang;
 
 public class Object
@@ -29827,7 +29876,7 @@
   JAVA_TEST=Test.java
   CLASS_TEST=Test.class
   cat << \EOF > $JAVA_TEST
-  /* #line 29830 "configure" */
+  /* #line 29881 "configure" */
   public class Test
   {
     public static void main(String args)
@@ -31681,6 +31730,9 @@
 s,@CREATE_PLUGIN_FALSE@,$CREATE_PLUGIN_FALSE,;t t
 s,@CREATE_GJDOC_TRUE@,$CREATE_GJDOC_TRUE,;t t
 s,@CREATE_GJDOC_FALSE@,$CREATE_GJDOC_FALSE,;t t
+s,@target_noncanonical@,$target_noncanonical,;t t
+s,@toolexecdir@,$toolexecdir,;t t
+s,@toolexecmainlibdir@,$toolexecmainlibdir,;t t
 s,@toolexeclibdir@,$toolexeclibdir,;t t
 s,@nativeexeclibdir@,$nativeexeclibdir,;t t
 s,@glibjdir@,$glibjdir,;t t
diff -Nur a/libjava/classpath/configure.ac b/libjava/classpath/configure.ac
--- a/libjava/classpath/configure.ac	2009-03-16 13:08:23.000000000 +0100
+++ b/libjava/classpath/configure.ac	2010-01-25 09:50:29.625686976 +0100
@@ -316,6 +316,16 @@
 dnl so that we can refer to the multilib installation directories from
 dnl classpath's build files.
 dnl -----------------------------------------------------------
+AC_ARG_ENABLE(version-specific-runtime-libs,
+  AS_HELP_STRING([--enable-version-specific-runtime-libs],    
+                 [specify that runtime libraries should be installed in a compiler-specific directory]),
+    [case "$enableval" in
+      yes) version_specific_libs=yes ;;
+      no)  version_specific_libs=no ;;
+      *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs]);;
+     esac],
+    [version_specific_libs=no]
+)
 CLASSPATH_TOOLEXECLIBDIR
 
 dnl -----------------------------------------------------------
diff -Nur a/libjava/classpath/doc/api/Makefile.in b/libjava/classpath/doc/api/Makefile.in
--- a/libjava/classpath/doc/api/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/doc/api/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -334,9 +334,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 @CREATE_API_DOCS_TRUE@noinst_DATA = html
diff -Nur a/libjava/classpath/doc/Makefile.in b/libjava/classpath/doc/Makefile.in
--- a/libjava/classpath/doc/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/doc/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -357,9 +357,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 SUBDIRS = api
diff -Nur a/libjava/classpath/examples/Makefile.in b/libjava/classpath/examples/Makefile.in
--- a/libjava/classpath/examples/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/examples/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -343,9 +343,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 GLIBJ_CLASSPATH = '$(top_builddir)/lib/glibj.zip:$(top_builddir)/lib'
diff -Nur a/libjava/classpath/external/jsr166/Makefile.in b/libjava/classpath/external/jsr166/Makefile.in
--- a/libjava/classpath/external/jsr166/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/external/jsr166/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -332,9 +332,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 EXTRA_DIST = IMPORTING \
diff -Nur a/libjava/classpath/external/Makefile.in b/libjava/classpath/external/Makefile.in
--- a/libjava/classpath/external/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/external/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -341,9 +341,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 SUBDIRS = sax w3c_dom relaxngDatatype jsr166
diff -Nur a/libjava/classpath/external/relaxngDatatype/Makefile.in b/libjava/classpath/external/relaxngDatatype/Makefile.in
--- a/libjava/classpath/external/relaxngDatatype/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/external/relaxngDatatype/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -332,9 +332,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 EXTRA_DIST = README.txt \
diff -Nur a/libjava/classpath/external/sax/Makefile.in b/libjava/classpath/external/sax/Makefile.in
--- a/libjava/classpath/external/sax/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/external/sax/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -332,9 +332,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 EXTRA_DIST = README \
diff -Nur a/libjava/classpath/external/w3c_dom/Makefile.in b/libjava/classpath/external/w3c_dom/Makefile.in
--- a/libjava/classpath/external/w3c_dom/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/external/w3c_dom/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -332,9 +332,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 EXTRA_DIST = README \
diff -Nur a/libjava/classpath/include/Makefile.in b/libjava/classpath/include/Makefile.in
--- a/libjava/classpath/include/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/include/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -333,9 +333,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 @CREATE_JNI_HEADERS_FALSE@DISTCLEANFILES = jni_md.h config-int.h
diff -Nur a/libjava/classpath/lib/Makefile.in b/libjava/classpath/lib/Makefile.in
--- a/libjava/classpath/lib/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/lib/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -337,9 +337,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 JAVA_DEPEND = java.dep
diff -Nur a/libjava/classpath/m4/acinclude.m4 b/libjava/classpath/m4/acinclude.m4
--- a/libjava/classpath/m4/acinclude.m4	2008-10-21 19:55:01.000000000 +0200
+++ b/libjava/classpath/m4/acinclude.m4	2010-01-25 09:50:29.625686976 +0100
@@ -247,11 +247,45 @@
 dnl -----------------------------------------------------------
 AC_DEFUN([CLASSPATH_TOOLEXECLIBDIR],
 [
-  multi_os_directory=`$CC -print-multi-os-directory`
-  case $multi_os_directory in
-    .) toolexeclibdir=${libdir} ;; # Avoid trailing /.
-    *) toolexeclibdir=${libdir}/${multi_os_directory} ;;
+  case ${host_alias} in
+    "") host_noncanonical=${build_noncanonical} ;;
+    *) host_noncanonical=${host_alias} ;;
   esac
+  case ${target_alias} in
+    "") target_noncanonical=${host_noncanonical} ;;
+    *) target_noncanonical=${target_alias} ;;
+  esac
+  AC_SUBST(target_noncanonical)
+
+  case ${version_specific_libs} in
+    yes)
+      # Need the gcc compiler version to know where to install libraries
+      # and header files if --enable-version-specific-runtime-libs option
+      # is selected.
+      includedir='$(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include/'
+      toolexecdir='$(libdir)/gcc/$(target_noncanonical)'
+      toolexecmainlibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+      toolexeclibdir=$toolexecmainlibdir
+      ;;
+    no)
+      if test -n "$with_cross_host" &&
+	 test x"$with_cross_host" != x"no"; then
+	# Install a library built with a cross compiler in tooldir, not libdir.
+	toolexecdir='$(exec_prefix)/$(target_noncanonical)'
+	toolexecmainlibdir='$(toolexecdir)/lib'
+      else
+	toolexecdir='$(libdir)/gcc-lib/$(target_noncanonical)'
+	toolexecmainlibdir='$(libdir)'
+      fi
+      multi_os_directory=`$CC -print-multi-os-directory`
+      case $multi_os_directory in
+	.) toolexeclibdir=$toolexecmainlibdir ;; # Avoid trailing /.
+	*) toolexeclibdir=$toolexecmainlibdir/$multi_os_directory ;;
+      esac
+      ;;
+  esac
+  AC_SUBST(toolexecdir)
+  AC_SUBST(toolexecmainlibdir)
   AC_SUBST(toolexeclibdir)
 ])
 
diff -Nur a/libjava/classpath/Makefile.in b/libjava/classpath/Makefile.in
--- a/libjava/classpath/Makefile.in	2009-02-25 22:40:28.000000000 +0100
+++ b/libjava/classpath/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -380,9 +380,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 
diff -Nur a/libjava/classpath/native/fdlibm/Makefile.in b/libjava/classpath/native/fdlibm/Makefile.in
--- a/libjava/classpath/native/fdlibm/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/fdlibm/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -359,9 +359,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 noinst_LTLIBRARIES = libfdlibm.la 
diff -Nur a/libjava/classpath/native/jawt/Makefile.in b/libjava/classpath/native/jawt/Makefile.in
--- a/libjava/classpath/native/jawt/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jawt/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -359,9 +359,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjawt.la
diff -Nur a/libjava/classpath/native/jni/classpath/Makefile.in b/libjava/classpath/native/jni/classpath/Makefile.in
--- a/libjava/classpath/native/jni/classpath/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/classpath/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -350,9 +350,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 
diff -Nur a/libjava/classpath/native/jni/gconf-peer/Makefile.in b/libjava/classpath/native/jni/gconf-peer/Makefile.in
--- a/libjava/classpath/native/jni/gconf-peer/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/gconf-peer/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -359,9 +359,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgconfpeer.la
diff -Nur a/libjava/classpath/native/jni/gstreamer-peer/Makefile.in b/libjava/classpath/native/jni/gstreamer-peer/Makefile.in
--- a/libjava/classpath/native/jni/gstreamer-peer/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/gstreamer-peer/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -361,9 +361,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgstreamerpeer.la
diff -Nur a/libjava/classpath/native/jni/gtk-peer/Makefile.in b/libjava/classpath/native/jni/gtk-peer/Makefile.in
--- a/libjava/classpath/native/jni/gtk-peer/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/gtk-peer/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -397,9 +397,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgtkpeer.la
diff -Nur a/libjava/classpath/native/jni/java-io/Makefile.in b/libjava/classpath/native/jni/java-io/Makefile.in
--- a/libjava/classpath/native/jni/java-io/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/java-io/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -361,9 +361,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavaio.la 
diff -Nur a/libjava/classpath/native/jni/java-lang/Makefile.in b/libjava/classpath/native/jni/java-lang/Makefile.in
--- a/libjava/classpath/native/jni/java-lang/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/java-lang/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -375,9 +375,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavalang.la libjavalangreflect.la libjavalangmanagement.la
diff -Nur a/libjava/classpath/native/jni/java-math/Makefile.in b/libjava/classpath/native/jni/java-math/Makefile.in
--- a/libjava/classpath/native/jni/java-math/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/java-math/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -359,9 +359,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavamath.la
diff -Nur a/libjava/classpath/native/jni/java-net/Makefile.in b/libjava/classpath/native/jni/java-net/Makefile.in
--- a/libjava/classpath/native/jni/java-net/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/java-net/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -371,9 +371,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavanet.la
diff -Nur a/libjava/classpath/native/jni/java-nio/Makefile.in b/libjava/classpath/native/jni/java-nio/Makefile.in
--- a/libjava/classpath/native/jni/java-nio/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/java-nio/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -369,9 +369,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavanio.la
diff -Nur a/libjava/classpath/native/jni/java-util/Makefile.in b/libjava/classpath/native/jni/java-util/Makefile.in
--- a/libjava/classpath/native/jni/java-util/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/java-util/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -358,9 +358,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavautil.la
diff -Nur a/libjava/classpath/native/jni/Makefile.in b/libjava/classpath/native/jni/Makefile.in
--- a/libjava/classpath/native/jni/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -340,9 +340,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 @CREATE_CORE_JNI_LIBRARIES_TRUE@JNIDIRS = native-lib java-io java-lang java-net java-nio java-util
diff -Nur a/libjava/classpath/native/jni/midi-alsa/Makefile.in b/libjava/classpath/native/jni/midi-alsa/Makefile.in
--- a/libjava/classpath/native/jni/midi-alsa/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/midi-alsa/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -361,9 +361,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgjsmalsa.la 
diff -Nur a/libjava/classpath/native/jni/midi-dssi/Makefile.in b/libjava/classpath/native/jni/midi-dssi/Makefile.in
--- a/libjava/classpath/native/jni/midi-dssi/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/midi-dssi/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -361,9 +361,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgjsmdssi.la 
diff -Nur a/libjava/classpath/native/jni/native-lib/Makefile.in b/libjava/classpath/native/jni/native-lib/Makefile.in
--- a/libjava/classpath/native/jni/native-lib/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/native-lib/Makefile.in	2010-01-25 09:50:29.625686976 +0100
@@ -350,9 +350,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 noinst_LTLIBRARIES = libclasspathnative.la
diff -Nur a/libjava/classpath/native/jni/qt-peer/Makefile.in b/libjava/classpath/native/jni/qt-peer/Makefile.in
--- a/libjava/classpath/native/jni/qt-peer/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/qt-peer/Makefile.in	2010-01-25 09:50:29.635686641 +0100
@@ -376,9 +376,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 noinst_LTLIBRARIES = libqtpeer.la
diff -Nur a/libjava/classpath/native/jni/xmlj/Makefile.in b/libjava/classpath/native/jni/xmlj/Makefile.in
--- a/libjava/classpath/native/jni/xmlj/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/jni/xmlj/Makefile.in	2010-01-25 09:50:29.635686641 +0100
@@ -360,9 +360,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libxmlj.la
diff -Nur a/libjava/classpath/native/Makefile.in b/libjava/classpath/native/Makefile.in
--- a/libjava/classpath/native/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/Makefile.in	2010-01-25 09:50:29.635686641 +0100
@@ -340,9 +340,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 @CREATE_JNI_LIBRARIES_TRUE@JNIDIR = jni
diff -Nur a/libjava/classpath/native/plugin/Makefile.in b/libjava/classpath/native/plugin/Makefile.in
--- a/libjava/classpath/native/plugin/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/native/plugin/Makefile.in	2010-01-25 09:50:29.635686641 +0100
@@ -358,9 +358,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgcjwebplugin.la
diff -Nur a/libjava/classpath/resource/Makefile.in b/libjava/classpath/resource/Makefile.in
--- a/libjava/classpath/resource/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/resource/Makefile.in	2010-01-25 09:50:29.635686641 +0100
@@ -343,9 +343,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 logging_DATA = java/util/logging/logging.properties
diff -Nur a/libjava/classpath/scripts/Makefile.in b/libjava/classpath/scripts/Makefile.in
--- a/libjava/classpath/scripts/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/scripts/Makefile.in	2010-01-25 09:50:29.635686641 +0100
@@ -333,9 +333,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 EXTRA_DIST = generate-locale-list.sh import-cacerts.sh
diff -Nur a/libjava/classpath/tools/Makefile.in b/libjava/classpath/tools/Makefile.in
--- a/libjava/classpath/tools/Makefile.in	2008-11-12 21:55:13.000000000 +0100
+++ b/libjava/classpath/tools/Makefile.in	2010-01-25 09:50:29.635686641 +0100
@@ -448,9 +448,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 @CREATE_GJDOC_TRUE@gjdoc_gendir = ${top_srcdir}/tools/generated
diff -Nur a/libjava/configure b/libjava/configure
--- a/libjava/configure	2009-07-22 09:43:59.000000000 +0200
+++ b/libjava/configure	2010-01-25 09:50:29.635686641 +0100
@@ -26501,10 +26501,10 @@
 multi_os_directory=`$CC -print-multi-os-directory`
 case $multi_os_directory in
   .)
-   dbexecdir='$(libdir)/'$gcjsubdir # Avoid /.
+   dbexecdir='$(toolexeclibdir)/'$gcjsubdir # Avoid /.
    ;;
   *)
-   dbexecdir='$(libdir)/'$multi_os_directory/$gcjsubdir
+   dbexecdir='$(toolexeclibdir)/'$multi_os_directory/$gcjsubdir
    ;;
 esac
 
@@ -27652,6 +27652,74 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   gcc_cv_have_tls=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -27661,6 +27729,24 @@
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 
 
 else
diff -Nur a/libjava/configure.ac b/libjava/configure.ac
--- a/libjava/configure.ac	2009-04-26 16:24:38.000000000 +0200
+++ b/libjava/configure.ac	2010-01-25 09:50:29.635686641 +0100
@@ -1490,10 +1490,10 @@
 multi_os_directory=`$CC -print-multi-os-directory`
 case $multi_os_directory in
   .)
-   dbexecdir='$(libdir)/'$gcjsubdir # Avoid /.
+   dbexecdir='$(toolexeclibdir)/'$gcjsubdir # Avoid /.
    ;;
   *)
-   dbexecdir='$(libdir)/'$multi_os_directory/$gcjsubdir
+   dbexecdir='$(toolexeclibdir)/'$multi_os_directory/$gcjsubdir
    ;;
 esac
 AC_SUBST(dbexecdir)
diff -Nur a/libjava/Makefile.am b/libjava/Makefile.am
--- a/libjava/Makefile.am	2009-05-11 10:21:39.000000000 +0200
+++ b/libjava/Makefile.am	2010-01-25 09:50:29.635686641 +0100
@@ -55,9 +55,14 @@
 
 dbexec_LTLIBRARIES = libjvm.la
 
-pkgconfigdir = $(libdir)/pkgconfig
+# Install the pkgconfig file in a target-specific directory, since the
+# libraries it indicates
 
-jardir = $(datadir)/java
+pkgconfigdir = $(toolexeclibdir)/pkgconfig
+
+# We install the JAR in a target-specific directory so that toolchains
+# build from different sources can be installed in the same directory.
+jardir = $(prefix)/$(target_noncanonical)/share/java
 jar_DATA = libgcj-$(gcc_version).jar libgcj-tools-$(gcc_version).jar
 if INSTALL_ECJ_JAR
 jar_DATA += $(ECJ_BUILD_JAR)
diff -Nur a/libjava/Makefile.in b/libjava/Makefile.in
--- a/libjava/Makefile.in	2009-07-22 09:43:59.000000000 +0200
+++ b/libjava/Makefile.in	2010-01-25 09:50:29.645688750 +0100
@@ -916,8 +916,14 @@
 	$(am__append_2) $(am__append_3)
 toolexecmainlib_DATA = libgcj.spec
 dbexec_LTLIBRARIES = libjvm.la
-pkgconfigdir = $(libdir)/pkgconfig
-jardir = $(datadir)/java
+
+# Install the pkgconfig file in a target-specific directory, since the
+# libraries it indicates
+pkgconfigdir = $(toolexeclibdir)/pkgconfig
+
+# We install the JAR in a target-specific directory so that toolchains
+# build from different sources can be installed in the same directory.
+jardir = $(prefix)/$(target_noncanonical)/share/java
 jar_DATA = libgcj-$(gcc_version).jar libgcj-tools-$(gcc_version).jar \
 	$(am__append_4)
 @JAVA_HOME_SET_FALSE@JAVA_HOME_DIR = $(prefix)
diff -Nur a/libmudflap/configure b/libmudflap/configure
--- a/libmudflap/configure	2009-03-01 18:49:31.000000000 +0100
+++ b/libmudflap/configure	2010-01-25 09:50:29.645688750 +0100
@@ -12787,6 +12787,64 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   gcc_cv_have_tls=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -12796,6 +12854,24 @@
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 
 
 else
diff -Nur a/libstdc++-v3/config/cpu/sh/atomicity.h b/libstdc++-v3/config/cpu/sh/atomicity.h
--- a/libstdc++-v3/config/cpu/sh/atomicity.h	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/config/cpu/sh/atomicity.h	2010-01-25 09:50:29.645688750 +0100
@@ -25,47 +25,48 @@
 
 #ifdef __SH4A__
 
-#ifndef _GLIBCXX_ATOMICITY_H
-#define _GLIBCXX_ATOMICITY_H	1
+#include <ext/atomicity.h>
 
-typedef int _Atomic_word;
+_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)
 
-static inline _Atomic_word
-__attribute__ ((__unused__))
-__exchange_and_add (volatile _Atomic_word* __mem, int __val)
-{
-  _Atomic_word __result;
+  typedef int _Atomic_word;
 
-  __asm__ __volatile__
-    ("0:\n"
-     "\tmovli.l\t@%2,r0\n"
-     "\tmov\tr0,%1\n"
-     "\tadd\t%3,r0\n"
-     "\tmovco.l\tr0,@%2\n"
-     "\tbf\t0b"
-     : "+m" (*__mem), "=r" (__result)
-     : "r" (__mem), "rI08" (__val)
-     : "r0");
-
-  return __result;
-}
-
-
-static inline void
-__attribute__ ((__unused__))
-__atomic_add (volatile _Atomic_word* __mem, int __val)
-{
-  asm("0:\n"
-      "\tmovli.l\t@%1,r0\n"
-      "\tadd\t%2,r0\n"
-      "\tmovco.l\tr0,@%1\n"
-      "\tbf\t0b"
-      : "+m" (*__mem)
-      : "r" (__mem), "rI08" (__val)
-      : "r0");
-}
+  _Atomic_word
+  __attribute__ ((__unused__))
+  __exchange_and_add (volatile _Atomic_word* __mem, int __val)
+  {
+    _Atomic_word __result;
 
-#endif
+    __asm__ __volatile__
+      ("0:\n"
+       "\tmovli.l\t@%2,r0\n"
+       "\tmov\tr0,%1\n"
+       "\tadd\t%3,r0\n"
+       "\tmovco.l\tr0,@%2\n"
+       "\tbf\t0b"
+       : "+m" (*__mem), "=&r" (__result)
+       : "r" (__mem), "rI08" (__val)
+       : "r0");
+
+    return __result;
+  }
+
+
+  void
+  __attribute__ ((__unused__))
+  __atomic_add (volatile _Atomic_word* __mem, int __val)
+  {
+    asm("0:\n"
+	"\tmovli.l\t@%1,r0\n"
+	"\tadd\t%2,r0\n"
+	"\tmovco.l\tr0,@%1\n"
+	"\tbf\t0b"
+	: "+m" (*__mem)
+	: "r" (__mem), "rI08" (__val)
+	: "r0");
+  }
+
+_GLIBCXX_END_NAMESPACE
 
 #else /* !__SH4A__ */
 
diff -Nur a/libstdc++-v3/configure b/libstdc++-v3/configure
--- a/libstdc++-v3/configure	2009-05-07 12:23:06.000000000 +0200
+++ b/libstdc++-v3/configure	2010-01-25 09:50:29.665687451 +0100
@@ -458,7 +458,7 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS libtool_VERSION multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar glibcxx_builddir glibcxx_srcdir toplevel_srcdir CC ac_ct_CC EXEEXT OBJEXT CXX ac_ct_CXX CFLAGS CXXFLAGS LN_S AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CPP CPPFLAGS EGREP LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM OBJDUMP ac_ct_OBJDUMP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 LDFLAGS CXXCPP enable_shared enable_static GLIBCXX_HOSTED_TRUE GLIBCXX_HOSTED_FALSE GLIBCXX_BUILD_PCH_TRUE GLIBCXX_BUILD_PCH_FALSE glibcxx_PCHFLAGS glibcxx_thread_h WERROR SECTION_FLAGS CSTDIO_H BASIC_FILE_H BASIC_FILE_CC check_msgfmt glibcxx_MOFILES glibcxx_POFILES glibcxx_localedir USE_NLS CLOCALE_H CMESSAGES_H CCODECVT_CC CCOLLATE_CC CCTYPE_CC CMESSAGES_CC CMONEY_CC CNUMERIC_CC CTIME_H CTIME_CC CLOCALE_CC CLOCALE_INTERNAL_H ALLOCATOR_H ALLOCATOR_NAME C_INCLUDE_DIR GLIBCXX_C_HEADERS_C_TRUE GLIBCXX_C_HEADERS_C_FALSE GLIBCXX_C_HEADERS_C_STD_TRUE GLIBCXX_C_HEADERS_C_STD_FALSE GLIBCXX_C_HEADERS_C_GLOBAL_TRUE GLIBCXX_C_HEADERS_C_GLOBAL_FALSE GLIBCXX_C_HEADERS_COMPATIBILITY_TRUE GLIBCXX_C_HEADERS_COMPATIBILITY_FALSE GLIBCXX_C_HEADERS_EXTRA_TRUE GLIBCXX_C_HEADERS_EXTRA_FALSE DEBUG_FLAGS GLIBCXX_BUILD_DEBUG_TRUE GLIBCXX_BUILD_DEBUG_FALSE ENABLE_PARALLEL_TRUE ENABLE_PARALLEL_FALSE EXTRA_CXX_FLAGS GLIBCXX_LIBS SECTION_LDFLAGS OPT_LDFLAGS LIBICONV LTLIBICONV SYMVER_FILE port_specific_symbol_files ENABLE_SYMVERS_TRUE ENABLE_SYMVERS_FALSE ENABLE_SYMVERS_GNU_TRUE ENABLE_SYMVERS_GNU_FALSE ENABLE_SYMVERS_GNU_NAMESPACE_TRUE ENABLE_SYMVERS_GNU_NAMESPACE_FALSE ENABLE_SYMVERS_DARWIN_TRUE ENABLE_SYMVERS_DARWIN_FALSE ENABLE_VISIBILITY_TRUE ENABLE_VISIBILITY_FALSE GLIBCXX_LDBL_COMPAT_TRUE GLIBCXX_LDBL_COMPAT_FALSE baseline_dir ATOMICITY_SRCDIR ATOMIC_WORD_SRCDIR ATOMIC_FLAGS CPU_DEFINES_SRCDIR ABI_TWEAKS_SRCDIR OS_INC_SRCDIR ERROR_CONSTANTS_SRCDIR glibcxx_prefixdir gxx_include_dir glibcxx_toolexecdir glibcxx_toolexeclibdir GLIBCXX_INCLUDES TOPLEVEL_INCLUDES OPTIMIZE_CXXFLAGS WARN_FLAGS LIBSUPCXX_PICFLAGS LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS libtool_VERSION multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar glibcxx_builddir glibcxx_srcdir toplevel_srcdir CC ac_ct_CC EXEEXT OBJEXT CXX ac_ct_CXX CFLAGS CXXFLAGS LN_S AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CPP CPPFLAGS EGREP LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM OBJDUMP ac_ct_OBJDUMP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 LDFLAGS CXXCPP enable_shared enable_static GLIBCXX_HOSTED_TRUE GLIBCXX_HOSTED_FALSE GLIBCXX_BUILD_PCH_TRUE GLIBCXX_BUILD_PCH_FALSE glibcxx_PCHFLAGS glibcxx_thread_h WERROR SECTION_FLAGS CSTDIO_H BASIC_FILE_H BASIC_FILE_CC check_msgfmt glibcxx_MOFILES glibcxx_POFILES glibcxx_localedir USE_NLS CLOCALE_H CMESSAGES_H CCODECVT_CC CCOLLATE_CC CCTYPE_CC CMESSAGES_CC CMONEY_CC CNUMERIC_CC CTIME_H CTIME_CC CLOCALE_CC CLOCALE_INTERNAL_H ALLOCATOR_H ALLOCATOR_NAME C_INCLUDE_DIR GLIBCXX_C_HEADERS_C_TRUE GLIBCXX_C_HEADERS_C_FALSE GLIBCXX_C_HEADERS_C_STD_TRUE GLIBCXX_C_HEADERS_C_STD_FALSE GLIBCXX_C_HEADERS_C_GLOBAL_TRUE GLIBCXX_C_HEADERS_C_GLOBAL_FALSE GLIBCXX_C_HEADERS_COMPATIBILITY_TRUE GLIBCXX_C_HEADERS_COMPATIBILITY_FALSE GLIBCXX_C_HEADERS_EXTRA_TRUE GLIBCXX_C_HEADERS_EXTRA_FALSE DEBUG_FLAGS GLIBCXX_BUILD_DEBUG_TRUE GLIBCXX_BUILD_DEBUG_FALSE ENABLE_PARALLEL_TRUE ENABLE_PARALLEL_FALSE EXTRA_CXX_FLAGS GLIBCXX_LIBS SECTION_LDFLAGS OPT_LDFLAGS LIBICONV LTLIBICONV SYMVER_FILE port_specific_symbol_files ENABLE_SYMVERS_TRUE ENABLE_SYMVERS_FALSE ENABLE_SYMVERS_GNU_TRUE ENABLE_SYMVERS_GNU_FALSE ENABLE_SYMVERS_GNU_NAMESPACE_TRUE ENABLE_SYMVERS_GNU_NAMESPACE_FALSE ENABLE_SYMVERS_DARWIN_TRUE ENABLE_SYMVERS_DARWIN_FALSE ENABLE_VISIBILITY_TRUE ENABLE_VISIBILITY_FALSE GLIBCXX_LDBL_COMPAT_TRUE GLIBCXX_LDBL_COMPAT_FALSE baseline_dir ATOMICITY_SRCDIR ATOMIC_WORD_SRCDIR ATOMIC_FLAGS CPU_DEFINES_SRCDIR ABI_TWEAKS_SRCDIR OS_INC_SRCDIR ERROR_CONSTANTS_SRCDIR LIBSUPCXX_PRONLY_TRUE LIBSUPCXX_PRONLY_FALSE glibcxx_prefixdir gxx_include_dir glibcxx_toolexecdir glibcxx_toolexeclibdir GLIBCXX_INCLUDES TOPLEVEL_INCLUDES OPTIMIZE_CXXFLAGS WARN_FLAGS LIBSUPCXX_PICFLAGS LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 ac_pwd=`pwd`
 
@@ -40730,6 +40730,74 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   gcc_cv_have_tls=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -40739,6 +40807,24 @@
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 
 
 else
@@ -76926,6 +77012,74 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   gcc_cv_have_tls=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -76935,6 +77089,24 @@
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 
 
 else
@@ -94541,6 +94713,74 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   gcc_cv_have_tls=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -94550,6 +94790,24 @@
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 
 
 else
@@ -114470,7 +114728,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114534,7 +114793,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114575,7 +114835,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114632,7 +114893,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114673,7 +114935,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114738,7 +115001,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114806,7 +115070,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (void *)); }
 unsigned long ulongval () { return (long) (sizeof (void *)); }
 #include <stdio.h>
@@ -114894,7 +115159,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114958,7 +115224,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114999,7 +115266,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115056,7 +115324,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115097,7 +115366,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115162,7 +115432,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115230,7 +115501,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (long)); }
 unsigned long ulongval () { return (long) (sizeof (long)); }
 #include <stdio.h>
@@ -115318,7 +115590,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115382,7 +115655,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115423,7 +115697,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115480,7 +115755,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115521,7 +115797,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115586,7 +115863,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115654,7 +115932,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (int)); }
 unsigned long ulongval () { return (long) (sizeof (int)); }
 #include <stdio.h>
@@ -115738,7 +116017,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115802,7 +116082,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115843,7 +116124,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115900,7 +116182,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115941,7 +116224,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116006,7 +116290,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116074,7 +116359,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (short)); }
 unsigned long ulongval () { return (long) (sizeof (short)); }
 #include <stdio.h>
@@ -116158,7 +116444,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116222,7 +116509,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116263,7 +116551,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116320,7 +116609,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116361,7 +116651,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116426,7 +116717,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116494,7 +116786,8 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (char)); }
 unsigned long ulongval () { return (long) (sizeof (char)); }
 #include <stdio.h>
@@ -118004,6 +118297,24 @@
 
 
 
+# For SymbianOS, we use a highly cut-down libsupc++. This lets us
+# conditionalise libsupc++'s Makefile.am to include only the necessary sources.
+case "$target" in
+  *arm*-symbianelf)
+  LIBSUPCXX_PRONLY=yes;;
+  *);;
+esac
+
+
+if test x$LIBSUPCXX_PRONLY = xyes; then
+  LIBSUPCXX_PRONLY_TRUE=
+  LIBSUPCXX_PRONLY_FALSE='#'
+else
+  LIBSUPCXX_PRONLY_TRUE='#'
+  LIBSUPCXX_PRONLY_FALSE=
+fi
+
+
 # Determine cross-compile flags and AM_CONDITIONALs.
 #AC_SUBST(GLIBCXX_IS_NATIVE)
 #AM_CONDITIONAL(CANADIAN, test $CANADIAN = yes)
@@ -118582,6 +118893,13 @@
 Usually this means the macro was only invoked conditionally." >&2;}
    { (exit 1); exit 1; }; }
 fi
+if test -z "${LIBSUPCXX_PRONLY_TRUE}" && test -z "${LIBSUPCXX_PRONLY_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"LIBSUPCXX_PRONLY\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"LIBSUPCXX_PRONLY\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
 
 : ${CONFIG_STATUS=./config.status}
 ac_clean_files_save=$ac_clean_files
@@ -119667,6 +119985,8 @@
 s,@ABI_TWEAKS_SRCDIR@,$ABI_TWEAKS_SRCDIR,;t t
 s,@OS_INC_SRCDIR@,$OS_INC_SRCDIR,;t t
 s,@ERROR_CONSTANTS_SRCDIR@,$ERROR_CONSTANTS_SRCDIR,;t t
+s,@LIBSUPCXX_PRONLY_TRUE@,$LIBSUPCXX_PRONLY_TRUE,;t t
+s,@LIBSUPCXX_PRONLY_FALSE@,$LIBSUPCXX_PRONLY_FALSE,;t t
 s,@glibcxx_prefixdir@,$glibcxx_prefixdir,;t t
 s,@gxx_include_dir@,$gxx_include_dir,;t t
 s,@glibcxx_toolexecdir@,$glibcxx_toolexecdir,;t t
diff -Nur a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
--- a/libstdc++-v3/configure.ac	2009-05-07 12:23:06.000000000 +0200
+++ b/libstdc++-v3/configure.ac	2010-01-25 09:50:29.675687743 +0100
@@ -329,6 +329,15 @@
 AC_SUBST(ERROR_CONSTANTS_SRCDIR)
 
 
+# For SymbianOS, we use a highly cut-down libsupc++. This lets us
+# conditionalise libsupc++'s Makefile.am to include only the necessary sources.
+case "$target" in
+  *arm*-symbianelf)
+  LIBSUPCXX_PRONLY=yes;;
+  *);;
+esac
+AM_CONDITIONAL(LIBSUPCXX_PRONLY, test x$LIBSUPCXX_PRONLY = xyes)
+
 # Determine cross-compile flags and AM_CONDITIONALs.
 #AC_SUBST(GLIBCXX_IS_NATIVE)
 #AM_CONDITIONAL(CANADIAN, test $CANADIAN = yes)
diff -Nur a/libstdc++-v3/doc/Makefile.in b/libstdc++-v3/doc/Makefile.in
--- a/libstdc++-v3/doc/Makefile.in	2009-01-15 21:02:11.000000000 +0100
+++ b/libstdc++-v3/doc/Makefile.in	2010-01-25 09:50:29.675687743 +0100
@@ -161,6 +161,8 @@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBSUPCXX_PICFLAGS = @LIBSUPCXX_PICFLAGS@
+LIBSUPCXX_PRONLY_FALSE = @LIBSUPCXX_PRONLY_FALSE@
+LIBSUPCXX_PRONLY_TRUE = @LIBSUPCXX_PRONLY_TRUE@
 LIBTOOL = @LIBTOOL@
 LIPO = @LIPO@
 LN_S = @LN_S@
diff -Nur a/libstdc++-v3/include/c_global/cwchar b/libstdc++-v3/include/c_global/cwchar
--- a/libstdc++-v3/include/c_global/cwchar	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/include/c_global/cwchar	2010-01-25 09:50:29.675687743 +0100
@@ -156,14 +156,18 @@
   using ::mbsrtowcs;
   using ::putwc;
   using ::putwchar;
+#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
   using ::swprintf;
+#endif
   using ::swscanf;
   using ::ungetwc;
   using ::vfwprintf;
 #if _GLIBCXX_HAVE_VFWSCANF
   using ::vfwscanf;
 #endif
+#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
   using ::vswprintf;
+#endif
 #if _GLIBCXX_HAVE_VSWSCANF
   using ::vswscanf;
 #endif
diff -Nur a/libstdc++-v3/include/Makefile.am b/libstdc++-v3/include/Makefile.am
--- a/libstdc++-v3/include/Makefile.am	2009-05-13 02:24:16.000000000 +0200
+++ b/libstdc++-v3/include/Makefile.am	2010-01-25 09:50:29.675687743 +0100
@@ -1125,8 +1125,14 @@
 if GLIBCXX_HOSTED
 install-data-local: install-headers
 else
+if LIBSUPCXX_PRONLY
+# Don't install any headers if we're only putting eh_personality in
+# libsupc++ (e.g. on SymbianOS)
+install-data-local:
+else
 install-data-local: install-freestanding-headers
 endif
+endif
 
 # This is a subset of the full install-headers rule.  We only need <cstddef>,
 # <limits>, <cstdlib>, <cstdarg>, <new>, <typeinfo>, <exception>, and any
diff -Nur a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
--- a/libstdc++-v3/include/Makefile.in	2009-05-13 02:24:16.000000000 +0200
+++ b/libstdc++-v3/include/Makefile.in	2010-01-25 09:50:29.675687743 +0100
@@ -161,6 +161,8 @@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBSUPCXX_PICFLAGS = @LIBSUPCXX_PICFLAGS@
+LIBSUPCXX_PRONLY_FALSE = @LIBSUPCXX_PRONLY_FALSE@
+LIBSUPCXX_PRONLY_TRUE = @LIBSUPCXX_PRONLY_TRUE@
 LIBTOOL = @LIBTOOL@
 LIPO = @LIPO@
 LN_S = @LN_S@
@@ -1527,7 +1529,10 @@
 # the rest are taken from the original source tree.
 
 @GLIBCXX_HOSTED_TRUE@install-data-local: install-headers
-@GLIBCXX_HOSTED_FALSE@install-data-local: install-freestanding-headers
+# Don't install any headers if we're only putting eh_personality in
+# libsupc++ (e.g. on SymbianOS)
+@GLIBCXX_HOSTED_FALSE@@LIBSUPCXX_PRONLY_TRUE@install-data-local:
+@GLIBCXX_HOSTED_FALSE@@LIBSUPCXX_PRONLY_FALSE@install-data-local: install-freestanding-headers
 
 # This is a subset of the full install-headers rule.  We only need <cstddef>,
 # <limits>, <cstdlib>, <cstdarg>, <new>, <typeinfo>, <exception>, and any
diff -Nur a/libstdc++-v3/libsupc++/eh_arm.cc b/libstdc++-v3/libsupc++/eh_arm.cc
--- a/libstdc++-v3/libsupc++/eh_arm.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/libsupc++/eh_arm.cc	2010-01-25 09:50:29.675687743 +0100
@@ -38,7 +38,7 @@
 extern "C" __cxa_type_match_result
 __cxa_type_match(_Unwind_Exception* ue_header,
 		 const std::type_info* catch_type,
-		 bool is_reference __attribute__((__unused__)),
+		 bool is_reference,
 		 void** thrown_ptr_p)
 {
   bool forced_unwind = __is_gxx_forced_unwind_class(ue_header->exception_class);
@@ -68,11 +68,11 @@
   if (throw_type->__is_pointer_p())
     thrown_ptr = *(void**) thrown_ptr;
 
-  if (catch_type->__do_catch(throw_type, &thrown_ptr, 1))
+  if (catch_type->__do_catch (throw_type, &thrown_ptr, 1 + is_reference * 2))
     {
       *thrown_ptr_p = thrown_ptr;
 
-      if (typeid(*catch_type) == typeid (typeid(void*)))
+      if (typeid (*catch_type) == typeid (typeid(void*)))
 	{
 	  const __pointer_type_info *catch_pointer_type =
 	    static_cast<const __pointer_type_info *> (catch_type);
diff -Nur a/libstdc++-v3/libsupc++/eh_personality.cc b/libstdc++-v3/libsupc++/eh_personality.cc
--- a/libstdc++-v3/libsupc++/eh_personality.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/libsupc++/eh_personality.cc	2010-01-25 09:50:29.675687743 +0100
@@ -89,20 +89,22 @@
 // Return an element from a type table.
 
 static const std::type_info*
-get_ttype_entry(lsda_header_info* info, _uleb128_t i)
+get_ttype_entry(lsda_header_info* info, _uleb128_t i, bool &is_ref)
 {
   _Unwind_Ptr ptr;
 
   ptr = (_Unwind_Ptr) (info->TType - (i * 4));
   ptr = _Unwind_decode_target2(ptr);
   
-  return reinterpret_cast<const std::type_info *>(ptr);
+  is_ref = ptr & 1;
+  
+  return reinterpret_cast<const std::type_info *>(ptr & ~1);
 }
 
 // The ABI provides a routine for matching exception object types.
 typedef _Unwind_Control_Block _throw_typet;
-#define get_adjusted_ptr(catch_type, throw_type, thrown_ptr_p) \
-  (__cxa_type_match (throw_type, catch_type, false, thrown_ptr_p) \
+#define get_adjusted_ptr(catch_type, throw_type, is_ref, thrown_ptr_p) \
+  (__cxa_type_match (throw_type, catch_type, is_ref, thrown_ptr_p) \
    != ctm_failed)
 
 // Return true if THROW_TYPE matches one if the filter types.
@@ -118,6 +120,7 @@
     {
       const std::type_info* catch_type;
       _uleb128_t tmp;
+      bool is_ref;
 
       tmp = *e;
       
@@ -129,13 +132,14 @@
       tmp = _Unwind_decode_target2((_Unwind_Word) e);
 
       // Match a ttype entry.
-      catch_type = reinterpret_cast<const std::type_info*>(tmp);
+      is_ref = tmp & 1;
+      catch_type = reinterpret_cast<const std::type_info*>(tmp & ~1);
 
       // ??? There is currently no way to ask the RTTI code about the
       // relationship between two types without reference to a specific
       // object.  There should be; then we wouldn't need to mess with
       // thrown_ptr here.
-      if (get_adjusted_ptr(catch_type, throw_type, &thrown_ptr))
+      if (get_adjusted_ptr(catch_type, throw_type, is_ref, &thrown_ptr))
 	return true;
 
       // Advance to the next entry.
@@ -207,7 +211,7 @@
 // Return an element from a type table.
 
 static const std::type_info *
-get_ttype_entry (lsda_header_info *info, _uleb128_t i)
+get_ttype_entry (lsda_header_info *info, _uleb128_t i, bool &is_ref)
 {
   _Unwind_Ptr ptr;
 
@@ -215,7 +219,9 @@
   read_encoded_value_with_base (info->ttype_encoding, info->ttype_base,
 				info->TType - i, &ptr);
 
-  return reinterpret_cast<const std::type_info *>(ptr);
+  is_ref = ptr & 1;
+  
+  return reinterpret_cast<const std::type_info *>(ptr & ~1);
 }
 
 // Given the thrown type THROW_TYPE, pointer to a variable containing a
@@ -226,6 +232,7 @@
 static bool
 get_adjusted_ptr (const std::type_info *catch_type,
 		  const std::type_info *throw_type,
+		  bool is_ref,
 		  void **thrown_ptr_p)
 {
   void *thrown_ptr = *thrown_ptr_p;
@@ -237,7 +244,7 @@
   if (throw_type->__is_pointer_p ())
     thrown_ptr = *(void **) thrown_ptr;
 
-  if (catch_type->__do_catch (throw_type, &thrown_ptr, 1))
+  if (catch_type->__do_catch (throw_type, &thrown_ptr, 1 + is_ref * 2))
     {
       *thrown_ptr_p = thrown_ptr;
       return true;
@@ -267,13 +274,15 @@
         return false;
 
       // Match a ttype entry.
-      catch_type = get_ttype_entry (info, tmp);
+      bool is_ref;
+      
+      catch_type = get_ttype_entry (info, tmp, is_ref);
 
       // ??? There is currently no way to ask the RTTI code about the
       // relationship between two types without reference to a specific
       // object.  There should be; then we wouldn't need to mess with
       // thrown_ptr here.
-      if (get_adjusted_ptr (catch_type, throw_type, &thrown_ptr))
+      if (get_adjusted_ptr (catch_type, throw_type, is_ref, &thrown_ptr))
 	return true;
     }
 }
@@ -582,14 +591,16 @@
 	  else if (ar_filter > 0)
 	    {
 	      // Positive filter values are handlers.
-	      catch_type = get_ttype_entry (&info, ar_filter);
+	      bool is_ref;
+	      
+	      catch_type = get_ttype_entry (&info, ar_filter, is_ref);
 
 	      // Null catch type is a catch-all handler; we can catch foreign
 	      // exceptions with this.  Otherwise we must match types.
 	      if (! catch_type
 		  || (throw_type
 		      && get_adjusted_ptr (catch_type, throw_type,
-					   &thrown_ptr)))
+					   is_ref, &thrown_ptr)))
 		{
 		  saw_handler = true;
 		  break;
diff -Nur a/libstdc++-v3/libsupc++/Makefile.am b/libstdc++-v3/libsupc++/Makefile.am
--- a/libstdc++-v3/libsupc++/Makefile.am	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/libsupc++/Makefile.am	2010-01-25 09:50:29.675687743 +0100
@@ -30,6 +30,11 @@
 # 2) integrated libsupc++convenience.la that is to be a part of libstdc++.a
 noinst_LTLIBRARIES = libsupc++convenience.la
 
+if LIBSUPCXX_PRONLY
+sources = \
+	eh_personality.cc
+
+else
 
 headers = \
 	exception new typeinfo cxxabi.h cxxabi-forced.h exception_defines.h \
@@ -84,6 +89,7 @@
 	vec.cc \
 	vmi_class_type_info.cc \
 	vterminate.cc
+endif
 
 libsupc___la_SOURCES = $(sources) $(c_sources)
 libsupc__convenience_la_SOURCES = $(sources) $(c_sources)
diff -Nur a/libstdc++-v3/libsupc++/Makefile.in b/libstdc++-v3/libsupc++/Makefile.in
--- a/libstdc++-v3/libsupc++/Makefile.in	2009-01-15 21:02:11.000000000 +0100
+++ b/libstdc++-v3/libsupc++/Makefile.in	2010-01-25 09:50:29.675687743 +0100
@@ -38,7 +38,7 @@
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
-DIST_COMMON = $(glibcxxinstall_HEADERS) $(srcdir)/Makefile.am \
+DIST_COMMON = $(am__glibcxxinstall_HEADERS_DIST) $(srcdir)/Makefile.am \
 	$(srcdir)/Makefile.in $(top_srcdir)/fragment.am
 subdir = libsupc++
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
@@ -87,19 +87,29 @@
 	pmem_type_info.cc pointer_type_info.cc pure.cc \
 	si_class_type_info.cc tinfo.cc tinfo2.cc vec.cc \
 	vmi_class_type_info.cc vterminate.cc cp-demangle.c
-am__objects_1 = array_type_info.lo atexit_arm.lo bad_cast.lo \
-	bad_typeid.lo class_type_info.lo del_op.lo del_opnt.lo \
-	del_opv.lo del_opvnt.lo dyncast.lo eh_alloc.lo eh_arm.lo \
-	eh_aux_runtime.lo eh_call.lo eh_catch.lo eh_exception.lo \
-	eh_globals.lo eh_personality.lo eh_ptr.lo eh_term_handler.lo \
-	eh_terminate.lo eh_throw.lo eh_type.lo eh_unex_handler.lo \
-	enum_type_info.lo function_type_info.lo \
-	fundamental_type_info.lo guard.lo new_handler.lo new_op.lo \
-	new_opnt.lo new_opv.lo new_opvnt.lo pbase_type_info.lo \
-	pmem_type_info.lo pointer_type_info.lo pure.lo \
-	si_class_type_info.lo tinfo.lo tinfo2.lo vec.lo \
-	vmi_class_type_info.lo vterminate.lo
-@GLIBCXX_HOSTED_TRUE@am__objects_2 = cp-demangle.lo
+@LIBSUPCXX_PRONLY_FALSE@am__objects_1 = array_type_info.lo \
+@LIBSUPCXX_PRONLY_FALSE@	atexit_arm.lo bad_cast.lo \
+@LIBSUPCXX_PRONLY_FALSE@	bad_typeid.lo class_type_info.lo \
+@LIBSUPCXX_PRONLY_FALSE@	del_op.lo del_opnt.lo del_opv.lo \
+@LIBSUPCXX_PRONLY_FALSE@	del_opvnt.lo dyncast.lo eh_alloc.lo \
+@LIBSUPCXX_PRONLY_FALSE@	eh_arm.lo eh_aux_runtime.lo eh_call.lo \
+@LIBSUPCXX_PRONLY_FALSE@	eh_catch.lo eh_exception.lo \
+@LIBSUPCXX_PRONLY_FALSE@	eh_globals.lo eh_personality.lo \
+@LIBSUPCXX_PRONLY_FALSE@	eh_ptr.lo eh_term_handler.lo \
+@LIBSUPCXX_PRONLY_FALSE@	eh_terminate.lo eh_throw.lo eh_type.lo \
+@LIBSUPCXX_PRONLY_FALSE@	eh_unex_handler.lo enum_type_info.lo \
+@LIBSUPCXX_PRONLY_FALSE@	function_type_info.lo \
+@LIBSUPCXX_PRONLY_FALSE@	fundamental_type_info.lo guard.lo \
+@LIBSUPCXX_PRONLY_FALSE@	new_handler.lo new_op.lo new_opnt.lo \
+@LIBSUPCXX_PRONLY_FALSE@	new_opv.lo new_opvnt.lo \
+@LIBSUPCXX_PRONLY_FALSE@	pbase_type_info.lo pmem_type_info.lo \
+@LIBSUPCXX_PRONLY_FALSE@	pointer_type_info.lo pure.lo \
+@LIBSUPCXX_PRONLY_FALSE@	si_class_type_info.lo tinfo.lo \
+@LIBSUPCXX_PRONLY_FALSE@	tinfo2.lo vec.lo \
+@LIBSUPCXX_PRONLY_FALSE@	vmi_class_type_info.lo vterminate.lo
+@LIBSUPCXX_PRONLY_TRUE@am__objects_1 = eh_personality.lo
+@GLIBCXX_HOSTED_TRUE@@LIBSUPCXX_PRONLY_FALSE@am__objects_2 =  \
+@GLIBCXX_HOSTED_TRUE@@LIBSUPCXX_PRONLY_FALSE@	cp-demangle.lo
 am_libsupc___la_OBJECTS = $(am__objects_1) $(am__objects_2)
 libsupc___la_OBJECTS = $(am_libsupc___la_OBJECTS)
 libsupc__convenience_la_LIBADD =
@@ -132,6 +142,9 @@
 SOURCES = $(libsupc___la_SOURCES) $(libsupc__convenience_la_SOURCES)
 DIST_SOURCES = $(am__libsupc___la_SOURCES_DIST) \
 	$(am__libsupc__convenience_la_SOURCES_DIST)
+am__glibcxxinstall_HEADERS_DIST = exception new typeinfo cxxabi.h \
+	cxxabi-forced.h exception_defines.h initializer_list \
+	exception_ptr.h
 glibcxxinstallHEADERS_INSTALL = $(INSTALL_HEADER)
 HEADERS = $(glibcxxinstall_HEADERS)
 ETAGS = etags
@@ -231,6 +244,8 @@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBSUPCXX_PICFLAGS = @LIBSUPCXX_PICFLAGS@
+LIBSUPCXX_PRONLY_FALSE = @LIBSUPCXX_PRONLY_FALSE@
+LIBSUPCXX_PRONLY_TRUE = @LIBSUPCXX_PRONLY_TRUE@
 LIBTOOL = @LIBTOOL@
 LIPO = @LIPO@
 LN_S = @LN_S@
@@ -365,57 +380,60 @@
 toolexeclib_LTLIBRARIES = libsupc++.la
 # 2) integrated libsupc++convenience.la that is to be a part of libstdc++.a
 noinst_LTLIBRARIES = libsupc++convenience.la
-headers = \
-	exception new typeinfo cxxabi.h cxxabi-forced.h exception_defines.h \
-	initializer_list exception_ptr.h
-
-@GLIBCXX_HOSTED_TRUE@c_sources = \
-@GLIBCXX_HOSTED_TRUE@	cp-demangle.c 
-
-sources = \
-	array_type_info.cc \
-	atexit_arm.cc \
-	bad_cast.cc \
-	bad_typeid.cc \
-	class_type_info.cc \
-	del_op.cc \
-	del_opnt.cc \
-	del_opv.cc \
-	del_opvnt.cc \
-	dyncast.cc \
-	eh_alloc.cc \
-	eh_arm.cc \
-	eh_aux_runtime.cc \
-	eh_call.cc \
-	eh_catch.cc \
-	eh_exception.cc \
-	eh_globals.cc \
-	eh_personality.cc \
-	eh_ptr.cc \
-	eh_term_handler.cc \
-	eh_terminate.cc \
-	eh_throw.cc \
-	eh_type.cc \
-	eh_unex_handler.cc \
-	enum_type_info.cc \
-	function_type_info.cc \
-	fundamental_type_info.cc \
-	guard.cc \
-	new_handler.cc \
-	new_op.cc \
-	new_opnt.cc \
-	new_opv.cc \
-	new_opvnt.cc \
-	pbase_type_info.cc \
-	pmem_type_info.cc \
-	pointer_type_info.cc \
-	pure.cc \
-	si_class_type_info.cc \
-	tinfo.cc \
-	tinfo2.cc \
-	vec.cc \
-	vmi_class_type_info.cc \
-	vterminate.cc
+@LIBSUPCXX_PRONLY_FALSE@sources = \
+@LIBSUPCXX_PRONLY_FALSE@	array_type_info.cc \
+@LIBSUPCXX_PRONLY_FALSE@	atexit_arm.cc \
+@LIBSUPCXX_PRONLY_FALSE@	bad_cast.cc \
+@LIBSUPCXX_PRONLY_FALSE@	bad_typeid.cc \
+@LIBSUPCXX_PRONLY_FALSE@	class_type_info.cc \
+@LIBSUPCXX_PRONLY_FALSE@	del_op.cc \
+@LIBSUPCXX_PRONLY_FALSE@	del_opnt.cc \
+@LIBSUPCXX_PRONLY_FALSE@	del_opv.cc \
+@LIBSUPCXX_PRONLY_FALSE@	del_opvnt.cc \
+@LIBSUPCXX_PRONLY_FALSE@	dyncast.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_alloc.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_arm.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_aux_runtime.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_call.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_catch.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_exception.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_globals.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_personality.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_ptr.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_term_handler.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_terminate.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_throw.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_type.cc \
+@LIBSUPCXX_PRONLY_FALSE@	eh_unex_handler.cc \
+@LIBSUPCXX_PRONLY_FALSE@	enum_type_info.cc \
+@LIBSUPCXX_PRONLY_FALSE@	function_type_info.cc \
+@LIBSUPCXX_PRONLY_FALSE@	fundamental_type_info.cc \
+@LIBSUPCXX_PRONLY_FALSE@	guard.cc \
+@LIBSUPCXX_PRONLY_FALSE@	new_handler.cc \
+@LIBSUPCXX_PRONLY_FALSE@	new_op.cc \
+@LIBSUPCXX_PRONLY_FALSE@	new_opnt.cc \
+@LIBSUPCXX_PRONLY_FALSE@	new_opv.cc \
+@LIBSUPCXX_PRONLY_FALSE@	new_opvnt.cc \
+@LIBSUPCXX_PRONLY_FALSE@	pbase_type_info.cc \
+@LIBSUPCXX_PRONLY_FALSE@	pmem_type_info.cc \
+@LIBSUPCXX_PRONLY_FALSE@	pointer_type_info.cc \
+@LIBSUPCXX_PRONLY_FALSE@	pure.cc \
+@LIBSUPCXX_PRONLY_FALSE@	si_class_type_info.cc \
+@LIBSUPCXX_PRONLY_FALSE@	tinfo.cc \
+@LIBSUPCXX_PRONLY_FALSE@	tinfo2.cc \
+@LIBSUPCXX_PRONLY_FALSE@	vec.cc \
+@LIBSUPCXX_PRONLY_FALSE@	vmi_class_type_info.cc \
+@LIBSUPCXX_PRONLY_FALSE@	vterminate.cc
+
+@LIBSUPCXX_PRONLY_TRUE@sources = \
+@LIBSUPCXX_PRONLY_TRUE@	eh_personality.cc
+
+@LIBSUPCXX_PRONLY_FALSE@headers = \
+@LIBSUPCXX_PRONLY_FALSE@	exception new typeinfo cxxabi.h cxxabi-forced.h exception_defines.h \
+@LIBSUPCXX_PRONLY_FALSE@	initializer_list exception_ptr.h
+
+@GLIBCXX_HOSTED_TRUE@@LIBSUPCXX_PRONLY_FALSE@c_sources = \
+@GLIBCXX_HOSTED_TRUE@@LIBSUPCXX_PRONLY_FALSE@	cp-demangle.c 
 
 libsupc___la_SOURCES = $(sources) $(c_sources)
 libsupc__convenience_la_SOURCES = $(sources) $(c_sources)
diff -Nur a/libstdc++-v3/Makefile.in b/libstdc++-v3/Makefile.in
--- a/libstdc++-v3/Makefile.in	2009-01-15 21:02:11.000000000 +0100
+++ b/libstdc++-v3/Makefile.in	2010-01-25 09:50:29.675687743 +0100
@@ -193,6 +193,8 @@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBSUPCXX_PICFLAGS = @LIBSUPCXX_PICFLAGS@
+LIBSUPCXX_PRONLY_FALSE = @LIBSUPCXX_PRONLY_FALSE@
+LIBSUPCXX_PRONLY_TRUE = @LIBSUPCXX_PRONLY_TRUE@
 LIBTOOL = @LIBTOOL@
 LIPO = @LIPO@
 LN_S = @LN_S@
diff -Nur a/libstdc++-v3/po/Makefile.in b/libstdc++-v3/po/Makefile.in
--- a/libstdc++-v3/po/Makefile.in	2009-01-15 21:02:11.000000000 +0100
+++ b/libstdc++-v3/po/Makefile.in	2010-01-25 09:50:29.675687743 +0100
@@ -161,6 +161,8 @@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBSUPCXX_PICFLAGS = @LIBSUPCXX_PICFLAGS@
+LIBSUPCXX_PRONLY_FALSE = @LIBSUPCXX_PRONLY_FALSE@
+LIBSUPCXX_PRONLY_TRUE = @LIBSUPCXX_PRONLY_TRUE@
 LIBTOOL = @LIBTOOL@
 LIPO = @LIPO@
 LN_S = @LN_S@
diff -Nur a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
--- a/libstdc++-v3/src/Makefile.in	2009-01-17 03:03:25.000000000 +0100
+++ b/libstdc++-v3/src/Makefile.in	2010-01-25 09:50:29.675687743 +0100
@@ -221,6 +221,8 @@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBSUPCXX_PICFLAGS = @LIBSUPCXX_PICFLAGS@
+LIBSUPCXX_PRONLY_FALSE = @LIBSUPCXX_PRONLY_FALSE@
+LIBSUPCXX_PRONLY_TRUE = @LIBSUPCXX_PRONLY_TRUE@
 LIBTOOL = @LIBTOOL@
 LIPO = @LIPO@
 LN_S = @LN_S@
diff -Nur a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stod.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stod.cc
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stod.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stod.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff -Nur a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stof.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stof.cc
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stof.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stof.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff -Nur a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoi.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoi.cc
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoi.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoi.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff -Nur a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stol.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stol.cc
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stol.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stol.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff -Nur a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stold.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stold.cc
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stold.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stold.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff -Nur a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoll.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoll.cc
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoll.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoll.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff -Nur a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoul.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoul.cc
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoul.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoul.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff -Nur a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoull.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoull.cc
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoull.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoull.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff -Nur a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/to_wstring.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/to_wstring.cc
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/to_wstring.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/to_wstring.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff -Nur a/libstdc++-v3/testsuite/21_strings/headers/cwchar/functions_std.cc b/libstdc++-v3/testsuite/21_strings/headers/cwchar/functions_std.cc
--- a/libstdc++-v3/testsuite/21_strings/headers/cwchar/functions_std.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/21_strings/headers/cwchar/functions_std.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,5 +1,6 @@
 // { dg-do compile }
 // { dg-require-c-std "" }
+// { dg-require-swprintf "" }
 
 // Copyright (C) 2007, 2009 Free Software Foundation, Inc.
 //
diff -Nur a/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/1-io.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/1-io.cc
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/1-io.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/1-io.cc	2010-01-25 09:50:29.675687743 +0100
@@ -20,6 +20,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff -Nur a/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/2-io.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/2-io.cc
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/2-io.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/2-io.cc	2010-01-25 09:50:29.675687743 +0100
@@ -20,6 +20,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff -Nur a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-in.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-in.cc
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-in.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-in.cc	2010-01-25 09:50:29.675687743 +0100
@@ -24,6 +24,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff -Nur a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-io.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-io.cc
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-io.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-io.cc	2010-01-25 09:50:29.675687743 +0100
@@ -24,6 +24,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff -Nur a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-in.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-in.cc
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-in.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-in.cc	2010-01-25 09:50:29.675687743 +0100
@@ -24,6 +24,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff -Nur a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-io.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-io.cc
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-io.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-io.cc	2010-01-25 09:50:29.675687743 +0100
@@ -24,6 +24,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff -Nur a/libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc	2010-01-25 09:50:29.675687743 +0100
@@ -17,6 +17,8 @@
 
 // 27.8.1.4 Overridden virtual functions
 
+// { dg-require-binary-io "" }
+
 #include <fstream>
 #include <locale>
 #include <testsuite_hooks.h>
diff -Nur a/libstdc++-v3/testsuite/27_io/basic_istream/readsome/char/6746-2.cc b/libstdc++-v3/testsuite/27_io/basic_istream/readsome/char/6746-2.cc
--- a/libstdc++-v3/testsuite/27_io/basic_istream/readsome/char/6746-2.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/readsome/char/6746-2.cc	2010-01-25 09:50:29.675687743 +0100
@@ -26,6 +26,7 @@
 // @diff@ %-*.tst %-*.txt
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <istream>
 #include <fstream>
diff -Nur a/libstdc++-v3/testsuite/27_io/basic_istream/readsome/wchar_t/6746-2.cc b/libstdc++-v3/testsuite/27_io/basic_istream/readsome/wchar_t/6746-2.cc
--- a/libstdc++-v3/testsuite/27_io/basic_istream/readsome/wchar_t/6746-2.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/readsome/wchar_t/6746-2.cc	2010-01-25 09:50:29.675687743 +0100
@@ -19,6 +19,8 @@
 // causes "in_avail" to return an incorrect value.
 // { dg-do run { xfail arm*-*-elf arm*-*-eabi } }
 
+// { dg-require-binary-io "" }
+
 // 27.6.1.3 unformatted input functions
 // @require@ %-*.tst %-*.txt
 // @diff@ %-*.tst %-*.txt
diff -Nur a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_arithmetic/wchar_t/4402.cc b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_arithmetic/wchar_t/4402.cc
--- a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_arithmetic/wchar_t/4402.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_arithmetic/wchar_t/4402.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,3 +1,5 @@
+// { dg-require-swprintf "" }
+
 // Copyright (C) 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
diff -Nur a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc
--- a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc	2009-04-28 12:32:22.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-swprintf "" }
 
 // Copyright (C) 2007, 2008, 2009 Free Software Foundation
 //
diff -Nur a/libstdc++-v3/testsuite/27_io/objects/char/10.cc b/libstdc++-v3/testsuite/27_io/objects/char/10.cc
--- a/libstdc++-v3/testsuite/27_io/objects/char/10.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/27_io/objects/char/10.cc	2010-01-25 09:50:29.675687743 +0100
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
  
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <iostream>
 #include <cstdio>
diff -Nur a/libstdc++-v3/testsuite/ext/vstring/element_access/char/front_back.cc b/libstdc++-v3/testsuite/ext/vstring/element_access/char/front_back.cc
--- a/libstdc++-v3/testsuite/ext/vstring/element_access/char/front_back.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/ext/vstring/element_access/char/front_back.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 
 // 2007-10-16  Paolo Carlini  <pcarlini@suse.de>
 
diff -Nur a/libstdc++-v3/testsuite/ext/vstring/element_access/wchar_t/front_back.cc b/libstdc++-v3/testsuite/ext/vstring/element_access/wchar_t/front_back.cc
--- a/libstdc++-v3/testsuite/ext/vstring/element_access/wchar_t/front_back.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/ext/vstring/element_access/wchar_t/front_back.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 
 // 2007-10-16  Paolo Carlini  <pcarlini@suse.de>
 
diff -Nur a/libstdc++-v3/testsuite/ext/vstring/init-list.cc b/libstdc++-v3/testsuite/ext/vstring/init-list.cc
--- a/libstdc++-v3/testsuite/ext/vstring/init-list.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/ext/vstring/init-list.cc	2010-01-25 09:50:29.675687743 +0100
@@ -17,6 +17,7 @@
 //
 
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 
 #include <ext/vstring.h>
 #include <testsuite_hooks.h>
diff -Nur a/libstdc++-v3/testsuite/ext/vstring/moveable.cc b/libstdc++-v3/testsuite/ext/vstring/moveable.cc
--- a/libstdc++-v3/testsuite/ext/vstring/moveable.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/ext/vstring/moveable.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 
 // Copyright (C) 2007, 2009 Free Software Foundation, Inc.
 //
diff -Nur a/libstdc++-v3/testsuite/ext/vstring/requirements/citerators.cc b/libstdc++-v3/testsuite/ext/vstring/requirements/citerators.cc
--- a/libstdc++-v3/testsuite/ext/vstring/requirements/citerators.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/ext/vstring/requirements/citerators.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 
 // 2007-10-15  Paolo Carlini  <pcarlini@suse.de>
 
diff -Nur a/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char16_t/1.cc b/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char16_t/1.cc
--- a/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char16_t/1.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char16_t/1.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,6 +1,7 @@
 // { dg-do compile }
 // { dg-options "-std=gnu++0x" }
 // { dg-require-cstdint "" }
+// { dg-require-string-conversions "" }
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
 //
diff -Nur a/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char32_t/1.cc b/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char32_t/1.cc
--- a/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char32_t/1.cc	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char32_t/1.cc	2010-01-25 09:50:29.675687743 +0100
@@ -1,6 +1,7 @@
 // { dg-do compile }
 // { dg-options "-std=gnu++0x" }
 // { dg-require-cstdint "" }
+// { dg-require-string-conversions "" }
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
 //
diff -Nur a/libstdc++-v3/testsuite/lib/dg-options.exp b/libstdc++-v3/testsuite/lib/dg-options.exp
--- a/libstdc++-v3/testsuite/lib/dg-options.exp	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/lib/dg-options.exp	2010-01-25 09:50:29.675687743 +0100
@@ -142,3 +142,21 @@
     }
     return
 }
+
+proc dg-require-swprintf { args } {
+    if { ![ check_v3_target_swprintf ] } {
+        upvar dg-do-what dg-do-what
+        set dg-do-what [list [lindex ${dg-do-what} 0] "N" "P"]
+        return
+    }
+    return
+}
+
+proc dg-require-binary-io { args } {
+    if { ![ check_v3_target_binary_io ] } {
+        upvar dg-do-what dg-do-what
+        set dg-do-what [list [lindex ${dg-do-what} 0] "N" "P"]
+        return
+    }
+    return
+}
diff -Nur a/libstdc++-v3/testsuite/lib/libstdc++.exp b/libstdc++-v3/testsuite/lib/libstdc++.exp
--- a/libstdc++-v3/testsuite/lib/libstdc++.exp	2009-05-21 13:30:55.000000000 +0200
+++ b/libstdc++-v3/testsuite/lib/libstdc++.exp	2010-01-25 09:50:29.675687743 +0100
@@ -204,14 +204,23 @@
 	# directory, and then add that to the search path.
 	foreach src [glob "${srcdir}/util/*.h" \
 		          "${srcdir}/util/*.cc" \
- 		          "${srcdir}/util/*/*.hpp" \
+		          "${srcdir}/util/*.tcc" \
+		          "${srcdir}/util/*.hpp" \
+ 		          "${srcdir}/util/*/*.h" \
 		          "${srcdir}/util/*/*.cc" \
+		          "${srcdir}/util/*/*.tcc" \
 			  "${srcdir}/util/*/*.hpp" \
+		          "${srcdir}/util/*/*/*.h" \
 		          "${srcdir}/util/*/*/*.cc" \
+		          "${srcdir}/util/*/*/*.tcc" \
 			  "${srcdir}/util/*/*/*.hpp" \
+		          "${srcdir}/util/*/*/*/*.h" \
 		          "${srcdir}/util/*/*/*/*.cc" \
+		          "${srcdir}/util/*/*/*/*.tcc" \
   			  "${srcdir}/util/*/*/*/*.hpp" \
+		          "${srcdir}/util/*/*/*/*/*.h" \
 		          "${srcdir}/util/*/*/*/*/*.cc" \
+		          "${srcdir}/util/*/*/*/*/*.tcc" \
   			  "${srcdir}/util/*/*/*/*/*.hpp" ] {
 	    # Remove everything up to "util/..."
 	    set dst [string range $src [string length "${srcdir}/"] end]
@@ -1374,3 +1383,119 @@
     verbose "check_v3_target_string_conversions: $et_string_conversions" 2
     return $et_string_conversions
 }
+
+proc check_v3_target_swprintf { } {
+    global cxxflags
+    global DEFAULT_CXXFLAGS
+    global et_swprintf
+
+    global tool
+
+    if { ![info exists et_swprintf_target_name] } {
+        set et_swprintf_target_name ""
+    }
+
+    # If the target has changed since we set the cached value, clear it.
+    set current_target [current_target_name]
+    if { $current_target != $et_swprintf_target_name } {
+        verbose "check_v3_target_swprintf: `$et_swprintf_target_name'" 2
+        set et_swprintf_target_name $current_target
+        if [info exists et_swprintf] {
+            verbose "check_v3_target_swprintf: removing cached result" 2
+            unset et_swprintf
+        }
+    }
+
+    if [info exists et_swprintf] {
+        verbose "check_v3_target_swprintf: using cached result" 2
+    } else {
+        set et_swprintf 0
+	
+	# Set up and compile a C++0x test program that depends
+        # on a standard swprintf function to be available.
+        set src swprintf[pid].cc
+        set exe swprintf[pid].exe
+
+        set f [open $src "w"]
+        puts $f "#include <bits/c++config.h>"
+        puts $f "int main()"
+        puts $f "#if !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF)"
+        puts $f "{ return 0; }"
+        puts $f "#endif"
+        close $f
+
+        set cxxflags_saved $cxxflags
+        set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"
+
+        set lines [v3_target_compile $src $exe executable ""]
+        set cxxflags $cxxflags_saved
+        file delete $src
+
+        if [string match "" $lines] {
+            # No error message, compilation succeeded.
+            set et_swprintf 1
+        } else {
+            verbose "check_v3_target_swprintf: compilation failed" 2
+        }
+    }
+    verbose "check_v3_target_swprintf: $et_swprintf" 2
+    return $et_swprintf
+}
+
+proc check_v3_target_binary_io { } {
+    global cxxflags
+    global DEFAULT_CXXFLAGS
+    global et_binary_io
+
+    global tool
+
+    if { ![info exists et_binary_io_target_name] } {
+        set et_binary_io_target_name ""
+    }
+
+    # If the target has changed since we set the cached value, clear it.
+    set current_target [current_target_name]
+    if { $current_target != $et_binary_io_target_name } {
+        verbose "check_v3_target_binary_io: `$et_binary_io_target_name'" 2
+        set et_binary_io_target_name $current_target
+        if [info exists et_binary_io] {
+            verbose "check_v3_target_binary_io: removing cached result" 2
+            unset et_binary_io
+        }
+    }
+
+    if [info exists et_binary_io] {
+        verbose "check_v3_target_binary_io: using cached result" 2
+    } else {
+        set et_binary_io 0
+	
+	# Set up and compile a C++0x test program that depends
+        # on text and binary I/O being the same.
+        set src binary_io[pid].cc
+        set exe binary_io[pid].exe
+
+        set f [open $src "w"]
+        puts $f "#include <bits/c++config.h>"
+        puts $f "int main()"
+        puts $f "#if !defined(_GLIBCXX_HAVE_DOS_BASED_FILESYSTEM)"
+        puts $f "{ return 0; }"
+        puts $f "#endif"
+        close $f
+
+        set cxxflags_saved $cxxflags
+        set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"
+
+        set lines [v3_target_compile $src $exe executable ""]
+        set cxxflags $cxxflags_saved
+        file delete $src
+
+        if [string match "" $lines] {
+            # No error message, compilation succeeded.
+            set et_binary_io 1
+        } else {
+            verbose "check_v3_target_binary_io: compilation failed" 2
+        }
+    }
+    verbose "check_v3_target_binary_io: $et_binary_io" 2
+    return $et_binary_io
+}
diff -Nur a/libstdc++-v3/testsuite/lib/prune.exp b/libstdc++-v3/testsuite/lib/prune.exp
--- a/libstdc++-v3/testsuite/lib/prune.exp	2009-04-10 01:23:07.000000000 +0200
+++ b/libstdc++-v3/testsuite/lib/prune.exp	2010-01-25 09:50:29.675687743 +0100
@@ -30,5 +30,23 @@
     regsub -all "(^|\n)\[^\n\]*: Additional NOP may be necessary to workaround Itanium processor A/B step errata" $text "" text
     regsub -all "(^|\n)\[^\n*\]*: Assembler messages:\[^\n\]*" $text "" text
 
+    if { [ishost "sparc*-*-solaris2*"] } {
+	# When testing a compiler built for SPARC Solaris 2.9 (or earlier)
+	# on a host running Solaris 2.10 (or later), we get this warning 
+	# from the static linker when building with g++:
+	#
+	#   libm.so.1, needed by .../libstdc++.so may conflict with
+	#   libm.so
+	#
+	# The warning is issued because libstdc++ is linked against
+	# libm.so.1 (from the Solaris 2.9 sysroot), whereas Solaris 2.10
+	# provides both libm.so.2 and libm.so.1.  On Solaris 2.10, libc.so
+	# depends on libm.so.2, so all programs pull in libm.so.2.
+	#
+	# Pulling both libraries must in fact be harmless, as, otherwise,
+	# programs built for Solaris 2.9 would break on Solaris 2.10.
+	regsub -all "(^|\n)\[^\n\]*: warning: libm.so.1, needed by \[^\n\]*, may conflict with libm.so.2" $text "" text
+    }
+
     return $text
 }
diff -Nur a/libstdc++-v3/testsuite/Makefile.in b/libstdc++-v3/testsuite/Makefile.in
--- a/libstdc++-v3/testsuite/Makefile.in	2009-02-23 21:42:53.000000000 +0100
+++ b/libstdc++-v3/testsuite/Makefile.in	2010-01-25 09:50:29.675687743 +0100
@@ -161,6 +161,8 @@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBSUPCXX_PICFLAGS = @LIBSUPCXX_PICFLAGS@
+LIBSUPCXX_PRONLY_FALSE = @LIBSUPCXX_PRONLY_FALSE@
+LIBSUPCXX_PRONLY_TRUE = @LIBSUPCXX_PRONLY_TRUE@
 LIBTOOL = @LIBTOOL@
 LIPO = @LIPO@
 LN_S = @LN_S@
