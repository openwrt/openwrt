From f76abd98383dbd350f4e41b400beaaff2130254a Mon Sep 17 00:00:00 2001
From: P Praneesh <quic_ppranees@quicinc.com>
Date: Sun, 3 Jul 2022 19:31:44 +0530
Subject: [PATCH] mac80211: add EHT radiotap header construction logic

Driver advertises U_SIG and EHT info in the flag under rx_status
structure. Based on this flag, corresponding EHT and U_SIG
information are added in the radiotap header.

Signed-off-by: P Praneesh <quic_ppranees@quicinc.com>
---
 include/net/ieee80211_radiotap.h | 160 +++++++++++++++++++++++++++++++++++++++
 include/net/mac80211.h           |   9 +++
 net/mac80211/rx.c                |  88 +++++++++++++++++++++
 3 files changed, 257 insertions(+)

--- a/include/net/ieee80211_radiotap.h
+++ b/include/net/ieee80211_radiotap.h
@@ -92,6 +92,11 @@ enum ieee80211_radiotap_presence {
 	IEEE80211_RADIOTAP_EHT = 34,
 };
 
+enum ieee80211_radiotap_presence_ext {
+	IEEE80211_RADIOTAP_USIG_INFO	= 1,
+	IEEE80211_RADIOTAP_EHT_INFO	= 2,
+};
+
 /* for IEEE80211_RADIOTAP_FLAGS */
 enum ieee80211_radiotap_flags {
 	IEEE80211_RADIOTAP_F_CFP = 0x01,
@@ -406,128 +411,6 @@ struct ieee80211_radiotap_eht_usig {
 	__le32 mask;
 } __packed;
 
-/* ieee80211_radiotap_eht - content of EHT tlv (type 34)
- * see www.radiotap.org/fields/EHT.html for details
- */
-struct ieee80211_radiotap_eht {
-	__le32 known;
-	__le32 data[9];
-	__le32 user_info[];
-} __packed;
-
-/* Known field for EHT TLV
- * The ending defines for what the field applies as following
- * O - OFDMA (including TB), M - MU-MIMO, S - EHT sounding.
- */
-enum ieee80211_radiotap_eht_known {
-	IEEE80211_RADIOTAP_EHT_KNOWN_SPATIAL_REUSE		= 0x00000002,
-	IEEE80211_RADIOTAP_EHT_KNOWN_GI				= 0x00000004,
-	IEEE80211_RADIOTAP_EHT_KNOWN_EHT_LTF			= 0x00000010,
-	IEEE80211_RADIOTAP_EHT_KNOWN_LDPC_EXTRA_SYM_OM		= 0x00000020,
-	IEEE80211_RADIOTAP_EHT_KNOWN_PRE_PADD_FACOR_OM		= 0x00000040,
-	IEEE80211_RADIOTAP_EHT_KNOWN_PE_DISAMBIGUITY_OM		= 0x00000080,
-	IEEE80211_RADIOTAP_EHT_KNOWN_DISREGARD_O		= 0x00000100,
-	IEEE80211_RADIOTAP_EHT_KNOWN_DISREGARD_S		= 0x00000200,
-	IEEE80211_RADIOTAP_EHT_KNOWN_CRC1			= 0x00002000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_TAIL1			= 0x00004000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_CRC2_O			= 0x00008000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_TAIL2_O			= 0x00010000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_NSS_S			= 0x00020000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_BEAMFORMED_S		= 0x00040000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_NR_NON_OFDMA_USERS_M	= 0x00080000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_ENCODING_BLOCK_CRC_M	= 0x00100000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_ENCODING_BLOCK_TAIL_M	= 0x00200000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_RU_MRU_SIZE_OM		= 0x00400000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_RU_MRU_INDEX_OM		= 0x00800000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_RU_ALLOC_TB_FMT		= 0x01000000,
-	IEEE80211_RADIOTAP_EHT_KNOWN_PRIMARY_80			= 0x02000000,
-};
-
-enum ieee80211_radiotap_eht_data {
-	/* Data 0 */
-	IEEE80211_RADIOTAP_EHT_DATA0_SPATIAL_REUSE		= 0x00000078,
-	IEEE80211_RADIOTAP_EHT_DATA0_GI				= 0x00000180,
-	IEEE80211_RADIOTAP_EHT_DATA0_LTF			= 0x00000600,
-	IEEE80211_RADIOTAP_EHT_DATA0_EHT_LTF			= 0x00003800,
-	IEEE80211_RADIOTAP_EHT_DATA0_LDPC_EXTRA_SYM_OM		= 0x00004000,
-	IEEE80211_RADIOTAP_EHT_DATA0_PRE_PADD_FACOR_OM		= 0x00018000,
-	IEEE80211_RADIOTAP_EHT_DATA0_PE_DISAMBIGUITY_OM		= 0x00020000,
-	IEEE80211_RADIOTAP_EHT_DATA0_DISREGARD_S		= 0x000c0000,
-	IEEE80211_RADIOTAP_EHT_DATA0_DISREGARD_O		= 0x003c0000,
-	IEEE80211_RADIOTAP_EHT_DATA0_CRC1_O			= 0x03c00000,
-	IEEE80211_RADIOTAP_EHT_DATA0_TAIL1_O			= 0xfc000000,
-	/* Data 1 */
-	IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE			= 0x0000001f,
-	IEEE80211_RADIOTAP_EHT_DATA1_RU_INDEX			= 0x00001fe0,
-	IEEE80211_RADIOTAP_EHT_DATA1_RU_ALLOC_CC_1_1_1		= 0x003fe000,
-	IEEE80211_RADIOTAP_EHT_DATA1_RU_ALLOC_CC_1_1_1_KNOWN	= 0x00400000,
-	IEEE80211_RADIOTAP_EHT_DATA1_PRIMARY_80			= 0xc0000000,
-	/* Data 2 */
-	IEEE80211_RADIOTAP_EHT_DATA2_RU_ALLOC_CC_2_1_1		= 0x000001ff,
-	IEEE80211_RADIOTAP_EHT_DATA2_RU_ALLOC_CC_2_1_1_KNOWN	= 0x00000200,
-	IEEE80211_RADIOTAP_EHT_DATA2_RU_ALLOC_CC_1_1_2		= 0x0007fc00,
-	IEEE80211_RADIOTAP_EHT_DATA2_RU_ALLOC_CC_1_1_2_KNOWN	= 0x00080000,
-	IEEE80211_RADIOTAP_EHT_DATA2_RU_ALLOC_CC_2_1_2		= 0x1ff00000,
-	IEEE80211_RADIOTAP_EHT_DATA2_RU_ALLOC_CC_2_1_2_KNOWN	= 0x20000000,
-	/* Data 3 */
-	IEEE80211_RADIOTAP_EHT_DATA3_RU_ALLOC_CC_1_2_1		= 0x000001ff,
-	IEEE80211_RADIOTAP_EHT_DATA3_RU_ALLOC_CC_1_2_1_KNOWN	= 0x00000200,
-	IEEE80211_RADIOTAP_EHT_DATA3_RU_ALLOC_CC_2_2_1		= 0x0007fc00,
-	IEEE80211_RADIOTAP_EHT_DATA3_RU_ALLOC_CC_2_2_1_KNOWN	= 0x00080000,
-	IEEE80211_RADIOTAP_EHT_DATA3_RU_ALLOC_CC_1_2_2		= 0x1ff00000,
-	IEEE80211_RADIOTAP_EHT_DATA3_RU_ALLOC_CC_1_2_2_KNOWN	= 0x20000000,
-	/* Data 4 */
-	IEEE80211_RADIOTAP_EHT_DATA4_RU_ALLOC_CC_2_2_2		= 0x000001ff,
-	IEEE80211_RADIOTAP_EHT_DATA4_RU_ALLOC_CC_2_2_2_KNOWN	= 0x00000200,
-	IEEE80211_RADIOTAP_EHT_DATA4_RU_ALLOC_CC_1_2_3		= 0x0007fc00,
-	IEEE80211_RADIOTAP_EHT_DATA4_RU_ALLOC_CC_1_2_3_KNOWN	= 0x00080000,
-	IEEE80211_RADIOTAP_EHT_DATA4_RU_ALLOC_CC_2_2_3		= 0x1ff00000,
-	IEEE80211_RADIOTAP_EHT_DATA4_RU_ALLOC_CC_2_2_3_KNOWN	= 0x20000000,
-	/* Data 5 */
-	IEEE80211_RADIOTAP_EHT_DATA5_RU_ALLOC_CC_1_2_4		= 0x000001ff,
-	IEEE80211_RADIOTAP_EHT_DATA5_RU_ALLOC_CC_1_2_4_KNOWN	= 0x00000200,
-	IEEE80211_RADIOTAP_EHT_DATA5_RU_ALLOC_CC_2_2_4		= 0x0007fc00,
-	IEEE80211_RADIOTAP_EHT_DATA5_RU_ALLOC_CC_2_2_4_KNOWN	= 0x00080000,
-	IEEE80211_RADIOTAP_EHT_DATA5_RU_ALLOC_CC_1_2_5		= 0x1ff00000,
-	IEEE80211_RADIOTAP_EHT_DATA5_RU_ALLOC_CC_1_2_5_KNOWN	= 0x20000000,
-	/* Data 6 */
-	IEEE80211_RADIOTAP_EHT_DATA6_RU_ALLOC_CC_2_2_5		= 0x000001ff,
-	IEEE80211_RADIOTAP_EHT_DATA6_RU_ALLOC_CC_2_2_5_KNOWN	= 0x00000200,
-	IEEE80211_RADIOTAP_EHT_DATA6_RU_ALLOC_CC_1_2_6		= 0x0007fc00,
-	IEEE80211_RADIOTAP_EHT_DATA6_RU_ALLOC_CC_1_2_6_KNOWN	= 0x00080000,
-	IEEE80211_RADIOTAP_EHT_DATA6_RU_ALLOC_CC_2_2_6		= 0x1ff00000,
-	IEEE80211_RADIOTAP_EHT_DATA6_RU_ALLOC_CC_2_2_6_KNOWN	= 0x20000000,
-	/* Data 7 */
-	IEEE80211_RADIOTAP_EHT_DATA7_CRC2_O			= 0x0000000f,
-	IEEE80211_RADIOTAP_EHT_DATA7_TAIL_2_O			= 0x000003f0,
-	IEEE80211_RADIOTAP_EHT_DATA7_NSS_S			= 0x0000f000,
-	IEEE80211_RADIOTAP_EHT_DATA7_BEAMFORMED_S		= 0x00010000,
-	IEEE80211_RADIOTAP_EHT_DATA7_NUM_OF_NON_OFDMA_USERS	= 0x000e0000,
-	IEEE80211_RADIOTAP_EHT_DATA7_USER_ENCODING_BLOCK_CRC	= 0x00f00000,
-	IEEE80211_RADIOTAP_EHT_DATA7_USER_ENCODING_BLOCK_TAIL	= 0x3f000000,
-	/* Data 8 */
-	IEEE80211_RADIOTAP_EHT_DATA8_RU_ALLOC_TB_FMT_PS_160	= 0x00000001,
-	IEEE80211_RADIOTAP_EHT_DATA8_RU_ALLOC_TB_FMT_B0		= 0x00000002,
-	IEEE80211_RADIOTAP_EHT_DATA8_RU_ALLOC_TB_FMT_B7_B1	= 0x000001fc,
-};
-
-enum ieee80211_radiotap_eht_user_info {
-	IEEE80211_RADIOTAP_EHT_USER_INFO_STA_ID_KNOWN		= 0x00000001,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_MCS_KNOWN		= 0x00000002,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_CODING_KNOWN		= 0x00000004,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_NSS_KNOWN_O		= 0x00000010,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_BEAMFORMING_KNOWN_O	= 0x00000020,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_SPATIAL_CONFIG_KNOWN_M	= 0x00000040,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_DATA_FOR_USER		= 0x00000080,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_STA_ID			= 0x0007ff00,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_CODING			= 0x00080000,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_MCS			= 0x00f00000,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_NSS_O			= 0x0f000000,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_BEAMFORMING_O		= 0x20000000,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_SPATIAL_CONFIG_M	= 0x3f000000,
-	IEEE80211_RADIOTAP_EHT_USER_INFO_RESEVED_c0000000	= 0xc0000000,
-};
-
 enum ieee80211_radiotap_eht_usig_common {
 	IEEE80211_RADIOTAP_EHT_USIG_COMMON_PHY_VER_KNOWN	= 0x00000001,
 	IEEE80211_RADIOTAP_EHT_USIG_COMMON_BW_KNOWN		= 0x00000002,
@@ -573,6 +456,161 @@ enum ieee80211_radiotap_eht_usig_tb {
 	IEEE80211_RADIOTAP_EHT_USIG2_TB_B20_B25_TAIL		= 0xfc000000,
 };
 
+enum ieee80211_radiotap_usig_common {
+	IEEE80211_RADIOTAP_USIG_CMN_PHY_VERSION			= 0x00000001,
+	IEEE80211_RADIOTAP_USIG_CMN_BW_KNOWN			= 0x00000002,
+	IEEE80211_RADIOTAP_USIG_CMN_UL_DL_KNOWN			= 0x00000004,
+	IEEE80211_RADIOTAP_USIG_CMN_BSS_COLOR_KNOWN		= 0x00000008,
+	IEEE80211_RADIOTAP_USIG_CMN_TXOP_KNOWN			= 0x00000010,
+	IEEE80211_RADIOTAP_USIG_CMN_BAD_CRC			= 0x00000020,
+	IEEE80211_RADIOTAP_USIG_CMN_PHY_VERSION_ID		= 0x00007000,
+	IEEE80211_RADIOTAP_USIG_CMN_BW				= 0x00038000,
+	IEEE80211_RADIOTAP_USIG_CMN_UL_DL			= 0x00040000,
+	IEEE80211_RADIOTAP_USIG_CMN_BSS_COLOR			= 0x01f80000,
+	IEEE80211_RADIOTAP_USIG_CMN_TXOP			= 0xfe000000,
+};
+
+enum ieee80211_radiotap_usig_eht_mu_ppdu {
+	IEEE80211_RADIOTAP_USIG_EHT_MU_DISREGARD		= 0x0000001f,
+	IEEE80211_RADIOTAP_USIG_EHT_MU_DISREGARD_VALIDATE	= 0x00000020,
+	IEEE80211_RADIOTAP_USIG_EHT_MU_PPDU_TYPE_COMP_MODE	= 0x000000c0,
+	IEEE80211_RADIOTAP_USIG_EHT_MU_PPDU_COMP_VALIDATE	= 0x00000100,
+	IEEE80211_RADIOTAP_USIG_EHT_MU_PUNCTURED_CHAN_INFO	= 0x00003e00,
+	IEEE80211_RADIOTAP_USIG_EHT_MU_PUNCTURED_CHAN_VALIDATE	= 0x00004000,
+	IEEE80211_RADIOTAP_USIG_EHT_MU_MCS			= 0x00018000,
+	IEEE80211_RADIOTAP_USIG_EHT_MU_NUM_SYMBOLS		= 0x003e0000,
+	IEEE80211_RADIOTAP_USIG_EHT_MU_CRC			= 0x03c00000,
+	IEEE80211_RADIOTAP_USIG_EHT_MU_TAIL			= 0xfc000000,
+};
+
+enum ieee80211_radiotap_usig_eht_tb_ppdu {
+	IEEE80211_RADIOTAP_USIG_EHT_TB_DISREGARD		= 0x0000003f,
+	IEEE80211_RADIOTAP_USIG_EHT_TB_PPDU_TYPE_COMP_MODE	= 0x000000c0,
+	IEEE80211_RADIOTAP_USIG_EHT_TB_VALIDATE			= 0x00000100,
+	IEEE80211_RADIOTAP_USIG_EHT_TB_SPATIAL_REUSE1		= 0x00001e00,
+	IEEE80211_RADIOTAP_USIG_EHT_TB_SPATIAL_REUSE2		= 0x0001e000,
+	IEEE80211_RADIOTAP_USIG_EHT_TB_DISREGARD1		= 0x003e0000,
+	IEEE80211_RADIOTAP_USIG_EHT_TB_CRC			= 0x03c00000,
+	IEEE80211_RADIOTAP_USIG_EHT_TB_TAIL			= 0xfc000000,
+};
+
+struct ieee80211_radiotap_usig {
+	__le32 usig_cmn;
+	__le32 eht_mu_ppdu;
+	__le32 eht_tb_ppdu;
+};
+
+enum ieee80211_radiotap_eht_known {
+	IEEE80211_RADIOTAP_EHT_SPATIAL_REUSE_KNOWN	= 0x00000002,
+	IEEE80211_RADIOTAP_EHT_GUARD_INTERVAL_KNOWN	= 0x00000004,
+	IEEE80211_RADIOTAP_EHT_LTF_KNOWN		= 0x00000008,
+	IEEE80211_RADIOTAP_EHT_EHT_LTF_KNOWN		= 0x00000010,
+	IEEE80211_RADIOTAP_EHT_LDPC_EXTRA_SYM_SEG_KNOWN	= 0x00000020,
+	IEEE80211_RADIOTAP_EHT_PRE_FEC_PAD_FACTOR_KNOWN	= 0x00000040,
+	IEEE80211_RADIOTAP_EHT_PE_DISAMBIGUITY_KNOWN	= 0x00000080,
+	IEEE80211_RADIOTAP_EHT_DISREGARD_KNOWN		= 0x00000100,
+	IEEE80211_RADIOTAP_EHT_SOUNDING_DISREGARD_KNOWN	= 0x00000200,
+	IEEE80211_RADIOTAP_EHT_CRC1_KNOWN		= 0x00002000,
+	IEEE80211_RADIOTAP_EHT_TAIL1_KNOWN		= 0x00004000,
+	IEEE80211_RADIOTAP_EHT_CRC2_KNOWN		= 0x00008000,
+	IEEE80211_RADIOTAP_EHT_TAIL2_KNOWN		= 0x00010000,
+	IEEE80211_RADIOTAP_EHT_NSS_KNOWN		= 0x00020000,
+	IEEE80211_RADIOTAP_EHT_BEAMFORMED_KNOWN		= 0x00040000,
+	IEEE80211_RADIOTAP_EHT_NUM_NON_OFDMA_USR_KNOWN	= 0x00080000,
+	IEEE80211_RADIOTAP_EHT_USR_ENC_BLK_CRC_KNOWN	= 0x00100000,
+	IEEE80211_RADIOTAP_EHT_USR_ENC_BLK_TAIL_KNOWN	= 0x00200000,
+	IEEE80211_RADIOTAP_EHT_RU_SIZE_KNOWN		= 0x00400000,
+	IEEE80211_RADIOTAP_EHT_RU_INDEX_KNOWN		= 0x00800000,
+	IEEE80211_RADIOTAP_EHT_RU_ALLOCATION		= 0x01000000,
+	IEEE80211_RADIOTAP_EHT_PRI80_CHAN_POS_KNOWN	= 0x02000000,
+};
+
+enum ieee80211_radiotap_eht_data0 {
+	IEEE80211_RADIOTAP_EHT_DATA0_SPATIAL_REUSE		= 0x00000078,
+	IEEE80211_RADIOTAP_EHT_DATA0_GI				= 0x00000180,
+	IEEE80211_RADIOTAP_EHT_DATA0_LTF			= 0x00000600,
+	IEEE80211_RADIOTAP_EHT_DATA0_EHT_LTF			= 0x00003800,
+	IEEE80211_RADIOTAP_EHT_DATA0_LDPC_EXTRA_SYM_SEG		= 0x00004000,
+	IEEE80211_RADIOTAP_EHT_DATA0_PRE_FEC_PAD_FACTOR		= 0x00018000,
+	IEEE80211_RADIOTAP_EHT_DATA0_PE_DISAMBIGUITY		= 0x00020000,
+	IEEE80211_RADIOTAP_EHT_DATA0_DISREGARD_EHT_SOUND	= 0x000c0000,
+	IEEE80211_RADIOTAP_EHT_DATA0_DISREGARD_NON_EHT_SOUND	= 0x003c0000,
+	IEEE80211_RADIOTAP_EHT_DATA0_CRC1			= 0x03c00000,
+	IEEE80211_RADIOTAP_EHT_DATA0_TAIL1			= 0xfc000000,
+};
+
+enum ieee80211_radiotap_eht_data1 {
+	IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE			= 0x0000001f,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_26			= 0,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_52			= 1,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_106		= 2,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_242		= 3,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_484		= 4,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_996		= 5,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_2x996		= 6,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_4x996		= 7,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_52P26		= 8,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_106P26		= 9,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_484P242		= 10,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_996P484		= 11,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_996P484P242	= 12,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_2x996P484		= 13,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_3x996		= 14,
+		IEEE80211_RADIOTAP_EHT_DATA1_RU_SIZE_3x996P484		= 15,
+
+	IEEE80211_RADIOTAP_EHT_DATA1_RU_INDEX			= 0x00001fe0,
+	IEEE80211_RADIOTAP_EHT_DATA1_RU_ALLOCATION1		= 0x003fe000,
+	IEEE80211_RADIOTAP_EHT_DATA1_RU_PRIMARY_80MHZ_CHAN_POS	= 0xc0000000,
+};
+
+enum ieee80211_radiotap_eht_data2_to_data6 {
+	IEEE80211_RADIOTAP_EHT_DATA2_6_RU_ALLOCATION_X		= 0x000001ff,
+	IEEE80211_RADIOTAP_EHT_DATA2_6_RU_ALLOCATION_X_KNOWN	= 0x00000200,
+	IEEE80211_RADIOTAP_EHT_DATA2_6_RU_ALLOCATION_XP1	= 0x0007fc00,
+	IEEE80211_RADIOTAP_EHT_DATA2_6_RU_ALLOCATION_XP1_KNOWN	= 0x00080000,
+	IEEE80211_RADIOTAP_EHT_DATA2_6_RU_ALLOCATION_XP2	= 0x1ff00000,
+	IEEE80211_RADIOTAP_EHT_DATA2_6_RU_ALLOCATION_XP2_KNOWN	= 0x20000000,
+};
+
+enum ieee80211_radiotap_eht_data7 {
+	IEEE80211_RADIOTAP_EHT_DATA7_CRC2			= 0x0000000f,
+	IEEE80211_RADIOTAP_EHT_DATA7_TAIL2			= 0x000003f0,
+	IEEE80211_RADIOTAP_EHT_DATA7_NSS			= 0x0000f000,
+	IEEE80211_RADIOTAP_EHT_DATA7_BEAMFORMED			= 0x00010000,
+	IEEE80211_RADIOTAP_EHT_DATA7_NUM_NON_OFDMA_USERS	= 0x000e0000,
+	IEEE80211_RADIOTAP_EHT_DATA7_USR_ENC_BLK_CRC		= 0x00f00000,
+	IEEE80211_RADIOTAP_EHT_DATA7_USR_ENC_BLK_TAIL		= 0x3f000000,
+};
+
+enum ieee80211_radiotap_eht_data8 {
+	IEEE80211_RADIOTAP_EHT_DATA8_RU_ALLOCATION_PS160	= 0x00000001,
+	IEEE80211_RADIOTAP_EHT_DATA8_RU_ALLOCATION_TB_FORMAT1	= 0x00000002,
+	IEEE80211_RADIOTAP_EHT_DATA8_RU_ALLOCATION_TB_FORMAT2	= 0x000001fc,
+};
+
+enum ieee80211_radiotap_eht_user_info {
+	IEEE80211_RADIOTAP_EHT_USER_INFO_STA_ID_KNOWN		= 0x00000001,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_MCS_KNOWN		= 0x00000002,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_CODING_KNOWN		= 0x00000004,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_RSVD_KNOWN		= 0x00000008,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_NSS_KNOWN		= 0x00000010,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_BEAMFORMING_KNOWN	= 0x00000020,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_SPATIAL_CONFIG_KNOWN	= 0x00000040,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_DATA_CAPTURE		= 0x00000080,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_STA_ID			= 0x0007ff00,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_CODING			= 0x00080000,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_MCS			= 0x00f00000,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_NSS			= 0x0f000000,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_BEAMFORMING		= 0x20000000,
+	IEEE80211_RADIOTAP_EHT_USER_INFO_SPATIAL_CONFIG		= 0x3f000000,
+};
+
+struct ieee80211_radiotap_eht {
+	__le32 known;
+	__le32 data[9];
+	__le32 user_info[];
+};
+
 /**
  * ieee80211_get_radiotap_len - get radiotap header length
  */
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -1441,7 +1441,11 @@ ieee80211_tx_info_clear_status(struct ie
  *	known the frame shouldn't be reported.
  * @RX_FLAG_8023: the frame has an 802.3 header (decap offload performed by
  *	hardware or driver)
+ * @RX_FLAG_USIG_HEADER: Universal field carries information necessary to
+ *	interpret EHT PPDUs.
+ * @RX_FLAG_EHT_HEADER: EHT radiotap data is present.
  */
+
 enum mac80211_rx_flags {
 	RX_FLAG_MMIC_ERROR		= BIT(0),
 	RX_FLAG_DECRYPTED		= BIT(1),
@@ -1473,6 +1477,8 @@ enum mac80211_rx_flags {
 	RX_FLAG_RADIOTAP_LSIG           = BIT(27),
 	RX_FLAG_NO_PSDU                 = BIT(28),
 	RX_FLAG_8023                    = BIT(29),
+	RX_FLAG_USIG_HEADER             = BIT(30),
+	RX_FLAG_EHT_HEADER              = BIT(31),
 };
 
 /**
@@ -1540,6 +1546,7 @@ enum mac80211_rx_encoding {
  *	HT or VHT is used (%RX_FLAG_HT/%RX_FLAG_VHT)
  * @nss: number of streams (VHT, HE and EHT only)
  * @flag: %RX_FLAG_\*
+ * @ext_flag: %RX_FLAG_\*
  * @encoding: &enum mac80211_rx_encoding
  * @bw: &enum rate_info_bw
  * @enc_flags: uses bits from &enum mac80211_rx_encoding_flags
@@ -1593,6 +1600,7 @@ struct ieee80211_rx_status {
 	u8 ampdu_delimiter_crc;
 	u8 zero_length_psdu_type;
 	u8 link_valid:1, link_id:4;
+	u8 eht_num_user;
 };
 
 static inline u32
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -143,6 +143,12 @@ ieee80211_rx_radiotap_hdrlen(struct ieee
 	/* always present fields */
 	len = sizeof(struct ieee80211_radiotap_header) + 8;
 
+	/* EHT present fields */
+	if ((status->flag & RX_FLAG_EHT_HEADER) ||
+	    (status->flag & RX_FLAG_USIG_HEADER)) {
+		len += 4;
+	}
+
 	/* allocate extra bitmaps */
 	if (status->chains)
 		len += 4 * hweight8(status->chains);
@@ -202,6 +208,20 @@ ieee80211_rx_radiotap_hdrlen(struct ieee
 		BUILD_BUG_ON(sizeof(struct ieee80211_radiotap_lsig) != 4);
 	}
 
+	if (status->flag & RX_FLAG_USIG_HEADER &&
+	    status->encoding == RX_ENC_EHT) {
+		len = ALIGN(len, 4);
+		len += 12;
+		BUILD_BUG_ON(sizeof(struct ieee80211_radiotap_usig) != 12);
+	}
+
+	if (status->flag & RX_FLAG_EHT_HEADER &&
+	    status->encoding == RX_ENC_EHT) {
+		len = ALIGN(len, 4);
+		len += 40;
+		len += status->eht_num_user * 4;
+	}
+
 	if (status->chains) {
 		/* antenna and antenna signal fields */
 		len += 2 * hweight8(status->chains);
@@ -223,6 +243,15 @@ ieee80211_rx_radiotap_hdrlen(struct ieee
 		if (status->flag & RX_FLAG_RADIOTAP_LSIG)
 			tlv_offset +=
 				sizeof(struct ieee80211_radiotap_lsig);
+		if (status->flag & RX_FLAG_USIG_HEADER)
+			tlv_offset +=
+				sizeof(struct ieee80211_radiotap_usig);
+		if (status->flag & RX_FLAG_EHT_HEADER) {
+			tlv_offset +=
+				sizeof(struct ieee80211_radiotap_eht);
+			tlv_offset +=
+				status->eht_num_user * sizeof(u32);
+		}
 
 		/* ensure 4 byte alignment for TLV */
 		len = ALIGN(len, 4);
@@ -330,6 +359,14 @@ ieee80211_add_rx_radiotap_header(struct
 	struct ieee80211_radiotap_he he = {};
 	struct ieee80211_radiotap_he_mu he_mu = {};
 	struct ieee80211_radiotap_lsig lsig = {};
+	struct ieee80211_radiotap_usig usig = {};
+	struct ieee80211_radiotap_eht eht = {};
+	u32 *user_info;
+	bool rhdr_ext = false;
+
+	if ((status->flag & RX_FLAG_USIG_HEADER) ||
+	    (status->flag & RX_FLAG_EHT_HEADER))
+		rhdr_ext = true;
 
 	if (status->flag & RX_FLAG_RADIOTAP_HE) {
 		he = *(struct ieee80211_radiotap_he *)skb->data;
@@ -352,6 +389,20 @@ ieee80211_add_rx_radiotap_header(struct
 		tlvs_len = skb_mac_header(skb) - skb->data;
 	}
 
+	if (status->flag & RX_FLAG_USIG_HEADER) {
+		usig = *(struct ieee80211_radiotap_usig *)skb->data;
+		skb_pull(skb, sizeof(usig));
+		WARN_ON_ONCE(status->encoding != RX_ENC_EHT);
+	}
+
+	if (status->flag & RX_FLAG_EHT_HEADER) {
+		eht = *(struct ieee80211_radiotap_eht *)skb->data;
+		skb_pull(skb, sizeof(eht));
+		user_info = (u32 *)skb->data;
+		skb_pull(skb, status->eht_num_user * sizeof(u32));
+		WARN_ON_ONCE(status->encoding != RX_ENC_EHT);
+	}
+
 	mpdulen = skb->len;
 	if (!(has_fcs && ieee80211_hw_check(&local->hw, RX_INCLUDES_FCS)))
 		mpdulen += FCS_LEN;
@@ -382,6 +433,19 @@ ieee80211_add_rx_radiotap_header(struct
 	if (status->flag & RX_FLAG_RADIOTAP_TLV_AT_END)
 		it_present_val |= BIT(IEEE80211_RADIOTAP_TLV);
 
+	if (rhdr_ext) {
+		it_present_val |= BIT(IEEE80211_RADIOTAP_EXT);
+		put_unaligned_le32(it_present_val, it_present);
+		it_present_val = 0;
+		it_present++;
+		/* IEEE80211_RADIOTAP_USIG */
+		if (status->flag & RX_FLAG_USIG_HEADER)
+			it_present_val |= BIT(IEEE80211_RADIOTAP_USIG_INFO);
+		/* IEEE80211_RADIOTAP_EHT */
+		if (status->flag & RX_FLAG_EHT_HEADER)
+			it_present_val |= BIT(IEEE80211_RADIOTAP_EHT_INFO);
+	}
+
 	put_unaligned_le32(it_present_val, it_present);
 
 	/* This references through an offset into it_optional[] rather
@@ -706,6 +770,22 @@ ieee80211_add_rx_radiotap_header(struct
 		*pos++ = status->chain_signal[chain];
 		*pos++ = chain;
 	}
+
+	if (status->flag & RX_FLAG_USIG_HEADER) {
+		while ((pos - (u8 *)rthdr) & 1)
+			pos++;
+		memcpy(pos, &usig, sizeof(usig));
+		pos += sizeof(usig);
+	}
+
+	if (status->flag & RX_FLAG_EHT_HEADER) {
+		while ((pos - (u8 *)rthdr) & 1)
+			pos++;
+		memcpy(pos, &eht, sizeof(eht));
+		pos += sizeof(eht);
+		memcpy(pos, user_info, (status->eht_num_user * sizeof(u32)));
+		pos += status->eht_num_user * sizeof(u32);
+	}
 }
 
 static struct sk_buff *
@@ -800,6 +880,14 @@ ieee80211_rx_monitor(struct ieee80211_lo
 	if (status->flag & RX_FLAG_RADIOTAP_TLV_AT_END)
 		rtap_space += skb_mac_header(origskb) - &origskb->data[rtap_space];
 
+	if (status->flag & RX_FLAG_USIG_HEADER)
+		rtap_space += sizeof(struct ieee80211_radiotap_usig);
+
+	if (status->flag & RX_FLAG_EHT_HEADER) {
+		rtap_space += sizeof(struct ieee80211_radiotap_eht);
+		rtap_space += (status->eht_num_user * sizeof(u32));
+	}
+
 	min_head_len = rtap_space;
 
 	/*
