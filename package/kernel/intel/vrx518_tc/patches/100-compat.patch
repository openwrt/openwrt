--- a/dcdp/atm_tc.c
+++ b/dcdp/atm_tc.c
@@ -44,9 +44,9 @@
 #include <linux/atmioc.h>
 #include <linux/skbuff.h>
 #include "inc/dsl_tc.h"
-#include <net/datapath_proc_api.h>
+// #include <net/datapath_proc_api.h>
 #include <linux/atm.h>
-#include <net/datapath_api.h>
+// #include <net/datapath_api.h>
 #include <net/dc_ep.h>
 #include<linux/sched.h>
 #include<linux/kthread.h>
@@ -1313,7 +1313,7 @@ static int ppe_send(struct atm_vcc *vcc,
 	/* assume LLC header + Ethernet ID: 6+2 */
     if ((priv->conn[conn].mpoa_type == MPOA_TYPE_EOA_WO_FCS) ||
 		(priv->conn[conn].mpoa_type == MPOA_TYPE_EOA_W_FCS)) {
-        if (__skb_put_padto(skb, ETH_ZLEN + 8))
+        if (__skb_put_padto(skb, ETH_ZLEN + 8, false))
 		    goto CHECK_SHOWTIME_FAIL;
 	}
 
@@ -1418,7 +1418,7 @@ int ppe_send_oam(struct atm_vcc *vcc, vo
 	struct atm_priv *priv = g_atm_tc;
 	struct sk_buff *skb;
 	unsigned int conn;
-	dp_subif_t dp_id;
+// 	dp_subif_t dp_id;
 #ifdef OAM_FIX_GRX750
 	unsigned char *dest_cell;
 #endif
@@ -1465,8 +1465,8 @@ int ppe_send_oam(struct atm_vcc *vcc, vo
 		priv->tc_priv->param.oam_prio = 0;
 	qid = priv->conn[conn].prio_queue_map[priv->tc_priv->param.oam_prio];
 	vid = priv->conn[conn].subif_id;
-	dp_id.subif = (vid & (~0x7f)) |
-		ATM_DESC_SUBIF_ID(qid, mpoa_pt, mpoa_type);
+// 	dp_id.subif = (vid & (~0x7f)) |
+// 		ATM_DESC_SUBIF_ID(qid, mpoa_pt, mpoa_type);
 #ifdef OAM_FIX_GRX750
 	dest_cell = kmalloc(CELL_SIZE, GFP_KERNEL);
 	if (dest_cell == NULL) {
@@ -1494,18 +1494,18 @@ int ppe_send_oam(struct atm_vcc *vcc, vo
 #else
 	memcpy(skb->data, cell, CELL_SIZE);
 #endif
-	/* SET SUBIFID */
-	skb->DW0 = (skb->DW0 & ~0x7FFF) | dp_id.subif;
-	skb->dev = priv->conn[conn].dev;
-	tc_dbg(priv->tc_priv, MSG_TX, "conn: %d, dev name: %s, qid: 0x%x len:%d\n",
-		conn, skb->dev->name, dp_id.subif, skb->len);
-	#ifdef OAM_FIX_GRX750
-	if (priv->tc_priv->tc_ops.send(NULL,
-			skb, dp_id.subif, ATM_OAM_PKT) == 0) {
-	#else
+// 	/* SET SUBIFID */
+// 	skb->DW0 = (skb->DW0 & ~0x7FFF) | dp_id.subif;
+// 	skb->dev = priv->conn[conn].dev;
+// 	tc_dbg(priv->tc_priv, MSG_TX, "conn: %d, dev name: %s, qid: 0x%x len:%d\n",
+// 		conn, skb->dev->name, dp_id.subif, skb->len);
+// 	#ifdef OAM_FIX_GRX750
+// 	if (priv->tc_priv->tc_ops.send(NULL,
+// 			skb, dp_id.subif, ATM_OAM_PKT) == 0) {
+// 	#else
 	if (priv->tc_priv->tc_ops.send(NULL,
 			skb, qid, ATM_OAM_PKT) == 0) {
-	#endif
+// 	#endif
 		priv->stats.oam_tx_pkts++;
 		priv->stats.oam_tx_bytes += skb->len;
 		priv->conn[conn].stats.oam_tx_pkts++;
@@ -2547,30 +2547,29 @@ static void ppe_atm_fw_hw_init(struct at
 static int atm_dev_init(struct atm_priv *atm_priv, int ep_id)
 {
 	int i, err;
-	struct atm_dev *dev;
-	dev = atm_dev_register(g_atm_dev_name,
-		atm_priv->tc_priv->ep_dev[ep_id].dev,
-		&g_ppe_atm_ops, -1, NULL);
-	if (!dev) {
-		err = -EIO;
-		goto ATM_DEV_REGISTER_FAIL;
-	}
-	dev->ci_range.vpi_bits = 8;
-	dev->ci_range.vci_bits = 16;
-	/* assume 3200 cell rate
-	 * before get real information
-	 */
-	dev->link_rate =
-		DEFAULT_CELL_RATE;
-	dev->dev_data = atm_priv;
-	dev->phy_data =
-		(void *)(unsigned long)0;
 
 	for (i = 0; i < ATM_PORT_NUMBER; i++) {
 		if (atm_priv->port[i].dev)
 			continue;
 		atm_priv->port[i].tx_max_cell_rate = DEFAULT_CELL_RATE;
-		atm_priv->port[i].dev = dev;
+		atm_priv->port[i].dev = atm_dev_register(g_atm_dev_name,
+				atm_priv->tc_priv->ep_dev[ep_id].dev,
+				&g_ppe_atm_ops, -1, NULL);
+		if (!atm_priv->port[i].dev) {
+			err = -EIO;
+			goto ATM_DEV_REGISTER_FAIL;
+		} else {
+			atm_priv->port[i].dev->ci_range.vpi_bits = 8;
+			atm_priv->port[i].dev->ci_range.vci_bits = 16;
+			/* assume 3200 cell rate
+			 * before get real information
+			 */
+			atm_priv->port[i].dev->link_rate =
+				DEFAULT_CELL_RATE;
+			atm_priv->port[i].dev->dev_data = atm_priv;
+			atm_priv->port[i].dev->phy_data =
+				(void *)(unsigned long)i;
+		}
 	}
 	//TODO : check for SoC PMAC, current fix
 #ifdef CONFIG_SOC_TYPE_XWAY
@@ -2985,7 +2984,8 @@ static unsigned int atm_get_pvc_id(struc
 		return -EINVAL;
 	}
 
-	return (skb->DW0 >> 3) & 0xF;
+// 	return (skb->DW0 >> 3) & 0xF;
+	return 1;
 }
 
 static int atm_get_qid_by_vcc(struct net_device *dev, struct sk_buff *skb,
--- a/dcdp/inc/tc_api.h
+++ b/dcdp/inc/tc_api.h
@@ -196,19 +196,6 @@ static inline void aca_ring_addr_init(st
 	ring->aca_cnt_phyaddr = ep_dev->phy_membase + addr;
 }
 
-static inline int __skb_put_padto(struct sk_buff *skb, unsigned int len)
-{
-	unsigned int size = skb->len;
-
-	if (unlikely(size < len)) {
-		len -= size;
-		if (skb_pad(skb, len))
-			return -ENOMEM;
-		__skb_put(skb, len);
-	}
-	return 0;
-}
-
 extern int showtime_stat(struct tc_priv *);
 extern void dump_skb_info(struct tc_priv *, struct sk_buff *, u32);
 extern void *tc_buf_alloc(void *, size_t, u32 *,
--- a/dcdp/ptm_tc.c
+++ b/dcdp/ptm_tc.c
@@ -39,7 +39,7 @@
 #include <linux/seq_file.h>
 #include <linux/printk.h>
 #include <linux/etherdevice.h>
-#include <net/datapath_proc_api.h>
+// #include <net/datapath_proc_api.h>
 
 #include "inc/tc_main.h"
 #include "inc/reg_addr.h"
@@ -182,8 +182,8 @@ static int ptm_get_qid(struct net_device
 	return qid;
 }
 
-static struct rtnl_link_stats64 *ptm_get_stats(struct net_device *dev,
-					struct rtnl_link_stats64 *storage)
+static void ptm_get_stats(struct net_device *dev,
+			  struct rtnl_link_stats64 *storage)
 {
 	struct ptm_priv *ptm_tc = netdev_priv(dev);
 
@@ -191,8 +191,6 @@ static struct rtnl_link_stats64 *ptm_get
 		memcpy(storage, &ptm_tc->stats64, sizeof(ptm_tc->stats64));
 	else
 		storage->tx_errors += ptm_tc->stats64.tx_errors;
-
-	return storage;
 }
 
 static int ptm_set_mac_address(struct net_device *dev, void *p)
@@ -503,7 +501,7 @@ static int ptm_xmit(struct sk_buff *skb,
 	if (!showtime_stat(ptm_tc->tc_priv))
 		goto PTM_XMIT_DROP;
 
-	if (__skb_put_padto(skb, ETH_ZLEN))
+	if (__skb_put_padto(skb, ETH_ZLEN, false))
 		goto PTM_XMIT_DROP;
 
 	dump_skb_info(ptm_tc->tc_priv, skb, (MSG_TX | MSG_TXDATA));
@@ -2103,7 +2101,6 @@ static int ptm_showtime_exit(const unsig
 	struct ptm_ep_priv *priv = tc_ep_priv(idx);
 	u32 stop = ACA_TXIN_EN;
 	struct dc_ep_dev *ep;
-	int i = 0;
 
 	tc_info(priv->tc_priv, MSG_EVENT, "Line[%d]: show time exit!\n", idx);
 	ep = priv->ep;
--- a/dcdp/tc_api.c
+++ b/dcdp/tc_api.c
@@ -52,18 +52,24 @@ static const char ppe_fw_name[] = "ppe_f
 #define VRX518_PPE_FW_ID		0xB
 #define MD5_LEN				16
 
+enum tc_multicast_groups {
+	TC_MCGRP,
+};
+
+/* TC message multicast group */
+static const struct genl_multicast_group tc_ml_grps[] = {
+	[TC_MCGRP] = { .name = TC_MCAST_GRP_NAME, },
+};
+
 /* TC message genelink family */
 static struct genl_family tc_gnl_family = {
-	.id = GENL_ID_GENERATE,	/* To generate an id for the family*/
+// 	.id = GENL_ID_GENERATE,	/* To generate an id for the family*/
 	.hdrsize = 0,
 	.name = TC_FAMILY_NAME,	/*family name, used by userspace application*/
 	.version = 1,		/*version number  */
 	.maxattr = TC_A_MAX - 1,
-};
-
-/* TC message multicast group */
-static struct genl_multicast_group tc_ml_grp = {
-	.name = TC_MCAST_GRP_NAME,
+	.mcgrps = tc_ml_grps,
+	.n_mcgrps = ARRAY_SIZE(tc_ml_grps),
 };
 
 /**
@@ -568,7 +574,8 @@ int tc_ntlk_msg_send(struct tc_priv *pri
 	nla_put_u32(skb, TC_A_LINENO, ln_no);
 
 	genlmsg_end(skb, msg_head);
-	ret = genlmsg_multicast(skb, pid, tc_ml_grp.id, GFP_KERNEL);
+	ret = genlmsg_multicast(&tc_gnl_family, skb, pid, TC_MCGRP,
+				GFP_KERNEL);
 	if (ret) {
 		tc_err(priv, MSG_EVENT, "Sent TC multicast message Fail!\n");
 		goto err1;
@@ -590,21 +597,11 @@ int tc_gentlk_init(struct tc_priv *priv)
 		return ret;
 	}
 
-	ret = genl_register_mc_group(&tc_gnl_family, &tc_ml_grp);
-	if (ret) {
-		tc_err(priv, MSG_EVENT, "register mc group fail: %i, grp name: %s\n",
-			ret, tc_ml_grp.name);
-		genl_unregister_family(&tc_gnl_family);
-		return ret;
-	}
-
 	return 0;
 }
 
 void tc_gentlk_exit(void)
 {
-	/* unregister mc groups */
-	genl_unregister_mc_group(&tc_gnl_family, &tc_ml_grp);
 	/*unregister the family*/
 	genl_unregister_family(&tc_gnl_family);
 }
@@ -666,7 +663,7 @@ void dump_skb_info(struct tc_priv *tcpri
 		(u32)skb->end, skb->len);
 	tc_dbg(tcpriv, type,
 		"skb: clone: %d, users: %d\n",
-		skb->cloned, atomic_read(&skb->users));
+		skb->cloned, refcount_read(&skb->users));
 	tc_dbg(tcpriv, type,
 		"skb: nfrag: %d\n", skb_shinfo(skb)->nr_frags);
 
@@ -704,8 +701,8 @@ void *tc_buf_alloc(void *priv, size_t si
 	dma_unmap_single(pdev, dma_addr, size, DMA_FROM_DEVICE);
 	*phy_addr = dma_addr;
 
-	*phy_addr = (dma_addr_t)buf;
 #endif
+	*phy_addr = (dma_addr_t)buf;
 
 	return buf;
 }
--- a/dcdp/tc_proc.c
+++ b/dcdp/tc_proc.c
@@ -22,7 +22,9 @@
 *******************************************************************************/
 #include <linux/fs.h>
 #include <linux/seq_file.h>
-#include <net/datapath_api.h>
+// #include <net/datapath_api.h>
+#include <linux/etherdevice.h>
+#include <linux/atmdev.h>
 #include <net/genetlink.h>
 #include <linux/time.h>
 #include "inc/tc_main.h"
@@ -1123,20 +1125,18 @@ static int proc_read_soc(struct seq_file
 
 	tcpriv = (struct tc_priv *)seq->private;
 
-#if 0
 	seq_printf(seq, "TXIN Base: 0x%08x, TXIN num: %d\n",
-			tcpriv->cfg.txin_dbase,
-			tcpriv->cfg.txin_dnum);
+			tcpriv->cfg.txin.soc_phydbase,
+			tcpriv->cfg.txin.soc_dnum);
 	seq_printf(seq, "TXOUT Base: 0x%08x, TXOUT num: %d\n",
-			tcpriv->cfg.txout_dbase,
-			tcpriv->cfg.txout_dnum);
+			tcpriv->cfg.txout.soc_phydbase,
+			tcpriv->cfg.txout.soc_dnum);
 	seq_printf(seq, "RXIN Base: 0x%08x, RXIN num: %d\n",
-			tcpriv->cfg.rxin_dbase,
-			tcpriv->cfg.rxin_dnum);
+			tcpriv->cfg.rxin.soc_phydbase,
+			tcpriv->cfg.rxin.soc_dnum);
 	seq_printf(seq, "RXOUT Base: 0x%08x, RXOUT num: %d\n",
-			tcpriv->cfg.rxout_dbase,
-			tcpriv->cfg.rxout_dnum);
-#endif
+			tcpriv->cfg.rxout.soc_phydbase,
+			tcpriv->cfg.rxout.soc_dnum);
 
 	return 0;
 }
--- a/dcdp/platform/sw_plat.c
+++ b/dcdp/platform/sw_plat.c
@@ -36,10 +36,11 @@
 #include <linux/printk.h>
 #include <linux/etherdevice.h>
 #include <linux/workqueue.h>
-#include "inc/dsl_tc.h"
+#include "../inc/dsl_tc.h"
 
 #include "../inc/tc_main.h"
 #include "../inc/reg_addr.h"
+#include "../inc/tc_common.h"
 
 
 #define PMAC_SIZE		8
@@ -419,7 +420,7 @@ static int ring_mmap(void *mem, int size
 	}
 	dma_unmap_single(pdev, phy_addr, size, dir);
 
-	pr_info("vaddr: 0x%x, phyaddr: 0x%lx\n", (u32)mem, phy_addr);
+	pr_info("vaddr: 0x%x, phyaddr: 0x%x\n", (u32)mem, phy_addr);
 	addr1 = (u32)phy_addr;
 
 	if (addr)
@@ -581,13 +582,13 @@ static void rxin_action(struct tc_priv *
 
 		desc->data_ptr = phyaddr;
 
-		
+
 		if (ring_mmap(desc, sizeof(*desc), DMA_TO_DEVICE, NULL) < 0) {
 			tc_err(priv, MSG_RX, "RXIN descriptor mmap failed: 0x%x\n",
 				(unsigned int)desc);
 			goto err2;
 		}
-		
+
 		ring_idx_inc(rxin, idx);
 	}
 
@@ -669,7 +670,7 @@ static void plat_rxout_tasklet(unsigned
 	struct aca_ring *rxin = &priv->soc_rings.rxin;
 	struct dc_ep_dev *ep_dev = &tcpriv->ep_dev[rxout->ep_dev_idx];
 	int cnt;
-	
+
 
 	cnt = rxout_action(tcpriv, rxout);
 	if (cnt)
@@ -694,7 +695,8 @@ static int plat_send(struct net_device *
 }
 
 /* return virtual address */
-static void *plat_mem_alloc(size_t size, enum tc_dir dir)
+static void *plat_mem_alloc(size_t size,
+		enum tc_dir dir, u32 *phyaddr)
 {
 	return kmalloc(size, GFP_KERNEL);
 }
@@ -703,7 +705,7 @@ static void plat_mem_free(u32 phy_addr,
 {
 	void *mem;
 
-	mem = (void * __force)__va(phy_addr);
+	mem = (void * __force)phy_addr;
 	kfree(mem);
 }
 
@@ -787,24 +789,30 @@ static void irq_init(struct tc_priv *pri
 		sprintf(name, "%s%d", dev_name, i);
 
 		ret = devm_request_irq(priv->ep_dev[i].dev, priv->ep_dev[i].aca_rx_irq,
-				aca_rx_irq_handler, 0, name, &priv->ep_dev[i]);
+				aca_rx_irq_handler, 0, "aca-rxo", &priv->ep_dev[i]);
 
 		if (ret) {
 			tc_err(priv, MSG_INIT,
 				"ACA RX IRQ request Fail!: irq: %d, ep_id: %d\n",
 				priv->ep_dev[i].aca_rx_irq, i);
 			//return;
-		} 
+		}
+
+// 		/* Enable RX interrupt */
+// 		priv->ep_dev[i].hw_ops->icu_en(&priv->ep_dev[i], ACA_HOSTIF_RX);
 
 		ret = devm_request_irq(priv->ep_dev[i].dev, priv->ep_dev[i].aca_tx_irq,
-				aca_tx_irq_handler, 0, name, &priv->ep_dev[i]);
+				aca_tx_irq_handler, 0, "aca-txo", &priv->ep_dev[i]);
 
 		if (ret) {
 			tc_err(priv, MSG_INIT,
 				"ACA TX IRQ request Fail!: irq: %d, ep_id: %d\n",
 				priv->ep_dev[i].aca_tx_irq, i);
 			//return;
-		} 
+		}
+
+// 		/* Enable TX interrupt */
+// 		priv->ep_dev[i].hw_ops->icu_en(&priv->ep_dev[i], ACA_HOSTIF_TX);
 	}
 
 	return;
@@ -850,6 +858,24 @@ static int plat_dp_init(struct plat_priv
  */
 static void plat_dp_exit(struct plat_priv *priv)
 {
+	struct tc_priv *tcpriv = priv->tc_priv;
+	int i;
+
+	for (i = 0; i < EP_MAX_NUM && i < tcpriv->ep_num; i++) {
+
+		/* Disable RX interrupt */
+		tcpriv->ep_dev[i].hw_ops->icu_mask(&tcpriv->ep_dev[i], ACA_HOSTIF_RX);
+
+		/* Unregister RX irq handler */
+		devm_free_irq(tcpriv->ep_dev[i].dev, tcpriv->ep_dev[i].aca_rx_irq, &tcpriv->ep_dev[i]);
+
+		/* Disable TX interrupt */
+		tcpriv->ep_dev[i].hw_ops->icu_mask(&tcpriv->ep_dev[i], ACA_HOSTIF_TX);
+
+		/* Unregister TX irq handler */
+		devm_free_irq(tcpriv->ep_dev[i].dev, tcpriv->ep_dev[i].aca_tx_irq, &tcpriv->ep_dev[i]);
+	}
+
 	return;
 }
 
@@ -858,44 +884,44 @@ static int plat_soc_cfg_get(struct soc_c
 	struct plat_priv *priv = g_plat_priv;
 
 	/* TXIN */
-	cfg->txin_dbase = priv->soc_rings.txin.dbase_phymem;
-	cfg->txin_dnum = priv->soc_rings.txin.dnum;
-	cfg->txin_desc_dwsz = DW_SZ(struct dma_desc);
-	cfg->txin_cnt_phyaddr = priv->soc_rings.txin.cnt_phyaddr;
+	cfg->txin.soc_phydbase = priv->soc_rings.txin.dbase_phymem;
+	cfg->txin.soc_dnum = priv->soc_rings.txin.dnum;
+	cfg->txin.soc_desc_dwsz = DW_SZ(struct dma_desc);
+	cfg->txin.soc_cnt_phyaddr = priv->soc_rings.txin.cnt_phyaddr;
 	/* TXOUT */
-	cfg->txout_dbase = priv->soc_rings.txout.dbase_phymem;
-	cfg->txout_dnum = priv->soc_rings.txout.dnum;
-	cfg->txout_desc_dwsz = DW_SZ(struct dma_desc);
-	cfg->txout_cnt_phyaddr = priv->soc_rings.txout.cnt_phyaddr;
+	cfg->txout.soc_phydbase = priv->soc_rings.txout.dbase_phymem;
+	cfg->txout.soc_dnum = priv->soc_rings.txout.dnum;
+	cfg->txout.soc_desc_dwsz = DW_SZ(struct dma_desc);
+	cfg->txout.soc_cnt_phyaddr = priv->soc_rings.txout.cnt_phyaddr;
 	/* RXOUT */
-	cfg->rxout_dbase = priv->soc_rings.rxout.dbase_phymem;
-	cfg->rxout_dnum = priv->soc_rings.rxout.dnum;
-	cfg->rxout_desc_dwsz = DW_SZ(struct dma_desc);
-	cfg->rxout_cnt_phyaddr = priv->soc_rings.rxout.cnt_phyaddr;
+	cfg->rxout.soc_phydbase = priv->soc_rings.rxout.dbase_phymem;
+	cfg->rxout.soc_dnum = priv->soc_rings.rxout.dnum;
+	cfg->rxout.soc_desc_dwsz = DW_SZ(struct dma_desc);
+	cfg->rxout.soc_cnt_phyaddr = priv->soc_rings.rxout.cnt_phyaddr;
 	/* RXIN */
-	cfg->rxin_dbase = priv->soc_rings.rxin.dbase_phymem;
-	cfg->rxin_dnum = priv->soc_rings.rxin.dnum;
-	cfg->rxin_desc_dwsz = DW_SZ(struct dma_desc);
-	cfg->rxin_cnt_phyaddr = priv->soc_rings.rxin.cnt_phyaddr;
+	cfg->rxin.soc_phydbase = priv->soc_rings.rxin.dbase_phymem;
+	cfg->rxin.soc_dnum = priv->soc_rings.rxin.dnum;
+	cfg->rxin.soc_desc_dwsz = DW_SZ(struct dma_desc);
+	cfg->rxin.soc_cnt_phyaddr = priv->soc_rings.rxin.cnt_phyaddr;
 
 	tc_info(priv->tc_priv, MSG_INIT,
 		"id: %d, txin(0x%x: %d, 0x%x), txout(0x%x: %d, 0x%x), rxin(0x%x: %d, 0x%x), rxout(0x%x: %d, 0x%x)\n",
-		id, cfg->txin_dbase, cfg->txin_dnum, cfg->txin_cnt_phyaddr,
-		cfg->txout_dbase, cfg->txout_dnum, cfg->txout_cnt_phyaddr,
-		cfg->rxin_dbase, cfg->rxout_dnum, cfg->rxin_cnt_phyaddr,
-		cfg->rxout_dbase, cfg->rxout_dnum, cfg->rxout_cnt_phyaddr);
+		id, cfg->txin.soc_phydbase, cfg->txin.soc_dnum, cfg->txin.soc_cnt_phyaddr,
+		cfg->txout.soc_phydbase, cfg->txout.soc_dnum, cfg->txout.soc_cnt_phyaddr,
+		cfg->rxin.soc_phydbase, cfg->rxout.soc_dnum, cfg->rxin.soc_cnt_phyaddr,
+		cfg->rxout.soc_phydbase, cfg->rxout.soc_dnum, cfg->rxout.soc_cnt_phyaddr);
 
 	return 0;
 }
 
-static int plat_open(struct net_device *pdev, char *dev_name,
-		int *subif, int flag)
+static int plat_open(struct net_device *pdev, const char *dev_name,
+		int id, int flag)
 {
 	return 0;
 }
 
-static void plat_close(struct net_device *pdev, char *dev_name,
-		int subif, int flag)
+static void plat_close(struct net_device *pdev, const char *dev_name,
+		int flag)
 {
 	return;
 }
