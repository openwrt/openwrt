From 67fb3e1054d5e5adf64ad84402f1aee3b5366b1a Mon Sep 17 00:00:00 2001
From: Eneas U de Queiroz <cote2004-github@yahoo.com>
Date: Wed, 21 Nov 2018 16:23:10 -0200
Subject: [PATCH 1/2] e_afalg: rewrite of AF_ALG engine

 - Use sync io
 - Mirror functionality of /dev/crypto engine

Signed-off-by: Eneas U de Queiroz <cote2004-github@yahoo.com>

diff --git a/engines/e_afalg.c b/engines/e_afalg.c
index 7f62d77e5b..79c8b2406c 100644
--- a/engines/e_afalg.c
+++ b/engines/e_afalg.c
@@ -7,858 +7,1533 @@
  * https://www.openssl.org/source/license.html
  */
 
+#ifdef ALG_ZERO_COPY
 /* Required for vmsplice */
-#ifndef _GNU_SOURCE
-# define _GNU_SOURCE
+# ifndef _GNU_SOURCE
+#  define _GNU_SOURCE
+# endif
+#include <sys/uio.h>
 #endif
-#include <stdio.h>
+
+#include "../e_os.h"
 #include <string.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
 #include <unistd.h>
-
-#include <openssl/engine.h>
-#include <openssl/async.h>
+#include <assert.h>
+#include <asm/types.h>
+#include <linux/cryptouser.h>
+#include <linux/if_alg.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
+#include <openssl/conf.h>
+#include <openssl/evp.h>
 #include <openssl/err.h>
-#include "internal/nelem.h"
+#include <openssl/engine.h>
+#include <openssl/objects.h>
 
-#include <sys/socket.h>
-#include <linux/version.h>
-#define K_MAJ   4
-#define K_MIN1  1
-#define K_MIN2  0
-#if LINUX_VERSION_CODE < KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2) || \
-    !defined(AF_ALG)
-# ifndef PEDANTIC
-#  warning "AFALG ENGINE requires Kernel Headers >= 4.1.0"
-#  warning "Skipping Compilation of AFALG engine"
-# endif
-void engine_load_afalg_int(void);
-void engine_load_afalg_int(void)
-{
-}
-#else
+#define engine_afalg_id "afalg"
 
-# include <linux/if_alg.h>
-# include <fcntl.h>
-# include <sys/utsname.h>
+#define AFALG_REQUIRE_ACCELERATED 0 /* require confirmation of acceleration */
+#define AFALG_USE_SOFTWARE        1 /* allow software drivers */
+#define AFALG_REJECT_SOFTWARE     2 /* only disallow confirmed software drivers */
 
-# include <linux/aio_abi.h>
-# include <sys/syscall.h>
-# include <errno.h>
+#define AFALG_DEFAULT_USE_SOFDTRIVERS AFALG_REJECT_SOFTWARE
+static int use_softdrivers = AFALG_DEFAULT_USE_SOFDTRIVERS;
 
-# include "e_afalg.h"
-# include "e_afalg_err.c"
+/*
+ * cipher/digest status & acceleration definitions
+ * Make sure the defaults are set to 0
+ */
 
-# ifndef SOL_ALG
-#  define SOL_ALG 279
-# endif
+struct driver_info_st {
+    enum afalg_status_t {
+        AFALG_STATUS_FAILURE       = -3, /* unusable for other reason */
+        AFALG_STATUS_NO_COPY       = -2, /* hash state copy not supported */
+        AFALG_STATUS_NO_OPEN       = -1, /* bind call failed */
+        AFALG_STATUS_UNKNOWN       =  0, /* not tested yet */
+        AFALG_STATUS_USABLE        =  1  /* algo can be used */
+    } status;
+
+    enum afalg_accelerated_t {
+        AFALG_NOT_ACCELERATED      = -1, /* software implemented */
+        AFALG_ACCELERATION_UNKNOWN =  0, /* acceleration support unkown */
+        AFALG_ACCELERATED          =  1  /* hardware accelerated */
+    } accelerated;
+
+    char *driver_name;
+};
 
-# ifdef ALG_ZERO_COPY
-#  ifndef SPLICE_F_GIFT
-#   define SPLICE_F_GIFT    (0x08)
-#  endif
-# endif
+#ifdef OPENSSL_NO_DYNAMIC_ENGINE
+void engine_load_afalg_int(void);
+#endif
 
-# define ALG_AES_IV_LEN 16
-# define ALG_IV_LEN(len) (sizeof(struct af_alg_iv) + (len))
-# define ALG_OP_TYPE     unsigned int
-# define ALG_OP_LEN      (sizeof(ALG_OP_TYPE))
+static int get_afalg_socket(const char *salg_name, const char *salg_type,
+                            const __u32 feat, const __u32 mask)
+{
+    int fd = -1;
+    struct sockaddr_alg sa;
 
-# ifdef OPENSSL_NO_DYNAMIC_ENGINE
-void engine_load_afalg_int(void);
-# endif
+    memset(&sa, 0, sizeof(sa));
+    sa.salg_family = AF_ALG;
+    OPENSSL_strlcpy((char *)sa.salg_type, salg_type, sizeof(sa.salg_type));
+    OPENSSL_strlcpy((char *)sa.salg_name, salg_name, sizeof(sa.salg_name));
+    sa.salg_feat = feat;
+    sa.salg_mask = mask;
+    if ((fd = socket(AF_ALG, SOCK_SEQPACKET, 0)) < 0) {
+        SYSerr(SYS_F_SOCKET, errno);
+        return -1;
+    }
 
-/* Local Linkage Functions */
-static int afalg_init_aio(afalg_aio *aio);
-static int afalg_fin_cipher_aio(afalg_aio *ptr, int sfd,
-                                unsigned char *buf, size_t len);
-static int afalg_create_sk(afalg_ctx *actx, const char *ciphertype,
-                                const char *ciphername);
-static int afalg_destroy(ENGINE *e);
-static int afalg_init(ENGINE *e);
-static int afalg_finish(ENGINE *e);
-static const EVP_CIPHER *afalg_aes_cbc(int nid);
-static cbc_handles *get_cipher_handle(int nid);
-static int afalg_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
-                         const int **nids, int nid);
-static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
-                             const unsigned char *iv, int enc);
-static int afalg_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                           const unsigned char *in, size_t inl);
-static int afalg_cipher_cleanup(EVP_CIPHER_CTX *ctx);
-static int afalg_chk_platform(void);
-
-/* Engine Id and Name */
-static const char *engine_afalg_id = "afalg";
-static const char *engine_afalg_name = "AFALG engine support";
-
-static int afalg_cipher_nids[] = {
-    NID_aes_128_cbc,
-    NID_aes_192_cbc,
-    NID_aes_256_cbc,
-};
+    if (bind(fd, (struct sockaddr *)&sa, sizeof(sa)) == 0)
+        return fd;
 
-static cbc_handles cbc_handle[] = {{AES_KEY_SIZE_128, NULL},
-                                    {AES_KEY_SIZE_192, NULL},
-                                    {AES_KEY_SIZE_256, NULL}};
+    close(fd);
+    return -1;
+}
 
-static ossl_inline int io_setup(unsigned n, aio_context_t *ctx)
+static int afalg_closefd(int fd)
 {
-    return syscall(__NR_io_setup, n, ctx);
+    int ret;
+
+    if (fd < 0 || (ret = close(fd)) == 0)
+        return 0;
+    SYSerr(SYS_F_CLOSE, errno);
+    return ret;
 }
 
-static ossl_inline int eventfd(int n)
+/* linux/crypto.h is not public, so we must define the type and masks here,
+ * and hope they are still valid. */
+#ifndef CRYPTO_ALG_TYPE_MASK
+# define CRYPTO_ALG_TYPE_MASK            0x0000000f
+# define CRYPTO_ALG_TYPE_BLKCIPHER       0x00000004
+# define CRYPTO_ALG_TYPE_SKCIPHER        0x00000005
+# define CRYPTO_ALG_TYPE_SHASH           0x0000000e
+# define CRYPTO_ALG_TYPE_AHASH           0x0000000f
+# define CRYPTO_ALG_KERN_DRIVER_ONLY     0x00001000
+# define CRYPTO_ALG_INTERNAL             0x00002000
+#endif
+
+struct afalg_alg_info {
+    char alg_name[CRYPTO_MAX_NAME];
+    char driver_name[CRYPTO_MAX_NAME];
+    __u32 priority;
+    __u32 flags;
+};
+
+static struct afalg_alg_info *afalg_alg_list = NULL;
+static int afalg_alg_list_count = -1; /* no info available */
+
+static int prepare_afalg_alg_list(void)
 {
-    return syscall(__NR_eventfd2, n, 0);
+    int ret = -EFAULT;
+
+    /* NETLINK_CRYPTO specific */
+    void *buf = NULL;
+    struct nlmsghdr *res_n;
+    size_t buf_size;
+    struct {
+        struct nlmsghdr n;
+        struct crypto_user_alg cru;
+    } req;
+    struct crypto_user_alg *cru_res = NULL;
+    struct afalg_alg_info *list;
+
+    /* AF_NETLINK specific */
+    struct sockaddr_nl nl;
+    struct iovec iov;
+    struct msghdr msg;
+    struct rtattr *rta;
+    int nlfd, msg_len, rta_len, list_count;
+    __u32 alg_type;
+
+    memset(&req, 0, sizeof(req));
+    memset(&msg, 0, sizeof(msg));
+    list = afalg_alg_list = NULL;
+    afalg_alg_list_count = -1;
+
+    req.n.nlmsg_len = NLMSG_LENGTH(sizeof(req.cru));
+    req.n.nlmsg_flags = NLM_F_REQUEST | NLM_F_MATCH;
+    req.n.nlmsg_type = CRYPTO_MSG_GETALG;
+
+    /* open netlink socket */
+    nlfd =  socket(AF_NETLINK, SOCK_RAW, NETLINK_CRYPTO);
+    if (nlfd < 0) {
+        if (errno != EPROTONOSUPPORT) /* crypto_user module not available */
+            perror("Netlink error: cannot open netlink socket");
+        return -errno;
+    }
+    memset(&nl, 0, sizeof(nl));
+    nl.nl_family = AF_NETLINK;
+    if (bind(nlfd, (struct sockaddr*)&nl, sizeof(nl)) < 0) {
+        perror("Netlink error: cannot bind netlink socket");
+        ret = -errno;
+        goto out;
+    }
+
+    /* sending data */
+    memset(&nl, 0, sizeof(nl));
+    nl.nl_family = AF_NETLINK;
+    iov.iov_base = (void*) &req.n;
+    iov.iov_len = req.n.nlmsg_len;
+    msg.msg_name = &nl;
+    msg.msg_namelen = sizeof(nl);
+    msg.msg_iov = &iov;
+    msg.msg_iovlen = 1;
+    if (sendmsg(nlfd, &msg, 0) < 0) {
+        perror("Netlink error: sendmsg failed");
+        ret = -errno;
+        goto out;
+    }
+
+    /* get the msg size */
+    iov.iov_base = NULL;
+    iov.iov_len = 0;
+    buf_size = recvmsg(nlfd, &msg, MSG_PEEK | MSG_TRUNC);
+
+    buf = OPENSSL_zalloc(buf_size);
+    iov.iov_base = buf;
+    iov.iov_len = buf_size;
+
+    while (1) {
+        if ((msg_len = recvmsg(nlfd, &msg, 0)) <= 0) {
+            if (errno == EINTR || errno == EAGAIN)
+                continue;
+            else if (msg_len == 0)
+                perror("Nelink error: no data");
+            else
+                perror("Nelink error: netlink receive error");
+            ret = -errno;
+            goto out;
+        }
+        if ((u_int32_t)msg_len > buf_size) {
+            perror("Netlink error: received too much data");
+            ret = -errno;
+            goto out;
+        }
+        break;
+    }
+
+    ret = -EFAULT;
+    list_count = 0;
+    for (res_n = (struct nlmsghdr *)buf; (ret = NLMSG_OK(res_n, msg_len));
+         res_n = NLMSG_NEXT(res_n, msg_len)) {
+        if (res_n->nlmsg_type == NLMSG_ERROR) {
+            ret = 0;
+            goto out;
+        }
+        cru_res = NLMSG_DATA(res_n);
+        if (res_n->nlmsg_type != CRYPTO_MSG_GETALG
+            || !cru_res || res_n->nlmsg_len < NLMSG_SPACE(sizeof(*cru_res)))
+            continue;
+        alg_type = cru_res->cru_flags & CRYPTO_ALG_TYPE_MASK;
+        if ((alg_type != CRYPTO_ALG_TYPE_SKCIPHER && alg_type != CRYPTO_ALG_TYPE_BLKCIPHER
+             && alg_type != CRYPTO_ALG_TYPE_SHASH && alg_type != CRYPTO_ALG_TYPE_AHASH)
+            || cru_res->cru_flags & CRYPTO_ALG_INTERNAL)
+            continue;
+        list = OPENSSL_realloc(afalg_alg_list, (list_count + 1) * sizeof(struct afalg_alg_info));
+        if (list == NULL) {
+            OPENSSL_free(afalg_alg_list);
+            afalg_alg_list = NULL;
+            ret = -ENOMEM;
+            goto out;
+        }
+        memset(&list[list_count], 0, sizeof(struct afalg_alg_info));
+        afalg_alg_list = list;
+
+        rta_len=msg_len;
+        list[list_count].priority = 0;
+        for (rta = (struct rtattr *)(((char *) cru_res)
+                                     + NLMSG_ALIGN(sizeof(struct crypto_user_alg)));
+             (ret = RTA_OK (rta, rta_len)); rta = RTA_NEXT(rta, rta_len)) {
+            if (rta->rta_type == CRYPTOCFGA_PRIORITY_VAL) {
+                list[list_count].priority = *((__u32 *)RTA_DATA(rta));
+                break;
+            }
+        }
+
+        OPENSSL_strlcpy(list[list_count].alg_name, cru_res->cru_name,
+                        sizeof(list->alg_name));
+        OPENSSL_strlcpy(list[list_count].driver_name, cru_res->cru_driver_name,
+                        sizeof(list->driver_name));
+        list[list_count].flags = cru_res->cru_flags;
+        list_count++;
+    }
+    ret = afalg_alg_list_count = list_count;
+out:
+    close(nlfd);
+    OPENSSL_free(buf);
+    return ret;
 }
 
-static ossl_inline int io_destroy(aio_context_t ctx)
+static enum afalg_accelerated_t
+afalg_get_accel_info(const char *alg_name, char *driver_name, size_t driver_len)
 {
-    return syscall(__NR_io_destroy, ctx);
+    int i;
+    __u32 priority = 0;
+    int found = 0;
+    enum afalg_accelerated_t new_accel, cur_accel = AFALG_ACCELERATION_UNKNOWN;
+
+    for (i = 0; i < afalg_alg_list_count; i++) {
+        if (strcmp(afalg_alg_list[i].alg_name, alg_name) ||
+            priority > afalg_alg_list[i].priority)
+            continue;
+        if (afalg_alg_list[i].flags & CRYPTO_ALG_KERN_DRIVER_ONLY)
+            new_accel = AFALG_ACCELERATED;
+        else
+            new_accel = AFALG_NOT_ACCELERATED;
+        if (found && priority == afalg_alg_list[i].priority) {
+            OPENSSL_strlcpy(driver_name, "**unreliable info**", driver_len);
+            if (new_accel != cur_accel)
+                cur_accel = AFALG_ACCELERATION_UNKNOWN;
+        } else {
+            found = 1;
+            cur_accel = new_accel;
+            priority = afalg_alg_list[i].priority;
+            OPENSSL_strlcpy(driver_name, afalg_alg_list[i].driver_name,
+                            driver_len);
+        }
+    }
+    return cur_accel;
 }
 
-static ossl_inline int io_read(aio_context_t ctx, long n, struct iocb **iocb)
+/******************************************************************************
+ *
+ * Ciphers
+ *
+ * Because they all do the same basic operation, we have only one set of
+ * method functions for them all to share, and a mapping table between
+ * NIDs and kernel cipher names, with all the necessary size data.
+ *
+ *****/
+
+struct cipher_ctx {
+    int bfd, sfd;
+#ifdef ALG_ZERO_COPY
+    int pipes[2];
+#endif
+    unsigned int op, blocksize, num;
+    unsigned char partial[EVP_MAX_BLOCK_LENGTH];
+};
+
+static const struct cipher_data_st {
+    int nid;
+    int blocksize;
+    int keylen;
+    int ivlen;
+    int flags;
+    const char *name;
+} cipher_data[] = {
+#ifndef OPENSSL_NO_DES
+    { NID_des_cbc, 8, 8, 8, EVP_CIPH_CBC_MODE, "cbc(des)" },
+    { NID_des_ede3_cbc, 8, 24, 8, EVP_CIPH_CBC_MODE, "cbc(des3_ede)" },
+#endif
+#ifndef OPENSSL_NO_BF
+    { NID_bf_cbc, 8, 16, 8, EVP_CIPH_CBC_MODE, "cbc(blowfish)" },
+#endif
+#ifndef OPENSSL_NO_CAST
+    { NID_cast5_cbc, 8, 16, 8, EVP_CIPH_CBC_MODE, "cbc(cast5)" },
+#endif
+    { NID_aes_128_cbc, 16, 128 / 8, 16, EVP_CIPH_CBC_MODE, "cbc(aes)" },
+    { NID_aes_192_cbc, 16, 192 / 8, 16, EVP_CIPH_CBC_MODE, "cbc(aes)" },
+    { NID_aes_256_cbc, 16, 256 / 8, 16, EVP_CIPH_CBC_MODE, "cbc(aes)" },
+#ifndef OPENSSL_NO_RC4
+    { NID_rc4, 1, 16, 0, EVP_CIPH_STREAM_CIPHER, "arc4" },
+#endif
+    { NID_aes_128_ctr, 16, 128 / 8, 16, EVP_CIPH_CTR_MODE, "ctr(aes)" },
+    { NID_aes_192_ctr, 16, 192 / 8, 16, EVP_CIPH_CTR_MODE, "ctr(aes)" },
+    { NID_aes_256_ctr, 16, 256 / 8, 16, EVP_CIPH_CTR_MODE, "ctr(aes)" },
+#if 0                            /* Not yet supported */
+    { NID_aes_128_xts, 16, 128 / 8 * 2, 16, EVP_CIPH_XTS_MODE, "xts(aes)" },
+    { NID_aes_256_xts, 16, 256 / 8 * 2, 16, EVP_CIPH_XTS_MODE, "xts(aes)" },
+#endif
+    { NID_aes_128_ecb, 16, 128 / 8, 0, EVP_CIPH_ECB_MODE, "ecb(aes)" },
+    { NID_aes_192_ecb, 16, 192 / 8, 0, EVP_CIPH_ECB_MODE, "ecb(aes)" },
+    { NID_aes_256_ecb, 16, 256 / 8, 0, EVP_CIPH_ECB_MODE, "ecb(aes)" },
+#if 0                            /* Not yet supported */
+    { NID_aes_128_gcm, 16, 128 / 8, 16, EVP_CIPH_GCM_MODE, "gcm(aes)" },
+    { NID_aes_192_gcm, 16, 192 / 8, 16, EVP_CIPH_GCM_MODE, "gcm(aes)" },
+    { NID_aes_256_gcm, 16, 256 / 8, 16, EVP_CIPH_GCM_MODE, "gcm(aes)" },
+#endif
+#if 0
+/* Current camellia kernel module does not implement the skcipher
+ * interface, necessary to work with AF_ALG */
+#ifndef OPENSSL_NO_CAMELLIA
+    { NID_camellia_128_cbc, 16, 128 / 8, 8, EVP_CIPH_CBC_MODE,
+      "cbc(camellia)" },
+    { NID_camellia_192_cbc, 16, 192 / 8, 8, EVP_CIPH_CBC_MODE,
+      "cbc(camellia)" },
+    { NID_camellia_256_cbc, 16, 256 / 8, 8, EVP_CIPH_CBC_MODE,
+      "cbc(camellia)" },
+#endif
+#endif
+};
+
+static size_t find_cipher_data_index(int nid)
 {
-    return syscall(__NR_io_submit, ctx, n, iocb);
+    size_t i;
+
+    for (i = 0; i < OSSL_NELEM(cipher_data); i++)
+        if (nid == cipher_data[i].nid)
+            return i;
+    return (size_t)-1;
 }
 
-static ossl_inline int io_getevents(aio_context_t ctx, long min, long max,
-                               struct io_event *events,
-                               struct timespec *timeout)
+static size_t get_cipher_data_index(int nid)
 {
-    return syscall(__NR_io_getevents, ctx, min, max, events, timeout);
+    size_t i = find_cipher_data_index(nid);
+
+    if (i != (size_t)-1)
+        return i;
+
+    /*
+     * Code further down must make sure that only NIDs in the table above
+     * are used.  If any other NID reaches this function, there's a grave
+     * coding error further down.
+     */
+    assert("Code that never should be reached" == NULL);
+    return -1;
 }
 
-static void afalg_waitfd_cleanup(ASYNC_WAIT_CTX *ctx, const void *key,
-                                 OSSL_ASYNC_FD waitfd, void *custom)
+static const struct cipher_data_st *get_cipher_data(int nid)
 {
-    close(waitfd);
+    return &cipher_data[get_cipher_data_index(nid)];
 }
 
-static int afalg_setup_async_event_notification(afalg_aio *aio)
-{
-    ASYNC_JOB *job;
-    ASYNC_WAIT_CTX *waitctx;
-    void *custom = NULL;
-    int ret;
+/*
+ * Following are the three necessary functions to map OpenSSL functionality
+ * with AF_ALG.
+ */
 
-    if ((job = ASYNC_get_current_job()) != NULL) {
-        /* Async mode */
-        waitctx = ASYNC_get_wait_ctx(job);
-        if (waitctx == NULL) {
-            ALG_WARN("%s(%d): ASYNC_get_wait_ctx error", __FILE__, __LINE__);
+static int cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+                       const unsigned char *iv, int enc)
+{
+    struct cipher_ctx *cipher_ctx =
+        (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
+    const struct cipher_data_st *cipher_d =
+        get_cipher_data(EVP_CIPHER_CTX_nid(ctx));
+
+    if (cipher_ctx->bfd == -1) {
+        if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_CTR_MODE)
+            cipher_ctx->blocksize = cipher_d->blocksize;
+        if ((cipher_ctx->bfd =
+             get_afalg_socket(cipher_d->name, "skcipher", 0, 0)) < 0) {
+            SYSerr(SYS_F_BIND, errno);
             return 0;
         }
-        /* Get waitfd from ASYNC_WAIT_CTX if it is already set */
-        ret = ASYNC_WAIT_CTX_get_fd(waitctx, engine_afalg_id,
-                                    &aio->efd, &custom);
-        if (ret == 0) {
-            /*
-             * waitfd is not set in ASYNC_WAIT_CTX, create a new one
-             * and set it. efd will be signaled when AIO operation completes
-             */
-            aio->efd = eventfd(0);
-            if (aio->efd == -1) {
-                ALG_PERR("%s(%d): Failed to get eventfd : ", __FILE__,
-                         __LINE__);
-                AFALGerr(AFALG_F_AFALG_SETUP_ASYNC_EVENT_NOTIFICATION,
-                         AFALG_R_EVENTFD_FAILED);
-                return 0;
-            }
-            ret = ASYNC_WAIT_CTX_set_wait_fd(waitctx, engine_afalg_id,
-                                             aio->efd, custom,
-                                             afalg_waitfd_cleanup);
-            if (ret == 0) {
-                ALG_WARN("%s(%d): Failed to set wait fd", __FILE__, __LINE__);
-                close(aio->efd);
-                return 0;
-            }
-            /* make fd non-blocking in async mode */
-            if (fcntl(aio->efd, F_SETFL, O_NONBLOCK) != 0) {
-                ALG_WARN("%s(%d): Failed to set event fd as NONBLOCKING",
-                         __FILE__, __LINE__);
-            }
-        }
-        aio->mode = MODE_ASYNC;
+        cipher_ctx->op = enc ? ALG_OP_ENCRYPT : ALG_OP_DECRYPT;
     } else {
-        /* Sync mode */
-        aio->efd = eventfd(0);
-        if (aio->efd == -1) {
-            ALG_PERR("%s(%d): Failed to get eventfd : ", __FILE__, __LINE__);
-            AFALGerr(AFALG_F_AFALG_SETUP_ASYNC_EVENT_NOTIFICATION,
-                     AFALG_R_EVENTFD_FAILED);
-            return 0;
-        }
-        aio->mode = MODE_SYNC;
+        close(cipher_ctx->sfd);
+        cipher_ctx->sfd = -1;
     }
-    return 1;
+    if ((key == NULL
+         || setsockopt(cipher_ctx->bfd, SOL_ALG, ALG_SET_KEY, key,
+                       EVP_CIPHER_CTX_key_length(ctx)) >= 0)
+        && (cipher_ctx->sfd = accept(cipher_ctx->bfd, NULL, 0)) >= 0
+#ifdef ALG_ZERO_COPY
+        && pipe(cipher_ctx->pipes) == 0
+#endif
+        )
+        return 1;
+
+    close(cipher_ctx->bfd);
+    if (cipher_ctx->sfd >= 0) {
+        perror("cipher_init: accept");
+        close(cipher_ctx->sfd);
+        cipher_ctx->sfd = -1;
+    } else {
+        perror("cipher_init: setsockopt");
+    }
+    return 0;
 }
 
-static int afalg_init_aio(afalg_aio *aio)
+static int afalg_do_cipher(struct cipher_ctx *cipher_ctx, unsigned char *out,
+                           const unsigned char *in, size_t inl, int enc,
+                           const unsigned char *iv, size_t ivlen)
 {
-    int r = -1;
+    struct msghdr msg = { 0 };
+    struct cmsghdr *cmsg;
+    struct af_alg_iv *aiv;
+    struct iovec iov;
+    char buf[CMSG_SPACE(sizeof(cipher_ctx->op))
+             + CMSG_SPACE(offsetof(struct af_alg_iv, iv) + EVP_MAX_IV_LENGTH)];
+    ssize_t nbytes;
+    size_t len;
+#ifdef ALG_ZERO_COPY
+    size_t pagesize;
+    int use_zc;
+#endif
 
-    /* Initialise for AIO */
-    aio->aio_ctx = 0;
-    r = io_setup(MAX_INFLIGHTS, &aio->aio_ctx);
-    if (r < 0) {
-        ALG_PERR("%s(%d): io_setup error : ", __FILE__, __LINE__);
-        AFALGerr(AFALG_F_AFALG_INIT_AIO, AFALG_R_IO_SETUP_FAILED);
-        return 0;
+    memset(&buf, 0, sizeof(buf));
+    msg.msg_control = buf;
+    msg.msg_controllen = CMSG_SPACE(sizeof(cipher_ctx->op));
+
+    cmsg = CMSG_FIRSTHDR(&msg);
+    cmsg->cmsg_level = SOL_ALG;
+    cmsg->cmsg_type = ALG_SET_OP;
+    cmsg->cmsg_len = CMSG_LEN(sizeof(cipher_ctx->op));
+    memcpy(CMSG_DATA(cmsg), &cipher_ctx->op, sizeof(cipher_ctx->op));
+
+    if (ivlen > 0) {
+        msg.msg_controllen += CMSG_SPACE(offsetof(struct af_alg_iv, iv) + ivlen);
+        cmsg = CMSG_NXTHDR(&msg, cmsg);
+        cmsg->cmsg_level = SOL_ALG;
+        cmsg->cmsg_type = ALG_SET_IV;
+        cmsg->cmsg_len = CMSG_LEN(offsetof(struct af_alg_iv, iv) + ivlen);
+        aiv = (void *)CMSG_DATA(cmsg);
+        aiv->ivlen = ivlen;
+        memcpy(aiv->iv, iv, ivlen);
     }
 
-    memset(aio->cbt, 0, sizeof(aio->cbt));
-    aio->efd = -1;
-    aio->mode = MODE_UNINIT;
+    iov.iov_base = (void *)in;
+    iov.iov_len = inl;
 
-    return 1;
+#ifdef ALG_ZERO_COPY
+    pagesize=(size_t) sysconf(_SC_PAGESIZE);
+    if ((use_zc = (inl <= (size_t) pagesize * 16) && ((size_t)in % pagesize == 0))) {
+        msg.msg_iov = NULL;
+        msg.msg_iovlen = 0;
+        len = 0;
+    } else {
+        msg.msg_iov = &iov;
+        msg.msg_iovlen = 1;
+        len = inl;
+    }
+#else
+    len = inl;
+    msg.msg_iov = &iov;
+    msg.msg_iovlen = 1;
+#endif
+    if ((nbytes = sendmsg(cipher_ctx->sfd, &msg, 0)) < 0) {
+        perror ("cipher_do_cipher: sendmsg");
+        return -1;
+    } else if (nbytes != (ssize_t) len) {
+        fprintf(stderr, "cipher_do_cipher: sent %zd bytes != len %zd\n",
+                nbytes, len);
+        return -1;
+    }
+
+#ifdef ALG_ZERO_COPY
+    if (use_zc &&
+        (vmsplice(cipher_ctx->pipes[1], &iov, 1, SPLICE_F_GIFT) < 0
+         || splice(cipher_ctx->pipes[0], NULL, cipher_ctx->sfd, NULL, inl, 0) < 0))
+        return 0;
+#endif
+
+    if ((nbytes = read(cipher_ctx->sfd, out, inl)) != (ssize_t) inl) {
+        fprintf(stderr, "cipher_do_cipher: read %zd bytes != inlen %zd\n",
+                nbytes, inl);
+        return -1;
+    }
+
+    return nbytes;
 }
 
-static int afalg_fin_cipher_aio(afalg_aio *aio, int sfd, unsigned char *buf,
-                                size_t len)
+static int cbc_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                         const unsigned char *in, size_t inl)
 {
-    int r;
-    int retry = 0;
-    unsigned int done = 0;
-    struct iocb *cb;
-    struct timespec timeout;
-    struct io_event events[MAX_INFLIGHTS];
-    u_int64_t eval = 0;
+    struct cipher_ctx *cipher_ctx =
+        (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
+    int enc = EVP_CIPHER_CTX_encrypting(ctx);
+    size_t ivlen = EVP_CIPHER_CTX_iv_length(ctx);
+    unsigned char *iv = EVP_CIPHER_CTX_iv_noconst(ctx);
+    unsigned char saved_iv[EVP_MAX_IV_LENGTH];
+    int outl;
+
+    assert(inl >= ivlen);
+    if (!enc)
+        memcpy(saved_iv, in + inl - ivlen, ivlen);
+    if ((outl = afalg_do_cipher(cipher_ctx, out, in, inl, enc, iv, ivlen)) < 1)
+        return outl;
+    memcpy(iv, enc ? out + inl - ivlen : saved_iv, ivlen);
+
+    return outl;
+}
 
-    timeout.tv_sec = 0;
-    timeout.tv_nsec = 0;
+static void ctr_updateiv(unsigned char* iv, size_t ivlen, size_t nblocks)
+{
+    do {
+        ivlen--;
+        nblocks += iv[ivlen];
+        iv[ivlen] = (uint8_t) nblocks;
+        nblocks >>= 8;
+    } while (ivlen);
+}
 
-    /* if efd has not been initialised yet do it here */
-    if (aio->mode == MODE_UNINIT) {
-        r = afalg_setup_async_event_notification(aio);
-        if (r == 0)
-            return 0;
+static int ctr_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                         const unsigned char *in, size_t inl)
+{
+    struct cipher_ctx *cipher_ctx =
+        (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
+    int enc = EVP_CIPHER_CTX_encrypting(ctx);
+    size_t ivlen = EVP_CIPHER_CTX_iv_length(ctx), nblocks, len;
+    unsigned char *iv = EVP_CIPHER_CTX_iv_noconst(ctx);
+
+    /* handle initial partial block */
+    while (cipher_ctx->num && inl) {
+        (*out++) = *(in++) ^ cipher_ctx->partial[cipher_ctx->num];
+        --inl;
+        cipher_ctx->num = (cipher_ctx->num + 1) % cipher_ctx->blocksize;
     }
 
-    cb = &(aio->cbt[0 % MAX_INFLIGHTS]);
-    memset(cb, '\0', sizeof(*cb));
-    cb->aio_fildes = sfd;
-    cb->aio_lio_opcode = IOCB_CMD_PREAD;
-    /*
-     * The pointer has to be converted to unsigned value first to avoid
-     * sign extension on cast to 64 bit value in 32-bit builds
-     */
-    cb->aio_buf = (size_t)buf;
-    cb->aio_offset = 0;
-    cb->aio_data = 0;
-    cb->aio_nbytes = len;
-    cb->aio_flags = IOCB_FLAG_RESFD;
-    cb->aio_resfd = aio->efd;
-
-    /*
-     * Perform AIO read on AFALG socket, this in turn performs an async
-     * crypto operation in kernel space
-     */
-    r = io_read(aio->aio_ctx, 1, &cb);
-    if (r < 0) {
-        ALG_PWARN("%s(%d): io_read failed : ", __FILE__, __LINE__);
-        return 0;
+    /* process full blocks */
+    if (inl > (unsigned int) cipher_ctx->blocksize) {
+      nblocks = inl/cipher_ctx->blocksize;
+      len = nblocks * cipher_ctx->blocksize;
+      if (afalg_do_cipher(cipher_ctx, out, in, len, enc, iv, ivlen) < 1)
+          return 0;
+      ctr_updateiv(iv, ivlen, nblocks);
+      inl -= len;
+      out += len;
+      in += len;
     }
 
-    do {
-        /* While AIO read is being performed pause job */
-        ASYNC_pause_job();
-
-        /* Check for completion of AIO read */
-        r = read(aio->efd, &eval, sizeof(eval));
-        if (r < 0) {
-            if (errno == EAGAIN || errno == EWOULDBLOCK)
-                continue;
-            ALG_PERR("%s(%d): read failed for event fd : ", __FILE__, __LINE__);
+    /* process final partial block */
+    if (inl) {
+        memset(cipher_ctx->partial, 0, cipher_ctx->blocksize);
+        if (afalg_do_cipher(cipher_ctx, cipher_ctx->partial,
+                            cipher_ctx->partial, cipher_ctx->blocksize, enc,
+                            iv, ivlen) < 1)
             return 0;
-        } else if (r == 0 || eval <= 0) {
-            ALG_WARN("%s(%d): eventfd read %d bytes, eval = %lu\n", __FILE__,
-                     __LINE__, r, eval);
+        ctr_updateiv(iv, ivlen, 1);
+        while (inl--) {
+            out[cipher_ctx->num] = in[cipher_ctx->num]
+                ^ cipher_ctx->partial[cipher_ctx->num];
+            cipher_ctx->num++;
         }
-        if (eval > 0) {
-
-            /* Get results of AIO read */
-            r = io_getevents(aio->aio_ctx, 1, MAX_INFLIGHTS,
-                             events, &timeout);
-            if (r > 0) {
-                /*
-                 * events.res indicates the actual status of the operation.
-                 * Handle the error condition first.
-                 */
-                if (events[0].res < 0) {
-                    /*
-                     * Underlying operation cannot be completed at the time
-                     * of previous submission. Resubmit for the operation.
-                     */
-                    if (events[0].res == -EBUSY && retry++ < 3) {
-                        r = io_read(aio->aio_ctx, 1, &cb);
-                        if (r < 0) {
-                            ALG_PERR("%s(%d): retry %d for io_read failed : ",
-                                     __FILE__, __LINE__, retry);
-                            return 0;
-                        }
-                        continue;
-                    } else {
-                        /*
-                         * Retries exceed for -EBUSY or unrecoverable error
-                         * condition for this instance of operation.
-                         */
-                        ALG_WARN
-                            ("%s(%d): Crypto Operation failed with code %lld\n",
-                             __FILE__, __LINE__, events[0].res);
-                        return 0;
-                    }
-                }
-                /* Operation successful. */
-                done = 1;
-            } else if (r < 0) {
-                ALG_PERR("%s(%d): io_getevents failed : ", __FILE__, __LINE__);
-                return 0;
-            } else {
-                ALG_WARN("%s(%d): io_geteventd read 0 bytes\n", __FILE__,
-                         __LINE__);
-            }
-        }
-    } while (!done);
+    }
 
     return 1;
 }
 
-static ossl_inline void afalg_set_op_sk(struct cmsghdr *cmsg,
-                                   const ALG_OP_TYPE op)
+static int ecb_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                         const unsigned char *in, size_t inl)
 {
-    cmsg->cmsg_level = SOL_ALG;
-    cmsg->cmsg_type = ALG_SET_OP;
-    cmsg->cmsg_len = CMSG_LEN(ALG_OP_LEN);
-    memcpy(CMSG_DATA(cmsg), &op, ALG_OP_LEN);
+    struct cipher_ctx *cipher_ctx =
+        (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
+    int enc = EVP_CIPHER_CTX_encrypting(ctx);
+
+    return afalg_do_cipher(cipher_ctx, out, in, inl, enc, NULL, 0);
 }
 
-static void afalg_set_iv_sk(struct cmsghdr *cmsg, const unsigned char *iv,
-                            const unsigned int len)
+static int cipher_ctrl(EVP_CIPHER_CTX *ctx, int type, int p1, void* p2)
 {
-    struct af_alg_iv *aiv;
+    struct cipher_ctx *cipher_ctx =
+        (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
+    struct cipher_ctx *to_cipher_ctx;
+
+    switch (type) {
+
+    case EVP_CTRL_COPY:
+        if (cipher_ctx == NULL)
+            return 1;
+        /* when copying the context, a new session needs to be initialized */
+        to_cipher_ctx = (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(
+                        (EVP_CIPHER_CTX *)p2);
+
+        to_cipher_ctx->bfd = to_cipher_ctx->sfd = -1;
+#ifdef ALG_ZERO_COPY
+        if (pipe(to->pipes) != 0)
+            return 0;
+#endif
+        if ((to_cipher_ctx->bfd = accept(cipher_ctx->bfd, NULL, 0)) != -1
+            && (to_cipher_ctx->sfd = accept(to_cipher_ctx->bfd, NULL, 0)) != -1)
+            return 1;
+        SYSerr(SYS_F_ACCEPT, errno);
+#ifdef ALG_ZERO_COPY
+        close(to_cipher_ctx->pipes[0]);
+        close(to_cipher_ctx->pipes[1]);
+#endif
+        if (to_cipher_ctx->bfd >= 0)
+            close(to_cipher_ctx->bfd);
+        return 0;
 
-    cmsg->cmsg_level = SOL_ALG;
-    cmsg->cmsg_type = ALG_SET_IV;
-    cmsg->cmsg_len = CMSG_LEN(ALG_IV_LEN(len));
-    aiv = (struct af_alg_iv *)CMSG_DATA(cmsg);
-    aiv->ivlen = len;
-    memcpy(aiv->iv, iv, len);
+    case EVP_CTRL_INIT:
+        cipher_ctx->bfd = cipher_ctx->sfd = -1;
+        return 1;
+
+    default:
+        break;
+    }
+
+    return -1;
 }
 
-static ossl_inline int afalg_set_key(afalg_ctx *actx, const unsigned char *key,
-                                const int klen)
+static int cipher_cleanup(EVP_CIPHER_CTX *ctx)
 {
+    struct cipher_ctx *cipher_ctx =
+        (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
     int ret;
-    ret = setsockopt(actx->bfd, SOL_ALG, ALG_SET_KEY, key, klen);
-    if (ret < 0) {
-        ALG_PERR("%s(%d): Failed to set socket option : ", __FILE__, __LINE__);
-        AFALGerr(AFALG_F_AFALG_SET_KEY, AFALG_R_SOCKET_SET_KEY_FAILED);
-        return 0;
-    }
-    return 1;
+
+    if (cipher_ctx == NULL)
+        return 1;
+
+    ret = !(0
+#ifdef ALG_ZERO_COPY
+            | afalg_closefd(cipher_ctx->pipes[0])
+            | afalg_closefd(cipher_ctx->pipes[1])
+#endif
+            | afalg_closefd(cipher_ctx->sfd)
+            | afalg_closefd(cipher_ctx->bfd));
+
+    cipher_ctx->bfd = cipher_ctx->sfd = -1;
+    return ret;
 }
 
-static int afalg_create_sk(afalg_ctx *actx, const char *ciphertype,
-                                const char *ciphername)
+/*
+ * Keep tables of known nids, associated methods, selected ciphers, and driver
+ * info.
+ * Note that known_cipher_nids[] isn't necessarily indexed the same way as
+ * cipher_data[] above, which the other tables are.
+ */
+static int known_cipher_nids[OSSL_NELEM(cipher_data)];
+static int known_cipher_nids_amount = -1; /* -1 indicates not yet initialised */
+static EVP_CIPHER *known_cipher_methods[OSSL_NELEM(cipher_data)] = { NULL, };
+static int selected_ciphers[OSSL_NELEM(cipher_data)];
+static struct driver_info_st cipher_driver_info[OSSL_NELEM(cipher_data)];
+
+
+static int afalg_test_cipher(size_t cipher_data_index)
 {
-    struct sockaddr_alg sa;
-    int r = -1;
+    return (cipher_driver_info[cipher_data_index].status == AFALG_STATUS_USABLE
+            && selected_ciphers[cipher_data_index] == 1
+            && (cipher_driver_info[cipher_data_index].accelerated
+                    == AFALG_ACCELERATED
+                || use_softdrivers == AFALG_USE_SOFTWARE
+                || (cipher_driver_info[cipher_data_index].accelerated
+                        != AFALG_NOT_ACCELERATED
+                    && use_softdrivers == AFALG_REJECT_SOFTWARE)));
+}
 
-    actx->bfd = actx->sfd = -1;
+static void prepare_cipher_methods(void)
+{
+    size_t i;
+    int fd, blocksize;
+    int (*do_cipher) (EVP_CIPHER_CTX *, unsigned char *, const unsigned char *,
+                      size_t);
+
+    for (i = 0, known_cipher_nids_amount = 0;
+         i < OSSL_NELEM(cipher_data); i++) {
+
+        selected_ciphers[i] = 1;
+        /*
+         * Check that the cipher is usable
+         */
+        if ((fd =
+            get_afalg_socket(cipher_data[i].name, "skcipher", 0, 0)) < 0) {
+            cipher_driver_info[i].status = AFALG_STATUS_NO_OPEN;
+            continue;
+        }
+        close(fd);
+
+        /* test hardware acceleration */
+        if ((fd =
+            get_afalg_socket(cipher_data[i].name, "skcipher",
+                             CRYPTO_ALG_KERN_DRIVER_ONLY,
+                             CRYPTO_ALG_KERN_DRIVER_ONLY)) >= 0) {
+            cipher_driver_info[i].accelerated = AFALG_ACCELERATED;
+            close(fd);
+        } else {
+            cipher_driver_info[i].accelerated = AFALG_NOT_ACCELERATED;
+        }
 
-    memset(&sa, 0, sizeof(sa));
-    sa.salg_family = AF_ALG;
-    OPENSSL_strlcpy((char *) sa.salg_type, ciphertype, sizeof(sa.salg_type));
-    OPENSSL_strlcpy((char *) sa.salg_name, ciphername, sizeof(sa.salg_name));
+        /* gather hardware driver information */
+        if (afalg_alg_list_count > 0
+            && (cipher_driver_info[i].driver_name =
+                OPENSSL_zalloc(CRYPTO_MAX_NAME)) != NULL
+            && cipher_driver_info[i].accelerated !=
+               afalg_get_accel_info(cipher_data[i].name,
+                                    cipher_driver_info[i].driver_name,
+                                    CRYPTO_MAX_NAME)) {
+            OPENSSL_strlcpy(cipher_driver_info[i].driver_name,
+                            "**unreliable info**", CRYPTO_MAX_NAME);
+            cipher_driver_info[i].accelerated = AFALG_ACCELERATION_UNKNOWN;
+        }
+        blocksize = cipher_data[i].blocksize;
+        switch (cipher_data[i].flags & EVP_CIPH_MODE) {
+        case EVP_CIPH_CBC_MODE:
+            do_cipher = cbc_do_cipher;
+            break;
+        case EVP_CIPH_CTR_MODE:
+            do_cipher = ctr_do_cipher;
+            blocksize = 1;
+            break;
+        case EVP_CIPH_ECB_MODE:
+            do_cipher = ecb_do_cipher;
+            break;
+        default:
+            cipher_driver_info[i].status = AFALG_STATUS_FAILURE;
+            known_cipher_methods[i] = NULL;
+            continue;
+        }
 
-    actx->bfd = socket(AF_ALG, SOCK_SEQPACKET, 0);
-    if (actx->bfd == -1) {
-        ALG_PERR("%s(%d): Failed to open socket : ", __FILE__, __LINE__);
-        AFALGerr(AFALG_F_AFALG_CREATE_SK, AFALG_R_SOCKET_CREATE_FAILED);
-        goto err;
+        if ((known_cipher_methods[i] =
+                 EVP_CIPHER_meth_new(cipher_data[i].nid, blocksize,
+                                     cipher_data[i].keylen)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(known_cipher_methods[i],
+                                              cipher_data[i].ivlen)
+            || !EVP_CIPHER_meth_set_flags(known_cipher_methods[i],
+                                          cipher_data[i].flags
+                                          | EVP_CIPH_CUSTOM_COPY
+                                          | EVP_CIPH_CTRL_INIT
+                                          | EVP_CIPH_FLAG_DEFAULT_ASN1)
+            || !EVP_CIPHER_meth_set_init(known_cipher_methods[i], cipher_init)
+            || !EVP_CIPHER_meth_set_do_cipher(known_cipher_methods[i], do_cipher)
+            || !EVP_CIPHER_meth_set_ctrl(known_cipher_methods[i], cipher_ctrl)
+            || !EVP_CIPHER_meth_set_cleanup(known_cipher_methods[i],
+                                            cipher_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(known_cipher_methods[i],
+                                                  sizeof(struct cipher_ctx))) {
+            cipher_driver_info[i].status = AFALG_STATUS_FAILURE;
+            EVP_CIPHER_meth_free(known_cipher_methods[i]);
+            known_cipher_methods[i] = NULL;
+        } else {
+            cipher_driver_info[i].status = AFALG_STATUS_USABLE;
+            if (afalg_test_cipher(i))
+                known_cipher_nids[known_cipher_nids_amount++] = cipher_data[i].nid;
+        }
     }
+}
 
-    r = bind(actx->bfd, (struct sockaddr *)&sa, sizeof(sa));
-    if (r < 0) {
-        ALG_PERR("%s(%d): Failed to bind socket : ", __FILE__, __LINE__);
-        AFALGerr(AFALG_F_AFALG_CREATE_SK, AFALG_R_SOCKET_BIND_FAILED);
-        goto err;
-    }
+static void rebuild_known_cipher_nids(ENGINE *e)
+{
+    size_t i;
 
-    actx->sfd = accept(actx->bfd, NULL, 0);
-    if (actx->sfd < 0) {
-        ALG_PERR("%s(%d): Socket Accept Failed : ", __FILE__, __LINE__);
-        AFALGerr(AFALG_F_AFALG_CREATE_SK, AFALG_R_SOCKET_ACCEPT_FAILED);
-        goto err;
+    for (i = 0, known_cipher_nids_amount = 0; i < OSSL_NELEM(cipher_data); i++) {
+        if (afalg_test_cipher(i))
+            known_cipher_nids[known_cipher_nids_amount++] = cipher_data[i].nid;
     }
+    ENGINE_unregister_ciphers(e);
+    ENGINE_register_ciphers(e);
+}
 
-    return 1;
+static const EVP_CIPHER *get_cipher_method(int nid)
+{
+    size_t i = get_cipher_data_index(nid);
 
- err:
-    if (actx->bfd >= 0)
-        close(actx->bfd);
-    if (actx->sfd >= 0)
-        close(actx->sfd);
-    actx->bfd = actx->sfd = -1;
-    return 0;
+    if (i == (size_t)-1)
+        return NULL;
+    return known_cipher_methods[i];
 }
 
-static int afalg_start_cipher_sk(afalg_ctx *actx, const unsigned char *in,
-                                 size_t inl, const unsigned char *iv,
-                                 unsigned int enc)
+static int get_cipher_nids(const int **nids)
 {
-    struct msghdr msg = { 0 };
-    struct cmsghdr *cmsg;
-    struct iovec iov;
-    ssize_t sbytes;
-# ifdef ALG_ZERO_COPY
-    int ret;
-# endif
-    char cbuf[CMSG_SPACE(ALG_IV_LEN(ALG_AES_IV_LEN)) + CMSG_SPACE(ALG_OP_LEN)];
-
-    memset(cbuf, 0, sizeof(cbuf));
-    msg.msg_control = cbuf;
-    msg.msg_controllen = sizeof(cbuf);
+    *nids = known_cipher_nids;
+    return known_cipher_nids_amount;
+}
 
-    /*
-     * cipher direction (i.e. encrypt or decrypt) and iv are sent to the
-     * kernel as part of sendmsg()'s ancillary data
-     */
-    cmsg = CMSG_FIRSTHDR(&msg);
-    afalg_set_op_sk(cmsg, enc);
-    cmsg = CMSG_NXTHDR(&msg, cmsg);
-    afalg_set_iv_sk(cmsg, iv, ALG_AES_IV_LEN);
+static void destroy_cipher_method(int nid)
+{
+    size_t i = get_cipher_data_index(nid);
 
-    /* iov that describes input data */
-    iov.iov_base = (unsigned char *)in;
-    iov.iov_len = inl;
+    EVP_CIPHER_meth_free(known_cipher_methods[i]);
+    known_cipher_methods[i] = NULL;
+}
 
-    msg.msg_flags = MSG_MORE;
+static void destroy_all_cipher_methods(void)
+{
+    size_t i;
 
-# ifdef ALG_ZERO_COPY
-    /*
-     * ZERO_COPY mode
-     * Works best when buffer is 4k aligned
-     * OPENS: out of place processing (i.e. out != in)
-     */
+    for (i = 0; i < OSSL_NELEM(cipher_data); i++) {
+        destroy_cipher_method(cipher_data[i].nid);
+        OPENSSL_free(cipher_driver_info[i].driver_name);
+        cipher_driver_info[i].driver_name = NULL;
+    }
+}
 
-    /* Input data is not sent as part of call to sendmsg() */
-    msg.msg_iovlen = 0;
-    msg.msg_iov = NULL;
+static int afalg_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
+                             const int **nids, int nid)
+{
+    if (cipher == NULL)
+        return get_cipher_nids(nids);
 
-    /* Sendmsg() sends iv and cipher direction to the kernel */
-    sbytes = sendmsg(actx->sfd, &msg, 0);
-    if (sbytes < 0) {
-        ALG_PERR("%s(%d): sendmsg failed for zero copy cipher operation : ",
-                 __FILE__, __LINE__);
-        return 0;
-    }
+    *cipher = get_cipher_method(nid);
 
-    /*
-     * vmsplice and splice are used to pin the user space input buffer for
-     * kernel space processing avoiding copys from user to kernel space
-     */
-    ret = vmsplice(actx->zc_pipe[1], &iov, 1, SPLICE_F_GIFT);
-    if (ret < 0) {
-        ALG_PERR("%s(%d): vmsplice failed : ", __FILE__, __LINE__);
-        return 0;
-    }
+    return *cipher != NULL;
+}
 
-    ret = splice(actx->zc_pipe[0], NULL, actx->sfd, NULL, inl, 0);
-    if (ret < 0) {
-        ALG_PERR("%s(%d): splice failed : ", __FILE__, __LINE__);
-        return 0;
-    }
-# else
-    msg.msg_iovlen = 1;
-    msg.msg_iov = &iov;
+static void afalg_select_all_ciphers(int *cipher_list)
+{
+    size_t i;
 
-    /* Sendmsg() sends iv, cipher direction and input data to the kernel */
-    sbytes = sendmsg(actx->sfd, &msg, 0);
-    if (sbytes < 0) {
-        ALG_PERR("%s(%d): sendmsg failed for cipher operation : ", __FILE__,
-                 __LINE__);
-        return 0;
-    }
+    for (i = 0; i < OSSL_NELEM(cipher_data); i++)
+        cipher_list[i] = 1;
+}
 
-    if (sbytes != (ssize_t) inl) {
-        ALG_WARN("Cipher operation send bytes %zd != inlen %zd\n", sbytes,
-                inl);
+static int afalg_select_cipher_cb(const char *str, int len, void *usr)
+{
+    int *cipher_list = (int *)usr;
+    char *name;
+    const EVP_CIPHER *EVP;
+    size_t i;
+
+    if (len == 0)
+        return 1;
+    if (usr == NULL || (name = OPENSSL_strndup(str, len)) == NULL)
         return 0;
-    }
-# endif
-
+    EVP = EVP_get_cipherbyname(name);
+    if (EVP == NULL)
+        fprintf(stderr, "afalg: unknown cipher %s\n", name);
+    else if ((i = find_cipher_data_index(EVP_CIPHER_nid(EVP))) != (size_t)-1)
+        cipher_list[i] = 1;
+    else
+        fprintf(stderr, "afalg: cipher %s not available\n", name);
+    OPENSSL_free(name);
     return 1;
 }
 
-static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
-                             const unsigned char *iv, int enc)
+static void dump_cipher_info(void)
 {
-    int ciphertype;
-    int ret;
-    afalg_ctx *actx;
-    const char *ciphername;
-
-    if (ctx == NULL || key == NULL) {
-        ALG_WARN("%s(%d): Null Parameter\n", __FILE__, __LINE__);
-        return 0;
+    size_t i;
+    const char *evp_name;
+
+    fprintf (stderr, "Information about ciphers supported by the AF_ALG"
+             " engine:\n");
+
+    for (i = 0; i < OSSL_NELEM(cipher_data); i++) {
+        evp_name = OBJ_nid2sn(cipher_data[i].nid);
+        fprintf (stderr, "Cipher %s, NID=%d, AF_ALG info: name=%s, ",
+                 evp_name ? evp_name : "unknown", cipher_data[i].nid,
+                 cipher_data[i].name);
+        if (cipher_driver_info[i].status == AFALG_STATUS_NO_OPEN) {
+            fprintf (stderr, "AF_ALG socket bind failed.\n");
+            continue;
+        }
+        fprintf(stderr, " driver=%s ", cipher_driver_info[i].driver_name ?
+                 cipher_driver_info[i].driver_name : "unknown");
+        if (cipher_driver_info[i].accelerated == AFALG_ACCELERATED)
+            fprintf (stderr, "(hw accelerated)");
+        else if (cipher_driver_info[i].accelerated == AFALG_NOT_ACCELERATED)
+            fprintf(stderr, "(software)");
+        else
+            fprintf(stderr, "(acceleration status unknown)");
+        if (cipher_driver_info[i].status == AFALG_STATUS_FAILURE)
+            fprintf (stderr, ". Cipher setup failed.");
+        fprintf (stderr, "\n");
     }
+    fprintf(stderr, "\n");
+}
 
-    if (EVP_CIPHER_CTX_cipher(ctx) == NULL) {
-        ALG_WARN("%s(%d): Cipher object NULL\n", __FILE__, __LINE__);
-        return 0;
-    }
+/******************************************************************************
+ *
+ * Digests
+ *
+ * Because they all do the same basic operation, we have only one set of
+ * method functions for them all to share, and a mapping table between
+ * NIDs and AF_ALG names, with all the necessary size data.
+ *
+ *****/
+
+struct digest_ctx {
+    /* This signals that the init function was called, not that it succeeded. */
+    int init_called;
+    int bfd, sfd;
+#ifdef ALG_ZERO_COPY
+    int pipes[2];
+#endif
+};
 
-    actx = EVP_CIPHER_CTX_get_cipher_data(ctx);
-    if (actx == NULL) {
-        ALG_WARN("%s(%d): Cipher data NULL\n", __FILE__, __LINE__);
-        return 0;
-    }
+static const struct digest_data_st {
+    int nid;
+    int blocksize;
+    int digestlen;
+    char *name;
+} digest_data[] = {
+#ifndef OPENSSL_NO_MD5
+    { NID_md5, /* MD5_CBLOCK */ 64, 16, "md5" },
+#endif
+    { NID_sha1, SHA_CBLOCK, 20, "sha1" },
+#ifndef OPENSSL_NO_RMD160
+    { NID_ripemd160, /* RIPEMD160_CBLOCK */ 64, 20, "rmd160" },
+#endif
+    { NID_sha224, SHA256_CBLOCK, 224 / 8, "sha224" },
+    { NID_sha256, SHA256_CBLOCK, 256 / 8, "sha256" },
+    { NID_sha384, SHA512_CBLOCK, 384 / 8, "sha384" },
+    { NID_sha512, SHA512_CBLOCK, 512 / 8, "sha512" },
+};
 
-    ciphertype = EVP_CIPHER_CTX_nid(ctx);
-    switch (ciphertype) {
-    case NID_aes_128_cbc:
-    case NID_aes_192_cbc:
-    case NID_aes_256_cbc:
-        ciphername = "cbc(aes)";
-        break;
-    default:
-        ALG_WARN("%s(%d): Unsupported Cipher type %d\n", __FILE__, __LINE__,
-                 ciphertype);
-        return 0;
-    }
+static size_t find_digest_data_index(int nid)
+{
+    size_t i;
 
-    if (ALG_AES_IV_LEN != EVP_CIPHER_CTX_iv_length(ctx)) {
-        ALG_WARN("%s(%d): Unsupported IV length :%d\n", __FILE__, __LINE__,
-                 EVP_CIPHER_CTX_iv_length(ctx));
-        return 0;
-    }
+    for (i = 0; i < OSSL_NELEM(digest_data); i++)
+        if (nid == digest_data[i].nid)
+            return i;
+    return (size_t)-1;
+}
 
-    /* Setup AFALG socket for crypto processing */
-    ret = afalg_create_sk(actx, "skcipher", ciphername);
-    if (ret < 1)
-        return 0;
+static size_t get_digest_data_index(int nid)
+{
+    size_t i = find_digest_data_index(nid);
 
+    if (i != (size_t)-1)
+        return i;
 
-    ret = afalg_set_key(actx, key, EVP_CIPHER_CTX_key_length(ctx));
-    if (ret < 1)
-        goto err;
+    /*
+     * Code further down must make sure that only NIDs in the table above
+     * are used.  If any other NID reaches this function, there's a grave
+     * coding error further down.
+     */
+    assert("Code that never should be reached" == NULL);
+    return -1;
+}
 
-    /* Setup AIO ctx to allow async AFALG crypto processing */
-    if (afalg_init_aio(&actx->aio) == 0)
-        goto err;
+static const struct digest_data_st *get_digest_data(int nid)
+{
+    return &digest_data[get_digest_data_index(nid)];
+}
 
-# ifdef ALG_ZERO_COPY
-    pipe(actx->zc_pipe);
-# endif
+/*
+ * Following are the five necessary functions to map OpenSSL functionality
+ * with AF_ALG: init, update, final, cleanup, and copy.
+ */
 
-    actx->init_done = MAGIC_INIT_NUM;
+static int digest_init(EVP_MD_CTX *ctx)
+{
+    struct digest_ctx *digest_ctx =
+        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
+    const struct digest_data_st *digest_d =
+        get_digest_data(EVP_MD_CTX_type(ctx));
 
-    return 1;
+    digest_ctx->init_called = 1;
 
-err:
-    close(actx->sfd);
-    close(actx->bfd);
+    digest_ctx->sfd = -1;
+    if ((digest_ctx->bfd =
+        get_afalg_socket(digest_d->name, "hash",0 ,0)) < 0) {
+        SYSerr(SYS_F_BIND, errno);
+        return 0;
+    }
+    if ((digest_ctx->sfd = accept(digest_ctx->bfd, NULL, 0)) >= 0
+#ifdef ALG_ZERO_COPY
+        && pipe(digest_ctx->pipes) == 0
+#endif
+        )
+        return 1;
+    close(digest_ctx->bfd);
+    digest_ctx->bfd = -1;
+    if (digest_ctx->sfd > -1) {
+        close(digest_ctx->sfd);
+        digest_ctx->sfd = -1;
+    }
     return 0;
 }
 
-static int afalg_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                           const unsigned char *in, size_t inl)
+static int digest_update(EVP_MD_CTX *ctx, const void *data, size_t count)
 {
-    afalg_ctx *actx;
-    int ret;
-    char nxtiv[ALG_AES_IV_LEN] = { 0 };
+    struct digest_ctx *digest_ctx =
+        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
+    int flags = 0;
+#ifdef ALG_ZERO_COPY
+    struct iovec iov;
+    size_t pagesize;
+#endif
 
-    if (ctx == NULL || out == NULL || in == NULL) {
-        ALG_WARN("NULL parameter passed to function %s(%d)\n", __FILE__,
-                 __LINE__);
-        return 0;
-    }
+    if (count == 0)
+        return 1;
 
-    actx = (afalg_ctx *) EVP_CIPHER_CTX_get_cipher_data(ctx);
-    if (actx == NULL || actx->init_done != MAGIC_INIT_NUM) {
-        ALG_WARN("%s afalg ctx passed\n",
-                 ctx == NULL ? "NULL" : "Uninitialised");
+    if (digest_ctx == NULL)
         return 0;
+
+#ifdef ALG_ZERO_COPY
+    pagesize=(size_t) sysconf(_SC_PAGESIZE);
+    if (count <= (size_t) pagesize * 16
+        && (size_t)data % pagesize == 0) {
+        iov.iov_base = (void *)data;
+        iov.iov_len = count;
+
+        if (!EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_ONESHOT))
+            flags = SPLICE_F_MORE;
+
+        if (vmsplice(digest_ctx->pipes[1], &iov, 1, flags | SPLICE_F_GIFT) >=0
+            && splice(digest_ctx->pipes[0], NULL, digest_ctx->sfd, NULL,
+                      count, flags) >0)
+            return 1;
     }
+    else
+#endif
+    {
+        if (!EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_ONESHOT))
+            flags = MSG_MORE;
 
-    /*
-     * set iv now for decrypt operation as the input buffer can be
-     * overwritten for inplace operation where in = out.
-     */
-    if (EVP_CIPHER_CTX_encrypting(ctx) == 0) {
-        memcpy(nxtiv, in + (inl - ALG_AES_IV_LEN), ALG_AES_IV_LEN);
+        if (send(digest_ctx->sfd, data, count, flags) == (ssize_t)count)
+            return 1;
     }
+    return 0;
+}
 
-    /* Send input data to kernel space */
-    ret = afalg_start_cipher_sk(actx, (unsigned char *)in, inl,
-                                EVP_CIPHER_CTX_iv(ctx),
-                                EVP_CIPHER_CTX_encrypting(ctx));
-    if (ret < 1) {
+static int digest_final(EVP_MD_CTX *ctx, unsigned char *md)
+{
+    struct digest_ctx *digest_ctx =
+        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
+    int len = EVP_MD_CTX_size(ctx);
+
+    if (md == NULL || digest_ctx == NULL)
         return 0;
-    }
 
-    /* Perform async crypto operation in kernel space */
-    ret = afalg_fin_cipher_aio(&actx->aio, actx->sfd, out, inl);
-    if (ret < 1)
+    if (!EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_ONESHOT)
+        && send(digest_ctx->sfd, NULL, 0, 0) < 0)
         return 0;
 
-    if (EVP_CIPHER_CTX_encrypting(ctx)) {
-        memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), out + (inl - ALG_AES_IV_LEN),
-               ALG_AES_IV_LEN);
-    } else {
-        memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), nxtiv, ALG_AES_IV_LEN);
-    }
+    if (recv(digest_ctx->sfd, md, len, 0) != len)
+        return 0;
 
     return 1;
 }
 
-static int afalg_cipher_cleanup(EVP_CIPHER_CTX *ctx)
+static int digest_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from)
 {
-    afalg_ctx *actx;
+    struct digest_ctx *digest_from =
+        (struct digest_ctx *)EVP_MD_CTX_md_data(from);
+    struct digest_ctx *digest_to =
+        (struct digest_ctx *)EVP_MD_CTX_md_data(to);
 
-    if (ctx == NULL) {
-        ALG_WARN("NULL parameter passed to function %s(%d)\n", __FILE__,
-                 __LINE__);
-        return 0;
-    }
+    if (digest_from == NULL || digest_from->init_called != 1)
+        return 1;
 
-    actx = (afalg_ctx *) EVP_CIPHER_CTX_get_cipher_data(ctx);
-    if (actx == NULL || actx->init_done != MAGIC_INIT_NUM) {
-        ALG_WARN("%s afalg ctx passed\n",
-                 ctx == NULL ? "NULL" : "Uninitialised");
+#ifdef ALG_ZERO_COPY
+    if (pipe(digest_to->pipes) != 0)
         return 0;
-    }
+#endif
+    digest_to->sfd = digest_to->bfd = -1;
+    if ((digest_to->bfd = accept(digest_from->bfd, NULL, 0)) != -1
+        && (digest_to->sfd = accept(digest_from->sfd, NULL, 0)) != -1)
+        return 1;
+
+    SYSerr(SYS_F_ACCEPT, errno);
+#ifdef ALG_ZERO_COPY
+    close(digest_to->pipes[0]);
+    close(digest_to->pipes[1]);
+#endif
+    if (digest_to->bfd != -1)
+        close(digest_to->bfd);
+    digest_to->sfd = digest_to->bfd = -1;
+    return 0;
+}
 
-    close(actx->sfd);
-    close(actx->bfd);
-# ifdef ALG_ZERO_COPY
-    close(actx->zc_pipe[0]);
-    close(actx->zc_pipe[1]);
-# endif
-    /* close efd in sync mode, async mode is closed in afalg_waitfd_cleanup() */
-    if (actx->aio.mode == MODE_SYNC)
-        close(actx->aio.efd);
-    io_destroy(actx->aio.aio_ctx);
+static int digest_cleanup(EVP_MD_CTX *ctx)
+{
+    struct digest_ctx *digest_ctx =
+        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
 
-    return 1;
+    if (digest_ctx == NULL || digest_ctx->init_called != 1)
+        return 1;
+
+    return !(0
+#ifdef ALG_ZERO_COPY
+             | afalg_closefd(digest_ctx->pipes[0])
+             | afalg_closefd(digest_ctx->pipes[1])
+#endif
+             | afalg_closefd(digest_ctx->sfd)
+             | afalg_closefd(digest_ctx->bfd));
 }
 
-static cbc_handles *get_cipher_handle(int nid)
+/*
+ * Keep tables of known nids, associated methods, selected digests, and
+ * driver info.
+ * Note that known_digest_nids[] isn't necessarily indexed the same way as
+ * digest_data[] above, which the other tables are.
+ */
+static int known_digest_nids[OSSL_NELEM(digest_data)];
+static int known_digest_nids_amount = -1; /* -1 indicates not yet initialised */
+static EVP_MD *known_digest_methods[OSSL_NELEM(digest_data)] = { NULL, };
+static int selected_digests[OSSL_NELEM(digest_data)];
+static struct driver_info_st digest_driver_info[OSSL_NELEM(digest_data)];
+
+static int afalg_test_digest(size_t digest_data_index)
 {
-    switch (nid) {
-    case NID_aes_128_cbc:
-        return &cbc_handle[AES_CBC_128];
-    case NID_aes_192_cbc:
-        return &cbc_handle[AES_CBC_192];
-    case NID_aes_256_cbc:
-        return &cbc_handle[AES_CBC_256];
-    default:
-        return NULL;
-    }
+    return (digest_driver_info[digest_data_index].status == AFALG_STATUS_USABLE
+            && selected_digests[digest_data_index] == 1
+            && (digest_driver_info[digest_data_index].accelerated
+                    == AFALG_ACCELERATED
+                || use_softdrivers == AFALG_USE_SOFTWARE
+                || (digest_driver_info[digest_data_index].accelerated
+                        != AFALG_NOT_ACCELERATED
+                    && use_softdrivers == AFALG_REJECT_SOFTWARE)));
 }
 
-static const EVP_CIPHER *afalg_aes_cbc(int nid)
+static void rebuild_known_digest_nids(ENGINE *e)
 {
-    cbc_handles *cipher_handle = get_cipher_handle(nid);
-    if (cipher_handle->_hidden == NULL
-        && ((cipher_handle->_hidden =
-         EVP_CIPHER_meth_new(nid,
-                             AES_BLOCK_SIZE,
-                             cipher_handle->key_size)) == NULL
-        || !EVP_CIPHER_meth_set_iv_length(cipher_handle->_hidden,
-                                          AES_IV_LEN)
-        || !EVP_CIPHER_meth_set_flags(cipher_handle->_hidden,
-                                      EVP_CIPH_CBC_MODE |
-                                      EVP_CIPH_FLAG_DEFAULT_ASN1)
-        || !EVP_CIPHER_meth_set_init(cipher_handle->_hidden,
-                                     afalg_cipher_init)
-        || !EVP_CIPHER_meth_set_do_cipher(cipher_handle->_hidden,
-                                          afalg_do_cipher)
-        || !EVP_CIPHER_meth_set_cleanup(cipher_handle->_hidden,
-                                        afalg_cipher_cleanup)
-        || !EVP_CIPHER_meth_set_impl_ctx_size(cipher_handle->_hidden,
-                                              sizeof(afalg_ctx)))) {
-        EVP_CIPHER_meth_free(cipher_handle->_hidden);
-        cipher_handle->_hidden= NULL;
+    size_t i;
+
+    for (i = 0, known_digest_nids_amount = 0; i < OSSL_NELEM(digest_data); i++) {
+        if (afalg_test_digest(i))
+            known_digest_nids[known_digest_nids_amount++] = digest_data[i].nid;
     }
-    return cipher_handle->_hidden;
+    ENGINE_unregister_digests(e);
+    ENGINE_register_digests(e);
 }
 
-static int afalg_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
-                         const int **nids, int nid)
+static void prepare_digest_methods(void)
 {
-    int r = 1;
+    size_t i;
+    int fd;
+
+    for (i = 0, known_digest_nids_amount = 0; i < OSSL_NELEM(digest_data);
+         i++) {
+
+        selected_digests[i] = 0;
+        /*
+         * Check that the digest is usable
+         */
+        if ((fd = get_afalg_socket(digest_data[i].name, "hash", 0, 0)) < 0) {
+            digest_driver_info[i].status = AFALG_STATUS_NO_OPEN;
+            continue;
+        }
+        close(fd);
+
+        /* test hardware acceleration */
+        if ((fd =
+            get_afalg_socket(cipher_data[i].name, "hash",
+                             CRYPTO_ALG_KERN_DRIVER_ONLY,
+                             CRYPTO_ALG_KERN_DRIVER_ONLY)) >= 0) {
+            digest_driver_info[i].accelerated = AFALG_ACCELERATED;
+            close(fd);
+        } else {
+            digest_driver_info[i].accelerated = AFALG_NOT_ACCELERATED;
+        }
 
-    if (cipher == NULL) {
-        *nids = afalg_cipher_nids;
-        return (sizeof(afalg_cipher_nids) / sizeof(afalg_cipher_nids[0]));
-    }
+        /* gather hardware driver information */
+        if (afalg_alg_list_count > 0
+            && (digest_driver_info[i].driver_name =
+                OPENSSL_zalloc(CRYPTO_MAX_NAME)) != NULL
+            && digest_driver_info[i].accelerated !=
+               afalg_get_accel_info(digest_data[i].name,
+                                    digest_driver_info[i].driver_name,
+                                    CRYPTO_MAX_NAME)) {
+            OPENSSL_strlcpy(digest_driver_info[i].driver_name,
+                            "**unreliable info**", CRYPTO_MAX_NAME);
+            digest_driver_info[i].accelerated = AFALG_ACCELERATION_UNKNOWN;
+        }
 
-    switch (nid) {
-    case NID_aes_128_cbc:
-    case NID_aes_192_cbc:
-    case NID_aes_256_cbc:
-        *cipher = afalg_aes_cbc(nid);
-        break;
-    default:
-        *cipher = NULL;
-        r = 0;
+        if ((known_digest_methods[i] = EVP_MD_meth_new(digest_data[i].nid,
+                                                       NID_undef)) == NULL
+            || !EVP_MD_meth_set_input_blocksize(known_digest_methods[i],
+                                                digest_data[i].blocksize)
+            || !EVP_MD_meth_set_result_size(known_digest_methods[i],
+                                            digest_data[i].digestlen)
+            || !EVP_MD_meth_set_init(known_digest_methods[i], digest_init)
+            || !EVP_MD_meth_set_update(known_digest_methods[i], digest_update)
+            || !EVP_MD_meth_set_final(known_digest_methods[i], digest_final)
+            || !EVP_MD_meth_set_copy(known_digest_methods[i], digest_copy)
+            || !EVP_MD_meth_set_cleanup(known_digest_methods[i], digest_cleanup)
+            || !EVP_MD_meth_set_app_datasize(known_digest_methods[i],
+                                             sizeof(struct digest_ctx))) {
+            digest_driver_info[i].status = AFALG_STATUS_FAILURE;
+            EVP_MD_meth_free(known_digest_methods[i]);
+            known_digest_methods[i] = NULL;
+        } else {
+            digest_driver_info[i].status = AFALG_STATUS_USABLE;
+        }
+        if (afalg_test_digest(i))
+            known_digest_nids[known_digest_nids_amount++] = digest_data[i].nid;
     }
-    return r;
 }
 
-static int bind_afalg(ENGINE *e)
+static const EVP_MD *get_digest_method(int nid)
 {
-    /* Ensure the afalg error handling is set up */
-    unsigned short i;
-    ERR_load_AFALG_strings();
+    size_t i = get_digest_data_index(nid);
 
-    if (!ENGINE_set_id(e, engine_afalg_id)
-        || !ENGINE_set_name(e, engine_afalg_name)
-        || !ENGINE_set_destroy_function(e, afalg_destroy)
-        || !ENGINE_set_init_function(e, afalg_init)
-        || !ENGINE_set_finish_function(e, afalg_finish)) {
-        AFALGerr(AFALG_F_BIND_AFALG, AFALG_R_INIT_FAILED);
-        return 0;
-    }
+    if (i == (size_t)-1)
+        return NULL;
+    return known_digest_methods[i];
+}
 
-    /*
-     * Create _hidden_aes_xxx_cbc by calling afalg_aes_xxx_cbc
-     * now, as bind_aflag can only be called by one thread at a
-     * time.
-     */
-    for(i = 0; i < OSSL_NELEM(afalg_cipher_nids); i++) {
-        if (afalg_aes_cbc(afalg_cipher_nids[i]) == NULL) {
-            AFALGerr(AFALG_F_BIND_AFALG, AFALG_R_INIT_FAILED);
-            return 0;
-        }
+static void destroy_digest_method(int nid)
+{
+    size_t i = get_digest_data_index(nid);
+
+    EVP_MD_meth_free(known_digest_methods[i]);
+    known_digest_methods[i] = NULL;
+}
+
+static void destroy_all_digest_methods(void)
+{
+    size_t i;
+
+    for (i = 0; i < OSSL_NELEM(digest_data); i++) {
+        destroy_digest_method(digest_data[i].nid);
+        OPENSSL_free(digest_driver_info[i].driver_name);
+        digest_driver_info[i].driver_name = NULL;
     }
+}
 
-    if (!ENGINE_set_ciphers(e, afalg_ciphers)) {
-        AFALGerr(AFALG_F_BIND_AFALG, AFALG_R_INIT_FAILED);
-        return 0;
+static int afalg_digests(ENGINE *e, const EVP_MD **digest,
+                             const int **nids, int nid)
+{
+    if (digest == NULL) {
+        *nids = known_digest_nids;
+        return known_digest_nids_amount;
     }
+    *digest = get_digest_method(nid);
 
-    return 1;
+    return *digest != NULL;
 }
 
-# ifndef OPENSSL_NO_DYNAMIC_ENGINE
-static int bind_helper(ENGINE *e, const char *id)
+static void afalg_select_all_digests(int *digest_list)
 {
-    if (id && (strcmp(id, engine_afalg_id) != 0))
-        return 0;
+    size_t i;
 
-    if (!afalg_chk_platform())
-        return 0;
+    for (i = 0; i < OSSL_NELEM(digest_data); i++)
+        digest_list[i] = 1;
+}
 
-    if (!bind_afalg(e))
+static int afalg_select_digest_cb(const char *str, int len, void *usr)
+{
+    int *digest_list = (int *)usr;
+    char *name;
+    const EVP_MD *EVP;
+    size_t i;
+
+    if (len == 0)
+        return 1;
+    if (usr == NULL || (name = OPENSSL_strndup(str, len)) == NULL)
         return 0;
+    EVP = EVP_get_digestbyname(name);
+    if (EVP == NULL)
+        fprintf(stderr, "afalg: unknown digest %s\n", name);
+    else if ((i = find_digest_data_index(EVP_MD_type(EVP))) != (size_t)-1)
+        digest_list[i] = 1;
+    else
+        fprintf(stderr, "afalg: digest %s not available\n", name);
+    OPENSSL_free(name);
     return 1;
 }
 
-IMPLEMENT_DYNAMIC_CHECK_FN()
-    IMPLEMENT_DYNAMIC_BIND_FN(bind_helper)
-# endif
+static void dump_digest_info(void)
+{
+    size_t i;
+    const char *evp_name;
+
+    fprintf (stderr, "Information about digests supported by the AF_ALG"
+             " engine:\n");
+
+    for (i = 0; i < OSSL_NELEM(digest_data); i++) {
+        evp_name = OBJ_nid2sn(digest_data[i].nid);
+        fprintf (stderr, "Digest %s, NID=%d, AF_ALG info: name=%s, ",
+                 evp_name ? evp_name : "unknown", digest_data[i].nid,
+                 digest_data[i].name);
+        if (digest_driver_info[i].status == AFALG_STATUS_NO_OPEN) {
+            fprintf (stderr, "AF_ALG socket bind failed.\n");
+            continue;
+        }
+        fprintf(stderr, " driver=%s ", digest_driver_info[i].driver_name ?
+                 digest_driver_info[i].driver_name : "unknown");
+        if (digest_driver_info[i].accelerated == AFALG_ACCELERATED)
+            fprintf (stderr, "(hw accelerated)");
+        else if (digest_driver_info[i].accelerated == AFALG_NOT_ACCELERATED)
+            fprintf(stderr, "(software)");
+        else
+            fprintf(stderr, "(acceleration status unknown)");
+        if (digest_driver_info[i].status == AFALG_STATUS_FAILURE)
+            fprintf (stderr, ". Digest setup failed.");
+        fprintf (stderr, "\n");
+    }
+    fprintf(stderr, "\n");
+}
+
+/******************************************************************************
+ *
+ * CONTROL COMMANDS
+ *
+ *****/
+
+#define AFALG_CMD_USE_SOFTDRIVERS  ENGINE_CMD_BASE
+#define AFALG_CMD_CIPHERS         (ENGINE_CMD_BASE + 1)
+#define AFALG_CMD_DIGESTS         (ENGINE_CMD_BASE + 2)
+#define AFALG_CMD_DUMP_INFO       (ENGINE_CMD_BASE + 3)
 
-static int afalg_chk_platform(void)
+/* Helper macros for CPP string composition */
+#ifndef OPENSSL_MSTR
+# define OPENSSL_MSTR_HELPER(x) #x
+# define OPENSSL_MSTR(x) OPENSSL_MSTR_HELPER(x)
+#endif
+
+static const ENGINE_CMD_DEFN afalg_cmds[] = {
+    {AFALG_CMD_USE_SOFTDRIVERS,
+    "USE_SOFTDRIVERS",
+    "specifies whether to use software (not accelerated) drivers ("
+        OPENSSL_MSTR(AFALG_REQUIRE_ACCELERATED) "=use only accelerated drivers, "
+        OPENSSL_MSTR(AFALG_USE_SOFTWARE) "=allow all drivers, "
+        OPENSSL_MSTR(AFALG_REJECT_SOFTWARE)
+        "=use if acceleration can't be determined) [default="
+        OPENSSL_MSTR(AFALG_DEFAULT_USE_SOFDTRIVERS) "]",
+    ENGINE_CMD_FLAG_NUMERIC},
+
+    {AFALG_CMD_CIPHERS,
+     "CIPHERS",
+     "either ALL, NONE, or a comma-separated list of ciphers to enable [default=ALL]",
+     ENGINE_CMD_FLAG_STRING},
+
+   {AFALG_CMD_DIGESTS,
+     "DIGESTS",
+     "either ALL, NONE, or a comma-separated list of digests to enable [default=NONE]",
+     ENGINE_CMD_FLAG_STRING},
+
+   {AFALG_CMD_DUMP_INFO,
+     "DUMP_INFO",
+     "dump info about each algorithm to stderr; use 'openssl engine -pre DUMP_INFO afalg'",
+     ENGINE_CMD_FLAG_NO_INPUT},
+
+    {0, NULL, NULL, 0}
+};
+
+static int afalg_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
 {
-    int ret;
-    int i;
-    int kver[3] = { -1, -1, -1 };
-    int sock;
-    char *str;
-    struct utsname ut;
+    int *new_list;
+
+    switch(cmd) {
+    case AFALG_CMD_USE_SOFTDRIVERS:
+        switch(i) {
+        case AFALG_REQUIRE_ACCELERATED:
+        case AFALG_USE_SOFTWARE:
+        case AFALG_REJECT_SOFTWARE:
+            break;
+        default:
+            fprintf(stderr, "afalg: invalid value (%ld) for USE_SOFTDRIVERS\n", i);
+            return 0;
+        }
+        if (use_softdrivers == i)
+            return 1;
+        use_softdrivers = i;
+        rebuild_known_digest_nids(e);
+        rebuild_known_cipher_nids(e);
+        return 1;
+
+    case AFALG_CMD_CIPHERS:
+        if (p == NULL)
+            return 1;
+        if (strcasecmp((const char *)p, "ALL") == 0) {
+            afalg_select_all_ciphers(selected_ciphers);
+        } else if (strcasecmp((const char*)p, "NONE") == 0) {
+            memset(selected_ciphers, 0, sizeof(selected_ciphers));
+        } else {
+            new_list=OPENSSL_zalloc(sizeof(selected_ciphers));
+            if (!CONF_parse_list(p, ',', 1, afalg_select_cipher_cb, new_list)) {
+                OPENSSL_free(new_list);
+                return 0;
+            }
+            memcpy(selected_ciphers, new_list, sizeof(selected_ciphers));
+            OPENSSL_free(new_list);
+        }
+        rebuild_known_cipher_nids(e);
+        return 1;
+
+    case AFALG_CMD_DIGESTS:
+        if (p == NULL)
+            return 1;
+        if (strcasecmp((const char *)p, "ALL") == 0) {
+            afalg_select_all_digests(selected_digests);
+        } else if (strcasecmp((const char*)p, "NONE") == 0) {
+            memset(selected_digests, 0, sizeof(selected_digests));
+        } else {
+            new_list=OPENSSL_zalloc(sizeof(selected_digests));
+            if (!CONF_parse_list(p, ',', 1, afalg_select_digest_cb, new_list)) {
+                OPENSSL_free(new_list);
+                return 0;
+            }
+            memcpy(selected_digests, new_list, sizeof(selected_digests));
+            OPENSSL_free(new_list);
+        }
+        rebuild_known_digest_nids(e);
+        return 1;
 
-    ret = uname(&ut);
-    if (ret != 0) {
-        AFALGerr(AFALG_F_AFALG_CHK_PLATFORM,
-                 AFALG_R_FAILED_TO_GET_PLATFORM_INFO);
-        return 0;
-    }
+    case AFALG_CMD_DUMP_INFO:
+        if (afalg_alg_list_count < 0)
+            fprintf (stderr, "Could not get driver info through the netlink"
+                     " interface.\nIs the 'crypto_user' module loaded?\n");
+        dump_cipher_info();
+        dump_digest_info();
+        return 1;
 
-    str = strtok(ut.release, ".");
-    for (i = 0; i < 3 && str != NULL; i++) {
-        kver[i] = atoi(str);
-        str = strtok(NULL, ".");
+    default:
+        break;
     }
+    return 0;
+}
+
+/******************************************************************************
+ *
+ * LOAD / UNLOAD
+ *
+ *****/
+
+static int afalg_unload(ENGINE *e)
+{
+    destroy_all_cipher_methods();
+    destroy_all_digest_methods();
 
-    if (KERNEL_VERSION(kver[0], kver[1], kver[2])
-        < KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2)) {
-        ALG_ERR("ASYNC AFALG not supported this kernel(%d.%d.%d)\n",
-                 kver[0], kver[1], kver[2]);
-        ALG_ERR("ASYNC AFALG requires kernel version %d.%d.%d or later\n",
-                 K_MAJ, K_MIN1, K_MIN2);
-        AFALGerr(AFALG_F_AFALG_CHK_PLATFORM,
-                 AFALG_R_KERNEL_DOES_NOT_SUPPORT_ASYNC_AFALG);
+    return 1;
+}
+
+
+static int bind_afalg(ENGINE *e) {
+    if (!ENGINE_set_id(e, engine_afalg_id)
+        || !ENGINE_set_name(e, "AF_ALG engine")
+        || !ENGINE_set_destroy_function(e, afalg_unload)
+        || !ENGINE_set_cmd_defns(e, afalg_cmds)
+        || !ENGINE_set_ctrl_function(e, afalg_ctrl))
         return 0;
-    }
+
+    prepare_afalg_alg_list();
+    prepare_cipher_methods();
+    prepare_digest_methods();
+    OPENSSL_free(afalg_alg_list);
+    if (afalg_alg_list_count > 0)
+        afalg_alg_list_count = 0;
+    return ENGINE_set_ciphers(e, afalg_ciphers) &&
+        ENGINE_set_digests(e, afalg_digests);
+}
+
+static int test_afalg_socket(void)
+{
+    int sock;
 
     /* Test if we can actually create an AF_ALG socket */
     sock = socket(AF_ALG, SOCK_SEQPACKET, 0);
     if (sock == -1) {
-        AFALGerr(AFALG_F_AFALG_CHK_PLATFORM, AFALG_R_SOCKET_CREATE_FAILED);
+        fprintf(stderr, "Could not create AF_ALG socket: %s\n", strerror(errno));
         return 0;
     }
     close(sock);
-
     return 1;
 }
 
-# ifdef OPENSSL_NO_DYNAMIC_ENGINE
-static ENGINE *engine_afalg(void)
-{
-    ENGINE *ret = ENGINE_new();
-    if (ret == NULL)
-        return NULL;
-    if (!bind_afalg(ret)) {
-        ENGINE_free(ret);
-        return NULL;
-    }
-    return ret;
-}
-
+#ifdef OPENSSL_NO_DYNAMIC_ENGINE
 void engine_load_afalg_int(void)
 {
-    ENGINE *toadd;
+    ENGINE *e = NULL;
 
-    if (!afalg_chk_platform())
+    if (!test_afalg_socket() || (e = ENGINE_new()) == NULL)
         return;
 
-    toadd = engine_afalg();
-    if (toadd == NULL)
+    if (!bind_afalg(e)) {
+        ENGINE_free(e);
         return;
-    ENGINE_add(toadd);
-    ENGINE_free(toadd);
+    }
+
+    ENGINE_add(e);
+    ENGINE_free(e);
     ERR_clear_error();
 }
-# endif
 
-static int afalg_init(ENGINE *e)
-{
-    return 1;
-}
+#else
 
-static int afalg_finish(ENGINE *e)
+static int bind_helper(ENGINE *e, const char *id)
 {
+    if ((id && (strcmp(id, engine_afalg_id) != 0))
+        || !test_afalg_socket())
+        return 0;
+    if (!bind_afalg(e))
+        return 0;
     return 1;
 }
 
-static int free_cbc(void)
-{
-    short unsigned int i;
-    for(i = 0; i < OSSL_NELEM(afalg_cipher_nids); i++) {
-        EVP_CIPHER_meth_free(cbc_handle[i]._hidden);
-        cbc_handle[i]._hidden = NULL;
-    }
-    return 1;
-}
+IMPLEMENT_DYNAMIC_CHECK_FN()
+IMPLEMENT_DYNAMIC_BIND_FN(bind_helper)
 
-static int afalg_destroy(ENGINE *e)
-{
-    ERR_unload_AFALG_strings();
-    free_cbc();
-    return 1;
-}
+#endif
 
-#endif                          /* KERNEL VERSION */
diff --git a/engines/e_afalg.ec b/engines/e_afalg.ec
deleted file mode 100644
index 6d7420fe5c..0000000000
--- a/engines/e_afalg.ec
+++ /dev/null
@@ -1,3 +0,0 @@
-# The INPUT HEADER is scanned for declarations
-# LIBNAME       INPUT HEADER                    ERROR-TABLE FILE
-L AFALG         e_afalg_err.h                   e_afalg_err.c
diff --git a/engines/e_afalg.h b/engines/e_afalg.h
deleted file mode 100644
index 2c03c448d6..0000000000
--- a/engines/e_afalg.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the OpenSSL license (the "License").  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * https://www.openssl.org/source/license.html
- */
-
-#ifndef HEADER_AFALG_H
-# define HEADER_AFALG_H
-
-# if defined(__GNUC__) && __GNUC__ >= 4 && \
-     (!defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L)
-#  pragma GCC diagnostic ignored "-Wvariadic-macros"
-# endif
-
-# ifdef ALG_DEBUG
-#  define ALG_DGB(x, ...) fprintf(stderr, "ALG_DBG: " x, __VA_ARGS__)
-#  define ALG_INFO(x, ...) fprintf(stderr, "ALG_INFO: " x, __VA_ARGS__)
-#  define ALG_WARN(x, ...) fprintf(stderr, "ALG_WARN: " x, __VA_ARGS__)
-# else
-#  define ALG_DGB(x, ...)
-#  define ALG_INFO(x, ...)
-#  define ALG_WARN(x, ...)
-# endif
-
-# define ALG_ERR(x, ...) fprintf(stderr, "ALG_ERR: " x, __VA_ARGS__)
-# define ALG_PERR(x, ...) \
-                do { \
-                    fprintf(stderr, "ALG_PERR: " x, __VA_ARGS__); \
-                    perror(NULL); \
-                } while(0)
-# define ALG_PWARN(x, ...) \
-                do { \
-                    fprintf(stderr, "ALG_PERR: " x, __VA_ARGS__); \
-                    perror(NULL); \
-                } while(0)
-
-# ifndef AES_BLOCK_SIZE
-#  define AES_BLOCK_SIZE   16
-# endif
-# define AES_KEY_SIZE_128 16
-# define AES_KEY_SIZE_192 24
-# define AES_KEY_SIZE_256 32
-# define AES_IV_LEN       16
-
-# define MAX_INFLIGHTS 1
-
-typedef enum {
-    MODE_UNINIT = 0,
-    MODE_SYNC,
-    MODE_ASYNC
-} op_mode;
-
-enum {
-    AES_CBC_128 = 0,
-    AES_CBC_192,
-    AES_CBC_256
-};
-
-struct cbc_cipher_handles {
-    int key_size;
-    EVP_CIPHER *_hidden;
-};
-
-typedef struct cbc_cipher_handles cbc_handles;
-
-struct afalg_aio_st {
-    int efd;
-    op_mode mode;
-    aio_context_t aio_ctx;
-    struct io_event events[MAX_INFLIGHTS];
-    struct iocb cbt[MAX_INFLIGHTS];
-};
-typedef struct afalg_aio_st afalg_aio;
-
-/*
- * MAGIC Number to identify correct initialisation
- * of afalg_ctx.
- */
-# define MAGIC_INIT_NUM 0x1890671
-
-struct afalg_ctx_st {
-    int init_done;
-    int sfd;
-    int bfd;
-# ifdef ALG_ZERO_COPY
-    int zc_pipe[2];
-# endif
-    afalg_aio aio;
-};
-
-typedef struct afalg_ctx_st afalg_ctx;
-#endif
diff --git a/engines/e_afalg.txt b/engines/e_afalg.txt
deleted file mode 100644
index 3b79305acf..0000000000
--- a/engines/e_afalg.txt
+++ /dev/null
@@ -1,30 +0,0 @@
-# Copyright 1999-2017 The OpenSSL Project Authors. All Rights Reserved.
-#
-# Licensed under the OpenSSL license (the "License").  You may not use
-# this file except in compliance with the License.  You can obtain a copy
-# in the file LICENSE in the source distribution or at
-# https://www.openssl.org/source/license.html
-
-# Function codes
-AFALG_F_AFALG_CHK_PLATFORM:100:afalg_chk_platform
-AFALG_F_AFALG_CREATE_SK:101:afalg_create_sk
-AFALG_F_AFALG_INIT_AIO:102:afalg_init_aio
-AFALG_F_AFALG_SETUP_ASYNC_EVENT_NOTIFICATION:103:\
-	afalg_setup_async_event_notification
-AFALG_F_AFALG_SET_KEY:104:afalg_set_key
-AFALG_F_BIND_AFALG:105:bind_afalg
-
-#Reason codes
-AFALG_R_EVENTFD_FAILED:108:eventfd failed
-AFALG_R_FAILED_TO_GET_PLATFORM_INFO:111:failed to get platform info
-AFALG_R_INIT_FAILED:100:init failed
-AFALG_R_IO_SETUP_FAILED:105:io setup failed
-AFALG_R_KERNEL_DOES_NOT_SUPPORT_AFALG:101:kernel does not support afalg
-AFALG_R_KERNEL_DOES_NOT_SUPPORT_ASYNC_AFALG:107:\
-	kernel does not support async afalg
-AFALG_R_MEM_ALLOC_FAILED:102:mem alloc failed
-AFALG_R_SOCKET_ACCEPT_FAILED:110:socket accept failed
-AFALG_R_SOCKET_BIND_FAILED:103:socket bind failed
-AFALG_R_SOCKET_CREATE_FAILED:109:socket create failed
-AFALG_R_SOCKET_OPERATION_FAILED:104:socket operation failed
-AFALG_R_SOCKET_SET_KEY_FAILED:106:socket set key failed
diff --git a/engines/e_afalg_err.c b/engines/e_afalg_err.c
deleted file mode 100644
index 18fe9c34e0..0000000000
--- a/engines/e_afalg_err.c
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Generated by util/mkerr.pl DO NOT EDIT
- * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the OpenSSL license (the "License").  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * https://www.openssl.org/source/license.html
- */
-
-#include <openssl/err.h>
-#include "e_afalg_err.h"
-
-#ifndef OPENSSL_NO_ERR
-
-static ERR_STRING_DATA AFALG_str_functs[] = {
-    {ERR_PACK(0, AFALG_F_AFALG_CHK_PLATFORM, 0), "afalg_chk_platform"},
-    {ERR_PACK(0, AFALG_F_AFALG_CREATE_SK, 0), "afalg_create_sk"},
-    {ERR_PACK(0, AFALG_F_AFALG_INIT_AIO, 0), "afalg_init_aio"},
-    {ERR_PACK(0, AFALG_F_AFALG_SETUP_ASYNC_EVENT_NOTIFICATION, 0),
-     "afalg_setup_async_event_notification"},
-    {ERR_PACK(0, AFALG_F_AFALG_SET_KEY, 0), "afalg_set_key"},
-    {ERR_PACK(0, AFALG_F_BIND_AFALG, 0), "bind_afalg"},
-    {0, NULL}
-};
-
-static ERR_STRING_DATA AFALG_str_reasons[] = {
-    {ERR_PACK(0, 0, AFALG_R_EVENTFD_FAILED), "eventfd failed"},
-    {ERR_PACK(0, 0, AFALG_R_FAILED_TO_GET_PLATFORM_INFO),
-    "failed to get platform info"},
-    {ERR_PACK(0, 0, AFALG_R_INIT_FAILED), "init failed"},
-    {ERR_PACK(0, 0, AFALG_R_IO_SETUP_FAILED), "io setup failed"},
-    {ERR_PACK(0, 0, AFALG_R_KERNEL_DOES_NOT_SUPPORT_AFALG),
-    "kernel does not support afalg"},
-    {ERR_PACK(0, 0, AFALG_R_KERNEL_DOES_NOT_SUPPORT_ASYNC_AFALG),
-    "kernel does not support async afalg"},
-    {ERR_PACK(0, 0, AFALG_R_MEM_ALLOC_FAILED), "mem alloc failed"},
-    {ERR_PACK(0, 0, AFALG_R_SOCKET_ACCEPT_FAILED), "socket accept failed"},
-    {ERR_PACK(0, 0, AFALG_R_SOCKET_BIND_FAILED), "socket bind failed"},
-    {ERR_PACK(0, 0, AFALG_R_SOCKET_CREATE_FAILED), "socket create failed"},
-    {ERR_PACK(0, 0, AFALG_R_SOCKET_OPERATION_FAILED),
-    "socket operation failed"},
-    {ERR_PACK(0, 0, AFALG_R_SOCKET_SET_KEY_FAILED), "socket set key failed"},
-    {0, NULL}
-};
-
-#endif
-
-static int lib_code = 0;
-static int error_loaded = 0;
-
-static int ERR_load_AFALG_strings(void)
-{
-    if (lib_code == 0)
-        lib_code = ERR_get_next_error_library();
-
-    if (!error_loaded) {
-#ifndef OPENSSL_NO_ERR
-        ERR_load_strings(lib_code, AFALG_str_functs);
-        ERR_load_strings(lib_code, AFALG_str_reasons);
-#endif
-        error_loaded = 1;
-    }
-    return 1;
-}
-
-static void ERR_unload_AFALG_strings(void)
-{
-    if (error_loaded) {
-#ifndef OPENSSL_NO_ERR
-        ERR_unload_strings(lib_code, AFALG_str_functs);
-        ERR_unload_strings(lib_code, AFALG_str_reasons);
-#endif
-        error_loaded = 0;
-    }
-}
-
-static void ERR_AFALG_error(int function, int reason, char *file, int line)
-{
-    if (lib_code == 0)
-        lib_code = ERR_get_next_error_library();
-    ERR_PUT_error(lib_code, function, reason, file, line);
-}
diff --git a/engines/e_afalg_err.h b/engines/e_afalg_err.h
deleted file mode 100644
index 3eb1332bbf..0000000000
--- a/engines/e_afalg_err.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Generated by util/mkerr.pl DO NOT EDIT
- * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the OpenSSL license (the "License").  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * https://www.openssl.org/source/license.html
- */
-
-#ifndef HEADER_AFALGERR_H
-# define HEADER_AFALGERR_H
-
-# define AFALGerr(f, r) ERR_AFALG_error((f), (r), OPENSSL_FILE, OPENSSL_LINE)
-
-
-/*
- * AFALG function codes.
- */
-# define AFALG_F_AFALG_CHK_PLATFORM                       100
-# define AFALG_F_AFALG_CREATE_SK                          101
-# define AFALG_F_AFALG_INIT_AIO                           102
-# define AFALG_F_AFALG_SETUP_ASYNC_EVENT_NOTIFICATION     103
-# define AFALG_F_AFALG_SET_KEY                            104
-# define AFALG_F_BIND_AFALG                               105
-
-/*
- * AFALG reason codes.
- */
-# define AFALG_R_EVENTFD_FAILED                           108
-# define AFALG_R_FAILED_TO_GET_PLATFORM_INFO              111
-# define AFALG_R_INIT_FAILED                              100
-# define AFALG_R_IO_SETUP_FAILED                          105
-# define AFALG_R_KERNEL_DOES_NOT_SUPPORT_AFALG            101
-# define AFALG_R_KERNEL_DOES_NOT_SUPPORT_ASYNC_AFALG      107
-# define AFALG_R_MEM_ALLOC_FAILED                         102
-# define AFALG_R_SOCKET_ACCEPT_FAILED                     110
-# define AFALG_R_SOCKET_BIND_FAILED                       103
-# define AFALG_R_SOCKET_CREATE_FAILED                     109
-# define AFALG_R_SOCKET_OPERATION_FAILED                  104
-# define AFALG_R_SOCKET_SET_KEY_FAILED                    106
-
-#endif
