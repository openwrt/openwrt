--- a/ath_hal/ah_os.c
+++ b/ath_hal/ah_os.c
@@ -917,9 +917,56 @@
  * NB: see the comments in ah_osdep.h about byte-swapping register
  *     reads and writes to understand what's going on below.
  */
+
+#ifdef CONFIG_IFXMIPS
+extern int ifxmips_has_brn_block(void);
+static int ifxmips_emulate = 0;
+#define EEPROM_EMULATION 1
+#endif
+
+#ifdef EEPROM_EMULATION
+static int ath_hal_eeprom(struct ath_hal *ah, unsigned long addr, int val, int write)
+{
+	static int addrsel = 0;
+	static int rc = 0;
+
+	if (write) {
+		if(addr == 0x6000) {
+			addrsel = val * 2;
+			rc = 0;
+		}
+	} else {
+		switch(addr)
+		{
+		case 0x600c:
+			if(rc++ < 2)
+				val = 0x00000000;
+			else
+				val = 0x00000002;
+			break;
+		case 0x6004:
+			val = cpu_to_le16(__raw_readw((u16 *) KSEG1ADDR(0xb07f0400 + addrsel)));
+			/* this forces the regdomain to 0x00 (worldwide), as the original setting
+			 * causes issues with the HAL */
+			if (addrsel == 0x17e)
+				val = 0;
+			break;
+		}
+	}
+	return val;
+}
+#endif
+
 void __ahdecl
 ath_hal_reg_write(struct ath_hal *ah, u_int address, u_int32_t value)
 {
+#ifdef EEPROM_EMULATION
+	if((address >= 0x6000) && (address <= 0x6010) && ifxmips_emulate) {
+		ath_hal_eeprom(ah, address, value, 1);
+		return;
+	}
+#endif
+
 	_trace_regop(ah, REGOP_WRITE, address, value);
 	_OS_REG_WRITE(ah, address, value);
 }
@@ -929,7 +976,14 @@
 u_int32_t __ahdecl
 ath_hal_reg_read(struct ath_hal *ah, u_int address)
 {
- 	u_int32_t val = _OS_REG_READ(ah, address);
+	u_int32_t val;
+
+#ifdef EEPROM_EMULATION
+	if((address >= 0x6000) && (address <= 0x6010) && ifxmips_emulate)
+		val = ath_hal_eeprom(ah, address, 0, 0);
+	else
+#endif
+		val = _OS_REG_READ(ah, address);
 	_trace_regop(ah, REGOP_READ, address, val);
 	return val;
 }
@@ -1123,6 +1177,9 @@
 #ifdef MMIOTRACE
 	kmmio_logmsg = _kmmio_logmsg;
 #endif
+#ifdef CONFIG_IFXMIPS
+	ifxmips_emulate = ifxmips_has_brn_block();
+#endif
 
 	sep = "";
 	for (i = 0; ath_hal_buildopts[i] != NULL; i++) {
