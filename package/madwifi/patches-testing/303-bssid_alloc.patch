--- a/ath/if_ath.c
+++ b/ath/if_ath.c
@@ -1347,11 +1347,12 @@
 			TAILQ_FOREACH(v, &ic->ic_vaps, iv_next)
 				id_mask |= (1 << ATH_GET_VAP_ID(v->iv_myaddr));
 
-			for (id = 1; id < ath_maxvaps; id++) {
+			for (id = 0; id < ath_maxvaps; id++) {
 				/* Get the first available slot. */
 				if ((id_mask & (1 << id)) == 0) {
 					ATH_SET_VAP_BSSID(vap->iv_myaddr, id);
 					ATH_SET_VAP_BSSID(vap->iv_bssid, id);
+					sc->sc_bclast = id;
 					break;
 				}
 			}
@@ -1359,7 +1360,12 @@
 			EPRINTF(sc, "Unique BSSID requested on HW that does"
 				"does not support the necessary features.");
 		}
+	} else {
+		/* share the BSSID of the last created VAP */
+		ATH_SET_VAP_BSSID(vap->iv_myaddr, sc->sc_bclast);
+		ATH_SET_VAP_BSSID(vap->iv_bssid, sc->sc_bclast);
 	}
+
 	avp->av_bslot = -1;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
 	atomic_set(&avp->av_beacon_alloc, 0);
--- a/ath/if_athvar.h
+++ b/ath/if_athvar.h
@@ -802,7 +802,7 @@
 	} sc_updateslot;			/* slot time update fsm */
 	int sc_slotupdate;			/* slot to next advance fsm */
 	struct ieee80211vap **sc_bslot;		/* beacon xmit slots */
-	int sc_bnext;				/* next slot for beacon xmit */
+	int sc_bclast;				/* last used slot for beacon xmit */
 
 	int sc_beacon_cal;			/* use beacon timer for calibration */
 	long unsigned int sc_calinterval_sec;	/* current interval for calibration (in seconds) */
