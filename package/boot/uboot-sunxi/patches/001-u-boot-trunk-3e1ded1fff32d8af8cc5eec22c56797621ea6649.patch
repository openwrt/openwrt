diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/bcm281xx/clk-bcm281xx.c u-boot/arch/arm/cpu/armv7/bcm281xx/clk-bcm281xx.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/bcm281xx/clk-bcm281xx.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/bcm281xx/clk-bcm281xx.c	2015-01-01 17:34:32.005507318 +0100
@@ -209,6 +209,10 @@
 	.gate		= SW_ONLY_GATE(0x0360, 20, 4),
 };
 
+static struct bus_clk_data usb_otg_ahb_data = {
+	.gate		= HW_SW_GATE_AUTO(0x0348, 16, 0, 1),
+};
+
 static struct bus_clk_data sdio1_ahb_data = {
 	.gate		= HW_SW_GATE_AUTO(0x0358, 16, 0, 1),
 };
@@ -331,6 +335,17 @@
  */
 
 /* KPM bus clocks */
+static struct bus_clock usb_otg_ahb_clk = {
+	.clk = {
+		.name = "usb_otg_ahb_clk",
+		.parent = &kpm_ccu_clk.clk,
+		.ops = &bus_clk_ops,
+		.ccu_clk_mgr_base = KONA_MST_CLK_BASE_ADDR,
+	},
+	.freq_tbl = master_ahb_freq_tbl,
+	.data = &usb_otg_ahb_data,
+};
+
 static struct bus_clock sdio1_ahb_clk = {
 	.clk = {
 		.name = "sdio1_ahb_clk",
@@ -541,6 +556,7 @@
 	CLK_LK(bsc2),
 	CLK_LK(bsc3),
 	/* Bus clocks */
+	CLK_LK(usb_otg_ahb),
 	CLK_LK(sdio1_ahb),
 	CLK_LK(sdio2_ahb),
 	CLK_LK(sdio3_ahb),
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/bcm281xx/clk-usb-otg.c u-boot/arch/arm/cpu/armv7/bcm281xx/clk-usb-otg.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/bcm281xx/clk-usb-otg.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/bcm281xx/clk-usb-otg.c	2015-01-01 17:34:32.005507318 +0100
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2014 Broadcom Corporation.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/arch/sysmap.h>
+#include "clk-core.h"
+
+/* Enable appropriate clocks for the USB OTG port */
+int clk_usb_otg_enable(void *base)
+{
+	char *ahbstr;
+
+	switch ((u32) base) {
+	case HSOTG_BASE_ADDR:
+		ahbstr = "usb_otg_ahb_clk";
+		break;
+	default:
+		printf("%s: base 0x%p not found\n", __func__, base);
+		return -EINVAL;
+	}
+
+	return clk_get_and_enable(ahbstr);
+}
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/bcm281xx/Makefile u-boot/arch/arm/cpu/armv7/bcm281xx/Makefile
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/bcm281xx/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/bcm281xx/Makefile	2015-01-01 17:34:32.005507318 +0100
@@ -10,3 +10,4 @@
 obj-y	+= clk-sdio.o
 obj-y	+= clk-bsc.o
 obj-$(CONFIG_BCM_SF2_ETH) += clk-eth.o
+obj-y	+= clk-usb-otg.o
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/kona-common/clk-stubs.c u-boot/arch/arm/cpu/armv7/kona-common/clk-stubs.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/kona-common/clk-stubs.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/kona-common/clk-stubs.c	2015-01-01 17:34:32.009507252 +0100
@@ -19,3 +19,8 @@
 {
 	return 0;
 }
+
+int __weak clk_usb_otg_enable(void *base)
+{
+	return 0;
+}
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/cpu.c u-boot/arch/arm/cpu/armv7/ls102xa/cpu.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/cpu.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/ls102xa/cpu.c	2015-01-01 17:34:32.009507252 +0100
@@ -12,6 +12,8 @@
 #include <netdev.h>
 #include <fsl_esdhc.h>
 
+#include "fsl_epu.h"
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #if defined(CONFIG_DISPLAY_CPUINFO)
@@ -101,3 +103,35 @@
 
 	return 0;
 }
+
+int arch_cpu_init(void)
+{
+	void *epu_base = (void *)(CONFIG_SYS_DCSRBAR + EPU_BLOCK_OFFSET);
+
+	/*
+	 * After wakeup from deep sleep, Clear EPU registers
+	 * as early as possible to prevent from possible issue.
+	 * It's also safe to clear at normal boot.
+	 */
+	fsl_epu_clean(epu_base);
+
+	return 0;
+}
+
+#if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_ARMV7_VIRT)
+/* Set the address at which the secondary core starts from.*/
+void smp_set_core_boot_addr(unsigned long addr, int corenr)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+
+	out_be32(&gur->scratchrw[0], addr);
+}
+
+/* Release the secondary core from holdoff state and kick it */
+void smp_kick_all_cpus(void)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+
+	out_be32(&gur->brrl, 0x2);
+}
+#endif
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/fdt.c u-boot/arch/arm/cpu/armv7/ls102xa/fdt.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/fdt.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/ls102xa/fdt.c	2015-01-01 17:34:32.009507252 +0100
@@ -91,7 +91,7 @@
 	}
 
 	do_fixup_by_prop_u32(blob, "device_type", "soc",
-			     4, "bus-frequency", busclk / 2, 1);
+			     4, "bus-frequency", busclk, 1);
 
 	ft_fixup_enet_phy_connect_type(blob);
 
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/fsl_epu.c u-boot/arch/arm/cpu/armv7/ls102xa/fsl_epu.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/fsl_epu.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/ls102xa/fsl_epu.c	2015-01-01 17:34:32.009507252 +0100
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+
+#include "fsl_epu.h"
+
+/**
+ * fsl_epu_clean - Clear EPU registers
+ */
+void fsl_epu_clean(void *epu_base)
+{
+	u32 offset;
+
+	/* follow the exact sequence to clear the registers */
+	/* Clear EPACRn */
+	for (offset = EPACR0; offset <= EPACR15; offset += EPACR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPEVTCRn */
+	for (offset = EPEVTCR0; offset <= EPEVTCR9; offset += EPEVTCR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPGCR */
+	out_be32(epu_base + EPGCR, 0);
+
+	/* Clear EPSMCRn */
+	for (offset = EPSMCR0; offset <= EPSMCR15; offset += EPSMCR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPCCRn */
+	for (offset = EPCCR0; offset <= EPCCR31; offset += EPCCR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPCMPRn */
+	for (offset = EPCMPR0; offset <= EPCMPR31; offset += EPCMPR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPCTRn */
+	for (offset = EPCTR0; offset <= EPCTR31; offset += EPCTR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPIMCRn */
+	for (offset = EPIMCR0; offset <= EPIMCR31; offset += EPIMCR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPXTRIGCRn */
+	out_be32(epu_base + EPXTRIGCR, 0);
+
+	/* Clear EPECRn */
+	for (offset = EPECR0; offset <= EPECR15; offset += EPECR_STRIDE)
+		out_be32(epu_base + offset, 0);
+}
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/fsl_epu.h u-boot/arch/arm/cpu/armv7/ls102xa/fsl_epu.h
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/fsl_epu.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/ls102xa/fsl_epu.h	2015-01-01 17:34:32.009507252 +0100
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_EPU_H
+#define __FSL_EPU_H
+
+#include <asm/types.h>
+
+#define FSL_STRIDE_4B	4
+#define FSL_STRIDE_8B	8
+
+/* Block offsets */
+#define EPU_BLOCK_OFFSET	0x00000000
+
+/* EPGCR (Event Processor Global Control Register) */
+#define EPGCR		0x000
+
+/* EPEVTCR0-9 (Event Processor EVT Pin Control Registers) */
+#define EPEVTCR0	0x050
+#define EPEVTCR9	0x074
+#define EPEVTCR_STRIDE	FSL_STRIDE_4B
+
+/* EPXTRIGCR (Event Processor Crosstrigger Control Register) */
+#define EPXTRIGCR	0x090
+
+/* EPIMCR0-31 (Event Processor Input Mux Control Registers) */
+#define EPIMCR0		0x100
+#define EPIMCR31	0x17C
+#define EPIMCR_STRIDE	FSL_STRIDE_4B
+
+/* EPSMCR0-15 (Event Processor SCU Mux Control Registers) */
+#define EPSMCR0		0x200
+#define EPSMCR15	0x278
+#define EPSMCR_STRIDE	FSL_STRIDE_8B
+
+/* EPECR0-15 (Event Processor Event Control Registers) */
+#define EPECR0		0x300
+#define EPECR15		0x33C
+#define EPECR_STRIDE	FSL_STRIDE_4B
+
+/* EPACR0-15 (Event Processor Action Control Registers) */
+#define EPACR0		0x400
+#define EPACR15		0x43C
+#define EPACR_STRIDE	FSL_STRIDE_4B
+
+/* EPCCRi0-15 (Event Processor Counter Control Registers) */
+#define EPCCR0		0x800
+#define EPCCR15		0x83C
+#define EPCCR31		0x87C
+#define EPCCR_STRIDE	FSL_STRIDE_4B
+
+/* EPCMPR0-15 (Event Processor Counter Compare Registers) */
+#define EPCMPR0		0x900
+#define EPCMPR15	0x93C
+#define EPCMPR31	0x97C
+#define EPCMPR_STRIDE	FSL_STRIDE_4B
+
+/* EPCTR0-31 (Event Processor Counter Register) */
+#define EPCTR0		0xA00
+#define EPCTR31		0xA7C
+#define EPCTR_STRIDE	FSL_STRIDE_4B
+
+void fsl_epu_clean(void *epu_base);
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/Makefile u-boot/arch/arm/cpu/armv7/ls102xa/Makefile
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/ls102xa/Makefile	2015-01-01 17:34:32.009507252 +0100
@@ -7,6 +7,8 @@
 obj-y	+= cpu.o
 obj-y	+= clock.o
 obj-y	+= timer.o
+obj-y	+= fsl_epu.o
 
 obj-$(CONFIG_OF_LIBFDT) += fdt.o
 obj-$(CONFIG_SYS_HAS_SERDES) += fsl_ls1_serdes.o ls102xa_serdes.o
+obj-$(CONFIG_SPL) += spl.o
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/spl.c u-boot/arch/arm/cpu/armv7/ls102xa/spl.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/ls102xa/spl.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/ls102xa/spl.c	2015-01-01 17:34:32.009507252 +0100
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <spl.h>
+
+u32 spl_boot_device(void)
+{
+#ifdef CONFIG_SPL_MMC_SUPPORT
+	return BOOT_DEVICE_MMC1;
+#endif
+	return BOOT_DEVICE_NAND;
+}
+
+u32 spl_boot_mode(void)
+{
+	switch (spl_boot_device()) {
+	case BOOT_DEVICE_MMC1:
+#ifdef CONFIG_SPL_FAT_SUPPORT
+		return MMCSD_MODE_FAT;
+#else
+		return MMCSD_MODE_RAW;
+#endif
+	case BOOT_DEVICE_NAND:
+		return 0;
+	default:
+		puts("spl: error: unsupported device\n");
+		hang();
+	}
+}
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/Makefile u-boot/arch/arm/cpu/armv7/Makefile
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/Makefile	2015-01-01 17:34:32.001507383 +0100
@@ -56,6 +56,7 @@
 obj-$(CONFIG_RMOBILE) += rmobile/
 obj-$(CONFIG_ARCH_S5PC1XX) += s5pc1xx/
 obj-$(CONFIG_SOCFPGA) += socfpga/
+obj-$(if $(filter stv0991,$(SOC)),y) += stv0991/
 obj-$(CONFIG_ARCH_SUNXI) += sunxi/
 obj-$(CONFIG_TEGRA20) += tegra20/
 obj-$(CONFIG_U8500) += u8500/
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/mx6/clock.c u-boot/arch/arm/cpu/armv7/mx6/clock.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/mx6/clock.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/mx6/clock.c	2015-01-01 17:34:32.009507252 +0100
@@ -443,7 +443,7 @@
 	struct anatop_regs __iomem *anatop =
 		(struct anatop_regs __iomem *)ANATOP_BASE_ADDR;
 
-	if (freq < ENET_25MHz || freq > ENET_125MHz)
+	if (freq < ENET_25MHZ || freq > ENET_125MHZ)
 		return -EINVAL;
 
 	reg = readl(&anatop->pll_enet);
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/nonsec_virt.S u-boot/arch/arm/cpu/armv7/nonsec_virt.S
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/nonsec_virt.S	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/nonsec_virt.S	2015-01-01 17:34:32.013507186 +0100
@@ -169,11 +169,11 @@
  * we do this here instead.
  * But first check if we have the generic timer.
  */
-#ifdef CONFIG_SYS_CLK_FREQ
+#ifdef CONFIG_TIMER_CLK_FREQ
 	mrc	p15, 0, r0, c0, c1, 1		@ read ID_PFR1
 	and	r0, r0, #CPUID_ARM_GENTIMER_MASK	@ mask arch timer bits
 	cmp	r0, #(1 << CPUID_ARM_GENTIMER_SHIFT)
-	ldreq	r1, =CONFIG_SYS_CLK_FREQ
+	ldreq	r1, =CONFIG_TIMER_CLK_FREQ
 	mcreq	p15, 0, r1, c14, c0, 0		@ write CNTFRQ
 #endif
 
@@ -191,6 +191,9 @@
 	wfi
 	ldr	r1, =CONFIG_SMP_PEN_ADDR	@ load start address
 	ldr	r1, [r1]
+#ifdef CONFIG_PEN_ADDR_BIG_ENDIAN
+	rev	r1, r1
+#endif
 	cmp	r0, r1			@ make sure we dont execute this code
 	beq	smp_waitloop		@ again (due to a spurious wakeup)
 	mov	r0, r1
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/socfpga/freeze_controller.c u-boot/arch/arm/cpu/armv7/socfpga/freeze_controller.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/socfpga/freeze_controller.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/socfpga/freeze_controller.c	2015-01-01 17:34:32.021507054 +0100
@@ -38,8 +38,7 @@
 	/* Freeze channel 0 to 2 */
 	for (channel_id = 0; channel_id <= 2; channel_id++) {
 		ioctrl_reg_offset = (u32)(
-			&freeze_controller_base->vioctrl +
-			(channel_id << SYSMGR_FRZCTRL_VIOCTRL_SHIFT));
+			&freeze_controller_base->vioctrl + channel_id);
 
 		/*
 		 * Assert active low enrnsl, plniotri
@@ -120,8 +119,7 @@
 	/* Thaw channel 0 to 2 */
 	for (channel_id = 0; channel_id <= 2; channel_id++) {
 		ioctrl_reg_offset
-			= (u32)(&freeze_controller_base->vioctrl
-				+ (channel_id << SYSMGR_FRZCTRL_VIOCTRL_SHIFT));
+			= (u32)(&freeze_controller_base->vioctrl + channel_id);
 
 		/*
 		 * Assert active low bhniotri signal and
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/socfpga/reset_manager.c u-boot/arch/arm/cpu/armv7/socfpga/reset_manager.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/socfpga/reset_manager.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/socfpga/reset_manager.c	2015-01-01 17:34:32.021507054 +0100
@@ -110,6 +110,6 @@
 {
 	const void *reset = &reset_manager_base->per_mod_reset;
 
-	clrbits_le32(reset, 1 << RSTMGR_PERMODRST_SPIM0_LSB);
-	clrbits_le32(reset, 1 << RSTMGR_PERMODRST_SPIM1_LSB);
+	clrbits_le32(reset, (1 << RSTMGR_PERMODRST_SPIM0_LSB) |
+		     (1 << RSTMGR_PERMODRST_SPIM1_LSB));
 }
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/clock.c u-boot/arch/arm/cpu/armv7/stv0991/clock.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/clock.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/stv0991/clock.c	2015-01-01 17:34:32.025506990 +0100
@@ -0,0 +1,41 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/stv0991_cgu.h>
+#include<asm/arch/stv0991_periph.h>
+
+static struct stv0991_cgu_regs *const stv0991_cgu_regs = \
+				(struct stv0991_cgu_regs *) (CGU_BASE_ADDR);
+
+void enable_pll1(void)
+{
+	/* pll1 already configured for 1000Mhz, just need to enable it */
+	writel(readl(&stv0991_cgu_regs->pll1_ctrl) & ~(0x01),
+			&stv0991_cgu_regs->pll1_ctrl);
+}
+
+void clock_setup(int peripheral)
+{
+	switch (peripheral) {
+	case UART_CLOCK_CFG:
+		writel(UART_CLK_CFG, &stv0991_cgu_regs->uart_freq);
+		break;
+	case ETH_CLOCK_CFG:
+		enable_pll1();
+		writel(ETH_CLK_CFG, &stv0991_cgu_regs->eth_freq);
+
+		/* Clock selection for ethernet tx_clk & rx_clk*/
+		writel((readl(&stv0991_cgu_regs->eth_ctrl) & ETH_CLK_MASK)
+				| ETH_CLK_CTRL, &stv0991_cgu_regs->eth_ctrl);
+
+		break;
+	default:
+		break;
+	}
+}
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/lowlevel.S u-boot/arch/arm/cpu/armv7/stv0991/lowlevel.S
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/lowlevel.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/stv0991/lowlevel.S	2015-01-01 17:34:32.025506990 +0100
@@ -0,0 +1,12 @@
+/*
+ * (C) Copyright 2014 stmicroelectronics
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+#include <linux/linkage.h>
+
+ENTRY(lowlevel_init)
+	mov	pc, lr
+ENDPROC(lowlevel_init)
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/Makefile u-boot/arch/arm/cpu/armv7/stv0991/Makefile
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/stv0991/Makefile	2015-01-01 17:34:32.025506990 +0100
@@ -0,0 +1,9 @@
+#
+# (C) Copyright 2014
+# Vikas Manocha, ST Microelectronics, vikas.manocha@stcom
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= timer.o clock.o pinmux.o reset.o
+obj-y	+= lowlevel.o
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/pinmux.c u-boot/arch/arm/cpu/armv7/stv0991/pinmux.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/pinmux.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/stv0991/pinmux.c	2015-01-01 17:34:32.025506990 +0100
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/io.h>
+#include <asm/arch/stv0991_creg.h>
+#include <asm/arch/stv0991_periph.h>
+#include <asm/arch/hardware.h>
+
+static struct stv0991_creg *const stv0991_creg = \
+			(struct stv0991_creg *)CREG_BASE_ADDR;
+
+int stv0991_pinmux_config(int peripheral)
+{
+	switch (peripheral) {
+	case UART_GPIOC_30_31:
+		/* SSDA/SSCL pad muxing to UART Rx/Dx */
+		writel((readl(&stv0991_creg->mux12) & GPIOC_31_MUX_MASK) |
+				CFG_GPIOC_31_UART_RX,
+				&stv0991_creg->mux12);
+		writel((readl(&stv0991_creg->mux12) & GPIOC_30_MUX_MASK) |
+				CFG_GPIOC_30_UART_TX,
+				&stv0991_creg->mux12);
+		/* SSDA/SSCL pad config to push pull*/
+		writel((readl(&stv0991_creg->cfg_pad6) & GPIOC_31_MODE_MASK) |
+				CFG_GPIOC_31_MODE_PP,
+				&stv0991_creg->cfg_pad6);
+		writel((readl(&stv0991_creg->cfg_pad6) & GPIOC_30_MODE_MASK) |
+				CFG_GPIOC_30_MODE_HIGH,
+				&stv0991_creg->cfg_pad6);
+		break;
+	case UART_GPIOB_16_17:
+		/* ethernet rx_6/7 to UART Rx/Dx */
+		writel((readl(&stv0991_creg->mux7) & GPIOB_17_MUX_MASK) |
+				CFG_GPIOB_17_UART_RX,
+				&stv0991_creg->mux7);
+		writel((readl(&stv0991_creg->mux7) & GPIOB_16_MUX_MASK) |
+				CFG_GPIOB_16_UART_TX,
+				&stv0991_creg->mux7);
+		break;
+	case ETH_GPIOB_10_31_C_0_4:
+		writel(readl(&stv0991_creg->mux6) & 0x000000FF,
+				&stv0991_creg->mux6);
+		writel(0x00000000, &stv0991_creg->mux7);
+		writel(0x00000000, &stv0991_creg->mux8);
+		writel(readl(&stv0991_creg->mux9) & 0xFFF00000,
+				&stv0991_creg->mux9);
+		/* Ethernet Voltage configuration to 1.8V*/
+		writel((readl(&stv0991_creg->vdd_pad1) & VDD_ETH_PS_MASK) |
+				ETH_VDD_CFG, &stv0991_creg->vdd_pad1);
+		writel((readl(&stv0991_creg->vdd_pad1) & VDD_ETH_PS_MASK) |
+				ETH_M_VDD_CFG, &stv0991_creg->vdd_pad1);
+
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/reset.c u-boot/arch/arm/cpu/armv7/stv0991/reset.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/reset.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/stv0991/reset.c	2015-01-01 17:34:32.025506990 +0100
@@ -0,0 +1,26 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/stv0991_wdru.h>
+void reset_cpu(ulong ignored)
+{
+	puts("System is going to reboot ...\n");
+	/*
+	 * This 1 second delay will allow the above message
+	 * to be printed before reset
+	 */
+	udelay((1000 * 1000));
+
+	/* Setting bit 1 of the WDRU unit will reset the SoC */
+	writel(WDRU_RST_SYS, &stv0991_wd_ru_ptr->wdru_ctrl1);
+
+	/* system will restart */
+	while (1)
+		;
+}
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/timer.c u-boot/arch/arm/cpu/armv7/stv0991/timer.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/stv0991/timer.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/stv0991/timer.c	2015-01-01 17:34:32.025506990 +0100
@@ -0,0 +1,114 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-stv0991/hardware.h>
+#include <asm/arch-stv0991/stv0991_cgu.h>
+#include <asm/arch-stv0991/stv0991_gpt.h>
+
+static struct stv0991_cgu_regs *const stv0991_cgu_regs = \
+				(struct stv0991_cgu_regs *) (CGU_BASE_ADDR);
+
+#define READ_TIMER()	(readl(&gpt1_regs_ptr->cnt) & GPT_FREE_RUNNING)
+#define GPT_RESOLUTION	(CONFIG_STV0991_HZ_CLOCK / CONFIG_STV0991_HZ)
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define timestamp gd->arch.tbl
+#define lastdec gd->arch.lastinc
+
+int timer_init(void)
+{
+	/* Timer1 clock configuration */
+	writel(TIMER1_CLK_CFG, &stv0991_cgu_regs->tim_freq);
+	writel(readl(&stv0991_cgu_regs->cgu_enable_2) |
+			TIMER1_CLK_EN, &stv0991_cgu_regs->cgu_enable_2);
+
+	/* Stop the timer */
+	writel(readl(&gpt1_regs_ptr->cr1) & ~GPT_CR1_CEN, &gpt1_regs_ptr->cr1);
+	writel(GPT_PRESCALER_128, &gpt1_regs_ptr->psc);
+	/* Configure timer for auto-reload */
+	writel(readl(&gpt1_regs_ptr->cr1) | GPT_MODE_AUTO_RELOAD,
+			&gpt1_regs_ptr->cr1);
+
+	/* load value for free running */
+	writel(GPT_FREE_RUNNING, &gpt1_regs_ptr->arr);
+
+	/* start timer */
+	writel(readl(&gpt1_regs_ptr->cr1) | GPT_CR1_CEN,
+			&gpt1_regs_ptr->cr1);
+
+	/* Reset the timer */
+	lastdec = READ_TIMER();
+	timestamp = 0;
+
+	return 0;
+}
+
+/*
+ * timer without interrupts
+ */
+ulong get_timer(ulong base)
+{
+	return (get_timer_masked() / GPT_RESOLUTION) - base;
+}
+
+void __udelay(unsigned long usec)
+{
+	ulong tmo;
+	ulong start = get_timer_masked();
+	ulong tenudelcnt = CONFIG_STV0991_HZ_CLOCK / (1000 * 100);
+	ulong rndoff;
+
+	rndoff = (usec % 10) ? 1 : 0;
+
+	/* tenudelcnt timer tick gives 10 microsecconds delay */
+	tmo = ((usec / 10) + rndoff) * tenudelcnt;
+
+	while ((ulong) (get_timer_masked() - start) < tmo)
+		;
+}
+
+ulong get_timer_masked(void)
+{
+	ulong now = READ_TIMER();
+
+	if (now >= lastdec) {
+		/* normal mode */
+		timestamp += now - lastdec;
+	} else {
+		/* we have an overflow ... */
+		timestamp += now + GPT_FREE_RUNNING - lastdec;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+void udelay_masked(unsigned long usec)
+{
+	return udelay(usec);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	return CONFIG_STV0991_HZ;
+}
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/tegra124/Kconfig u-boot/arch/arm/cpu/armv7/tegra124/Kconfig
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/tegra124/Kconfig	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/tegra124/Kconfig	2015-01-01 17:34:32.025506990 +0100
@@ -6,6 +6,15 @@
 config TARGET_JETSON_TK1
 	bool "NVIDIA Tegra124 Jetson TK1 board"
 
+config TARGET_NYAN_BIG
+	bool "Google/NVIDIA Nyan-big Chrombook"
+	help
+	  Nyan Big is a Tegra124 clamshell board that is very similar
+	  to venice2, but it has a different panel, the sdcard CD and WP
+	  sense are flipped, and it has a different revision of the AS3722
+	  PMIC. The retail name is the Acer Chromebook 13 CB5-311-T7NN
+	  (13.3-inch HD, NVIDIA Tegra K1, 2GB).
+
 config TARGET_VENICE2
 	bool "NVIDIA Tegra124 Venice2"
 
@@ -15,6 +24,7 @@
 	default "tegra124"
 
 source "board/nvidia/jetson-tk1/Kconfig"
+source "board/nvidia/nyan-big/Kconfig"
 source "board/nvidia/venice2/Kconfig"
 
 endif
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/uniphier/init_page_table.c u-boot/arch/arm/cpu/armv7/uniphier/init_page_table.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/uniphier/init_page_table.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/uniphier/init_page_table.c	2015-01-01 17:34:32.029506924 +0100
@@ -17,11 +17,7 @@
 #define REG	DEVICE	/* IO Register: Device */
 #define DDR	DEVICE	/* DDR SDRAM: Device */
 
-#ifdef CONFIG_SPL_BUILD
 #define IS_SPL_TEXT_AREA(x)	((x) == ((CONFIG_SPL_TEXT_BASE) >> 20))
-#else
-#define IS_SPL_TEXT_AREA(x)	((x) == ((CONFIG_SYS_TEXT_BASE) >> 20))
-#endif
 
 #define IS_INIT_STACK_AREA(x)	((x) == ((CONFIG_SYS_INIT_SP_ADDR) >> 20))
 
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/armv7/vf610/generic.c u-boot/arch/arm/cpu/armv7/vf610/generic.c
--- u-boot-2015.01-rc3/arch/arm/cpu/armv7/vf610/generic.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/armv7/vf610/generic.c	2015-01-01 17:34:32.029506924 +0100
@@ -265,20 +265,21 @@
 
 	cause = readl(&src_regs->srsr);
 	writel(cause, &src_regs->srsr);
-	cause &= 0xff;
 
-	switch (cause) {
-	case 0x08:
-		return "WDOG";
-	case 0x20:
+	if (cause & SRC_SRSR_POR_RST)
+		return "POWER ON RESET";
+	else if (cause & SRC_SRSR_WDOG_A5)
+		return "WDOG A5";
+	else if (cause & SRC_SRSR_WDOG_M4)
+		return "WDOG M4";
+	else if (cause & SRC_SRSR_JTAG_RST)
 		return "JTAG HIGH-Z";
-	case 0x80:
+	else if (cause & SRC_SRSR_SW_RST)
+		return "SW RESET";
+	else if (cause & SRC_SRSR_RESETB)
 		return "EXTERNAL RESET";
-	case 0xfd:
-		return "POR";
-	default:
+	else
 		return "unknown reset";
-	}
 }
 
 int print_cpuinfo(void)
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/tegra20-common/pmu.c u-boot/arch/arm/cpu/tegra20-common/pmu.c
--- u-boot-2015.01-rc3/arch/arm/cpu/tegra20-common/pmu.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/tegra20-common/pmu.c	2015-01-01 17:34:32.037506793 +0100
@@ -6,6 +6,7 @@
  */
 
 #include <common.h>
+#include <i2c.h>
 #include <tps6586x.h>
 #include <asm/io.h>
 #include <asm/arch/tegra.h>
@@ -23,9 +24,13 @@
 #define VDD_TRANSITION_STEP	0x06	/* 150mv */
 #define VDD_TRANSITION_RATE	0x06	/* 3.52mv/us */
 
+#define PMI_I2C_ADDRESS	0x34	/* chip requires this address */
+
 int pmu_set_nominal(void)
 {
-	int core, cpu, bus;
+	struct udevice *bus, *dev;
+	int core, cpu;
+	int ret;
 
 	/* by default, the table has been filled with T25 settings */
 	switch (tegra_get_chip_sku()) {
@@ -42,12 +47,18 @@
 		return -1;
 	}
 
-	bus = tegra_i2c_get_dvc_bus_num();
-	if (bus == -1) {
+	ret = tegra_i2c_get_dvc_bus(&bus);
+	if (ret) {
 		debug("%s: Cannot find DVC I2C bus\n", __func__);
-		return -1;
+		return ret;
 	}
-	tps6586x_init(bus);
+	ret = i2c_get_chip(bus, PMI_I2C_ADDRESS, &dev);
+	if (ret) {
+		debug("%s: Cannot find DVC I2C chip\n", __func__);
+		return ret;
+	}
+
+	tps6586x_init(dev);
 	tps6586x_set_pwm_mode(TPS6586X_PWM_SM1);
 	return tps6586x_adjust_sm0_sm1(core, cpu, VDD_TRANSITION_STEP,
 				VDD_TRANSITION_RATE, VDD_RELATION);
diff -ruN u-boot-2015.01-rc3/arch/arm/cpu/u-boot-spl.lds u-boot/arch/arm/cpu/u-boot-spl.lds
--- u-boot-2015.01-rc3/arch/arm/cpu/u-boot-spl.lds	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/cpu/u-boot-spl.lds	2015-01-01 17:34:32.037506793 +0100
@@ -32,6 +32,9 @@
 	}
 
 	. = ALIGN(4);
+	.u_boot_list : {
+		KEEP(*(SORT(.u_boot_list*_i2c_*)));
+	}
 
 	. = .;
 #ifdef CONFIG_SPL_DM
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/cros-ec-keyboard.dtsi u-boot/arch/arm/dts/cros-ec-keyboard.dtsi
--- u-boot-2015.01-rc3/arch/arm/dts/cros-ec-keyboard.dtsi	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/dts/cros-ec-keyboard.dtsi	2015-01-01 17:34:32.037506793 +0100
@@ -0,0 +1,105 @@
+/*
+ * Keyboard dts fragment for devices that use cros-ec-keyboard
+ *
+ * Copyright (c) 2014 Google, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <dt-bindings/input/input.h>
+
+&cros_ec {
+	keyboard-controller {
+		compatible = "google,cros-ec-keyb";
+		keypad,num-rows = <8>;
+		keypad,num-columns = <13>;
+		google,needs-ghost-filter;
+
+		linux,keymap = <
+			MATRIX_KEY(0x00, 0x01, KEY_LEFTMETA)
+			MATRIX_KEY(0x00, 0x02, KEY_F1)
+			MATRIX_KEY(0x00, 0x03, KEY_B)
+			MATRIX_KEY(0x00, 0x04, KEY_F10)
+			MATRIX_KEY(0x00, 0x06, KEY_N)
+			MATRIX_KEY(0x00, 0x08, KEY_EQUAL)
+			MATRIX_KEY(0x00, 0x0a, KEY_RIGHTALT)
+
+			MATRIX_KEY(0x01, 0x01, KEY_ESC)
+			MATRIX_KEY(0x01, 0x02, KEY_F4)
+			MATRIX_KEY(0x01, 0x03, KEY_G)
+			MATRIX_KEY(0x01, 0x04, KEY_F7)
+			MATRIX_KEY(0x01, 0x06, KEY_H)
+			MATRIX_KEY(0x01, 0x08, KEY_APOSTROPHE)
+			MATRIX_KEY(0x01, 0x09, KEY_F9)
+			MATRIX_KEY(0x01, 0x0b, KEY_BACKSPACE)
+
+			MATRIX_KEY(0x02, 0x00, KEY_LEFTCTRL)
+			MATRIX_KEY(0x02, 0x01, KEY_TAB)
+			MATRIX_KEY(0x02, 0x02, KEY_F3)
+			MATRIX_KEY(0x02, 0x03, KEY_T)
+			MATRIX_KEY(0x02, 0x04, KEY_F6)
+			MATRIX_KEY(0x02, 0x05, KEY_RIGHTBRACE)
+			MATRIX_KEY(0x02, 0x06, KEY_Y)
+			MATRIX_KEY(0x02, 0x07, KEY_102ND)
+			MATRIX_KEY(0x02, 0x08, KEY_LEFTBRACE)
+			MATRIX_KEY(0x02, 0x09, KEY_F8)
+
+			MATRIX_KEY(0x03, 0x01, KEY_GRAVE)
+			MATRIX_KEY(0x03, 0x02, KEY_F2)
+			MATRIX_KEY(0x03, 0x03, KEY_5)
+			MATRIX_KEY(0x03, 0x04, KEY_F5)
+			MATRIX_KEY(0x03, 0x06, KEY_6)
+			MATRIX_KEY(0x03, 0x08, KEY_MINUS)
+			MATRIX_KEY(0x03, 0x0b, KEY_BACKSLASH)
+
+			MATRIX_KEY(0x04, 0x00, KEY_RIGHTCTRL)
+			MATRIX_KEY(0x04, 0x01, KEY_A)
+			MATRIX_KEY(0x04, 0x02, KEY_D)
+			MATRIX_KEY(0x04, 0x03, KEY_F)
+			MATRIX_KEY(0x04, 0x04, KEY_S)
+			MATRIX_KEY(0x04, 0x05, KEY_K)
+			MATRIX_KEY(0x04, 0x06, KEY_J)
+			MATRIX_KEY(0x04, 0x08, KEY_SEMICOLON)
+			MATRIX_KEY(0x04, 0x09, KEY_L)
+			MATRIX_KEY(0x04, 0x0a, KEY_BACKSLASH)
+			MATRIX_KEY(0x04, 0x0b, KEY_ENTER)
+
+			MATRIX_KEY(0x05, 0x01, KEY_Z)
+			MATRIX_KEY(0x05, 0x02, KEY_C)
+			MATRIX_KEY(0x05, 0x03, KEY_V)
+			MATRIX_KEY(0x05, 0x04, KEY_X)
+			MATRIX_KEY(0x05, 0x05, KEY_COMMA)
+			MATRIX_KEY(0x05, 0x06, KEY_M)
+			MATRIX_KEY(0x05, 0x07, KEY_LEFTSHIFT)
+			MATRIX_KEY(0x05, 0x08, KEY_SLASH)
+			MATRIX_KEY(0x05, 0x09, KEY_DOT)
+			MATRIX_KEY(0x05, 0x0b, KEY_SPACE)
+
+			MATRIX_KEY(0x06, 0x01, KEY_1)
+			MATRIX_KEY(0x06, 0x02, KEY_3)
+			MATRIX_KEY(0x06, 0x03, KEY_4)
+			MATRIX_KEY(0x06, 0x04, KEY_2)
+			MATRIX_KEY(0x06, 0x05, KEY_8)
+			MATRIX_KEY(0x06, 0x06, KEY_7)
+			MATRIX_KEY(0x06, 0x08, KEY_0)
+			MATRIX_KEY(0x06, 0x09, KEY_9)
+			MATRIX_KEY(0x06, 0x0a, KEY_LEFTALT)
+			MATRIX_KEY(0x06, 0x0b, KEY_DOWN)
+			MATRIX_KEY(0x06, 0x0c, KEY_RIGHT)
+
+			MATRIX_KEY(0x07, 0x01, KEY_Q)
+			MATRIX_KEY(0x07, 0x02, KEY_E)
+			MATRIX_KEY(0x07, 0x03, KEY_R)
+			MATRIX_KEY(0x07, 0x04, KEY_W)
+			MATRIX_KEY(0x07, 0x05, KEY_I)
+			MATRIX_KEY(0x07, 0x06, KEY_U)
+			MATRIX_KEY(0x07, 0x07, KEY_RIGHTSHIFT)
+			MATRIX_KEY(0x07, 0x08, KEY_P)
+			MATRIX_KEY(0x07, 0x09, KEY_O)
+			MATRIX_KEY(0x07, 0x0b, KEY_UP)
+			MATRIX_KEY(0x07, 0x0c, KEY_LEFT)
+		>;
+	};
+};
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/include/dt-bindings/pinctrl/pinctrl-tegra.h u-boot/arch/arm/dts/include/dt-bindings/pinctrl/pinctrl-tegra.h
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/include/dt-bindings/reset/altr,rst-mgr.h u-boot/arch/arm/dts/include/dt-bindings/reset/altr,rst-mgr.h
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/Makefile u-boot/arch/arm/dts/Makefile
--- u-boot-2015.01-rc3/arch/arm/dts/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/dts/Makefile	2015-01-01 17:34:32.037506793 +0100
@@ -31,6 +31,7 @@
 	tegra30-tec-ng.dtb \
 	tegra114-dalmore.dtb \
 	tegra124-jetson-tk1.dtb \
+	tegra124-nyan-big.dtb \
 	tegra124-venice2.dtb
 dtb-$(CONFIG_ARCH_UNIPHIER) += \
 	uniphier-ph1-sld3-ref.dtb \
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/socfpga_cyclone5.dtsi u-boot/arch/arm/dts/socfpga_cyclone5.dtsi
--- u-boot-2015.01-rc3/arch/arm/dts/socfpga_cyclone5.dtsi	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/dts/socfpga_cyclone5.dtsi	2015-01-01 17:34:32.041506727 +0100
@@ -1,18 +1,7 @@
 /*
  *  Copyright (C) 2012 Altera Corporation <www.altera.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 /dts-v1/;
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/socfpga_cyclone5_socrates.dts u-boot/arch/arm/dts/socfpga_cyclone5_socrates.dts
--- u-boot-2015.01-rc3/arch/arm/dts/socfpga_cyclone5_socrates.dts	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/dts/socfpga_cyclone5_socrates.dts	2015-01-01 17:34:32.041506727 +0100
@@ -1,18 +1,7 @@
 /*
  *  Copyright (C) 2014 Steffen Trumtrar <s.trumtrar@pengutronix.de>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include "socfpga_cyclone5.dtsi"
@@ -25,6 +14,12 @@
 		bootargs = "console=ttyS0,115200";
 	};
 
+ 	aliases {
+		spi0 = "/spi@ff705000";		/* QSPI */
+		spi1 = "/spi@fff00000";
+		spi2 = "/spi@fff01000";
+ 	};
+
 	memory {
 		name = "memory";
 		device_type = "memory";
@@ -48,3 +43,23 @@
 &mmc {
 	status = "okay";
 };
+
+&qspi {
+	status = "okay";
+
+	flash0: n25q00@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "n25q00";
+		reg = <0>;      /* chip select */
+		spi-max-frequency = <50000000>;
+		m25p,fast-read;
+		page-size = <256>;
+		block-size = <16>; /* 2^16, 64KB */
+		read-delay = <4>;  /* delay value in read data capture register */
+		tshsl-ns = <50>;
+		tsd2d-ns = <50>;
+		tchsh-ns = <4>;
+		tslch-ns = <4>;
+	};
+};
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/socfpga.dtsi u-boot/arch/arm/dts/socfpga.dtsi
--- u-boot-2015.01-rc3/arch/arm/dts/socfpga.dtsi	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/dts/socfpga.dtsi	2015-01-01 17:34:32.041506727 +0100
@@ -1,18 +1,7 @@
 /*
  *  Copyright (C) 2012 Altera <www.altera.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include "skeleton.dtsi"
@@ -639,6 +628,49 @@
 			clock-names = "biu", "ciu";
 		};
 
+		qspi: spi@ff705000 {
+			compatible = "cadence,qspi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xff705000 0x1000>,
+				<0xffa00000 0x1000>;
+			interrupts = <0 151 4>;
+			clocks = <&qspi_clk>;
+			ext-decoder = <0>;  /* external decoder */
+			num-chipselect = <4>;
+			fifo-depth = <128>;
+			bus-num = <2>;
+			status = "disabled";
+		};
+
+		spi0: spi@fff00000 {
+			compatible = "snps,dw-spi-mmio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xfff00000 0x1000>;
+			interrupts = <0 154 4>;
+			num-chipselect = <4>;
+			bus-num = <0>;
+			tx-dma-channel = <&pdma 16>;
+			rx-dma-channel = <&pdma 17>;
+			clocks = <&per_base_clk>;
+			status = "disabled";
+		};
+
+		spi1: spi@fff01000 {
+			compatible = "snps,dw-spi-mmio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xfff01000 0x1000>;
+			interrupts = <0 156 4>;
+			num-chipselect = <4>;
+			bus-num = <1>;
+			tx-dma-channel = <&pdma 20>;
+			rx-dma-channel = <&pdma 21>;
+			clocks = <&per_base_clk>;
+			status = "disabled";
+		};
+
 		/* Local timer */
 		timer@fffec600 {
 			compatible = "arm,cortex-a9-twd-timer";
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/tegra124.dtsi u-boot/arch/arm/dts/tegra124.dtsi
--- u-boot-2015.01-rc3/arch/arm/dts/tegra124.dtsi	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/dts/tegra124.dtsi	2015-01-01 17:34:32.041506727 +0100
@@ -1,5 +1,6 @@
 #include <dt-bindings/clock/tegra124-car.h>
 #include <dt-bindings/gpio/tegra-gpio.h>
+#include <dt-bindings/pinctrl/pinctrl-tegra.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 
 #include "skeleton.dtsi"
@@ -192,6 +193,16 @@
 		status = "disabled";
 	};
 
+	pwm: pwm@7000a000 {
+		compatible = "nvidia,tegra124-pwm", "nvidia,tegra20-pwm";
+		reg = <0x7000a000 0x100>;
+		#pwm-cells = <2>;
+		clocks = <&tegra_car TEGRA124_CLK_PWM>;
+		resets = <&tegra_car 17>;
+		reset-names = "pwm";
+		status = "disabled";
+	};
+
 	spi@7000d400 {
 		compatible = "nvidia,tegra124-spi", "nvidia,tegra114-spi";
 		reg = <0x7000d400 0x200>;
@@ -290,6 +301,109 @@
 		status = "disabled";
 	};
 
+	ahub@70300000 {
+		compatible = "nvidia,tegra124-ahub";
+		reg = <0x70300000 0x200>,
+		      <0x70300800 0x800>,
+		      <0x70300200 0x600>;
+		interrupts = <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&tegra_car TEGRA124_CLK_D_AUDIO>,
+			 <&tegra_car TEGRA124_CLK_APBIF>;
+		clock-names = "d_audio", "apbif";
+		resets = <&tegra_car 106>, /* d_audio */
+			 <&tegra_car 107>, /* apbif */
+			 <&tegra_car 30>,  /* i2s0 */
+			 <&tegra_car 11>,  /* i2s1 */
+			 <&tegra_car 18>,  /* i2s2 */
+			 <&tegra_car 101>, /* i2s3 */
+			 <&tegra_car 102>, /* i2s4 */
+			 <&tegra_car 108>, /* dam0 */
+			 <&tegra_car 109>, /* dam1 */
+			 <&tegra_car 110>, /* dam2 */
+			 <&tegra_car 10>,  /* spdif */
+			 <&tegra_car 153>, /* amx */
+			 <&tegra_car 185>, /* amx1 */
+			 <&tegra_car 154>, /* adx */
+			 <&tegra_car 180>, /* adx1 */
+			 <&tegra_car 186>, /* afc0 */
+			 <&tegra_car 187>, /* afc1 */
+			 <&tegra_car 188>, /* afc2 */
+			 <&tegra_car 189>, /* afc3 */
+			 <&tegra_car 190>, /* afc4 */
+			 <&tegra_car 191>; /* afc5 */
+		reset-names = "d_audio", "apbif", "i2s0", "i2s1", "i2s2",
+			      "i2s3", "i2s4", "dam0", "dam1", "dam2",
+			      "spdif", "amx", "amx1", "adx", "adx1",
+			      "afc0", "afc1", "afc2", "afc3", "afc4", "afc5";
+		dmas = <&apbdma 1>, <&apbdma 1>,
+		       <&apbdma 2>, <&apbdma 2>,
+		       <&apbdma 3>, <&apbdma 3>,
+		       <&apbdma 4>, <&apbdma 4>,
+		       <&apbdma 6>, <&apbdma 6>,
+		       <&apbdma 7>, <&apbdma 7>,
+		       <&apbdma 12>, <&apbdma 12>,
+		       <&apbdma 13>, <&apbdma 13>,
+		       <&apbdma 14>, <&apbdma 14>,
+		       <&apbdma 29>, <&apbdma 29>;
+		dma-names = "rx0", "tx0", "rx1", "tx1", "rx2", "tx2",
+			    "rx3", "tx3", "rx4", "tx4", "rx5", "tx5",
+			    "rx6", "tx6", "rx7", "tx7", "rx8", "tx8",
+			    "rx9", "tx9";
+		ranges;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		tegra_i2s0: i2s@70301000 {
+			compatible = "nvidia,tegra124-i2s";
+			reg = <0x70301000 0x100>;
+			nvidia,ahub-cif-ids = <4 4>;
+			clocks = <&tegra_car TEGRA124_CLK_I2S0>;
+			resets = <&tegra_car 30>;
+			reset-names = "i2s";
+			status = "disabled";
+		};
+
+		tegra_i2s1: i2s@70301100 {
+			compatible = "nvidia,tegra124-i2s";
+			reg = <0x70301100 0x100>;
+			nvidia,ahub-cif-ids = <5 5>;
+			clocks = <&tegra_car TEGRA124_CLK_I2S1>;
+			resets = <&tegra_car 11>;
+			reset-names = "i2s";
+			status = "disabled";
+		};
+
+		tegra_i2s2: i2s@70301200 {
+			compatible = "nvidia,tegra124-i2s";
+			reg = <0x70301200 0x100>;
+			nvidia,ahub-cif-ids = <6 6>;
+			clocks = <&tegra_car TEGRA124_CLK_I2S2>;
+			resets = <&tegra_car 18>;
+			reset-names = "i2s";
+			status = "disabled";
+		};
+
+		tegra_i2s3: i2s@70301300 {
+			compatible = "nvidia,tegra124-i2s";
+			reg = <0x70301300 0x100>;
+			nvidia,ahub-cif-ids = <7 7>;
+			clocks = <&tegra_car TEGRA124_CLK_I2S3>;
+			resets = <&tegra_car 101>;
+			reset-names = "i2s";
+			status = "disabled";
+		};
+
+		tegra_i2s4: i2s@70301400 {
+			compatible = "nvidia,tegra124-i2s";
+			reg = <0x70301400 0x100>;
+			nvidia,ahub-cif-ids = <8 8>;
+			clocks = <&tegra_car TEGRA124_CLK_I2S4>;
+			resets = <&tegra_car 102>;
+			reset-names = "i2s";
+			status = "disabled";
+		};
+	};
+
 	usb@7d000000 {
 		compatible = "nvidia,tegra124-ehci", "nvidia,tegra30-ehci";
 		reg = <0x7d000000 0x4000>;
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/tegra124-jetson-tk1.dts u-boot/arch/arm/dts/tegra124-jetson-tk1.dts
--- u-boot-2015.01-rc3/arch/arm/dts/tegra124-jetson-tk1.dts	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/dts/tegra124-jetson-tk1.dts	2015-01-01 17:34:32.041506727 +0100
@@ -16,7 +16,6 @@
 		i2c2 = "/i2c@7000c400";
 		i2c3 = "/i2c@7000c500";
 		i2c4 = "/i2c@7000c700";
-		i2c5 = "/i2c@7000d100";
 		sdhci0 = "/sdhci@700b0600";
 		sdhci1 = "/sdhci@700b0400";
 		spi0 = "/spi@7000d400";
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/tegra124-nyan-big.dts u-boot/arch/arm/dts/tegra124-nyan-big.dts
--- u-boot-2015.01-rc3/arch/arm/dts/tegra124-nyan-big.dts	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/dts/tegra124-nyan-big.dts	2015-01-01 17:34:32.041506727 +0100
@@ -0,0 +1,365 @@
+/dts-v1/;
+
+#include <dt-bindings/input/input.h>
+#include "tegra124.dtsi"
+
+/ {
+	model = "Acer Chromebook 13 CB5-311";
+	compatible = "google,nyan-big", "nvidia,tegra124";
+
+	aliases {
+		console = &uarta;
+		i2c0 = "/i2c@7000d000";
+		i2c1 = "/i2c@7000c000";
+		i2c2 = "/i2c@7000c400";
+		i2c3 = "/i2c@7000c500";
+		i2c4 = "/i2c@7000c700";
+		i2c5 = "/i2c@7000d100";
+		rtc0 = "/i2c@0,7000d000/pmic@40";
+		rtc1 = "/rtc@0,7000e000";
+		sdhci0 = "/sdhci@700b0600";
+		sdhci1 = "/sdhci@700b0400";
+		spi0 = "/spi@7000d400";
+		spi1 = "/spi@7000da00";
+		usb0 = "/usb@7d000000";
+		usb1 = "/usb@7d008000";
+	};
+
+	memory {
+		reg = <0x80000000 0x80000000>;
+	};
+
+	serial@70006000 {
+		/* Debug connector on the bottom of the board near SD card. */
+		status = "okay";
+	};
+
+	pwm@7000a000 {
+		status = "okay";
+	};
+
+	i2c@7000c000 {
+		status = "okay";
+		clock-frequency = <100000>;
+
+		acodec: audio-codec@10 {
+			compatible = "maxim,max98090";
+			reg = <0x10>;
+			interrupt-parent = <&gpio>;
+			interrupts = <TEGRA_GPIO(H, 4) GPIO_ACTIVE_HIGH>;
+		};
+
+		temperature-sensor@4c {
+			compatible = "ti,tmp451";
+			reg = <0x4c>;
+			interrupt-parent = <&gpio>;
+			interrupts = <TEGRA_GPIO(I, 6) IRQ_TYPE_LEVEL_LOW>;
+
+			#thermal-sensor-cells = <1>;
+		};
+	};
+
+	i2c@7000c400 {
+		status = "okay";
+		clock-frequency = <100000>;
+	};
+
+	i2c@7000c500 {
+		status = "okay";
+		clock-frequency = <400000>;
+
+		tpm@20 {
+			compatible = "infineon,slb9645tt";
+			reg = <0x20>;
+		};
+	};
+
+	hdmi_ddc: i2c@7000c700 {
+		status = "okay";
+		clock-frequency = <100000>;
+	};
+
+	i2c@7000d000 {
+		status = "okay";
+		clock-frequency = <400000>;
+
+		pmic: pmic@40 {
+			compatible = "ams,as3722";
+			reg = <0x40>;
+			interrupts = <0 86 IRQ_TYPE_LEVEL_HIGH>;
+
+			ams,system-power-controller;
+
+			#interrupt-cells = <2>;
+			interrupt-controller;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&as3722_default>;
+
+			as3722_default: pinmux {
+				gpio0 {
+					pins = "gpio0";
+					function = "gpio";
+					bias-pull-down;
+				};
+
+				gpio1 {
+					pins = "gpio1";
+					function = "gpio";
+					bias-pull-up;
+				};
+
+				gpio2_4_7 {
+					pins = "gpio2", "gpio4", "gpio7";
+					function = "gpio";
+					bias-pull-up;
+				};
+
+				gpio3_6 {
+					pins = "gpio3", "gpio6";
+					bias-high-impedance;
+				};
+
+				gpio5 {
+					pins = "gpio5";
+					function = "clk32k-out";
+					bias-pull-down;
+				};
+			};
+		};
+	};
+
+	spi@7000d400 {
+		status = "okay";
+
+		cros_ec: cros-ec@0 {
+			compatible = "google,cros-ec-spi";
+			spi-max-frequency = <3000000>;
+			interrupt-parent = <&gpio>;
+			interrupts = <TEGRA_GPIO(C, 7) IRQ_TYPE_LEVEL_LOW>;
+			reg = <0>;
+
+			google,cros-ec-spi-msg-delay = <2000>;
+
+			i2c-tunnel {
+				compatible = "google,cros-ec-i2c-tunnel";
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				google,remote-bus = <0>;
+
+				charger: bq24735@9 {
+					compatible = "ti,bq24735";
+					reg = <0x9>;
+					interrupt-parent = <&gpio>;
+					interrupts = <TEGRA_GPIO(J, 0)
+							GPIO_ACTIVE_HIGH>;
+					ti,ac-detect-gpios = <&gpio
+							TEGRA_GPIO(J, 0)
+							GPIO_ACTIVE_HIGH>;
+				};
+
+				battery: sbs-battery@b {
+					compatible = "sbs,sbs-battery";
+					reg = <0xb>;
+					sbs,i2c-retry-count = <2>;
+					sbs,poll-retry-count = <10>;
+					power-supplies = <&charger>;
+				};
+			};
+		};
+	};
+
+	spi@7000da00 {
+		status = "okay";
+		spi-max-frequency = <25000000>;
+
+		flash@0 {
+			compatible = "winbond,w25q32dw";
+			reg = <0>;
+		};
+	};
+
+	pmc@7000e400 {
+		nvidia,invert-interrupt;
+		nvidia,suspend-mode = <0>;
+		nvidia,cpu-pwr-good-time = <500>;
+		nvidia,cpu-pwr-off-time = <300>;
+		nvidia,core-pwr-good-time = <641 3845>;
+		nvidia,core-pwr-off-time = <61036>;
+		nvidia,core-power-req-active-high;
+		nvidia,sys-clock-req-active-high;
+	};
+
+	hda@70030000 {
+		status = "okay";
+	};
+
+	sdhci@700b0000 { /* WiFi/BT on this bus */
+		status = "okay";
+		power-gpios = <&gpio TEGRA_GPIO(X, 7) GPIO_ACTIVE_HIGH>;
+		bus-width = <4>;
+		no-1-8-v;
+		non-removable;
+	};
+
+	sdhci@700b0400 { /* SD Card on this bus */
+		status = "okay";
+		cd-gpios = <&gpio TEGRA_GPIO(V, 2) GPIO_ACTIVE_LOW>;
+		power-gpios = <&gpio TEGRA_GPIO(R, 0) GPIO_ACTIVE_HIGH>;
+		wp-gpios = <&gpio TEGRA_GPIO(Q, 4) GPIO_ACTIVE_LOW>;
+		bus-width = <4>;
+		no-1-8-v;
+	};
+
+	sdhci@700b0600 { /* eMMC on this bus */
+		status = "okay";
+		bus-width = <8>;
+		no-1-8-v;
+		non-removable;
+	};
+
+	ahub@70300000 {
+		i2s@70301100 {
+			status = "okay";
+		};
+	};
+
+	usb@7d000000 { /* Rear external USB port. */
+		status = "okay";
+	};
+
+	usb-phy@7d000000 {
+		status = "okay";
+	};
+
+	usb@7d004000 { /* Internal webcam. */
+		status = "okay";
+	};
+
+	usb-phy@7d004000 {
+		status = "okay";
+	};
+
+	usb@7d008000 { /* Left external USB port. */
+		status = "okay";
+	};
+
+	usb-phy@7d008000 {
+		status = "okay";
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+
+		enable-gpios = <&gpio TEGRA_GPIO(H, 2) GPIO_ACTIVE_HIGH>;
+		pwms = <&pwm 1 1000000>;
+
+		default-brightness-level = <224>;
+		brightness-levels =
+			<  0   1   2   3   4   5   6   7
+			   8   9  10  11  12  13  14  15
+			  16  17  18  19  20  21  22  23
+			  24  25  26  27  28  29  30  31
+			  32  33  34  35  36  37  38  39
+			  40  41  42  43  44  45  46  47
+			  48  49  50  51  52  53  54  55
+			  56  57  58  59  60  61  62  63
+			  64  65  66  67  68  69  70  71
+			  72  73  74  75  76  77  78  79
+			  80  81  82  83  84  85  86  87
+			  88  89  90  91  92  93  94  95
+			  96  97  98  99 100 101 102 103
+			 104 105 106 107 108 109 110 111
+			 112 113 114 115 116 117 118 119
+			 120 121 122 123 124 125 126 127
+			 128 129 130 131 132 133 134 135
+			 136 137 138 139 140 141 142 143
+			 144 145 146 147 148 149 150 151
+			 152 153 154 155 156 157 158 159
+			 160 161 162 163 164 165 166 167
+			 168 169 170 171 172 173 174 175
+			 176 177 178 179 180 181 182 183
+			 184 185 186 187 188 189 190 191
+			 192 193 194 195 196 197 198 199
+			 200 201 202 203 204 205 206 207
+			 208 209 210 211 212 213 214 215
+			 216 217 218 219 220 221 222 223
+			 224 225 226 227 228 229 230 231
+			 232 233 234 235 236 237 238 239
+			 240 241 242 243 244 245 246 247
+			 248 249 250 251 252 253 254 255
+			 256>;
+	};
+
+	clocks {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		clk32k_in: clock@0 {
+			compatible = "fixed-clock";
+			reg = <0>;
+			#clock-cells = <0>;
+			clock-frequency = <32768>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		lid {
+			label = "Lid";
+			gpios = <&gpio TEGRA_GPIO(R, 4) GPIO_ACTIVE_LOW>;
+			linux,input-type = <5>;
+			linux,code = <KEY_RESERVED>;
+			debounce-interval = <1>;
+			gpio-key,wakeup;
+		};
+
+		power {
+			label = "Power";
+			gpios = <&gpio TEGRA_GPIO(Q, 0) GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_POWER>;
+			debounce-interval = <30>;
+			gpio-key,wakeup;
+		};
+	};
+
+	panel: panel {
+		compatible = "auo,b133xtn01";
+
+		backlight = <&backlight>;
+	};
+
+	sound {
+		compatible = "nvidia,tegra-audio-max98090-nyan-big",
+			     "nvidia,tegra-audio-max98090";
+		nvidia,model = "Acer Chromebook 13";
+
+		nvidia,audio-routing =
+			"Headphones", "HPR",
+			"Headphones", "HPL",
+			"Speakers", "SPKR",
+			"Speakers", "SPKL",
+			"Mic Jack", "MICBIAS",
+			"DMICL", "Int Mic",
+			"DMICR", "Int Mic",
+			"IN34", "Mic Jack";
+
+		nvidia,i2s-controller = <&tegra_i2s1>;
+		nvidia,audio-codec = <&acodec>;
+
+		clocks = <&tegra_car TEGRA124_CLK_PLL_A>,
+			 <&tegra_car TEGRA124_CLK_PLL_A_OUT0>,
+			 <&tegra_car TEGRA124_CLK_EXTERN1>;
+		clock-names = "pll_a", "pll_a_out0", "mclk";
+
+		nvidia,hp-det-gpios = <&gpio TEGRA_GPIO(I, 7) GPIO_ACTIVE_HIGH>;
+	};
+};
+
+#include "cros-ec-keyboard.dtsi"
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/tegra30-tec-ng.dts u-boot/arch/arm/dts/tegra30-tec-ng.dts
--- u-boot-2015.01-rc3/arch/arm/dts/tegra30-tec-ng.dts	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/dts/tegra30-tec-ng.dts	2015-01-01 17:34:32.045506662 +0100
@@ -6,6 +6,10 @@
 	model = "Avionic Design Tamontenâ„¢ NG Evaluation Carrier";
 	compatible = "ad,tec-ng", "nvidia,tegra30";
 
+	aliases {
+		i2c0 = "/i2c@7000c400";
+	};
+
 	/* GEN2 */
 	i2c@7000c400 {
 		status = "okay";
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/uniphier-ph1-ld4-ref.dts u-boot/arch/arm/dts/uniphier-ph1-ld4-ref.dts
--- u-boot-2015.01-rc3/arch/arm/dts/uniphier-ph1-ld4-ref.dts	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/dts/uniphier-ph1-ld4-ref.dts	2015-01-01 17:34:32.045506662 +0100
@@ -25,10 +25,10 @@
 	};
 
 	aliases {
-		uart0 = &uart0;
-		uart1 = &uart1;
-		uart2 = &uart2;
-		uart3 = &uart3;
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
 		i2c0 = &i2c0;
 		i2c1 = &i2c1;
 		i2c2 = &i2c2;
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/uniphier-ph1-pro4-ref.dts u-boot/arch/arm/dts/uniphier-ph1-pro4-ref.dts
--- u-boot-2015.01-rc3/arch/arm/dts/uniphier-ph1-pro4-ref.dts	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/dts/uniphier-ph1-pro4-ref.dts	2015-01-01 17:34:32.045506662 +0100
@@ -25,10 +25,10 @@
 	};
 
 	aliases {
-		uart0 = &uart0;
-		uart1 = &uart1;
-		uart2 = &uart2;
-		uart3 = &uart3;
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
 		i2c0 = &i2c0;
 		i2c1 = &i2c1;
 		i2c2 = &i2c2;
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/uniphier-ph1-sld3-ref.dts u-boot/arch/arm/dts/uniphier-ph1-sld3-ref.dts
--- u-boot-2015.01-rc3/arch/arm/dts/uniphier-ph1-sld3-ref.dts	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/dts/uniphier-ph1-sld3-ref.dts	2015-01-01 17:34:32.045506662 +0100
@@ -25,9 +25,9 @@
 	};
 
 	aliases {
-		uart0 = &uart0;
-		uart1 = &uart1;
-		uart2 = &uart2;
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
 		i2c0 = &i2c0;
 		i2c1 = &i2c1;
 		i2c2 = &i2c2;
diff -ruN u-boot-2015.01-rc3/arch/arm/dts/uniphier-ph1-sld8-ref.dts u-boot/arch/arm/dts/uniphier-ph1-sld8-ref.dts
--- u-boot-2015.01-rc3/arch/arm/dts/uniphier-ph1-sld8-ref.dts	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/dts/uniphier-ph1-sld8-ref.dts	2015-01-01 17:34:32.045506662 +0100
@@ -25,10 +25,10 @@
 	};
 
 	aliases {
-		uart0 = &uart0;
-		uart1 = &uart1;
-		uart2 = &uart2;
-		uart3 = &uart3;
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
 		i2c0 = &i2c0;
 		i2c1 = &i2c1;
 		i2c2 = &i2c2;
diff -ruN u-boot-2015.01-rc3/arch/arm/imx-common/cpu.c u-boot/arch/arm/imx-common/cpu.c
--- u-boot-2015.01-rc3/arch/arm/imx-common/cpu.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/imx-common/cpu.c	2015-01-01 17:34:32.045506662 +0100
@@ -206,6 +206,9 @@
 {
 #if defined(CONFIG_CMD_SATA)
 	sata_stop();
+#if defined(CONFIG_MX6)
+	disable_sata_clock();
+#endif
 #endif
 #if defined(CONFIG_VIDEO_IPUV3)
 	/* disable video before launching O/S */
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-bcm281xx/sysmap.h u-boot/arch/arm/include/asm/arch-bcm281xx/sysmap.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-bcm281xx/sysmap.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-bcm281xx/sysmap.h	2015-01-01 17:34:32.053506531 +0100
@@ -13,6 +13,8 @@
 #define ESUB_CLK_BASE_ADDR	0x38000000
 #define ESW_CONTRL_BASE_ADDR	0x38200000
 #define GPIO2_BASE_ADDR		0x35003000
+#define HSOTG_BASE_ADDR		0x3f120000
+#define HSOTG_CTRL_BASE_ADDR	0x3f130000
 #define KONA_MST_CLK_BASE_ADDR	0x3f001000
 #define KONA_SLV_CLK_BASE_ADDR	0x3e011000
 #define PMU_BSC_BASE_ADDR	0x3500d000
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-bcm2835/mbox.h u-boot/arch/arm/include/asm/arch-bcm2835/mbox.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-bcm2835/mbox.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-bcm2835/mbox.h	2015-01-01 17:34:32.053506531 +0100
@@ -140,6 +140,7 @@
 #define BCM2835_BOARD_REV_B_REV2_f	0xf
 #define BCM2835_BOARD_REV_B_PLUS	0x10
 #define BCM2835_BOARD_REV_CM		0x11
+#define BCM2835_BOARD_REV_A_PLUS	0x12
 
 struct bcm2835_mbox_tag_get_board_rev {
 	struct bcm2835_mbox_tag_hdr tag_hdr;
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-ls102xa/config.h u-boot/arch/arm/include/asm/arch-ls102xa/config.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-ls102xa/config.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-ls102xa/config.h	2015-01-01 17:34:32.065506333 +0100
@@ -11,11 +11,17 @@
 
 #define OCRAM_BASE_ADDR				0x10000000
 #define OCRAM_SIZE				0x00020000
+#define OCRAM_BASE_S_ADDR			0x10010000
+#define OCRAM_S_SIZE				0x00010000
 
 #define CONFIG_SYS_IMMR				0x01000000
+#define CONFIG_SYS_DCSRBAR			0x20000000
+
+#define CONFIG_SYS_DCSR_DCFG_ADDR	(CONFIG_SYS_DCSRBAR + 0x00220000)
 
 #define CONFIG_SYS_FSL_DDR_ADDR			(CONFIG_SYS_IMMR + 0x00080000)
 #define CONFIG_SYS_CCI400_ADDR			(CONFIG_SYS_IMMR + 0x00180000)
+#define CONFIG_SYS_FSL_CSU_ADDR                 (CONFIG_SYS_IMMR + 0x00510000)
 #define CONFIG_SYS_IFC_ADDR			(CONFIG_SYS_IMMR + 0x00530000)
 #define CONFIG_SYS_FSL_ESDHC_ADDR		(CONFIG_SYS_IMMR + 0x00560000)
 #define CONFIG_SYS_FSL_SCFG_ADDR		(CONFIG_SYS_IMMR + 0x00570000)
@@ -52,6 +58,9 @@
 
 #define LPUART_BASE				(CONFIG_SYS_IMMR + 0x01950000)
 
+#define CONFIG_SYS_PCIE1_ADDR			(CONFIG_SYS_IMMR + 0x2400000)
+#define CONFIG_SYS_PCIE2_ADDR			(CONFIG_SYS_IMMR + 0x2500000)
+
 #ifdef CONFIG_DDR_SPD
 #define CONFIG_SYS_FSL_DDR_BE
 #define CONFIG_VERY_BIG_RAM
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-ls102xa/immap_ls102xa.h u-boot/arch/arm/include/asm/arch-ls102xa/immap_ls102xa.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-ls102xa/immap_ls102xa.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-ls102xa/immap_ls102xa.h	2015-01-01 17:34:32.065506333 +0100
@@ -17,6 +17,9 @@
 #define SOC_VER_LS1021		0x11
 #define SOC_VER_LS1022		0x12
 
+#define CCSR_BRR_OFFSET		0xe4
+#define CCSR_SCRATCHRW1_OFFSET	0x200
+
 #define RCWSR0_SYS_PLL_RAT_SHIFT	25
 #define RCWSR0_SYS_PLL_RAT_MASK		0x1f
 #define RCWSR0_MEM_PLL_RAT_SHIFT	16
@@ -29,6 +32,11 @@
 #define ARCH_TIMER_CTRL_ENABLE		(1 << 0)
 #define SYS_COUNTER_CTRL_ENABLE		(1 << 24)
 
+#define DCFG_CCSR_PORSR1_RCW_MASK	0xff800000
+#define DCFG_CCSR_PORSR1_RCW_SRC_I2C	0x24800000
+
+#define DCFG_DCSR_PORCR1		0
+
 struct sys_info {
 	unsigned long freq_processor[CONFIG_MAX_CPUS];
 	unsigned long freq_systembus;
@@ -98,6 +106,7 @@
 #define SCFG_ETSECDMAMCR_LE_BD_FR	0xf8001a0f
 #define SCFG_ETSECCMCR_GE2_CLK125	0x04000000
 #define SCFG_PIXCLKCR_PXCKEN		0x80000000
+#define SCFG_QSPI_CLKSEL		0xc0100000
 
 /* Supplemental Configuration Unit */
 struct ccsr_scfg {
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-ls102xa/ls102xa_stream_id.h u-boot/arch/arm/include/asm/arch-ls102xa/ls102xa_stream_id.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-ls102xa/ls102xa_stream_id.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-ls102xa/ls102xa_stream_id.h	2015-01-01 17:34:32.065506333 +0100
@@ -0,0 +1,17 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_LS102XA_STREAM_ID_H_
+#define __FSL_LS102XA_STREAM_ID_H_
+
+struct smmu_stream_id {
+	uint16_t offset;
+	uint16_t stream_id;
+	char dev_name[32];
+};
+
+void ls102xa_config_smmu_stream_id(struct smmu_stream_id *id, uint32_t num);
+#endif
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-ls102xa/ns_access.h u-boot/arch/arm/include/asm/arch-ls102xa/ns_access.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-ls102xa/ns_access.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-ls102xa/ns_access.h	2015-01-01 17:34:32.065506333 +0100
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_NS_ACCESS_H_
+#define __FSL_NS_ACCESS_H_
+
+enum csu_cslx_access {
+	CSU_NS_SUP_R = 0x08,
+	CSU_NS_SUP_W = 0x80,
+	CSU_NS_SUP_RW = 0x88,
+	CSU_NS_USER_R = 0x04,
+	CSU_NS_USER_W = 0x40,
+	CSU_NS_USER_RW = 0x44,
+	CSU_S_SUP_R = 0x02,
+	CSU_S_SUP_W = 0x20,
+	CSU_S_SUP_RW = 0x22,
+	CSU_S_USER_R = 0x01,
+	CSU_S_USER_W = 0x10,
+	CSU_S_USER_RW = 0x11,
+	CSU_ALL_RW = 0xff,
+};
+
+enum csu_cslx_ind {
+	CSU_CSLX_PCIE2_IO = 0,
+	CSU_CSLX_PCIE1_IO,
+	CSU_CSLX_MG2TPR_IP,
+	CSU_CSLX_IFC_MEM,
+	CSU_CSLX_OCRAM,
+	CSU_CSLX_GIC,
+	CSU_CSLX_PCIE1,
+	CSU_CSLX_OCRAM2,
+	CSU_CSLX_QSPI_MEM,
+	CSU_CSLX_PCIE2,
+	CSU_CSLX_SATA,
+	CSU_CSLX_USB3,
+	CSU_CSLX_SERDES = 32,
+	CSU_CSLX_QDMA,
+	CSU_CSLX_LPUART2,
+	CSU_CSLX_LPUART1,
+	CSU_CSLX_LPUART4,
+	CSU_CSLX_LPUART3,
+	CSU_CSLX_LPUART6,
+	CSU_CSLX_LPUART5,
+	CSU_CSLX_DSPI2 = 40,
+	CSU_CSLX_DSPI1,
+	CSU_CSLX_QSPI,
+	CSU_CSLX_ESDHC,
+	CSU_CSLX_2D_ACE,
+	CSU_CSLX_IFC,
+	CSU_CSLX_I2C1,
+	CSU_CSLX_USB2,
+	CSU_CSLX_I2C3,
+	CSU_CSLX_I2C2,
+	CSU_CSLX_DUART2 = 50,
+	CSU_CSLX_DUART1,
+	CSU_CSLX_WDT2,
+	CSU_CSLX_WDT1,
+	CSU_CSLX_EDMA,
+	CSU_CSLX_SYS_CNT,
+	CSU_CSLX_DMA_MUX2,
+	CSU_CSLX_DMA_MUX1,
+	CSU_CSLX_DDR,
+	CSU_CSLX_QUICC,
+	CSU_CSLX_DCFG_CCU_RCPM = 60,
+	CSU_CSLX_SECURE_BOOTROM,
+	CSU_CSLX_SFP,
+	CSU_CSLX_TMU,
+	CSU_CSLX_SECURE_MONITOR,
+	CSU_CSLX_RESERVED0,
+	CSU_CSLX_ETSEC1,
+	CSU_CSLX_SEC5_5,
+	CSU_CSLX_ETSEC3,
+	CSU_CSLX_ETSEC2,
+	CSU_CSLX_GPIO2 = 70,
+	CSU_CSLX_GPIO1,
+	CSU_CSLX_GPIO4,
+	CSU_CSLX_GPIO3,
+	CSU_CSLX_PLATFORM_CONT,
+	CSU_CSLX_CSU,
+	CSU_CSLX_ASRC,
+	CSU_CSLX_SPDIF,
+	CSU_CSLX_FLEXCAN2,
+	CSU_CSLX_FLEXCAN1,
+	CSU_CSLX_FLEXCAN4 = 80,
+	CSU_CSLX_FLEXCAN3,
+	CSU_CSLX_SAI2,
+	CSU_CSLX_SAI1,
+	CSU_CSLX_SAI4,
+	CSU_CSLX_SAI3,
+	CSU_CSLX_FTM2,
+	CSU_CSLX_FTM1,
+	CSU_CSLX_FTM4,
+	CSU_CSLX_FTM3,
+	CSU_CSLX_FTM6 = 90,
+	CSU_CSLX_FTM5,
+	CSU_CSLX_FTM8,
+	CSU_CSLX_FTM7,
+	CSU_CSLX_COP_DCSR,
+	CSU_CSLX_EPU,
+	CSU_CSLX_GDI,
+	CSU_CSLX_DDI,
+	CSU_CSLX_RESERVED1,
+	CSU_CSLX_USB3_PHY = 117,
+	CSU_CSLX_RESERVED2,
+	CSU_CSLX_MAX,
+};
+
+struct csu_ns_dev {
+	unsigned long ind;
+	uint32_t val;
+};
+
+void enable_devices_ns_access(struct csu_ns_dev *ns_dev, uint32_t num);
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-ls102xa/spl.h u-boot/arch/arm/include/asm/arch-ls102xa/spl.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-ls102xa/spl.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-ls102xa/spl.h	2015-01-01 17:34:32.065506333 +0100
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_SPL_H__
+#define __ASM_ARCH_SPL_H__
+
+#define BOOT_DEVICE_NONE	0
+#define BOOT_DEVICE_XIP		1
+#define BOOT_DEVICE_XIPWAIT	2
+#define BOOT_DEVICE_NAND	3
+#define BOOT_DEVICE_ONENAND	4
+#define BOOT_DEVICE_MMC1	5
+#define BOOT_DEVICE_MMC2	6
+#define BOOT_DEVICE_MMC2_2	7
+#define BOOT_DEVICE_SPI		10
+
+#endif	/* __ASM_ARCH_SPL_H__ */
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-mx6/clock.h u-boot/arch/arm/include/asm/arch-mx6/clock.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-mx6/clock.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-mx6/clock.h	2015-01-01 17:34:32.073506203 +0100
@@ -43,10 +43,10 @@
 };
 
 enum enet_freq {
-	ENET_25MHz,
-	ENET_50MHz,
-	ENET_100MHz,
-	ENET_125MHz,
+	ENET_25MHZ,
+	ENET_50MHZ,
+	ENET_100MHZ,
+	ENET_125MHZ,
 };
 
 u32 imx_get_uartclk(void);
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-mx6/mx6sl_pins.h u-boot/arch/arm/include/asm/arch-mx6/mx6sl_pins.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-mx6/mx6sl_pins.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-mx6/mx6sl_pins.h	2015-01-01 17:34:32.073506203 +0100
@@ -53,5 +53,10 @@
 	MX6_PAD_FEC_REF_CLK__FEC_REF_OUT			= IOMUX_PAD(0x424, 0x134, 0x10, 0x000, 0, 0),
 	MX6_PAD_FEC_RX_ER__GPIO_4_19				= IOMUX_PAD(0x0428, 0x0138, 5, 0x0000, 0, 0),
 	MX6_PAD_FEC_TX_CLK__GPIO_4_21				= IOMUX_PAD(0x0434, 0x0144, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWRCOM__ANATOP_USBOTG1_ID			= IOMUX_PAD(0x03D0, 0x00E0, 4, 0x05DC, 0, 0),
+
+	MX6_PAD_KEY_COL4__USB_USBOTG1_PWR			= IOMUX_PAD(0x0484, 0x017C, 6, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL5__USB_USBOTG2_PWR			= IOMUX_PAD(0x0488, 0x0180, 6, 0x0000, 0, 0),
 };
 #endif	/* __ASM_ARCH_MX6_MX6SL_PINS_H__ */
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/mmc.h u-boot/arch/arm/include/asm/arch-rmobile/mmc.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/mmc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-rmobile/mmc.h	2015-01-01 17:34:32.085506005 +0100
@@ -0,0 +1,14 @@
+/*
+ * Renesas SuperH MMCIF driver.
+ *
+ * Copyright (C)  2014 Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
+ * Copyright (C)  2014 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ */
+#ifndef _RMOBILE_MMC_H_
+#define _RMOBILE_MMC_H_
+
+int mmcif_mmc_init(void);
+
+#endif /* _RMOBILE_MMC_H_ */
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/r8a7790.h u-boot/arch/arm/include/asm/arch-rmobile/r8a7790.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/r8a7790.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-rmobile/r8a7790.h	2015-01-01 17:34:32.085506005 +0100
@@ -15,6 +15,19 @@
 #define CONFIG_SYS_I2C_SH_BASE2	0xE6520000
 #define CONFIG_SYS_I2C_SH_BASE3	0xE60B0000
 
+/* Module stop control/status register bits */
+#define MSTP0_BITS	0x00640801
+#define MSTP1_BITS	0xDB6E9BDF
+#define MSTP2_BITS	0x300DA1FC
+#define MSTP3_BITS	0xF08CF831
+#define MSTP4_BITS	0x80000184
+#define MSTP5_BITS	0x44C00046
+#define MSTP7_BITS	0x07F30718
+#define MSTP8_BITS	0x01F0FF84
+#define MSTP9_BITS	0xF5979FCF
+#define MSTP10_BITS	0xFFFEFFE0
+#define MSTP11_BITS	0x00000000
+
 #define R8A7790_CUT_ES2X	2
 #define IS_R8A7790_ES2()	\
 	(rmobile_get_cpu_rev_integer() == R8A7790_CUT_ES2X)
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/r8a7791.h u-boot/arch/arm/include/asm/arch-rmobile/r8a7791.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/r8a7791.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-rmobile/r8a7791.h	2015-01-01 17:34:32.089505941 +0100
@@ -51,6 +51,19 @@
 #define DBSC3_1_QOS_W15_BASE	0xE67A2F00
 #define DBSC3_1_DBADJ2		0xE67A00C8
 
+/* Module stop control/status register bits */
+#define MSTP0_BITS	0x00640801
+#define MSTP1_BITS	0x9B6C9B5A
+#define MSTP2_BITS	0x100D21FC
+#define MSTP3_BITS	0xF08CD810
+#define MSTP4_BITS	0x800001C4
+#define MSTP5_BITS	0x44C00046
+#define MSTP7_BITS	0x05BFE618
+#define MSTP8_BITS	0x40C0FE85
+#define MSTP9_BITS	0xFF979FFF
+#define MSTP10_BITS	0xFFFEFFE0
+#define MSTP11_BITS	0x000001C0
+
 #define R8A7791_CUT_ES2X	2
 #define IS_R8A7791_ES2()	\
 	(rmobile_get_cpu_rev_integer() == R8A7791_CUT_ES2X)
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/r8a7793.h u-boot/arch/arm/include/asm/arch-rmobile/r8a7793.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/r8a7793.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-rmobile/r8a7793.h	2015-01-01 17:34:32.089505941 +0100
@@ -56,6 +56,20 @@
 /*
  * R8A7793 I/O Product Information
  */
+
+/* Module stop control/status register bits */
+#define MSTP0_BITS	0x00640801
+#define MSTP1_BITS	0x9B6C9B5A
+#define MSTP2_BITS	0x100D21FC
+#define MSTP3_BITS	0xF08CD810
+#define MSTP4_BITS	0x800001C4
+#define MSTP5_BITS	0x44C00046
+#define MSTP7_BITS	0x05BFE618
+#define MSTP8_BITS	0x40C0FE85
+#define MSTP9_BITS	0xFF979FFF
+#define MSTP10_BITS	0xFFFEFFE0
+#define MSTP11_BITS	0x000001C0
+
 #define R8A7793_CUT_ES2X	2
 #define IS_R8A7793_ES2() \
 	(rmobile_get_cpu_rev_integer() == R8A7793_CUT_ES2X)
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/r8a7794.h u-boot/arch/arm/include/asm/arch-rmobile/r8a7794.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/r8a7794.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-rmobile/r8a7794.h	2015-01-01 17:34:32.089505941 +0100
@@ -14,4 +14,17 @@
 /* SH-I2C */
 #define CONFIG_SYS_I2C_SH_BASE2	0xE60B0000
 
+/* Module stop control/status register bits */
+#define MSTP0_BITS	0x00440801
+#define MSTP1_BITS	0x936899DA
+#define MSTP2_BITS	0x100D21FC
+#define MSTP3_BITS	0xE084D810
+#define MSTP4_BITS	0x800001C4
+#define MSTP5_BITS	0x40C00044
+#define MSTP7_BITS	0x013FE618
+#define MSTP8_BITS	0x40803C05
+#define MSTP9_BITS	0xFB879FEE
+#define MSTP10_BITS	0xFFFEFFE0
+#define MSTP11_BITS	0x000001C0
+
 #endif /* __ASM_ARCH_R8A7794_H */
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/rcar-base.h u-boot/arch/arm/include/asm/arch-rmobile/rcar-base.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/rcar-base.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-rmobile/rcar-base.h	2015-01-01 17:34:32.089505941 +0100
@@ -29,6 +29,45 @@
 #define SCIF4_BASE		0xE6EE0000
 #define SCIF5_BASE		0xE6EE8000
 
+/* Module stop status register */
+#define MSTPSR0			0xE6150030
+#define MSTPSR1			0xE6150038
+#define MSTPSR2			0xE6150040
+#define MSTPSR3			0xE6150048
+#define MSTPSR4			0xE615004C
+#define MSTPSR5			0xE615003C
+#define MSTPSR7			0xE61501C4
+#define MSTPSR8			0xE61509A0
+#define MSTPSR9			0xE61509A4
+#define MSTPSR10		0xE61509A8
+#define MSTPSR11		0xE61509AC
+
+/* Realtime module stop control register */
+#define RMSTPCR0		0xE6150110
+#define RMSTPCR1		0xE6150114
+#define RMSTPCR2		0xE6150118
+#define RMSTPCR3		0xE615011C
+#define RMSTPCR4		0xE6150120
+#define RMSTPCR5		0xE6150124
+#define RMSTPCR7		0xE615012C
+#define RMSTPCR8		0xE6150980
+#define RMSTPCR9		0xE6150984
+#define RMSTPCR10		0xE6150988
+#define RMSTPCR11		0xE615098C
+
+/* System module stop control register */
+#define SMSTPCR0		0xE6150130
+#define SMSTPCR1		0xE6150134
+#define SMSTPCR2		0xE6150138
+#define SMSTPCR3		0xE615013C
+#define SMSTPCR4		0xE6150140
+#define SMSTPCR5		0xE6150144
+#define SMSTPCR7		0xE615014C
+#define SMSTPCR8		0xE6150990
+#define SMSTPCR9		0xE6150994
+#define SMSTPCR10		0xE6150998
+#define SMSTPCR11		0xE615099C
+
 /*
  * SH-I2C
  * Ch2 and ch3 are different address. These are defined
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/rcar-mstp.h u-boot/arch/arm/include/asm/arch-rmobile/rcar-mstp.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-rmobile/rcar-mstp.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-rmobile/rcar-mstp.h	2015-01-01 17:34:32.089505941 +0100
@@ -0,0 +1,109 @@
+/*
+ * arch/arm/include/asm/arch-rmobile/rcar-mstp.h
+ *
+ * Copyright (C) 2013, 2014 Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
+ * Copyright (C) 2013, 2014 Renesas Electronics Corporation
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ */
+
+#ifndef __ASM_ARCH_RCAR_MSTP_H
+#define __ASM_ARCH_RCAR_MSTP_H
+
+#define mstp_setbits(type, addr, saddr, set) \
+		out_##type((saddr), in_##type(addr) | (set))
+#define mstp_clrbits(type, addr, saddr, clear) \
+		out_##type((saddr), in_##type(addr) & ~(clear))
+#define mstp_setclrbits(type, addr, set, clear) \
+		out_##type((addr), (in_##type(addr) | (set)) & ~(clear))
+#define mstp_setbits_le32(addr, saddr, set) \
+		mstp_setbits(le32, addr, saddr, set)
+#define mstp_clrbits_le32(addr, saddr, clear) \
+		mstp_clrbits(le32, addr, saddr, clear)
+#define mstp_setclrbits_le32(addr, set, clear) \
+		mstp_setclrbits(le32, addr, set, clear)
+
+#ifndef CONFIG_SMSTP0_ENA
+#define CONFIG_SMSTP0_ENA	0x00
+#endif
+#ifndef CONFIG_SMSTP1_ENA
+#define CONFIG_SMSTP1_ENA	0x00
+#endif
+#ifndef CONFIG_SMSTP2_ENA
+#define CONFIG_SMSTP2_ENA	0x00
+#endif
+#ifndef CONFIG_SMSTP3_ENA
+#define CONFIG_SMSTP3_ENA	0x00
+#endif
+#ifndef CONFIG_SMSTP4_ENA
+#define CONFIG_SMSTP4_ENA	0x00
+#endif
+#ifndef CONFIG_SMSTP5_ENA
+#define CONFIG_SMSTP5_ENA	0x00
+#endif
+#ifndef CONFIG_SMSTP6_ENA
+#define CONFIG_SMSTP6_ENA	0x00
+#endif
+#ifndef CONFIG_SMSTP7_ENA
+#define CONFIG_SMSTP7_ENA	0x00
+#endif
+#ifndef CONFIG_SMSTP8_ENA
+#define CONFIG_SMSTP8_ENA	0x00
+#endif
+#ifndef CONFIG_SMSTP9_ENA
+#define CONFIG_SMSTP9_ENA	0x00
+#endif
+#ifndef CONFIG_SMSTP10_ENA
+#define CONFIG_SMSTP10_ENA	0x00
+#endif
+#ifndef CONFIG_SMSTP11_ENA
+#define CONFIG_SMSTP11_ENA	0x00
+#endif
+
+#ifndef CONFIG_RMSTP0_ENA
+#define CONFIG_RMSTP0_ENA	0x00
+#endif
+#ifndef CONFIG_RMSTP1_ENA
+#define CONFIG_RMSTP1_ENA	0x00
+#endif
+#ifndef CONFIG_RMSTP2_ENA
+#define CONFIG_RMSTP2_ENA	0x00
+#endif
+#ifndef CONFIG_RMSTP3_ENA
+#define CONFIG_RMSTP3_ENA	0x00
+#endif
+#ifndef CONFIG_RMSTP4_ENA
+#define CONFIG_RMSTP4_ENA	0x00
+#endif
+#ifndef CONFIG_RMSTP5_ENA
+#define CONFIG_RMSTP5_ENA	0x00
+#endif
+#ifndef CONFIG_RMSTP6_ENA
+#define CONFIG_RMSTP6_ENA	0x00
+#endif
+#ifndef CONFIG_RMSTP7_ENA
+#define CONFIG_RMSTP7_ENA	0x00
+#endif
+#ifndef CONFIG_RMSTP8_ENA
+#define CONFIG_RMSTP8_ENA	0x00
+#endif
+#ifndef CONFIG_RMSTP9_ENA
+#define CONFIG_RMSTP9_ENA	0x00
+#endif
+#ifndef CONFIG_RMSTP10_ENA
+#define CONFIG_RMSTP10_ENA	0x00
+#endif
+#ifndef CONFIG_RMSTP11_ENA
+#define CONFIG_RMSTP11_ENA	0x00
+#endif
+
+struct mstp_ctl {
+	u32 s_addr;
+	u32 s_dis;
+	u32 s_ena;
+	u32 r_addr;
+	u32 r_dis;
+	u32 r_ena;
+};
+
+#endif /* __ASM_ARCH_RCAR_MSTP_H */
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-socfpga/clock_manager.h u-boot/arch/arm/include/asm/arch-socfpga/clock_manager.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-socfpga/clock_manager.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-socfpga/clock_manager.h	2015-01-01 17:34:32.089505941 +0100
@@ -14,6 +14,7 @@
 unsigned int cm_get_l4_sp_clk_hz(void);
 unsigned int cm_get_mmc_controller_clk_hz(void);
 unsigned int cm_get_qspi_controller_clk_hz(void);
+unsigned int cm_get_spi_controller_clk_hz(void);
 #endif
 
 typedef struct {
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-socfpga/freeze_controller.h u-boot/arch/arm/include/asm/arch-socfpga/freeze_controller.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-socfpga/freeze_controller.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-socfpga/freeze_controller.h	2015-01-01 17:34:32.089505941 +0100
@@ -42,7 +42,6 @@
 #define SYSMGR_FRZCTRL_HWCTRL_VIO1REQ_MASK 0x00000001
 #define SYSMGR_FRZCTRL_HWCTRL_VIO1STATE_ENUM_FROZEN 0x2
 #define SYSMGR_FRZCTRL_HWCTRL_VIO1STATE_ENUM_THAWED 0x1
-#define SYSMGR_FRZCTRL_VIOCTRL_SHIFT 0x2
 
 void sys_mgr_frzctrl_freeze_req(void);
 void sys_mgr_frzctrl_thaw_req(void);
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-socfpga/scan_manager.h u-boot/arch/arm/include/asm/arch-socfpga/scan_manager.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-socfpga/scan_manager.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-socfpga/scan_manager.h	2015-01-01 17:34:32.089505941 +0100
@@ -13,6 +13,7 @@
 	u32	padding[2];
 	u32	fifo_single_byte;
 	u32	fifo_double_byte;
+	u32	fifo_triple_byte;
 	u32	fifo_quad_byte;
 };
 
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/gpio.h u-boot/arch/arm/include/asm/arch-stv0991/gpio.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-stv0991/gpio.h	2015-01-01 17:34:32.093505875 +0100
@@ -0,0 +1,22 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_STV0991_GPIO_H
+#define __ASM_ARCH_STV0991_GPIO_H
+
+enum gpio_direction {
+	GPIO_DIRECTION_IN,
+	GPIO_DIRECTION_OUT,
+};
+
+struct gpio_regs {
+	u32 data;		/* offset 0x0 */
+	u32 reserved[0xff];	/* 0x4--0x3fc */
+	u32 dir;		/* offset 0x400 */
+};
+
+#endif	/* __ASM_ARCH_STV0991_GPIO_H */
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/hardware.h u-boot/arch/arm/include/asm/arch-stv0991/hardware.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/hardware.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-stv0991/hardware.h	2015-01-01 17:34:32.093505875 +0100
@@ -0,0 +1,73 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, STMicroelectronics, <vikas.manocha@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ASM_ARCH_HARDWARE_H
+#define _ASM_ARCH_HARDWARE_H
+
+/* STV0991 */
+#define SRAM0_BASE_ADDR                          0x00000000UL
+#define SRAM1_BASE_ADDR                          0x00068000UL
+#define SRAM2_BASE_ADDR                          0x000D0000UL
+#define SRAM3_BASE_ADDR                          0x00138000UL
+#define CFS_SRAM0_BASE_ADDR                      0x00198000UL
+#define CFS_SRAM1_BASE_ADDR                      0x001B8000UL
+#define FAST_SRAM_BASE_ADDR                      0x001D8000UL
+#define FLASH_BASE_ADDR                          0x40000000UL
+#define PL310_BASE_ADDR                          0x70000000UL
+#define HSAXIM_BASE_ADDR                         0x70100000UL
+#define IMGSS_BASE_ADDR                          0x70200000UL
+#define ADC_BASE_ADDR                            0x80000000UL
+#define GPIOA_BASE_ADDR                          0x80001000UL
+#define GPIOB_BASE_ADDR                          0x80002000UL
+#define GPIOC_BASE_ADDR                          0x80003000UL
+#define HDM_BASE_ADDR                            0x80004000UL
+#define THSENS_BASE_ADDR                         0x80200000UL
+#define GPTIMER2_BASE_ADDR                       0x80201000UL
+#define GPTIMER1_BASE_ADDR                       0x80202000UL
+#define QSPI_BASE_ADDR                           0x80203000UL
+#define CGU_BASE_ADDR                            0x80204000UL
+#define CREG_BASE_ADDR                           0x80205000UL
+#define PEC_BASE_ADDR                            0x80206000UL
+#define WDRU_BASE_ADDR                           0x80207000UL
+#define BSEC_BASE_ADDR                           0x80208000UL
+#define DAP_ROM_BASE_ADDR                        0x80210000UL
+#define SOC_CTI_BASE_ADDR                        0x80211000UL
+#define TPIU_BASE_ADDR                           0x80212000UL
+#define TMC_ETF_BASE_ADDR                        0x80213000UL
+#define R4_ETM_BASE_ADDR                         0x80214000UL
+#define R4_CTI_BASE_ADDR                         0x80215000UL
+#define R4_DBG_BASE_ADDR                         0x80216000UL
+#define GMAC_BASE_ADDR                           0x80300000UL
+#define RNSS_BASE_ADDR                           0x80302000UL
+#define CRYP_BASE_ADDR                           0x80303000UL
+#define HASH_BASE_ADDR                           0x80304000UL
+#define GPDMA_BASE_ADDR                          0x80305000UL
+#define ISA_BASE_ADDR                            0x8032A000UL
+#define HCI_BASE_ADDR                            0x80400000UL
+#define I2C1_BASE_ADDR                           0x80401000UL
+#define I2C2_BASE_ADDR                           0x80402000UL
+#define SAI_BASE_ADDR                            0x80403000UL
+#define USI_BASE_ADDR                            0x80404000UL
+#define SPI1_BASE_ADDR                           0x80405000UL
+#define UART_BASE_ADDR                           0x80406000UL
+#define SPI2_BASE_ADDR                           0x80500000UL
+#define CAN_BASE_ADDR                            0x80501000UL
+#define USART1_BASE_ADDR                         0x80502000UL
+#define USART2_BASE_ADDR                         0x80503000UL
+#define USART3_BASE_ADDR                         0x80504000UL
+#define USART4_BASE_ADDR                         0x80505000UL
+#define USART5_BASE_ADDR                         0x80506000UL
+#define USART6_BASE_ADDR                         0x80507000UL
+#define SDI2_BASE_ADDR                           0x80600000UL
+#define SDI1_BASE_ADDR                           0x80601000UL
+#define VICA_BASE_ADDR                           0x81000000UL
+#define VICB_BASE_ADDR                           0x81001000UL
+#define STM_CHANNELS_BASE_ADDR                   0x81100000UL
+#define STM_BASE_ADDR                            0x81110000UL
+#define SROM_BASE_ADDR                           0xFFFF0000UL
+
+#endif /* _ASM_ARCH_HARDWARE_H */
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_cgu.h u-boot/arch/arm/include/asm/arch-stv0991/stv0991_cgu.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_cgu.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-stv0991/stv0991_cgu.h	2015-01-01 17:34:32.093505875 +0100
@@ -0,0 +1,116 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _STV0991_CGU_H
+#define _STV0991_CGU_H
+
+struct stv0991_cgu_regs {
+	u32 cpu_freq;		/* offset 0x0 */
+	u32 icn2_freq;		/* offset 0x4 */
+	u32 dma_freq;		/* offset 0x8 */
+	u32 isp_freq;		/* offset 0xc */
+	u32 h264_freq;		/* offset 0x10 */
+	u32 osif_freq;		/* offset 0x14 */
+	u32 ren_freq;		/* offset 0x18 */
+	u32 tim_freq;		/* offset 0x1c */
+	u32 sai_freq;		/* offset 0x20 */
+	u32 eth_freq;		/* offset 0x24 */
+	u32 i2c_freq;		/* offset 0x28 */
+	u32 spi_freq;		/* offset 0x2c */
+	u32 uart_freq;		/* offset 0x30 */
+	u32 qspi_freq;		/* offset 0x34 */
+	u32 sdio_freq;		/* offset 0x38 */
+	u32 usi_freq;		/* offset 0x3c */
+	u32 can_line_freq;	/* offset 0x40 */
+	u32 debug_freq;		/* offset 0x44 */
+	u32 trace_freq;		/* offset 0x48 */
+	u32 stm_freq;		/* offset 0x4c */
+	u32 eth_ctrl;		/* offset 0x50 */
+	u32 reserved[3];	/* offset 0x54 */
+	u32 osc_ctrl;		/* offset 0x60 */
+	u32 pll1_ctrl;		/* offset 0x64 */
+	u32 pll1_freq;		/* offset 0x68 */
+	u32 pll1_fract;		/* offset 0x6c */
+	u32 pll1_spread;	/* offset 0x70 */
+	u32 pll1_status;	/* offset 0x74 */
+	u32 pll2_ctrl;		/* offset 0x78 */
+	u32 pll2_freq;		/* offset 0x7c */
+	u32 pll2_fract;		/* offset 0x80 */
+	u32 pll2_spread;	/* offset 0x84 */
+	u32 pll2_status;	/* offset 0x88 */
+	u32 cgu_enable_1;	/* offset 0x8c */
+	u32 cgu_enable_2;	/* offset 0x90 */
+	u32 cgu_isp_pulse;	/* offset 0x94 */
+	u32 cgu_h264_pulse;	/* offset 0x98 */
+	u32 cgu_osif_pulse;	/* offset 0x9c */
+	u32 cgu_ren_pulse;	/* offset 0xa0 */
+
+};
+
+/* CGU Timer */
+#define CLK_TMR_OSC			0
+#define CLK_TMR_MCLK			1
+#define CLK_TMR_PLL1			2
+#define CLK_TMR_PLL2			3
+#define MDIV_SHIFT_TMR			3
+#define DIV_SHIFT_TMR			6
+
+#define TIMER1_CLK_CFG			(0 << DIV_SHIFT_TMR \
+					| 0 << MDIV_SHIFT_TMR | CLK_TMR_MCLK)
+
+/* Clock Enable/Disable */
+
+#define TIMER1_CLK_EN			(1 << 15)
+
+/* CGU Uart config */
+#define CLK_UART_MCLK			0
+#define CLK_UART_PLL1			1
+#define CLK_UART_PLL2			2
+
+#define MDIV_SHIFT_UART			3
+#define DIV_SHIFT_UART			6
+
+#define UART_CLK_CFG			(4 << DIV_SHIFT_UART \
+					| 1 << MDIV_SHIFT_UART | CLK_UART_MCLK)
+
+/* CGU Ethernet clock config */
+#define CLK_ETH_MCLK			0
+#define CLK_ETH_PLL1			1
+#define CLK_ETH_PLL2			2
+
+#define MDIV_SHIFT_ETH			3
+#define DIV_SHIFT_ETH			6
+#define DIV_ETH_125			9
+#define DIV_ETH_50			12
+#define DIV_ETH_P2P			15
+
+#define ETH_CLK_CFG			(4 << DIV_ETH_P2P | 4 << DIV_ETH_50 \
+					| 1 << DIV_ETH_125 \
+					| 0 << DIV_SHIFT_ETH \
+					| 3 << MDIV_SHIFT_ETH | CLK_ETH_PLL1)
+ /* CGU Ethernet control */
+
+#define ETH_CLK_TX_EXT_PHY		0
+#define ETH_CLK_TX_125M			1
+#define ETH_CLK_TX_25M			2
+#define ETH_CLK_TX_2M5			3
+#define ETH_CLK_TX_DIS			7
+
+#define ETH_CLK_RX_EXT_PHY		0
+#define ETH_CLK_RX_25M			1
+#define ETH_CLK_RX_2M5			2
+#define ETH_CLK_RX_DIS			3
+#define RX_CLK_SHIFT			3
+#define ETH_CLK_MASK			~(0x1F)
+
+#define ETH_PHY_MODE_GMII		0
+#define ETH_PHY_MODE_RMII		1
+#define ETH_PHY_CLK_DIS			1
+
+#define ETH_CLK_CTRL			(ETH_CLK_RX_EXT_PHY << RX_CLK_SHIFT \
+					| ETH_CLK_TX_EXT_PHY)
+#endif
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_creg.h u-boot/arch/arm/include/asm/arch-stv0991/stv0991_creg.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_creg.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-stv0991/stv0991_creg.h	2015-01-01 17:34:32.093505875 +0100
@@ -0,0 +1,95 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _STV0991_CREG_H
+#define _STV0991_CREG_H
+
+struct stv0991_creg {
+	u32 version;		/* offset 0x0 */
+	u32 hdpctl;		/* offset 0x4 */
+	u32 hdpval;		/* offset 0x8 */
+	u32 hdpgposet;		/* offset 0xc */
+	u32 hdpgpoclr;		/* offset 0x10 */
+	u32 hdpgpoval;		/* offset 0x14 */
+	u32 stm_mux;		/* offset 0x18 */
+	u32 sysctrl_1;		/* offset 0x1c */
+	u32 sysctrl_2;		/* offset 0x20 */
+	u32 sysctrl_3;		/* offset 0x24 */
+	u32 sysctrl_4;		/* offset 0x28 */
+	u32 reserved_1[0x35];	/* offset 0x2C-0xFC */
+	u32 mux1;		/* offset 0x100 */
+	u32 mux2;		/* offset 0x104 */
+	u32 mux3;		/* offset 0x108 */
+	u32 mux4;		/* offset 0x10c */
+	u32 mux5;		/* offset 0x110 */
+	u32 mux6;		/* offset 0x114 */
+	u32 mux7;		/* offset 0x118 */
+	u32 mux8;		/* offset 0x11c */
+	u32 mux9;		/* offset 0x120 */
+	u32 mux10;		/* offset 0x124 */
+	u32 mux11;		/* offset 0x128 */
+	u32 mux12;		/* offset 0x12c */
+	u32 mux13;		/* offset 0x130 */
+	u32 reserved_2[0x33];	/* offset 0x134-0x1FC */
+	u32 cfg_pad1;		/* offset 0x200 */
+	u32 cfg_pad2;		/* offset 0x204 */
+	u32 cfg_pad3;		/* offset 0x208 */
+	u32 cfg_pad4;		/* offset 0x20c */
+	u32 cfg_pad5;		/* offset 0x210 */
+	u32 cfg_pad6;		/* offset 0x214 */
+	u32 cfg_pad7;		/* offset 0x218 */
+	u32 reserved_3[0x39];	/* offset 0x21C-0x2FC */
+	u32 vdd_pad1;		/* offset 0x300 */
+	u32 vdd_pad2;		/* offset 0x304 */
+	u32 reserved_4[0x3e];	/* offset 0x308-0x3FC */
+	u32 vdd_comp1;		/* offset 0x400 */
+};
+
+/* CREG MUX 12 register */
+#define GPIOC_30_MUX_SHIFT	24
+#define GPIOC_30_MUX_MASK	~(1 << GPIOC_30_MUX_SHIFT)
+#define CFG_GPIOC_30_UART_TX	(1 << GPIOC_30_MUX_SHIFT)
+
+#define GPIOC_31_MUX_SHIFT	28
+#define GPIOC_31_MUX_MASK	~(1 << GPIOC_31_MUX_SHIFT)
+#define CFG_GPIOC_31_UART_RX	(1 << GPIOC_31_MUX_SHIFT)
+
+/* CREG MUX 7 register */
+#define GPIOB_16_MUX_SHIFT	0
+#define GPIOB_16_MUX_MASK	~(1 << GPIOB_16_MUX_SHIFT)
+#define CFG_GPIOB_16_UART_TX	(1 << GPIOB_16_MUX_SHIFT)
+
+#define GPIOB_17_MUX_SHIFT	4
+#define GPIOB_17_MUX_MASK	~(1 << GPIOB_17_MUX_SHIFT)
+#define CFG_GPIOB_17_UART_RX	(1 << GPIOB_17_MUX_SHIFT)
+
+/* CREG CFG_PAD6 register */
+
+#define GPIOC_31_MODE_SHIFT	30
+#define GPIOC_31_MODE_MASK	~(1 << GPIOC_31_MODE_SHIFT)
+#define CFG_GPIOC_31_MODE_OD	(0 << GPIOC_31_MODE_SHIFT)
+#define CFG_GPIOC_31_MODE_PP	(1 << GPIOC_31_MODE_SHIFT)
+
+#define GPIOC_30_MODE_SHIFT	28
+#define GPIOC_30_MODE_MASK	~(1 << GPIOC_30_MODE_SHIFT)
+#define CFG_GPIOC_30_MODE_LOW	(0 << GPIOC_30_MODE_SHIFT)
+#define CFG_GPIOC_30_MODE_HIGH	(1 << GPIOC_30_MODE_SHIFT)
+
+/* CREG Ethernet pad config */
+
+#define VDD_ETH_PS_1V8		0
+#define VDD_ETH_PS_2V5		2
+#define VDD_ETH_PS_3V3		3
+#define VDD_ETH_PS_MASK		0x3
+
+#define VDD_ETH_PS_SHIFT	12
+#define ETH_VDD_CFG		(VDD_ETH_PS_1V8 << VDD_ETH_PS_SHIFT)
+
+#define VDD_ETH_M_PS_SHIFT	28
+#define ETH_M_VDD_CFG		(VDD_ETH_PS_1V8 << VDD_ETH_M_PS_SHIFT)
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_defs.h u-boot/arch/arm/include/asm/arch-stv0991/stv0991_defs.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_defs.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-stv0991/stv0991_defs.h	2015-01-01 17:34:32.093505875 +0100
@@ -0,0 +1,16 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __STV0991_DEFS_H__
+#define __STV0991_DEFS_H__
+#include <asm/arch/stv0991_periph.h>
+
+extern int stv0991_pinmux_config(enum periph_id);
+extern int clock_setup(enum periph_clock);
+
+#endif
+
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_gpt.h u-boot/arch/arm/include/asm/arch-stv0991/stv0991_gpt.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_gpt.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-stv0991/stv0991_gpt.h	2015-01-01 17:34:32.093505875 +0100
@@ -0,0 +1,43 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _STV0991_GPT_H
+#define _STV0991_GPT_H
+
+#include <asm/arch-stv0991/hardware.h>
+
+struct gpt_regs {
+	u32 cr1;
+	u32 cr2;
+	u32 reserved_1;
+	u32 dier;	/* dma_int_en */
+	u32 sr;		/* status reg */
+	u32 egr;	/* event gen */
+	u32 reserved_2[3];	/* offset 0x18--0x20*/
+	u32 cnt;
+	u32 psc;
+	u32 arr;
+};
+
+struct gpt_regs *const gpt1_regs_ptr =
+	(struct gpt_regs *) GPTIMER1_BASE_ADDR;
+
+/* Timer control1 register  */
+#define GPT_CR1_CEN			0x0001
+#define GPT_MODE_AUTO_RELOAD		(1 << 7)
+
+/* Timer prescalar reg */
+#define GPT_PRESCALER_128		0x128
+
+/* Auto reload register for free running config */
+#define GPT_FREE_RUNNING		0xFFFF
+
+/* Timer, HZ specific defines */
+#define CONFIG_STV0991_HZ		1000
+#define CONFIG_STV0991_HZ_CLOCK		(27*1000*1000)/GPT_PRESCALER_128
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_periph.h u-boot/arch/arm/include/asm/arch-stv0991/stv0991_periph.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_periph.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-stv0991/stv0991_periph.h	2015-01-01 17:34:32.093505875 +0100
@@ -0,0 +1,44 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARM_ARCH_PERIPH_H
+#define __ASM_ARM_ARCH_PERIPH_H
+
+/*
+ * Peripherals required for pinmux configuration. List will
+ * grow with support for more devices getting added.
+ * Numbering based on interrupt table.
+ *
+ */
+enum periph_id {
+	UART_GPIOC_30_31 = 0,
+	UART_GPIOB_16_17,
+	ETH_GPIOB_10_31_C_0_4,
+	PERIPH_ID_I2C0,
+	PERIPH_ID_I2C1,
+	PERIPH_ID_I2C2,
+	PERIPH_ID_I2C3,
+	PERIPH_ID_I2C4,
+	PERIPH_ID_I2C5,
+	PERIPH_ID_I2C6,
+	PERIPH_ID_I2C7,
+	PERIPH_ID_SPI0,
+	PERIPH_ID_SPI1,
+	PERIPH_ID_SPI2,
+	PERIPH_ID_SDMMC0,
+	PERIPH_ID_SDMMC1,
+	PERIPH_ID_SDMMC2,
+	PERIPH_ID_SDMMC3,
+	PERIPH_ID_I2S1,
+};
+
+enum periph_clock {
+	UART_CLOCK_CFG = 0,
+	ETH_CLOCK_CFG,
+};
+
+#endif /* __ASM_ARM_ARCH_PERIPH_H */
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_wdru.h u-boot/arch/arm/include/asm/arch-stv0991/stv0991_wdru.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-stv0991/stv0991_wdru.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-stv0991/stv0991_wdru.h	2015-01-01 17:34:32.093505875 +0100
@@ -0,0 +1,28 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _STV0991_WD_RST_H
+#define _STV0991_WD_RST_H
+#include <asm/arch-stv0991/hardware.h>
+
+struct stv0991_wd_ru {
+	u32 wdru_config;
+	u32 wdru_ctrl1;
+	u32 wdru_ctrl2;
+	u32 wdru_tim;
+	u32 wdru_count;
+	u32 wdru_stat;
+	u32 wdru_wrlock;
+};
+
+struct stv0991_wd_ru *const stv0991_wd_ru_ptr = \
+		(struct stv0991_wd_ru *)WDRU_BASE_ADDR;
+
+/* Watchdog control register */
+#define WDRU_RST_SYS		0x1
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-tegra/tegra_i2c.h u-boot/arch/arm/include/asm/arch-tegra/tegra_i2c.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-tegra/tegra_i2c.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-tegra/tegra_i2c.h	2015-01-01 17:34:32.097505809 +0100
@@ -167,6 +167,6 @@
  *
  * @return number of bus, or -1 if there is no DVC active
  */
-int tegra_i2c_get_dvc_bus_num(void);
+int tegra_i2c_get_dvc_bus(struct udevice **busp);
 
 #endif	/* _TEGRA_I2C_H_ */
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/arch-vf610/imx-regs.h u-boot/arch/arm/include/asm/arch-vf610/imx-regs.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/arch-vf610/imx-regs.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/arch-vf610/imx-regs.h	2015-01-01 17:34:32.109505612 +0100
@@ -256,6 +256,14 @@
 #define DDRMC_CR161_TODTH_RD(v)				(((v) & 0xf) << 8)
 #define DDRMC_CR161_TODTH_WR(v)				((v) & 0xf)
 
+/* System Reset Controller (SRC) */
+#define SRC_SRSR_SW_RST					(0x1 << 18)
+#define SRC_SRSR_RESETB					(0x1 << 7)
+#define SRC_SRSR_JTAG_RST				(0x1 << 5)
+#define SRC_SRSR_WDOG_M4				(0x1 << 4)
+#define SRC_SRSR_WDOG_A5				(0x1 << 3)
+#define SRC_SRSR_POR_RST				(0x1 << 0)
+
 #if !(defined(__KERNEL_STRICT_NAMES) || defined(__ASSEMBLY__))
 #include <asm/types.h>
 
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/kona-common/clk.h u-boot/arch/arm/include/asm/kona-common/clk.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/kona-common/clk.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/kona-common/clk.h	2015-01-01 17:34:32.113505547 +0100
@@ -25,5 +25,6 @@
 struct clk *clk_get_parent(struct clk *clk);
 int clk_sdio_enable(void *base, u32 rate, u32 *actual_ratep);
 int clk_bsc_enable(void *base);
+int clk_usb_otg_enable(void *base);
 
 #endif
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/pcie_layerscape.h u-boot/arch/arm/include/asm/pcie_layerscape.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/pcie_layerscape.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/arm/include/asm/pcie_layerscape.h	2015-01-01 17:34:32.125505350 +0100
@@ -0,0 +1,13 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __PCIE_LAYERSCAPE_H_
+#define __PCIE_LAYERSCAPE_H_
+
+void pci_init_board(void);
+void ft_pcie_setup(void *blob, bd_t *bd);
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/arm/include/asm/semihosting.h u-boot/arch/arm/include/asm/semihosting.h
--- u-boot-2015.01-rc3/arch/arm/include/asm/semihosting.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/include/asm/semihosting.h	2015-01-01 17:34:32.125505350 +0100
@@ -12,10 +12,6 @@
  * code for more information.
  */
 int smh_load(const char *fname, void *memp, int avail, int verbose);
-int smh_read(int fd, void *memp, int len);
-int smh_open(const char *fname, char *modestr);
-int smh_close(int fd);
-int smh_len_fd(int fd);
-int smh_len(const char *fname);
+long smh_len(const char *fname);
 
 #endif /* __SEMIHOSTING_H__ */
diff -ruN u-boot-2015.01-rc3/arch/arm/Kconfig u-boot/arch/arm/Kconfig
--- u-boot-2015.01-rc3/arch/arm/Kconfig	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/Kconfig	2015-01-01 17:34:31.989507580 +0100
@@ -341,6 +341,10 @@
 	bool "Support spear600"
 	select CPU_ARM926EJS
 
+config TARGET_STV0991
+	bool "Support stv0991"
+	select CPU_V7
+
 config TARGET_X600
 	bool "Support x600"
 	select CPU_ARM926EJS
@@ -650,6 +654,7 @@
 
 config TARGET_TBS2910
 	bool "Support tbs2910"
+	select CPU_V7
 
 config TARGET_TQMA6
 	bool "TQ Systems TQMa6 board"
@@ -728,12 +733,14 @@
 	select ARM64
 
 config TARGET_LS1021AQDS
-	bool "Support ls1021aqds_nor"
+	bool "Support ls1021aqds"
 	select CPU_V7
+	select SUPPORT_SPL
 
 config TARGET_LS1021ATWR
-	bool "Support ls1021atwr_nor"
+	bool "Support ls1021atwr"
 	select CPU_V7
+	select SUPPORT_SPL
 
 config TARGET_BALLOON3
 	bool "Support balloon3"
@@ -793,6 +800,7 @@
 	bool "Panasonic UniPhier platform"
 	select CPU_V7
 	select SUPPORT_SPL
+	select SPL
 	select OF_CONTROL if !SPL_BUILD
 
 endchoice
@@ -953,6 +961,7 @@
 source "board/spear/x600/Kconfig"
 source "board/st-ericsson/snowball/Kconfig"
 source "board/st-ericsson/u8500/Kconfig"
+source "board/st/stv0991/Kconfig"
 source "board/sunxi/Kconfig"
 source "board/syteco/jadecpu/Kconfig"
 source "board/syteco/zmx25/Kconfig"
diff -ruN u-boot-2015.01-rc3/arch/arm/lib/semihosting.c u-boot/arch/arm/lib/semihosting.c
--- u-boot-2015.01-rc3/arch/arm/lib/semihosting.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/arm/lib/semihosting.c	2015-01-01 17:34:32.133505219 +0100
@@ -26,9 +26,9 @@
 /*
  * Call the handler
  */
-static int smh_trap(unsigned int sysnum, void *addr)
+static long smh_trap(unsigned int sysnum, void *addr)
 {
-	register int result asm("r0");
+	register long result asm("r0");
 #if defined(CONFIG_ARM64)
 	asm volatile ("hlt #0xf000" : "=r" (result) : "0"(sysnum), "r"(addr));
 #else
@@ -39,167 +39,164 @@
 }
 
 /*
- * Open, load a file into memory, and close it. Check that the available space
- * is sufficient to store the entire file. Return the bytes actually read from
- * the file as seen by the read function. The verbose flag enables some extra
- * printing of successful read status.
+ * Open a file on the host. Mode is "r" or "rb" currently. Returns a file
+ * descriptor or -1 on error.
  */
-int smh_load(const char *fname, void *memp, int avail, int verbose)
+static long smh_open(const char *fname, char *modestr)
 {
-	int ret, fd, len;
-
-	ret = -1;
-
-	debug("%s: fname \'%s\', avail %u, memp %p\n", __func__, fname,
-	      avail, memp);
-
-	/* Open the file */
-	fd = smh_open(fname, "rb");
-	if (fd == -1)
-		return ret;
+	long fd;
+	unsigned long mode;
+	struct smh_open_s {
+		const char *fname;
+		unsigned long mode;
+		size_t len;
+	} open;
 
-	/* Get the file length */
-	ret = smh_len_fd(fd);
-	if (ret == -1) {
-		smh_close(fd);
-		return ret;
-	}
+	debug("%s: file \'%s\', mode \'%s\'\n", __func__, fname, modestr);
 
-	/* Check that the file will fit in the supplied buffer */
-	if (ret > avail) {
-		printf("%s: ERROR ret %d, avail %u\n", __func__, ret,
-		       avail);
-		smh_close(fd);
-		return ret;
+	/* Check the file mode */
+	if (!(strcmp(modestr, "r"))) {
+		mode = MODE_READ;
+	} else if (!(strcmp(modestr, "rb"))) {
+		mode = MODE_READBIN;
+	} else {
+		printf("%s: ERROR mode \'%s\' not supported\n", __func__,
+		       modestr);
+		return -1;
 	}
 
-	len = ret;
-
-	/* Read the file into the buffer */
-	ret = smh_read(fd, memp, len);
-	if (ret == 0) {
-		/* Print successful load information if requested */
-		if (verbose) {
-			printf("\n%s\n", fname);
-			printf("    0x%8p dest\n", memp);
-			printf("    0x%08x size\n", len);
-			printf("    0x%08x avail\n", avail);
-		}
-	}
+	open.fname = fname;
+	open.len = strlen(fname);
+	open.mode = mode;
 
-	/* Close the file */
-	smh_close(fd);
+	/* Open the file on the host */
+	fd = smh_trap(SYSOPEN, &open);
+	if (fd == -1)
+		printf("%s: ERROR fd %ld for file \'%s\'\n", __func__, fd,
+		       fname);
 
-	return ret;
+	return fd;
 }
 
 /*
  * Read 'len' bytes of file into 'memp'. Returns 0 on success, else failure
  */
-int smh_read(int fd, void *memp, int len)
+static long smh_read(long fd, void *memp, size_t len)
 {
-	int ret;
+	long ret;
 	struct smh_read_s {
-		int fd;
+		long fd;
 		void *memp;
-		int len;
+		size_t len;
 	} read;
 
-	debug("%s: fd %d, memp %p, len %d\n", __func__, fd, memp, len);
+	debug("%s: fd %ld, memp %p, len %lu\n", __func__, fd, memp, len);
 
 	read.fd = fd;
 	read.memp = memp;
 	read.len = len;
 
 	ret = smh_trap(SYSREAD, &read);
-	if (ret == 0) {
-		return 0;
-	} else {
+	if (ret < 0) {
 		/*
 		 * The ARM handler allows for returning partial lengths,
 		 * but in practice this never happens so rather than create
 		 * hard to maintain partial read loops and such, just fail
 		 * with an error message.
 		 */
-		printf("%s: ERROR ret %d, fd %d, len %u memp %p\n",
+		printf("%s: ERROR ret %ld, fd %ld, len %lu memp %p\n",
 		       __func__, ret, fd, len, memp);
+		return -1;
 	}
-	return ret;
+
+	return 0;
 }
 
 /*
- * Open a file on the host. Mode is "r" or "rb" currently. Returns a file
- * descriptor or -1 on error.
+ * Close the file using the file descriptor
  */
-int smh_open(const char *fname, char *modestr)
+static long smh_close(long fd)
 {
-	int ret, fd, mode;
-	struct smh_open_s {
-		const char *fname;
-		unsigned int mode;
-		unsigned int len;
-	} open;
+	long ret;
 
-	debug("%s: file \'%s\', mode \'%s\'\n", __func__, fname, modestr);
-
-	ret = -1;
+	debug("%s: fd %ld\n", __func__, fd);
 
-	/* Check the file mode */
-	if (!(strcmp(modestr, "r"))) {
-		mode = MODE_READ;
-	} else if (!(strcmp(modestr, "rb"))) {
-		mode = MODE_READBIN;
-	} else {
-		printf("%s: ERROR mode \'%s\' not supported\n", __func__,
-		       modestr);
-		return ret;
-	}
-
-	open.fname = fname;
-	open.len = strlen(fname);
-	open.mode = mode;
-
-	/* Open the file on the host */
-	fd = smh_trap(SYSOPEN, &open);
-	if (fd == -1)
-		printf("%s: ERROR fd %d for file \'%s\'\n", __func__, fd,
-		       fname);
+	ret = smh_trap(SYSCLOSE, &fd);
+	if (ret == -1)
+		printf("%s: ERROR fd %ld\n", __func__, fd);
 
-	return fd;
+	return ret;
 }
 
 /*
- * Close the file using the file descriptor
+ * Get the file length from the file descriptor
  */
-int smh_close(int fd)
+static long smh_len_fd(long fd)
 {
-	int ret;
-	long fdlong;
+	long ret;
 
-	debug("%s: fd %d\n", __func__, fd);
+	debug("%s: fd %ld\n", __func__, fd);
 
-	fdlong = (long)fd;
-	ret = smh_trap(SYSCLOSE, &fdlong);
+	ret = smh_trap(SYSFLEN, &fd);
 	if (ret == -1)
-		printf("%s: ERROR fd %d\n", __func__, fd);
+		printf("%s: ERROR ret %ld, fd %ld\n", __func__, ret, fd);
 
 	return ret;
 }
 
 /*
- * Get the file length from the file descriptor
+ * Open, load a file into memory, and close it. Check that the available space
+ * is sufficient to store the entire file. Return the bytes actually read from
+ * the file as seen by the read function. The verbose flag enables some extra
+ * printing of successful read status.
  */
-int smh_len_fd(int fd)
+int smh_load(const char *fname, void *memp, int avail, int verbose)
 {
-	int ret;
-	long fdlong;
+	long ret;
+	long fd;
+	size_t len;
 
-	debug("%s: fd %d\n", __func__, fd);
+	ret = -1;
 
-	fdlong = (long)fd;
-	ret = smh_trap(SYSFLEN, &fdlong);
-	if (ret == -1)
-		printf("%s: ERROR ret %d\n", __func__, ret);
+	debug("%s: fname \'%s\', avail %u, memp %p\n", __func__, fname,
+	      avail, memp);
+
+	/* Open the file */
+	fd = smh_open(fname, "rb");
+	if (fd == -1)
+		return -1;
+
+	/* Get the file length */
+	ret = smh_len_fd(fd);
+	if (ret == -1) {
+		smh_close(fd);
+		return -1;
+	}
+
+	/* Check that the file will fit in the supplied buffer */
+	if (ret > avail) {
+		printf("%s: ERROR ret %ld, avail %u\n", __func__, ret,
+		       avail);
+		smh_close(fd);
+		return -1;
+	}
+
+	len = ret;
+
+	/* Read the file into the buffer */
+	ret = smh_read(fd, memp, len);
+	if (ret == 0) {
+		/* Print successful load information if requested */
+		if (verbose) {
+			printf("\n%s\n", fname);
+			printf("    0x%8p dest\n", memp);
+			printf("    0x%08lx size\n", len);
+			printf("    0x%08x avail\n", avail);
+		}
+	}
+
+	/* Close the file */
+	smh_close(fd);
 
 	return ret;
 }
@@ -207,26 +204,32 @@
 /*
  * Get the file length from the filename
  */
-int smh_len(const char *fname)
+long smh_len(const char *fname)
 {
-	int ret, fd, len;
+	long ret;
+	long fd;
+	long len;
 
 	debug("%s: file \'%s\'\n", __func__, fname);
 
 	/* Open the file */
 	fd = smh_open(fname, "rb");
-	if (fd == -1)
+	if (fd < 0)
 		return fd;
 
 	/* Get the file length */
 	len = smh_len_fd(fd);
+	if (len < 0) {
+		smh_close(fd);
+		return len;
+	}
 
 	/* Close the file */
 	ret = smh_close(fd);
-	if (ret == -1)
+	if (ret < 0)
 		return ret;
 
-	debug("%s: returning len %d\n", __func__, len);
+	debug("%s: returning len %ld\n", __func__, len);
 
 	/* Return the file length (or -1 error indication) */
 	return len;
diff -ruN u-boot-2015.01-rc3/arch/microblaze/dts/include/dt-bindings/pinctrl/pinctrl-tegra.h u-boot/arch/microblaze/dts/include/dt-bindings/pinctrl/pinctrl-tegra.h
diff -ruN u-boot-2015.01-rc3/arch/microblaze/dts/include/dt-bindings/reset/altr,rst-mgr.h u-boot/arch/microblaze/dts/include/dt-bindings/reset/altr,rst-mgr.h
diff -ruN u-boot-2015.01-rc3/arch/powerpc/cpu/mpc85xx/p5040_ids.c u-boot/arch/powerpc/cpu/mpc85xx/p5040_ids.c
--- u-boot-2015.01-rc3/arch/powerpc/cpu/mpc85xx/p5040_ids.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/powerpc/cpu/mpc85xx/p5040_ids.c	2015-01-01 17:34:32.221503777 +0100
@@ -49,23 +49,23 @@
 
 #ifdef CONFIG_SYS_DPAA_FMAN
 struct liodn_id_table fman1_liodn_tbl[] = {
-	SET_FMAN_RX_1G_LIODN(1, 0, 6),
-	SET_FMAN_RX_1G_LIODN(1, 1, 7),
-	SET_FMAN_RX_1G_LIODN(1, 2, 8),
-	SET_FMAN_RX_1G_LIODN(1, 3, 9),
-	SET_FMAN_RX_1G_LIODN(1, 4, 10),
-	SET_FMAN_RX_10G_LIODN(1, 0, 11),
+	SET_FMAN_RX_1G_LIODN(1, 0, 11),
+	SET_FMAN_RX_1G_LIODN(1, 1, 12),
+	SET_FMAN_RX_1G_LIODN(1, 2, 13),
+	SET_FMAN_RX_1G_LIODN(1, 3, 14),
+	SET_FMAN_RX_1G_LIODN(1, 4, 15),
+	SET_FMAN_RX_10G_LIODN(1, 0, 16),
 };
 int fman1_liodn_tbl_sz = ARRAY_SIZE(fman1_liodn_tbl);
 
 #if (CONFIG_SYS_NUM_FMAN == 2)
 struct liodn_id_table fman2_liodn_tbl[] = {
-	SET_FMAN_RX_1G_LIODN(2, 0, 12),
-	SET_FMAN_RX_1G_LIODN(2, 1, 13),
-	SET_FMAN_RX_1G_LIODN(2, 2, 14),
-	SET_FMAN_RX_1G_LIODN(2, 3, 15),
-	SET_FMAN_RX_1G_LIODN(2, 4, 16),
-	SET_FMAN_RX_10G_LIODN(2, 0, 17),
+	SET_FMAN_RX_1G_LIODN(2, 0, 17),
+	SET_FMAN_RX_1G_LIODN(2, 1, 18),
+	SET_FMAN_RX_1G_LIODN(2, 2, 19),
+	SET_FMAN_RX_1G_LIODN(2, 3, 20),
+	SET_FMAN_RX_1G_LIODN(2, 4, 21),
+	SET_FMAN_RX_10G_LIODN(2, 0, 22),
 };
 int fman2_liodn_tbl_sz = ARRAY_SIZE(fman2_liodn_tbl);
 #endif
diff -ruN u-boot-2015.01-rc3/arch/powerpc/cpu/mpc85xx/portals.c u-boot/arch/powerpc/cpu/mpc85xx/portals.c
--- u-boot-2015.01-rc3/arch/powerpc/cpu/mpc85xx/portals.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/powerpc/cpu/mpc85xx/portals.c	2015-01-01 17:34:32.221503777 +0100
@@ -14,9 +14,46 @@
 #include <asm/fsl_portals.h>
 #include <asm/fsl_liodn.h>
 
+#define MAX_BPORTALS (CONFIG_SYS_BMAN_CINH_SIZE / CONFIG_SYS_BMAN_SP_CINH_SIZE)
+#define MAX_QPORTALS (CONFIG_SYS_QMAN_CINH_SIZE / CONFIG_SYS_QMAN_SP_CINH_SIZE)
+static void inhibit_portals(void __iomem *addr, int max_portals,
+			int arch_max_portals, int portal_cinh_size)
+{
+	uint32_t val;
+	int i;
+
+	/* arch_max_portals is the maximum based on memory size. This includes
+	 * the reserved memory in the SoC.  max_portals the number of physical
+	 * portals in the SoC */
+	if (max_portals > arch_max_portals) {
+		printf("ERROR: portal config error\n");
+		max_portals = arch_max_portals;
+	}
+
+	for (i = 0; i < max_portals; i++) {
+		out_be32(addr, -1);
+		val = in_be32(addr);
+		if (!val) {
+			printf("ERROR: Stopped after %d portals\n", i);
+			goto done;
+		}
+		addr += portal_cinh_size;
+	}
+#ifdef DEBUG
+	printf("Cleared %d portals\n", i);
+#endif
+done:
+
+	return;
+}
+
 void setup_portals(void)
 {
 	ccsr_qman_t *qman = (void *)CONFIG_SYS_FSL_QMAN_ADDR;
+	void __iomem *bpaddr = (void *)CONFIG_SYS_BMAN_CINH_BASE +
+				CONFIG_SYS_BMAN_SWP_ISDR_REG;
+	void __iomem *qpaddr = (void *)CONFIG_SYS_QMAN_CINH_BASE +
+				CONFIG_SYS_QMAN_SWP_ISDR_REG;
 #ifdef CONFIG_FSL_CORENET
 	int i;
 
@@ -38,6 +75,12 @@
 	out_be32(&qman->qcsp_bare, (u32)(CONFIG_SYS_QMAN_MEM_PHYS >> 32));
 #endif
 	out_be32(&qman->qcsp_bar, (u32)CONFIG_SYS_QMAN_MEM_PHYS);
+
+	/* Change default state of BMan ISDR portals to all 1s */
+	inhibit_portals(bpaddr, CONFIG_SYS_BMAN_NUM_PORTALS, MAX_BPORTALS,
+			CONFIG_SYS_BMAN_SP_CINH_SIZE);
+	inhibit_portals(qpaddr, CONFIG_SYS_QMAN_NUM_PORTALS, MAX_QPORTALS,
+			CONFIG_SYS_QMAN_SP_CINH_SIZE);
 }
 
 /* Update portal containter to match LAW setup of portal in phy map */
diff -ruN u-boot-2015.01-rc3/arch/powerpc/cpu/mpc85xx/tlb.c u-boot/arch/powerpc/cpu/mpc85xx/tlb.c
--- u-boot-2015.01-rc3/arch/powerpc/cpu/mpc85xx/tlb.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/powerpc/cpu/mpc85xx/tlb.c	2015-01-01 17:34:32.221503777 +0100
@@ -299,12 +299,16 @@
 {
 	unsigned int ram_tlb_address = (unsigned int)CONFIG_SYS_DDR_SDRAM_BASE;
 	u64 memsize = (u64)memsize_in_meg << 20;
+	u64 size;
 
-	memsize = min(memsize, (u64)CONFIG_MAX_MEM_MAPPED);
-	memsize = tlb_map_range(ram_tlb_address, p_addr, memsize, TLB_MAP_RAM);
+	size = min(memsize, (u64)CONFIG_MAX_MEM_MAPPED);
+	size = tlb_map_range(ram_tlb_address, p_addr, size, TLB_MAP_RAM);
 
-	if (memsize)
-		print_size(memsize, " left unmapped\n");
+	if (size || memsize > CONFIG_MAX_MEM_MAPPED) {
+		print_size(memsize > CONFIG_MAX_MEM_MAPPED ?
+			   memsize - CONFIG_MAX_MEM_MAPPED + size : size,
+			   " left unmapped\n");
+	}
 
 	return memsize_in_meg;
 }
diff -ruN u-boot-2015.01-rc3/arch/powerpc/cpu/mpc8xxx/fdt.c u-boot/arch/powerpc/cpu/mpc8xxx/fdt.c
--- u-boot-2015.01-rc3/arch/powerpc/cpu/mpc8xxx/fdt.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/powerpc/cpu/mpc8xxx/fdt.c	2015-01-01 17:34:32.225503711 +0100
@@ -73,110 +73,6 @@
 }
 #endif /* defined(CONFIG_MPC85xx) || defined(CONFIG_MPC86xx) */
 
-#if defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_MPH_USB)
-static int fdt_fixup_usb_mode_phy_type(void *blob, const char *mode,
-				const char *phy_type, int start_offset)
-{
-	const char *compat_dr = "fsl-usb2-dr";
-	const char *compat_mph = "fsl-usb2-mph";
-	const char *prop_mode = "dr_mode";
-	const char *prop_type = "phy_type";
-	const char *node_type = NULL;
-	int node_offset;
-	int err;
-
-	node_offset = fdt_node_offset_by_compatible(blob,
-			start_offset, compat_mph);
-	if (node_offset < 0) {
-		node_offset = fdt_node_offset_by_compatible(blob,
-			start_offset, compat_dr);
-		if (node_offset < 0) {
-			printf("WARNING: could not find compatible"
-				" node %s or %s: %s.\n", compat_mph,
-				compat_dr, fdt_strerror(node_offset));
-			return -1;
-		} else
-			node_type = compat_dr;
-	} else
-		node_type = compat_mph;
-
-	if (mode) {
-		err = fdt_setprop(blob, node_offset, prop_mode, mode,
-				  strlen(mode) + 1);
-		if (err < 0)
-			printf("WARNING: could not set %s for %s: %s.\n",
-			       prop_mode, node_type, fdt_strerror(err));
-	}
-
-	if (phy_type) {
-		err = fdt_setprop(blob, node_offset, prop_type, phy_type,
-				  strlen(phy_type) + 1);
-		if (err < 0)
-			printf("WARNING: could not set %s for %s: %s.\n",
-			       prop_type, node_type, fdt_strerror(err));
-	}
-
-	return node_offset;
-}
-
-void fdt_fixup_dr_usb(void *blob, bd_t *bd)
-{
-	const char *modes[] = { "host", "peripheral", "otg" };
-	const char *phys[] = { "ulpi", "utmi" };
-	int usb_mode_off = -1;
-	int usb_phy_off = -1;
-	char str[5];
-	int i, j;
-
-	for (i = 1; i <= CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
-		const char *dr_mode_type = NULL;
-		const char *dr_phy_type = NULL;
-		int mode_idx = -1, phy_idx = -1;
-		snprintf(str, 5, "%s%d", "usb", i);
-		if (hwconfig(str)) {
-			for (j = 0; j < ARRAY_SIZE(modes); j++) {
-				if (hwconfig_subarg_cmp(str, "dr_mode",
-						modes[j])) {
-					mode_idx = j;
-					break;
-				}
-			}
-
-			for (j = 0; j < ARRAY_SIZE(phys); j++) {
-				if (hwconfig_subarg_cmp(str, "phy_type",
-						phys[j])) {
-					phy_idx = j;
-					break;
-				}
-			}
-
-			if (mode_idx < 0 && phy_idx < 0) {
-				printf("WARNING: invalid phy or mode\n");
-				return;
-			}
-
-			if (mode_idx > -1)
-				dr_mode_type = modes[mode_idx];
-
-			if (phy_idx > -1)
-				dr_phy_type = phys[phy_idx];
-		}
-
-		usb_mode_off = fdt_fixup_usb_mode_phy_type(blob,
-			dr_mode_type, NULL, usb_mode_off);
-
-		if (usb_mode_off < 0)
-			return;
-
-		usb_phy_off = fdt_fixup_usb_mode_phy_type(blob,
-			NULL, dr_phy_type, usb_phy_off);
-
-		if (usb_phy_off < 0)
-			return;
-	}
-}
-#endif /* defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_MPH_USB) */
-
 /*
  * update crypto node properties to a specified revision of the SEC
  * called with sec_rev == 0 if not on an E processor
diff -ruN u-boot-2015.01-rc3/arch/sandbox/dts/include/dt-bindings/pinctrl/pinctrl-tegra.h u-boot/arch/sandbox/dts/include/dt-bindings/pinctrl/pinctrl-tegra.h
diff -ruN u-boot-2015.01-rc3/arch/sandbox/dts/include/dt-bindings/reset/altr,rst-mgr.h u-boot/arch/sandbox/dts/include/dt-bindings/reset/altr,rst-mgr.h
diff -ruN u-boot-2015.01-rc3/arch/sandbox/dts/sandbox.dts u-boot/arch/sandbox/dts/sandbox.dts
--- u-boot-2015.01-rc3/arch/sandbox/dts/sandbox.dts	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/sandbox/dts/sandbox.dts	2015-01-01 17:34:32.241503449 +0100
@@ -134,6 +134,23 @@
 		num-gpios = <20>;
 	};
 
+	i2c@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0>;
+		compatible = "sandbox,i2c";
+		clock-frequency = <400000>;
+		eeprom@2c {
+			reg = <0x2c>;
+			compatible = "i2c-eeprom";
+			emul {
+				compatible = "sandbox,i2c-eeprom";
+				sandbox,filename = "i2c.bin";
+				sandbox,size = <128>;
+			};
+		};
+	};
+
 	spi@0 {
 		#address-cells = <1>;
 		#size-cells = <0>;
diff -ruN u-boot-2015.01-rc3/arch/sandbox/include/asm/test.h u-boot/arch/sandbox/include/asm/test.h
--- u-boot-2015.01-rc3/arch/sandbox/include/asm/test.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/sandbox/include/asm/test.h	2015-01-01 17:34:32.241503449 +0100
@@ -0,0 +1,26 @@
+/*
+ * Test-related constants for sandbox
+ *
+ * Copyright (c) 2014 Google, Inc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_TEST_H
+#define __ASM_TEST_H
+
+/* The sandbox driver always permits an I2C device with this address */
+#define SANDBOX_I2C_TEST_ADDR	0x59
+
+enum sandbox_i2c_eeprom_test_mode {
+	SIE_TEST_MODE_NONE,
+	/* Permits read/write of only one byte per I2C transaction */
+	SIE_TEST_MODE_SINGLE_BYTE,
+};
+
+void sandbox_i2c_eeprom_set_test_mode(struct udevice *dev,
+				      enum sandbox_i2c_eeprom_test_mode mode);
+
+void sandbox_i2c_eeprom_set_offset_len(struct udevice *dev, int offset_len);
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/ivybridge/cpu.c u-boot/arch/x86/cpu/ivybridge/cpu.c
--- u-boot-2015.01-rc3/arch/x86/cpu/ivybridge/cpu.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/cpu/ivybridge/cpu.c	2015-01-01 17:34:32.249503317 +0100
@@ -263,6 +263,7 @@
 static int report_bist_failure(void)
 {
 	if (gd->arch.bist != 0) {
+		post_code(POST_BIST_FAILURE);
 		printf("BIST failed: %08x\n", gd->arch.bist);
 		return -EFAULT;
 	}
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/ivybridge/microcode_intel.c u-boot/arch/x86/cpu/ivybridge/microcode_intel.c
--- u-boot-2015.01-rc3/arch/x86/cpu/ivybridge/microcode_intel.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/cpu/ivybridge/microcode_intel.c	2015-01-01 17:34:32.249503317 +0100
@@ -40,6 +40,8 @@
 	update->data = fdt_getprop(blob, node, "data", &update->size);
 	if (!update->data)
 		return -EINVAL;
+	update->data += 48;
+	update->size -= 48;
 
 	update->header_version = fdtdec_get_int(blob, node,
 						"intel,header-version", 0);
@@ -48,17 +50,17 @@
 	update->date_code = fdtdec_get_int(blob, node,
 					   "intel,date-code", 0);
 	update->processor_signature = fdtdec_get_int(blob, node,
-					"intel.processor-signature", 0);
+					"intel,processor-signature", 0);
 	update->checksum = fdtdec_get_int(blob, node, "intel,checksum", 0);
 	update->loader_revision = fdtdec_get_int(blob, node,
-						 "loader-revision", 0);
+						 "intel,loader-revision", 0);
 	update->processor_flags = fdtdec_get_int(blob, node,
-						 "processor-flags", 0);
+						 "intel,processor-flags", 0);
 
 	return 0;
 }
 
-static uint32_t microcode_read_rev(void)
+static inline uint32_t microcode_read_rev(void)
 {
 	/*
 	 * Some Intel CPUs can be very finicky about the CPUID sequence used.
@@ -114,6 +116,7 @@
 {
 	struct microcode_update cpu, update;
 	const void *blob = gd->fdt_blob;
+	int skipped;
 	int count;
 	int node;
 	int ret;
@@ -121,12 +124,13 @@
 	microcode_read_cpu(&cpu);
 	node = 0;
 	count = 0;
+	skipped = 0;
 	do {
 		node = fdtdec_next_compatible(blob, node,
 					      COMPAT_INTEL_MICROCODE);
 		if (node < 0) {
 			debug("%s: Found %d updates\n", __func__, count);
-			return count ? 0 : -ENOENT;
+			return count ? 0 : skipped ? -EEXIST : -ENOENT;
 		}
 
 		ret = microcode_decode_node(blob, node, &update);
@@ -135,12 +139,15 @@
 			      ret);
 			return ret;
 		}
-		if (update.processor_signature == cpu.processor_signature &&
-		    (update.processor_flags & cpu.processor_flags)) {
-			debug("%s: Update already exists\n", __func__);
-			return -EEXIST;
+		if (!(update.processor_signature == cpu.processor_signature &&
+		      (update.processor_flags & cpu.processor_flags))) {
+			debug("%s: Skipping non-matching update, sig=%x, pf=%x\n",
+			      __func__, update.processor_signature,
+			      update.processor_flags);
+			skipped++;
+			continue;
 		}
-
+		ret = microcode_read_rev();
 		wrmsr(0x79, (ulong)update.data, 0);
 		debug("microcode: updated to revision 0x%x date=%04x-%02x-%02x\n",
 		      microcode_read_rev(), update.date_code & 0xffff,
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/ivybridge/sdram.c u-boot/arch/x86/cpu/ivybridge/sdram.c
--- u-boot-2015.01-rc3/arch/x86/cpu/ivybridge/sdram.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/cpu/ivybridge/sdram.c	2015-01-01 17:34:32.253503252 +0100
@@ -177,7 +177,7 @@
 
 	debug("PEI data at %p, size %x:\n", pei_data, sizeof(*pei_data));
 
-	data = (char *)CONFIG_X86_MRC_START;
+	data = (char *)CONFIG_X86_MRC_ADDR;
 	if (data) {
 		int rv;
 		int (*func)(struct pei_data *);
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/Makefile u-boot/arch/x86/cpu/Makefile
--- u-boot-2015.01-rc3/arch/x86/cpu/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/cpu/Makefile	2015-01-01 17:34:32.249503317 +0100
@@ -15,6 +15,7 @@
 obj-$(CONFIG_SYS_COREBOOT) += coreboot/
 obj-$(CONFIG_NORTHBRIDGE_INTEL_SANDYBRIDGE) += ivybridge/
 obj-$(CONFIG_NORTHBRIDGE_INTEL_IVYBRIDGE) += ivybridge/
+obj-$(CONFIG_INTEL_QUEENSBAY) += queensbay/
 obj-y += lapic.o
 obj-$(CONFIG_PCI) += pci.o
 obj-y += turbo.o
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/queensbay/fsp_configs.c u-boot/arch/x86/cpu/queensbay/fsp_configs.c
--- u-boot-2015.01-rc3/arch/x86/cpu/queensbay/fsp_configs.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/cpu/queensbay/fsp_configs.c	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#include <common.h>
+#include <asm/arch/fsp/fsp_support.h>
+
+void update_fsp_upd(struct upd_region *fsp_upd)
+{
+	/* Override any UPD setting if required */
+
+	/* Uncomment the line below to enable DEBUG message */
+	/* fsp_upd->serial_dbgport_type = 1; */
+
+	/* Examples on how to initialize the pointers in UPD region */
+	/* fsp_upd->pcd_example = (EXAMPLE_DATA *)&example; */
+}
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/queensbay/fsp_support.c u-boot/arch/x86/cpu/queensbay/fsp_support.c
--- u-boot-2015.01-rc3/arch/x86/cpu/queensbay/fsp_support.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/cpu/queensbay/fsp_support.c	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,401 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#include <common.h>
+#include <asm/arch/fsp/fsp_support.h>
+#include <asm/post.h>
+
+/**
+ * Compares two GUIDs
+ *
+ * If the GUIDs are identical then true is returned.
+ * If there are any bit differences in the two GUIDs, then false is returned.
+ *
+ * @guid1:        A pointer to a 128 bit GUID.
+ * @guid2:        A pointer to a 128 bit GUID.
+ *
+ * @retval true:  guid1 and guid2 are identical.
+ * @retval false: guid1 and guid2 are not identical.
+ */
+static bool compare_guid(const struct efi_guid *guid1,
+			 const struct efi_guid *guid2)
+{
+	if (memcmp(guid1, guid2, sizeof(struct efi_guid)) == 0)
+		return true;
+	else
+		return false;
+}
+
+u32 __attribute__((optimize("O0"))) find_fsp_header(void)
+{
+	/*
+	 * This function may be called before the a stack is established,
+	 * so special care must be taken. First, it cannot declare any local
+	 * variable using stack. Only register variable can be used here.
+	 * Secondly, some compiler version will add prolog or epilog code
+	 * for the C function. If so the function call may not work before
+	 * stack is ready.
+	 *
+	 * GCC 4.8.1 has been verified to be working for the following codes.
+	 */
+	volatile register u8 *fsp asm("eax");
+
+	/* Initalize the FSP base */
+	fsp = (u8 *)CONFIG_FSP_ADDR;
+
+	/* Check the FV signature, _FVH */
+	if (((struct fv_header *)fsp)->sign == EFI_FVH_SIGNATURE) {
+		/* Go to the end of the FV header and align the address */
+		fsp += ((struct fv_header *)fsp)->ext_hdr_off;
+		fsp += ((struct fv_ext_header *)fsp)->ext_hdr_size;
+		fsp  = (u8 *)(((u32)fsp + 7) & 0xFFFFFFF8);
+	} else {
+		fsp  = 0;
+	}
+
+	/* Check the FFS GUID */
+	if (fsp &&
+	    ((struct ffs_file_header *)fsp)->name.data1 == FSP_GUID_DATA1 &&
+	    ((struct ffs_file_header *)fsp)->name.data2 == FSP_GUID_DATA2 &&
+	    ((struct ffs_file_header *)fsp)->name.data3 == FSP_GUID_DATA3 &&
+	    ((struct ffs_file_header *)fsp)->name.data4[0] == FSP_GUID_DATA4_0 &&
+	    ((struct ffs_file_header *)fsp)->name.data4[1] == FSP_GUID_DATA4_1 &&
+	    ((struct ffs_file_header *)fsp)->name.data4[2] == FSP_GUID_DATA4_2 &&
+	    ((struct ffs_file_header *)fsp)->name.data4[3] == FSP_GUID_DATA4_3 &&
+	    ((struct ffs_file_header *)fsp)->name.data4[4] == FSP_GUID_DATA4_4 &&
+	    ((struct ffs_file_header *)fsp)->name.data4[5] == FSP_GUID_DATA4_5 &&
+	    ((struct ffs_file_header *)fsp)->name.data4[6] == FSP_GUID_DATA4_6 &&
+	    ((struct ffs_file_header *)fsp)->name.data4[7] == FSP_GUID_DATA4_7) {
+		/* Add the FFS header size to find the raw section header */
+		fsp += sizeof(struct ffs_file_header);
+	} else {
+		fsp = 0;
+	}
+
+	if (fsp &&
+	    ((struct raw_section *)fsp)->type == EFI_SECTION_RAW) {
+		/* Add the raw section header size to find the FSP header */
+		fsp += sizeof(struct raw_section);
+	} else {
+		fsp = 0;
+	}
+
+	return (u32)fsp;
+}
+
+void fsp_continue(struct shared_data *shared_data, u32 status, void *hob_list)
+{
+	u32 stack_len;
+	u32 stack_base;
+	u32 stack_top;
+
+	post_code(POST_MRC);
+
+	assert(status == 0);
+
+	/* Get the migrated stack in normal memory */
+	stack_base = (u32)fsp_get_bootloader_tmp_mem(hob_list, &stack_len);
+	assert(stack_base != 0);
+	stack_top  = stack_base + stack_len - sizeof(u32);
+
+	/*
+	 * Old stack base is stored at the very end of the stack top,
+	 * use it to calculate the migrated shared data base
+	 */
+	shared_data = (struct shared_data *)(stack_base +
+			((u32)shared_data - *(u32 *)stack_top));
+
+	/* The boot loader main function entry */
+	fsp_init_done(hob_list);
+}
+
+void fsp_init(u32 stack_top, u32 boot_mode, void *nvs_buf)
+{
+	struct shared_data shared_data;
+	fsp_init_f init;
+	struct fsp_init_params params;
+	struct fspinit_rtbuf rt_buf;
+	struct vpd_region *fsp_vpd;
+	struct fsp_header *fsp_hdr;
+	struct fsp_init_params *params_ptr;
+	struct upd_region *fsp_upd;
+
+	fsp_hdr = (struct fsp_header *)find_fsp_header();
+	if (fsp_hdr == NULL) {
+		/* No valid FSP info header was found */
+		panic("Invalid FSP header");
+	}
+
+	fsp_upd = (struct upd_region *)&shared_data.fsp_upd;
+	memset(&rt_buf, 0, sizeof(struct fspinit_rtbuf));
+
+	/* Reserve a gap in stack top */
+	rt_buf.common.stack_top = (u32 *)stack_top - 32;
+	rt_buf.common.boot_mode = boot_mode;
+	rt_buf.common.upd_data = (struct upd_region *)fsp_upd;
+
+	/* Get VPD region start */
+	fsp_vpd = (struct vpd_region *)(fsp_hdr->img_base +
+			fsp_hdr->cfg_region_off);
+
+	/* Verifify the VPD data region is valid */
+	assert((fsp_vpd->img_rev == VPD_IMAGE_REV) &&
+	       (fsp_vpd->sign == VPD_IMAGE_ID));
+
+	/* Copy default data from Flash */
+	memcpy(fsp_upd, (void *)(fsp_hdr->img_base + fsp_vpd->upd_offset),
+	       sizeof(struct upd_region));
+
+	/* Verifify the UPD data region is valid */
+	assert(fsp_upd->terminator == UPD_TERMINATOR);
+
+	/* Override any UPD setting if required */
+	update_fsp_upd(fsp_upd);
+
+	memset(&params, 0, sizeof(struct fsp_init_params));
+	params.nvs_buf = nvs_buf;
+	params.rt_buf = (struct fspinit_rtbuf *)&rt_buf;
+	params.continuation = (fsp_continuation_f)asm_continuation;
+
+	init = (fsp_init_f)(fsp_hdr->img_base + fsp_hdr->fsp_init);
+	params_ptr = &params;
+
+	shared_data.fsp_hdr = fsp_hdr;
+	shared_data.stack_top = (u32 *)stack_top;
+
+	post_code(POST_PRE_MRC);
+
+	/*
+	 * Use ASM code to ensure the register value in EAX & ECX
+	 * will be passed into BlContinuationFunc
+	 */
+	asm volatile (
+		"pushl	%0;"
+		"call	*%%eax;"
+		".global asm_continuation;"
+		"asm_continuation:;"
+		"movl	%%ebx, %%eax;"		/* shared_data */
+		"movl	4(%%esp), %%edx;"	/* status */
+		"movl	8(%%esp), %%ecx;"	/* hob_list */
+		"jmp	fsp_continue;"
+		: : "m"(params_ptr), "a"(init), "b"(&shared_data)
+	);
+
+	/*
+	 * Should never get here.
+	 * Control will continue from fsp_continue.
+	 * This line below is to prevent the compiler from optimizing
+	 * structure intialization.
+	 *
+	 * DO NOT REMOVE!
+	 */
+	init(&params);
+}
+
+u32 fsp_notify(struct fsp_header *fsp_hdr, u32 phase)
+{
+	fsp_notify_f notify;
+	struct fsp_notify_params params;
+	struct fsp_notify_params *params_ptr;
+	u32 status;
+
+	if (!fsp_hdr)
+		fsp_hdr = (struct fsp_header *)find_fsp_header();
+
+	if (fsp_hdr == NULL) {
+		/* No valid FSP info header */
+		panic("Invalid FSP header");
+	}
+
+	notify = (fsp_notify_f)(fsp_hdr->img_base + fsp_hdr->fsp_notify);
+	params.phase = phase;
+	params_ptr = &params;
+
+	/*
+	 * Use ASM code to ensure correct parameter is on the stack for
+	 * FspNotify as U-Boot is using different ABI from FSP
+	 */
+	asm volatile (
+		"pushl	%1;"		/* push notify phase */
+		"call	*%%eax;"	/* call FspNotify */
+		"addl	$4, %%esp;"	/* clean up the stack */
+		: "=a"(status) : "m"(params_ptr), "a"(notify), "m"(*params_ptr)
+	);
+
+	return status;
+}
+
+u32 fsp_get_usable_lowmem_top(const void *hob_list)
+{
+	union hob_pointers hob;
+	phys_addr_t phys_start;
+	u32 top;
+
+	/* Get the HOB list for processing */
+	hob.raw = (void *)hob_list;
+
+	/* * Collect memory ranges */
+	top = FSP_LOWMEM_BASE;
+	while (!end_of_hob(hob)) {
+		if (get_hob_type(hob) == HOB_TYPE_RES_DESC) {
+			if (hob.res_desc->type == RES_SYS_MEM) {
+				phys_start = hob.res_desc->phys_start;
+				/* Need memory above 1MB to be collected here */
+				if (phys_start >= FSP_LOWMEM_BASE &&
+				    phys_start < (phys_addr_t)FSP_HIGHMEM_BASE)
+					top += (u32)(hob.res_desc->len);
+			}
+		}
+		hob.raw = get_next_hob(hob);
+	}
+
+	return top;
+}
+
+u64 fsp_get_usable_highmem_top(const void *hob_list)
+{
+	union hob_pointers hob;
+	phys_addr_t phys_start;
+	u64 top;
+
+	/* Get the HOB list for processing */
+	hob.raw = (void *)hob_list;
+
+	/* Collect memory ranges */
+	top = FSP_HIGHMEM_BASE;
+	while (!end_of_hob(hob)) {
+		if (get_hob_type(hob) == HOB_TYPE_RES_DESC) {
+			if (hob.res_desc->type == RES_SYS_MEM) {
+				phys_start = hob.res_desc->phys_start;
+				/* Need memory above 1MB to be collected here */
+				if (phys_start >= (phys_addr_t)FSP_HIGHMEM_BASE)
+					top += (u32)(hob.res_desc->len);
+			}
+		}
+		hob.raw = get_next_hob(hob);
+	}
+
+	return top;
+}
+
+u64 fsp_get_reserved_mem_from_guid(const void *hob_list, u64 *len,
+				   struct efi_guid *guid)
+{
+	union hob_pointers hob;
+
+	/* Get the HOB list for processing */
+	hob.raw = (void *)hob_list;
+
+	/* Collect memory ranges */
+	while (!end_of_hob(hob)) {
+		if (get_hob_type(hob) == HOB_TYPE_RES_DESC) {
+			if (hob.res_desc->type == RES_MEM_RESERVED) {
+				if (compare_guid(&hob.res_desc->owner, guid)) {
+					if (len)
+						*len = (u32)(hob.res_desc->len);
+
+					return (u64)(hob.res_desc->phys_start);
+				}
+			}
+		}
+		hob.raw = get_next_hob(hob);
+	}
+
+	return 0;
+}
+
+u32 fsp_get_fsp_reserved_mem(const void *hob_list, u32 *len)
+{
+	const struct efi_guid guid = FSP_HOB_RESOURCE_OWNER_FSP_GUID;
+	u64 length;
+	u32 base;
+
+	base = (u32)fsp_get_reserved_mem_from_guid(hob_list,
+			&length, (struct efi_guid *)&guid);
+	if ((len != 0) && (base != 0))
+		*len = (u32)length;
+
+	return base;
+}
+
+u32 fsp_get_tseg_reserved_mem(const void *hob_list, u32 *len)
+{
+	const struct efi_guid guid = FSP_HOB_RESOURCE_OWNER_TSEG_GUID;
+	u64 length;
+	u32 base;
+
+	base = (u32)fsp_get_reserved_mem_from_guid(hob_list,
+			&length, (struct efi_guid *)&guid);
+	if ((len != 0) && (base != 0))
+		*len = (u32)length;
+
+	return base;
+}
+
+void *fsp_get_next_hob(u16 type, const void *hob_list)
+{
+	union hob_pointers hob;
+
+	assert(hob_list != NULL);
+
+	hob.raw = (u8 *)hob_list;
+
+	/* Parse the HOB list until end of list or matching type is found */
+	while (!end_of_hob(hob)) {
+		if (get_hob_type(hob) == type)
+			return hob.raw;
+
+		hob.raw = get_next_hob(hob);
+	}
+
+	return NULL;
+}
+
+void *fsp_get_next_guid_hob(const struct efi_guid *guid, const void *hob_list)
+{
+	union hob_pointers hob;
+
+	hob.raw = (u8 *)hob_list;
+	while ((hob.raw = fsp_get_next_hob(HOB_TYPE_GUID_EXT,
+			hob.raw)) != NULL) {
+		if (compare_guid(guid, &hob.guid->name))
+			break;
+		hob.raw = get_next_hob(hob);
+	}
+
+	return hob.raw;
+}
+
+void *fsp_get_guid_hob_data(const void *hob_list, u32 *len,
+			    struct efi_guid *guid)
+{
+	u8 *guid_hob;
+
+	guid_hob = fsp_get_next_guid_hob(guid, hob_list);
+	if (guid_hob == NULL) {
+		return NULL;
+	} else {
+		if (len)
+			*len = get_guid_hob_data_size(guid_hob);
+
+		return get_guid_hob_data(guid_hob);
+	}
+}
+
+void *fsp_get_nvs_data(const void *hob_list, u32 *len)
+{
+	const struct efi_guid guid = FSP_NON_VOLATILE_STORAGE_HOB_GUID;
+
+	return fsp_get_guid_hob_data(hob_list, len, (struct efi_guid *)&guid);
+}
+
+void *fsp_get_bootloader_tmp_mem(const void *hob_list, u32 *len)
+{
+	const struct efi_guid guid = FSP_BOOTLOADER_TEMP_MEM_HOB_GUID;
+
+	return fsp_get_guid_hob_data(hob_list, len, (struct efi_guid *)&guid);
+}
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/queensbay/Kconfig u-boot/arch/x86/cpu/queensbay/Kconfig
--- u-boot-2015.01-rc3/arch/x86/cpu/queensbay/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/cpu/queensbay/Kconfig	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,79 @@
+#
+# Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+config INTEL_QUEENSBAY
+	bool
+	select HAVE_FSP
+	select HAVE_CMC
+
+if INTEL_QUEENSBAY
+
+config HAVE_FSP
+	bool "Add an Firmware Support Package binary"
+	help
+	  Select this option to add an Firmware Support Package binary to
+	  the resulting U-Boot image. It is a binary blob which U-Boot uses
+	  to set up SDRAM and other chipset specific initialization.
+
+	  Note: Without this binary U-Boot will not be able to set up its
+	  SDRAM so will not boot.
+
+config FSP_FILE
+	string "Firmware Support Package binary filename"
+	depends on HAVE_FSP
+	default "fsp.bin"
+	help
+	  The filename of the file to use as Firmware Support Package binary
+	  in the board directory.
+
+config FSP_ADDR
+	hex "Firmware Support Package binary location"
+	depends on HAVE_FSP
+	default 0xfffc0000
+	help
+	  FSP is not Position Independent Code (PIC) and the whole FSP has to
+	  be rebased if it is placed at a location which is different from the
+	  perferred base address specified during the FSP build. Use Intel's
+	  Binary Configuration Tool (BCT) to do the rebase.
+
+	  The default base address of 0xfffc0000 indicates that the binary must
+	  be located at offset 0xc0000 from the beginning of a 1MB flash device.
+
+config FSP_TEMP_RAM_ADDR
+	hex
+	default 0x2000000
+	help
+	  Stack top address which is used in FspInit after DRAM is ready and
+	  CAR is disabled.
+
+config HAVE_CMC
+	bool "Add a Chipset Micro Code state machine binary"
+	help
+	  Select this option to add a Chipset Micro Code state machine binary
+	  to the resulting U-Boot image. It is a 64K data block of machine
+	  specific code which must be put in the flash for the processor to
+	  access when powered up before system BIOS is executed.
+
+config CMC_FILE
+	string "Chipset Micro Code state machine filename"
+	depends on HAVE_CMC
+	default "cmc.bin"
+	help
+	  The filename of the file to use as Chipset Micro Code state machine
+	  binary in the board directory.
+
+config CMC_ADDR
+	hex "Chipset Micro Code state machine binary location"
+	depends on HAVE_CMC
+	default 0xfffb0000
+	help
+	  The location of the CMC binary is determined by a strap. It must be
+	  put in flash at a location matching the strap-determined base address.
+
+	  The default base address of 0xfffb0000 indicates that the binary must
+	  be located at offset 0xb0000 from the beginning of a 1MB flash device.
+
+endif
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/queensbay/Makefile u-boot/arch/x86/cpu/queensbay/Makefile
--- u-boot-2015.01-rc3/arch/x86/cpu/queensbay/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/cpu/queensbay/Makefile	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y += tnc_car.o tnc_dram.o tnc.o topcliff.o
+obj-y += fsp_configs.o fsp_support.o
+obj-$(CONFIG_PCI) += tnc_pci.o
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/queensbay/tnc.c u-boot/arch/x86/cpu/queensbay/tnc.c
--- u-boot-2015.01-rc3/arch/x86/cpu/queensbay/tnc.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/cpu/queensbay/tnc.c	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/pci.h>
+#include <asm/post.h>
+#include <asm/arch/tnc.h>
+#include <asm/arch/fsp/fsp_support.h>
+#include <asm/processor.h>
+
+static void unprotect_spi_flash(void)
+{
+	u32 bc;
+
+	bc = pci_read_config32(PCH_LPC_DEV, 0xd8);
+	bc |= 0x1;	/* unprotect the flash */
+	pci_write_config32(PCH_LPC_DEV, 0xd8, bc);
+}
+
+int arch_cpu_init(void)
+{
+	struct pci_controller *hose;
+	int ret;
+
+	post_code(POST_CPU_INIT);
+#ifdef CONFIG_SYS_X86_TSC_TIMER
+	timer_set_base(rdtsc());
+#endif
+
+	ret = x86_cpu_init_f();
+	if (ret)
+		return ret;
+
+	ret = pci_early_init_hose(&hose);
+	if (ret)
+		return ret;
+
+	unprotect_spi_flash();
+
+	return 0;
+}
+
+int print_cpuinfo(void)
+{
+	post_code(POST_CPU_INFO);
+	return default_print_cpuinfo();
+}
+
+void reset_cpu(ulong addr)
+{
+	/* cold reset */
+	outb(0x06, PORT_RESET);
+}
+
+void board_final_cleanup(void)
+{
+	u32 status;
+
+	/* call into FspNotify */
+	debug("Calling into FSP (notify phase INIT_PHASE_BOOT): ");
+	status = fsp_notify(NULL, INIT_PHASE_BOOT);
+	if (status != FSP_SUCCESS)
+		debug("fail, error code %x\n", status);
+	else
+		debug("OK\n");
+
+	return;
+}
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/queensbay/tnc_car.S u-boot/arch/x86/cpu/queensbay/tnc_car.S
--- u-boot-2015.01-rc3/arch/x86/cpu/queensbay/tnc_car.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/cpu/queensbay/tnc_car.S	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+#include <asm/post.h>
+
+.globl car_init
+car_init:
+	/*
+	 * Note: ebp holds the BIST value (built-in self test) so far, but ebp
+	 * will be destroyed through the FSP call, thus we have to test the
+	 * BIST value here before we call into FSP.
+	 */
+	test	%ebp, %ebp
+	jz	car_init_start
+	post_code(POST_BIST_FAILURE)
+	jmp	die
+
+car_init_start:
+	post_code(POST_CAR_START)
+	lea	find_fsp_header_romstack, %esp
+	jmp	find_fsp_header
+
+find_fsp_header_ret:
+	/* EAX points to FSP_INFO_HEADER */
+	mov	%eax, %ebp
+
+	/* sanity test */
+	cmp	$CONFIG_FSP_ADDR, %eax
+	jb	die
+
+	/* calculate TempRamInitEntry address */
+	mov	0x30(%ebp), %eax
+	add	0x1c(%ebp), %eax
+
+	/* call FSP TempRamInitEntry to setup temporary stack */
+	lea	temp_ram_init_romstack, %esp
+	jmp	*%eax
+
+temp_ram_init_ret:
+	addl	$4, %esp
+	cmp	$0, %eax
+	jnz	car_init_fail
+
+	post_code(POST_CAR_CPU_CACHE)
+
+	/*
+	 * The FSP TempRamInit initializes the ecx and edx registers to
+	 * point to a temporary but writable memory range (Cache-As-RAM).
+	 * ecx: the start of this temporary memory range,
+	 * edx: the end of this range.
+	 */
+
+	/* stack grows down from top of CAR */
+	movl	%edx, %esp
+
+	/*
+	 * TODO:
+	 *
+	 * According to FSP architecture spec, the fsp_init() will not return
+	 * to its caller, instead it requires the bootloader to provide a
+	 * so-called continuation function to pass into the FSP as a parameter
+	 * of fsp_init, and fsp_init() will call that continuation function
+	 * directly.
+	 *
+	 * The call to fsp_init() may need to be moved out of the car_init()
+	 * to cpu_init_f() with the help of some inline assembly codes.
+	 * Note there is another issue that fsp_init() will setup another stack
+	 * using the fsp_init parameter stack_top after DRAM is initialized,
+	 * which means any data on the previous stack (on the CAR) gets lost
+	 * (ie: U-Boot global_data). FSP is supposed to support such scenario,
+	 * however it does not work. This should be revisited in the future.
+	 */
+	movl	$CONFIG_FSP_TEMP_RAM_ADDR, %eax
+	xorl	%edx, %edx
+	xorl	%ecx, %ecx
+	call	fsp_init
+
+.global fsp_init_done
+fsp_init_done:
+	/*
+	 * We come here from FspInit with eax pointing to the HOB list.
+	 * Save eax to esi temporarily.
+	 */
+	movl	%eax, %esi
+	/*
+	 * Re-initialize the ebp (BIST) to zero, as we already reach here
+	 * which means we passed BIST testing before.
+	 */
+	xorl	%ebp, %ebp
+	jmp	car_init_ret
+
+car_init_fail:
+	post_code(POST_CAR_FAILURE)
+
+die:
+	hlt
+	jmp	die
+	hlt
+
+	/*
+	 * The function call before CAR initialization is tricky. It cannot
+	 * be called using the 'call' instruction but only the 'jmp' with
+	 * the help of a handcrafted stack in the ROM. The stack needs to
+	 * contain the function return address as well as the parameters.
+	 */
+	.balign	4
+find_fsp_header_romstack:
+	.long	find_fsp_header_ret
+
+	.balign	4
+temp_ram_init_romstack:
+	.long	temp_ram_init_ret
+	.long	temp_ram_init_params
+temp_ram_init_params:
+_dt_ucode_base_size:
+	/* These next two fields are filled in by ifdtool */
+	.long	0			/* microcode base */
+	.long	0			/* microcode size */
+	.long	CONFIG_SYS_MONITOR_BASE	/* code region base */
+	.long	CONFIG_SYS_MONITOR_LEN	/* code region size */
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/queensbay/tnc_dram.c u-boot/arch/x86/cpu/queensbay/tnc_dram.c
--- u-boot-2015.01-rc3/arch/x86/cpu/queensbay/tnc_dram.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/cpu/queensbay/tnc_dram.c	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/fsp/fsp_support.h>
+#include <asm/e820.h>
+#include <asm/post.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int dram_init(void)
+{
+	phys_size_t ram_size = 0;
+	union hob_pointers hob;
+
+	hob.raw = gd->arch.hob_list;
+	while (!end_of_hob(hob)) {
+		if (get_hob_type(hob) == HOB_TYPE_RES_DESC) {
+			if (hob.res_desc->type == RES_SYS_MEM ||
+			    hob.res_desc->type == RES_MEM_RESERVED) {
+				ram_size += hob.res_desc->len;
+			}
+		}
+		hob.raw = get_next_hob(hob);
+	}
+
+	gd->ram_size = ram_size;
+	post_code(POST_DRAM);
+
+	return 0;
+}
+
+void dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = 0;
+	gd->bd->bi_dram[0].size = gd->ram_size;
+}
+
+/*
+ * This function looks for the highest region of memory lower than 4GB which
+ * has enough space for U-Boot where U-Boot is aligned on a page boundary.
+ * It overrides the default implementation found elsewhere which simply
+ * picks the end of ram, wherever that may be. The location of the stack,
+ * the relocation address, and how far U-Boot is moved by relocation are
+ * set in the global data structure.
+ */
+ulong board_get_usable_ram_top(ulong total_size)
+{
+	return fsp_get_usable_lowmem_top(gd->arch.hob_list);
+}
+
+unsigned install_e820_map(unsigned max_entries, struct e820entry *entries)
+{
+	unsigned num_entries = 0;
+
+	union hob_pointers hob;
+
+	hob.raw = gd->arch.hob_list;
+
+	while (!end_of_hob(hob)) {
+		if (get_hob_type(hob) == HOB_TYPE_RES_DESC) {
+			entries[num_entries].addr = hob.res_desc->phys_start;
+			entries[num_entries].size = hob.res_desc->len;
+
+			if (hob.res_desc->type == RES_SYS_MEM)
+				entries[num_entries].type = E820_RAM;
+			else if (hob.res_desc->type == RES_MEM_RESERVED)
+				entries[num_entries].type = E820_RESERVED;
+		}
+		hob.raw = get_next_hob(hob);
+		num_entries++;
+	}
+
+	return num_entries;
+}
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/queensbay/tnc_pci.c u-boot/arch/x86/cpu/queensbay/tnc_pci.c
--- u-boot-2015.01-rc3/arch/x86/cpu/queensbay/tnc_pci.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/cpu/queensbay/tnc_pci.c	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <asm/pci.h>
+#include <asm/arch/fsp/fsp_support.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void board_pci_setup_hose(struct pci_controller *hose)
+{
+	hose->first_busno = 0;
+	hose->last_busno = 0;
+
+	/* PCI memory space */
+	pci_set_region(hose->regions + 0,
+		       CONFIG_PCI_MEM_BUS,
+		       CONFIG_PCI_MEM_PHYS,
+		       CONFIG_PCI_MEM_SIZE,
+		       PCI_REGION_MEM);
+
+	/* PCI IO space */
+	pci_set_region(hose->regions + 1,
+		       CONFIG_PCI_IO_BUS,
+		       CONFIG_PCI_IO_PHYS,
+		       CONFIG_PCI_IO_SIZE,
+		       PCI_REGION_IO);
+
+	pci_set_region(hose->regions + 2,
+		       CONFIG_PCI_PREF_BUS,
+		       CONFIG_PCI_PREF_PHYS,
+		       CONFIG_PCI_PREF_SIZE,
+		       PCI_REGION_PREFETCH);
+
+	pci_set_region(hose->regions + 3,
+		       0,
+		       0,
+		       gd->ram_size,
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
+
+	hose->region_count = 4;
+}
+
+int board_pci_post_scan(struct pci_controller *hose)
+{
+	u32 status;
+
+	/* call into FspNotify */
+	debug("Calling into FSP (notify phase INIT_PHASE_PCI): ");
+	status = fsp_notify(NULL, INIT_PHASE_PCI);
+	if (status != FSP_SUCCESS)
+		debug("fail, error code %x\n", status);
+	else
+		debug("OK\n");
+
+	return 0;
+}
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/queensbay/topcliff.c u-boot/arch/x86/cpu/queensbay/topcliff.c
--- u-boot-2015.01-rc3/arch/x86/cpu/queensbay/topcliff.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/cpu/queensbay/topcliff.c	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <pci.h>
+#include <pci_ids.h>
+#include <sdhci.h>
+
+static struct pci_device_id mmc_supported[] = {
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_TCF_SDIO_0 },
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_TCF_SDIO_1 },
+	{ }
+};
+
+int cpu_mmc_init(bd_t *bis)
+{
+	struct sdhci_host *mmc_host;
+	pci_dev_t devbusfn;
+	u32 iobase;
+	int ret;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mmc_supported); i++) {
+		devbusfn =  pci_find_devices(mmc_supported, i);
+		if (devbusfn == -1)
+			return -ENODEV;
+
+		mmc_host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
+		if (!mmc_host)
+			return -ENOMEM;
+
+		mmc_host->name = "Topcliff SDHCI";
+		pci_read_config_dword(devbusfn, PCI_BASE_ADDRESS_0, &iobase);
+		mmc_host->ioaddr = (void *)iobase;
+		mmc_host->quirks = 0;
+		ret = add_sdhci(mmc_host, 0, 0);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
diff -ruN u-boot-2015.01-rc3/arch/x86/cpu/start.S u-boot/arch/x86/cpu/start.S
--- u-boot-2015.01-rc3/arch/x86/cpu/start.S	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/cpu/start.S	2015-01-01 17:34:32.253503252 +0100
@@ -1,5 +1,5 @@
 /*
- *  U-boot - x86 Startup Code
+ *  U-Boot - x86 Startup Code
  *
  * (C) Copyright 2008-2011
  * Graeme Russ, <graeme.russ@gmail.com>
@@ -17,6 +17,7 @@
 #include <asm/processor.h>
 #include <asm/processor-flags.h>
 #include <generated/generic-asm-offsets.h>
+#include <generated/asm-offsets.h>
 
 .section .text
 .code32
@@ -74,6 +75,7 @@
 	jmp	car_init
 .globl car_init_ret
 car_init_ret:
+#ifndef CONFIG_HAVE_FSP
 	/*
 	 * We now have CONFIG_SYS_CAR_SIZE bytes of Cache-As-RAM (or SRAM,
 	 * or fully initialised SDRAM - we really don't care which)
@@ -94,6 +96,12 @@
 #ifdef CONFIG_DCACHE_RAM_MRC_VAR_SIZE
 	subl	$CONFIG_DCACHE_RAM_MRC_VAR_SIZE, %esp
 #endif
+#else
+	/*
+	 * When we get here after car_init, esp points to a temporary stack
+	 * and esi holds the HOB list address returned by the FSP.
+	 */
+#endif
 
 	/* Reserve space on stack for global data */
 	subl	$GENERATED_GBL_DATA_SIZE, %esp
@@ -108,6 +116,13 @@
 	movl	%esp, %edi
 	rep	stosb
 
+#ifdef CONFIG_HAVE_FSP
+	/* Store HOB list */
+	movl	%esp, %edx
+	addl	$GD_HOB_LIST, %edx
+	movl	%esi, (%edx)
+#endif
+
 	/* Setup first parameter to setup_gdt, pointer to global_data */
 	movl	%esp, %eax
 
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/chromebook_link.dts u-boot/arch/x86/dts/chromebook_link.dts
--- u-boot-2015.01-rc3/arch/x86/dts/chromebook_link.dts	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/dts/chromebook_link.dts	2015-01-01 17:34:32.253503252 +0100
@@ -214,10 +214,10 @@
 
 	microcode {
 		update@0 {
-#include "m12206a7_00000028.dtsi"
+#include "microcode/m12206a7_00000029.dtsi"
 		};
 		update@1 {
-#include "m12306a9_00000017.dtsi"
+#include "microcode/m12306a9_0000001b.dtsi"
 		};
 	};
 
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/coreboot.dtsi u-boot/arch/x86/dts/coreboot.dtsi
--- u-boot-2015.01-rc3/arch/x86/dts/coreboot.dtsi	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/dts/coreboot.dtsi	2015-01-01 17:34:32.253503252 +0100
@@ -6,7 +6,7 @@
 	};
 
 	serial {
-		compatible = "coreboot-uart";
+		compatible = "x86-uart";
 		reg = <0x3f8 0x10>;
 		reg-shift = <0>;
 		io-mapped = <1>;
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/crownbay.dts u-boot/arch/x86/dts/crownbay.dts
--- u-boot-2015.01-rc3/arch/x86/dts/crownbay.dts	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/dts/crownbay.dts	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+
+/include/ "coreboot.dtsi"
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	model = "Intel Crown Bay";
+	compatible = "intel,crownbay", "intel,queensbay";
+
+	config {
+		silent_console = <0>;
+	};
+
+	gpioa {
+		compatible = "intel,ich6-gpio";
+		u-boot,dm-pre-reloc;
+		reg = <0 0x20>;
+		bank-name = "A";
+	};
+
+	gpiob {
+		compatible = "intel,ich6-gpio";
+		u-boot,dm-pre-reloc;
+		reg = <0x20 0x20>;
+		bank-name = "B";
+	};
+
+	serial {
+		reg = <0x3f8 8>;
+		clock-frequency = <115200>;
+	};
+
+	chosen { };
+	memory { device_type = "memory"; reg = <0 0>; };
+
+	spi {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "intel,ich7";
+		spi-flash@0 {
+			reg = <0>;
+			compatible = "sst,25vf016b", "spi-flash";
+			memory-map = <0xffe00000 0x00200000>;
+		};
+	};
+
+	microcode {
+		update@0 {
+#include "microcode/m0220661105_cv.dtsi"
+		};
+	};
+
+};
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/include/dt-bindings/pinctrl/pinctrl-tegra.h u-boot/arch/x86/dts/include/dt-bindings/pinctrl/pinctrl-tegra.h
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/include/dt-bindings/reset/altr,rst-mgr.h u-boot/arch/x86/dts/include/dt-bindings/reset/altr,rst-mgr.h
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/link.dts u-boot/arch/x86/dts/link.dts
--- u-boot-2015.01-rc3/arch/x86/dts/link.dts	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/dts/link.dts	2015-01-01 17:34:32.253503252 +0100
@@ -214,10 +214,10 @@
 
 	microcode {
 		update@0 {
-#include "m12206a7_00000028.dtsi"
+#include "microcode/m12206a7_00000029.dtsi"
 		};
 		update@1 {
-#include "m12306a9_00000017.dtsi"
+#include "microcode/m12306a9_0000001b.dtsi"
 		};
 	};
 
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/m12206a7_00000028.dtsi u-boot/arch/x86/dts/m12206a7_00000028.dtsi
--- u-boot-2015.01-rc3/arch/x86/dts/m12206a7_00000028.dtsi	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/dts/m12206a7_00000028.dtsi	1970-01-01 01:00:00.000000000 +0100
@@ -1,622 +0,0 @@
-/*
- * Copyright (c) <1995-2013>, Intel Corporation.
- * All rights reserved.
- *
- * Redistribution. Redistribution and use in binary form, without modification, are
- * permitted provided that the following conditions are met:
- *	.Redistributions must reproduce the above copyright notice and the following
- * disclaimer in the documentation and/or other materials provided with the
- * distribution.
- * Neither the name of Intel Corporation nor the names of its suppliers may be used
- * to endorse or promote products derived from this software without specific prior
- * written permission.
- *	.No reverse engineering, decompilation, or disassembly of this software is
- * permitted.
- *	."Binary form" includes any format commonly used for electronic conveyance
- * which is a reversible, bit-exact translation of binary representation to ASCII or
- * ISO text, for example, "uuencode."
- *
- * DISCLAIMER. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
- * HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *---
- * This is a device tree fragment. Use #include to add these properties to a
- * node.
- */
-
-compatible = "intel,microcode";
-intel,header-version = <1>;
-intel,update-revision = <0x28>;
-intel,date-code = <0x04242012>;
-intel,processor-signature = <0x000206a7>;
-intel,checksum = <0xf3e9935d>;
-intel,loader-revision = <1>;
-intel,processor-flags = <0x12>;
-
-/* The 48-byte public header is omitted. */
-data = <
-	0x00000000	0x000000a1	0x00020001	0x00000028
-	0x00000000	0x00000000	0x20120423	0x000008f1
-	0x00000001	0x000206a7	0x00000000	0x00000000
-	0x00000000	0x00000000	0x00000000	0x00000000
-	0x00000000	0x000008f1	0x00000000	0x00000000
-	0x00000000	0x00000000	0x00000000	0x00000000
-	0x52b813ac	0xdb8994c7	0x70e9f6bb	0x9d6db2ff
-	0xf4d70f5d	0x5b1eccf6	0xac59106f	0x0ae2e2c1
-	0x1a7bbeb1	0x355a1d62	0x2e7eb594	0x09f8dea9
-	0x432a49e4	0xbf520253	0xdafa4010	0x893a858a
-	0x766e0efb	0xd91e196d	0x838bd2ef	0xe5146494
-	0xd515f413	0x29704828	0xe85598b6	0xdcbe6c51
-	0x88eabbfa	0xa1e8909f	0xd8931721	0x35386554
-	0x089a78a7	0xd9914775	0xd4644748	0x1556a4dc
-	0xf44448f6	0xd054d7db	0xf30f2b7d	0x5ae223d0
-	0xcbbb48b0	0x5c8b0383	0x177de157	0x9c1e5f73
-	0x2ec28289	0xd72a7b6c	0x823b6eb2	0x35e02171
-	0xba8deae4	0x06f4d468	0x13dbafaa	0x72b419f1
-	0x033385b5	0x05806920	0x4c6034cf	0x9bd117dc
-	0x976e2d04	0x250330f0	0x7250b5e1	0x184980c2
-	0x12a9d7d6	0x1bc808f9	0xae79994f	0xc6f87901
-	0xc0e3132f	0x671491c5	0x236cad39	0x37889d9c
-	0x67f7c3f3	0x964a6be5	0xbcced7da	0x57eeaa6e
-	0x7bca1522	0x654fee4c	0x2a1ca5d9	0xa1803cf3
-	0x00000011	0x8c316d2c	0x17603b7e	0x32e42981
-	0xc26c1400	0xf0fbccb6	0xeab6b43a	0x11d456a5
-	0x5b912d46	0x15195fe0	0x542f6db3	0x0b7f212e
-	0x47718dd9	0x7c41b108	0x06c21111	0x4445d5ea
-	0xb4fb8128	0xe07404a6	0x8d503da4	0x78fc7e44
-	0xb9919656	0x9968c797	0x87f26ab0	0x23bb1af7
-	0x1ec5d761	0x26f30d2c	0x7cdb747c	0xe4d42033
-	0x8a5d4801	0x768aff57	0xbcfd5d11	0x7c853c2d
-	0x231e6207	0x8b1988a6	0xd68fdb75	0x58dcb417
-	0x44422ef9	0x2a186ebb	0x7d27e85f	0x36ac31f7
-	0x1e487e77	0x2b0b8c37	0xd8ba682f	0x2cba791b
-	0xe6d3dece	0x1b2c2a99	0x4e5decab	0xfbd313a3
-	0xdbc78294	0x5a80cce7	0x2d8e0f0b	0xcf564f71
-	0x073d1f37	0x25162870	0x96cdb85b	0x9c553048
-	0x24eba740	0xfc0f352e	0x0c83be68	0x89b5076c
-	0xc39c4355	0x6a4cf25c	0x2bbd2682	0xc524fdb9
-	0x7ea19bae	0x191ad6f1	0xd3fbf3bf	0x21bf77fa
-	0x8f77fec4	0x0f90f635	0xe55e165c	0x868d58c0
-	0x966bc0ad	0x6c276364	0x9d8f7eff	0x4b7925d4
-	0x8b2f9326	0x4ab7b47e	0x33a9087c	0xf31ab949
-	0x69831dfb	0x4711a215	0x8128c1fa	0x8481c213
-	0x7401b01b	0xfdcfdc50	0xd6b55266	0xae9b23ac
-	0xfa2ad275	0xa225bb45	0x4dd720c4	0x760a20e6
-	0x5f1223c9	0x2f334372	0x6e1dcdab	0xe8ee8638
-	0x1c19ba8a	0xef9341c4	0x360aaa9d	0x90452ea9
-	0x65852446	0xe9398fa3	0xbba6a631	0x1a3e90b9
-	0xe2a73a56	0x6e8c0747	0x35c7c53d	0xcc1ac842
-	0x183356af	0xb6e98608	0x987b43c2	0xa8a3cfd2
-	0xc2c5fce0	0xcc3af64a	0xd6d3a291	0xe59ad1f5
-	0x124ca513	0x9522b50a	0x25150477	0xa2eb5797
-	0x7fc63626	0x648c48e3	0x9f5797ff	0x2307b84d
-	0x980625a4	0xabc05983	0x24980807	0x773c4f99
-	0x3407b872	0x07c3657a	0xa2cd9e48	0x49c1e6a8
-	0xa881b84c	0xf804d72c	0xb5319d2a	0x3e39780f
-	0x97518822	0x0acd54c2	0x0721a9ff	0x10e1d2fd
-	0xa7b6db77	0x845b1a56	0xef00160e	0x6b41bfd5
-	0xc994df0d	0xcf44a5ca	0x794b36a4	0xf9fdb127
-	0x922a1366	0x822aa8a9	0x4b137bd5	0x5722a49f
-	0x8933719a	0x17edc1a9	0x079d9538	0x21fae7d5
-	0xe534fd73	0x9d3038d5	0x48c3a056	0x5b22d58a
-	0x6f142866	0xf1d767cd	0xb51ad5a6	0x34a0ef85
-	0x0111703e	0xca4b3a30	0xa0f3c34d	0x9d48775a
-	0x3f2059f9	0xf2fe2c36	0x588861a9	0xed5bd9fe
-	0x8231f7cb	0x8c115969	0x3f82ba00	0x21b3730c
-	0xba757997	0x3ec0bb2c	0x16f11def	0x5d4356c6
-	0xdc2e0bc2	0x58c1eb6e	0x313ede0c	0xb68fcc52
-	0x84d3e1b5	0xcc6d9201	0x95046196	0x276b527b
-	0x80a4a729	0xe782916d	0x5cf09e0b	0x98aaf9fa
-	0x1de6dd43	0xab4f1962	0x49ece734	0x81455488
-	0xc2597b61	0x5b22af85	0x646f7b94	0x09213a1f
-	0x08edf7e4	0x963d343c	0x059ba888	0xb4e804ed
-	0xe7cc826c	0xf87bafc7	0xeecaec10	0x8e60919c
-	0xbf14c996	0xd3dcaee3	0xb8fa0b7e	0x81563c6e
-	0x7f59a258	0x2f344446	0x374d8aa6	0x9b6de5c9
-	0xbf992857	0xbc5b94fc	0x28adb080	0x17e41044
-	0xb87b469e	0xda504d12	0xf21bef8b	0xce75c1e3
-	0xdbd92c83	0x58bba0af	0x77b42977	0x506cfd75
-	0x1139e875	0x6ce5fe43	0xc6a5d7b3	0x87f9e628
-	0x7b5c500b	0x130066b3	0x789b611f	0xec8c1ba9
-	0xb7e6872d	0xaf828cd6	0xc28d3316	0x2a91f6d0
-	0xc725f063	0x065ac531	0x4f9ef4b8	0x2b9d927e
-	0xaf54f3f9	0x7c924f72	0xda1d77ad	0xff00db67
-	0xaf4f03c0	0xb4f4ee64	0x169e64e5	0x04653ac0
-	0xed51cb70	0xfeaff0e5	0x51dbf346	0x072a2407
-	0x23fb74f4	0x9a906eef	0x5d6fc3f0	0xbc3c374c
-	0x1cf9f063	0x919015d9	0x5b3e9d07	0xd6209d8b
-	0xa3710b3d	0x90ad23b8	0x420ceedc	0x58e8371f
-	0x5d419d1f	0xb8acd13f	0x7d100d6d	0x210c10d1
-	0xcd0a697e	0x5023db4b	0x33e6d8e7	0x44bbe6b4
-	0x827e859f	0x6ca4cc81	0x661bb2c3	0x71209ee8
-	0xb8c3ffaf	0xd1075f51	0xba1eae10	0x728b0a6a
-	0xe4af7a2f	0xca9bcf2e	0xb249a631	0xdce6be47
-	0x5c910321	0x425c3c27	0x33083e43	0xdea067ae
-	0xea594a23	0x41b75c2c	0x3a401a95	0xd33cd88a
-	0xc295cad0	0x67f48045	0x1dc9ad4c	0x4bc48864
-	0x53991b6e	0x7aadde5f	0x2b0bf775	0x06ba5380
-	0x9eb874be	0x2c4b967a	0x1bcc342f	0xe875001b
-	0x15b5642d	0x5be99c9d	0xcb210ace	0x1b4924ad
-	0x3793ed81	0x8b983114	0x3ec33981	0x75ec71e7
-	0x8b5b7df3	0x834756f4	0x100fad01	0x70037fdf
-	0x0cef9a36	0x3d9e3a2d	0x38b48efd	0xfc4034b6
-	0xa32e29dd	0x388944bc	0xc1c15614	0x3877e9c7
-	0xa5e733fa	0xa621bd53	0x4b651df6	0xce082970
-	0x85f30d6f	0x729a5c87	0x31dd7ba9	0xdb495828
-	0x7b12c698	0x953495c9	0x6b5f99e7	0x2cc42fa8
-	0x697ac512	0x1be679de	0xc116d305	0x94a36606
-	0x9e5e141e	0x874affed	0x58d40b0b	0x5e3cf5e5
-	0x5d05e9a9	0x06840efc	0xd2f98b21	0xa1e83ab2
-	0x4f726202	0xa6394535	0x62a02403	0x9f2167ec
-	0x4f9fc77b	0x98073be4	0x2bc781fa	0xfc8e4c89
-	0xc7179b97	0x692cf793	0x708ff7bb	0x12ecba93
-	0xacd06e21	0x202bef76	0x03852241	0xe84e02a1
-	0xf1f9ac8d	0xcee61aef	0x61a4f235	0xd22991eb
-	0x67a81345	0x375a15c6	0xe8fae8a3	0xb4ff2b37
-	0x339ee4ea	0x14ffadc3	0xf49340dd	0xf285e568
-	0x00fc6970	0x369c52d1	0x4f55368f	0x3f4d75f1
-	0x6a73b603	0x963c1f59	0x171e2bdc	0x72bac76b
-	0x9e2e5c32	0x307f7c3f	0xd3b48637	0x3a917acf
-	0xea52a65f	0xecd209fb	0xf0ad84bf	0xd4bdea70
-	0xa2647b38	0xce040b49	0xc6d5f13d	0x5d942c52
-	0xf8edc042	0x798fdefd	0x4b074246	0x1cb1873a
-	0x6793c186	0x23b9c774	0x77bb0202	0xc519b3aa
-	0xa30c09a2	0xe1f6669a	0xb7eddb8d	0x7aaa91d6
-	0x076a3789	0x0ac47791	0x1e503404	0x44fe8c54
-	0xf3cbbf49	0xd3234eef	0x0d898b3f	0xe854984b
-	0xe3986de9	0x923a5c76	0x2ee9abca	0x1a9fedbe
-	0xdf76dcd1	0xea07936b	0xcdaaf247	0xe62d98fa
-	0xa99c7f7b	0x34fc84d4	0x03a35111	0xad5675c8
-	0xcc64075b	0x408203f9	0x846e1f08	0xe934019e
-	0x423d1223	0x2f04f9e3	0xee1dbf40	0x65edc60f
-	0x097aa22f	0x7058a2b7	0x41c8a0a5	0xa68aa391
-	0x0f345c40	0x667517e6	0x860838ba	0x6dae933b
-	0x764d5919	0x6673fa0f	0xf0a5e97d	0x4262ebbe
-	0x64b413f2	0xd2c4145a	0x0b2c11f3	0xfdfe9f93
-	0x96c77107	0x1399fdda	0xf599f215	0xb504da5d
-	0xf8a95268	0x9ed1ef87	0x9ae33cfb	0x3b21f1ef
-	0xc6d447c2	0xe0694d4e	0x967febab	0xc13f631d
-	0x8393bfba	0x37438788	0x1724194d	0x8e77a045
-	0x20e2483c	0xb961c2fc	0x485cf593	0xb3462621
-	0xcb2959b8	0x10307e19	0xf71fbbfd	0xdda641e1
-	0x0daf5f66	0x56d85178	0x145f6749	0xebc46ed1
-	0x5593c249	0x94561f51	0x534cc654	0xca7c8814
-	0xb59a578c	0x40b2b614	0xeaf3437a	0x198d5b4e
-	0xf245fa53	0xfb75e0b0	0xa363c46d	0xc43b5468
-	0xdf036413	0xc59f5a36	0xd8ff4381	0xa3af3e36
-	0x7af63462	0x414526d7	0x7bdc41c5	0xa416f1e7
-	0x6987d9ad	0x472c5499	0x4f10ee37	0x47bb7ff7
-	0xc7f2e621	0x820008f7	0x33a475db	0x91ff5d72
-	0x0517401c	0x73d067c8	0xe417b69d	0xb86d9903
-	0x1ac9a032	0x74bbf582	0x8b65596e	0x883be34c
-	0x95dcc26f	0xe232c646	0xfae9c19f	0x35cb5273
-	0x6a94d095	0xfff6ca91	0xb9c40eb5	0xd351dcac
-	0xc90d464f	0x9b609642	0x15663b56	0x15f7f88d
-	0x22499f60	0x417fd6c5	0x2dc36fe2	0x712bf66a
-	0x22f1fba8	0x531b8092	0x40d269b6	0x1d227898
-	0xeb6ff35b	0x2490ac31	0xc958ed65	0x3ce6ffb7
-	0x9338a806	0x3beadfe2	0x1c361ac9	0x53d0e3b0
-	0x91d46102	0x4d57045f	0xb5c8afb3	0xfd2c9e7d
-	0x3d578410	0x2adb9406	0x10df7459	0x90abccfb
-	0xe3f217ed	0xef5f4e09	0x74925ce4	0x169b5879
-	0xfeff4ad5	0xb300dd1d	0xc96022ba	0x72da501b
-	0x1e694296	0x9efa33cb	0x0dc3ee6c	0x0ac4e7ea
-	0x73041130	0xf0e6a295	0xc46bdb6a	0x6a927044
-	0xd217ceca	0x0b744007	0xd5a2bafb	0x4220cd92
-	0x70d3352a	0x5ee4f661	0xfa07e5c0	0x155542d9
-	0x4a39fba0	0xcec0552d	0x30c1d8ef	0xbef9d21e
-	0x183879aa	0x5b3f30a8	0x54a06db4	0xef876e4e
-	0x5e823680	0x53e2a353	0xc9aa4112	0x13a56ee5
-	0x848859fd	0x0ba2b801	0xec15260f	0x7bb22672
-	0x1a097332	0xb141339f	0x752a67d9	0xdae373f3
-	0x3c8cfd49	0x2dfaf2a9	0x95820c6c	0x956b39a2
-	0x1ca0d24e	0x1312b978	0x7280e1bd	0xa7a7c2ff
-	0x0b48e987	0xb6083e55	0x4b4b82f4	0x9c6104ad
-	0xcb93beca	0xe1c34035	0x34de740d	0xbb151baa
-	0x71f5942f	0x1eaac228	0x0c68331b	0x3d2a1dd0
-	0xe7a3d41a	0x7253acae	0xfd4de230	0x79988d80
-	0x4468f19b	0xac4440fd	0x6e8a6ef3	0x5736adf8
-	0xded67716	0x1f1d5a4b	0x96c5f451	0x85bae181
-	0x1293ab28	0xc2ba53c2	0x729ff4cf	0x60218df8
-	0xc2870138	0x6127d844	0x89604e9e	0xd2b9ad4e
-	0x4f6ded9f	0xdd263849	0x1633bd92	0x64b03a24
-	0x96dabd4d	0x6e85d235	0x1ab69ad0	0x9aa80454
-	0x6b9041e0	0x106c7e9a	0x8f54812f	0xa274efe4
-	0xe45d6695	0xf3aa7bd3	0x6a5a2a63	0xe36f3525
-	0x6238fa4b	0x7d6cb06f	0x16d3b4a2	0xf3b04822
-	0x638f1a60	0x0e1875fa	0x1c0292b9	0x6b519ea4
-	0x9faba37b	0x209341ec	0x83c9061f	0x3387dfe8
-	0xc7f12ceb	0x2bef45d7	0x8f8acb47	0x35d9741b
-	0x7009f514	0xfd003802	0x6f9489c5	0xe2ea2504
-	0x910e996a	0xcc81d016	0x3280730d	0xdedfef59
-	0x5a7357cc	0x8fe8dd39	0x15543fe5	0x976c4207
-	0xe41cf62b	0x0ba6b4b5	0x5c3b7ced	0xa6c5b72b
-	0x72ad3b4d	0xff143181	0x2b78a157	0x7fe231a5
-	0x6ff0538a	0xe58ed1ac	0x81a311a5	0xefaa54b8
-	0xf04a797e	0xce6e69c7	0xdc810726	0x7bab7be3
-	0xdd5923e8	0x5a2413ed	0x31cef794	0x73dfd806
-	0x1b9223c1	0x0c370882	0x04fa3b68	0x87c50bc1
-	0x1d78c90f	0xf4e2cee6	0xebea941b	0x73e5838f
-	0xca8d39a6	0xe004296b	0x28cf8a0e	0x7c73e7ef
-	0x26a296c2	0x789d4c72	0xd1490265	0xd9a9e843
-	0xf03504c3	0xfae6dffb	0x7a48f00d	0x51e369c8
-	0xcb3eeee6	0x0625e936	0xe93d0d7d	0xfb15ba6b
-	0xec5c76da	0x8fdf44f1	0xa036653a	0x5730c4a3
-	0xe5bfe6dd	0x0b8c091f	0x3b51558c	0x403748f4
-	0xf4007f86	0x952b5db6	0x5524d8ba	0x8046409a
-	0xe3fc61a9	0x66f4ea56	0x5645150b	0xdb2bec15
-	0x50672218	0x7f40e87d	0x2b8359f8	0x438787dc
-	0x7f221597	0xf8b1590c	0x4f468251	0xff586d05
-	0xb9195380	0x0ee09e0b	0x2fa7dbd9	0xd197b327
-	0xa0dbad58	0xb485681f	0x5ef0937c	0x1e07ebb6
-	0xcb49fe3f	0xc2427cd9	0x6c2c5298	0x4a2e171a
-	0xa7f333a8	0xb3609ad6	0x94e374d6	0x0e1eb64d
-	0x22c3367d	0xcdf89975	0x647aceef	0x16727c9c
-	0xf476ae53	0x35a1212e	0x0db768b8	0xfff8b53d
-	0xbd4fe45e	0xab28a5a3	0x59cec0af	0x28bcd1ef
-	0x6f43ad69	0x2658a059	0x27aee0ec	0x4e8bbd15
-	0xa9fdcf04	0xc9aa329f	0x687f010f	0x5c968a07
-	0xb894e607	0x0e1cba22	0x2f00f203	0xe8e133ac
-	0x494a4746	0xe8bdff9a	0xf69791a2	0x64179ce2
-	0xbfd10dc6	0xc026f6d8	0x4871923a	0x8946b277
-	0x609f49a4	0x6466df1b	0xd8c3c131	0x46ef0291
-	0x0fdce8b6	0x2b9aedb7	0x225c4520	0x72b332cf
-	0x4e220d47	0xf2f69c36	0x2c23fad9	0x57a2a918
-	0xe017409c	0x490819af	0xf2121afd	0x951ff7ff
-	0x40363fcf	0x5078b94e	0x9e4be775	0xee97ef16
-	0xdb3a2390	0x17d42af9	0x96f56a51	0x1b4c2934
-	0xc866315c	0x2b746f99	0x9a3b73f6	0xa1e081fc
-	0xa9d07ebd	0xa6359fae	0xdf50d099	0x55304e01
-	0xfe5aaa81	0x1e74267d	0x38b1d2d7	0x8633e9af
-	0x99b013df	0x3aa05831	0x86279736	0xd2b464e0
-	0xdf036a9f	0xe8162915	0x876c0d4f	0x4beb7d0e
-	0xfec9b170	0x46bc9df4	0x46cb88fa	0x0cb5904d
-	0x2e2961cf	0x7ea5dc1a	0x60670df2	0xf935ca32
-	0x67e6777b	0x8bacc97a	0x5cd07248	0x32e483e6
-	0xfdf09b0d	0xca57150b	0x3f432d09	0xdea2d7db
-	0x9f6a2954	0x6f07dff3	0x4133f394	0x60272f97
-	0x1b98c9ec	0x2ab648d9	0xb5df14a8	0x0d2c38f2
-	0x5dfde2c4	0x7cb43ca3	0x8d0c6c01	0xe80ea41e
-	0x5f58b71e	0x4ca9fef2	0xabd201a4	0x50905c08
-	0xca8ba387	0x5592922b	0xfa4e05f5	0xceb64b14
-	0x0845c5bd	0x518d369b	0x727e570c	0x1daaab31
-	0x801e8b9c	0xec6568f3	0xd4c3760f	0x40a78d22
-	0x38af58b5	0xc406a76e	0x8c3a7779	0x18272c42
-	0x45cf7b70	0xa6f3c0f3	0x88021e41	0xda662504
-	0xe97aa709	0xe93bafe0	0x8862ed5f	0x35bc8268
-	0xf5a41551	0x3dd3bb21	0x1af0cf11	0x08fe1ad7
-	0x53ecae41	0x01a4a8ae	0xfed636b7	0xf09323e6
-	0x73b9b253	0x7ebd7ce2	0x7074b4de	0x21c719b2
-	0x50982743	0xd23cfd27	0x136a1f4a	0x23260f6e
-	0xfad89dcd	0x57586681	0xadc4fba5	0xad0f71b8
-	0x91a3f188	0x20d62385	0xfecda9cb	0x33d67776
-	0x2abb0e6c	0x0ad16087	0x486332da	0x2928d342
-	0xf6d1b174	0x5e133a4e	0x72fc0ad4	0x940578b8
-	0x320a42b1	0x9cbda7d4	0xf2a36135	0x00ab8de3
-	0x5bad9000	0x5778e633	0x3952763d	0xe0e58583
-	0xdfb0bf19	0xb11914b6	0xa67da7a1	0x8d9a9f81
-	0x638cbcf7	0x83bf931d	0x8703b0dd	0xcab30fa4
-	0xd6db2ee6	0x5cc2e5ac	0x717e636b	0xfdcbc760
-	0x563b3b25	0x0e4df458	0x9efb8fa7	0x95aaa7a1
-	0xf05b6680	0x5e237e59	0xc884018a	0x177b5a30
-	0x3ea2c9bc	0xd0325ee6	0xb1dae51b	0x812ee29d
-	0x6d58db21	0xb787fa68	0xfd092294	0x09683dd3
-	0xfe0d6405	0xfdd99aad	0x78744a59	0x936738e6
-	0x6ad6cba7	0x370f7f8f	0xd208c214	0x12239384
-	0xbe71f0e7	0xfc0ef264	0xc04e4a49	0x354f9cf3
-	0xf5d7572c	0x07839ad0	0x834a003d	0x23ba26e2
-	0xf4049ecf	0x5ff402b2	0xff9d6769	0x074ebe6d
-	0xdc829da1	0xc3d7697d	0x973efe4f	0xfc2a9165
-	0x126dc518	0x0b824ca4	0xc438fb70	0xb7b0ee00
-	0xbe56afd9	0xa3d8defd	0x971455ae	0xc11ffde7
-	0x346e619a	0xb41111a9	0x6004b62e	0x896c668d
-	0x738e458c	0x351f9fdd	0xe771b2ba	0xad6d7464
-	0x719b57c2	0x6f6a4611	0x8a676f2d	0xb8db1c43
-	0x3f102641	0x51bffdbc	0xb7862565	0x5d8dd231
-	0x7a79bd39	0xfa472894	0x0fd1d2ff	0x64cf589a
-	0x38234d7a	0x5c9acefd	0x8eb0b9f8	0x761e1c95
-	0xf2fe78fa	0xe06220d7	0xaf82a919	0xf4e196e1
-	0xa17c8935	0x06d08d16	0x6bad807b	0xf410805d
-	0x4ff2bce6	0x3297c81f	0x06e35353	0xbe1f5e1c
-	0x65d1cb92	0x0dc69b2f	0xac55d597	0x636ff24c
-	0xe2e4f2ba	0x63d64922	0x4b2e9f71	0xad2279ec
-	0x5f0b5c0e	0xac688638	0x35613358	0xf5531360
-	0x54a304e8	0x27ebfe65	0x977b5a3c	0x3dc5e10c
-	0x73b32ee9	0x3a2c9454	0x30a149c6	0x31e5b55c
-	0x2c10854f	0x745cd38a	0x2853a27b	0x6629e355
-	0x0bb67e39	0x5469184d	0x694a9bb6	0x0a0ca25f
-	0xa878c5de	0xee15fd46	0x23d92ff8	0x02328404
-	0x1c9402b5	0xa46b6ce0	0xefc3e947	0x0e9312ad
-	0x5830ae9e	0xe30e32f2	0x9db8ee81	0xe8aeebbc
-	0x30675c83	0x447278c2	0xab2bad3b	0x08ba3d0c
-	0x1124e681	0x3691242d	0x903c8d2b	0x3281c312
-	0x22af690f	0xd69a150c	0x57622c5b	0x29313c73
-	0x6ab2d7c6	0x39b06dad	0x6e1f9f81	0x03324986
-	0x53a49093	0x7654eba3	0x2527245a	0x9af596fb
-	0x818ffb3a	0xa3817173	0x6a2c4b80	0xfcc42ad5
-	0xfb1bbb69	0x3a3720a2	0x90a89bcf	0xed80308d
-	0x7753cb1c	0x1c2654a5	0xb01ee4af	0x81091e85
-	0x9067b3f1	0x2e2b9b5e	0x9fb0c7d1	0x78fd9f69
-	0x5771c46d	0xacdf498d	0xfd8b8e77	0x4c15fa61
-	0x607120ce	0x18a298d8	0x73716420	0x65e5e06a
-	0x18c53e04	0x35b84427	0xcd82b522	0x9a7d26bb
-	0xd56b4b74	0x49b47fe8	0x63178dc6	0x0bac0f46
-	0xc8b0755a	0x9bbaaf1f	0x18131d2b	0xcc019330
-	0x0ceb89bb	0x8808c2d6	0xfb5bd86c	0x6c945b71
-	0xdc911924	0x4ebb8d35	0x44e46d08	0xabfee615
-	0xf456931f	0x7a244955	0x0bffce7d	0x5533ca5f
-	0xb1b2c636	0x4f29075e	0x64012561	0x7aa5e7c7
-	0x9c8a0666	0x9698782d	0x3481ad8f	0x21a55b19
-	0x735aa45d	0x4245b9c4	0x0d4c3fdc	0xd1b10966
-	0x7035fcde	0xc2257947	0x4a37271a	0x9da464a9
-	0x228adbf8	0xbf309e03	0x096f560a	0xa2b8ca78
-	0x427702cd	0x35a99cf5	0x99811758	0x6953db58
-	0xec07533e	0xe95838b9	0x61c71654	0xc9cce595
-	0x275af106	0xc8697af3	0xb3f27e58	0x411d8d30
-	0xd0d90ecd	0x1503b9dc	0x76bf070e	0x49f89ef0
-	0x7333b083	0x53f9c44b	0x8330c3a2	0x6a1119c3
-	0xca555f2b	0x3d51fc6f	0xac7b3320	0xf8e42cdf
-	0x053753fe	0xc122336f	0x94d289c6	0x088b5a64
-	0xc3aac7f0	0x96a76344	0x2ff05828	0x9b4f2af3
-	0x46de6a46	0x4ed29d98	0xe2ab7634	0x27481ddc
-	0x300ca71f	0xce7ac539	0x88240e09	0xb1a14e78
-	0x2addd4c5	0xb3a7f320	0xe91f549b	0x6881c45b
-	0x0e381c47	0x1018feb4	0x64679650	0xe62281cc
-	0x670ee6d4	0x0d226160	0x947b7f08	0xbc595a74
-	0x2380c0b3	0xc0235785	0x63b41221	0x80b9cc31
-	0x3231b4ae	0x33ed5718	0xf2c5c90f	0xdd3b03ea
-	0x67dfca08	0x453e9d29	0xa2bdecbf	0x5e9a3181
-	0xad17aea2	0xff0a8f13	0xdf946849	0xcfbbecb7
-	0xb0a602d7	0xb1a820c6	0xfe7abbc8	0x7f70790d
-	0xeb5f8863	0x266d3cc1	0xbd552a44	0xe19b1b3d
-	0x856aefbd	0x51c11f1e	0xde661b7f	0x61c075d2
-	0xd0f6a834	0xff1d0d37	0x6793d1c2	0x70c133a5
-	0x20c4d2cf	0x8c80d4d3	0x61ebe382	0x788b74df
-	0x11c56903	0x535889ba	0x0a9c7380	0xf9de2837
-	0x09437fe7	0x1627c6b2	0xb943bdb8	0x69bc29b2
-	0xee9795a4	0x83c992e0	0x95437918	0x8ce166a2
-	0x56b56b66	0xb0680941	0x623d38a9	0x2add07ad
-	0xe583ba09	0x96f6532a	0x3eff4696	0x2a8a6b0b
-	0x905b913b	0xafc01673	0xe871e006	0x2c2339ad
-	0x248438e5	0x96d83e53	0xb3a75d6b	0x2258cf63
-	0x69ff39bf	0x95727173	0xc3ac09d5	0xea8d2c06
-	0x0e7c0a4b	0x144fcade	0x28a9a5a3	0x97c11ae8
-	0x89865e3d	0x1640cd32	0xe3e551f8	0x1f7ba770
-	0x6d23fb31	0x11eceae3	0xc8ccb8ee	0x46dd0bb0
-	0xd01a46ff	0x0504adf5	0xec6e170e	0x2e3d7ac5
-	0x70f893ac	0xaf9963db	0x061e283c	0xf0ad248f
-	0x2fe97e19	0x881fd340	0xc686c9d5	0x88ea8ba5
-	0x92f05cd7	0xd6716148	0x6fc47fc3	0x2c51d9b9
-	0xd50a7faf	0x4eccacd1	0x7c92f802	0xa63ffc83
-	0x7cb0ab1d	0x4492e81b	0x7d906554	0x43306ba1
-	0x73a5d57a	0xe57a05d6	0x6850b964	0xefed595c
-	0x7754978f	0x629e8236	0x62ec4dde	0x247439ee
-	0x8b9982fa	0x4eece5c2	0x48599175	0x0fdc752c
-	0xecd87b12	0x94936c75	0x17a45ea1	0x80a899ac
-	0x22a39ee7	0x745730b6	0x03ea4daf	0x4a7570d7
-	0x307621fa	0x7322e0a7	0x3a8e0316	0x454e46f7
-	0x08773750	0x156dcaad	0x5562bc06	0xa23a1ee3
-	0x20435211	0x1d679ea0	0xb220e205	0x682cc1a6
-	0xd64a71c7	0x3ca7f8e3	0x2e92f253	0xa7cfdd0b
-	0xd62b4053	0xf5c5f641	0xbf72dde1	0xdcb716c1
-	0xe2f7b05d	0xa03145ea	0xc09828d2	0x7dae7916
-	0x6fb97c79	0xb3a85204	0x998a9c7b	0x5f42ba8c
-	0xd9c628b3	0x6b17bacb	0xa889b716	0x450ff97d
-	0xe9166f3c	0x2d20777b	0x82a003ae	0x2c7ae0aa
-	0x6011a9fe	0xfeed34be	0x1328f67e	0xf61003a3
-	0xfaecdf20	0xee18c81e	0x731a0302	0x11a39e60
-	0x355d78dc	0x99088f2c	0xcf253759	0x97347603
-	0x736f71f1	0x37e4b395	0x9cc74540	0xf7e39994
-	0xf01c5f64	0xbec519f1	0xa79c1067	0x76000d5e
-	0x1ac85b6e	0x51e5b7a3	0x62a97ddf	0x6f20096a
-	0x2af51e77	0xea5554f6	0xb4e581da	0xc1ac4ba8
-	0xc8f22bf7	0x9e254d3b	0xd7dd62f6	0x6461ae3e
-	0x423e1f10	0xf143e7b9	0x18c73b04	0xa43de614
-	0x2da8d02f	0x9befa706	0xc01dcd49	0xa278f1e0
-	0xd85f3177	0x6b6679fd	0x1ccef04e	0x53af9252
-	0x34d751db	0xc8d32c86	0x3d725097	0xa64ed581
-	0xd090c42f	0x9e92bf3f	0x6f82b089	0xd42728eb
-	0x3dd651e0	0x1985bc52	0x4b0f4159	0x0f99bd7f
-	0xe2597023	0xca0cae4c	0xce48a894	0x7249dd88
-	0x8e146632	0xb4be1d6c	0x790ae7e5	0x6747b657
-	0x52143947	0xa2e42ed3	0xea359617	0x6ca01a11
-	0x35c5e2dc	0xc97b78fc	0x5db6db2a	0x80fe3414
-	0x27da19d4	0xd7431d04	0xa91e9110	0x7d8ecb23
-	0x2508700a	0xc8c71ed9	0xd28835af	0x018c2887
-	0x3d0a6fab	0x3e8523d6	0xd0688dee	0xe5c3865c
-	0x838d72e4	0x6bb73a1d	0x497a59ca	0xf77c56de
-	0x38ecb72e	0xa55e3565	0x04b12c92	0x1aec9997
-	0x037c340a	0xef0d04c3	0x78f74bd6	0xdec9b9e8
-	0xd95b61ea	0x5528e8f5	0x4ecd325c	0x88ffdc0b
-	0xb337ac61	0x899d90e7	0xb5eeb978	0x8295d9ae
-	0x1ed8978b	0xa8849eda	0x8633b4a3	0xb8c858b5
-	0xbe3c4375	0x28b9e84e	0xb2a26def	0x22f8f66b
-	0x3a4aed99	0x0c4914ea	0xad103249	0xba5a5eff
-	0x8a052461	0x26938899	0x915c6ed7	0xe6268ad9
-	0x246e8c74	0x75f3c196	0xc3e725d6	0x92e02549
-	0x1f78a5cb	0xeada57e5	0x40f14906	0x0215e49c
-	0x57c06bae	0xc1896b87	0x0cd40a63	0x60741d80
-	0x11a69899	0x80fed942	0x0497e115	0x56697b55
-	0xba89c3d4	0x27d6b7c5	0xddff87b0	0xd3b1ff2f
-	0x3160e528	0x9cca1286	0x13b4fdf1	0x38cdd907
-	0xb50c4597	0x4c151714	0x1cab86c7	0x23126a3e
-	0xe26e9749	0x289a0d0e	0xc4004640	0x9d33928d
-	0x33b691a2	0x15ed6e6b	0x6e773980	0xadd59678
-	0x188ba49f	0x08da4c6d	0x6d150d0b	0x0c6c7b98
-	0xc8e1df7e	0xb8b1e692	0x5e89fd35	0xcb253d24
-	0xfc6ee27c	0x8013de3d	0x1d38012b	0xe50a8f7b
-	0x7d410ff1	0xceee4e9f	0x0e8094b6	0xaa1a5f57
-	0xb395a551	0xbd62b2ae	0x5d7b34c8	0xbd2d6195
-	0x33af4109	0x0769ff18	0x9c6cc123	0x78ee6eb6
-	0x412644e7	0x70e0c6f4	0xf45d8fc6	0x0435f5af
-	0xd43622b7	0x27409d5b	0x6dd04e8f	0x9f02ecf5
-	0xca415f7d	0xc9f439c2	0x7198e539	0x20476b75
-	0x3cdd8dd8	0xce17fbb0	0xa5bc115e	0xb0ee52c1
-	0x0b074cfa	0xd26d4f99	0x3b43320b	0x230b680b
-	0x9908f2d2	0xcbcb1952	0xf45a2f53	0x7b4564c6
-	0xcf2fd983	0x414fe4b2	0x55ea7f11	0x63e8117d
-	0xe8954052	0x7c2ea344	0x97a02aaf	0x6ca874c3
-	0x1ae5b4ee	0x41754eae	0x6954abe0	0x115ddcda
-	0x9a27968b	0x32a53e65	0xffe47b2f	0x4fe7e5a7
-	0x6016dedc	0xb3c0893e	0x9626776d	0x5ec773f9
-	0x1104e01c	0x1473cfb3	0x43b2cedf	0x8ca9d119
-	0x7f1bc844	0xd8bb7387	0xba90d2ef	0x2bb0dcf4
-	0x2340f124	0xa5bd514c	0x50afab05	0x718f5ad5
-	0x7c03fad9	0x71d00d2d	0x1c31fdc2	0x4a938809
-	0x40945ded	0x437f2a0d	0x83c10d64	0xd224c6ab
-	0x0cd44481	0xb0040966	0x27fd6e7f	0x6ff45d4c
-	0xab057ad1	0x8fa4e5d4	0xac50270c	0x6e4926ca
-	0xc5721498	0x2529b458	0x40ee2ad5	0xde5e21f2
-	0xea8964ca	0x56766e60	0xdc3b8702	0xa93528d4
-	0x28d7713d	0x42edf022	0x59774dd8	0x200ff942
-	0xe7a4d769	0xd8c4ef5e	0xe177f715	0xe9d53cd6
-	0xc11270bb	0xb25977e5	0xb80867b4	0xfb48468b
-	0xdbf166a8	0x49700d85	0x0f85f98a	0xa7ca7a75
-	0x109817ce	0xca243f19	0x8bed7688	0x9a1c8231
-	0x94f0ce97	0xc36309ca	0x90ecac24	0x67e7e0de
-	0x86b18d62	0x18c7b7a5	0x622f5d3a	0x47e1e067
-	0xdc96b94d	0xe4a03beb	0x59d17692	0x040abc0d
-	0x44a5ae50	0x3d3dab7d	0xc18dfd30	0x2802b9d9
-	0x6818379f	0x56db41d7	0x97cbf039	0xe41d6a32
-	0x64b5fb01	0x6506e0b4	0xd60a3234	0xdf3573d2
-	0xac148579	0xe7f46ac0	0x05e1c763	0x904a5aa9
-	0xc7ca1ee0	0xe0c3b047	0x5e36e1bc	0x447a9141
-	0xe24654df	0x9853a49b	0x6a29cedb	0x022f00dc
-	0x6df2a7a7	0x3636da02	0x72bb9c81	0x4f0e0918
-	0xd649f4a5	0xbb0c81f9	0xc0ba93fd	0xc1b390f1
-	0xda84e720	0x1aea0064	0xf3ee67e1	0xb874ef4a
-	0x82467ce6	0x59abf506	0xafbf145a	0x9a4cf8a1
-	0x17247c89	0xd8669398	0x1796eaf7	0xbc2d24a9
-	0xcb486570	0x17a9db23	0x3e6504f0	0x08684517
-	0x2723ab28	0x7081b814	0x8a265a04	0x697e6d8b
-	0x69b146dc	0x6434c182	0x27ec8101	0x864405c5
-	0xfff86c9e	0x3052d8a6	0x23d283db	0x492970e8
-	0xbc6c64c3	0x46d8f98b	0xe16e7ff3	0x731e4f82
-	0xbd26b1af	0x6b30e6c1	0xff192fce	0x097e0bba
-	0x49df63a5	0x2fdc3f01	0x50aae053	0x60177b8f
-	0x1949eb85	0xa46084ce	0x9658f694	0xcb951fbc
-	0xc53806d9	0x63a17d30	0x3b3f86c2	0x8a37aa6c
-	0xedf8fe5c	0x87aee1d3	0x8c680126	0xfd8b27a6
-	0x231fa106	0x69358c25	0x4502c348	0xc107861c
-	0x46280e70	0xcf6067ac	0xf6a04ff3	0x3e488677
-	0x6f3fb4c1	0xeec1f758	0x560e1c48	0xb604c06b
-	0x69e34b1e	0x8ef41dec	0x854cea22	0x726581d7
-	0x55ea91f3	0x38ae4053	0x5ff7389d	0x6952cbf6
-	0x09aa0fc1	0xcccb1d50	0x5c1a633a	0xde1eba46
-	0x797212d8	0xa943fb3d	0x6063a1a8	0xbe68ef36
-	0x6ba0d5ba	0x0dbe2061	0x47711712	0x62679807
-	0x6f34009e	0xe6fe8f18	0x66a6a64b	0x3f80f472
-	0xe953d5e0	0xbcd8196a	0x086faad0	0x49da7f16
-	0x7f2199a5	0x55af4af2	0x085b4d38	0x22e634bd
-	0x6cff0416	0x343466f4	0xd121a7a6	0x6caa3942
-	0xe4f365a2	0xd832eb0c	0x616728e5	0xcca4c71a
-	0x4010cdc2	0xd0f1d1cb	0x5e695f89	0x27719206
-	0x0ec92854	0x76144a1b	0x49808021	0x12457a1b
-	0xdde7aa5c	0x8f1a077f	0x110a4a5a	0xb3a5ad31
-	0xaacebf8f	0x66ff7f33	0xa2340971	0xfb4c7e82
-	0x8dd536d7	0xafd2021a	0x72aa9c6e	0x22df6952
-	0x83c4b4fb	0xba515555	0x93eee8f0	0x22d0ed5a
-	0xbec05586	0x83828f28	0xe0d7f930	0xac0f0199
-	0xef6d76f9	0xf56ebdf8	0xf67323c9	0x8b805745
-	0xce5902c0	0xfa2ce3da	0x10f836dd	0xe1ac6d97
-	0xa0e415ea	0xbb7c32ad	0xc421f3b0	0x8166e898
-	0x74e7a73c	0xf454b82a	0x631369b1	0xe30ed23f
-	0xdaa1c75b	0xe7c9c6a7	0x5f33c375	0x99c05187
-	0xf2d6e6ae	0xcd2045b8	0x92ff3009	0x15082015
-	0xd1a1580e	0xdce25f9b	0x21984a75	0xa9be5388
-	0x099a5372	0x3ab9bcfa	0xdb9069aa	0x49a99be6
-	0x42a9ee0b	0xfe32d832	0x24e11ad3	0xd16f596b
-	0xb95982cc	0x754ab1c8	0x42ffa128	0x539e823d
-	0x28e0f976	0x262ddfc0	0x2a16e7ad	0x49b5acd9
-	0x931f3def	0xdc419b84	0x8412cc3c	0x81056cd9
-	0x91933e1f	0x57710b15	0xa55d2696	0x87d88724
-	0xd4fedfdc	0xcc3825c6	0x397f382f	0x80f9b6ba
-	0xcdd6d59f	0x24b984d8	0x8f1c5bcf	0x25bcef1d
-	0x00dc603a	0x76fd94c2	0xa267a7dc	0xa6e90a6a
-	0x5c5916d6	0x065a52cf	0xa28d3263	0x9b17b72d
-	0xb8436b48	0x1b1c2391	0x1fda3395	0xa6cecbcb
-	0xbc4ec502	0x1766b590	0x5945fbd6	0x6a124405
-	0xf92d06f2	0xe24694b7	0xf6befd08	0x8266cf5c
-	0x03ed670a	0x5f98be62	0xf27b7e2e	0x598cf22c
-	0x2e855591	0x879815fb	0x153799c6	0x3820faf6
-	0x3d3a2cc6	0xdbb6dece	0x1a3c46b2	0x5031bdda
-	0x47894c03	0xe43661fe	0x7a6ee548	0xa5ca9779
-	0x6aa9e105	0xbc8505a3	0xa03b860a	0x448faeb9
-	0x367de4a9	0xc9779c7d	0x6535ad8c	0x4b7fcacc
-	0xb2db5c10	0x0ab41ec6	0xe528ab90	0x5e6f03da
-	0x98bc76d3	0xf38df42e	0xea59b039	0x1c2eaa28
-	0xca30dac5	0xdb0eb8c6	0x60063860	0x18823f8d
-	0x164e2f28	0x7cbbe080	0x70a12315	0xb08f44d9
-	0x5fbb9453	0x4bc62738	0x9fa15ffc	0xe4033ca1
-	0xc9dfbc13	0x58245d7d	0x588113aa	0x8f5a6ac8
-	0x92588a60	0x26330c74	0xb2aaf0e3	0x24ada1ea
-	0xa9e973ae	0x624b73e7	0x4ef961db	0x95ede155
-	0xf2bb86ff	0x96bc79d9	0x95cd646b	0x1c3af453
-	0xf60fa711	0x10905115	0x0e24b740	0x169bb227
-	0x34cee6f0	0x990980db	0x18d8ace5	0xd4c87504
-	0x29515d32	0x2e5d9c04	0x87dffa60	0x12e815d1
-	0x021db8e9	0x2c5a42fd	0x6e3a1a13	0x88889ab5
-	0x3bc915a6	0x608919c5	0xd310a970	0xea8f3218
-	0x949f55bc	0x9ed7aadd	0x6d990157	0x181f1c2f
-	0xa940df64	0xf3be8c39	0x7ca2e699	0x7b4f07f9
-	0x89e83fee	0xe66b9493	0x54fc3d17	0xa63d2d46
-	0xd5e835d5	0x910e0144	0xecf67025	0x1fa6a93a
-	0xe692dbca	0x466af681	0xc2bc808c	0xbb4ebd60
-	0x74d5c729	0xa283ad25	0x1e66fa23	0x6d372988
-	0x753c9fcb	0x1742efdb	0x5b68cf15	0x372a0e33
-	0xaa3a7ebd	0xa0e944d5	0x95d5cbb4	0x4fb6020b
-	0xced927b0	0xb2afea78	0xd0646b72	0x1622fad4
-	0x4672c6b6	0x736ae4f8	0x8d46a4db	0x0e6a432e
-	0xe0a30a98	0x4c2bcf4f	0xd87acedd	0x19682d7a
-	0xf97c025c	0x55d8feb3	0xbcd4d2ff	0x236c6f9f
-	0x8ba0246d	0x42812f73	0x327636f5	0xc92cd30a
-	0x08a69d9d	0xc735a946	0x82eca01f	0xda0753a0
-	0x7077b1d1	0x17b05834	0xfa24bc02	0xf49f4473
-	0x8f9ac6b4	0xa880c630	0xf7457b4d	0xd5f829e4
-	0x25c49a99	0x1176a997	0xbb2d2009	0x61d35764
-	0xa322c752	0x6ef3ae02	0x5faae6f8	0x9a52acf1
-	0x19176f43	0x43843b07	0x14efc471	0xee474403
-	0x319c4857	0xa19adcf0	0xc0a466e1	0x02db14ad
-	0xb7f211f3	0x72aa6ca6	0x0eb9bffe	0x48a6d284
-	0x9a93a2ee	0xac09fc5f	0x92a62c4f	0xd34f0271
-	0xffb348c7	0xf229b6e2	0xc68ec1ca	0x19577dbc
-	0x069a10bf	0xf64ac347	0xf7c3c848	0x81975294
-	0x6376e550	0x93b53440	0x8bb17daa	0xc4c64c07
-	0xcaeff293	0xd51497b0	0x33da3565	0xa73d5def
-	0x4bf4dcde	0xfb470fcd	0xca7db864	0x7ef17022
-	0x47567363	0xd8fb8d74	0xa68c3c72	0x8202e4f3
-	0x75bf1798	0x16a70fd2	0xcc3b697f	0xab9a1075
-	0x13f56ef3	0x269d0302	0xcb655a43	0xc9a4de88
-	0xfb8363de	0xff40f36d	0xd2555489	0x647a7995
-	0xfd8eda6e	0xa3958c9a	0x20e029b4	0xbed3e225
-	0xa7df5f17	0x63bc3c1a	0x337ecc9d	0x6c329508
-	0x786aa47e	0x1db5b093	0xc0acd73b	0xf9587237
-	0x243e5d40	0xd3623c3a	0x338c4740	0xb672140e
-	0x43640a9b	0xb7ef3f6a	0x44151074	0x749bcc46
-	0xfa1f103b	0x0fefb19e	0x58855538	0x138ad276
-	0x2641fd80	0x297d99d0	0xfaa63ba2	0x00b6f11a
-	0x3793fb6b	0x124763a1	0x8b9419ac	0x56abf9eb
-	0xdbf83419	0x43570571	0x37299cd8	0x8b201e62
-	0xa4058fa5	0xb320e91b	0xbe7d40b7	0x4eca3b2d
-	0x8519c155	0xf4b17021	0x9e4c572a	0xdc1f9e16
-	0x39a589a3	0xa6cfc7a8	0x5b986910	0x64e150e7
-	0x60b6f2c1	0x02bacd3f	0x2f3b5a5c	0xc6f453a8
-	0x15a87a7e	0x76104a14	0xafa2ef63	0x2cd48dbe
-	0x3c7abddc	0xd786ea5a	0x4f65867a	0x355cda38
-	0x2ae03d9e	0x4f11f6be	0xfc0a0034	0xde4ea602
-	0x21ff83ea	0x0f12d913	0xedf4da28	0xc96d8fd1
-	0xd7e82c3c	0xfec63bdc	0x37a456d7	0x3007e18c
-	0x091a47b6	0x82f1c641	0x82219cce	0x3e7e6993
-	0x7b3a2115	0x0b8e1a02	0x40f88213	0xfa2f9c21
-	>;
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/m12306a9_00000017.dtsi u-boot/arch/x86/dts/m12306a9_00000017.dtsi
--- u-boot-2015.01-rc3/arch/x86/dts/m12306a9_00000017.dtsi	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/dts/m12306a9_00000017.dtsi	1970-01-01 01:00:00.000000000 +0100
@@ -1,750 +0,0 @@
-/*
- * Copyright (c) <1995-2013>, Intel Corporation.
- * All rights reserved.
- *
- * Redistribution. Redistribution and use in binary form, without modification, are
- * permitted provided that the following conditions are met:
- *	.Redistributions must reproduce the above copyright notice and the following
- * disclaimer in the documentation and/or other materials provided with the
- * distribution.
- * Neither the name of Intel Corporation nor the names of its suppliers may be used
- * to endorse or promote products derived from this software without specific prior
- * written permission.
- *	.No reverse engineering, decompilation, or disassembly of this software is
- * permitted.
- *	."Binary form" includes any format commonly used for electronic conveyance
- * which is a reversible, bit-exact translation of binary representation to ASCII or
- * ISO text, for example, "uuencode."
- *
- * DISCLAIMER. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
- * HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *---
- * This is a device tree fragment. Use #include to add these properties to a
- * node.
- */
-
-compatible = "intel,microcode";
-intel,header-version = <1>;
-intel,update-revision = <0x17>;
-intel,date-code = <0x01092013>;
-intel,processor-signature = <0x000306a9>;
-intel,checksum = <0x3546450b>;
-intel,loader-revision = <1>;
-intel,processor-flags = <0x12>;
-
-/* The 48-byte public header is omitted. */
-data = <
-	0x00000000	0x000000a1	0x00020001	0x00000017
-	0x00000000	0x00000000	0x20130107	0x00000a61
-	0x00000001	0x000306a9	0x00000000	0x00000000
-	0x00000000	0x00000000	0x00000000	0x00000000
-	0x00000000	0x00000000	0x00000000	0x00000000
-	0x00000000	0x00000000	0x00000000	0x00000000
-	0x86c5b0d4	0xf6978804	0x7f4f5870	0x6319dc3c
-	0xbb3b7d61	0x33cf9075	0xe8424658	0xf611a357
-	0x5a3401db	0x42caecce	0xb4d8e75e	0xe6dbaf24
-	0x7861b35f	0x6bd717bc	0x23b9b731	0x82ec1ac8
-	0x20337b64	0x5396dbf1	0x59973bff	0x724bc7e9
-	0x5237193b	0x0b8647c1	0x6a0d0e16	0xbf9ddb5b
-	0xace2cc1c	0xad707638	0x056f102f	0xa37e60f8
-	0x76255642	0xfb86e030	0xb8069a40	0x367795f1
-	0x653fb05e	0xab7f14ad	0xb6e8a8e1	0xd2598d20
-	0x2eba3f68	0x78b372f1	0xba8d13f8	0x1f1de861
-	0x97f951d5	0x8097c728	0x27dbf904	0xb97906a8
-	0xffe7a4ac	0x4b947668	0xc1dbd726	0x2adcf777
-	0x63b1bcf0	0x818e2a1b	0x49aa907b	0x2faf5e8d
-	0xae842352	0x82707fae	0x0aa12b41	0xa0bae11c
-	0xb4298c47	0xd2b4099c	0x4ff625f2	0xcd2630d4
-	0x79850981	0x05dbf57d	0xb05b81a5	0x56e73ec7
-	0x95cb3897	0xe262bda5	0xb2c6e288	0xcb7f8e77
-	0x72b8bdd3	0x3f400494	0x63ade65b	0xbc4adc71
-	0x00000011	0x06c0f8ff	0x0eb63d77	0xc54cdabf
-	0x76bc8860	0xdd142643	0xe7bfc220	0x17aa0a91
-	0x4fd676ba	0x4b6b1a15	0x2a1a1c16	0x4fed6de0
-	0x8c3d6bcf	0xbb319bf6	0xa82532f1	0x7c8ce014
-	0xb830a38b	0xec25bc6b	0x61c8a8a9	0x49a21dba
-	0xfcf8bad0	0x7372f29c	0x1f7fbcdd	0xc2ff42f4
-	0x780878f0	0xc967068e	0xe19cc3c9	0x155e6646
-	0x75235c43	0x9aaf3741	0x9dfd116d	0x0f031b6a
-	0x4963e039	0x6918daa8	0x7f0ca4ab	0xd77dad79
-	0x2f8847e8	0xf79c82a4	0x6a6aaad4	0x24f07dbc
-	0x895d3f6a	0xc96b2eb0	0xff50228f	0x573d364a
-	0x5fca9d56	0x3c11c35b	0x3e90fb12	0xc4604067
-	0x5c980234	0x7c42e0c7	0x60cca3de	0x637a4644
-	0xedc43956	0xb0efb4e1	0xe94716fa	0xa6478f51
-	0x33965654	0xdf6b40a3	0x48ac1b18	0xd6723c94
-	0xf040d6d1	0xaf850470	0xe2bcde48	0xb90a4998
-	0x8f620105	0x3d592878	0x2f697bad	0x9f7721d9
-	0xec34444a	0xb0594770	0xd7180f9f	0xa510a168
-	0x460563b0	0x5d4f34f4	0x21dfc16b	0x051de344
-	0xa57bc344	0xff2c7863	0xf0bc063d	0xf5a89004
-	0x79a81dab	0x9e8cb974	0x2309b0a4	0xa47a46de
-	0xcf9c0c44	0xf761c817	0x67ab642c	0x0db4422f
-	0xca3616fc	0x79e66c8a	0xd56a3332	0x5e0f338b
-	0x5814cb3a	0xed1b9a4d	0x47d59f72	0x25b03786
-	0x3edd1d42	0x8cd947cd	0x706e6ebd	0x82c2bada
-	0x1bf6a96b	0x77dd859a	0xda35335f	0x22fab458
-	0xd0661fd8	0x02bb4a42	0xe2a2bcdb	0x0616580e
-	0xd35be23f	0xc206d16c	0x401218be	0x51107c3d
-	0xba84b8be	0xace4d8f2	0x505b9b28	0xc517034b
-	0xac5ba582	0x7419fe54	0x43493cb1	0x2fe0a66e
-	0x206039b5	0x07569011	0x230ce53d	0x168d427f
-	0xbfe0bd10	0x82bf11be	0x5b55475b	0x5490a0e9
-	0x1c3c1e3c	0xacad77de	0x1666512f	0xfc3250d8
-	0x930a6312	0xdd85c066	0x1b95c18f	0xc8bbd3b0
-	0x1bb2a34e	0x642c7653	0x0f536213	0x1f7ab4eb
-	0xaa5ef677	0xe6ac9581	0xd7a2fe73	0xd417dc79
-	0x455a6877	0xae825a40	0xe0c98bec	0xac39ba49
-	0x299d9bd9	0x957d0bb0	0x1645111b	0xe9da4beb
-	0x1b005ce7	0xddb742ce	0x6c5f3ffc	0x24f74d2c
-	0xf4ace044	0xb21bc7ba	0x338002dc	0x240effa1
-	0xd208ae00	0xfe8c2b5c	0x9a457293	0xd9365ac4
-	0x98f24244	0xf6d1aaea	0x7b874350	0x1ba4086b
-	0x1d3bf168	0x2bb6f4fa	0xb27f8477	0x8da836f6
-	0xa8762693	0xc377fa64	0x74cfd979	0x90435c25
-	0x29d80e17	0xc3503c9c	0xaacd2178	0x232c748d
-	0x6fecd3ba	0x00fb4aa0	0xbac3ee19	0x6e5c63e3
-	0x17823c14	0x0e9d33bc	0x0fa9de06	0x998b14b2
-	0xfdd8c80d	0x01b0591b	0xf70bc4ce	0xb278c496
-	0xa7e30708	0x69cf8420	0x14f8b744	0x8bb8a0ff
-	0x168f6db0	0x95da6db2	0xf96d121d	0x67fd06f7
-	0xcd81d278	0x8693d095	0x15e1a24c	0xe5f554f2
-	0x499874e8	0x30fc0785	0x0f4fa1b9	0x65c93dad
-	0xd939bf24	0xdad29721	0xf253b752	0xf6ff59da
-	0xc5dfaffc	0xf0071f34	0xdb0db8b0	0x24475e2d
-	0x2a4d5b8a	0xf7624bea	0x3fdcbc90	0xb5a66e35
-	0xd0f08636	0x24643caa	0xc5d08e83	0xb134c55c
-	0x8e3653c7	0x34496b0c	0x6b2aeebc	0x2fbab601
-	0x105613a2	0x7babd55d	0xa01af846	0x248be690
-	0xed27917c	0x26ee6e13	0xa1dac5fe	0x852ed91a
-	0xfc83fcca	0xdf479c33	0xfd6efe96	0xdc62521b
-	0xa37d2a8c	0x1d2bad9e	0x4287614f	0xc4f7b62c
-	0x2aab0562	0xec6d4226	0x52853fb4	0x264e3507
-	0x1c3af366	0x33269776	0x81b8529d	0x115530dc
-	0xe035f98f	0x433d1b6c	0x1ea6daea	0xecfd2ad2
-	0xa57a0c22	0x1dbe3e12	0x6fafe41b	0x8e579e35
-	0x6c493fbb	0x034dd4f9	0xd17cd6f2	0x05c5cfa8
-	0xd9bffa39	0x0fc16e9c	0x831b88c8	0x7e7dce3e
-	0x3320bc7f	0xd5abafaa	0x217ab526	0xade2597d
-	0xf01b00f2	0xc9e34b72	0x00a4cb0b	0xdc198512
-	0xdc7cc8a1	0x89db07b5	0x6c2153ea	0xb8bdb8aa
-	0xdf8a1ae8	0xa517f6b1	0xd32569d9	0x37e79008
-	0x3c7527c3	0x7d5b2d3b	0xb31cb907	0x35db7f6c
-	0x0ab0cd65	0x75feaded	0x7c8260a9	0x5bc04f56
-	0x2fac9f60	0xd7b3a2c0	0x2b393634	0xc2df7f43
-	0x1ff2fa9f	0xc81af169	0x188b1f4e	0x08bf6f86
-	0x5ab2f188	0x0a71eb64	0x03b57501	0xa684fc23
-	0xa729ffef	0xe3b4a709	0xf9eb97d2	0x01506c95
-	0x0d9285f5	0x8e1ee93c	0x7d15a0d8	0xd9390673
-	0xf116ebd8	0x7e68798b	0x3dc8412e	0x5a9a04b4
-	0xe3805f51	0x00493bb1	0x4ec65ca2	0x2aedd69a
-	0x7f2a5b18	0x9994ac32	0x476f3703	0x7d3da882
-	0x5635f55f	0x7a0887e0	0x0af46feb	0xfc2f3591
-	0x02e29400	0x70fd3234	0xc549379e	0xaf34fa5a
-	0x5bf7c649	0xeb183cff	0xa236d508	0x4525ab64
-	0xc4301026	0xf281df99	0x0b298e46	0x9b7c1a99
-	0xc4b24e77	0xea536992	0x5a39e37c	0x570fb6df
-	0xae5d5c49	0x01142cc2	0xda05d3f1	0x337bf65c
-	0x3c986598	0xbecefd30	0xb5e34c2a	0xe7c3847f
-	0x18cb24b4	0x71278c26	0x4b8d6caa	0xaf7c300e
-	0xfb6ce9b8	0x94c4b785	0x67275f17	0x59498cf5
-	0xca8eeec6	0x3374e7a6	0x649affac	0x9049ba78
-	0xff9d3908	0xaceec446	0x225ece3a	0xac1d4fec
-	0xdc050fed	0x04e3ed8a	0xb303d8e9	0xe9d26aff
-	0x0a98691d	0xf243492d	0xe3b42f00	0x6c21a97b
-	0xa385ae98	0x14ba3f4d	0xc0215cc1	0xe1ba6c0d
-	0x412bbbe4	0x39f95d1c	0x593bd878	0x45d3066a
-	0x9fcee8a1	0x3f29b2fa	0xc9ae58ee	0xed6def92
-	0x6c8f2182	0xdba64e20	0x276c2c21	0x81ea9dfe
-	0x20ae00b2	0x8c2d2724	0x66c09f5c	0x24908e2e
-	0xfecf8194	0x6be61e94	0xcdf5d7db	0x98b829a3
-	0x4241ab07	0x1207ef2f	0x96e7b073	0x766293ea
-	0x58eb0882	0xf12a6426	0x741b074b	0xbd4302cb
-	0x909b6c4f	0x1c4949cc	0xd4d6a3e9	0x442b74b3
-	0xbc8cb3f9	0x0efad89a	0xa2ceff3d	0xecdf86bb
-	0x46a4a72e	0xe9d8abe4	0x94c91479	0xe99a80b9
-	0x1072b708	0xb8318ad3	0x0685426f	0x3e89a0d8
-	0x0b7c438e	0xb4b577d0	0x046599e2	0xd0ef85f2
-	0x3566d2d2	0x43ade22b	0x8753a78a	0x8f6d8e02
-	0xbdf33e56	0x8b2b6696	0x22a5e911	0xd0e0f4eb
-	0x42729c29	0x425921fb	0x82f7634e	0x2c145fd5
-	0xff59deeb	0x018a5372	0x33c4e11a	0xc001c097
-	0xf250cfcf	0x2f682912	0x21f40dc0	0x883196aa
-	0xcd5c58d0	0x7c329754	0x481c450e	0x9411c6c0
-	0x69a9df82	0xacb01a1a	0xc0b569a7	0x0b7fd1a9
-	0x4c339ad3	0xb0d9e211	0x07098664	0x14a5cff9
-	0x53beae37	0x4e173257	0x4e1d2e6c	0xce981dd1
-	0x45d6204f	0x3c193268	0x4f51ac3c	0x5ecffa12
-	0x48068ee9	0xde12270f	0x0a0aa980	0xd6fe8ca2
-	0x97d51da8	0xccf2db36	0xb3ad0598	0xbc56eb56
-	0x0adf5e5e	0x9e320aa1	0x8ebb75ef	0x3973a323
-	0x7e3d87e0	0x2c0d1858	0x83b7fa0c	0x36effdb5
-	0xcd9eba1a	0xab5b5790	0xa48fbf00	0x536e2ae9
-	0x2f2a3f61	0x05706a73	0xd2dfed08	0x7e4626b1
-	0x172c6ced	0xbf2e44ba	0x15aefc2e	0x9cf56c37
-	0x663c6695	0x04cece5f	0x4ce00027	0x465b1cd4
-	0x333dc2c7	0xce41f1f1	0x6dd8503b	0x52b79af7
-	0x564c81de	0x0e5e2daf	0x869753f5	0x16667889
-	0xe1acaf08	0x38ffbb0b	0x83400589	0x5144052f
-	0xa3819950	0xd21501c5	0x1bdadeda	0x0a874e2b
-	0x05480284	0xe8f76f11	0x582cad8a	0x0553f942
-	0xb6451cb9	0x76bdc86f	0x96ffe0c7	0xc630eba2
-	0xa82ec683	0x5902ef45	0xc362248c	0x18c412a9
-	0x1d09c103	0x2355ed98	0x5ec5c718	0x5037e359
-	0x1508f804	0x09cfea9d	0xa16cbdfa	0x5f962b17
-	0x85a35a27	0xa048dd30	0x6fe7ba90	0x0dc20150
-	0xcb56daa0	0x4188fb20	0xb4182598	0xa1bc5dd7
-	0x8c11e0bf	0x2104df35	0x025e74b8	0x79d177df
-	0xad74bb77	0x4b2419aa	0xe374add2	0x411593d5
-	0x796778da	0x9e43a420	0x4a2e0860	0xefb48578
-	0x47cafbdb	0xea15924d	0x70ac1467	0xf52fd888
-	0xd2df4bd6	0xc1fc63bb	0x119ab88e	0x0e147ead
-	0xa85bd8b5	0xc2e61ddb	0xd566417d	0x6bb9f9ec
-	0x69bbcf1e	0x24d46989	0x3caf067f	0x58151211
-	0xc2a6b6e5	0xb233416f	0x3da28155	0xf9cd9385
-	0x7a530045	0x1eab05ce	0xb86ed141	0xa8f13a5b
-	0xf9819f81	0x66d5d5c5	0x148c1a02	0x496d3c56
-	0x370dcd45	0x5f13f0b6	0xdd4eaeed	0x8dbad50d
-	0x0747ce54	0x69d2adcc	0xfb69c18f	0xd44ea186
-	0x74ab7537	0x0c642449	0x88b096cf	0x3a8ad683
-	0x408cd7aa	0x6daa6708	0xb267b312	0xa4225c7a
-	0x7a56dce7	0x6a8d497d	0x8837bcbb	0x6125397c
-	0xeb51d233	0x362bdde9	0x689657f7	0x32d09e1f
-	0x753a3d39	0xf77db5b2	0x8057908a	0xef12815d
-	0x594fffe6	0xcf3402c5	0x1a0d4923	0xca547b2f
-	0xaf9d604d	0x5d2e30f3	0xffe18005	0xe29bb0d9
-	0x36fc10f9	0x3720aac6	0x37bc1ad3	0x47d000ae
-	0xa4b0da0a	0xa178228b	0xdd9374e6	0xa1f3df5f
-	0x9ae2e451	0x21c4aceb	0x8f9fb226	0x5190b712
-	0x70253633	0x9c9cb5f1	0xc9178689	0x551c1a2d
-	0x6db67cc0	0xcf1b1ade	0x48449272	0xd18634f1
-	0x9d9c3de7	0x19025530	0x121d78d4	0xae4a39e1
-	0x62850819	0xf3d4af6a	0xe5ad5b80	0xfa053c7d
-	0x7ed68b9a	0xdbde2894	0x4b5c04de	0x65178203
-	0x9181cdd8	0xb17e27b9	0x0e29b338	0x50156ab4
-	0xf7726438	0x178108d6	0x1d8dc6b7	0xc3e7512f
-	0x0eb8339c	0xe2684a6f	0x7668ed31	0xd0ed6eda
-	0x4342a534	0x03840286	0xad1e6969	0xa9a6c98d
-	0x1bf77774	0xd32fc9d8	0x405620d2	0x8ab19efc
-	0xce4d7506	0x6f4eaae4	0x3e830dbd	0x76818782
-	0xfde4ee8d	0x1953cd0f	0xd47be276	0xf2480bc0
-	0xd1010013	0x2dd56a58	0x083084f4	0xc91b0ad6
-	0xc2524e12	0xa60710f2	0x3d955047	0xce380846
-	0x0f6dec2b	0x604d1492	0x5ca43ee1	0x6b51a626
-	0x350d5483	0x8d99ae30	0xcba06491	0xcc0185eb
-	0x7b64caa6	0x2f1754db	0xca0691f1	0x6219efb6
-	0x43291db0	0x259d3f12	0xeaf6ef9f	0x5f0e065b
-	0xad576541	0x8615a414	0x81124bdf	0x62b855a9
-	0xabdc529f	0x01bfdf75	0x10e4c656	0xf8e86f78
-	0x1fbe10d1	0xa6873c2c	0xdf83dcd8	0x20d35872
-	0xf46f2861	0x22f3d642	0xfdcda29a	0x16adbdb4
-	0x01e5844c	0x011e5454	0xf5432b04	0xd5f6a80d
-	0xb081fab6	0x64fc2fbd	0x4ca76e0f	0x3a8d8b29
-	0x3f03ec12	0x58e2bf6c	0x24f2b8b1	0x108e414f
-	0xe76a02ab	0xcb525af9	0x623ba7a3	0x31412c27
-	0x69c2f5db	0xd5546d8b	0x8200d2c9	0xf1e34a71
-	0x393e24dd	0x2b867933	0x0596e778	0xc5112b49
-	0xf433cdea	0xbc505e7b	0xf64bb064	0x1e892633
-	0xbf17307b	0x9118de2c	0x6b1d61a8	0x1945519c
-	0x32638ca4	0x5e436733	0x3dc20ff6	0x9babf127
-	0x485c1555	0x0d0c4e2d	0xc4d5d718	0x8cfffc16
-	0xf64050db	0xaa4ef416	0x8d398a00	0xe4a16eca
-	0x5d9d9314	0xefa2bf1c	0x05917dd4	0xca5f1660
-	0x59642534	0x02639b9f	0x12b895df	0xb2deaf0e
-	0x20d8f0b9	0x04d8342c	0xa1ba5f57	0xa26cdb06
-	0xca732ca8	0xdce0c561	0xf5e4b205	0xc05f5cfb
-	0xba4a41a6	0xaf219d7b	0xce08df01	0xa02bbdb9
-	0xc1adbc20	0xcb9ae4fd	0xd828cfb5	0x690b17db
-	0xd29ae8bc	0x8fc71289	0xd6fc9cf6	0x61c7a6fc
-	0x8e8012d5	0xd3320498	0x36e80084	0x0036d3ab
-	0x53141aae	0x987d0cba	0x57581df5	0xace4704c
-	0x3ce49642	0x991556c1	0x6cb0b984	0xac15e528
-	0xe7d208ca	0x2486d1c5	0x93b6623e	0x340b7622
-	0xe7e1cf7b	0x3cdeed88	0xa23c849a	0xcc6e8b3b
-	0x292add5a	0x17763ee1	0x9f87203e	0x72cf4551
-	0x2053e66f	0x06c3a411	0xb61c2e0c	0xa4a7f3ae
-	0x0ff87dbb	0x03999ed8	0x48aacedc	0x2e126ef3
-	0x799441bb	0xaee15b4d	0xea08bf54	0x47248787
-	0xb60afc11	0x8c3d6a20	0x7c04f801	0xb902760e
-	0x319040eb	0x370bbd5d	0x9a1dd5e6	0x63f7da1d
-	0xb3784eac	0x3b304dea	0x987ada9f	0x2b6b1cda
-	0xf9241003	0x0d3d16f2	0x1185dcbf	0x519b7a5f
-	0xeb612361	0x28b57da5	0xdeb8419a	0x0ba13122
-	0x062e28fa	0x5ffb9b36	0xb1258247	0x8337401f
-	0xed1f6423	0x730cafe6	0xf728c690	0xe40557eb
-	0xc4951a15	0x04a988a9	0xbf5fe18c	0x2766e40a
-	0xe4d74d13	0x8638d052	0x8eefeaf2	0x9ad07978
-	0x32042a87	0x4385f38d	0xc9b48f02	0x02ab0ae7
-	0x9eaeb632	0xf386c14d	0x8b1c2ab2	0xad432a24
-	0xfc5bd462	0x2d7ac5fe	0x45dff5c6	0xa235e1a6
-	0x825b770c	0x5568471b	0xa7ac3a3a	0xfcc6e40c
-	0x0c1be59c	0x77685a3c	0x5b1bafbd	0x40b8a139
-	0x3dd1bf01	0xb6651001	0xf2915a6a	0x16fe1cf2
-	0xe78467d1	0x4bec9fb1	0x88615320	0xa3920831
-	0xed4afac7	0x206cffba	0x96c42567	0xcc2b5215
-	0x7ca0193f	0x0e1a60e5	0xf3892c10	0x2ceee7b2
-	0x110d3311	0x9a322e7e	0x3cb7e5fc	0x3fb971c1
-	0x59971332	0x08386001	0xe4a2444d	0x17d9c47f
-	0x9f53c4a5	0xdb54e5c2	0xfaac9f08	0x975c07c6
-	0x8a6e6bcd	0x4392053a	0x6473bef8	0x4b3b91a3
-	0xfb7e8ebc	0x46c6ffed	0x04939839	0x71b93766
-	0x47e4f74a	0x786545c8	0x77f55b59	0xdf8e992d
-	0x60a0d2a5	0x6cc8a5cb	0x113ee95c	0xa378558d
-	0x5d3b8bd9	0x3c95b2a8	0x6efa3682	0x9535dd34
-	0x3e29974d	0xa477d069	0x2dbf58d2	0x165edae3
-	0xea25d53d	0x44e3ef71	0xba6341cf	0xc61b964c
-	0x4612838b	0x62151b9e	0xc1de2511	0xa364130c
-	0xa9710643	0x1a436c70	0x97030b09	0x5cef28e0
-	0xd5197e49	0x02b9ffa8	0x1b52dc7b	0x04f9428b
-	0x01ebed2a	0x1eaecbee	0xc53c4d54	0x3e34c125
-	0x05b4f37a	0x6e3d042b	0xf1c1f40d	0x39cfe9e1
-	0xd2938e89	0xa14b9846	0xb1333676	0x31068254
-	0x4b627e4b	0xb5185882	0x101b52bc	0x73e05abf
-	0x68a4e24c	0x67e301f4	0x6bf8b538	0xc502e1e1
-	0xc3889b5b	0xdfbc6d96	0x4239d0e1	0xbf3667ab
-	0xb0c4cb00	0x3efdcffd	0x7cd9661d	0x4f5eca03
-	0x0ef218dd	0x464f0826	0x048fc539	0x6a1c63fe
-	0x76cc341a	0x1ae2945c	0x7a339006	0x858fdc20
-	0x2a4a7270	0xd4cbe12c	0x7b27e5d8	0x998cf520
-	0x4795ccf7	0x52e15388	0x86aa7b96	0xff1845fa
-	0xd49d1061	0x035b6a80	0x1df18220	0x28fc4fd1
-	0xa8e8f333	0x3a9240a6	0x41a4caca	0xee736b6f
-	0xdfa7ce4b	0xd4bf5c0c	0x4e62f6d3	0xe98ae9b4
-	0x7f544550	0x2b0706df	0x8fb2e752	0x546af9d1
-	0x8517758f	0x53f522fc	0x03bd1819	0x6fd264e2
-	0x16839ef8	0x44a1200d	0xcd5a586b	0x1ead251c
-	0xf58dd3be	0x80217ce7	0x0367ff42	0x2d8f2ce8
-	0xe8a0a689	0xba33e366	0x5dc7980d	0x005c0eaf
-	0xc0c44118	0x5553076a	0xdaf39389	0x703e09eb
-	0xc54c8112	0x4a26135c	0x36a46f2b	0xdc93ee12
-	0x7060db72	0x7778befc	0xe028fc55	0x52e86278
-	0xd0b00188	0x6ed5565a	0xb5e2785c	0x3608bffa
-	0x55c3f5a3	0xe1e41afa	0x08a227fe	0x94c793ce
-	0x650934f7	0xddc36524	0x6dac40de	0x9eec3ceb
-	0x8fe3d1cc	0x3cebab86	0x61e4d63a	0x5382ea11
-	0xa90c9495	0x0277ccb3	0x412cecc1	0x5853c945
-	0x97df9a48	0x364d9b10	0x7e8c9bf1	0x6b4974ef
-	0xd3dbaeeb	0x6626dd26	0x2b746d2c	0xfb762155
-	0xf942f687	0x1317d1b5	0x0c989def	0x5f4c0ed6
-	0x31aebbd3	0x51cd8d5b	0x3d729511	0xc07c8f23
-	0xa7f3e6f7	0x7683dba9	0x5f051d5c	0x750437f5
-	0x1b9ffe98	0xa4de609b	0x4c498e9a	0x18dfc535
-	0x376c6c34	0x19a57039	0xa70e93eb	0x7e966bc7
-	0xb6e9d77a	0x3ab98e5f	0x1607125e	0xe8845aa3
-	0xa20a2d80	0xb17ac63b	0xa07a9790	0x71e5a14f
-	0xb6b5fc78	0x4c610f86	0xb57b21b6	0x1bcfb3ac
-	0xbf812998	0xd429986b	0x02b837e9	0x0823aca8
-	0xd8a85194	0x708bad39	0xff94ef19	0xc3599461
-	0xaee622f6	0xa8b5a808	0xf801b298	0x0aeb35b7
-	0x4db4bf27	0xfa31c205	0xa047dc66	0x7e0ae406
-	0x2ceea6cb	0xef0ef96f	0x4cc4fdba	0x6161256f
-	0x94505fd1	0xbced5596	0xbf9e36a5	0x271e68bd
-	0x7a3308b6	0xef1af50d	0xb55ede06	0x6783e602
-	0x1152acf0	0xdc644ccd	0x1b692da3	0x59f6886b
-	0xd7236158	0xe39d75a6	0xe7026697	0x25496283
-	0xb6b0a61c	0x09d0931c	0xe8d459a1	0x1a124097
-	0x88e50621	0xf2ed18ff	0x37681783	0x4afa1ffc
-	0x8a96ec4a	0x4474a860	0x274591b1	0x59df3968
-	0x34f56fb9	0xce821f96	0x7ec825b2	0x6ed4a9bf
-	0x687253cf	0xa511c1d3	0xaf2bd6f0	0xd1ce1a5c
-	0x241dd505	0x39037238	0x0c761934	0x53181db5
-	0x11ad47ec	0x915a527b	0x748bc970	0xeb8f2669
-	0xb8bfd5af	0xd8d19145	0x0361ff58	0x6dc6e2f2
-	0x1fd06556	0x120db4c5	0xbd704c8b	0x70a1a57c
-	0x27543851	0x095403a6	0x28171887	0x640e7c92
-	0xb48fd7d1	0x62ad2774	0x224767cd	0x347b8843
-	0x821ca7f3	0xf94749c6	0x2bc7f40f	0x700cc1d8
-	0x50d50832	0xc2f9465c	0xa6e1cbaa	0xe0f5e934
-	0x7f33617f	0x8876cb07	0x408c24fe	0xc0cfcdf7
-	0x39152b72	0xa0ba80ab	0x301a73eb	0x6e704f6c
-	0x3b73c24b	0xd433f861	0x43192007	0xa56d2ca4
-	0x2d28bd5d	0x14f4c9cd	0xb7fe189c	0x031e1818
-	0xf8f4133e	0xdc8e7727	0x4f8f5a06	0xe7b114cd
-	0x5cb9ff12	0xdb4c5a53	0xed956df5	0xf3634f5f
-	0x6cce1cc2	0x5393f9ac	0x1184c2f7	0x0b6fd240
-	0x64771374	0xaafed1a1	0xbdc55bcf	0x976414ef
-	0x6a333e56	0x0c5cefb2	0xff2574e0	0x11b059ef
-	0xff8b7f2a	0x9651e97b	0x594fe89b	0x7be60f6a
-	0x7b7695ac	0x612036f7	0x5be0d4fa	0x25855737
-	0x12e32ee2	0x8e86130f	0x46d75d41	0x3769d438
-	0xd14752d4	0x1612ad6d	0x8f86f2a0	0x63e01251
-	0x9a44ac4a	0x49fdb148	0xe1757062	0x42798804
-	0xf21f46c1	0xed0a3794	0x5528add4	0xeddc0c90
-	0x7f188ce8	0x59568b7a	0x8e25d50f	0x9277c492
-	0x955c6e6a	0x79f94a59	0x3a65fb08	0xceb23267
-	0x7d8dce01	0xd15c492d	0xa35f005c	0x0e7cba9a
-	0x950485d9	0x2d92e448	0x4aced016	0x0d10136d
-	0x3d2ec365	0xd982e881	0xe81940d2	0xb1a84849
-	0xdb30d967	0x9f51d3d4	0x4fbe18a9	0xef21cd28
-	0x5d3cba6c	0xaa89b02b	0xbe1e9526	0xa20a918e
-	0x0c26bd72	0x8372eff8	0xcf7ab414	0x1d3ab83f
-	0xfd2c8f79	0x4929f77e	0x2416e8df	0x65dcaaca
-	0x58fbf7b3	0x1c4a3089	0x9bfb6e26	0xc7338ac9
-	0x88e5ad26	0xc62bb3d4	0xad6d36f5	0x6445167d
-	0xe9de8daf	0xc391c6bc	0xa78b4558	0x0216bcdd
-	0xbd4365b9	0xb0a874b2	0xe95e9453	0x77296b9a
-	0x49803c1e	0xc01fd0ed	0x165a9d5d	0xf7da6442
-	0x4c00818d	0xaad5bfca	0xdb252937	0x0e4e0f74
-	0x0c2738e8	0xd075b8ba	0xe3b2df11	0x8aee60a4
-	0x36052cd8	0xb4aa190b	0x413e7155	0x3e7e646d
-	0x807e6eea	0x97993e6f	0xa5129ff5	0x98e01bca
-	0xa8bd70c9	0x8800721e	0xb3407ffa	0x266b2f99
-	0xd9da73ee	0xa06f634a	0xcaae53b1	0xd98e53c6
-	0x49368291	0xc89485fe	0x938a8a29	0xb57f77cc
-	0x58c867de	0xcdac8a84	0xf4d57b6f	0xc6daf080
-	0xe3d9c67f	0x0264b194	0xc3b2ca50	0x6d214667
-	0x88503872	0x549ed8cf	0xe827689f	0xcbe94e2e
-	0x4a02516d	0x24ddcfa1	0x3cbc736e	0x34c88707
-	0x9f4c9376	0x4ced4d41	0xfdbabfb5	0xafd291d9
-	0x2fa602a3	0x53e19d9c	0x44422427	0xf85e2c53
-	0x40e91ef7	0x02646045	0x3d1fa703	0x1613b99f
-	0xa108de10	0xf9cb3d04	0x7b9f9523	0x007d74b1
-	0x961771dc	0x2e49fe1b	0x5fefe27d	0x54737b43
-	0xa11d7c40	0x7f0cc2d9	0x67c6533e	0xd1ab10fa
-	0xb1950645	0x536087d2	0xd6937b40	0xc35960c1
-	0x2df0c356	0xecb5ab53	0x61e08998	0x1671bdd0
-	0xd72935b5	0xdf1a9d7c	0x70b1aa4e	0xa9272818
-	0x1f7b8d55	0xc7292a0f	0xda7af847	0x190076ad
-	0x58370ba6	0x3020fb4e	0xff8a4b30	0x13818958
-	0x6ba1ca38	0x6a90d39b	0x5e180929	0x206e8a22
-	0x0568f241	0x5f83ad21	0xef05e5c6	0x21d0521c
-	0xe7886eff	0x68eebbce	0x550c1659	0xa0843444
-	0x19468c2b	0x539cb9b8	0xa4b18b62	0xdab0680e
-	0x1b254dbc	0x47068aaf	0xa8193743	0x44b60b88
-	0x90c07337	0x2e55666a	0x632f4b23	0x68af10db
-	0x8e29f54b	0x5f436bcd	0x8bf81d55	0xb640ccc5
-	0x2e4ab6a9	0x198697a5	0x8a1c8481	0x572fb679
-	0x7597c416	0x608fd45e	0x57c8c7f4	0xe151d349
-	0xed9e17bb	0xa66f2816	0x8175fe68	0xd57d91ad
-	0x79df0711	0x7a349868	0x13403cd4	0x7d974c60
-	0x8860ce70	0x2e6d62ea	0x8916e2f2	0x0e336838
-	0xf54d382d	0xc4e172c8	0x94bfcfbf	0x5fa53172
-	0x2933cecd	0x4d5b8439	0x0ca0e6e4	0x8ef87b00
-	0x2fdd121c	0x24beae76	0xa85b47f4	0x4e38af2e
-	0x12b8734a	0xf698abf4	0xde2c2d93	0xeb100795
-	0x8ab19df8	0x93a6f4d1	0x43c4b2cb	0xbaff7c4a
-	0xf52b1471	0x72804f4f	0x0c0ca257	0x1dc24c77
-	0xbad7203b	0x3a998fa0	0x9cb20388	0x7ef1fb3b
-	0xbae66020	0x9a22144f	0x39ac47db	0x3f145996
-	0x05a32b6c	0xd201a2ec	0xd868727f	0x08b2df4f
-	0x4583bbfa	0x9a422baa	0xa6a2e8f5	0x236310ec
-	0x5aafc3cf	0x344156a6	0x6f964ceb	0xed0495ae
-	0xb5638c98	0x2c8e84ba	0x63d8c7a5	0xec956b66
-	0x69c54f32	0x767874ec	0xe8fb6ce1	0x68b1c780
-	0xe4b861e4	0x2787cc38	0x4b2202e7	0x23b476be
-	0xecdf296f	0x094aa000	0xe95ef073	0x4182ebb5
-	0x30daa31a	0xef68cb68	0x2fbcf6bc	0x21c52620
-	0x19abf83e	0x4de7528c	0x05fe4c05	0x32c2a1e9
-	0x8c23abdb	0xabba9a90	0xa6a215c1	0x891f915c
-	0x667cd65a	0xaa5a9b2c	0x689fd1e9	0x42b52c95
-	0xd9872e76	0x05dd5278	0xc19798f7	0x8d031d86
-	0x25690670	0x165f4b19	0x76b51d6f	0x61cd8232
-	0x7b530271	0xa8e9326c	0xd952e94d	0x56a7021b
-	0x128be860	0x4da40144	0xeb4ac3d5	0x82b7ff5a
-	0xea2abda7	0x690a9ebc	0x33562378	0x6bc91b2f
-	0x46134185	0x8fb77fb2	0x029518a2	0xe1fa1f4c
-	0xf78783b9	0x5d8ebe63	0x103e8050	0x924085bf
-	0x80593f2e	0x5be4bcb6	0xcb935edd	0x882d0a5f
-	0x7deb8205	0xcdc0fe2e	0x9c333db4	0x1d0c888d
-	0xf8dc3575	0x2f901125	0x6bf48cdb	0x98ab6fb4
-	0x491d7df2	0xa064922e	0xbbb86c70	0x88aad77d
-	0xfcff0669	0xb0c47c1c	0x0fcc6fe1	0x50df8a83
-	0x014460e4	0xb014e6ab	0xbeff4bc5	0x8d939fae
-	0xd750ae17	0x42dd29c9	0xdb1cbf70	0x82265be9
-	0xd11afd6a	0x21834e1c	0xd11e3c3a	0xbe568139
-	0x6cf92d50	0x9304ebf1	0xf177046b	0xa5b127a5
-	0xfb57e4a7	0xf94291df	0x0f089d58	0x07395b5f
-	0xde4ba5b9	0xf7371fc5	0xae44f190	0xd529271d
-	0xbcaea246	0xfa777c0b	0xad3bab9f	0x0d6251ec
-	0x6f4fa894	0xc39273e2	0x7710fcc3	0x81f08a5d
-	0x395b54ee	0x87295638	0x57398bb0	0xfd46c7c9
-	0x3f1dafc6	0x548479b7	0x37c42fba	0xa2130147
-	0x99dc0bb0	0x3596c5cf	0xbcca6bec	0x418735ed
-	0xfcd4273d	0xee141135	0x8457cf47	0x95fe7220
-	0x041aaf8a	0x6e947153	0xc963afa7	0x09390a74
-	0xc40dffd3	0x4208039c	0x319b1f84	0x42b6b3b7
-	0xade789da	0x83338c91	0xf2d74712	0xe80011dd
-	0xdd61645e	0x286fc63a	0x26e2fb23	0xfef2b4ea
-	0x3290efb8	0x595a0c17	0x6cd9bea9	0x7be1338e
-	0xe0ff2c09	0x1b93aea5	0xbbd97e91	0x5e1ae1e7
-	0x7c6c078b	0x0b9b3a03	0x43d38011	0x824cd94b
-	0x9725170d	0x87ce6f33	0x60525d85	0xc0a5e853
-	0x242e613b	0xebf72857	0xcb500fc6	0x0de5c3f0
-	0x382b625d	0x08840e50	0xcef30663	0x1bc848b6
-	0xefa78141	0x81b860d6	0x4eb125fe	0x7e125296
-	0x276a5558	0x45caa775	0x7c6ec23c	0x5dcddd08
-	0xc41aa32d	0x6a2851b1	0xb69ae1c1	0x8f603c43
-	0x763497f2	0x73344cbd	0xcffd175c	0xfccf5a91
-	0xb2318bf7	0x66ac628f	0xa98fa975	0xb68e5426
-	0x27555715	0x5157a93f	0x666fd404	0xb37fcc40
-	0x563b0512	0xb70f8446	0xe10d257f	0x73793ef2
-	0x31a84915	0xe0de9489	0x08dfa368	0x9169d4fd
-	0xc14f5c9a	0x92e6db4f	0xa30b6cec	0xca04670e
-	0x8a664367	0xe8984e70	0x1c96a39c	0x655f9abd
-	0x6999a190	0x76267621	0x0f49f963	0x8ddad3a1
-	0x51fdab6a	0xaf0d6863	0x23b71bdb	0x32818c8a
-	0x6398044d	0x26c60bec	0xb0b631fa	0x938f69c7
-	0x52f11913	0x1e6fbe7a	0x92dcd409	0x419bfeae
-	0xb147bb96	0xbac5bf9d	0x08de155a	0xde8ca968
-	0x20aef902	0x62df25a8	0x64a4042f	0xef19da4e
-	0xc75fd112	0xc9863e47	0xaccfdbcb	0xd29b6090
-	0x6dc67b4a	0xa84b3cd6	0x45a0e708	0xd28673bd
-	0x00bebebe	0xd5e518d7	0xc63d647c	0xa28f5f6d
-	0x3372edc8	0xa1c44ed1	0x88e61d44	0x5e095835
-	0x2d8713ce	0x6791a885	0xae89c04a	0xf1dc5105
-	0x6423f3b7	0xf4e2f384	0x2d2761a7	0x38ea905d
-	0xa263d776	0xd1936fa6	0x2fc54081	0x429a25c2
-	0x13f6c5df	0xffffa6c1	0xfaf82002	0xe4bbb103
-	0x2fc0c622	0x669ee281	0xec785fda	0x91156b25
-	0xa9f4444e	0x354fdfc2	0x7c5f5069	0x72ae591b
-	0x73bfd64e	0x6b96d744	0xf261daaa	0x2de15dae
-	0xedaba9c2	0xf287b3fd	0x8b2097b6	0x589934c0
-	0x7edc2a73	0x469b16eb	0x247b9a22	0x8b7e6c7b
-	0x3e71ffe2	0x5275f242	0x032a211f	0x977bff60
-	0x4306ad03	0x6a212383	0xceb36448	0xa2a79209
-	0xe3842f42	0xcee0cbe7	0x37cdb626	0x29a0a515
-	0x2857ead6	0x981d5d9b	0xf0ff9b06	0x95de8cad
-	0x4dcb565b	0x065d585d	0xe7eb754b	0x278fa774
-	0xe4d8fb7a	0xe152f018	0xfb7bb25e	0x50323b64
-	0xba618e43	0xf8cb1c61	0x1b6dce25	0xb4fc7867
-	0x2a7fb213	0xea9e646e	0x3f9b735b	0x5640315d
-	0x0793ba5b	0x71ff31fb	0x4b41f1d6	0xb1538146
-	0x336f4272	0xf176d509	0xb7fc03c5	0xd6a1c927
-	0x56a68c10	0x8b4740cd	0x14c54f8a	0xf07ad8a9
-	0xa8403db8	0x37c23f2b	0xdca69aba	0x4b39ef9d
-	0x2af13bdb	0x6baace1f	0x8c7ca0d2	0xba86bd02
-	0x2a74681c	0x5542ae58	0xc36709e2	0x82b34568
-	0x26ea06be	0xd4bf458c	0xde209de7	0xa311b4e5
-	0xdc00e139	0x7d305958	0xc5d76ed7	0x0943a285
-	0x48ce4e29	0xe371bd9a	0xfe6a6501	0x4167d215
-	0x402e47ba	0x588458be	0xbf4bcf37	0xf7fa27a8
-	0xb725f91a	0xc17f5c07	0xce771dbe	0x66f9d592
-	0xe8521ed4	0x42f75171	0x343b3e74	0x2d5448b5
-	0x2d1fca8c	0xd7a32431	0xc29a88d2	0xffb07fd7
-	0xcca0333f	0x43204f2f	0x866c1867	0xcb215814
-	0xfcb67d4f	0x423680be	0xdf22f6d6	0x03373eda
-	0x3bd202e3	0xd8972fe3	0xb7733d70	0x7a472c76
-	0x6cc8a627	0x3b27e643	0xa3475f3f	0x87ffb286
-	0xf823d69f	0x6d57c38e	0xa0fd464e	0x53e2e341
-	0xaaab23ef	0x439429ef	0x55ba2a2b	0x4da5ea4c
-	0xc1fe05fc	0x874b7a34	0x9a875956	0x713ccc90
-	0x49afcff2	0x5905dc0b	0x1f5dddb7	0x8ef5c1d9
-	0xf60eca50	0x25172569	0x3525639a	0x25804bbe
-	0x5729cd49	0x17f84e66	0xc540d86d	0x51524bc9
-	0x9a6e9901	0xf5bcc70e	0xf7a73ffd	0x54509c8f
-	0xec58b8a4	0x9993703b	0x6ef45fc4	0x5ce3a507
-	0x1d73c611	0x8780e8ff	0xc7d2e02b	0x0bc825f2
-	0x02f75fca	0xe80c0758	0x24646fe9	0xd378ff5a
-	0x592c5619	0x6c80372e	0x1f7351d1	0x4db5182d
-	0x3985fdfb	0x16ca9158	0x58ee1ae4	0xaf2b9fa0
-	0xe97f60ce	0xbb911e68	0x01748fa0	0xaef578d3
-	0xc3736418	0x8ab0deb5	0x0de16af1	0xb8369f7b
-	0x68e43c12	0x914ca0f6	0xe950ef28	0x834eff90
-	0x51adb952	0xc42ee4ce	0xf70ab4a5	0xbf9fc916
-	0xed9444b1	0x845a6a1e	0xf92e7b64	0xb9ca8a1b
-	0xa9cdfcd0	0xb5956bc8	0xb8520e59	0xdde7aa57
-	0xb41d390f	0x364aef3c	0xf39d4482	0x8b4e651e
-	0x0b82f5fb	0x7960e81c	0x12ed7b84	0xe9f123ca
-	0x88a64db2	0xa0c714cb	0x57b01471	0x80ff31a6
-	0x7571d8cd	0x857035d9	0x0508587c	0x594a4a42
-	0x011503e5	0x27c75e55	0x03264f62	0x9316ed1d
-	0x36e5cd1e	0xfa9b23b4	0x5bc8c606	0x0902bd38
-	0xd6745c69	0x6fa73118	0xa50f7b94	0xc529e962
-	0x28738486	0x7b85a599	0x2c495a35	0x85f2cbef
-	0xa09dfe51	0x1c763ab2	0x4effdb5c	0x506586f0
-	0xec182a58	0x45293146	0xaf8d78b8	0xa89bd228
-	0xec24826a	0x752cc421	0xbf36aa46	0x6760e225
-	0xe15d0987	0x6fa9bdf3	0x6837c755	0x9426d654
-	0x14b48f5b	0x5d70567d	0x63a14f92	0x809d5361
-	0x3b6e2729	0x84ce5415	0x7eaca6e0	0x9b467302
-	0x8f39d484	0x8e78398c	0x33108b33	0xdc07005c
-	0xbdc2500f	0x35f1f452	0x9d254e3d	0xfa61eb21
-	0x2ab6c7aa	0x83561fdc	0x8735d598	0x416e8591
-	0xfe10e93a	0x18da409d	0xab6d0bfd	0x675baaf1
-	0x287fdd24	0x6b50b63c	0x8c08abca	0x871a59c9
-	0x41bb2ae4	0xfba9abdf	0xb46491c7	0x4e433d5a
-	0x01e4fbda	0x0bc40399	0x3bdb61c2	0x3cf051ba
-	0x910daa46	0x8d4065d6	0x270667eb	0xf6d42459
-	0x01993a1b	0x00a95dda	0x6ed5a693	0xed4fbf7b
-	0x24dbb70f	0x67fd62ee	0xcef5f0a4	0x9e65b798
-	0x9a9913fd	0x3d0e7190	0x4265b4e4	0x80bfc46f
-	0x6b354d2c	0x2b90a987	0xc989cb75	0x773e6b64
-	0x55325e9f	0x18816a56	0x07413406	0x5177ae31
-	0x24a19ef7	0xdac405a4	0xdca2d3b4	0xab7c7b70
-	0x42b5de0e	0xfcf918a5	0xa54d934b	0xcaa9eab6
-	0x50e63e2a	0x4b168926	0xb2442913	0x594c0f94
-	0xf387f31f	0x4d716749	0xc8433297	0x34c1a5de
-	0xe929008e	0x5644251b	0x736476d0	0x0d00aee7
-	0xf20b2f64	0x5e158173	0x9af3e568	0x5f19fa7e
-	0xb23b2861	0x8659ee6e	0x94058a64	0x66ec4fb1
-	0x37cd6a4a	0xbd2944fe	0x0ea44ec6	0xe7d64c24
-	0x75a170e3	0xb4a9479c	0x2215716a	0x64a8a574
-	0x257e86ab	0x86bae993	0x3030352b	0x15cb88bc
-	0x576363a0	0x61138c36	0x7cc4fe7f	0x648977a8
-	0x0ef71fec	0x1c60df47	0xc75f70ea	0x88509798
-	0x172b407a	0xf888e400	0xef33cd15	0x5976757d
-	0xf8cfef13	0xbf024380	0xbb9c1b02	0xe4c38ec9
-	0xf30fce01	0x8efa5213	0xf4b48aad	0xc94c3a37
-	0xeb1bcece	0x09a18b56	0x4e83c0d3	0x6fcf9f77
-	0xf52f4d76	0xf3368a12	0x33b2797f	0x627b6e41
-	0xefd05154	0xa83ae2a0	0xea211129	0xd25723d5
-	0x7bbb0e3b	0x7131f088	0x5dd5193f	0xef5aa905
-	0x39f77be7	0xa21b48c1	0x1ded01c1	0x5cf98c5f
-	0x6e23d207	0xd7e7dadf	0x5932ed1a	0x2a729061
-	0x29a89f4a	0xac0e8447	0x01ff4205	0x8b1456c6
-	0x3fba0156	0x658c03f7	0x5c69f968	0xf6570582
-	0x21bb0145	0x8683bf5b	0xa4b6eba5	0x4ccfe5cb
-	0xd202898c	0xbd2411cc	0xc2fc702a	0x5c39b695
-	0x87584ccf	0xeae3c735	0xc472b6f9	0x4249f637
-	0x3fa89c0e	0xce5a8bd7	0xbb28138b	0xc080ecb1
-	0x9cbf1916	0xd70424e9	0x75cc4ed1	0xa575f3e9
-	0x1c571f68	0xe2906205	0xc26520cf	0xf9c1fc8e
-	0x61c982de	0x1af6cfcc	0xaf397c9a	0x46830771
-	0x623d98bb	0xda7b52fa	0x5a3c57d3	0xfa35d2f0
-	0x4783df19	0x6ad07325	0x487406f4	0x3fae5152
-	0x189137cb	0xd98a644e	0x17ffe880	0xeb6aa9f7
-	0x67184e3e	0xe475734b	0x0f1113c2	0x39a4df47
-	0xbf8f6ec9	0xe13a4d8b	0x63ec02f5	0xdfe7d75d
-	0x1379034c	0x5db7314a	0xa9d9ad3e	0xfaaed8f2
-	0xf0fb6074	0x12f27b84	0xc97a92bb	0xae5e3bb7
-	0x5f7fc2bf	0x00cbc1f7	0x9360a4d9	0x3632ba04
-	0xad044c83	0xeda13ec1	0x34a214c0	0xcf9c972a
-	0x96352243	0xf1a35357	0x2d77bc30	0x8485bbad
-	0x67fbaa99	0x8035b1a5	0x8ca763c0	0x109d7887
-	0xa1c35cd8	0xdc79e308	0x4495404d	0x64419226
-	0xacdcea08	0x9545c0ef	0x5493e09e	0x7fe16336
-	0x41381aa2	0x5c344f46	0xb40cab9f	0xc43951c4
-	0xd86e52a5	0xb141d934	0xd78efcff	0xf37ec320
-	0xc184a45b	0xf4a57954	0xc8aed0bd	0xe602c15a
-	0x71a6b48b	0xce837428	0x02733706	0xc4a4a044
-	0xa75efb97	0xcb63d62e	0xd0580b5a	0xce499087
-	0xc12bf4ca	0x9c995345	0x1d8adfbc	0xe62fd60e
-	0xccbf5412	0x6161f8d0	0x64268e34	0x565d066b
-	0x1896b63f	0x838f8f2a	0x1e314a00	0xac470276
-	0x1879cfdf	0x4702d7f9	0x83b4d777	0x81fcb068
-	0x1b6da94d	0xd075ed01	0x3c7734e8	0x56389a0b
-	0x0743b9cd	0xb6b0bf0d	0x63107ab9	0x193172bc
-	0xc7b84c8e	0x982ce2aa	0xb8e387a6	0xc264a4b0
-	0x2ac6c802	0xb89ea335	0x052332a4	0x49932ecc
-	0xb940f808	0xa7a09330	0x19f3f49d	0x7aef6b5a
-	0x201d8ed0	0xf29aac4b	0x8ae2ac0f	0x998c1ca7
-	0x665c3927	0xab4ef641	0xf136710d	0x9644ee9b
-	0x34efae96	0x4c596035	0x8cfe8b3b	0x5d9f742e
-	0xab2c63ca	0x017d864d	0xd0604d6e	0xab24eee0
-	0x75916a9a	0xad0d1167	0xbeb47775	0x6ac822d1
-	0x776907aa	0x9e9377f2	0x438c5d81	0xd70e9964
-	0x1c09c914	0xab90e5cf	0x31cee523	0x26ba6ea7
-	0xef00781d	0x622b886d	0x36a54031	0x88b1221c
-	0x666333f5	0x60e1c93e	0x5e4d0e0a	0x3ee6ff69
-	0xceb4c76b	0xa5deb4f8	0x0668ced8	0x30225378
-	0x6697cf37	0xc5d9661d	0x089eab85	0x7684a876
-	0x018a81af	0x221a7fb2	0x31d80de0	0x9f18ae90
-	0xa29c9af0	0xc3e2b00f	0xda0edbab	0x7ee9cd2a
-	0x3ab0f88e	0x02c58228	0x606fa7aa	0x7776cb0a
-	0x4e8ad99c	0x3b527469	0x58123d62	0x4ce428d2
-	0xee91a210	0x466ba2cc	0x043c57b9	0xaf7bdd43
-	0x98e76fee	0x8f3eac1b	0x00dffd6c	0x6fcb1c6a
-	0x5cb90573	0x485d4505	0x0df5418a	0x26eafe35
-	0x0faddf3e	0x4e972930	0xe113c823	0xe45944d1
-	0xa646077f	0xc1708ae5	0x6ba07c20	0xc7e4e234
-	0xc6754ed5	0xbd6e85aa	0x8cc1756e	0x02afda29
-	0x72809597	0x75b6f5a1	0x61141874	0x1774047f
-	0x7a10afed	0xfac2c4ad	0x42cf5c99	0x24f0350e
-	0x042f2864	0xfab55b67	0xc8ead5bc	0x914e9512
-	0x77c8ef6b	0x8369aeb1	0x71bc947f	0x0c6b49d8
-	0x8ddd0513	0x028ad10d	0x99a1b28f	0xe6cfbdc8
-	0x7978b4a6	0x3ebbade8	0x9985f5cf	0x431f42f1
-	0x004372b2	0x18b67f68	0x20111c21	0xbb6f77ff
-	0x1783b030	0xa045d7d1	0x0e9c7e09	0x3ccbd95f
-	0x0b84a2ed	0xf0ee3325	0x63f2e126	0x5ec4c67b
-	0x2ca782cc	0xcaf20d04	0x8b59d515	0x3212aa33
-	0x335ca0c3	0x6f9e0cdd	0x4d4bf189	0x44d2fa0c
-	0x5abe9396	0x492794ee	0x10dcfcb1	0x9acda9bd
-	0xe8aa2803	0x3f1b9605	0x3e2ecb5a	0x971bfa8a
-	0xcbf141d2	0x0afafe10	0x2fc906a6	0xefad20c0
-	0x9e922581	0xe69142cc	0xc9c0ba82	0xc069e640
-	0xb99c08b6	0x4b62ca1f	0xf3c5767a	0x6ab088c7
-	0x8f0f0c0b	0x6726f64a	0x9711a3cd	0x46462571
-	0x3a58350e	0xa2561911	0xe24dfdfe	0x97443fdc
-	0xf80540be	0x069978bf	0xb38a359b	0x8e574f62
-	0x69aea75c	0xdc753fcb	0x2a74002c	0xced027b4
-	0xda993254	0x03409b83	0xf827331d	0x75fb3271
-	0x01ad839d	0x68520842	0xca65c45c	0x1a3db5a0
-	0x91d37dd3	0x6168c0fb	0x935f5a08	0x002007c3
-	0x42eb4760	0xdab3a804	0x72a6297e	0x905c32d9
-	0x81abcfa9	0x1b21d04a	0x5a1289ae	0x424e7183
-	0xc207906c	0x31fe9134	0x5eb2e5af	0xc9253fc7
-	0xc32be24f	0xe5474cbd	0xeff6e1b0	0x710e5e69
-	0xe6c4c538	0x96b5f1de	0x2abc9c35	0xddbd1a92
-	0x8aca40d7	0xe359c238	0x954718f4	0x18b157e5
-	0xeeed790e	0x6948a963	0x24e70bfb	0x4d681547
-	0xf68369a7	0x5b54409a	0x1f0b787a	0xc2610047
-	0x0f8bd269	0xd7c8c154	0x9dee62d9	0xd4738ed8
-	0x1a66c6b1	0x5bad5a5b	0xb110311a	0xfaec6802
-	0x6b750f2d	0xcbf8d0e0	0x11edaf4b	0xf64a07bb
-	0x422e7c15	0xb1732663	0x1ff404f0	0x2d5052b0
-	0x6e45356c	0x7e2201e8	0x7c5ebcd1	0x1cb4425a
-	0xb1539a64	0xa2e4459f	0xcf1ade8a	0xfc476473
-	0xf4147deb	0x2afbdd77	0xff01fabc	0x6597408a
-	0x0951220b	0x6750f3ec	0x0a242763	0xf3d71c05
-	0x84cb1c26	0xdb7a81bd	0x7aea1a5d	0x7e719a48
-	0xc5c12fe1	0x0ce2e988	0x29ecc6f0	0x5ede901a
-	0xda8399b1	0x31c05d6b	0xe1956aff	0x59ed7c3d
-	0x60832637	0x9bcb7cac	0x63c530d1	0x14c677de
-	0x9225ed18	0x065327c9	0xd1ff6a0e	0x5516517e
-	0x53c6f5c2	0xed5983cf	0xaa1d18b9	0xbe300d7f
-	0xadc525a7	0x07ea81b6	0xfc517a09	0x4ead3f86
-	0x45435f41	0x2efa58df	0x02348ebc	0x30ed6783
-	0x190b4fb9	0x85c55d6e	0xc9ed8896	0x416ee113
-	0x9b3536d9	0x30577cc0	0xbc4b88c8	0xcda59612
-	0xdfe2bd89	0xd60cde71	0x98843881	0xcc1f32f2
-	0x18b3f643	0x671a14ca	0xd6482a47	0xac6a7d38
-	0x1897da16	0x91b6fcb3	0xf199bb35	0xd38c00ba
-	0xa8c946b6	0x52a1ad37	0xd38ed2d4	0xa1d6f81d
-	0x5af6865b	0xebdb858f	0xb844b110	0x53201ea2
-	0x08870945	0x10c869de	0x19849613	0xdb35d3ed
-	0xd68ebd6e	0x1056fd48	0xf1a0e305	0xe3982ebd
-	0x6f7cc391	0x5956374a	0xf414a5a2	0x325119ab
-	0x99ee1f96	0x6f044bd9	0x8374805b	0xb55c366c
-	0xa2c77051	0x68f199e5	0xd36a9714	0x878f847b
-	0xec0394ae	0x86d0584b	0xf4df66b9	0x451cd039
-	0xf4de06ae	0x35dd0554	0x818a342f	0xeefdbfc9
-	0x5b4e9edd	0x22d9313a	0x3b710d60	0x6deaeb4c
-	0xa9e26512	0x98d31867	0x3c2c2d61	0x7eb5ce41
-	0x40890db6	0x7a3aa660	0x3ef4f306	0x7322881f
-	0x49dac4d5	0x96efe685	0x27bb7f49	0xbb955283
-	0x79c5f2b7	0xff599c28	0x28ee7f5e	0x9f324b73
-	0x45edb7cf	0x39a8b79c	0xd0919c6e	0xe149b29d
-	0x62f5f82e	0xebcfa23e	0xd4d68937	0x54270090
-	0x958af0d4	0xa1e4e799	0xaf68ac19	0x82a84f4e
-	0x50f67b84	0xd5e59629	0xf5fdf24c	0xab1d63c5
-	0x30835807	0x431fce5f	0xe5f96f4d	0x3f6b4802
-	0x14010be8	0xdca45ae5	0xc82709af	0xff76ce2c
-	0x8b222c22	0x73a2d948	0xa8d59cea	0x8c31849e
-	0x469c2e5f	0x3777ee84	0x5fdfa5da	0x02ef9bb2
-	0x792d3194	0xbed63f21	0x0b6dc5f1	0xc9d7fe08
-	0x6df7883d	0x366566cf	0xef772769	0x37826465
-	0x1cdc3086	0xa69ff7b6	0x235012ea	0x292f7e75
-	0x30bdd0fd	0xffdc9df1	0x95c6d570	0xec206204
-	0xc6cd42cb	0xc0d6dfd9	0xb7a16b71	0x17fa527e
-	0x295f2c79	0x990f9820	0x8b8f447d	0x193f9ad1
-	0xebddb2af	0x5dd532eb	0xf1bbd8e8	0x3444a3f4
-	0x18ccce93	0x05edeb4f	0xc4a6b935	0xba37aab0
-	0x96076ba4	0x250dc2f7	0xc4093548	0x030e777d
-	0x7ea40933	0x8da7b1dd	0x59c0b79f	0x807d437c
-	0xf5233ddf	0x54c1983f	0xfc18771b	0xe74b85f0
-	0xdbd725b5	0x70cdd153	0x4ffe300c	0xfda4bdae
-	0xf4ac75d2	0x91c4e15a	0x34d92b97	0x16356a79
-	>;
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/Makefile u-boot/arch/x86/dts/Makefile
--- u-boot-2015.01-rc3/arch/x86/dts/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/dts/Makefile	2015-01-01 17:34:32.253503252 +0100
@@ -1,6 +1,7 @@
 dtb-y += link.dtb \
 	chromebook_link.dtb \
-	alex.dtb
+	alex.dtb \
+	crownbay.dtb
 
 targets += $(dtb-y)
 
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/microcode/m0220661105_cv.dtsi u-boot/arch/x86/dts/microcode/m0220661105_cv.dtsi
--- u-boot-2015.01-rc3/arch/x86/dts/microcode/m0220661105_cv.dtsi	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/dts/microcode/m0220661105_cv.dtsi	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,368 @@
+/*
+ * Copyright (c) <1995-2014>, Intel Corporation.
+ * All rights reserved.
+ * Redistribution. Redistribution and use in binary form, without modification, are
+ * permitted provided that the following conditions are met:
+ *	.Redistributions must reproduce the above copyright notice and the following
+ * disclaimer in the documentation and/or other materials provided with the
+ * distribution.
+ *	.Neither the name of Intel Corporation nor the names of its suppliers may be used
+ * to endorse or promote products derived from this software without specific prior
+ * written permission.
+ *	.No reverse engineering, decompilation, or disassembly of this software is
+ * permitted.
+ *	."Binary form" includes any format commonly used for electronic conveyance
+ * which is a reversible, bit-exact translation of binary representation to ASCII or
+ * ISO text, for example, "uuencode."
+ * DISCLAIMER. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
+ * HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ---
+ * This is a device tree fragment. Use #include to add these properties to a
+ * node.
+ *
+ * Date: Sat Sep 13 22:51:38 CST 2014
+ */
+
+compatible = "intel,microcode";
+intel,header-version = <1>;
+intel,update-revision = <0x105>;
+intel,date-code = <0x7182011>;
+intel,processor-signature = <0x20661>;
+intel,checksum = <0x52558795>;
+intel,loader-revision = <1>;
+intel,processor-flags = <0x2>;
+
+/* The first 48-bytes are the public header which repeats the above data */
+data = <
+	0x01000000	0x05010000	0x11201807	0x61060200
+	0x95875552	0x01000000	0x02000000	0xd0130000
+	0x00140000	0x00000000	0x00000000	0x00000000
+	0x00000000	0xa1000000	0x01000200	0x05010000
+	0x19000000	0x00010500	0x15071120	0x01040000
+	0x01000000	0x61060200	0x00000000	0x00000000
+	0x00000000	0x00000000	0x00000000	0x00000000
+	0x00000000	0x00000000	0x00000000	0x00000000
+	0x00000000	0x00000000	0x00000000	0x00000000
+	0x9557a557	0x7d7a0fe3	0x8e2fbe53	0x0db9e346
+	0xd35c00d6	0x21bb34b7	0x662b6406	0xa0425035
+	0x3d028208	0xcb843695	0xee06be0a	0x9817efa7
+	0xb86c0d16	0x45f70c93	0x79fdc3af	0xd5f30da7
+	0x460f62b0	0x238a0470	0xf0ec95bf	0x97b9c176
+	0x6d612851	0x69b9b4b6	0x1df769cc	0xe11674df
+	0x1b579adf	0xc8bcc050	0xcdb3e285	0x327592c1
+	0xbeb6047a	0x977f6be5	0xc4854052	0x27f38b66
+	0x4ca5eab3	0xf806decc	0x2be4b409	0x460a3b03
+	0xde2f6e0f	0x53ce08b3	0x3ef0ef93	0x4e013088
+	0x226f8a5c	0x57f7d291	0x8d640bf7	0x8a998907
+	0x40464dd8	0x804ef3e5	0x647e35f3	0xeabee2d1
+	0x3a5ce9c7	0x4d7ee530	0x564321ec	0x9e85107e
+	0xd595581d	0xcbf6efde	0xed3010ed	0x3d607e82
+	0xe32d4b6b	0xd06fec83	0xf39240a6	0xe487988d
+	0xddbefcbe	0xefaf1121	0x96bf9acb	0xacce795c
+	0x7fa5f89b	0xbe440e5d	0xb6d3a3dc	0xcad17290
+	0x503ae748	0x04c80b8d	0xd394ea6a	0x3e4072c3
+	0x11000000	0x0b0ae65d	0xc6c53cbd	0xd52a6c2d
+	0x84cc192f	0x89498e7d	0x89270686	0xe68105e0
+	0x4073a570	0xd3338d8e	0x51193152	0x7266182f
+	0x980553fa	0x51b89c90	0xd13b6151	0xe6e40a91
+	0x0ab997d8	0x2d0a443b	0x9d3d566d	0x820402d1
+	0xdbe79fcc	0x7c5e0b45	0xaf94216d	0xbf717950
+	0x520b3dd4	0x566a3396	0x0b6f794f	0xc5dfeda5
+	0x71ba0f02	0x4839a5ed	0x39a4e4a6	0xe567c652
+	0x0e044997	0x84a0effd	0x09c67178	0x89a815c8
+	0xac821555	0xd6719303	0x582b964e	0xfe3a53f6
+	0x241b9b8b	0xc6e65457	0x623a4e0a	0x590d7d03
+	0xe50e7ce1	0x4bca4700	0xf24f5eff	0x1f1b20d9
+	0x77e3227e	0x699b5e5d	0x9aa5f621	0xff08bba0
+	0xf17ce716	0x0f5336f5	0xbce055a7	0x8cea9dac
+	0x8e09d26c	0x66c3ddf0	0xbec71660	0x75248cd2
+	0x29afcf8d	0xa5ade5ce	0xf68bace5	0x63b513cd
+	0x4736a842	0x4dbf80df	0x4e85fbdf	0x4dce3d56
+	0xf2150fdc	0xc4232709	0xffdc3e3a	0x92b72a3d
+	0x9ffce715	0x682959d1	0x091ba33c	0x0f1dc729
+	0x2f29a924	0x1df72429	0x19b0365d	0x2d5a3cd8
+	0x20617351	0x109074f9	0xf232874a	0x40d79569
+	0x97dbe4c6	0xa3b66845	0xa04d2faa	0x6dce9a96
+	0xd4963c67	0xd4516f76	0x64a0b04d	0x0b87ddfe
+	0xd8a5305d	0x717ecf67	0x77189035	0x40542ed4
+	0x5a180ff1	0xb2042e2c	0x6639819b	0x0f0756c3
+	0xf939bd70	0x25efe0d6	0x3eb65ae9	0x39a057d2
+	0xb2595655	0xf808b4fd	0xe22d0593	0x76256500
+	0x0eeee6ee	0x6895d1cf	0x9fc117a7	0xd19e5f15
+	0xf677f085	0x1ecdb30d	0x704d0975	0x9099f42e
+	0x421be0b2	0xd02548bd	0x3a16e675	0x7d8b051d
+	0x9d24480f	0xbc006432	0x184da9ec	0xbad7abef
+	0x299f58aa	0xc1a249fa	0x8d9d31f3	0xe73cda17
+	0xf41ac993	0x7b88d3bb	0xf349c676	0xb8341361
+	0x1b69bc01	0x98e0bfd2	0xf31db8d9	0xeb49b275
+	0xabc40133	0xfb7d0701	0xcd5ff353	0x4eaceb8d
+	0x67aac555	0x6d81693b	0xe81c555d	0x5d7f3688
+	0xd4347083	0xcd861b1d	0xd332f2cb	0x43130028
+	0x7f1a1c51	0xe2ce3af2	0xdff5076e	0x6ef21237
+	0xf65fc8c4	0xbd28ff14	0xd70f49a3	0x4f559249
+	0xd6fe7530	0x1fe89b4a	0xc1cc8975	0x2fd705c5
+	0xf2993d77	0x60f2e3da	0xe3ca3c44	0xbd0f70b1
+	0x0d333d10	0xa29a6aa1	0x43b5a6d4	0x30d15a08
+	0x6df9564a	0xea09045d	0x54ca3f5a	0xfbcfa037
+	0x6dd64d1b	0xa4a8995c	0x1f4298f0	0x3f4d9a86
+	0x924ee146	0xc2e3f464	0xc247747f	0x8bf5c7d7
+	0xf8f0b05d	0xf65a115f	0x4b1ae4e5	0xe131e187
+	0xfaf713c1	0x5ff88660	0xcd4916b0	0x448028e0
+	0x140711ca	0xffe77575	0x8b7740bd	0x82b6ed95
+	0xd94d9647	0x2623c011	0xd54fba11	0x30a7050b
+	0x28fe4069	0x70b8bf7d	0xf786eb6d	0xe39db734
+	0xa3290669	0x8747e1d6	0x35804a42	0x1c26ed60
+	0x30a8880f	0x8170a277	0xa1d97657	0x6ebcb3ed
+	0x3bb6ce89	0xff808c1b	0xc919fd1e	0x911d8b14
+	0xcbf41a24	0x82abc738	0xfb5e988e	0x328aa123
+	0xf19146e3	0x587baa80	0xd105e811	0x83b09389
+	0xa29fc554	0xe3831a28	0x183f8de7	0x4ef5656e
+	0xcc940baf	0x938bf4b4	0x90627bae	0x14fc3cdb
+	0x75e45681	0xf912c1b3	0x7a5b8a0f	0x3b970524
+	0x6a74d34a	0xb3da9fe6	0x847a3bd8	0xfc4f7dd6
+	0x88fd7f3b	0xbcd74a15	0x3afed836	0x17e31cd0
+	0x5d866dcb	0x0ab69608	0xe334f0fb	0x7181d4a3
+	0x8dc87560	0xd9c94d6f	0x491c2c91	0xca295ed6
+	0xfb8dcd79	0xeb4d3f89	0xec581071	0x0457ebc6
+	0x6b63590b	0x9dde4b79	0x3dc0a0aa	0x41ec8a1e
+	0xfb2ab80e	0x07adc629	0xb8534a4f	0xd0d23901
+	0xcfd024da	0x47c4163a	0xc89d26bb	0xe5cac48c
+	0x17c7fbba	0xd992f42e	0x466f5e35	0xce48304e
+	0x394683c8	0xef6e6b7a	0xb9d1242d	0xb961debd
+	0x432a3dff	0xa4931ea7	0xd9f03907	0xc29e9ce6
+	0x4fccf4c9	0xbf234555	0x0b6a6771	0xb29f29ef
+	0x7edc4bfd	0x781dcf74	0x4ae31020	0x1ab72d9b
+	0x0ac457e2	0xf9291e09	0xd4084918	0xa540d999
+	0x223408d3	0x0bd039aa	0xaf0dd904	0x9cfd6a01
+	0x826c6bca	0x8e41a96d	0xa56fc4ee	0x6a7509fb
+	0x5cd2e6fc	0xb89aa158	0xb1e5d3f5	0x92ccd05e
+	0x995d5acb	0x5ed1dc08	0x75038dac	0x4377c835
+	0x265d66d8	0x3692096f	0xcd69ee59	0x310df351
+	0x087e3133	0xe89e2d58	0x137fd054	0x00f3562b
+	0x2ae304e5	0x9db0316d	0x6868cec6	0xb249ccec
+	0x9f602c90	0xd3715e7c	0x3fcc8a62	0xa1c1e065
+	0x5b4281d4	0x124dfd7e	0xe9d21462	0x77cbc940
+	0xf915f2a5	0x66df82fc	0xa8c67c56	0xac4d461b
+	0x836deb52	0x95fbb48d	0x3454b6bd	0xd87d7a64
+	0xe64d32b8	0xc44c2aa0	0x3e213c1f	0x4d31b94d
+	0x4640be5e	0xe127234b	0x9ca54856	0xac7d093f
+	0x03d0508b	0x30f5121d	0x6e347d91	0x47772312
+	0x318ea26e	0xad3f6902	0xb5598746	0x8be3b65b
+	0xc8bbd31d	0x24691564	0xee77d2e8	0x3581944e
+	0xeff8eed5	0xa29ea86c	0xc2597492	0x23c1c118
+	0x7810c079	0xb966ee47	0x823e9954	0x9e558c0a
+	0x74759c12	0x193c6b4e	0x7544597d	0x65c9bf8a
+	0x68f5e263	0x718c679b	0xc8dc50ba	0x5f5ab841
+	0xc3eaf579	0xc2072358	0x62481939	0xffe7e686
+	0x201f3215	0x1d88dc8e	0x28fb4002	0x40c56ec5
+	0xb7bcce00	0xd52f5042	0x84498e04	0xcc97fb7d
+	0x64035e93	0xcd3478a4	0x15d63309	0xa9e47b85
+	0xe835e45f	0x9de598b7	0x94f569f7	0x56689b0c
+	0x381f9173	0x708b3e52	0xc81f0649	0x12113041
+	0x4694aae2	0x69040fc0	0xe4ba7bf4	0xfadc5729
+	0xc168381f	0x1985f118	0xab0ca720	0xf0150799
+	0x42690e4a	0x71af3be9	0x9325f3b8	0x36575996
+	0x4dc1dca7	0x7e534c37	0x01830a21	0x221eef4f
+	0x18698322	0x57a80837	0x483ae2d8	0xef905b54
+	0xe01827de	0xae9a8ff1	0x0058be7b	0x052632ad
+	0x9df5c90b	0xb763fc7a	0x5535c95c	0x8eb5916a
+	0x75fde5cc	0x57d8eeab	0x0dcc35c6	0xbf11c88f
+	0x69142118	0x4f35c928	0x7966066c	0xb2d13b4b
+	0xdad06d34	0xb5d8f5c7	0xe0bb11e6	0x8a36325d
+	0xc1122d64	0xcf07a1a5	0xfe7ce9b1	0x176b624b
+	0x4de883fd	0x00a9024b	0x3d3f7271	0x5072895d
+	0x2634e158	0x2f3c9a35	0x95e374d1	0x65e66528
+	0x47766433	0x4cb805ff	0xbc8f0319	0x6d5055a5
+	0x4932e8c2	0xa93fbb4d	0x87f08bd9	0xf5e5706e
+	0x409af40e	0x017edf5c	0xc5394c71	0x6fb97b6d
+	0x7b5ddb6b	0x0256adfe	0x76d337e2	0xa3327113
+	0xfbb4cb29	0xea68ca27	0xa76a865e	0x8cdb2dd3
+	0x902642bd	0x16772269	0xb2341eaf	0x858fa943
+	0xb087fac9	0xd17de85b	0x3d9c248a	0x0bdcf2d0
+	0x874fc03c	0xf19f2591	0x190c06a9	0xc6b5c3ea
+	0x472b6245	0xdb9f8201	0x46d27a0d	0x52218ffe
+	0xece78c44	0x3ef6e38a	0xfcf19b65	0x536c840c
+	0x86d363e8	0xaa852826	0xde17e3ec	0xa9c3b45b
+	0xd322302a	0x48f03728	0x2f60d01a	0x3b356752
+	0x8a869fd4	0x055d04f4	0x765074fb	0xb0b5c2d1
+	0x865ad360	0x0cb6c6e8	0x5de9cf99	0x863938d3
+	0xd4d9aeea	0x0babfa86	0x172cfb57	0x972d8f4f
+	0xe9aeeb95	0x6acbe297	0xf2459e42	0x415fdd12
+	0x84b2e67b	0x47d2d466	0x44bc85a4	0x1a55b957
+	0xe4d01142	0xbf4ea387	0x5651e1a2	0x19124703
+	0x8aaed1b2	0x841f3ecd	0xc6d6cc4f	0x1f2d8565
+	0xba08e74a	0x68e5ecf4	0x07af5ef4	0xdd5a43a9
+	0x6086c705	0x37ced045	0x0fb05ca6	0x35f39f3b
+	0xda1ecbef	0x1daf6d76	0x5481d7ed	0xc51e8385
+	0xa705e11e	0x127d2a7f	0x654d4710	0x1a34370e
+	0xf8496ea4	0x4392b6ec	0x2f209933	0x9c5ab017
+	0xa4f7b837	0x33e0a7d0	0x98fb0635	0xdefc042a
+	0xc7a1f6b5	0x47107766	0xd06acfba	0xb8ac2a93
+	0xe21cca44	0xf0150492	0xd4de2e01	0xe0d6e9a5
+	0xa758b5df	0x2e1c31c0	0xc4794495	0x3d9cc157
+	0xf94aa4f7	0xc2325855	0xcf9ddd12	0xaa70e611
+	0x2b2404b8	0x75d87f38	0xa2a6f772	0x61abfa04
+	0x23b61fb0	0x87f4067f	0x355abf99	0x2c4e6c48
+	0x2dc8a3b2	0x119b08b5	0x3f1f6d09	0x374372f0
+	0x24d79d32	0xef2b58be	0x461ab91c	0x1d31267e
+	0x8b1b2c7e	0x27a4f103	0x1686c7c3	0x55af0d87
+	0x61c2503b	0x9ffcca7f	0xc3cbdd07	0xd49a4f3c
+	0x9ddc2ac9	0x335e1b2a	0xd8dcfc08	0x6e83f11c
+	0x53de9e30	0x7b774670	0x15a97571	0x1ecacf66
+	0x26581520	0xeee3496b	0x1fdf8174	0x4ddd3c61
+	0xaa504fc2	0x0b09792e	0x9b81d1c7	0x10765c95
+	0xd3e7b9d1	0xefdb38f9	0x4c44d38e	0xaaf8fd08
+	0xceb22e7c	0x5ac74242	0x6baee02d	0x5c7eaa5b
+	0x27265dca	0x614c3b5e	0x2994874d	0x486d48a3
+	0x5945c4f9	0xe465f343	0x934e55de	0x633199a2
+	0x147222cc	0x9bbb0c16	0x6a7e7ef1	0xb7bce9b5
+	0x13413d18	0x628231af	0x0fd2d58c	0x4cbafba0
+	0xa930fae6	0x91733823	0xe06f99c3	0xda3b57b7
+	0x04b8a9dd	0x53451e33	0x11fde5fd	0x0e35bcb8
+	0x3a5799d4	0x3893f9c0	0x6b9d0e1d	0xf8d948ce
+	0xa33a6628	0x7d09792d	0xd74b3719	0x0afb4de0
+	0xfaa5a685	0xecf7f8ac	0xcf34b855	0x89453b4d
+	0x12f028c3	0x45edc3fd	0x792c43fc	0x2b054962
+	0xb8799a92	0x0ab38d61	0xa6c6a76d	0x7670cdbd
+	0xf878b511	0x9a3474ba	0x478673f0	0x7398bba8
+	0x4fa10ff5	0xf0a1931c	0xd5938e03	0xe9a23c28
+	0x7bea2a5b	0xf7a8db22	0xb94ae0e3	0x2abe6385
+	0x0ef2cc36	0x6b997544	0x1e8cc4f1	0x69a5b182
+	0x54f9b7c7	0x8fe56cba	0xc7c12fcc	0x8d689865
+	0x2d6ef011	0xc6a1b740	0x66af0a76	0x76018cdd
+	0x30661377	0xcf1fcf93	0x08046423	0xdf9371c8
+	0x1795ec3e	0xf5ea09c6	0xe462de69	0xd7da78a1
+	0xd8bda1eb	0x1179f53a	0x2b394767	0x3ba153a7
+	0xf9c85bd7	0x5700c827	0x8478ac99	0x080a2f52
+	0xdd1c18f1	0x579cea67	0x345c56ce	0x4563f16a
+	0xfa1a5b74	0x0b6e233e	0xadc7bd9a	0xbee6d2f0
+	0xa249f3ef	0xcdea9b77	0xeaaed82e	0xcc4448a7
+	0x34f7cafb	0x7621bb44	0x4965b0eb	0xe6d6b8bf
+	0x3c683b25	0x33bcb5fe	0x3f376249	0x5b40dc67
+	0x658bf6aa	0x7f0c5d0d	0x61514591	0xeb3bb83f
+	0xc2e208dd	0xe82f08f2	0x6ef75ae5	0x9c11bc0d
+	0x289c0553	0x1578ce5d	0xb7f05c0e	0x818c5ebd
+	0xe566ec9b	0xc6995b3f	0x0c02aac3	0x2b4264b3
+	0xf9cad304	0x5b0479fb	0xf8ce8d6f	0xb7d80d8b
+	0x41a0d223	0x71ec8a7a	0xc9d74d41	0x245c5988
+	0xf607fc59	0xf1c7b6ab	0x142ef712	0xbf607800
+	0x281e5911	0xad9a3e63	0x87b59384	0x7ebdc04c
+	0x6f47867b	0xb6a304ac	0x289f65e7	0x335fc866
+	0x77eb11b3	0xb70c25b2	0x70b43d52	0x684d46c0
+	0x0940459b	0xde739ede	0x0b438a29	0xb713e77e
+	0x71f539b7	0x8b2f0f7b	0x8d8ab95d	0x42cde8c9
+	0x08c259d1	0x021eda69	0x2af81ddc	0xc7d13028
+	0x05abfa20	0x6a61008b	0xfc62557f	0xd6d731b2
+	0xb080aca3	0x6acae4a3	0xab33d2bc	0x7983c177
+	0xdf0c357d	0xb8dcb956	0x9c214460	0xfeb75d75
+	0x9b3d468b	0xd2c3106c	0xb1bd118e	0xf26df6a8
+	0x11b9c4d2	0x031357f9	0xf7af8a12	0x70fef26c
+	0xe5d8b8d5	0xf6746fd8	0xd6cc3266	0x4158e59f
+	0xa38fbfcb	0x01c61ff6	0x44c7c4e6	0xf26db3aa
+	0x46bb6d84	0x0a794535	0x1d5eab72	0x42345de7
+	0x0c7e6d47	0x8bacc223	0xb7334b8d	0x3d9d951b
+	0x18f4afc4	0x9c0cb708	0x53b71b82	0x603e8350
+	0x6f2df978	0x0c6f3f0f	0x661ebca9	0x30788bd0
+	0x982959c0	0x50aa1351	0x672297c1	0xa490a756
+	0x21c9e911	0x977e172e	0x0446db50	0x49b711c1
+	0xbc6d54c7	0x0fe0adb4	0xc4ec0fe4	0xae6d09b6
+	0x316cfa53	0xba68cc8b	0x104bdbe9	0xc31639a3
+	0x812a97fb	0xa1c6884b	0xc884d473	0xe3057c15
+	0x5ee879a3	0x5abe8262	0xb906bbde	0xfd98fcbd
+	0x6ae15c96	0x44a17e0e	0x28acfa15	0xb345122c
+	0x6ddc4244	0x005eb369	0x22d038bc	0x0d226e4f
+	0x64c7ed6c	0x7964b8d9	0xbc5d668d	0x99155e56
+	0x9979151c	0x65312a00	0x0271d338	0x64867293
+	0xed0d26fb	0xe69c5f02	0x93fd6871	0xf5702656
+	0x4fad1c2b	0x20f8c272	0x438b964a	0x87ff3fa2
+	0x6706537a	0x437b5709	0x6fb797dd	0x85679fab
+	0x00da6b51	0xeecc5540	0x2998791c	0xc36d40ef
+	0xb545e334	0x9ace5e06	0x8a9e6c54	0xc341d0cd
+	0x1478a2d4	0xb81413bd	0x80601f72	0xa1b250b9
+	0x1cb7f5ce	0xefad630c	0x32325fcc	0x29e3474d
+	0x6a7ae043	0x879ee630	0xdc1e8a55	0x7ae794a8
+	0x4ee38039	0x2ff4947a	0x53bb84b1	0x8f0b077d
+	0xaa4c543b	0x9aa88443	0xeb31a017	0xf3485983
+	0xe53b855c	0x6e17aec6	0x726458a6	0x5acf4345
+	0xa1b95c5a	0x30668c67	0x47fb5dc7	0x8aafbff4
+	0x4b94ef01	0x07bd6231	0x544afcf3	0xfdffca2f
+	0xce847471	0xe90abc6e	0xf05e3cc1	0xf602a9c8
+	0x8f104b51	0x1ae3da07	0xd07dfc04	0x561d9373
+	0x6f6cc833	0xac982489	0x3c0f8afd	0xfab974d0
+	0x397e135e	0x8edb3eb4	0x452b9509	0x3972829d
+	0x639e3981	0x1c758ec1	0x11428fa5	0xe8308fa7
+	0x571d71b9	0x94e40c2b	0x1aaaa397	0xce9283ae
+	0x599bbb93	0x51c04bf7	0x556bc74f	0xf6e6e799
+	0xc34191e0	0x5f06bce6	0x9f63ecd1	0x54437905
+	0xf8f9bd50	0xde82cbf6	0xe11a9949	0x9d312bfa
+	0xe712e3db	0xb57eabc9	0x57682068	0xc91c2e3c
+	0x681e4fbd	0x0ecd3452	0xcc893248	0xf13f0600
+	0x9a8a9194	0xb4c1cd29	0xd504d8f2	0xee6c5b8a
+	0x211c9958	0x7a4f9c30	0x32775708	0xda97bf03
+	0xf7035e57	0xbe77d547	0x37accd1e	0x6c537775
+	0x8d63b752	0x7fec4a3c	0x94211d9e	0x60bfeb2a
+	0xebd47130	0x747d52fc	0x8434f487	0xac9091cc
+	0x8f8b228f	0xb77f96a1	0xc21fede9	0xa9e2678a
+	0xbc815194	0x54d677ac	0x66c11faf	0xfb666595
+	0x01e5e973	0x5c990d0c	0xf2cea425	0x5b516ff8
+	0x8c932784	0xd18feb32	0xb5acd3d3	0x1703b89a
+	0x34fb512c	0x0ac83386	0xd58c5728	0x5c018ed6
+	0xbe0908a0	0xd490b0e9	0x0ec94527	0x2f281499
+	0x471df723	0x03eddc08	0x9b99d975	0x11535b70
+	0x5802288c	0xb3512d42	0x415a9c0d	0x52dbd146
+	0x8b0c59bf	0xd8160cc7	0xe37dee6e	0xfd5211cc
+	0x5635ff4d	0x8d783398	0xc11f5d62	0x54ca73b4
+	0xc3ebdf96	0x835e7883	0x9cd03137	0xe4b4f709
+	0xdbde6d86	0x2b562b2d	0xfecc0df5	0x172a5ec2
+	0x568b52b9	0xf542957c	0xd738b325	0x49c49aaf
+	0x6eb4c9ad	0x363f4978	0xac4b0cb3	0x4ec8dca8
+	0x7a2ec2ba	0x10ff39bc	0x8b8748d5	0x6a86e67b
+	0x0d81e2b6	0xf4bde138	0x02249333	0xab0c7acf
+	0x4ce5e894	0x1656dad7	0x46c59329	0xa849fea0
+	0x3d0400be	0x6898c4f7	0xd866ff9a	0x84a5b170
+	0xc997009e	0x80524f6e	0xc80fb5dd	0x5bde0181
+	0x0bb0c8a8	0xe5a6b9e4	0xd4753f0a	0xda9bf0c6
+	0xd6dd041b	0x4c7338f0	0xa223bd71	0x23b58f4a
+	0xf6e127dc	0x1777033d	0x5b057a0f	0xe08af0bf
+	0x17c07032	0xbbc3f27f	0xac6dc98b	0x921e2f12
+	0xcf32236d	0x6cb700a8	0xa3b4e5cc	0xe9b65d73
+	0xca7d6f44	0x7b5917f6	0x7b80dd21	0x5ee87e45
+	0x86799f71	0x0667e036	0x8f97dcca	0xc4bfd5d9
+	0x90737eed	0x41b5a457	0xc6c96301	0xf8933e95
+	0xe51c2456	0x00c661f4	0x8a0e1aaa	0x92aa4181
+	0x1e3f8638	0xd481a14a	0xaf637189	0x91622fb3
+	0x4450865d	0x4202b431	0x5248342b	0x01ff713b
+	0xe33b5ec5	0x912d6856	0x10deb2ac	0x9072c180
+	0x24d792af	0xa39c5dfd	0xb4c94140	0xfeb32004
+	0xa174dae8	0x49da7dfc	0xa4db1090	0x7d2a998b
+	0xb7eba69b	0x9b824871	0x3557bd1d	0xd3a73d9b
+	0xf225310b	0xad1ffcf6	0x2d5f075b	0x592de6f4
+	0x69e438f4	0x4ed8cac4	0xa79c947f	0xb95f9590
+	0xb8ede5c9	0x0b1c9229	0x85a4b30e	0x65149920
+	0x433461a8	0x186fda4f	0xbaee7097	0xd3cac1bd
+	0x8bc32ca2	0x914f1512	0x9b619478	0x582a53c9
+	0x4e624a00	0x77e445ec	0x6f823159	0xa9c4766b
+	0x0dd6ad28	0xfabdadc5	0x704bfd95	0x08645056
+	0xe1939821	0x76650b62	0x8876941a	0xf812239f
+	0x2869ce13	0xa4d292c7	0xecba40fd	0x83d2fd8f
+	0xdd45ccc0	0x7c12b7cb	0xdc0a20bb	0x0d9be34d
+	0x4dd16a9d	0x25835446	0xb94d8c21	0x97ca8010
+	0xddd09324	0x95ffe31f	0xa86136c9	0x828ac571
+	0x9aa7fc00	0x382cc48c	0x015f7186	0xc3fd040d
+	0x505408e0	0x21cdc34c	0xbd266059	0x6e2f673e
+	0xe4523c1b	0x3ba56bb3	0x1c343938	0xabc0df54
+	0x8ba4f1e8	0xfbd4c592	0xb678c884	0xff3be2f1
+	0xca013570	0xfb0598df	0x3cb9cc1d	0xe3ba8ca3
+	0xc3d7ecee	0x0ae84a0b	0x0d70f0c3	0x963110ff
+	>;
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/microcode/m12206a7_00000029.dtsi u-boot/arch/x86/dts/microcode/m12206a7_00000029.dtsi
--- u-boot-2015.01-rc3/arch/x86/dts/microcode/m12206a7_00000029.dtsi	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/dts/microcode/m12206a7_00000029.dtsi	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,686 @@
+/*
+ * Copyright (c) <1995-2014>, Intel Corporation.
+ * All rights reserved.
+ * Redistribution. Redistribution and use in binary form, without modification, are
+ * permitted provided that the following conditions are met:
+ *	.Redistributions must reproduce the above copyright notice and the following
+ * disclaimer in the documentation and/or other materials provided with the
+ * distribution.
+ *	.Neither the name of Intel Corporation nor the names of its suppliers may be used
+ * to endorse or promote products derived from this software without specific prior
+ * written permission.
+ *	.No reverse engineering, decompilation, or disassembly of this software is
+ * permitted.
+ *	."Binary form" includes any format commonly used for electronic conveyance
+ * which is a reversible, bit-exact translation of binary representation to ASCII or
+ * ISO text, for example, "uuencode."
+ * DISCLAIMER. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
+ * HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ---
+ * This is a device tree fragment. Use #include to add these properties to a
+ * node.
+ */
+
+compatible = "intel,microcode";
+intel,header-version = <1>;
+intel,update-revision = <0x29>;
+intel,date-code = <0x6122013>;
+intel,processor-signature = <0x206a7>;
+intel,checksum = <0xc9c91df0>;
+intel,loader-revision = <1>;
+intel,processor-flags = <0x12>;
+
+/* The first 48-bytes are the public header which repeats the above data */
+data = <
+	0x01000000	0x29000000	0x13201206	0xa7060200
+	0xf01dc9c9	0x01000000	0x12000000	0xd0270000
+	0x00280000	0x00000000	0x00000000	0x00000000
+	0x00000000	0xa1000000	0x01000200	0x29000000
+	0x00000000	0x00000000	0x11061320	0xd1090000
+	0x01000000	0xa7060200	0x00000000	0x00000000
+	0x00000000	0x00000000	0x00000000	0x00000000
+	0x00000000	0xd1090000	0x00000000	0x00000000
+	0x00000000	0x00000000	0x00000000	0x00000000
+	0xfd2a2f68	0x82ac7ebb	0xa4916328	0x7480b81b
+	0xd329a777	0x25750339	0x9a8f7a9b	0xf1da9cb8
+	0xb1be7b1a	0x621d5a35	0x94b57e2e	0xa9def809
+	0xe4492a43	0x530252bf	0x1040fada	0x8a853a89
+	0xfb0e6e76	0x6d191ed9	0xefd28b83	0x946414e5
+	0x13f415d5	0x28487029	0xb69855e8	0x516cbedc
+	0xfabbea88	0x9f90e8a1	0x211793d8	0x54653835
+	0xa7789a08	0x754791d9	0x484764d4	0xdca45615
+	0xf64844f4	0xdbd754d0	0x7d2b0ff3	0xd023e25a
+	0xb048bbcb	0x83038b5c	0x57e17d17	0x735f1e9c
+	0x8982c22e	0x6c7b2ad7	0xb26e3b82	0x7121e035
+	0xe4ea8dba	0x68d4f406	0xaaafdb13	0xf119b472
+	0xb5853303	0x20698005	0xcf34604c	0xdc17d19b
+	0x042d6e97	0xf0300325	0xe1b55072	0xc2804918
+	0xd6d7a912	0xf908c81b	0x4f9979ae	0x0179f8c6
+	0x2f13e3c0	0xc5911467	0x39ad6c23	0x9c9d8837
+	0xf3c3f767	0xe56b4a96	0xdad7cebc	0x6eaaee57
+	0x2215ca7b	0x4cee4f65	0xd9a51c2a	0xf33c80a1
+	0x11000000	0x0b468bda	0x0b57c7cb	0x885fad4b
+	0x8a37307a	0x68cc7d5b	0xb6395b55	0x583626b8
+	0x21efe98d	0xa516cc42	0xf5b978b1	0x585d8a11
+	0xdd5f2ee4	0x17b1c7eb	0xb6f005ea	0x9ecc6ac6
+	0x82c0f1b2	0x25a114fb	0xa6086296	0x93da75f4
+	0x0695ff88	0xd413dd65	0xccf7609e	0xb7718aa8
+	0x334406dd	0x28de253f	0xfb43ca83	0xa4674656
+	0x7392e05f	0x9b062c62	0x17571892	0xb5811cbf
+	0x9d64666b	0xa01c1500	0x5893e418	0x07ba6ed1
+	0x0eebedd8	0x299a52bf	0xdfdb6191	0x4e846b26
+	0x298b7431	0x576f4479	0xf5317e04	0xc9492745
+	0x167c42e3	0x0c0cd705	0x82756ce5	0xe81ba860
+	0x536c357c	0xc27433fa	0x41c8078f	0x1ff779d0
+	0x73ddd76d	0xe606c66c	0xe0ad45bf	0xfebdc310
+	0xcb2aa836	0x39903a79	0xe53d5dc1	0x0cb6a1ff
+	0xe6091d08	0xcb2961d8	0xd38987ff	0x2bd624fd
+	0xfb4e484a	0x8c60efbb	0x0ed088b5	0x5a142b04
+	0xa737bab1	0x44da29a2	0xc046ecb1	0xe7ccefdc
+	0x81895d2d	0x41266fa8	0x52a5e25e	0xcfeac133
+	0x252b0737	0xec54b6c8	0xe1c9ebf6	0x25180c1a
+	0xea65b9e2	0x5e9ada96	0x08559e07	0x414fcece
+	0xdb4927f7	0xa229106d	0x6a7db273	0x8ac6a901
+	0x00a87e4d	0x14fd1e2a	0x63a5fa87	0x5ca223c5
+	0xc0c980c1	0x42c447ef	0x5b274187	0x75bd6279
+	0xdb44dae2	0x60856af1	0x777caf5f	0x298e810a
+	0x93f4f418	0x9e1ddf3f	0x6f589046	0x18ea149c
+	0x4a5ce4b0	0x529db285	0x3c2dde59	0x1d680e51
+	0x3a62d819	0xdf4c01d2	0x432a8f06	0x70a37043
+	0x4a0d4baf	0x0d3395be	0xfce0391f	0x5228aac2
+	0x9dd9b00e	0x6149f393	0x6fee1d85	0x1d3628cb
+	0x107076de	0xd99fe940	0xa227eec2	0xc97d8119
+	0xcf2fa8b2	0x821dac93	0x518875f2	0xd18d1d47
+	0x3e27fdcb	0x47823f98	0x20d42c1e	0x9a58812b
+	0xe0987435	0x1426f12f	0x61d6f627	0x5c58d415
+	0xe5ca80de	0x9e11e526	0xbccc0f94	0xb49cec4d
+	0x357f947c	0xbef0e2f2	0x5b9b2596	0xddc87ff7
+	0x5f2705f8	0xa25f2be7	0xbb45a165	0xe49ef6d5
+	0xe76e250a	0x75584c7d	0x7900da7b	0xee0e3360
+	0x6988740c	0x4aa56944	0x2d485383	0xef45f5d5
+	0x0df4b0f7	0x48199182	0x5b33c21c	0x8f2483c1
+	0x8aae6c50	0xaf406ccb	0xb7522bda	0xeafb64de
+	0x9a9b1fd7	0x3ab46c34	0x0ec5f025	0xe5bc9668
+	0xdb108e78	0xd6152ac8	0xc382ec93	0x5abc2565
+	0x4f256030	0x856f6eb5	0xb589dc96	0x3de80942
+	0x49d20a05	0x8e3ac21b	0x0262ecc7	0x5f1bce89
+	0xec50198c	0x0115b078	0xf67d94e3	0x1cc3682b
+	0xfb2d4ab0	0x4d6ce252	0x1d7aace9	0xf7e99257
+	0xc1235e85	0x8129ee72	0xb6cfbb13	0x6b851ab5
+	0x430633d1	0xe9ed33e9	0xfe85a42a	0xb4583c0a
+	0x35a65f5e	0x5fb0bc81	0xe16db440	0x7d022cf2
+	0x8f832920	0x20ed9ad4	0x6a4ace8b	0xf4c85869
+	0xf17dd57b	0x277ae0d5	0xb5f59c50	0x35d099a5
+	0x9ce955ae	0xcb200000	0xcedc4073	0x2a2ba8b2
+	0xa1b53439	0x46ced775	0x59069604	0x6488f5d8
+	0x2bc0af55	0x643178a2	0x36f62be3	0x2606f0a1
+	0x3057cf8a	0xc28f4a3d	0x708e8020	0xb3fccf9a
+	0x29b79fa7	0x35622d93	0x85eb0e68	0x80fa3b59
+	0x143f340f	0x20e17166	0x169fe55d	0x698f3655
+	0x0bc8b45b	0xde3aaf6c	0xbd597266	0x75505401
+	0x44d0095d	0x4c00f346	0xfb9ef2c6	0xee70ef96
+	0xae807621	0xfbbe7490	0x9c0a283e	0x01a8058d
+	0x1be53568	0x0b8dc8a8	0x45afb745	0x3ee1ff58
+	0xe772e14e	0x3ca4e729	0x6973e751	0x764f244e
+	0xca8d1621	0x6c4fb15c	0xae972e6d	0x3d26c6d3
+	0x5ca8f450	0x6328d65c	0x2e7cd88c	0x87dddcc1
+	0xcbbdefc6	0x1ab8c0cc	0xd21e503a	0x20c11d27
+	0x2f0adc1d	0xc24240d2	0xc73aa069	0x99afc53e
+	0xcab27e40	0xbe107ccb	0x8ad5f0ae	0x9024c188
+	0xe02bb39d	0xdb784309	0xf91acb54	0x4d15b75d
+	0xd339c237	0x3b556619	0xf69f91f6	0xca6fcfd4
+	0xb5ddf471	0x0698490e	0xb0855c30	0xe2b34b13
+	0x3c979248	0xc0484a59	0xb4cf9f4f	0x7975f2ac
+	0x602259d3	0x89364c24	0x37f29913	0x0b4c88a0
+	0x23f0b663	0x309c13d2	0x80a3d12c	0x4c866e87
+	0xea7e29c0	0xbc33db6e	0x3c3af584	0x63da0de7
+	0x9bc6bf5f	0x3b948269	0x4d41b09b	0x5724dd20
+	0x4e16618b	0x5917781f	0x4bdec762	0x562cc3fd
+	0x50e59d92	0xb3edea05	0xa6ceaa68	0x60af473d
+	0x78a99aca	0xd60ba313	0xe502992c	0x0c25c2ba
+	0x476eebd4	0xe7e23958	0xc4ac2757	0x0d6695ec
+	0x7664b4f0	0xb87ed0a5	0xdcf23b2a	0x76d38802
+	0x21699284	0x87b80e7c	0xf0e34f45	0x4bb84bc8
+	0x0316744a	0x26de0ed4	0xb25ff5e3	0x31445bb1
+	0xaccc5b87	0x271b976a	0xcdf5663b	0xe142d271
+	0x1af28339	0x7d304ca4	0x11ee6243	0xdf70fbc3
+	0xb8d88f25	0x4c2d9626	0x8eb72c77	0xceee1817
+	0x4e1b35f7	0x6c261f67	0xa32a2801	0x67ace2af
+	0x7c87f8c1	0xca6f2505	0x982269dc	0x137080a9
+	0xe40fa78a	0x3897a66a	0xdc5d0ff7	0x58016e44
+	0x21bcc988	0xf2a4df15	0x9fb021d4	0xca59e882
+	0x3673d08e	0x7cf5d500	0xd41ab9df	0xc17b4a58
+	0x2cb85aa3	0x01103427	0x5a8fac5b	0x7ac856b2
+	0xb1532563	0x1b94b518	0xadea3bfa	0x597109a9
+	0xf28df608	0xc2bf64bf	0xf517bb53	0x61b7d5ad
+	0xa4a38e9d	0xa9fdc597	0xf990f2f1	0x00466640
+	0xcecd06a7	0x5eef09d3	0xb67a08ae	0xd780d8a0
+	0x07641a71	0x9dc9f7b9	0x5f0b5a44	0x94dfe40f
+	0x6db0cf7c	0x3fe72d11	0xb2443ea3	0xe051f336
+	0x4ec8a6a4	0x11201430	0xb44e2b28	0x5bd018b0
+	0x444ba2bf	0xa63031eb	0x147f9826	0x3fc56ac1
+	0xd3a75ad3	0xc3f71815	0x340bd72b	0x3e5a488d
+	0x0cd8fb05	0x17791534	0x68e7321c	0x1489c701
+	0xa39f2d71	0x7cbbd9f9	0x42cba365	0x024f7d9a
+	0x29ef2da1	0x1eb9c4e6	0xc8b24985	0x9c33412c
+	0x5fd3003d	0x7f0793b9	0x497b6ef4	0x3af648f2
+	0x22f4a1db	0xac8500c7	0x3b1a859a	0x57921c78
+	0xb0efd82e	0x8e60452d	0xd86ed85f	0xc1ae73d1
+	0x633d83dd	0x7dbee7f6	0x46ef5590	0x027f2d50
+	0x3c81bcf1	0x37a3940d	0xc92d0a8f	0x270cd02d
+	0xaeed9d1c	0xb6d76bcd	0xda27f251	0x1625a683
+	0xf2d1302d	0x3f95bc0e	0xdb4b36e0	0x96fe1e6e
+	0x1dcbca54	0x57d44867	0x14aada62	0xf20f5444
+	0x9ccf560e	0xb8d178af	0x9affe58e	0x8e3bd741
+	0x7dff29e9	0x3c1998e5	0x9909e1df	0x1bbbd50f
+	0xfda14fdb	0xb66fb65e	0xe646d5f3	0x71f41791
+	0xbca50c12	0x57c6d2a2	0x8f5c750f	0x48f87301
+	0x9103acac	0xef185c41	0x6dbe9524	0x3c040c16
+	0x211dc2ac	0xa61925bb	0x20bfb41a	0x98253e77
+	0x4d5ea3b8	0xc2b11b6d	0x7f072104	0x58340448
+	0x596e3090	0x72484d15	0xf5e5d16b	0xc1b9faca
+	0x5c786fdb	0xdcd97509	0x73d21aa9	0x2a90c7ae
+	0x396ed0b1	0xa23e63da	0xea20cb1b	0xb2bb359b
+	0xb5df6ff5	0xdbc470b4	0xa6fd8d97	0x9458f6d0
+	0x97434866	0x2c9521c4	0xc51f6ad2	0xa33fb3b5
+	0xb26915d7	0x3ef363da	0x9ff9f5c7	0xfa236e60
+	0xa12b879d	0x2f98bd3b	0x95282ca8	0x64f90513
+	0xc03d2962	0xb13b82f8	0xfdc2eb41	0xc39dcf3b
+	0x95a409af	0xbaba6e7e	0x0d028543	0xc5b9426b
+	0x35f5727b	0x8f3b9f8c	0x6e7b85d8	0x2cfa9b2e
+	0x2a7117cb	0xa41f3fe5	0xbe17ff18	0x0f4a8be4
+	0x20b9003a	0xebce04ff	0xd6f276d6	0x9fc66d07
+	0x83f40250	0x560eaffe	0x92be2ddd	0xdb0ff83e
+	0x424f0605	0xb3cf76a4	0x167725c5	0xe3b513e2
+	0xc31a1a72	0x9f7161a4	0x25707dd1	0xdb5f2a91
+	0x85db06af	0x78443bf6	0xebbd8e7d	0x7909e5fe
+	0x618237a6	0xe6dea70c	0xcd3299c2	0x7736d40a
+	0x044cda94	0x6cec190e	0xb9652583	0x51946c01
+	0xcba67203	0x0dae0f1d	0x6d0dff0d	0x85756bf7
+	0x1db9e08a	0x88977944	0xa6252c60	0x06ff1a07
+	0x1b8d319f	0x884f10eb	0xbdeb7feb	0xe1681bb9
+	0xb5f0cefc	0x5359534d	0x6de87cf9	0x94a78727
+	0x15c17557	0x398876df	0x2f85f258	0xa0284d4b
+	0x4879ca57	0xb5ab7844	0xb402fde8	0xd520cb53
+	0x8a601365	0x8853b510	0x1e0538f6	0x0135f899
+	0xa78c7bba	0xa33c8ccc	0x6cf0da00	0xa5f96757
+	0x94714373	0x79413ed2	0x27c7b9cd	0xda172153
+	0xeeeee91b	0x959d8437	0x660efcda	0x2a6ab94a
+	0x8913d65f	0x24246350	0xf6c85ab5	0xf6b696f7
+	0xd75840c8	0x046b7435	0xb55474fc	0xd8d8bab0
+	0x265e79e0	0x0dd030b3	0x826a182c	0x38f1121b
+	0xeb33b5cb	0xe3ca835b	0xe8850761	0x25955d7a
+	0xbb6b7fb4	0xbc02ca0f	0x1b03bd1f	0xdd1a59d6
+	0x5d48f10b	0x35e35688	0x1411d34a	0x6131c664
+	0xc1b8b277	0x1bc8afd3	0x886f0c09	0xc1b6b517
+	0x74ec9ecb	0xee2d43a5	0xbc0f122a	0xd1911c88
+	0xc7e39b2e	0xa60c39b0	0x942fce7e	0xc8c2a2b6
+	0x51978cc2	0xad8d9ed2	0xcc2b0c3d	0xf6aff0f7
+	0xbfb3920a	0xd25aa79c	0x67d87d44	0xf612df60
+	0xf06dbe9f	0xd4ab61da	0xd96c6b1b	0xb39ab4b7
+	0x3368a90d	0x39c8bd81	0xf4ba5ead	0x6fe656ad
+	0x93b946dc	0x2181219e	0x7b98805d	0x675af3fd
+	0x59760289	0x934b4803	0x4189f27d	0x9503a5fd
+	0x42aaa076	0x6b4bd024	0x86c826e9	0xe0370ff4
+	0x1bfdf980	0xc487f797	0xd4754c3b	0x1098b2e8
+	0x05753a1c	0x3833ede3	0x5f1065ec	0x40cb562e
+	0x8d4fc418	0x392290d2	0x622d2e29	0x55df1f46
+	0x4ae0893e	0x24ddf8a9	0x302a64dc	0xc93f7504
+	0xde8e1674	0x033acbcd	0xc9732a64	0x6f7a7da3
+	0x72b7c43a	0xb5110e6a	0x00865c19	0xaf5e00f7
+	0x0a80b55d	0x6e638c0c	0x3771d602	0xb4a95ae7
+	0x01ba3cff	0x42e350eb	0xedb1d897	0x82f0cfff
+	0x98e79055	0x6b0cc62e	0x8ce1735b	0x62645395
+	0xd99fc208	0x86ee3066	0xc8f13758	0x2378d582
+	0xad41c218	0xc3954b87	0x47acab9a	0x69126227
+	0xbf778357	0xc5a7b76c	0xb96894c4	0x89e2dd88
+	0x27cc53b7	0x2187116c	0xd397c13b	0x578a6686
+	0xe3e58b11	0xdc3e4d40	0x69f064f5	0xdfb64348
+	0x42291e77	0xacc21c46	0x5444d976	0x616bcdc1
+	0x01ffb3bd	0x5cb926e5	0xbd763a24	0xbf224c70
+	0xdeca1d57	0xded1cc56	0x9b6cbcd2	0xee6efaf4
+	0x44d634ff	0xf33334c6	0xd275d66b	0x6a1a4c9d
+	0xbd675ae0	0x6289d1c1	0x053aeaf0	0x8a170aa1
+	0xe12cfbb9	0x0ae15a94	0x1dab08f3	0x9a2657ab
+	0x8348417f	0x9572e6dc	0x9c69e518	0x5397dfa1
+	0xe46120cd	0xad4457fa	0x0106a79d	0x40b191be
+	0xbb64bccb	0x9dda8fb0	0xc74fe994	0x64ac0ef1
+	0x3a57986c	0x86e8dc78	0xbb055d88	0x7a1243da
+	0x585cafe1	0x8968ad92	0x5b73bf26	0xccf77edc
+	0x10ac1643	0x5738ba43	0x3d39ecee	0x57fd555b
+	0x36ee9d5b	0xec9115fb	0x4250e03f	0x9e4fd6a6
+	0xc547b01e	0x9c84f42a	0x37756616	0x217cb517
+	0x33da3c5e	0xa0a7ae6f	0x8ddb7b99	0xbd84ac35
+	0x644ec4e0	0xaa62a7ac	0x71795f77	0xd5f67163
+	0x77dcc227	0x59f09342	0xf6666ce4	0x1e164a0c
+	0x011e205b	0xc4a80a0c	0x7fd31f1d	0x05ccae4c
+	0x39b6abfb	0xf4b7ac82	0x39d38e89	0x14c1e7f3
+	0xdb3bb53b	0x02577ec5	0x7bc12087	0x65ccc2bd
+	0x72492c6e	0xa6ae0062	0x965946ea	0x58e5f31a
+	0xfdfd7770	0x052afb9c	0x889b8358	0x2dd65c3e
+	0x55418587	0x445af0e9	0x43fe6671	0xae45e776
+	0x2c25d02c	0x44805865	0xaa3a70c5	0x7dd55d11
+	0x3499f5d7	0xc12e4a51	0x9ef98a38	0x5462e98c
+	0x0f73c72f	0xd0481aa2	0x56bccd0e	0x64143a1a
+	0xa7913ef6	0x0ca932ae	0x3739ec96	0xac5d38d5
+	0xe9c8c754	0xd56e855b	0x950cadcc	0x91cb2e5e
+	0x6e170c11	0x1eb66637	0xf641b0ae	0x8ba43c21
+	0x3f43b8af	0x8f1596e7	0xb614d1ae	0xac99c14c
+	0xe7beddce	0x5757f98b	0xfec1cf89	0x19608162
+	0x96479a49	0x1f089d9e	0xc2e4ac47	0x1cdea563
+	0x027f57a7	0xc0ba57c6	0x6eb2faa1	0x8e85c333
+	0xc391dfd2	0xe2c0bcbf	0xc1f87d66	0xb597d958
+	0x3655d5a3	0x2d9adaaf	0x8efd0aa0	0x05d65caf
+	0xa28991d9	0x28b6d7cf	0xdcb48013	0x65e75783
+	0x8b8b77ed	0xa4b36df8	0xa8ccfb9d	0xd0a1734c
+	0x2dc97601	0x35d81082	0x2e6d26f8	0xf3baf2c5
+	0x416084dc	0xd8b84ad5	0xa06b9edb	0x45c2b0b6
+	0x553c973a	0xbbcda1bf	0xca154d25	0x7a781012
+	0x4864ea32	0x0784f663	0x27656507	0xb359d4dd
+	0x43d4c165	0x69b844c7	0x31b1b9e2	0x0f3420f8
+	0x3cd2e455	0x201920cb	0x93018659	0x5c4a08f0
+	0x3a0d094b	0x5448c1ed	0xc888d1a2	0x4826cb64
+	0x625da2c7	0x12110d40	0x5cd8e76b	0x26e09eb5
+	0x8c6aab45	0x6dd192c6	0x937f1252	0xc927efc5
+	0x4c5bf11c	0xdd62c6fa	0xeef59620	0xbffc2d5b
+	0xb90299f0	0xb24df71b	0x76656678	0x550b3228
+	0x01536098	0x4fbfe03c	0xa82d0c31	0x2eec9bb6
+	0x752e6720	0x26322556	0x5d94bd64	0xa2e1122a
+	0x25899986	0xb63d5cc2	0x9222b055	0xbf4f0bcf
+	0x3d182483	0xc7bb9999	0x97ffc8c1	0xa6500a8b
+	0xb8b97382	0x3f6f39b0	0xcaca9f6c	0x7b67941d
+	0x7875ea1e	0x3ff25c0d	0x4cff1a40	0xb5a351ef
+	0x556a59e5	0x011e995f	0x25a7a5e9	0xedc8707a
+	0x42b4ddfa	0xa51a3ddd	0x9c9f1d73	0xc8f24ef3
+	0xfcd73118	0x1a61c16f	0x1e2fa7c7	0x1f49826a
+	0xd8418fe9	0x726358a8	0x6a0857fa	0x6804ccc1
+	0x78a55fa0	0xc3e41419	0x60416b10	0x2afe46d8
+	0x0c0ba2f7	0xd3dfa8ca	0xfa474ea2	0x8e763446
+	0x1f664c64	0x6a8d06cf	0x1b891114	0xa27c1a28
+	0x98ddd324	0x26cc9fb8	0x544078da	0x03acbeee
+	0xc3f3b761	0x56797b83	0xf04ac5a1	0x8603b17f
+	0xb8989b96	0x28c7be17	0xb750b4a6	0x84b2f7f8
+	0x32138f9b	0x7661c86b	0xb7517518	0xf2a961c6
+	0x240a0100	0x100c5b96	0xa1931730	0x18513938
+	0xdf2baa73	0xd6b55cce	0xf89cab59	0x238c90c3
+	0x4799f50d	0x29cd7942	0x62677a47	0x7261f326
+	0x4ff7da96	0x294ba5e9	0xb6474251	0x96de1b44
+	0x9d84552f	0x1103468f	0xcfd063af	0x5d8a0b6c
+	0x172670ac	0xc1a9b97f	0x0a278773	0x08b48bb5
+	0x392b3563	0x8f65e926	0x4be71f10	0x7615e05e
+	0x98b0c931	0x50bf9779	0x5baa97aa	0xb6e26fe4
+	0x2c40971a	0xe5d739f0	0xa7e30500	0xc724895c
+	0xc7a3f44a	0x5b381b1b	0xa7a478c7	0x219f567c
+	0x42d7a960	0xaae6780f	0xa96c56d1	0xe3787bf4
+	0x743f3a5e	0x6b99c9e1	0x36cf72b0	0x784ab5c2
+	0x5113773d	0x625393af	0x62c4da61	0x05422921
+	0x339711f3	0x3ee04f5e	0xf3a778b9	0x55e1bcf7
+	0xe49e5a9f	0x5f0935f6	0xa13e17f5	0x3028d23b
+	0xac9a6fd9	0x14006013	0xbf1b3fb2	0xce785f7b
+	0x83942244	0xd299d59b	0xf8c0593b	0x71c74beb
+	0x7561a1f5	0xb133ace7	0x15d5d4c1	0x21c3bb29
+	0x6ab1c2c7	0xee20d3dd	0xcfd62c54	0xedf9a43e
+	0x0e23222c	0x5eef5bc2	0xe7426bd0	0x42db58e9
+	0x62ffe203	0xd63163c5	0x8dbbcb48	0x9e16d9c7
+	0xb6d51e39	0xbee5a6c4	0x5d0bd775	0xeded86db
+	0x9eb1454f	0x6217eb64	0xa4b76ae7	0xe3481698
+	0x6d576cec	0xe751f610	0x1473bd83	0x4aaead8c
+	0xff4a602b	0x01ed092b	0x310f16cb	0x2e199177
+	0x693a8ad1	0xf5e520d1	0x1713d604	0xfff1225c
+	0x644c81b8	0x1adf5032	0x79058d81	0x7aafda08
+	0x80b6c9df	0x6f927c46	0x307bcaa6	0x0a1aac12
+	0x7d20bdae	0xd0e9c9a7	0x4530bebc	0xf1dbac36
+	0xdee3e8a9	0xa96d2aca	0x291c6944	0x436cfac8
+	0x9dd501c3	0x696e0c6b	0xa85d7036	0xca1c1321
+	0xcb802235	0xae614fec	0x4f0cf745	0x08604468
+	0x93bd00f3	0xf39eb605	0x89a8f420	0x18a7f61a
+	0xa0aebc3b	0x723e6ba9	0xed00f2a0	0x231b43d5
+	0x37c81702	0x891ffeb9	0x122de4f5	0x90f16757
+	0x1eb06046	0x21d5cdd1	0x75fd0e6f	0x7d595ae9
+	0xeb8ed50e	0x7bfd8696	0x3b91f3e4	0xd629e74a
+	0x1650dfcd	0xda48163d	0x2f8f5aba	0xbc40ee60
+	0x5291b6b0	0xb059d788	0x1ed5f092	0x65b7a885
+	0x44503d18	0x3a2893c8	0xaf3dab25	0x8ee0a8e5
+	0xf82f0696	0xf4fe9322	0x863feff8	0x2cfee629
+	0xacd8bcbc	0xb3791232	0xdd694c06	0x2a606479
+	0xaed9bc38	0x49a126fd	0x2a9c7581	0xaf43095c
+	0xb97acc90	0xca7a25b6	0x06adceb3	0xc8bf7269
+	0x6eeb0c59	0xa953657b	0x8e175c3a	0x9facc87c
+	0x4c143d0b	0xb4467fe4	0x372b6cbf	0x2099b361
+	0xb8ac2cfe	0xb9a798d0	0x15b8b336	0xdab5d568
+	0xb53a4dda	0x00ce1ef7	0xefef7644	0x41823aa2
+	0xcb8d307d	0x3baf1baa	0x7124a219	0x8d2820df
+	0xf3b8cfed	0x95e55a1b	0x8199fa40	0x631042fc
+	0xf7886353	0x3592b875	0x3b516841	0xac7aa00a
+	0x3dbfec52	0x9b91e8d6	0x0a8ffce6	0xd11429db
+	0x92392bec	0xe194095b	0x253d7425	0x6b55919c
+	0x4c11de8c	0x10b46ae6	0x5902c153	0x9509ace0
+	0xbb65fc04	0x648a35e0	0xab728bec	0x738effb4
+	0x416f95fd	0xee30a0da	0xcbaf3cb4	0x312fdeda
+	0xcdb5aaf3	0xcc631b82	0xe3bf4d97	0x37e2a1b5
+	0x2920c6b2	0x0d995ad3	0x11af607c	0xcacf31d6
+	0x781496f2	0x9e478c0e	0xc4c14545	0x89ba2ab0
+	0xdb1a8262	0xbb924c65	0xad836a24	0x4374fbd6
+	0xd45a10df	0xd4158c0f	0xd4e88c1a	0xee8b8e23
+	0x3472ee5c	0xc0a0de0c	0xb1ba04dd	0x7be6532b
+	0x0101669b	0x2a56f032	0x12879eef	0xa600458f
+	0x20a96992	0xa2e7910d	0x13235ef1	0xb1185320
+	0x418ffba7	0xc0ba01af	0x27571c7a	0xde5b661f
+	0xdd359089	0x6ae76b8d	0x095784d0	0x400a29fd
+	0x5b3276cc	0x774c4e38	0x6a85e14f	0x37d8d1bd
+	0x2007cea4	0x3e6942be	0x1a49828d	0xea4d84ff
+	0x681b5a30	0xd8ff8440	0xac19844b	0x7553a6d0
+	0x389fb0a2	0x1b0526fc	0xa193b9e0	0xb9987cb7
+	0x6f14d980	0x0507f958	0xf6a1354f	0xcb9e49d8
+	0x5a4e1d3f	0x10d8c348	0xb77cf166	0x5097503d
+	0xf0e17ed5	0x72a2e029	0xddc756b8	0x0a0e30e8
+	0xf12c6bc7	0x809db2c5	0x243fee9c	0xd2b57957
+	0xc1b19244	0x8d59262c	0xff94c28e	0x2050edc2
+	0xa4806d15	0x02026bf6	0x2d95c9d1	0xeb336e65
+	0x84bcf6ac	0xe53b97b7	0x954eedc9	0xf22209fe
+	0xf4771bc0	0x1e405f04	0x1d0ec592	0xcd479333
+	0xdfeb3738	0x0ae23cb7	0x03d509c5	0x837a5e1a
+	0x634a4467	0x7ee22185	0x102f5326	0x5d002daf
+	0xea4e31ce	0x1d2be82e	0x5ebe1ad6	0x354259bd
+	0xdaed312d	0x1e598ea0	0xd6a2b9af	0x76eb9bbb
+	0x338645d3	0x4d3236f8	0x777011eb	0x0221d076
+	0x22dee347	0x1e35037e	0x2f34d4c5	0xdda03e2e
+	0xa541311d	0x3acf0087	0xb435b17c	0x08b8210e
+	0x7c77f156	0xe20025f2	0xea0e32a9	0xbf766fd1
+	0x8b6c4f43	0xf6ca80f1	0x07d1d342	0x272b865d
+	0x8261aed7	0xf3bbe9cf	0x5835370f	0xfaaf4623
+	0x8cb5a665	0xe6c92e5f	0x22ce69f6	0x61e16f89
+	0xf15ec311	0xbacaf7b4	0x1317e388	0xa1869c49
+	0x328da67f	0xd818a8fb	0x6f4c7613	0xcc13480c
+	0x06789788	0xa7b4e1a8	0x0d8fed7b	0x48308fe3
+	0xbe5ff9e2	0x7e7a74ee	0x4ffbb70c	0x551895c8
+	0x734ffc0e	0x82b8b8d6	0xdf710f9c	0xc3df529d
+	0xf175e377	0xcec6194f	0xc3443fb1	0x52655208
+	0x94be229e	0x3279939e	0x771647a1	0x34c9a15a
+	0xaae80baa	0x0b32ec13	0x6d59b440	0x50ddd10b
+	0x98c166cd	0xfd465f40	0x74eabbc2	0x6dcb95c0
+	0xddef6f85	0x54348377	0x905f31bd	0xbde86f48
+	0x1322356f	0x90f3d5f2	0x5d2d4de3	0x2d5253a5
+	0x729b8879	0x41839289	0x845f8061	0xf5ffcf8b
+	0xf25ec4d7	0x30570dda	0xcc69f64b	0xeb024bde
+	0xc847bf80	0xeb8c5624	0x4e4d28eb	0x43f6cc1e
+	0x8c201bfb	0x1475f9cc	0xde13b005	0x11fd9342
+	0x07617ac9	0x2fec6867	0x5b30a62e	0x5a8c91f7
+	0x47208b6f	0x680a22af	0x60fd0ebd	0x229ebe44
+	0x568c37d6	0xa3eb78b7	0x6f06f502	0x1b183db2
+	0xd48e4d35	0x4fb23b3d	0x57d7dc0b	0x3d34b427
+	0x0415552f	0x1bbe91d1	0x74e7ecf8	0xb1fdc30e
+	0x466a69f5	0xfddf86b3	0xfb61fd48	0xae250961
+	0x6a99bcec	0x2142c5c8	0x1c08d4ea	0xe8f849c2
+	0xa3cb1614	0x43ac8702	0x22b50659	0x92dc3644
+	0x7a40a305	0x4a1e0780	0xfb638be0	0xb0912795
+	0x522a688e	0x1133c55d	0x0544a27b	0x3c56a574
+	0x748502e1	0xaee58228	0x30ae0736	0x41a029ad
+	0xa1e3d0e1	0xa9b66582	0x6ec07231	0xda4dba0d
+	0x41db8fa0	0x731529eb	0x87f679d3	0x593d1579
+	0x10935a3c	0x793d7b44	0xac680a86	0x1d01ec27
+	0x6d669681	0xef056753	0x96aab271	0xae070e5f
+	0x3321dc26	0xa5ea33a2	0xf8f14406	0xdc755c9d
+	0x7f8e3210	0xc2fd90cd	0x34c102d7	0xe1c744a7
+	0xa79f623f	0x07507959	0x34d28c67	0x26cbff85
+	0xfa24075b	0x618dcdfc	0x64d52c6e	0xce650b7d
+	0xcc414394	0xadc52ceb	0x43667ed0	0xa04f518d
+	0xe52196a2	0xbcb7e578	0x2ed0486e	0x4d669b00
+	0xf765e153	0xd2f097df	0x4ef97542	0xfa31d688
+	0x1698d42e	0x3d828d65	0x222355aa	0xf2c37eb2
+	0x3da4052b	0x198577ae	0x819590ff	0x5ab919a5
+	0x673d5552	0xd2fa9d52	0xb711b72c	0xabd9c188
+	0xb73a4ce5	0x2d20447b	0x3d19d4c4	0x4bbe86d0
+	0xd205021c	0xe9875ec2	0x8dcb01f3	0x6e109fec
+	0x60a3a693	0x2fb6b975	0x0ed26de1	0x7487f920
+	0x83092880	0x4d5fcb5d	0x72b047d0	0xa256dcdd
+	0xfef28251	0x41e36ee6	0xd91e2c20	0x7698357b
+	0xb3684b1a	0x272311be	0x32860f75	0x44a6cc61
+	0x63e3f66f	0x5a1497b7	0xeddf5a57	0xcdd4577c
+	0x3cc63cd3	0xf7e72773	0x3fc9bb40	0x97ce4118
+	0x1438da68	0x7a32210b	0x2aa07598	0x04e858ca
+	0x850e0082	0x0b0f78d1	0xb178c391	0x9a2e231e
+	0xa8f3b67b	0x2a08ea99	0x340d101b	0x42973ffa
+	0x755ae5cf	0x201213c4	0x445e44f7	0x15a872c8
+	0x857b94f3	0x24c023ab	0xb203df2a	0xc4711de8
+	0xd1faaeea	0x1eb857b6	0x8c1b712b	0x11ad0f2a
+	0xc64cf474	0xff6c128c	0xff13eac3	0xc4952e8f
+	0xacdac9d1	0xb8c2f092	0x38d50a33	0xaeec4534
+	0xa661a7ee	0x4d19a2bd	0x0f2d95e4	0x9a221827
+	0xc9fe071f	0xe53486d7	0x1dc5426c	0x848eea4c
+	0x607f616b	0x41a301f6	0xeadc389c	0x1f109048
+	0x249f14da	0x2a20d362	0x7c93cd00	0x7ca633e8
+	0xe50fb5a4	0xace8f92f	0x49638c89	0x478b4371
+	0x60d70e8b	0x0bfb8bfb	0x6cac803d	0x702996e4
+	0x15a35d2c	0xd68a2d93	0xe025d5ee	0xd8ca8c86
+	0x295393d3	0xce1be3f8	0x0ee6bd15	0xd6735f38
+	0x311495e6	0x7eb8bc83	0xea53551f	0x4fa9a90d
+	0xe16a9ea0	0x651eb233	0x95f0afec	0xc687ed29
+	0x0cd3abc8	0x132bb8b4	0xd70dadd3	0x538e630a
+	0x98481e4c	0x0d7e6f1b	0x3986b2de	0xbe0924dd
+	0x1d14608e	0x189f553e	0x7a6b7786	0x48bae520
+	0xed56a3cf	0x795b4c6f	0x8670597a	0x40eb02ab
+	0xf9b0b287	0xec9f86c3	0xe9a8c3a1	0xe6860542
+	0x387ad930	0x8676e402	0x633f0709	0xd661d134
+	0x011c1396	0xabf1f3f5	0x3fd76128	0x7be75289
+	0xa6046e69	0xf3713680	0xa2ed30c5	0x893df28d
+	0x197b8543	0x9860bef6	0xf6930c5c	0x6c0c379b
+	0x0b0026e1	0x3ca86896	0xa7ea0bdc	0xca94413f
+	0x6cbe8d16	0xd3e4edf9	0xb06efcef	0x3a8934c6
+	0x00195592	0xa978bf0c	0x7435b0d1	0x3b17d97c
+	0x0438684e	0x576ced8e	0x648683fc	0x362a8a87
+	0x493fd86f	0x6bbe0476	0x16f74de4	0xbfeaaba8
+	0xe6b90728	0xdc252878	0xe0b72eac	0x0872f52c
+	0x2bab1521	0xa6c0d894	0x9f2b3726	0xd392e334
+	0x785f82ce	0x15bba4af	0xb55cd743	0x6e8e9cf8
+	0x047fd2e7	0x1fdfe424	0x8d4820e5	0xce7dd8c3
+	0x88c82282	0x31ef9a76	0x1881fc38	0x3932a9da
+	0x65bbfefb	0xe00f33b6	0xdd0754aa	0x1f596051
+	0x704dfd7b	0x2604be1b	0x08b6c4f5	0x3f244085
+	0xd89c65e3	0xcc4cdb71	0x143a2681	0x1bd3d004
+	0x009460ff	0x86e314a5	0xb1aff86f	0xaa2599df
+	0xbf68de69	0x355c8267	0x9588dbed	0xe47edd9b
+	0x266b2ddd	0x129b0b01	0x6e6622a6	0xb3ea4a00
+	0x802abd6b	0x7a268c1d	0x9f5a7b41	0x6f4aba0e
+	0xe279b988	0x660ef08f	0xf4207beb	0xfa0168f6
+	0x93266ea0	0xedfef092	0x302b5e5f	0x7278d2be
+	0x58a494ab	0x8f53a302	0xf5e766de	0x1ef717bf
+	0x45e2d6fd	0xf593b066	0xaea0f1e1	0x1bd1e027
+	0xf853ba21	0x1127c5c4	0x8aa43b18	0xf1fba0b8
+	0xe1cfb0b8	0xa9f9fef6	0x1320f1ab	0x5f7dfc74
+	0x30f11ab4	0xaf47a3cc	0x9c190830	0xac085edb
+	0x8b4db7c8	0x771ec065	0x6d5f3c3f	0xb8815437
+	0x20d3c99c	0x00823c74	0x24d63cae	0x7587e453
+	0x1a3fd67b	0xa5b361cd	0x789d168b	0x98a93943
+	0xd7505c0a	0xa923b38d	0x46097a4f	0x814e41dc
+	0x0f50f2de	0xbb548368	0xc48273d4	0xf27b6798
+	0x9a6b5231	0x68491e7b	0x3f482179	0x89ea3b35
+	0xa7525ffd	0xf8f1f616	0x07859572	0x738cb4b3
+	0x8937c6dd	0xf5988c71	0x4874905e	0x677a8c17
+	0xd58df987	0xc4210078	0xe6b1c480	0x7a91e14d
+	0xa1228a7a	0x09057467	0x6cd59ec7	0x6ba93248
+	0xb8e263cb	0xd3305730	0xaec36ee6	0xc773d0b5
+	0x2895f8ec	0x6c9f5fb5	0xd32a21a5	0xcea9d058
+	0xfa97282f	0x5559ceb4	0x5a0bf57c	0xf3cd99b5
+	0x2771f6c4	0xfcc9a35d	0x5143417e	0x7c6f9db7
+	0xb47cb7df	0xe7dde37b	0x70a07531	0xe25e06a2
+	0x3bbb7d30	0xaf41b085	0xe664f973	0xee2c7ab7
+	0xef8eb1b5	0xfba67f7d	0xd71568dc	0xbbff3339
+	0xdf49725d	0xbc0e7edc	0x5361e6d3	0xb0978c73
+	0x1320540a	0xa9843a06	0x34099c74	0x4bdddd23
+	0x18680496	0x44f9cc19	0x6de71a34	0xe4eae858
+	0x3349a819	0x28400571	0x10a55fe9	0x05672399
+	0xb376eadd	0xed4b1a35	0xe79d0a4f	0xca8d0601
+	0x78a7b066	0x8ea59a40	0x7be112a2	0xe99ea438
+	0x44bd9efa	0x6e5227a1	0x70325aef	0x777282e9
+	0xb579c189	0x4ee92bc9	0x0d0236dd	0xb57cf232
+	0xb815e184	0xd05823e4	0x0c9490b8	0x70a5fa56
+	0xdf0f178a	0x99d27374	0x1aba9e05	0x18378c3d
+	0x86991118	0x3a199a70	0x90b2a2cf	0x67a6923b
+	0x0975e5f2	0xf50fb0a3	0xbffbd67a	0xce6371e7
+	0x203564ef	0xb1d7a395	0x201cb1c4	0x30085e3c
+	0xfb2c66b4	0xf80ae969	0x1d407625	0x0bca1a0f
+	0xb62c078f	0x83efbf38	0xbd7b0a69	0x7d9bb66a
+	0x46b5c885	0xb256d753	0x0b5d008e	0x1756d5bf
+	0xa9ffdaf6	0x01231fcb	0x8c69e461	0xbb2ad661
+	0x29dee8f7	0xf1f23d56	0xd5e90ffa	0x48d9d93e
+	0x77b26e95	0x49c47953	0x7565da8e	0x41a6124a
+	0xfce69643	0x55f99554	0xa5501d6e	0x5738b726
+	0x4c989c96	0x93cbe27e	0x20ff3d38	0xf4787a09
+	0xfa3520e4	0x26b2dc11	0xb701c94b	0xcd8857ee
+	0xb4b07229	0x0bbcf1a7	0x3d31cd32	0x08ced413
+	0x3da04c1d	0x7bdf1787	0x344f510d	0x53a02e8e
+	0x7e295418	0xa5ed24b3	0x3a5a2c98	0x34947e44
+	0xb398bfcb	0x7c0ea498	0x18db3289	0xec646beb
+	0x2e8ed766	0x5aff9ee3	0x497dc7fa	0xa70c3be4
+	0xfc9306c4	0x729f532c	0xd87d61d0	0x635fadbd
+	0x1efb1234	0x66fdb543	0xf5b86d07	0x3a4836fd
+	0x9caf7dd3	0x8a9d9e5b	0x179529ac	0xa9a3fee8
+	0x4cfa4495	0x791b8b7a	0xc503fc2b	0x1e07d0e5
+	0x0561cfae	0xb5e7c403	0x0809744a	0xea84c654
+	0x23614fd6	0x23ae773f	0x545be2c5	0x3585b8b4
+	0xcad8b6ed	0x088a56c0	0x81054caf	0xecb13d9f
+	0x44bd49f7	0x90a3da4a	0xf4b04300	0x32a2b69f
+	0x44bed501	0x85cb54ef	0x85dde589	0xe410132b
+	0x1c2e41c7	0x3d28cc9b	0x4df948de	0xaa058c37
+	0xb82cf615	0xfa0574f8	0xd0391f5d	0xfb2b98b3
+	0x3ce5585d	0x80ca4d6a	0x4b138f75	0x721ccc65
+	0x496a3e37	0x4a8dd025	0x2d77b3db	0x65800ff3
+	0x1d2df03e	0xb4b12a59	0x4c6a5b9b	0x17413fda
+	0x4e938a09	0x7e3aa03a	0xf86cc8f3	0x972cd7b7
+	0x871849b1	0x0c0879d2	0xc7c652a9	0xe9531ae1
+	0x541142d9	0x4f731afa	0x9c43e538	0x866b695d
+	0x4a4c4076	0x1e8aa293	0x51bc1eaa	0x5f57d28a
+	0x142eb7f5	0x14096954	0xae0e9eb3	0xef732983
+	0x70187474	0x3569b88a	0xfd3a3c61	0x54f0e2d0
+	0x7afff032	0xa89cd23d	0x658114ec	0x434ccbc9
+	0xc25f33c7	0x1b6e9a7a	0xd97bd017	0x3b7489d7
+	0x67129c97	0x333ee180	0x04bf73ae	0x4731105f
+	0x09d589f9	0x7d5a67a3	0x3e8fcb8c	0x2090c536
+	0x14a623c0	0x21a247fb	0xe117bbe6	0xe98bbd1c
+	0x09e23674	0x02f09f22	0xba7f9f45	0xd18573b6
+	0xa6eb18fb	0xe01a7904	0xa8869f58	0x82ec81ee
+	0xf4549f1a	0xfa0f6085	0x1cf809e9	0xe603d078
+	0x13525306	0xd5611c7a	0x2c92b32b	0x5fdc0c0a
+	0x0b3aaced	0xa40059b7	0x27c42499	0xcc619db5
+	0x9f9b7841	0xfdca5eb2	0x2d3e833a	0x2830a6a0
+	0x4c81f3b0	0x3ec8a8bd	0x50b95605	0x33a9d515
+	0x7fe14795	0x4ff1d83d	0xef92fbfe	0x87f4faed
+	0x35d5fc69	0xd8764a49	0xec81abfe	0x634a2ed8
+	0x9635825a	0x0943624c	0x5eea8464	0x578e2344
+	0x551bd5af	0xca02915b	0xea419d8c	0x9d0fa00e
+	0xf3633f48	0xc6ad62ae	0x1eeef6ab	0x21ab106a
+	0xe325954d	0x60457916	0x6ac9168c	0xea8a9d6f
+	0x14772361	0x7630452f	0x8795e1de	0x21144d8d
+	0xe7996dd2	0x45aff64a	0xfa62c37f	0x3f5a04cf
+	0x250f988b	0x7985d243	0x1f717008	0x7908d22f
+	0x4fc0d5d5	0x856d9819	0xccfab84e	0x3fec2a74
+	0xe75c1af6	0xe2682ac3	0x2f08e560	0x7133d2a0
+	0x63e5fcca	0x3a17438f	0x9cb826c8	0x06a2f3cd
+	0x4bac2001	0x50596ba4	0xe74758d4	0x64d17e0a
+	0x08fc5b67	0xb0d62f6e	0x95eb8e15	0xd51bfa64
+	0x421c68b9	0xdd1526a8	0xfb7ea10e	0xab21193a
+	0x4b1186dc	0x77bbfd82	0x1ab08e9f	0x871659a5
+	0x1658fd5f	0xa04f322d	0xf50ed273	0xb8d411a7
+	0x8056489c	0xfbd858ae	0xd70f7d88	0x3c5cbc78
+	0xf53ec2be	0x1d2228e2	0x8b53aace	0x212454d9
+	0x76ea1d2e	0x9ca66373	0x9f6679c2	0x51c48b56
+	0x47348811	0x8abc0a27	0x60050980	0x5d290483
+	0x7ea8504f	0xde186466	0x91219d4c	0xa73144ed
+	0xb5f36fa4	0xa37912b8	0x02625bd3	0x3bc2d9ed
+	0x2e623844	0xa9a751af	0xf0ba18af	0x4433e06e
+	0xca7cda24	0x686c9163	0x86a437c1	0xf8c17120
+	0xed50542e	0x62b61fa1	0x600e47b6	0xdff86df8
+	0x77502dd5	0xea5d75ac	0x095a06e4	0xa18efafd
+	0xfbd01eaa	0x27a1cb0a	0x3dfcab8e	0x07be7250
+	0x086cb680	0x2c1ddcf4	0x6fa79784	0xcd874edb
+	0xa383d520	0xa5c0d1cd	0x2e09cd9a	0x34d645c4
+	0xf6b9b98d	0xe8e80ab0	0x39b78c60	0x6098b6f2
+	0xc3c13e53	0x88c9fd83	0x60c9e766	0xf49c4c2d
+	0x79e3d3d3	0xbfade7d5	0x6ba57dc1	0x3069e3ad
+	0x59632e2b	0xb86e871e	0x2dd63287	0x9704b283
+	0x343a6cb3	0x37d7950d	0x283f262d	0xd49d5f75
+	0xdacc49b7	0x5952e045	0xc0fefa19	0x69effce3
+	0x5b2a3c0b	0x3757339f	0x18584f8a	0x77a80760
+	0x5fcdadc0	0xc9b4df80	0xfa521be0	0xbcfc8ecb
+	0xfd3f8eb8	0xbee4739a	0x139caf94	0xbdea1cd7
+	0xab158240	0x233fd8dc	0x8ec63274	0x34eee6d8
+	0x4603b2f8	0xae544fc5	0xcd444551	0x2b2b349a
+	0x0a562524	0xb2e02518	0x577b1125	0x8b3c1ff9
+	0xfd27d88c	0x2ad77d04	0x1f82a54e	0x20254fdc
+	0xee8e63cf	0x8df3fa2f	0x9ffc7c43	0x421ae12f
+	0x9b166441	0xb74a5a4f	0xdad0511e	0x0a8ee5e9
+	0x8fe86041	0x37ef90ea	0x3fcf8380	0x87288691
+	0x384b8b8a	0x98d8a45f	0x995443d7	0x6c617236
+	0x9a40f76f	0x9f30733f	0xfdbf3927	0x7b4c0281
+	0x9e87e64f	0x9802938c	0x65f9de31	0x829c3eda
+	0x0a1d2f4a	0x22e0e854	0x30045b70	0xbf84a44f
+	0xc2c30b57	0x47c5ff90	0xaea87e93	0x99c69ae5
+	0x1080e89f	0xc2896e80	0x09ba0cb2	0xd16ee263
+	0xe05337b0	0xef1d8359	0xc1d4b102	0x08620117
+	0x2e4ab2bf	0x05dc3af8	0xc7ab866b	0xeee05983
+	0xd0a00c19	0x96996791	0x75ac6042	0x29001ada
+	0x13440a23	0x2b1eca42	0x4cddfd68	0x81a98384
+	0x6bcda226	0xa8594443	0x92f26e53	0x434de4ec
+	0x07596ee2	0x4c8ea6ed	0x5596054d	0xaffe0ef4
+	0x6dc1ab64	0x20bc006b	0xad4e3933	0xe6df0d3f
+	0xfb3ca9ee	0xc2895a4e	0x8fed0d43	0xa5ed7985
+	0xc364f083	0xc397a806	0x7b651ff9	0x1d7e22e5
+	0xfd02f57d	0x5f16a429	0x8612177a	0xd36b8983
+	0xd87b0303	0xeaa632b0	0x57dff2b2	0x19772dd0
+	0x51317bfc	0x28404b1f	0x9e35d818	0x9c771bb7
+	0x6d42a5c1	0xa6030578	0x9c844d5f	0x95d5eb7f
+	0xdf15f5ec	0xf0f8c86e	0xf8ebfd20	0xae32d9b5
+	0x4ce2b066	0x776f0149	0xda8a429f	0x0e895a79
+	0xbe62c881	0xf9c051d8	0xcaa48f97	0x9e8dcb1b
+	0x69cafc21	0x411f1bff	0x4f4d71dd	0x102cf709
+	0x974ebe53	0x7373aea6	0xef2a7ec1	0xedabaccc
+	0xdac969c4	0xe010b562	0xb6880570	0xa7a7f5d4
+	0x3c6464f2	0x96dea774	0x1614a588	0x06074080
+	0xb37304f0	0x99da7dda	0xd3e36214	0xb27b7cae
+	0xb4cef0b3	0xa435dc77	0x9d1c1a15	0x616993f4
+	0xb8a5ec8f	0xdce1ff5a	0xaaea14c4	0xa5d2172f
+	0x90c8c636	0x49c0b81e	0xff9db895	0x4252b336
+	0xd420b5ce	0x87b35be4	0xae32bda2	0x441092d9
+	0x321e8583	0x7d863719	0x3c888147	0x3f2bb9f6
+	0xd1daf5f1	0x682f2ffe	0xae62e280	0xcf8f928a
+	0x4a7237f5	0x6f3a55af	0xb91dba98	0x9b83b723
+	0x0e857ed8	0xd5ac567d	0xaf8bf791	0x23f8269a
+	0xe369638f	0x6a88edb1	0x5ff0be07	0x5c02b513
+	0x7d22f89e	0x2f865c08	0x9cc0d56e	0x31c87205
+	0x420508f2	0x95a21602	0x04d838e3	0x353353e8
+	0x7ca1feb6	0x61c6f7dc	0xf78a68eb	0x918f2ac1
+	0x413037a4	0x09692d1c	0xc8eceb54	0xb1bf975a
+	0x2ab63552	0x467bceeb	0x408bf024	0xeaed2b31
+	0x3255158b	0x8d9c6617	0xe450350f	0x615cf5f3
+	0x1a7fd744	0x27a0da59	0x43298211	0x77392298
+	0x9511e81a	0x08a2c2dc	0x3d6f1113	0x967e6586
+	0xd1726b35	0xb9292da6	0xaa6f8ad4	0x0f13b47f
+	0x34b96cea	0xebd9487d	0xfe533d60	0x41bcdc60
+	0x364c8c79	0x32be8bb8	0x1395ead9	0x9e85e474
+	0x146b6fbc	0xc93267cf	0xcdda98d4	0xccfb2835
+	0xe779dbd5	0xf9288237	0x2073e129	0x16fe4ab8
+	0x34ca576d	0xac313eb7	0x5deb3b4d	0x1727510b
+	0xc168a414	0x332cd921	0xe38e8123	0x9a2c1aef
+	0x80f5d1d9	0x7c88c923	0x8af17577	0x59ae1408
+	0xffa5e565	0xb418ab13	0xdd6376aa	0x45cd70d9
+	0x3c3a06a2	0xbc555669	0x34d1fc08	0xc2aa934a
+	0x385416e2	0x91ceeadb	0xe06c9cef	0x0394dbd4
+	0x43e7c657	0x296d7621	0x55dafcba	0x808b836b
+	0x61c41f0c	0xd9689bc5	0x3a531ffd	0x8417ed30
+	0x3f3f8616	0x641eb4a9	0x24964006	0xe8d2612a
+	0x3b916d7c	0x5603319f	0x29007523	0xc9c7dc1c
+	0xd1f7212e	0x22ac1932	0x05c39a5a	0xd55081ce
+	0x589ae996	0xa998fcbe	0xd8df5512	0xef7d7a01
+	>;
diff -ruN u-boot-2015.01-rc3/arch/x86/dts/microcode/m12306a9_0000001b.dtsi u-boot/arch/x86/dts/microcode/m12306a9_0000001b.dtsi
--- u-boot-2015.01-rc3/arch/x86/dts/microcode/m12306a9_0000001b.dtsi	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/dts/microcode/m12306a9_0000001b.dtsi	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,814 @@
+/*
+ * Copyright (c) <1995-2014>, Intel Corporation.
+ * All rights reserved.
+ * Redistribution. Redistribution and use in binary form, without modification, are
+ * permitted provided that the following conditions are met:
+ *	.Redistributions must reproduce the above copyright notice and the following
+ * disclaimer in the documentation and/or other materials provided with the
+ * distribution.
+ *	.Neither the name of Intel Corporation nor the names of its suppliers may be used
+ * to endorse or promote products derived from this software without specific prior
+ * written permission.
+ *	.No reverse engineering, decompilation, or disassembly of this software is
+ * permitted.
+ *	."Binary form" includes any format commonly used for electronic conveyance
+ * which is a reversible, bit-exact translation of binary representation to ASCII or
+ * ISO text, for example, "uuencode."
+ * DISCLAIMER. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
+ * HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ---
+ * This is a device tree fragment. Use #include to add these properties to a
+ * node.
+ */
+
+compatible = "intel,microcode";
+intel,header-version = <1>;
+intel,update-revision = <0x1b>;
+intel,date-code = <0x5292014>;
+intel,processor-signature = <0x306a9>;
+intel,checksum = <0x579ae07a>;
+intel,loader-revision = <1>;
+intel,processor-flags = <0x12>;
+
+/* The first 48-bytes are the public header which repeats the above data */
+data = <
+	0x01000000	0x1b000000	0x14202905	0xa9060300
+	0x7ae09a57	0x01000000	0x12000000	0xd02f0000
+	0x00300000	0x00000000	0x00000000	0x00000000
+	0x00000000	0xa1000000	0x01000200	0x1b000000
+	0x00000000	0x00000000	0x16051420	0x610b0000
+	0x01000000	0xa9060300	0x00000000	0x00000000
+	0x00000000	0x00000000	0x00000000	0x00000000
+	0x00000000	0x00000000	0x00000000	0x00000000
+	0x00000000	0x00000000	0x00000000	0x00000000
+	0xc2b13ad8	0x6ce74fea	0xd364ad12	0xf6404a69
+	0xc89041e4	0x217fa2f6	0x6ff6e43f	0x79cde4eb
+	0xdb01345a	0xceecca42	0x5ee7d8b4	0x24afdbe6
+	0x5fb36178	0xbc17d76b	0x31b7b923	0xc81aec82
+	0x647b3320	0xf1db9653	0xff3b9759	0xe9c74b72
+	0x3b193752	0xc147860b	0x160e0d6a	0x5bdb9dbf
+	0x1ccce2ac	0x387670ad	0x2f106f05	0xf8607ea3
+	0x42562576	0x30e086fb	0x409a06b8	0xf1957736
+	0x5eb03f65	0xad147fab	0xe1a8e8b6	0x208d59d2
+	0x683fba2e	0xf172b378	0xf8138dba	0x61e81d1f
+	0xd551f997	0x28c79780	0x04f9db27	0xa80679b9
+	0xaca4e7ff	0x6876944b	0x26d7dbc1	0x77f7dc2a
+	0xf0bcb163	0x1b2a8e81	0x7b90aa49	0x8d5eaf2f
+	0x522384ae	0xae7f7082	0x412ba10a	0x1ce1baa0
+	0x478c29b4	0x9c09b4d2	0xf225f64f	0xd43026cd
+	0x81098579	0x7df5db05	0xa5815bb0	0xc73ee756
+	0x9738cb95	0xa5bd62e2	0x88e2c6b2	0x778e7fcb
+	0xd3bdb872	0x9404403f	0x5be6ad63	0x71dc4abc
+	0x11000000	0xd350099c	0x242d0996	0x1a4ddff8
+	0xd7f1f03b	0x77590eb8	0x45c3ad79	0x3b714d23
+	0xa85ba322	0x31851c5a	0x540fe0ce	0x38692bd6
+	0xe3d9927b	0xb33428b5	0xcf0ac8d2	0xd3646604
+	0xca88adc7	0x8afc41c8	0x721432b3	0x8fd19454
+	0x26344e0d	0x3acf6c28	0xbda18c21	0x526d52ac
+	0xf8d37e15	0x09305e37	0xf6907871	0xdb56cc21
+	0x6802cccc	0x6693c8a3	0x0f4dbe32	0x0d924103
+	0xee9242a7	0x5f867a13	0x2f65a246	0x6b35ad05
+	0x39fb7da1	0xd69cb7d8	0x45869424	0x4768b466
+	0xe3ace365	0xa85eea7c	0xa59939d9	0x2ae32fb9
+	0xa20b1559	0x8865f3d3	0xbe02e023	0x4199575b
+	0x0c43089a	0x0d57b287	0xd37544ad	0xcd4573b4
+	0xa96b7485	0x05b67259	0x117414ca	0x2ba24577
+	0x439db14d	0xf82c5833	0x54ec9806	0xf8282306
+	0x1de7d3cf	0xf7a76dc2	0xcd897f60	0x0bb1decd
+	0xae58efb0	0x743c07af	0x48adffb5	0x262260e7
+	0xaa9fa071	0x9a9ef7c0	0x98e861eb	0x14a48871
+	0x0b4c3292	0xad851820	0xe0f7f45c	0xd71366c5
+	0xc63a2f01	0xd02f23c6	0x49645eb3	0x2365fe48
+	0x44817f1f	0x576ee68e	0x396b6134	0xd9fc4857
+	0x9a771368	0xda5f2693	0x6ad30ec2	0xc8d08171
+	0xe40bcd42	0xf82291a8	0x3094a8b1	0xd3edffa3
+	0x5d5fb5e6	0x93802a7e	0xdf0ff376	0x09ebeae6
+	0x35091690	0xe938ec68	0xd203065b	0xcf2e8172
+	0x85282b27	0xe59fb64d	0x4b2ad981	0xeb5dde75
+	0xc07eac26	0xa78c969e	0x74165d84	0x61c4cfc8
+	0x740452f3	0xe5f6435e	0xb712e157	0xac49215d
+	0x5be5e61b	0x09f46a94	0xde5cd48d	0xe3ed6b11
+	0x2e8173de	0xabb6759b	0x46ffc47e	0x0cd84607
+	0x6046c26d	0x19356116	0xe1da098e	0x8e1bbe9f
+	0x5c8d6c20	0xa17cfe55	0x101a1f91	0xd64aef70
+	0xef2e7b34	0xbb428dc4	0xf2252a3d	0x8ab3f6c0
+	0x161db4ef	0xfdbf4f9c	0xb5bf9f19	0x414ea8b5
+	0xc3db5422	0xfc3934f2	0x635a8253	0x86260b8c
+	0xa4c0e59a	0xa45d24cd	0x4a25da59	0x7a568be1
+	0x4ae3587e	0xbc77a3e8	0x70723657	0x9abcabaf
+	0xe0a95d4e	0x25519f22	0x3ee1d340	0x2ddc2ca8
+	0x04ae20c3	0xc143f7c1	0x4a79e4d6	0x19377b64
+	0x2ab0d3f5	0xd3f19f6d	0xc8dc880e	0xf577dab6
+	0x69b6ac46	0x37d4af3b	0x0999bc85	0x3d9fbbf5
+	0xb9387ac9	0xc148824f	0x4d11f5f7	0x1ff4594b
+	0x59beb5b7	0x29474f52	0x68e6b2b9	0x4b60966e
+	0x5e40a736	0xdeff5ef2	0xe623bbc1	0x50407021
+	0x34ec34ec	0x131b3d57	0x628bda97	0x58152b10
+	0xdd830410	0xf953e469	0xea4c8d25	0xd79d7ba0
+	0x7a4da4f4	0x887d6841	0x7ff1e41f	0xdeffc5dd
+	0x8354cb26	0xb133716f	0xae73deaa	0x292e200b
+	0x9a9400f9	0x7a5d21c3	0x590d4799	0x1333b4a3
+	0x782bbe3f	0x314fcb2c	0x475a1cca	0x4cd07c7f
+	0x7a69a5fe	0xaef5a52a	0x0e9957f3	0xf7d86f6b
+	0xd0983d0b	0xdffd48b9	0xbeea1e9c	0x19de4c7a
+	0x46487695	0x5719e4e5	0x6dab39ac	0x856bf2bb
+	0xc0644339	0xe60e92ee	0xc328b5e5	0x2d0c31e9
+	0xeb73f1f4	0x7b577248	0x361159ba	0xd0f7002b
+	0x5fa816ae	0x11ace78c	0xab62e0da	0xc924891a
+	0x1d5800e7	0x4f90e04a	0x21374c9b	0xa3350e64
+	0xcb9c1901	0xcc350b3d	0x5c3e5932	0x3cc6261d
+	0xc3b54acc	0x849cf200	0x1425fad1	0xb3a479d9
+	0xfd4dfda8	0x62973133	0xdd528736	0xd7e62e0e
+	0x6921e1d6	0x7e41d7f0	0x74397b86	0xf739079a
+	0x4ff82d1b	0x38b6fcdc	0xb20e36bb	0x0cef9b7d
+	0xa737fdf3	0x1d18ef1a	0xc2c5dda1	0xdb16c5e7
+	0xbfa99b2a	0xf83f2c10	0x883c8183	0xad10014d
+	0xcf9f6321	0x5e0c079c	0x3ddd3d29	0x306325e0
+	0xebdaff05	0xa88741be	0x181fbf20	0xa58a3a1c
+	0x1f7c7165	0x7f5f5141	0x12576e50	0x9db22976
+	0xd1fbe204	0x6ca2025a	0x10c15009	0x920649fa
+	0xf42d3035	0x79efbc73	0xad2bde6c	0xb4e317ab
+	0x1f7358be	0x447d850f	0x9bb2d1ee	0x3545cea3
+	0x78eff6bc	0xaa86e51f	0x6383ada5	0x0c969d05
+	0xadd720e6	0x92f77e04	0xda58e24d	0x401bd323
+	0xdac090fd	0x9dc372b2	0x86726956	0xc508fde7
+	0x20ec1cf1	0x29fdb66a	0xa3f7e3b2	0x5ffa58ac
+	0x653c0106	0xf0d01026	0x55feffa1	0x661399b6
+	0x5b23998d	0x91add159	0xbf917f02	0x87ef6fee
+	0x64c4d653	0xbfadf48f	0x23f3ebcd	0x67869030
+	0x3b90b7ae	0x19efc2a4	0x26596a35	0xaaa5fcf9
+	0x5a14fd14	0xebeb9c9f	0x72224625	0x3a2c0009
+	0xbe5a09af	0x5aad7b74	0x7d92261a	0x8bd722bb
+	0xfff48488	0x0379b991	0x750cdaf8	0x83d3ec67
+	0x2f582115	0xfdeca132	0x889817f9	0x2bcccbb5
+	0x58107ba4	0xb57e016c	0xbbc45c80	0x5f14439f
+	0x6e71c73c	0x5e18e93f	0x43c07fca	0x6d49bc66
+	0x6641a788	0x234f48cc	0x9e18222c	0x86efa566
+	0x450ad39c	0xbc3ef112	0x98e7d17c	0x5334659e
+	0x9919cb9c	0x9fb4f0c5	0x2ea90893	0xc70453a6
+	0xe83cc486	0x454da884	0x4cba0511	0xfb83f2aa
+	0x0cf7ec27	0x20ef41bb	0x08355d0e	0x732798dc
+	0x1689d337	0x61bf955b	0xa10d3f79	0x05fe9c6a
+	0x1cbbc776	0x42e00326	0xf92509f4	0x71488be8
+	0x3d92da26	0x839acf18	0x6dae5781	0xeecfcc85
+	0xc63c0f72	0xcd79f887	0x677dd4c5	0x167c779a
+	0x3359b45d	0x48f974f6	0xbd7debdb	0xd57d5935
+	0x41beb132	0x1574e273	0x417a8fb4	0x46ca9d85
+	0x859f3434	0x7cd1675e	0x1fb4e8b2	0xc55de45b
+	0x4be8afa5	0x193c1260	0xd4225590	0x255fb988
+	0xde63caee	0x96108c66	0xacc2b48a	0xad2992d2
+	0xdd4cf4ad	0x0f6f5246	0xaf20d77d	0xf1c81d1f
+	0x0db57bac	0xbb39c168	0xb78944a1	0x4ea55714
+	0x0bb537be	0x5824ab81	0xdb9345fe	0xab0606d4
+	0x12a8b9c2	0x90001c30	0x12c7197e	0x603cae66
+	0xe2cb6b47	0xab0f94ba	0x28091fbd	0xb79d112d
+	0xc53a69b4	0x7de8c3bd	0x4aee880f	0x5a5dd399
+	0x850105e4	0x366d8714	0x4da7971b	0xc3a0013f
+	0xfbc2461e	0x65954a32	0x4c8f348e	0x3ddf0054
+	0xc615725a	0x3021e167	0x4a88ec0c	0xd69c44b1
+	0xb21cd2b1	0x08e16586	0x90f02d12	0x554afff3
+	0x65067d72	0x8c310d6a	0xd62ab40d	0x443bda33
+	0xb6eac5c1	0xd0cd461e	0xaf200f23	0x41fd1b8e
+	0x84e74a66	0x15b0bc4a	0x13fb1a4e	0xb36bf139
+	0xeeaa0c1c	0xa91d6fab	0x64c99859	0xc049d5ae
+	0x38921c4f	0x92b2f269	0x5c867fd7	0x41bd4d62
+	0x70009a4c	0x85a37897	0xe228af8e	0x9ef4f31e
+	0x891bbb42	0x3c09f291	0x32c29325	0x88f9ee6c
+	0x81a0bc38	0xfef31889	0x8d2e3f79	0xc5e405f7
+	0xb78e4127	0x3d61f392	0x3427d259	0x9f0bb662
+	0xfe6ffb44	0x57e1e8c2	0xd4abd164	0xd0449914
+	0x5bd5fe60	0x873601a5	0x0b07ae28	0xf4aac893
+	0xb9c8f9f5	0xe3a514ed	0x9da193c2	0x55ebeca0
+	0xa9d8f9bd	0x0a37dcc7	0x3f1d9f15	0x0bc645d8
+	0xb808085a	0xc79b0f4e	0x0286eafc	0xefc87a56
+	0xf1225ab8	0x58ac6a9c	0x9227ea3c	0x82deed0f
+	0xff0f8edb	0x3c29a1b6	0x6d777dae	0xbeeee7d2
+	0x0bdca157	0xf8d9d18d	0x52fda265	0x630da310
+	0x4f660e86	0x1c985fc0	0x68f1c993	0xf4ae63bf
+	0x3ec5373e	0xf6a10f89	0x2b19bd61	0x8aab04b4
+	0x75653336	0x4be6689f	0xc2631812	0xc6d386f4
+	0x93a6268a	0x4e5851ad	0xc2b47fdd	0x5acbd226
+	0xd2aaf25f	0xbe83081c	0xe57eb32e	0x00debc3c
+	0xcd8d7dbe	0x7cf67994	0xba17c779	0x34c19529
+	0x5cf29a31	0xe10b7d8e	0x7b116896	0xf702de15
+	0x6ee2e8cd	0x2f3a12d0	0x0e2a4666	0xbc1333e7
+	0x2b653c7f	0x36e282a5	0x0ca0544a	0x2255b148
+	0x5e413d5b	0x0fc88547	0x81e3073f	0xbcef6576
+	0x12b29e93	0x233bef85	0xd41790ed	0x4f4dbf15
+	0x20dea3d6	0x25f86504	0xb13177fb	0xee626fbb
+	0x2f7529e3	0x6157578f	0xeee068f6	0xc97c5909
+	0x053c28cb	0x6f540d47	0x692bb599	0x7004243d
+	0x1c5620cd	0x0ca53749	0x9d7d6a4b	0xb8e504f7
+	0xdd138f32	0x4d2fd525	0x676904b1	0x67b90411
+	0x6777ede4	0xc1fbe02f	0xd7eb61fe	0x1c62f909
+	0x91cfdb29	0x293a8d72	0x4475e4dc	0xba9d955f
+	0x5413cb0b	0x952694f7	0x3b8eede3	0x33f1f6cc
+	0x61c2604a	0x244f8403	0x862316a5	0x2e0387fc
+	0xb3b3c699	0x418f5b0b	0x89a49abb	0x6c325320
+	0xa952f0c0	0x72454ccd	0xaa272d96	0xf05e80d4
+	0x1dceb03a	0xdb00d312	0x96cbcca4	0xc87c31f7
+	0x96b17422	0xdba12c7d	0xedaac717	0x99b1da89
+	0x48f3e07e	0xbace3088	0x71937740	0xd754a585
+	0x31784510	0x36d08e4c	0x4e8e2396	0x081fe566
+	0x0cd2092c	0xec932481	0xfae11d02	0xcb3b8609
+	0xe20559f2	0xa2330b46	0x2beec857	0x86911540
+	0x5e8e1895	0x4f42f3cf	0x8e32bede	0x78285f4c
+	0xaf267610	0x9dc86091	0x6adf9b99	0xfc91da24
+	0xc987356d	0x78f260f0	0x9cc6f796	0x1d6aa013
+	0x5f1922de	0x54d065e8	0x8a7c3cea	0x13768df3
+	0x4e8858b2	0x712b5b8d	0x0b64c3be	0x3845ef6a
+	0xff77b842	0x83a497a5	0x77f15aaf	0xccfc6df7
+	0x20084d31	0xaacdde0d	0x4059b446	0xb940b3a7
+	0x3fa88d6f	0x3162ec66	0x43cc767b	0x2a2a6916
+	0xd0dea02d	0x5b9f11a1	0xec36c7a9	0x6d7eb6ce
+	0x4506fc1a	0x1c3e362e	0x9e2b0f99	0x547e6ba7
+	0x6b8169ea	0xbd89401a	0x2cf5ea6a	0x100e6249
+	0x47ef40de	0x063a0b33	0xb1f49499	0x3026e75d
+	0x3b6d951b	0x6212fd9a	0x5073aa23	0x9bd609b2
+	0x760cf7bf	0xe6766d03	0xff811dac	0xa461d069
+	0xf40e74b3	0xec113577	0xa2cf15e0	0x6f43a20a
+	0x43f52321	0x96896eb8	0x480c1129	0x35190a4d
+	0x29a80a08	0x8ce4dd2c	0xf4b40d21	0x2324ef9a
+	0xf3f2b54d	0x7a0cc79e	0x3e9d973e	0x2d28dd0a
+	0x1a5e9aae	0x5abb6fab	0x215bade0	0x39e678c3
+	0xd6543c64	0x1652e0d4	0xca2f5303	0x0a6879bf
+	0x24841561	0x05c559e7	0xa1ac6c48	0x3fc52191
+	0x29527695	0xb977ce60	0x04589311	0xaff7180b
+	0xdeb08866	0xd62d8f6a	0xa6f62306	0xfdef1235
+	0x1946ad8d	0x1d49fa21	0xac486c1e	0x3ca80491
+	0xba8c2a76	0x06ce9ac6	0xcbfbc465	0x675c4ada
+	0x1eb6b108	0x27d03a7a	0x606144e6	0x2eedb163
+	0x64d8d1b7	0xe7695fde	0x75d593a5	0xe7f00f68
+	0xc3c45a5a	0x522c4164	0x37833c3d	0xddfda19e
+	0xd7b9f984	0x77e6ea85	0xd148df03	0x89989155
+	0x80fd8f07	0x3adafce3	0xf4e07aa6	0x6ea417b4
+	0xd1732fad	0xd13cba8a	0x01729b17	0xb9e666be
+	0x48addea4	0xffb3a560	0x4a96d730	0x0349777c
+	0xbf355e6a	0xb5055554	0x22442c5e	0xd8bda1b4
+	0xb0a088ab	0xef18b9a6	0x11ecc51d	0xd59247f1
+	0xf86fe339	0x17752dba	0x0bfacac1	0xdef25155
+	0x035b4275	0x02a3f293	0x8466a5bc	0xf376864f
+	0x04265d7d	0xc6fc5aa3	0x36adf7ec	0x4e16af5b
+	0xe3b28d5a	0xa49c6535	0x2b05f03b	0x46d5d914
+	0xfcae58a0	0xda644349	0x656d72c0	0x75d47095
+	0x302a9fad	0x4e245aaf	0xe2a3e852	0xa9b73076
+	0x8d9a2469	0xe7c05607	0x1c17b4b3	0xc2e63302
+	0x49fa365d	0xabf1f5dd	0xc850b090	0xdced47ac
+	0xd60b15d7	0xb25efb14	0x33f9a3af	0xd011cc8f
+	0xf0414eaf	0xff212e84	0x9e2fbd61	0xf6636285
+	0xd892696a	0x6d9ffc34	0x253ad380	0xffb7ed45
+	0xaae31520	0xadba81d1	0x7f1e41bf	0xcd7e1eb7
+	0x9dabd0e9	0x5de91eeb	0xe9fa68ed	0x3fae0c6a
+	0x6da21b40	0xac743c3a	0x19228523	0xf5098069
+	0xf647fe8d	0x95666621	0xa2a3613d	0xe6278031
+	0x6901cfe4	0x3bf132be	0xc3314ee8	0x5b8261b8
+	0x9b724149	0xd0838d83	0xb0d05c76	0x57295707
+	0xcb11fd8f	0xfdce9b20	0x346449b6	0xe8b44745
+	0xc0784ff6	0xe6083a3f	0xb0b87142	0xd2df2210
+	0x7b9dc719	0x961585df	0x359390ec	0x0d40e1f0
+	0x56436a52	0x8ccb0d80	0x78066e70	0xcfd04ac4
+	0xd850a6a2	0x00612831	0x19e74acb	0x5a80989e
+	0x0d7b151c	0xca9bee4e	0x2fea9d99	0xfdd7ec3c
+	0x3a73b4e7	0xa70068d1	0x38aff576	0x4c861c14
+	0x2e23b093	0x0e429806	0x8cce23dd	0xb0ce104f
+	0x1684bf8d	0xb2756213	0xa64c594a	0xdd8ee144
+	0xda5316cc	0x76dc877f	0xa1c5fe35	0xb5e04383
+	0xc9e10000	0x8ac58408	0xf6d7e781	0xbda6cdc5
+	0x81517c56	0xdee2ba90	0x3cbfc247	0x4c84887c
+	0xa722c632	0x4767a4b3	0xe83b79a3	0x7f100150
+	0x1074198a	0x220260db	0x1c940f4a	0x92c42619
+	0x56dc9f64	0x1c0f7eef	0x3694f4e8	0x5b4b63d0
+	0xe784afaf	0xcdcdb039	0xf7040a88	0x47f2d84b
+	0x143a94b5	0xf68f4fab	0xf6640462	0x3cd6b1c1
+	0x7fbe0e60	0x700ee673	0x030e877f	0x60779cb8
+	0xddb6933d	0xe46f377f	0x9f9c43c9	0xce0f0d58
+	0xe6bf42a4	0xae09f51b	0x295e8cf0	0x140df2b9
+	0xfb04c209	0xb6d46f7b	0xa86e0c91	0x64fc624d
+	0xa7a8760d	0xdac844b4	0xbe1491b0	0xad480684
+	0xea874ca4	0x3535e483	0xd49365c9	0x83f2c050
+	0x05ec206f	0x7fe3b010	0xb72aadbf	0x40b3a286
+	0xafe395a8	0x3506d4af	0x9c4e33e7	0x0259eba9
+	0x0daecf5c	0x264c008c	0x898bdada	0x0f3ac833
+	0x7ef5f3f8	0x41934050	0xc3bda261	0xab624dd0
+	0x5d93609b	0x495a5f1f	0x34119efb	0x3bfd15fd
+	0x49255da9	0x3ab2d260	0x15ce2006	0xd466d454
+	0x3d052ca5	0x567977cc	0x7f8b8657	0xd9b34f42
+	0x36c65ff5	0x5f96bffb	0x2d32daf1	0xb301cf05
+	0x933435e1	0x316fb1ae	0x48be2982	0x657c3286
+	0x1916c189	0xa3a030b5	0xe4c7bce9	0x6a762931
+	0x1e90df3b	0xe9084ef0	0x1236cfe1	0x7239326c
+	0x29bd4dfe	0xaa01cc46	0x93e514ef	0x4e376f6d
+	0x14087975	0x9cdad6f9	0x86b31bd6	0x2c206281
+	0xe178b367	0x4943f013	0x9f97c9dd	0xe848fb0d
+	0x7d19e49e	0xde4d9b1c	0xee7f552b	0xadea7634
+	0x605ab7c5	0xef66b062	0xaf369aec	0x39a96463
+	0xb39ed4e0	0xf4c38bbd	0x48565c84	0xcb4ccad7
+	0x37b656c4	0xa5291b2c	0xba05d037	0x0027ff97
+	0xec2034c9	0xa19abaff	0x99dd50bb	0x44bd5f0b
+	0x8cc4193d	0xe1dca3f4	0xae2896c9	0x992105a5
+	0x46b04aed	0x3ca454cd	0x9a0e86a3	0xfdb3702e
+	0xf2ddfd7c	0x6b7ca41e	0xe49f2227	0x4839351f
+	0x201f1173	0xc9af9d40	0x7942ef65	0xf35e5867
+	0xe5358390	0x0beff1a6	0xd057a81e	0x89830387
+	0xe496a246	0x45007e0b	0x62c34ed5	0xc2170342
+	0xa095780e	0x00682a8d	0xfab7e24d	0x207cb6f9
+	0x7d5c8058	0xb0164454	0xee8b6d44	0x0aa01190
+	0x70637e84	0x1268c1cb	0xf7a1eb80	0xbe90b153
+	0xcdc765f5	0x5841d605	0x00141f5d	0x475f8d3a
+	0xff60a6f1	0x5f7a2e3a	0x30d3f150	0xd9a22f7e
+	0xdded3241	0xfb05ea5e	0x4093fd88	0xb11f5a9e
+	0xf1b36594	0xc7579059	0x7f66c5e6	0x8fdb1095
+	0x46ff7f62	0x70925647	0x207287e3	0x6bddfe5d
+	0x240fb596	0xc91784fd	0x28acd7f8	0x7cfbc9da
+	0x2d6b3cc8	0xf8e9aaf5	0x489616b8	0x9ed70056
+	0x586bca94	0x6a95971e	0xa2238b5e	0xc9a06325
+	0xb90882a9	0xb5b3ffab	0xae4b2beb	0x5aa0ee34
+	0x52e23123	0x9a019e1c	0x84b0f00c	0xba2cf495
+	0xca4108dc	0x9272b0e7	0x760b209d	0x3e294274
+	0xb8f0316a	0xb666af5b	0xcf436e91	0x365dd253
+	0xbf11262e	0xdfa3f8ee	0xd6e0ab96	0xd8a639f8
+	0xcba8b31f	0x58940e1a	0xa4bf5e3a	0x7f8cec5e
+	0xb5ec87d4	0xb7924503	0xe2bff3a9	0xc7ec4445
+	0x1e94324c	0xccf28ba8	0x2294b594	0xad297087
+	0x18624369	0xa017851f	0xc635302f	0x802becac
+	0xe631eaeb	0x386589dc	0x780823c4	0x7b989c1d
+	0x94554d93	0xfc22d343	0xb8edbd0e	0x8bc08005
+	0x998a234e	0x507d3976	0xf1f9833c	0x522a2971
+	0x2765433f	0xe1ef356f	0xd45d5fd5	0x8d3294d3
+	0xabcffdba	0x9b7a6338	0x2f261e1f	0x891fdbd0
+	0x67008f6c	0x23d96866	0x057410ec	0x2f360684
+	0x8380c618	0xc968f3ae	0x91ac868d	0xdb5cc503
+	0xf092b320	0x73ef35c1	0x0fada995	0x56316744
+	0xde2290fc	0x7070dee5	0xcf1cd6ab	0xf1a47253
+	0x2c53b495	0x8952b433	0xa5b47637	0x9dfe09ae
+	0x2fb36206	0xcb1dec3f	0xec188994	0x10407824
+	0x91f27ffe	0xd461edb0	0xc3779ae4	0xe3f9bede
+	0x183a107a	0x0122654f	0xe319bba5	0xe75c33cc
+	0xc657ea24	0xe5490f98	0x653d01c7	0xce09c546
+	0x631ea29b	0x81278443	0x0cd4dd3c	0x6b7da4ff
+	0xacf1363c	0x563ed879	0xe8420e5b	0x43adcc25
+	0xc6ff7dd8	0x21e26910	0xa4b4f3be	0xaea31be5
+	0xc241c837	0x07178d5d	0x2b69f8b3	0x3bc0b4e6
+	0x429c50c1	0xe493ba56	0x5933b099	0x237b2036
+	0x0e807425	0xe450e510	0xd72a6007	0xc1459771
+	0xe9b22ad9	0xb25e452b	0xeda83668	0xb00e8d93
+	0x12b8f351	0x703ed783	0x901c6109	0x72b3e601
+	0x099cfb54	0x7fc68f6b	0xda7f436b	0x1dd70c40
+	0x5a57914c	0xddc3fe51	0xf1b692dc	0xe8b066bd
+	0xaa7b0d19	0x4a593520	0xd3bb712f	0x1e1b4c0e
+	0xe651f456	0x4fd0e108	0xdef8932f	0x3de33c3a
+	0x4c189801	0x62c607ea	0x708e8086	0xf1b9d204
+	0x19656d6f	0x216430e3	0xc8bab24c	0x4ea84e4f
+	0x659f0cea	0x4e7bad1d	0x7f4d77d5	0xf6d114a2
+	0x6d8038b8	0x8d56f1fb	0x2f015191	0x0b3770bf
+	0xd81e40db	0xfe66c348	0xffd1d3bf	0x07021042
+	0x8ce5e26a	0xcdaa21ca	0x1bd4b85d	0xfabd423f
+	0xba6814e4	0xaa5fe624	0xb2591597	0x81e601e5
+	0xf3601f5f	0xf4dbb30a	0x0950789f	0xbe9b1f70
+	0x35faf9cf	0x9f27e299	0xf9c1075e	0x09b04ac9
+	0x2bb3cb1e	0x8c197668	0x8dffa14f	0xda4a57de
+	0x5e0f0a9a	0xd1521120	0x31c26430	0x46a75d9c
+	0x6c7e1a50	0xda1db6de	0xaef50782	0xd32d301c
+	0xa4688102	0x77c6bc1a	0x3c7e2525	0xcbd4284f
+	0x5f493a22	0xb35abf25	0xc996f4ff	0x009f0c05
+	0x6143581f	0x7a864557	0xd0e1d52f	0x0725f9fa
+	0xdcc0b294	0xc3609ee2	0x75373ce8	0x1ffd4ead
+	0x331b82b2	0xfa833542	0x43c00611	0x7ab1215a
+	0x099bb7f3	0x1c95dc3b	0xbbfb8231	0xf62659ba
+	0xf9cc6fbc	0x030b6f56	0x793603cb	0xe7c48d71
+	0x9754aa20	0x41710095	0x35b92718	0xf464fca0
+	0x4ad77ab4	0xd5582574	0xe0552ad4	0x7393e896
+	0x34920ff9	0xd0a44180	0x2e523669	0x81d5573c
+	0x1959ad82	0xfb153a03	0x1cfa615f	0x8b302a87
+	0x4e4eea7e	0x21ca24c2	0x5a971dcd	0x788e063e
+	0x2c9beb8d	0xb3b98af9	0x24079012	0xbdec8a61
+	0xc41752df	0x8d2c0a3d	0xe960ac61	0x658cae63
+	0x891956fa	0xd0d1a216	0xbc37b8fb	0x5e2c3009
+	0xd600a7ad	0x47c7c30c	0x8fbd13f4	0xbae4d97c
+	0xdd15d643	0x71440bb6	0x3fccfa22	0x1ef82308
+	0x2c48907e	0xf6ad303e	0xc1ed250f	0x6f9204f8
+	0x19062b0a	0xfe8ab325	0x379e8b1b	0x8116d220
+	0xc6d4d8cc	0x624098ee	0x3e6aad4d	0xbce3ace2
+	0xba349982	0x7439dd11	0x6ac6d240	0x9f2cf9c6
+	0x3dff687d	0xe5b6f2c9	0xbe1645a3	0x39a39bfb
+	0x7956d69e	0x50d22da6	0xb7e32b7a	0xf4144b4e
+	0xb94151a5	0xee36b1b1	0xc8cd8d65	0x5e571859
+	0x0db49c4b	0xd9d71cd9	0x4bc017ca	0xc81d5130
+	0x0c9660c7	0xe4b12b28	0x5549e753	0x97a9fa4a
+	0x0dac4813	0x7854b977	0x7c8cc619	0xe4166449
+	0x020ae016	0x02448146	0xa3924345	0x1542cba9
+	0x461583ad	0x7bf66ddd	0xaff59684	0x398b370c
+	0x5ffbd30c	0x87900806	0x0891afff	0x7aa84ad3
+	0x62e35158	0x995e545a	0x6ff3779d	0xa05bdc9b
+	0x777a7e83	0x53643dc4	0xd77d4704	0x422ec993
+	0xabd03cd1	0xcb6ad4b7	0xa94c512d	0x6562975c
+	0x63b27747	0xecc0955d	0xd965b2b6	0xc67b64c5
+	0xfd69b042	0xfe7314c4	0x9f807bbe	0xafaba4d7
+	0xbd63eb72	0x811a8901	0x7ea1be4d	0x7316f0fa
+	0xa6cf004c	0xc17d9363	0xe3fe88d2	0xe60faddc
+	0x5d3a1b02	0x8a9f1ed3	0xebfb9234	0xbc453cf2
+	0x190085ca	0x369a1df9	0x55721790	0xb071a9f3
+	0x0697bfc2	0x65753b76	0x177d720f	0x1563979f
+	0x970c4dd8	0x511aec5d	0x19878647	0xc17280ee
+	0xe61c4188	0x7a4c0756	0xdb49157b	0x0d461f37
+	0xcf0bc73b	0x1c6e7ac1	0x683a9e1e	0x0dd9ae7c
+	0x72be0902	0x85a22cd8	0x8b98d2dc	0x2f3a9ff1
+	0x4540314d	0x3a4e344f	0x3ada6bee	0x3408b829
+	0x711ba0cb	0x0c92ae4a	0x621bc5f1	0x908043da
+	0x8f8ac31f	0xed15f127	0x731dc6d9	0xdc6eb058
+	0x6815eb3e	0xaca3d9e0	0xef7b5c61	0xfea2a032
+	0xd3c76315	0x0f88f4c8	0x291b8710	0xa5ef8346
+	0xcab00448	0x78ef9fb3	0xebf0388d	0x33f2a5da
+	0xc41190f2	0x0cb6bcf7	0x0afe5680	0xef88d3ea
+	0xc0e10f4d	0x7e028bfb	0x933657d9	0x6f61fcd0
+	0x7e03e392	0x23258472	0xfb16ab16	0xfaf74a5b
+	0x7ab0a634	0x8346df0a	0xc3c93451	0xdff93a32
+	0x3920a816	0xc3331312	0xa6a2270c	0x10025010
+	0xa8f4d842	0x36b96367	0x77a30dad	0xe1bd6d0c
+	0xf3ddb722	0x9412e861	0x4e7cd927	0xef243451
+	0x41d7258f	0x6eb34be2	0x026ef296	0x46112337
+	0x656c8c07	0x18deff2a	0x5be15cbb	0xbaed3a53
+	0xc795a134	0xdcb1350b	0x758b6482	0xc6cd0e88
+	0x9be9d4f6	0x1ec7c2da	0xc5c1fe49	0x3e86e8f1
+	0x09126f9e	0x96772352	0xa4d5c70b	0xc6f1f2d6
+	0x3c22e595	0xd5ccf006	0x48f6167e	0x415dfe21
+	0xf49891e0	0xab4c4a7c	0xcd9b336f	0x5777d2af
+	0x6a8ad930	0x3f47c079	0x72286c81	0x44b565fc
+	0x5ff87a6d	0x6aad7ebe	0x66535422	0x4dfcef23
+	0xc0ffcc8b	0x6e2cfe00	0xf1e7e1f4	0x06e46379
+	0xce1bf7c8	0x70fec576	0xe9d0014a	0x844f7b07
+	0xb7a27720	0x4a62dde1	0x39207994	0xe12e7ef1
+	0x75f2152c	0xec05cfff	0xac67a90a	0xbb9f0c88
+	0x8fe2e008	0x58e15130	0xd54c4808	0x71fc616c
+	0x02564be1	0xf3d121e1	0x904f4a7e	0x7eaa8b70
+	0x893d8579	0xeb94b6a0	0x4c84f056	0xebf49f0a
+	0x2b2fb4cc	0xb6014008	0x1fe0a076	0x9e7af7eb
+	0xc168be50	0x61653283	0x2016760c	0x57c36535
+	0x720405de	0xb4924329	0xb1189d2c	0x9dd8f5c0
+	0x2a5f1ab8	0x49580b2e	0xacbbd3d3	0x3261e254
+	0x7a827ba0	0xfc91f0bc	0x2b02ba34	0x96edf03b
+	0xfd7fd36a	0x24edb430	0xafc7e2cb	0x0a8cd505
+	0x22ed5205	0xb42ca58f	0x24fc4009	0xf064cb61
+	0xa564a202	0xe42a9b54	0xd2a28338	0xca1f1a5a
+	0xbe51905d	0x9a960bd5	0x4238b656	0xfb08649e
+	0x76c93495	0xaccc0877	0xc465148e	0xa2bc11d6
+	0x84a54419	0x2a2ddd16	0xd9e1d2e4	0x622bbcfb
+	0xcf0608d2	0x93a26458	0x2b666698	0x0645f585
+	0xed3df83d	0xf6e81a41	0xce11e962	0x93c27f84
+	0x30f41197	0x659aba68	0x57c01eea	0x2a4cc4de
+	0xecf2f07d	0x3340329a	0x1084f771	0x9d4c351c
+	0x32d28528	0xa3b947ae	0x78fce7f7	0x14d0290c
+	0x7b7ac82e	0x7de381ad	0xa907d620	0xc31ae25b
+	0x513a2723	0xd8cc3457	0x8fe676a6	0x04039d12
+	0xdce5a5ff	0xcc0af574	0x1406d489	0x3393d517
+	0x004cfc81	0xeffe2eba	0xf2ee0c96	0xacac4889
+	0x6484e7d3	0xdecdce02	0x029dacc5	0x95c52292
+	0x0dfaa257	0x7150527a	0x0b59ab84	0x3a915b26
+	0x2624fe20	0x46309564	0x704261ba	0xdf434f92
+	0x2eb248c1	0x26d555d7	0xc75d81f5	0xbd0185b8
+	0xf53b1298	0x059b9353	0x7821a25e	0x4d7fe1cc
+	0x811b5179	0xe42e22a9	0x4fb78808	0xd6841c31
+	0xd9edb88a	0x9b433474	0x1c54ca12	0x4887f63d
+	0xf1b21006	0x8f7761fe	0x62a15331	0x6b35788c
+	0x4a5a9edf	0xfdee39c8	0xed95d818	0xe087b392
+	0xcdc89907	0x5ee58605	0xd4d7290b	0x46f8d2ce
+	0x6c9c3f65	0xd129f26e	0xd8cd5b87	0x2bc19529
+	0x7ab5b036	0xc44a6fbf	0x76fb68b1	0x6bffe654
+	0x482067f6	0xf8ed9d43	0xdad6bd63	0xa9ac77a2
+	0x76e6c089	0xe24ba46c	0x420ccbe3	0xfb09b718
+	0x83ec3694	0xf76e47d9	0x5f3a8859	0xe85f7fcd
+	0x61f1d09a	0x35065817	0x88bf5c6b	0xfbb9f76d
+	0x8b68fca3	0xed95dcb5	0xc2ff7cf1	0x855a2958
+	0xf7d28d92	0xb61802f7	0xf9814028	0xac8703c5
+	0x4ce8c7cd	0x1876cfe3	0x851c045a	0x56b3d146
+	0xe7abf1e7	0xdc46d720	0xd1e35c3a	0x2243ff60
+	0xc257c828	0x16513009	0xcb797d5d	0xe0f2cb11
+	0xf7e40b66	0x721e0495	0xce72e9b7	0x32eeedcf
+	0xf5dc5e01	0x355de93e	0xc20ad627	0x95aa436a
+	0xe69cab2b	0x511fef1c	0x18522a80	0x203e240f
+	0x882fb1f6	0xfed4db9a	0xa4bf7193	0x420df144
+	0x84791341	0xdb4767a1	0x8c0b40fb	0xcfa5c5d2
+	0x2783cad4	0xcf8dd48c	0x051037a0	0xc2994140
+	0xaf2a0a2e	0x29619774	0xffd83edd	0x1e346b24
+	0xb058a539	0x8118011a	0xb1722fcf	0x4f89c7b1
+	0x0e6f2f4b	0xdb155d1d	0x21d21cf9	0x25ba315b
+	0x7a17b541	0x3f23c32b	0x301e0881	0x9b0ad7f7
+	0x8adfccee	0x6c2f2975	0xbc9c318d	0x8d220d3b
+	0x33d2d0c1	0x5bc2dbf5	0xe0290856	0xedd38c75
+	0x56642fea	0xf7f5609b	0x5bdb0058	0x511dfc07
+	0xc6b0b515	0xeac6f4af	0x7da3a898	0x50452011
+	0x4668042b	0x4055890e	0x7bd41459	0x9b98f96a
+	0xc516cb64	0x15313f77	0x04f6816a	0xd622931a
+	0xbe2be61e	0xd549a421	0x380373c2	0xabb7123d
+	0xc54b9d3b	0x5a130630	0xafff90c4	0x50f5b4ce
+	0x75b0ecf0	0x16078950	0x44d547f1	0x8353af66
+	0x587bb496	0xf8f3c68a	0xd3b06119	0xef05594d
+	0xd403c928	0xf12b06bf	0x2b78eb2d	0x7de9106d
+	0x4966726e	0xa8b5ef1a	0x1c42a3f6	0xd55aa69b
+	0xe409c51f	0x93533259	0xc6d9dbf5	0xb4d63a17
+	0xaaf73aaa	0xe485f5d5	0x753f0d34	0x1a3e6dde
+	0x41183e36	0x2ec20e27	0x6b66bead	0xfc5f1d42
+	0xfecdf91f	0xb7066b78	0x8ed6da1c	0xbbeb87d7
+	0x8a72de9b	0x1e0e2f97	0xc377f532	0xedbdeb81
+	0x0f5b9e33	0x6ae7ebf2	0xca7440df	0xe9c3eefd
+	0x4bd50433	0xc25a6b95	0x9d2bd1e2	0x70709639
+	0x9050c202	0x7cbd2f1d	0x41443fa5	0x63dd89b1
+	0xb2607a0e	0x88c1417d	0x1631dbb0	0x13508ae3
+	0x4e78d90c	0x19811ae0	0x4bc827fb	0x459a55aa
+	0x52c0fd8d	0x8359500c	0x6a886312	0xbe704e33
+	0x441b7c24	0x5121c79c	0x86066830	0x1a0d013f
+	0xe78bfa0b	0x3f9e3ffc	0x7b3abb16	0xfc24b9ee
+	0x4f543a26	0x0619ad49	0x6a20077e	0xc8191371
+	0xd1d2876f	0x8b83645d	0x48330de1	0xe132ea1a
+	0xdc077f5a	0xfd14dd79	0xf606c198	0xec47c478
+	0x17c3f14f	0x334fd708	0xe39cf072	0x39f543c2
+	0xebab93a2	0xf7febed4	0x79971f6b	0x888858d4
+	0xdfd11199	0xafe72dfa	0x13f30ff8	0x6141ada3
+	0x5fe75eb0	0x75dcecd6	0x70fb1b33	0x073f9823
+	0x7afb726d	0x04b10ea5	0x6c881a5b	0x945a5c69
+	0x2ecb950a	0xb384f045	0xe5eb9ac8	0xa46dfd3b
+	0xb8185584	0xc095b417	0x86173c80	0x6a509180
+	0x4eddcc32	0xf408ac80	0x0833ae99	0x58ca79b2
+	0x2eac5d79	0x85c2deb7	0x400e6a01	0xdc6caa56
+	0x706176e7	0xa5dadc8f	0x0d4969de	0x259553d9
+	0x52425195	0x7d074da3	0x784ef596	0x8580e28c
+	0xbaa52874	0x71abf00e	0x8434cb32	0xc3a8ffe2
+	0x6ec52581	0xa4cd744f	0xd5820757	0x7e257e4d
+	0xb7428f60	0xb55fd824	0xd454c529	0x8de72e07
+	0xf84abcb4	0x30b7c926	0x5140a1d2	0x4e9550c6
+	0x18826ed6	0xf561a8eb	0x28c7cde6	0xe91022ea
+	0x73cdc0ef	0x32bea752	0xc7a0138d	0xa0af6cd3
+	0x52c4736d	0x0b459241	0x2156a8d8	0x0d32a2ad
+	0x49bb6600	0x8752c2bd	0x45d0a0ec	0xc89f9bc3
+	0x76d775a6	0x963f0a6b	0xb5d100fc	0x2731528b
+	0x2719d1a1	0x2b201af5	0xc337ea7b	0x70ce1c8f
+	0x8cb21437	0x9869038c	0x53e9458e	0x624904e5
+	0xcb7cdad7	0x13b9bba7	0xc66ec1ae	0x86bbb14d
+	0x018c25ad	0x88573452	0x4165b4bd	0xa719f640
+	0xd4b8227a	0xdace857f	0x701c449e	0xa835c09e
+	0xef8e4608	0x72ec0d91	0xe88703ac	0xb6470c3d
+	0x0cae0aff	0xae650f6c	0x384c382e	0x5d4b6275
+	0x6691c449	0xfba67785	0xe3a5b7b7	0xfb72c85e
+	0x09056be6	0x15e28bd0	0xb6be7e9e	0xd97fac13
+	0x1e6023bc	0x0f28cfbd	0x840eeee5	0xd208ac51
+	0x12b36d98	0xd28885de	0x108c3e86	0xff2ae965
+	0x09b446c4	0xe453ba28	0x42c997ac	0x880e22f3
+	0x0eeee913	0x5a0c9803	0xf080f33c	0x47e99f76
+	0xa62e02f6	0x38283513	0x5ecad92f	0xaef2a1eb
+	0xa5cdc2c5	0xd5e6ae58	0x03dbffd9	0xc24ddb4f
+	0xaaeecc9d	0xdbeb2dfc	0xfda7e5a0	0x8e537029
+	0x8ae38058	0xfce24682	0xcdd46b74	0x0cc2b384
+	0x89cd2e8b	0xe955abd6	0x82c64f39	0x716c7713
+	0x70dbaa6c	0x271b7a9c	0x332e6234	0x8d081fed
+	0xb47ac8d3	0x818af259	0x6d97d09f	0x7aaca213
+	0x2124cd22	0x70fc4cbc	0x02988745	0x29e28390
+	0x2b11e888	0xe62b3826	0x8c6260e9	0x2b2d9036
+	0xc3cd85c3	0x3a08e1a7	0xf406364f	0x6ff5f0d9
+	0xc0c2a847	0x076cac4b	0x85eea1ab	0xbe6d6dbc
+	0xdffbd36d	0xf1bb8934	0xae696cac	0xfe51475b
+	0x6bce710a	0x83d6ff0d	0x44cb120f	0xd0c01d5a
+	0x997f8469	0xdaad8626	0xdff160f7	0xf2954b72
+	0xd4efa312	0x07035ee6	0x03e8dbb0	0x5a33d382
+	0xc6527dc6	0x0b7391a3	0xfe568e01	0x24c28c70
+	0x76e65ea0	0xeafaf171	0x1ab4ebfa	0x4ff66462
+	0xc9949824	0x776d25fe	0x3689d8f9	0x1ec65a2c
+	0x746581f5	0x227209d2	0xbff7bc69	0x91b4c927
+	0x171c5962	0xb4dd5f85	0x72e4917a	0xd01ff1af
+	0x9c6ba703	0xdb9d9be6	0xae1cf2c5	0x48b85c21
+	0x9628b693	0xa8d2e2f7	0x856584db	0x1b33821e
+	0xff5de311	0x4126d04c	0xf00ac027	0x54bdaa98
+	0xa3dd5b0a	0xce2b2558	0xea5f50d8	0xb2e88f18
+	0x19590981	0x6dae2c0a	0xbfd758bc	0x2897e93c
+	0x3ba5d054	0x2d809b4c	0x3de6aa52	0xea171509
+	0x7d8b7b44	0x19a1ad1c	0xe99b2657	0x98ac56e9
+	0xc2150187	0x63a12506	0x4ffc1739	0x50e2ca6c
+	0x4f2ff10c	0xb7323ff6	0x81d9f57a	0x5146beee
+	0xa1f45456	0xf6ce5d75	0xdff7be9a	0x75ab2dc9
+	0x5ff2901a	0xec756ab3	0x8a5e0299	0xc4e248ce
+	0x248502e8	0xd8c62cf1	0xc7001b23	0xf7c636d2
+	0xefbb67e1	0xec507025	0x1820ac19	0x39e1624c
+	0x4ee603b2	0xb70e1c67	0xaf9376fc	0x371af05b
+	0xa19209fe	0x8ecdf499	0x9a607cb2	0xcbe61a2c
+	0x9f4e950c	0xb9a1546f	0xe718f140	0xc75d5d02
+	0xabe66af2	0xecc54d7b	0xb4373489	0x22254496
+	0x4b4b7f7c	0x40dde60e	0xfe621a3e	0xa6605c67
+	0x5cf6a3a2	0x75df88a3	0xbf0749b0	0x705a0a04
+	0xf3cae078	0x392bdebd	0x98878e65	0x0f5a2be5
+	0xec172835	0xf610cc90	0xac6ff369	0x0a71c173
+	0x8eae2d62	0x2ccbb630	0xd3b702ea	0x1626bfff
+	0xdb4a6975	0xd2a936f7	0x0bb63194	0x5d9120dd
+	0x5860e04e	0x3baeca91	0x95a621db	0xa6d23aaf
+	0xfebcfa2d	0xa5ed89cf	0x2192280a	0x72322cb8
+	0xd79e14d2	0x0528ce06	0x1c6a8f9c	0x6703407c
+	0x93819694	0x6c554390	0x7875452a	0xf45d2757
+	0xe0458d1d	0x335f6179	0x48989cc9	0xdc16cec8
+	0x9e2c0ee5	0x78daabe2	0x2069e8eb	0x0e87f238
+	0x0a928dda	0xc66e14b3	0x2a6c4031	0x73821630
+	0x8b8c4a40	0x243702b7	0xded80901	0x5de34802
+	0xea029b73	0x59a47771	0xe747d796	0xe80aea8d
+	0x0bd01815	0x76fe1f68	0xa345fc34	0x73737383
+	0x76753b6c	0x57dcba56	0xb11d6b21	0x81dc371e
+	0x311f4ea0	0x3b4b2522	0xe8a66ef4	0x1932df0c
+	0x9f3790d6	0x0d0478a3	0x7dd0a24b	0xeb581381
+	0x6fe8ff06	0xe34c2d69	0x26842e15	0xe9a39562
+	0x78f2d7d1	0x79ab33f5	0x197df69c	0x38a9a004
+	0x9391dba9	0xfbb4b7c5	0xa97bb70f	0x0720b57b
+	0xd9b26325	0x3ed1a3fc	0x11f5aba0	0x6e6a53ef
+	0xe2ce236e	0x30994468	0x9d4369cd	0xcb6b5b5c
+	0x61a0945c	0x090e7dea	0x5d9b676a	0xd474cb52
+	0x8ebf1af3	0x35f2a70b	0x417d48a0	0x45062dcc
+	0x841d8d90	0x30f8e590	0x1c935ad3	0x29313e0c
+	0x46ecf673	0x4998b596	0x95f23529	0xf31bd581
+	0x1b32045a	0x90432d28	0xa2a6c268	0xbf40fcae
+	0x4104b314	0x02677221	0xa99231ac	0xe28abada
+	0xd7d72a73	0xf1b2ce4c	0xf753f8be	0x9d7fc1c7
+	0x9a0e7a7a	0xf04ccf32	0x58433f5f	0xab9a6d51
+	0x71262b1c	0x48f84d91	0x897670bb	0x47dd10cb
+	0xac7ef74d	0x78dc3e54	0x30b17eaa	0xc8f46618
+	0xc636fe3b	0x86ac06e3	0xfb8edd16	0xed357170
+	0xbfd34bf8	0xaeb9571a	0x4eec6a50	0xe881a1b7
+	0x8a1cbbde	0xc6c077b6	0xaeda1441	0xf990296a
+	0xc91e87d6	0xad0ca921	0x855537b6	0xfc0da57d
+	0xf8427d87	0x9ece7413	0xc5d4b4c9	0x2fca7822
+	0xa1888443	0xd3bf617e	0xab21ce7d	0xe63b5f53
+	0x828501c5	0x81a39da9	0xb8cfb4c6	0x6b23b8dc
+	0x853fe425	0xba262321	0x34f11b05	0x8044aea4
+	0x67a3f99d	0x51e8afb7	0x04efcf27	0x7773f9ff
+	0x8abceec1	0xd75d87a2	0x7e30d774	0xdd7a42f2
+	0x2ca6ad73	0x27d4e62f	0xbc228d26	0x035a7713
+	0x5dbcc13a	0x792a97da	0x56cf9fc2	0x5906fa3e
+	0x97a3147c	0x85e59863	0x19ad1f49	0x1af659a8
+	0xddc6a273	0xd254a195	0x44d83a00	0x3b7c5fa7
+	0xcaf756aa	0x68ad08b9	0xfc57da12	0x3b278f24
+	0xbd165574	0x3cf597ca	0xdeb872ba	0x543eb2f5
+	0xfabc0d4f	0x0799c544	0x3d71181d	0x22c8a598
+	0xb82840fc	0x1a198d19	0xf529a0ea	0x2f65bc24
+	0xe979f99d	0xff8617b4	0x376e5abb	0xb095a03e
+	0xa36b1107	0x2dacf004	0xe4c565e1	0xc96463cd
+	0x3b495e2d	0x4a2c2cd7	0xa0053fc2	0x6c82a085
+	0x6b801c45	0xc1481d77	0x6d95dc15	0x44dc8bf6
+	0x3eed7d25	0x901a6b49	0x2797e953	0x502ad2c3
+	0x8491c3f2	0x3ce059eb	0x992c1a76	0x6c56d2a2
+	0xcf1878a7	0x10574487	0x5a2f85e6	0xf94e418e
+	0x4c149aed	0x9381b5a3	0x79c90da4	0x635e696e
+	0x243073ba	0x67504105	0xe82ac957	0xaccda7b3
+	0x29bdd624	0xd0c1533c	0xbc080065	0x8d617329
+	0x27e6f74a	0x31e87692	0x50a3857d	0xc5b1ec3f
+	0x4f03be5f	0xa35fde17	0x537a59bb	0x793d1eb5
+	0xc11a0588	0x067e5593	0x102532c3	0x4024b312
+	0x32504cf4	0x4ddc0e9a	0xad5b1d24	0x41081874
+	0xf94fced4	0x16f39da6	0x9bdfbe58	0xc5615db4
+	0x1fdd769d	0x4278b52e	0x4525b8b6	0x7feed258
+	0xe0b4348b	0xb4925ccc	0x5547cc88	0x3f7f5443
+	0x5b8cc6d3	0xbe6a15cf	0x7308c088	0xde4219df
+	0x4685593c	0xc4ae83a3	0xaea72ff0	0x403b0c08
+	0xe533a9aa	0xed46be76	0x4390bcd0	0x683a9f3f
+	0x338b5cd3	0x7cd59689	0x2eb11aec	0x74e91cfd
+	0x7ae588aa	0x0eadf94e	0x30a6b42f	0x1965f165
+	0xd96de54b	0x06c85abf	0x1bbc0ab8	0x79f3ddd0
+	0x871fd58d	0x498dd69d	0x9197dd0e	0x6cbb3a4f
+	0x8a1f2a01	0x0d9cf747	0x80e66655	0x770d2b25
+	0x567bd3eb	0x59583c5a	0x58afeddd	0x9296d0e3
+	0xcf5af62c	0xf48b4c78	0x746f657e	0xe543b903
+	0x24603809	0xd1bceeea	0x16d04950	0x2a7c754b
+	0x4ea8bb99	0x9daecb97	0x3045b9a9	0x4a3e84d9
+	0x5487e79f	0xd6145e57	0xc3b17f6f	0x14448bb6
+	0x8e8529f5	0xf895acb9	0x6605c0f0	0x52d00ca9
+	0xabf6e3e9	0x8f36e307	0xa7a15442	0x55144801
+	0x69b028b2	0x8ab3b912	0xb493f80e	0x2dc9fdfa
+	0x1b091fbf	0x1bce6b31	0x79eb414e	0xe5f86ea0
+	0x39ef7dbd	0x2f86faf0	0xec366923	0xe770c7be
+	0x74e4aa61	0xef3b9da0	0xd77bd8be	0xfd13d3cb
+	0x4e8023c6	0x3d993904	0xfcb2f700	0xa14b753b
+	0xde16c1c3	0x983c5a86	0x52ba5e61	0x1d67b044
+	0x0f9a302d	0x2f13b653	0x769cbb97	0xea3e1cbd
+	0x5791778c	0x540fcff1	0x5e6c53f2	0xc9cbac0f
+	0x40ceadf0	0x648713d3	0xb5347ada	0xfe280079
+	0xb8389f3f	0x5a6be26a	0x8e683d28	0x6a3e8e3a
+	0x97ecac7a	0x70b648f1	0xe4eca20e	0x088cd0b4
+	0xbad30405	0x0f77e382	0x673cdf65	0x438af1f0
+	0x0b4f4eea	0xf0cc34e9	0x374a3c04	0x4370d27d
+	0xc3e1e84d	0x141205c2	0xfa831e8d	0x32f2f10a
+	0x77899366	0xc9d07590	0x9b6f2286	0xcac96a03
+	0xf822808b	0x265606cd	0xbeef275d	0x73415b15
+	0x4c87250e	0xf95a8c8a	0xdc8d6166	0x68522e63
+	0xb9becc14	0x7b5f20be	0x3d158dab	0xa73b1716
+	0x3b2cac15	0xf0498939	0xb60653bf	0x33fafc0e
+	0x3b416955	0x3addca50	0x16ab21cf	0xd18cbdb6
+	0x3b29b87b	0xa6fb7e4b	0x6634147f	0x44283b1e
+	0x430ae726	0xa907ab82	0x2baa6706	0x621d2390
+	0x15944559	0x2516c807	0x7d1eeb61	0xe2714121
+	0x288d3998	0x47713cbb	0xa1ce3c1e	0x0c29b6dd
+	0x9923131c	0x2dd19cfa	0x83d0ece5	0x78474c7b
+	0x92dee4f0	0xba5cb0f7	0x780c1d41	0x50da5a89
+	0xe303cebb	0xe8d5a2bd	0x7d6269a9	0xb75484f1
+	0x33ee8186	0x085b7657	0x7b1c7863	0xdb1a43ce
+	0x3d0c4bf0	0x302c1292	0x81e42216	0xee1f2c9d
+	0x822451ab	0xcefd8067	0x8330dc41	0x14492542
+	0xf038f54d	0x90a1abf9	0xc3067a77	0x40d9a42c
+	0x127285c1	0x80ad15ff	0xaf4854e2	0xa47874f4
+	0x2ed59760	0x67252c6a	0xe2830f38	0x8150c00c
+	0x16f61cca	0x1331f815	0x2d832d17	0x163c6010
+	0x69464e2f	0x99940411	0xbce5e85f	0x43d39ef2
+	0x9b7224dc	0x28652b6d	0x331a7632	0x127f669e
+	0x44a034ad	0xe95d2cec	0x3d83fefb	0xfa6d40a2
+	0x9b535bf4	0xc83411ce	0xd661655b	0x64bcd8d2
+	0xd99e1570	0x7dc4d877	0x9756b210	0x7623dc0d
+	0x484dd33f	0xe7bca204	0xa06efbc5	0xa358c03f
+	0x362cb282	0xe40e6d04	0x17ab9f5e	0x79a71a09
+	0x804bf1a9	0x6bca7d73	0x5504a4ff	0xd3946f75
+	0x18b0b9d4	0xd85993cc	0x94d000a5	0x8dda1609
+	0x30afb8f6	0xb3c99c3c	0x7686d59d	0x68b719db
+	0xdc7b3edb	0xedb76012	0xbfa0ba3b	0x280b829d
+	0x72fcf1aa	0xe3d8f83c	0x088a57cf	0x95156217
+	0x3306eb47	0x1d09cf54	0x1391876f	0x5b15ecde
+	0xb46104e1	0x8d8f2593	0x90ee50cc	0x78dad4b2
+	0xfd96daee	0xdbf15e95	0xfc859faa	0xdb4422a5
+	0xa00eeab6	0x525232c6	0x9b665668	0x8a70518b
+	0xbb27f7ac	0xb066b096	0x25754db6	0xe8c7d748
+	0xd4e8d361	0x380dd246	0x9bdf15e6	0x6823c660
+	0x5d408fe7	0xe59a5a89	0x1eb7523b	0x4997158e
+	0xfa6214d2	0x03b35025	0x9aeff33c	0x20a38aad
+	0x522f79cd	0x4141f19c	0xc58cd2bd	0xc816da37
+	0x62c6f8d9	0xc15ea9f4	0x138d1f45	0xd36cef03
+	0x88183bd6	0xe0de9036	0xefcbe8fc	0x5ebdce26
+	0x9e83b01b	0xd35f6747	0x552951f1	0x4e20dd66
+	0x419702b1	0x45446e7c	0x7ce5616b	0x6152e3a8
+	0xffd572e1	0x4fab25b0	0x07563b80	0x98720ee7
+	0x176d29bf	0x21cbd730	0xbde74431	0x09a8cce2
+	0xc15e548e	0xe6a92b4b	0x14f17e74	0x75f7817b
+	0x592143e8	0x113dbd25	0x5f7d7160	0xbdd8b1e0
+	0x6ce045e5	0x53b27b2d	0x371c8aa8	0xa4da8be0
+	0xf1f6df4e	0x9519bac4	0x6d6169cf	0x7846253f
+	0xccb95d95	0x6ad11a98	0x4a3bd21d	0x5389f44c
+	0x7c07ef3a	0xb983ca57	0xcf7f290d	0x4ec516f1
+	0xa7711e70	0x818d45a9	0x49db6441	0xd032fc2a
+	0x657df4d3	0xe37e6809	0x459a22da	0x41df8aa5
+	0x462108a6	0x65177d27	0x1ddffa9f	0x7fa6631b
+	0xdd7a414c	0x6351f0d1	0x1b38a419	0x6b529c8e
+	0x167745e4	0xcac35897	0x3d7bf419	0xd59ed67a
+	0x6486b2c9	0x9ae4fc90	0x8f608920	0xd35335c0
+	0x8f113cba	0x0fcc11a1	0xdc180fbf	0x57a99319
+	0x2c54185f	0x764c18d0	0x4f84b111	0x30a11040
+	0xd15620af	0x496af145	0x263b2de2	0x3ff103dd
+	0x38484dac	0xf143a3bc	0xb62c0de6	0xb122c545
+	0x72f10466	0x63728442	0xee0117c9	0x2309f14b
+	0x4ccdd5de	0x37ae022d	0x2ee7f050	0xf2aa9af6
+	0xcd314a20	0x86954941	0x97215303	0xcd7e1687
+	0x1dab6672	0x1c920209	0x41102dae	0x8b21c8ab
+	0x6f70b04b	0x2988b209	0x86e6f033	0x5eb91718
+	0x925b3c40	0xdcad0288	0x0ee98331	0xc3096ceb
+	0x9fa04740	0x3ce3fb23	0x90d75cbd	0xeab21768
+	0xaca5db0a	0x1c440578	0x762cb728	0x315a699f
+	0xcd2b6490	0x11e3e267	0xa10d1bbc	0x23ac26d3
+	0xc0c7c268	0x37ecf7ac	0x28de6fe5	0x6fb8e3e8
+	0x583d1131	0x8370812a	0x3afd5d58	0x4569a06e
+	0xf27ad86f	0x0db6a631	0x9add5128	0x1748c9fd
+	0xc46e3c57	0x4c0df93e	0xc595c544	0x397f7e7e
+	0x241f4086	0x7d7ed51b	0x56027473	0x656a6110
+	0x970a8011	0xf9c7beb5	0xc6cb9957	0xb7426461
+	0x62d3d89d	0xf99d48ca	0x3e4d4a88	0x9f751b71
+	0xfa020205	0xa3124337	0x59935869	0x98c58314
+	0xff7c4385	0x69191265	0xaf85ebb9	0xe434cda2
+	0xb1ad3e0e	0x221d32e1	0x022d73a0	0xd676ce06
+	0xab7f0c21	0x915c2444	0xf5bdaba2	0x74e4e789
+	0x11ff0d95	0x58c53feb	0xa54eb847	0x9af982ae
+	0x8d721596	0x73510fe4	0x95e3bd19	0xd82f8359
+	0xc09cdd5b	0xc07f57a4	0xbece605b	0xa8a43c5b
+	0x0acbeb6d	0x3c5cd8ce	0xb631050d	0xd558c921
+	0xcb5054c2	0xefb06252	0x40d2e2cc	0x14ffe6ff
+	0x761001a9	0xad64e7a5	0xb55618b4	0x2a40a1fc
+	0x2cbe6d40	0x2bc18fc1	0x196e7092	0x3c137791
+	0xa799eb23	0x1156feb9	0xd55d7ed1	0x0149c315
+	0xae77081f	0xfe724690	0x55ed2fd7	0x04b18cd7
+	0x691583f4	0xb1be4fde	0x19ae1cf7	0x3250140b
+	0x35daeeb2	0xc9459a84	0xea2c19e1	0x57f8c9cb
+	0xe05e07a4	0xcc77a363	0x43afd702	0x48305862
+	0x6c4b459f	0x66ed6178	0x26be9f81	0xeac41ee5
+	0xbe5e2e6b	0x177f9068	0xede56c48	0x438b3811
+	0xd5bd7ee4	0xc027d1a8	0xc1c0f725	0x48d4d4eb
+	0x6ffa28d5	0xbd6ac9eb	0xd497781d	0x24d3a154
+	0x409bb5c0	0x8079bf76	0x90a522dc	0x19bf7033
+	0x1a529b6e	0xe5207e4d	0x3d49b7bc	0x3eca6d54
+	0xa37681a6	0xaa9a62e4	0xe54aa1e1	0xb91e7157
+	0x8cce8f65	0xbcbbd62c	0x7fa477b5	0x44f46b50
+	0x54263fcf	0x529cbb5d	0x8923e390	0x0778d6d7
+	0x0cc0503f	0x02c374ce	0xb89c3e5c	0x25b1b353
+	0xb227cb2d	0x44108698	0x5e5968c2	0x82c48632
+	0x0b8f4209	0x1a241879	0x9edca6f1	0xa1fa51ab
+	0x206db0c6	0xbfbbbe98	0xa71c91f6	0xa1b28056
+	0xb8bfaaa9	0xa5914f75	0x77d26574	0xacfd459d
+	0x77f7cab2	0x249ebf26	0xef902bdd	0x77f6e48d
+	0x82497035	0x93333a9d	0x34ea9953	0x8f08d41c
+	>;
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-coreboot/gpio.h u-boot/arch/x86/include/asm/arch-coreboot/gpio.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-coreboot/gpio.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-coreboot/gpio.h	2015-01-01 17:34:32.253503252 +0100
@@ -7,4 +7,7 @@
 #ifndef _X86_ARCH_GPIO_H_
 #define _X86_ARCH_GPIO_H_
 
+/* Where in config space is the register that points to the GPIO registers? */
+#define PCI_CFG_GPIOBASE 0x48
+
 #endif /* _X86_ARCH_GPIO_H_ */
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-ivybridge/gpio.h u-boot/arch/x86/include/asm/arch-ivybridge/gpio.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-ivybridge/gpio.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-ivybridge/gpio.h	2015-01-01 17:34:32.253503252 +0100
@@ -7,4 +7,7 @@
 #ifndef _X86_ARCH_GPIO_H_
 #define _X86_ARCH_GPIO_H_
 
+/* Where in config space is the register that points to the GPIO registers? */
+#define PCI_CFG_GPIOBASE 0x48
+
 #endif /* _X86_ARCH_GPIO_H_ */
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-ivybridge/pei_data.h u-boot/arch/x86/include/asm/arch-ivybridge/pei_data.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-ivybridge/pei_data.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-ivybridge/pei_data.h	2015-01-01 17:34:32.253503252 +0100
@@ -7,6 +7,8 @@
 #ifndef ASM_ARCH_PEI_DATA_H
 #define ASM_ARCH_PEI_DATA_H
 
+#include <linux/linkage.h>
+
 struct pch_usb3_controller_settings {
 	/* 0: Disable, 1: Enable, 2: Auto, 3: Smart Auto */
 	uint16_t mode;
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_api.h u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_api.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_api.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_api.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#ifndef __FSP_API_H__
+#define __FSP_API_H__
+
+/*
+ * FspInit continuation function prototype.
+ * Control will be returned to this callback function after FspInit API call.
+ */
+typedef void (*fsp_continuation_f)(u32 status, void *hob_list);
+
+struct fsp_init_params {
+	/* Non-volatile storage buffer pointer */
+	void			*nvs_buf;
+	/* Runtime buffer pointer */
+	void			*rt_buf;
+	/* Continuation function address */
+	fsp_continuation_f	continuation;
+};
+
+struct common_buf {
+	/*
+	 * Stack top pointer used by the bootloader. The new stack frame will be
+	 * set up at this location after FspInit API call.
+	 */
+	u32	*stack_top;
+	u32	boot_mode;	/* Current system boot mode */
+	void	*upd_data;	/* User platform configuraiton data region */
+	u32	reserved[7];	/* Reserved */
+};
+
+enum fsp_phase {
+	/* Notification code for post PCI enuermation */
+	INIT_PHASE_PCI	= 0x20,
+	/* Notification code before transfering control to the payload */
+	INIT_PHASE_BOOT	= 0x40
+};
+
+struct fsp_notify_params {
+	/* Notification phase used for NotifyPhase API */
+	enum fsp_phase	phase;
+};
+
+/* FspInit API function prototype */
+typedef u32 (*fsp_init_f)(struct fsp_init_params *params);
+
+/* FspNotify API function prototype */
+typedef u32 (*fsp_notify_f)(struct fsp_notify_params *params);
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_bootmode.h u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_bootmode.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_bootmode.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_bootmode.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#ifndef __FSP_BOOT_MODE_H__
+#define __FSP_BOOT_MODE_H__
+
+/* 0x21 - 0xf..f are reserved */
+#define BOOT_FULL_CONFIG		0x00
+#define BOOT_MINIMAL_CONFIG		0x01
+#define BOOT_NO_CONFIG_CHANGES		0x02
+#define BOOT_FULL_CONFIG_PLUS_DIAG	0x03
+#define BOOT_DEFAULT_SETTINGS		0x04
+#define BOOT_ON_S4_RESUME		0x05
+#define BOOT_ON_S5_RESUME		0x06
+#define BOOT_ON_S2_RESUME		0x10
+#define BOOT_ON_S3_RESUME		0x11
+#define BOOT_ON_FLASH_UPDATE		0x12
+#define BOOT_IN_RECOVERY_MODE		0x20
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_ffs.h u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_ffs.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_ffs.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_ffs.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#ifndef __FSP_FFS_H__
+#define __FSP_FFS_H__
+
+/* Used to verify the integrity of the file */
+union __packed ffs_integrity {
+	struct {
+		/*
+		 * The IntegrityCheck.checksum.header field is an 8-bit
+		 * checksum of the file header. The State and
+		 * IntegrityCheck.checksum.file fields are assumed to be zero
+		 * and the checksum is calculated such that the entire header
+		 * sums to zero.
+		 */
+		u8	header;
+		/*
+		 * If the FFS_ATTRIB_CHECKSUM (see definition below) bit of
+		 * the Attributes field is set to one, the
+		 * IntegrityCheck.checksum.file field is an 8-bit checksum of
+		 * the file data. If the FFS_ATTRIB_CHECKSUM bit of the
+		 * Attributes field is cleared to zero, the
+		 * IntegrityCheck.checksum.file field must be initialized with
+		 * a value of 0xAA. The IntegrityCheck.checksum.file field is
+		 * valid any time the EFI_FILE_DATA_VALID bit is set in the
+		 * State field.
+		 */
+		u8	file;
+	} checksum;
+
+	/* This is the full 16 bits of the IntegrityCheck field */
+	u16	checksum16;
+};
+
+/*
+ * Each file begins with the header that describe the
+ * contents and state of the files.
+ */
+struct __packed ffs_file_header {
+	/*
+	 * This GUID is the file name.
+	 * It is used to uniquely identify the file.
+	 */
+	struct efi_guid		name;
+	/* Used to verify the integrity of the file */
+	union ffs_integrity	integrity;
+	/* Identifies the type of file */
+	u8			type;
+	/* Declares various file attribute bits */
+	u8			attr;
+	/* The length of the file in bytes, including the FFS header */
+	u8			size[3];
+	/*
+	 * Used to track the state of the file throughout the life of
+	 * the file from creation to deletion.
+	 */
+	u8			state;
+};
+
+struct __packed ffs_file_header2 {
+	/*
+	 * This GUID is the file name. It is used to uniquely identify the file.
+	 * There may be only one instance of a file with the file name GUID of
+	 * Name in any given firmware volume, except if the file type is
+	 * EFI_FV_FILE_TYPE_FFS_PAD.
+	 */
+	struct efi_guid		name;
+	/* Used to verify the integrity of the file */
+	union ffs_integrity	integrity;
+	/* Identifies the type of file */
+	u8			type;
+	/* Declares various file attribute bits */
+	u8			attr;
+	/*
+	 * The length of the file in bytes, including the FFS header.
+	 * The length of the file data is either
+	 * (size - sizeof(struct ffs_file_header)). This calculation means a
+	 * zero-length file has a size of 24 bytes, which is
+	 * sizeof(struct ffs_file_header). Size is not required to be a
+	 * multiple of 8 bytes. Given a file F, the next file header is located
+	 * at the next 8-byte aligned firmware volume offset following the last
+	 * byte of the file F.
+	 */
+	u8			size[3];
+	/*
+	 * Used to track the state of the file throughout the life of
+	 * the file from creation to deletion.
+	 */
+	u8			state;
+	/*
+	 * If FFS_ATTRIB_LARGE_FILE is set in attr, then ext_size exists
+	 * and size must be set to zero.
+	 * If FFS_ATTRIB_LARGE_FILE is not set then
+	 * struct ffs_file_header is used.
+	 */
+	u32			ext_size;
+};
+
+/*
+ * Pseudo type. It is used as a wild card when retrieving sections.
+ * The section type EFI_SECTION_ALL matches all section types.
+ */
+#define EFI_SECTION_ALL				0x00
+
+/* Encapsulation section Type values */
+#define EFI_SECTION_COMPRESSION			0x01
+#define EFI_SECTION_GUID_DEFINED		0x02
+#define EFI_SECTION_DISPOSABLE			0x03
+
+/* Leaf section Type values */
+#define EFI_SECTION_PE32			0x10
+#define EFI_SECTION_PIC				0x11
+#define EFI_SECTION_TE				0x12
+#define EFI_SECTION_DXE_DEPEX			0x13
+#define EFI_SECTION_VERSION			0x14
+#define EFI_SECTION_USER_INTERFACE		0x15
+#define EFI_SECTION_COMPATIBILITY16		0x16
+#define EFI_SECTION_FIRMWARE_VOLUME_IMAGE	0x17
+#define EFI_SECTION_FREEFORM_SUBTYPE_GUID	0x18
+#define EFI_SECTION_RAW				0x19
+#define EFI_SECTION_PEI_DEPEX			0x1B
+#define EFI_SECTION_SMM_DEPEX			0x1C
+
+/* Common section header */
+struct __packed raw_section {
+	/*
+	 * A 24-bit unsigned integer that contains the total size of
+	 * the section in bytes, including the EFI_COMMON_SECTION_HEADER.
+	 */
+	u8	size[3];
+	u8	type;
+};
+
+struct __packed raw_section2 {
+	/*
+	 * A 24-bit unsigned integer that contains the total size of
+	 * the section in bytes, including the EFI_COMMON_SECTION_HEADER.
+	 */
+	u8	size[3];
+	u8	type;
+	/*
+	 * If size is 0xFFFFFF, then ext_size contains the size of
+	 * the section. If size is not equal to 0xFFFFFF, then this
+	 * field does not exist.
+	 */
+	u32	ext_size;
+};
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_fv.h u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_fv.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_fv.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_fv.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#ifndef __FSP_FV___
+#define __FSP_FV___
+
+/* Value of EFI_FV_FILE_ATTRIBUTES */
+#define EFI_FV_FILE_ATTR_ALIGNMENT	0x0000001F
+#define EFI_FV_FILE_ATTR_FIXED		0x00000100
+#define EFI_FV_FILE_ATTR_MEMORY_MAPPED	0x00000200
+
+/* Attributes bit definitions */
+#define EFI_FVB2_READ_DISABLED_CAP	0x00000001
+#define EFI_FVB2_READ_ENABLED_CAP	0x00000002
+#define EFI_FVB2_READ_STATUS		0x00000004
+#define EFI_FVB2_WRITE_DISABLED_CAP	0x00000008
+#define EFI_FVB2_WRITE_ENABLED_CAP	0x00000010
+#define EFI_FVB2_WRITE_STATUS		0x00000020
+#define EFI_FVB2_LOCK_CAP		0x00000040
+#define EFI_FVB2_LOCK_STATUS		0x00000080
+#define EFI_FVB2_STICKY_WRITE		0x00000200
+#define EFI_FVB2_MEMORY_MAPPED		0x00000400
+#define EFI_FVB2_ERASE_POLARITY		0x00000800
+#define EFI_FVB2_READ_LOCK_CAP		0x00001000
+#define EFI_FVB2_READ_LOCK_STATUS	0x00002000
+#define EFI_FVB2_WRITE_LOCK_CAP		0x00004000
+#define EFI_FVB2_WRITE_LOCK_STATUS	0x00008000
+#define EFI_FVB2_ALIGNMENT		0x001F0000
+#define EFI_FVB2_ALIGNMENT_1		0x00000000
+#define EFI_FVB2_ALIGNMENT_2		0x00010000
+#define EFI_FVB2_ALIGNMENT_4		0x00020000
+#define EFI_FVB2_ALIGNMENT_8		0x00030000
+#define EFI_FVB2_ALIGNMENT_16		0x00040000
+#define EFI_FVB2_ALIGNMENT_32		0x00050000
+#define EFI_FVB2_ALIGNMENT_64		0x00060000
+#define EFI_FVB2_ALIGNMENT_128		0x00070000
+#define EFI_FVB2_ALIGNMENT_256		0x00080000
+#define EFI_FVB2_ALIGNMENT_512		0x00090000
+#define EFI_FVB2_ALIGNMENT_1K		0x000A0000
+#define EFI_FVB2_ALIGNMENT_2K		0x000B0000
+#define EFI_FVB2_ALIGNMENT_4K		0x000C0000
+#define EFI_FVB2_ALIGNMENT_8K		0x000D0000
+#define EFI_FVB2_ALIGNMENT_16K		0x000E0000
+#define EFI_FVB2_ALIGNMENT_32K		0x000F0000
+#define EFI_FVB2_ALIGNMENT_64K		0x00100000
+#define EFI_FVB2_ALIGNMENT_128K		0x00110000
+#define EFI_FVB2_ALIGNMENT_256K		0x00120000
+#define EFI_FVB2_ALIGNMENT_512K		0x00130000
+#define EFI_FVB2_ALIGNMENT_1M		0x00140000
+#define EFI_FVB2_ALIGNMENT_2M		0x00150000
+#define EFI_FVB2_ALIGNMENT_4M		0x00160000
+#define EFI_FVB2_ALIGNMENT_8M		0x00170000
+#define EFI_FVB2_ALIGNMENT_16M		0x00180000
+#define EFI_FVB2_ALIGNMENT_32M		0x00190000
+#define EFI_FVB2_ALIGNMENT_64M		0x001A0000
+#define EFI_FVB2_ALIGNMENT_128M		0x001B0000
+#define EFI_FVB2_ALIGNMENT_256M		0x001C0000
+#define EFI_FVB2_ALIGNMENT_512M		0x001D0000
+#define EFI_FVB2_ALIGNMENT_1G		0x001E0000
+#define EFI_FVB2_ALIGNMENT_2G		0x001F0000
+
+struct fv_blkmap_entry {
+	/* The number of sequential blocks which are of the same size */
+	u32	num_blocks;
+	/* The size of the blocks */
+	u32	length;
+};
+
+/* Describes the features and layout of the firmware volume */
+struct fv_header {
+	/*
+	 * The first 16 bytes are reserved to allow for the reset vector of
+	 * processors whose reset vector is at address 0.
+	 */
+	u8			zero_vec[16];
+	/*
+	 * Declares the file system with which the firmware volume
+	 * is formatted.
+	 */
+	struct efi_guid		fs_guid;
+	/*
+	 * Length in bytes of the complete firmware volume, including
+	 * the header.
+	 */
+	u64			fv_len;
+	/* Set to EFI_FVH_SIGNATURE */
+	u32			sign;
+	/*
+	 * Declares capabilities and power-on defaults for the firmware
+	 * volume.
+	 */
+	u32			attr;
+	/* Length in bytes of the complete firmware volume header */
+	u16			hdr_len;
+	/*
+	 * A 16-bit checksum of the firmware volume header.
+	 * A valid header sums to zero.
+	 */
+	u16			checksum;
+	/*
+	 * Offset, relative to the start of the header, of the extended
+	 * header (EFI_FIRMWARE_VOLUME_EXT_HEADER) or zero if there is
+	 * no extended header.
+	 */
+	u16			ext_hdr_off;
+	/* This field must always be set to zero */
+	u8			reserved[1];
+	/*
+	 * Set to 2. Future versions of this specification may define new
+	 * header fields and will increment the Revision field accordingly.
+	 */
+	u8			rev;
+	/*
+	 * An array of run-length encoded FvBlockMapEntry structures.
+	 * The array is terminated with an entry of {0,0}.
+	 */
+	struct fv_blkmap_entry	block_map[1];
+};
+
+#define EFI_FVH_SIGNATURE	SIGNATURE_32('_', 'F', 'V', 'H')
+
+/* Firmware Volume Header Revision definition */
+#define EFI_FVH_REVISION	0x02
+
+/* Extension header pointed by ExtHeaderOffset of volume header */
+struct fv_ext_header {
+	/* firmware volume name */
+	struct efi_guid		fv_name;
+	/* Size of the rest of the extension header including this structure */
+	u32			ext_hdr_size;
+};
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_hob.h u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_hob.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_hob.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_hob.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,340 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#ifndef __FSP_HOB_H__
+#define __FSP_HOB_H__
+
+/* Type of HOB Header */
+#define HOB_TYPE_MEM_ALLOC	0x0002
+#define HOB_TYPE_RES_DESC	0x0003
+#define HOB_TYPE_GUID_EXT	0x0004
+#define HOB_TYPE_UNUSED		0xFFFE
+#define HOB_TYPE_EOH		0xFFFF
+
+/*
+ * Describes the format and size of the data inside the HOB.
+ * All HOBs must contain this generic HOB header.
+ */
+struct hob_header {
+	u16	type;		/* HOB type */
+	u16	len;		/* HOB length */
+	u32	reserved;	/* always zero */
+};
+
+/* Enumeration of memory types introduced in UEFI */
+enum efi_mem_type {
+	EFI_RESERVED_MEMORY_TYPE,
+	/*
+	 * The code portions of a loaded application.
+	 * (Note that UEFI OS loaders are UEFI applications.)
+	 */
+	EFI_LOADER_CODE,
+	/*
+	 * The data portions of a loaded application and
+	 * the default data allocation type used by an application
+	 * to allocate pool memory.
+	 */
+	EFI_LOADER_DATA,
+	/* The code portions of a loaded Boot Services Driver */
+	EFI_BOOT_SERVICES_CODE,
+	/*
+	 * The data portions of a loaded Boot Serves Driver and
+	 * the default data allocation type used by a Boot Services
+	 * Driver to allocate pool memory.
+	 */
+	EFI_BOOT_SERVICES_DATA,
+	/* The code portions of a loaded Runtime Services Driver */
+	EFI_RUNTIME_SERVICES_CODE,
+	/*
+	 * The data portions of a loaded Runtime Services Driver and
+	 * the default data allocation type used by a Runtime Services
+	 * Driver to allocate pool memory.
+	 */
+	EFI_RUNTIME_SERVICES_DATA,
+	/* Free (unallocated) memory */
+	EFI_CONVENTIONAL_MEMORY,
+	/* Memory in which errors have been detected */
+	EFI_UNUSABLE_MEMORY,
+	/* Memory that holds the ACPI tables */
+	EFI_ACPI_RECLAIM_MEMORY,
+	/* Address space reserved for use by the firmware */
+	EFI_ACPI_MEMORY_NVS,
+	/*
+	 * Used by system firmware to request that a memory-mapped IO region
+	 * be mapped by the OS to a virtual address so it can be accessed by
+	 * EFI runtime services.
+	 */
+	EFI_MMAP_IO,
+	/*
+	 * System memory-mapped IO region that is used to translate
+	 * memory cycles to IO cycles by the processor.
+	 */
+	EFI_MMAP_IO_PORT,
+	/*
+	 * Address space reserved by the firmware for code that is
+	 * part of the processor.
+	 */
+	EFI_PAL_CODE,
+	EFI_MAX_MEMORY_TYPE
+};
+
+/*
+ * Describes all memory ranges used during the HOB producer phase that
+ * exist outside the HOB list. This HOB type describes how memory is used,
+ * not the physical attributes of memory.
+ */
+struct hob_mem_alloc {
+	struct hob_header	hdr;
+	/*
+	 * A GUID that defines the memory allocation region's type and purpose,
+	 * as well as other fields within the memory allocation HOB. This GUID
+	 * is used to define the additional data within the HOB that may be
+	 * present for the memory allocation HOB. Type efi_guid is defined in
+	 * InstallProtocolInterface() in the UEFI 2.0 specification.
+	 */
+	struct efi_guid		name;
+	/*
+	 * The base address of memory allocated by this HOB.
+	 * Type phys_addr_t is defined in AllocatePages() in the UEFI 2.0
+	 * specification.
+	 */
+	phys_addr_t		mem_base;
+	/* The length in bytes of memory allocated by this HOB */
+	phys_size_t		mem_len;
+	/*
+	 * Defines the type of memory allocated by this HOB.
+	 * The memory type definition follows the EFI_MEMORY_TYPE definition.
+	 * Type EFI_MEMORY_TYPE is defined in AllocatePages() in the UEFI 2.0
+	 * specification.
+	 */
+	enum efi_mem_type	mem_type;
+	/* padding */
+	u8			reserved[4];
+};
+
+/* Value of ResourceType in HOB_RES_DESC */
+#define RES_SYS_MEM		0x00000000
+#define RES_MMAP_IO		0x00000001
+#define RES_IO			0x00000002
+#define RES_FW_DEVICE		0x00000003
+#define RES_MMAP_IO_PORT	0x00000004
+#define RES_MEM_RESERVED	0x00000005
+#define RES_IO_RESERVED		0x00000006
+#define RES_MAX_MEM_TYPE	0x00000007
+
+/*
+ * These types can be ORed together as needed.
+ *
+ * The first three enumerations describe settings
+ * The rest of the settings describe capabilities
+ */
+#define RES_ATTR_PRESENT			0x00000001
+#define RES_ATTR_INITIALIZED			0x00000002
+#define RES_ATTR_TESTED				0x00000004
+#define RES_ATTR_SINGLE_BIT_ECC			0x00000008
+#define RES_ATTR_MULTIPLE_BIT_ECC		0x00000010
+#define RES_ATTR_ECC_RESERVED_1			0x00000020
+#define RES_ATTR_ECC_RESERVED_2			0x00000040
+#define RES_ATTR_READ_PROTECTED			0x00000080
+#define RES_ATTR_WRITE_PROTECTED		0x00000100
+#define RES_ATTR_EXECUTION_PROTECTED		0x00000200
+#define RES_ATTR_UNCACHEABLE			0x00000400
+#define RES_ATTR_WRITE_COMBINEABLE		0x00000800
+#define RES_ATTR_WRITE_THROUGH_CACHEABLE	0x00001000
+#define RES_ATTR_WRITE_BACK_CACHEABLE		0x00002000
+#define RES_ATTR_16_BIT_IO			0x00004000
+#define RES_ATTR_32_BIT_IO			0x00008000
+#define RES_ATTR_64_BIT_IO			0x00010000
+#define RES_ATTR_UNCACHED_EXPORTED		0x00020000
+
+/*
+ * Describes the resource properties of all fixed, nonrelocatable resource
+ * ranges found on the processor host bus during the HOB producer phase.
+ */
+struct hob_res_desc {
+	struct hob_header	hdr;
+	/*
+	 * A GUID representing the owner of the resource. This GUID is
+	 * used by HOB consumer phase components to correlate device
+	 * ownership of a resource.
+	 */
+	struct efi_guid		owner;
+	u32			type;
+	u32			attr;
+	/* The physical start address of the resource region */
+	phys_addr_t		phys_start;
+	/* The number of bytes of the resource region */
+	phys_size_t		len;
+};
+
+/*
+ * Allows writers of executable content in the HOB producer phase to
+ * maintain and manage HOBs with specific GUID.
+ */
+struct hob_guid {
+	struct hob_header	hdr;
+	/* A GUID that defines the contents of this HOB */
+	struct efi_guid		name;
+	/* GUID specific data goes here */
+};
+
+/* Union of all the possible HOB Types */
+union hob_pointers {
+	struct hob_header	*hdr;
+	struct hob_mem_alloc	*mem_alloc;
+	struct hob_res_desc	*res_desc;
+	struct hob_guid		*guid;
+	u8			*raw;
+};
+
+/**
+ * get_hob_type() - return the type of a HOB
+ *
+ * This macro returns the type field from the HOB header for the
+ * HOB specified by hob.
+ *
+ * @hob:    A pointer to a HOB.
+ *
+ * @return: HOB type.
+ */
+static inline u16 get_hob_type(union hob_pointers hob)
+{
+	return hob.hdr->type;
+}
+
+/**
+ * get_hob_length() - return the length, in bytes, of a HOB
+ *
+ * This macro returns the len field from the HOB header for the
+ * HOB specified by hob.
+ *
+ * @hob:    A pointer to a HOB.
+ *
+ * @return: HOB length.
+ */
+static inline u16 get_hob_length(union hob_pointers hob)
+{
+	return hob.hdr->len;
+}
+
+/**
+ * get_next_hob() - return a pointer to the next HOB in the HOB list
+ *
+ * This macro returns a pointer to HOB that follows the HOB specified by hob
+ * in the HOB List.
+ *
+ * @hob:    A pointer to a HOB.
+ *
+ * @return: A pointer to the next HOB in the HOB list.
+ */
+static inline void *get_next_hob(union hob_pointers hob)
+{
+	return (void *)(*(u8 **)&(hob) + get_hob_length(hob));
+}
+
+/**
+ * end_of_hob() - determine if a HOB is the last HOB in the HOB list
+ *
+ * This macro determine if the HOB specified by hob is the last HOB in the
+ * HOB list.  If hob is last HOB in the HOB list, then true is returned.
+ * Otherwise, false is returned.
+ *
+ * @hob:          A pointer to a HOB.
+ *
+ * @retval true:  The HOB specified by hob is the last HOB in the HOB list.
+ * @retval false: The HOB specified by hob is not the last HOB in the HOB list.
+ */
+static inline bool end_of_hob(union hob_pointers hob)
+{
+	return get_hob_type(hob) == HOB_TYPE_EOH;
+}
+
+/**
+ * get_guid_hob_data() - return a pointer to data buffer from a HOB of
+ *                       type HOB_TYPE_GUID_EXT
+ *
+ * This macro returns a pointer to the data buffer in a HOB specified by hob.
+ * hob is assumed to be a HOB of type HOB_TYPE_GUID_EXT.
+ *
+ * @hob:    A pointer to a HOB.
+ *
+ * @return: A pointer to the data buffer in a HOB.
+ */
+static inline void *get_guid_hob_data(u8 *hob)
+{
+	return (void *)(hob + sizeof(struct hob_guid));
+}
+
+/**
+ * get_guid_hob_data_size() - return the size of the data buffer from a HOB
+ *                            of type HOB_TYPE_GUID_EXT
+ *
+ * This macro returns the size, in bytes, of the data buffer in a HOB
+ * specified by hob. hob is assumed to be a HOB of type HOB_TYPE_GUID_EXT.
+ *
+ * @hob:    A pointer to a HOB.
+ *
+ * @return: The size of the data buffer.
+ */
+static inline u16 get_guid_hob_data_size(u8 *hob)
+{
+	union hob_pointers hob_p = *(union hob_pointers *)hob;
+	return get_hob_length(hob_p) - sizeof(struct hob_guid);
+}
+
+/* FSP specific GUID HOB definitions */
+#define FSP_GUID_DATA1		0x912740be
+#define FSP_GUID_DATA2		0x2284
+#define FSP_GUID_DATA3		0x4734
+#define FSP_GUID_DATA4_0	0xb9
+#define FSP_GUID_DATA4_1	0x71
+#define FSP_GUID_DATA4_2	0x84
+#define FSP_GUID_DATA4_3	0xb0
+#define FSP_GUID_DATA4_4	0x27
+#define FSP_GUID_DATA4_5	0x35
+#define FSP_GUID_DATA4_6	0x3f
+#define FSP_GUID_DATA4_7	0x0c
+
+#define FSP_HEADER_GUID \
+	{ \
+	FSP_GUID_DATA1, FSP_GUID_DATA2, FSP_GUID_DATA3, \
+	{ FSP_GUID_DATA4_0, FSP_GUID_DATA4_1, FSP_GUID_DATA4_2, \
+	  FSP_GUID_DATA4_3, FSP_GUID_DATA4_4, FSP_GUID_DATA4_5, \
+	  FSP_GUID_DATA4_6, FSP_GUID_DATA4_7 } \
+	}
+
+#define FSP_NON_VOLATILE_STORAGE_HOB_GUID \
+	{ \
+	0x721acf02, 0x4d77, 0x4c2a, \
+	{ 0xb3, 0xdc, 0x27, 0xb, 0x7b, 0xa9, 0xe4, 0xb0 } \
+	}
+
+#define FSP_BOOTLOADER_TEMP_MEM_HOB_GUID \
+	{ \
+	0xbbcff46c, 0xc8d3, 0x4113, \
+	{ 0x89, 0x85, 0xb9, 0xd4, 0xf3, 0xb3, 0xf6, 0x4e } \
+	}
+
+#define FSP_HOB_RESOURCE_OWNER_FSP_GUID \
+	{ \
+	0x69a79759, 0x1373, 0x4367, \
+	{ 0xa6, 0xc4, 0xc7, 0xf5, 0x9e, 0xfd, 0x98, 0x6e } \
+	}
+
+#define FSP_HOB_RESOURCE_OWNER_TSEG_GUID \
+	{ \
+	0xd038747c, 0xd00c, 0x4980, \
+	{ 0xb3, 0x19, 0x49, 0x01, 0x99, 0xa4, 0x7d, 0x55 } \
+	}
+
+#define FSP_HOB_RESOURCE_OWNER_GRAPHICS_GUID \
+	{ \
+	0x9c7c3aa7, 0x5332, 0x4917, \
+	{ 0x82, 0xb9, 0x56, 0xa5, 0xf3, 0xe6, 0x2a, 0x07 } \
+	}
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_infoheader.h u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_infoheader.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_infoheader.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_infoheader.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#ifndef _FSP_HEADER_H_
+#define _FSP_HEADER_H_
+
+#define FSP_HEADER_OFF	0x94	/* Fixed FSP header offset in the FSP image */
+
+struct __packed fsp_header {
+	u32	sign;			/* 'FSPH' */
+	u32	hdr_len;		/* header length */
+	u8	reserved1[3];
+	u8	hdr_rev;		/* header rev */
+	u32	img_rev;		/* image rev */
+	char	img_id[8];		/* signature string */
+	u32	img_size;		/* image size */
+	u32	img_base;		/* image base */
+	u32	img_attr;		/* image attribute */
+	u32	cfg_region_off;		/* configuration region offset */
+	u32	cfg_region_size;	/* configuration region size */
+	u32	api_num;		/* number of API entries */
+	u32	fsp_tempram_init;	/* tempram_init offset */
+	u32	fsp_init;		/* fsp_init offset */
+	u32	fsp_notify;		/* fsp_notify offset */
+	u32	reserved2;
+};
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_platform.h u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_platform.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_platform.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_platform.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,15 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#ifndef __FSP_PLATFORM_H__
+#define __FSP_PLATFORM_H__
+
+struct fspinit_rtbuf {
+	struct common_buf	common;	/* FSP common runtime data structure */
+};
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_support.h u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_support.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_support.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_support.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#ifndef __FSP_SUPPORT_H__
+#define __FSP_SUPPORT_H__
+
+#include "fsp_types.h"
+#include "fsp_fv.h"
+#include "fsp_ffs.h"
+#include "fsp_api.h"
+#include "fsp_hob.h"
+#include "fsp_platform.h"
+#include "fsp_infoheader.h"
+#include "fsp_bootmode.h"
+#include "fsp_vpd.h"
+
+struct shared_data {
+	struct fsp_header	*fsp_hdr;
+	u32			*stack_top;
+	struct upd_region	fsp_upd;
+};
+
+#define FSP_LOWMEM_BASE		0x100000UL
+#define FSP_HIGHMEM_BASE	0x100000000ULL
+
+/**
+ * FSP Continuation assembly helper routine
+ *
+ * This routine jumps to the C version of FSP continuation function
+ */
+void asm_continuation(void);
+
+/**
+ * FSP initialization complete
+ *
+ * This is the function that indicates FSP initialization is complete and jumps
+ * back to the bootloader with HOB list pointer as the parameter.
+ *
+ * @hob_list:    HOB list pointer
+ */
+void fsp_init_done(void *hob_list);
+
+/**
+ * FSP Continuation function
+ *
+ * @shared_data: Shared data base before stack migration
+ * @status:      Always 0
+ * @hob_list:    HOB list pointer
+ *
+ * @retval:      Never returns
+ */
+void fsp_continue(struct shared_data *shared_data, u32 status,
+		  void *hob_list);
+
+/**
+ * Find FSP header offset in FSP image
+ *
+ * @retval: the offset of FSP header. If signature is invalid, returns 0.
+ */
+u32 find_fsp_header(void);
+
+/**
+ * FSP initialization wrapper function.
+ *
+ * @stack_top: bootloader stack top address
+ * @boot_mode: boot mode defined in fsp_bootmode.h
+ * @nvs_buf:   Non-volatile memory buffer pointer
+ */
+void fsp_init(u32 stack_top, u32 boot_mode, void *nvs_buf);
+
+/**
+ * FSP notification wrapper function
+ *
+ * @fsp_hdr: Pointer to FSP information header
+ * @phase:   FSP initialization phase defined in enum fsp_phase
+ *
+ * @retval:  compatible status code with EFI_STATUS defined in PI spec
+ */
+u32 fsp_notify(struct fsp_header *fsp_hdr, u32 phase);
+
+/**
+ * This function retrieves the top of usable low memory.
+ *
+ * @hob_list: A HOB list pointer.
+ *
+ * @retval:   Usable low memory top.
+ */
+u32 fsp_get_usable_lowmem_top(const void *hob_list);
+
+/**
+ * This function retrieves the top of usable high memory.
+ *
+ * @hob_list: A HOB list pointer.
+ *
+ * @retval:   Usable high memory top.
+ */
+u64 fsp_get_usable_highmem_top(const void *hob_list);
+
+/**
+ * This function retrieves a special reserved memory region.
+ *
+ * @hob_list: A HOB list pointer.
+ * @len:      A pointer to the GUID HOB data buffer length.
+ *            If the GUID HOB is located, the length will be updated.
+ * @guid:     A pointer to the owner guild.
+ *
+ * @retval:   Reserved region start address.
+ *            0 if this region does not exist.
+ */
+u64 fsp_get_reserved_mem_from_guid(const void *hob_list,
+				   u64 *len, struct efi_guid *guid);
+
+/**
+ * This function retrieves the FSP reserved normal memory.
+ *
+ * @hob_list: A HOB list pointer.
+ * @len:      A pointer to the FSP reserved memory length buffer.
+ *            If the GUID HOB is located, the length will be updated.
+ * @retval:   FSP reserved memory base
+ *            0 if this region does not exist.
+ */
+u32 fsp_get_fsp_reserved_mem(const void *hob_list, u32 *len);
+
+/**
+ * This function retrieves the TSEG reserved normal memory.
+ *
+ * @hob_list:      A HOB list pointer.
+ * @len:           A pointer to the TSEG reserved memory length buffer.
+ *                 If the GUID HOB is located, the length will be updated.
+ *
+ * @retval NULL:   Failed to find the TSEG reserved memory.
+ * @retval others: TSEG reserved memory base.
+ */
+u32 fsp_get_tseg_reserved_mem(const void *hob_list, u32 *len);
+
+/**
+ * Returns the next instance of a HOB type from the starting HOB.
+ *
+ * @type:     HOB type to search
+ * @hob_list: A pointer to the HOB list
+ *
+ * @retval:   A HOB object with matching type; Otherwise NULL.
+ */
+void *fsp_get_next_hob(u16 type, const void *hob_list);
+
+/**
+ * Returns the next instance of the matched GUID HOB from the starting HOB.
+ *
+ * @guid:     GUID to search
+ * @hob_list: A pointer to the HOB list
+ *
+ * @retval:   A HOB object with matching GUID; Otherwise NULL.
+ */
+void *fsp_get_next_guid_hob(const struct efi_guid *guid, const void *hob_list);
+
+/**
+ * This function retrieves a GUID HOB data buffer and size.
+ *
+ * @hob_list:      A HOB list pointer.
+ * @len:           A pointer to the GUID HOB data buffer length.
+ *                 If the GUID HOB is located, the length will be updated.
+ * @guid           A pointer to HOB GUID.
+ *
+ * @retval NULL:   Failed to find the GUID HOB.
+ * @retval others: GUID HOB data buffer pointer.
+ */
+void *fsp_get_guid_hob_data(const void *hob_list, u32 *len,
+			    struct efi_guid *guid);
+
+/**
+ * This function retrieves FSP Non-volatile Storage HOB buffer and size.
+ *
+ * @hob_list:      A HOB list pointer.
+ * @len:           A pointer to the NVS data buffer length.
+ *                 If the HOB is located, the length will be updated.
+ *
+ * @retval NULL:   Failed to find the NVS HOB.
+ * @retval others: FSP NVS data buffer pointer.
+ */
+void *fsp_get_nvs_data(const void *hob_list, u32 *len);
+
+/**
+ * This function retrieves Bootloader temporary stack buffer and size.
+ *
+ * @hob_list:      A HOB list pointer.
+ * @len:           A pointer to the bootloader temporary stack length.
+ *                 If the HOB is located, the length will be updated.
+ *
+ * @retval NULL:   Failed to find the bootloader temporary stack HOB.
+ * @retval others: Bootloader temporary stackbuffer pointer.
+ */
+void *fsp_get_bootloader_tmp_mem(const void *hob_list, u32 *len);
+
+/**
+ * This function overrides the default configurations in the UPD data region.
+ *
+ * @fsp_upd: A pointer to the upd_region data strcture
+ *
+ * @return:  None
+ */
+void update_fsp_upd(struct upd_region *fsp_upd);
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_types.h u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_types.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_types.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_types.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#ifndef __FSP_TYPES_H__
+#define __FSP_TYPES_H__
+
+/* 128 bit buffer containing a unique identifier value */
+struct efi_guid {
+	u32	data1;
+	u16	data2;
+	u16	data3;
+	u8	data4[8];
+};
+
+/**
+ * Returns a 16-bit signature built from 2 ASCII characters.
+ *
+ * This macro returns a 16-bit value built from the two ASCII characters
+ * specified by A and B.
+ *
+ * @A: The first ASCII character.
+ * @B: The second ASCII character.
+ *
+ * @return: A 16-bit value built from the two ASCII characters specified by
+ *          A and B.
+ */
+#define SIGNATURE_16(A, B)	((A) | (B << 8))
+
+/**
+ * Returns a 32-bit signature built from 4 ASCII characters.
+ *
+ * This macro returns a 32-bit value built from the four ASCII characters
+ * specified by A, B, C, and D.
+ *
+ * @A: The first ASCII character.
+ * @B: The second ASCII character.
+ * @C: The third ASCII character.
+ * @D: The fourth ASCII character.
+ *
+ * @return: A 32-bit value built from the two ASCII characters specified by
+ *          A, B, C and D.
+ */
+#define SIGNATURE_32(A, B, C, D)	\
+	(SIGNATURE_16(A, B) | (SIGNATURE_16(C, D) << 16))
+
+/**
+ * Returns a 64-bit signature built from 8 ASCII characters.
+ *
+ * This macro returns a 64-bit value built from the eight ASCII characters
+ * specified by A, B, C, D, E, F, G,and H.
+ *
+ * @A: The first ASCII character.
+ * @B: The second ASCII character.
+ * @C: The third ASCII character.
+ * @D: The fourth ASCII character.
+ * @E: The fifth ASCII character.
+ * @F: The sixth ASCII character.
+ * @G: The seventh ASCII character.
+ * @H: The eighth ASCII character.
+ *
+ * @return: A 64-bit value built from the two ASCII characters specified by
+ *          A, B, C, D, E, F, G and H.
+ */
+#define SIGNATURE_64(A, B, C, D, E, F, G, H)	\
+	(SIGNATURE_32(A, B, C, D) | ((u64)(SIGNATURE_32(E, F, G, H)) << 32))
+
+/*
+ * Define FSP API return status code.
+ * Compatiable with EFI_STATUS defined in PI Spec.
+ */
+#define FSP_SUCCESS		0
+#define FSP_INVALID_PARAM	0x80000002
+#define FSP_UNSUPPORTED		0x80000003
+#define FSP_DEVICE_ERROR	0x80000007
+#define FSP_NOT_FOUND		0x8000000E
+#define FSP_ALREADY_STARTED	0x80000014
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_vpd.h u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_vpd.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/fsp/fsp_vpd.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/fsp/fsp_vpd.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2013, Intel Corporation
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * This file is automatically generated. Please do NOT modify !!!
+ *
+ * SPDX-License-Identifier:	Intel
+ */
+
+#ifndef __VPDHEADER_H__
+#define __VPDHEADER_H__
+
+#define UPD_TERMINATOR	0x55AA
+
+struct __packed upd_region {
+	u64	sign;			/* Offset 0x0000 */
+	u64	reserved;		/* Offset 0x0008 */
+	u8	dummy[240];		/* Offset 0x0010 */
+	u8	hda_verb_header[12];	/* Offset 0x0100 */
+	u32	hda_verb_length;	/* Offset 0x010C */
+	u8	hda_verb_data0[16];	/* Offset 0x0110 */
+	u8	hda_verb_data1[16];	/* Offset 0x0120 */
+	u8	hda_verb_data2[16];	/* Offset 0x0130 */
+	u8	hda_verb_data3[16];	/* Offset 0x0140 */
+	u8	hda_verb_data4[16];	/* Offset 0x0150 */
+	u8	hda_verb_data5[16];	/* Offset 0x0160 */
+	u8	hda_verb_data6[16];	/* Offset 0x0170 */
+	u8	hda_verb_data7[16];	/* Offset 0x0180 */
+	u8	hda_verb_data8[16];	/* Offset 0x0190 */
+	u8	hda_verb_data9[16];	/* Offset 0x01A0 */
+	u8	hda_verb_data10[16];	/* Offset 0x01B0 */
+	u8	hda_verb_data11[16];	/* Offset 0x01C0 */
+	u8	hda_verb_data12[16];	/* Offset 0x01D0 */
+	u8	hda_verb_data13[16];	/* Offset 0x01E0 */
+	u8	hda_verb_pad[47];	/* Offset 0x01F0 */
+	u16	terminator;		/* Offset 0x021F */
+};
+
+#define VPD_IMAGE_ID	0x445056574F4E4E4D	/* 'MNNOWVPD' */
+#define VPD_IMAGE_REV	0x00000301
+
+struct __packed vpd_region {
+	u64	sign;			/* Offset 0x0000 */
+	u32	img_rev;		/* Offset 0x0008 */
+	u32	upd_offset;		/* Offset 0x000C */
+	u8	unused[16];		/* Offset 0x0010 */
+	u32	fsp_res_memlen;		/* Offset 0x0020 */
+	u8	disable_pcie1;		/* Offset 0x0024 */
+	u8	disable_pcie2;		/* Offset 0x0025 */
+	u8	disable_pcie3;		/* Offset 0x0026 */
+	u8	enable_azalia;		/* Offset 0x0027 */
+	u8	legacy_seg_decode;	/* Offset 0x0028 */
+	u8	pcie_port_ioh;		/* Offset 0x0029 */
+};
+
+#endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/gpio.h u-boot/arch/x86/include/asm/arch-queensbay/gpio.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/gpio.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,13 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _X86_ARCH_GPIO_H_
+#define _X86_ARCH_GPIO_H_
+
+/* Where in config space is the register that points to the GPIO registers? */
+#define PCI_CFG_GPIOBASE 0x44
+
+#endif /* _X86_ARCH_GPIO_H_ */
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/tnc.h u-boot/arch/x86/include/asm/arch-queensbay/tnc.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/arch-queensbay/tnc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/arch-queensbay/tnc.h	2015-01-01 17:34:32.253503252 +0100
@@ -0,0 +1,15 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _X86_ARCH_TNC_H_
+#define _X86_ARCH_TNC_H_
+
+#include <pci.h>
+
+/* PCI Configuration Space (D31:F0): LPC */
+#define PCH_LPC_DEV	PCI_BDF(0, 0x1f, 0)
+
+#endif /* _X86_ARCH_TNC_H_ */
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/config.h u-boot/arch/x86/include/asm/config.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/config.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/include/asm/config.h	2015-01-01 17:34:32.257503186 +0100
@@ -10,6 +10,5 @@
 #define CONFIG_SYS_GENERIC_BOARD
 #define CONFIG_LMB
 #define CONFIG_SYS_BOOT_RAMDISK_HIGH
-#define asmlinkage __attribute__((regparm(0)))
 
 #endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/global_data.h u-boot/arch/x86/include/asm/global_data.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/global_data.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/include/asm/global_data.h	2015-01-01 17:34:32.257503186 +0100
@@ -47,6 +47,9 @@
 	enum pei_boot_mode_t pei_boot_mode;
 	const struct pch_gpio_map *gpio_map;	/* board GPIO map */
 	struct memory_info meminfo;	/* Memory information */
+#ifdef CONFIG_HAVE_FSP
+	void	*hob_list;		/* FSP HOB list */
+#endif
 };
 
 #endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/gpio.h u-boot/arch/x86/include/asm/gpio.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/gpio.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/include/asm/gpio.h	2015-01-01 17:34:32.257503186 +0100
@@ -11,7 +11,7 @@
 #include <asm-generic/gpio.h>
 
 struct ich6_bank_platdata {
-	uint32_t base_addr;
+	uint16_t base_addr;
 	const char *bank_name;
 };
 
@@ -147,6 +147,7 @@
 	} set3;
 };
 
+void setup_pch_gpios(u16 gpiobase, const struct pch_gpio_map *gpio);
 void ich_gpio_set_gpio_map(const struct pch_gpio_map *map);
 
 #endif /* _X86_GPIO_H_ */
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/ibmpc.h u-boot/arch/x86/include/asm/ibmpc.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/ibmpc.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/include/asm/ibmpc.h	2015-01-01 17:34:32.257503186 +0100
@@ -18,4 +18,7 @@
 #define SYSCTLA         0x92
 #define SLAVE_PIC       0xa0
 
+#define UART0_BASE	0x3f8
+#define UART1_BASE	0x2f8
+
 #endif
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/linkage.h u-boot/arch/x86/include/asm/linkage.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/linkage.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/linkage.h	2015-01-01 17:34:32.257503186 +0100
@@ -0,0 +1,6 @@
+#ifndef _ASM_X86_LINKAGE_H
+#define _ASM_X86_LINKAGE_H
+
+#define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0)))
+
+#endif /* _ASM_X86_LINKAGE_H */
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/pnp_def.h u-boot/arch/x86/include/asm/pnp_def.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/pnp_def.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/include/asm/pnp_def.h	2015-01-01 17:34:32.257503186 +0100
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * Adapted from coreboot src/include/device/pnp_def.h
+ * and arch/x86/include/arch/io.h
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ASM_PNP_DEF_H_
+#define _ASM_PNP_DEF_H_
+
+#include <asm/io.h>
+
+#define PNP_IDX_EN   0x30
+#define PNP_IDX_IO0  0x60
+#define PNP_IDX_IO1  0x62
+#define PNP_IDX_IO2  0x64
+#define PNP_IDX_IO3  0x66
+#define PNP_IDX_IRQ0 0x70
+#define PNP_IDX_IRQ1 0x72
+#define PNP_IDX_DRQ0 0x74
+#define PNP_IDX_DRQ1 0x75
+#define PNP_IDX_MSC0 0xf0
+#define PNP_IDX_MSC1 0xf1
+
+/* Generic functions for pnp devices */
+
+/*
+ * pnp device is a 16-bit integer composed of its i/o port address at high byte
+ * and logic function number at low byte.
+ */
+#define PNP_DEV(PORT, FUNC) (((PORT) << 8) | (FUNC))
+
+static inline void pnp_write_config(uint16_t dev, uint8_t reg, uint8_t value)
+{
+	uint8_t port = dev >> 8;
+
+	outb(reg, port);
+	outb(value, port + 1);
+}
+
+static inline uint8_t pnp_read_config(uint16_t dev, uint8_t reg)
+{
+	uint8_t port = dev >> 8;
+
+	outb(reg, port);
+	return inb(port + 1);
+}
+
+static inline void pnp_set_logical_device(uint16_t dev)
+{
+	uint8_t device = dev & 0xff;
+
+	pnp_write_config(dev, 0x07, device);
+}
+
+static inline void pnp_set_enable(uint16_t dev, int enable)
+{
+	pnp_write_config(dev, PNP_IDX_EN, enable ? 1 : 0);
+}
+
+static inline int pnp_read_enable(uint16_t dev)
+{
+	return !!pnp_read_config(dev, PNP_IDX_EN);
+}
+
+static inline void pnp_set_iobase(uint16_t dev, uint8_t index, uint16_t iobase)
+{
+	pnp_write_config(dev, index + 0, (iobase >> 8) & 0xff);
+	pnp_write_config(dev, index + 1, iobase & 0xff);
+}
+
+static inline uint16_t pnp_read_iobase(uint16_t dev, uint8_t index)
+{
+	return ((uint16_t)(pnp_read_config(dev, index)) << 8) |
+		pnp_read_config(dev, index + 1);
+}
+
+static inline void pnp_set_irq(uint16_t dev, uint8_t index, unsigned irq)
+{
+	pnp_write_config(dev, index, irq);
+}
+
+static inline void pnp_set_drq(uint16_t dev, uint8_t index, unsigned drq)
+{
+	pnp_write_config(dev, index, drq & 0xff);
+}
+
+#endif /* _ASM_PNP_DEF_H_ */
diff -ruN u-boot-2015.01-rc3/arch/x86/include/asm/post.h u-boot/arch/x86/include/asm/post.h
--- u-boot-2015.01-rc3/arch/x86/include/asm/post.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/include/asm/post.h	2015-01-01 17:34:32.257503186 +0100
@@ -33,6 +33,8 @@
 #define POST_LAPIC		0x30
 
 #define POST_RAM_FAILURE	0xea
+#define POST_BIST_FAILURE	0xeb
+#define POST_CAR_FAILURE	0xec
 
 /* Output a post code using al - value must be 0 to 0xff */
 #ifdef __ASSEMBLY__
diff -ruN u-boot-2015.01-rc3/arch/x86/Kconfig u-boot/arch/x86/Kconfig
--- u-boot-2015.01-rc3/arch/x86/Kconfig	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/Kconfig	2015-01-01 17:34:32.249503317 +0100
@@ -32,6 +32,15 @@
 	  and it provides a 2560x1700 high resolution touch-enabled LCD
 	  display.
 
+config TARGET_CROWNBAY
+	bool "Support Intel Crown Bay CRB"
+	help
+	  This is the Intel Crown Bay Customer Reference Board. It contains
+	  the Intel Atom Processor E6xx populated on the COM Express module
+	  with 1GB DDR2 soldered down memory and a carrier board with the
+	  Intel Platform Controller Hub EG20T, other system components and
+	  peripheral connectors for PCIe/SATA/USB/LAN/SD/UART/Audio/LVDS.
+
 endchoice
 
 config RAMBASE
@@ -61,9 +70,85 @@
 config SMM_TSEG_SIZE
 	hex
 
+config BOARD_ROMSIZE_KB_512
+	bool
+config BOARD_ROMSIZE_KB_1024
+	bool
+config BOARD_ROMSIZE_KB_2048
+	bool
+config BOARD_ROMSIZE_KB_4096
+	bool
+config BOARD_ROMSIZE_KB_8192
+	bool
+config BOARD_ROMSIZE_KB_16384
+	bool
+
+choice
+	prompt "ROM chip size"
+	default UBOOT_ROMSIZE_KB_512 if BOARD_ROMSIZE_KB_512
+	default UBOOT_ROMSIZE_KB_1024 if BOARD_ROMSIZE_KB_1024
+	default UBOOT_ROMSIZE_KB_2048 if BOARD_ROMSIZE_KB_2048
+	default UBOOT_ROMSIZE_KB_4096 if BOARD_ROMSIZE_KB_4096
+	default UBOOT_ROMSIZE_KB_8192 if BOARD_ROMSIZE_KB_8192
+	default UBOOT_ROMSIZE_KB_16384 if BOARD_ROMSIZE_KB_16384
+	help
+	  Select the size of the ROM chip you intend to flash U-Boot on.
+
+	  The build system will take care of creating a u-boot.rom file
+	  of the matching size.
+
+config UBOOT_ROMSIZE_KB_512
+	bool "512 KB"
+	help
+	  Choose this option if you have a 512 KB ROM chip.
+
+config UBOOT_ROMSIZE_KB_1024
+	bool "1024 KB (1 MB)"
+	help
+	  Choose this option if you have a 1024 KB (1 MB) ROM chip.
+
+config UBOOT_ROMSIZE_KB_2048
+	bool "2048 KB (2 MB)"
+	help
+	  Choose this option if you have a 2048 KB (2 MB) ROM chip.
+
+config UBOOT_ROMSIZE_KB_4096
+	bool "4096 KB (4 MB)"
+	help
+	  Choose this option if you have a 4096 KB (4 MB) ROM chip.
+
+config UBOOT_ROMSIZE_KB_8192
+	bool "8192 KB (8 MB)"
+	help
+	  Choose this option if you have a 8192 KB (8 MB) ROM chip.
+
+config UBOOT_ROMSIZE_KB_16384
+	bool "16384 KB (16 MB)"
+	help
+	  Choose this option if you have a 16384 KB (16 MB) ROM chip.
+
+endchoice
+
+# Map the config names to an integer (KB).
+config UBOOT_ROMSIZE_KB
+	int
+	default 512 if UBOOT_ROMSIZE_KB_512
+	default 1024 if UBOOT_ROMSIZE_KB_1024
+	default 2048 if UBOOT_ROMSIZE_KB_2048
+	default 4096 if UBOOT_ROMSIZE_KB_4096
+	default 8192 if UBOOT_ROMSIZE_KB_8192
+	default 16384 if UBOOT_ROMSIZE_KB_16384
+
+# Map the config names to a hex value (bytes).
 config ROM_SIZE
 	hex
-	default 0x800000
+	default 0x80000 if UBOOT_ROMSIZE_KB_512
+	default 0x100000 if UBOOT_ROMSIZE_KB_1024
+	default 0x200000 if UBOOT_ROMSIZE_KB_2048
+	default 0x400000 if UBOOT_ROMSIZE_KB_4096
+	default 0x800000 if UBOOT_ROMSIZE_KB_8192
+	default 0xc00000 if UBOOT_ROMSIZE_KB_12288
+	default 0x1000000 if UBOOT_ROMSIZE_KB_16384
 
 config HAVE_INTEL_ME
 	bool "Platform requires Intel Management Engine"
@@ -234,8 +319,12 @@
 
 source "arch/x86/cpu/ivybridge/Kconfig"
 
+source "arch/x86/cpu/queensbay/Kconfig"
+
 source "board/coreboot/coreboot/Kconfig"
 
 source "board/google/chromebook_link/Kconfig"
 
+source "board/intel/crownbay/Kconfig"
+
 endmenu
diff -ruN u-boot-2015.01-rc3/arch/x86/lib/asm-offsets.c u-boot/arch/x86/lib/asm-offsets.c
--- u-boot-2015.01-rc3/arch/x86/lib/asm-offsets.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/lib/asm-offsets.c	2015-01-01 17:34:32.257503186 +0100
@@ -17,6 +17,9 @@
 
 int main(void)
 {
-	DEFINE(GENERATED_GD_RELOC_OFF, offsetof(gd_t, reloc_off));
+	DEFINE(GD_BIST, offsetof(gd_t, arch.bist));
+#ifdef CONFIG_HAVE_FSP
+	DEFINE(GD_HOB_LIST, offsetof(gd_t, arch.hob_list));
+#endif
 	return 0;
 }
diff -ruN u-boot-2015.01-rc3/arch/x86/lib/bios.c u-boot/arch/x86/lib/bios.c
--- u-boot-2015.01-rc3/arch/x86/lib/bios.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/lib/bios.c	2015-01-01 17:34:32.257503186 +0100
@@ -9,6 +9,7 @@
 #include <common.h>
 #include <bios_emul.h>
 #include <vbe.h>
+#include <linux/linkage.h>
 #include <asm/cache.h>
 #include <asm/processor.h>
 #include <asm/i8259.h>
diff -ruN u-boot-2015.01-rc3/arch/x86/lib/bios.h u-boot/arch/x86/lib/bios.h
--- u-boot-2015.01-rc3/arch/x86/lib/bios.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/lib/bios.h	2015-01-01 17:34:32.257503186 +0100
@@ -10,6 +10,8 @@
 #ifndef _X86_LIB_BIOS_H
 #define _X86_LIB_BIOS_H
 
+#include <linux/linkage.h>
+
 #define REALMODE_BASE		0x600
 
 #ifdef __ASSEMBLY__
diff -ruN u-boot-2015.01-rc3/arch/x86/lib/cmd_hob.c u-boot/arch/x86/lib/cmd_hob.c
--- u-boot-2015.01-rc3/arch/x86/lib/cmd_hob.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/arch/x86/lib/cmd_hob.c	2015-01-01 17:34:32.257503186 +0100
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <linux/compiler.h>
+#include <asm/arch/fsp/fsp_support.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static char *hob_type[] = {
+	"reserved",
+	"Hand-off",
+	"Memory Allocation",
+	"Resource Descriptor",
+	"GUID Extension",
+	"Firmware Volume",
+	"CPU",
+	"Memory Pool",
+	"reserved",
+	"Firmware Volume 2",
+	"Load PEIM Unused",
+	"UEFI Capsule",
+};
+
+int do_hob(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	union hob_pointers hob;
+	u16 type;
+	char *desc;
+	int i = 0;
+
+	hob.raw = (u8 *)gd->arch.hob_list;
+
+	printf("HOB list address: 0x%08x\n\n", (unsigned int)hob.raw);
+
+	printf("No. | Address  | Type                | Length in Bytes\n");
+	printf("----|----------|---------------------|----------------\n");
+	while (!end_of_hob(hob)) {
+		printf("%-3d | %08x | ", i, (unsigned int)hob.raw);
+		type = get_hob_type(hob);
+		if (type == HOB_TYPE_UNUSED)
+			desc = "*Unused*";
+		else if (type == HOB_TYPE_EOH)
+			desc = "*END OF HOB*";
+		else if (type >= 0 && type <= ARRAY_SIZE(hob_type))
+			desc = hob_type[type];
+		else
+			desc = "*Invalid Type*";
+		printf("%-19s | %-15d\n", desc, get_hob_length(hob));
+		hob.raw = get_next_hob(hob);
+		i++;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	hob,	1,	1,	do_hob,
+	"print Firmware Support Package (FSP) Hand-Off Block information",
+	""
+);
diff -ruN u-boot-2015.01-rc3/arch/x86/lib/Makefile u-boot/arch/x86/lib/Makefile
--- u-boot-2015.01-rc3/arch/x86/lib/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/arch/x86/lib/Makefile	2015-01-01 17:34:32.257503186 +0100
@@ -10,6 +10,7 @@
 obj-y += bios_interrupts.o
 obj-$(CONFIG_CMD_BOOTM) += bootm.o
 obj-y	+= cmd_boot.o
+obj-$(CONFIG_HAVE_FSP) += cmd_hob.o
 obj-y	+= gcc.o
 obj-y	+= init_helpers.o
 obj-y	+= interrupts.o
diff -ruN u-boot-2015.01-rc3/board/altera/socfpga/MAINTAINERS u-boot/board/altera/socfpga/MAINTAINERS
--- u-boot-2015.01-rc3/board/altera/socfpga/MAINTAINERS	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/altera/socfpga/MAINTAINERS	2015-01-01 17:34:32.269502990 +0100
@@ -5,3 +5,8 @@
 F:	board/altera/socfpga/
 F:	include/configs/socfpga_cyclone5.h
 F:	configs/socfpga_cyclone5_defconfig
+
+SOCRATES BOARD
+M:	Stefan Roese <sr@denx.de>
+S:	Maintained
+F:	configs/socfpga_socrates_defconfig
diff -ruN u-boot-2015.01-rc3/board/altera/socfpga/socfpga_cyclone5.c u-boot/board/altera/socfpga/socfpga_cyclone5.c
--- u-boot-2015.01-rc3/board/altera/socfpga/socfpga_cyclone5.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/altera/socfpga/socfpga_cyclone5.c	2015-01-01 17:34:32.273502924 +0100
@@ -12,7 +12,9 @@
 #include <usb/s3c_udc.h>
 #include <usb_mass_storage.h>
 
+#include <micrel.h>
 #include <netdev.h>
+#include <phy.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -44,6 +46,42 @@
 	return 0;
 }
 
+/*
+ * PHY configuration
+ */
+#ifdef CONFIG_PHY_MICREL_KSZ9021
+int board_phy_config(struct phy_device *phydev)
+{
+	int ret;
+	/*
+	 * These skew settings for the KSZ9021 ethernet phy is required for ethernet
+	 * to work reliably on most flavors of cyclone5 boards.
+	 */
+	ret = ksz9021_phy_extended_write(phydev,
+					 MII_KSZ9021_EXT_RGMII_RX_DATA_SKEW,
+					 0x0);
+	if (ret)
+		return ret;
+
+	ret = ksz9021_phy_extended_write(phydev,
+					 MII_KSZ9021_EXT_RGMII_TX_DATA_SKEW,
+					 0x0);
+	if (ret)
+		return ret;
+
+	ret = ksz9021_phy_extended_write(phydev,
+					 MII_KSZ9021_EXT_RGMII_CLOCK_SKEW,
+					 0xf0f0);
+	if (ret)
+		return ret;
+
+	if (phydev->drv->config)
+		return phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_USB_GADGET
 struct s3c_plat_otg_data socfpga_otg_data = {
 	.regs_otg	= CONFIG_USB_DWC2_REG_ADDR,
diff -ruN u-boot-2015.01-rc3/board/aristainetos/aristainetos.c u-boot/board/aristainetos/aristainetos.c
--- u-boot-2015.01-rc3/board/aristainetos/aristainetos.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/aristainetos/aristainetos.c	2015-01-01 17:34:32.281502792 +0100
@@ -301,7 +301,7 @@
 	/* clear gpr1[14], gpr1[18:17] to select anatop clock */
 	clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC_MASK, 0);
 
-	ret = enable_fec_anatop_clock(ENET_50MHz);
+	ret = enable_fec_anatop_clock(ENET_50MHZ);
 	if (ret)
 		return ret;
 
diff -ruN u-boot-2015.01-rc3/board/armltd/vexpress64/MAINTAINERS u-boot/board/armltd/vexpress64/MAINTAINERS
--- u-boot-2015.01-rc3/board/armltd/vexpress64/MAINTAINERS	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/armltd/vexpress64/MAINTAINERS	2015-01-01 17:34:32.281502792 +0100
@@ -6,6 +6,6 @@
 F:	configs/vexpress_aemv8a_defconfig
 
 VEXPRESS_AEMV8A_SEMI BOARD
-M:	Steve Rae <srae@broadcom.com>
+M:	Linus Walleij <linus.walleij@linaro.org>
 S:	Maintained
 F:	configs/vexpress_aemv8a_semi_defconfig
diff -ruN u-boot-2015.01-rc3/board/avionic-design/common/tamonten-ng.c u-boot/board/avionic-design/common/tamonten-ng.c
--- u-boot-2015.01-rc3/board/avionic-design/common/tamonten-ng.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/avionic-design/common/tamonten-ng.c	2015-01-01 17:34:32.285502727 +0100
@@ -6,6 +6,7 @@
  */
 
 #include <common.h>
+#include <dm.h>
 #include <asm/arch/pinmux.h>
 #include <asm/arch/gp_padctrl.h>
 #include <asm/arch/gpio.h>
@@ -51,8 +52,15 @@
 
 void pmu_write(uchar reg, uchar data)
 {
-	i2c_set_bus_num(4);	/* PMU is on bus 4 */
-	i2c_write(PMU_I2C_ADDRESS, reg, 1, &data, 1);
+	struct udevice *dev;
+	int ret;
+
+	ret = i2c_get_chip_for_busnum(4, PMU_I2C_ADDRESS, &dev);
+	if (ret) {
+		debug("%s: Cannot find PMIC I2C chip\n", __func__);
+		return;
+	}
+	i2c_write(dev, reg, &data, 1);
 }
 
 /*
diff -ruN u-boot-2015.01-rc3/board/coreboot/coreboot/coreboot.c u-boot/board/coreboot/coreboot/coreboot.c
--- u-boot-2015.01-rc3/board/coreboot/coreboot/coreboot.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/coreboot/coreboot/coreboot.c	2015-01-01 17:34:32.305502399 +0100
@@ -6,6 +6,7 @@
 
 #include <common.h>
 #include <cros_ec.h>
+#include <asm/gpio.h>
 
 int arch_early_init_r(void)
 {
@@ -14,3 +15,8 @@
 
 	return 0;
 }
+
+void setup_pch_gpios(u16 gpiobase, const struct pch_gpio_map *gpio)
+{
+	return;
+}
diff -ruN u-boot-2015.01-rc3/board/freescale/common/arm_sleep.c u-boot/board/freescale/common/arm_sleep.c
--- u-boot-2015.01-rc3/board/freescale/common/arm_sleep.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/freescale/common/arm_sleep.c	2015-01-01 17:34:32.357501547 +0100
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#if !defined(CONFIG_ARMV7_NONSEC) || !defined(CONFIG_ARMV7_VIRT)
+#error " Deep sleep needs non-secure mode support. "
+#else
+#include <asm/secure.h>
+#endif
+#include <asm/armv7.h>
+#include <asm/cache.h>
+
+#if defined(CONFIG_LS102XA)
+#include <asm/arch/immap_ls102xa.h>
+#endif
+
+#include "sleep.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void __weak board_mem_sleep_setup(void)
+{
+}
+
+void __weak board_sleep_prepare(void)
+{
+}
+
+bool is_warm_boot(void)
+{
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+
+	if (in_be32(&gur->crstsr) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+
+void fsl_dp_disable_console(void)
+{
+	gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
+}
+
+/*
+ * When wakeup from deep sleep, the first 128 bytes space
+ * will be used to do DDR training which corrupts the data
+ * in there. This function will restore them.
+ */
+static void dp_ddr_restore(void)
+{
+	u64 *src, *dst;
+	int i;
+	struct ccsr_scfg __iomem *scfg = (void *)CONFIG_SYS_FSL_SCFG_ADDR;
+
+	/* get the address of ddr date from SPARECR3 */
+	src = (u64 *)in_le32(&scfg->sparecr[2]);
+	dst = (u64 *)CONFIG_SYS_SDRAM_BASE;
+
+	for (i = 0; i < DDR_BUFF_LEN / 8; i++)
+		*dst++ = *src++;
+
+	flush_dcache_all();
+}
+
+static void dp_resume_prepare(void)
+{
+	dp_ddr_restore();
+	board_sleep_prepare();
+	armv7_init_nonsec();
+	cleanup_before_linux();
+}
+
+int fsl_dp_resume(void)
+{
+	u32 start_addr;
+	void (*kernel_resume)(void);
+	struct ccsr_scfg __iomem *scfg = (void *)CONFIG_SYS_FSL_SCFG_ADDR;
+
+	if (!is_warm_boot())
+		return 0;
+
+	dp_resume_prepare();
+
+	/* Get the entry address and jump to kernel */
+	start_addr = in_le32(&scfg->sparecr[1]);
+	debug("Entry address is 0x%08x\n", start_addr);
+	kernel_resume = (void (*)(void))start_addr;
+	secure_ram_addr(_do_nonsec_entry)(kernel_resume, 0, 0, 0);
+
+	return 0;
+}
diff -ruN u-boot-2015.01-rc3/board/freescale/common/ls102xa_stream_id.c u-boot/board/freescale/common/ls102xa_stream_id.c
--- u-boot-2015.01-rc3/board/freescale/common/ls102xa_stream_id.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/freescale/common/ls102xa_stream_id.c	2015-01-01 17:34:32.357501547 +0100
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2014 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/ls102xa_stream_id.h>
+
+void ls102xa_config_smmu_stream_id(struct smmu_stream_id *id, uint32_t num)
+{
+	uint32_t *scfg = (uint32_t *)CONFIG_SYS_FSL_SCFG_ADDR;
+	int i;
+
+	for (i = 0; i < num; i++)
+		out_be32(scfg + id[i].offset, id[i].stream_id);
+}
diff -ruN u-boot-2015.01-rc3/board/freescale/common/Makefile u-boot/board/freescale/common/Makefile
--- u-boot-2015.01-rc3/board/freescale/common/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/common/Makefile	2015-01-01 17:34:32.357501547 +0100
@@ -37,6 +37,12 @@
 
 obj-$(CONFIG_FSL_DIU_CH7301)	+= diu_ch7301.o
 
+ifdef CONFIG_ARM
+obj-$(CONFIG_DEEP_SLEEP)		+= arm_sleep.o
+else
+obj-$(CONFIG_DEEP_SLEEP)		+= mpc85xx_sleep.o
+endif
+
 obj-$(CONFIG_FSL_DCU_SII9022A)    += dcu_sii9022a.o
 
 obj-$(CONFIG_MPC8541CDS)	+= cds_pci_ft.o
@@ -56,10 +62,14 @@
 obj-$(CONFIG_ZM7300)		+= zm7300.o
 obj-$(CONFIG_POWER_PFUZE100)	+= pfuze.o
 
+obj-$(CONFIG_LS102XA_STREAM_ID)	+= ls102xa_stream_id.o
+
 # deal with common files for P-series corenet based devices
 obj-$(CONFIG_P2041RDB)	+= p_corenet/
 obj-$(CONFIG_P3041DS)	+= p_corenet/
 obj-$(CONFIG_P4080DS)	+= p_corenet/
 obj-$(CONFIG_P5020DS)	+= p_corenet/
 obj-$(CONFIG_P5040DS)	+= p_corenet/
+
+obj-$(CONFIG_LS102XA_NS_ACCESS)	+= ns_access.o
 endif
diff -ruN u-boot-2015.01-rc3/board/freescale/common/mpc85xx_sleep.c u-boot/board/freescale/common/mpc85xx_sleep.c
--- u-boot-2015.01-rc3/board/freescale/common/mpc85xx_sleep.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/freescale/common/mpc85xx_sleep.c	2015-01-01 17:34:32.357501547 +0100
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/immap_85xx.h>
+#include "sleep.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void __weak board_mem_sleep_setup(void)
+{
+}
+
+void __weak board_sleep_prepare(void)
+{
+}
+
+bool is_warm_boot(void)
+{
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	if (in_be32(&gur->scrtsr[0]) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+
+void fsl_dp_disable_console(void)
+{
+	gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
+}
+
+/*
+ * When wakeup from deep sleep, the first 128 bytes space
+ * will be used to do DDR training which corrupts the data
+ * in there. This function will restore them.
+ */
+static void dp_ddr_restore(void)
+{
+	volatile u64 *src, *dst;
+	int i;
+	struct ccsr_scfg __iomem *scfg = (void *)CONFIG_SYS_MPC85xx_SCFG;
+
+	/* get the address of ddr date from SPARECR3 */
+	src = (u64 *)in_be32(&scfg->sparecr[2]);
+	dst = (u64 *)CONFIG_SYS_SDRAM_BASE;
+
+	for (i = 0; i < DDR_BUFF_LEN / 8; i++)
+		*dst++ = *src++;
+
+	flush_dcache();
+}
+
+static void dp_resume_prepare(void)
+{
+	dp_ddr_restore();
+
+	board_sleep_prepare();
+
+	l2cache_init();
+#if defined(CONFIG_RAMBOOT_PBL)
+	disable_cpc_sram();
+#endif
+	enable_cpc();
+}
+
+int fsl_dp_resume(void)
+{
+	u32 start_addr;
+	void (*kernel_resume)(void);
+	struct ccsr_scfg __iomem *scfg = (void *)CONFIG_SYS_MPC85xx_SCFG;
+
+	if (!is_warm_boot())
+		return 0;
+
+	dp_resume_prepare();
+
+	/* Get the entry address and jump to kernel */
+	start_addr = in_be32(&scfg->sparecr[1]);
+	debug("Entry address is 0x%08x\n", start_addr);
+	kernel_resume = (void (*)(void))start_addr;
+	kernel_resume();
+
+	return 0;
+}
diff -ruN u-boot-2015.01-rc3/board/freescale/common/ns_access.c u-boot/board/freescale/common/ns_access.c
--- u-boot-2015.01-rc3/board/freescale/common/ns_access.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/freescale/common/ns_access.c	2015-01-01 17:34:32.357501547 +0100
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2014 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/ns_access.h>
+
+void enable_devices_ns_access(struct csu_ns_dev *ns_dev, uint32_t num)
+{
+	u32 *base = (u32 *)CONFIG_SYS_FSL_CSU_ADDR;
+	u32 *reg;
+	uint32_t val;
+	int i;
+
+	for (i = 0; i < num; i++) {
+		reg = base + ns_dev[i].ind / 2;
+		val = in_be32(reg);
+		if (ns_dev[i].ind % 2 == 0) {
+			val &= 0x0000ffff;
+			val |= ns_dev[i].val << 16;
+		} else {
+			val &= 0xffff0000;
+			val |= ns_dev[i].val;
+		}
+		out_be32(reg, val);
+	}
+}
diff -ruN u-boot-2015.01-rc3/board/freescale/common/qixis.h u-boot/board/freescale/common/qixis.h
--- u-boot-2015.01-rc3/board/freescale/common/qixis.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/common/qixis.h	2015-01-01 17:34:32.357501547 +0100
@@ -100,8 +100,15 @@
 void qixis_write_i2c(unsigned int reg, u8 value);
 #endif
 
+#if defined(CONFIG_QIXIS_I2C_ACCESS) && defined(CONFIG_SYS_I2C_FPGA_ADDR)
+#define QIXIS_READ(reg) qixis_read_i2c(offsetof(struct qixis, reg))
+#define QIXIS_WRITE(reg, value) \
+	qixis_write_i2c(offsetof(struct qixis, reg), value)
+#else
 #define QIXIS_READ(reg) qixis_read(offsetof(struct qixis, reg))
 #define QIXIS_WRITE(reg, value) qixis_write(offsetof(struct qixis, reg), value)
+#endif
+
 #ifdef CONFIG_SYS_I2C_FPGA_ADDR
 #define QIXIS_READ_I2C(reg) qixis_read_i2c(offsetof(struct qixis, reg))
 #define QIXIS_WRITE_I2C(reg, value) \
diff -ruN u-boot-2015.01-rc3/board/freescale/common/sleep.h u-boot/board/freescale/common/sleep.h
--- u-boot-2015.01-rc3/board/freescale/common/sleep.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/freescale/common/sleep.h	2015-01-01 17:34:32.357501547 +0100
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef __SLEEP_H
+#define __SLEEP_H
+
+#define DCFG_CCSR_CRSTSR_WDRFR	(1 << 3)
+#define DDR_BUFF_LEN			128
+
+/* determine if it is a wakeup from deep sleep */
+bool is_warm_boot(void);
+
+/* disable console output */
+void fsl_dp_disable_console(void);
+
+/* clean up everything and jump to kernel */
+int fsl_dp_resume(void);
+#endif
diff -ruN u-boot-2015.01-rc3/board/freescale/ls1021aqds/ddr.c u-boot/board/freescale/ls1021aqds/ddr.c
--- u-boot-2015.01-rc3/board/freescale/ls1021aqds/ddr.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/ls1021aqds/ddr.c	2015-01-01 17:34:32.361501481 +0100
@@ -153,9 +153,12 @@
 {
 	phys_size_t dram_size;
 
+#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_SPL)
 	puts("Initializing DDR....using SPD\n");
 	dram_size = fsl_ddr_sdram();
-
+#else
+	dram_size =  fsl_ddr_sdram_size();
+#endif
 	return dram_size;
 }
 
diff -ruN u-boot-2015.01-rc3/board/freescale/ls1021aqds/ls1021aqds.c u-boot/board/freescale/ls1021aqds/ls1021aqds.c
--- u-boot-2015.01-rc3/board/freescale/ls1021aqds/ls1021aqds.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/ls1021aqds/ls1021aqds.c	2015-01-01 17:34:32.361501481 +0100
@@ -8,12 +8,17 @@
 #include <i2c.h>
 #include <asm/io.h>
 #include <asm/arch/immap_ls102xa.h>
+#include <asm/arch/ns_access.h>
 #include <asm/arch/clock.h>
 #include <asm/arch/fsl_serdes.h>
+#include <asm/arch/ls102xa_stream_id.h>
+#include <asm/pcie_layerscape.h>
+#include <hwconfig.h>
 #include <mmc.h>
 #include <fsl_esdhc.h>
 #include <fsl_ifc.h>
 #include <fsl_sec.h>
+#include <spl.h>
 
 #include "../common/qixis.h"
 #include "ls1021aqds_qixis.h"
@@ -21,9 +26,22 @@
 #include "../../../drivers/qe/qe.h"
 #endif
 
+#define PIN_MUX_SEL_CAN		0x03
+#define PIN_MUX_SEL_IIC2	0xa0
+#define PIN_MUX_SEL_RGMII	0x00
+#define PIN_MUX_SEL_SAI		0x0c
+#define PIN_MUX_SEL_SDHC	0x00
+
+#define SET_SDHC_MUX_SEL(reg, value)	((reg & 0x0f) | value)
+#define SET_EC_MUX_SEL(reg, value)	((reg & 0xf0) | value)
 DECLARE_GLOBAL_DATA_PTR;
 
 enum {
+	MUX_TYPE_CAN,
+	MUX_TYPE_IIC2,
+	MUX_TYPE_RGMII,
+	MUX_TYPE_SAI,
+	MUX_TYPE_SDHC,
 	MUX_TYPE_SD_PCI4,
 	MUX_TYPE_SD_PC_SA_SG_SG,
 	MUX_TYPE_SD_PC_SA_PC_SG,
@@ -32,11 +50,20 @@
 
 int checkboard(void)
 {
+#ifndef CONFIG_QSPI_BOOT
 	char buf[64];
+#endif
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
 	u8 sw;
+#endif
 
 	puts("Board: LS1021AQDS\n");
 
+#ifdef CONFIG_SD_BOOT
+	puts("SD\n");
+#elif CONFIG_QSPI_BOOT
+	puts("QSPI\n");
+#else
 	sw = QIXIS_READ(brdcfg[0]);
 	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
 
@@ -50,13 +77,16 @@
 		printf("IFCCard\n");
 	else
 		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+#endif
 
+#ifndef CONFIG_QSPI_BOOT
 	printf("Sys ID:0x%02x, Sys Ver: 0x%02x\n",
 	       QIXIS_READ(id), QIXIS_READ(arch));
 
 	printf("FPGA:  v%d (%s), build %d\n",
 	       (int)QIXIS_READ(scver), qixis_read_tag(buf),
 	       (int)qixis_read_minor());
+#endif
 
 	return 0;
 }
@@ -101,8 +131,27 @@
 	return 66666666;
 }
 
+int select_i2c_ch_pca9547(u8 ch)
+{
+	int ret;
+
+	ret = i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &ch, 1);
+	if (ret) {
+		puts("PCA: failed to select proper channel\n");
+		return ret;
+	}
+
+	return 0;
+}
+
 int dram_init(void)
 {
+	/*
+	 * When resuming from deep sleep, the I2C channel may not be
+	 * in the default channel. So, switch to the default channel
+	 * before accessing DDR SPD.
+	 */
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
 	gd->ram_size = initdram(0);
 
 	return 0;
@@ -121,19 +170,6 @@
 }
 #endif
 
-int select_i2c_ch_pca9547(u8 ch)
-{
-	int ret;
-
-	ret = i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &ch, 1);
-	if (ret) {
-		puts("PCA: failed to select proper channel\n");
-		return ret;
-	}
-
-	return 0;
-}
-
 int board_early_init_f(void)
 {
 	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
@@ -148,6 +184,10 @@
 	init_early_memctl_regs();
 #endif
 
+#ifdef CONFIG_FSL_QSPI
+	out_be32(&scfg->qspi_cfg, SCFG_QSPI_CLKSEL);
+#endif
+
 	/* Workaround for the issue that DDR could not respond to
 	 * barrier transaction which is generated by executing DSB/ISB
 	 * instruction. Set CCI-400 control override register to
@@ -158,13 +198,75 @@
 	return 0;
 }
 
+#ifdef CONFIG_SPL_BUILD
+void board_init_f(ulong dummy)
+{
+	struct ccsr_cci400 *cci = (struct ccsr_cci400 *)CONFIG_SYS_CCI400_ADDR;
+
+#ifdef CONFIG_NAND_BOOT
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+	u32 porsr1, pinctl;
+
+	/*
+	 * There is LS1 SoC issue where NOR, FPGA are inaccessible during
+	 * NAND boot because IFC signals > IFC_AD7 are not enabled.
+	 * This workaround changes RCW source to make all signals enabled.
+	 */
+	porsr1 = in_be32(&gur->porsr1);
+	pinctl = ((porsr1 & ~(DCFG_CCSR_PORSR1_RCW_MASK)) |
+		 DCFG_CCSR_PORSR1_RCW_SRC_I2C);
+	out_be32((unsigned int *)(CONFIG_SYS_DCSR_DCFG_ADDR + DCFG_DCSR_PORCR1),
+		 pinctl);
+#endif
+
+	/* Set global data pointer */
+	gd = &gdata;
+
+	/* Clear the BSS */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+#ifdef CONFIG_FSL_IFC
+	init_early_memctl_regs();
+#endif
+
+	get_clocks();
+
+	preloader_console_init();
+
+#ifdef CONFIG_SPL_I2C_SUPPORT
+	i2c_init_all();
+#endif
+	out_le32(&cci->ctrl_ord, CCI400_CTRLORD_TERM_BARRIER);
+
+	dram_init();
+
+	board_init_r(NULL, 0);
+}
+#endif
+
 int config_board_mux(int ctrl_type)
 {
-	u8 reg12;
+	u8 reg12, reg14;
 
 	reg12 = QIXIS_READ(brdcfg[12]);
+	reg14 = QIXIS_READ(brdcfg[14]);
 
 	switch (ctrl_type) {
+	case MUX_TYPE_CAN:
+		reg14 = SET_EC_MUX_SEL(reg14, PIN_MUX_SEL_CAN);
+		break;
+	case MUX_TYPE_IIC2:
+		reg14 = SET_SDHC_MUX_SEL(reg14, PIN_MUX_SEL_IIC2);
+		break;
+	case MUX_TYPE_RGMII:
+		reg14 = SET_EC_MUX_SEL(reg14, PIN_MUX_SEL_RGMII);
+		break;
+	case MUX_TYPE_SAI:
+		reg14 = SET_EC_MUX_SEL(reg14, PIN_MUX_SEL_SAI);
+		break;
+	case MUX_TYPE_SDHC:
+		reg14 = SET_SDHC_MUX_SEL(reg14, PIN_MUX_SEL_SDHC);
+		break;
 	case MUX_TYPE_SD_PCI4:
 		reg12 = 0x38;
 		break;
@@ -183,6 +285,7 @@
 	}
 
 	QIXIS_WRITE(brdcfg[12], reg12);
+	QIXIS_WRITE(brdcfg[14], reg14);
 
 	return 0;
 }
@@ -216,15 +319,154 @@
 	return 0;
 }
 
-#if defined(CONFIG_MISC_INIT_R)
 int misc_init_r(void)
 {
+	int conflict_flag;
+
+	/* some signals can not enable simultaneous*/
+	conflict_flag = 0;
+	if (hwconfig("sdhc"))
+		conflict_flag++;
+	if (hwconfig("iic2"))
+		conflict_flag++;
+	if (conflict_flag > 1) {
+		printf("WARNING: pin conflict !\n");
+		return 0;
+	}
+
+	conflict_flag = 0;
+	if (hwconfig("rgmii"))
+		conflict_flag++;
+	if (hwconfig("can"))
+		conflict_flag++;
+	if (hwconfig("sai"))
+		conflict_flag++;
+	if (conflict_flag > 1) {
+		printf("WARNING: pin conflict !\n");
+		return 0;
+	}
+
+	if (hwconfig("can"))
+		config_board_mux(MUX_TYPE_CAN);
+	else if (hwconfig("rgmii"))
+		config_board_mux(MUX_TYPE_RGMII);
+	else if (hwconfig("sai"))
+		config_board_mux(MUX_TYPE_SAI);
+
+	if (hwconfig("iic2"))
+		config_board_mux(MUX_TYPE_IIC2);
+	else if (hwconfig("sdhc"))
+		config_board_mux(MUX_TYPE_SDHC);
+
 #ifdef CONFIG_FSL_CAAM
 	return sec_init();
 #endif
+	return 0;
 }
+
+#ifdef CONFIG_LS102XA_NS_ACCESS
+static struct csu_ns_dev ns_dev[] = {
+	{ CSU_CSLX_PCIE2_IO, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE1_IO, CSU_ALL_RW },
+	{ CSU_CSLX_MG2TPR_IP, CSU_ALL_RW },
+	{ CSU_CSLX_IFC_MEM, CSU_ALL_RW },
+	{ CSU_CSLX_OCRAM, CSU_ALL_RW },
+	{ CSU_CSLX_GIC, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE1, CSU_ALL_RW },
+	{ CSU_CSLX_OCRAM2, CSU_ALL_RW },
+	{ CSU_CSLX_QSPI_MEM, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE2, CSU_ALL_RW },
+	{ CSU_CSLX_SATA, CSU_ALL_RW },
+	{ CSU_CSLX_USB3, CSU_ALL_RW },
+	{ CSU_CSLX_SERDES, CSU_ALL_RW },
+	{ CSU_CSLX_QDMA, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART2, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART1, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART4, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART3, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART6, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART5, CSU_ALL_RW },
+	{ CSU_CSLX_DSPI2, CSU_ALL_RW },
+	{ CSU_CSLX_DSPI1, CSU_ALL_RW },
+	{ CSU_CSLX_QSPI, CSU_ALL_RW },
+	{ CSU_CSLX_ESDHC, CSU_ALL_RW },
+	{ CSU_CSLX_2D_ACE, CSU_ALL_RW },
+	{ CSU_CSLX_IFC, CSU_ALL_RW },
+	{ CSU_CSLX_I2C1, CSU_ALL_RW },
+	{ CSU_CSLX_USB2, CSU_ALL_RW },
+	{ CSU_CSLX_I2C3, CSU_ALL_RW },
+	{ CSU_CSLX_I2C2, CSU_ALL_RW },
+	{ CSU_CSLX_DUART2, CSU_ALL_RW },
+	{ CSU_CSLX_DUART1, CSU_ALL_RW },
+	{ CSU_CSLX_WDT2, CSU_ALL_RW },
+	{ CSU_CSLX_WDT1, CSU_ALL_RW },
+	{ CSU_CSLX_EDMA, CSU_ALL_RW },
+	{ CSU_CSLX_SYS_CNT, CSU_ALL_RW },
+	{ CSU_CSLX_DMA_MUX2, CSU_ALL_RW },
+	{ CSU_CSLX_DMA_MUX1, CSU_ALL_RW },
+	{ CSU_CSLX_DDR, CSU_ALL_RW },
+	{ CSU_CSLX_QUICC, CSU_ALL_RW },
+	{ CSU_CSLX_DCFG_CCU_RCPM, CSU_ALL_RW },
+	{ CSU_CSLX_SECURE_BOOTROM, CSU_ALL_RW },
+	{ CSU_CSLX_SFP, CSU_ALL_RW },
+	{ CSU_CSLX_TMU, CSU_ALL_RW },
+	{ CSU_CSLX_SECURE_MONITOR, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED0, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC1, CSU_ALL_RW },
+	{ CSU_CSLX_SEC5_5, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC3, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC2, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO2, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO1, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO4, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO3, CSU_ALL_RW },
+	{ CSU_CSLX_PLATFORM_CONT, CSU_ALL_RW },
+	{ CSU_CSLX_CSU, CSU_ALL_RW },
+	{ CSU_CSLX_ASRC, CSU_ALL_RW },
+	{ CSU_CSLX_SPDIF, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN2, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN1, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN4, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN3, CSU_ALL_RW },
+	{ CSU_CSLX_SAI2, CSU_ALL_RW },
+	{ CSU_CSLX_SAI1, CSU_ALL_RW },
+	{ CSU_CSLX_SAI4, CSU_ALL_RW },
+	{ CSU_CSLX_SAI3, CSU_ALL_RW },
+	{ CSU_CSLX_FTM2, CSU_ALL_RW },
+	{ CSU_CSLX_FTM1, CSU_ALL_RW },
+	{ CSU_CSLX_FTM4, CSU_ALL_RW },
+	{ CSU_CSLX_FTM3, CSU_ALL_RW },
+	{ CSU_CSLX_FTM6, CSU_ALL_RW },
+	{ CSU_CSLX_FTM5, CSU_ALL_RW },
+	{ CSU_CSLX_FTM8, CSU_ALL_RW },
+	{ CSU_CSLX_FTM7, CSU_ALL_RW },
+	{ CSU_CSLX_COP_DCSR, CSU_ALL_RW },
+	{ CSU_CSLX_EPU, CSU_ALL_RW },
+	{ CSU_CSLX_GDI, CSU_ALL_RW },
+	{ CSU_CSLX_DDI, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED1, CSU_ALL_RW },
+	{ CSU_CSLX_USB3_PHY, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED2, CSU_ALL_RW },
+};
 #endif
 
+struct smmu_stream_id dev_stream_id[] = {
+	{ 0x100, 0x01, "ETSEC MAC1" },
+	{ 0x104, 0x02, "ETSEC MAC2" },
+	{ 0x108, 0x03, "ETSEC MAC3" },
+	{ 0x10c, 0x04, "PEX1" },
+	{ 0x110, 0x05, "PEX2" },
+	{ 0x114, 0x06, "qDMA" },
+	{ 0x118, 0x07, "SATA" },
+	{ 0x11c, 0x08, "USB3" },
+	{ 0x120, 0x09, "QE" },
+	{ 0x124, 0x0a, "eSDHC" },
+	{ 0x128, 0x0b, "eMA" },
+	{ 0x14c, 0x0c, "2D-ACE" },
+	{ 0x150, 0x0d, "USB2" },
+	{ 0x18c, 0x0e, "DEBUG" },
+};
+
 int board_init(void)
 {
 	struct ccsr_cci400 *cci = (struct ccsr_cci400 *)CONFIG_SYS_CCI400_ADDR;
@@ -247,6 +489,13 @@
 	config_serdes_mux();
 #endif
 
+	ls102xa_config_smmu_stream_id(dev_stream_id,
+				      ARRAY_SIZE(dev_stream_id));
+
+#ifdef CONFIG_LS102XA_NS_ACCESS
+	enable_devices_ns_access(ns_dev, ARRAY_SIZE(ns_dev));
+#endif
+
 #ifdef CONFIG_U_QE
 	u_qe_init();
 #endif
@@ -258,6 +507,10 @@
 {
 	ft_cpu_setup(blob, bd);
 
+#ifdef CONFIG_PCIE_LAYERSCAPE
+	ft_pcie_setup(blob, bd);
+#endif
+
 	return 0;
 }
 
diff -ruN u-boot-2015.01-rc3/board/freescale/ls1021aqds/ls102xa_pbi.cfg u-boot/board/freescale/ls1021aqds/ls102xa_pbi.cfg
--- u-boot-2015.01-rc3/board/freescale/ls1021aqds/ls102xa_pbi.cfg	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/freescale/ls1021aqds/ls102xa_pbi.cfg	2015-01-01 17:34:32.361501481 +0100
@@ -0,0 +1,12 @@
+#PBI commands
+
+09570200 ffffffff
+09570158 00000300
+8940007c 21f47300
+
+#Configure Scratch register
+09ee0200 10000000
+#Configure alternate space
+09570158 00001000
+#Flush PBL data
+096100c0 000FFFFF
diff -ruN u-boot-2015.01-rc3/board/freescale/ls1021aqds/ls102xa_rcw_nand.cfg u-boot/board/freescale/ls1021aqds/ls102xa_rcw_nand.cfg
--- u-boot-2015.01-rc3/board/freescale/ls1021aqds/ls102xa_rcw_nand.cfg	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/freescale/ls1021aqds/ls102xa_rcw_nand.cfg	2015-01-01 17:34:32.361501481 +0100
@@ -0,0 +1,7 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+# serdes protocol
+0608000a 00000000 00000000 00000000
+60000000 00407900 e0106a00 21046000
+00000000 00000000 00000000 00038000
+00000000 001b7200 00000000 00000000
diff -ruN u-boot-2015.01-rc3/board/freescale/ls1021aqds/ls102xa_rcw_sd.cfg u-boot/board/freescale/ls1021aqds/ls102xa_rcw_sd.cfg
--- u-boot-2015.01-rc3/board/freescale/ls1021aqds/ls102xa_rcw_sd.cfg	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/freescale/ls1021aqds/ls102xa_rcw_sd.cfg	2015-01-01 17:34:32.361501481 +0100
@@ -0,0 +1,14 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+
+#enable IFC, disable QSPI and DSPI
+0608000a 00000000 00000000 00000000
+60000000 00407900 60040a00 21046000
+00000000 00000000 00000000 00038000
+00000000 001b7200 00000000 00000000
+
+#disable IFC, enable QSPI and DSPI
+#0608000a 00000000 00000000 00000000
+#60000000 00407900 60040a00 21046000
+#00000000 00000000 00000000 00038000
+#20024800 001b7200 00000000 00000000
diff -ruN u-boot-2015.01-rc3/board/freescale/ls1021aqds/MAINTAINERS u-boot/board/freescale/ls1021aqds/MAINTAINERS
--- u-boot-2015.01-rc3/board/freescale/ls1021aqds/MAINTAINERS	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/ls1021aqds/MAINTAINERS	2015-01-01 17:34:32.361501481 +0100
@@ -6,3 +6,6 @@
 F:	configs/ls1021aqds_nor_defconfig
 F:	configs/ls1021aqds_ddr4_nor_defconfig
 F:	configs/ls1021aqds_nor_SECURE_BOOT_defconfig
+F:	configs/ls1021aqds_sdcard_defconfig
+F:	configs/ls1021aqds_qspi_defconfig
+F:	configs/ls1021aqds_nand_defconfig
diff -ruN u-boot-2015.01-rc3/board/freescale/ls1021atwr/ls1021atwr.c u-boot/board/freescale/ls1021atwr/ls1021atwr.c
--- u-boot-2015.01-rc3/board/freescale/ls1021atwr/ls1021atwr.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/ls1021atwr/ls1021atwr.c	2015-01-01 17:34:32.361501481 +0100
@@ -8,8 +8,11 @@
 #include <i2c.h>
 #include <asm/io.h>
 #include <asm/arch/immap_ls102xa.h>
+#include <asm/arch/ns_access.h>
 #include <asm/arch/clock.h>
 #include <asm/arch/fsl_serdes.h>
+#include <asm/arch/ls102xa_stream_id.h>
+#include <asm/pcie_layerscape.h>
 #include <mmc.h>
 #include <fsl_esdhc.h>
 #include <fsl_ifc.h>
@@ -17,6 +20,7 @@
 #include <fsl_mdio.h>
 #include <tsec.h>
 #include <fsl_sec.h>
+#include <spl.h>
 #ifdef CONFIG_U_QE
 #include "../../../drivers/qe/qe.h"
 #endif
@@ -70,6 +74,7 @@
 	u8 rev2;		/* Reserved */
 };
 
+#ifndef CONFIG_QSPI_BOOT
 static void convert_serdes_mux(int type, int need_reset);
 
 void cpld_show(void)
@@ -105,11 +110,14 @@
 	       in_8(&cpld_data->serdes_mux));
 #endif
 }
+#endif
 
 int checkboard(void)
 {
 	puts("Board: LS1021ATWR\n");
+#ifndef CONFIG_QSPI_BOOT
 	cpld_show();
+#endif
 
 	return 0;
 }
@@ -218,6 +226,7 @@
 }
 #endif
 
+#ifndef CONFIG_QSPI_BOOT
 int config_serdes_mux(void)
 {
 	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
@@ -249,6 +258,7 @@
 
 	return 0;
 }
+#endif
 
 int board_early_init_f(void)
 {
@@ -267,9 +277,135 @@
 	out_be32(&scfg->pixclkcr, SCFG_PIXCLKCR_PXCKEN);
 #endif
 
+#ifdef CONFIG_FSL_QSPI
+	out_be32(&scfg->qspi_cfg, SCFG_QSPI_CLKSEL);
+#endif
+
 	return 0;
 }
 
+#ifdef CONFIG_SPL_BUILD
+void board_init_f(ulong dummy)
+{
+	/* Set global data pointer */
+	gd = &gdata;
+
+	/* Clear the BSS */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	get_clocks();
+
+	preloader_console_init();
+
+	dram_init();
+
+	board_init_r(NULL, 0);
+}
+#endif
+
+#ifdef CONFIG_LS102XA_NS_ACCESS
+static struct csu_ns_dev ns_dev[] = {
+	{ CSU_CSLX_PCIE2_IO, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE1_IO, CSU_ALL_RW },
+	{ CSU_CSLX_MG2TPR_IP, CSU_ALL_RW },
+	{ CSU_CSLX_IFC_MEM, CSU_ALL_RW },
+	{ CSU_CSLX_OCRAM, CSU_ALL_RW },
+	{ CSU_CSLX_GIC, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE1, CSU_ALL_RW },
+	{ CSU_CSLX_OCRAM2, CSU_ALL_RW },
+	{ CSU_CSLX_QSPI_MEM, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE2, CSU_ALL_RW },
+	{ CSU_CSLX_SATA, CSU_ALL_RW },
+	{ CSU_CSLX_USB3, CSU_ALL_RW },
+	{ CSU_CSLX_SERDES, CSU_ALL_RW },
+	{ CSU_CSLX_QDMA, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART2, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART1, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART4, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART3, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART6, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART5, CSU_ALL_RW },
+	{ CSU_CSLX_DSPI2, CSU_ALL_RW },
+	{ CSU_CSLX_DSPI1, CSU_ALL_RW },
+	{ CSU_CSLX_QSPI, CSU_ALL_RW },
+	{ CSU_CSLX_ESDHC, CSU_ALL_RW },
+	{ CSU_CSLX_2D_ACE, CSU_ALL_RW },
+	{ CSU_CSLX_IFC, CSU_ALL_RW },
+	{ CSU_CSLX_I2C1, CSU_ALL_RW },
+	{ CSU_CSLX_USB2, CSU_ALL_RW },
+	{ CSU_CSLX_I2C3, CSU_ALL_RW },
+	{ CSU_CSLX_I2C2, CSU_ALL_RW },
+	{ CSU_CSLX_DUART2, CSU_ALL_RW },
+	{ CSU_CSLX_DUART1, CSU_ALL_RW },
+	{ CSU_CSLX_WDT2, CSU_ALL_RW },
+	{ CSU_CSLX_WDT1, CSU_ALL_RW },
+	{ CSU_CSLX_EDMA, CSU_ALL_RW },
+	{ CSU_CSLX_SYS_CNT, CSU_ALL_RW },
+	{ CSU_CSLX_DMA_MUX2, CSU_ALL_RW },
+	{ CSU_CSLX_DMA_MUX1, CSU_ALL_RW },
+	{ CSU_CSLX_DDR, CSU_ALL_RW },
+	{ CSU_CSLX_QUICC, CSU_ALL_RW },
+	{ CSU_CSLX_DCFG_CCU_RCPM, CSU_ALL_RW },
+	{ CSU_CSLX_SECURE_BOOTROM, CSU_ALL_RW },
+	{ CSU_CSLX_SFP, CSU_ALL_RW },
+	{ CSU_CSLX_TMU, CSU_ALL_RW },
+	{ CSU_CSLX_SECURE_MONITOR, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED0, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC1, CSU_ALL_RW },
+	{ CSU_CSLX_SEC5_5, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC3, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC2, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO2, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO1, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO4, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO3, CSU_ALL_RW },
+	{ CSU_CSLX_PLATFORM_CONT, CSU_ALL_RW },
+	{ CSU_CSLX_CSU, CSU_ALL_RW },
+	{ CSU_CSLX_ASRC, CSU_ALL_RW },
+	{ CSU_CSLX_SPDIF, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN2, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN1, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN4, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN3, CSU_ALL_RW },
+	{ CSU_CSLX_SAI2, CSU_ALL_RW },
+	{ CSU_CSLX_SAI1, CSU_ALL_RW },
+	{ CSU_CSLX_SAI4, CSU_ALL_RW },
+	{ CSU_CSLX_SAI3, CSU_ALL_RW },
+	{ CSU_CSLX_FTM2, CSU_ALL_RW },
+	{ CSU_CSLX_FTM1, CSU_ALL_RW },
+	{ CSU_CSLX_FTM4, CSU_ALL_RW },
+	{ CSU_CSLX_FTM3, CSU_ALL_RW },
+	{ CSU_CSLX_FTM6, CSU_ALL_RW },
+	{ CSU_CSLX_FTM5, CSU_ALL_RW },
+	{ CSU_CSLX_FTM8, CSU_ALL_RW },
+	{ CSU_CSLX_FTM7, CSU_ALL_RW },
+	{ CSU_CSLX_COP_DCSR, CSU_ALL_RW },
+	{ CSU_CSLX_EPU, CSU_ALL_RW },
+	{ CSU_CSLX_GDI, CSU_ALL_RW },
+	{ CSU_CSLX_DDI, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED1, CSU_ALL_RW },
+	{ CSU_CSLX_USB3_PHY, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED2, CSU_ALL_RW },
+};
+#endif
+
+struct smmu_stream_id dev_stream_id[] = {
+	{ 0x100, 0x01, "ETSEC MAC1" },
+	{ 0x104, 0x02, "ETSEC MAC2" },
+	{ 0x108, 0x03, "ETSEC MAC3" },
+	{ 0x10c, 0x04, "PEX1" },
+	{ 0x110, 0x05, "PEX2" },
+	{ 0x114, 0x06, "qDMA" },
+	{ 0x118, 0x07, "SATA" },
+	{ 0x11c, 0x08, "USB3" },
+	{ 0x120, 0x09, "QE" },
+	{ 0x124, 0x0a, "eSDHC" },
+	{ 0x128, 0x0b, "eMA" },
+	{ 0x14c, 0x0c, "2D-ACE" },
+	{ 0x150, 0x0d, "USB2" },
+	{ 0x18c, 0x0e, "DEBUG" },
+};
+
 int board_init(void)
 {
 	struct ccsr_cci400 *cci = (struct ccsr_cci400 *)CONFIG_SYS_CCI400_ADDR;
@@ -284,8 +420,17 @@
 
 #ifndef CONFIG_SYS_FSL_NO_SERDES
 	fsl_serdes_init();
+#ifndef CONFIG_QSPI_BOOT
 	config_serdes_mux();
 #endif
+#endif
+
+	ls102xa_config_smmu_stream_id(dev_stream_id,
+				      ARRAY_SIZE(dev_stream_id));
+
+#ifdef CONFIG_LS102XA_NS_ACCESS
+	enable_devices_ns_access(ns_dev, ARRAY_SIZE(ns_dev));
+#endif
 
 #ifdef CONFIG_U_QE
 	u_qe_init();
@@ -307,6 +452,10 @@
 {
 	ft_cpu_setup(blob, bd);
 
+#ifdef CONFIG_PCIE_LAYERSCAPE
+	ft_pcie_setup(blob, bd);
+#endif
+
 	return 0;
 }
 
@@ -329,6 +478,7 @@
 	return (((val) >> 8) & 0x00ff) | (((val) << 8) & 0xff00);
 }
 
+#ifndef CONFIG_QSPI_BOOT
 static void convert_flash_bank(char bank)
 {
 	struct cpld_data *cpld_data = (void *)(CONFIG_SYS_CPLD_BASE);
@@ -511,3 +661,4 @@
 	"	-change lane C & lane D to PCIeX2\n"
 	"\nWARNING: If you aren't familiar with the setting of serdes, don't try to change anything!\n"
 );
+#endif
diff -ruN u-boot-2015.01-rc3/board/freescale/ls1021atwr/ls102xa_pbi.cfg u-boot/board/freescale/ls1021atwr/ls102xa_pbi.cfg
--- u-boot-2015.01-rc3/board/freescale/ls1021atwr/ls102xa_pbi.cfg	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/freescale/ls1021atwr/ls102xa_pbi.cfg	2015-01-01 17:34:32.361501481 +0100
@@ -0,0 +1,12 @@
+#PBI commands
+
+09570200 ffffffff
+09570158 00000300
+8940007c 21f47300
+
+#Configure Scratch register
+09ee0200 10000000
+#Configure alternate space
+09570158 00001000
+#Flush PBL data
+096100c0 000FFFFF
diff -ruN u-boot-2015.01-rc3/board/freescale/ls1021atwr/ls102xa_rcw_sd.cfg u-boot/board/freescale/ls1021atwr/ls102xa_rcw_sd.cfg
--- u-boot-2015.01-rc3/board/freescale/ls1021atwr/ls102xa_rcw_sd.cfg	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/freescale/ls1021atwr/ls102xa_rcw_sd.cfg	2015-01-01 17:34:32.361501481 +0100
@@ -0,0 +1,14 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+
+#enable IFC, disable QSPI and DSPI
+0608000a 00000000 00000000 00000000
+20000000 00407900 60040a00 21046000
+00000000 00000000 00000000 00038000
+00080000 881b7340 00000000 00000000
+
+#disable IFC, enable QSPI and DSPI
+#0608000a 00000000 00000000 00000000
+#20000000 00407900 60040a00 21046000
+#00000000 00000000 00000000 00038000
+#20084800 881b7340 00000000 00000000
diff -ruN u-boot-2015.01-rc3/board/freescale/ls1021atwr/MAINTAINERS u-boot/board/freescale/ls1021atwr/MAINTAINERS
--- u-boot-2015.01-rc3/board/freescale/ls1021atwr/MAINTAINERS	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/ls1021atwr/MAINTAINERS	2015-01-01 17:34:32.361501481 +0100
@@ -5,3 +5,5 @@
 F:	include/configs/ls1021atwr.h
 F:	configs/ls1021atwr_nor_defconfig
 F:	configs/ls1021atwr_nor_SECURE_BOOT_defconfig
+F:	configs/ls1021atwr_sdcard_defconfig
+F:	configs/ls1021atwr_qspi_defconfig
diff -ruN u-boot-2015.01-rc3/board/freescale/mx6slevk/mx6slevk.c u-boot/board/freescale/mx6slevk/mx6slevk.c
--- u-boot-2015.01-rc3/board/freescale/mx6slevk/mx6slevk.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/mx6slevk/mx6slevk.c	2015-01-01 17:34:32.381501153 +0100
@@ -20,6 +20,8 @@
 #include <fsl_esdhc.h>
 #include <mmc.h>
 #include <netdev.h>
+#include <usb.h>
+#include <usb/ehci-fsl.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -234,10 +236,52 @@
 	/* clear gpr1[14], gpr1[18:17] to select anatop clock */
 	clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC_MASK, 0);
 
-	return enable_fec_anatop_clock(ENET_50MHz);
+	return enable_fec_anatop_clock(ENET_50MHZ);
 }
 #endif
 
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	/* OTG1 */
+	MX6_PAD_KEY_COL4__USB_USBOTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EPDC_PWRCOM__ANATOP_USBOTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* OTG2 */
+	MX6_PAD_KEY_COL5__USB_USBOTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL)
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
 
 int board_early_init_f(void)
 {
@@ -256,6 +300,11 @@
 #ifdef	CONFIG_FEC_MXC
 	setup_fec();
 #endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
 	return 0;
 }
 
diff -ruN u-boot-2015.01-rc3/board/freescale/mx6sxsabresd/mx6sxsabresd.c u-boot/board/freescale/mx6sxsabresd/mx6sxsabresd.c
--- u-boot-2015.01-rc3/board/freescale/mx6sxsabresd/mx6sxsabresd.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/mx6sxsabresd/mx6sxsabresd.c	2015-01-01 17:34:32.381501153 +0100
@@ -26,6 +26,8 @@
 #include <power/pmic.h>
 #include <power/pfuze100_pmic.h>
 #include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -168,7 +170,7 @@
 	reg |= BM_ANADIG_PLL_ENET_REF_25M_ENABLE;
 	writel(reg, &anatop->pll_enet);
 
-	return enable_fec_anatop_clock(ENET_125MHz);
+	return enable_fec_anatop_clock(ENET_125MHZ);
 }
 
 int board_eth_init(bd_t *bis)
@@ -212,6 +214,49 @@
 	return 0;
 }
 
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	/* OGT1 */
+	MX6_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* OTG2 */
+	MX6_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL)
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
 int board_phy_config(struct phy_device *phydev)
 {
 	/*
@@ -242,6 +287,10 @@
 	/* Active high for ncp692 */
 	gpio_direction_output(IMX_GPIO_NR(4, 16) , 1);
 
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
 	return 0;
 }
 
@@ -322,7 +371,6 @@
 	return 0;
 }
 
-
 int board_init(void)
 {
 	/* Address of boot parameters */
diff -ruN u-boot-2015.01-rc3/board/freescale/t104xrdb/ddr.c u-boot/board/freescale/t104xrdb/ddr.c
--- u-boot-2015.01-rc3/board/freescale/t104xrdb/ddr.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/t104xrdb/ddr.c	2015-01-01 17:34:32.389501022 +0100
@@ -11,6 +11,7 @@
 #include <fsl_ddr_sdram.h>
 #include <fsl_ddr_dimm_params.h>
 #include <asm/fsl_law.h>
+#include <asm/mpc85xx_gpio.h>
 #include "ddr.h"
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -109,6 +110,19 @@
 	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
 }
 
+#if defined(CONFIG_DEEP_SLEEP)
+void board_mem_sleep_setup(void)
+{
+	void __iomem *cpld_base = (void *)CONFIG_SYS_CPLD_BASE;
+
+	/* does not provide HW signals for power management */
+	clrbits_8(cpld_base + 0x17, 0x40);
+	/* Disable MCKE isolation */
+	gpio_set_value(2, 0);
+	udelay(1);
+}
+#endif
+
 phys_size_t initdram(int board_type)
 {
 	phys_size_t dram_size;
@@ -124,5 +138,10 @@
 #else
 	dram_size =  fsl_ddr_sdram_size();
 #endif
+
+#if defined(CONFIG_DEEP_SLEEP) && !defined(CONFIG_SPL_BUILD)
+	fsl_dp_resume();
+#endif
+
 	return dram_size;
 }
diff -ruN u-boot-2015.01-rc3/board/freescale/t104xrdb/spl.c u-boot/board/freescale/t104xrdb/spl.c
--- u-boot-2015.01-rc3/board/freescale/t104xrdb/spl.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/t104xrdb/spl.c	2015-01-01 17:34:32.389501022 +0100
@@ -11,7 +11,7 @@
 #include <mmc.h>
 #include <fsl_esdhc.h>
 #include <spi_flash.h>
-#include <asm/mpc85xx_gpio.h>
+#include "../common/sleep.h"
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -64,8 +64,8 @@
 
 #ifdef CONFIG_DEEP_SLEEP
 	/* disable the console if boot from deep sleep */
-	if (in_be32(&gur->scrtsr[0]) & (1 << 3))
-		gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
+	if (is_warm_boot())
+		fsl_dp_disable_console();
 #endif
 	/* compiler optimization barrier needed for GCC >= 3.4 */
 	__asm__ __volatile__("" : : : "memory");
@@ -132,16 +132,3 @@
 	nand_boot();
 #endif
 }
-
-#ifdef CONFIG_DEEP_SLEEP
-void board_mem_sleep_setup(void)
-{
-	void __iomem *cpld_base = (void *)CONFIG_SYS_CPLD_BASE;
-
-	/* does not provide HW signals for power management */
-	clrbits_8(cpld_base + 0x17, 0x40);
-	/* Disable MCKE isolation */
-	gpio_set_value(2, 0);
-	udelay(1);
-}
-#endif
diff -ruN u-boot-2015.01-rc3/board/freescale/t104xrdb/t104xrdb.c u-boot/board/freescale/t104xrdb/t104xrdb.c
--- u-boot-2015.01-rc3/board/freescale/t104xrdb/t104xrdb.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/freescale/t104xrdb/t104xrdb.c	2015-01-01 17:34:32.389501022 +0100
@@ -17,8 +17,7 @@
 #include <asm/fsl_portals.h>
 #include <asm/fsl_liodn.h>
 #include <fm_eth.h>
-#include <asm/mpc85xx_gpio.h>
-
+#include "../common/sleep.h"
 #include "t104xrdb.h"
 #include "cpld.h"
 
@@ -44,6 +43,16 @@
 	return 0;
 }
 
+int board_early_init_f(void)
+{
+#if defined(CONFIG_DEEP_SLEEP)
+	if (is_warm_boot())
+		fsl_dp_disable_console();
+#endif
+
+	return 0;
+}
+
 int board_early_init_r(void)
 {
 #ifdef CONFIG_SYS_FLASH_BASE
@@ -113,14 +122,3 @@
 
 	return 0;
 }
-
-#ifdef CONFIG_DEEP_SLEEP
-void board_mem_sleep_setup(void)
-{
-	/* does not provide HW signals for power management */
-	CPLD_WRITE(misc_ctl_status, (CPLD_READ(misc_ctl_status) & ~0x40));
-	/* Disable MCKE isolation */
-	gpio_set_value(2, 0);
-	udelay(1);
-}
-#endif
diff -ruN u-boot-2015.01-rc3/board/google/chromebook_link/Kconfig u-boot/board/google/chromebook_link/Kconfig
--- u-boot-2015.01-rc3/board/google/chromebook_link/Kconfig	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/google/chromebook_link/Kconfig	2015-01-01 17:34:32.401500826 +0100
@@ -19,6 +19,7 @@
 	select SOUTHBRIDGE_INTEL_C216
 	select HAVE_ACPI_RESUME
 	select MARK_GRAPHICS_MEM_WRCOMB
+	select BOARD_ROMSIZE_KB_8192
 
 config MMCONF_BASE_ADDRESS
 	hex
diff -ruN u-boot-2015.01-rc3/board/google/chromebook_link/link.c u-boot/board/google/chromebook_link/link.c
--- u-boot-2015.01-rc3/board/google/chromebook_link/link.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/google/chromebook_link/link.c	2015-01-01 17:34:32.401500826 +0100
@@ -7,6 +7,9 @@
 #include <common.h>
 #include <cros_ec.h>
 #include <asm/gpio.h>
+#include <asm/io.h>
+#include <asm/pci.h>
+#include <asm/arch/pch.h>
 
 int arch_early_init_r(void)
 {
@@ -121,3 +124,40 @@
 
 	return 0;
 }
+
+void setup_pch_gpios(u16 gpiobase, const struct pch_gpio_map *gpio)
+{
+	/* GPIO Set 1 */
+	if (gpio->set1.level)
+		outl(*((u32 *)gpio->set1.level), gpiobase + GP_LVL);
+	if (gpio->set1.mode)
+		outl(*((u32 *)gpio->set1.mode), gpiobase + GPIO_USE_SEL);
+	if (gpio->set1.direction)
+		outl(*((u32 *)gpio->set1.direction), gpiobase + GP_IO_SEL);
+	if (gpio->set1.reset)
+		outl(*((u32 *)gpio->set1.reset), gpiobase + GP_RST_SEL1);
+	if (gpio->set1.invert)
+		outl(*((u32 *)gpio->set1.invert), gpiobase + GPI_INV);
+	if (gpio->set1.blink)
+		outl(*((u32 *)gpio->set1.blink), gpiobase + GPO_BLINK);
+
+	/* GPIO Set 2 */
+	if (gpio->set2.level)
+		outl(*((u32 *)gpio->set2.level), gpiobase + GP_LVL2);
+	if (gpio->set2.mode)
+		outl(*((u32 *)gpio->set2.mode), gpiobase + GPIO_USE_SEL2);
+	if (gpio->set2.direction)
+		outl(*((u32 *)gpio->set2.direction), gpiobase + GP_IO_SEL2);
+	if (gpio->set2.reset)
+		outl(*((u32 *)gpio->set2.reset), gpiobase + GP_RST_SEL2);
+
+	/* GPIO Set 3 */
+	if (gpio->set3.level)
+		outl(*((u32 *)gpio->set3.level), gpiobase + GP_LVL3);
+	if (gpio->set3.mode)
+		outl(*((u32 *)gpio->set3.mode), gpiobase + GPIO_USE_SEL3);
+	if (gpio->set3.direction)
+		outl(*((u32 *)gpio->set3.direction), gpiobase + GP_IO_SEL3);
+	if (gpio->set3.reset)
+		outl(*((u32 *)gpio->set3.reset), gpiobase + GP_RST_SEL3);
+}
diff -ruN u-boot-2015.01-rc3/board/intel/crownbay/crownbay.c u-boot/board/intel/crownbay/crownbay.c
--- u-boot-2015.01-rc3/board/intel/crownbay/crownbay.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/intel/crownbay/crownbay.c	2015-01-01 17:34:32.405500760 +0100
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/ibmpc.h>
+#include <asm/pnp_def.h>
+#include <netdev.h>
+#include <smsc_lpc47m.h>
+
+#define SERIAL_DEV PNP_DEV(0x2e, 4)
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int board_early_init_f(void)
+{
+	lpc47m_enable_serial(SERIAL_DEV, UART0_BASE);
+
+	return 0;
+}
+
+void setup_pch_gpios(u16 gpiobase, const struct pch_gpio_map *gpio)
+{
+	return;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	return pci_eth_init(bis);
+}
diff -ruN u-boot-2015.01-rc3/board/intel/crownbay/Kconfig u-boot/board/intel/crownbay/Kconfig
--- u-boot-2015.01-rc3/board/intel/crownbay/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/intel/crownbay/Kconfig	2015-01-01 17:34:32.405500760 +0100
@@ -0,0 +1,20 @@
+if TARGET_CROWNBAY
+
+config SYS_BOARD
+	default "crownbay"
+
+config SYS_VENDOR
+	default "intel"
+
+config SYS_SOC
+	default "queensbay"
+
+config SYS_CONFIG_NAME
+	default "crownbay"
+
+config BOARD_SPECIFIC_OPTIONS # dummy
+	def_bool y
+	select INTEL_QUEENSBAY
+	select BOARD_ROMSIZE_KB_1024
+
+endif
diff -ruN u-boot-2015.01-rc3/board/intel/crownbay/MAINTAINERS u-boot/board/intel/crownbay/MAINTAINERS
--- u-boot-2015.01-rc3/board/intel/crownbay/MAINTAINERS	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/intel/crownbay/MAINTAINERS	2015-01-01 17:34:32.405500760 +0100
@@ -0,0 +1,6 @@
+INTEL CROWNBAY BOARD
+M:	Bin Meng <bmeng.cn@gmail.com>
+S:	Maintained
+F:	board/intel/crownbay/
+F:	include/configs/crownbay.h
+F:	configs/crownbay_defconfig
diff -ruN u-boot-2015.01-rc3/board/intel/crownbay/Makefile u-boot/board/intel/crownbay/Makefile
--- u-boot-2015.01-rc3/board/intel/crownbay/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/intel/crownbay/Makefile	2015-01-01 17:34:32.405500760 +0100
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	+= crownbay.o start.o
diff -ruN u-boot-2015.01-rc3/board/intel/crownbay/start.S u-boot/board/intel/crownbay/start.S
--- u-boot-2015.01-rc3/board/intel/crownbay/start.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/intel/crownbay/start.S	2015-01-01 17:34:32.405500760 +0100
@@ -0,0 +1,9 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+.globl early_board_init
+early_board_init:
+	jmp	early_board_init_ret
diff -ruN u-boot-2015.01-rc3/board/nvidia/cardhu/cardhu.c u-boot/board/nvidia/cardhu/cardhu.c
--- u-boot-2015.01-rc3/board/nvidia/cardhu/cardhu.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/nvidia/cardhu/cardhu.c	2015-01-01 17:34:32.449500039 +0100
@@ -6,6 +6,7 @@
  */
 
 #include <common.h>
+#include <dm.h>
 #include <asm/arch/pinmux.h>
 #include <asm/arch/gp_padctrl.h>
 #include "pinmux-config-cardhu.h"
@@ -37,17 +38,23 @@
  */
 void board_sdmmc_voltage_init(void)
 {
+	struct udevice *dev;
 	uchar reg, data_buffer[1];
+	int ret;
 	int i;
 
-	i2c_set_bus_num(0);	/* PMU is on bus 0 */
+	ret = i2c_get_chip_for_busnum(0, PMU_I2C_ADDRESS, &dev);
+	if (ret) {
+		debug("%s: Cannot find PMIC I2C chip\n", __func__);
+		return;
+	}
 
 	/* TPS659110: LDO5_REG = 3.3v, ACTIVE to SDMMC1 */
 	data_buffer[0] = 0x65;
 	reg = 0x32;
 
 	for (i = 0; i < MAX_I2C_RETRY; ++i) {
-		if (i2c_write(PMU_I2C_ADDRESS, reg, 1, data_buffer, 1))
+		if (i2c_write(dev, reg, data_buffer, 1))
 			udelay(100);
 	}
 
@@ -56,7 +63,7 @@
 	reg = 0x67;
 
 	for (i = 0; i < MAX_I2C_RETRY; ++i) {
-		if (i2c_write(PMU_I2C_ADDRESS, reg, 1, data_buffer, 1))
+		if (i2c_write(dev, reg, data_buffer, 1))
 			udelay(100);
 	}
 }
diff -ruN u-boot-2015.01-rc3/board/nvidia/common/board.c u-boot/board/nvidia/common/board.c
--- u-boot-2015.01-rc3/board/nvidia/common/board.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/nvidia/common/board.c	2015-01-01 17:34:32.453499973 +0100
@@ -113,10 +113,6 @@
 	power_det_init();
 
 #ifdef CONFIG_SYS_I2C_TEGRA
-#ifndef CONFIG_SYS_I2C_INIT_BOARD
-#error "You must define CONFIG_SYS_I2C_INIT_BOARD to use i2c on Nvidia boards"
-#endif
-	i2c_init_board();
 # ifdef CONFIG_TEGRA_PMU
 	if (pmu_set_nominal())
 		debug("Failed to select nominal voltages\n");
diff -ruN u-boot-2015.01-rc3/board/nvidia/dalmore/dalmore.c u-boot/board/nvidia/dalmore/dalmore.c
--- u-boot-2015.01-rc3/board/nvidia/dalmore/dalmore.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/nvidia/dalmore/dalmore.c	2015-01-01 17:34:32.453499973 +0100
@@ -15,6 +15,7 @@
  */
 
 #include <common.h>
+#include <dm.h>
 #include <asm/arch/pinmux.h>
 #include <asm/arch/gp_padctrl.h>
 #include "pinmux-config-dalmore.h"
@@ -50,18 +51,21 @@
  */
 void board_sdmmc_voltage_init(void)
 {
+	struct udevice *dev;
 	uchar reg, data_buffer[1];
 	int ret;
 
-	ret = i2c_set_bus_num(0);/* PMU is on bus 0 */
-	if (ret)
-		printf("%s: i2c_set_bus_num returned %d\n", __func__, ret);
+	ret = i2c_get_chip_for_busnum(0, PMU_I2C_ADDRESS, &dev);
+	if (ret) {
+		debug("%s: Cannot find PMIC I2C chip\n", __func__);
+		return;
+	}
 
 	/* TPS65913: LDO9_VOLTAGE = 3.3V */
 	data_buffer[0] = 0x31;
 	reg = 0x61;
 
-	ret = i2c_write(PMU_I2C_ADDRESS, reg, 1, data_buffer, 1);
+	ret = i2c_write(dev, reg, data_buffer, 1);
 	if (ret)
 		printf("%s: PMU i2c_write %02X<-%02X returned %d\n",
 			__func__, reg, data_buffer[0], ret);
@@ -70,7 +74,7 @@
 	data_buffer[0] = 0x01;
 	reg = 0x60;
 
-	ret = i2c_write(PMU_I2C_ADDRESS, reg, 1, data_buffer, 1);
+	ret = i2c_write(dev, reg, data_buffer, 1);
 	if (ret)
 		printf("%s: PMU i2c_write %02X<-%02X returned %d\n",
 			__func__, reg, data_buffer[0], ret);
@@ -79,7 +83,12 @@
 	data_buffer[0] = 0x03;
 	reg = 0x14;
 
-	ret = i2c_write(BAT_I2C_ADDRESS, reg, 1, data_buffer, 1);
+	ret = i2c_get_chip_for_busnum(0, BAT_I2C_ADDRESS, &dev);
+	if (ret) {
+		debug("%s: Cannot find charger I2C chip\n", __func__);
+		return;
+	}
+	ret = i2c_write(dev, reg, data_buffer, 1);
 	if (ret)
 		printf("%s: BAT i2c_write %02X<-%02X returned %d\n",
 			__func__, reg, data_buffer[0], ret);
diff -ruN u-boot-2015.01-rc3/board/nvidia/nyan-big/Kconfig u-boot/board/nvidia/nyan-big/Kconfig
--- u-boot-2015.01-rc3/board/nvidia/nyan-big/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/nvidia/nyan-big/Kconfig	2015-01-01 17:34:32.453499973 +0100
@@ -0,0 +1,24 @@
+if TARGET_NYAN_BIG
+
+config SYS_CPU
+	string
+	default "arm720t" if SPL_BUILD
+	default "armv7" if !SPL_BUILD
+
+config SYS_BOARD
+	string
+	default "nyan-big"
+
+config SYS_VENDOR
+	string
+	default "nvidia"
+
+config SYS_SOC
+	string
+	default "tegra124"
+
+config SYS_CONFIG_NAME
+	string
+	default "nyan-big"
+
+endif
diff -ruN u-boot-2015.01-rc3/board/nvidia/nyan-big/MAINTAINERS u-boot/board/nvidia/nyan-big/MAINTAINERS
--- u-boot-2015.01-rc3/board/nvidia/nyan-big/MAINTAINERS	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/nvidia/nyan-big/MAINTAINERS	2015-01-01 17:34:32.453499973 +0100
@@ -0,0 +1,6 @@
+NORRIN BOARD
+M:	Allen Martin <amartin@nvidia.com>
+S:	Maintained
+F:	board/nvidia/nyan-big/
+F:	include/configs/nyan-big.h
+F:	configs/nyan-big_defconfig
diff -ruN u-boot-2015.01-rc3/board/nvidia/nyan-big/Makefile u-boot/board/nvidia/nyan-big/Makefile
--- u-boot-2015.01-rc3/board/nvidia/nyan-big/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/nvidia/nyan-big/Makefile	2015-01-01 17:34:32.453499973 +0100
@@ -0,0 +1,9 @@
+#
+# (C) Copyright 2014
+# NVIDIA Corporation <www.nvidia.com>
+#
+# SPDX-License-Identifier:     GPL-2.0+
+#
+
+obj-y	+= ../venice2/as3722_init.o
+obj-y	+= nyan-big.o
diff -ruN u-boot-2015.01-rc3/board/nvidia/nyan-big/nyan-big.c u-boot/board/nvidia/nyan-big/nyan-big.c
--- u-boot-2015.01-rc3/board/nvidia/nyan-big/nyan-big.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/nvidia/nyan-big/nyan-big.c	2015-01-01 17:34:32.453499973 +0100
@@ -0,0 +1,27 @@
+/*
+ * (C) Copyright 2014
+ * NVIDIA Corporation <www.nvidia.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pinmux.h>
+#include "pinmux-config-nyan-big.h"
+
+/*
+ * Routine: pinmux_init
+ * Description: Do individual peripheral pinmux configs
+ */
+void pinmux_init(void)
+{
+	gpio_config_table(nyan_big_gpio_inits,
+			  ARRAY_SIZE(nyan_big_gpio_inits));
+
+	pinmux_config_pingrp_table(nyan_big_pingrps,
+				   ARRAY_SIZE(nyan_big_pingrps));
+
+	pinmux_config_drvgrp_table(nyan_big_drvgrps,
+				   ARRAY_SIZE(nyan_big_drvgrps));
+}
diff -ruN u-boot-2015.01-rc3/board/nvidia/nyan-big/pinmux-config-nyan-big.h u-boot/board/nvidia/nyan-big/pinmux-config-nyan-big.h
--- u-boot-2015.01-rc3/board/nvidia/nyan-big/pinmux-config-nyan-big.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/nvidia/nyan-big/pinmux-config-nyan-big.h	2015-01-01 17:34:32.453499973 +0100
@@ -0,0 +1,287 @@
+/*
+ * Copyright (c) 2014, NVIDIA CORPORATION. All rights reserved.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef _PINMUX_CONFIG_NYAN_BIG_H_
+#define _PINMUX_CONFIG_NYAN_BIG_H_
+
+#define GPIO_INIT(_gpio, _init)				\
+	{						\
+		.gpio	= GPIO_P##_gpio,		\
+		.init	= TEGRA_GPIO_INIT_##_init,	\
+	}
+
+static const struct tegra_gpio_config nyan_big_gpio_inits[] = {
+	/*        gpio, init_val */
+	GPIO_INIT(A0,   IN),
+	GPIO_INIT(C7,   IN),
+	GPIO_INIT(G0,   IN),
+	GPIO_INIT(G1,   IN),
+	GPIO_INIT(G2,   IN),
+	GPIO_INIT(G3,   IN),
+	GPIO_INIT(H2,   IN),
+	GPIO_INIT(H4,   IN),
+	GPIO_INIT(H6,   IN),
+	GPIO_INIT(H7,   OUT1),
+	GPIO_INIT(I0,   IN),
+	GPIO_INIT(I1,   IN),
+	GPIO_INIT(I5,   OUT1),
+	GPIO_INIT(I6,   IN),
+	GPIO_INIT(I7,   IN),
+	GPIO_INIT(J0,   IN),
+	GPIO_INIT(J7,   IN),
+	GPIO_INIT(K1,   OUT0),
+	GPIO_INIT(K2,   IN),
+	GPIO_INIT(K4,   OUT0),
+	GPIO_INIT(K6,   OUT0),
+	GPIO_INIT(K7,   IN),
+	GPIO_INIT(N7,   IN),
+	GPIO_INIT(P2,   OUT0),
+	GPIO_INIT(Q0,   IN),
+	GPIO_INIT(Q2,   IN),
+	GPIO_INIT(Q3,   IN),
+	GPIO_INIT(Q6,   IN),
+	GPIO_INIT(Q7,   IN),
+	GPIO_INIT(R0,   OUT0),
+	GPIO_INIT(R1,   IN),
+	GPIO_INIT(R4,   IN),
+	GPIO_INIT(R7,   IN),
+	GPIO_INIT(S3,   OUT0),
+	GPIO_INIT(S4,   OUT0),
+	GPIO_INIT(S7,   IN),
+	GPIO_INIT(T1,   IN),
+	GPIO_INIT(U4,   IN),
+	GPIO_INIT(U5,   IN),
+	GPIO_INIT(U6,   IN),
+	GPIO_INIT(V0,   IN),
+	GPIO_INIT(W3,   IN),
+	GPIO_INIT(X1,   IN),
+	GPIO_INIT(X4,   IN),
+	GPIO_INIT(X7,   OUT0),
+};
+
+#define PINCFG(_pingrp, _mux, _pull, _tri, _io, _od, _rcv_sel)	\
+	{							\
+		.pingrp		= PMUX_PINGRP_##_pingrp,	\
+		.func		= PMUX_FUNC_##_mux,		\
+		.pull		= PMUX_PULL_##_pull,		\
+		.tristate	= PMUX_TRI_##_tri,		\
+		.io		= PMUX_PIN_##_io,		\
+		.od		= PMUX_PIN_OD_##_od,		\
+		.rcv_sel	= PMUX_PIN_RCV_SEL_##_rcv_sel,	\
+		.lock		= PMUX_PIN_LOCK_DEFAULT,	\
+		.ioreset	= PMUX_PIN_IO_RESET_DEFAULT,	\
+	}
+
+static const struct pmux_pingrp_config nyan_big_pingrps[] = {
+	/*     pingrp,                 mux,         pull,   tri,      e_input, od,      rcv_sel */
+	PINCFG(CLK_32K_OUT_PA0,        DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(UART3_CTS_N_PA1,        GMI,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP2_FS_PA2,            I2S1,        NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(DAP2_SCLK_PA3,          I2S1,        NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(DAP2_DIN_PA4,           I2S1,        NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(DAP2_DOUT_PA5,          I2S1,        NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC3_CLK_PA6,         SDMMC3,      NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(SDMMC3_CMD_PA7,         SDMMC3,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PB0,                    RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PB1,                    RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(SDMMC3_DAT3_PB4,        SDMMC3,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC3_DAT2_PB5,        SDMMC3,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC3_DAT1_PB6,        SDMMC3,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC3_DAT0_PB7,        SDMMC3,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(UART3_RTS_N_PC0,        GMI,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(UART2_TXD_PC2,          IRDA,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(UART2_RXD_PC3,          IRDA,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(GEN1_I2C_SCL_PC4,       I2C1,        NORMAL, NORMAL,   INPUT,   ENABLE,  DEFAULT),
+	PINCFG(GEN1_I2C_SDA_PC5,       I2C1,        NORMAL, NORMAL,   INPUT,   ENABLE,  DEFAULT),
+	PINCFG(PC7,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PG0,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PG1,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PG2,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PG3,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PG4,                    SPI4,        NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PG5,                    SPI4,        NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PG6,                    SPI4,        NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PG7,                    SPI4,        NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PH0,                    GMI,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PH1,                    PWM1,        NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PH2,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PH3,                    GMI,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PH4,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PH5,                    RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PH6,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PH7,                    DEFAULT,     NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PI0,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PI1,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PI2,                    RSVD4,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PI3,                    SPI4,        NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PI4,                    GMI,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PI5,                    DEFAULT,     UP,     NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PI6,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PI7,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PJ0,                    DEFAULT,     UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PJ2,                    RSVD1,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(UART2_CTS_N_PJ5,        GMI,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(UART2_RTS_N_PJ6,        GMI,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PJ7,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PK0,                    RSVD1,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PK1,                    DEFAULT,     NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PK2,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PK3,                    GMI,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PK4,                    DEFAULT,     UP,     NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(SPDIF_OUT_PK5,          RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(SPDIF_IN_PK6,           DEFAULT,     DOWN,   NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PK7,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(DAP1_FS_PN0,            RSVD4,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP1_DIN_PN1,           RSVD4,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP1_DOUT_PN2,          I2S0,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP1_SCLK_PN3,          RSVD4,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(USB_VBUS_EN0_PN4,       USB,         NORMAL, NORMAL,   INPUT,   ENABLE,  DEFAULT),
+	PINCFG(USB_VBUS_EN1_PN5,       USB,         NORMAL, NORMAL,   INPUT,   ENABLE,  DEFAULT),
+	PINCFG(HDMI_INT_PN7,           DEFAULT,     DOWN,   NORMAL,   INPUT,   DEFAULT, NORMAL),
+	PINCFG(ULPI_DATA7_PO0,         ULPI,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(ULPI_DATA0_PO1,         ULPI,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(ULPI_DATA1_PO2,         ULPI,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(ULPI_DATA2_PO3,         ULPI,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(ULPI_DATA3_PO4,         ULPI,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(ULPI_DATA4_PO5,         ULPI,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(ULPI_DATA5_PO6,         ULPI,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(ULPI_DATA6_PO7,         ULPI,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP3_FS_PP0,            I2S2,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP3_DIN_PP1,           I2S2,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP3_DOUT_PP2,          DEFAULT,     NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP3_SCLK_PP3,          RSVD3,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP4_FS_PP4,            RSVD4,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP4_DIN_PP5,           RSVD3,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP4_DOUT_PP6,          RSVD4,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP4_SCLK_PP7,          RSVD3,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_COL0_PQ0,            DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(KB_COL1_PQ1,            RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_COL2_PQ2,            DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(KB_COL3_PQ3,            DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(KB_COL4_PQ4,            SDMMC3,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(KB_COL5_PQ5,            RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_COL6_PQ6,            DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(KB_COL7_PQ7,            DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(KB_ROW0_PR0,            DEFAULT,     NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW1_PR1,            DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(KB_ROW2_PR2,            RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW3_PR3,            KBC,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW4_PR4,            DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(KB_ROW5_PR5,            RSVD3,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW6_PR6,            KBC,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW7_PR7,            DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(KB_ROW8_PS0,            RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW9_PS1,            UARTA,       DOWN,   NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW10_PS2,           UARTA,       NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(KB_ROW11_PS3,           DEFAULT,     NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW12_PS4,           DEFAULT,     NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW13_PS5,           RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW14_PS6,           RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW15_PS7,           DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(KB_ROW16_PT0,           RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(KB_ROW17_PT1,           DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(GEN2_I2C_SCL_PT5,       I2C2,        NORMAL, NORMAL,   INPUT,   ENABLE,  DEFAULT),
+	PINCFG(GEN2_I2C_SDA_PT6,       I2C2,        NORMAL, NORMAL,   INPUT,   ENABLE,  DEFAULT),
+	PINCFG(SDMMC4_CMD_PT7,         SDMMC4,      NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PU0,                    RSVD4,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PU1,                    RSVD1,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PU2,                    RSVD1,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PU3,                    GMI,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PU4,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PU5,                    DEFAULT,     UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PU6,                    DEFAULT,     UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PV0,                    DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PV1,                    RSVD1,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(SDMMC3_CD_N_PV2,        SDMMC3,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC1_WP_N_PV3,        SDMMC1,      DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DDC_SCL_PV4,            I2C4,        NORMAL, NORMAL,   INPUT,   DEFAULT, NORMAL),
+	PINCFG(DDC_SDA_PV5,            I2C4,        NORMAL, NORMAL,   INPUT,   DEFAULT, NORMAL),
+	PINCFG(GPIO_W2_AUD_PW2,        RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(GPIO_W3_AUD_PW3,        DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(DAP_MCLK1_PW4,          EXTPERIPH1,  NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(CLK2_OUT_PW5,           RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(UART3_TXD_PW6,          RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(UART3_RXD_PW7,          RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DVFS_PWM_PX0,           CLDVFS,      NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(GPIO_X1_AUD_PX1,        DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(DVFS_CLK_PX2,           CLDVFS,      NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(GPIO_X3_AUD_PX3,        RSVD4,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(GPIO_X4_AUD_PX4,        DEFAULT,     NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(GPIO_X5_AUD_PX5,        RSVD4,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(GPIO_X6_AUD_PX6,        GMI,         DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(GPIO_X7_AUD_PX7,        DEFAULT,     NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(ULPI_CLK_PY0,           SPI1,        NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(ULPI_DIR_PY1,           SPI1,        NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(ULPI_NXT_PY2,           SPI1,        NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(ULPI_STP_PY3,           SPI1,        NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(SDMMC1_DAT3_PY4,        SDMMC1,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC1_DAT2_PY5,        SDMMC1,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC1_DAT1_PY6,        SDMMC1,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC1_DAT0_PY7,        SDMMC1,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC1_CLK_PZ0,         SDMMC1,      NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC1_CMD_PZ1,         SDMMC1,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PWR_I2C_SCL_PZ6,        I2CPWR,      NORMAL, NORMAL,   INPUT,   ENABLE,  DEFAULT),
+	PINCFG(PWR_I2C_SDA_PZ7,        I2CPWR,      NORMAL, NORMAL,   INPUT,   ENABLE,  DEFAULT),
+	PINCFG(SDMMC4_DAT0_PAA0,       SDMMC4,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC4_DAT1_PAA1,       SDMMC4,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC4_DAT2_PAA2,       SDMMC4,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC4_DAT3_PAA3,       SDMMC4,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC4_DAT4_PAA4,       SDMMC4,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC4_DAT5_PAA5,       SDMMC4,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC4_DAT6_PAA6,       SDMMC4,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(SDMMC4_DAT7_PAA7,       SDMMC4,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(PBB0,                   VGP6,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(CAM_I2C_SCL_PBB1,       RSVD3,       DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(CAM_I2C_SDA_PBB2,       RSVD3,       DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PBB3,                   VGP3,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PBB4,                   VGP4,        DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PBB5,                   RSVD3,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PBB6,                   RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PBB7,                   RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(CAM_MCLK_PCC0,          VI,          DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PCC1,                   RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PCC2,                   RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(SDMMC4_CLK_PCC4,        SDMMC4,      NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(CLK2_REQ_PCC5,          RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PEX_L0_RST_N_PDD1,      RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PEX_L0_CLKREQ_N_PDD2,   RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PEX_WAKE_N_PDD3,        RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PEX_L1_RST_N_PDD5,      RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PEX_L1_CLKREQ_N_PDD6,   RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(CLK3_OUT_PEE0,          RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(CLK3_REQ_PEE1,          RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(DAP_MCLK1_REQ_PEE2,     RSVD4,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(HDMI_CEC_PEE3,          CEC,         NORMAL, NORMAL,   INPUT,   ENABLE,  DEFAULT),
+	PINCFG(SDMMC3_CLK_LB_OUT_PEE4, SDMMC3,      NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(SDMMC3_CLK_LB_IN_PEE5,  SDMMC3,      UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(DP_HPD_PFF0,            DP,          UP,     NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(USB_VBUS_EN2_PFF1,      RSVD2,       DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(PFF2,                   RSVD2,       DOWN,   TRISTATE, OUTPUT,  DISABLE, DEFAULT),
+	PINCFG(CORE_PWR_REQ,           PWRON,       NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(CPU_PWR_REQ,            CPU,         NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(PWR_INT_N,              PMI,         NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(RESET_OUT_N,            RESET_OUT_N, NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+	PINCFG(OWR,                    RSVD2,       DOWN,   TRISTATE, OUTPUT,  DEFAULT, NORMAL),
+	PINCFG(CLK_32K_IN,             CLK,         NORMAL, NORMAL,   INPUT,   DEFAULT, DEFAULT),
+	PINCFG(JTAG_RTCK,              RTCK,        NORMAL, NORMAL,   OUTPUT,  DEFAULT, DEFAULT),
+};
+
+#define DRVCFG(_drvgrp, _slwf, _slwr, _drvup, _drvdn, _lpmd, _schmt, _hsm) \
+	{						\
+		.drvgrp = PMUX_DRVGRP_##_drvgrp,	\
+		.slwf   = _slwf,			\
+		.slwr   = _slwr,			\
+		.drvup  = _drvup,			\
+		.drvdn  = _drvdn,			\
+		.lpmd   = PMUX_LPMD_##_lpmd,		\
+		.schmt  = PMUX_SCHMT_##_schmt,		\
+		.hsm    = PMUX_HSM_##_hsm,		\
+	}
+
+static const struct pmux_drvgrp_config nyan_big_drvgrps[] = {
+};
+
+#endif /* PINMUX_CONFIG_NYAN_BIG_H */
diff -ruN u-boot-2015.01-rc3/board/nvidia/venice2/as3722_init.h u-boot/board/nvidia/venice2/as3722_init.h
--- u-boot-2015.01-rc3/board/nvidia/venice2/as3722_init.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/nvidia/venice2/as3722_init.h	2015-01-01 17:34:32.453499973 +0100
@@ -18,7 +18,7 @@
 #define AS3722_LDO6VOLTAGE_REG	0x16	/* VDD_SDMMC */
 #define AS3722_LDCONTROL_REG	0x4E
 
-#ifdef CONFIG_TARGET_JETSON_TK1
+#if defined(CONFIG_TARGET_JETSON_TK1) || defined(CONFIG_TARGET_NYAN_BIG)
 #define AS3722_SD0VOLTAGE_DATA	(0x3C00 | AS3722_SD0VOLTAGE_REG)
 #else
 #define AS3722_SD0VOLTAGE_DATA	(0x2800 | AS3722_SD0VOLTAGE_REG)
diff -ruN u-boot-2015.01-rc3/board/nvidia/whistler/whistler.c u-boot/board/nvidia/whistler/whistler.c
--- u-boot-2015.01-rc3/board/nvidia/whistler/whistler.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/nvidia/whistler/whistler.c	2015-01-01 17:34:32.453499973 +0100
@@ -6,6 +6,7 @@
  */
 
 #include <common.h>
+#include <dm.h>
 #include <asm/io.h>
 #include <asm/arch/tegra.h>
 #include <asm/arch/clock.h>
@@ -21,23 +22,26 @@
  */
 void pin_mux_mmc(void)
 {
+	struct udevice *dev;
 	uchar val;
 	int ret;
 
 	/* Turn on MAX8907B LDO12 to 2.8V for J40 power */
-	ret = i2c_set_bus_num(0);
-	if (ret)
-		printf("i2c_set_bus_num failed: %d\n", ret);
+	ret = i2c_get_chip_for_busnum(0, 0x3c, &dev);
+	if (ret) {
+		printf("%s: Cannot find MAX8907B I2C chip\n", __func__);
+		return;
+	}
 	val = 0x29;
-	ret = i2c_write(0x3c, 0x46, 1, &val, 1);
+	ret = i2c_write(dev, 0x46, &val, 1);
 	if (ret)
 		printf("i2c_write 0 0x3c 0x46 failed: %d\n", ret);
 	val = 0x00;
-	ret = i2c_write(0x3c, 0x45, 1, &val, 1);
+	ret = i2c_write(dev, 0x45, &val, 1);
 	if (ret)
 		printf("i2c_write 0 0x3c 0x45 failed: %d\n", ret);
 	val = 0x1f;
-	ret = i2c_write(0x3c, 0x44, 1, &val, 1);
+	ret = i2c_write(dev, 0x44, &val, 1);
 	if (ret)
 		printf("i2c_write 0 0x3c 0x44 failed: %d\n", ret);
 
@@ -49,6 +53,7 @@
 /* this is a weak define that we are overriding */
 void pin_mux_usb(void)
 {
+	struct udevice *dev;
 	uchar val;
 	int ret;
 
@@ -59,15 +64,17 @@
 	 */
 
 	/* Turn on TAC6416's GPIO 0+1 for USB1/3's VBUS */
-	ret = i2c_set_bus_num(0);
-	if (ret)
-		printf("i2c_set_bus_num failed: %d\n", ret);
+	ret = i2c_get_chip_for_busnum(0, 0x20, &dev);
+	if (ret) {
+		printf("%s: Cannot find TAC6416 I2C chip\n", __func__);
+		return;
+	}
 	val = 0x03;
-	ret = i2c_write(0x20, 2, 1, &val, 1);
+	ret = i2c_write(dev, 2, &val, 1);
 	if (ret)
 		printf("i2c_write 0 0x20 2 failed: %d\n", ret);
 	val = 0xfc;
-	ret = i2c_write(0x20, 6, 1, &val, 1);
+	ret = i2c_write(dev, 6, &val, 1);
 	if (ret)
 		printf("i2c_write 0 0x20 6 failed: %d\n", ret);
 }
diff -ruN u-boot-2015.01-rc3/board/raspberrypi/rpi/rpi.c u-boot/board/raspberrypi/rpi/rpi.c
--- u-boot-2015.01-rc3/board/raspberrypi/rpi/rpi.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/raspberrypi/rpi/rpi.c	2015-01-01 17:34:32.469499711 +0100
@@ -24,6 +24,7 @@
 #include <asm/arch/mbox.h>
 #include <asm/arch/sdhci.h>
 #include <asm/global_data.h>
+#include <dm/platform_data/serial_pl01x.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -36,6 +37,17 @@
 	.platdata = &gpio_platdata,
 };
 
+static const struct pl01x_serial_platdata serial_platdata = {
+	.base = 0x20201000,
+	.type = TYPE_PL011,
+	.clock = 3000000,
+};
+
+U_BOOT_DEVICE(bcm2835_serials) = {
+	.name = "serial_pl01x",
+	.platdata = &serial_platdata,
+};
+
 struct msg_get_arm_mem {
 	struct bcm2835_mbox_hdr hdr;
 	struct bcm2835_mbox_tag_get_arm_mem get_arm_mem;
@@ -70,58 +82,82 @@
 static const struct {
 	const char *name;
 	const char *fdtfile;
+	bool has_onboard_eth;
 } models[] = {
+	[0] = {
+		"Unknown model",
+		"bcm2835-rpi-other.dtb",
+		false,
+	},
 	[BCM2835_BOARD_REV_B_I2C0_2] = {
 		"Model B (no P5)",
 		"bcm2835-rpi-b-i2c0.dtb",
+		true,
 	},
 	[BCM2835_BOARD_REV_B_I2C0_3] = {
 		"Model B (no P5)",
 		"bcm2835-rpi-b-i2c0.dtb",
+		true,
 	},
 	[BCM2835_BOARD_REV_B_I2C1_4] = {
 		"Model B",
 		"bcm2835-rpi-b.dtb",
+		true,
 	},
 	[BCM2835_BOARD_REV_B_I2C1_5] = {
 		"Model B",
 		"bcm2835-rpi-b.dtb",
+		true,
 	},
 	[BCM2835_BOARD_REV_B_I2C1_6] = {
 		"Model B",
 		"bcm2835-rpi-b.dtb",
+		true,
 	},
 	[BCM2835_BOARD_REV_A_7] = {
 		"Model A",
 		"bcm2835-rpi-a.dtb",
+		false,
 	},
 	[BCM2835_BOARD_REV_A_8] = {
 		"Model A",
 		"bcm2835-rpi-a.dtb",
+		false,
 	},
 	[BCM2835_BOARD_REV_A_9] = {
 		"Model A",
 		"bcm2835-rpi-a.dtb",
+		false,
 	},
 	[BCM2835_BOARD_REV_B_REV2_d] = {
 		"Model B rev2",
 		"bcm2835-rpi-b-rev2.dtb",
+		true,
 	},
 	[BCM2835_BOARD_REV_B_REV2_e] = {
 		"Model B rev2",
 		"bcm2835-rpi-b-rev2.dtb",
+		true,
 	},
 	[BCM2835_BOARD_REV_B_REV2_f] = {
 		"Model B rev2",
 		"bcm2835-rpi-b-rev2.dtb",
+		true,
 	},
 	[BCM2835_BOARD_REV_B_PLUS] = {
 		"Model B+",
 		"bcm2835-rpi-b-plus.dtb",
+		true,
 	},
 	[BCM2835_BOARD_REV_CM] = {
 		"Compute Module",
 		"bcm2835-rpi-cm.dtb",
+		false,
+	},
+	[BCM2835_BOARD_REV_A_PLUS] = {
+		"Model A+",
+		"bcm2835-rpi-a-plus.dtb",
+		false,
 	},
 };
 
@@ -154,9 +190,6 @@
 		return;
 
 	fdtfile = models[rpi_board_rev].fdtfile;
-	if (!fdtfile)
-		fdtfile = "bcm2835-rpi-other.dtb";
-
 	setenv("fdtfile", fdtfile);
 }
 
@@ -165,6 +198,9 @@
 	ALLOC_ALIGN_BUFFER(struct msg_get_mac_address, msg, 1, 16);
 	int ret;
 
+	if (!models[rpi_board_rev].has_onboard_eth)
+		return;
+
 	if (getenv("usbethaddr"))
 		return;
 
@@ -231,12 +267,17 @@
 	}
 
 	rpi_board_rev = msg->get_board_rev.body.resp.rev;
-	if (rpi_board_rev >= ARRAY_SIZE(models))
+	if (rpi_board_rev >= ARRAY_SIZE(models)) {
+		printf("RPI: Board rev %u outside known range\n",
+		       rpi_board_rev);
 		rpi_board_rev = 0;
+	}
+	if (!models[rpi_board_rev].name) {
+		printf("RPI: Board rev %u unknown\n", rpi_board_rev);
+		rpi_board_rev = 0;
+	}
 
 	name = models[rpi_board_rev].name;
-	if (!name)
-		name = "Unknown model";
 	printf("RPI model: %s\n", name);
 }
 
diff -ruN u-boot-2015.01-rc3/board/renesas/alt/alt.c u-boot/board/renesas/alt/alt.c
--- u-boot-2015.01-rc3/board/renesas/alt/alt.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/renesas/alt/alt.c	2015-01-01 17:34:32.473499645 +0100
@@ -15,6 +15,8 @@
 #include <asm/arch/sys_proto.h>
 #include <asm/gpio.h>
 #include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
+#include <asm/arch/mmc.h>
 #include <netdev.h>
 #include <miiphy.h>
 #include <i2c.h>
@@ -37,30 +39,11 @@
 	qos_init();
 }
 
-#define MSTPSR1		0xE6150038
-#define SMSTPCR1	0xE6150134
 #define TMU0_MSTP125	(1 << 25)
-
-#define MSTPSR7		0xE61501C4
-#define SMSTPCR7	0xE615014C
 #define SCIF2_MSTP719	(1 << 19)
-
-#define MSTPSR8		0xE61509A0
-#define SMSTPCR8	0xE6150990
 #define ETHER_MSTP813	(1 << 13)
-
-#define MSTPSR3		0xE6150048
-#define SMSTPCR3	0xE615013C
 #define IIC1_MSTP323	(1 << 23)
-
-#define mstp_setbits(type, addr, saddr, set) \
-	out_##type((saddr), in_##type(addr) | (set))
-#define mstp_clrbits(type, addr, saddr, clear) \
-	out_##type((saddr), in_##type(addr) & ~(clear))
-#define mstp_setbits_le32(addr, saddr, set) \
-	mstp_setbits(le32, addr, saddr, set)
-#define mstp_clrbits_le32(addr, saddr, clear)   \
-	mstp_clrbits(le32, addr, saddr, clear)
+#define MMC0_MSTP315	(1 << 15)
 
 int board_early_init_f(void)
 {
@@ -76,15 +59,13 @@
 	/* IIC1 / sh-i2c ch1 */
 	mstp_clrbits_le32(MSTPSR3, SMSTPCR3, IIC1_MSTP323);
 
+#ifdef CONFIG_SH_MMCIF
+	/* MMC */
+	mstp_clrbits_le32(MSTPSR3, SMSTPCR3, MMC0_MSTP315);
+#endif
 	return 0;
 }
 
-void arch_preboot_os(void)
-{
-	/* Disable TMU0 */
-	mstp_setbits_le32(MSTPSR1, SMSTPCR1, TMU0_MSTP125);
-}
-
 int board_init(void)
 {
 	/* adress of boot parameters */
@@ -145,6 +126,19 @@
 #endif
 }
 
+int board_mmc_init(bd_t *bis)
+{
+	int ret = 0;
+
+#ifdef CONFIG_SH_MMCIF
+	gpio_request(GPIO_GP_4_31, NULL);
+	gpio_set_value(GPIO_GP_4_31, 1);
+
+	ret = mmcif_mmc_init();
+#endif
+	return ret;
+}
+
 int dram_init(void)
 {
 	gd->ram_size = CONFIG_SYS_SDRAM_SIZE;
diff -ruN u-boot-2015.01-rc3/board/renesas/alt/Makefile u-boot/board/renesas/alt/Makefile
--- u-boot-2015.01-rc3/board/renesas/alt/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/renesas/alt/Makefile	2015-01-01 17:34:32.473499645 +0100
@@ -6,4 +6,4 @@
 # SPDX-License-Identifier: GPL-2.0
 #
 
-obj-y	:= alt.o qos.o
+obj-y	:= alt.o qos.o ../rcar-gen2-common/common.o
diff -ruN u-boot-2015.01-rc3/board/renesas/gose/gose.c u-boot/board/renesas/gose/gose.c
--- u-boot-2015.01-rc3/board/renesas/gose/gose.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/renesas/gose/gose.c	2015-01-01 17:34:32.473499645 +0100
@@ -15,6 +15,7 @@
 #include <asm/arch/sys_proto.h>
 #include <asm/gpio.h>
 #include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
 #include <netdev.h>
 #include <miiphy.h>
 #include <i2c.h>
@@ -41,27 +42,10 @@
 	qos_init();
 }
 
-#define MSTPSR1		0xE6150038
-#define SMSTPCR1	0xE6150134
 #define TMU0_MSTP125	(1 << 25)
-
-#define MSTPSR7		0xE61501C4
-#define SMSTPCR7	0xE615014C
 #define SCIF0_MSTP721	(1 << 21)
-
-#define MSTPSR8		0xE61509A0
-#define SMSTPCR8	0xE6150990
 #define ETHER_MSTP813	(1 << 13)
 
-#define mstp_setbits(type, addr, saddr, set) \
-	out_##type((saddr), in_##type(addr) | (set))
-#define mstp_clrbits(type, addr, saddr, clear) \
-	out_##type((saddr), in_##type(addr) & ~(clear))
-#define mstp_setbits_le32(addr, saddr, set) \
-	mstp_setbits(le32, addr, saddr, set)
-#define mstp_clrbits_le32(addr, saddr, clear) \
-	mstp_clrbits(le32, addr, saddr, clear)
-
 int board_early_init_f(void)
 {
 	/* TMU0 */
@@ -76,16 +60,6 @@
 	return 0;
 }
 
-#define TSTR0		0x04
-#define TSTR0_STR0	0x01
-void arch_preboot_os(void)
-{
-	/* stop TMU0 */
-	mstp_clrbits_le32(TMU_BASE + TSTR0, TMU_BASE + TSTR0, TSTR0_STR0);
-	/* Disable TMU0 */
-	mstp_setbits_le32(MSTPSR1, SMSTPCR1, TMU0_MSTP125);
-}
-
 #define PUPR5		0xE6060114
 #define PUPR5_ETH	0x3FFC0000
 #define PUPR5_ETH_MAGIC	(1 << 27)
diff -ruN u-boot-2015.01-rc3/board/renesas/gose/Makefile u-boot/board/renesas/gose/Makefile
--- u-boot-2015.01-rc3/board/renesas/gose/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/renesas/gose/Makefile	2015-01-01 17:34:32.473499645 +0100
@@ -6,4 +6,4 @@
 # SPDX-License-Identifier: GPL-2.0
 #
 
-obj-y	:= gose.o qos.o
+obj-y	:= gose.o qos.o ../rcar-gen2-common/common.o
diff -ruN u-boot-2015.01-rc3/board/renesas/koelsch/koelsch.c u-boot/board/renesas/koelsch/koelsch.c
--- u-boot-2015.01-rc3/board/renesas/koelsch/koelsch.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/renesas/koelsch/koelsch.c	2015-01-01 17:34:32.473499645 +0100
@@ -16,6 +16,7 @@
 #include <asm/arch/sys_proto.h>
 #include <asm/gpio.h>
 #include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
 #include <netdev.h>
 #include <miiphy.h>
 #include <i2c.h>
@@ -43,27 +44,10 @@
 	qos_init();
 }
 
-#define MSTPSR1		0xE6150038
-#define SMSTPCR1	0xE6150134
 #define TMU0_MSTP125	(1 << 25)
-
-#define MSTPSR7		0xE61501C4
-#define SMSTPCR7	0xE615014C
 #define SCIF0_MSTP721	(1 << 21)
-
-#define MSTPSR8		0xE61509A0
-#define SMSTPCR8	0xE6150990
 #define ETHER_MSTP813	(1 << 13)
 
-#define mstp_setbits(type, addr, saddr, set) \
-	out_##type((saddr), in_##type(addr) | (set))
-#define mstp_clrbits(type, addr, saddr, clear) \
-	out_##type((saddr), in_##type(addr) & ~(clear))
-#define mstp_setbits_le32(addr, saddr, set) \
-	mstp_setbits(le32, addr, saddr, set)
-#define mstp_clrbits_le32(addr, saddr, clear)   \
-	mstp_clrbits(le32, addr, saddr, clear)
-
 int board_early_init_f(void)
 {
 	mstp_clrbits_le32(MSTPSR1, SMSTPCR1, TMU0_MSTP125);
@@ -77,12 +61,6 @@
 	return 0;
 }
 
-void arch_preboot_os(void)
-{
-	/* Disable TMU0 */
-	mstp_setbits_le32(MSTPSR1, SMSTPCR1, TMU0_MSTP125);
-}
-
 /* LSI pin pull-up control */
 #define PUPR5 0xe6060114
 #define PUPR5_ETH 0x3FFC0000
diff -ruN u-boot-2015.01-rc3/board/renesas/koelsch/Makefile u-boot/board/renesas/koelsch/Makefile
--- u-boot-2015.01-rc3/board/renesas/koelsch/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/renesas/koelsch/Makefile	2015-01-01 17:34:32.473499645 +0100
@@ -6,4 +6,4 @@
 # SPDX-License-Identifier: GPL-2.0
 #
 
-obj-y	:= koelsch.o qos.o
+obj-y	:= koelsch.o qos.o ../rcar-gen2-common/common.o
diff -ruN u-boot-2015.01-rc3/board/renesas/lager/lager.c u-boot/board/renesas/lager/lager.c
--- u-boot-2015.01-rc3/board/renesas/lager/lager.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/renesas/lager/lager.c	2015-01-01 17:34:32.473499645 +0100
@@ -18,8 +18,11 @@
 #include <asm/arch/sys_proto.h>
 #include <asm/gpio.h>
 #include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
+#include <asm/arch/mmc.h>
 #include <miiphy.h>
 #include <i2c.h>
+#include <mmc.h>
 #include "qos.h"
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -50,26 +53,10 @@
 	qos_init();
 }
 
-#define MSTPSR1	0xE6150038
-#define SMSTPCR1	0xE6150134
 #define TMU0_MSTP125	(1 << 25)
-
-#define MSTPSR7	0xE61501C4
-#define SMSTPCR7	0xE615014C
 #define SCIF0_MSTP721	(1 << 21)
-
-#define MSTPSR8	0xE61509A0
-#define SMSTPCR8	0xE6150990
 #define ETHER_MSTP813	(1 << 13)
-
-#define mstp_setbits(type, addr, saddr, set) \
-	out_##type((saddr), in_##type(addr) | (set))
-#define mstp_clrbits(type, addr, saddr, clear) \
-	out_##type((saddr), in_##type(addr) & ~(clear))
-#define mstp_setbits_le32(addr, saddr, set)	\
-		mstp_setbits(le32, addr, saddr, set)
-#define mstp_clrbits_le32(addr, saddr, clear)	\
-		mstp_clrbits(le32, addr, saddr, clear)
+#define MMC1_MSTP305    (1 << 5)
 
 int board_early_init_f(void)
 {
@@ -79,16 +66,12 @@
 	mstp_clrbits_le32(MSTPSR7, SMSTPCR7, SCIF0_MSTP721);
 	/* ETHER */
 	mstp_clrbits_le32(MSTPSR8, SMSTPCR8, ETHER_MSTP813);
+	/* eMMC */
+	mstp_clrbits_le32(MSTPSR3, SMSTPCR3, MMC1_MSTP305);
 
 	return 0;
 }
 
-void arch_preboot_os(void)
-{
-	/* Disable TMU0 */
-	mstp_setbits_le32(MSTPSR1, SMSTPCR1, TMU0_MSTP125);
-}
-
 DECLARE_GLOBAL_DATA_PTR;
 int board_init(void)
 {
@@ -163,6 +146,28 @@
 	return 0;
 }
 
+int board_mmc_init(bd_t *bis)
+{
+	int ret = 0;
+
+#ifdef CONFIG_SH_MMCIF
+	gpio_request(GPIO_FN_MMC1_D0, NULL);
+	gpio_request(GPIO_FN_MMC1_D1, NULL);
+	gpio_request(GPIO_FN_MMC1_D2, NULL);
+	gpio_request(GPIO_FN_MMC1_D3, NULL);
+	gpio_request(GPIO_FN_MMC1_D4, NULL);
+	gpio_request(GPIO_FN_MMC1_D5, NULL);
+	gpio_request(GPIO_FN_MMC1_D6, NULL);
+	gpio_request(GPIO_FN_MMC1_D7, NULL);
+	gpio_request(GPIO_FN_MMC1_CLK, NULL);
+	gpio_request(GPIO_FN_MMC1_CMD, NULL);
+
+	ret = mmcif_mmc_init();
+#endif
+	return ret;
+}
+
+
 int dram_init(void)
 {
 	gd->ram_size = CONFIG_SYS_SDRAM_SIZE;
diff -ruN u-boot-2015.01-rc3/board/renesas/lager/Makefile u-boot/board/renesas/lager/Makefile
--- u-boot-2015.01-rc3/board/renesas/lager/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/renesas/lager/Makefile	2015-01-01 17:34:32.473499645 +0100
@@ -6,4 +6,4 @@
 # SPDX-License-Identifier: GPL-2.0
 #
 
-obj-y	:= lager.o qos.o
+obj-y	:= lager.o qos.o ../rcar-gen2-common/common.o
diff -ruN u-boot-2015.01-rc3/board/renesas/rcar-gen2-common/common.c u-boot/board/renesas/rcar-gen2-common/common.c
--- u-boot-2015.01-rc3/board/renesas/rcar-gen2-common/common.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/renesas/rcar-gen2-common/common.c	2015-01-01 17:34:32.477499579 +0100
@@ -0,0 +1,59 @@
+/*
+ * board/renesas/rcar-gen2-common/common.c
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ * Copyright (C) 2013 Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/rmobile.h>
+#include <asm/arch/rcar-mstp.h>
+
+#define TSTR0		0x04
+#define TSTR0_STR0	0x01
+
+static struct mstp_ctl mstptbl[] = {
+	{ SMSTPCR0, MSTP0_BITS, CONFIG_SMSTP0_ENA,
+		RMSTPCR0, MSTP0_BITS, CONFIG_RMSTP0_ENA },
+	{ SMSTPCR1, MSTP1_BITS, CONFIG_SMSTP1_ENA,
+		RMSTPCR1, MSTP1_BITS, CONFIG_RMSTP1_ENA },
+	{ SMSTPCR2, MSTP2_BITS, CONFIG_SMSTP2_ENA,
+		RMSTPCR2, MSTP2_BITS, CONFIG_RMSTP2_ENA },
+	{ SMSTPCR3, MSTP3_BITS, CONFIG_SMSTP3_ENA,
+		RMSTPCR3, MSTP3_BITS, CONFIG_RMSTP3_ENA },
+	{ SMSTPCR4, MSTP4_BITS, CONFIG_SMSTP4_ENA,
+		RMSTPCR4, MSTP4_BITS, CONFIG_RMSTP4_ENA },
+	{ SMSTPCR5, MSTP5_BITS, CONFIG_SMSTP5_ENA,
+		RMSTPCR5, MSTP5_BITS, CONFIG_RMSTP5_ENA },
+	/* No MSTP6 */
+	{ SMSTPCR7, MSTP7_BITS, CONFIG_SMSTP7_ENA,
+		RMSTPCR7, MSTP7_BITS, CONFIG_RMSTP7_ENA },
+	{ SMSTPCR8, MSTP8_BITS, CONFIG_SMSTP8_ENA,
+		RMSTPCR8, MSTP8_BITS, CONFIG_RMSTP8_ENA },
+	{ SMSTPCR9, MSTP9_BITS, CONFIG_SMSTP9_ENA,
+		RMSTPCR9, MSTP9_BITS, CONFIG_RMSTP9_ENA },
+	{ SMSTPCR10, MSTP10_BITS, CONFIG_SMSTP10_ENA,
+		 RMSTPCR10, MSTP10_BITS, CONFIG_RMSTP10_ENA },
+	{ SMSTPCR11, MSTP11_BITS, CONFIG_SMSTP1_ENA,
+		 RMSTPCR11, MSTP11_BITS, CONFIG_RMSTP11_ENA },
+};
+
+void arch_preboot_os(void)
+{
+	int i;
+
+	/* stop TMU0 */
+	mstp_clrbits_le32(TMU_BASE + TSTR0, TMU_BASE + TSTR0, TSTR0_STR0);
+
+	/* Stop module clock */
+	for (i = 0; i < ARRAY_SIZE(mstptbl); i++) {
+		mstp_setclrbits_le32(mstptbl[i].s_addr, mstptbl[i].s_dis,
+				     mstptbl[i].s_ena);
+		mstp_setclrbits_le32(mstptbl[i].r_addr, mstptbl[i].r_dis,
+				     mstptbl[i].r_ena);
+	}
+}
diff -ruN u-boot-2015.01-rc3/board/solidrun/hummingboard/hummingboard.c u-boot/board/solidrun/hummingboard/hummingboard.c
--- u-boot-2015.01-rc3/board/solidrun/hummingboard/hummingboard.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/solidrun/hummingboard/hummingboard.c	2015-01-01 17:34:32.497499251 +0100
@@ -146,7 +146,7 @@
 {
 	struct iomuxc *const iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
 
-	int ret = enable_fec_anatop_clock(ENET_25MHz);
+	int ret = enable_fec_anatop_clock(ENET_25MHZ);
 	if (ret)
 		return ret;
 
diff -ruN u-boot-2015.01-rc3/board/st/stv0991/Kconfig u-boot/board/st/stv0991/Kconfig
--- u-boot-2015.01-rc3/board/st/stv0991/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/st/stv0991/Kconfig	2015-01-01 17:34:32.501499185 +0100
@@ -0,0 +1,23 @@
+if TARGET_STV0991
+
+config SYS_CPU
+	string
+	default "armv7"
+
+config SYS_BOARD
+	string
+	default "stv0991"
+
+config SYS_VENDOR
+	string
+	default "st"
+
+config SYS_SOC
+	string
+	default "stv0991"
+
+config SYS_CONFIG_NAME
+	string
+	default "stv0991"
+
+endif
diff -ruN u-boot-2015.01-rc3/board/st/stv0991/MAINTAINERS u-boot/board/st/stv0991/MAINTAINERS
--- u-boot-2015.01-rc3/board/st/stv0991/MAINTAINERS	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/st/stv0991/MAINTAINERS	2015-01-01 17:34:32.501499185 +0100
@@ -0,0 +1,5 @@
+STV0991 APPLICATION BOARD
+M:	Vikas Manocha <vikas.manocha@st.com>
+S:	Maintained
+F:	board/st/stv0991/
+F:	include/configs/stv0991.h
diff -ruN u-boot-2015.01-rc3/board/st/stv0991/Makefile u-boot/board/st/stv0991/Makefile
--- u-boot-2015.01-rc3/board/st/stv0991/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/st/stv0991/Makefile	2015-01-01 17:34:32.501499185 +0100
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2014
+# Vikas Manocha, ST Microelectronics, vikas.manocha@stcom
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= stv0991.o
diff -ruN u-boot-2015.01-rc3/board/st/stv0991/stv0991.c u-boot/board/st/stv0991/stv0991.c
--- u-boot-2015.01-rc3/board/st/stv0991/stv0991.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/st/stv0991/stv0991.c	2015-01-01 17:34:32.501499185 +0100
@@ -0,0 +1,104 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, ST Micoelectronics, vikas.manocha@st.com.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <miiphy.h>
+#include <asm/arch/stv0991_periph.h>
+#include <asm/arch/stv0991_defs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <dm/platdata.h>
+#include <dm/platform_data/serial_pl01x.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct gpio_regs *const gpioa_regs =
+		(struct gpio_regs *) GPIOA_BASE_ADDR;
+
+static const struct pl01x_serial_platdata serial_platdata = {
+	.base = 0x80406000,
+	.type = TYPE_PL011,
+	.clock = 2700 * 1000,
+};
+
+U_BOOT_DEVICE(stv09911_serials) = {
+	.name = "serial_pl01x",
+	.platdata = &serial_platdata,
+};
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+void show_boot_progress(int progress)
+{
+	printf("%i\n", progress);
+}
+#endif
+
+void enable_eth_phy(void)
+{
+	/* Set GPIOA_06 pad HIGH (Appli board)*/
+	writel(readl(&gpioa_regs->dir) | 0x40, &gpioa_regs->dir);
+	writel(readl(&gpioa_regs->data) | 0x40, &gpioa_regs->data);
+}
+int board_eth_enable(void)
+{
+	stv0991_pinmux_config(ETH_GPIOB_10_31_C_0_4);
+	clock_setup(ETH_CLOCK_CFG);
+	enable_eth_phy();
+	return 0;
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+int board_init(void)
+{
+	board_eth_enable();
+	return 0;
+}
+
+int board_uart_init(void)
+{
+	stv0991_pinmux_config(UART_GPIOC_30_31);
+	clock_setup(UART_CLOCK_CFG);
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_EARLY_INIT_F
+int board_early_init_f(void)
+{
+	board_uart_init();
+	return 0;
+}
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+void dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+}
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bis)
+{
+	int ret = 0;
+
+#if defined(CONFIG_DESIGNWARE_ETH)
+	u32 interface = PHY_INTERFACE_MODE_MII;
+	if (designware_initialize(GMAC_BASE_ADDR, interface) >= 0)
+		ret++;
+#endif
+	return ret;
+}
+#endif
diff -ruN u-boot-2015.01-rc3/board/tbs/tbs2910/Kconfig u-boot/board/tbs/tbs2910/Kconfig
--- u-boot-2015.01-rc3/board/tbs/tbs2910/Kconfig	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/tbs/tbs2910/Kconfig	2015-01-01 17:34:32.505499121 +0100
@@ -1,23 +1,15 @@
 if TARGET_TBS2910
 
-config SYS_CPU
-	string
-	default "armv7"
-
 config SYS_BOARD
-	string
 	default "tbs2910"
 
 config SYS_VENDOR
-	string
 	default "tbs"
 
 config SYS_SOC
-	string
 	default "mx6"
 
 config SYS_CONFIG_NAME
-	string
 	default "tbs2910"
 
 endif
diff -ruN u-boot-2015.01-rc3/board/toradex/apalis_t30/apalis_t30.c u-boot/board/toradex/apalis_t30/apalis_t30.c
--- u-boot-2015.01-rc3/board/toradex/apalis_t30/apalis_t30.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/board/toradex/apalis_t30/apalis_t30.c	2015-01-01 17:34:32.509499055 +0100
@@ -6,7 +6,7 @@
  */
 
 #include <common.h>
-
+#include <dm.h>
 #include <asm/arch/gp_padctrl.h>
 #include <asm/arch/pinmux.h>
 #include <asm/gpio.h>
@@ -38,23 +38,20 @@
 #ifdef CONFIG_PCI_TEGRA
 int tegra_pcie_board_init(void)
 {
-	unsigned int old_bus;
+	struct udevice *dev;
 	u8 addr, data[1];
 	int err;
 
-	old_bus = i2c_get_bus_num();
-
-	err = i2c_set_bus_num(0);
+	err = i2c_get_chip_for_busnum(0, PMU_I2C_ADDRESS, &dev);
 	if (err) {
-		debug("failed to set I2C bus\n");
+		debug("%s: Cannot find PMIC I2C chip\n", __func__);
 		return err;
 	}
-
 	/* TPS659110: VDD2_OP_REG = 1.05V */
 	data[0] = 0x27;
 	addr = 0x25;
 
-	err = i2c_write(PMU_I2C_ADDRESS, addr, 1, data, 1);
+	err = i2c_write(dev, addr, data, 1);
 	if (err) {
 		debug("failed to set VDD supply\n");
 		return err;
@@ -64,7 +61,7 @@
 	data[0] = 0x0D;
 	addr = 0x24;
 
-	err = i2c_write(PMU_I2C_ADDRESS, addr, 1, data, 1);
+	err = i2c_write(dev, addr, data, 1);
 	if (err) {
 		debug("failed to enable VDD supply\n");
 		return err;
@@ -74,14 +71,12 @@
 	data[0] = 0x0D;
 	addr = 0x35;
 
-	err = i2c_write(PMU_I2C_ADDRESS, addr, 1, data, 1);
+	err = i2c_write(dev, addr, data, 1);
 	if (err) {
 		debug("failed to set AVDD supply\n");
 		return err;
 	}
 
-	i2c_set_bus_num(old_bus);
-
 	return 0;
 }
 
diff -ruN u-boot-2015.01-rc3/common/board_f.c u-boot/common/board_f.c
--- u-boot-2015.01-rc3/common/board_f.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/common/board_f.c	2015-01-01 17:34:32.521498858 +0100
@@ -813,7 +813,9 @@
 #endif
 	setup_mon_len,
 	setup_fdt,
+#ifdef CONFIG_TRACE
 	trace_early_init,
+#endif
 	initf_malloc,
 #if defined(CONFIG_MPC85xx) || defined(CONFIG_MPC86xx)
 	/* TODO: can this go into arch_cpu_init()? */
diff -ruN u-boot-2015.01-rc3/common/cmd_dfu.c u-boot/common/cmd_dfu.c
--- u-boot-2015.01-rc3/common/cmd_dfu.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/common/cmd_dfu.c	2015-01-01 17:34:32.525498793 +0100
@@ -38,10 +38,10 @@
 
 	int controller_index = simple_strtoul(usb_controller, NULL, 0);
 	board_usb_init(controller_index, USB_INIT_DEVICE);
-	dfu_clear_detach();
+	g_dnl_clear_detach();
 	g_dnl_register("usb_dnl_dfu");
 	while (1) {
-		if (dfu_detach()) {
+		if (g_dnl_detach()) {
 			/*
 			 * Check if USB bus reset is performed after detach,
 			 * which indicates that -R switch has been passed to
@@ -74,7 +74,7 @@
 	if (dfu_reset)
 		run_command("reset", 0);
 
-	dfu_clear_detach();
+	g_dnl_clear_detach();
 
 	return ret;
 }
diff -ruN u-boot-2015.01-rc3/common/cmd_fastboot.c u-boot/common/cmd_fastboot.c
--- u-boot-2015.01-rc3/common/cmd_fastboot.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/common/cmd_fastboot.c	2015-01-01 17:34:32.525498793 +0100
@@ -15,17 +15,21 @@
 {
 	int ret;
 
+	g_dnl_clear_detach();
 	ret = g_dnl_register("usb_dnl_fastboot");
 	if (ret)
 		return ret;
 
 	while (1) {
+		if (g_dnl_detach())
+			break;
 		if (ctrlc())
 			break;
 		usb_gadget_handle_interrupts();
 	}
 
 	g_dnl_unregister();
+	g_dnl_clear_detach();
 	return CMD_RET_SUCCESS;
 }
 
diff -ruN u-boot-2015.01-rc3/common/cmd_hash.c u-boot/common/cmd_hash.c
--- u-boot-2015.01-rc3/common/cmd_hash.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/common/cmd_hash.c	2015-01-01 17:34:32.529498727 +0100
@@ -18,9 +18,9 @@
 static int do_hash(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	char *s;
-#ifdef CONFIG_HASH_VERIFY
 	int flags = HASH_FLAG_ENV;
 
+#ifdef CONFIG_HASH_VERIFY
 	if (argc < 4)
 		return CMD_RET_USAGE;
 	if (!strcmp(argv[1], "-v")) {
@@ -28,8 +28,6 @@
 		argc--;
 		argv++;
 	}
-#else
-	const int flags = HASH_FLAG_ENV;
 #endif
 	/* Move forward to 'algorithm' parameter */
 	argc--;
@@ -40,19 +38,19 @@
 }
 
 #ifdef CONFIG_HASH_VERIFY
-U_BOOT_CMD(
-	hash,	6,	1,	do_hash,
-	"compute hash message digest",
-	"algorithm address count [[*]sum_dest]\n"
-		"    - compute message digest [save to env var / *address]\n"
-	"hash -v algorithm address count [*]sum\n"
-		"    - verify hash of memory area with env var / *address"
-);
+#define HARGS 6
 #else
+#define HARGS 5
+#endif
+
 U_BOOT_CMD(
-	hash,	5,	1,	do_hash,
-	"compute message digest",
-	"algorithm address count [[*]sum_dest]\n"
+	hash,	HARGS,	1,	do_hash,
+	"compute hash message digest",
+	"algorithm address count [[*]hash_dest]\n"
 		"    - compute message digest [save to env var / *address]"
-);
+#ifdef CONFIG_HASH_VERIFY
+	"\nhash -v algorithm address count [*]hash\n"
+		"    - verify message digest of memory area to immediate value, \n"
+		"      env var or *address"
 #endif
+);
diff -ruN u-boot-2015.01-rc3/common/cmd_i2c.c u-boot/common/cmd_i2c.c
--- u-boot-2015.01-rc3/common/cmd_i2c.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/common/cmd_i2c.c	2015-01-01 17:34:32.529498727 +0100
@@ -69,8 +69,10 @@
 #include <bootretry.h>
 #include <cli.h>
 #include <command.h>
+#include <dm.h>
 #include <edid.h>
 #include <environment.h>
+#include <errno.h>
 #include <i2c.h>
 #include <malloc.h>
 #include <asm/byteorder.h>
@@ -117,6 +119,60 @@
 
 #define DISP_LINE_LEN	16
 
+/*
+ * Default for driver model is to use the chip's existing address length.
+ * For legacy code, this is not stored, so we need to use a suitable
+ * default.
+ */
+#ifdef CONFIG_DM_I2C
+#define DEFAULT_ADDR_LEN	(-1)
+#else
+#define DEFAULT_ADDR_LEN	1
+#endif
+
+#ifdef CONFIG_DM_I2C
+static struct udevice *i2c_cur_bus;
+
+static int i2c_set_bus_num(unsigned int busnum)
+{
+	struct udevice *bus;
+	int ret;
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus);
+	if (ret) {
+		debug("%s: No bus %d\n", __func__, busnum);
+		return ret;
+	}
+	i2c_cur_bus = bus;
+
+	return 0;
+}
+
+static int i2c_get_cur_bus(struct udevice **busp)
+{
+	if (!i2c_cur_bus) {
+		puts("No I2C bus selected\n");
+		return -ENODEV;
+	}
+	*busp = i2c_cur_bus;
+
+	return 0;
+}
+
+static int i2c_get_cur_bus_chip(uint chip_addr, struct udevice **devp)
+{
+	struct udevice *bus;
+	int ret;
+
+	ret = i2c_get_cur_bus(&bus);
+	if (ret)
+		return ret;
+
+	return i2c_get_chip(bus, chip_addr, devp);
+}
+
+#endif
+
 /**
  * i2c_init_board() - Board-specific I2C bus init
  *
@@ -143,7 +199,7 @@
  *
  * Returns I2C bus speed in Hz.
  */
-#if !defined(CONFIG_SYS_I2C)
+#if !defined(CONFIG_SYS_I2C) && !defined(CONFIG_DM_I2C)
 /*
  * TODO: Implement architecture-specific get/set functions
  * Should go away, if we switched completely to new multibus support
@@ -182,12 +238,12 @@
  *
  * Returns the address length.
  */
-static uint get_alen(char *arg)
+static uint get_alen(char *arg, int default_len)
 {
 	int	j;
 	int	alen;
 
-	alen = 1;
+	alen = default_len;
 	for (j = 0; j < 8; j++) {
 		if (arg[j] == '.') {
 			alen = arg[j+1] - '0';
@@ -227,8 +283,13 @@
 static int do_i2c_read ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	u_char	chip;
-	uint	devaddr, alen, length;
+	uint	devaddr, length;
+	int alen;
 	u_char  *memaddr;
+	int ret;
+#ifdef CONFIG_DM_I2C
+	struct udevice *dev;
+#endif
 
 	if (argc != 5)
 		return CMD_RET_USAGE;
@@ -243,7 +304,7 @@
 	 * 2 bytes long.  Some day it might be 3 bytes long :-).
 	 */
 	devaddr = simple_strtoul(argv[2], NULL, 16);
-	alen = get_alen(argv[2]);
+	alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
 	if (alen > 3)
 		return CMD_RET_USAGE;
 
@@ -257,18 +318,31 @@
 	 */
 	memaddr = (u_char *)simple_strtoul(argv[4], NULL, 16);
 
-	if (i2c_read(chip, devaddr, alen, memaddr, length) != 0) {
-		i2c_report_err(-1, I2C_ERR_READ);
-		return 1;
-	}
+#ifdef CONFIG_DM_I2C
+	ret = i2c_get_cur_bus_chip(chip, &dev);
+	if (!ret && alen != -1)
+		ret = i2c_set_chip_offset_len(dev, alen);
+	if (!ret)
+		ret = i2c_read(dev, devaddr, memaddr, length);
+#else
+	ret = i2c_read(chip, devaddr, alen, memaddr, length);
+#endif
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_READ);
+
 	return 0;
 }
 
 static int do_i2c_write(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	u_char	chip;
-	uint	devaddr, alen, length;
+	uint	devaddr, length;
+	int alen;
 	u_char  *memaddr;
+	int ret;
+#ifdef CONFIG_DM_I2C
+	struct udevice *dev;
+#endif
 
 	if (argc != 5)
 		return cmd_usage(cmdtp);
@@ -288,7 +362,7 @@
 	 * 2 bytes long.  Some day it might be 3 bytes long :-).
 	 */
 	devaddr = simple_strtoul(argv[3], NULL, 16);
-	alen = get_alen(argv[3]);
+	alen = get_alen(argv[3], DEFAULT_ADDR_LEN);
 	if (alen > 3)
 		return cmd_usage(cmdtp);
 
@@ -297,10 +371,22 @@
 	 */
 	length = simple_strtoul(argv[4], NULL, 16);
 
+#ifdef CONFIG_DM_I2C
+	ret = i2c_get_cur_bus_chip(chip, &dev);
+	if (!ret && alen != -1)
+		ret = i2c_set_chip_offset_len(dev, alen);
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_WRITE);
+#endif
+
 	while (length-- > 0) {
-		if (i2c_write(chip, devaddr++, alen, memaddr++, 1) != 0) {
-			return i2c_report_err(-1, I2C_ERR_WRITE);
-		}
+#ifdef CONFIG_DM_I2C
+		ret = i2c_write(dev, devaddr++, memaddr++, 1);
+#else
+		ret = i2c_write(chip, devaddr++, alen, memaddr++, 1);
+#endif
+		if (ret)
+			return i2c_report_err(ret, I2C_ERR_WRITE);
 /*
  * No write delay with FRAM devices.
  */
@@ -311,6 +397,38 @@
 	return 0;
 }
 
+#ifdef CONFIG_DM_I2C
+static int do_i2c_flags(cmd_tbl_t *cmdtp, int flag, int argc,
+			char *const argv[])
+{
+	struct udevice *dev;
+	uint flags;
+	int chip;
+	int ret;
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	chip = simple_strtoul(argv[1], NULL, 16);
+	ret = i2c_get_cur_bus_chip(chip, &dev);
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_READ);
+
+	if (argc > 2) {
+		flags = simple_strtoul(argv[2], NULL, 16);
+		ret = i2c_set_chip_flags(dev, flags);
+	} else  {
+		ret = i2c_get_chip_flags(dev, &flags);
+		if (!ret)
+			printf("%x\n", flags);
+	}
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_READ);
+
+	return 0;
+}
+#endif
+
 /**
  * do_i2c_md() - Handle the "i2c md" command-line command
  * @cmdtp:	Command data struct pointer
@@ -327,8 +445,13 @@
 static int do_i2c_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	u_char	chip;
-	uint	addr, alen, length;
+	uint	addr, length;
+	int alen;
 	int	j, nbytes, linebytes;
+	int ret;
+#ifdef CONFIG_DM_I2C
+	struct udevice *dev;
+#endif
 
 	/* We use the last specified parameters, unless new ones are
 	 * entered.
@@ -356,7 +479,7 @@
 		 * 2 bytes long.  Some day it might be 3 bytes long :-).
 		 */
 		addr = simple_strtoul(argv[2], NULL, 16);
-		alen = get_alen(argv[2]);
+		alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
 		if (alen > 3)
 			return CMD_RET_USAGE;
 
@@ -368,6 +491,14 @@
 			length = simple_strtoul(argv[3], NULL, 16);
 	}
 
+#ifdef CONFIG_DM_I2C
+	ret = i2c_get_cur_bus_chip(chip, &dev);
+	if (!ret && alen != -1)
+		ret = i2c_set_chip_offset_len(dev, alen);
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_READ);
+#endif
+
 	/*
 	 * Print the lines.
 	 *
@@ -381,8 +512,13 @@
 
 		linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;
 
-		if (i2c_read(chip, addr, alen, linebuf, linebytes) != 0)
-			i2c_report_err(-1, I2C_ERR_READ);
+#ifdef CONFIG_DM_I2C
+		ret = i2c_read(dev, addr, linebuf, linebytes);
+#else
+		ret = i2c_read(chip, addr, alen, linebuf, linebytes);
+#endif
+		if (ret)
+			i2c_report_err(ret, I2C_ERR_READ);
 		else {
 			printf("%04x:", addr);
 			cp = linebuf;
@@ -429,9 +565,13 @@
 {
 	uchar	chip;
 	ulong	addr;
-	uint	alen;
+	int	alen;
 	uchar	byte;
 	int	count;
+	int ret;
+#ifdef CONFIG_DM_I2C
+	struct udevice *dev;
+#endif
 
 	if ((argc < 4) || (argc > 5))
 		return CMD_RET_USAGE;
@@ -445,10 +585,17 @@
 	 * Address is always specified.
 	 */
 	addr = simple_strtoul(argv[2], NULL, 16);
-	alen = get_alen(argv[2]);
+	alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
 	if (alen > 3)
 		return CMD_RET_USAGE;
 
+#ifdef CONFIG_DM_I2C
+	ret = i2c_get_cur_bus_chip(chip, &dev);
+	if (!ret && alen != -1)
+		ret = i2c_set_chip_offset_len(dev, alen);
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_WRITE);
+#endif
 	/*
 	 * Value to write is always specified.
 	 */
@@ -463,8 +610,13 @@
 		count = 1;
 
 	while (count-- > 0) {
-		if (i2c_write(chip, addr++, alen, &byte, 1) != 0)
-			i2c_report_err(-1, I2C_ERR_WRITE);
+#ifdef CONFIG_DM_I2C
+		ret = i2c_write(dev, addr++, &byte, 1);
+#else
+		ret = i2c_write(chip, addr++, alen, &byte, 1);
+#endif
+		if (ret)
+			i2c_report_err(ret, I2C_ERR_WRITE);
 		/*
 		 * Wait for the write to complete.  The write can take
 		 * up to 10mSec (we allow a little more time).
@@ -499,11 +651,15 @@
 {
 	uchar	chip;
 	ulong	addr;
-	uint	alen;
+	int	alen;
 	int	count;
 	uchar	byte;
 	ulong	crc;
 	ulong	err;
+	int ret = 0;
+#ifdef CONFIG_DM_I2C
+	struct udevice *dev;
+#endif
 
 	if (argc < 4)
 		return CMD_RET_USAGE;
@@ -517,10 +673,17 @@
 	 * Address is always specified.
 	 */
 	addr = simple_strtoul(argv[2], NULL, 16);
-	alen = get_alen(argv[2]);
+	alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
 	if (alen > 3)
 		return CMD_RET_USAGE;
 
+#ifdef CONFIG_DM_I2C
+	ret = i2c_get_cur_bus_chip(chip, &dev);
+	if (!ret && alen != -1)
+		ret = i2c_set_chip_offset_len(dev, alen);
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_READ);
+#endif
 	/*
 	 * Count is always specified
 	 */
@@ -534,13 +697,18 @@
 	crc = 0;
 	err = 0;
 	while (count-- > 0) {
-		if (i2c_read(chip, addr, alen, &byte, 1) != 0)
+#ifdef CONFIG_DM_I2C
+		ret = i2c_read(dev, addr, &byte, 1);
+#else
+		ret = i2c_read(chip, addr, alen, &byte, 1);
+#endif
+		if (ret)
 			err++;
 		crc = crc32 (crc, &byte, 1);
 		addr++;
 	}
 	if (err > 0)
-		i2c_report_err(-1, I2C_ERR_READ);
+		i2c_report_err(ret, I2C_ERR_READ);
 	else
 		printf ("%08lx\n", crc);
 
@@ -568,10 +736,14 @@
 {
 	uchar	chip;
 	ulong	addr;
-	uint	alen;
+	int	alen;
 	ulong	data;
 	int	size = 1;
 	int	nbytes;
+	int ret;
+#ifdef CONFIG_DM_I2C
+	struct udevice *dev;
+#endif
 
 	if (argc != 3)
 		return CMD_RET_USAGE;
@@ -601,19 +773,32 @@
 		 * Address is always specified.
 		 */
 		addr = simple_strtoul(argv[2], NULL, 16);
-		alen = get_alen(argv[2]);
+		alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
 		if (alen > 3)
 			return CMD_RET_USAGE;
 	}
 
+#ifdef CONFIG_DM_I2C
+	ret = i2c_get_cur_bus_chip(chip, &dev);
+	if (!ret && alen != -1)
+		ret = i2c_set_chip_offset_len(dev, alen);
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_WRITE);
+#endif
+
 	/*
 	 * Print the address, followed by value.  Then accept input for
 	 * the next value.  A non-converted value exits.
 	 */
 	do {
 		printf("%08lx:", addr);
-		if (i2c_read(chip, addr, alen, (uchar *)&data, size) != 0)
-			i2c_report_err(-1, I2C_ERR_READ);
+#ifdef CONFIG_DM_I2C
+		ret = i2c_read(dev, addr, (uchar *)&data, size);
+#else
+		ret = i2c_read(chip, addr, alen, (uchar *)&data, size);
+#endif
+		if (ret)
+			i2c_report_err(ret, I2C_ERR_READ);
 		else {
 			data = cpu_to_be32(data);
 			if (size == 1)
@@ -655,8 +840,15 @@
 				 * good enough to not time out
 				 */
 				bootretry_reset_cmd_timeout();
-				if (i2c_write(chip, addr, alen, (uchar *)&data, size) != 0)
-					i2c_report_err(-1, I2C_ERR_WRITE);
+#ifdef CONFIG_DM_I2C
+				ret = i2c_write(dev, addr, (uchar *)&data,
+						size);
+#else
+				ret = i2c_write(chip, addr, alen,
+						(uchar *)&data, size);
+#endif
+				if (ret)
+					i2c_report_err(ret, I2C_ERR_WRITE);
 #ifdef CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS
 				udelay(CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS * 1000);
 #endif
@@ -697,6 +889,13 @@
 	int k, skip;
 	unsigned int bus = GET_BUS_NUM;
 #endif	/* NOPROBES */
+	int ret;
+#ifdef CONFIG_DM_I2C
+	struct udevice *bus, *dev;
+
+	if (i2c_get_cur_bus(&bus))
+		return CMD_RET_FAILURE;
+#endif
 
 	if (argc == 2)
 		addr = simple_strtol(argv[1], 0, 16);
@@ -717,7 +916,12 @@
 		if (skip)
 			continue;
 #endif
-		if (i2c_probe(j) == 0) {
+#ifdef CONFIG_DM_I2C
+		ret = i2c_probe(bus, j, 0, &dev);
+#else
+		ret = i2c_probe(j);
+#endif
+		if (ret == 0) {
 			printf(" %02X", j);
 			found++;
 		}
@@ -754,11 +958,15 @@
 static int do_i2c_loop(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	u_char	chip;
-	ulong	alen;
+	int alen;
 	uint	addr;
 	uint	length;
 	u_char	bytes[16];
 	int	delay;
+	int ret;
+#ifdef CONFIG_DM_I2C
+	struct udevice *dev;
+#endif
 
 	if (argc < 3)
 		return CMD_RET_USAGE;
@@ -772,9 +980,16 @@
 	 * Address is always specified.
 	 */
 	addr = simple_strtoul(argv[2], NULL, 16);
-	alen = get_alen(argv[2]);
+	alen = get_alen(argv[2], DEFAULT_ADDR_LEN);
 	if (alen > 3)
 		return CMD_RET_USAGE;
+#ifdef CONFIG_DM_I2C
+	ret = i2c_get_cur_bus_chip(chip, &dev);
+	if (!ret && alen != -1)
+		ret = i2c_set_chip_offset_len(dev, alen);
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_WRITE);
+#endif
 
 	/*
 	 * Length is the number of objects, not number of bytes.
@@ -794,8 +1009,13 @@
 	 * Run the loop...
 	 */
 	while (1) {
-		if (i2c_read(chip, addr, alen, bytes, length) != 0)
-			i2c_report_err(-1, I2C_ERR_READ);
+#ifdef CONFIG_DM_I2C
+		ret = i2c_read(dev, addr, bytes, length);
+#else
+		ret = i2c_read(chip, addr, alen, bytes, length);
+#endif
+		if (ret)
+			i2c_report_err(ret, I2C_ERR_READ);
 		udelay(delay);
 	}
 
@@ -1345,6 +1565,10 @@
 {
 	u_char chip;
 	struct edid1_info edid;
+	int ret;
+#ifdef CONFIG_DM_I2C
+	struct udevice *dev;
+#endif
 
 	if (argc < 2) {
 		cmd_usage(cmdtp);
@@ -1352,10 +1576,15 @@
 	}
 
 	chip = simple_strtoul(argv[1], NULL, 16);
-	if (i2c_read(chip, 0, 1, (uchar *)&edid, sizeof(edid)) != 0) {
-		i2c_report_err(-1, I2C_ERR_READ);
-		return 1;
-	}
+#ifdef CONFIG_DM_I2C
+	ret = i2c_get_cur_bus_chip(chip, &dev);
+	if (!ret)
+		ret = i2c_read(dev, 0, (uchar *)&edid, sizeof(edid));
+#else
+	ret = i2c_read(chip, 0, 1, (uchar *)&edid, sizeof(edid));
+#endif
+	if (ret)
+		return i2c_report_err(ret, I2C_ERR_READ);
 
 	if (edid_check_info(&edid)) {
 		puts("Content isn't valid EDID.\n");
@@ -1437,17 +1666,28 @@
  * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
  * on error.
  */
-#if defined(CONFIG_SYS_I2C) || defined(CONFIG_I2C_MULTI_BUS)
+#if defined(CONFIG_SYS_I2C) || defined(CONFIG_I2C_MULTI_BUS) || \
+		defined(CONFIG_DM_I2C)
 static int do_i2c_bus_num(cmd_tbl_t *cmdtp, int flag, int argc,
 				char * const argv[])
 {
 	int		ret = 0;
-	unsigned int	bus_no;
+	int	bus_no;
 
-	if (argc == 1)
+	if (argc == 1) {
 		/* querying current setting */
-		printf("Current bus is %d\n", i2c_get_bus_num());
-	else {
+#ifdef CONFIG_DM_I2C
+		struct udevice *bus;
+
+		if (!i2c_get_cur_bus(&bus))
+			bus_no = bus->seq;
+		else
+			bus_no = -1;
+#else
+		bus_no = i2c_get_bus_num();
+#endif
+		printf("Current bus is %d\n", bus_no);
+	} else {
 		bus_no = simple_strtoul(argv[1], NULL, 10);
 #if defined(CONFIG_SYS_I2C)
 		if (bus_no >= CONFIG_SYS_NUM_I2C_BUSES) {
@@ -1478,13 +1718,28 @@
 {
 	int speed, ret=0;
 
-	if (argc == 1)
+#ifdef CONFIG_DM_I2C
+	struct udevice *bus;
+
+	if (i2c_get_cur_bus(&bus))
+		return 1;
+#endif
+	if (argc == 1) {
+#ifdef CONFIG_DM_I2C
+		speed = i2c_get_bus_speed(bus);
+#else
+		speed = i2c_get_bus_speed();
+#endif
 		/* querying current speed */
-		printf("Current bus speed=%d\n", i2c_get_bus_speed());
-	else {
+		printf("Current bus speed=%d\n", speed);
+	} else {
 		speed = simple_strtoul(argv[1], NULL, 10);
 		printf("Setting bus speed to %d Hz\n", speed);
+#ifdef CONFIG_DM_I2C
+		ret = i2c_set_bus_speed(bus, speed);
+#else
 		ret = i2c_set_bus_speed(speed);
+#endif
 		if (ret)
 			printf("Failure changing bus speed (%d)\n", ret);
 	}
@@ -1532,7 +1787,16 @@
  */
 static int do_i2c_reset(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
 {
-#if defined(CONFIG_SYS_I2C)
+#if defined(CONFIG_DM_I2C)
+	struct udevice *bus;
+
+	if (i2c_get_cur_bus(&bus))
+		return CMD_RET_FAILURE;
+	if (i2c_deblock(bus)) {
+		printf("Error: Not supported by the driver\n");
+		return CMD_RET_FAILURE;
+	}
+#elif defined(CONFIG_SYS_I2C)
 	i2c_init(I2C_ADAP->speed, I2C_ADAP->slaveaddr);
 #else
 	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
@@ -1546,7 +1810,7 @@
 #endif
 	U_BOOT_CMD_MKENT(crc32, 3, 1, do_i2c_crc, "", ""),
 #if defined(CONFIG_SYS_I2C) || \
-	defined(CONFIG_I2C_MULTI_BUS)
+	defined(CONFIG_I2C_MULTI_BUS) || defined(CONFIG_DM_I2C)
 	U_BOOT_CMD_MKENT(dev, 1, 1, do_i2c_bus_num, "", ""),
 #endif  /* CONFIG_I2C_MULTI_BUS */
 #if defined(CONFIG_I2C_EDID)
@@ -1560,6 +1824,9 @@
 	U_BOOT_CMD_MKENT(probe, 0, 1, do_i2c_probe, "", ""),
 	U_BOOT_CMD_MKENT(read, 5, 1, do_i2c_read, "", ""),
 	U_BOOT_CMD_MKENT(write, 5, 0, do_i2c_write, "", ""),
+#ifdef CONFIG_DM_I2C
+	U_BOOT_CMD_MKENT(flags, 2, 1, do_i2c_flags, "", ""),
+#endif
 	U_BOOT_CMD_MKENT(reset, 0, 1, do_i2c_reset, "", ""),
 #if defined(CONFIG_CMD_SDRAM)
 	U_BOOT_CMD_MKENT(sdram, 1, 1, do_sdram, "", ""),
@@ -1610,7 +1877,7 @@
 #endif
 	"crc32 chip address[.0, .1, .2] count - compute CRC32 checksum\n"
 #if defined(CONFIG_SYS_I2C) || \
-	defined(CONFIG_I2C_MULTI_BUS)
+	defined(CONFIG_I2C_MULTI_BUS) || defined(CONFIG_DM_I2C)
 	"i2c dev [dev] - show or set current I2C bus\n"
 #endif  /* CONFIG_I2C_MULTI_BUS */
 #if defined(CONFIG_I2C_EDID)
@@ -1622,8 +1889,11 @@
 	"i2c mw chip address[.0, .1, .2] value [count] - write to I2C device (fill)\n"
 	"i2c nm chip address[.0, .1, .2] - write to I2C device (constant address)\n"
 	"i2c probe [address] - test for and show device(s) on the I2C bus\n"
-	"i2c read chip address[.0, .1, .2] length memaddress - read to memory \n"
+	"i2c read chip address[.0, .1, .2] length memaddress - read to memory\n"
 	"i2c write memaddress chip address[.0, .1, .2] length - write memory to i2c\n"
+#ifdef CONFIG_DM_I2C
+	"i2c flags chip [flags] - set or get chip flags\n"
+#endif
 	"i2c reset - re-init the I2C Controller\n"
 #if defined(CONFIG_CMD_SDRAM)
 	"i2c sdram chip - print SDRAM configuration information\n"
diff -ruN u-boot-2015.01-rc3/common/cmd_mmc.c u-boot/common/cmd_mmc.c
--- u-boot-2015.01-rc3/common/cmd_mmc.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/common/cmd_mmc.c	2015-01-01 17:34:32.529498727 +0100
@@ -90,7 +90,8 @@
 	puts("Capacity: ");
 	print_size(mmc->capacity, "\n");
 
-	printf("Bus Width: %d-bit\n", mmc->bus_width);
+	printf("Bus Width: %d-bit%s\n", mmc->bus_width,
+			mmc->ddr_mode ? " DDR" : "");
 }
 static struct mmc *init_mmc_device(int dev, bool force_init)
 {
diff -ruN u-boot-2015.01-rc3/common/fb_mmc.c u-boot/common/fb_mmc.c
--- u-boot-2015.01-rc3/common/fb_mmc.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/common/fb_mmc.c	2015-01-01 17:34:32.537498596 +0100
@@ -4,12 +4,17 @@
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
+#include <config.h>
 #include <common.h>
 #include <fb_mmc.h>
 #include <part.h>
 #include <aboot.h>
 #include <sparse_format.h>
 
+#ifndef CONFIG_FASTBOOT_GPT_NAME
+#define CONFIG_FASTBOOT_GPT_NAME GPT_ENTRY_NAME
+#endif
+
 /* The 64 defined bytes plus the '\0' */
 #define RESPONSE_LEN	(64 + 1)
 
@@ -62,7 +67,6 @@
 void fb_mmc_flash_write(const char *cmd, void *download_buffer,
 			unsigned int download_bytes, char *response)
 {
-	int ret;
 	block_dev_desc_t *dev_desc;
 	disk_partition_t info;
 
@@ -76,8 +80,24 @@
 		return;
 	}
 
-	ret = get_partition_info_efi_by_name(dev_desc, cmd, &info);
-	if (ret) {
+	if (strcmp(cmd, CONFIG_FASTBOOT_GPT_NAME) == 0) {
+		printf("%s: updating MBR, Primary and Backup GPT(s)\n",
+		       __func__);
+		if (is_valid_gpt_buf(dev_desc, download_buffer)) {
+			printf("%s: invalid GPT - refusing to write to flash\n",
+			       __func__);
+			fastboot_fail("invalid GPT partition");
+			return;
+		}
+		if (write_mbr_and_gpt_partitions(dev_desc, download_buffer)) {
+			printf("%s: writing GPT partitions failed\n", __func__);
+			fastboot_fail("writing GPT partitions failed");
+			return;
+		}
+		printf("........ success\n");
+		fastboot_okay("");
+		return;
+	} else if (get_partition_info_efi_by_name(dev_desc, cmd, &info)) {
 		error("cannot find partition: '%s'\n", cmd);
 		fastboot_fail("cannot find partition");
 		return;
diff -ruN u-boot-2015.01-rc3/common/hash.c u-boot/common/hash.c
--- u-boot-2015.01-rc3/common/hash.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/common/hash.c	2015-01-01 17:34:32.537498596 +0100
@@ -256,7 +256,7 @@
 			env_var = 1;
 	}
 
-	if (env_var) {
+	if (!env_var) {
 		ulong addr;
 		void *buf;
 
@@ -347,7 +347,7 @@
 {
 	ulong addr, len;
 
-	if (argc < 2)
+	if ((argc < 2) || ((flags & HASH_FLAG_VERIFY) && (argc < 3)))
 		return CMD_RET_USAGE;
 
 	addr = simple_strtoul(*argv++, NULL, 16);
@@ -380,8 +380,6 @@
 #else
 		if (0) {
 #endif
-			if (!argc)
-				return CMD_RET_USAGE;
 			if (parse_verify_sum(algo, *argv, vsum,
 					flags & HASH_FLAG_ENV)) {
 				printf("ERROR: %s does not contain a valid "
diff -ruN u-boot-2015.01-rc3/configs/armadillo-800eva_defconfig u-boot/configs/armadillo-800eva_defconfig
--- u-boot-2015.01-rc3/configs/armadillo-800eva_defconfig	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/configs/armadillo-800eva_defconfig	2015-01-01 17:34:32.557498268 +0100
@@ -1,3 +1,3 @@
 CONFIG_ARM=y
-+S:CONFIG_RMOBILE=y
+CONFIG_RMOBILE=y
 CONFIG_TARGET_ARMADILLO_800EVA=y
diff -ruN u-boot-2015.01-rc3/configs/crownbay_defconfig u-boot/configs/crownbay_defconfig
--- u-boot-2015.01-rc3/configs/crownbay_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/configs/crownbay_defconfig	2015-01-01 17:34:32.561498202 +0100
@@ -0,0 +1,6 @@
+CONFIG_SYS_EXTRA_OPTIONS="SYS_TEXT_BASE=0xfff00000"
+CONFIG_X86=y
+CONFIG_TARGET_CROWNBAY=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_SEPARATE=y
+CONFIG_DEFAULT_DEVICE_TREE="crownbay"
diff -ruN u-boot-2015.01-rc3/configs/kzm9g_defconfig u-boot/configs/kzm9g_defconfig
--- u-boot-2015.01-rc3/configs/kzm9g_defconfig	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/configs/kzm9g_defconfig	2015-01-01 17:34:32.561498202 +0100
@@ -1,3 +1,3 @@
 CONFIG_ARM=y
-+S:CONFIG_RMOBILE=y
+CONFIG_RMOBILE=y
 CONFIG_TARGET_KZM9G=y
diff -ruN u-boot-2015.01-rc3/configs/ls1021aqds_nand_defconfig u-boot/configs/ls1021aqds_nand_defconfig
--- u-boot-2015.01-rc3/configs/ls1021aqds_nand_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/configs/ls1021aqds_nand_defconfig	2015-01-01 17:34:32.561498202 +0100
@@ -0,0 +1,4 @@
+CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="RAMBOOT_PBL,SPL_FSL_PBL,NAND_BOOT"
++S:CONFIG_ARM=y
++S:CONFIG_TARGET_LS1021AQDS=y
diff -ruN u-boot-2015.01-rc3/configs/ls1021aqds_qspi_defconfig u-boot/configs/ls1021aqds_qspi_defconfig
--- u-boot-2015.01-rc3/configs/ls1021aqds_qspi_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/configs/ls1021aqds_qspi_defconfig	2015-01-01 17:34:32.561498202 +0100
@@ -0,0 +1,3 @@
+CONFIG_SYS_EXTRA_OPTIONS="QSPI_BOOT"
++S:CONFIG_ARM=y
++S:CONFIG_TARGET_LS1021AQDS=y
diff -ruN u-boot-2015.01-rc3/configs/ls1021aqds_sdcard_defconfig u-boot/configs/ls1021aqds_sdcard_defconfig
--- u-boot-2015.01-rc3/configs/ls1021aqds_sdcard_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/configs/ls1021aqds_sdcard_defconfig	2015-01-01 17:34:32.565498136 +0100
@@ -0,0 +1,4 @@
+CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="RAMBOOT_PBL,SPL_FSL_PBL,SD_BOOT"
++S:CONFIG_ARM=y
++S:CONFIG_TARGET_LS1021AQDS=y
diff -ruN u-boot-2015.01-rc3/configs/ls1021atwr_qspi_defconfig u-boot/configs/ls1021atwr_qspi_defconfig
--- u-boot-2015.01-rc3/configs/ls1021atwr_qspi_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/configs/ls1021atwr_qspi_defconfig	2015-01-01 17:34:32.565498136 +0100
@@ -0,0 +1,3 @@
+CONFIG_SYS_EXTRA_OPTIONS="QSPI_BOOT"
++S:CONFIG_ARM=y
++S:CONFIG_TARGET_LS1021ATWR=y
diff -ruN u-boot-2015.01-rc3/configs/ls1021atwr_sdcard_defconfig u-boot/configs/ls1021atwr_sdcard_defconfig
--- u-boot-2015.01-rc3/configs/ls1021atwr_sdcard_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/configs/ls1021atwr_sdcard_defconfig	2015-01-01 17:34:32.565498136 +0100
@@ -0,0 +1,4 @@
+CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="RAMBOOT_PBL,SPL_FSL_PBL,SD_BOOT"
++S:CONFIG_ARM=y
++S:CONFIG_TARGET_LS1021ATWR=y
diff -ruN u-boot-2015.01-rc3/configs/nyan-big_defconfig u-boot/configs/nyan-big_defconfig
--- u-boot-2015.01-rc3/configs/nyan-big_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/configs/nyan-big_defconfig	2015-01-01 17:34:32.565498136 +0100
@@ -0,0 +1,5 @@
++S:CONFIG_ARM=y
++S:CONFIG_TEGRA=y
++S:CONFIG_TEGRA124=y
++S:CONFIG_TARGET_NYAN_BIG=y
+CONFIG_DEFAULT_DEVICE_TREE="tegra124-nyan-big"
diff -ruN u-boot-2015.01-rc3/configs/ph1_ld4_defconfig u-boot/configs/ph1_ld4_defconfig
--- u-boot-2015.01-rc3/configs/ph1_ld4_defconfig	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/configs/ph1_ld4_defconfig	2015-01-01 17:34:32.565498136 +0100
@@ -1,4 +1,3 @@
-CONFIG_SPL=y
 CONFIG_FIT=y
 CONFIG_FIT_VERBOSE=y
 +S:CONFIG_ARM=y
diff -ruN u-boot-2015.01-rc3/configs/ph1_pro4_defconfig u-boot/configs/ph1_pro4_defconfig
--- u-boot-2015.01-rc3/configs/ph1_pro4_defconfig	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/configs/ph1_pro4_defconfig	2015-01-01 17:34:32.565498136 +0100
@@ -1,4 +1,3 @@
-CONFIG_SPL=y
 CONFIG_FIT=y
 CONFIG_FIT_VERBOSE=y
 +S:CONFIG_ARM=y
diff -ruN u-boot-2015.01-rc3/configs/ph1_sld8_defconfig u-boot/configs/ph1_sld8_defconfig
--- u-boot-2015.01-rc3/configs/ph1_sld8_defconfig	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/configs/ph1_sld8_defconfig	2015-01-01 17:34:32.565498136 +0100
@@ -1,4 +1,3 @@
-CONFIG_SPL=y
 CONFIG_FIT=y
 CONFIG_FIT_VERBOSE=y
 +S:CONFIG_ARM=y
diff -ruN u-boot-2015.01-rc3/configs/stv0991_defconfig u-boot/configs/stv0991_defconfig
--- u-boot-2015.01-rc3/configs/stv0991_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/configs/stv0991_defconfig	2015-01-01 17:34:32.569498072 +0100
@@ -0,0 +1,3 @@
+CONFIG_SYS_EXTRA_OPTIONS="stv0991"
+CONFIG_ARM=y
+CONFIG_TARGET_STV0991=y
diff -ruN u-boot-2015.01-rc3/disk/part_efi.c u-boot/disk/part_efi.c
--- u-boot-2015.01-rc3/disk/part_efi.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/disk/part_efi.c	2015-01-01 17:34:32.573498006 +0100
@@ -69,6 +69,107 @@
 			sizeof(efi_guid_t));
 }
 
+static int validate_gpt_header(gpt_header *gpt_h, lbaint_t lba,
+		lbaint_t lastlba)
+{
+	uint32_t crc32_backup = 0;
+	uint32_t calc_crc32;
+
+	/* Check the GPT header signature */
+	if (le64_to_cpu(gpt_h->signature) != GPT_HEADER_SIGNATURE) {
+		printf("%s signature is wrong: 0x%llX != 0x%llX\n",
+		       "GUID Partition Table Header",
+		       le64_to_cpu(gpt_h->signature),
+		       GPT_HEADER_SIGNATURE);
+		return -1;
+	}
+
+	/* Check the GUID Partition Table CRC */
+	memcpy(&crc32_backup, &gpt_h->header_crc32, sizeof(crc32_backup));
+	memset(&gpt_h->header_crc32, 0, sizeof(gpt_h->header_crc32));
+
+	calc_crc32 = efi_crc32((const unsigned char *)gpt_h,
+		le32_to_cpu(gpt_h->header_size));
+
+	memcpy(&gpt_h->header_crc32, &crc32_backup, sizeof(crc32_backup));
+
+	if (calc_crc32 != le32_to_cpu(crc32_backup)) {
+		printf("%s CRC is wrong: 0x%x != 0x%x\n",
+		       "GUID Partition Table Header",
+		       le32_to_cpu(crc32_backup), calc_crc32);
+		return -1;
+	}
+
+	/*
+	 * Check that the my_lba entry points to the LBA that contains the GPT
+	 */
+	if (le64_to_cpu(gpt_h->my_lba) != lba) {
+		printf("GPT: my_lba incorrect: %llX != " LBAF "\n",
+		       le64_to_cpu(gpt_h->my_lba),
+		       lba);
+		return -1;
+	}
+
+	/*
+	 * Check that the first_usable_lba and that the last_usable_lba are
+	 * within the disk.
+	 */
+	if (le64_to_cpu(gpt_h->first_usable_lba) > lastlba) {
+		printf("GPT: first_usable_lba incorrect: %llX > " LBAF "\n",
+		       le64_to_cpu(gpt_h->first_usable_lba), lastlba);
+		return -1;
+	}
+	if (le64_to_cpu(gpt_h->last_usable_lba) > lastlba) {
+		printf("GPT: last_usable_lba incorrect: %llX > " LBAF "\n",
+		       le64_to_cpu(gpt_h->last_usable_lba), lastlba);
+		return -1;
+	}
+
+	debug("GPT: first_usable_lba: %llX last_usable_lba: %llX last lba: "
+	      LBAF "\n", le64_to_cpu(gpt_h->first_usable_lba),
+	      le64_to_cpu(gpt_h->last_usable_lba), lastlba);
+
+	return 0;
+}
+
+static int validate_gpt_entries(gpt_header *gpt_h, gpt_entry *gpt_e)
+{
+	uint32_t calc_crc32;
+
+	/* Check the GUID Partition Table Entry Array CRC */
+	calc_crc32 = efi_crc32((const unsigned char *)gpt_e,
+		le32_to_cpu(gpt_h->num_partition_entries) *
+		le32_to_cpu(gpt_h->sizeof_partition_entry));
+
+	if (calc_crc32 != le32_to_cpu(gpt_h->partition_entry_array_crc32)) {
+		printf("%s: 0x%x != 0x%x\n",
+		       "GUID Partition Table Entry Array CRC is wrong",
+		       le32_to_cpu(gpt_h->partition_entry_array_crc32),
+		       calc_crc32);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void prepare_backup_gpt_header(gpt_header *gpt_h)
+{
+	uint32_t calc_crc32;
+	uint64_t val;
+
+	/* recalculate the values for the Backup GPT Header */
+	val = le64_to_cpu(gpt_h->my_lba);
+	gpt_h->my_lba = gpt_h->alternate_lba;
+	gpt_h->alternate_lba = cpu_to_le64(val);
+	gpt_h->partition_entry_lba =
+			cpu_to_le64(le64_to_cpu(gpt_h->last_usable_lba) + 1);
+	gpt_h->header_crc32 = 0;
+
+	calc_crc32 = efi_crc32((const unsigned char *)gpt_h,
+			       le32_to_cpu(gpt_h->header_size));
+	gpt_h->header_crc32 = cpu_to_le32(calc_crc32);
+}
+
 #ifdef CONFIG_EFI_PARTITION
 /*
  * Public Functions (include/part.h)
@@ -259,7 +360,6 @@
 	const int pte_blk_cnt = BLOCK_CNT((gpt_h->num_partition_entries
 					   * sizeof(gpt_entry)), dev_desc);
 	u32 calc_crc32;
-	u64 val;
 
 	debug("max lba: %x\n", (u32) dev_desc->lba);
 	/* Setup the Protective MBR */
@@ -284,15 +384,7 @@
 	    != pte_blk_cnt)
 		goto err;
 
-	/* recalculate the values for the Backup GPT Header */
-	val = le64_to_cpu(gpt_h->my_lba);
-	gpt_h->my_lba = gpt_h->alternate_lba;
-	gpt_h->alternate_lba = cpu_to_le64(val);
-	gpt_h->header_crc32 = 0;
-
-	calc_crc32 = efi_crc32((const unsigned char *)gpt_h,
-			      le32_to_cpu(gpt_h->header_size));
-	gpt_h->header_crc32 = cpu_to_le32(calc_crc32);
+	prepare_backup_gpt_header(gpt_h);
 
 	if (dev_desc->block_write(dev_desc->dev,
 				  (lbaint_t)le64_to_cpu(gpt_h->last_usable_lba)
@@ -455,6 +547,97 @@
 	free(gpt_h);
 	return ret;
 }
+
+int is_valid_gpt_buf(block_dev_desc_t *dev_desc, void *buf)
+{
+	gpt_header *gpt_h;
+	gpt_entry *gpt_e;
+
+	/* determine start of GPT Header in the buffer */
+	gpt_h = buf + (GPT_PRIMARY_PARTITION_TABLE_LBA *
+		       dev_desc->blksz);
+	if (validate_gpt_header(gpt_h, GPT_PRIMARY_PARTITION_TABLE_LBA,
+				dev_desc->lba))
+		return -1;
+
+	/* determine start of GPT Entries in the buffer */
+	gpt_e = buf + (le64_to_cpu(gpt_h->partition_entry_lba) *
+		       dev_desc->blksz);
+	if (validate_gpt_entries(gpt_h, gpt_e))
+		return -1;
+
+	return 0;
+}
+
+int write_mbr_and_gpt_partitions(block_dev_desc_t *dev_desc, void *buf)
+{
+	gpt_header *gpt_h;
+	gpt_entry *gpt_e;
+	int gpt_e_blk_cnt;
+	lbaint_t lba;
+	int cnt;
+
+	if (is_valid_gpt_buf(dev_desc, buf))
+		return -1;
+
+	/* determine start of GPT Header in the buffer */
+	gpt_h = buf + (GPT_PRIMARY_PARTITION_TABLE_LBA *
+		       dev_desc->blksz);
+
+	/* determine start of GPT Entries in the buffer */
+	gpt_e = buf + (le64_to_cpu(gpt_h->partition_entry_lba) *
+		       dev_desc->blksz);
+	gpt_e_blk_cnt = BLOCK_CNT((le32_to_cpu(gpt_h->num_partition_entries) *
+				   le32_to_cpu(gpt_h->sizeof_partition_entry)),
+				  dev_desc);
+
+	/* write MBR */
+	lba = 0;	/* MBR is always at 0 */
+	cnt = 1;	/* MBR (1 block) */
+	if (dev_desc->block_write(dev_desc->dev, lba, cnt, buf) != cnt) {
+		printf("%s: failed writing '%s' (%d blks at 0x" LBAF ")\n",
+		       __func__, "MBR", cnt, lba);
+		return 1;
+	}
+
+	/* write Primary GPT */
+	lba = GPT_PRIMARY_PARTITION_TABLE_LBA;
+	cnt = 1;	/* GPT Header (1 block) */
+	if (dev_desc->block_write(dev_desc->dev, lba, cnt, gpt_h) != cnt) {
+		printf("%s: failed writing '%s' (%d blks at 0x" LBAF ")\n",
+		       __func__, "Primary GPT Header", cnt, lba);
+		return 1;
+	}
+
+	lba = le64_to_cpu(gpt_h->partition_entry_lba);
+	cnt = gpt_e_blk_cnt;
+	if (dev_desc->block_write(dev_desc->dev, lba, cnt, gpt_e) != cnt) {
+		printf("%s: failed writing '%s' (%d blks at 0x" LBAF ")\n",
+		       __func__, "Primary GPT Entries", cnt, lba);
+		return 1;
+	}
+
+	prepare_backup_gpt_header(gpt_h);
+
+	/* write Backup GPT */
+	lba = le64_to_cpu(gpt_h->partition_entry_lba);
+	cnt = gpt_e_blk_cnt;
+	if (dev_desc->block_write(dev_desc->dev, lba, cnt, gpt_e) != cnt) {
+		printf("%s: failed writing '%s' (%d blks at 0x" LBAF ")\n",
+		       __func__, "Backup GPT Entries", cnt, lba);
+		return 1;
+	}
+
+	lba = le64_to_cpu(gpt_h->my_lba);
+	cnt = 1;	/* GPT Header (1 block) */
+	if (dev_desc->block_write(dev_desc->dev, lba, cnt, gpt_h) != cnt) {
+		printf("%s: failed writing '%s' (%d blks at 0x" LBAF ")\n",
+		       __func__, "Backup GPT Header", cnt, lba);
+		return 1;
+	}
+
+	return 0;
+}
 #endif
 
 /*
@@ -511,10 +694,6 @@
 static int is_gpt_valid(block_dev_desc_t *dev_desc, u64 lba,
 			gpt_header *pgpt_head, gpt_entry **pgpt_pte)
 {
-	u32 crc32_backup = 0;
-	u32 calc_crc32;
-	u64 lastlba;
-
 	if (!dev_desc || !pgpt_head) {
 		printf("%s: Invalid Argument(s)\n", __func__);
 		return 0;
@@ -527,55 +706,8 @@
 		return 0;
 	}
 
-	/* Check the GPT header signature */
-	if (le64_to_cpu(pgpt_head->signature) != GPT_HEADER_SIGNATURE) {
-		printf("GUID Partition Table Header signature is wrong:"
-			"0x%llX != 0x%llX\n",
-			le64_to_cpu(pgpt_head->signature),
-			GPT_HEADER_SIGNATURE);
-		return 0;
-	}
-
-	/* Check the GUID Partition Table CRC */
-	memcpy(&crc32_backup, &pgpt_head->header_crc32, sizeof(crc32_backup));
-	memset(&pgpt_head->header_crc32, 0, sizeof(pgpt_head->header_crc32));
-
-	calc_crc32 = efi_crc32((const unsigned char *)pgpt_head,
-		le32_to_cpu(pgpt_head->header_size));
-
-	memcpy(&pgpt_head->header_crc32, &crc32_backup, sizeof(crc32_backup));
-
-	if (calc_crc32 != le32_to_cpu(crc32_backup)) {
-		printf("GUID Partition Table Header CRC is wrong:"
-			"0x%x != 0x%x\n",
-		       le32_to_cpu(crc32_backup), calc_crc32);
-		return 0;
-	}
-
-	/* Check that the my_lba entry points to the LBA that contains the GPT */
-	if (le64_to_cpu(pgpt_head->my_lba) != lba) {
-		printf("GPT: my_lba incorrect: %llX != %" PRIX64 "\n",
-		       le64_to_cpu(pgpt_head->my_lba),
-		       lba);
+	if (validate_gpt_header(pgpt_head, (lbaint_t)lba, dev_desc->lba))
 		return 0;
-	}
-
-	/* Check the first_usable_lba and last_usable_lba are within the disk. */
-	lastlba = (u64)dev_desc->lba;
-	if (le64_to_cpu(pgpt_head->first_usable_lba) > lastlba) {
-		printf("GPT: first_usable_lba incorrect: %llX > %" PRIX64 "\n",
-		       le64_to_cpu(pgpt_head->first_usable_lba), lastlba);
-		return 0;
-	}
-	if (le64_to_cpu(pgpt_head->last_usable_lba) > lastlba) {
-		printf("GPT: last_usable_lba incorrect: %llX > %" PRIX64 "\n",
-		       le64_to_cpu(pgpt_head->last_usable_lba), lastlba);
-		return 0;
-	}
-
-	debug("GPT: first_usable_lba: %llX last_usable_lba %llX last lba %"
-	      PRIX64 "\n", le64_to_cpu(pgpt_head->first_usable_lba),
-	      le64_to_cpu(pgpt_head->last_usable_lba), lastlba);
 
 	/* Read and allocate Partition Table Entries */
 	*pgpt_pte = alloc_read_gpt_entries(dev_desc, pgpt_head);
@@ -584,17 +716,7 @@
 		return 0;
 	}
 
-	/* Check the GUID Partition Table Entry Array CRC */
-	calc_crc32 = efi_crc32((const unsigned char *)*pgpt_pte,
-		le32_to_cpu(pgpt_head->num_partition_entries) *
-		le32_to_cpu(pgpt_head->sizeof_partition_entry));
-
-	if (calc_crc32 != le32_to_cpu(pgpt_head->partition_entry_array_crc32)) {
-		printf("GUID Partition Table Entry Array CRC is wrong:"
-			"0x%x != 0x%x\n",
-			le32_to_cpu(pgpt_head->partition_entry_array_crc32),
-			calc_crc32);
-
+	if (validate_gpt_entries(pgpt_head, *pgpt_pte)) {
 		free(*pgpt_pte);
 		return 0;
 	}
diff -ruN u-boot-2015.01-rc3/doc/README.x86 u-boot/doc/README.x86
--- u-boot-2015.01-rc3/doc/README.x86	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/doc/README.x86	2015-01-01 17:34:32.597497612 +0100
@@ -0,0 +1,126 @@
+#
+# Copyright (C) 2014, Simon Glass <sjg@chromium.org>
+# Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+U-Boot on x86
+=============
+
+This document describes the information about U-Boot running on x86 targets,
+including supported boards, build instructions, todo list, etc.
+
+Status
+------
+U-Boot supports running as a coreboot [1] payload on x86. So far only Link
+(Chromebook Pixel) has been tested, but it should work with minimal adjustments
+on other x86 boards since coreboot deals with most of the low-level details.
+
+U-Boot also supports booting directly from x86 reset vector without coreboot,
+aka raw support or bare support. Currently Link and Intel Crown Bay board
+support running U-Boot 'bare metal'.
+
+As for loading OS, U-Boot supports directly booting a 32-bit or 64-bit Linux
+kernel as part of a FIT image. It also supports a compressed zImage.
+
+Build Instructions
+------------------
+Building U-Boot as a coreboot payload is just like building U-Boot for targets
+on other architectures, like below:
+
+$ make coreboot-x86_defconfig
+$ make all
+
+Building ROM version of U-Boot (hereafter referred to as u-boot.rom) is a
+little bit tricky, as generally it requires several binary blobs which are not
+shipped in the U-Boot source tree. Due to this reason, the u-boot.rom build is
+not turned on by default in the U-Boot source tree. Firstly, you need turn it
+on by uncommenting the following line in the main U-Boot Makefile:
+
+# ALL-$(CONFIG_X86_RESET_VECTOR) += u-boot.rom
+
+Link-specific instructions:
+
+First, you need the following binary blobs:
+
+* descriptor.bin - Intel flash descriptor
+* me.bin - Intel Management Engine
+* mrc.bin - Memory Reference Code, which sets up SDRAM
+* video ROM - sets up the display
+
+You can get these binary blobs by:
+
+$ git clone http://review.coreboot.org/p/blobs.git
+$ cd blobs
+
+Find the following files:
+
+* ./mainboard/google/link/descriptor.bin
+* ./mainboard/google/link/me.bin
+* ./northbridge/intel/sandybridge/systemagent-ivybridge.bin
+
+The 3rd one should be renamed to mrc.bin.
+As for the video ROM, you can get it here [2].
+Make sure all these binary blobs are put in the board directory.
+
+Now you can build U-Boot and obtain u-boot.rom:
+
+$ make chromebook_link_defconfig
+$ make all
+
+Intel Crown Bay specific instructions:
+
+U-Boot support of Intel Crown Bay board [3] relies on a binary blob called
+Firmware Support Package [4] to perform all the necessary initialization steps
+as documented in the BIOS Writer Guide, including initialization of the CPU,
+memory controller, chipset and certain bus interfaces.
+
+Download the Intel FSP for Atom E6xx series and Platform Controller Hub EG20T,
+install it on your host and locate the FSP binary blob. Note this platform
+also requires a Chipset Micro Code (CMC) state machine binary to be present in
+the SPI flash where u-boot.rom resides, and this CMC binary blob can be found
+in this FSP package too.
+
+* ./FSP/QUEENSBAY_FSP_GOLD_001_20-DECEMBER-2013.fd
+* ./Microcode/C0_22211.BIN
+
+Rename the first one to fsp.bin and second one to cmc.bin and put them in the
+board directory.
+
+Now you can build U-Boot and obtaim u-boot.rom
+
+$ make crownbay_defconfig
+$ make all
+
+CPU Microcode
+-------------
+Modern CPU usually requires a special bit stream called microcode [5] to be
+loaded on the processor after power up in order to function properly. U-Boot
+has already integrated these as hex dumps in the source tree.
+
+Driver Model
+------------
+x86 has been converted to use driver model for serial and GPIO.
+
+Device Tree
+-----------
+x86 uses device tree to configure the board thus requires CONFIG_OF_CONTROL to
+be turned on. Not every device on the board is configured via devie tree, but
+more and more devices will be added as time goes by. Check out the directory
+arch/x86/dts/ for these device tree source files.
+
+TODO List
+---------
+- MTRR support (for performance)
+- Audio
+- Chrome OS verified boot
+- SMI and ACPI support, to provide platform info and facilities to Linux
+
+References
+----------
+[1] http://www.coreboot.org
+[2] http://www.coreboot.org/~stepan/pci8086,0166.rom
+[3] http://www.intel.com/content/www/us/en/embedded/design-tools/evaluation-platforms/atom-e660-eg20t-development-kit.html
+[4] http://www.intel.com/fsp
+[5] http://en.wikipedia.org/wiki/Microcode
diff -ruN u-boot-2015.01-rc3/drivers/bios_emulator/besys.c u-boot/drivers/bios_emulator/besys.c
--- u-boot-2015.01-rc3/drivers/bios_emulator/besys.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/bios_emulator/besys.c	2015-01-01 17:34:32.605497481 +0100
@@ -48,8 +48,8 @@
 ****************************************************************************/
 
 #define __io
-#include <asm/io.h>
 #include <common.h>
+#include <asm/io.h>
 #include "biosemui.h"
 
 /*------------------------- Global Variables ------------------------------*/
diff -ruN u-boot-2015.01-rc3/drivers/bios_emulator/bios.c u-boot/drivers/bios_emulator/bios.c
--- u-boot-2015.01-rc3/drivers/bios_emulator/bios.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/bios_emulator/bios.c	2015-01-01 17:34:32.605497481 +0100
@@ -42,8 +42,8 @@
 ****************************************************************************/
 
 #define __io
-#include <asm/io.h>
 #include <common.h>
+#include <asm/io.h>
 #include "biosemui.h"
 
 /*----------------------------- Implementation ----------------------------*/
diff -ruN u-boot-2015.01-rc3/drivers/block/dwc_ahsata.c u-boot/drivers/block/dwc_ahsata.c
--- u-boot-2015.01-rc3/drivers/block/dwc_ahsata.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/block/dwc_ahsata.c	2015-01-01 17:34:32.613497350 +0100
@@ -594,22 +594,24 @@
 
 int reset_sata(int dev)
 {
-	struct ahci_probe_ent *probe_ent =
-			(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
-	struct sata_host_regs *host_mmio =
-			(struct sata_host_regs *)probe_ent->mmio_base;
+	struct ahci_probe_ent *probe_ent;
+	struct sata_host_regs *host_mmio;
 
 	if (dev < 0 || dev > (CONFIG_SYS_SATA_MAX_DEVICE - 1)) {
 		printf("The sata index %d is out of ranges\n\r", dev);
 		return -1;
 	}
 
+	probe_ent = (struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	if (NULL == probe_ent)
+		/* not initialized, so nothing to reset */
+		return 0;
+
+	host_mmio = (struct sata_host_regs *)probe_ent->mmio_base;
 	setbits_le32(&host_mmio->ghc, SATA_HOST_GHC_HR);
 	while (readl(&host_mmio->ghc) & SATA_HOST_GHC_HR)
 		udelay(100);
 
-	disable_sata_clock();
-
 	return 0;
 }
 
diff -ruN u-boot-2015.01-rc3/drivers/core/device.c u-boot/drivers/core/device.c
--- u-boot-2015.01-rc3/drivers/core/device.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/core/device.c	2015-01-01 17:34:32.621497219 +0100
@@ -234,7 +234,7 @@
 void *dev_get_platdata(struct udevice *dev)
 {
 	if (!dev) {
-		dm_warn("%s: null device", __func__);
+		dm_warn("%s: null device\n", __func__);
 		return NULL;
 	}
 
@@ -244,7 +244,7 @@
 void *dev_get_priv(struct udevice *dev)
 {
 	if (!dev) {
-		dm_warn("%s: null device", __func__);
+		dm_warn("%s: null device\n", __func__);
 		return NULL;
 	}
 
@@ -254,7 +254,7 @@
 void *dev_get_parentdata(struct udevice *dev)
 {
 	if (!dev) {
-		dm_warn("%s: null device", __func__);
+		dm_warn("%s: null device\n", __func__);
 		return NULL;
 	}
 
diff -ruN u-boot-2015.01-rc3/drivers/crypto/fsl/jr.c u-boot/drivers/crypto/fsl/jr.c
--- u-boot-2015.01-rc3/drivers/crypto/fsl/jr.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/crypto/fsl/jr.c	2015-01-01 17:34:32.621497219 +0100
@@ -246,7 +246,7 @@
 	struct result op;
 	int ret = 0;
 
-	memset(&op, sizeof(op), 0);
+	memset(&op, 0, sizeof(op));
 
 	ret = jr_enqueue(desc, desc_done, &op);
 	if (ret) {
diff -ruN u-boot-2015.01-rc3/drivers/ddr/fsl/arm_ddr_gen3.c u-boot/drivers/ddr/fsl/arm_ddr_gen3.c
--- u-boot-2015.01-rc3/drivers/ddr/fsl/arm_ddr_gen3.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/ddr/fsl/arm_ddr_gen3.c	2015-01-01 17:34:32.621497219 +0100
@@ -92,7 +92,6 @@
 	ddr_out32(&ddr->timing_cfg_0, regs->timing_cfg_0);
 	ddr_out32(&ddr->timing_cfg_1, regs->timing_cfg_1);
 	ddr_out32(&ddr->timing_cfg_2, regs->timing_cfg_2);
-	ddr_out32(&ddr->sdram_cfg_2, regs->ddr_sdram_cfg_2);
 	ddr_out32(&ddr->sdram_mode, regs->ddr_sdram_mode);
 	ddr_out32(&ddr->sdram_mode_2, regs->ddr_sdram_mode_2);
 	ddr_out32(&ddr->sdram_mode_3, regs->ddr_sdram_mode_3);
@@ -105,9 +104,6 @@
 	ddr_out32(&ddr->sdram_interval, regs->ddr_sdram_interval);
 	ddr_out32(&ddr->sdram_data_init, regs->ddr_data_init);
 	ddr_out32(&ddr->sdram_clk_cntl, regs->ddr_sdram_clk_cntl);
-	ddr_out32(&ddr->init_addr, regs->ddr_init_addr);
-	ddr_out32(&ddr->init_ext_addr, regs->ddr_init_ext_addr);
-
 	ddr_out32(&ddr->timing_cfg_4, regs->timing_cfg_4);
 	ddr_out32(&ddr->timing_cfg_5, regs->timing_cfg_5);
 	ddr_out32(&ddr->ddr_zq_cntl, regs->ddr_zq_cntl);
@@ -128,7 +124,24 @@
 	ddr_out32(&ddr->ddr_sdram_rcw_1, regs->ddr_sdram_rcw_1);
 	ddr_out32(&ddr->ddr_sdram_rcw_2, regs->ddr_sdram_rcw_2);
 	ddr_out32(&ddr->ddr_cdr1, regs->ddr_cdr1);
-	ddr_out32(&ddr->ddr_cdr2, regs->ddr_cdr2);
+#ifdef CONFIG_DEEP_SLEEP
+	if (is_warm_boot()) {
+		ddr_out32(&ddr->sdram_cfg_2,
+			  regs->ddr_sdram_cfg_2 & ~SDRAM_CFG2_D_INIT);
+		ddr_out32(&ddr->init_addr, CONFIG_SYS_SDRAM_BASE);
+		ddr_out32(&ddr->init_ext_addr, DDR_INIT_ADDR_EXT_UIA);
+
+		/* DRAM VRef will not be trained */
+		ddr_out32(&ddr->ddr_cdr2,
+			  regs->ddr_cdr2 & ~DDR_CDR2_VREF_TRAIN_EN);
+	} else
+#endif
+	{
+		ddr_out32(&ddr->sdram_cfg_2, regs->ddr_sdram_cfg_2);
+		ddr_out32(&ddr->init_addr, regs->ddr_init_addr);
+		ddr_out32(&ddr->init_ext_addr, regs->ddr_init_ext_addr);
+		ddr_out32(&ddr->ddr_cdr2, regs->ddr_cdr2);
+	}
 	ddr_out32(&ddr->err_disable, regs->err_disable);
 	ddr_out32(&ddr->err_int_en, regs->err_int_en);
 	for (i = 0; i < 32; i++) {
@@ -167,8 +180,20 @@
 	udelay(500);
 	asm volatile("dsb sy;isb");
 
+#ifdef CONFIG_DEEP_SLEEP
+	if (is_warm_boot()) {
+		/* enter self-refresh */
+		temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg_2);
+		temp_sdram_cfg |= SDRAM_CFG2_FRC_SR;
+		ddr_out32(&ddr->sdram_cfg_2, temp_sdram_cfg);
+		/* do board specific memory setup */
+		board_mem_sleep_setup();
+
+		temp_sdram_cfg = (ddr_in32(&ddr->sdram_cfg) | SDRAM_CFG_BI);
+	} else
+#endif
+		temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg) & ~SDRAM_CFG_BI;
 	/* Let the controller go */
-	temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg) & ~SDRAM_CFG_BI;
 	ddr_out32(&ddr->sdram_cfg, temp_sdram_cfg | SDRAM_CFG_MEM_EN);
 	asm volatile("dsb sy;isb");
 
@@ -211,4 +236,12 @@
 
 	if (timeout <= 0)
 		printf("Waiting for D_INIT timeout. Memory may not work.\n");
+#ifdef CONFIG_DEEP_SLEEP
+	if (is_warm_boot()) {
+		/* exit self-refresh */
+		temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg_2);
+		temp_sdram_cfg &= ~SDRAM_CFG2_FRC_SR;
+		ddr_out32(&ddr->sdram_cfg_2, temp_sdram_cfg);
+	}
+#endif
 }
diff -ruN u-boot-2015.01-rc3/drivers/ddr/fsl/ctrl_regs.c u-boot/drivers/ddr/fsl/ctrl_regs.c
--- u-boot-2015.01-rc3/drivers/ddr/fsl/ctrl_regs.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/ddr/fsl/ctrl_regs.c	2015-01-01 17:34:32.625497153 +0100
@@ -324,6 +324,7 @@
 #elif defined(CONFIG_SYS_FSL_DDR3)
 	unsigned int data_rate = get_ddr_freq(0);
 	int txp;
+	unsigned int ip_rev;
 	int odt_overlap;
 	/*
 	 * (tXARD and tXARDS). Empirical?
@@ -336,7 +337,25 @@
 	 */
 	txp = max((int)mclk_ps * 3, (mclk_ps > 1540 ? 7500 : 6000));
 
-	tmrd_mclk = 4;
+	ip_rev = fsl_ddr_get_version();
+	if (ip_rev >= 0x40700) {
+		/*
+		 * MRS_CYC = max(tMRD, tMOD)
+		 * tMRD = 4nCK (8nCK for RDIMM)
+		 * tMOD = max(12nCK, 15ns)
+		 */
+		tmrd_mclk = max((unsigned int)12, picos_to_mclk(15000));
+	} else {
+		/*
+		 * MRS_CYC = tMRD
+		 * tMRD = 4nCK (8nCK for RDIMM)
+		 */
+		if (popts->registered_dimm_en)
+			tmrd_mclk = 8;
+		else
+			tmrd_mclk = 4;
+	}
+
 	/* set the turnaround time */
 
 	/*
diff -ruN u-boot-2015.01-rc3/drivers/ddr/fsl/fsl_ddr_gen4.c u-boot/drivers/ddr/fsl/fsl_ddr_gen4.c
--- u-boot-2015.01-rc3/drivers/ddr/fsl/fsl_ddr_gen4.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/ddr/fsl/fsl_ddr_gen4.c	2015-01-01 17:34:32.625497153 +0100
@@ -103,7 +103,6 @@
 	ddr_out32(&ddr->dq_map_1, regs->dq_map_1);
 	ddr_out32(&ddr->dq_map_2, regs->dq_map_2);
 	ddr_out32(&ddr->dq_map_3, regs->dq_map_3);
-	ddr_out32(&ddr->sdram_cfg_2, regs->ddr_sdram_cfg_2);
 	ddr_out32(&ddr->sdram_cfg_3, regs->ddr_sdram_cfg_3);
 	ddr_out32(&ddr->sdram_mode, regs->ddr_sdram_mode);
 	ddr_out32(&ddr->sdram_mode_2, regs->ddr_sdram_mode_2);
@@ -124,8 +123,6 @@
 	ddr_out32(&ddr->sdram_md_cntl, regs->ddr_sdram_md_cntl);
 	ddr_out32(&ddr->sdram_interval, regs->ddr_sdram_interval);
 	ddr_out32(&ddr->sdram_data_init, regs->ddr_data_init);
-	ddr_out32(&ddr->init_addr, regs->ddr_init_addr);
-	ddr_out32(&ddr->init_ext_addr, regs->ddr_init_ext_addr);
 	ddr_out32(&ddr->ddr_wrlvl_cntl, regs->ddr_wrlvl_cntl);
 #ifndef CONFIG_SYS_FSL_DDR_EMU
 	/*
@@ -147,7 +144,24 @@
 	ddr_out32(&ddr->ddr_sdram_rcw_5, regs->ddr_sdram_rcw_5);
 	ddr_out32(&ddr->ddr_sdram_rcw_6, regs->ddr_sdram_rcw_6);
 	ddr_out32(&ddr->ddr_cdr1, regs->ddr_cdr1);
-	ddr_out32(&ddr->ddr_cdr2, regs->ddr_cdr2);
+#ifdef CONFIG_DEEP_SLEEP
+	if (is_warm_boot()) {
+		ddr_out32(&ddr->sdram_cfg_2,
+			  regs->ddr_sdram_cfg_2 & ~SDRAM_CFG2_D_INIT);
+		ddr_out32(&ddr->init_addr, CONFIG_SYS_SDRAM_BASE);
+		ddr_out32(&ddr->init_ext_addr, DDR_INIT_ADDR_EXT_UIA);
+
+		/* DRAM VRef will not be trained */
+		ddr_out32(&ddr->ddr_cdr2,
+			  regs->ddr_cdr2 & ~DDR_CDR2_VREF_TRAIN_EN);
+	} else
+#endif
+	{
+		ddr_out32(&ddr->sdram_cfg_2, regs->ddr_sdram_cfg_2);
+		ddr_out32(&ddr->init_addr, regs->ddr_init_addr);
+		ddr_out32(&ddr->init_ext_addr, regs->ddr_init_ext_addr);
+		ddr_out32(&ddr->ddr_cdr2, regs->ddr_cdr2);
+	}
 	ddr_out32(&ddr->err_disable, regs->err_disable);
 	ddr_out32(&ddr->err_int_en, regs->err_int_en);
 	for (i = 0; i < 32; i++) {
@@ -187,8 +201,20 @@
 	mb();
 	isb();
 
+#ifdef CONFIG_DEEP_SLEEP
+	if (is_warm_boot()) {
+		/* enter self-refresh */
+		temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg_2);
+		temp_sdram_cfg |= SDRAM_CFG2_FRC_SR;
+		ddr_out32(&ddr->sdram_cfg_2, temp_sdram_cfg);
+		/* do board specific memory setup */
+		board_mem_sleep_setup();
+
+		temp_sdram_cfg = (ddr_in32(&ddr->sdram_cfg) | SDRAM_CFG_BI);
+	} else
+#endif
+		temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg) & ~SDRAM_CFG_BI;
 	/* Let the controller go */
-	temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg) & ~SDRAM_CFG_BI;
 	ddr_out32(&ddr->sdram_cfg, temp_sdram_cfg | SDRAM_CFG_MEM_EN);
 	mb();
 	isb();
@@ -233,4 +259,12 @@
 
 	if (timeout <= 0)
 		printf("Waiting for D_INIT timeout. Memory may not work.\n");
+#ifdef CONFIG_DEEP_SLEEP
+	if (is_warm_boot()) {
+		/* exit self-refresh */
+		temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg_2);
+		temp_sdram_cfg &= ~SDRAM_CFG2_FRC_SR;
+		ddr_out32(&ddr->sdram_cfg_2, temp_sdram_cfg);
+	}
+#endif
 }
diff -ruN u-boot-2015.01-rc3/drivers/ddr/fsl/mpc85xx_ddr_gen3.c u-boot/drivers/ddr/fsl/mpc85xx_ddr_gen3.c
--- u-boot-2015.01-rc3/drivers/ddr/fsl/mpc85xx_ddr_gen3.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/ddr/fsl/mpc85xx_ddr_gen3.c	2015-01-01 17:34:32.625497153 +0100
@@ -15,8 +15,6 @@
 #error Invalid setting for CONFIG_CHIP_SELECTS_PER_CTRL
 #endif
 
-DECLARE_GLOBAL_DATA_PTR;
-
 /*
  * regs has the to-be-set values for DDR controller registers
  * ctrl_num is the DDR controller number
@@ -44,16 +42,6 @@
 	u32 save1, save2;
 #endif
 
-#ifdef CONFIG_DEEP_SLEEP
-	const ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
-	bool sleep_flag = 0;
-#endif
-
-#ifdef CONFIG_DEEP_SLEEP
-	if (in_be32(&gur->scrtsr[0]) & (1 << 3))
-		sleep_flag = 1;
-#endif
-
 	switch (ctrl_num) {
 	case 0:
 		ddr = (void *)CONFIG_SYS_FSL_DDR_ADDR;
@@ -130,13 +118,6 @@
 	out_be32(&ddr->timing_cfg_0, regs->timing_cfg_0);
 	out_be32(&ddr->timing_cfg_1, regs->timing_cfg_1);
 	out_be32(&ddr->timing_cfg_2, regs->timing_cfg_2);
-#ifdef CONFIG_DEEP_SLEEP
-	if (sleep_flag)
-		out_be32(&ddr->sdram_cfg_2,
-			 regs->ddr_sdram_cfg_2 & ~SDRAM_CFG2_D_INIT);
-	else
-#endif
-		out_be32(&ddr->sdram_cfg_2, regs->ddr_sdram_cfg_2);
 	out_be32(&ddr->sdram_mode, regs->ddr_sdram_mode);
 	out_be32(&ddr->sdram_mode_2, regs->ddr_sdram_mode_2);
 	out_be32(&ddr->sdram_mode_3, regs->ddr_sdram_mode_3);
@@ -149,17 +130,6 @@
 	out_be32(&ddr->sdram_interval, regs->ddr_sdram_interval);
 	out_be32(&ddr->sdram_data_init, regs->ddr_data_init);
 	out_be32(&ddr->sdram_clk_cntl, regs->ddr_sdram_clk_cntl);
-#ifdef CONFIG_DEEP_SLEEP
-	if (sleep_flag) {
-		out_be32(&ddr->init_addr, 0);
-		out_be32(&ddr->init_ext_addr, (1 << 31));
-	} else
-#endif
-	{
-		out_be32(&ddr->init_addr, regs->ddr_init_addr);
-		out_be32(&ddr->init_ext_addr, regs->ddr_init_ext_addr);
-	}
-
 	out_be32(&ddr->timing_cfg_4, regs->timing_cfg_4);
 	out_be32(&ddr->timing_cfg_5, regs->timing_cfg_5);
 	out_be32(&ddr->ddr_zq_cntl, regs->ddr_zq_cntl);
@@ -180,7 +150,24 @@
 	out_be32(&ddr->ddr_sdram_rcw_1, regs->ddr_sdram_rcw_1);
 	out_be32(&ddr->ddr_sdram_rcw_2, regs->ddr_sdram_rcw_2);
 	out_be32(&ddr->ddr_cdr1, regs->ddr_cdr1);
-	out_be32(&ddr->ddr_cdr2, regs->ddr_cdr2);
+#ifdef CONFIG_DEEP_SLEEP
+	if (is_warm_boot()) {
+		out_be32(&ddr->sdram_cfg_2,
+			 regs->ddr_sdram_cfg_2 & ~SDRAM_CFG2_D_INIT);
+		out_be32(&ddr->init_addr, CONFIG_SYS_SDRAM_BASE);
+		out_be32(&ddr->init_ext_addr, DDR_INIT_ADDR_EXT_UIA);
+
+		/* DRAM VRef will not be trained */
+		out_be32(&ddr->ddr_cdr2,
+			 regs->ddr_cdr2 & ~DDR_CDR2_VREF_TRAIN_EN);
+	} else
+#endif
+	{
+		out_be32(&ddr->sdram_cfg_2, regs->ddr_sdram_cfg_2);
+		out_be32(&ddr->init_addr, regs->ddr_init_addr);
+		out_be32(&ddr->init_ext_addr, regs->ddr_init_ext_addr);
+		out_be32(&ddr->ddr_cdr2, regs->ddr_cdr2);
+	}
 	out_be32(&ddr->err_disable, regs->err_disable);
 	out_be32(&ddr->err_int_en, regs->err_int_en);
 	for (i = 0; i < 32; i++) {
@@ -400,21 +387,17 @@
 	asm volatile("sync;isync");
 
 #ifdef CONFIG_DEEP_SLEEP
-	if (sleep_flag) {
+	if (is_warm_boot()) {
 		/* enter self-refresh */
-		setbits_be32(&ddr->sdram_cfg_2, (1 << 31));
+		setbits_be32(&ddr->sdram_cfg_2, SDRAM_CFG2_FRC_SR);
 		/* do board specific memory setup */
 		board_mem_sleep_setup();
-	}
-#endif
-
-	/* Let the controller go */
-#ifdef CONFIG_DEEP_SLEEP
-	if (sleep_flag)
 		temp_sdram_cfg = (in_be32(&ddr->sdram_cfg) | SDRAM_CFG_BI);
-	else
+	} else
 #endif
 		temp_sdram_cfg = (in_be32(&ddr->sdram_cfg) & ~SDRAM_CFG_BI);
+
+	/* Let the controller go */
 	out_be32(&ddr->sdram_cfg, temp_sdram_cfg | SDRAM_CFG_MEM_EN);
 	asm volatile("sync;isync");
 
@@ -566,8 +549,8 @@
 	}
 #endif /* CONFIG_SYS_FSL_ERRATUM_DDR111_DDR134 */
 #ifdef CONFIG_DEEP_SLEEP
-	if (sleep_flag)
+	if (is_warm_boot())
 		/* exit self-refresh */
-		clrbits_be32(&ddr->sdram_cfg_2, (1 << 31));
+		clrbits_be32(&ddr->sdram_cfg_2, SDRAM_CFG2_FRC_SR);
 #endif
 }
diff -ruN u-boot-2015.01-rc3/drivers/dfu/dfu.c u-boot/drivers/dfu/dfu.c
--- u-boot-2015.01-rc3/drivers/dfu/dfu.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/dfu/dfu.c	2015-01-01 17:34:32.629497087 +0100
@@ -17,7 +17,6 @@
 #include <linux/list.h>
 #include <linux/compiler.h>
 
-static bool dfu_detach_request;
 static LIST_HEAD(dfu_list);
 static int dfu_alt_num;
 static int alt_num_cnt;
@@ -39,21 +38,6 @@
 	return true;
 }
 
-bool dfu_detach(void)
-{
-	return dfu_detach_request;
-}
-
-void dfu_trigger_detach(void)
-{
-	dfu_detach_request = true;
-}
-
-void dfu_clear_detach(void)
-{
-	dfu_detach_request = false;
-}
-
 static int dfu_find_alt_num(const char *s)
 {
 	int i = 0;
@@ -111,8 +95,12 @@
 		return dfu_buf;
 
 	s = getenv("dfu_bufsiz");
-	dfu_buf_size = s ? (unsigned long)simple_strtol(s, NULL, 16) :
-			CONFIG_SYS_DFU_DATA_BUF_SIZE;
+	if (s)
+		dfu_buf_size = (unsigned long)simple_strtol(s, NULL, 0);
+
+	if (!s || !dfu_buf_size)
+		dfu_buf_size = CONFIG_SYS_DFU_DATA_BUF_SIZE;
+
 	if (dfu->max_buf_size && dfu_buf_size > dfu->max_buf_size)
 		dfu_buf_size = dfu->max_buf_size;
 
@@ -544,10 +532,35 @@
 int dfu_get_alt(char *name)
 {
 	struct dfu_entity *dfu;
+	char *str;
 
 	list_for_each_entry(dfu, &dfu_list, list) {
-		if (!strncmp(dfu->name, name, strlen(dfu->name)))
-			return dfu->alt;
+		if (dfu->name[0] != '/') {
+			if (!strncmp(dfu->name, name, strlen(dfu->name)))
+				return dfu->alt;
+		} else {
+			/*
+			 * One must also consider absolute path
+			 * (/boot/bin/uImage) available at dfu->name when
+			 * compared "plain" file name (uImage)
+			 *
+			 * It is the case for e.g. thor gadget where lthor SW
+			 * sends only the file name, so only the very last part
+			 * of path must be checked for equality
+			 */
+
+			str = strstr(dfu->name, name);
+			if (!str)
+				continue;
+
+			/*
+			 * Check if matching substring is the last element of
+			 * dfu->name (uImage)
+			 */
+			if (strlen(dfu->name) ==
+			    ((str - dfu->name) + strlen(name)))
+				return dfu->alt;
+		}
 	}
 
 	return -ENODEV;
diff -ruN u-boot-2015.01-rc3/drivers/dfu/dfu_mmc.c u-boot/drivers/dfu/dfu_mmc.c
--- u-boot-2015.01-rc3/drivers/dfu/dfu_mmc.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/dfu/dfu_mmc.c	2015-01-01 17:34:32.629497087 +0100
@@ -40,10 +40,16 @@
 static int mmc_block_op(enum dfu_op op, struct dfu_entity *dfu,
 			u64 offset, void *buf, long *len)
 {
-	struct mmc *mmc = find_mmc_device(dfu->data.mmc.dev_num);
+	struct mmc *mmc;
 	u32 blk_start, blk_count, n = 0;
 	int ret, part_num_bkp = 0;
 
+	mmc = find_mmc_device(dfu->data.mmc.dev_num);
+	if (!mmc) {
+		error("Device MMC %d - not found!", dfu->data.mmc.dev_num);
+		return -ENODEV;
+	}
+
 	/*
 	 * We must ensure that we work in lba_blk_size chunks, so ALIGN
 	 * this value.
diff -ruN u-boot-2015.01-rc3/drivers/gpio/intel_ich6_gpio.c u-boot/drivers/gpio/intel_ich6_gpio.c
--- u-boot-2015.01-rc3/drivers/gpio/intel_ich6_gpio.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/gpio/intel_ich6_gpio.c	2015-01-01 17:34:32.637496957 +0100
@@ -34,69 +34,21 @@
 #include <asm/gpio.h>
 #include <asm/io.h>
 #include <asm/pci.h>
-#ifdef CONFIG_X86_RESET_VECTOR
-#include <asm/arch/pch.h>
-#define SUPPORT_GPIO_SETUP
-#endif
 
 #define GPIO_PER_BANK	32
 
-/* Where in config space is the register that points to the GPIO registers? */
-#define PCI_CFG_GPIOBASE 0x48
-
 struct ich6_bank_priv {
 	/* These are I/O addresses */
-	uint32_t use_sel;
-	uint32_t io_sel;
-	uint32_t lvl;
+	uint16_t use_sel;
+	uint16_t io_sel;
+	uint16_t lvl;
 };
 
-#ifdef SUPPORT_GPIO_SETUP
-static void setup_pch_gpios(const struct pch_gpio_map *gpio)
-{
-	u16 gpiobase = pci_read_config16(PCH_LPC_DEV, GPIO_BASE) & 0xfffc;
-
-	/* GPIO Set 1 */
-	if (gpio->set1.level)
-		outl(*((u32 *)gpio->set1.level), gpiobase + GP_LVL);
-	if (gpio->set1.mode)
-		outl(*((u32 *)gpio->set1.mode), gpiobase + GPIO_USE_SEL);
-	if (gpio->set1.direction)
-		outl(*((u32 *)gpio->set1.direction), gpiobase + GP_IO_SEL);
-	if (gpio->set1.reset)
-		outl(*((u32 *)gpio->set1.reset), gpiobase + GP_RST_SEL1);
-	if (gpio->set1.invert)
-		outl(*((u32 *)gpio->set1.invert), gpiobase + GPI_INV);
-	if (gpio->set1.blink)
-		outl(*((u32 *)gpio->set1.blink), gpiobase + GPO_BLINK);
-
-	/* GPIO Set 2 */
-	if (gpio->set2.level)
-		outl(*((u32 *)gpio->set2.level), gpiobase + GP_LVL2);
-	if (gpio->set2.mode)
-		outl(*((u32 *)gpio->set2.mode), gpiobase + GPIO_USE_SEL2);
-	if (gpio->set2.direction)
-		outl(*((u32 *)gpio->set2.direction), gpiobase + GP_IO_SEL2);
-	if (gpio->set2.reset)
-		outl(*((u32 *)gpio->set2.reset), gpiobase + GP_RST_SEL2);
-
-	/* GPIO Set 3 */
-	if (gpio->set3.level)
-		outl(*((u32 *)gpio->set3.level), gpiobase + GP_LVL3);
-	if (gpio->set3.mode)
-		outl(*((u32 *)gpio->set3.mode), gpiobase + GPIO_USE_SEL3);
-	if (gpio->set3.direction)
-		outl(*((u32 *)gpio->set3.direction), gpiobase + GP_IO_SEL3);
-	if (gpio->set3.reset)
-		outl(*((u32 *)gpio->set3.reset), gpiobase + GP_RST_SEL3);
-}
-
 /* TODO: Move this to device tree, or platform data */
 void ich_gpio_set_gpio_map(const struct pch_gpio_map *map)
 {
 	gd->arch.gpio_map = map;
 }
-#endif /* SUPPORT_GPIO_SETUP */
 
 static int gpio_ich6_ofdata_to_platdata(struct udevice *dev)
 {
@@ -105,7 +57,7 @@
 	u8 tmpbyte;
 	u16 tmpword;
 	u32 tmplong;
-	u32 gpiobase;
+	u16 gpiobase;
 	int offset;
 
 	/* Where should it be? */
@@ -164,11 +116,15 @@
 	/*
 	 * GPIOBASE moved to its current offset with ICH6, but prior to
 	 * that it was unused (or undocumented). Check that it looks
-	 * okay: not all ones or zeros, and mapped to I/O space (bit 0).
+	 * okay: not all ones or zeros.
+	 *
+	 * Note we don't need check bit0 here, because the Tunnel Creek
+	 * GPIO base address register bit0 is reserved (read returns 0),
+	 * while on the Ivybridge the bit0 is used to indicate it is an
+	 * I/O space.
 	 */
 	tmplong = pci_read_config32(pci_dev, PCI_CFG_GPIOBASE);
-	if (tmplong == 0x00000000 || tmplong == 0xffffffff ||
-	    !(tmplong & 0x00000001)) {
+	if (tmplong == 0x00000000 || tmplong == 0xffffffff) {
 		debug("%s: unexpected GPIOBASE value\n", __func__);
 		return -ENODEV;
 	}
@@ -179,7 +135,7 @@
 	 * at the offset that we just read. Bit 0 indicates that it's
 	 * an I/O address, not a memory address, so mask that off.
 	 */
-	gpiobase = tmplong & 0xfffffffe;
+	gpiobase = tmplong & 0xfffe;
 	offset = fdtdec_get_int(gd->fdt_blob, dev->of_offset, "reg", -1);
 	if (offset == -1) {
 		debug("%s: Invalid register offset %d\n", __func__, offset);
@@ -198,12 +154,11 @@
 	struct gpio_dev_priv *uc_priv = dev->uclass_priv;
 	struct ich6_bank_priv *bank = dev_get_priv(dev);
 
-#ifdef SUPPORT_GPIO_SETUP
 	if (gd->arch.gpio_map) {
-		setup_pch_gpios(gd->arch.gpio_map);
+		setup_pch_gpios(plat->base_addr, gd->arch.gpio_map);
 		gd->arch.gpio_map = NULL;
 	}
-#endif
+
 	uc_priv->gpio_count = GPIO_PER_BANK;
 	uc_priv->bank_name = plat->bank_name;
 	bank->use_sel = plat->base_addr;
@@ -251,6 +206,8 @@
 	struct ich6_bank_priv *bank = dev_get_priv(dev);
 	u32 tmplong;
 
+	gpio_set_value(offset, value);
+
 	tmplong = inl(bank->io_sel);
 	tmplong &= ~(1UL << offset);
 	outl(bank->io_sel, tmplong);
diff -ruN u-boot-2015.01-rc3/drivers/i2c/i2c-emul-uclass.c u-boot/drivers/i2c/i2c-emul-uclass.c
--- u-boot-2015.01-rc3/drivers/i2c/i2c-emul-uclass.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/i2c/i2c-emul-uclass.c	2015-01-01 17:34:32.645496825 +0100
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2014 Google, Inc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <i2c.h>
+
+UCLASS_DRIVER(i2c_emul) = {
+	.id		= UCLASS_I2C_EMUL,
+	.name		= "i2c_emul",
+};
diff -ruN u-boot-2015.01-rc3/drivers/i2c/i2c-uclass.c u-boot/drivers/i2c/i2c-uclass.c
--- u-boot-2015.01-rc3/drivers/i2c/i2c-uclass.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/i2c/i2c-uclass.c	2015-01-01 17:34:32.645496825 +0100
@@ -0,0 +1,466 @@
+/*
+ * Copyright (c) 2014 Google, Inc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <dm/device-internal.h>
+#include <dm/lists.h>
+#include <dm/root.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_MAX_OFFSET_LEN	4
+
+/**
+ * i2c_setup_offset() - Set up a new message with a chip offset
+ *
+ * @chip:	Chip to use
+ * @offset:	Byte offset within chip
+ * @offset_buf:	Place to put byte offset
+ * @msg:	Message buffer
+ * @return 0 if OK, -EADDRNOTAVAIL if the offset length is 0. In that case the
+ * message is still set up but will not contain an offset.
+ */
+static int i2c_setup_offset(struct dm_i2c_chip *chip, uint offset,
+			    uint8_t offset_buf[], struct i2c_msg *msg)
+{
+	int offset_len;
+
+	msg->addr = chip->chip_addr;
+	msg->flags = chip->flags & DM_I2C_CHIP_10BIT ? I2C_M_TEN : 0;
+	msg->len = chip->offset_len;
+	msg->buf = offset_buf;
+	if (!chip->offset_len)
+		return -EADDRNOTAVAIL;
+	assert(chip->offset_len <= I2C_MAX_OFFSET_LEN);
+	offset_len = chip->offset_len;
+	while (offset_len--)
+		*offset_buf++ = offset >> (8 * offset_len);
+
+	return 0;
+}
+
+static int i2c_read_bytewise(struct udevice *dev, uint offset,
+			     uint8_t *buffer, int len)
+{
+	struct dm_i2c_chip *chip = dev_get_parentdata(dev);
+	struct udevice *bus = dev_get_parent(dev);
+	struct dm_i2c_ops *ops = i2c_get_ops(bus);
+	struct i2c_msg msg[2], *ptr;
+	uint8_t offset_buf[I2C_MAX_OFFSET_LEN];
+	int ret;
+	int i;
+
+	for (i = 0; i < len; i++) {
+		if (i2c_setup_offset(chip, offset + i, offset_buf, msg))
+			return -EINVAL;
+		ptr = msg + 1;
+		ptr->addr = chip->chip_addr;
+		ptr->flags = msg->flags | I2C_M_RD;
+		ptr->len = 1;
+		ptr->buf = &buffer[i];
+		ptr++;
+
+		ret = ops->xfer(bus, msg, ptr - msg);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int i2c_write_bytewise(struct udevice *dev, uint offset,
+			     const uint8_t *buffer, int len)
+{
+	struct dm_i2c_chip *chip = dev_get_parentdata(dev);
+	struct udevice *bus = dev_get_parent(dev);
+	struct dm_i2c_ops *ops = i2c_get_ops(bus);
+	struct i2c_msg msg[1];
+	uint8_t buf[I2C_MAX_OFFSET_LEN + 1];
+	int ret;
+	int i;
+
+	for (i = 0; i < len; i++) {
+		if (i2c_setup_offset(chip, offset + i, buf, msg))
+			return -EINVAL;
+		buf[msg->len++] = buffer[i];
+
+		ret = ops->xfer(bus, msg, 1);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int i2c_read(struct udevice *dev, uint offset, uint8_t *buffer, int len)
+{
+	struct dm_i2c_chip *chip = dev_get_parentdata(dev);
+	struct udevice *bus = dev_get_parent(dev);
+	struct dm_i2c_ops *ops = i2c_get_ops(bus);
+	struct i2c_msg msg[2], *ptr;
+	uint8_t offset_buf[I2C_MAX_OFFSET_LEN];
+	int msg_count;
+
+	if (!ops->xfer)
+		return -ENOSYS;
+	if (chip->flags & DM_I2C_CHIP_RD_ADDRESS)
+		return i2c_read_bytewise(dev, offset, buffer, len);
+	ptr = msg;
+	if (!i2c_setup_offset(chip, offset, offset_buf, ptr))
+		ptr++;
+
+	if (len) {
+		ptr->addr = chip->chip_addr;
+		ptr->flags = chip->flags & DM_I2C_CHIP_10BIT ? I2C_M_TEN : 0;
+		ptr->flags |= I2C_M_RD;
+		ptr->len = len;
+		ptr->buf = buffer;
+		ptr++;
+	}
+	msg_count = ptr - msg;
+
+	return ops->xfer(bus, msg, msg_count);
+}
+
+int i2c_write(struct udevice *dev, uint offset, const uint8_t *buffer, int len)
+{
+	struct dm_i2c_chip *chip = dev_get_parentdata(dev);
+	struct udevice *bus = dev_get_parent(dev);
+	struct dm_i2c_ops *ops = i2c_get_ops(bus);
+	struct i2c_msg msg[1];
+
+	if (!ops->xfer)
+		return -ENOSYS;
+
+	if (chip->flags & DM_I2C_CHIP_WR_ADDRESS)
+		return i2c_write_bytewise(dev, offset, buffer, len);
+	/*
+	 * The simple approach would be to send two messages here: one to
+	 * set the offset and one to write the bytes. However some drivers
+	 * will not be expecting this, and some chips won't like how the
+	 * driver presents this on the I2C bus.
+	 *
+	 * The API does not support separate offset and data. We could extend
+	 * it with a flag indicating that there is data in the next message
+	 * that needs to be processed in the same transaction. We could
+	 * instead add an additional buffer to each message. For now, handle
+	 * this in the uclass since it isn't clear what the impact on drivers
+	 * would be with this extra complication. Unfortunately this means
+	 * copying the message.
+	 *
+	 * Use the stack for small messages, malloc() for larger ones. We
+	 * need to allow space for the offset (up to 4 bytes) and the message
+	 * itself.
+	 */
+	if (len < 64) {
+		uint8_t buf[I2C_MAX_OFFSET_LEN + len];
+
+		i2c_setup_offset(chip, offset, buf, msg);
+		msg->len += len;
+		memcpy(buf + chip->offset_len, buffer, len);
+
+		return ops->xfer(bus, msg, 1);
+	} else {
+		uint8_t *buf;
+		int ret;
+
+		buf = malloc(I2C_MAX_OFFSET_LEN + len);
+		if (!buf)
+			return -ENOMEM;
+		i2c_setup_offset(chip, offset, buf, msg);
+		msg->len += len;
+		memcpy(buf + chip->offset_len, buffer, len);
+
+		ret = ops->xfer(bus, msg, 1);
+		free(buf);
+		return ret;
+	}
+}
+
+/**
+ * i2c_probe_chip() - probe for a chip on a bus
+ *
+ * @bus:	Bus to probe
+ * @chip_addr:	Chip address to probe
+ * @flags:	Flags for the chip
+ * @return 0 if found, -ENOSYS if the driver is invalid, -EREMOTEIO if the chip
+ * does not respond to probe
+ */
+static int i2c_probe_chip(struct udevice *bus, uint chip_addr,
+			  enum dm_i2c_chip_flags chip_flags)
+{
+	struct dm_i2c_ops *ops = i2c_get_ops(bus);
+	struct i2c_msg msg[1];
+	int ret;
+
+	if (ops->probe_chip) {
+		ret = ops->probe_chip(bus, chip_addr, chip_flags);
+		if (!ret || ret != -ENOSYS)
+			return ret;
+	}
+
+	if (!ops->xfer)
+		return -ENOSYS;
+
+	/* Probe with a zero-length message */
+	msg->addr = chip_addr;
+	msg->flags = chip_flags & DM_I2C_CHIP_10BIT ? I2C_M_TEN : 0;
+	msg->len = 0;
+	msg->buf = NULL;
+
+	return ops->xfer(bus, msg, 1);
+}
+
+static int i2c_bind_driver(struct udevice *bus, uint chip_addr,
+			   struct udevice **devp)
+{
+	struct dm_i2c_chip chip;
+	char name[30], *str;
+	struct udevice *dev;
+	int ret;
+
+	snprintf(name, sizeof(name), "generic_%x", chip_addr);
+	str = strdup(name);
+	ret = device_bind_driver(bus, "i2c_generic_chip_drv", str, &dev);
+	debug("%s:  device_bind_driver: ret=%d\n", __func__, ret);
+	if (ret)
+		goto err_bind;
+
+	/* Tell the device what we know about it */
+	memset(&chip, '\0', sizeof(chip));
+	chip.chip_addr = chip_addr;
+	chip.offset_len = 1;	/* we assume */
+	ret = device_probe_child(dev, &chip);
+	debug("%s:  device_probe_child: ret=%d\n", __func__, ret);
+	if (ret)
+		goto err_probe;
+
+	*devp = dev;
+	return 0;
+
+err_probe:
+	device_unbind(dev);
+err_bind:
+	free(str);
+	return ret;
+}
+
+int i2c_get_chip(struct udevice *bus, uint chip_addr, struct udevice **devp)
+{
+	struct udevice *dev;
+
+	debug("%s: Searching bus '%s' for address %02x: ", __func__,
+	      bus->name, chip_addr);
+	for (device_find_first_child(bus, &dev); dev;
+			device_find_next_child(&dev)) {
+		struct dm_i2c_chip store;
+		struct dm_i2c_chip *chip = dev_get_parentdata(dev);
+		int ret;
+
+		if (!chip) {
+			chip = &store;
+			i2c_chip_ofdata_to_platdata(gd->fdt_blob,
+						    dev->of_offset, chip);
+		}
+		if (chip->chip_addr == chip_addr) {
+			ret = device_probe(dev);
+			debug("found, ret=%d\n", ret);
+			if (ret)
+				return ret;
+			*devp = dev;
+			return 0;
+		}
+	}
+	debug("not found\n");
+	return i2c_bind_driver(bus, chip_addr, devp);
+}
+
+int i2c_get_chip_for_busnum(int busnum, int chip_addr, struct udevice **devp)
+{
+	struct udevice *bus;
+	int ret;
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus);
+	if (ret) {
+		debug("Cannot find I2C bus %d\n", busnum);
+		return ret;
+	}
+	ret = i2c_get_chip(bus, chip_addr, devp);
+	if (ret) {
+		debug("Cannot find I2C chip %02x on bus %d\n", chip_addr,
+		      busnum);
+		return ret;
+	}
+
+	return 0;
+}
+
+int i2c_probe(struct udevice *bus, uint chip_addr, uint chip_flags,
+	      struct udevice **devp)
+{
+	int ret;
+
+	*devp = NULL;
+
+	/* First probe that chip */
+	ret = i2c_probe_chip(bus, chip_addr, chip_flags);
+	debug("%s: bus='%s', address %02x, ret=%d\n", __func__, bus->name,
+	      chip_addr, ret);
+	if (ret)
+		return ret;
+
+	/* The chip was found, see if we have a driver, and probe it */
+	ret = i2c_get_chip(bus, chip_addr, devp);
+	debug("%s:  i2c_get_chip: ret=%d\n", __func__, ret);
+
+	return ret;
+}
+
+int i2c_set_bus_speed(struct udevice *bus, unsigned int speed)
+{
+	struct dm_i2c_ops *ops = i2c_get_ops(bus);
+	struct dm_i2c_bus *i2c = bus->uclass_priv;
+	int ret;
+
+	/*
+	 * If we have a method, call it. If not then the driver probably wants
+	 * to deal with speed changes on the next transfer. It can easily read
+	 * the current speed from this uclass
+	 */
+	if (ops->set_bus_speed) {
+		ret = ops->set_bus_speed(bus, speed);
+		if (ret)
+			return ret;
+	}
+	i2c->speed_hz = speed;
+
+	return 0;
+}
+
+/*
+ * i2c_get_bus_speed:
+ *
+ *  Returns speed of selected I2C bus in Hz
+ */
+int i2c_get_bus_speed(struct udevice *bus)
+{
+	struct dm_i2c_ops *ops = i2c_get_ops(bus);
+	struct dm_i2c_bus *i2c = bus->uclass_priv;
+
+	if (!ops->get_bus_speed)
+		return i2c->speed_hz;
+
+	return ops->get_bus_speed(bus);
+}
+
+int i2c_set_chip_flags(struct udevice *dev, uint flags)
+{
+	struct udevice *bus = dev->parent;
+	struct dm_i2c_chip *chip = dev_get_parentdata(dev);
+	struct dm_i2c_ops *ops = i2c_get_ops(bus);
+	int ret;
+
+	if (ops->set_flags) {
+		ret = ops->set_flags(dev, flags);
+		if (ret)
+			return ret;
+	}
+	chip->flags = flags;
+
+	return 0;
+}
+
+int i2c_get_chip_flags(struct udevice *dev, uint *flagsp)
+{
+	struct dm_i2c_chip *chip = dev_get_parentdata(dev);
+
+	*flagsp = chip->flags;
+
+	return 0;
+}
+
+int i2c_set_chip_offset_len(struct udevice *dev, uint offset_len)
+{
+	struct dm_i2c_chip *chip = dev_get_parentdata(dev);
+
+	if (offset_len > I2C_MAX_OFFSET_LEN)
+		return -EINVAL;
+	chip->offset_len = offset_len;
+
+	return 0;
+}
+
+int i2c_deblock(struct udevice *bus)
+{
+	struct dm_i2c_ops *ops = i2c_get_ops(bus);
+
+	/*
+	 * We could implement a software deblocking here if we could get
+	 * access to the GPIOs used by I2C, and switch them to GPIO mode
+	 * and then back to I2C. This is somewhat beyond our powers in
+	 * driver model at present, so for now just fail.
+	 *
+	 * See https://patchwork.ozlabs.org/patch/399040/
+	 */
+	if (!ops->deblock)
+		return -ENOSYS;
+
+	return ops->deblock(bus);
+}
+
+int i2c_chip_ofdata_to_platdata(const void *blob, int node,
+				struct dm_i2c_chip *chip)
+{
+	chip->offset_len = 1;	/* default */
+	chip->flags = 0;
+	chip->chip_addr = fdtdec_get_int(gd->fdt_blob, node, "reg", -1);
+	if (chip->chip_addr == -1) {
+		debug("%s: I2C Node '%s' has no 'reg' property\n", __func__,
+		      fdt_get_name(blob, node, NULL));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int i2c_post_probe(struct udevice *dev)
+{
+	struct dm_i2c_bus *i2c = dev->uclass_priv;
+
+	i2c->speed_hz = fdtdec_get_int(gd->fdt_blob, dev->of_offset,
+				     "clock-frequency", 100000);
+
+	return i2c_set_bus_speed(dev, i2c->speed_hz);
+}
+
+int i2c_post_bind(struct udevice *dev)
+{
+	/* Scan the bus for devices */
+	return dm_scan_fdt_node(dev, gd->fdt_blob, dev->of_offset, false);
+}
+
+UCLASS_DRIVER(i2c) = {
+	.id		= UCLASS_I2C,
+	.name		= "i2c",
+	.per_device_auto_alloc_size = sizeof(struct dm_i2c_bus),
+	.post_bind	= i2c_post_bind,
+	.post_probe	= i2c_post_probe,
+};
+
+UCLASS_DRIVER(i2c_generic) = {
+	.id		= UCLASS_I2C_GENERIC,
+	.name		= "i2c_generic",
+};
+
+U_BOOT_DRIVER(i2c_generic_chip_drv) = {
+	.name		= "i2c_generic_chip_drv",
+	.id		= UCLASS_I2C_GENERIC,
+};
diff -ruN u-boot-2015.01-rc3/drivers/i2c/Makefile u-boot/drivers/i2c/Makefile
--- u-boot-2015.01-rc3/drivers/i2c/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/i2c/Makefile	2015-01-01 17:34:32.641496891 +0100
@@ -4,6 +4,7 @@
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
+obj-$(CONFIG_DM_I2C) += i2c-uclass.o
 
 obj-$(CONFIG_SYS_I2C_ADI) += adi_i2c.o
 obj-$(CONFIG_I2C_MV) += mv_i2c.o
@@ -26,6 +27,7 @@
 obj-$(CONFIG_SYS_I2C_PPC4XX) += ppc4xx_i2c.o
 obj-$(CONFIG_SYS_I2C_RCAR) += rcar_i2c.o
 obj-$(CONFIG_SYS_I2C_S3C24X0) += s3c24x0_i2c.o
+obj-$(CONFIG_SYS_I2C_SANDBOX) += sandbox_i2c.o i2c-emul-uclass.o
 obj-$(CONFIG_SYS_I2C_SH) += sh_i2c.o
 obj-$(CONFIG_SYS_I2C_SOFT) += soft_i2c.o
 obj-$(CONFIG_SYS_I2C_TEGRA) += tegra_i2c.o
diff -ruN u-boot-2015.01-rc3/drivers/i2c/sandbox_i2c.c u-boot/drivers/i2c/sandbox_i2c.c
--- u-boot-2015.01-rc3/drivers/i2c/sandbox_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/i2c/sandbox_i2c.c	2015-01-01 17:34:32.649496760 +0100
@@ -0,0 +1,111 @@
+/*
+ * Simulate an I2C port
+ *
+ * Copyright (c) 2014 Google, Inc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <i2c.h>
+#include <asm/test.h>
+#include <dm/lists.h>
+#include <dm/device-internal.h>
+#include <dm/root.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct dm_sandbox_i2c_emul_priv {
+	struct udevice *emul;
+};
+
+static int get_emul(struct udevice *dev, struct udevice **devp,
+		    struct dm_i2c_ops **opsp)
+{
+	struct dm_i2c_chip *priv;
+	int ret;
+
+	*devp = NULL;
+	*opsp = NULL;
+	priv = dev_get_parentdata(dev);
+	if (!priv->emul) {
+		ret = dm_scan_fdt_node(dev, gd->fdt_blob, dev->of_offset,
+				       false);
+		if (ret)
+			return ret;
+
+		ret = device_get_child(dev, 0, &priv->emul);
+		if (ret)
+			return ret;
+	}
+	*devp = priv->emul;
+	*opsp = i2c_get_ops(priv->emul);
+
+	return 0;
+}
+
+static int sandbox_i2c_xfer(struct udevice *bus, struct i2c_msg *msg,
+			    int nmsgs)
+{
+	struct dm_i2c_bus *i2c = bus->uclass_priv;
+	struct dm_i2c_ops *ops;
+	struct udevice *emul, *dev;
+	bool is_read;
+	int ret;
+
+	/* Special test code to return success but with no emulation */
+	if (msg->addr == SANDBOX_I2C_TEST_ADDR)
+		return 0;
+
+	ret = i2c_get_chip(bus, msg->addr, &dev);
+	if (ret)
+		return ret;
+
+	ret = get_emul(dev, &emul, &ops);
+	if (ret)
+		return ret;
+
+	/*
+	 * For testing, don't allow writing above 100KHz for writes and
+	 * 400KHz for reads
+	 */
+	is_read = nmsgs > 1;
+	if (i2c->speed_hz > (is_read ? 400000 : 100000))
+		return -EINVAL;
+	return ops->xfer(emul, msg, nmsgs);
+}
+
+static const struct dm_i2c_ops sandbox_i2c_ops = {
+	.xfer		= sandbox_i2c_xfer,
+};
+
+static int sandbox_i2c_child_pre_probe(struct udevice *dev)
+{
+	struct dm_i2c_chip *i2c_chip = dev_get_parentdata(dev);
+
+	/* Ignore our test address */
+	if (i2c_chip->chip_addr == SANDBOX_I2C_TEST_ADDR)
+		return 0;
+	if (dev->of_offset == -1)
+		return 0;
+
+	return i2c_chip_ofdata_to_platdata(gd->fdt_blob, dev->of_offset,
+					   i2c_chip);
+}
+
+static const struct udevice_id sandbox_i2c_ids[] = {
+	{ .compatible = "sandbox,i2c" },
+	{ }
+};
+
+U_BOOT_DRIVER(i2c_sandbox) = {
+	.name	= "i2c_sandbox",
+	.id	= UCLASS_I2C,
+	.of_match = sandbox_i2c_ids,
+	.per_child_auto_alloc_size = sizeof(struct dm_i2c_chip),
+	.child_pre_probe = sandbox_i2c_child_pre_probe,
+	.ops	= &sandbox_i2c_ops,
+};
diff -ruN u-boot-2015.01-rc3/drivers/i2c/tegra_i2c.c u-boot/drivers/i2c/tegra_i2c.c
--- u-boot-2015.01-rc3/drivers/i2c/tegra_i2c.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/i2c/tegra_i2c.c	2015-01-01 17:34:32.649496760 +0100
@@ -7,6 +7,8 @@
  */
 
 #include <common.h>
+#include <dm.h>
+#include <errno.h>
 #include <fdtdec.h>
 #include <i2c.h>
 #include <asm/io.h>
@@ -19,6 +21,12 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+enum i2c_type {
+	TYPE_114,
+	TYPE_STD,
+	TYPE_DVC,
+};
+
 /* Information about i2c controller */
 struct i2c_bus {
 	int			id;
@@ -27,20 +35,17 @@
 	int			pinmux_config;
 	struct i2c_control	*control;
 	struct i2c_ctlr		*regs;
-	int			is_dvc;	/* DVC type, rather than I2C */
-	int			is_scs;	/* single clock source (T114+) */
+	enum i2c_type		type;
 	int			inited;	/* bus is inited */
 };
 
-static struct i2c_bus i2c_controllers[TEGRA_I2C_NUM_CONTROLLERS];
-
 static void set_packet_mode(struct i2c_bus *i2c_bus)
 {
 	u32 config;
 
 	config = I2C_CNFG_NEW_MASTER_FSM_MASK | I2C_CNFG_PACKET_MODE_MASK;
 
-	if (i2c_bus->is_dvc) {
+	if (i2c_bus->type == TYPE_DVC) {
 		struct dvc_ctlr *dvc = (struct dvc_ctlr *)i2c_bus->regs;
 
 		writel(config, &dvc->cnfg);
@@ -65,6 +70,9 @@
 
 static void i2c_init_controller(struct i2c_bus *i2c_bus)
 {
+	if (!i2c_bus->speed)
+		return;
+	debug("%s: speed=%d\n", __func__, i2c_bus->speed);
 	/*
 	 * Use PLLP - DP-04508-001_v06 datasheet indicates a divisor of 8
 	 * here, in section 23.3.1, but in fact we seem to need a factor of
@@ -73,7 +81,7 @@
 	clock_start_periph_pll(i2c_bus->periph_id, CLOCK_ID_PERIPH,
 		i2c_bus->speed * 2 * 8);
 
-	if (i2c_bus->is_scs) {
+	if (i2c_bus->type == TYPE_114) {
 		/*
 		 * T114 I2C went to a single clock source for standard/fast and
 		 * HS clock speeds. The new clock rate setting calculation is:
@@ -98,7 +106,7 @@
 	i2c_reset_controller(i2c_bus);
 
 	/* Configure I2C controller. */
-	if (i2c_bus->is_dvc) {	/* only for DVC I2C */
+	if (i2c_bus->type == TYPE_DVC) {	/* only for DVC I2C */
 		struct dvc_ctlr *dvc = (struct dvc_ctlr *)i2c_bus->regs;
 
 		setbits_le32(&dvc->ctrl3, DVC_CTRL_REG3_I2C_HW_SW_PROG_MASK);
@@ -272,7 +280,7 @@
 	return error;
 }
 
-static int tegra_i2c_write_data(struct i2c_bus *bus, u32 addr, u8 *data,
+static int tegra_i2c_write_data(struct i2c_bus *i2c_bus, u32 addr, u8 *data,
 				u32 len, bool end_with_repeated_start)
 {
 	int error;
@@ -286,14 +294,14 @@
 	trans_info.num_bytes = len;
 	trans_info.is_10bit_address = 0;
 
-	error = send_recv_packets(bus, &trans_info);
+	error = send_recv_packets(i2c_bus, &trans_info);
 	if (error)
 		debug("tegra_i2c_write_data: Error (%d) !!!\n", error);
 
 	return error;
 }
 
-static int tegra_i2c_read_data(struct i2c_bus *bus, u32 addr, u8 *data,
+static int tegra_i2c_read_data(struct i2c_bus *i2c_bus, u32 addr, u8 *data,
 			       u32 len)
 {
 	int error;
@@ -305,52 +313,32 @@
 	trans_info.num_bytes = len;
 	trans_info.is_10bit_address = 0;
 
-	error = send_recv_packets(bus, &trans_info);
+	error = send_recv_packets(i2c_bus, &trans_info);
 	if (error)
 		debug("tegra_i2c_read_data: Error (%d) !!!\n", error);
 
 	return error;
 }
 
-#ifndef CONFIG_OF_CONTROL
-#error "Please enable device tree support to use this driver"
-#endif
-
-/**
- * Check that a bus number is valid and return a pointer to it
- *
- * @param bus_num	Bus number to check / return
- * @return pointer to bus, if valid, else NULL
- */
-static struct i2c_bus *tegra_i2c_get_bus(struct i2c_adapter *adap)
+static int tegra_i2c_set_bus_speed(struct udevice *dev, unsigned int speed)
 {
-	struct i2c_bus *bus;
+	struct i2c_bus *i2c_bus = dev_get_priv(dev);
 
-	bus = &i2c_controllers[adap->hwadapnr];
-	if (!bus->inited) {
-		debug("%s: Bus %u not available\n", __func__, adap->hwadapnr);
-		return NULL;
-	}
-
-	return bus;
-}
-
-static unsigned int tegra_i2c_set_bus_speed(struct i2c_adapter *adap,
-			unsigned int speed)
-{
-	struct i2c_bus *bus;
-
-	bus = tegra_i2c_get_bus(adap);
-	if (!bus)
-		return 0;
-	bus->speed = speed;
-	i2c_init_controller(bus);
+	i2c_bus->speed = speed;
+	i2c_init_controller(i2c_bus);
 
 	return 0;
 }
 
-static int i2c_get_config(const void *blob, int node, struct i2c_bus *i2c_bus)
+static int tegra_i2c_probe(struct udevice *dev)
 {
+	struct i2c_bus *i2c_bus = dev_get_priv(dev);
+	const void *blob = gd->fdt_blob;
+	int node = dev->of_offset;
+	bool is_dvc;
+
+	i2c_bus->id = dev->seq;
+	i2c_bus->type = dev_get_of_data(dev);
 	i2c_bus->regs = (struct i2c_ctlr *)fdtdec_get_addr(blob, node, "reg");
 
 	/*
@@ -358,7 +346,6 @@
 	 * far no one needs anything other than the default.
 	 */
 	i2c_bus->pinmux_config = FUNCMUX_DEFAULT;
-	i2c_bus->speed = fdtdec_get_int(blob, node, "clock-frequency", 0);
 	i2c_bus->periph_id = clock_decode_periph_id(blob, node);
 
 	/*
@@ -371,107 +358,25 @@
 	 *		i2c_bus->pinmux_config = FUNCMUX_I2C2_PTA;
 	 */
 	if (i2c_bus->periph_id == -1)
-		return -FDT_ERR_NOTFOUND;
+		return -EINVAL;
 
-	return 0;
-}
-
-/*
- * Process a list of nodes, adding them to our list of I2C ports.
- *
- * @param blob		fdt blob
- * @param node_list	list of nodes to process (any <=0 are ignored)
- * @param count		number of nodes to process
- * @param is_dvc	1 if these are DVC ports, 0 if standard I2C
- * @param is_scs	1 if this HW uses a single clock source (T114+)
- * @return 0 if ok, -1 on error
- */
-static int process_nodes(const void *blob, int node_list[], int count,
-			 int is_dvc, int is_scs)
-{
-	struct i2c_bus *i2c_bus;
-	int i;
-
-	/* build the i2c_controllers[] for each controller */
-	for (i = 0; i < count; i++) {
-		int node = node_list[i];
-
-		if (node <= 0)
-			continue;
-
-		i2c_bus = &i2c_controllers[i];
-		i2c_bus->id = i;
-
-		if (i2c_get_config(blob, node, i2c_bus)) {
-			printf("i2c_init_board: failed to decode bus %d\n", i);
-			return -1;
-		}
-
-		i2c_bus->is_scs = is_scs;
-
-		i2c_bus->is_dvc = is_dvc;
-		if (is_dvc) {
-			i2c_bus->control =
-				&((struct dvc_ctlr *)i2c_bus->regs)->control;
-		} else {
-			i2c_bus->control = &i2c_bus->regs->control;
-		}
-		debug("%s: controller bus %d at %p, periph_id %d, speed %d: ",
-		      is_dvc ? "dvc" : "i2c", i, i2c_bus->regs,
-		      i2c_bus->periph_id, i2c_bus->speed);
-		i2c_init_controller(i2c_bus);
-		debug("ok\n");
-		i2c_bus->inited = 1;
-
-		/* Mark position as used */
-		node_list[i] = -1;
+	is_dvc = dev_get_of_data(dev) == TYPE_DVC;
+	if (is_dvc) {
+		i2c_bus->control =
+			&((struct dvc_ctlr *)i2c_bus->regs)->control;
+	} else {
+		i2c_bus->control = &i2c_bus->regs->control;
 	}
+	i2c_init_controller(i2c_bus);
+	debug("%s: controller bus %d at %p, periph_id %d, speed %d: ",
+	      is_dvc ? "dvc" : "i2c", dev->seq, i2c_bus->regs,
+	      i2c_bus->periph_id, i2c_bus->speed);
 
 	return 0;
 }
 
-/* Sadly there is no error return from this function */
-void i2c_init_board(void)
-{
-	int node_list[TEGRA_I2C_NUM_CONTROLLERS];
-	const void *blob = gd->fdt_blob;
-	int count;
-
-	/* First check for newer (T114+) I2C ports */
-	count = fdtdec_find_aliases_for_id(blob, "i2c",
-			COMPAT_NVIDIA_TEGRA114_I2C, node_list,
-			TEGRA_I2C_NUM_CONTROLLERS);
-	if (process_nodes(blob, node_list, count, 0, 1))
-		return;
-
-	/* Now get the older (T20/T30) normal I2C ports */
-	count = fdtdec_find_aliases_for_id(blob, "i2c",
-			COMPAT_NVIDIA_TEGRA20_I2C, node_list,
-			TEGRA_I2C_NUM_CONTROLLERS);
-	if (process_nodes(blob, node_list, count, 0, 0))
-		return;
-
-	/* Now look for dvc ports */
-	count = fdtdec_add_aliases_for_id(blob, "i2c",
-			COMPAT_NVIDIA_TEGRA20_DVC, node_list,
-			TEGRA_I2C_NUM_CONTROLLERS);
-	if (process_nodes(blob, node_list, count, 1, 0))
-		return;
-}
-
-static void tegra_i2c_init(struct i2c_adapter *adap, int speed, int slaveaddr)
-{
-	/* No i2c support prior to relocation */
-	if (!(gd->flags & GD_FLG_RELOC))
-		return;
-
-	/* This will override the speed selected in the fdt for that port */
-	debug("i2c_init(speed=%u, slaveaddr=0x%x)\n", speed, slaveaddr);
-	i2c_set_bus_speed(speed);
-}
-
 /* i2c write version without the register address */
-static int i2c_write_data(struct i2c_bus *bus, uchar chip, uchar *buffer,
+static int i2c_write_data(struct i2c_bus *i2c_bus, uchar chip, uchar *buffer,
 			  int len, bool end_with_repeated_start)
 {
 	int rc;
@@ -484,7 +389,7 @@
 	debug("\n");
 
 	/* Shift 7-bit address over for lower-level i2c functions */
-	rc = tegra_i2c_write_data(bus, chip << 1, buffer, len,
+	rc = tegra_i2c_write_data(i2c_bus, chip << 1, buffer, len,
 				  end_with_repeated_start);
 	if (rc)
 		debug("i2c_write_data(): rc=%d\n", rc);
@@ -493,14 +398,14 @@
 }
 
 /* i2c read version without the register address */
-static int i2c_read_data(struct i2c_bus *bus, uchar chip, uchar *buffer,
-				int len)
+static int i2c_read_data(struct i2c_bus *i2c_bus, uchar chip, uchar *buffer,
+			 int len)
 {
 	int rc;
 
 	debug("inside i2c_read_data():\n");
 	/* Shift 7-bit address over for lower-level i2c functions */
-	rc = tegra_i2c_read_data(bus, chip << 1, buffer, len);
+	rc = tegra_i2c_read_data(i2c_bus, chip << 1, buffer, len);
 	if (rc) {
 		debug("i2c_read_data(): rc=%d\n", rc);
 		return rc;
@@ -516,132 +421,99 @@
 }
 
 /* Probe to see if a chip is present. */
-static int tegra_i2c_probe(struct i2c_adapter *adap, uchar chip)
+static int tegra_i2c_probe_chip(struct udevice *bus, uint chip_addr,
+				uint chip_flags)
 {
-	struct i2c_bus *bus;
+	struct i2c_bus *i2c_bus = dev_get_priv(bus);
 	int rc;
-	uchar reg;
+	u8 reg;
 
-	debug("i2c_probe: addr=0x%x\n", chip);
-	bus = tegra_i2c_get_bus(adap);
-	if (!bus)
-		return 1;
-	reg = 0;
-	rc = i2c_write_data(bus, chip, &reg, 1, false);
-	if (rc) {
-		debug("Error probing 0x%x.\n", chip);
-		return 1;
-	}
-	return 0;
+	/* Shift 7-bit address over for lower-level i2c functions */
+	rc = tegra_i2c_write_data(i2c_bus, chip_addr << 1, &reg, sizeof(reg),
+				  false);
+
+	return rc;
 }
 
-static int i2c_addr_ok(const uint addr, const int alen)
+static int tegra_i2c_xfer(struct udevice *bus, struct i2c_msg *msg,
+			  int nmsgs)
 {
-	/* We support 7 or 10 bit addresses, so one or two bytes each */
-	return alen == 1 || alen == 2;
-}
+	struct i2c_bus *i2c_bus = dev_get_priv(bus);
+	int ret;
 
-/* Read bytes */
-static int tegra_i2c_read(struct i2c_adapter *adap, uchar chip, uint addr,
-			int alen, uchar *buffer, int len)
-{
-	struct i2c_bus *bus;
-	uint offset;
-	int i;
-
-	debug("i2c_read: chip=0x%x, addr=0x%x, alen=0x%x len=0x%x\n",
-	      chip, addr, alen, len);
-	bus = tegra_i2c_get_bus(adap);
-	if (!bus)
-		return 1;
-	if (!i2c_addr_ok(addr, alen)) {
-		debug("i2c_read: Bad address %x.%d.\n", addr, alen);
-		return 1;
-	}
-	for (offset = 0; offset < len; offset++) {
-		if (alen) {
-			uchar data[alen];
-			for (i = 0; i < alen; i++) {
-				data[alen - i - 1] =
-					(addr + offset) >> (8 * i);
-			}
-			if (i2c_write_data(bus, chip, data, alen, true)) {
-				debug("i2c_read: error sending (0x%x)\n",
-					addr);
-				return 1;
-			}
+	debug("i2c_xfer: %d messages\n", nmsgs);
+	for (; nmsgs > 0; nmsgs--, msg++) {
+		bool next_is_read = nmsgs > 1 && (msg[1].flags & I2C_M_RD);
+
+		debug("i2c_xfer: chip=0x%x, len=0x%x\n", msg->addr, msg->len);
+		if (msg->flags & I2C_M_RD) {
+			ret = i2c_read_data(i2c_bus, msg->addr, msg->buf,
+					    msg->len);
+		} else {
+			ret = i2c_write_data(i2c_bus, msg->addr, msg->buf,
+					     msg->len, next_is_read);
 		}
-		if (i2c_read_data(bus, chip, buffer + offset, 1)) {
-			debug("i2c_read: error reading (0x%x)\n", addr);
-			return 1;
+		if (ret) {
+			debug("i2c_write: error sending\n");
+			return -EREMOTEIO;
 		}
 	}
 
 	return 0;
 }
 
-/* Write bytes */
-static int tegra_i2c_write(struct i2c_adapter *adap, uchar chip, uint addr,
-			int alen, uchar *buffer, int len)
-{
-	struct i2c_bus *bus;
-	uint offset;
-	int i;
-
-	debug("i2c_write: chip=0x%x, addr=0x%x, alen=0x%x len=0x%x\n",
-	      chip, addr, alen, len);
-	bus = tegra_i2c_get_bus(adap);
-	if (!bus)
-		return 1;
-	if (!i2c_addr_ok(addr, alen)) {
-		debug("i2c_write: Bad address %x.%d.\n", addr, alen);
-		return 1;
-	}
-	for (offset = 0; offset < len; offset++) {
-		uchar data[alen + 1];
-		for (i = 0; i < alen; i++)
-			data[alen - i - 1] = (addr + offset) >> (8 * i);
-		data[alen] = buffer[offset];
-		if (i2c_write_data(bus, chip, data, alen + 1, false)) {
-			debug("i2c_write: error sending (0x%x)\n", addr);
-			return 1;
+int tegra_i2c_get_dvc_bus(struct udevice **busp)
+{
+	struct udevice *bus;
+
+	for (uclass_first_device(UCLASS_I2C, &bus);
+	     bus;
+	     uclass_next_device(&bus)) {
+		if (dev_get_of_data(bus) == TYPE_DVC) {
+			*busp = bus;
+			return 0;
 		}
 	}
 
-	return 0;
+	return -ENODEV;
 }
 
-int tegra_i2c_get_dvc_bus_num(void)
-{
-	int i;
+static const struct dm_i2c_ops tegra_i2c_ops = {
+	.xfer		= tegra_i2c_xfer,
+	.probe_chip	= tegra_i2c_probe_chip,
+	.set_bus_speed	= tegra_i2c_set_bus_speed,
+};
 
-	for (i = 0; i < TEGRA_I2C_NUM_CONTROLLERS; i++) {
-		struct i2c_bus *bus = &i2c_controllers[i];
+static int tegra_i2c_child_pre_probe(struct udevice *dev)
+{
+	struct dm_i2c_chip *i2c_chip = dev_get_parentdata(dev);
 
-		if (bus->inited && bus->is_dvc)
-			return i;
-	}
+	if (dev->of_offset == -1)
+		return 0;
+	return i2c_chip_ofdata_to_platdata(gd->fdt_blob, dev->of_offset,
+					   i2c_chip);
+}
 
-	return -1;
+static int tegra_i2c_ofdata_to_platdata(struct udevice *dev)
+{
+	return 0;
 }
 
-/*
- * Register soft i2c adapters
- */
-U_BOOT_I2C_ADAP_COMPLETE(tegra0, tegra_i2c_init, tegra_i2c_probe,
-			 tegra_i2c_read, tegra_i2c_write,
-			 tegra_i2c_set_bus_speed, 100000, 0, 0)
-U_BOOT_I2C_ADAP_COMPLETE(tegra1, tegra_i2c_init, tegra_i2c_probe,
-			 tegra_i2c_read, tegra_i2c_write,
-			 tegra_i2c_set_bus_speed, 100000, 0, 1)
-U_BOOT_I2C_ADAP_COMPLETE(tegra2, tegra_i2c_init, tegra_i2c_probe,
-			 tegra_i2c_read, tegra_i2c_write,
-			 tegra_i2c_set_bus_speed, 100000, 0, 2)
-U_BOOT_I2C_ADAP_COMPLETE(tegra3, tegra_i2c_init, tegra_i2c_probe,
-			 tegra_i2c_read, tegra_i2c_write,
-			 tegra_i2c_set_bus_speed, 100000, 0, 3)
-#if TEGRA_I2C_NUM_CONTROLLERS > 4
-U_BOOT_I2C_ADAP_COMPLETE(tegra4, tegra_i2c_init, tegra_i2c_probe,
-			 tegra_i2c_read, tegra_i2c_write,
-			 tegra_i2c_set_bus_speed, 100000, 0, 4)
-#endif
+static const struct udevice_id tegra_i2c_ids[] = {
+	{ .compatible = "nvidia,tegra114-i2c", .data = TYPE_114 },
+	{ .compatible = "nvidia,tegra20-i2c", .data = TYPE_STD },
+	{ .compatible = "nvidia,tegra20-i2c-dvc", .data = TYPE_DVC },
+	{ }
+};
+
+U_BOOT_DRIVER(i2c_tegra) = {
+	.name	= "i2c_tegra",
+	.id	= UCLASS_I2C,
+	.of_match = tegra_i2c_ids,
+	.ofdata_to_platdata = tegra_i2c_ofdata_to_platdata,
+	.probe	= tegra_i2c_probe,
+	.per_child_auto_alloc_size = sizeof(struct dm_i2c_chip),
+	.child_pre_probe = tegra_i2c_child_pre_probe,
+	.priv_auto_alloc_size = sizeof(struct i2c_bus),
+	.ops	= &tegra_i2c_ops,
+};
diff -ruN u-boot-2015.01-rc3/drivers/misc/i2c_eeprom.c u-boot/drivers/misc/i2c_eeprom.c
--- u-boot-2015.01-rc3/drivers/misc/i2c_eeprom.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/misc/i2c_eeprom.c	2015-01-01 17:34:32.649496760 +0100
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2014 Google, Inc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <i2c.h>
+#include <i2c_eeprom.h>
+
+static int i2c_eeprom_read(struct udevice *dev, int offset, uint8_t *buf,
+			   int size)
+{
+	return -ENODEV;
+}
+
+static int i2c_eeprom_write(struct udevice *dev, int offset,
+			    const uint8_t *buf, int size)
+{
+	return -ENODEV;
+}
+
+struct i2c_eeprom_ops i2c_eeprom_std_ops = {
+	.read	= i2c_eeprom_read,
+	.write	= i2c_eeprom_write,
+};
+
+int i2c_eeprom_std_probe(struct udevice *dev)
+{
+	return 0;
+}
+
+static const struct udevice_id i2c_eeprom_std_ids[] = {
+	{ .compatible = "i2c-eeprom" },
+	{ }
+};
+
+U_BOOT_DRIVER(i2c_eeprom_std) = {
+	.name		= "i2c_eeprom",
+	.id		= UCLASS_I2C_EEPROM,
+	.of_match	= i2c_eeprom_std_ids,
+	.probe		= i2c_eeprom_std_probe,
+	.priv_auto_alloc_size = sizeof(struct i2c_eeprom),
+	.ops		= &i2c_eeprom_std_ops,
+};
+
+UCLASS_DRIVER(i2c_eeprom) = {
+	.id		= UCLASS_I2C_EEPROM,
+	.name		= "i2c_eeprom",
+};
diff -ruN u-boot-2015.01-rc3/drivers/misc/i2c_eeprom_emul.c u-boot/drivers/misc/i2c_eeprom_emul.c
--- u-boot-2015.01-rc3/drivers/misc/i2c_eeprom_emul.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/misc/i2c_eeprom_emul.c	2015-01-01 17:34:32.649496760 +0100
@@ -0,0 +1,168 @@
+/*
+ * Simulate an I2C eeprom
+ *
+ * Copyright (c) 2014 Google, Inc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <fdtdec.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <asm/test.h>
+
+#ifdef DEBUG
+#define debug_buffer print_buffer
+#else
+#define debug_buffer(x, ...)
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct sandbox_i2c_flash_plat_data {
+	enum sandbox_i2c_eeprom_test_mode test_mode;
+	const char *filename;
+	int offset_len;		/* Length of an offset in bytes */
+	int size;		/* Size of data buffer */
+};
+
+struct sandbox_i2c_flash {
+	uint8_t *data;
+};
+
+void sandbox_i2c_eeprom_set_test_mode(struct udevice *dev,
+				      enum sandbox_i2c_eeprom_test_mode mode)
+{
+	struct sandbox_i2c_flash_plat_data *plat = dev_get_platdata(dev);
+
+	plat->test_mode = mode;
+}
+
+void sandbox_i2c_eeprom_set_offset_len(struct udevice *dev, int offset_len)
+{
+	struct sandbox_i2c_flash_plat_data *plat = dev_get_platdata(dev);
+
+	plat->offset_len = offset_len;
+}
+
+static int sandbox_i2c_eeprom_xfer(struct udevice *emul, struct i2c_msg *msg,
+				  int nmsgs)
+{
+	struct sandbox_i2c_flash *priv = dev_get_priv(emul);
+	uint offset = 0;
+
+	debug("\n%s\n", __func__);
+	debug_buffer(0, priv->data, 1, 16, 0);
+	for (; nmsgs > 0; nmsgs--, msg++) {
+		struct sandbox_i2c_flash_plat_data *plat =
+				dev_get_platdata(emul);
+		int len;
+		u8 *ptr;
+
+		if (!plat->size)
+			return -ENODEV;
+		if (msg->addr + msg->len > plat->size) {
+			debug("%s: Address %x, len %x is outside range 0..%x\n",
+			      __func__, msg->addr, msg->len, plat->size);
+			return -EINVAL;
+		}
+		len = msg->len;
+		debug("   %s: msg->len=%d",
+		      msg->flags & I2C_M_RD ? "read" : "write",
+		      msg->len);
+		if (msg->flags & I2C_M_RD) {
+			if (plat->test_mode == SIE_TEST_MODE_SINGLE_BYTE)
+				len = 1;
+			debug(", offset %x, len %x: ", offset, len);
+			memcpy(msg->buf, priv->data + offset, len);
+			memset(msg->buf + len, '\xff', msg->len - len);
+			debug_buffer(0, msg->buf, 1, msg->len, 0);
+		} else if (len >= plat->offset_len) {
+			int i;
+
+			ptr = msg->buf;
+			for (i = 0; i < plat->offset_len; i++, len--)
+				offset = (offset << 8) | *ptr++;
+			debug(", set offset %x: ", offset);
+			debug_buffer(0, msg->buf, 1, msg->len, 0);
+			if (plat->test_mode == SIE_TEST_MODE_SINGLE_BYTE)
+				len = min(len, 1);
+
+			/* For testing, map offsets into our limited buffer */
+			for (i = 24; i > 0; i -= 8) {
+				if (offset > (1 << i)) {
+					offset = (offset >> i) |
+						(offset & ((1 << i) - 1));
+					offset += i;
+				}
+			}
+			memcpy(priv->data + offset, ptr, len);
+		}
+	}
+	debug_buffer(0, priv->data, 1, 16, 0);
+
+	return 0;
+}
+
+struct dm_i2c_ops sandbox_i2c_emul_ops = {
+	.xfer = sandbox_i2c_eeprom_xfer,
+};
+
+static int sandbox_i2c_eeprom_ofdata_to_platdata(struct udevice *dev)
+{
+	struct sandbox_i2c_flash_plat_data *plat = dev_get_platdata(dev);
+
+	plat->size = fdtdec_get_int(gd->fdt_blob, dev->of_offset,
+				    "sandbox,size", 32);
+	plat->filename = fdt_getprop(gd->fdt_blob, dev->of_offset,
+				     "sandbox,filename", NULL);
+	if (!plat->filename) {
+		debug("%s: No filename for device '%s'\n", __func__,
+		      dev->name);
+		return -EINVAL;
+	}
+	plat->test_mode = SIE_TEST_MODE_NONE;
+	plat->offset_len = 1;
+
+	return 0;
+}
+
+static int sandbox_i2c_eeprom_probe(struct udevice *dev)
+{
+	struct sandbox_i2c_flash_plat_data *plat = dev_get_platdata(dev);
+	struct sandbox_i2c_flash *priv = dev_get_priv(dev);
+
+	priv->data = calloc(1, plat->size);
+	if (!priv->data)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int sandbox_i2c_eeprom_remove(struct udevice *dev)
+{
+	struct sandbox_i2c_flash *priv = dev_get_priv(dev);
+
+	free(priv->data);
+
+	return 0;
+}
+
+static const struct udevice_id sandbox_i2c_ids[] = {
+	{ .compatible = "sandbox,i2c-eeprom" },
+	{ }
+};
+
+U_BOOT_DRIVER(sandbox_i2c_emul) = {
+	.name		= "sandbox_i2c_eeprom_emul",
+	.id		= UCLASS_I2C_EMUL,
+	.of_match	= sandbox_i2c_ids,
+	.ofdata_to_platdata = sandbox_i2c_eeprom_ofdata_to_platdata,
+	.probe		= sandbox_i2c_eeprom_probe,
+	.remove		= sandbox_i2c_eeprom_remove,
+	.priv_auto_alloc_size = sizeof(struct sandbox_i2c_flash),
+	.platdata_auto_alloc_size = sizeof(struct sandbox_i2c_flash_plat_data),
+	.ops		= &sandbox_i2c_emul_ops,
+};
diff -ruN u-boot-2015.01-rc3/drivers/misc/Makefile u-boot/drivers/misc/Makefile
--- u-boot-2015.01-rc3/drivers/misc/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/misc/Makefile	2015-01-01 17:34:32.649496760 +0100
@@ -15,11 +15,16 @@
 obj-$(CONFIG_CROS_EC_SPI) += cros_ec_spi.o
 obj-$(CONFIG_FSL_IIM) += fsl_iim.o
 obj-$(CONFIG_GPIO_LED) += gpio_led.o
+obj-$(CONFIG_I2C_EEPROM) += i2c_eeprom.o
 obj-$(CONFIG_FSL_MC9SDZ60) += mc9sdz60.o
 obj-$(CONFIG_MXC_OCOTP) += mxc_ocotp.o
 obj-$(CONFIG_MXS_OCOTP) += mxs_ocotp.o
 obj-$(CONFIG_NS87308) += ns87308.o
 obj-$(CONFIG_PDSP188x) += pdsp188x.o
+ifdef CONFIG_DM_I2C
+obj-$(CONFIG_SANDBOX) += i2c_eeprom_emul.o
+endif
+obj-$(CONFIG_SMSC_LPC47M) += smsc_lpc47m.o
 obj-$(CONFIG_STATUS_LED) += status_led.o
 obj-$(CONFIG_TWL4030_LED) += twl4030_led.o
 obj-$(CONFIG_FSL_IFC) += fsl_ifc.o
diff -ruN u-boot-2015.01-rc3/drivers/misc/mxc_ocotp.c u-boot/drivers/misc/mxc_ocotp.c
--- u-boot-2015.01-rc3/drivers/misc/mxc_ocotp.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/misc/mxc_ocotp.c	2015-01-01 17:34:32.649496760 +0100
@@ -81,8 +81,6 @@
 	err = !!(readl(&regs->ctrl) & BM_CTRL_ERROR);
 	clear_error(regs);
 
-	enable_ocotp_clk(0);
-
 	if (err) {
 		printf("mxc_ocotp %s(): Access protect error\n", caller);
 		return -EIO;
diff -ruN u-boot-2015.01-rc3/drivers/misc/mxs_ocotp.c u-boot/drivers/misc/mxs_ocotp.c
--- u-boot-2015.01-rc3/drivers/misc/mxs_ocotp.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/misc/mxs_ocotp.c	2015-01-01 17:34:32.649496760 +0100
@@ -187,6 +187,8 @@
 	uint32_t hclk_val, vddio_val;
 	int ret;
 
+	mxs_ocotp_clear_error();
+
 	/* Make sure the banks are closed for reading. */
 	ret = mxs_ocotp_read_bank_open(0);
 	if (ret) {
@@ -221,13 +223,17 @@
 		goto fail;
 	}
 
+	/* Check for errors */
+	if (readl(&ocotp_regs->hw_ocotp_ctrl) & OCOTP_CTRL_ERROR) {
+		puts("Failed writing fuses!\n");
+		ret = -EPERM;
+		goto fail;
+	}
+
 fail:
 	mxs_ocotp_scale_vddio(0, &vddio_val);
-	ret = mxs_ocotp_scale_hclk(0, &hclk_val);
-	if (ret) {
+	if (mxs_ocotp_scale_hclk(0, &hclk_val))
 		puts("Failed scaling up the HCLK!\n");
-		return ret;
-	}
 
 	return ret;
 }
diff -ruN u-boot-2015.01-rc3/drivers/misc/smsc_lpc47m.c u-boot/drivers/misc/smsc_lpc47m.c
--- u-boot-2015.01-rc3/drivers/misc/smsc_lpc47m.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/misc/smsc_lpc47m.c	2015-01-01 17:34:32.649496760 +0100
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/pnp_def.h>
+
+static void pnp_enter_conf_state(u16 dev)
+{
+	u16 port = dev >> 8;
+
+	outb(0x55, port);
+}
+
+static void pnp_exit_conf_state(u16 dev)
+{
+	u16 port = dev >> 8;
+
+	outb(0xaa, port);
+}
+
+void lpc47m_enable_serial(u16 dev, u16 iobase)
+{
+	pnp_enter_conf_state(dev);
+	pnp_set_logical_device(dev);
+	pnp_set_enable(dev, 0);
+	pnp_set_iobase(dev, PNP_IDX_IO0, iobase);
+	pnp_set_enable(dev, 1);
+	pnp_exit_conf_state(dev);
+}
diff -ruN u-boot-2015.01-rc3/drivers/mmc/dw_mmc.c u-boot/drivers/mmc/dw_mmc.c
--- u-boot-2015.01-rc3/drivers/mmc/dw_mmc.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/mmc/dw_mmc.c	2015-01-01 17:34:32.653496694 +0100
@@ -318,7 +318,7 @@
 	dwmci_writel(host, DWMCI_CTYPE, ctype);
 
 	regs = dwmci_readl(host, DWMCI_UHS_REG);
-	if (mmc->card_caps & MMC_MODE_DDR_52MHz)
+	if (mmc->ddr_mode)
 		regs |= DWMCI_DDR_MODE;
 	else
 		regs &= DWMCI_DDR_MODE;
diff -ruN u-boot-2015.01-rc3/drivers/mmc/exynos_dw_mmc.c u-boot/drivers/mmc/exynos_dw_mmc.c
--- u-boot-2015.01-rc3/drivers/mmc/exynos_dw_mmc.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/mmc/exynos_dw_mmc.c	2015-01-01 17:34:32.653496694 +0100
@@ -101,7 +101,7 @@
 	host->get_mmc_clk = exynos_dwmci_get_clk;
 	/* Add the mmc channel to be registered with mmc core */
 	if (add_dwmci(host, DWMMC_MAX_FREQ, DWMMC_MIN_FREQ)) {
-		debug("dwmmc%d registration failed\n", index);
+		printf("DWMMC%d registration failed\n", index);
 		return -1;
 	}
 	return 0;
@@ -146,7 +146,7 @@
 	flag = host->buswidth == 8 ? PINMUX_FLAG_8BIT_MODE : PINMUX_FLAG_NONE;
 	err = exynos_pinmux_config(host->dev_id, flag);
 	if (err) {
-		debug("DWMMC not configure\n");
+		printf("DWMMC%d not configure\n", index);
 		return err;
 	}
 
@@ -162,21 +162,22 @@
 	/* Extract device id for each mmc channel */
 	host->dev_id = pinmux_decode_periph_id(blob, node);
 
+	host->dev_index = fdtdec_get_int(blob, node, "index", host->dev_id);
+	if (host->dev_index == host->dev_id)
+		host->dev_index = host->dev_id - PERIPH_ID_SDMMC0;
+
+
 	/* Get the bus width from the device node */
 	host->buswidth = fdtdec_get_int(blob, node, "samsung,bus-width", 0);
 	if (host->buswidth <= 0) {
-		debug("DWMMC: Can't get bus-width\n");
+		printf("DWMMC%d: Can't get bus-width\n", host->dev_index);
 		return -EINVAL;
 	}
 
-	host->dev_index = fdtdec_get_int(blob, node, "index", host->dev_id);
-	if (host->dev_index == host->dev_id)
-		host->dev_index = host->dev_id - PERIPH_ID_SDMMC0;
-
 	/* Set the base address from the device node */
 	base = fdtdec_get_addr(blob, node, "reg");
 	if (!base) {
-		debug("DWMMC: Can't get base address\n");
+		printf("DWMMC%d: Can't get base address\n", host->dev_index);
 		return -EINVAL;
 	}
 	host->ioaddr = (void *)base;
@@ -184,7 +185,8 @@
 	/* Extract the timing info from the node */
 	err =  fdtdec_get_int_array(blob, node, "samsung,timing", timing, 3);
 	if (err) {
-		debug("Can't get sdr-timings for devider\n");
+		printf("DWMMC%d: Can't get sdr-timings for devider\n",
+				host->dev_index);
 		return -EINVAL;
 	}
 
@@ -214,7 +216,7 @@
 		host = &dwmci_host[i];
 		err = exynos_dwmci_get_config(blob, node, host);
 		if (err) {
-			debug("%s: failed to decode dev %d\n", __func__, i);
+			printf("%s: failed to decode dev %d\n", __func__, i);
 			return err;
 		}
 
diff -ruN u-boot-2015.01-rc3/drivers/mmc/mmc.c u-boot/drivers/mmc/mmc.c
--- u-boot-2015.01-rc3/drivers/mmc/mmc.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/mmc/mmc.c	2015-01-01 17:34:32.653496694 +0100
@@ -159,7 +159,7 @@
 {
 	struct mmc_cmd cmd;
 
-	if (mmc->card_caps & MMC_MODE_DDR_52MHz)
+	if (mmc->ddr_mode)
 		return 0;
 
 	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
@@ -486,7 +486,7 @@
 	char cardtype;
 	int err;
 
-	mmc->card_caps = 0;
+	mmc->card_caps = MMC_MODE_4BIT | MMC_MODE_8BIT;
 
 	if (mmc_host_is_spi(mmc))
 		return 0;
@@ -519,7 +519,7 @@
 
 	/* High Speed is set, there are two types: 52MHz and 26MHz */
 	if (cardtype & EXT_CSD_CARD_TYPE_52) {
-		if (cardtype & EXT_CSD_CARD_TYPE_DDR_52)
+		if (cardtype & EXT_CSD_CARD_TYPE_DDR_1_8V)
 			mmc->card_caps |= MMC_MODE_DDR_52MHz;
 		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
 	} else {
@@ -1001,6 +1001,9 @@
 		case 6:
 			mmc->version = MMC_VERSION_4_5;
 			break;
+		case 7:
+			mmc->version = MMC_VERSION_5_0;
+			break;
 		}
 
 		/*
@@ -1022,6 +1025,21 @@
 			mmc->erase_grp_size =
 				ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] *
 					MMC_MAX_BLOCK_LEN * 1024;
+			/*
+			 * if high capacity and partition setting completed
+			 * SEC_COUNT is valid even if it is smaller than 2 GiB
+			 * JEDEC Standard JESD84-B45, 6.2.4
+			 */
+			if (mmc->high_capacity &&
+			    (ext_csd[EXT_CSD_PARTITION_SETTING] &
+			     EXT_CSD_PARTITION_SETTING_COMPLETED)) {
+				capacity = (ext_csd[EXT_CSD_SEC_CNT]) |
+					(ext_csd[EXT_CSD_SEC_CNT + 1] << 8) |
+					(ext_csd[EXT_CSD_SEC_CNT + 2] << 16) |
+					(ext_csd[EXT_CSD_SEC_CNT + 3] << 24);
+				capacity *= MMC_MAX_BLOCK_LEN;
+				mmc->capacity_user = capacity;
+			}
 		} else {
 			/* Calculate the group size from the csd value. */
 			int erase_gsz, erase_gmul;
@@ -1103,8 +1121,10 @@
 
 		/* An array to map CSD bus widths to host cap bits */
 		static unsigned ext_to_hostcaps[] = {
-			[EXT_CSD_DDR_BUS_WIDTH_4] = MMC_MODE_DDR_52MHz,
-			[EXT_CSD_DDR_BUS_WIDTH_8] = MMC_MODE_DDR_52MHz,
+			[EXT_CSD_DDR_BUS_WIDTH_4] =
+				MMC_MODE_DDR_52MHz | MMC_MODE_4BIT,
+			[EXT_CSD_DDR_BUS_WIDTH_8] =
+				MMC_MODE_DDR_52MHz | MMC_MODE_8BIT,
 			[EXT_CSD_BUS_WIDTH_4] = MMC_MODE_4BIT,
 			[EXT_CSD_BUS_WIDTH_8] = MMC_MODE_8BIT,
 		};
@@ -1116,13 +1136,13 @@
 
 		for (idx=0; idx < ARRAY_SIZE(ext_csd_bits); idx++) {
 			unsigned int extw = ext_csd_bits[idx];
+			unsigned int caps = ext_to_hostcaps[extw];
 
 			/*
-			 * Check to make sure the controller supports
-			 * this bus width, if it's more than 1
+			 * Check to make sure the card and controller support
+			 * these capabilities
 			 */
-			if (extw != EXT_CSD_BUS_WIDTH_1 &&
-					!(mmc->cfg->host_caps & ext_to_hostcaps[extw]))
+			if ((mmc->card_caps & caps) != caps)
 				continue;
 
 			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
@@ -1131,26 +1151,33 @@
 			if (err)
 				continue;
 
+			mmc->ddr_mode = (caps & MMC_MODE_DDR_52MHz) ? 1 : 0;
 			mmc_set_bus_width(mmc, widths[idx]);
 
 			err = mmc_send_ext_csd(mmc, test_csd);
-			/* Only compare read only fields */
-			if (!err && ext_csd[EXT_CSD_PARTITIONING_SUPPORT] \
-				    == test_csd[EXT_CSD_PARTITIONING_SUPPORT]
-				 && ext_csd[EXT_CSD_HC_WP_GRP_SIZE] \
-				    == test_csd[EXT_CSD_HC_WP_GRP_SIZE] \
-				 && ext_csd[EXT_CSD_REV] \
-				    == test_csd[EXT_CSD_REV]
-				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
-				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
-				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
-					&test_csd[EXT_CSD_SEC_CNT], 4) == 0) {
 
-				mmc->card_caps |= ext_to_hostcaps[extw];
+			if (err)
+				continue;
+
+			/* Only compare read only fields */
+			if (ext_csd[EXT_CSD_PARTITIONING_SUPPORT]
+				== test_csd[EXT_CSD_PARTITIONING_SUPPORT] &&
+			    ext_csd[EXT_CSD_HC_WP_GRP_SIZE]
+				== test_csd[EXT_CSD_HC_WP_GRP_SIZE] &&
+			    ext_csd[EXT_CSD_REV]
+				== test_csd[EXT_CSD_REV] &&
+			    ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
+				== test_csd[EXT_CSD_HC_ERASE_GRP_SIZE] &&
+			    memcmp(&ext_csd[EXT_CSD_SEC_CNT],
+				   &test_csd[EXT_CSD_SEC_CNT], 4) == 0)
 				break;
-			}
+			else
+				err = SWITCH_ERR;
 		}
 
+		if (err)
+			return err;
+
 		if (mmc->card_caps & MMC_MODE_HS) {
 			if (mmc->card_caps & MMC_MODE_HS_52MHz)
 				mmc->tran_speed = 52000000;
@@ -1161,6 +1188,12 @@
 
 	mmc_set_clock(mmc, mmc->tran_speed);
 
+	/* Fix the block length for DDR mode */
+	if (mmc->ddr_mode) {
+		mmc->read_bl_len = MMC_MAX_BLOCK_LEN;
+		mmc->write_bl_len = MMC_MAX_BLOCK_LEN;
+	}
+
 	/* fill in device description */
 	mmc->block_dev.lun = 0;
 	mmc->block_dev.type = 0;
@@ -1306,6 +1339,7 @@
 	if (err)
 		return err;
 
+	mmc->ddr_mode = 0;
 	mmc_set_bus_width(mmc, 1);
 	mmc_set_clock(mmc, 1);
 
@@ -1408,8 +1442,11 @@
 
 		printf("%s: %d", m->cfg->name, m->block_dev.dev);
 
-		if (entry->next != &mmc_devices)
-			printf("%c ", separator);
+		if (entry->next != &mmc_devices) {
+			printf("%c", separator);
+			if (separator != '\n')
+				puts (" ");
+		}
 	}
 
 	printf("\n");
diff -ruN u-boot-2015.01-rc3/drivers/mtd/nand/fsl_ifc_nand.c u-boot/drivers/mtd/nand/fsl_ifc_nand.c
--- u-boot-2015.01-rc3/drivers/mtd/nand/fsl_ifc_nand.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/mtd/nand/fsl_ifc_nand.c	2015-01-01 17:34:32.657496629 +0100
@@ -292,7 +292,7 @@
 	struct fsl_ifc *ifc = ctrl->regs;
 	u32 timeo = (CONFIG_SYS_HZ * 10) / 1000;
 	u32 time_start;
-	u32 eccstat[4];
+	u32 eccstat[4] = {0};
 	int i;
 
 	/* set the chip select for NAND Transaction */
diff -ruN u-boot-2015.01-rc3/drivers/mtd/nand/fsl_ifc_spl.c u-boot/drivers/mtd/nand/fsl_ifc_spl.c
--- u-boot-2015.01-rc3/drivers/mtd/nand/fsl_ifc_spl.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/mtd/nand/fsl_ifc_spl.c	2015-01-01 17:34:32.657496629 +0100
@@ -254,3 +254,13 @@
 	uboot = (void *)CONFIG_SYS_NAND_U_BOOT_START;
 	uboot();
 }
+
+#ifndef CONFIG_SPL_NAND_INIT
+void nand_init(void)
+{
+}
+
+void nand_deselect(void)
+{
+}
+#endif
diff -ruN u-boot-2015.01-rc3/drivers/mtd/spi/sf_internal.h u-boot/drivers/mtd/spi/sf_internal.h
--- u-boot-2015.01-rc3/drivers/mtd/spi/sf_internal.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/mtd/spi/sf_internal.h	2015-01-01 17:34:32.665496498 +0100
@@ -23,13 +23,16 @@
 /* Enum list - Full read commands */
 enum spi_read_cmds {
 	ARRAY_SLOW		= 1 << 0,
-	DUAL_OUTPUT_FAST	= 1 << 1,
-	DUAL_IO_FAST		= 1 << 2,
-	QUAD_OUTPUT_FAST	= 1 << 3,
-	QUAD_IO_FAST		= 1 << 4,
+	ARRAY_FAST		= 1 << 1,
+	DUAL_OUTPUT_FAST	= 1 << 2,
+	DUAL_IO_FAST		= 1 << 3,
+	QUAD_OUTPUT_FAST	= 1 << 4,
+	QUAD_IO_FAST		= 1 << 5,
 };
 
-#define RD_EXTN	(ARRAY_SLOW | DUAL_OUTPUT_FAST | DUAL_IO_FAST)
+/* Normal - Extended - Full command set */
+#define RD_NORM	(ARRAY_SLOW | ARRAY_FAST)
+#define RD_EXTN	(RD_NORM | DUAL_OUTPUT_FAST | DUAL_IO_FAST)
 #define RD_FULL	(RD_EXTN | QUAD_OUTPUT_FAST | QUAD_IO_FAST)
 
 /* sf param flags */
@@ -37,9 +40,13 @@
 	SECT_4K		= 1 << 0,
 	SECT_32K	= 1 << 1,
 	E_FSR		= 1 << 2,
-	WR_QPP		= 1 << 3,
+	SST_BP		= 1 << 3,
+	SST_WP		= 1 << 4,
+	WR_QPP		= 1 << 5,
 };
 
+#define SST_WR		(SST_BP | SST_WP)
+
 #define SPI_FLASH_3B_ADDR_LEN		3
 #define SPI_FLASH_CMD_LEN		(1 + SPI_FLASH_3B_ADDR_LEN)
 #define SPI_FLASH_16MB_BOUN		0x1000000
@@ -101,12 +108,13 @@
 
 /* SST specific */
 #ifdef CONFIG_SPI_FLASH_SST
-# define SST_WP		0x01	/* Supports AAI word program */
 # define CMD_SST_BP		0x02    /* Byte Program */
 # define CMD_SST_AAI_WP	0xAD	/* Auto Address Incr Word Program */
 
 int sst_write_wp(struct spi_flash *flash, u32 offset, size_t len,
 		const void *buf);
+int sst_write_bp(struct spi_flash *flash, u32 offset, size_t len,
+		const void *buf);
 #endif
 
 /**
diff -ruN u-boot-2015.01-rc3/drivers/mtd/spi/sf_ops.c u-boot/drivers/mtd/spi/sf_ops.c
--- u-boot-2015.01-rc3/drivers/mtd/spi/sf_ops.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/mtd/spi/sf_ops.c	2015-01-01 17:34:32.665496498 +0100
@@ -517,4 +517,35 @@
 	spi_release_bus(flash->spi);
 	return ret;
 }
+
+int sst_write_bp(struct spi_flash *flash, u32 offset, size_t len,
+		const void *buf)
+{
+	size_t actual;
+	int ret;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: Unable to claim SPI bus\n");
+		return ret;
+	}
+
+	for (actual = 0; actual < len; actual++) {
+		ret = sst_byte_write(flash, offset, buf + actual);
+		if (ret) {
+			debug("SF: sst byte program failed\n");
+			break;
+		}
+		offset++;
+	}
+
+	if (!ret)
+		ret = spi_flash_cmd_write_disable(flash);
+
+	debug("SF: sst: program %s %zu bytes @ 0x%zx\n",
+	      ret ? "failure" : "success", len, offset - actual);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
 #endif
diff -ruN u-boot-2015.01-rc3/drivers/mtd/spi/sf_params.c u-boot/drivers/mtd/spi/sf_params.c
--- u-boot-2015.01-rc3/drivers/mtd/spi/sf_params.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/mtd/spi/sf_params.c	2015-01-01 17:34:32.665496498 +0100
@@ -15,42 +15,42 @@
 /* SPI/QSPI flash device params structure */
 const struct spi_flash_params spi_flash_params_table[] = {
 #ifdef CONFIG_SPI_FLASH_ATMEL		/* ATMEL */
-	{"AT45DB011D",	   0x1f2200, 0x0,	64 * 1024,     4,	0,		    SECT_4K},
-	{"AT45DB021D",	   0x1f2300, 0x0,	64 * 1024,     8,	0,		    SECT_4K},
-	{"AT45DB041D",	   0x1f2400, 0x0,	64 * 1024,     8,	0,		    SECT_4K},
-	{"AT45DB081D",	   0x1f2500, 0x0,	64 * 1024,    16,	0,		    SECT_4K},
-	{"AT45DB161D",	   0x1f2600, 0x0,	64 * 1024,    32,	0,		    SECT_4K},
-	{"AT45DB321D",	   0x1f2700, 0x0,	64 * 1024,    64,	0,		    SECT_4K},
-	{"AT45DB641D",	   0x1f2800, 0x0,	64 * 1024,   128,	0,		    SECT_4K},
-	{"AT25DF321",      0x1f4701, 0x0,	64 * 1024,    64,	0,		    SECT_4K},
+	{"AT45DB011D",	   0x1f2200, 0x0,	64 * 1024,     4, RD_NORM,		    SECT_4K},
+	{"AT45DB021D",	   0x1f2300, 0x0,	64 * 1024,     8, RD_NORM,		    SECT_4K},
+	{"AT45DB041D",	   0x1f2400, 0x0,	64 * 1024,     8, RD_NORM,		    SECT_4K},
+	{"AT45DB081D",	   0x1f2500, 0x0,	64 * 1024,    16, RD_NORM,		    SECT_4K},
+	{"AT45DB161D",	   0x1f2600, 0x0,	64 * 1024,    32, RD_NORM,		    SECT_4K},
+	{"AT45DB321D",	   0x1f2700, 0x0,	64 * 1024,    64, RD_NORM,		    SECT_4K},
+	{"AT45DB641D",	   0x1f2800, 0x0,	64 * 1024,   128, RD_NORM,		    SECT_4K},
+	{"AT25DF321",      0x1f4701, 0x0,	64 * 1024,    64, RD_NORM,		    SECT_4K},
 #endif
 #ifdef CONFIG_SPI_FLASH_EON		/* EON */
-	{"EN25Q32B",	   0x1c3016, 0x0,	64 * 1024,    64,	0,			  0},
-	{"EN25Q64",	   0x1c3017, 0x0,	64 * 1024,   128,	0,		    SECT_4K},
-	{"EN25Q128B",	   0x1c3018, 0x0,       64 * 1024,   256,	0,			  0},
-	{"EN25S64",	   0x1c3817, 0x0,	64 * 1024,   128,	0,			  0},
+	{"EN25Q32B",	   0x1c3016, 0x0,	64 * 1024,    64, RD_NORM,			  0},
+	{"EN25Q64",	   0x1c3017, 0x0,	64 * 1024,   128, RD_NORM,		    SECT_4K},
+	{"EN25Q128B",	   0x1c3018, 0x0,       64 * 1024,   256, RD_NORM,			  0},
+	{"EN25S64",	   0x1c3817, 0x0,	64 * 1024,   128, RD_NORM,			  0},
 #endif
 #ifdef CONFIG_SPI_FLASH_GIGADEVICE	/* GIGADEVICE */
-	{"GD25Q64B",	   0xc84017, 0x0,	64 * 1024,   128,	0,		    SECT_4K},
-	{"GD25LQ32",	   0xc86016, 0x0,	64 * 1024,    64,	0,		    SECT_4K},
+	{"GD25Q64B",	   0xc84017, 0x0,	64 * 1024,   128, RD_NORM,		    SECT_4K},
+	{"GD25LQ32",	   0xc86016, 0x0,	64 * 1024,    64, RD_NORM,		    SECT_4K},
 #endif
 #ifdef CONFIG_SPI_FLASH_MACRONIX	/* MACRONIX */
-	{"MX25L2006E",	   0xc22012, 0x0,	64 * 1024,     4,	0,			  0},
-	{"MX25L4005",	   0xc22013, 0x0,	64 * 1024,     8,	0,			  0},
-	{"MX25L8005",	   0xc22014, 0x0,	64 * 1024,    16,	0,			  0},
-	{"MX25L1605D",	   0xc22015, 0x0,	64 * 1024,    32,	0,			  0},
-	{"MX25L3205D",	   0xc22016, 0x0,	64 * 1024,    64,	0,			  0},
-	{"MX25L6405D",	   0xc22017, 0x0,	64 * 1024,   128,	0,			  0},
+	{"MX25L2006E",	   0xc22012, 0x0,	64 * 1024,     4, RD_NORM,			  0},
+	{"MX25L4005",	   0xc22013, 0x0,	64 * 1024,     8, RD_NORM,			  0},
+	{"MX25L8005",	   0xc22014, 0x0,	64 * 1024,    16, RD_NORM,			  0},
+	{"MX25L1605D",	   0xc22015, 0x0,	64 * 1024,    32, RD_NORM,			  0},
+	{"MX25L3205D",	   0xc22016, 0x0,	64 * 1024,    64, RD_NORM,			  0},
+	{"MX25L6405D",	   0xc22017, 0x0,	64 * 1024,   128, RD_NORM,			  0},
 	{"MX25L12805",	   0xc22018, 0x0,	64 * 1024,   256, RD_FULL,		     WR_QPP},
 	{"MX25L25635F",	   0xc22019, 0x0,	64 * 1024,   512, RD_FULL,		     WR_QPP},
 	{"MX25L51235F",	   0xc2201a, 0x0,	64 * 1024,  1024, RD_FULL,		     WR_QPP},
 	{"MX25L12855E",	   0xc22618, 0x0,	64 * 1024,   256, RD_FULL,		     WR_QPP},
 #endif
 #ifdef CONFIG_SPI_FLASH_SPANSION	/* SPANSION */
-	{"S25FL008A",	   0x010213, 0x0,	64 * 1024,    16,	0,			  0},
-	{"S25FL016A",	   0x010214, 0x0,	64 * 1024,    32,	0,			  0},
-	{"S25FL032A",	   0x010215, 0x0,	64 * 1024,    64,	0,			  0},
-	{"S25FL064A",	   0x010216, 0x0,	64 * 1024,   128,	0,			  0},
+	{"S25FL008A",	   0x010213, 0x0,	64 * 1024,    16, RD_NORM,			  0},
+	{"S25FL016A",	   0x010214, 0x0,	64 * 1024,    32, RD_NORM,			  0},
+	{"S25FL032A",	   0x010215, 0x0,	64 * 1024,    64, RD_NORM,			  0},
+	{"S25FL064A",	   0x010216, 0x0,	64 * 1024,   128, RD_NORM,			  0},
 	{"S25FL128P_256K", 0x012018, 0x0300,   256 * 1024,    64, RD_FULL,		     WR_QPP},
 	{"S25FL128P_64K",  0x012018, 0x0301,    64 * 1024,   256, RD_FULL,		     WR_QPP},
 	{"S25FL032P",	   0x010215, 0x4d00,    64 * 1024,    64, RD_FULL,		     WR_QPP},
@@ -64,17 +64,17 @@
 	{"S25FL512S_512K", 0x010220, 0x4f00,   256 * 1024,   256, RD_FULL,		     WR_QPP},
 #endif
 #ifdef CONFIG_SPI_FLASH_STMICRO		/* STMICRO */
-	{"M25P10",	   0x202011, 0x0,	32 * 1024,     4,	0,			  0},
-	{"M25P20",	   0x202012, 0x0,       64 * 1024,     4,	0,			  0},
-	{"M25P40",	   0x202013, 0x0,       64 * 1024,     8,	0,			  0},
-	{"M25P80",	   0x202014, 0x0,       64 * 1024,    16,	0,			  0},
-	{"M25P16",	   0x202015, 0x0,       64 * 1024,    32,	0,			  0},
-	{"M25PE16",	   0x208015, 0x1000,    64 * 1024,    32,	0,			  0},
+	{"M25P10",	   0x202011, 0x0,	32 * 1024,     4, RD_NORM,			  0},
+	{"M25P20",	   0x202012, 0x0,       64 * 1024,     4, RD_NORM,			  0},
+	{"M25P40",	   0x202013, 0x0,       64 * 1024,     8, RD_NORM,			  0},
+	{"M25P80",	   0x202014, 0x0,       64 * 1024,    16, RD_NORM,			  0},
+	{"M25P16",	   0x202015, 0x0,       64 * 1024,    32, RD_NORM,			  0},
+	{"M25PE16",	   0x208015, 0x1000,    64 * 1024,    32, RD_NORM,			  0},
 	{"M25PX16",	   0x207115, 0x1000,    64 * 1024,    32, RD_EXTN,			  0},
-	{"M25P32",	   0x202016, 0x0,       64 * 1024,    64,	0,			  0},
-	{"M25P64",	   0x202017, 0x0,       64 * 1024,   128,	0,			  0},
-	{"M25P128",	   0x202018, 0x0,      256 * 1024,    64,	0,			  0},
-	{"M25PX64",	   0x207117, 0x0,       64 * 1024,   128,	0,		    SECT_4K},
+	{"M25P32",	   0x202016, 0x0,       64 * 1024,    64, RD_NORM,			  0},
+	{"M25P64",	   0x202017, 0x0,       64 * 1024,   128, RD_NORM,			  0},
+	{"M25P128",	   0x202018, 0x0,      256 * 1024,    64, RD_NORM,			  0},
+	{"M25PX64",	   0x207117, 0x0,       64 * 1024,   128, RD_NORM,		    SECT_4K},
 	{"N25Q32",	   0x20ba16, 0x0,       64 * 1024,    64, RD_FULL,	   WR_QPP | SECT_4K},
 	{"N25Q32A",	   0x20bb16, 0x0,       64 * 1024,    64, RD_FULL,	   WR_QPP | SECT_4K},
 	{"N25Q64",	   0x20ba17, 0x0,       64 * 1024,   128, RD_FULL,	   WR_QPP | SECT_4K},
@@ -89,25 +89,25 @@
 	{"N25Q1024A",	   0x20bb21, 0x0,       64 * 1024,  2048, RD_FULL, WR_QPP | E_FSR | SECT_4K},
 #endif
 #ifdef CONFIG_SPI_FLASH_SST		/* SST */
-	{"SST25VF040B",	   0xbf258d, 0x0,	64 * 1024,     8,	0,          SECT_4K | SST_WP},
-	{"SST25VF080B",	   0xbf258e, 0x0,	64 * 1024,    16,	0,	    SECT_4K | SST_WP},
-	{"SST25VF016B",	   0xbf2541, 0x0,	64 * 1024,    32,	0,	    SECT_4K | SST_WP},
-	{"SST25VF032B",	   0xbf254a, 0x0,	64 * 1024,    64,	0,	    SECT_4K | SST_WP},
-	{"SST25VF064C",	   0xbf254b, 0x0,	64 * 1024,   128,	0,		     SECT_4K},
-	{"SST25WF512",	   0xbf2501, 0x0,	64 * 1024,     1,	0,	    SECT_4K | SST_WP},
-	{"SST25WF010",	   0xbf2502, 0x0,	64 * 1024,     2,       0,          SECT_4K | SST_WP},
-	{"SST25WF020",	   0xbf2503, 0x0,	64 * 1024,     4,       0,	    SECT_4K | SST_WP},
-	{"SST25WF040",	   0xbf2504, 0x0,	64 * 1024,     8,       0,	    SECT_4K | SST_WP},
-	{"SST25WF080",	   0xbf2505, 0x0,	64 * 1024,    16,       0,	    SECT_4K | SST_WP},
+	{"SST25VF040B",	   0xbf258d, 0x0,	64 * 1024,     8, RD_NORM,          SECT_4K | SST_WR},
+	{"SST25VF080B",	   0xbf258e, 0x0,	64 * 1024,    16, RD_NORM,	    SECT_4K | SST_WR},
+	{"SST25VF016B",	   0xbf2541, 0x0,	64 * 1024,    32, RD_NORM,	    SECT_4K | SST_WR},
+	{"SST25VF032B",	   0xbf254a, 0x0,	64 * 1024,    64, RD_NORM,	    SECT_4K | SST_WR},
+	{"SST25VF064C",	   0xbf254b, 0x0,	64 * 1024,   128, RD_NORM,		     SECT_4K},
+	{"SST25WF512",	   0xbf2501, 0x0,	64 * 1024,     1, RD_NORM,	    SECT_4K | SST_WR},
+	{"SST25WF010",	   0xbf2502, 0x0,	64 * 1024,     2, RD_NORM,          SECT_4K | SST_WR},
+	{"SST25WF020",	   0xbf2503, 0x0,	64 * 1024,     4, RD_NORM,	    SECT_4K | SST_WR},
+	{"SST25WF040",	   0xbf2504, 0x0,	64 * 1024,     8, RD_NORM,	    SECT_4K | SST_WR},
+	{"SST25WF080",	   0xbf2505, 0x0,	64 * 1024,    16, RD_NORM,	    SECT_4K | SST_WR},
 #endif
 #ifdef CONFIG_SPI_FLASH_WINBOND		/* WINBOND */
-	{"W25P80",	   0xef2014, 0x0,	64 * 1024,    16,	0,		           0},
-	{"W25P16",	   0xef2015, 0x0,	64 * 1024,    32,	0,		           0},
-	{"W25P32",	   0xef2016, 0x0,	64 * 1024,    64,	0,		           0},
-	{"W25X40",	   0xef3013, 0x0,	64 * 1024,     8,	0,		     SECT_4K},
-	{"W25X16",	   0xef3015, 0x0,	64 * 1024,    32,	0,		     SECT_4K},
-	{"W25X32",	   0xef3016, 0x0,	64 * 1024,    64,	0,		     SECT_4K},
-	{"W25X64",	   0xef3017, 0x0,	64 * 1024,   128,	0,		     SECT_4K},
+	{"W25P80",	   0xef2014, 0x0,	64 * 1024,    16, RD_NORM,		           0},
+	{"W25P16",	   0xef2015, 0x0,	64 * 1024,    32, RD_NORM,		           0},
+	{"W25P32",	   0xef2016, 0x0,	64 * 1024,    64, RD_NORM,		           0},
+	{"W25X40",	   0xef3013, 0x0,	64 * 1024,     8, RD_NORM,		     SECT_4K},
+	{"W25X16",	   0xef3015, 0x0,	64 * 1024,    32, RD_NORM,		     SECT_4K},
+	{"W25X32",	   0xef3016, 0x0,	64 * 1024,    64, RD_NORM,		     SECT_4K},
+	{"W25X64",	   0xef3017, 0x0,	64 * 1024,   128, RD_NORM,		     SECT_4K},
 	{"W25Q80BL",	   0xef4014, 0x0,	64 * 1024,    16, RD_FULL,	    WR_QPP | SECT_4K},
 	{"W25Q16CL",	   0xef4015, 0x0,	64 * 1024,    32, RD_FULL,	    WR_QPP | SECT_4K},
 	{"W25Q32BV",	   0xef4016, 0x0,	64 * 1024,    64, RD_FULL,	    WR_QPP | SECT_4K},
diff -ruN u-boot-2015.01-rc3/drivers/mtd/spi/sf_probe.c u-boot/drivers/mtd/spi/sf_probe.c
--- u-boot-2015.01-rc3/drivers/mtd/spi/sf_probe.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/mtd/spi/sf_probe.c	2015-01-01 17:34:32.665496498 +0100
@@ -24,6 +24,7 @@
 /* Read commands array */
 static u8 spi_read_cmds_array[] = {
 	CMD_READ_ARRAY_SLOW,
+	CMD_READ_ARRAY_FAST,
 	CMD_READ_DUAL_OUTPUT_FAST,
 	CMD_READ_DUAL_IO_FAST,
 	CMD_READ_QUAD_OUTPUT_FAST,
@@ -135,8 +136,12 @@
 #ifndef CONFIG_DM_SPI_FLASH
 	flash->write = spi_flash_cmd_write_ops;
 #if defined(CONFIG_SPI_FLASH_SST)
-	if (params->flags & SST_WP)
-		flash->write = sst_write_wp;
+	if (params->flags & SST_WR) {
+		if (flash->spi->op_mode_tx & SPI_OPM_TX_BP)
+			flash->write = sst_write_bp;
+		else
+			flash->write = sst_write_wp;
+	}
 #endif
 	flash->erase = spi_flash_cmd_erase_ops;
 	flash->read = spi_flash_cmd_read_ops;
diff -ruN u-boot-2015.01-rc3/drivers/net/fm/init.c u-boot/drivers/net/fm/init.c
--- u-boot-2015.01-rc3/drivers/net/fm/init.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/net/fm/init.c	2015-01-01 17:34:32.677496300 +0100
@@ -247,17 +247,17 @@
 	}
 
 #ifdef CONFIG_SYS_FMAN_V3
+#ifndef CONFIG_FSL_FM_10GEC_REGULAR_NOTATION
 	/*
-	 * Physically FM1_DTSEC9 and FM1_10GEC1 use the same dual-role MAC, when
-	 * FM1_10GEC1 is enabled and  FM1_DTSEC9 is disabled, ensure that the
-	 * dual-role MAC is not disabled, ditto for other dual-role MACs.
+	 * On T2/T4 SoCs, physically FM1_DTSEC9 and FM1_10GEC1 use the same
+	 * dual-role MAC, when FM1_10GEC1 is enabled and  FM1_DTSEC9
+	 * is disabled, ensure that the dual-role MAC is not disabled,
+	 * ditto for other dual-role MACs.
 	 */
 	if (((info->port == FM1_DTSEC9) && (PORT_IS_ENABLED(FM1_10GEC1)))  ||
 	    ((info->port == FM1_DTSEC10) && (PORT_IS_ENABLED(FM1_10GEC2))) ||
-	    ((info->port == FM1_DTSEC1) && (PORT_IS_ENABLED(FM1_10GEC1)))  ||
 	    ((info->port == FM1_DTSEC1) && (PORT_IS_ENABLED(FM1_10GEC3)))  ||
 	    ((info->port == FM1_DTSEC2) && (PORT_IS_ENABLED(FM1_10GEC4)))  ||
-	    ((info->port == FM1_10GEC1) && (PORT_IS_ENABLED(FM1_DTSEC1)))  ||
 	    ((info->port == FM1_10GEC1) && (PORT_IS_ENABLED(FM1_DTSEC9)))  ||
 	    ((info->port == FM1_10GEC2) && (PORT_IS_ENABLED(FM1_DTSEC10))) ||
 	    ((info->port == FM1_10GEC3) && (PORT_IS_ENABLED(FM1_DTSEC1)))  ||
@@ -269,6 +269,17 @@
 	    ((info->port == FM2_10GEC1) && (PORT_IS_ENABLED(FM2_DTSEC9)))	||
 	    ((info->port == FM2_10GEC2) && (PORT_IS_ENABLED(FM2_DTSEC10)))
 #endif
+#else
+	/* FM1_DTSECx and FM1_10GECx use the same dual-role MAC */
+	if (((info->port == FM1_DTSEC1) && (PORT_IS_ENABLED(FM1_10GEC1)))  ||
+	    ((info->port == FM1_DTSEC2) && (PORT_IS_ENABLED(FM1_10GEC2)))  ||
+	    ((info->port == FM1_DTSEC3) && (PORT_IS_ENABLED(FM1_10GEC3)))  ||
+	    ((info->port == FM1_DTSEC4) && (PORT_IS_ENABLED(FM1_10GEC4)))  ||
+	    ((info->port == FM1_10GEC1) && (PORT_IS_ENABLED(FM1_DTSEC1)))  ||
+	    ((info->port == FM1_10GEC2) && (PORT_IS_ENABLED(FM1_DTSEC2)))  ||
+	    ((info->port == FM1_10GEC3) && (PORT_IS_ENABLED(FM1_DTSEC3)))  ||
+	    ((info->port == FM1_10GEC4) && (PORT_IS_ENABLED(FM1_DTSEC4)))
+#endif
 	)
 		return;
 #endif
diff -ruN u-boot-2015.01-rc3/drivers/pci/Makefile u-boot/drivers/pci/Makefile
--- u-boot-2015.01-rc3/drivers/pci/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/pci/Makefile	2015-01-01 17:34:32.685496170 +0100
@@ -17,3 +17,4 @@
 obj-$(CONFIG_SH7780_PCI) +=pci_sh7780.o
 obj-$(CONFIG_TSI108_PCI) += tsi108_pci.o
 obj-$(CONFIG_WINBOND_83C553) += w83c553f.o
+obj-$(CONFIG_PCIE_LAYERSCAPE) += pcie_layerscape.o
diff -ruN u-boot-2015.01-rc3/drivers/pci/pcie_layerscape.c u-boot/drivers/pci/pcie_layerscape.c
--- u-boot-2015.01-rc3/drivers/pci/pcie_layerscape.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/pci/pcie_layerscape.c	2015-01-01 17:34:32.689496104 +0100
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Layerscape PCIe driver
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/fsl_serdes.h>
+#include <pci.h>
+#include <asm/io.h>
+#include <asm/pcie_layerscape.h>
+
+#ifdef CONFIG_OF_BOARD_SETUP
+#include <libfdt.h>
+#include <fdt_support.h>
+
+static void ft_pcie_ls_setup(void *blob, const char *pci_compat,
+			     unsigned long ctrl_addr, enum srds_prtcl dev)
+{
+	int off;
+
+	off = fdt_node_offset_by_compat_reg(blob, pci_compat,
+					    (phys_addr_t)ctrl_addr);
+	if (off < 0)
+		return;
+
+	if (!is_serdes_configured(dev))
+		fdt_set_node_status(blob, off, FDT_STATUS_DISABLED, 0);
+}
+
+void ft_pcie_setup(void *blob, bd_t *bd)
+{
+	#ifdef CONFIG_PCIE1
+	ft_pcie_ls_setup(blob, FSL_PCIE_COMPAT, CONFIG_SYS_PCIE1_ADDR, PCIE1);
+	#endif
+
+	#ifdef CONFIG_PCIE2
+	ft_pcie_ls_setup(blob, FSL_PCIE_COMPAT, CONFIG_SYS_PCIE2_ADDR, PCIE2);
+	#endif
+}
+
+#else
+void ft_pcie_setup(void *blob, bd_t *bd)
+{
+}
+#endif
+
+void pci_init_board(void)
+{
+}
diff -ruN u-boot-2015.01-rc3/drivers/power/tps6586x.c u-boot/drivers/power/tps6586x.c
--- u-boot-2015.01-rc3/drivers/power/tps6586x.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/power/tps6586x.c	2015-01-01 17:34:32.693496038 +0100
@@ -10,9 +10,7 @@
 #include <asm/io.h>
 #include <i2c.h>
 
-static int bus_num;		/* I2C bus we are on */
-#define I2C_ADDRESS		0x34	/* chip requires this address */
-static char inited;		/* 1 if we have been inited */
+static struct udevice *tps6586x_dev;
 
 enum {
 	/* Registers that we access */
@@ -37,13 +35,9 @@
 	int	i;
 	uchar	data;
 	int	retval = -1;
-	int	old_bus_num;
-
-	old_bus_num = i2c_get_bus_num();
-	i2c_set_bus_num(bus_num);
 
 	for (i = 0; i < MAX_I2C_RETRY; ++i) {
-		if (!i2c_read(I2C_ADDRESS, reg, 1, &data, 1)) {
+		if (!i2c_read(tps6586x_dev, reg,  &data, 1)) {
 			retval = (int)data;
 			goto exit;
 		}
@@ -53,7 +47,6 @@
 	}
 
 exit:
-	i2c_set_bus_num(old_bus_num);
 	debug("pmu_read %x=%x\n", reg, retval);
 	if (retval < 0)
 		debug("%s: failed to read register %#x: %d\n", __func__, reg,
@@ -65,13 +58,9 @@
 {
 	int	i;
 	int	retval = -1;
-	int	old_bus_num;
-
-	old_bus_num = i2c_get_bus_num();
-	i2c_set_bus_num(bus_num);
 
 	for (i = 0; i < MAX_I2C_RETRY; ++i) {
-		if (!i2c_write(I2C_ADDRESS, reg, 1, data, len)) {
+		if (!i2c_write(tps6586x_dev, reg, data, len)) {
 			retval = 0;
 			goto exit;
 		}
@@ -81,7 +70,6 @@
 	}
 
 exit:
-	i2c_set_bus_num(old_bus_num);
 	debug("pmu_write %x=%x: ", reg, retval);
 	for (i = 0; i < len; i++)
 		debug("%x ", data[i]);
@@ -163,7 +151,7 @@
 	uchar val;
 	int ret;
 
-	assert(inited);
+	assert(tps6586x_dev);
 	ret = tps6586x_read(PFM_MODE);
 	if (ret != -1) {
 		val = (uchar)ret;
@@ -184,7 +172,7 @@
 	int sm0, sm1;
 	int bad;
 
-	assert(inited);
+	assert(tps6586x_dev);
 
 	/* get current voltage settings */
 	if (read_voltages(&sm0, &sm1)) {
@@ -255,10 +243,9 @@
 	return bad ? -1 : 0;
 }
 
-int tps6586x_init(int bus)
+int tps6586x_init(struct udevice *dev)
 {
-	bus_num = bus;
-	inited = 1;
+	tps6586x_dev = dev;
 
 	return 0;
 }
diff -ruN u-boot-2015.01-rc3/drivers/qe/qe.c u-boot/drivers/qe/qe.c
--- u-boot-2015.01-rc3/drivers/qe/qe.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/qe/qe.c	2015-01-01 17:34:32.693496038 +0100
@@ -13,6 +13,9 @@
 #include "asm/io.h"
 #include "linux/immap_qe.h"
 #include "qe.h"
+#ifdef CONFIG_LS102XA
+#include <asm/arch/immap_ls102xa.h>
+#endif
 
 #define MPC85xx_DEVDISR_QE_DISABLE	0x1
 
@@ -335,8 +338,12 @@
 	size_t length;
 	const struct qe_header *hdr;
 #ifdef CONFIG_DEEP_SLEEP
+#ifdef CONFIG_LS102XA
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+#else
 	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
 #endif
+#endif
 	if (!firmware) {
 		printf("Invalid address\n");
 		return -EINVAL;
@@ -470,8 +477,12 @@
 	size_t length;
 	const struct qe_header *hdr;
 #ifdef CONFIG_DEEP_SLEEP
+#ifdef CONFIG_LS102XA
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+#else
 	ccsr_gur_t __iomem *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
 #endif
+#endif
 	if (!firmware) {
 		printf("Invalid address\n");
 		return -EINVAL;
diff -ruN u-boot-2015.01-rc3/drivers/serial/Makefile u-boot/drivers/serial/Makefile
--- u-boot-2015.01-rc3/drivers/serial/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/serial/Makefile	2015-01-01 17:34:32.697495972 +0100
@@ -43,7 +43,7 @@
 obj-$(CONFIG_TEGRA_SERIAL) += serial_tegra.o
 obj-$(CONFIG_UNIPHIER_SERIAL) += serial_uniphier.o
 obj-$(CONFIG_OMAP_SERIAL) += serial_omap.o
-obj-$(CONFIG_COREBOOT_SERIAL) += serial_coreboot.o
+obj-$(CONFIG_X86_SERIAL) += serial_x86.o
 
 ifndef CONFIG_SPL_BUILD
 obj-$(CONFIG_USB_TTY) += usbtty.o
diff -ruN u-boot-2015.01-rc3/drivers/serial/serial_coreboot.c u-boot/drivers/serial/serial_coreboot.c
--- u-boot-2015.01-rc3/drivers/serial/serial_coreboot.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/serial/serial_coreboot.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2014 Google, Inc
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <dm.h>
-#include <ns16550.h>
-#include <serial.h>
-
-static const struct udevice_id coreboot_serial_ids[] = {
-	{ .compatible = "coreboot-uart" },
-	{ }
-};
-
-static int coreboot_serial_ofdata_to_platdata(struct udevice *dev)
-{
-	struct ns16550_platdata *plat = dev_get_platdata(dev);
-	int ret;
-
-	ret = ns16550_serial_ofdata_to_platdata(dev);
-	if (ret)
-		return ret;
-	plat->clock = 1843200;
-
-	return 0;
-}
-U_BOOT_DRIVER(serial_ns16550) = {
-	.name	= "serial_coreboot",
-	.id	= UCLASS_SERIAL,
-	.of_match = coreboot_serial_ids,
-	.ofdata_to_platdata = coreboot_serial_ofdata_to_platdata,
-	.platdata_auto_alloc_size = sizeof(struct ns16550_platdata),
-	.priv_auto_alloc_size = sizeof(struct NS16550),
-	.probe = ns16550_serial_probe,
-	.ops	= &ns16550_serial_ops,
-};
diff -ruN u-boot-2015.01-rc3/drivers/serial/serial_pl01x.c u-boot/drivers/serial/serial_pl01x.c
--- u-boot-2015.01-rc3/drivers/serial/serial_pl01x.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/serial/serial_pl01x.c	2015-01-01 17:34:32.697495972 +0100
@@ -348,6 +348,7 @@
 	.probe = pl01x_serial_probe,
 	.ops	= &pl01x_serial_ops,
 	.flags = DM_FLAG_PRE_RELOC,
+	.priv_auto_alloc_size = sizeof(struct pl01x_priv),
 };
 
 #endif
diff -ruN u-boot-2015.01-rc3/drivers/serial/serial_x86.c u-boot/drivers/serial/serial_x86.c
--- u-boot-2015.01-rc3/drivers/serial/serial_x86.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/serial/serial_x86.c	2015-01-01 17:34:32.697495972 +0100
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2014 Google, Inc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <ns16550.h>
+#include <serial.h>
+
+static const struct udevice_id x86_serial_ids[] = {
+	{ .compatible = "x86-uart" },
+	{ }
+};
+
+static int x86_serial_ofdata_to_platdata(struct udevice *dev)
+{
+	struct ns16550_platdata *plat = dev_get_platdata(dev);
+	int ret;
+
+	ret = ns16550_serial_ofdata_to_platdata(dev);
+	if (ret)
+		return ret;
+	plat->clock = 1843200;
+
+	return 0;
+}
+U_BOOT_DRIVER(serial_ns16550) = {
+	.name	= "serial_x86",
+	.id	= UCLASS_SERIAL,
+	.of_match = x86_serial_ids,
+	.ofdata_to_platdata = x86_serial_ofdata_to_platdata,
+	.platdata_auto_alloc_size = sizeof(struct ns16550_platdata),
+	.priv_auto_alloc_size = sizeof(struct NS16550),
+	.probe = ns16550_serial_probe,
+	.ops	= &ns16550_serial_ops,
+};
diff -ruN u-boot-2015.01-rc3/drivers/spi/cadence_qspi_apb.c u-boot/drivers/spi/cadence_qspi_apb.c
--- u-boot-2015.01-rc3/drivers/spi/cadence_qspi_apb.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/spi/cadence_qspi_apb.c	2015-01-01 17:34:32.701495908 +0100
@@ -0,0 +1,898 @@
+/*
+ * Copyright (C) 2012 Altera Corporation <www.altera.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *  - Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  - Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *  - Neither the name of the Altera Corporation nor the
+ *    names of its contributors may be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL ALTERA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include "cadence_qspi.h"
+
+#define CQSPI_REG_POLL_US			(1) /* 1us */
+#define CQSPI_REG_RETRY				(10000)
+#define CQSPI_POLL_IDLE_RETRY			(3)
+
+#define CQSPI_FIFO_WIDTH			(4)
+
+/* Controller sram size in word */
+#define CQSPI_REG_SRAM_SIZE_WORD		(128)
+#define CQSPI_REG_SRAM_RESV_WORDS		(2)
+#define CQSPI_REG_SRAM_PARTITION_WR		(1)
+#define CQSPI_REG_SRAM_PARTITION_RD		\
+	(CQSPI_REG_SRAM_SIZE_WORD - CQSPI_REG_SRAM_RESV_WORDS)
+#define CQSPI_REG_SRAM_THRESHOLD_WORDS		(50)
+
+/* Transfer mode */
+#define CQSPI_INST_TYPE_SINGLE			(0)
+#define CQSPI_INST_TYPE_DUAL			(1)
+#define CQSPI_INST_TYPE_QUAD			(2)
+
+#define CQSPI_STIG_DATA_LEN_MAX			(8)
+#define CQSPI_INDIRECTTRIGGER_ADDR_MASK		(0xFFFFF)
+
+#define CQSPI_DUMMY_CLKS_PER_BYTE		(8)
+#define CQSPI_DUMMY_BYTES_MAX			(4)
+
+
+#define CQSPI_REG_SRAM_FILL_THRESHOLD	\
+	((CQSPI_REG_SRAM_SIZE_WORD / 2) * CQSPI_FIFO_WIDTH)
+/****************************************************************************
+ * Controller's configuration and status register (offset from QSPI_BASE)
+ ****************************************************************************/
+#define	CQSPI_REG_CONFIG			0x00
+#define	CQSPI_REG_CONFIG_CLK_POL_LSB		1
+#define	CQSPI_REG_CONFIG_CLK_PHA_LSB		2
+#define	CQSPI_REG_CONFIG_ENABLE_MASK		(1 << 0)
+#define	CQSPI_REG_CONFIG_DIRECT_MASK		(1 << 7)
+#define	CQSPI_REG_CONFIG_DECODE_MASK		(1 << 9)
+#define	CQSPI_REG_CONFIG_XIP_IMM_MASK		(1 << 18)
+#define	CQSPI_REG_CONFIG_CHIPSELECT_LSB		10
+#define	CQSPI_REG_CONFIG_BAUD_LSB		19
+#define	CQSPI_REG_CONFIG_IDLE_LSB		31
+#define	CQSPI_REG_CONFIG_CHIPSELECT_MASK	0xF
+#define	CQSPI_REG_CONFIG_BAUD_MASK		0xF
+
+#define	CQSPI_REG_RD_INSTR			0x04
+#define	CQSPI_REG_RD_INSTR_OPCODE_LSB		0
+#define	CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB	8
+#define	CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB	12
+#define	CQSPI_REG_RD_INSTR_TYPE_DATA_LSB	16
+#define	CQSPI_REG_RD_INSTR_MODE_EN_LSB		20
+#define	CQSPI_REG_RD_INSTR_DUMMY_LSB		24
+#define	CQSPI_REG_RD_INSTR_TYPE_INSTR_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_TYPE_ADDR_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_TYPE_DATA_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_DUMMY_MASK		0x1F
+
+#define	CQSPI_REG_WR_INSTR			0x08
+#define	CQSPI_REG_WR_INSTR_OPCODE_LSB		0
+
+#define	CQSPI_REG_DELAY				0x0C
+#define	CQSPI_REG_DELAY_TSLCH_LSB		0
+#define	CQSPI_REG_DELAY_TCHSH_LSB		8
+#define	CQSPI_REG_DELAY_TSD2D_LSB		16
+#define	CQSPI_REG_DELAY_TSHSL_LSB		24
+#define	CQSPI_REG_DELAY_TSLCH_MASK		0xFF
+#define	CQSPI_REG_DELAY_TCHSH_MASK		0xFF
+#define	CQSPI_REG_DELAY_TSD2D_MASK		0xFF
+#define	CQSPI_REG_DELAY_TSHSL_MASK		0xFF
+
+#define	CQSPI_READLCAPTURE			0x10
+#define	CQSPI_READLCAPTURE_BYPASS_LSB		0
+#define	CQSPI_READLCAPTURE_DELAY_LSB		1
+#define	CQSPI_READLCAPTURE_DELAY_MASK		0xF
+
+#define	CQSPI_REG_SIZE				0x14
+#define	CQSPI_REG_SIZE_ADDRESS_LSB		0
+#define	CQSPI_REG_SIZE_PAGE_LSB			4
+#define	CQSPI_REG_SIZE_BLOCK_LSB		16
+#define	CQSPI_REG_SIZE_ADDRESS_MASK		0xF
+#define	CQSPI_REG_SIZE_PAGE_MASK		0xFFF
+#define	CQSPI_REG_SIZE_BLOCK_MASK		0x3F
+
+#define	CQSPI_REG_SRAMPARTITION			0x18
+#define	CQSPI_REG_INDIRECTTRIGGER		0x1C
+
+#define	CQSPI_REG_REMAP				0x24
+#define	CQSPI_REG_MODE_BIT			0x28
+
+#define	CQSPI_REG_SDRAMLEVEL			0x2C
+#define	CQSPI_REG_SDRAMLEVEL_RD_LSB		0
+#define	CQSPI_REG_SDRAMLEVEL_WR_LSB		16
+#define	CQSPI_REG_SDRAMLEVEL_RD_MASK		0xFFFF
+#define	CQSPI_REG_SDRAMLEVEL_WR_MASK		0xFFFF
+
+#define	CQSPI_REG_IRQSTATUS			0x40
+#define	CQSPI_REG_IRQMASK			0x44
+
+#define	CQSPI_REG_INDIRECTRD			0x60
+#define	CQSPI_REG_INDIRECTRD_START_MASK		(1 << 0)
+#define	CQSPI_REG_INDIRECTRD_CANCEL_MASK	(1 << 1)
+#define	CQSPI_REG_INDIRECTRD_INPROGRESS_MASK	(1 << 2)
+#define	CQSPI_REG_INDIRECTRD_DONE_MASK		(1 << 5)
+
+#define	CQSPI_REG_INDIRECTRDWATERMARK		0x64
+#define	CQSPI_REG_INDIRECTRDSTARTADDR		0x68
+#define	CQSPI_REG_INDIRECTRDBYTES		0x6C
+
+#define	CQSPI_REG_CMDCTRL			0x90
+#define	CQSPI_REG_CMDCTRL_EXECUTE_MASK		(1 << 0)
+#define	CQSPI_REG_CMDCTRL_INPROGRESS_MASK	(1 << 1)
+#define	CQSPI_REG_CMDCTRL_DUMMY_LSB		7
+#define	CQSPI_REG_CMDCTRL_WR_BYTES_LSB		12
+#define	CQSPI_REG_CMDCTRL_WR_EN_LSB		15
+#define	CQSPI_REG_CMDCTRL_ADD_BYTES_LSB		16
+#define	CQSPI_REG_CMDCTRL_ADDR_EN_LSB		19
+#define	CQSPI_REG_CMDCTRL_RD_BYTES_LSB		20
+#define	CQSPI_REG_CMDCTRL_RD_EN_LSB		23
+#define	CQSPI_REG_CMDCTRL_OPCODE_LSB		24
+#define	CQSPI_REG_CMDCTRL_DUMMY_MASK		0x1F
+#define	CQSPI_REG_CMDCTRL_WR_BYTES_MASK		0x7
+#define	CQSPI_REG_CMDCTRL_ADD_BYTES_MASK	0x3
+#define	CQSPI_REG_CMDCTRL_RD_BYTES_MASK		0x7
+#define	CQSPI_REG_CMDCTRL_OPCODE_MASK		0xFF
+
+#define	CQSPI_REG_INDIRECTWR			0x70
+#define	CQSPI_REG_INDIRECTWR_START_MASK		(1 << 0)
+#define	CQSPI_REG_INDIRECTWR_CANCEL_MASK	(1 << 1)
+#define	CQSPI_REG_INDIRECTWR_INPROGRESS_MASK	(1 << 2)
+#define	CQSPI_REG_INDIRECTWR_DONE_MASK		(1 << 5)
+
+#define	CQSPI_REG_INDIRECTWRWATERMARK		0x74
+#define	CQSPI_REG_INDIRECTWRSTARTADDR		0x78
+#define	CQSPI_REG_INDIRECTWRBYTES		0x7C
+
+#define	CQSPI_REG_CMDADDRESS			0x94
+#define	CQSPI_REG_CMDREADDATALOWER		0xA0
+#define	CQSPI_REG_CMDREADDATAUPPER		0xA4
+#define	CQSPI_REG_CMDWRITEDATALOWER		0xA8
+#define	CQSPI_REG_CMDWRITEDATAUPPER		0xAC
+
+#define CQSPI_REG_IS_IDLE(base)					\
+	((readl(base + CQSPI_REG_CONFIG) >>		\
+		CQSPI_REG_CONFIG_IDLE_LSB) & 0x1)
+
+#define CQSPI_CAL_DELAY(tdelay_ns, tref_ns, tsclk_ns)		\
+	((((tdelay_ns) - (tsclk_ns)) / (tref_ns)))
+
+#define CQSPI_GET_RD_SRAM_LEVEL(reg_base)			\
+	(((readl(reg_base + CQSPI_REG_SDRAMLEVEL)) >>	\
+	CQSPI_REG_SDRAMLEVEL_RD_LSB) & CQSPI_REG_SDRAMLEVEL_RD_MASK)
+
+#define CQSPI_GET_WR_SRAM_LEVEL(reg_base)			\
+	(((readl(reg_base + CQSPI_REG_SDRAMLEVEL)) >>	\
+	CQSPI_REG_SDRAMLEVEL_WR_LSB) & CQSPI_REG_SDRAMLEVEL_WR_MASK)
+
+static unsigned int cadence_qspi_apb_cmd2addr(const unsigned char *addr_buf,
+	unsigned int addr_width)
+{
+	unsigned int addr;
+
+	addr = (addr_buf[0] << 16) | (addr_buf[1] << 8) | addr_buf[2];
+
+	if (addr_width == 4)
+		addr = (addr << 8) | addr_buf[3];
+
+	return addr;
+}
+
+static void cadence_qspi_apb_read_fifo_data(void *dest,
+	const void *src_ahb_addr, unsigned int bytes)
+{
+	unsigned int temp;
+	int remaining = bytes;
+	unsigned int *dest_ptr = (unsigned int *)dest;
+	unsigned int *src_ptr = (unsigned int *)src_ahb_addr;
+
+	while (remaining > 0) {
+		if (remaining >= CQSPI_FIFO_WIDTH) {
+			*dest_ptr = readl(src_ptr);
+			remaining -= CQSPI_FIFO_WIDTH;
+		} else {
+			/* dangling bytes */
+			temp = readl(src_ptr);
+			memcpy(dest_ptr, &temp, remaining);
+			break;
+		}
+		dest_ptr++;
+	}
+
+	return;
+}
+
+static void cadence_qspi_apb_write_fifo_data(const void *dest_ahb_addr,
+	const void *src, unsigned int bytes)
+{
+	unsigned int temp;
+	int remaining = bytes;
+	unsigned int *dest_ptr = (unsigned int *)dest_ahb_addr;
+	unsigned int *src_ptr = (unsigned int *)src;
+
+	while (remaining > 0) {
+		if (remaining >= CQSPI_FIFO_WIDTH) {
+			writel(*src_ptr, dest_ptr);
+			remaining -= sizeof(unsigned int);
+		} else {
+			/* dangling bytes */
+			memcpy(&temp, src_ptr, remaining);
+			writel(temp, dest_ptr);
+			break;
+		}
+		src_ptr++;
+	}
+
+	return;
+}
+
+/* Read from SRAM FIFO with polling SRAM fill level. */
+static int qspi_read_sram_fifo_poll(const void *reg_base, void *dest_addr,
+			const void *src_addr,  unsigned int num_bytes)
+{
+	unsigned int remaining = num_bytes;
+	unsigned int retry;
+	unsigned int sram_level = 0;
+	unsigned char *dest = (unsigned char *)dest_addr;
+
+	while (remaining > 0) {
+		retry = CQSPI_REG_RETRY;
+		while (retry--) {
+			sram_level = CQSPI_GET_RD_SRAM_LEVEL(reg_base);
+			if (sram_level)
+				break;
+			udelay(1);
+		}
+
+		if (!retry) {
+			printf("QSPI: No receive data after polling for %d times\n",
+			       CQSPI_REG_RETRY);
+			return -1;
+		}
+
+		sram_level *= CQSPI_FIFO_WIDTH;
+		sram_level = sram_level > remaining ? remaining : sram_level;
+
+		/* Read data from FIFO. */
+		cadence_qspi_apb_read_fifo_data(dest, src_addr, sram_level);
+		dest += sram_level;
+		remaining -= sram_level;
+		udelay(1);
+	}
+	return 0;
+}
+
+/* Write to SRAM FIFO with polling SRAM fill level. */
+static int qpsi_write_sram_fifo_push(struct cadence_spi_platdata *plat,
+				const void *src_addr, unsigned int num_bytes)
+{
+	const void *reg_base = plat->regbase;
+	void *dest_addr = plat->ahbbase;
+	unsigned int retry = CQSPI_REG_RETRY;
+	unsigned int sram_level;
+	unsigned int wr_bytes;
+	unsigned char *src = (unsigned char *)src_addr;
+	int remaining = num_bytes;
+	unsigned int page_size = plat->page_size;
+	unsigned int sram_threshold_words = CQSPI_REG_SRAM_THRESHOLD_WORDS;
+
+	while (remaining > 0) {
+		retry = CQSPI_REG_RETRY;
+		while (retry--) {
+			sram_level = CQSPI_GET_WR_SRAM_LEVEL(reg_base);
+			if (sram_level <= sram_threshold_words)
+				break;
+		}
+		if (!retry) {
+			printf("QSPI: SRAM fill level (0x%08x) not hit lower expected level (0x%08x)",
+			       sram_level, sram_threshold_words);
+			return -1;
+		}
+		/* Write a page or remaining bytes. */
+		wr_bytes = (remaining > page_size) ?
+					page_size : remaining;
+
+		cadence_qspi_apb_write_fifo_data(dest_addr, src, wr_bytes);
+		src += wr_bytes;
+		remaining -= wr_bytes;
+	}
+
+	return 0;
+}
+
+void cadence_qspi_apb_controller_enable(void *reg_base)
+{
+	unsigned int reg;
+	reg = readl(reg_base + CQSPI_REG_CONFIG);
+	reg |= CQSPI_REG_CONFIG_ENABLE_MASK;
+	writel(reg, reg_base + CQSPI_REG_CONFIG);
+	return;
+}
+
+void cadence_qspi_apb_controller_disable(void *reg_base)
+{
+	unsigned int reg;
+	reg = readl(reg_base + CQSPI_REG_CONFIG);
+	reg &= ~CQSPI_REG_CONFIG_ENABLE_MASK;
+	writel(reg, reg_base + CQSPI_REG_CONFIG);
+	return;
+}
+
+/* Return 1 if idle, otherwise return 0 (busy). */
+static unsigned int cadence_qspi_wait_idle(void *reg_base)
+{
+	unsigned int start, count = 0;
+	/* timeout in unit of ms */
+	unsigned int timeout = 5000;
+
+	start = get_timer(0);
+	for ( ; get_timer(start) < timeout ; ) {
+		if (CQSPI_REG_IS_IDLE(reg_base))
+			count++;
+		else
+			count = 0;
+		/*
+		 * Ensure the QSPI controller is in true idle state after
+		 * reading back the same idle status consecutively
+		 */
+		if (count >= CQSPI_POLL_IDLE_RETRY)
+			return 1;
+	}
+
+	/* Timeout, still in busy mode. */
+	printf("QSPI: QSPI is still busy after poll for %d times.\n",
+	       CQSPI_REG_RETRY);
+	return 0;
+}
+
+void cadence_qspi_apb_readdata_capture(void *reg_base,
+				unsigned int bypass, unsigned int delay)
+{
+	unsigned int reg;
+	cadence_qspi_apb_controller_disable(reg_base);
+
+	reg = readl(reg_base + CQSPI_READLCAPTURE);
+
+	if (bypass)
+		reg |= (1 << CQSPI_READLCAPTURE_BYPASS_LSB);
+	else
+		reg &= ~(1 << CQSPI_READLCAPTURE_BYPASS_LSB);
+
+	reg &= ~(CQSPI_READLCAPTURE_DELAY_MASK
+		<< CQSPI_READLCAPTURE_DELAY_LSB);
+
+	reg |= ((delay & CQSPI_READLCAPTURE_DELAY_MASK)
+		<< CQSPI_READLCAPTURE_DELAY_LSB);
+
+	writel(reg, reg_base + CQSPI_READLCAPTURE);
+
+	cadence_qspi_apb_controller_enable(reg_base);
+	return;
+}
+
+void cadence_qspi_apb_config_baudrate_div(void *reg_base,
+	unsigned int ref_clk_hz, unsigned int sclk_hz)
+{
+	unsigned int reg;
+	unsigned int div;
+
+	cadence_qspi_apb_controller_disable(reg_base);
+	reg = readl(reg_base + CQSPI_REG_CONFIG);
+	reg &= ~(CQSPI_REG_CONFIG_BAUD_MASK << CQSPI_REG_CONFIG_BAUD_LSB);
+
+	div = ref_clk_hz / sclk_hz;
+
+	if (div > 32)
+		div = 32;
+
+	/* Check if even number. */
+	if ((div & 1)) {
+		div = (div / 2);
+	} else {
+		if (ref_clk_hz % sclk_hz)
+			/* ensure generated SCLK doesn't exceed user
+			specified sclk_hz */
+			div = (div / 2);
+		else
+			div = (div / 2) - 1;
+	}
+
+	debug("%s: ref_clk %dHz sclk %dHz Div 0x%x\n", __func__,
+	      ref_clk_hz, sclk_hz, div);
+
+	div = (div & CQSPI_REG_CONFIG_BAUD_MASK) << CQSPI_REG_CONFIG_BAUD_LSB;
+	reg |= div;
+	writel(reg, reg_base + CQSPI_REG_CONFIG);
+
+	cadence_qspi_apb_controller_enable(reg_base);
+	return;
+}
+
+void cadence_qspi_apb_set_clk_mode(void *reg_base,
+	unsigned int clk_pol, unsigned int clk_pha)
+{
+	unsigned int reg;
+
+	cadence_qspi_apb_controller_disable(reg_base);
+	reg = readl(reg_base + CQSPI_REG_CONFIG);
+	reg &= ~(1 <<
+		(CQSPI_REG_CONFIG_CLK_POL_LSB | CQSPI_REG_CONFIG_CLK_PHA_LSB));
+
+	reg |= ((clk_pol & 0x1) << CQSPI_REG_CONFIG_CLK_POL_LSB);
+	reg |= ((clk_pha & 0x1) << CQSPI_REG_CONFIG_CLK_PHA_LSB);
+
+	writel(reg, reg_base + CQSPI_REG_CONFIG);
+
+	cadence_qspi_apb_controller_enable(reg_base);
+	return;
+}
+
+void cadence_qspi_apb_chipselect(void *reg_base,
+	unsigned int chip_select, unsigned int decoder_enable)
+{
+	unsigned int reg;
+
+	cadence_qspi_apb_controller_disable(reg_base);
+
+	debug("%s : chipselect %d decode %d\n", __func__, chip_select,
+	      decoder_enable);
+
+	reg = readl(reg_base + CQSPI_REG_CONFIG);
+	/* docoder */
+	if (decoder_enable) {
+		reg |= CQSPI_REG_CONFIG_DECODE_MASK;
+	} else {
+		reg &= ~CQSPI_REG_CONFIG_DECODE_MASK;
+		/* Convert CS if without decoder.
+		 * CS0 to 4b'1110
+		 * CS1 to 4b'1101
+		 * CS2 to 4b'1011
+		 * CS3 to 4b'0111
+		 */
+		chip_select = 0xF & ~(1 << chip_select);
+	}
+
+	reg &= ~(CQSPI_REG_CONFIG_CHIPSELECT_MASK
+			<< CQSPI_REG_CONFIG_CHIPSELECT_LSB);
+	reg |= (chip_select & CQSPI_REG_CONFIG_CHIPSELECT_MASK)
+			<< CQSPI_REG_CONFIG_CHIPSELECT_LSB;
+	writel(reg, reg_base + CQSPI_REG_CONFIG);
+
+	cadence_qspi_apb_controller_enable(reg_base);
+	return;
+}
+
+void cadence_qspi_apb_delay(void *reg_base,
+	unsigned int ref_clk, unsigned int sclk_hz,
+	unsigned int tshsl_ns, unsigned int tsd2d_ns,
+	unsigned int tchsh_ns, unsigned int tslch_ns)
+{
+	unsigned int ref_clk_ns;
+	unsigned int sclk_ns;
+	unsigned int tshsl, tchsh, tslch, tsd2d;
+	unsigned int reg;
+
+	cadence_qspi_apb_controller_disable(reg_base);
+
+	/* Convert to ns. */
+	ref_clk_ns = (1000000000) / ref_clk;
+
+	/* Convert to ns. */
+	sclk_ns = (1000000000) / sclk_hz;
+
+	/* Plus 1 to round up 1 clock cycle. */
+	tshsl = CQSPI_CAL_DELAY(tshsl_ns, ref_clk_ns, sclk_ns) + 1;
+	tchsh = CQSPI_CAL_DELAY(tchsh_ns, ref_clk_ns, sclk_ns) + 1;
+	tslch = CQSPI_CAL_DELAY(tslch_ns, ref_clk_ns, sclk_ns) + 1;
+	tsd2d = CQSPI_CAL_DELAY(tsd2d_ns, ref_clk_ns, sclk_ns) + 1;
+
+	reg = ((tshsl & CQSPI_REG_DELAY_TSHSL_MASK)
+			<< CQSPI_REG_DELAY_TSHSL_LSB);
+	reg |= ((tchsh & CQSPI_REG_DELAY_TCHSH_MASK)
+			<< CQSPI_REG_DELAY_TCHSH_LSB);
+	reg |= ((tslch & CQSPI_REG_DELAY_TSLCH_MASK)
+			<< CQSPI_REG_DELAY_TSLCH_LSB);
+	reg |= ((tsd2d & CQSPI_REG_DELAY_TSD2D_MASK)
+			<< CQSPI_REG_DELAY_TSD2D_LSB);
+	writel(reg, reg_base + CQSPI_REG_DELAY);
+
+	cadence_qspi_apb_controller_enable(reg_base);
+	return;
+}
+
+void cadence_qspi_apb_controller_init(struct cadence_spi_platdata *plat)
+{
+	unsigned reg;
+
+	cadence_qspi_apb_controller_disable(plat->regbase);
+
+	/* Configure the device size and address bytes */
+	reg = readl(plat->regbase + CQSPI_REG_SIZE);
+	/* Clear the previous value */
+	reg &= ~(CQSPI_REG_SIZE_PAGE_MASK << CQSPI_REG_SIZE_PAGE_LSB);
+	reg &= ~(CQSPI_REG_SIZE_BLOCK_MASK << CQSPI_REG_SIZE_BLOCK_LSB);
+	reg |= (plat->page_size << CQSPI_REG_SIZE_PAGE_LSB);
+	reg |= (plat->block_size << CQSPI_REG_SIZE_BLOCK_LSB);
+	writel(reg, plat->regbase + CQSPI_REG_SIZE);
+
+	/* Configure the remap address register, no remap */
+	writel(0, plat->regbase + CQSPI_REG_REMAP);
+
+	/* Disable all interrupts */
+	writel(0, plat->regbase + CQSPI_REG_IRQMASK);
+
+	cadence_qspi_apb_controller_enable(plat->regbase);
+	return;
+}
+
+static int cadence_qspi_apb_exec_flash_cmd(void *reg_base,
+	unsigned int reg)
+{
+	unsigned int retry = CQSPI_REG_RETRY;
+
+	/* Write the CMDCTRL without start execution. */
+	writel(reg, reg_base + CQSPI_REG_CMDCTRL);
+	/* Start execute */
+	reg |= CQSPI_REG_CMDCTRL_EXECUTE_MASK;
+	writel(reg, reg_base + CQSPI_REG_CMDCTRL);
+
+	while (retry--) {
+		reg = readl(reg_base + CQSPI_REG_CMDCTRL);
+		if ((reg & CQSPI_REG_CMDCTRL_INPROGRESS_MASK) == 0)
+			break;
+		udelay(1);
+	}
+
+	if (!retry) {
+		printf("QSPI: flash command execution timeout\n");
+		return -EIO;
+	}
+
+	/* Polling QSPI idle status. */
+	if (!cadence_qspi_wait_idle(reg_base))
+		return -EIO;
+
+	return 0;
+}
+
+/* For command RDID, RDSR. */
+int cadence_qspi_apb_command_read(void *reg_base,
+	unsigned int cmdlen, const u8 *cmdbuf, unsigned int rxlen,
+	u8 *rxbuf)
+{
+	unsigned int reg;
+	unsigned int read_len;
+	int status;
+
+	if (!cmdlen || rxlen > CQSPI_STIG_DATA_LEN_MAX || rxbuf == NULL) {
+		printf("QSPI: Invalid input arguments cmdlen %d rxlen %d\n",
+		       cmdlen, rxlen);
+		return -EINVAL;
+	}
+
+	reg = cmdbuf[0] << CQSPI_REG_CMDCTRL_OPCODE_LSB;
+
+	reg |= (0x1 << CQSPI_REG_CMDCTRL_RD_EN_LSB);
+
+	/* 0 means 1 byte. */
+	reg |= (((rxlen - 1) & CQSPI_REG_CMDCTRL_RD_BYTES_MASK)
+		<< CQSPI_REG_CMDCTRL_RD_BYTES_LSB);
+	status = cadence_qspi_apb_exec_flash_cmd(reg_base, reg);
+	if (status != 0)
+		return status;
+
+	reg = readl(reg_base + CQSPI_REG_CMDREADDATALOWER);
+
+	/* Put the read value into rx_buf */
+	read_len = (rxlen > 4) ? 4 : rxlen;
+	memcpy(rxbuf, &reg, read_len);
+	rxbuf += read_len;
+
+	if (rxlen > 4) {
+		reg = readl(reg_base + CQSPI_REG_CMDREADDATAUPPER);
+
+		read_len = rxlen - read_len;
+		memcpy(rxbuf, &reg, read_len);
+	}
+	return 0;
+}
+
+/* For commands: WRSR, WREN, WRDI, CHIP_ERASE, BE, etc. */
+int cadence_qspi_apb_command_write(void *reg_base, unsigned int cmdlen,
+	const u8 *cmdbuf, unsigned int txlen,  const u8 *txbuf)
+{
+	unsigned int reg = 0;
+	unsigned int addr_value;
+	unsigned int wr_data;
+	unsigned int wr_len;
+
+	if (!cmdlen || cmdlen > 5 || txlen > 8 || cmdbuf == NULL) {
+		printf("QSPI: Invalid input arguments cmdlen %d txlen %d\n",
+		       cmdlen, txlen);
+		return -EINVAL;
+	}
+
+	reg |= cmdbuf[0] << CQSPI_REG_CMDCTRL_OPCODE_LSB;
+
+	if (cmdlen == 4 || cmdlen == 5) {
+		/* Command with address */
+		reg |= (0x1 << CQSPI_REG_CMDCTRL_ADDR_EN_LSB);
+		/* Number of bytes to write. */
+		reg |= ((cmdlen - 2) & CQSPI_REG_CMDCTRL_ADD_BYTES_MASK)
+			<< CQSPI_REG_CMDCTRL_ADD_BYTES_LSB;
+		/* Get address */
+		addr_value = cadence_qspi_apb_cmd2addr(&cmdbuf[1],
+			cmdlen >= 5 ? 4 : 3);
+
+		writel(addr_value, reg_base + CQSPI_REG_CMDADDRESS);
+	}
+
+	if (txlen) {
+		/* writing data = yes */
+		reg |= (0x1 << CQSPI_REG_CMDCTRL_WR_EN_LSB);
+		reg |= ((txlen - 1) & CQSPI_REG_CMDCTRL_WR_BYTES_MASK)
+			<< CQSPI_REG_CMDCTRL_WR_BYTES_LSB;
+
+		wr_len = txlen > 4 ? 4 : txlen;
+		memcpy(&wr_data, txbuf, wr_len);
+		writel(wr_data, reg_base +
+			CQSPI_REG_CMDWRITEDATALOWER);
+
+		if (txlen > 4) {
+			txbuf += wr_len;
+			wr_len = txlen - wr_len;
+			memcpy(&wr_data, txbuf, wr_len);
+			writel(wr_data, reg_base +
+				CQSPI_REG_CMDWRITEDATAUPPER);
+		}
+	}
+
+	/* Execute the command */
+	return cadence_qspi_apb_exec_flash_cmd(reg_base, reg);
+}
+
+/* Opcode + Address (3/4 bytes) + dummy bytes (0-4 bytes) */
+int cadence_qspi_apb_indirect_read_setup(struct cadence_spi_platdata *plat,
+	unsigned int cmdlen, const u8 *cmdbuf)
+{
+	unsigned int reg;
+	unsigned int rd_reg;
+	unsigned int addr_value;
+	unsigned int dummy_clk;
+	unsigned int dummy_bytes;
+	unsigned int addr_bytes;
+
+	/*
+	 * Identify addr_byte. All NOR flash device drivers are using fast read
+	 * which always expecting 1 dummy byte, 1 cmd byte and 3/4 addr byte.
+	 * With that, the length is in value of 5 or 6. Only FRAM chip from
+	 * ramtron using normal read (which won't need dummy byte).
+	 * Unlikely NOR flash using normal read due to performance issue.
+	 */
+	if (cmdlen >= 5)
+		/* to cater fast read where cmd + addr + dummy */
+		addr_bytes = cmdlen - 2;
+	else
+		/* for normal read (only ramtron as of now) */
+		addr_bytes = cmdlen - 1;
+
+	/* Setup the indirect trigger address */
+	writel(((u32)plat->ahbbase & CQSPI_INDIRECTTRIGGER_ADDR_MASK),
+	       plat->regbase + CQSPI_REG_INDIRECTTRIGGER);
+
+	/* Configure SRAM partition for read. */
+	writel(CQSPI_REG_SRAM_PARTITION_RD, plat->regbase +
+	       CQSPI_REG_SRAMPARTITION);
+
+	/* Configure the opcode */
+	rd_reg = cmdbuf[0] << CQSPI_REG_RD_INSTR_OPCODE_LSB;
+
+#if (CONFIG_SPI_FLASH_QUAD == 1)
+	/* Instruction and address at DQ0, data at DQ0-3. */
+	rd_reg |= CQSPI_INST_TYPE_QUAD << CQSPI_REG_RD_INSTR_TYPE_DATA_LSB;
+#endif
+
+	/* Get address */
+	addr_value = cadence_qspi_apb_cmd2addr(&cmdbuf[1], addr_bytes);
+	writel(addr_value, plat->regbase + CQSPI_REG_INDIRECTRDSTARTADDR);
+
+	/* The remaining lenght is dummy bytes. */
+	dummy_bytes = cmdlen - addr_bytes - 1;
+	if (dummy_bytes) {
+		if (dummy_bytes > CQSPI_DUMMY_BYTES_MAX)
+			dummy_bytes = CQSPI_DUMMY_BYTES_MAX;
+
+		rd_reg |= (1 << CQSPI_REG_RD_INSTR_MODE_EN_LSB);
+#if defined(CONFIG_SPL_SPI_XIP) && defined(CONFIG_SPL_BUILD)
+		writel(0x0, plat->regbase + CQSPI_REG_MODE_BIT);
+#else
+		writel(0xFF, plat->regbase + CQSPI_REG_MODE_BIT);
+#endif
+
+		/* Convert to clock cycles. */
+		dummy_clk = dummy_bytes * CQSPI_DUMMY_CLKS_PER_BYTE;
+		/* Need to minus the mode byte (8 clocks). */
+		dummy_clk -= CQSPI_DUMMY_CLKS_PER_BYTE;
+
+		if (dummy_clk)
+			rd_reg |= (dummy_clk & CQSPI_REG_RD_INSTR_DUMMY_MASK)
+				<< CQSPI_REG_RD_INSTR_DUMMY_LSB;
+	}
+
+	writel(rd_reg, plat->regbase + CQSPI_REG_RD_INSTR);
+
+	/* set device size */
+	reg = readl(plat->regbase + CQSPI_REG_SIZE);
+	reg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;
+	reg |= (addr_bytes - 1);
+	writel(reg, plat->regbase + CQSPI_REG_SIZE);
+	return 0;
+}
+
+int cadence_qspi_apb_indirect_read_execute(struct cadence_spi_platdata *plat,
+	unsigned int rxlen, u8 *rxbuf)
+{
+	unsigned int reg;
+
+	writel(rxlen, plat->regbase + CQSPI_REG_INDIRECTRDBYTES);
+
+	/* Start the indirect read transfer */
+	writel(CQSPI_REG_INDIRECTRD_START_MASK,
+	       plat->regbase + CQSPI_REG_INDIRECTRD);
+
+	if (qspi_read_sram_fifo_poll(plat->regbase, (void *)rxbuf,
+				     (const void *)plat->ahbbase, rxlen))
+		goto failrd;
+
+	/* Check flash indirect controller */
+	reg = readl(plat->regbase + CQSPI_REG_INDIRECTRD);
+	if (!(reg & CQSPI_REG_INDIRECTRD_DONE_MASK)) {
+		reg = readl(plat->regbase + CQSPI_REG_INDIRECTRD);
+		printf("QSPI: indirect completion status error with reg 0x%08x\n",
+		       reg);
+		goto failrd;
+	}
+
+	/* Clear indirect completion status */
+	writel(CQSPI_REG_INDIRECTRD_DONE_MASK,
+	       plat->regbase + CQSPI_REG_INDIRECTRD);
+	return 0;
+
+failrd:
+	/* Cancel the indirect read */
+	writel(CQSPI_REG_INDIRECTRD_CANCEL_MASK,
+	       plat->regbase + CQSPI_REG_INDIRECTRD);
+	return -1;
+}
+
+/* Opcode + Address (3/4 bytes) */
+int cadence_qspi_apb_indirect_write_setup(struct cadence_spi_platdata *plat,
+	unsigned int cmdlen, const u8 *cmdbuf)
+{
+	unsigned int reg;
+	unsigned int addr_bytes = cmdlen > 4 ? 4 : 3;
+
+	if (cmdlen < 4 || cmdbuf == NULL) {
+		printf("QSPI: iInvalid input argument, len %d cmdbuf 0x%08x\n",
+		       cmdlen, (unsigned int)cmdbuf);
+		return -EINVAL;
+	}
+	/* Setup the indirect trigger address */
+	writel(((u32)plat->ahbbase & CQSPI_INDIRECTTRIGGER_ADDR_MASK),
+	       plat->regbase + CQSPI_REG_INDIRECTTRIGGER);
+
+	writel(CQSPI_REG_SRAM_PARTITION_WR,
+	       plat->regbase + CQSPI_REG_SRAMPARTITION);
+
+	/* Configure the opcode */
+	reg = cmdbuf[0] << CQSPI_REG_WR_INSTR_OPCODE_LSB;
+	writel(reg, plat->regbase + CQSPI_REG_WR_INSTR);
+
+	/* Setup write address. */
+	reg = cadence_qspi_apb_cmd2addr(&cmdbuf[1], addr_bytes);
+	writel(reg, plat->regbase + CQSPI_REG_INDIRECTWRSTARTADDR);
+
+	reg = readl(plat->regbase + CQSPI_REG_SIZE);
+	reg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;
+	reg |= (addr_bytes - 1);
+	writel(reg, plat->regbase + CQSPI_REG_SIZE);
+	return 0;
+}
+
+int cadence_qspi_apb_indirect_write_execute(struct cadence_spi_platdata *plat,
+	unsigned int txlen, const u8 *txbuf)
+{
+	unsigned int reg = 0;
+	unsigned int retry;
+
+	/* Configure the indirect read transfer bytes */
+	writel(txlen, plat->regbase + CQSPI_REG_INDIRECTWRBYTES);
+
+	/* Start the indirect write transfer */
+	writel(CQSPI_REG_INDIRECTWR_START_MASK,
+	       plat->regbase + CQSPI_REG_INDIRECTWR);
+
+	if (qpsi_write_sram_fifo_push(plat, (const void *)txbuf, txlen))
+		goto failwr;
+
+	/* Wait until last write is completed (FIFO empty) */
+	retry = CQSPI_REG_RETRY;
+	while (retry--) {
+		reg = CQSPI_GET_WR_SRAM_LEVEL(plat->regbase);
+		if (reg == 0)
+			break;
+
+		udelay(1);
+	}
+
+	if (reg != 0) {
+		printf("QSPI: timeout for indirect write\n");
+		goto failwr;
+	}
+
+	/* Check flash indirect controller status */
+	retry = CQSPI_REG_RETRY;
+	while (retry--) {
+		reg = readl(plat->regbase + CQSPI_REG_INDIRECTWR);
+		if (reg & CQSPI_REG_INDIRECTWR_DONE_MASK)
+			break;
+		udelay(1);
+	}
+
+	if (!(reg & CQSPI_REG_INDIRECTWR_DONE_MASK)) {
+		printf("QSPI: indirect completion status error with reg 0x%08x\n",
+		       reg);
+		goto failwr;
+	}
+
+	/* Clear indirect completion status */
+	writel(CQSPI_REG_INDIRECTWR_DONE_MASK,
+	       plat->regbase + CQSPI_REG_INDIRECTWR);
+	return 0;
+
+failwr:
+	/* Cancel the indirect write */
+	writel(CQSPI_REG_INDIRECTWR_CANCEL_MASK,
+	       plat->regbase + CQSPI_REG_INDIRECTWR);
+	return -1;
+}
+
+void cadence_qspi_apb_enter_xip(void *reg_base, char xip_dummy)
+{
+	unsigned int reg;
+
+	/* enter XiP mode immediately and enable direct mode */
+	reg = readl(reg_base + CQSPI_REG_CONFIG);
+	reg |= CQSPI_REG_CONFIG_ENABLE_MASK;
+	reg |= CQSPI_REG_CONFIG_DIRECT_MASK;
+	reg |= CQSPI_REG_CONFIG_XIP_IMM_MASK;
+	writel(reg, reg_base + CQSPI_REG_CONFIG);
+
+	/* keep the XiP mode */
+	writel(xip_dummy, reg_base + CQSPI_REG_MODE_BIT);
+
+	/* Enable mode bit at devrd */
+	reg = readl(reg_base + CQSPI_REG_RD_INSTR);
+	reg |= (1 << CQSPI_REG_RD_INSTR_MODE_EN_LSB);
+	writel(reg, reg_base + CQSPI_REG_RD_INSTR);
+}
diff -ruN u-boot-2015.01-rc3/drivers/spi/cadence_qspi.c u-boot/drivers/spi/cadence_qspi.c
--- u-boot-2015.01-rc3/drivers/spi/cadence_qspi.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/spi/cadence_qspi.c	2015-01-01 17:34:32.701495908 +0100
@@ -0,0 +1,345 @@
+/*
+ * Copyright (C) 2012
+ * Altera Corporation <www.altera.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <fdtdec.h>
+#include <malloc.h>
+#include <spi.h>
+#include <asm/errno.h>
+#include "cadence_qspi.h"
+
+#define CQSPI_STIG_READ			0
+#define CQSPI_STIG_WRITE		1
+#define CQSPI_INDIRECT_READ		2
+#define CQSPI_INDIRECT_WRITE		3
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static int cadence_spi_write_speed(struct udevice *bus, uint hz)
+{
+	struct cadence_spi_platdata *plat = bus->platdata;
+	struct cadence_spi_priv *priv = dev_get_priv(bus);
+
+	cadence_qspi_apb_config_baudrate_div(priv->regbase,
+					     CONFIG_CQSPI_REF_CLK, hz);
+
+	/* Reconfigure delay timing if speed is changed. */
+	cadence_qspi_apb_delay(priv->regbase, CONFIG_CQSPI_REF_CLK, hz,
+			       plat->tshsl_ns, plat->tsd2d_ns,
+			       plat->tchsh_ns, plat->tslch_ns);
+
+	return 0;
+}
+
+/* Calibration sequence to determine the read data capture delay register */
+static int spi_calibration(struct udevice *bus)
+{
+	struct cadence_spi_platdata *plat = bus->platdata;
+	struct cadence_spi_priv *priv = dev_get_priv(bus);
+	void *base = priv->regbase;
+	u8 opcode_rdid = 0x9F;
+	unsigned int idcode = 0, temp = 0;
+	int err = 0, i, range_lo = -1, range_hi = -1;
+
+	/* start with slowest clock (1 MHz) */
+	cadence_spi_write_speed(bus, 1000000);
+
+	/* configure the read data capture delay register to 0 */
+	cadence_qspi_apb_readdata_capture(base, 1, 0);
+
+	/* Enable QSPI */
+	cadence_qspi_apb_controller_enable(base);
+
+	/* read the ID which will be our golden value */
+	err = cadence_qspi_apb_command_read(base, 1, &opcode_rdid,
+		3, (u8 *)&idcode);
+	if (err) {
+		puts("SF: Calibration failed (read)\n");
+		return err;
+	}
+
+	/* use back the intended clock and find low range */
+	cadence_spi_write_speed(bus, plat->max_hz);
+	for (i = 0; i < CQSPI_READ_CAPTURE_MAX_DELAY; i++) {
+		/* Disable QSPI */
+		cadence_qspi_apb_controller_disable(base);
+
+		/* reconfigure the read data capture delay register */
+		cadence_qspi_apb_readdata_capture(base, 1, i);
+
+		/* Enable back QSPI */
+		cadence_qspi_apb_controller_enable(base);
+
+		/* issue a RDID to get the ID value */
+		err = cadence_qspi_apb_command_read(base, 1, &opcode_rdid,
+			3, (u8 *)&temp);
+		if (err) {
+			puts("SF: Calibration failed (read)\n");
+			return err;
+		}
+
+		/* search for range lo */
+		if (range_lo == -1 && temp == idcode) {
+			range_lo = i;
+			continue;
+		}
+
+		/* search for range hi */
+		if (range_lo != -1 && temp != idcode) {
+			range_hi = i - 1;
+			break;
+		}
+		range_hi = i;
+	}
+
+	if (range_lo == -1) {
+		puts("SF: Calibration failed (low range)\n");
+		return err;
+	}
+
+	/* Disable QSPI for subsequent initialization */
+	cadence_qspi_apb_controller_disable(base);
+
+	/* configure the final value for read data capture delay register */
+	cadence_qspi_apb_readdata_capture(base, 1, (range_hi + range_lo) / 2);
+	debug("SF: Read data capture delay calibrated to %i (%i - %i)\n",
+	      (range_hi + range_lo) / 2, range_lo, range_hi);
+
+	/* just to ensure we do once only when speed or chip select change */
+	priv->qspi_calibrated_hz = plat->max_hz;
+	priv->qspi_calibrated_cs = spi_chip_select(bus);
+
+	return 0;
+}
+
+static int cadence_spi_set_speed(struct udevice *bus, uint hz)
+{
+	struct cadence_spi_platdata *plat = bus->platdata;
+	struct cadence_spi_priv *priv = dev_get_priv(bus);
+	int err;
+
+	/* Disable QSPI */
+	cadence_qspi_apb_controller_disable(priv->regbase);
+
+	cadence_spi_write_speed(bus, hz);
+
+	/* Calibration required for different SCLK speed or chip select */
+	if (priv->qspi_calibrated_hz != plat->max_hz ||
+	    priv->qspi_calibrated_cs != spi_chip_select(bus)) {
+		err = spi_calibration(bus);
+		if (err)
+			return err;
+	}
+
+	/* Enable QSPI */
+	cadence_qspi_apb_controller_enable(priv->regbase);
+
+	debug("%s: speed=%d\n", __func__, hz);
+
+	return 0;
+}
+
+static int cadence_spi_probe(struct udevice *bus)
+{
+	struct cadence_spi_platdata *plat = bus->platdata;
+	struct cadence_spi_priv *priv = dev_get_priv(bus);
+
+	priv->regbase = plat->regbase;
+	priv->ahbbase = plat->ahbbase;
+
+	if (!priv->qspi_is_init) {
+		cadence_qspi_apb_controller_init(plat);
+		priv->qspi_is_init = 1;
+	}
+
+	return 0;
+}
+
+static int cadence_spi_set_mode(struct udevice *bus, uint mode)
+{
+	struct cadence_spi_priv *priv = dev_get_priv(bus);
+	unsigned int clk_pol = (mode & SPI_CPOL) ? 1 : 0;
+	unsigned int clk_pha = (mode & SPI_CPHA) ? 1 : 0;
+
+	/* Disable QSPI */
+	cadence_qspi_apb_controller_disable(priv->regbase);
+
+	/* Set SPI mode */
+	cadence_qspi_apb_set_clk_mode(priv->regbase, clk_pol, clk_pha);
+
+	/* Enable QSPI */
+	cadence_qspi_apb_controller_enable(priv->regbase);
+
+	return 0;
+}
+
+static int cadence_spi_xfer(struct udevice *dev, unsigned int bitlen,
+			    const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev->parent;
+	struct cadence_spi_platdata *plat = bus->platdata;
+	struct cadence_spi_priv *priv = dev_get_priv(bus);
+	void *base = priv->regbase;
+	u8 *cmd_buf = priv->cmd_buf;
+	size_t data_bytes;
+	int err = 0;
+	u32 mode = CQSPI_STIG_WRITE;
+
+	if (flags & SPI_XFER_BEGIN) {
+		/* copy command to local buffer */
+		priv->cmd_len = bitlen / 8;
+		memcpy(cmd_buf, dout, priv->cmd_len);
+	}
+
+	if (flags == (SPI_XFER_BEGIN | SPI_XFER_END)) {
+		/* if start and end bit are set, the data bytes is 0. */
+		data_bytes = 0;
+	} else {
+		data_bytes = bitlen / 8;
+	}
+	debug("%s: len=%d [bytes]\n", __func__, data_bytes);
+
+	/* Set Chip select */
+	cadence_qspi_apb_chipselect(base, spi_chip_select(dev),
+				    CONFIG_CQSPI_DECODER);
+
+	if ((flags & SPI_XFER_END) || (flags == 0)) {
+		if (priv->cmd_len == 0) {
+			printf("QSPI: Error, command is empty.\n");
+			return -1;
+		}
+
+		if (din && data_bytes) {
+			/* read */
+			/* Use STIG if no address. */
+			if (!CQSPI_IS_ADDR(priv->cmd_len))
+				mode = CQSPI_STIG_READ;
+			else
+				mode = CQSPI_INDIRECT_READ;
+		} else if (dout && !(flags & SPI_XFER_BEGIN)) {
+			/* write */
+			if (!CQSPI_IS_ADDR(priv->cmd_len))
+				mode = CQSPI_STIG_WRITE;
+			else
+				mode = CQSPI_INDIRECT_WRITE;
+		}
+
+		switch (mode) {
+		case CQSPI_STIG_READ:
+			err = cadence_qspi_apb_command_read(
+				base, priv->cmd_len, cmd_buf,
+				data_bytes, din);
+
+		break;
+		case CQSPI_STIG_WRITE:
+			err = cadence_qspi_apb_command_write(base,
+				priv->cmd_len, cmd_buf,
+				data_bytes, dout);
+		break;
+		case CQSPI_INDIRECT_READ:
+			err = cadence_qspi_apb_indirect_read_setup(plat,
+				priv->cmd_len, cmd_buf);
+			if (!err) {
+				err = cadence_qspi_apb_indirect_read_execute
+				(plat, data_bytes, din);
+			}
+		break;
+		case CQSPI_INDIRECT_WRITE:
+			err = cadence_qspi_apb_indirect_write_setup
+				(plat, priv->cmd_len, cmd_buf);
+			if (!err) {
+				err = cadence_qspi_apb_indirect_write_execute
+				(plat, data_bytes, dout);
+			}
+		break;
+		default:
+			err = -1;
+			break;
+		}
+
+		if (flags & SPI_XFER_END) {
+			/* clear command buffer */
+			memset(cmd_buf, 0, sizeof(priv->cmd_buf));
+			priv->cmd_len = 0;
+		}
+	}
+
+	return err;
+}
+
+static int cadence_spi_ofdata_to_platdata(struct udevice *bus)
+{
+	struct cadence_spi_platdata *plat = bus->platdata;
+	const void *blob = gd->fdt_blob;
+	int node = bus->of_offset;
+	int subnode;
+	u32 data[4];
+	int ret;
+
+	/* 2 base addresses are needed, lets get them from the DT */
+	ret = fdtdec_get_int_array(blob, node, "reg", data, ARRAY_SIZE(data));
+	if (ret) {
+		printf("Error: Can't get base addresses (ret=%d)!\n", ret);
+		return -ENODEV;
+	}
+
+	plat->regbase = (void *)data[0];
+	plat->ahbbase = (void *)data[2];
+
+	/* Use 500KHz as a suitable default */
+	plat->max_hz = fdtdec_get_int(blob, node, "spi-max-frequency",
+				      500000);
+
+	/* All other paramters are embedded in the child node */
+	subnode = fdt_first_subnode(blob, node);
+	if (!subnode) {
+		printf("Error: subnode with SPI flash config missing!\n");
+		return -ENODEV;
+	}
+
+	/* Read other parameters from DT */
+	plat->page_size = fdtdec_get_int(blob, subnode, "page-size", 256);
+	plat->block_size = fdtdec_get_int(blob, subnode, "block-size", 16);
+	plat->tshsl_ns = fdtdec_get_int(blob, subnode, "tshsl-ns", 200);
+	plat->tsd2d_ns = fdtdec_get_int(blob, subnode, "tsd2d-ns", 255);
+	plat->tchsh_ns = fdtdec_get_int(blob, subnode, "tchsh-ns", 20);
+	plat->tslch_ns = fdtdec_get_int(blob, subnode, "tslch-ns", 20);
+
+	debug("%s: regbase=%p ahbbase=%p max-frequency=%d page-size=%d\n",
+	      __func__, plat->regbase, plat->ahbbase, plat->max_hz,
+	      plat->page_size);
+
+	return 0;
+}
+
+static const struct dm_spi_ops cadence_spi_ops = {
+	.xfer		= cadence_spi_xfer,
+	.set_speed	= cadence_spi_set_speed,
+	.set_mode	= cadence_spi_set_mode,
+	/*
+	 * cs_info is not needed, since we require all chip selects to be
+	 * in the device tree explicitly
+	 */
+};
+
+static const struct udevice_id cadence_spi_ids[] = {
+	{ .compatible = "cadence,qspi" },
+	{ }
+};
+
+U_BOOT_DRIVER(cadence_spi) = {
+	.name = "cadence_spi",
+	.id = UCLASS_SPI,
+	.of_match = cadence_spi_ids,
+	.ops = &cadence_spi_ops,
+	.ofdata_to_platdata = cadence_spi_ofdata_to_platdata,
+	.platdata_auto_alloc_size = sizeof(struct cadence_spi_platdata),
+	.priv_auto_alloc_size = sizeof(struct cadence_spi_priv),
+	.per_child_auto_alloc_size = sizeof(struct spi_slave),
+	.probe = cadence_spi_probe,
+};
diff -ruN u-boot-2015.01-rc3/drivers/spi/cadence_qspi.h u-boot/drivers/spi/cadence_qspi.h
--- u-boot-2015.01-rc3/drivers/spi/cadence_qspi.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/spi/cadence_qspi.h	2015-01-01 17:34:32.701495908 +0100
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2012
+ * Altera Corporation <www.altera.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CADENCE_QSPI_H__
+#define __CADENCE_QSPI_H__
+
+#define CQSPI_IS_ADDR(cmd_len)		(cmd_len > 1 ? 1 : 0)
+
+#define CQSPI_NO_DECODER_MAX_CS		4
+#define CQSPI_DECODER_MAX_CS		16
+#define CQSPI_READ_CAPTURE_MAX_DELAY	16
+
+struct cadence_spi_platdata {
+	unsigned int	max_hz;
+	void		*regbase;
+	void		*ahbbase;
+
+	u32		page_size;
+	u32		block_size;
+	u32		tshsl_ns;
+	u32		tsd2d_ns;
+	u32		tchsh_ns;
+	u32		tslch_ns;
+};
+
+struct cadence_spi_priv {
+	void		*regbase;
+	void		*ahbbase;
+	size_t		cmd_len;
+	u8		cmd_buf[32];
+	size_t		data_len;
+
+	int		qspi_is_init;
+	unsigned int	qspi_calibrated_hz;
+	unsigned int	qspi_calibrated_cs;
+};
+
+/* Functions call declaration */
+void cadence_qspi_apb_controller_init(struct cadence_spi_platdata *plat);
+void cadence_qspi_apb_controller_enable(void *reg_base_addr);
+void cadence_qspi_apb_controller_disable(void *reg_base_addr);
+
+int cadence_qspi_apb_command_read(void *reg_base_addr,
+	unsigned int cmdlen, const u8 *cmdbuf, unsigned int rxlen, u8 *rxbuf);
+int cadence_qspi_apb_command_write(void *reg_base_addr,
+	unsigned int cmdlen, const u8 *cmdbuf,
+	unsigned int txlen,  const u8 *txbuf);
+
+int cadence_qspi_apb_indirect_read_setup(struct cadence_spi_platdata *plat,
+	unsigned int cmdlen, const u8 *cmdbuf);
+int cadence_qspi_apb_indirect_read_execute(struct cadence_spi_platdata *plat,
+	unsigned int rxlen, u8 *rxbuf);
+int cadence_qspi_apb_indirect_write_setup(struct cadence_spi_platdata *plat,
+	unsigned int cmdlen, const u8 *cmdbuf);
+int cadence_qspi_apb_indirect_write_execute(struct cadence_spi_platdata *plat,
+	unsigned int txlen, const u8 *txbuf);
+
+void cadence_qspi_apb_chipselect(void *reg_base,
+	unsigned int chip_select, unsigned int decoder_enable);
+void cadence_qspi_apb_set_clk_mode(void *reg_base_addr,
+	unsigned int clk_pol, unsigned int clk_pha);
+void cadence_qspi_apb_config_baudrate_div(void *reg_base,
+	unsigned int ref_clk_hz, unsigned int sclk_hz);
+void cadence_qspi_apb_delay(void *reg_base,
+	unsigned int ref_clk, unsigned int sclk_hz,
+	unsigned int tshsl_ns, unsigned int tsd2d_ns,
+	unsigned int tchsh_ns, unsigned int tslch_ns);
+void cadence_qspi_apb_enter_xip(void *reg_base, char xip_dummy);
+void cadence_qspi_apb_readdata_capture(void *reg_base,
+	unsigned int bypass, unsigned int delay);
+
+#endif /* __CADENCE_QSPI_H__ */
diff -ruN u-boot-2015.01-rc3/drivers/spi/designware_spi.c u-boot/drivers/spi/designware_spi.c
--- u-boot-2015.01-rc3/drivers/spi/designware_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/spi/designware_spi.c	2015-01-01 17:34:32.701495908 +0100
@@ -0,0 +1,426 @@
+/*
+ * Designware master SPI core controller driver
+ *
+ * Copyright (C) 2014 Stefan Roese <sr@denx.de>
+ *
+ * Very loosely based on the Linux driver:
+ * drivers/spi/spi-dw.c, which is:
+ * Copyright (c) 2009, Intel Corporation.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <malloc.h>
+#include <spi.h>
+#include <fdtdec.h>
+#include <linux/compat.h>
+#include <asm/io.h>
+#include <asm/arch/clock_manager.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* Register offsets */
+#define DW_SPI_CTRL0			0x00
+#define DW_SPI_CTRL1			0x04
+#define DW_SPI_SSIENR			0x08
+#define DW_SPI_MWCR			0x0c
+#define DW_SPI_SER			0x10
+#define DW_SPI_BAUDR			0x14
+#define DW_SPI_TXFLTR			0x18
+#define DW_SPI_RXFLTR			0x1c
+#define DW_SPI_TXFLR			0x20
+#define DW_SPI_RXFLR			0x24
+#define DW_SPI_SR			0x28
+#define DW_SPI_IMR			0x2c
+#define DW_SPI_ISR			0x30
+#define DW_SPI_RISR			0x34
+#define DW_SPI_TXOICR			0x38
+#define DW_SPI_RXOICR			0x3c
+#define DW_SPI_RXUICR			0x40
+#define DW_SPI_MSTICR			0x44
+#define DW_SPI_ICR			0x48
+#define DW_SPI_DMACR			0x4c
+#define DW_SPI_DMATDLR			0x50
+#define DW_SPI_DMARDLR			0x54
+#define DW_SPI_IDR			0x58
+#define DW_SPI_VERSION			0x5c
+#define DW_SPI_DR			0x60
+
+/* Bit fields in CTRLR0 */
+#define SPI_DFS_OFFSET			0
+
+#define SPI_FRF_OFFSET			4
+#define SPI_FRF_SPI			0x0
+#define SPI_FRF_SSP			0x1
+#define SPI_FRF_MICROWIRE		0x2
+#define SPI_FRF_RESV			0x3
+
+#define SPI_MODE_OFFSET			6
+#define SPI_SCPH_OFFSET			6
+#define SPI_SCOL_OFFSET			7
+
+#define SPI_TMOD_OFFSET			8
+#define SPI_TMOD_MASK			(0x3 << SPI_TMOD_OFFSET)
+#define	SPI_TMOD_TR			0x0		/* xmit & recv */
+#define SPI_TMOD_TO			0x1		/* xmit only */
+#define SPI_TMOD_RO			0x2		/* recv only */
+#define SPI_TMOD_EPROMREAD		0x3		/* eeprom read mode */
+
+#define SPI_SLVOE_OFFSET		10
+#define SPI_SRL_OFFSET			11
+#define SPI_CFS_OFFSET			12
+
+/* Bit fields in SR, 7 bits */
+#define SR_MASK				0x7f		/* cover 7 bits */
+#define SR_BUSY				(1 << 0)
+#define SR_TF_NOT_FULL			(1 << 1)
+#define SR_TF_EMPT			(1 << 2)
+#define SR_RF_NOT_EMPT			(1 << 3)
+#define SR_RF_FULL			(1 << 4)
+#define SR_TX_ERR			(1 << 5)
+#define SR_DCOL				(1 << 6)
+
+#define RX_TIMEOUT			1000		/* timeout in ms */
+
+struct dw_spi_platdata {
+	s32 frequency;		/* Default clock frequency, -1 for none */
+	void __iomem *regs;
+};
+
+struct dw_spi_priv {
+	void __iomem *regs;
+	unsigned int freq;		/* Default frequency */
+	unsigned int mode;
+
+	int bits_per_word;
+	u8 cs;			/* chip select pin */
+	u8 tmode;		/* TR/TO/RO/EEPROM */
+	u8 type;		/* SPI/SSP/MicroWire */
+	int len;
+
+	u32 fifo_len;		/* depth of the FIFO buffer */
+	void *tx;
+	void *tx_end;
+	void *rx;
+	void *rx_end;
+};
+
+static inline u32 dw_readl(struct dw_spi_priv *priv, u32 offset)
+{
+	return __raw_readl(priv->regs + offset);
+}
+
+static inline void dw_writel(struct dw_spi_priv *priv, u32 offset, u32 val)
+{
+	__raw_writel(val, priv->regs + offset);
+}
+
+static inline u16 dw_readw(struct dw_spi_priv *priv, u32 offset)
+{
+	return __raw_readw(priv->regs + offset);
+}
+
+static inline void dw_writew(struct dw_spi_priv *priv, u32 offset, u16 val)
+{
+	__raw_writew(val, priv->regs + offset);
+}
+
+static int dw_spi_ofdata_to_platdata(struct udevice *bus)
+{
+	struct dw_spi_platdata *plat = bus->platdata;
+	const void *blob = gd->fdt_blob;
+	int node = bus->of_offset;
+
+	plat->regs = (struct dw_spi *)fdtdec_get_addr(blob, node, "reg");
+
+	/* Use 500KHz as a suitable default */
+	plat->frequency = fdtdec_get_int(blob, node, "spi-max-frequency",
+					500000);
+	debug("%s: regs=%p max-frequency=%d\n", __func__, plat->regs,
+	      plat->frequency);
+
+	return 0;
+}
+
+static inline void spi_enable_chip(struct dw_spi_priv *priv, int enable)
+{
+	dw_writel(priv, DW_SPI_SSIENR, (enable ? 1 : 0));
+}
+
+/* Restart the controller, disable all interrupts, clean rx fifo */
+static void spi_hw_init(struct dw_spi_priv *priv)
+{
+	spi_enable_chip(priv, 0);
+	dw_writel(priv, DW_SPI_IMR, 0xff);
+	spi_enable_chip(priv, 1);
+
+	/*
+	 * Try to detect the FIFO depth if not set by interface driver,
+	 * the depth could be from 2 to 256 from HW spec
+	 */
+	if (!priv->fifo_len) {
+		u32 fifo;
+
+		for (fifo = 2; fifo <= 257; fifo++) {
+			dw_writew(priv, DW_SPI_TXFLTR, fifo);
+			if (fifo != dw_readw(priv, DW_SPI_TXFLTR))
+				break;
+		}
+
+		priv->fifo_len = (fifo == 257) ? 0 : fifo;
+		dw_writew(priv, DW_SPI_TXFLTR, 0);
+	}
+	debug("%s: fifo_len=%d\n", __func__, priv->fifo_len);
+}
+
+static int dw_spi_probe(struct udevice *bus)
+{
+	struct dw_spi_platdata *plat = dev_get_platdata(bus);
+	struct dw_spi_priv *priv = dev_get_priv(bus);
+
+	priv->regs = plat->regs;
+	priv->freq = plat->frequency;
+
+	/* Currently only bits_per_word == 8 supported */
+	priv->bits_per_word = 8;
+
+	priv->tmode = 0; /* Tx & Rx */
+
+	/* Basic HW init */
+	spi_hw_init(priv);
+
+	return 0;
+}
+
+/* Return the max entries we can fill into tx fifo */
+static inline u32 tx_max(struct dw_spi_priv *priv)
+{
+	u32 tx_left, tx_room, rxtx_gap;
+
+	tx_left = (priv->tx_end - priv->tx) / (priv->bits_per_word >> 3);
+	tx_room = priv->fifo_len - dw_readw(priv, DW_SPI_TXFLR);
+
+	/*
+	 * Another concern is about the tx/rx mismatch, we
+	 * thought about using (priv->fifo_len - rxflr - txflr) as
+	 * one maximum value for tx, but it doesn't cover the
+	 * data which is out of tx/rx fifo and inside the
+	 * shift registers. So a control from sw point of
+	 * view is taken.
+	 */
+	rxtx_gap = ((priv->rx_end - priv->rx) - (priv->tx_end - priv->tx)) /
+		(priv->bits_per_word >> 3);
+
+	return min3(tx_left, tx_room, (u32)(priv->fifo_len - rxtx_gap));
+}
+
+/* Return the max entries we should read out of rx fifo */
+static inline u32 rx_max(struct dw_spi_priv *priv)
+{
+	u32 rx_left = (priv->rx_end - priv->rx) / (priv->bits_per_word >> 3);
+
+	return min_t(u32, rx_left, dw_readw(priv, DW_SPI_RXFLR));
+}
+
+static void dw_writer(struct dw_spi_priv *priv)
+{
+	u32 max = tx_max(priv);
+	u16 txw = 0;
+
+	while (max--) {
+		/* Set the tx word if the transfer's original "tx" is not null */
+		if (priv->tx_end - priv->len) {
+			if (priv->bits_per_word == 8)
+				txw = *(u8 *)(priv->tx);
+			else
+				txw = *(u16 *)(priv->tx);
+		}
+		dw_writew(priv, DW_SPI_DR, txw);
+		debug("%s: tx=0x%02x\n", __func__, txw);
+		priv->tx += priv->bits_per_word >> 3;
+	}
+}
+
+static int dw_reader(struct dw_spi_priv *priv)
+{
+	unsigned start = get_timer(0);
+	u32 max;
+	u16 rxw;
+
+	/* Wait for rx data to be ready */
+	while (rx_max(priv) == 0) {
+		if (get_timer(start) > RX_TIMEOUT)
+			return -ETIMEDOUT;
+	}
+
+	max = rx_max(priv);
+
+	while (max--) {
+		rxw = dw_readw(priv, DW_SPI_DR);
+		debug("%s: rx=0x%02x\n", __func__, rxw);
+
+		/*
+		 * Care about rx only if the transfer's original "rx" is
+		 * not null
+		 */
+		if (priv->rx_end - priv->len) {
+			if (priv->bits_per_word == 8)
+				*(u8 *)(priv->rx) = rxw;
+			else
+				*(u16 *)(priv->rx) = rxw;
+		}
+		priv->rx += priv->bits_per_word >> 3;
+	}
+
+	return 0;
+}
+
+static int poll_transfer(struct dw_spi_priv *priv)
+{
+	int ret;
+
+	do {
+		dw_writer(priv);
+		ret = dw_reader(priv);
+		if (ret < 0)
+			return ret;
+	} while (priv->rx_end > priv->rx);
+
+	return 0;
+}
+
+static int dw_spi_xfer(struct udevice *dev, unsigned int bitlen,
+		       const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev->parent;
+	struct dw_spi_priv *priv = dev_get_priv(bus);
+	const u8 *tx = dout;
+	u8 *rx = din;
+	int ret = 0;
+	u32 cr0 = 0;
+	u32 cs;
+
+	/* spi core configured to do 8 bit transfers */
+	if (bitlen % 8) {
+		debug("Non byte aligned SPI transfer.\n");
+		return -1;
+	}
+
+	cr0 = (priv->bits_per_word - 1) | (priv->type << SPI_FRF_OFFSET) |
+		(priv->mode << SPI_MODE_OFFSET) |
+		(priv->tmode << SPI_TMOD_OFFSET);
+
+	if (rx && tx)
+		priv->tmode = SPI_TMOD_TR;
+	else if (rx)
+		priv->tmode = SPI_TMOD_RO;
+	else
+		priv->tmode = SPI_TMOD_TO;
+
+	cr0 &= ~SPI_TMOD_MASK;
+	cr0 |= (priv->tmode << SPI_TMOD_OFFSET);
+
+	priv->len = bitlen >> 3;
+	debug("%s: rx=%p tx=%p len=%d [bytes]\n", __func__, rx, tx, priv->len);
+
+	priv->tx = (void *)tx;
+	priv->tx_end = priv->tx + priv->len;
+	priv->rx = rx;
+	priv->rx_end = priv->rx + priv->len;
+
+	/* Disable controller before writing control registers */
+	spi_enable_chip(priv, 0);
+
+	debug("%s: cr0=%08x\n", __func__, cr0);
+	/* Reprogram cr0 only if changed */
+	if (dw_readw(priv, DW_SPI_CTRL0) != cr0)
+		dw_writew(priv, DW_SPI_CTRL0, cr0);
+
+	/*
+	 * Configure the desired SS (slave select 0...3) in the controller
+	 * The DW SPI controller will activate and deactivate this CS
+	 * automatically. So no cs_activate() etc is needed in this driver.
+	 */
+	cs = spi_chip_select(dev);
+	dw_writel(priv, DW_SPI_SER, 1 << cs);
+
+	/* Enable controller after writing control registers */
+	spi_enable_chip(priv, 1);
+
+	/* Start transfer in a polling loop */
+	ret = poll_transfer(priv);
+
+	return ret;
+}
+
+static int dw_spi_set_speed(struct udevice *bus, uint speed)
+{
+	struct dw_spi_platdata *plat = bus->platdata;
+	struct dw_spi_priv *priv = dev_get_priv(bus);
+	u16 clk_div;
+
+	if (speed > plat->frequency)
+		speed = plat->frequency;
+
+	/* Disable controller before writing control registers */
+	spi_enable_chip(priv, 0);
+
+	/* clk_div doesn't support odd number */
+	clk_div = cm_get_spi_controller_clk_hz() / speed;
+	clk_div = (clk_div + 1) & 0xfffe;
+	dw_writel(priv, DW_SPI_BAUDR, clk_div);
+
+	/* Enable controller after writing control registers */
+	spi_enable_chip(priv, 1);
+
+	priv->freq = speed;
+	debug("%s: regs=%p speed=%d clk_div=%d\n", __func__, priv->regs,
+	      priv->freq, clk_div);
+
+	return 0;
+}
+
+static int dw_spi_set_mode(struct udevice *bus, uint mode)
+{
+	struct dw_spi_priv *priv = dev_get_priv(bus);
+
+	/*
+	 * Can't set mode yet. Since this depends on if rx, tx, or
+	 * rx & tx is requested. So we have to defer this to the
+	 * real transfer function.
+	 */
+	priv->mode = mode;
+	debug("%s: regs=%p, mode=%d\n", __func__, priv->regs, priv->mode);
+
+	return 0;
+}
+
+static const struct dm_spi_ops dw_spi_ops = {
+	.xfer		= dw_spi_xfer,
+	.set_speed	= dw_spi_set_speed,
+	.set_mode	= dw_spi_set_mode,
+	/*
+	 * cs_info is not needed, since we require all chip selects to be
+	 * in the device tree explicitly
+	 */
+};
+
+static const struct udevice_id dw_spi_ids[] = {
+	{ .compatible = "snps,dw-spi-mmio" },
+	{ }
+};
+
+U_BOOT_DRIVER(dw_spi) = {
+	.name = "dw_spi",
+	.id = UCLASS_SPI,
+	.of_match = dw_spi_ids,
+	.ops = &dw_spi_ops,
+	.ofdata_to_platdata = dw_spi_ofdata_to_platdata,
+	.platdata_auto_alloc_size = sizeof(struct dw_spi_platdata),
+	.priv_auto_alloc_size = sizeof(struct dw_spi_priv),
+	.per_child_auto_alloc_size = sizeof(struct spi_slave),
+	.probe = dw_spi_probe,
+};
diff -ruN u-boot-2015.01-rc3/drivers/spi/ich.c u-boot/drivers/spi/ich.c
--- u-boot-2015.01-rc3/drivers/spi/ich.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/spi/ich.c	2015-01-01 17:34:32.701495908 +0100
@@ -141,6 +141,15 @@
 	ich->slave.max_write_size = ctlr.databytes;
 	ich->speed = max_hz;
 
+	/*
+	 * ICH 7 SPI controller only supports array read command
+	 * and byte program command for SST flash
+	 */
+	if (ctlr.ich_version == 7) {
+		ich->slave.op_mode_rx = SPI_OPM_RX_AS;
+		ich->slave.op_mode_tx = SPI_OPM_TX_BP;
+	}
+
 	return &ich->slave;
 }
 
@@ -158,7 +167,8 @@
  */
 static int get_ich_version(uint16_t device_id)
 {
-	if (device_id == PCI_DEVICE_ID_INTEL_TGP_LPC)
+	if (device_id == PCI_DEVICE_ID_INTEL_TGP_LPC ||
+	    device_id == PCI_DEVICE_ID_INTEL_ITC_LPC)
 		return 7;
 
 	if ((device_id >= PCI_DEVICE_ID_INTEL_COUGARPOINT_LPC_MIN &&
@@ -483,8 +493,6 @@
 	struct spi_trans *trans = &ich->trans;
 	unsigned type = flags & (SPI_XFER_BEGIN | SPI_XFER_END);
 	int using_cmd = 0;
-	/* Align read transactions to 64-byte boundaries */
-	char buff[ctlr.databytes];
 
 	/* Ee don't support writing partial bytes. */
 	if (bitlen % 8) {
@@ -632,14 +640,9 @@
 	 */
 	while (trans->bytesout || trans->bytesin) {
 		uint32_t data_length;
-		uint32_t aligned_offset;
-		uint32_t diff;
-
-		aligned_offset = trans->offset & ~(ctlr.databytes - 1);
-		diff = trans->offset - aligned_offset;
 
 		/* SPI addresses are 24 bit only */
-		ich_writel(aligned_offset & 0x00FFFFFF, ctlr.addr);
+		ich_writel(trans->offset & 0x00FFFFFF, ctlr.addr);
 
 		if (trans->bytesout)
 			data_length = min(trans->bytesout, ctlr.databytes);
@@ -673,13 +676,7 @@
 		}
 
 		if (trans->bytesin) {
-			if (diff) {
-				data_length -= diff;
-				read_reg(ctlr.data, buff, ctlr.databytes);
-				memcpy(trans->in, buff + diff, data_length);
-			} else {
-				read_reg(ctlr.data, trans->in, data_length);
-			}
+			read_reg(ctlr.data, trans->in, data_length);
 			spi_use_in(trans, data_length);
 			if (with_address)
 				trans->offset += data_length;
diff -ruN u-boot-2015.01-rc3/drivers/spi/Makefile u-boot/drivers/spi/Makefile
--- u-boot-2015.01-rc3/drivers/spi/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/spi/Makefile	2015-01-01 17:34:32.701495908 +0100
@@ -23,9 +23,11 @@
 obj-$(CONFIG_ATMEL_SPI) += atmel_spi.o
 obj-$(CONFIG_BFIN_SPI) += bfin_spi.o
 obj-$(CONFIG_BFIN_SPI6XX) += bfin_spi6xx.o
+obj-$(CONFIG_CADENCE_QSPI) += cadence_qspi.o cadence_qspi_apb.o
 obj-$(CONFIG_CF_SPI) += cf_spi.o
 obj-$(CONFIG_CF_QSPI) += cf_qspi.o
 obj-$(CONFIG_DAVINCI_SPI) += davinci_spi.o
+obj-$(CONFIG_DESIGNWARE_SPI) += designware_spi.o
 obj-$(CONFIG_EXYNOS_SPI) += exynos_spi.o
 obj-$(CONFIG_FTSSP010_SPI) += ftssp010_spi.o
 obj-$(CONFIG_ICH_SPI) +=  ich.o
diff -ruN u-boot-2015.01-rc3/drivers/thermal/imx_thermal.c u-boot/drivers/thermal/imx_thermal.c
--- u-boot-2015.01-rc3/drivers/thermal/imx_thermal.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/thermal/imx_thermal.c	2015-01-01 17:34:32.705495842 +0100
@@ -156,8 +156,6 @@
 	if (fuse == 0 || fuse == ~0) {
 		printf("CPU:   Thermal invalid data, fuse: 0x%x\n", fuse);
 		return -EPERM;
-	} else {
-		printf("CPU:   Thermal calibration data: 0x%x\n", fuse);
 	}
 
 	*priv = fuse;
diff -ruN u-boot-2015.01-rc3/drivers/usb/gadget/atmel_usba_udc.c u-boot/drivers/usb/gadget/atmel_usba_udc.c
--- u-boot-2015.01-rc3/drivers/usb/gadget/atmel_usba_udc.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/usb/gadget/atmel_usba_udc.c	2015-01-01 17:34:32.709495776 +0100
@@ -1062,7 +1062,6 @@
 	if ((epstatus & epctrl) & USBA_RX_BK_RDY) {
 		DBG(DBG_BUS, "%s: RX data ready\n", ep->ep.name);
 		receive_data(ep);
-		usba_ep_writel(ep, CLR_STA, USBA_RX_BK_RDY);
 	}
 }
 
diff -ruN u-boot-2015.01-rc3/drivers/usb/gadget/ether.c u-boot/drivers/usb/gadget/ether.c
--- u-boot-2015.01-rc3/drivers/usb/gadget/ether.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/usb/gadget/ether.c	2015-01-01 17:34:32.709495776 +0100
@@ -852,30 +852,6 @@
 DEFINE_CACHE_ALIGN_BUFFER(u8, status_req, STATUS_BYTECOUNT);
 #endif
 
-
-/**
- * strlcpy - Copy a %NUL terminated string into a sized buffer
- * @dest: Where to copy the string to
- * @src: Where to copy the string from
- * @size: size of destination buffer
- *
- * Compatible with *BSD: the result is always a valid
- * NUL-terminated string that fits in the buffer (unless,
- * of course, the buffer size is zero). It does not pad
- * out the result like strncpy() does.
- */
-size_t strlcpy(char *dest, const char *src, size_t size)
-{
-	size_t ret = strlen(src);
-
-	if (size) {
-		size_t len = (ret >= size) ? size - 1 : ret;
-		memcpy(dest, src, len);
-		dest[len] = '\0';
-	}
-	return ret;
-}
-
 /*============================================================================*/
 
 /*
diff -ruN u-boot-2015.01-rc3/drivers/usb/gadget/f_dfu.c u-boot/drivers/usb/gadget/f_dfu.c
--- u-boot-2015.01-rc3/drivers/usb/gadget/f_dfu.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/usb/gadget/f_dfu.c	2015-01-01 17:34:32.709495776 +0100
@@ -366,7 +366,7 @@
 		to_runtime_mode(f_dfu);
 		f_dfu->dfu_state = DFU_STATE_appIDLE;
 
-		dfu_trigger_detach();
+		g_dnl_trigger_detach();
 		break;
 	default:
 		f_dfu->dfu_state = DFU_STATE_dfuERROR;
diff -ruN u-boot-2015.01-rc3/drivers/usb/gadget/f_fastboot.c u-boot/drivers/usb/gadget/f_fastboot.c
--- u-boot-2015.01-rc3/drivers/usb/gadget/f_fastboot.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/usb/gadget/f_fastboot.c	2015-01-01 17:34:32.709495776 +0100
@@ -480,6 +480,17 @@
 	fastboot_tx_write_str("OKAY");
 }
 
+static void do_exit_on_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	g_dnl_trigger_detach();
+}
+
+static void cb_continue(struct usb_ep *ep, struct usb_request *req)
+{
+	fastboot_func->in_req->complete = do_exit_on_complete;
+	fastboot_tx_write_str("OKAY");
+}
+
 #ifdef CONFIG_FASTBOOT_FLASH
 static void cb_flash(struct usb_ep *ep, struct usb_request *req)
 {
@@ -520,6 +531,9 @@
 	}, {
 		.cmd = "boot",
 		.cb = cb_boot,
+	}, {
+		.cmd = "continue",
+		.cb = cb_continue,
 	},
 #ifdef CONFIG_FASTBOOT_FLASH
 	{
diff -ruN u-boot-2015.01-rc3/drivers/usb/gadget/f_thor.c u-boot/drivers/usb/gadget/f_thor.c
--- u-boot-2015.01-rc3/drivers/usb/gadget/f_thor.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/usb/gadget/f_thor.c	2015-01-01 17:34:32.709495776 +0100
@@ -205,12 +205,24 @@
 
 static int download_tail(long long int left, int cnt)
 {
-	struct dfu_entity *dfu_entity = dfu_get_entity(alt_setting_num);
-	void *transfer_buffer = dfu_get_buf(dfu_entity);
+	struct dfu_entity *dfu_entity;
+	void *transfer_buffer;
 	int ret;
 
 	debug("%s: left: %llu cnt: %d\n", __func__, left, cnt);
 
+	dfu_entity = dfu_get_entity(alt_setting_num);
+	if (!dfu_entity) {
+		error("Alt setting: %d entity not found!\n", alt_setting_num);
+		return -ENOENT;
+	}
+
+	transfer_buffer = dfu_get_buf(dfu_entity);
+	if (!transfer_buffer) {
+		error("Transfer buffer not allocated!");
+		return -ENXIO;
+	}
+
 	if (left) {
 		ret = dfu_write(dfu_entity, transfer_buffer, left, cnt++);
 		if (ret) {
diff -ruN u-boot-2015.01-rc3/drivers/usb/gadget/g_dnl.c u-boot/drivers/usb/gadget/g_dnl.c
--- u-boot-2015.01-rc3/drivers/usb/gadget/g_dnl.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/usb/gadget/g_dnl.c	2015-01-01 17:34:32.709495776 +0100
@@ -163,6 +163,23 @@
 	return -EOPNOTSUPP;
 }
 
+static bool g_dnl_detach_request;
+
+bool g_dnl_detach(void)
+{
+	return g_dnl_detach_request;
+}
+
+void g_dnl_trigger_detach(void)
+{
+	g_dnl_detach_request = true;
+}
+
+void g_dnl_clear_detach(void)
+{
+	g_dnl_detach_request = false;
+}
+
 static int g_dnl_get_bcd_device_number(struct usb_composite_dev *cdev)
 {
 	struct usb_gadget *gadget = cdev->gadget;
diff -ruN u-boot-2015.01-rc3/drivers/usb/host/ehci-fsl.c u-boot/drivers/usb/host/ehci-fsl.c
--- u-boot-2015.01-rc3/drivers/usb/host/ehci-fsl.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/usb/host/ehci-fsl.c	2015-01-01 17:34:32.713495710 +0100
@@ -15,9 +15,14 @@
 #include <usb/ehci-fsl.h>
 #include <hwconfig.h>
 #include <fsl_usb.h>
+#include <fdt_support.h>
 
 #include "ehci.h"
 
+#ifndef CONFIG_USB_MAX_CONTROLLER_COUNT
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+#endif
+
 static void set_txfifothresh(struct usb_ehci *, u32);
 
 /* Check USB PHY clock valid */
@@ -158,3 +163,184 @@
 	cmd |= TXFIFO_THRESH(txfifo_thresh);
 	ehci_writel(&ehci->txfilltuning, cmd);
 }
+
+#if defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_MPH_USB)
+static int fdt_fixup_usb_mode_phy_type(void *blob, const char *mode,
+				       const char *phy_type, int start_offset)
+{
+	const char *compat_dr = "fsl-usb2-dr";
+	const char *compat_mph = "fsl-usb2-mph";
+	const char *prop_mode = "dr_mode";
+	const char *prop_type = "phy_type";
+	const char *node_type = NULL;
+	int node_offset;
+	int err;
+
+	node_offset = fdt_node_offset_by_compatible(blob,
+						    start_offset, compat_mph);
+	if (node_offset < 0) {
+		node_offset = fdt_node_offset_by_compatible(blob,
+							    start_offset,
+							    compat_dr);
+		if (node_offset < 0) {
+			printf("WARNING: could not find compatible node: %s",
+			       fdt_strerror(node_offset));
+			return -1;
+		}
+		node_type = compat_dr;
+	} else {
+		node_type = compat_mph;
+	}
+
+	if (mode) {
+		err = fdt_setprop(blob, node_offset, prop_mode, mode,
+				  strlen(mode) + 1);
+		if (err < 0)
+			printf("WARNING: could not set %s for %s: %s.\n",
+			       prop_mode, node_type, fdt_strerror(err));
+	}
+
+	if (phy_type) {
+		err = fdt_setprop(blob, node_offset, prop_type, phy_type,
+				  strlen(phy_type) + 1);
+		if (err < 0)
+			printf("WARNING: could not set %s for %s: %s.\n",
+			       prop_type, node_type, fdt_strerror(err));
+	}
+
+	return node_offset;
+}
+
+static const char *fdt_usb_get_node_type(void *blob, int start_offset,
+					 int *node_offset)
+{
+	const char *compat_dr = "fsl-usb2-dr";
+	const char *compat_mph = "fsl-usb2-mph";
+	const char *node_type = NULL;
+
+	*node_offset = fdt_node_offset_by_compatible(blob, start_offset,
+						     compat_mph);
+	if (*node_offset < 0) {
+		*node_offset = fdt_node_offset_by_compatible(blob,
+							     start_offset,
+							     compat_dr);
+		if (*node_offset < 0) {
+			printf("ERROR: could not find compatible node: %s\n",
+			       fdt_strerror(*node_offset));
+		} else {
+			node_type = compat_dr;
+		}
+	} else {
+		node_type = compat_mph;
+	}
+
+	return node_type;
+}
+
+static int fdt_fixup_usb_erratum(void *blob, const char *prop_erratum,
+				 int start_offset)
+{
+	int node_offset, err;
+	const char *node_type = NULL;
+
+	node_type = fdt_usb_get_node_type(blob, start_offset, &node_offset);
+	if (!node_type)
+		return -1;
+
+	err = fdt_setprop(blob, node_offset, prop_erratum, NULL, 0);
+	if (err < 0) {
+		printf("ERROR: could not set %s for %s: %s.\n",
+		       prop_erratum, node_type, fdt_strerror(err));
+	}
+
+	return node_offset;
+}
+
+void fdt_fixup_dr_usb(void *blob, bd_t *bd)
+{
+	static const char * const modes[] = { "host", "peripheral", "otg" };
+	static const char * const phys[] = { "ulpi", "utmi" };
+	int usb_erratum_a006261_off = -1;
+	int usb_erratum_a007075_off = -1;
+	int usb_erratum_a007792_off = -1;
+	int usb_mode_off = -1;
+	int usb_phy_off = -1;
+	char str[5];
+	int i, j;
+
+	for (i = 1; i <= CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
+		const char *dr_mode_type = NULL;
+		const char *dr_phy_type = NULL;
+		int mode_idx = -1, phy_idx = -1;
+
+		snprintf(str, 5, "%s%d", "usb", i);
+		if (hwconfig(str)) {
+			for (j = 0; j < ARRAY_SIZE(modes); j++) {
+				if (hwconfig_subarg_cmp(str, "dr_mode",
+							modes[j])) {
+					mode_idx = j;
+					break;
+				}
+			}
+
+			for (j = 0; j < ARRAY_SIZE(phys); j++) {
+				if (hwconfig_subarg_cmp(str, "phy_type",
+							phys[j])) {
+					phy_idx = j;
+					break;
+				}
+			}
+
+			if (mode_idx < 0 && phy_idx < 0) {
+				printf("WARNING: invalid phy or mode\n");
+				return;
+			}
+
+			if (mode_idx > -1)
+				dr_mode_type = modes[mode_idx];
+
+			if (phy_idx > -1)
+				dr_phy_type = phys[phy_idx];
+		}
+
+		usb_mode_off = fdt_fixup_usb_mode_phy_type(blob,
+							   dr_mode_type, NULL,
+							   usb_mode_off);
+
+		if (usb_mode_off < 0)
+			return;
+
+		usb_phy_off = fdt_fixup_usb_mode_phy_type(blob,
+							  NULL, dr_phy_type,
+							  usb_phy_off);
+
+		if (usb_phy_off < 0)
+			return;
+
+		if (has_erratum_a006261()) {
+			usb_erratum_a006261_off =  fdt_fixup_usb_erratum
+						   (blob,
+						    "fsl,usb-erratum-a006261",
+						    usb_erratum_a006261_off);
+			if (usb_erratum_a006261_off < 0)
+				return;
+		}
+		if (has_erratum_a007075()) {
+			usb_erratum_a007075_off =  fdt_fixup_usb_erratum
+						   (blob,
+						    "fsl,usb-erratum-a007075",
+						    usb_erratum_a007075_off);
+			if (usb_erratum_a007075_off < 0)
+				return;
+		}
+		if (has_erratum_a007792()) {
+			usb_erratum_a007792_off =  fdt_fixup_usb_erratum
+						   (blob,
+						    "fsl,usb-erratum-a007792",
+						    usb_erratum_a007792_off);
+			if (usb_erratum_a007792_off < 0)
+				return;
+		}
+	}
+}
+#endif
diff -ruN u-boot-2015.01-rc3/drivers/usb/host/ehci-hcd.c u-boot/drivers/usb/host/ehci-hcd.c
--- u-boot-2015.01-rc3/drivers/usb/host/ehci-hcd.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/usb/host/ehci-hcd.c	2015-01-01 17:34:32.713495710 +0100
@@ -971,7 +971,6 @@
 	qh_list->qh_link = cpu_to_hc32((uint32_t)qh_list | QH_LINK_TYPE_QH);
 	qh_list->qh_endpt1 = cpu_to_hc32(QH_ENDPT1_H(1) |
 						QH_ENDPT1_EPS(USB_SPEED_HIGH));
-	qh_list->qh_curtd = cpu_to_hc32(QT_NEXT_TERMINATE);
 	qh_list->qh_overlay.qt_next = cpu_to_hc32(QT_NEXT_TERMINATE);
 	qh_list->qh_overlay.qt_altnext = cpu_to_hc32(QT_NEXT_TERMINATE);
 	qh_list->qh_overlay.qt_token =
diff -ruN u-boot-2015.01-rc3/drivers/usb/host/ehci-mx6.c u-boot/drivers/usb/host/ehci-mx6.c
--- u-boot-2015.01-rc3/drivers/usb/host/ehci-mx6.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/drivers/usb/host/ehci-mx6.c	2015-01-01 17:34:32.713495710 +0100
@@ -160,7 +160,7 @@
 	val |= (USBPHY_CTRL_ENUTMILEVEL2 | USBPHY_CTRL_ENUTMILEVEL3);
 	__raw_writel(val, phy_ctrl);
 
-	return val & USBPHY_CTRL_OTG_ID;
+	return 0;
 }
 
 /* Base address for this IP block is 0x02184800 */
@@ -193,6 +193,28 @@
 	__raw_writel(val, ctrl);
 }
 
+int usb_phy_mode(int port)
+{
+	void __iomem *phy_reg;
+	void __iomem *phy_ctrl;
+	u32 val;
+
+	phy_reg = (void __iomem *)phy_bases[port];
+	phy_ctrl = (void __iomem *)(phy_reg + USBPHY_CTRL);
+
+	val = __raw_readl(phy_ctrl);
+
+	if (val & USBPHY_CTRL_OTG_ID)
+		return USB_INIT_DEVICE;
+	else
+		return USB_INIT_HOST;
+}
+
+int __weak board_usb_phy_mode(int port)
+{
+	return usb_phy_mode(port);
+}
+
 int __weak board_ehci_hcd_init(int port)
 {
 	return 0;
@@ -221,7 +243,8 @@
 	usb_power_config(index);
 	usb_oc_config(index);
 	usb_internal_phy_clock_gate(index, 1);
-	type = usb_phy_enable(index, ehci) ? USB_INIT_DEVICE : USB_INIT_HOST;
+	usb_phy_enable(index, ehci);
+	type = board_usb_phy_mode(index);
 
 	*hccr = (struct ehci_hccr *)((uint32_t)&ehci->caplength);
 	*hcor = (struct ehci_hcor *)((uint32_t)*hccr +
diff -ruN u-boot-2015.01-rc3/.git/config u-boot/.git/config
--- u-boot-2015.01-rc3/.git/config	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/config	2015-01-01 17:34:31.953508170 +0100
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	fetch = +refs/heads/*:refs/remotes/origin/*
+	url = git://git.denx.de/u-boot.git
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -ruN u-boot-2015.01-rc3/.git/description u-boot/.git/description
--- u-boot-2015.01-rc3/.git/description	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/description	2015-01-01 17:34:05.785937163 +0100
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -ruN u-boot-2015.01-rc3/.git/HEAD u-boot/.git/HEAD
--- u-boot-2015.01-rc3/.git/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/HEAD	2015-01-01 17:34:31.953508170 +0100
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -ruN u-boot-2015.01-rc3/.git/hooks/applypatch-msg.sample u-boot/.git/hooks/applypatch-msg.sample
--- u-boot-2015.01-rc3/.git/hooks/applypatch-msg.sample	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/hooks/applypatch-msg.sample	2015-01-01 17:34:05.793937033 +0100
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -ruN u-boot-2015.01-rc3/.git/hooks/commit-msg.sample u-boot/.git/hooks/commit-msg.sample
--- u-boot-2015.01-rc3/.git/hooks/commit-msg.sample	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/hooks/commit-msg.sample	2015-01-01 17:34:05.793937033 +0100
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -ruN u-boot-2015.01-rc3/.git/hooks/post-update.sample u-boot/.git/hooks/post-update.sample
--- u-boot-2015.01-rc3/.git/hooks/post-update.sample	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/hooks/post-update.sample	2015-01-01 17:34:05.797936967 +0100
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -ruN u-boot-2015.01-rc3/.git/hooks/pre-applypatch.sample u-boot/.git/hooks/pre-applypatch.sample
--- u-boot-2015.01-rc3/.git/hooks/pre-applypatch.sample	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/hooks/pre-applypatch.sample	2015-01-01 17:34:05.793937033 +0100
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -ruN u-boot-2015.01-rc3/.git/hooks/pre-commit.sample u-boot/.git/hooks/pre-commit.sample
--- u-boot-2015.01-rc3/.git/hooks/pre-commit.sample	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/hooks/pre-commit.sample	2015-01-01 17:34:05.793937033 +0100
@@ -0,0 +1,50 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ascii filenames set this variable to true.
+allownonascii=$(git config hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ascii filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	echo "Error: Attempt to add a non-ascii file name."
+	echo
+	echo "This can cause problems if you want to work"
+	echo "with people on other platforms."
+	echo
+	echo "To be portable it is advisable to rename the file ..."
+	echo
+	echo "If you know what you are doing you can disable this"
+	echo "check using:"
+	echo
+	echo "  git config hooks.allownonascii true"
+	echo
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -ruN u-boot-2015.01-rc3/.git/hooks/prepare-commit-msg.sample u-boot/.git/hooks/prepare-commit-msg.sample
--- u-boot-2015.01-rc3/.git/hooks/prepare-commit-msg.sample	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/hooks/prepare-commit-msg.sample	2015-01-01 17:34:05.801936901 +0100
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -ruN u-boot-2015.01-rc3/.git/hooks/pre-rebase.sample u-boot/.git/hooks/pre-rebase.sample
--- u-boot-2015.01-rc3/.git/hooks/pre-rebase.sample	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/hooks/pre-rebase.sample	2015-01-01 17:34:05.801936901 +0100
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff -ruN u-boot-2015.01-rc3/.git/hooks/update.sample u-boot/.git/hooks/update.sample
--- u-boot-2015.01-rc3/.git/hooks/update.sample	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/hooks/update.sample	2015-01-01 17:34:05.793937033 +0100
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "Usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files u-boot-2015.01-rc3/.git/index and u-boot/.git/index differ
diff -ruN u-boot-2015.01-rc3/.git/info/exclude u-boot/.git/info/exclude
--- u-boot-2015.01-rc3/.git/info/exclude	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/info/exclude	2015-01-01 17:34:05.789937097 +0100
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -ruN u-boot-2015.01-rc3/.git/logs/HEAD u-boot/.git/logs/HEAD
--- u-boot-2015.01-rc3/.git/logs/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/logs/HEAD	2015-01-01 17:34:31.953508170 +0100
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 125738e819a3b9d15210794b3dcef9f4d9bcf866 Zoltan HERPAI <wigyori@uid0.hu> 1420130071 +0100	clone: from git://git.denx.de/u-boot.git
diff -ruN u-boot-2015.01-rc3/.git/logs/refs/heads/master u-boot/.git/logs/refs/heads/master
--- u-boot-2015.01-rc3/.git/logs/refs/heads/master	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/logs/refs/heads/master	2015-01-01 17:34:31.953508170 +0100
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 125738e819a3b9d15210794b3dcef9f4d9bcf866 Zoltan HERPAI <wigyori@uid0.hu> 1420130071 +0100	clone: from git://git.denx.de/u-boot.git
diff -ruN u-boot-2015.01-rc3/.git/logs/refs/remotes/origin/HEAD u-boot/.git/logs/refs/remotes/origin/HEAD
--- u-boot-2015.01-rc3/.git/logs/refs/remotes/origin/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/logs/refs/remotes/origin/HEAD	2015-01-01 17:34:31.953508170 +0100
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 125738e819a3b9d15210794b3dcef9f4d9bcf866 Zoltan HERPAI <wigyori@uid0.hu> 1420130071 +0100	clone: from git://git.denx.de/u-boot.git
Binary files u-boot-2015.01-rc3/.git/objects/pack/pack-e62dd83e4128e234ff5dabb586722d23d1bae06c.idx and u-boot/.git/objects/pack/pack-e62dd83e4128e234ff5dabb586722d23d1bae06c.idx differ
Binary files u-boot-2015.01-rc3/.git/objects/pack/pack-e62dd83e4128e234ff5dabb586722d23d1bae06c.pack and u-boot/.git/objects/pack/pack-e62dd83e4128e234ff5dabb586722d23d1bae06c.pack differ
diff -ruN u-boot-2015.01-rc3/.git/packed-refs u-boot/.git/packed-refs
--- u-boot-2015.01-rc3/.git/packed-refs	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/packed-refs	2015-01-01 17:34:31.865509612 +0100
@@ -0,0 +1,388 @@
+# pack-refs with: peeled 
+125738e819a3b9d15210794b3dcef9f4d9bcf866 refs/remotes/origin/master
+ece0d370144fdecb6f3ed5738ffe96f5b12f9e96 refs/remotes/origin/next
+cd5b2b9941d5b6f6596787ebdb03c215d91fc44d refs/remotes/origin/origin
+f20393c5e787b3776c179d20f82a86bda124d651 refs/remotes/origin/u-boot-2009.11.y
+e8ae0fa5edd152b2b29c470b88429be4cdcd2c46 refs/remotes/origin/u-boot-2013.01.y
+be360d9824d653780ebd3ffc08f1938a8e3dd747 refs/tags/DENX-2005-10-29-2350
+384ae02506f0673070a3516b1858f058a07f85f3 refs/tags/LABEL_2002_11_05_0120
+56f94be3ef63732384063e110277ed89701b6471 refs/tags/LABEL_2002_11_05_1735
+7f6c2cbc2bc0721c41bb776242c0b18ec70328e4 refs/tags/LABEL_2002_11_10_2310
+1d0350ed0b1b0f63e3fb5db6b19397b84a2ea1c7 refs/tags/LABEL_2002_11_11_2211
+2262cfeef91458b01a1bfe3812ccbbfdf8b82807 refs/tags/LABEL_2002_11_18_0115
+ea909b7604306a400ee3abf57e2fa7b2dde5dde1 refs/tags/LABEL_2002_11_22_0015
+a6c7ad2f65afaa717ba19cbf9d8d138b5f10ccf9 refs/tags/LABEL_2002_12_03_2230
+7c7a23bd5a0bc149d2edd665ec46381726b24e0c refs/tags/LABEL_2002_12_07_0120
+288b3d7f5a54c987ecdfc5add4c7c25d36a9a3e1 refs/tags/LABEL_2002_12_21_0040
+13122b4f1d6d00d6d4993ef56d9b5c5bd24f431e refs/tags/LABEL_2002_12_28_1700
+d0fb80c3021e15853895e9ae45ab9368d0fb52fa refs/tags/LABEL_2003_01_11_1050
+608c91460b37fd9fe0088a0ce813a443f116a8d5 refs/tags/LABEL_2003_01_14_0055
+6069ff265362ef6239749b5f598b137f407b821e refs/tags/LABEL_2003_02_28_0150
+43d9616cffb4a130e1620e3e33fc9bc1bcabe399 refs/tags/LABEL_2003_03_06_0050
+db2f721ffcf9693086a7e5c6c7015f2019e7f52e refs/tags/LABEL_2003_03_06_0200
+500545cc6b83958209128bffa825b3c842a21a4e refs/tags/LABEL_2003_03_06_1440
+1cb8e980c41e86760fa93de63f4e4cf643bef9d9 refs/tags/LABEL_2003_03_06_2255
+1957dd29d980ecb197c3a6dbe4f6609dae135a1d refs/tags/LABEL_2003_03_14_2150
+10f670178cce29d7f078ca622f0eeafd6903748a refs/tags/LABEL_2003_03_25_1830
+ac6dbb85b7f080d923013bff4e1d5267cb6f8a5a refs/tags/LABEL_2003_03_26_1300
+cdd8a0f1517b89349265465bf334db32e2304b45 refs/tags/LABEL_2003_03_27_1900
+3e38691e8f7aa0d9b498d76c7279ddec6e4946f3 refs/tags/LABEL_2003_04_05_0300
+4a6fd34b267dbf4a72080ab9a085bb45c63660fb refs/tags/LABEL_2003_04_15_1900
+7aa78614716b7bd7bdf68553f261ad0d5a12826a refs/tags/LABEL_2003_05_03_1700
+45219c46605f9b933ab454738ee4ce543d5b70d6 refs/tags/LABEL_2003_05_12_2355
+7f70e85309c6367138c0ebd14abdd49964b8d50a refs/tags/LABEL_2003_05_20_1630
+82226bf4d2fe87076d7f5d7e2677fdd5d0e35fc2 refs/tags/LABEL_2003_05_20_2250
+c8c3a8be2dd09e51d7dc33f431e3a638ac5688f2 refs/tags/LABEL_2003_05_22_2230
+5d232d0e7ea982d859d028ab482d95eb68460b19 refs/tags/LABEL_2003_05_23_0055
+4c3b21a5f915988e3d9681cf9cb566bb7bd56859 refs/tags/LABEL_2003_05_23_1450
+3b57fe0a70b903f4db66c558bb9828bc58acf06b refs/tags/LABEL_2003_05_30_1450
+7a8e9bed17d7924a9c5c4699b1f6a3a0359524ed refs/tags/LABEL_2003_05_31_2115
+682011ff6968198da14b89e40d9f55b00f6d91f7 refs/tags/LABEL_2003_06_04_0200
+a3ed3996cdb9fca78329f6aca62d235263b7da90 refs/tags/LABEL_2003_06_05_2140
+71f9511803de65a3b98d2f592d418da1d1539f13 refs/tags/LABEL_2003_06_16_0055
+9a0e21a3a87830f66a93c17d1bca66fd12d860ae refs/tags/LABEL_2003_06_22_1530
+b783edaee8252bfdba3f7b3fd29519a81ce71e42 refs/tags/LABEL_2003_06_26_2220
+8bde7f776c77b343aca29b8c7b58464d915ac245 refs/tags/LABEL_2003_06_27_2340
+91a0ce965d5905c37fff45555b7e3113b9359c8f refs/tags/LABEL_2003_06_28_0050-stable
+ef0630617e0f52dabb2cf7073df281e680073ec1 refs/tags/LABEL_2003_06_28_0130-stable
+ed579b4210cc5341d511e090239ca697e91ad728 refs/tags/LABEL_2003_06_28_1800-stable
+eeacb89cb311fe273fef0f20b2bacf589b36f8f4 refs/tags/LABEL_2003_06_29_0145
+7152b1d0b3f8beec8c297d64664e41b4c4ef610a refs/tags/LABEL_2003_09_06_0055
+4f7cb08ee7b48a511a9cd2398fd4a243ca2733c7 refs/tags/LABEL_2003_09_12_0110
+f5300ab241898c490231e59229e6312aa862ce52 refs/tags/LABEL_2003_09_12_1745
+531716e1710083f91d9fa351f89d18e271b5c577 refs/tags/LABEL_2003_09_13_2100
+34b3049a60a37e180d73332ccddf706c049a0515 refs/tags/LABEL_2003_09_16_2310
+80369866a482b923f0398f4c8172865282559f5b refs/tags/LABEL_2003_09_18_2045
+bb65a312675f3cd1923a5cbe325ad9ca1703fc58 refs/tags/LABEL_2003_10_01_1830
+fbe4b5cbdea438ccec0d93de443f367f3ba46196 refs/tags/LABEL_2003_10_06_2355
+a0ff7f2eda50de4d4096265a086c94ac640fab7c refs/tags/LABEL_2003_10_09_1515
+5da627a424b3ad2d38a81886ba4a18e5123a6788 refs/tags/LABEL_2003_10_09_2320
+f72da3406bf6f1c1bce9aa03b07d070413a916af refs/tags/LABEL_2003_10_10_1200
+2d5b561e2bfdee8552a99b2cf93016cce2a74895 refs/tags/LABEL_2003_10_14_2140
+42d1f0394bef0624fc9664714d54bb137931d6a6 refs/tags/LABEL_2003_10_16_0200
+d7281f41094bee59eca958de3c04995a2f79034a refs/tags/LABEL_2003_10_20_0025
+b4757cee52597ab5a67c30a1bf2a3208209e1ccb refs/tags/LABEL_2003_11_26_MKR
+fa1399ed127c8be507bf182dc7d8d61a54938d79 refs/tags/LABEL_2003_12_06_1550
+5e4be00fb037feb6476125d044b98e0e22b70d31 refs/tags/LABEL_2004_01_21_2110
+6876609446980c3055bbd32c195a63330e21d8e6 refs/tags/LABEL_2004_01_29_1030
+a2d18bb7d31e7b971386fef505ff0218f3b6e893 refs/tags/LABEL_2004_02_11_2240
+cf56e1101957c09cb4aafcf28a89658c4649c511 refs/tags/LABEL_2004_02_20_2310
+5cfbab3d822cb690be6d4f1793aab0cea761134c refs/tags/LABEL_2004_02_24_0305
+232c150a250bb2fcb894b15d67c65df2458e271f refs/tags/LABEL_2004_03_12_0130
+42dfe7a1844cbad7114038aaf03828acb7a84414 refs/tags/LABEL_2004_03_14_2340
+d9df1f4e662441c487f96a4e1f91caa9297afdd9 refs/tags/LABEL_2004_03_16_2330
+b79a11cc2bda7a4d5e00444427a0d06b4e86a990 refs/tags/LABEL_2004_03_25_1630
+998eaaecd46ee5f00550e30e606cb5556e0b9345 refs/tags/LABEL_2004_04_18_2135
+5cf91d6bdc3e60bd43f9ba1bbb97a43ee49b2b2d refs/tags/LABEL_2004_04_23_2240
+e4cc71aa4403c82f0b3e89087024f83832ece9ec refs/tags/LABEL_2004_05_19_2335
+69459791268d48c7081802dbc7a51d4e42c8a8cd refs/tags/LABEL_2004_05_29_1850
+021bfcd3c624ce88f739f01ba4220197bdd47a5e refs/tags/LABEL_2004_06_24_1800
+e94d2cd9d1dc0f58b18e7c31fc9345129b1a44fb refs/tags/LABEL_2004_07_01_1200
+31a649234ee4051e96cf45285cdf2dbfa668d30c refs/tags/LABEL_2004_08_28_2355
+7ca202f566a6e9dc3d0dd0216e82ad1a48f50f19 refs/tags/LABEL_2004_08_29_0045
+eedcd078fe1434d93b84322c4e14c52f80282a41 refs/tags/LABEL_2004_09_09_0000
+8b74bf31fe57edfc502f94e905977304eac943ca refs/tags/LABEL_2004_10_12_0110
+14699a22cf47b83995d19877d2b938b2270defc0 refs/tags/LABEL_2004_10_20_0020
+cacfab588a897c369a4906818c5ed4bc40a450c5 refs/tags/LABEL_2004_11_17_2222
+ed54e6212518262d27abe5e6de3c608d5ebceafb refs/tags/LABEL_2004_11_25_0035
+f7d1572bf51619554f278cb543ef0445baa3a1f8 refs/tags/LABEL_2004_12_18_2335
+bff96b0e6bdf8551e8468b111177c553e4994db2 refs/tags/LABEL_2004_12_19_1100
+08f272787a93cb11338fd81ab92a7439a361e3b2 refs/tags/LABEL_2004_12_19_2240
+400ab719c6025c176c50bcdff342384222d7424b refs/tags/LABEL_2004_12_20_1220
+436be29cad60a46ed5983120aff71909d8f234a3 refs/tags/LABEL_2005_01_31_2245
+e799d3755e83c70bf8c92977190d1777b390a8de refs/tags/LABEL_2005_02_07_2045
+b9649854f6ffdeaad23daec21013552cef2e05f0 refs/tags/LABEL_2005_02_08_1615
+e58cf2a0cfeb357faa134af1e12b96f4109af360 refs/tags/LABEL_2005_02_28_0050
+f4733a0764741966a5e842968166b40fb062d577 refs/tags/LABEL_2005_03_06_0225
+911d08f6ae244c6407fff268585e5b9544ce8adb refs/tags/LABEL_2005_03_15_0125
+f5c5ef4a1fa7dcf90fd74f795a131d07377406ab refs/tags/LABEL_2005_04_05_1830
+12b43d515c62682fcf7b578f31920a2be49142fe refs/tags/LABEL_2005_04_05_2345
+5e5f9ed254e20b830fef5f42a52ac0bbdc92a57e refs/tags/LABEL_2005_04_14_0115
+412babe304b948e1e3a909f8d2eb091b83f700d5 refs/tags/LABEL_2005_05_05_1920
+ed16fefcbaf99a67a7dd7639898dbc896c70cb1b refs/tags/LABEL_2005_05_09_1245
+9dd41a7b0c5c94d74c25edfdd6393c656669c09a refs/tags/LABEL_2005_05_13_0050
+88804d19e2bf36c9eaefadbd7199c093c900953b refs/tags/LABEL_2005_07_04_0202
+dafba16e6fc1837381c8e74c4891ad6965cf54ab refs/tags/LABEL_2005_08_12_0050
+053b40fa0c90d885b00c29c9c4490924801809f7 refs/tags/LABEL_2005_09_15_2320
+eb394f56db3e05d00891d6dc36a00df0025cf255 refs/tags/LABEL_2006_03_12_0025
+^84ef51a632063e8cb57b2e9a4252497512831ffe
+9bf86baaa3b35b25baa2d664e2f7f6cafad689ee refs/tags/LABEL_2006_04_18_1106
+^8419c013048b1f15f3fa2fc7c0463d860a04ee3e
+7a4978bc272e20c7febd15d76786c7d9b86a98cd refs/tags/LABEL_2006_05_10_1800
+^977b50f86824fe3c262ef7efce5dbb7ddaf8a48f
+c7071e6d645a8e13adb0d4cea2caad27213fa62f refs/tags/LABEL_2006_05_19_1133
+^5770a1e488621a9e7e344afed7c921ff4e715a63
+b11752921b5d22dcfda237e035a86470993e887b refs/tags/LABEL_2006_06_30_2020
+^3f7a63e6a34c5b435864c860c1563117e45d1c35
+2f91a3d0f8a73665423eb6ab17689c67f05e0887 refs/tags/U-Boot-0_2_0
+60fbe254243ec461ec73da13132be098db33d3fa refs/tags/U-Boot-0_3_0
+02c9bed451b36f3b1f11d5fe617da4fe4b9f9ab7 refs/tags/U-Boot-0_3_1
+993cad9364c6b87ae429d1ed1130d8153f6f027e refs/tags/U-Boot-0_4_0
+b0fce99bfc116c2ddb4506268d6e4a0a7054478d refs/tags/U-Boot-0_4_1
+f12e568ca45f6c56b5a6d52a43524987e141abe7 refs/tags/U-Boot-0_4_2
+ad12965db5d145f7cf7595cbeaf03b3402f42897 refs/tags/U-Boot-0_4_3
+945af8d723a29e9b6289d84250745ed0dc16fc81 refs/tags/U-Boot-0_4_4
+ae3af05ec986a8ac66dadb5eafe13db2d4a02c5c refs/tags/U-Boot-0_4_5
+e0ac62d798ce60ec5d43125d4786e58b0d881836 refs/tags/U-Boot-0_4_6
+0cb61d7dddb0d8c087f6df46a74815950668c97b refs/tags/U-Boot-0_4_7
+7205e4075d8b50e4dd89fe39ed03860b23cbb704 refs/tags/U-Boot-0_4_8
+b13fb01a62708492cae4b33c4d6fa9ae127905f4 refs/tags/U-Boot-1_0_0
+b299e41a0d34bf96202d9bbb72739bdd9414b0cc refs/tags/U-Boot-1_0_1
+198ea9e294e38cea49f9f2d9b911bdfdd20e48dc refs/tags/U-Boot-1_0_2
+f525c8a1476945b078ce4ffe6cf768c286cbf8cc refs/tags/U-Boot-1_1_0
+08f1080c9cbde2a500e6efe8bc5647a68f183c91 refs/tags/U-Boot-1_1_1
+15c7a8efd2f7275e5b3249aac305f2598a998645 refs/tags/U-Boot-1_1_2
+2893ecbf3e5b983970138289b759baf45a327ff3 refs/tags/U-Boot-1_1_3
+74ad4b4fef966ab4cc7192b5b3808ec95e60570b refs/tags/U-Boot-1_1_4
+^e6b6d16de73de6a76e2ec4338291e828b860f040
+b7487ff5a5d41e379809509b9a07546e73577dc8 refs/tags/U-Boot-1_1_5
+^ba999c531ed16ec749b2b6f4b0133cee38842b91
+ba89ef3908907cf55a5bff6ba211b8d8c2b08800 refs/tags/U-Boot-1_1_6
+^c59200443072353044aa4bf737a5a60f9a9af231
+eb8fae4983cfe07fe7c785f483f2278b6146463a refs/tags/U-Boot-1_2_0
+^f4eb54529bb3664c3a562e488b460fe075f79d67
+d9af3c87df93e1a8126b1a52adf8db978e9a0d40 refs/tags/U_BOOT_0_1_0
+69a193a815e7f0b35eeeb013a1f1e0cd9e590f92 refs/tags/v1.3.0
+^9a337ddc154a10a26f117fd147b009abcdeba75a
+6b894f3c3eac06420acad28e70621c5ba410b321 refs/tags/v1.3.0-rc1
+^ff7640c9ead8806b5d827f2b29f9cb2632add729
+a5d674296b4a991efdb708a9c8d6c78d4e47f565 refs/tags/v1.3.0-rc2
+^66dcad3a9a53e0766d90e0084123bd8529522fb0
+bf58489ae2e0de9bd2d7a6ebdbfdb655b48f0c09 refs/tags/v1.3.0-rc3
+^636400198228d96983c06657b17f760f5989958e
+409530dcb489cf4c24fab977ca041dac27ff9f28 refs/tags/v1.3.0-rc4
+^5947f6999aafa7c54c1390983d264a8463dfea8e
+2006af48494237562529cfdb111681149e0f13e9 refs/tags/v1.3.1
+^41be969f4957115ed7b1fe8b890bfaee99d7a7a2
+b67a97f26c406e9116fc85f5dcad4917b7a1c801 refs/tags/v1.3.1-rc1
+^8d4f040a3c15036a6ea25a9c39e7d89fefa8440d
+2b0e9596bac7d2776431657488db88703ba1d441 refs/tags/v1.3.2
+^30f1806f60978d707b0cff2d7bf89d141fc24290
+1dec865fbd4b229061233c504166443f623335db refs/tags/v1.3.2-rc1
+^67a4389e39ad853d65b72e2b7cad15c7e8291147
+c19f1e9b9a8794d488221a9cc3a60db03b7ccc5a refs/tags/v1.3.2-rc2
+^b29661fc1151077776454288051bc9a488351ce8
+955a05aa4445c5652c53e06254d420d7dffd49a6 refs/tags/v1.3.2-rc3
+^661bad63a076a96c39c64f136915f146725af92b
+01348d89a001323ae51dda449decea61092e008b refs/tags/v1.3.3
+^180a90abdae72587c0f679edf8991455e559440d
+33a7d077fd81772d263a4e91a5aebe585c5362ca refs/tags/v1.3.3-rc1
+^fd7531c1e9d56b9e5e06d2c0e02b798dab72f70c
+5ee1a6e902f3b76f672587bb7be4600ab9af1c34 refs/tags/v1.3.3-rc2
+^76617299358ebba260ecc02d33e8e75d8d13dd3b
+239f0883ea3a9f511f8925619d30a0dc9ea8fe01 refs/tags/v1.3.3-rc3
+^6adf61dc4cb5c53a2df990cbc8df2bceacbfd869
+5978b7d69fc40ee9512a6c1b5a3216019ee8e847 refs/tags/v1.3.4
+^cd82919e6c8a73b363a26f34b734923844e52d1c
+7cbbab2ab61f4f726fac1ff6b8bf2dfd26f2b3ba refs/tags/v1.3.4-rc1
+^699f05125509249072a0b865c8d35520d97cd501
+69be245e15510af0756aafb01020f9752ff7e066 refs/tags/v1.3.4-rc2
+^4b50cd12a3b3c644153c4cf393f4a4c12289e5aa
+624c2d518b6dfc652db6fcbc969bbd93f9821322 refs/tags/v2008.10
+^b59b16ca24bc7e77ec113021a6d77b9b32fcf192
+3033c74cb0ad3dfbb1733a36f72f2f4496ba1863 refs/tags/v2008.10-rc1
+^8b9e4787641719d709bfa2ebeb72e8bd4952bee7
+2071c4239c250da6c8cbc93aa1d74b503acb2507 refs/tags/v2008.10-rc2
+^c0d2f87d6c450128b88e73eea715fa3654f65b6c
+789d45f945bc37e721b91923388a91a4f4fcbedb refs/tags/v2008.10-rc3
+^b4dbacf69a669a17487054552fc2761149dd6767
+c2d264a1e4540f09e7098a42d094bf6724567043 refs/tags/v2009.01
+^72d15e705bc3983884105cb7755c7ba80e74a0a5
+866b1cc6f942be4e2669c17e390cd552abc68e3e refs/tags/v2009.01-rc1
+^aced78d852d0b009e8aaa1445af8cb40861ee549
+35ca1e5e625049dbad16ce4cb273e5af47706a23 refs/tags/v2009.01-rc2
+^0e3ece33801e377be67ffa29f083421ad820f28b
+79f73ea6d9d81ce14a839fa4cc24d1a3ad0975fc refs/tags/v2009.01-rc3
+^635e5f8fc82365e6e9734b3132bc95135a6de679
+661e77d04058f94336f621e41b7b341a3b503833 refs/tags/v2009.03
+^e60beb13cf0135dc71c541021487b5ccc4d269cb
+0eb92888fc505ffc6bc58a5e7bedc0ae127279fa refs/tags/v2009.03-rc1
+^32688e572ff96715b41420e9a7f280db6c399b65
+0e34d8aa7974c11a5fd9afe983e9c277e02ef358 refs/tags/v2009.03-rc2
+^b3dd629e78870ba2dc9f8032978721c0fa02a856
+d70da93b038dbee50cb3e84cc0db25aab424a772 refs/tags/v2009.06
+^6b1f78ae6ad037382ad430b07064105c88f7ac02
+4cb5ec6e36792f300ecbe4e67eb6931848e0bace refs/tags/v2009.06-rc1
+^6b8edfde22acc574b5532e9f086e6a7287a9bc78
+210d415558d01a195f98360b127e3f4eb3bb933b refs/tags/v2009.06-rc2
+^a2e0ffcf2d9a22c582a93e84a4bef20fd3877f47
+95bd78f93cfc903186e88fc58deac036c401cfbc refs/tags/v2009.06-rc3
+^580611cb0932143fc2d7a735cfa9ce1ef34d6002
+e99ab567a1a6848b871a9af8cab3ad2c0c49647a refs/tags/v2009.08
+^3d35d87d5482de23cd5dc4d7721b1086107cae50
+e2447f7b3a5336462dd3bebf9a10fc368461b023 refs/tags/v2009.08-rc1
+^94978e19f31d225b4f7d97c4acbac1ecfaeb8f69
+6f03d260e53b1263471e5c3e690ddfe43b53d959 refs/tags/v2009.08-rc2
+^eb1a4d0a471505c169bef19a73a60f8641f0b875
+9ab87511114da4af82dbdf745edc7478d3e3f274 refs/tags/v2009.08-rc3
+^963f2f611741f8d9c38bd7caf20ae8c95cab7b3f
+bd1e74b1989e22fe19f8809cacfbf9cbbf4eaf20 refs/tags/v2009.11
+^a200a7c04d89853d2a1395b96d8ca5e3dd754551
+815f048382dc123c29baa41238a89f820876bf1e refs/tags/v2009.11-rc1
+^4946775c6db52dba28f72ba3525764b54f1d4593
+4c682c60e20b5624868ed6aa214d073cfb8dc0a6 refs/tags/v2009.11-rc2
+^0fc52948bda0734431cb528ee4fd82f1dec8c7b5
+9fd828dddea4306b99670d07366fe3f7c1052d08 refs/tags/v2009.11.1
+^f20393c5e787b3776c179d20f82a86bda124d651
+65bc917e953601b09965e5fcdfbe4f6c75547e50 refs/tags/v2010.03
+^ca6e1c136ddb720c3bb2cc043b99f7f06bc46c55
+537c2a51feed445384aa43e482e4ddc0b5549a75 refs/tags/v2010.03-rc1
+^93910edb595a88d394da3eb2cf5148096155dfe9
+273a6decf55982f7a5263d17559b94281f36caf7 refs/tags/v2010.03-rc2
+^152dda3d94e97ede7af3f9560a59a659384d4585
+3ef91195a43e6a229290977d70bb913008db2dc9 refs/tags/v2010.03-rc3
+^2883cc2d48e99fd1873ef8af03fee7966611b735
+41d5718ee6fb36a1282cde6c86b55f83b62278e1 refs/tags/v2010.06
+^a59e27997637a2395ae2cc7f809127f24119a167
+096e50e0a8934f4e083d43d5711d611eebe82607 refs/tags/v2010.06-rc1
+^01f03bda5b22e5aeae5f02fd537da97a41485c73
+a42fe9aa726cd3d64c3fcf11eea0bc531ee8d281 refs/tags/v2010.06-rc2
+^a9046b9e1aeeedc66ddf1d00474ad0ce8c6aa6e4
+17d61cb4e86f3dc4e7deaa0042fe6d6a6afff8f3 refs/tags/v2010.06-rc3
+^482126e27b3dbf0e69a6445da8b94b3551adf05d
+f7b386b1df73ff213287eed6ca1b74bb91da1b05 refs/tags/v2010.09
+^1e4e5ef0469050f014aee1204dae8a9ab6053e49
+c988fb931f8c8f5d9ce1fc6ca2c20219bcd0fc10 refs/tags/v2010.09-rc1
+^2d941de9d5c7ba00dc19787dfa0aac2949fd00fb
+09012d353eaf26310dc3ddb1915a3d3504ab9a27 refs/tags/v2010.09-rc2
+^07517e7f4f582d1607adbc444bab75af3ac4a7f9
+d0e3a3f4574f1f51ae3d7c5605b7ea5c6df929d4 refs/tags/v2010.12
+^250ef029844be2cb98635f265359396866d1749f
+5aeba5ba231ccceba84dd2311b1dae645b75bfdc refs/tags/v2010.12-rc1
+^908614f20f7f0f5df736eed21b88e81ebbf14e86
+a1904f2bc34e97d79483bcefc35b188620ee9089 refs/tags/v2010.12-rc2
+^d0d2271f8c62e830ec65fb069b6d12dd708e3e2f
+9bde025ff24c811c02d2a7e6451a57ea63895b3a refs/tags/v2010.12-rc3
+^3ac45988ab1605baaf83bd3acb80a197c9a208c2
+b29fbb347698286935bfc401c08499a6f63479de refs/tags/v2011.03
+^19b54a701811220221fc4d5089a2bb18892018ca
+2360c73ed79d91fe75c297c8a62b2810e8eef281 refs/tags/v2011.03-rc1
+^42d44f631c4e8e5359775bdc098f2fffde4e5c05
+38c5af4db86a3e7feaff5092b136722c53784c03 refs/tags/v2011.03-rc2
+^cb815e5ff979e36d68df130a810d34de4bf93289
+54d5e1052f16fe5e3337600f485b13b4c6204972 refs/tags/v2011.06
+^b1af6f532e0d348b153d5c148369229d24af361a
+4d0984f19a46afd17d1ca843deacc5bbedd95eda refs/tags/v2011.06-rc1
+^7a82c208143bbc774ffcb4e53239410f867a0794
+1b885e3346f4e06463949dcca3f9444d3d76eeda refs/tags/v2011.06-rc2
+^6f4dd40cddbd69c56fec1285fee02cbd5a3833d8
+0431724fde21417139eb1209ea8b562235c64c6e refs/tags/v2011.06-rc3
+^79cfe422615c010a75ece41662a05cd432ada389
+58fb473021fd5377db6cb934ea7032da885f80b7 refs/tags/v2011.09
+^1d5e7fb403257d62f0f2419cb83fdf6b0f02f215
+86773b53d37288d8ad16f27b93fd948ff11f8012 refs/tags/v2011.09-rc1
+^6ceb0135f96d73063ffbaab5be7ce23933367388
+00e61f6907d4ecc2e41f4ba61da74e7cc8665e29 refs/tags/v2011.09-rc2
+^bc196029f53c2d82eb9a12eb8b66e696b6284941
+d0b049d45ae734fa473894ae6fd9f4d7d2437cc5 refs/tags/v2011.12
+^cba9a894fdb1cb49b60fcd1d1d6919cbd7995dd5
+ee26bfcef5eb5cb4481eb073924cddc22ea2e423 refs/tags/v2011.12-rc1
+^5738946be46c513fd945d3e1d8f8a0fa718b7c58
+db9c62b847eab7d42b396ee59cbf4e5e75f02fc6 refs/tags/v2011.12-rc2
+^901de79a3792c81aefcbf207a34049e63f21362b
+d18276f86b5bed7646749a6a81ae94af79578d5f refs/tags/v2011.12-rc3
+^be662e9a6b7bf27cb7bc06de18f3c51b2ea80160
+5910ada22359d6cd06b9299f1ef6020a1ea2b893 refs/tags/v2012.04
+^2790bf69dc12fb9aeb9836904e5f57c7f83d5552
+bf41e44b53ad476c47da12f985115d2f073c716d refs/tags/v2012.04-rc1
+^c008b6f6dd6b8965e9a7654ffbce75bb9ff7a3b5
+b9c6ec5eb3eaa4471b32e92f48d6df2867020738 refs/tags/v2012.04-rc2
+^f5cdc11775c4b7fdbf52a6dd2f463d329804ab11
+d2062de0a3356d2e5c4b9ee6b7c805f0ac5cef37 refs/tags/v2012.04-rc3
+^fb14b6b2f680363678b4e6a75eb9f3f0d79111fa
+b75d3092239fc5e0e05571d91a380eb8d90d2f45 refs/tags/v2012.04.01
+^415d386877df49eb051b85ef74fa59a16dc17c7d
+d8679b1a4e01cfc7e90be484f4feafdcf153f3a1 refs/tags/v2012.07
+^190649fb4309d1bc0fe7732fd0f951cb6440f935
+ea406aa0f20923152f447108f189bd6e84f2b082 refs/tags/v2012.07-rc1
+^211e47549b668c7cdd8658c0413a272f0d0495d4
+5f4bc90c127618f5022d0086d329bbacab9c2b9b refs/tags/v2012.07-rc2
+^8b10652d6d9cc05023b5a6b73840078066f95a50
+473fff580bfa77b2f4b4dcecbb63ede28f8da5fa refs/tags/v2012.07-rc3
+^c627faf637f5fe091bdb6846a52b16983e97b262
+5aad5045f59029384c11058970caa31de2cfa514 refs/tags/v2012.10
+^6528ff0109d81c1f21d20f9f1370782bccf87bcb
+91c92e05eb518c1697c64e30e6887aa59a4fde44 refs/tags/v2012.10-rc1
+^ee1f4caaa2a3f79d692155eec8a4c7289d60e106
+3b07d3f76ca3b0bb41b463291f8456918ecc7df9 refs/tags/v2012.10-rc2
+^221953d41dea8dce027b9ce6beee700d97ac2c83
+7f2daf884129488975dd5f41d87730b26532e128 refs/tags/v2012.10-rc3
+^c7c63221439ad87a8c05e7b42f9eae32ec7cc2d4
+35c192cf449860aec8766e20a51bf2052a1dc968 refs/tags/v2013.01
+^3a9d879f6f64585b819af728b53be0a05037fe0d
+02eac6cbf79f854495705a5cf074b9b31ebdef47 refs/tags/v2013.01-rc1
+^3ae7b240ad8c723d02aa79654220a07049b7ae4d
+e99406154b90847a729cfef176c5b0681b8fbf62 refs/tags/v2013.01-rc2
+^ebbf0d20aa85f623c49b7ed3349ebfea450c152d
+32811f96f8259013d054deddb4d3b67a3d3092aa refs/tags/v2013.01-rc3
+^6fb4d74e59750b43f00d460c569e8a30c67c5bb0
+8512592e47cc968d2d6eb788acde761ebc3acbf6 refs/tags/v2013.01.01
+^e8ae0fa5edd152b2b29c470b88429be4cdcd2c46
+eb34b5ea26363ff349dee46ec6fb90fbc2198495 refs/tags/v2013.04
+^d10f68ae47b67acab8b110b5c605dde4197a1820
+734a826d8508b7ca8131381f1fb9ad36e7e98432 refs/tags/v2013.04-rc1
+^2536850d7cd90bdb75bf3ff86838f913392b68db
+8a7f04c4b3fe8ecb0b8af5c285cd2e252f60482e refs/tags/v2013.04-rc2
+^c8142633e169665b246352918df5b76fd243bb71
+83be647fa85edeb64c98d2d61114ca30de30e308 refs/tags/v2013.04-rc3
+^cba6494f24d711ba63afb22b1ee691a41fee121c
+9e96446a0bf49683dad66708579873a3b6c4f068 refs/tags/v2013.07
+^62c175fbb8a0f9a926c88294ea9f7e88eb898f6c
+7a42d4e7aa2788b653927904e03ec20793823a19 refs/tags/v2013.07-rc1
+^216a793cc1702227fd4ad624080f585038d1fa45
+4d5aaff0a76a07d28051134d7301d25a74a3a32e refs/tags/v2013.07-rc2
+^e6bf18dba2a21bebf2c421b1c2e188225f6485a1
+3060931a37a2417275a24400a6eb60abeb1a176a refs/tags/v2013.07-rc3
+^68c517eafcb060aa8ef92ed2620f0f41c5275d89
+2d65a6b5a3f069ea92ee33c1c925d79610af12d0 refs/tags/v2013.10
+^183acb700378a8cfc5d50a01a65de93fb2c24586
+ff92b6e5cf51421163e4ea1d29004eeffd6b6a99 refs/tags/v2013.10-rc1
+^40a60c6e8bdd00330310eaa351c9391e74d0bc2c
+bab9dca36165be177a74ff31eabda75f94e26599 refs/tags/v2013.10-rc2
+^fb18fa95a14ae875ef0a5421cd9fecc00c7c3a4c
+c1d48b0698c9b7ddf342f5808d3a4a973317c2dc refs/tags/v2013.10-rc3
+^46ef4faed18196472eb95216b2f74c1397ecf024
+c99ec7332286341649cd5337eb1bbeabdff13a3a refs/tags/v2013.10-rc4
+^0c5274e6f3231a3a28dafc1204b3f71a3534c520
+e3fbee81eccebfd6c91609f6bc4b4aec3a017131 refs/tags/v2014.01
+^b44bd2c73c4cfb6e3b9e7f8cf987e8e39aa74a0b
+0b3dd5f23cf6eeb9ec84da8c77d8c7d1e7d23680 refs/tags/v2014.01-rc1
+^d19ad726bcd5d9106f7ba9c750462fcc369f1020
+e68eecb2d896ddef422984ae6d52793099b74e9a refs/tags/v2014.01-rc2
+^fd44194945714a478fab6407c04453caaef0bac9
+5f60aba0d3f6b827de8dc7e0850c1050f655b572 refs/tags/v2014.01-rc3
+^cddb6b8304bfbc34f43920051256de7fe6c4c0ab
+5b3ba909f4f881add7756d820f2eb67d3e31b112 refs/tags/v2014.04
+^dda0dbfc69f3d560c87f5be85f127ed862ea6721
+9574fdf82ff62a7086b257c89c01bde937a0c45e refs/tags/v2014.04-rc1
+^0a8e823ad0c5a602c93c2e8a54caf622ade6d3fb
+4017dac218f34783977c36af8f65984a57ace7e3 refs/tags/v2014.04-rc2
+^8ee950dd273aef6a074d41bf2ee4ef11d6f848fb
+ba34c9404626f23a41ef07bcdf3e7e5cbf133b82 refs/tags/v2014.04-rc3
+^c494eaf409cb8db9a5a513e9bdfac20b7a83daca
+590a74953a76f2b4cc552bd85b475ea54ba02f66 refs/tags/v2014.07
+^524123a70761110c5cf3ccc5f52f6d4da071b959
+2db93972561773246cb7498bf1ee73e3d34fa697 refs/tags/v2014.07-rc1
+^3e41c54ad8099951d57c3c5a0f5ebc6e8becf70c
+3472f37f1ce4d2737476b4ec7c768c04afe20046 refs/tags/v2014.07-rc2
+^0116f40bbc269c57566d69e0db8cb9da2e194d33
+d3b233a6a320688e22419134d6f7bb23e9c0332b refs/tags/v2014.07-rc3
+^76b21026ceb5a6a83fc53b0ecdf425f240318022
+9019e02a9d98f6788035ea352289a5afdbbf133d refs/tags/v2014.07-rc4
+^a176ff0705351bf6d993a8f15e081bfa2ba2e1af
+d96885d68127e270d16484c0fbc252953a2bf2e8 refs/tags/v2014.10
+^c43fd23cf619856b0763a64a6a3bcf3663058c49
+49fe41ad45d09cf083db39ce4a2653d903fbe1a7 refs/tags/v2014.10-rc1
+^e76b933e02e1b38e48754c435e9dba1c0deeb3c6
+8d6f7381cd8f915f6599044b1848a8a6a7faff02 refs/tags/v2014.10-rc2
+^d6c1ffc7d23f4fe4ae8c91101861055b8e1501b6
+1f254ba729e8b21ccba3c9caf02bf358a0e8d136 refs/tags/v2014.10-rc3
+^742de9076e8a8f44b77794b43e6175d86b897996
+a013989f700d43f79af64fb74b05b2f333a60c7d refs/tags/v2015.01-rc1
+^9906090f527153afddc5aa64d37cb5f89c6ee129
+77831f3e5f83e12b4e7df418e7d43977b189031d refs/tags/v2015.01-rc2
+^2a82ec77d27ef5f860a107c4b764643a655dceeb
+ecb091a9035a9c89a57b7fbd6cdf1db1c5ee9a80 refs/tags/v2015.01-rc3
+^32fdf0e4d82bdca5d64d86330e461e59685f9959
+9305547115a8073900fec5e8f3938b93c675f2c2 refs/tags/v2015.01-rc4
+^125738e819a3b9d15210794b3dcef9f4d9bcf866
diff -ruN u-boot-2015.01-rc3/.git/refs/heads/master u-boot/.git/refs/heads/master
--- u-boot-2015.01-rc3/.git/refs/heads/master	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/refs/heads/master	2015-01-01 17:34:31.953508170 +0100
@@ -0,0 +1 @@
+125738e819a3b9d15210794b3dcef9f4d9bcf866
diff -ruN u-boot-2015.01-rc3/.git/refs/remotes/origin/HEAD u-boot/.git/refs/remotes/origin/HEAD
--- u-boot-2015.01-rc3/.git/refs/remotes/origin/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/.git/refs/remotes/origin/HEAD	2015-01-01 17:34:31.937508433 +0100
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -ruN u-boot-2015.01-rc3/include/common.h u-boot/include/common.h
--- u-boot-2015.01-rc3/include/common.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/common.h	2015-01-01 17:34:32.757494989 +0100
@@ -70,12 +70,6 @@
 #ifdef	CONFIG_4xx
 #include <asm/ppc4xx.h>
 #endif
-#ifdef CONFIG_ARM
-#define asmlinkage	/* nothing */
-#endif
-#ifdef CONFIG_X86
-#define asmlinkage __attribute__((regparm(0)))
-#endif
 #ifdef CONFIG_BLACKFIN
 #include <asm/blackfin.h>
 #endif
diff -ruN u-boot-2015.01-rc3/include/config_fallbacks.h u-boot/include/config_fallbacks.h
--- u-boot-2015.01-rc3/include/config_fallbacks.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/config_fallbacks.h	2015-01-01 17:34:32.757494989 +0100
@@ -79,6 +79,10 @@
 #define CONFIG_SYS_PROMPT	"=> "
 #endif
 
+#ifndef CONFIG_SYS_PBSIZE
+#define CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE + 128)
+#endif
+
 #ifndef CONFIG_FIT_SIGNATURE
 #define CONFIG_IMAGE_FORMAT_LEGACY
 #endif
@@ -87,4 +91,10 @@
 #undef CONFIG_IMAGE_FORMAT_LEGACY
 #endif
 
+#ifdef CONFIG_DM_I2C
+# ifdef CONFIG_SYS_I2C
+#  error "Cannot define CONFIG_SYS_I2C when CONFIG_DM_I2C is used"
+# endif
+#endif
+
 #endif	/* __CONFIG_FALLBACKS_H */
diff -ruN u-boot-2015.01-rc3/include/configs/alt.h u-boot/include/configs/alt.h
--- u-boot-2015.01-rc3/include/configs/alt.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/alt.h	2015-01-01 17:34:32.777494661 +0100
@@ -95,4 +95,23 @@
 #define CONFIG_USB_EHCI_RMOBILE
 #define CONFIG_USB_MAX_CONTROLLER_COUNT	2
 
+/* MMCIF */
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_MMC
+
+#define CONFIG_SH_MMCIF
+#define CONFIG_SH_MMCIF_ADDR		0xee200000
+#define CONFIG_SH_MMCIF_CLK		48000000
+
+/* Module stop status bits */
+/* INTC-RT */
+#define CONFIG_SMSTP0_ENA	0x00400000
+/* MSIF */
+#define CONFIG_SMSTP2_ENA	0x00002000
+/* INTC-SYS, IRQC */
+#define CONFIG_SMSTP4_ENA	0x00000180
+/* SCIF2 */
+#define CONFIG_SMSTP7_ENA	0x00080000
+
 #endif /* __ALT_H */
diff -ruN u-boot-2015.01-rc3/include/configs/apalis_t30.h u-boot/include/configs/apalis_t30.h
--- u-boot-2015.01-rc3/include/configs/apalis_t30.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/apalis_t30.h	2015-01-01 17:34:32.777494661 +0100
@@ -26,10 +26,7 @@
 
 /* I2C */
 #define CONFIG_SYS_I2C_TEGRA
-#define CONFIG_SYS_I2C_INIT_BOARD
-#define CONFIG_SYS_I2C_SPEED		100000
 #define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
 
 /* SD/MMC */
 #define CONFIG_MMC
diff -ruN u-boot-2015.01-rc3/include/configs/B4860QDS.h u-boot/include/configs/B4860QDS.h
--- u-boot-2015.01-rc3/include/configs/B4860QDS.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/B4860QDS.h	2015-01-01 17:34:32.757494989 +0100
@@ -641,6 +641,14 @@
 #define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE	0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE	0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE	CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE	(CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE	(CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE	(CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	25
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #ifdef CONFIG_PHYS_64BIT
@@ -649,6 +657,14 @@
 #define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 
diff -ruN u-boot-2015.01-rc3/include/configs/beaver.h u-boot/include/configs/beaver.h
--- u-boot-2015.01-rc3/include/configs/beaver.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/beaver.h	2015-01-01 17:34:32.781494596 +0100
@@ -40,10 +40,7 @@
 
 /* I2C */
 #define CONFIG_SYS_I2C_TEGRA
-#define CONFIG_SYS_I2C_INIT_BOARD
-#define CONFIG_SYS_I2C_SPEED		100000
 #define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
 
 /* SD/MMC */
 #define CONFIG_MMC
diff -ruN u-boot-2015.01-rc3/include/configs/BSC9131RDB.h u-boot/include/configs/BSC9131RDB.h
--- u-boot-2015.01-rc3/include/configs/BSC9131RDB.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/BSC9131RDB.h	2015-01-01 17:34:32.757494989 +0100
@@ -11,6 +11,9 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
+
 #ifdef CONFIG_BSC9131RDB
 #define CONFIG_BSC9131
 #define CONFIG_NAND_FSL_IFC
diff -ruN u-boot-2015.01-rc3/include/configs/BSC9132QDS.h u-boot/include/configs/BSC9132QDS.h
--- u-boot-2015.01-rc3/include/configs/BSC9132QDS.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/BSC9132QDS.h	2015-01-01 17:34:32.761494923 +0100
@@ -11,6 +11,9 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
+
 #ifdef CONFIG_BSC9132QDS
 #define CONFIG_BSC9132
 #endif
diff -ruN u-boot-2015.01-rc3/include/configs/cardhu.h u-boot/include/configs/cardhu.h
--- u-boot-2015.01-rc3/include/configs/cardhu.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/cardhu.h	2015-01-01 17:34:32.785494529 +0100
@@ -43,12 +43,7 @@
 
 /* I2C */
 #define CONFIG_SYS_I2C_TEGRA
-#define CONFIG_SYS_I2C_INIT_BOARD
-#define CONFIG_I2C_MULTI_BUS
-#define CONFIG_SYS_MAX_I2C_BUS		TEGRA_I2C_NUM_CONTROLLERS
-#define CONFIG_SYS_I2C_SPEED		100000
 #define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
 
 /* SD/MMC */
 #define CONFIG_MMC
diff -ruN u-boot-2015.01-rc3/include/configs/chromebook_link.h u-boot/include/configs/chromebook_link.h
--- u-boot-2015.01-rc3/include/configs/chromebook_link.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/chromebook_link.h	2015-01-01 17:34:32.785494529 +0100
@@ -25,10 +25,10 @@
 
 #define CONFIG_X86_RESET_VECTOR
 #define CONFIG_NR_DRAM_BANKS			8
-#define CONFIG_X86_MRC_START			0xfffa0000
+#define CONFIG_X86_MRC_ADDR			0xfffa0000
 #define CONFIG_CACHE_MRC_SIZE_KB		512
 
-#define CONFIG_COREBOOT_SERIAL
+#define CONFIG_X86_SERIAL
 
 #define CONFIG_SCSI_DEV_LIST		{PCI_VENDOR_ID_INTEL, \
 			PCI_DEVICE_ID_INTEL_NM10_AHCI},	      \
@@ -39,7 +39,7 @@
 	{PCI_VENDOR_ID_INTEL,		\
 			PCI_DEVICE_ID_INTEL_PANTHERPOINT_AHCI_MOBILE}
 
-#define CONFIG_X86_OPTION_ROM_FILENAME		pci8086,0166.bin
+#define CONFIG_X86_OPTION_ROM_FILE		pci8086,0166.bin
 #define CONFIG_X86_OPTION_ROM_ADDR		0xfff90000
 #define CONFIG_VIDEO_X86
 
diff -ruN u-boot-2015.01-rc3/include/configs/colibri_t30.h u-boot/include/configs/colibri_t30.h
--- u-boot-2015.01-rc3/include/configs/colibri_t30.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/colibri_t30.h	2015-01-01 17:34:32.785494529 +0100
@@ -25,10 +25,7 @@
 
 /* I2C */
 #define CONFIG_SYS_I2C_TEGRA
-#define CONFIG_SYS_I2C_INIT_BOARD
-#define CONFIG_SYS_I2C_SPEED		100000
 #define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
 
 /* SD/MMC */
 #define CONFIG_MMC
diff -ruN u-boot-2015.01-rc3/include/configs/coreboot.h u-boot/include/configs/coreboot.h
--- u-boot-2015.01-rc3/include/configs/coreboot.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/coreboot.h	2015-01-01 17:34:32.785494529 +0100
@@ -49,7 +49,7 @@
 	{PCI_VENDOR_ID_INTEL,		\
 			PCI_DEVICE_ID_INTEL_PANTHERPOINT_AHCI_MOBILE}
 
-#define CONFIG_COREBOOT_SERIAL
+#define CONFIG_X86_SERIAL
 
 #define CONFIG_STD_DEVICES_SETTINGS     "stdin=usbkbd,vga,serial\0" \
 					"stdout=vga,serial,cbmem\0" \
diff -ruN u-boot-2015.01-rc3/include/configs/corenet_ds.h u-boot/include/configs/corenet_ds.h
--- u-boot-2015.01-rc3/include/configs/corenet_ds.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/corenet_ds.h	2015-01-01 17:34:32.785494529 +0100
@@ -495,6 +495,14 @@
 #define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf4200000
 #ifdef CONFIG_PHYS_64BIT
@@ -503,6 +511,14 @@
 #define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
diff -ruN u-boot-2015.01-rc3/include/configs/crownbay.h u-boot/include/configs/crownbay.h
--- u-boot-2015.01-rc3/include/configs/crownbay.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/crownbay.h	2015-01-01 17:34:32.785494529 +0100
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*
+ * board/config.h - configuration options, board specific
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/x86-common.h>
+
+#define CONFIG_SYS_MONITOR_LEN		(1 << 20)
+#define CONFIG_SYS_X86_START16		0xfffff800
+#define CONFIG_BOARD_EARLY_INIT_F
+
+#define CONFIG_X86_RESET_VECTOR
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CONFIG_X86_SERIAL
+#define CONFIG_SMSC_LPC47M
+
+#define CONFIG_PCI_MEM_BUS		0x40000000
+#define CONFIG_PCI_MEM_PHYS		CONFIG_PCI_MEM_BUS
+#define CONFIG_PCI_MEM_SIZE		0x80000000
+
+#define CONFIG_PCI_PREF_BUS		0xc0000000
+#define CONFIG_PCI_PREF_PHYS		CONFIG_PCI_PREF_BUS
+#define CONFIG_PCI_PREF_SIZE		0x20000000
+
+#define CONFIG_PCI_IO_BUS		0x2000
+#define CONFIG_PCI_IO_PHYS		CONFIG_PCI_IO_BUS
+#define CONFIG_PCI_IO_SIZE		0xe000
+
+#define CONFIG_SYS_EARLY_PCI_INIT
+#define CONFIG_PCI_PNP
+#define CONFIG_E1000
+
+#define CONFIG_STD_DEVICES_SETTINGS     "stdin=serial\0" \
+					"stdout=serial\0" \
+					"stderr=serial\0"
+
+#define CONFIG_SCSI_DEV_LIST            \
+	{PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_TCF_SATA}
+
+#define CONFIG_SPI_FLASH_SST
+
+#define CONFIG_MMC
+#define CONFIG_SDHCI
+#define CONFIG_GENERIC_MMC
+#define CONFIG_MMC_SDMA
+#define CONFIG_CMD_MMC
+
+/* Video is not supported */
+#undef CONFIG_VIDEO
+#undef CONFIG_CFB_CONSOLE
+
+#endif	/* __CONFIG_H */
diff -ruN u-boot-2015.01-rc3/include/configs/dalmore.h u-boot/include/configs/dalmore.h
--- u-boot-2015.01-rc3/include/configs/dalmore.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/dalmore.h	2015-01-01 17:34:32.789494465 +0100
@@ -36,12 +36,7 @@
 
 /* I2C */
 #define CONFIG_SYS_I2C_TEGRA
-#define CONFIG_SYS_I2C_INIT_BOARD
-#define CONFIG_I2C_MULTI_BUS
-#define CONFIG_SYS_MAX_I2C_BUS		TEGRA_I2C_NUM_CONTROLLERS
-#define CONFIG_SYS_I2C_SPEED		100000
 #define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
 
 /* SD/MMC */
 #define CONFIG_MMC
diff -ruN u-boot-2015.01-rc3/include/configs/gose.h u-boot/include/configs/gose.h
--- u-boot-2015.01-rc3/include/configs/gose.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/gose.h	2015-01-01 17:34:32.793494399 +0100
@@ -91,4 +91,14 @@
 #define CONFIG_USB_EHCI_RMOBILE
 #define CONFIG_USB_MAX_CONTROLLER_COUNT	2
 
+/* Module stop status bits */
+/* INTC-RT */
+#define CONFIG_SMSTP0_ENA	0x00400000
+/* MSIF */
+#define CONFIG_SMSTP2_ENA	0x00002000
+/* INTC-SYS, IRQC */
+#define CONFIG_SMSTP4_ENA	0x00000180
+/* SCIF0 */
+#define CONFIG_SMSTP7_ENA	0x00200000
+
 #endif	/* __GOSE_H */
diff -ruN u-boot-2015.01-rc3/include/configs/jetson-tk1.h u-boot/include/configs/jetson-tk1.h
--- u-boot-2015.01-rc3/include/configs/jetson-tk1.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/jetson-tk1.h	2015-01-01 17:34:32.797494333 +0100
@@ -25,12 +25,7 @@
 
 /* I2C */
 #define CONFIG_SYS_I2C_TEGRA
-#define CONFIG_SYS_I2C_INIT_BOARD
-#define CONFIG_I2C_MULTI_BUS
-#define CONFIG_SYS_MAX_I2C_BUS		TEGRA_I2C_NUM_CONTROLLERS
-#define CONFIG_SYS_I2C_SPEED		100000
 #define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
 
 /* SD/MMC */
 #define CONFIG_MMC
diff -ruN u-boot-2015.01-rc3/include/configs/km/kmp204x-common.h u-boot/include/configs/km/kmp204x-common.h
--- u-boot-2015.01-rc3/include/configs/km/kmp204x-common.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/km/kmp204x-common.h	2015-01-01 17:34:32.797494333 +0100
@@ -339,10 +339,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf4200000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff4200000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
diff -ruN u-boot-2015.01-rc3/include/configs/koelsch.h u-boot/include/configs/koelsch.h
--- u-boot-2015.01-rc3/include/configs/koelsch.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/koelsch.h	2015-01-01 17:34:32.797494333 +0100
@@ -92,4 +92,15 @@
 #define CONFIG_USB_MAX_CONTROLLER_COUNT	2
 #define CONFIG_USB_STORAGE
 
+
+/* Module stop status bits */
+/* INTC-RT */
+#define CONFIG_SMSTP0_ENA	0x00400000
+/* MSIF*/
+#define CONFIG_SMSTP2_ENA	0x00002000
+/* INTC-SYS, IRQC */
+#define CONFIG_SMSTP4_ENA	0x00000180
+/* SCIF0 */
+#define CONFIG_SMSTP7_ENA	0x00200000
+
 #endif	/* __KOELSCH_H */
diff -ruN u-boot-2015.01-rc3/include/configs/lager.h u-boot/include/configs/lager.h
--- u-boot-2015.01-rc3/include/configs/lager.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/lager.h	2015-01-01 17:34:32.797494333 +0100
@@ -93,4 +93,23 @@
 #define CONFIG_USB_MAX_CONTROLLER_COUNT	3
 #define CONFIG_USB_STORAGE
 
+/* MMC */
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+
+#define CONFIG_SH_MMCIF
+#define CONFIG_SH_MMCIF_ADDR		0xEE220000
+#define CONFIG_SH_MMCIF_CLK		97500000
+
+/* Module stop status bits */
+/* INTC-RT */
+#define CONFIG_SMSTP0_ENA	0x00400000
+/* MSIF */
+#define CONFIG_SMSTP2_ENA	0x00002000
+/* INTC-SYS, IRQC */
+#define CONFIG_SMSTP4_ENA	0x00000180
+/* SCIF0 */
+#define CONFIG_SMSTP7_ENA	0x00200000
+
 #endif	/* __LAGER_H */
diff -ruN u-boot-2015.01-rc3/include/configs/ls1021aqds.h u-boot/include/configs/ls1021aqds.h
--- u-boot-2015.01-rc3/include/configs/ls1021aqds.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/ls1021aqds.h	2015-01-01 17:34:32.797494333 +0100
@@ -37,8 +37,85 @@
 unsigned long get_board_ddr_clk(void);
 #endif
 
+#ifdef CONFIG_QSPI_BOOT
+#define CONFIG_SYS_CLK_FREQ		100000000
+#define CONFIG_DDR_CLK_FREQ		100000000
+#define CONFIG_QIXIS_I2C_ACCESS
+#else
 #define CONFIG_SYS_CLK_FREQ		get_board_sys_clk()
 #define CONFIG_DDR_CLK_FREQ		get_board_ddr_clk()
+#endif
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_SYS_FSL_PBL_PBI	board/freescale/ls1021aqds/ls102xa_pbi.cfg
+#endif
+
+#ifdef CONFIG_SD_BOOT
+#define CONFIG_SYS_FSL_PBL_RCW	board/freescale/ls1021aqds/ls102xa_rcw_sd.cfg
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_LDSCRIPT	"arch/$(ARCH)/cpu/u-boot-spl.lds"
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_WATCHDOG_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_DRIVERS_MISC_SUPPORT
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR		0xe8
+#define CONFIG_SYS_U_BOOT_MAX_SIZE_SECTORS		0x400
+
+#define CONFIG_SPL_TEXT_BASE		0x10000000
+#define CONFIG_SPL_MAX_SIZE		0x1a000
+#define CONFIG_SPL_STACK		0x1001d000
+#define CONFIG_SPL_PAD_TO		0x1c000
+#define CONFIG_SYS_TEXT_BASE		0x82000000
+
+#define CONFIG_SYS_SPL_MALLOC_START	0x80200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x100000
+#define CONFIG_SPL_BSS_START_ADDR	0x80100000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x80000
+#define CONFIG_SYS_MONITOR_LEN		0x80000
+#endif
+
+#ifdef CONFIG_QSPI_BOOT
+#define CONFIG_SYS_TEXT_BASE		0x40010000
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#ifdef CONFIG_NAND_BOOT
+#define CONFIG_SYS_FSL_PBL_RCW	board/freescale/ls1021aqds/ls102xa_rcw_nand.cfg
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_LDSCRIPT	"arch/$(ARCH)/cpu/u-boot-spl.lds"
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_WATCHDOG_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_DRIVERS_MISC_SUPPORT
+
+#define CONFIG_SPL_TEXT_BASE		0x10000000
+#define CONFIG_SPL_MAX_SIZE		0x1a000
+#define CONFIG_SPL_STACK		0x1001d000
+#define CONFIG_SPL_PAD_TO		0x1c000
+#define CONFIG_SYS_TEXT_BASE		0x82000000
+
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(400 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	CONFIG_SPL_PAD_TO
+#define CONFIG_SYS_NAND_PAGE_SIZE	2048
+#define CONFIG_SYS_NAND_U_BOOT_DST	CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_NAND_U_BOOT_START	CONFIG_SYS_TEXT_BASE
+
+#define CONFIG_SYS_SPL_MALLOC_START	0x80200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x100000
+#define CONFIG_SPL_BSS_START_ADDR	0x80100000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x80000
+#define CONFIG_SYS_MONITOR_LEN		0x80000
+#endif
 
 #ifndef CONFIG_SYS_TEXT_BASE
 #define CONFIG_SYS_TEXT_BASE		0x67f80000
@@ -71,13 +148,15 @@
 
 #define CONFIG_FSL_CAAM			/* Enable CAAM */
 
-#if !defined(CONFIG_SDCARD) && !defined(CONFIG_NAND) && !defined(CONFIG_SPI)
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_NAND_BOOT) && \
+	!defined(CONFIG_QSPI_BOOT)
 #define CONFIG_U_QE
 #endif
 
 /*
  * IFC Definitions
  */
+#ifndef CONFIG_QSPI_BOOT
 #define CONFIG_FSL_IFC
 #define CONFIG_SYS_FLASH_BASE		0x60000000
 #define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
@@ -170,6 +249,7 @@
 #define CONFIG_CMD_NAND
 
 #define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+#endif
 
 /*
  * QIXIS Definitions
@@ -214,6 +294,40 @@
 #define CONFIG_SYS_FPGA_FTIM3		0x0
 #endif
 
+#if defined(CONFIG_NAND_BOOT)
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR3_EXT		CONFIG_SYS_FPGA_CSPR_EXT
+#define CONFIG_SYS_CSPR3		CONFIG_SYS_FPGA_CSPR
+#define CONFIG_SYS_AMASK3		CONFIG_SYS_FPGA_AMASK
+#define CONFIG_SYS_CSOR3		CONFIG_SYS_FPGA_CSOR
+#define CONFIG_SYS_CS3_FTIM0		CONFIG_SYS_FPGA_FTIM0
+#define CONFIG_SYS_CS3_FTIM1		CONFIG_SYS_FPGA_FTIM1
+#define CONFIG_SYS_CS3_FTIM2		CONFIG_SYS_FPGA_FTIM2
+#define CONFIG_SYS_CS3_FTIM3		CONFIG_SYS_FPGA_FTIM3
+#else
 #define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
 #define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
 #define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
@@ -246,6 +360,7 @@
 #define CONFIG_SYS_CS3_FTIM1		CONFIG_SYS_FPGA_FTIM1
 #define CONFIG_SYS_CS3_FTIM2		CONFIG_SYS_FPGA_FTIM2
 #define CONFIG_SYS_CS3_FTIM3		CONFIG_SYS_FPGA_FTIM3
+#endif
 
 /*
  * Serial Port
@@ -279,6 +394,21 @@
 #define CONFIG_FSL_ESDHC
 #define CONFIG_GENERIC_MMC
 
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+
+/* QSPI */
+#ifdef CONFIG_QSPI_BOOT
+#define CONFIG_FSL_QSPI
+#define QSPI0_AMBA_BASE			0x40000000
+#define FSL_QSPI_FLASH_SIZE		(1 << 24)
+#define FSL_QSPI_FLASH_NUM		2
+
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_SPANSION
+#endif
+
 /*
  * USB
  */
@@ -341,6 +471,14 @@
 #endif
 
 #endif
+
+/* PCIe */
+#define CONFIG_PCI		/* Enable PCI/PCIE */
+#define CONFIG_PCIE1		/* PCIE controler 1 */
+#define CONFIG_PCIE2		/* PCIE controler 2 */
+#define CONFIG_PCIE_LAYERSCAPE	/* Use common FSL Layerscape PCIe code */
+#define FSL_PCIE_COMPAT "fsl,ls1021a-pcie"
+
 #define CONFIG_CMD_PING
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_MII
@@ -348,7 +486,20 @@
 
 #define CONFIG_CMDLINE_TAG
 #define CONFIG_CMDLINE_EDITING
+
+#ifdef CONFIG_QSPI_BOOT
+#undef CONFIG_CMD_IMLS
+#else
 #define CONFIG_CMD_IMLS
+#endif
+
+#define CONFIG_ARMV7_NONSEC
+#define CONFIG_ARMV7_VIRT
+#define CONFIG_PEN_ADDR_BIG_ENDIAN
+#define CONFIG_LS102XA_NS_ACCESS
+#define CONFIG_SMP_PEN_ADDR		0x01ee0200
+#define CONFIG_TIMER_CLK_FREQ		12500000
+#define CONFIG_ARMV7_SECURE_BASE	OCRAM_BASE_S_ADDR
 
 #define CONFIG_HWCONFIG
 #define HWCONFIG_BUFFER_SIZE		128
@@ -385,6 +536,8 @@
 
 #define CONFIG_SYS_LOAD_ADDR		0x82000000
 
+#define CONFIG_LS102XA_STREAM_ID
+
 /*
  * Stack sizes
  * The stack sizes are set up in start.S using the settings below
@@ -396,17 +549,37 @@
 #define CONFIG_SYS_INIT_SP_ADDR \
 	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
 
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SPL_TEXT_BASE
+#else
 #define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#endif
 
 /*
  * Environment
  */
 #define CONFIG_ENV_OVERWRITE
 
+#if defined(CONFIG_SD_BOOT)
+#define CONFIG_ENV_OFFSET		0x100000
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_SIZE			0x2000
+#elif defined(CONFIG_QSPI_BOOT)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SIZE			0x2000          /* 8KB */
+#define CONFIG_ENV_OFFSET		0x100000        /* 1MB */
+#define CONFIG_ENV_SECT_SIZE		0x10000
+#elif defined(CONFIG_NAND_BOOT)
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(10 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#else
 #define CONFIG_ENV_IS_IN_FLASH
 #define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
 #define CONFIG_ENV_SIZE			0x2000
 #define CONFIG_ENV_SECT_SIZE		0x20000 /* 128K (one sector) */
+#endif
 
 #define CONFIG_OF_LIBFDT
 #define CONFIG_OF_BOARD_SETUP
diff -ruN u-boot-2015.01-rc3/include/configs/ls1021atwr.h u-boot/include/configs/ls1021atwr.h
--- u-boot-2015.01-rc3/include/configs/ls1021atwr.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/ls1021atwr.h	2015-01-01 17:34:32.797494333 +0100
@@ -35,6 +35,43 @@
 #define CONFIG_SYS_CLK_FREQ		100000000
 #define CONFIG_DDR_CLK_FREQ		100000000
 
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_SYS_FSL_PBL_PBI	board/freescale/ls1021atwr/ls102xa_pbi.cfg
+#endif
+
+#ifdef CONFIG_SD_BOOT
+#define CONFIG_SYS_FSL_PBL_RCW	board/freescale/ls1021atwr/ls102xa_rcw_sd.cfg
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_LDSCRIPT	"arch/$(ARCH)/cpu/u-boot-spl.lds"
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_WATCHDOG_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR		0xe8
+#define CONFIG_SYS_U_BOOT_MAX_SIZE_SECTORS		0x400
+
+#define CONFIG_SPL_TEXT_BASE		0x10000000
+#define CONFIG_SPL_MAX_SIZE		0x1a000
+#define CONFIG_SPL_STACK		0x1001d000
+#define CONFIG_SPL_PAD_TO		0x1c000
+#define CONFIG_SYS_TEXT_BASE		0x82000000
+
+#define CONFIG_SYS_SPL_MALLOC_START	0x80200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x100000
+#define CONFIG_SPL_BSS_START_ADDR	0x80100000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x80000
+#define CONFIG_SYS_MONITOR_LEN		0x80000
+#endif
+
+#ifdef CONFIG_QSPI_BOOT
+#define CONFIG_SYS_TEXT_BASE		0x40010000
+#define CONFIG_SYS_NO_FLASH
+#endif
+
 #ifndef CONFIG_SYS_TEXT_BASE
 #define CONFIG_SYS_TEXT_BASE		0x67f80000
 #endif
@@ -50,13 +87,15 @@
 
 #define CONFIG_FSL_CAAM			/* Enable CAAM */
 
-#if !defined(CONFIG_SDCARD) && !defined(CONFIG_NAND) && !defined(CONFIG_SPI)
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_NAND_BOOT) && \
+	!defined(CONFIG_QSPI_BOOT)
 #define CONFIG_U_QE
 #endif
 
 /*
  * IFC Definitions
  */
+#ifndef CONFIG_QSPI_BOOT
 #define CONFIG_FSL_IFC
 #define CONFIG_SYS_FLASH_BASE		0x60000000
 #define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
@@ -100,6 +139,7 @@
 
 #define CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
 #define CONFIG_SYS_WRITE_SWAPPED_DATA
+#endif
 
 /* CPLD */
 
@@ -180,6 +220,21 @@
 #define CONFIG_FSL_ESDHC
 #define CONFIG_GENERIC_MMC
 
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+
+/* QSPI */
+#ifdef CONFIG_QSPI_BOOT
+#define CONFIG_FSL_QSPI
+#define QSPI0_AMBA_BASE			0x40000000
+#define FSL_QSPI_FLASH_SIZE		(1 << 24)
+#define FSL_QSPI_FLASH_NUM		2
+
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#endif
+
 /*
  * Video
  */
@@ -236,6 +291,13 @@
 #define CONFIG_HAS_ETH2
 #endif
 
+/* PCIe */
+#define CONFIG_PCI		/* Enable PCI/PCIE */
+#define CONFIG_PCIE1		/* PCIE controler 1 */
+#define CONFIG_PCIE2		/* PCIE controler 2 */
+#define CONFIG_PCIE_LAYERSCAPE	/* Use common FSL Layerscape PCIe code */
+#define FSL_PCIE_COMPAT "fsl,ls1021a-pcie"
+
 #define CONFIG_CMD_PING
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_MII
@@ -243,7 +305,20 @@
 
 #define CONFIG_CMDLINE_TAG
 #define CONFIG_CMDLINE_EDITING
+
+#ifdef CONFIG_QSPI_BOOT
+#undef CONFIG_CMD_IMLS
+#else
 #define CONFIG_CMD_IMLS
+#endif
+
+#define CONFIG_ARMV7_NONSEC
+#define CONFIG_ARMV7_VIRT
+#define CONFIG_PEN_ADDR_BIG_ENDIAN
+#define CONFIG_LS102XA_NS_ACCESS
+#define CONFIG_SMP_PEN_ADDR		0x01ee0200
+#define CONFIG_TIMER_CLK_FREQ		12500000
+#define CONFIG_ARMV7_SECURE_BASE	OCRAM_BASE_S_ADDR
 
 #define CONFIG_HWCONFIG
 #define HWCONFIG_BUFFER_SIZE		128
@@ -277,6 +352,8 @@
 
 #define CONFIG_SYS_LOAD_ADDR		0x82000000
 
+#define CONFIG_LS102XA_STREAM_ID
+
 /*
  * Stack sizes
  * The stack sizes are set up in start.S using the settings below
@@ -288,7 +365,11 @@
 #define CONFIG_SYS_INIT_SP_ADDR \
 	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
 
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SPL_TEXT_BASE
+#else
 #define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#endif
 
 #define CONFIG_SYS_QE_FW_ADDR     0x67f40000
 
@@ -297,10 +378,22 @@
  */
 #define CONFIG_ENV_OVERWRITE
 
+#if defined(CONFIG_SD_BOOT)
+#define CONFIG_ENV_OFFSET		0x100000
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_SIZE			0x20000
+#elif defined(CONFIG_QSPI_BOOT)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		0x100000
+#define CONFIG_ENV_SECT_SIZE		0x10000
+#else
 #define CONFIG_ENV_IS_IN_FLASH
 #define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
 #define CONFIG_ENV_SIZE			0x20000
 #define CONFIG_ENV_SECT_SIZE		0x20000 /* 128K (one sector) */
+#endif
 
 #define CONFIG_OF_LIBFDT
 #define CONFIG_OF_BOARD_SETUP
diff -ruN u-boot-2015.01-rc3/include/configs/mx53loco.h u-boot/include/configs/mx53loco.h
--- u-boot-2015.01-rc3/include/configs/mx53loco.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/mx53loco.h	2015-01-01 17:34:32.801494268 +0100
@@ -94,6 +94,7 @@
 /* Command definition */
 #include <config_cmd_default.h>
 #define CONFIG_CMD_BOOTZ
+#define CONFIG_SUPPORT_RAW_INITRD
 
 #undef CONFIG_CMD_IMLS
 
diff -ruN u-boot-2015.01-rc3/include/configs/mx6sabre_common.h u-boot/include/configs/mx6sabre_common.h
--- u-boot-2015.01-rc3/include/configs/mx6sabre_common.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/mx6sabre_common.h	2015-01-01 17:34:32.801494268 +0100
@@ -220,9 +220,6 @@
 #define CONFIG_SYS_PROMPT_HUSH_PS2     "> "
 #define CONFIG_AUTO_COMPLETE
 #define CONFIG_SYS_CBSIZE              256
-
-/* Print Buffer Size */
-#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
 #define CONFIG_SYS_MAXARGS             16
 #define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
 
diff -ruN u-boot-2015.01-rc3/include/configs/mx6slevk.h u-boot/include/configs/mx6slevk.h
--- u-boot-2015.01-rc3/include/configs/mx6slevk.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/mx6slevk.h	2015-01-01 17:34:32.805494202 +0100
@@ -209,6 +209,20 @@
 #define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
 #endif
 
+/* USB Configs */
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS		0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#endif
+
 #define CONFIG_SYS_FSL_USDHC_NUM	3
 #if defined(CONFIG_ENV_IS_IN_MMC)
 #define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC2*/
diff -ruN u-boot-2015.01-rc3/include/configs/mx6sxsabresd.h u-boot/include/configs/mx6sxsabresd.h
--- u-boot-2015.01-rc3/include/configs/mx6sxsabresd.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/mx6sxsabresd.h	2015-01-01 17:34:32.805494202 +0100
@@ -198,6 +198,20 @@
 #define CONFIG_PHYLIB
 #define CONFIG_PHY_ATHEROS
 
+
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#endif
+
 #define CONFIG_CMD_PCI
 #ifdef CONFIG_CMD_PCI
 #define CONFIG_PCI
@@ -208,6 +222,16 @@
 #define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(2, 1)
 #endif
 
+#define CONFIG_DM
+#define CONFIG_DM_THERMAL
+#define CONFIG_SYS_MALLOC_F_LEN	(1 << 10)
+#define CONFIG_IMX6_THERMAL
+
+#define CONFIG_CMD_FUSE
+#if defined(CONFIG_CMD_FUSE) || defined(CONFIG_IMX6_THERMAL)
+#define CONFIG_MXC_OCOTP
+#endif
+
 /* FLASH and environment organization */
 #define CONFIG_SYS_NO_FLASH
 
diff -ruN u-boot-2015.01-rc3/include/configs/nyan-big.h u-boot/include/configs/nyan-big.h
--- u-boot-2015.01-rc3/include/configs/nyan-big.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/nyan-big.h	2015-01-01 17:34:32.805494202 +0100
@@ -0,0 +1,74 @@
+/*
+ * (C) Copyright 2014
+ * NVIDIA Corporation <www.nvidia.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <linux/sizes.h>
+
+#include "tegra124-common.h"
+
+/* High-level configuration options */
+#define V_PROMPT			"Tegra124 (Nyan-big) # "
+#define CONFIG_TEGRA_BOARD_STRING	"Google/NVIDIA Nyan-big"
+
+/* Board-specific serial config */
+#define CONFIG_SERIAL_MULTI
+#define CONFIG_TEGRA_ENABLE_UARTA
+#define CONFIG_SYS_NS16550_COM1		NV_PA_APB_UARTA_BASE
+
+#define CONFIG_BOARD_EARLY_INIT_F
+
+/* I2C */
+#define CONFIG_SYS_I2C_TEGRA
+#define CONFIG_CMD_I2C
+
+/* SD/MMC */
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_TEGRA_MMC
+#define CONFIG_CMD_MMC
+
+/* Environment in eMMC, at the end of 2nd "boot sector" */
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_SYS_MMC_ENV_PART		2
+#define CONFIG_ENV_OFFSET		(-CONFIG_ENV_SIZE)
+
+/* SPI */
+#define CONFIG_TEGRA114_SPI		/* Compatible w/ Tegra114 SPI */
+#define CONFIG_TEGRA114_SPI_CTRLS	6
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_WINBOND
+#define CONFIG_SF_DEFAULT_MODE         SPI_MODE_0
+#define CONFIG_SF_DEFAULT_SPEED        24000000
+#define CONFIG_CMD_SPI
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH_SIZE          (4 << 20)
+
+/* USB Host support */
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_TEGRA
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#define CONFIG_USB_STORAGE
+#define CONFIG_CMD_USB
+
+/* USB networking support */
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+
+/* General networking support */
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_DHCP
+
+#define CONFIG_FIT
+#define CONFIG_OF_LIBFDT
+
+#include "tegra-common-usb-gadget.h"
+#include "tegra-common-post.h"
+
+#endif /* __CONFIG_H */
diff -ruN u-boot-2015.01-rc3/include/configs/P1023RDB.h u-boot/include/configs/P1023RDB.h
--- u-boot-2015.01-rc3/include/configs/P1023RDB.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/P1023RDB.h	2015-01-01 17:34:32.769494793 +0100
@@ -347,9 +347,25 @@
 #define CONFIG_SYS_QMAN_MEM_BASE	0xff000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_BMAN_MEM_BASE	0xff200000
 #define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 
 /* For FM */
 #define CONFIG_SYS_DPAA_FMAN
diff -ruN u-boot-2015.01-rc3/include/configs/P2041RDB.h u-boot/include/configs/P2041RDB.h
--- u-boot-2015.01-rc3/include/configs/P2041RDB.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/P2041RDB.h	2015-01-01 17:34:32.769494793 +0100
@@ -13,6 +13,8 @@
 
 #define CONFIG_P2041RDB
 #define CONFIG_PHYS_64BIT
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
 #define CONFIG_PPC_P2041
 
 #ifdef CONFIG_RAMBOOT_PBL
@@ -489,6 +491,14 @@
 #define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf4200000
 #ifdef CONFIG_PHYS_64BIT
@@ -497,6 +507,14 @@
 #define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
diff -ruN u-boot-2015.01-rc3/include/configs/rcar-gen2-common.h u-boot/include/configs/rcar-gen2-common.h
--- u-boot-2015.01-rc3/include/configs/rcar-gen2-common.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/rcar-gen2-common.h	2015-01-01 17:34:32.809494137 +0100
@@ -28,6 +28,9 @@
 #define CONFIG_CMD_FAT
 #define CONFIG_CMD_SF
 #define CONFIG_CMD_SPI
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_EXT4
+#define CONFIG_CMD_EXT4_WRITE
 
 #define CONFIG_SYS_THUMB_BUILD
 #define CONFIG_SYS_GENERIC_BOARD
@@ -36,6 +39,7 @@
 #define CONFIG_FAT_WRITE
 #define CONFIG_DOS_PARTITION
 #define CONFIG_SUPPORT_VFAT
+#define CONFIG_FS_EXT4
 #define CONFIG_EXT4_WRITE
 
 #define CONFIG_CMDLINE_TAG
diff -ruN u-boot-2015.01-rc3/include/configs/rpi.h u-boot/include/configs/rpi.h
--- u-boot-2015.01-rc3/include/configs/rpi.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/rpi.h	2015-01-01 17:34:32.809494137 +0100
@@ -34,6 +34,7 @@
 #define CONFIG_DM
 #define CONFIG_CMD_DM
 #define CONFIG_DM_GPIO
+#define CONFIG_DM_SERIAL
 
 /* Memory layout */
 #define CONFIG_NR_DRAM_BANKS		1
@@ -51,6 +52,7 @@
 					 CONFIG_SYS_SDRAM_SIZE - \
 					 GENERATED_GBL_DATA_SIZE)
 #define CONFIG_SYS_MALLOC_LEN		SZ_4M
+#define CONFIG_SYS_MALLOC_F_LEN		(1 << 10)
 #define CONFIG_SYS_MEMTEST_START	0x00100000
 #define CONFIG_SYS_MEMTEST_END		0x00200000
 #define CONFIG_LOADADDR			0x00200000
@@ -92,9 +94,7 @@
 #endif
 
 /* Console UART */
-#define CONFIG_PL011_SERIAL
-#define CONFIG_PL011_CLOCK		3000000
-#define CONFIG_PL01x_PORTS		{ (void *)0x20201000 }
+#define CONFIG_PL01X_SERIAL
 #define CONFIG_CONS_INDEX		0
 #define CONFIG_BAUDRATE			115200
 
diff -ruN u-boot-2015.01-rc3/include/configs/sandbox.h u-boot/include/configs/sandbox.h
--- u-boot-2015.01-rc3/include/configs/sandbox.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/sandbox.h	2015-01-01 17:34:32.809494137 +0100
@@ -112,6 +112,12 @@
 #define CONFIG_SPI_FLASH_STMICRO
 #define CONFIG_SPI_FLASH_WINBOND
 
+#define CONFIG_DM_I2C
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C_SANDBOX
+#define CONFIG_I2C_EDID
+#define CONFIG_I2C_EEPROM
+
 /* Memory things - we don't really want a memory test */
 #define CONFIG_SYS_LOAD_ADDR		0x00000000
 #define CONFIG_SYS_MEMTEST_START	0x00100000
diff -ruN u-boot-2015.01-rc3/include/configs/seaboard.h u-boot/include/configs/seaboard.h
--- u-boot-2015.01-rc3/include/configs/seaboard.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/seaboard.h	2015-01-01 17:34:32.813494071 +0100
@@ -37,10 +37,7 @@
 
 /* I2C */
 #define CONFIG_SYS_I2C_TEGRA
-#define CONFIG_SYS_I2C_INIT_BOARD
-#define CONFIG_SYS_I2C_SPEED		100000
 #define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
 
 /* SD/MMC */
 #define CONFIG_MMC
diff -ruN u-boot-2015.01-rc3/include/configs/socfpga_common.h u-boot/include/configs/socfpga_common.h
--- u-boot-2015.01-rc3/include/configs/socfpga_common.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/socfpga_common.h	2015-01-01 17:34:32.813494071 +0100
@@ -159,7 +159,7 @@
 #define CONFIG_SYS_MMC_MAX_BLK_COUNT	256	/* FIXME -- SPL only? */
 #endif
 
- /*
+/*
  * I2C support
  */
 #define CONFIG_SYS_I2C
@@ -187,6 +187,37 @@
 #define CONFIG_CMD_I2C
 
 /*
+ * QSPI support
+ */
+#ifdef CONFIG_OF_CONTROL	/* QSPI is controlled via DT */
+#define CONFIG_CMD_DM
+#define CONFIG_DM
+#define CONFIG_DM_SPI
+#define CONFIG_DM_SPI_FLASH
+#define CONFIG_CADENCE_QSPI
+/* Enable multiple SPI NOR flash manufacturers */
+#define CONFIG_SPI_FLASH		/* SPI flash subsystem */
+#define CONFIG_SPI_FLASH_STMICRO	/* Micron/Numonyx flash */
+#define CONFIG_SPI_FLASH_SPANSION	/* Spansion flash */
+#define CONFIG_SPI_FLASH_MTD
+/* QSPI reference clock */
+#ifndef __ASSEMBLY__
+unsigned int cm_get_qspi_controller_clk_hz(void);
+#define CONFIG_CQSPI_REF_CLK		cm_get_qspi_controller_clk_hz()
+#endif
+#define CONFIG_CQSPI_DECODER		0
+#define CONFIG_CMD_SF
+#endif
+
+#ifdef CONFIG_OF_CONTROL	/* DW SPI is controlled via DT */
+#define CONFIG_CMD_DM
+#define CONFIG_DM
+#define CONFIG_DM_SPI
+#define CONFIG_DESIGNWARE_SPI
+#define CONFIG_CMD_SPI
+#endif
+
+/*
  * Serial Driver
  */
 #define CONFIG_SYS_NS16550
diff -ruN u-boot-2015.01-rc3/include/configs/stv0991.h u-boot/include/configs/stv0991.h
--- u-boot-2015.01-rc3/include/configs/stv0991.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/stv0991.h	2015-01-01 17:34:32.813494071 +0100
@@ -0,0 +1,95 @@
+/*
+ * (C) Copyright 2014
+ * Vikas Manocha, STMicroelectronics, <vikas.manocha@st.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_STV0991_H
+#define __CONFIG_STV0991_H
+#define CONFIG_SYS_DCACHE_OFF
+#define CONFIG_SYS_EXCEPTION_VECTORS_HIGH
+#define CONFIG_BOARD_EARLY_INIT_F
+
+#define CONFIG_SYS_CORTEX_R4
+
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_SYS_NO_FLASH
+
+/* ram memory-related information */
+#define CONFIG_NR_DRAM_BANKS			1
+#define PHYS_SDRAM_1				0x00000000
+#define CONFIG_SYS_SDRAM_BASE			PHYS_SDRAM_1
+#define PHYS_SDRAM_1_SIZE			0x00198000
+
+#define CONFIG_ENV_SIZE				0x10000
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR				\
+	(PHYS_SDRAM_1_SIZE - CONFIG_ENV_SIZE)
+#define CONFIG_SYS_MAXARGS			16
+#define CONFIG_SYS_MALLOC_LEN			(CONFIG_ENV_SIZE + 16 * 1024)
+#define CONFIG_SYS_MALLOC_F_LEN			0x2000
+
+#define CONFIG_DM
+/* serial port (PL011) configuration */
+#define CONFIG_BAUDRATE				115200
+#ifdef CONFIG_DM
+#define CONFIG_DM_SERIAL
+#define CONFIG_PL01X_SERIAL
+#else
+#define CONFIG_SYS_SERIAL0                     0x80406000
+#define CONFIG_CONS_INDEX			0
+#define CONFIG_PL011_SERIAL
+#define CONFIG_PL01x_PORTS                     {(void *)CONFIG_SYS_SERIAL0}
+#define CONFIG_PL011_CLOCK                     (2700 * 1000)
+#endif
+
+/* user interface */
+#define CONFIG_SYS_PROMPT			"STV0991> "
+#define CONFIG_SYS_CBSIZE			1024
+#define CONFIG_SYS_PBSIZE			(CONFIG_SYS_CBSIZE \
+						+sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* MISC */
+#define CONFIG_SYS_LOAD_ADDR			0x00000000
+#define CONFIG_SYS_INIT_RAM_SIZE		0x8000
+#define CONFIG_SYS_INIT_RAM_ADDR		0x00190000
+#define CONFIG_SYS_INIT_SP_OFFSET		\
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+/* U-boot Load Address */
+#define CONFIG_SYS_TEXT_BASE			0x00010000
+#define CONFIG_SYS_INIT_SP_ADDR			\
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* GMAC related configs */
+
+#define CONFIG_MII
+#define CONFIG_PHYLIB
+#define CONFIG_CMD_NET
+#define CONFIG_DESIGNWARE_ETH
+#define CONFIG_DW_ALTDESCRIPTOR
+#define CONFIG_PHY_MICREL
+
+/* Command support defines */
+#define CONFIG_CMD_PING
+#define CONFIG_PHY_RESET_DELAY			10000		/* in usec */
+
+#include "config_cmd_default.h"
+#undef CONFIG_CMD_SAVEENV
+
+#define CONFIG_SYS_MEMTEST_START               0x0000
+#define CONFIG_SYS_MEMTEST_END                 1024*1024
+#define CONFIG_CMD_MEMTEST
+
+/* Misc configuration */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+
+#define CONFIG_BOOTDELAY                       3
+#define CONFIG_BOOTCOMMAND                     "go 0x40040000"
+#define CONFIG_AUTOBOOT_KEYED
+#define CONFIG_AUTOBOOT_STOP_STR               " "
+#define CONFIG_AUTOBOOT_PROMPT                 \
+	"Hit SPACE in %d seconds to stop autoboot.\n", bootdelay
+
+#endif /* __CONFIG_H */
diff -ruN u-boot-2015.01-rc3/include/configs/sun7i.h u-boot/include/configs/sun7i.h
--- u-boot-2015.01-rc3/include/configs/sun7i.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/sun7i.h	2015-01-01 17:34:32.813494071 +0100
@@ -25,6 +25,7 @@
 #define CONFIG_ARMV7_PSCI		1
 #define CONFIG_ARMV7_SECURE_BASE	SUNXI_SRAM_B_BASE
 #define CONFIG_SYS_CLK_FREQ		24000000
+#define CONFIG_TIMER_CLK_FREQ		CONFIG_SYS_CLK_FREQ
 
 /*
  * Include common sunxi configuration where most the settings are
diff -ruN u-boot-2015.01-rc3/include/configs/T102xQDS.h u-boot/include/configs/T102xQDS.h
--- u-boot-2015.01-rc3/include/configs/T102xQDS.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/T102xQDS.h	2015-01-01 17:34:32.773494727 +0100
@@ -720,7 +720,7 @@
 /* Qman/Bman */
 #ifndef CONFIG_NOBQFMAN
 #define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
-#define CONFIG_SYS_BMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_NUM_PORTALS	10
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
@@ -728,7 +728,15 @@
 #define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
-#define CONFIG_SYS_QMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
+#define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
@@ -736,6 +744,14 @@
 #define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 
diff -ruN u-boot-2015.01-rc3/include/configs/T102xRDB.h u-boot/include/configs/T102xRDB.h
--- u-boot-2015.01-rc3/include/configs/T102xRDB.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/T102xRDB.h	2015-01-01 17:34:32.773494727 +0100
@@ -677,7 +677,7 @@
 /* Qman/Bman */
 #ifndef CONFIG_NOBQFMAN
 #define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
-#define CONFIG_SYS_BMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_NUM_PORTALS	10
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
@@ -685,7 +685,15 @@
 #define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
-#define CONFIG_SYS_QMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
+#define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
@@ -693,6 +701,14 @@
 #define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 
diff -ruN u-boot-2015.01-rc3/include/configs/T1040QDS.h u-boot/include/configs/T1040QDS.h
--- u-boot-2015.01-rc3/include/configs/T1040QDS.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/T1040QDS.h	2015-01-01 17:34:32.773494727 +0100
@@ -605,14 +605,30 @@
 /* Qman/Bman */
 #ifndef CONFIG_NOBQFMAN
 #define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
-#define CONFIG_SYS_BMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_NUM_PORTALS	10
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
-#define CONFIG_SYS_QMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
+#define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
diff -ruN u-boot-2015.01-rc3/include/configs/T104xRDB.h u-boot/include/configs/T104xRDB.h
--- u-boot-2015.01-rc3/include/configs/T104xRDB.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/T104xRDB.h	2015-01-01 17:34:32.773494727 +0100
@@ -104,7 +104,10 @@
 
 /* support deep sleep */
 #define CONFIG_DEEP_SLEEP
+#if defined(CONFIG_DEEP_SLEEP)
+#define CONFIG_BOARD_EARLY_INIT_F
 #define CONFIG_SILENT_CONSOLE
+#endif
 
 #ifndef CONFIG_SYS_TEXT_BASE
 #define CONFIG_SYS_TEXT_BASE	0xeff40000
@@ -636,14 +639,30 @@
 /* Qman/Bman */
 #ifndef CONFIG_NOBQFMAN
 #define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
-#define CONFIG_SYS_BMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_NUM_PORTALS	10
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
-#define CONFIG_SYS_QMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
+#define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
diff -ruN u-boot-2015.01-rc3/include/configs/T208xQDS.h u-boot/include/configs/T208xQDS.h
--- u-boot-2015.01-rc3/include/configs/T208xQDS.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/T208xQDS.h	2015-01-01 17:34:32.773494727 +0100
@@ -634,10 +634,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG    0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	18
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
diff -ruN u-boot-2015.01-rc3/include/configs/T208xRDB.h u-boot/include/configs/T208xRDB.h
--- u-boot-2015.01-rc3/include/configs/T208xRDB.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/T208xRDB.h	2015-01-01 17:34:32.773494727 +0100
@@ -567,10 +567,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	18
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
diff -ruN u-boot-2015.01-rc3/include/configs/T4240EMU.h u-boot/include/configs/T4240EMU.h
--- u-boot-2015.01-rc3/include/configs/T4240EMU.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/T4240EMU.h	2015-01-01 17:34:32.773494727 +0100
@@ -85,10 +85,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG    0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	50
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
diff -ruN u-boot-2015.01-rc3/include/configs/T4240QDS.h u-boot/include/configs/T4240QDS.h
--- u-boot-2015.01-rc3/include/configs/T4240QDS.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/T4240QDS.h	2015-01-01 17:34:32.773494727 +0100
@@ -417,10 +417,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG    0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	50
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
diff -ruN u-boot-2015.01-rc3/include/configs/T4240RDB.h u-boot/include/configs/T4240RDB.h
--- u-boot-2015.01-rc3/include/configs/T4240RDB.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/T4240RDB.h	2015-01-01 17:34:32.773494727 +0100
@@ -12,6 +12,8 @@
 
 #define CONFIG_T4240RDB
 #define CONFIG_PHYS_64BIT
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
 
 #define CONFIG_FSL_SATA_V2
 #define CONFIG_PCIE4
@@ -577,10 +579,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG    0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	50
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
diff -ruN u-boot-2015.01-rc3/include/configs/tbs2910.h u-boot/include/configs/tbs2910.h
--- u-boot-2015.01-rc3/include/configs/tbs2910.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/tbs2910.h	2015-01-01 17:34:32.817494006 +0100
@@ -167,7 +167,7 @@
 #define CONFIG_USB_STORAGE
 #define CONFIG_USB_KEYBOARD
 #ifdef CONFIG_USB_KEYBOARD
-#define CONFIG_SYS_USB_EVENT_POLL
+#define CONFIG_SYS_USB_EVENT_POLL_VIA_INT_QUEUE
 #define CONFIG_SYS_STDIO_DEREGISTER
 #define CONFIG_PREBOOT "if hdmidet; then usb start; fi"
 #endif /* CONFIG_USB_KEYBOARD */
diff -ruN u-boot-2015.01-rc3/include/configs/tec-ng.h u-boot/include/configs/tec-ng.h
--- u-boot-2015.01-rc3/include/configs/tec-ng.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/tec-ng.h	2015-01-01 17:34:32.817494006 +0100
@@ -23,12 +23,7 @@
 
 /* I2C */
 #define CONFIG_SYS_I2C_TEGRA
-#define CONFIG_SYS_I2C_INIT_BOARD
-#define CONFIG_I2C_MULTI_BUS
-#define CONFIG_SYS_MAX_I2C_BUS		TEGRA_I2C_NUM_CONTROLLERS
-#define CONFIG_SYS_I2C_SPEED		100000
 #define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
 
 /* SD/MMC */
 #define CONFIG_MMC
diff -ruN u-boot-2015.01-rc3/include/configs/tegra114-common.h u-boot/include/configs/tegra114-common.h
--- u-boot-2015.01-rc3/include/configs/tegra114-common.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/tegra114-common.h	2015-01-01 17:34:32.817494006 +0100
@@ -76,9 +76,6 @@
 #define CONFIG_SYS_SPL_MALLOC_START	0x80090000
 #define CONFIG_SPL_STACK		0x800ffffc
 
-/* Total I2C ports on Tegra114 */
-#define TEGRA_I2C_NUM_CONTROLLERS	5
-
 /* For USB EHCI controller */
 #define CONFIG_EHCI_IS_TDI
 #define CONFIG_USB_EHCI_TXFIFO_THRESH	0x10
diff -ruN u-boot-2015.01-rc3/include/configs/tegra124-common.h u-boot/include/configs/tegra124-common.h
--- u-boot-2015.01-rc3/include/configs/tegra124-common.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/tegra124-common.h	2015-01-01 17:34:32.817494006 +0100
@@ -68,9 +68,6 @@
 #define CONFIG_SYS_SPL_MALLOC_START	0x80090000
 #define CONFIG_SPL_STACK		0x800ffffc
 
-/* Total I2C ports on Tegra124 */
-#define TEGRA_I2C_NUM_CONTROLLERS	5
-
 /* For USB EHCI controller */
 #define CONFIG_EHCI_IS_TDI
 #define CONFIG_USB_EHCI_TXFIFO_THRESH	0x10
diff -ruN u-boot-2015.01-rc3/include/configs/tegra20-common.h u-boot/include/configs/tegra20-common.h
--- u-boot-2015.01-rc3/include/configs/tegra20-common.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/tegra20-common.h	2015-01-01 17:34:32.817494006 +0100
@@ -97,9 +97,6 @@
 #define CONFIG_EHCI_IS_TDI
 #define CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS 1
 
-/* Total I2C ports on Tegra20 */
-#define TEGRA_I2C_NUM_CONTROLLERS	4
-
 #define CONFIG_SYS_NAND_SELF_INIT
 #define CONFIG_SYS_NAND_ONFI_DETECTION
 
diff -ruN u-boot-2015.01-rc3/include/configs/tegra30-common.h u-boot/include/configs/tegra30-common.h
--- u-boot-2015.01-rc3/include/configs/tegra30-common.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/tegra30-common.h	2015-01-01 17:34:32.817494006 +0100
@@ -73,9 +73,6 @@
 #define CONFIG_SYS_SPL_MALLOC_START	0x80090000
 #define CONFIG_SPL_STACK		0x800ffffc
 
-/* Total I2C ports on Tegra30 */
-#define TEGRA_I2C_NUM_CONTROLLERS	5
-
 /* For USB EHCI controller */
 #define CONFIG_EHCI_IS_TDI
 #define CONFIG_USB_EHCI_TXFIFO_THRESH	0x10
diff -ruN u-boot-2015.01-rc3/include/configs/tegra-common.h u-boot/include/configs/tegra-common.h
--- u-boot-2015.01-rc3/include/configs/tegra-common.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/tegra-common.h	2015-01-01 17:34:32.817494006 +0100
@@ -26,6 +26,7 @@
 #endif
 #define CONFIG_DM_SPI
 #define CONFIG_DM_SPI_FLASH
+#define CONFIG_DM_I2C
 
 #define CONFIG_SYS_TIMER_RATE		1000000
 #define CONFIG_SYS_TIMER_COUNTER	NV_PA_TMRUS_BASE
diff -ruN u-boot-2015.01-rc3/include/configs/trimslice.h u-boot/include/configs/trimslice.h
--- u-boot-2015.01-rc3/include/configs/trimslice.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/trimslice.h	2015-01-01 17:34:32.817494006 +0100
@@ -34,10 +34,7 @@
 
 /* I2C */
 #define CONFIG_SYS_I2C_TEGRA
-#define CONFIG_SYS_I2C_INIT_BOARD
-#define CONFIG_SYS_I2C_SPEED		100000
 #define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
 
 /* SD/MMC */
 #define CONFIG_MMC
diff -ruN u-boot-2015.01-rc3/include/configs/uniphier.h u-boot/include/configs/uniphier.h
--- u-boot-2015.01-rc3/include/configs/uniphier.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/uniphier.h	2015-01-01 17:34:32.817494006 +0100
@@ -187,6 +187,8 @@
 #define CONFIG_FAT_WRITE
 #define CONFIG_DOS_PARTITION
 
+#define CONFIG_CMD_DM
+
 /* memtest works on */
 #define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
 #define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x01000000)
@@ -273,7 +275,11 @@
 #define CONFIG_SYS_SPL_MALLOC_START	(0x0ff00000)
 #define CONFIG_SYS_SPL_MALLOC_SIZE	(0x00004000)
 
+#ifdef CONFIG_SPL_BUILD
 #define CONFIG_SYS_INIT_SP_ADDR		(0x0ff08000)
+#else
+#define CONFIG_SYS_INIT_SP_ADDR		((CONFIG_SYS_TEXT_BASE) - 0x00001000)
+#endif
 
 #define CONFIG_SPL_FRAMEWORK
 #define CONFIG_SPL_NAND_SUPPORT
diff -ruN u-boot-2015.01-rc3/include/configs/venice2.h u-boot/include/configs/venice2.h
--- u-boot-2015.01-rc3/include/configs/venice2.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/venice2.h	2015-01-01 17:34:32.821493940 +0100
@@ -25,12 +25,7 @@
 
 /* I2C */
 #define CONFIG_SYS_I2C_TEGRA
-#define CONFIG_SYS_I2C_INIT_BOARD
-#define CONFIG_I2C_MULTI_BUS
-#define CONFIG_SYS_MAX_I2C_BUS		TEGRA_I2C_NUM_CONTROLLERS
-#define CONFIG_SYS_I2C_SPEED		100000
 #define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
 
 /* SD/MMC */
 #define CONFIG_MMC
diff -ruN u-boot-2015.01-rc3/include/configs/vexpress_aemv8a.h u-boot/include/configs/vexpress_aemv8a.h
--- u-boot-2015.01-rc3/include/configs/vexpress_aemv8a.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/vexpress_aemv8a.h	2015-01-01 17:34:32.821493940 +0100
@@ -8,6 +8,9 @@
 #ifndef __VEXPRESS_AEMV8A_H
 #define __VEXPRESS_AEMV8A_H
 
+/* We use generic board for v8 Versatile Express */
+#define CONFIG_SYS_GENERIC_BOARD
+
 #ifdef CONFIG_BASE_FVP
 #ifndef CONFIG_SEMIHOSTING
 #error CONFIG_BASE_FVP requires CONFIG_SEMIHOSTING
@@ -25,8 +28,6 @@
 
 /*#define CONFIG_ARMV8_SWITCH_TO_EL1*/
 
-/*#define CONFIG_SYS_GENERIC_BOARD*/
-
 #define CONFIG_SYS_NO_FLASH
 
 #define CONFIG_SUPPORT_RAW_INITRD
diff -ruN u-boot-2015.01-rc3/include/configs/whistler.h u-boot/include/configs/whistler.h
--- u-boot-2015.01-rc3/include/configs/whistler.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/configs/whistler.h	2015-01-01 17:34:32.821493940 +0100
@@ -26,10 +26,7 @@
 
 /* I2C */
 #define CONFIG_SYS_I2C_TEGRA
-#define CONFIG_SYS_I2C_INIT_BOARD
-#define CONFIG_SYS_I2C_SPEED		100000
 #define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
 
 /* SD/MMC */
 #define CONFIG_MMC
diff -ruN u-boot-2015.01-rc3/include/dfu.h u-boot/include/dfu.h
--- u-boot-2015.01-rc3/include/dfu.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/dfu.h	2015-01-01 17:34:32.825493874 +0100
@@ -150,9 +150,6 @@
 char *dfu_extract_token(char** e, int *n);
 void dfu_trigger_reset(void);
 int dfu_get_alt(char *name);
-bool dfu_detach(void);
-void dfu_trigger_detach(void);
-void dfu_clear_detach(void);
 int dfu_init_env_entities(char *interface, char *devstr);
 unsigned char *dfu_get_buf(struct dfu_entity *dfu);
 unsigned char *dfu_free_buf(void);
diff -ruN u-boot-2015.01-rc3/include/dm/uclass-id.h u-boot/include/dm/uclass-id.h
--- u-boot-2015.01-rc3/include/dm/uclass-id.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/dm/uclass-id.h	2015-01-01 17:34:32.825493874 +0100
@@ -19,6 +19,7 @@
 	UCLASS_TEST_FDT,
 	UCLASS_TEST_BUS,
 	UCLASS_SPI_EMUL,	/* sandbox SPI device emulator */
+	UCLASS_I2C_EMUL,	/* sandbox I2C device emulator */
 	UCLASS_SIMPLE_BUS,
 
 	/* U-Boot uclasses start here */
@@ -29,6 +30,9 @@
 	UCLASS_SPI_FLASH,	/* SPI flash */
 	UCLASS_CROS_EC,	/* Chrome OS EC */
 	UCLASS_THERMAL,		/* Thermal sensor */
+	UCLASS_I2C,		/* I2C bus */
+	UCLASS_I2C_GENERIC,	/* Generic I2C device */
+	UCLASS_I2C_EEPROM,	/* I2C EEPROM device */
 
 	UCLASS_COUNT,
 	UCLASS_INVALID = -1,
diff -ruN u-boot-2015.01-rc3/include/dm/ut.h u-boot/include/dm/ut.h
--- u-boot-2015.01-rc3/include/dm/ut.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/dm/ut.h	2015-01-01 17:34:32.825493874 +0100
@@ -89,6 +89,18 @@
 	}								\
 }
 
+/* Assert that a pointer is not NULL */
+#define ut_assertnonnull(expr) {					\
+	const void *val = (expr);					\
+									\
+	if (val == NULL) {						\
+		ut_failf(dms, __FILE__, __LINE__, __func__,		\
+			 #expr " = NULL",				\
+			 "Expected non-null, got NULL");		\
+		return -1;						\
+	}								\
+}
+
 /* Assert that an operation succeeds (returns 0) */
 #define ut_assertok(cond)	ut_asserteq(0, cond)
 
diff -ruN u-boot-2015.01-rc3/include/dt-bindings/pinctrl/pinctrl-tegra.h u-boot/include/dt-bindings/pinctrl/pinctrl-tegra.h
--- u-boot-2015.01-rc3/include/dt-bindings/pinctrl/pinctrl-tegra.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/dt-bindings/pinctrl/pinctrl-tegra.h	2015-01-01 17:34:32.825493874 +0100
@@ -0,0 +1,45 @@
+/*
+ * This header provides constants for Tegra pinctrl bindings.
+ *
+ * Copyright (c) 2013, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * Author: Laxman Dewangan <ldewangan@nvidia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _DT_BINDINGS_PINCTRL_TEGRA_H
+#define _DT_BINDINGS_PINCTRL_TEGRA_H
+
+/*
+ * Enable/disable for diffeent dt properties. This is applicable for
+ * properties nvidia,enable-input, nvidia,tristate, nvidia,open-drain,
+ * nvidia,lock, nvidia,rcv-sel, nvidia,high-speed-mode, nvidia,schmitt.
+ */
+#define TEGRA_PIN_DISABLE				0
+#define TEGRA_PIN_ENABLE				1
+
+#define TEGRA_PIN_PULL_NONE				0
+#define TEGRA_PIN_PULL_DOWN				1
+#define TEGRA_PIN_PULL_UP				2
+
+/* Low power mode driver */
+#define TEGRA_PIN_LP_DRIVE_DIV_8			0
+#define TEGRA_PIN_LP_DRIVE_DIV_4			1
+#define TEGRA_PIN_LP_DRIVE_DIV_2			2
+#define TEGRA_PIN_LP_DRIVE_DIV_1			3
+
+/* Rising/Falling slew rate */
+#define TEGRA_PIN_SLEW_RATE_FASTEST			0
+#define TEGRA_PIN_SLEW_RATE_FAST			1
+#define TEGRA_PIN_SLEW_RATE_SLOW			2
+#define TEGRA_PIN_SLEW_RATE_SLOWEST			3
+
+#endif
diff -ruN u-boot-2015.01-rc3/include/dt-bindings/reset/altr,rst-mgr.h u-boot/include/dt-bindings/reset/altr,rst-mgr.h
--- u-boot-2015.01-rc3/include/dt-bindings/reset/altr,rst-mgr.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/dt-bindings/reset/altr,rst-mgr.h	2015-01-01 17:34:32.825493874 +0100
@@ -1,14 +1,7 @@
 /*
  * Copyright (c) 2014, Steffen Trumtrar <s.trumtrar@pengutronix.de>
  *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * SPDX-License-Identifier:	GPL-2.0
  */
 
 #ifndef _DT_BINDINGS_RESET_ALTR_RST_MGR_H
diff -ruN u-boot-2015.01-rc3/include/errno.h u-boot/include/errno.h
--- u-boot-2015.01-rc3/include/errno.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/errno.h	2015-01-01 17:34:32.829493808 +0100
@@ -6,4 +6,7 @@
 
 #define __set_errno(val) do { errno = val; } while (0)
 
+#ifdef CONFIG_ERRNO_STR
+const char *errno_str(int errno);
+#endif
 #endif /* _ERRNO_H */
diff -ruN u-boot-2015.01-rc3/include/fsl_ddr_sdram.h u-boot/include/fsl_ddr_sdram.h
--- u-boot-2015.01-rc3/include/fsl_ddr_sdram.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/fsl_ddr_sdram.h	2015-01-01 17:34:32.829493808 +0100
@@ -114,6 +114,7 @@
 #define SDRAM_CFG_2T_EN			0x00008000
 #define SDRAM_CFG_BI			0x00000001
 
+#define SDRAM_CFG2_FRC_SR		0x80000000
 #define SDRAM_CFG2_D_INIT		0x00000010
 #define SDRAM_CFG2_ODT_CFG_MASK		0x00600000
 #define SDRAM_CFG2_ODT_NEVER		0
@@ -163,6 +164,7 @@
 #define DDR_CDR1_ODT(x) ((x & DDR_CDR1_ODT_MASK) << DDR_CDR1_ODT_SHIFT)
 #define DDR_CDR2_ODT(x) (x & DDR_CDR2_ODT_MASK)
 #define DDR_CDR2_VREF_OVRD(x)	(0x00008080 | ((((x) - 37) & 0x3F) << 8))
+#define DDR_CDR2_VREF_TRAIN_EN	0x00000080
 
 #if (defined(CONFIG_SYS_FSL_DDR_VER) && \
 	(CONFIG_SYS_FSL_DDR_VER >= FSL_DDR_VER_4_7))
@@ -202,6 +204,8 @@
 #define DDR_CDR_ODT_120ohm	0x6
 #endif
 
+#define DDR_INIT_ADDR_EXT_UIA	(1 << 31)
+
 /* Record of register values computed */
 typedef struct fsl_ddr_cfg_regs_s {
 	struct {
@@ -414,9 +418,11 @@
 int board_need_mem_reset(void)
 	__attribute__((weak, alias("__board_need_mem_reset")));
 
-void __weak board_mem_sleep_setup(void)
-{
-}
+#if defined(CONFIG_DEEP_SLEEP)
+void board_mem_sleep_setup(void);
+bool is_warm_boot(void);
+int fsl_dp_resume(void);
+#endif
 
 /*
  * The 85xx boards have a common prototype for fixed_sdram so put the
diff -ruN u-boot-2015.01-rc3/include/fsl_usb.h u-boot/include/fsl_usb.h
--- u-boot-2015.01-rc3/include/fsl_usb.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/fsl_usb.h	2015-01-01 17:34:32.829493808 +0100
@@ -145,6 +145,25 @@
 	return SVR_SOC_VER(get_svr()) == SVR_T4240 &&
 		IS_SVR_REV(get_svr(), 2, 0);
 }
+
+static inline bool has_erratum_a007792(void)
+{
+	u32 svr = get_svr();
+	u32 soc = SVR_SOC_VER(svr);
+
+	switch (soc) {
+	case SVR_T4240:
+	case SVR_T4160:
+		return IS_SVR_REV(svr, 2, 0);
+	case SVR_T1040:
+		return IS_SVR_REV(svr, 1, 0);
+	case SVR_T2080:
+	case SVR_T2081:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 1, 1);
+	}
+	return false;
+}
+
 #else
 static inline bool has_erratum_a006261(void)
 {
@@ -161,5 +180,9 @@
 	return false;
 }
 
+static inline bool has_erratum_a007792(void)
+{
+	return false;
+}
 #endif
 #endif /*_ASM_FSL_USB_H_ */
diff -ruN u-boot-2015.01-rc3/include/g_dnl.h u-boot/include/g_dnl.h
--- u-boot-2015.01-rc3/include/g_dnl.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/g_dnl.h	2015-01-01 17:34:32.829493808 +0100
@@ -39,4 +39,8 @@
 void g_dnl_unregister(void);
 void g_dnl_set_serialnumber(char *);
 
+bool g_dnl_detach(void);
+void g_dnl_trigger_detach(void);
+void g_dnl_clear_detach(void);
+
 #endif /* __G_DOWNLOAD_H_ */
diff -ruN u-boot-2015.01-rc3/include/i2c_eeprom.h u-boot/include/i2c_eeprom.h
--- u-boot-2015.01-rc3/include/i2c_eeprom.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/i2c_eeprom.h	2015-01-01 17:34:32.833493744 +0100
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2014 Google, Inc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __I2C_EEPROM
+#define __I2C_EEPROM
+
+struct i2c_eeprom_ops {
+	int (*read)(struct udevice *dev, int offset, uint8_t *buf, int size);
+	int (*write)(struct udevice *dev, int offset, const uint8_t *buf,
+		     int size);
+};
+
+struct i2c_eeprom {
+};
+
+#endif
diff -ruN u-boot-2015.01-rc3/include/i2c.h u-boot/include/i2c.h
--- u-boot-2015.01-rc3/include/i2c.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/i2c.h	2015-01-01 17:34:32.833493744 +0100
@@ -18,6 +18,355 @@
 #define _I2C_H_
 
 /*
+ * For now there are essentially two parts to this file - driver model
+ * here at the top, and the older code below (with CONFIG_SYS_I2C being
+ * most recent). The plan is to migrate everything to driver model.
+ * The driver model structures and API are separate as they are different
+ * enough as to be incompatible for compilation purposes.
+ */
+
+#ifdef CONFIG_DM_I2C
+
+enum dm_i2c_chip_flags {
+	DM_I2C_CHIP_10BIT	= 1 << 0, /* Use 10-bit addressing */
+	DM_I2C_CHIP_RD_ADDRESS	= 1 << 1, /* Send address for each read byte */
+	DM_I2C_CHIP_WR_ADDRESS	= 1 << 2, /* Send address for each write byte */
+};
+
+/**
+ * struct dm_i2c_chip - information about an i2c chip
+ *
+ * An I2C chip is a device on the I2C bus. It sits at a particular address
+ * and normally supports 7-bit or 10-bit addressing.
+ *
+ * To obtain this structure, use dev_get_parentdata(dev) where dev is the
+ * chip to examine.
+ *
+ * @chip_addr:	Chip address on bus
+ * @offset_len: Length of offset in bytes. A single byte offset can
+ *		represent up to 256 bytes. A value larger than 1 may be
+ *		needed for larger devices.
+ * @flags:	Flags for this chip (dm_i2c_chip_flags)
+ * @emul: Emulator for this chip address (only used for emulation)
+ */
+struct dm_i2c_chip {
+	uint chip_addr;
+	uint offset_len;
+	uint flags;
+#ifdef CONFIG_SANDBOX
+	struct udevice *emul;
+#endif
+};
+
+/**
+ * struct dm_i2c_bus- information about an i2c bus
+ *
+ * An I2C bus contains 0 or more chips on it, each at its own address. The
+ * bus can operate at different speeds (measured in Hz, typically 100KHz
+ * or 400KHz).
+ *
+ * To obtain this structure, use bus->uclass_priv where bus is the I2C
+ * bus udevice.
+ *
+ * @speed_hz: Bus speed in hertz (typically 100000)
+ */
+struct dm_i2c_bus {
+	int speed_hz;
+};
+
+/**
+ * i2c_read() - read bytes from an I2C chip
+ *
+ * To obtain an I2C device (called a 'chip') given the I2C bus address you
+ * can use i2c_get_chip(). To obtain a bus by bus number use
+ * uclass_get_device_by_seq(UCLASS_I2C, <bus number>).
+ *
+ * To set the address length of a devce use i2c_set_addr_len(). It
+ * defaults to 1.
+ *
+ * @dev:	Chip to read from
+ * @offset:	Offset within chip to start reading
+ * @buffer:	Place to put data
+ * @len:	Number of bytes to read
+ *
+ * @return 0 on success, -ve on failure
+ */
+int i2c_read(struct udevice *dev, uint offset, uint8_t *buffer,
+	     int len);
+
+/**
+ * i2c_write() - write bytes to an I2C chip
+ *
+ * See notes for i2c_read() above.
+ *
+ * @dev:	Chip to write to
+ * @offset:	Offset within chip to start writing
+ * @buffer:	Buffer containing data to write
+ * @len:	Number of bytes to write
+ *
+ * @return 0 on success, -ve on failure
+ */
+int i2c_write(struct udevice *dev, uint offset, const uint8_t *buffer,
+	      int len);
+
+/**
+ * i2c_probe() - probe a particular chip address
+ *
+ * This can be useful to check for the existence of a chip on the bus.
+ * It is typically implemented by writing the chip address to the bus
+ * and checking that the chip replies with an ACK.
+ *
+ * @bus:	Bus to probe
+ * @chip_addr:	7-bit address to probe (10-bit and others are not supported)
+ * @chip_flags:	Flags for the probe (see enum dm_i2c_chip_flags)
+ * @devp:	Returns the device found, or NULL if none
+ * @return 0 if a chip was found at that address, -ve if not
+ */
+int i2c_probe(struct udevice *bus, uint chip_addr, uint chip_flags,
+	      struct udevice **devp);
+
+/**
+ * i2c_set_bus_speed() - set the speed of a bus
+ *
+ * @bus:	Bus to adjust
+ * @speed:	Requested speed in Hz
+ * @return 0 if OK, -EINVAL for invalid values
+ */
+int i2c_set_bus_speed(struct udevice *bus, unsigned int speed);
+
+/**
+ * i2c_get_bus_speed() - get the speed of a bus
+ *
+ * @bus:	Bus to check
+ * @return speed of selected I2C bus in Hz, -ve on error
+ */
+int i2c_get_bus_speed(struct udevice *bus);
+
+/**
+ * i2c_set_chip_flags() - set flags for a chip
+ *
+ * Typically addresses are 7 bits, but for 10-bit addresses you should set
+ * flags to DM_I2C_CHIP_10BIT. All accesses will then use 10-bit addressing.
+ *
+ * @dev:	Chip to adjust
+ * @flags:	New flags
+ * @return 0 if OK, -EINVAL if value is unsupported, other -ve value on error
+ */
+int i2c_set_chip_flags(struct udevice *dev, uint flags);
+
+/**
+ * i2c_get_chip_flags() - get flags for a chip
+ *
+ * @dev:	Chip to check
+ * @flagsp:	Place to put flags
+ * @return 0 if OK, other -ve value on error
+ */
+int i2c_get_chip_flags(struct udevice *dev, uint *flagsp);
+
+/**
+ * i2c_set_offset_len() - set the offset length for a chip
+ *
+ * The offset used to access a chip may be up to 4 bytes long. Typically it
+ * is only 1 byte, which is enough for chips with 256 bytes of memory or
+ * registers. The default value is 1, but you can call this function to
+ * change it.
+ *
+ * @offset_len:	New offset length value (typically 1 or 2)
+ */
+
+int i2c_set_chip_offset_len(struct udevice *dev, uint offset_len);
+/**
+ * i2c_deblock() - recover a bus that is in an unknown state
+ *
+ * See the deblock() method in 'struct dm_i2c_ops' for full information
+ *
+ * @bus:	Bus to recover
+ * @return 0 if OK, -ve on error
+ */
+int i2c_deblock(struct udevice *bus);
+
+/*
+ * Not all of these flags are implemented in the U-Boot API
+ */
+enum dm_i2c_msg_flags {
+	I2C_M_TEN		= 0x0010, /* ten-bit chip address */
+	I2C_M_RD		= 0x0001, /* read data, from slave to master */
+	I2C_M_STOP		= 0x8000, /* send stop after this message */
+	I2C_M_NOSTART		= 0x4000, /* no start before this message */
+	I2C_M_REV_DIR_ADDR	= 0x2000, /* invert polarity of R/W bit */
+	I2C_M_IGNORE_NAK	= 0x1000, /* continue after NAK */
+	I2C_M_NO_RD_ACK		= 0x0800, /* skip the Ack bit on reads */
+	I2C_M_RECV_LEN		= 0x0400, /* length is first received byte */
+};
+
+/**
+ * struct i2c_msg - an I2C message
+ *
+ * @addr:	Slave address
+ * @flags:	Flags (see enum dm_i2c_msg_flags)
+ * @len:	Length of buffer in bytes, may be 0 for a probe
+ * @buf:	Buffer to send/receive, or NULL if no data
+ */
+struct i2c_msg {
+	uint addr;
+	uint flags;
+	uint len;
+	u8 *buf;
+};
+
+/**
+ * struct i2c_msg_list - a list of I2C messages
+ *
+ * This is called i2c_rdwr_ioctl_data in Linux but the name does not seem
+ * appropriate in U-Boot.
+ *
+ * @msg:	Pointer to i2c_msg array
+ * @nmsgs:	Number of elements in the array
+ */
+struct i2c_msg_list {
+	struct i2c_msg *msgs;
+	uint nmsgs;
+};
+
+/**
+ * struct dm_i2c_ops - driver operations for I2C uclass
+ *
+ * Drivers should support these operations unless otherwise noted. These
+ * operations are intended to be used by uclass code, not directly from
+ * other code.
+ */
+struct dm_i2c_ops {
+	/**
+	 * xfer() - transfer a list of I2C messages
+	 *
+	 * @bus:	Bus to read from
+	 * @msg:	List of messages to transfer
+	 * @nmsgs:	Number of messages in the list
+	 * @return 0 if OK, -EREMOTEIO if the slave did not ACK a byte,
+	 *	-ECOMM if the speed cannot be supported, -EPROTO if the chip
+	 *	flags cannot be supported, other -ve value on some other error
+	 */
+	int (*xfer)(struct udevice *bus, struct i2c_msg *msg, int nmsgs);
+
+	/**
+	 * probe_chip() - probe for the presense of a chip address
+	 *
+	 * This function is optional. If omitted, the uclass will send a zero
+	 * length message instead.
+	 *
+	 * @bus:	Bus to probe
+	 * @chip_addr:	Chip address to probe
+	 * @chip_flags:	Probe flags (enum dm_i2c_chip_flags)
+	 * @return 0 if chip was found, -EREMOTEIO if not, -ENOSYS to fall back
+	 * to default probem other -ve value on error
+	 */
+	int (*probe_chip)(struct udevice *bus, uint chip_addr, uint chip_flags);
+
+	/**
+	 * set_bus_speed() - set the speed of a bus (optional)
+	 *
+	 * The bus speed value will be updated by the uclass if this function
+	 * does not return an error. This method is optional - if it is not
+	 * provided then the driver can read the speed from
+	 * bus->uclass_priv->speed_hz
+	 *
+	 * @bus:	Bus to adjust
+	 * @speed:	Requested speed in Hz
+	 * @return 0 if OK, -EINVAL for invalid values
+	 */
+	int (*set_bus_speed)(struct udevice *bus, unsigned int speed);
+
+	/**
+	 * get_bus_speed() - get the speed of a bus (optional)
+	 *
+	 * Normally this can be provided by the uclass, but if you want your
+	 * driver to check the bus speed by looking at the hardware, you can
+	 * implement that here. This method is optional. This method would
+	 * normally be expected to return bus->uclass_priv->speed_hz.
+	 *
+	 * @bus:	Bus to check
+	 * @return speed of selected I2C bus in Hz, -ve on error
+	 */
+	int (*get_bus_speed)(struct udevice *bus);
+
+	/**
+	 * set_flags() - set the flags for a chip (optional)
+	 *
+	 * This is generally implemented by the uclass, but drivers can
+	 * check the value to ensure that unsupported options are not used.
+	 * This method is optional. If provided, this method will always be
+	 * called when the flags change.
+	 *
+	 * @dev:	Chip to adjust
+	 * @flags:	New flags value
+	 * @return 0 if OK, -EINVAL if value is unsupported
+	 */
+	int (*set_flags)(struct udevice *dev, uint flags);
+
+	/**
+	 * deblock() - recover a bus that is in an unknown state
+	 *
+	 * I2C is a synchronous protocol and resets of the processor in the
+	 * middle of an access can block the I2C Bus until a powerdown of
+	 * the full unit is done. This is because slaves can be stuck
+	 * waiting for addition bus transitions for a transaction that will
+	 * never complete. Resetting the I2C master does not help. The only
+	 * way is to force the bus through a series of transitions to make
+	 * sure that all slaves are done with the transaction. This method
+	 * performs this 'deblocking' if support by the driver.
+	 *
+	 * This method is optional.
+	 */
+	int (*deblock)(struct udevice *bus);
+};
+
+#define i2c_get_ops(dev)	((struct dm_i2c_ops *)(dev)->driver->ops)
+
+/**
+ * i2c_get_chip() - get a device to use to access a chip on a bus
+ *
+ * This returns the device for the given chip address. The device can then
+ * be used with calls to i2c_read(), i2c_write(), i2c_probe(), etc.
+ *
+ * @bus:	Bus to examine
+ * @chip_addr:	Chip address for the new device
+ * @devp:	Returns pointer to new device if found or -ENODEV if not
+ *		found
+ */
+int i2c_get_chip(struct udevice *bus, uint chip_addr, struct udevice **devp);
+
+/**
+ * i2c_get_chip() - get a device to use to access a chip on a bus number
+ *
+ * This returns the device for the given chip address on a particular bus
+ * number.
+ *
+ * @busnum:	Bus number to examine
+ * @chip_addr:	Chip address for the new device
+ * @devp:	Returns pointer to new device if found or -ENODEV if not
+ *		found
+ */
+int i2c_get_chip_for_busnum(int busnum, int chip_addr, struct udevice **devp);
+
+/**
+ * i2c_chip_ofdata_to_platdata() - Decode standard I2C platform data
+ *
+ * This decodes the chip address from a device tree node and puts it into
+ * its dm_i2c_chip structure. This should be called in your driver's
+ * ofdata_to_platdata() method.
+ *
+ * @blob:	Device tree blob
+ * @node:	Node offset to read from
+ * @spi:	Place to put the decoded information
+ */
+int i2c_chip_ofdata_to_platdata(const void *blob, int node,
+				struct dm_i2c_chip *chip);
+
+#endif
+
+#ifndef CONFIG_DM_I2C
+
+/*
  * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
  *
  * The implementation MUST NOT use static or global variables if the
@@ -451,4 +800,7 @@
  * @return 0 if port was reset, -1 if not found
  */
 int i2c_reset_port_fdt(const void *blob, int node);
+
+#endif /* !CONFIG_DM_I2C */
+
 #endif	/* _I2C_H_ */
diff -ruN u-boot-2015.01-rc3/include/linux/linkage.h u-boot/include/linux/linkage.h
--- u-boot-2015.01-rc3/include/linux/linkage.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/linux/linkage.h	2015-01-01 17:34:32.837493678 +0100
@@ -17,7 +17,9 @@
 #define CPP_ASMLINKAGE
 #endif
 
+#ifndef asmlinkage
 #define asmlinkage CPP_ASMLINKAGE
+#endif
 
 #define SYMBOL_NAME_STR(X)	#X
 #define SYMBOL_NAME(X)		X
diff -ruN u-boot-2015.01-rc3/include/linux/string.h u-boot/include/linux/string.h
--- u-boot-2015.01-rc3/include/linux/string.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/linux/string.h	2015-01-01 17:34:32.837493678 +0100
@@ -30,6 +30,9 @@
 #ifndef __HAVE_ARCH_STRNCPY
 extern char * strncpy(char *,const char *, __kernel_size_t);
 #endif
+#ifndef __HAVE_ARCH_STRLCPY
+size_t strlcpy(char *, const char *, size_t);
+#endif
 #ifndef __HAVE_ARCH_STRCAT
 extern char * strcat(char *, const char *);
 #endif
diff -ruN u-boot-2015.01-rc3/include/mmc.h u-boot/include/mmc.h
--- u-boot-2015.01-rc3/include/mmc.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/mmc.h	2015-01-01 17:34:32.841493612 +0100
@@ -31,6 +31,7 @@
 #define MMC_VERSION_4_3		(MMC_VERSION_MMC | 0x403)
 #define MMC_VERSION_4_41	(MMC_VERSION_MMC | 0x429)
 #define MMC_VERSION_4_5		(MMC_VERSION_MMC | 0x405)
+#define MMC_VERSION_5_0		(MMC_VERSION_MMC | 0x500)
 
 #define MMC_MODE_HS		(1 << 0)
 #define MMC_MODE_HS_52MHz	(1 << 1)
@@ -147,6 +148,7 @@
  * EXT_CSD fields
  */
 #define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
+#define EXT_CSD_PARTITION_SETTING	155	/* R/W */
 #define EXT_CSD_PARTITIONS_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITIONING_SUPPORT	160	/* RO */
 #define EXT_CSD_RST_N_FUNCTION		162	/* R/W */
@@ -197,6 +199,8 @@
 #define EXT_CSD_BOOT_BUS_WIDTH_RESET(x)	(x << 2)
 #define EXT_CSD_BOOT_BUS_WIDTH_WIDTH(x)	(x)
 
+#define EXT_CSD_PARTITION_SETTING_COMPLETED	(1 << 0)
+
 #define R1_ILLEGAL_COMMAND		(1 << 22)
 #define R1_APP_CMD			(1 << 5)
 
@@ -314,6 +318,7 @@
 	char init_in_progress;	/* 1 if we have done mmc_start_init() */
 	char preinit;		/* start init as early as possible */
 	uint op_cond_response;	/* the response byte from the last op_cond */
+	int ddr_mode;
 };
 
 int mmc_register(struct mmc *mmc);
diff -ruN u-boot-2015.01-rc3/include/part.h u-boot/include/part.h
--- u-boot-2015.01-rc3/include/part.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/part.h	2015-01-01 17:34:32.845493546 +0100
@@ -244,6 +244,26 @@
  */
 int gpt_restore(block_dev_desc_t *dev_desc, char *str_disk_guid,
 		disk_partition_t *partitions, const int parts_count);
+
+/**
+ * is_valid_gpt_buf() - Ensure that the Primary GPT information is valid
+ *
+ * @param dev_desc - block device descriptor
+ * @param buf - buffer which contains the MBR and Primary GPT info
+ *
+ * @return - '0' on success, otherwise error
+ */
+int is_valid_gpt_buf(block_dev_desc_t *dev_desc, void *buf);
+
+/**
+ * write_mbr_and_gpt_partitions() - write MBR, Primary GPT and Backup GPT
+ *
+ * @param dev_desc - block device descriptor
+ * @param buf - buffer which contains the MBR and Primary GPT info
+ *
+ * @return - '0' on success, otherwise error
+ */
+int write_mbr_and_gpt_partitions(block_dev_desc_t *dev_desc, void *buf);
 #endif
 
 #endif /* _PART_H */
diff -ruN u-boot-2015.01-rc3/include/pci_ids.h u-boot/include/pci_ids.h
--- u-boot-2015.01-rc3/include/pci_ids.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/pci_ids.h	2015-01-01 17:34:32.845493546 +0100
@@ -2998,6 +2998,14 @@
 #define PCI_DEVICE_ID_INTEL_82454NX     0x84cb
 #define PCI_DEVICE_ID_INTEL_84460GX	0x84ea
 #define PCI_DEVICE_ID_INTEL_IXP4XX	0x8500
+#define PCI_DEVICE_ID_INTEL_TCF_GBE	0x8802
+#define PCI_DEVICE_ID_INTEL_TCF_SDIO_0	0x8809
+#define PCI_DEVICE_ID_INTEL_TCF_SDIO_1	0x880a
+#define PCI_DEVICE_ID_INTEL_TCF_SATA	0x880b
+#define PCI_DEVICE_ID_INTEL_TCF_UART_0	0x8811
+#define PCI_DEVICE_ID_INTEL_TCF_UART_1	0x8812
+#define PCI_DEVICE_ID_INTEL_TCF_UART_2	0x8813
+#define PCI_DEVICE_ID_INTEL_TCF_UART_3	0x8814
 #define PCI_DEVICE_ID_INTEL_IXP2800	0x9004
 #define PCI_DEVICE_ID_INTEL_S21152BB	0xb152
 
diff -ruN u-boot-2015.01-rc3/include/smsc_lpc47m.h u-boot/include/smsc_lpc47m.h
--- u-boot-2015.01-rc3/include/smsc_lpc47m.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/smsc_lpc47m.h	2015-01-01 17:34:32.849493480 +0100
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2014, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SMSC_LPC47M_H_
+#define _SMSC_LPC47M_H_
+
+/**
+ * Configure the base I/O port of the specified serial device and enable the
+ * serial device.
+ *
+ * @dev: High 8 bits = Super I/O port, low 8 bits = logical device number.
+ * @iobase: Processor I/O port address to assign to this serial device.
+ */
+void lpc47m_enable_serial(u16 dev, u16 iobase);
+
+#endif /* _SMSC_LPC47M_H_ */
diff -ruN u-boot-2015.01-rc3/include/spi.h u-boot/include/spi.h
--- u-boot-2015.01-rc3/include/spi.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/spi.h	2015-01-01 17:34:32.849493480 +0100
@@ -34,6 +34,7 @@
 
 /* SPI TX operation modes */
 #define SPI_OPM_TX_QPP		(1 << 0)
+#define SPI_OPM_TX_BP		(1 << 1)
 
 /* SPI RX operation modes */
 #define SPI_OPM_RX_AS		(1 << 0)
diff -ruN u-boot-2015.01-rc3/include/tps6586x.h u-boot/include/tps6586x.h
--- u-boot-2015.01-rc3/include/tps6586x.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/tps6586x.h	2015-01-01 17:34:32.849493480 +0100
@@ -44,9 +44,9 @@
  * Set up the TPS6586X I2C bus number. This will be used for all operations
  * on the device. This function must be called before using other functions.
  *
- * @param bus	I2C bus number containing the TPS6586X chip
+ * @param bus	I2C bus containing the TPS6586X chip
  * @return 0 (always succeeds)
  */
-int tps6586x_init(int bus);
+int tps6586x_init(struct udevice *bus);
 
 #endif	/* _TPS6586X_H_ */
diff -ruN u-boot-2015.01-rc3/include/usb/ehci-fsl.h u-boot/include/usb/ehci-fsl.h
--- u-boot-2015.01-rc3/include/usb/ehci-fsl.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/include/usb/ehci-fsl.h	2015-01-01 17:34:32.853493416 +0100
@@ -280,7 +280,9 @@
 #define MXC_EHCI_IPPUE_DOWN		(1 << 10)
 #define MXC_EHCI_IPPUE_UP		(1 << 11)
 
+int usb_phy_mode(int port);
 /* Board-specific initialization */
 int board_ehci_hcd_init(int port);
+int board_usb_phy_mode(int port);
 
 #endif /* _EHCI_FSL_H */
diff -ruN u-boot-2015.01-rc3/lib/asm-offsets.c u-boot/lib/asm-offsets.c
--- u-boot-2015.01-rc3/lib/asm-offsets.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/lib/asm-offsets.c	2015-01-01 17:34:32.857493350 +0100
@@ -31,9 +31,6 @@
 #ifdef CONFIG_SYS_MALLOC_F_LEN
 	DEFINE(GD_MALLOC_BASE, offsetof(struct global_data, malloc_base));
 #endif
-#ifdef CONFIG_X86
-	DEFINE(GD_BIST, offsetof(struct global_data, arch.bist));
-#endif
 
 #if defined(CONFIG_ARM)
 
diff -ruN u-boot-2015.01-rc3/lib/errno_str.c u-boot/lib/errno_str.c
--- u-boot-2015.01-rc3/lib/errno_str.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/lib/errno_str.c	2015-01-01 17:34:32.857493350 +0100
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2014 Samsung Electronics
+ * Przemyslaw Marczak <p.marczak@samsung.com>
+ *
+ * SDPX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <errno.h>
+
+#define ERRNO_MSG(errno, msg)	msg
+#define SAME_AS(x)		(const char *)&errno_message[x]
+
+static const char * const errno_message[] = {
+	ERRNO_MSG(0, "Success"),
+	ERRNO_MSG(EPERM, "Operation not permitted"),
+	ERRNO_MSG(ENOEN, "No such file or directory"),
+	ERRNO_MSG(ESRCH, "No such process"),
+	ERRNO_MSG(EINTR, "Interrupted system call"),
+	ERRNO_MSG(EIO, "I/O error"),
+	ERRNO_MSG(ENXIO, "No such device or address"),
+	ERRNO_MSG(E2BIG, "Argument list too long"),
+	ERRNO_MSG(ENOEXEC, "Exec format error"),
+	ERRNO_MSG(EBADF, "Bad file number"),
+	ERRNO_MSG(ECHILD, "No child processes"),
+	ERRNO_MSG(EAGAIN, "Try again"),
+	ERRNO_MSG(ENOMEM, "Out of memory"),
+	ERRNO_MSG(EACCES, "Permission denied"),
+	ERRNO_MSG(EFAULT, "Bad address"),
+	ERRNO_MSG(ENOTBL, "Block device required"),
+	ERRNO_MSG(EBUSY, "Device or resource busy"),
+	ERRNO_MSG(EEXIST, "File exists"),
+	ERRNO_MSG(EXDEV, "Cross-device link"),
+	ERRNO_MSG(ENODEV, "No such device"),
+	ERRNO_MSG(ENOTDIR, "Not a directory"),
+	ERRNO_MSG(EISDIR, "Is a directory"),
+	ERRNO_MSG(EINVAL, "Invalid argument"),
+	ERRNO_MSG(ENFILE, "File table overflow"),
+	ERRNO_MSG(EMFILE, "Too many open files"),
+	ERRNO_MSG(ENOTTY, "Not a typewriter"),
+	ERRNO_MSG(ETXTBSY, "Text file busy"),
+	ERRNO_MSG(EFBIG, "File too large"),
+	ERRNO_MSG(ENOSPC, "No space left on device"),
+	ERRNO_MSG(ESPIPE, "Illegal seek"),
+	ERRNO_MSG(EROFS, "Read-only file system"),
+	ERRNO_MSG(EMLINK, "Too many links"),
+	ERRNO_MSG(EPIPE, "Broken pipe"),
+	ERRNO_MSG(EDOM, "Math argument out of domain of func"),
+	ERRNO_MSG(ERANGE, "Math result not representable"),
+	ERRNO_MSG(EDEADLK, "Resource deadlock would occur"),
+	ERRNO_MSG(ENAMETOOLONG, "File name too long"),
+	ERRNO_MSG(ENOLCK, "No record locks available"),
+	ERRNO_MSG(ENOSYS, "Function not implemented"),
+	ERRNO_MSG(ENOTEMPTY, "Directory not empty"),
+	ERRNO_MSG(ELOOP, "Too many symbolic links encountered"),
+	ERRNO_MSG(EWOULDBLOCK, SAME_AS(EAGAIN)),
+	ERRNO_MSG(ENOMSG, "No message of desired type"),
+	ERRNO_MSG(EIDRM, "Identifier removed"),
+	ERRNO_MSG(ECHRNG, "Channel number out of range"),
+	ERRNO_MSG(EL2NSYNC, "Level 2 not synchronized"),
+	ERRNO_MSG(EL3HLT, "Level 3 halted"),
+	ERRNO_MSG(EL3RST, "Level 3 reset"),
+	ERRNO_MSG(ELNRNG, "Link number out of range"),
+	ERRNO_MSG(EUNATCH, "Protocol driver not attached"),
+	ERRNO_MSG(ENOCSI, "No CSI structure available"),
+	ERRNO_MSG(EL2HLT, "Level 2 halted"),
+	ERRNO_MSG(EBADE, "Invalid exchange"),
+	ERRNO_MSG(EBADR, "Invalid request descriptor"),
+	ERRNO_MSG(EXFULL, "Exchange full"),
+	ERRNO_MSG(ENOANO, "No anode"),
+	ERRNO_MSG(EBADRQC, "Invalid request code"),
+	ERRNO_MSG(EBADSLT, "Invalid slot"),
+	ERRNO_MSG(EDEADLOCK, SAME_AS(EDEADLK)),
+	ERRNO_MSG(EBFONT, "Bad font file format"),
+	ERRNO_MSG(ENOSTR, "Device not a stream"),
+	ERRNO_MSG(ENODATA, "No data available"),
+	ERRNO_MSG(ETIME, "Timer expired"),
+	ERRNO_MSG(ENOSR, "Out of streams resources"),
+	ERRNO_MSG(ENONET, "Machine is not on the network"),
+	ERRNO_MSG(ENOPKG, "Package not installed"),
+	ERRNO_MSG(EREMOTE, "Object is remote"),
+	ERRNO_MSG(ENOLINK, "Link has been severed"),
+	ERRNO_MSG(EADV, "Advertise error"),
+	ERRNO_MSG(ESRMNT, "Srmount error"),
+	ERRNO_MSG(ECOMM, "Communication error on send"),
+	ERRNO_MSG(EPROTO, "Protocol error"),
+	ERRNO_MSG(EMULTIHOP, "Multihop attempted"),
+	ERRNO_MSG(EDOTDOT, "RFS specific error"),
+	ERRNO_MSG(EBADMSG, "Not a data message"),
+	ERRNO_MSG(EOVERFLOW, "Value too large for defined data type"),
+	ERRNO_MSG(ENOTUNIQ, "Name not unique on network"),
+	ERRNO_MSG(EBADFD, "File descriptor in bad state"),
+	ERRNO_MSG(EREMCHG, "Remote address changed"),
+	ERRNO_MSG(ELIBACC, "Can not access a needed shared library"),
+	ERRNO_MSG(ELIBBAD, "Accessing a corrupted shared library"),
+	ERRNO_MSG(ELIBSCN, ".lib section in a.out corrupted"),
+	ERRNO_MSG(ELIBMAX, "Attempting to link in too many shared libraries"),
+	ERRNO_MSG(ELIBEXEC, "Cannot exec a shared library directly"),
+	ERRNO_MSG(EILSEQ, "Illegal byte sequence"),
+	ERRNO_MSG(ERESTART, "Interrupted system call should be restarted"),
+	ERRNO_MSG(ESTRPIPE, "Streams pipe error"),
+	ERRNO_MSG(EUSERS, "Too many users"),
+	ERRNO_MSG(ENOTSOCK, "Socket operation on non-socket"),
+	ERRNO_MSG(EDESTADDRREQ, "Destination address required"),
+	ERRNO_MSG(EMSGSIZE, "Message too long"),
+	ERRNO_MSG(EPROTOTYPE, "Protocol wrong type for socket"),
+	ERRNO_MSG(ENOPROTOOPT, "Protocol not available"),
+	ERRNO_MSG(EPROTONOSUPPORT, "Protocol not supported"),
+	ERRNO_MSG(ESOCKTNOSUPPORT, "Socket type not supported"),
+	ERRNO_MSG(EOPNOTSUPP, "Operation not supported on transport endpoint"),
+	ERRNO_MSG(EPFNOSUPPORT, "Protocol family not supported"),
+	ERRNO_MSG(AFNOSUPPORT, "Address family not supported by protocol"),
+	ERRNO_MSG(EADDRINUSE, "Address already in use"),
+	ERRNO_MSG(EADDRNOTAVAIL, "Cannot assign requested address"),
+	ERRNO_MSG(ENETDOWN, "Network is down"),
+	ERRNO_MSG(ENETUNREACH, "Network is unreachable"),
+	ERRNO_MSG(ENETRESET, "Network dropped connection because of reset"),
+	ERRNO_MSG(ECONNABORTED, "Software caused connection abort"),
+	ERRNO_MSG(ECONNRESET, "Connection reset by peer"),
+	ERRNO_MSG(ENOBUFS, "No buffer space available"),
+	ERRNO_MSG(EISCONN, "Transport endpoint is already connected"),
+	ERRNO_MSG(ENOTCONN, "Transport endpoint is not connected"),
+	ERRNO_MSG(ESHUTDOWN, "Cannot send after transport endpoint shutdown"),
+	ERRNO_MSG(ETOOMANYREFS, "Too many references: cannot splice"),
+	ERRNO_MSG(ETIMEDOUT, "Connection timed out"),
+	ERRNO_MSG(ECONNREFUSED, "Connection refused"),
+	ERRNO_MSG(EHOSTDOWN, "Host is down"),
+	ERRNO_MSG(EHOSTUNREACH, "No route to host"),
+	ERRNO_MSG(EALREADY, "Operation already in progress"),
+	ERRNO_MSG(EINPROGRESS, "Operation now in progress"),
+	ERRNO_MSG(ESTALE, "Stale NFS file handle"),
+	ERRNO_MSG(EUCLEAN, "Structure needs cleaning"),
+	ERRNO_MSG(ENOTNAM, "Not a XENIX named type file"),
+	ERRNO_MSG(ENAVAIL, "No XENIX semaphores available"),
+	ERRNO_MSG(EISNAM, "Is a named type file"),
+	ERRNO_MSG(EREMOTEIO, "Remote I/O error"),
+	ERRNO_MSG(EDQUOT, "Quota exceeded"),
+	ERRNO_MSG(ENOMEDIUM, "No medium found"),
+	ERRNO_MSG(EMEDIUMTYPE, "Wrong medium type"),
+};
+
+const char *errno_str(int errno)
+{
+	if (errno >= 0)
+		return errno_message[0];
+
+	return errno_message[abs(errno)];
+}
diff -ruN u-boot-2015.01-rc3/lib/initcall.c u-boot/lib/initcall.c
--- u-boot-2015.01-rc3/lib/initcall.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/lib/initcall.c	2015-01-01 17:34:32.861493284 +0100
@@ -19,7 +19,11 @@
 
 		if (gd->flags & GD_FLG_RELOC)
 			reloc_ofs = gd->reloc_off;
-		debug("initcall: %p\n", (char *)*init_fnc_ptr - reloc_ofs);
+		debug("initcall: %p", (char *)*init_fnc_ptr - reloc_ofs);
+		if (gd->flags & GD_FLG_RELOC)
+			debug(" (relocated to %p)\n", (char *)*init_fnc_ptr);
+		else
+			debug("\n");
 		ret = (*init_fnc_ptr)();
 		if (ret) {
 			printf("initcall sequence %p failed at call %p (err=%d)\n",
diff -ruN u-boot-2015.01-rc3/lib/Makefile u-boot/lib/Makefile
--- u-boot-2015.01-rc3/lib/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/lib/Makefile	2015-01-01 17:34:32.857493350 +0100
@@ -51,6 +51,7 @@
 obj-$(CONFIG_ADDR_MAP) += addr_map.o
 obj-y += hashtable.o
 obj-y += errno.o
+obj-$(CONFIG_ERRNO_STR) += errno_str.o
 obj-y += display_options.o
 obj-$(CONFIG_BCH) += bch.o
 obj-y += crc32.o
diff -ruN u-boot-2015.01-rc3/lib/string.c u-boot/lib/string.c
--- u-boot-2015.01-rc3/lib/string.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/lib/string.c	2015-01-01 17:34:32.861493284 +0100
@@ -102,6 +102,31 @@
 }
 #endif
 
+#ifndef __HAVE_ARCH_STRLCPY
+/**
+ * strlcpy - Copy a C-string into a sized buffer
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ * @size: size of destination buffer
+ *
+ * Compatible with *BSD: the result is always a valid
+ * NUL-terminated string that fits in the buffer (unless,
+ * of course, the buffer size is zero). It does not pad
+ * out the result like strncpy() does.
+ */
+size_t strlcpy(char *dest, const char *src, size_t size)
+{
+	size_t ret = strlen(src);
+
+	if (size) {
+		size_t len = (ret >= size) ? size - 1 : ret;
+		memcpy(dest, src, len);
+		dest[len] = '\0';
+	}
+	return ret;
+}
+#endif
+
 #ifndef __HAVE_ARCH_STRCAT
 /**
  * strcat - Append one %NUL-terminated string to another
diff -ruN u-boot-2015.01-rc3/MAINTAINERS u-boot/MAINTAINERS
--- u-boot-2015.01-rc3/MAINTAINERS	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/MAINTAINERS	2015-01-01 17:34:31.981507711 +0100
@@ -128,6 +128,12 @@
 F:	arch/arm/cpu/arm926ejs/spear/
 F:	arch/arm/include/asm/arch-spear/
 
+ARM STM STV0991
+M:	Vikas Manocha <vikas.manocha@st.com>
+S:	Maintained
+F:	arch/arm/cpu/armv7/stv0991/
+F:	arch/arm/include/asm/arch-stv0991/
+
 ARM SUNXI
 M:	Ian Campbell <ijc@hellion.org.uk>
 M:	Hans De Goede <hdegoede@redhat.com>
diff -ruN u-boot-2015.01-rc3/Makefile u-boot/Makefile
--- u-boot-2015.01-rc3/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/Makefile	2015-01-01 17:34:31.981507711 +0100
@@ -1,7 +1,7 @@
 VERSION = 2015
 PATCHLEVEL = 01
 SUBLEVEL =
-EXTRAVERSION = -rc3
+EXTRAVERSION = -rc4
 NAME =
 
 # *DOCUMENTATION*
@@ -946,27 +946,43 @@
 ifneq ($(CONFIG_X86_RESET_VECTOR),)
 rom: u-boot.rom FORCE
 
-u-boot.rom: u-boot-x86-16bit.bin u-boot-dtb.bin \
-		$(srctree)/board/$(BOARDDIR)/mrc.bin
-	$(objtree)/tools/ifdtool -c -r $(CONFIG_ROM_SIZE) u-boot.tmp
-	if [ -n "$(CONFIG_HAVE_INTEL_ME)" ]; then \
-		$(objtree)/tools/ifdtool -D \
-			$(srctree)/board/$(BOARDDIR)/descriptor.bin u-boot.tmp; \
-		$(objtree)/tools/ifdtool \
-			-i ME:$(srctree)/board/$(BOARDDIR)/me.bin u-boot.tmp; \
-	fi
-	$(objtree)/tools/ifdtool -w \
-		$(CONFIG_SYS_TEXT_BASE):$(objtree)/u-boot-dtb.bin u-boot.tmp
-	$(objtree)/tools/ifdtool -w \
-		$(CONFIG_X86_MRC_START):$(srctree)/board/$(BOARDDIR)/mrc.bin \
-		u-boot.tmp
-	$(objtree)/tools/ifdtool -w \
-		$(CONFIG_SYS_X86_START16):$(objtree)/u-boot-x86-16bit.bin \
-		u-boot.tmp
-	$(objtree)/tools/ifdtool -w \
-		$(CONFIG_X86_OPTION_ROM_ADDR):$(srctree)/board/$(BOARDDIR)/$(CONFIG_X86_OPTION_ROM_FILENAME) \
-		u-boot.tmp
-	mv u-boot.tmp $@
+IFDTOOL=$(objtree)/tools/ifdtool
+IFDTOOL_FLAGS  = -f 0:$(objtree)/u-boot.dtb
+IFDTOOL_FLAGS += -m 0x$(shell $(NM) u-boot |grep _dt_ucode_base_size |cut -d' ' -f1)
+IFDTOOL_FLAGS += -U $(CONFIG_SYS_TEXT_BASE):$(objtree)/u-boot.bin
+IFDTOOL_FLAGS += -w $(CONFIG_SYS_X86_START16):$(objtree)/u-boot-x86-16bit.bin
+
+ifneq ($(CONFIG_HAVE_INTEL_ME),)
+IFDTOOL_ME_FLAGS  = -D $(srctree)/board/$(BOARDDIR)/descriptor.bin
+IFDTOOL_ME_FLAGS += -i ME:$(srctree)/board/$(BOARDDIR)/me.bin
+endif
+
+ifneq ($(CONFIG_HAVE_MRC),)
+IFDTOOL_FLAGS += -w $(CONFIG_X86_MRC_ADDR):$(srctree)/board/$(BOARDDIR)/mrc.bin
+endif
+
+ifneq ($(CONFIG_HAVE_FSP),)
+IFDTOOL_FLAGS += -w $(CONFIG_FSP_ADDR):$(srctree)/board/$(BOARDDIR)/$(CONFIG_FSP_FILE)
+endif
+
+ifneq ($(CONFIG_HAVE_CMC),)
+IFDTOOL_FLAGS += -w $(CONFIG_CMC_ADDR):$(srctree)/board/$(BOARDDIR)/$(CONFIG_CMC_FILE)
+endif
+
+ifneq ($(CONFIG_X86_OPTION_ROM_ADDR),)
+IFDTOOL_FLAGS += -w $(CONFIG_X86_OPTION_ROM_ADDR):$(srctree)/board/$(BOARDDIR)/$(CONFIG_X86_OPTION_ROM_FILE)
+endif
+
+quiet_cmd_ifdtool = IFDTOOL $@
+cmd_ifdtool  = $(IFDTOOL) -c -r $(CONFIG_ROM_SIZE) u-boot.tmp;
+ifneq ($(CONFIG_HAVE_INTEL_ME),)
+cmd_ifdtool += $(IFDTOOL) $(IFDTOOL_ME_FLAGS) u-boot.tmp;
+endif
+cmd_ifdtool += $(IFDTOOL) $(IFDTOOL_FLAGS) u-boot.tmp;
+cmd_ifdtool += mv u-boot.tmp $@
+
+u-boot.rom: u-boot-x86-16bit.bin u-boot-dtb.bin
+	$(call if_changed,ifdtool)
 
 OBJCOPYFLAGS_u-boot-x86-16bit.bin := -O binary -j .start16 -j .resetvec
 u-boot-x86-16bit.bin: u-boot FORCE
@@ -999,15 +1015,22 @@
 #concatenated with u-boot binary. It is need by PowerPC SoC having
 #internal SRAM <= 512KB.
 MKIMAGEFLAGS_u-boot-spl.pbl = -n $(srctree)/$(CONFIG_SYS_FSL_PBL_RCW:"%"=%) \
-		-R $(srctree)/$(CONFIG_SYS_FSL_PBL_PBI:"%"=%) -T pblimage
+		-R $(srctree)/$(CONFIG_SYS_FSL_PBL_PBI:"%"=%) -T pblimage \
+		-A $(ARCH) -a $(CONFIG_SPL_TEXT_BASE)
 
 spl/u-boot-spl.pbl: spl/u-boot-spl.bin FORCE
 	$(call if_changed,mkimage)
 
+ifeq ($(ARCH),arm)
+UBOOT_BINLOAD := u-boot.img
+else
+UBOOT_BINLOAD := u-boot.bin
+endif
+
 OBJCOPYFLAGS_u-boot-with-spl-pbl.bin = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO) \
 			  --gap-fill=0xff
 
-u-boot-with-spl-pbl.bin: spl/u-boot-spl.pbl u-boot.bin FORCE
+u-boot-with-spl-pbl.bin: spl/u-boot-spl.pbl $(UBOOT_BINLOAD) FORCE
 	$(call if_changed,pad_cat)
 
 # PPC4xx needs the SPL at the end of the image, since the reset vector
diff -ruN u-boot-2015.01-rc3/README u-boot/README
--- u-boot-2015.01-rc3/README	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/README	2015-01-01 17:34:31.985507645 +0100
@@ -1773,6 +1773,15 @@
 		regarding the non-volatile storage device. Define this to
 		the eMMC device that fastboot should use to store the image.
 
+		CONFIG_FASTBOOT_GPT_NAME
+		The fastboot "flash" command supports writing the downloaded
+		image to the Protective MBR and the Primary GUID Partition
+		Table. (Additionally, this downloaded image is post-processed
+		to generate and write the Backup GUID Partition Table.)
+		This occurs when the specified "partition name" on the
+		"fastboot flash" command line matches this value.
+		Default is GPT_ENTRY_NAME (currently "gpt") if undefined.
+
 - Journaling Flash filesystem support:
 		CONFIG_JFFS2_NAND, CONFIG_JFFS2_NAND_OFF, CONFIG_JFFS2_NAND_SIZE,
 		CONFIG_JFFS2_NAND_DEV
diff -ruN u-boot-2015.01-rc3/scripts/binutils-version.sh u-boot/scripts/binutils-version.sh
--- u-boot-2015.01-rc3/scripts/binutils-version.sh	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/scripts/binutils-version.sh	2015-01-01 17:34:32.877493022 +0100
@@ -14,7 +14,9 @@
 	exit 1
 fi
 
-MAJOR=$($gas --version | head -1 | awk '{print $NF}' | cut -d . -f 1)
-MINOR=$($gas --version | head -1 | awk '{print $NF}' | cut -d . -f 2)
+version_string=$($gas --version | head -1 | sed -e 's/.*) *\([0-9.]*\).*/\1/' )
+
+MAJOR=$(echo $version_string | cut -d . -f 1)
+MINOR=$(echo $version_string | cut -d . -f 2)
 
 printf "%02d%02d\\n" $MAJOR $MINOR
diff -ruN u-boot-2015.01-rc3/snapshot.commit u-boot/snapshot.commit
--- u-boot-2015.01-rc3/snapshot.commit	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/snapshot.commit	2015-01-01 17:34:32.885492891 +0100
@@ -1 +1 @@
-32fdf0e4d82bdca5d64d86330e461e59685f9959  Mon, 8 Dec 2014 16:35:08 -0500
+$Format:%H  %cD$
diff -ruN u-boot-2015.01-rc3/test/dm/cmd_dm.c u-boot/test/dm/cmd_dm.c
--- u-boot-2015.01-rc3/test/dm/cmd_dm.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/test/dm/cmd_dm.c	2015-01-01 17:34:32.885492891 +0100
@@ -16,17 +16,65 @@
 #include <dm/test.h>
 #include <dm/uclass-internal.h>
 
+static void show_devices(struct udevice *dev, int depth, int last_flag)
+{
+	int i, is_last;
+	struct udevice *child;
+	char class_name[12];
+
+	/* print the first 11 characters to not break the tree-format. */
+	strlcpy(class_name, dev->uclass->uc_drv->name, sizeof(class_name));
+	printf(" %-11s [ %c ]    ", class_name,
+	       dev->flags & DM_FLAG_ACTIVATED ? '+' : ' ');
+
+	for (i = depth; i >= 0; i--) {
+		is_last = (last_flag >> i) & 1;
+		if (i) {
+			if (is_last)
+				printf("    ");
+			else
+				printf("|   ");
+		} else {
+			if (is_last)
+				printf("`-- ");
+			else
+				printf("|-- ");
+		}
+	}
+
+	printf("%s\n", dev->name);
+
+	list_for_each_entry(child, &dev->child_head, sibling_node) {
+		is_last = list_is_last(&child->sibling_node, &dev->child_head);
+		show_devices(child, depth + 1, (last_flag << 1) | is_last);
+	}
+}
+
+static int do_dm_dump_all(cmd_tbl_t *cmdtp, int flag, int argc,
+			  char * const argv[])
+{
+	struct udevice *root;
+
+	root = dm_root();
+	if (root) {
+		printf(" Class       Probed   Name\n");
+		printf("----------------------------------------\n");
+		show_devices(root, -1, 0);
+	}
+
+	return 0;
+}
+
 /**
  * dm_display_line() - Display information about a single device
  *
  * Displays a single line of information with an option prefix
  *
  * @dev:	Device to display
- * @buf:	Prefix to display at the start of the line
  */
-static void dm_display_line(struct udevice *dev, char *buf)
+static void dm_display_line(struct udevice *dev)
 {
-	printf("%s- %c %s @ %08lx", buf,
+	printf("- %c %s @ %08lx",
 	       dev->flags & DM_FLAG_ACTIVATED ? '*' : ' ',
 	       dev->name, (ulong)map_to_sysmem(dev));
 	if (dev->req_seq != -1)
@@ -34,53 +82,6 @@
 	puts("\n");
 }
 
-static int display_succ(struct udevice *in, char *buf)
-{
-	int len;
-	int ip = 0;
-	char local[16];
-	struct udevice *pos, *n, *prev = NULL;
-
-	dm_display_line(in, buf);
-
-	if (list_empty(&in->child_head))
-		return 0;
-
-	len = strlen(buf);
-	strncpy(local, buf, sizeof(local));
-	snprintf(local + len, 2, "|");
-	if (len && local[len - 1] == '`')
-		local[len - 1] = ' ';
-
-	list_for_each_entry_safe(pos, n, &in->child_head, sibling_node) {
-		if (ip++)
-			display_succ(prev, local);
-		prev = pos;
-	}
-
-	snprintf(local + len, 2, "`");
-	display_succ(prev, local);
-
-	return 0;
-}
-
-static int dm_dump(struct udevice *dev)
-{
-	if (!dev)
-		return -EINVAL;
-	return display_succ(dev, "");
-}
-
-static int do_dm_dump_all(cmd_tbl_t *cmdtp, int flag, int argc,
-			  char * const argv[])
-{
-	struct udevice *root;
-
-	root = dm_root();
-	printf("ROOT %08lx\n", (ulong)map_to_sysmem(root));
-	return dm_dump(root);
-}
-
 static int do_dm_dump_uclass(cmd_tbl_t *cmdtp, int flag, int argc,
 			     char * const argv[])
 {
@@ -99,7 +100,7 @@
 		if (list_empty(&uc->dev_head))
 			continue;
 		list_for_each_entry(dev, &uc->dev_head, uclass_node) {
-			dm_display_line(dev, "");
+			dm_display_line(dev);
 		}
 		puts("\n");
 	}
diff -ruN u-boot-2015.01-rc3/test/dm/i2c.c u-boot/test/dm/i2c.c
--- u-boot-2015.01-rc3/test/dm/i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/test/dm/i2c.c	2015-01-01 17:34:32.885492891 +0100
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2013 Google, Inc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Note: Test coverage does not include 10-bit addressing
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <fdtdec.h>
+#include <i2c.h>
+#include <dm/device-internal.h>
+#include <dm/test.h>
+#include <dm/uclass-internal.h>
+#include <dm/ut.h>
+#include <dm/util.h>
+#include <asm/state.h>
+#include <asm/test.h>
+
+static const int busnum;
+static const int chip = 0x2c;
+
+/* Test that we can find buses and chips */
+static int dm_test_i2c_find(struct dm_test_state *dms)
+{
+	struct udevice *bus, *dev;
+	const int no_chip = 0x10;
+
+	ut_asserteq(-ENODEV, uclass_find_device_by_seq(UCLASS_I2C, busnum,
+						       false, &bus));
+
+	/*
+	 * i2c_post_bind() will bind devices to chip selects. Check this then
+	 * remove the emulation and the slave device.
+	 */
+	ut_assertok(uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus));
+	ut_assertok(i2c_probe(bus, chip, 0, &dev));
+	ut_asserteq(-ENODEV, i2c_probe(bus, no_chip, 0, &dev));
+	ut_asserteq(-ENODEV, uclass_get_device_by_seq(UCLASS_I2C, 1, &bus));
+
+	return 0;
+}
+DM_TEST(dm_test_i2c_find, DM_TESTF_SCAN_PDATA | DM_TESTF_SCAN_FDT);
+
+static int dm_test_i2c_read_write(struct dm_test_state *dms)
+{
+	struct udevice *bus, *dev;
+	uint8_t buf[5];
+
+	ut_assertok(uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus));
+	ut_assertok(i2c_get_chip(bus, chip, &dev));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(memcmp(buf, "\0\0\0\0\0", sizeof(buf)));
+	ut_assertok(i2c_write(dev, 2, (uint8_t *)"AB", 2));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(memcmp(buf, "\0\0AB\0", sizeof(buf)));
+
+	return 0;
+}
+DM_TEST(dm_test_i2c_read_write, DM_TESTF_SCAN_PDATA | DM_TESTF_SCAN_FDT);
+
+static int dm_test_i2c_speed(struct dm_test_state *dms)
+{
+	struct udevice *bus, *dev;
+	uint8_t buf[5];
+
+	ut_assertok(uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus));
+	ut_assertok(i2c_get_chip(bus, chip, &dev));
+	ut_assertok(i2c_set_bus_speed(bus, 100000));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(i2c_set_bus_speed(bus, 400000));
+	ut_asserteq(400000, i2c_get_bus_speed(bus));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_asserteq(-EINVAL, i2c_write(dev, 0, buf, 5));
+
+	return 0;
+}
+DM_TEST(dm_test_i2c_speed, DM_TESTF_SCAN_PDATA | DM_TESTF_SCAN_FDT);
+
+static int dm_test_i2c_offset_len(struct dm_test_state *dms)
+{
+	struct udevice *bus, *dev;
+	uint8_t buf[5];
+
+	ut_assertok(uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus));
+	ut_assertok(i2c_get_chip(bus, chip, &dev));
+	ut_assertok(i2c_set_chip_offset_len(dev, 1));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+
+	/* This is not supported by the uclass */
+	ut_asserteq(-EINVAL, i2c_set_chip_offset_len(dev, 5));
+
+	return 0;
+}
+DM_TEST(dm_test_i2c_offset_len, DM_TESTF_SCAN_PDATA | DM_TESTF_SCAN_FDT);
+
+static int dm_test_i2c_probe_empty(struct dm_test_state *dms)
+{
+	struct udevice *bus, *dev;
+
+	ut_assertok(uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus));
+	ut_assertok(i2c_probe(bus, SANDBOX_I2C_TEST_ADDR, 0, &dev));
+
+	return 0;
+}
+DM_TEST(dm_test_i2c_probe_empty, DM_TESTF_SCAN_PDATA | DM_TESTF_SCAN_FDT);
+
+static int dm_test_i2c_bytewise(struct dm_test_state *dms)
+{
+	struct udevice *bus, *dev;
+	struct udevice *eeprom;
+	uint8_t buf[5];
+
+	ut_assertok(uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus));
+	ut_assertok(i2c_get_chip(bus, chip, &dev));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(memcmp(buf, "\0\0\0\0\0", sizeof(buf)));
+
+	/* Tell the EEPROM to only read/write one register at a time */
+	ut_assertok(uclass_first_device(UCLASS_I2C_EMUL, &eeprom));
+	ut_assertnonnull(eeprom);
+	sandbox_i2c_eeprom_set_test_mode(eeprom, SIE_TEST_MODE_SINGLE_BYTE);
+
+	/* Now we only get the first byte - the rest will be 0xff */
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(memcmp(buf, "\0\xff\xff\xff\xff", sizeof(buf)));
+
+	/* If we do a separate transaction for each byte, it works */
+	ut_assertok(i2c_set_chip_flags(dev, DM_I2C_CHIP_RD_ADDRESS));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(memcmp(buf, "\0\0\0\0\0", sizeof(buf)));
+
+	/* This will only write A */
+	ut_assertok(i2c_set_chip_flags(dev, 0));
+	ut_assertok(i2c_write(dev, 2, (uint8_t *)"AB", 2));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(memcmp(buf, "\0\xff\xff\xff\xff", sizeof(buf)));
+
+	/* Check that the B was ignored */
+	ut_assertok(i2c_set_chip_flags(dev, DM_I2C_CHIP_RD_ADDRESS));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(memcmp(buf, "\0\0A\0\0\0", sizeof(buf)));
+
+	/* Now write it again with the new flags, it should work */
+	ut_assertok(i2c_set_chip_flags(dev, DM_I2C_CHIP_WR_ADDRESS));
+	ut_assertok(i2c_write(dev, 2, (uint8_t *)"AB", 2));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(memcmp(buf, "\0\xff\xff\xff\xff", sizeof(buf)));
+
+	ut_assertok(i2c_set_chip_flags(dev, DM_I2C_CHIP_WR_ADDRESS |
+						DM_I2C_CHIP_RD_ADDRESS));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(memcmp(buf, "\0\0AB\0\0", sizeof(buf)));
+
+	/* Restore defaults */
+	sandbox_i2c_eeprom_set_test_mode(eeprom, SIE_TEST_MODE_NONE);
+	ut_assertok(i2c_set_chip_flags(dev, 0));
+
+	return 0;
+}
+DM_TEST(dm_test_i2c_bytewise, DM_TESTF_SCAN_PDATA | DM_TESTF_SCAN_FDT);
+
+static int dm_test_i2c_offset(struct dm_test_state *dms)
+{
+	struct udevice *eeprom;
+	struct udevice *dev;
+	uint8_t buf[5];
+
+	ut_assertok(i2c_get_chip_for_busnum(busnum, chip, &dev));
+
+	/* Do a transfer so we can find the emulator */
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(uclass_first_device(UCLASS_I2C_EMUL, &eeprom));
+
+	/* Offset length 0 */
+	sandbox_i2c_eeprom_set_offset_len(eeprom, 0);
+	ut_assertok(i2c_set_chip_offset_len(dev, 0));
+	ut_assertok(i2c_write(dev, 10 /* ignored */, (uint8_t *)"AB", 2));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(memcmp(buf, "AB\0\0\0\0", sizeof(buf)));
+
+	/* Offset length 1 */
+	sandbox_i2c_eeprom_set_offset_len(eeprom, 1);
+	ut_assertok(i2c_set_chip_offset_len(dev, 1));
+	ut_assertok(i2c_write(dev, 2, (uint8_t *)"AB", 2));
+	ut_assertok(i2c_read(dev, 0, buf, 5));
+	ut_assertok(memcmp(buf, "ABAB\0", sizeof(buf)));
+
+	/* Offset length 2 */
+	sandbox_i2c_eeprom_set_offset_len(eeprom, 2);
+	ut_assertok(i2c_set_chip_offset_len(dev, 2));
+	ut_assertok(i2c_write(dev, 0x210, (uint8_t *)"AB", 2));
+	ut_assertok(i2c_read(dev, 0x210, buf, 5));
+	ut_assertok(memcmp(buf, "AB\0\0\0", sizeof(buf)));
+
+	/* Offset length 3 */
+	sandbox_i2c_eeprom_set_offset_len(eeprom, 2);
+	ut_assertok(i2c_set_chip_offset_len(dev, 2));
+	ut_assertok(i2c_write(dev, 0x410, (uint8_t *)"AB", 2));
+	ut_assertok(i2c_read(dev, 0x410, buf, 5));
+	ut_assertok(memcmp(buf, "AB\0\0\0", sizeof(buf)));
+
+	/* Offset length 4 */
+	sandbox_i2c_eeprom_set_offset_len(eeprom, 2);
+	ut_assertok(i2c_set_chip_offset_len(dev, 2));
+	ut_assertok(i2c_write(dev, 0x420, (uint8_t *)"AB", 2));
+	ut_assertok(i2c_read(dev, 0x420, buf, 5));
+	ut_assertok(memcmp(buf, "AB\0\0\0", sizeof(buf)));
+
+	/* Restore defaults */
+	sandbox_i2c_eeprom_set_offset_len(eeprom, 1);
+
+	return 0;
+}
+DM_TEST(dm_test_i2c_offset, DM_TESTF_SCAN_PDATA | DM_TESTF_SCAN_FDT);
diff -ruN u-boot-2015.01-rc3/test/dm/Makefile u-boot/test/dm/Makefile
--- u-boot-2015.01-rc3/test/dm/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/test/dm/Makefile	2015-01-01 17:34:32.885492891 +0100
@@ -20,4 +20,5 @@
 obj-$(CONFIG_DM_GPIO) += gpio.o
 obj-$(CONFIG_DM_SPI) += spi.o
 obj-$(CONFIG_DM_SPI_FLASH) += sf.o
+obj-$(CONFIG_DM_I2C) += i2c.o
 endif
diff -ruN u-boot-2015.01-rc3/test/dm/test.dts u-boot/test/dm/test.dts
--- u-boot-2015.01-rc3/test/dm/test.dts	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/test/dm/test.dts	2015-01-01 17:34:32.885492891 +0100
@@ -93,6 +93,23 @@
 		num-gpios = <10>;
 	};
 
+	i2c@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0>;
+		compatible = "sandbox,i2c";
+		clock-frequency = <100000>;
+		eeprom@2c {
+			reg = <0x2c>;
+			compatible = "i2c-eeprom";
+			emul {
+				compatible = "sandbox,i2c-eeprom";
+				sandbox,filename = "i2c.bin";
+				sandbox,size = <256>;
+			};
+		};
+	};
+
 	spi@0 {
 		#address-cells = <1>;
 		#size-cells = <0>;
diff -ruN u-boot-2015.01-rc3/test/ums/ums_gadget_test.sh u-boot/test/ums/ums_gadget_test.sh
--- u-boot-2015.01-rc3/test/ums/ums_gadget_test.sh	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/test/ums/ums_gadget_test.sh	2015-01-01 17:34:32.885492891 +0100
@@ -11,6 +11,7 @@
 
 COLOUR_RED="\33[31m"
 COLOUR_GREEN="\33[32m"
+COLOUR_ORANGE="\33[33m"
 COLOUR_DEFAULT="\33[0m"
 
 DIR=./
@@ -59,8 +60,15 @@
     fi
 
     cp ./$1 $MNT_DIR
-    umount $MNT_DIR
 
+    while true; do
+	umount $MNT_DIR > /dev/null 2>&1
+	if [ $? -eq 0 ]; then
+	    break
+	fi
+	printf "$COLOUR_ORANGE\tSleeping to wait for umount...$COLOUR_DEFAULT\n"
+	sleep 1
+    done
 
     echo -n "TX: "
     calculate_md5sum $1
diff -ruN u-boot-2015.01-rc3/tools/buildman/README u-boot/tools/buildman/README
--- u-boot-2015.01-rc3/tools/buildman/README	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/tools/buildman/README	2015-01-01 17:34:32.885492891 +0100
@@ -42,7 +42,7 @@
 Buildman is a builder. It is not make, although it runs make. It does not
 produce any useful output on the terminal while building, except for
 progress information (except with -v, see below). All the output (errors,
-warnings and binaries if you are ask for them) is stored in output
+warnings and binaries if you ask for them) is stored in output
 directories, which you can look at while the build is progressing, or when
 it is finished.
 
@@ -121,7 +121,7 @@
 means to build all arm boards except nvidia, freescale and anything ending
 with 'ball'.
 
-It is convenient to use the -n option to see whaat will be built based on
+It is convenient to use the -n option to see what will be built based on
 the subset given.
 
 Buildman does not store intermediate object files. It optionally copies
@@ -371,7 +371,7 @@
 
 
 To find out how the build went, ask for a summary with -s. You can do this
-either before the build completes (presumably in another terminal) or or
+either before the build completes (presumably in another terminal) or
 afterwards. Let's work through an example of how this is used:
 
 $ ./tools/buildman/buildman -b lcd9b -s
@@ -439,7 +439,7 @@
 
 At commit 16, the error moves - you can see that the old error at line 120
 is fixed, but there is a new one at line 126. This is probably only because
-we added some code and moved the broken line father down the file.
+we added some code and moved the broken line further down the file.
 
 If many boards have the same error, then -e will display the error only
 once. This makes the output as concise as possible. To see which boards have
@@ -647,8 +647,8 @@
 board was built) and by 96 bytes for powerpc. This increase was offset in both
 cases by reductions in rodata and data/bss.
 
-Shown below the summary lines is the sizes for each board. Below each board
-is the sizes for each function. This information starts with:
+Shown below the summary lines are the sizes for each board. Below each board
+are the sizes for each function. This information starts with:
 
    add - number of functions added / removed
    grow - number of functions which grew / shrunk
@@ -817,7 +817,7 @@
 This has mostly be written in my spare time as a response to my difficulties
 in testing large series of patches. Apart from tidying up there is quite a
 bit of scope for improvement. Things like better error diffs and easier
-access to log files. Also it would be nice it buildman could 'hunt' for
+access to log files. Also it would be nice if buildman could 'hunt' for
 problems, perhaps by building a few boards for each arch, or checking
 commits for changed files and building only boards which use those files.
 
diff -ruN u-boot-2015.01-rc3/tools/ifdtool.c u-boot/tools/ifdtool.c
--- u-boot-2015.01-rc3/tools/ifdtool.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/tools/ifdtool.c	2015-01-01 17:34:32.893492759 +0100
@@ -18,6 +18,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <libfdt.h>
 #include "ifdtool.h"
 
 #undef DEBUG
@@ -32,6 +33,18 @@
 #define FLREG_BASE(reg)		((reg & 0x00000fff) << 12);
 #define FLREG_LIMIT(reg)	(((reg & 0x0fff0000) >> 4) | 0xfff);
 
+enum input_file_type_t {
+	IF_normal,
+	IF_fdt,
+	IF_uboot,
+};
+
+struct input_file {
+	char *fname;
+	unsigned int addr;
+	enum input_file_type_t type;
+};
+
 /**
  * find_fd() - Find the flash description in the ROM image
  *
@@ -54,7 +67,8 @@
 		return NULL;
 	}
 
-	debug("Found Flash Descriptor signature at 0x%08x\n", i);
+	debug("Found Flash Descriptor signature at 0x%08lx\n",
+	      (char *)ptr - image);
 
 	return (struct fdbar_t *)ptr;
 }
@@ -464,6 +478,16 @@
 	return ret;
 }
 
+static int perror_fname(const char *fmt, const char *fname)
+{
+	char msg[strlen(fmt) + strlen(fname) + 1];
+
+	sprintf(msg, fmt, fname);
+	perror(msg);
+
+	return -1;
+}
+
 /**
  * write_image() - Write the image to a file
  *
@@ -480,10 +504,10 @@
 
 	new_fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR |
 		      S_IWUSR | S_IRGRP | S_IROTH);
-	if (write(new_fd, image, size) != size) {
-		perror("Error while writing");
-		return -1;
-	}
+	if (new_fd < 0)
+		return perror_fname("Could not open file '%s'", filename);
+	if (write(new_fd, image, size) != size)
+		return perror_fname("Could not write file '%s'", filename);
 	close(new_fd);
 
 	return 0;
@@ -585,14 +609,10 @@
 	int fd = open(fname, O_RDONLY);
 	struct stat buf;
 
-	if (fd == -1) {
-		perror("Could not open file");
-		return -1;
-	}
-	if (fstat(fd, &buf) == -1) {
-		perror("Could not stat file");
-		return -1;
-	}
+	if (fd == -1)
+		return perror_fname("Could not open file '%s'", fname);
+	if (fstat(fd, &buf) == -1)
+		return perror_fname("Could not stat file '%s'", fname);
 	*sizep = buf.st_size;
 	debug("File %s is %d bytes\n", fname, *sizep);
 
@@ -686,7 +706,7 @@
  *			0xffffffff so use an address relative to that. For an
  *			8MB ROM the start address is 0xfff80000.
  * @write_fname:	Filename to add to the image
- * @return 0 if OK, -ve on error
+ * @return number of bytes written if OK, -ve on error
  */
 static int write_data(char *image, int size, unsigned int addr,
 		      const char *write_fname)
@@ -698,7 +718,7 @@
 	if (write_fd < 0)
 		return write_fd;
 
-	offset = addr + size;
+	offset = (uint32_t)(addr + size);
 	debug("Writing %s to offset %#x\n", write_fname, offset);
 
 	if (offset < 0 || offset + write_size > size) {
@@ -714,6 +734,68 @@
 
 	close(write_fd);
 
+	return write_size;
+}
+
+/**
+ * write_uboot() - Write U-Boot, device tree and microcode pointer
+ *
+ * This writes U-Boot into a place in the flash, followed by its device tree.
+ * The microcode pointer is written so that U-Boot can find the microcode in
+ * the device tree very early in boot.
+ *
+ * @image:	Pointer to image
+ * @size:	Size of image in bytes
+ * @uboot:	Input file information for u-boot.bin
+ * @fdt:	Input file information for u-boot.dtb
+ * @ucode_ptr:	Address in U-Boot where the microcode pointer should be placed
+ * @return 0 if OK, -ve on error
+ */
+static int write_uboot(char *image, int size, struct input_file *uboot,
+		       struct input_file *fdt, unsigned int ucode_ptr)
+{
+	const void *blob;
+	const char *data;
+	int uboot_size;
+	uint32_t *ptr;
+	int data_size;
+	int offset;
+	int node;
+	int ret;
+
+	uboot_size = write_data(image, size, uboot->addr, uboot->fname);
+	if (uboot_size < 0)
+		return uboot_size;
+	fdt->addr = uboot->addr + uboot_size;
+	debug("U-Boot size %#x, FDT at %#x\n", uboot_size, fdt->addr);
+	ret = write_data(image, size, fdt->addr, fdt->fname);
+	if (ret < 0)
+		return ret;
+
+	if (ucode_ptr) {
+		blob = (void *)image + (uint32_t)(fdt->addr + size);
+		debug("DTB at %lx\n", (char *)blob - image);
+		node = fdt_node_offset_by_compatible(blob, 0,
+						     "intel,microcode");
+		if (node < 0) {
+			debug("No microcode found in FDT: %s\n",
+			      fdt_strerror(node));
+			return -ENOENT;
+		}
+		data = fdt_getprop(blob, node, "data", &data_size);
+		if (!data) {
+			debug("No microcode data found in FDT: %s\n",
+			      fdt_strerror(data_size));
+			return -ENOENT;
+		}
+		offset = ucode_ptr - uboot->addr;
+		ptr = (void *)image + offset;
+		ptr[0] = uboot->addr + (data - image);
+		ptr[1] = data_size;
+		debug("Wrote microcode pointer at %x: addr=%x, size=%x\n",
+		      ucode_ptr, ptr[0], ptr[1]);
+	}
+
 	return 0;
 }
 
@@ -732,6 +814,7 @@
 	       "   -x | --extract:                   extract intel fd modules\n"
 	       "   -i | --inject <region>:<module>   inject file <module> into region <region>\n"
 	       "   -w | --write <addr>:<file>        write file to appear at memory address <addr>\n"
+	       "                                     multiple files can be written simultaneously\n"
 	       "   -s | --spifreq <20|33|50>         set the SPI frequency\n"
 	       "   -e | --em100                      set SPI frequency to 20MHz and disable\n"
 	       "                                     Dual Output Fast Read Support\n"
@@ -778,17 +861,20 @@
 	int mode_spifreq = 0, mode_em100 = 0, mode_locked = 0;
 	int mode_unlocked = 0, mode_write = 0, mode_write_descriptor = 0;
 	int create = 0;
-	char *region_type_string = NULL, *src_fname = NULL;
-	char *addr_str = NULL;
+	char *region_type_string = NULL, *inject_fname = NULL;
+	char *desc_fname = NULL, *addr_str = NULL;
 	int region_type = -1, inputfreq = 0;
 	enum spi_frequency spifreq = SPI_FREQUENCY_20MHZ;
-	unsigned int addr = 0;
+	struct input_file input_file[WRITE_MAX], *ifile, *fdt = NULL;
+	unsigned char wr_idx, wr_num = 0;
 	int rom_size = -1;
 	bool write_it;
 	char *filename;
 	char *outfile = NULL;
 	struct stat buf;
 	int size = 0;
+	unsigned int ucode_ptr = 0;
+	bool have_uboot = false;
 	int bios_fd;
 	char *image;
 	int ret;
@@ -798,18 +884,21 @@
 		{"descriptor", 1, NULL, 'D'},
 		{"em100", 0, NULL, 'e'},
 		{"extract", 0, NULL, 'x'},
+		{"fdt", 1, NULL, 'f'},
 		{"inject", 1, NULL, 'i'},
 		{"lock", 0, NULL, 'l'},
+		{"microcode", 1, NULL, 'm'},
 		{"romsize", 1, NULL, 'r'},
 		{"spifreq", 1, NULL, 's'},
 		{"unlock", 0, NULL, 'u'},
+		{"uboot", 1, NULL, 'U'},
 		{"write", 1, NULL, 'w'},
 		{"version", 0, NULL, 'v'},
 		{"help", 0, NULL, 'h'},
 		{0, 0, 0, 0}
 	};
 
-	while ((opt = getopt_long(argc, argv, "cdD:ehi:lr:s:uvw:x?",
+	while ((opt = getopt_long(argc, argv, "cdD:ef:hi:lm:r:s:uU:vw:x?",
 				  long_options, &option_index)) != EOF) {
 		switch (opt) {
 		case 'c':
@@ -820,14 +909,14 @@
 			break;
 		case 'D':
 			mode_write_descriptor = 1;
-			src_fname = optarg;
+			desc_fname = optarg;
 			break;
 		case 'e':
 			mode_em100 = 1;
 			break;
 		case 'i':
 			if (get_two_words(optarg, &region_type_string,
-					  &src_fname)) {
+					  &inject_fname)) {
 				print_usage(argv[0]);
 				exit(EXIT_FAILURE);
 			}
@@ -852,6 +941,9 @@
 		case 'l':
 			mode_locked = 1;
 			break;
+		case 'm':
+			ucode_ptr = strtoul(optarg, NULL, 0);
+			break;
 		case 'r':
 			rom_size = strtol(optarg, NULL, 0);
 			debug("ROM size %d\n", rom_size);
@@ -885,12 +977,29 @@
 			exit(EXIT_SUCCESS);
 			break;
 		case 'w':
+		case 'U':
+		case 'f':
+			ifile = &input_file[wr_num];
 			mode_write = 1;
-			if (get_two_words(optarg, &addr_str, &src_fname)) {
-				print_usage(argv[0]);
-				exit(EXIT_FAILURE);
+			if (wr_num < WRITE_MAX) {
+				if (get_two_words(optarg, &addr_str,
+						  &ifile->fname)) {
+					print_usage(argv[0]);
+					exit(EXIT_FAILURE);
+				}
+				ifile->addr = strtol(optarg, NULL, 0);
+				ifile->type = opt == 'f' ? IF_fdt :
+					opt == 'U' ? IF_uboot : IF_normal;
+				if (ifile->type == IF_fdt)
+					fdt = ifile;
+				else if (ifile->type == IF_uboot)
+					have_uboot = true;
+				wr_num++;
+			} else {
+				fprintf(stderr,
+					"The number of files to write simultaneously exceeds the limitation (%d)\n",
+					WRITE_MAX);
 			}
-			addr = strtol(optarg, NULL, 0);
 			break;
 		case 'x':
 			mode_extract = 1;
@@ -941,6 +1050,13 @@
 		exit(EXIT_FAILURE);
 	}
 
+	if (have_uboot && !fdt) {
+		fprintf(stderr,
+			"You must supply a device tree file for U-Boot\n\n");
+		print_usage(argv[0]);
+		exit(EXIT_FAILURE);
+	}
+
 	filename = argv[optind];
 	if (optind + 2 != argc)
 		outfile = argv[optind + 1];
@@ -997,13 +1113,27 @@
 	}
 
 	if (mode_write_descriptor)
-		ret = write_data(image, size, -size, src_fname);
+		ret = write_data(image, size, -size, desc_fname);
 
 	if (mode_inject)
-		ret = inject_region(image, size, region_type, src_fname);
+		ret = inject_region(image, size, region_type, inject_fname);
 
-	if (mode_write)
-		ret = write_data(image, size, addr, src_fname);
+	if (mode_write) {
+		for (wr_idx = 0; wr_idx < wr_num; wr_idx++) {
+			ifile = &input_file[wr_idx];
+			if (ifile->type == IF_fdt) {
+				continue;
+			} else if (ifile->type == IF_uboot) {
+				ret = write_uboot(image, size, ifile, fdt,
+						  ucode_ptr);
+			} else {
+				ret = write_data(image, size, ifile->addr,
+					 ifile->fname);
+			}
+			if (ret < 0)
+				break;
+		}
+	}
 
 	if (mode_spifreq)
 		set_spi_frequency(image, size, spifreq);
@@ -1035,5 +1165,5 @@
 	free(image);
 	close(bios_fd);
 
-	return ret ? 1 : 0;
+	return ret < 0 ? 1 : 0;
 }
diff -ruN u-boot-2015.01-rc3/tools/ifdtool.h u-boot/tools/ifdtool.h
--- u-boot-2015.01-rc3/tools/ifdtool.h	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/tools/ifdtool.h	2015-01-01 17:34:32.893492759 +0100
@@ -14,6 +14,8 @@
 
 #define IFDTOOL_VERSION "1.1-U-Boot"
 
+#define WRITE_MAX	16
+
 enum spi_frequency {
 	SPI_FREQUENCY_20MHZ = 0,
 	SPI_FREQUENCY_33MHZ = 1,
diff -ruN u-boot-2015.01-rc3/tools/Makefile u-boot/tools/Makefile
--- u-boot-2015.01-rc3/tools/Makefile	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/tools/Makefile	2015-01-01 17:34:32.885492891 +0100
@@ -126,6 +126,7 @@
 hostprogs-$(CONFIG_EXYNOS5420) += mkexynosspl
 HOSTCFLAGS_mkexynosspl.o := -pedantic
 
+ifdtool-objs := $(LIBFDT_OBJS) ifdtool.o
 hostprogs-$(CONFIG_X86) += ifdtool
 
 hostprogs-$(CONFIG_MX23) += mxsboot
diff -ruN u-boot-2015.01-rc3/tools/microcode-tool u-boot/tools/microcode-tool
--- u-boot-2015.01-rc3/tools/microcode-tool	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/tools/microcode-tool	2015-01-01 17:34:32.897492694 +0100
@@ -0,0 +1,253 @@
+#!/usr/bin/env python
+#
+# Copyright (c) 2014 Google, Inc
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+# Intel microcode update tool
+
+from optparse import OptionParser
+import os
+import re
+import struct
+import sys
+
+MICROCODE_DIR = 'arch/x86/dts/microcode'
+
+class Microcode:
+    """Holds information about the microcode for a particular model of CPU.
+
+    Attributes:
+        name:  Name of the CPU this microcode is for, including any version
+                   information (e.g. 'm12206a7_00000029')
+        model: Model code string (this is cpuid(1).eax, e.g. '206a7')
+        words: List of hex words containing the microcode. The first 16 words
+                   are the public header.
+    """
+    def __init__(self, name, data):
+        self.name = name
+        # Convert data into a list of hex words
+        self.words = []
+        for value in ''.join(data).split(','):
+            hexval = value.strip()
+            if hexval:
+                self.words.append(int(hexval, 0))
+
+        # The model is in the 4rd hex word
+        self.model = '%x' % self.words[3]
+
+def ParseFile(fname):
+    """Parse a micrcode.dat file and return the component parts
+
+    Args:
+        fname: Filename to parse
+    Returns:
+        3-Tuple:
+            date:         String containing date from the file's header
+            license_text: List of text lines for the license file
+            microcodes:   List of Microcode objects from the file
+    """
+    re_date = re.compile('/\* *(.* [0-9]{4}) *\*/$')
+    re_license = re.compile('/[^-*+] *(.*)$')
+    re_name = re.compile('/\* *(.*)\.inc *\*/', re.IGNORECASE)
+    microcodes = {}
+    license_text = []
+    date = ''
+    data = []
+    name = None
+    with open(fname) as fd:
+        for line in fd:
+            line = line.rstrip()
+            m_date = re_date.match(line)
+            m_license = re_license.match(line)
+            m_name = re_name.match(line)
+            if m_name:
+                if name:
+                    microcodes[name] = Microcode(name, data)
+                name = m_name.group(1).lower()
+                data = []
+            elif m_license:
+                license_text.append(m_license.group(1))
+            elif m_date:
+                date = m_date.group(1)
+            else:
+                data.append(line)
+    if name:
+        microcodes[name] = Microcode(name, data)
+    return date, license_text, microcodes
+
+def List(date, microcodes, model):
+    """List the available microcode chunks
+
+    Args:
+        date:           Date of the microcode file
+        microcodes:     Dict of Microcode objects indexed by name
+        model:          Model string to search for, or None
+    """
+    print 'Date: %s' % date
+    if model:
+        mcode_list, tried = FindMicrocode(microcodes, model.lower())
+        print 'Matching models %s:' % (', '.join(tried))
+    else:
+        print 'All models:'
+        mcode_list = [microcodes[m] for m in microcodes.keys()]
+    for mcode in mcode_list:
+        print '%-20s: model %s' % (mcode.name, mcode.model)
+
+def FindMicrocode(microcodes, model):
+    """Find all the microcode chunks which match the given model.
+
+    This model is something like 306a9 (the value returned in eax from
+    cpuid(1) when running on Intel CPUs). But we allow a partial match,
+    omitting the last 1 or two characters to allow many families to have the
+    same microcode.
+
+    If the model name is ambiguous we return a list of matches.
+
+    Args:
+        microcodes: Dict of Microcode objects indexed by name
+        model:      String containing model name to find
+    Returns:
+        Tuple:
+            List of matching Microcode objects
+            List of abbreviations we tried
+    """
+    # Allow a full name to be used
+    mcode = microcodes.get(model)
+    if mcode:
+        return [mcode], []
+
+    tried = []
+    found = []
+    for i in range(3):
+        abbrev = model[:-i] if i else model
+        tried.append(abbrev)
+        for mcode in microcodes.values():
+            if mcode.model.startswith(abbrev):
+                found.append(mcode)
+        if found:
+            break
+    return found, tried
+
+def CreateFile(date, license_text, mcode, outfile):
+    """Create a microcode file in U-Boot's .dtsi format
+
+    Args:
+        date:       String containing date of original microcode file
+        license:    List of text lines for the license file
+        mcode:      Microcode object to write
+        outfile:    Filename to write to ('-' for stdout)
+    """
+    out = '''/*%s
+ * ---
+ * This is a device tree fragment. Use #include to add these properties to a
+ * node.
+ *
+ * Date: %s
+ */
+
+compatible = "intel,microcode";
+intel,header-version = <%d>;
+intel,update-revision = <%#x>;
+intel,date-code = <%#x>;
+intel,processor-signature = <%#x>;
+intel,checksum = <%#x>;
+intel,loader-revision = <%d>;
+intel,processor-flags = <%#x>;
+
+/* The first 48-bytes are the public header which repeats the above data */
+data = <%s
+\t>;'''
+    words = ''
+    for i in range(len(mcode.words)):
+        if not (i & 3):
+            words += '\n'
+        val = mcode.words[i]
+        # Change each word so it will be little-endian in the FDT
+        # This data is needed before RAM is available on some platforms so we
+        # cannot do an endianness swap on boot.
+        val = struct.unpack("<I", struct.pack(">I", val))[0]
+        words += '\t%#010x' % val
+
+    # Take care to avoid adding a space before a tab
+    text = ''
+    for line in license_text:
+        if line[0] == '\t':
+            text += '\n *' + line
+        else:
+            text += '\n * ' + line
+    args = [text, date]
+    args += [mcode.words[i] for i in range(7)]
+    args.append(words)
+    if outfile == '-':
+        print out % tuple(args)
+    else:
+        if not outfile:
+            if not os.path.exists(MICROCODE_DIR):
+                print >> sys.stderr, "Creating directory '%s'" % MICROCODE_DIR
+                os.makedirs(MICROCODE_DIR)
+            outfile = os.path.join(MICROCODE_DIR, mcode.name + '.dtsi')
+            print >> sys.stderr, "Writing microcode for '%s' to '%s'" % (
+                     mcode.name, outfile)
+        with open(outfile, 'w') as fd:
+            print >> fd, out % tuple(args)
+
+def MicrocodeTool():
+    """Run the microcode tool"""
+    commands = 'create,license,list'.split(',')
+    parser = OptionParser()
+    parser.add_option('-d', '--mcfile', type='string', action='store',
+                    help='Name of microcode.dat file')
+    parser.add_option('-m', '--model', type='string', action='store',
+                    help='Model name to extract')
+    parser.add_option('-o', '--outfile', type='string', action='store',
+                    help='Filename to use for output (- for stdout), default is'
+                    ' %s/<name>.dtsi' % MICROCODE_DIR)
+    parser.usage += """ command
+
+    Process an Intel microcode file (use -h for help). Commands:
+
+       create     Create microcode .dtsi file for a model
+       list       List available models in microcode file
+       license    Print the license
+
+    Typical usage:
+
+       ./tools/microcode-tool -d microcode.dat -m 306a create
+
+    This will find the appropriate file and write it to %s.""" % MICROCODE_DIR
+
+    (options, args) = parser.parse_args()
+    if not args:
+        parser.error('Please specify a command')
+    cmd = args[0]
+    if cmd not in commands:
+        parser.error("Unknown command '%s'" % cmd)
+
+    if not options.mcfile:
+        parser.error('You must specify a microcode file')
+    date, license_text, microcodes = ParseFile(options.mcfile)
+
+    if cmd == 'list':
+        List(date, microcodes, options.model)
+    elif cmd == 'license':
+        print '\n'.join(license_text)
+    elif cmd == 'create':
+        if not options.model:
+            parser.error('You must specify a model to create')
+        model = options.model.lower()
+        mcode_list, tried = FindMicrocode(microcodes, model)
+        if not mcode_list:
+            parser.error("Unknown model '%s' (%s) - try 'list' to list" %
+                        (model, ', '.join(tried)))
+        if len(mcode_list) > 1:
+            parser.error("Ambiguous model '%s' (%s) matched %s - try 'list' "
+                        "to list or specify a particular file" %
+                        (model, ', '.join(tried),
+                        ', '.join([m.name for m in mcode_list])))
+        CreateFile(date, license_text, mcode_list[0], options.outfile)
+    else:
+        parser.error("Unknown command '%s'" % cmd)
+
+if __name__ == "__main__":
+    MicrocodeTool()
diff -ruN u-boot-2015.01-rc3/tools/microcode-tool.py u-boot/tools/microcode-tool.py
--- u-boot-2015.01-rc3/tools/microcode-tool.py	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/tools/microcode-tool.py	2015-01-01 17:34:32.897492694 +0100
@@ -0,0 +1,253 @@
+#!/usr/bin/env python
+#
+# Copyright (c) 2014 Google, Inc
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+# Intel microcode update tool
+
+from optparse import OptionParser
+import os
+import re
+import struct
+import sys
+
+MICROCODE_DIR = 'arch/x86/dts/microcode'
+
+class Microcode:
+    """Holds information about the microcode for a particular model of CPU.
+
+    Attributes:
+        name:  Name of the CPU this microcode is for, including any version
+                   information (e.g. 'm12206a7_00000029')
+        model: Model code string (this is cpuid(1).eax, e.g. '206a7')
+        words: List of hex words containing the microcode. The first 16 words
+                   are the public header.
+    """
+    def __init__(self, name, data):
+        self.name = name
+        # Convert data into a list of hex words
+        self.words = []
+        for value in ''.join(data).split(','):
+            hexval = value.strip()
+            if hexval:
+                self.words.append(int(hexval, 0))
+
+        # The model is in the 4rd hex word
+        self.model = '%x' % self.words[3]
+
+def ParseFile(fname):
+    """Parse a micrcode.dat file and return the component parts
+
+    Args:
+        fname: Filename to parse
+    Returns:
+        3-Tuple:
+            date:         String containing date from the file's header
+            license_text: List of text lines for the license file
+            microcodes:   List of Microcode objects from the file
+    """
+    re_date = re.compile('/\* *(.* [0-9]{4}) *\*/$')
+    re_license = re.compile('/[^-*+] *(.*)$')
+    re_name = re.compile('/\* *(.*)\.inc *\*/', re.IGNORECASE)
+    microcodes = {}
+    license_text = []
+    date = ''
+    data = []
+    name = None
+    with open(fname) as fd:
+        for line in fd:
+            line = line.rstrip()
+            m_date = re_date.match(line)
+            m_license = re_license.match(line)
+            m_name = re_name.match(line)
+            if m_name:
+                if name:
+                    microcodes[name] = Microcode(name, data)
+                name = m_name.group(1).lower()
+                data = []
+            elif m_license:
+                license_text.append(m_license.group(1))
+            elif m_date:
+                date = m_date.group(1)
+            else:
+                data.append(line)
+    if name:
+        microcodes[name] = Microcode(name, data)
+    return date, license_text, microcodes
+
+def List(date, microcodes, model):
+    """List the available microcode chunks
+
+    Args:
+        date:           Date of the microcode file
+        microcodes:     Dict of Microcode objects indexed by name
+        model:          Model string to search for, or None
+    """
+    print 'Date: %s' % date
+    if model:
+        mcode_list, tried = FindMicrocode(microcodes, model.lower())
+        print 'Matching models %s:' % (', '.join(tried))
+    else:
+        print 'All models:'
+        mcode_list = [microcodes[m] for m in microcodes.keys()]
+    for mcode in mcode_list:
+        print '%-20s: model %s' % (mcode.name, mcode.model)
+
+def FindMicrocode(microcodes, model):
+    """Find all the microcode chunks which match the given model.
+
+    This model is something like 306a9 (the value returned in eax from
+    cpuid(1) when running on Intel CPUs). But we allow a partial match,
+    omitting the last 1 or two characters to allow many families to have the
+    same microcode.
+
+    If the model name is ambiguous we return a list of matches.
+
+    Args:
+        microcodes: Dict of Microcode objects indexed by name
+        model:      String containing model name to find
+    Returns:
+        Tuple:
+            List of matching Microcode objects
+            List of abbreviations we tried
+    """
+    # Allow a full name to be used
+    mcode = microcodes.get(model)
+    if mcode:
+        return [mcode], []
+
+    tried = []
+    found = []
+    for i in range(3):
+        abbrev = model[:-i] if i else model
+        tried.append(abbrev)
+        for mcode in microcodes.values():
+            if mcode.model.startswith(abbrev):
+                found.append(mcode)
+        if found:
+            break
+    return found, tried
+
+def CreateFile(date, license_text, mcode, outfile):
+    """Create a microcode file in U-Boot's .dtsi format
+
+    Args:
+        date:       String containing date of original microcode file
+        license:    List of text lines for the license file
+        mcode:      Microcode object to write
+        outfile:    Filename to write to ('-' for stdout)
+    """
+    out = '''/*%s
+ * ---
+ * This is a device tree fragment. Use #include to add these properties to a
+ * node.
+ *
+ * Date: %s
+ */
+
+compatible = "intel,microcode";
+intel,header-version = <%d>;
+intel,update-revision = <%#x>;
+intel,date-code = <%#x>;
+intel,processor-signature = <%#x>;
+intel,checksum = <%#x>;
+intel,loader-revision = <%d>;
+intel,processor-flags = <%#x>;
+
+/* The first 48-bytes are the public header which repeats the above data */
+data = <%s
+\t>;'''
+    words = ''
+    for i in range(len(mcode.words)):
+        if not (i & 3):
+            words += '\n'
+        val = mcode.words[i]
+        # Change each word so it will be little-endian in the FDT
+        # This data is needed before RAM is available on some platforms so we
+        # cannot do an endianness swap on boot.
+        val = struct.unpack("<I", struct.pack(">I", val))[0]
+        words += '\t%#010x' % val
+
+    # Take care to avoid adding a space before a tab
+    text = ''
+    for line in license_text:
+        if line[0] == '\t':
+            text += '\n *' + line
+        else:
+            text += '\n * ' + line
+    args = [text, date]
+    args += [mcode.words[i] for i in range(7)]
+    args.append(words)
+    if outfile == '-':
+        print out % tuple(args)
+    else:
+        if not outfile:
+            if not os.path.exists(MICROCODE_DIR):
+                print >> sys.stderr, "Creating directory '%s'" % MICROCODE_DIR
+                os.makedirs(MICROCODE_DIR)
+            outfile = os.path.join(MICROCODE_DIR, mcode.name + '.dtsi')
+            print >> sys.stderr, "Writing microcode for '%s' to '%s'" % (
+                     mcode.name, outfile)
+        with open(outfile, 'w') as fd:
+            print >> fd, out % tuple(args)
+
+def MicrocodeTool():
+    """Run the microcode tool"""
+    commands = 'create,license,list'.split(',')
+    parser = OptionParser()
+    parser.add_option('-d', '--mcfile', type='string', action='store',
+                    help='Name of microcode.dat file')
+    parser.add_option('-m', '--model', type='string', action='store',
+                    help='Model name to extract')
+    parser.add_option('-o', '--outfile', type='string', action='store',
+                    help='Filename to use for output (- for stdout), default is'
+                    ' %s/<name>.dtsi' % MICROCODE_DIR)
+    parser.usage += """ command
+
+    Process an Intel microcode file (use -h for help). Commands:
+
+       create     Create microcode .dtsi file for a model
+       list       List available models in microcode file
+       license    Print the license
+
+    Typical usage:
+
+       ./tools/microcode-tool -d microcode.dat -m 306a create
+
+    This will find the appropriate file and write it to %s.""" % MICROCODE_DIR
+
+    (options, args) = parser.parse_args()
+    if not args:
+        parser.error('Please specify a command')
+    cmd = args[0]
+    if cmd not in commands:
+        parser.error("Unknown command '%s'" % cmd)
+
+    if not options.mcfile:
+        parser.error('You must specify a microcode file')
+    date, license_text, microcodes = ParseFile(options.mcfile)
+
+    if cmd == 'list':
+        List(date, microcodes, options.model)
+    elif cmd == 'license':
+        print '\n'.join(license_text)
+    elif cmd == 'create':
+        if not options.model:
+            parser.error('You must specify a model to create')
+        model = options.model.lower()
+        mcode_list, tried = FindMicrocode(microcodes, model)
+        if not mcode_list:
+            parser.error("Unknown model '%s' (%s) - try 'list' to list" %
+                        (model, ', '.join(tried)))
+        if len(mcode_list) > 1:
+            parser.error("Ambiguous model '%s' (%s) matched %s - try 'list' "
+                        "to list or specify a particular file" %
+                        (model, ', '.join(tried),
+                        ', '.join([m.name for m in mcode_list])))
+        CreateFile(date, license_text, mcode_list[0], options.outfile)
+    else:
+        parser.error("Unknown command '%s'" % cmd)
+
+if __name__ == "__main__":
+    MicrocodeTool()
diff -ruN u-boot-2015.01-rc3/tools/pblimage.c u-boot/tools/pblimage.c
--- u-boot-2015.01-rc3/tools/pblimage.c	2014-12-08 22:35:08.000000000 +0100
+++ u-boot/tools/pblimage.c	2015-01-01 17:34:32.905492563 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2012-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -8,6 +8,10 @@
 #include "pblimage.h"
 #include "pbl_crc32.h"
 
+#define roundup(x, y)		((((x) + ((y) - 1)) / (y)) * (y))
+#define PBL_ACS_CONT_CMD	0x81000000
+#define PBL_ADDR_24BIT_MASK	0x00ffffff
+
 /*
  * Initialize to an invalid value.
  */
@@ -22,6 +26,13 @@
 static char *fname = "Unknown";
 static int lineno = -1;
 static struct pbl_header pblimage_header;
+static int uboot_size;
+static int arch_flag;
+
+static uint32_t pbl_cmd_initaddr;
+static uint32_t pbi_crc_cmd1;
+static uint32_t pbi_crc_cmd2;
+static uint32_t pbl_end_cmd[4];
 
 static union
 {
@@ -38,20 +49,6 @@
  * start offset by subtracting the size of the u-boot image from the
  * top of the allowable 24-bit range.
  */
-static void init_next_pbl_cmd(FILE *fp_uboot)
-{
-	struct stat st;
-	int fd = fileno(fp_uboot);
-
-	if (fstat(fd, &st) == -1) {
-		printf("Error: Could not determine u-boot image size. %s\n",
-			strerror(errno));
-		exit(EXIT_FAILURE);
-	}
-
-	next_pbl_cmd = 0x82000000 - st.st_size;
-}
-
 static void generate_pbl_cmd(void)
 {
 	uint32_t val = next_pbl_cmd;
@@ -66,11 +63,15 @@
 
 static void pbl_fget(size_t size, FILE *stream)
 {
-	unsigned char c;
+	unsigned char c = 0xff;
 	int c_temp;
 
-	while (size && (c_temp = fgetc(stream)) != EOF) {
-		c = (unsigned char)c_temp;
+	while (size) {
+		c_temp = fgetc(stream);
+		if (c_temp != EOF)
+			c = (unsigned char)c_temp;
+		else if ((c_temp == EOF) && (arch_flag == IH_ARCH_ARM))
+			c = 0xff;
 		*pmem_buf++ = c;
 		pbl_size++;
 		size--;
@@ -80,8 +81,8 @@
 /* load split u-boot with PBI command 81xxxxxx. */
 static void load_uboot(FILE *fp_uboot)
 {
-	init_next_pbl_cmd(fp_uboot);
-	while (next_pbl_cmd < 0x82000000) {
+	next_pbl_cmd = pbl_cmd_initaddr - uboot_size;
+	while (next_pbl_cmd < pbl_cmd_initaddr) {
 		generate_pbl_cmd();
 		pbl_fget(64, fp_uboot);
 	}
@@ -154,8 +155,6 @@
 /* write end command and crc command to memory. */
 static void add_end_cmd(void)
 {
-	uint32_t pbl_end_cmd[4] = {0x09138000, 0x00000000,
-		0x091380c0, 0x00000000};
 	uint32_t crc32_pbl;
 	int i;
 	unsigned char *p = (unsigned char *)&pbl_end_cmd;
@@ -172,8 +171,8 @@
 
 	/* Add PBI CRC command. */
 	*pmem_buf++ = 0x08;
-	*pmem_buf++ = 0x13;
-	*pmem_buf++ = 0x80;
+	*pmem_buf++ = pbi_crc_cmd1;
+	*pmem_buf++ = pbi_crc_cmd2;
 	*pmem_buf++ = 0x40;
 	pbl_size += 4;
 
@@ -184,17 +183,6 @@
 	*pmem_buf++ = (crc32_pbl >> 8) & 0xff;
 	*pmem_buf++ = (crc32_pbl) & 0xff;
 	pbl_size += 4;
-
-	if ((pbl_size % 16) != 0) {
-		for (i = 0; i < 8; i++) {
-			*pmem_buf++ = 0x0;
-			pbl_size++;
-		}
-	}
-	if ((pbl_size % 16 != 0)) {
-		printf("Error: Bad size of image file\n");
-		exit(EXIT_FAILURE);
-	}
 }
 
 void pbl_load_uboot(int ifd, struct image_tool_params *params)
@@ -268,12 +256,64 @@
 	/*nothing need to do, pbl_load_uboot takes care of whole file. */
 }
 
+int pblimage_check_params(struct image_tool_params *params)
+{
+	FILE *fp_uboot;
+	int fd;
+	struct stat st;
+
+	if (!params)
+		return EXIT_FAILURE;
+
+	fp_uboot = fopen(params->datafile, "r");
+	if (fp_uboot == NULL) {
+		printf("Error: %s open failed\n", params->datafile);
+		exit(EXIT_FAILURE);
+	}
+	fd = fileno(fp_uboot);
+
+	if (fstat(fd, &st) == -1) {
+		printf("Error: Could not determine u-boot image size. %s\n",
+		       strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	/* For the variable size, we need to pad it to 64 byte boundary */
+	uboot_size = roundup(st.st_size, 64);
+
+	if (params->arch == IH_ARCH_ARM) {
+		arch_flag = IH_ARCH_ARM;
+		pbi_crc_cmd1 = 0x61;
+		pbi_crc_cmd2 = 0;
+		pbl_cmd_initaddr = params->addr & PBL_ADDR_24BIT_MASK;
+		pbl_cmd_initaddr |= PBL_ACS_CONT_CMD;
+		pbl_cmd_initaddr |= uboot_size;
+		pbl_end_cmd[0] = 0x09610000;
+		pbl_end_cmd[1] = 0x00000000;
+		pbl_end_cmd[2] = 0x096100c0;
+		pbl_end_cmd[3] = 0x00000000;
+	} else if (params->arch == IH_ARCH_PPC) {
+		arch_flag = IH_ARCH_PPC;
+		pbi_crc_cmd1 = 0x13;
+		pbi_crc_cmd2 = 0x80;
+		pbl_cmd_initaddr = 0x82000000;
+		pbl_end_cmd[0] = 0x09138000;
+		pbl_end_cmd[1] = 0x00000000;
+		pbl_end_cmd[2] = 0x091380c0;
+		pbl_end_cmd[3] = 0x00000000;
+	}
+
+	next_pbl_cmd = pbl_cmd_initaddr;
+	return 0;
+};
+
 /* pblimage parameters */
 static struct image_type_params pblimage_params = {
 	.name		= "Freescale PBL Boot Image support",
 	.header_size	= sizeof(struct pbl_header),
 	.hdr		= (void *)&pblimage_header,
 	.check_image_type = pblimage_check_image_types,
+	.check_params	= pblimage_check_params,
 	.verify_header	= pblimage_verify_header,
 	.print_header	= pblimage_print_header,
 	.set_header	= pblimage_set_header,
