diff -urN linux.old/drivers/atm/Config.in linux.dev/drivers/atm/Config.in
--- linux.old/drivers/atm/Config.in	2005-08-22 23:18:37.773532032 +0200
+++ linux.dev/drivers/atm/Config.in	2005-08-23 04:46:50.076846888 +0200
@@ -99,4 +99,10 @@
     bool 'Use S/UNI PHY driver' CONFIG_ATM_HE_USE_SUNI
   fi
 fi
+#
+# Texas Instruments SANGAM ADSL/ATM support
+#
+if [ "$CONFIG_AR7" = "y" ]; then
+     tristate 'Texas Instruments SANGAM ATM/ADSL support' CONFIG_MIPS_SANGAM_ATM
+fi
 endmenu
diff -urN linux.old/drivers/atm/Makefile linux.dev/drivers/atm/Makefile
--- linux.old/drivers/atm/Makefile	2005-08-22 23:18:37.773532032 +0200
+++ linux.dev/drivers/atm/Makefile	2005-08-23 04:46:50.077846736 +0200
@@ -14,6 +14,32 @@
 obj-$(CONFIG_ATM_NICSTAR) += nicstar.o
 obj-$(CONFIG_ATM_IDT77252) += idt77252.o
 
+ifeq ($(CONFIG_AR7),y)
+
+subdir-$(CONFIG_MIPS_SANGAM_ATM) += sangam_atm
+
+EXTRA_CFLAGS += -DEL -I$(TOPDIR)/drivers/atm/sangam_atm -DPOST_SILICON -DCOMMON_NSP -DCONFIG_LED_MODULE -DDEREGISTER_LED -DNO_ACT
+#EXTRA_CFLAGS += -DEL -I$(TOPDIR)/drivers/atm/sangam_atm -DPOST_SILICON -DCOMMON_NSP
+
+ifeq ($(ANNEX),B)
+EXTRA_CFLAGS += -DANNEX_B -DB
+else
+ifeq ($(ANNEX),C)
+EXTRA_CFLAGS += -DANNEX_C -DC
+else
+EXTRA_CFLAGS += -DANNEX_A -DP
+endif
+endif
+
+list-multi	:= tiatm.o
+tiatm-objs	:= sangam_atm/tn7atm.o sangam_atm/tn7dsl.o sangam_atm/tn7sar.o \
+	sangam_atm/dsl_hal_api.o sangam_atm/dsl_hal_support.o sangam_atm/cpsar.o \
+	sangam_atm/aal5sar.o
+
+obj-$(CONFIG_MIPS_SANGAM_ATM) += sangam_atm/tiatm.o
+
+endif
+
 ifeq ($(CONFIG_ATM_NICSTAR_USE_SUNI),y)
   obj-$(CONFIG_ATM_NICSTAR) += suni.o
 endif
diff -urN linux.old/drivers/atm/sangam_atm/aal5sar.c linux.dev/drivers/atm/sangam_atm/aal5sar.c
--- linux.old/drivers/atm/sangam_atm/aal5sar.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/aal5sar.c	2005-08-23 04:46:50.080846280 +0200
@@ -0,0 +1,2962 @@
+
+/**
+ *  
+ *  aal5sar.c
+ *
+ *  TNETDxxxx Software Support\n
+ *  Copyright (c) 2002 Texas Instruments Incorporated. All Rights Reserved.
+ *
+ *  version
+ *      28Feb02 Greg       1.00  Original Version created.\n 
+ *      06Mar02 Greg       1.01  Documentation (Doxygen-style) enhanced
+ *      06May02 Greg       1.02  AAL2 added
+ *      06Jun02 Greg       1.03  Multiple API and bug fixes from emulation
+ *      12Jul02 Greg       1.04  API Update
+ */
+
+/**
+@defgroup CPHAL_Functions CPHAL Functions
+
+These are the CPHAL Functions.
+*/
+
+/**
+@page CPHAL_Implementation_Details
+
+@section cphal_intro Introduction
+
+The CPHAL API described above is generally applicable to all modules.  Any
+implementation differences will be described in the following module-specific
+appendix sections.  
+
+Included for your reference is a diagram showing the internal architecture
+of the CPHAL:
+
+@image html SangamSoftware.jpg "HAL Architecture"
+@image latex SangamSoftware.jpg "HAL Architecture" height=2.8in
+
+*/
+
+/**
+@defgroup AAL5_Functions Additional Functions for AAL5 Implementation
+
+These functions are used only by the AAL5 module.
+*/
+
+/*
+@defgroup CPMAC_Functions Additional Functions for CPMAC Implementation
+
+No additional functions currently defined.
+*/
+
+/**
+@page VDMA_Implementation_Details
+
+@section vdma_intro Introduction
+
+The VDMA-VT module facilitates efficient transfer of data (especially voice)
+between two devices, as shown in the figure below.
+
+@image html vdma.jpg "VDMA System Block Diagram"
+@image latex vdma.jpg "VDMA System Block Diagram" height=1in
+
+The VDMA-VT module supports two modes of operation: mirror mode and credit mode.
+Mirror mode is intended for systems in which the remote device does not have a
+VDMA-based module.  Credit mode is intended for highest performance when VDMA-based
+modules exist on both ends of an interface.
+
+For more detailed information on the operation of the VDMA module, please
+reference the VDMA Module Guide.
+
+@section vdma_channels VDMA Channels
+
+The VDMA-VT module is a single channel, single transmit queue device.  Therefore,
+when using the CHANNEL_INFO structure, the correct value for @c Ch is always 0.
+Correspondingly, the correct value for the @c Ch parameter in @c ChannelTeardown() is
+always 0.  Further, when calling @c Send(), the driver should always supply the value
+of 0 for both the @c Ch and @c Queue parameters.
+
+For the VDMA-VT, configuring the channel requires the configuration of either 2 FIFO 
+elements (in credit mode) or 4 FIFO elements (in mirror mode).  For credit mode, the
+driver must configure just the local Tx and Rx FIFOs.  For mirror mode, the driver must
+configure the Tx and Rx FIFOs for both the remote and local ends of the interface.
+
+This channel configuration is accomplished through multiple calls to @c ChannelSetup().
+Each call configures a single FIFO, according to the parameters in the CHANNEL_INFO
+structure.  The members of VDMA-VT's CHANNEL_INFO structure are defined below.
+
+
+- int RemFifoAddr; Address of remote FIFO (mirror mode only).  Set to 0 for credit mode.
+- int FifoAddr;    Address of the local FIFO.  If 0, the CPHAL will allocate the FIFO.
+- int FifoSize;    Size of the FIFO.
+- int PollInt;     Polling interval for the FIFO.
+- int Endianness;  Endianness of the FIFO.  If 1, big endian.  If 0, little endian.
+- int RemAddr;     Used only in credit mode.  This is the base address of the remote
+                   remote VDMA-based device (VDMA-VT or AAL2)
+- int RemDevID;    Used only in credit mode.  Identifies the type of remote VDMA-based device.
+                   0=VDMAVT, 1=AAL2 Ch0, 2=AAL2 Ch1, 3=AAL2 Ch2, 4= AAL2 Ch3.       
+
+For the VDMA-VT module, the driver must make all calls to @c ChannelSetup() prior to calling
+@c Open().  This is because several of the channel specific parameters may not be changed
+while the VDMA-VT module is operational.
+
+@section vdma_params VDMA Parameters
+
+Defined here are the set of parameters for the VDMA-VT module.  Default settings for
+each parameter should be represented in the device configuration file (options.conf).
+During @c Init(), the CPHAL will reference the device configuration file and load all
+default settings.  The @c Control() interface gives the driver an opportunity to
+modify any default settings before the module becomes operational during the @c Open()
+call.
+
+@param NoTxIndication  If 1, the CPHAL will not call @c SendComplete(). 0 is default.
+@param NoRxIndication  If 1, the CPHAL will not call @c Receive(). 0 is default.
+@param RemoteCPU       If 1, the CPHAL will not directly manipulate data in FIFO's, leaving
+                       that task for a remote CPU. 0 is default.
+@param RxIntEn         If 1, enables Rx interrupts.  0 is default.
+@param TxIntEn         If 1, enables Tx interrupts.  0 is default.
+@param Mirror          If 1, enables mirror mode.  0 selects credit mode (default).
+@param RxIntCtl        Valid only in mirror mode.  If 1, interrupts will occur when the Rx FIFO
+                       RdIndex is updated.  If 0, interrupts occur when the Rx FIFO WrIndex
+                       is updated.
+@param TxIntCtl        Valid only in mirror mode.  If 1, interrupts will occur when the Rx FIFO
+                       RdIndex is updated.  If 0, interrupts occur when the Rx FIFO WrIndex
+                       is updated.
+@param RBigEn          Remote big endian mode.  If 1, remote is big endian.
+@param LBigEn          Local big endian mode.  If 1, local is big endian.
+
+@section vdma_polling Using VDMA-VT without interrupts
+
+If your system configuration does not utilize VDMA interrupts, the ability to process the
+Tx and Rx FIFOs is supported.  To process the Tx FIFO, call @c CheckTx().  If the CPHAL is
+able to process any complete data transmissions, it will call @c SendComplete() as usual.  
+To process the Rx FIFO, call @c CheckRx().  If the CPHAL has received any data, it will
+call @c Receive() to pass the driver the data.  Please reference @ref VDMA_Functions for more
+information on these interfaces.
+
+@section vdma_details VDMA Implementation Details
+
+The following functions are not defined for use with VDMA:  @c Status(), @c Tick(), @c StatsGet(),
+and @c StatsClear().
+
+*/
+
+/**
+@page AAL5_Implementation_Details
+
+@section aal5_ver Version
+
+@copydoc AAL5_Version
+
+@section aal5_intro Introduction
+
+The AAL5 implementation will support 16 channels for transmit and 16 channels for
+receive.  Each of the transmit channels may have up to two transmit queues
+associated with it.  If two queues are used, Queue 0 is the high priority queue,
+and Queue 1 is the low priority queue.
+
+@section aal5_params AAL5 Configuration Parameters
+
+AAL5 requires two device entries to be available in the configuration repository, named
+@p "aal5" and @p "sar".  The @p aal5 device entry must contain @p base (base address)
+and @p int_line (interrupt number). The @p sar device entry must have both @p base 
+(base address) and @p reset_bit (reset bit).
+
+@par Device Level Configuration Parameters
+
+The following parameters are device-level parameters, which apply across all
+channels.  The value for these parameters may be modified by changing the value in the
+configuration repository.  
+
+- "UniNni":  
+AAL5 network setting. 0 = UNI (default), 1 = NNI.
+
+@par Channel Configuration Parameters
+
+All AAL5 channel parameters may also be configured through the @c ChannelSetup() interface.
+Following is the list of @p CHANNEL_INFO members that may be modified by the driver when 
+calling @c ChannelSetup().  The driver may provide a value of 0xFFFFFFFF for any channel 
+parameter to select a default value for the parameter.  The driver should at a minimum 
+configure @p Vci and @p Vpi.  The usage of all parameters beginning with TxVc_,
+TxVp_, RxVc_, RxVp_ is described in greater detail in the SAR Firmware Spec.
+These parameters are mainly associated with QoS and OAM functionality.
+
+- "RxNumBuffers":    
+The number of Rx buffer descriptors to allocate for Ch.  
+- "RxBufSize":         
+Size (in bytes) for each Rx buffer.
+- "RxBufferOffset":   
+Number of bytes to offset rx data from start of buffer (must be less than buffer size).
+- "RxServiceMax":    
+Maximum number of packets to service at one time.
+- "TxNumBuffers":      
+The number of Tx buffer descriptors to allocate for Ch.
+- "TxNumQueues":        
+Number of Tx queues for this channel (1-2). Choosing 2 enables a low priority SAR queue. 
+- "TxServiceMax":       
+Maximum number of packets to service at one time. 
+- "CpcsUU":         
+The 2-byte CPCS UU and CPI information.
+- "Gfc":    
+Generic Flow Control.  Used in ATM header of Tx packets.
+- "Clp":   
+Cell Loss Priority.  Used in ATM header of Tx packets.
+- "Pti":   
+Payload Type Indication.  Used in ATM header of Tx packets.
+- "DaMask":           
+Specifies whether credit issuance is paused when Tx data not available.
+- "Priority":   
+Priority bin this channel will be scheduled within.
+- "PktType":   
+0=AAL5,1=Null AAL,2=OAM,3=Transparent,4=AAL2.
+- "Vci":                
+Virtual Channel Identifier.
+- "Vpi":                 
+Virtual Path Identifier.
+- "TxVc_AtmHeader":
+In firmware OAM mode, this
+is the ATM header to be appended to front of firmware generated VC OAM cells for
+this channel.  Note: To generate host OAM cells, call @c Send() with 
+the appropriate mode.
+- "TxVc_CellRate":       
+Tx rate, set as clock ticks between transmissions (SCR for VBR, CBR for CBR).
+- "TxVc_QosType":        
+0=CBR,1=VBR,2=UBR,3=UBRmcr.
+- "TxVc_Mbs":            
+Min Burst Size in cells.
+- "TxVc_Pcr":            
+Peak Cell Rate for VBR in clock ticks between transmissions.
+- "TxVc_OamTc":   
+TC Path to transmit OAM cells for TX connections (0,1).
+- "TxVc_VpOffset":   
+Offset to the OAM VP state table for TX connections.  Channels with the same
+VPI must have the same VpOffset value.  Channels with different VPIs
+must have unique VpOffset values.
+- "RxVc_OamCh":   
+Channel to which to terminate received OAM cells to be forwarded to the Host
+for either Host OAM mode, or when RxVc_OamToHost is enabled during Firmware
+OAM mode.
+- "RxVc_OamToHost":   
+Indicates whether to pass received unmatched OAM loopback cells to the host;
+0=do not pass, 1=pass.
+- "RxVc_AtmHeader":   
+ATM Header placed on firmware gen'd OAM cells for this channel on a Rx 
+connection (must be big endian with 0 PTI).
+- "RxVc_OamTc":   
+TC Path to transmit OAM cells for RX connections (0,1).
+- "RxVc_VpOffset":   
+Offset to the OAM VP state table for RX connections.  Channels with the same
+VPI must have the same VpOffset value.  Channels with different VPIs
+must have unique VpOffset values.
+- "TxVp_OamTc":   
+TC Path to transmit OAM cells for TX VP connections (0,1).
+- "TxVp_AtmHeader":   
+ATM Header placed on firmware gen'd VP OAM cells for this channel on a Tx VP
+connection (must be big endian with 0 VCI).
+- "RxVp_OamCh":   
+Channel to which to terminate received OAM cells to be forwarded to the Host
+for either Host OAM mode, or when RxVc_OamToHost is enabled during Firmware
+OAM mode.
+- "RxVp_OamToHost":   
+Indicates whether to pass received unmatched OAM loopback cells to the host;
+0=do not pass, 1=pass.
+- "RxVp_AtmHeader":
+In firmware OAM mode, this
+is the ATM header to be appended to front of firmware generated VP OAM cells for
+this channel.  Note: To generate host OAM cells, call @c Send() with 
+the appropriate mode.
+- "RxVp_OamTc":   
+TC Path to transmit OAM cells for RX VP connections (0,1).
+- "RxVp_OamVcList":   
+This 32-bit field is one-hot encoded to indicate all the VC channels that are
+associated with this VP channel.  A value of 21 will indicate that VC
+channels 0, 2, and 4 are associated with this VP channel.
+- "FwdUnkVc":
+Indicates whether or not to forward unknown VCI/VPI cells to the host.  This 
+parameter only takes effect if the channel's PktType is Transparent(3).
+1=forwarding enabled, 0=forwarding disabled.
+
+@section aal5_details API Implementation Details
+
+ATTENTION: Documentation given here supplements the documentation given in the general
+CPHAL API section.  The following details are crucial to correct usage of the
+AAL5 CPHAL.
+
+@par Receive()
+The least significant byte of @p Mode contains the channel number.  Bit 31
+indicates whether or not the ATM header is present in the first fragment of
+the packet.  If bit 31 is set, the 4 byte ATM header (minus HEC) will be provided 
+in the first fragment, with the payload beginning in the second fragment.  Currently,
+this is the default behavior for host OAM and transparent mode packets.
+Bits 17-16 indicate the packet type that is being received.  
+Mode Parameter Breakdown: <BR>
+- 31     ATM Header In First Fragment (1=true, 0=false) <BR>
+- 30-18  Unused. <BR>
+- 17-16  Pkt Type. <BR>
+  -   0=AAL5 <BR>
+  -   1=PTI Based Null AAL <BR>
+  -   2=OAM <BR>
+  -   3=Transparent <BR>
+- 15-08  Unused. <BR>
+- 07-00  Channel Number.
+
+@par Send()
+The most significant 16 bits of the first fragment 'len' is used as the Offset 
+to be added to the packet.  @c Send() will reserve this many bytes at the 
+beginning of the transmit buffer prior to the first byte of valid data.
+For the @p Mode parameter, Bit 31 must be set if the user has sent a packet with
+the ATM Header (minus HEC) embedded in the first 4 bytes of the first fragment data buffer.
+The OS has the option of using a 4 byte first fragment containing only ATM header,
+or concatenating the ATM Header in front of the data payload.
+If Bit 31 is set, the ATM Header in the buffer is preserved and sent with
+each cell of the packet.  Otherwise, Send() will build the ATM header based on the
+values of the Pti, Gfc, Clp, Vpi, and Vci parameters for the given channel.
+Bits 17-16 are defined as the packet type.  Bits 15-08 may be used to specify the 
+transmit queue to send the packet on.  Only values 0 (high priority) and 1 (low 
+priority) are accepted.  Bits 07-00 should be used to indicate the channel number 
+for the @c Send() operation.  Valid channel numbers are 0-15.
+Mode Parameter Breakdown: <BR>
+- 31     ATM Header In Packet (1=true, 0=false) <BR>
+- 30-18  Unused. <BR>
+- 17-16  Pkt Type. <BR>
+  -   0=AAL5 <BR>
+  -   1=PTI Based Null AAL <BR>
+  -   2=OAM <BR>
+  -   3=Transparent <BR>
+- 15-08  Transmit Queue. <BR>
+- 07-00  Channel Number.
+  
+@par ChannelSetup()
+The AAL5 @c ChannelSetup() always configures both the Tx and Rx side of the channel
+connection in the same call.
+
+@par ChannelTeardown()
+Regardless of the channel teardown direction selected, the AAL5 CPHAL will always
+teardown both the Tx and Rx side of the channel connection.
+
+@par TeardownComplete()
+The value for the @p Direction parameter should be ignored for the AAL5 implementation,
+since both directions (Tx and Rx) are always torndown in response to a @c ChannelTeardown()
+command.
+
+@par Control() (HAL version)
+Defined keys and actions.  Unless otherwise stated, the data type
+for Value is pointer to unsigned integer.  The list is broken into
+three groups, one group which can be used anytime, one group that should
+be used before halOpen(), and one group which can only be used after 
+halOpen() (but before halClose()).  For channelized parameters, replace
+'Ch' with the integer number of a channel (ex. "Gfc.4" can be used to set
+Gfc for channel 4).
+
+MAY USE ANYTIME AFTER INIT (after halInit() is called):
+
+- "Gfc.Ch".  The OS may "Set" this value.  Changing this value causes
+the Gfc in each Tx ATM header for this channel to take on the new Gfc value.
+
+- "Clp.Ch".  The OS may "Set" this value.  Changing this value causes
+the Clp in each Tx ATM header for this channel to take on the new Clp value.
+
+- "Pti.Ch".  The OS may "Set" this value.  Changing this value causes
+the Pti in each Tx ATM header for this channel to take on the new Pti value.
+
+- "CpcsUU.Ch".  The OS may "Set" this value.  Changing this value causes
+the CpcsUU in each Tx ATM header for this channel to take on the new CpcsUU value.
+
+- "OamMode".  Specifies if host or firmware is performing OAM functions; 0 = Host OAM, 
+1 = Firmware OAM.  When set, all SAR channels will be configured for
+the selection, including AAL2 channels.
+
+- "OamLbTimeout".  Specifies the firmware OAM loopback timeout, in milliseconds.
+
+- "DeviceCPID".  The OS may "Set" this value.  This is the OAM connection 
+point identifier.  The OS should provide a pointer to an array of 4 32-bit
+integers.  Each word must be configured in big endian format.
+
+- "FwdUnkVc.Ch".  Indicates whether or not to forward unknown VCI/VPI cells to the host.
+This parameter only takes effect if the channel's PktType is Transparent(3).
+1=forwarding enabled, 0=forwarding disabled.
+
+MAY USE ONLY BEFORE HAL IS OPEN (before halOpen() call):
+- "StrictPriority". The OS may "Set" this value.  Setting to 1 causes
+a different interrupt processing routine to be used, which gives strict
+priority to channels with lower numbers (channel 0 has highest priority).
+The default handler gives equal priority to all channels.
+
+- "MaxFrags".  The OS may "Set" or "Get" this value.  This defines the maximum
+number of fragments that can be received by the AAL5 Rx port.  The default
+value for AAL5 is 46.  This provides enough space to receive a maximum
+length AAL5 packet (65,568 bytes) with the default buffer size of 1518 bytes, and
+any amount of RxBufferOffset.  If the buffer size is configured to be smaller,
+the OS *MUST* modify this parameter according to the following formula: 
+((System Max AAL5 packet length)/(RxBufSize)) + 2.  (The extra two fragments in
+the formula allow for RxBufferOffset and one fragment for the ATM Header, used
+when receiving host OAM or transparent mode packets)
+
+MAY USE ONLY AFTER HAL IS 'OPEN' (after halOpen() call):
+- "Stats;Level;Ch;Queue".  The OS may "Get" Stats groups with this key, where 
+'Level' is an integer from 0-4, Ch is an integer from 0-15, and Queue is
+an integer from 0-1.  Note that Ch is not required for Level 4 stats, and Queue
+is not required for Level 0, 3, and 4.  The statistics functionality and return 
+value is described in the appendix entitled "Configuration and Control".
+
+- "TxVc_CellRate.Ch".  The OS may "Set" this value.  Can be used to modify
+CellRate for a channel on the fly.
+
+- "TxVc_Mbs.Ch".  The OS may "Set" this value.  Can be used to modify
+Mbs for a channel on the fly.
+
+- "TxVc_Pcr.Ch".  The OS may "Set" this value.  Can be used to modify
+Pcr for a channel on the fly.
+
+- "PdspEnable".  The OS may "Set" this value.  Value 0 disables the PDSP.
+Value 1 enables to PDSP.
+
+- "DeviceCPID".  The OS may "Set" this value.  The Value should be an array
+of 4 32-bit integers that comprise the CPID.  
+
+- "RxVc_RDICount.Ch".  The OS may "Get" or "Set" this value.  Get returns
+the current RDI count for the VC channel.  Set clears the counter, and the Value
+is ignored.
+
+- "RxVp_RDICount.Ch".  The OS may "Get" or "Set" this value.  Get returns
+the current RDI count for the VP channel.  Set clears the counter, and the Value
+is ignored.
+
+- "RxVc_AISseg.Ch". The OS may "Get" this value.  This is an indication of
+AIS segment error for the VC channel.
+
+- "RxVp_AISseg.Ch". The OS may "Get" this value.  This is an indication of
+AIS segment error for the VP channel.
+
+- "RxVc_AISetoe.Ch". The OS may "Get" this value.  This is an indication of
+AIS end-to-end error for the VC channel.
+
+- "RxVp_AISetoe.Ch". The OS may "Get" this value.  This is an indication of
+AIS end-to-end error for the VP channel.
+
+- "RxVc_OamCh.Ch". The OS may "Set" this value.  Channel to which to terminate 
+received OAM cells to be forwarded to the Host for either Host OAM mode, or when 
+RxVc_OamToHost is enabled during Firmware OAM mode.
+
+- "RxVp_OamCh.Ch". The OS may "Set" this value.  Channel to which to terminate 
+received OAM cells to be forwarded to the Host for either Host OAM mode, or when 
+RxVp_OamToHost is enabled during Firmware OAM mode.
+
+- "F4_LB_Counter". The OS may "Get" this value.  This is a count of the number
+  of near-end F4 loopbacks performed by the PDSP in firmware OAM mode.
+
+- "F5_LB_Counter". The OS may "Get" this value.  This is a count of the number
+  of near-end F5 loopbacks performed by the PDSP in firmware OAM mode.
+
+- "TxVc_AtmHeader.Ch". The OS may "Set" this value.  In firmware OAM mode, this
+is the ATM header to be appended to front of firmware generated VC OAM cells for
+this channel.  In host OAM mode, this is used as the ATM header to be appended
+to front of host generated VC OAM cells for this channel.  It must be configured
+as big endian with PTI=0.  Note: To generate host OAM cells, call @c Send() with 
+the appropriate mode.
+
+- "TxVp_AtmHeader.Ch". The OS may "Set" this value.  In firmware OAM mode, this
+is the ATM header to be appended to front of firmware generated VP OAM cells for
+this channel.  In host OAM mode, this is used as the ATM header to be appended
+to front of host generated VP OAM cells for this channel.  It must be configured
+as big endian with VCI=0.  Note: To generate host OAM cells, call @c Send() with 
+the appropriate mode.
+
+- "PdspEnable".  The OS may "Set" this value. Controls whether or not the PDSP is 
+allowed to fetch new instructions.  The PDSP is enabled by the CPHAL during Open(), 
+and disabled during Close().  0 = disabled, 1 = enabled.
+
+@par Control() (OS version)
+Defined keys and actions:
+
+- "Firmware".  The CPHAL will perform a "Get" action for the key "Firmware".  A pointer
+to a pointer is passed in @p Value.  The OS must modify the referenced pointer to point
+to the firmware.
+
+- "FirmwareSize".  The CPHAL will perform a "Get" action for the key "FirmwareSize".
+The OS must place the firmware size in the memory pointed at by @p Value.
+
+- "OamLbResult".  When a channel that is in firmware OAM mode is commanded to perform
+a loopback function, the result of the loopback generates an interrupt that is handled
+by the OS like any other interrupt.  The CPHAL, upon servicing the interrupt, will call
+osControl with this key, and an action of "Set".  The @p Value parameter will be a 
+pointer to the integer result.  1 = pass, 0 = fail.
+
+- "SarFreq". The CPHAL will perform a "Get" action for this key.  The OS should place
+the SAR frequency (in Hz) in the memory pointed at by @p Value.
+
+@section aal5_stats AAL5 Specific Statistics
+
+Statistics level '0' contains all AAL5 specific statistics.  The following values will
+be obtained when requesting stats level 0:
+
+- "Crc Errors".  Number of CRC errors reported by SAR hardware.  Incremented for received
+packets that contain CRC errors.  
+
+- "Len Errors".  Number of length errors reported by SAR hardware.  Incremented for received
+packets that are in excess of 1366 cells.
+
+- "Abort Errors".  Number of abort errors reported by SAR hardware.
+
+- "Starv Errors".  Number of buffer starvation errors reported by SAR hardware.  Incremented
+when a part or all of a buffer cannot be received due to lack of RX buffer resources.  The SAR
+drops all cells associated with the packet for each buffer starvation error that occurs.
+
+*/ 
+
+/* register files */
+#include "cp_sar_reg.h"  
+
+#define _CPHAL_AAL5
+#define _CPHAL
+#define _CPPI_TEST /** @todo remove for release */
+#define __CPHAL_CPPI_OFFSET /* support use of offset */
+
+/*  OS Data Structure definitions  */
+
+typedef void OS_PRIVATE;
+typedef void OS_DEVICE;
+typedef void OS_SENDINFO;
+typedef void OS_RECEIVEINFO;
+typedef void OS_SETUP;
+
+/*  CPHAL Data Structure definitions  */
+
+typedef struct hal_device  HAL_DEVICE;
+typedef struct hal_private HAL_PRIVATE;
+typedef struct hal_private HAL_RECEIVEINFO;
+
+/* include CPHAL header files here */
+#include "cpcommon_cpaal5.h"
+#include "cpswhal_cpaal5.h"
+#include "aal5sar.h"
+#include "cpcommon_cpaal5.c"
+    
+#define CR_SERVICE            (170-1)
+#define UTOPIA_PAUSE_REG      (*(volatile bit32u *)0xa4000000)
+
+/* 
+these masks are for the mode parameter used in halSend/OsReceive
+(may move these elsewhere)
+*/
+#define CH_MASK            0xff
+#define PRI_MASK           0x10000 
+  
+/* Rcb/Tcb Constants */
+#define CB_SOF_BIT         (1<<31)
+#define CB_EOF_BIT         (1<<30)
+#define CB_SOF_AND_EOF_BIT (CB_SOF_BIT|CB_EOF_BIT)
+#define CB_OWNERSHIP_BIT   (1<<29)
+#define CB_EOQ_BIT         (1<<28)
+#define CB_SIZE_MASK       0x0000ffff
+#define CB_OFFSET_MASK     0xffff0000
+#define RCB_ERRORS_MASK    0x03fe0000
+#define RX_ERROR_MASK      0x000f0000
+#define CRC_ERROR_MASK     0x00010000
+#define LENGTH_ERROR_MASK  0x00020000
+#define ABORT_ERROR_MASK   0x00040000
+#define STARV_ERROR_MASK   0x00080000
+#define TEARDOWN_VAL       0xfffffffc
+
+/* interrupt vector masks */
+#define TXH_PEND        0x01000000
+#define TXL_PEND        0x02000000
+#define RX_PEND         0x04000000
+#define STS_PEND        0x08000000
+#define AAL2_PEND       0x10000000
+#define INT_PENDING     (TXH_PEND | TXL_PEND | RX_PEND | STS_PEND | AAL2_PEND)
+#define STS_PEND_INVEC  0x0001F000
+#define RX_PEND_INVEC   0x00000F00
+#define TXL_PEND_INVEC  0x000000F0
+#define TXH_PEND_INVEC  0x0000000F
+#define AIS_SEG_MASK    0x1        /* +01.02.00 */
+#define AIS_SEG_SHIFT   0          /* +01.02.00 */
+#define AIS_ETOE_MASK   0x20000    /* +01.02.00 */
+#define AIS_ETOE_SHIFT  17         /* +01.02.00 */
+#define RDI_CNT_MASK    0xffff0000 /* +01.02.00 */
+#define RDI_CNT_SHIFT   16         /* +01.02.00 */
+
+/*
+ *  This function takes a vpi/vci pair and computes the 4 byte atm header
+ *  (minus the HEC).
+ *
+ *  @param  vpi  Virtual Path Identifier.
+ *  @param  vci  Virtual Channel Identifier.
+ *
+ *  @return  A properly formatted ATM header, without the HEC.
+ */ 
+static int atmheader(int gfc, int vpi, int vci, int pti, int clp)
+  {
+   int itmp;
+
+   itmp=0;
+  
+   /* UNI Mode uses the GFC field */
+   itmp |= ((gfc & 0xF) << 28);
+   itmp |= ((vpi & 0xFF) << 20);
+    
+   /* if NNI Mode, no gfc and larger VPI */
+   /*itmp |= ((vpi & 0xFFF) << 20);*/
+
+   itmp|=((vci & 0xFFFF) << 4);
+   itmp|=((pti & 0x7) << 1);
+   itmp|=(clp & 0x1);
+   return(itmp);
+  }
+
+#include "cppi_cpaal5.c"
+
+/*
+ *   Re-entrancy Issues
+ *   In order to ensure successful re-entrancy certain sections of the
+ *   CPHAL code will be bracketed as Critical.
+ *   The OS will provide the function Os.CriticalSection(BOOL), which
+ *   will be passed a TRUE to enter the Critical Section and FALSE to exit.
+ */
+
+/*
+ *  @ingroup CPHAL_Functions
+ *  Clears the statistics information.
+ *
+ *  @param  HalDev   CPHAL module instance. (set by xxxInitModule())
+ *
+ *  @return 0 OK, Non-zero not OK
+ */
+static int StatsClear(HAL_DEVICE *HalDev)
+  {
+   int i;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]StatsClear(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* clear stats */
+   for (i=0; i<NUM_AAL5_CHAN; i++)
+     {
+      HalDev->Stats.CrcErrors[i]=0;
+      HalDev->Stats.LenErrors[i]=0;
+      HalDev->Stats.DmaLenErrors[i]=0;
+      HalDev->Stats.AbortErrors[i]=0;
+      HalDev->Stats.StarvErrors[i]=0;
+      HalDev->Stats.TxMisQCnt[i][0]=0;
+      HalDev->Stats.TxMisQCnt[i][1]=0;
+      HalDev->Stats.RxMisQCnt[i]=0;
+      HalDev->Stats.RxEOQCnt[i]=0;
+      HalDev->Stats.TxEOQCnt[i][0]=0;
+      HalDev->Stats.TxEOQCnt[i][1]=0;
+      HalDev->Stats.RxPacketsServiced[i]=0;
+      HalDev->Stats.TxPacketsServiced[i][0]=0;
+      HalDev->Stats.TxPacketsServiced[i][1]=0;
+      HalDev->Stats.TxMaxServiced[i][0]=0;
+      HalDev->Stats.TxMaxServiced[i][1]=0;
+     }
+   HalDev->Stats.RxTotal=0;
+   HalDev->Stats.TxTotal=0;
+   HalDev->Stats.RxMaxServiced=0;
+   return (EC_NO_ERRORS);
+  }
+
+/*
+ *  Returns statistics information.
+ *
+ *  @param  HalDev   CPHAL module instance. (set by xxxInitModule())  
+ *
+ *  @return 0
+ */
+/*
+static STAT_INFO* StatsGet(HAL_DEVICE *HalDev)
+  {
+   STAT_INFO* MyStats = &HalDev->Stats;
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]StatsGet(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   dbgPrintf("HAL Stats:\n");
+   DispStat(HalDev, "Rx Total",MyStats->RxTotal);
+   DispStat(HalDev, "Tx Total",MyStats->TxTotal);
+   DispStat(HalDev, "Rx Peak",MyStats->RxMaxServiced);
+   DispStat(HalDev, "TxH Peak",MyStats->TxMaxServiced[0][0]);
+   DispStat(HalDev, "TxL Peak",MyStats->TxMaxServiced[0][1]);
+   DispChStat(HalDev, "CrcErr",&MyStats->CrcErrors[0],1);
+   DispChStat(HalDev, "LenErr",&MyStats->LenErrors[0],1);
+   DispChStat(HalDev, "DmaLenErr",&MyStats->DmaLenErrors[0],1);
+   DispChStat(HalDev, "AbortErr",&MyStats->AbortErrors[0],1);
+   DispChStat(HalDev, "StarvErr",&MyStats->StarvErrors[0],1);
+   DispChStat(HalDev, "TxH MisQ Cnt",&MyStats->TxMisQCnt[0][0],2);
+   DispChStat(HalDev, "TxL MisQ Cnt",&MyStats->TxMisQCnt[0][1],2);
+   DispChStat(HalDev, "Rx MisQ Cnt",&MyStats->RxMisQCnt[0],1);
+   DispChStat(HalDev, "Rx EOQ Cnt",&MyStats->RxEOQCnt[0],1); 
+   DispChStat(HalDev, "TxH EOQ Cnt",&MyStats->TxEOQCnt[0][0],2);
+   DispChStat(HalDev, "TxL EOQ Cnt",&MyStats->TxEOQCnt[0][1],2);
+   DispChStat(HalDev, "Rx Pkts",&MyStats->RxPacketsServiced[0],1);
+   DispChStat(HalDev, "TxH Pkts",&MyStats->TxPacketsServiced[0][0],2);
+   DispChStat(HalDev, "TxL Pkts",&MyStats->TxPacketsServiced[0][1],2); 
+
+   return (&HalDev->Stats);
+  }
+*/
+
+#ifdef __CPHAL_DEBUG
+void dbgChannelConfigDump(HAL_DEVICE *HalDev, int Ch)
+  {
+   CHANNEL_INFO *HalCh = &HalDev->ChData[Ch];
+   dbgPrintf("  [aal5 Inst %d, Ch %d] Config Dump:\n", HalDev->Inst, Ch);
+   dbgPrintf("    TxNumBuffers  :%08d, TxNumQueues :%08d\n", 
+             HalCh->TxNumBuffers, HalCh->TxNumQueues);
+   dbgPrintf("    RxNumBuffers  :%08d, RxBufSize   :%08d\n", 
+             HalCh->RxNumBuffers, HalCh->RxBufSize);
+   dbgPrintf("    TxServiceMax  :%08d, RxServiceMax:%08d\n", 
+             HalCh->TxServiceMax, HalCh->RxServiceMax);
+   dbgPrintf("    RxBufferOffset:%08d, DaMask      :%08d\n", 
+             HalCh->RxBufferOffset, HalCh->DaMask);
+   dbgPrintf("    CpcsUU        :%08d, Gfc         :%08d\n", 
+             HalCh->CpcsUU, HalCh->Gfc);
+   dbgPrintf("    Clp           :%08d, Pti         :%08d\n", 
+             HalCh->Clp, HalCh->Pti);
+   dbgPrintf("    Priority      :%08d, PktType     :%08d\n", 
+             HalCh->Priority, HalCh->PktType);
+   dbgPrintf("    Vci           :%08d, Vpi         :%08d\n", 
+             HalCh->Vci, HalCh->Vpi);
+   dbgPrintf("    TxVc_CellRate :%08d, TxVc_QosType:%08d\n", 
+             HalCh->TxVc_CellRate, HalCh->TxVc_QosType);
+   dbgPrintf("    TxVc_Mbs      :%08d, TxVc_Pcr    :%08d\n", 
+             HalCh->TxVc_Mbs, HalCh->TxVc_Pcr);
+   dbgPrintf("    TxVc_AtmHeader:%08d\n", 
+             HalCh->TxVc_AtmHeader);
+   osfuncSioFlush();
+  }
+#endif
+
+/*
+ * Retrieves channel parameters from configuration file.  Any parameters
+ * which are not found are ignored, and the HAL default value will apply,
+ * unless a new value is given through the channel structure in the call
+ * to ChannelSetup.
+ */
+static int ChannelConfigGet(HAL_DEVICE *HalDev, CHANNEL_INFO *HalChn)
+  {
+   unsigned int Ret, Value, Ch = HalChn->Channel;
+   OS_FUNCTIONS *OsFunc = HalDev->OsFunc;
+   void *ChInfo;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]ChannelConfigGet(HalDev:%08x, HalChn:%08x)\n", (bit32u)HalDev,
+                (bit32u)HalChn);
+      osfuncSioFlush();
+     }
+#endif
+
+   Ret=OsFunc->DeviceFindParmValue(HalDev->DeviceInfo, channel_names[Ch], &ChInfo);
+   if (Ret) return (EC_AAL5|EC_FUNC_CHSETUP|EC_VAL_CH_INFO_NOT_FOUND);
+
+   /* i don't care if a value is not found because they are optional */
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "TxNumBuffers", &Value);
+   if (!Ret) HalDev->ChData[Ch].TxNumBuffers = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "TxNumQueues", &Value);
+   if (!Ret) HalDev->ChData[Ch].TxNumQueues = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "TxServiceMax", &Value);
+   if (!Ret) HalDev->ChData[Ch].TxServiceMax = Value;
+   
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "RxNumBuffers", &Value);
+   if (!Ret) HalDev->ChData[Ch].RxNumBuffers = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "RxBufferOffset", &Value);
+   if (!Ret) HalDev->ChData[Ch].RxBufferOffset = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "RxBufSize", &Value);
+   if (!Ret) HalDev->ChData[Ch].RxBufSize = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "RxServiceMax", &Value);
+   if (!Ret) HalDev->ChData[Ch].RxServiceMax = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "CpcsUU", &Value);
+   if (!Ret) HalDev->ChData[Ch].CpcsUU = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "Gfc", &Value);
+   if (!Ret) HalDev->ChData[Ch].Gfc = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "Clp", &Value);
+   if (!Ret) HalDev->ChData[Ch].Clp = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "Pti", &Value);
+   if (!Ret) HalDev->ChData[Ch].Pti = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "DaMask", &Value);
+   if (!Ret) HalDev->ChData[Ch].DaMask = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "Priority", &Value);
+   if (!Ret) HalDev->ChData[Ch].Priority = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "PktType", &Value);
+   if (!Ret) HalDev->ChData[Ch].PktType = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "Vci", &Value);
+   if (!Ret) HalDev->ChData[Ch].Vci = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "Vpi", &Value);
+   if (!Ret) HalDev->ChData[Ch].Vpi = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "TxVc_CellRate", &Value);
+   if (!Ret) HalDev->ChData[Ch].TxVc_CellRate = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "TxVc_QosType", &Value);
+   if (!Ret) HalDev->ChData[Ch].TxVc_QosType = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "TxVc_Mbs", &Value);
+   if (!Ret) HalDev->ChData[Ch].TxVc_Mbs = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "TxVc_Pcr", &Value);
+   if (!Ret) HalDev->ChData[Ch].TxVc_Pcr = Value;
+
+   Ret=OsFunc->DeviceFindParmUint(ChInfo, "TxVc_AtmHeader", &Value);
+   if (!Ret) HalDev->ChData[Ch].TxVc_AtmHeader = Value;
+
+   return (EC_NO_ERRORS);
+  }
+
+/*
+ * Sets up channel parameters in the hardware, and initializes the CPPI
+ * TX and RX buffer descriptors and buffers.
+ */
+static int ChannelConfigApply(HAL_DEVICE *HalDev, CHANNEL_INFO *HalChn)
+  {
+   int j, Ch = HalChn->Channel;
+   volatile bit32u *pTmp;
+   int Ret; /* +GSG 030410 */
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]ChannelConfigApply(HalDev:%08x, HalChn:%08x)\n", (bit32u)HalDev,
+                (bit32u)HalChn);
+      osfuncSioFlush();
+     }
+#endif
+
+   if ((HalDev->ChIsOpen[Ch][DIRECTION_TX] == TRUE) || (HalDev->ChIsOpen[Ch][DIRECTION_RX] == TRUE))
+     {
+      return(EC_AAL5|EC_FUNC_CHSETUP|EC_VAL_CH_ALREADY_OPEN);
+     }
+
+   HalDev->InRxInt[Ch]=FALSE;
+  
+   /* Initialize Queue Data */
+   HalDev->RxActQueueHead[Ch]=0;
+   HalDev->RxActQueueCount[Ch]=0;
+   HalDev->TxActQueueHead[Ch][0]=0;
+   HalDev->TxActQueueHead[Ch][1]=0;
+   HalDev->TxActQueueCount[Ch][0]=0;
+   HalDev->TxActQueueCount[Ch][1]=0;
+   HalDev->RxActive[Ch] = FALSE;
+   HalDev->TxActive[Ch][0] = FALSE;
+   HalDev->TxActive[Ch][1] = FALSE;
+
+   /* Clear Rx State RAM */
+   pTmp = pRX_DMA_STATE_WORD_0(HalDev->dev_base) + (Ch*64);
+   for (j=0; j<NUM_RX_STATE_WORDS; j++)
+     *pTmp++ = 0; 
+     
+   /* Check that Rx DMA State RAM was cleared */
+   pTmp -= NUM_RX_STATE_WORDS;
+   for (j=0; j<NUM_RX_STATE_WORDS; j++)
+     {
+      if (*pTmp++ != 0)
+        {
+         return(EC_AAL5|EC_FUNC_CHSETUP|EC_VAL_RX_STATE_RAM_NOT_CLEARED);
+        }    
+     } 
+ 
+   /* Clear Tx State RAM */
+   pTmp = pTX_DMA_STATE_WORD_0(HalDev->dev_base) + (Ch*64);
+   for (j=0; j<NUM_TX_STATE_WORDS; j++)
+     *pTmp++ = 0; 
+     
+   /* Check that Tx DMA State RAM was cleared */
+   pTmp -= NUM_TX_STATE_WORDS;
+   for (j=0; j<NUM_TX_STATE_WORDS; j++)
+     {
+      if (*pTmp++ != 0)
+        {
+         return(EC_AAL5|EC_FUNC_CHSETUP|EC_VAL_TX_STATE_RAM_NOT_CLEARED);
+        }
+     }
+  
+   /* Initialize Tx State RAM (Nothing to do) */
+   
+   /* Initialize Rx State RAM */
+   /* Configure the Rx buffer offset */
+   pTmp=(pRX_DMA_STATE_WORD_0(HalDev->dev_base) + (Ch*64));
+   *pTmp |= (HalDev->ChData[Ch].RxBufferOffset & 0xFF);
+
+   /* Initialize buffer memory for the channel */
+   Ret = InitTcb(HalDev, Ch);
+   if (Ret) return (Ret);
+
+   Ret = InitRcb(HalDev, Ch);
+   if (Ret) return (Ret);
+
+   /* setup interrupt mask/enable for the channel */
+   SAR_TX_MASK_SET(HalDev->dev_base) = (1<<Ch);
+
+   /* if using the low priority queue, set up mask for it */
+   if (HalDev->ChData[Ch].TxNumQueues == 2)            /* +GSG 030421 */
+     SAR_TX_MASK_SET(HalDev->dev_base) = (1<<Ch)<<16;  /* +GSG 030421 */
+
+   SAR_RX_MASK_SET(HalDev->dev_base) = (1<<Ch);
+
+   /* call SAR layer to complete the channel setup - hardware configuration of ch */
+   Ret = HalDev->SarFunc->ChannelSetup(HalDev->SarDev, &HalDev->ChData[Ch]); /* ~GSG 030410 */
+   if (Ret)                                                                  /* +GSG 030410 */
+     return (Ret);                                                           /* +GSG 030410 */
+
+   /* channel officially open for business */
+   HalDev->ChIsOpen[Ch][DIRECTION_TX] = TRUE;
+   HalDev->ChIsOpen[Ch][DIRECTION_RX] = TRUE;
+
+   return (EC_NO_ERRORS);
+  }
+
+/*
+ * Sets up HAL default channel configuration parameter values.
+ */
+static void ChannelConfigInit(HAL_DEVICE *HalDev, CHANNEL_INFO *HalChn)
+  {
+   int Ch = HalChn->Channel;
+   
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]ChannelConfigInit(HalDev:%08x, HalChn:%08x)\n", (bit32u)HalDev,
+                (bit32u)HalChn);
+      osfuncSioFlush();
+     }
+#endif
+
+   HalDev->ChData[Ch].Channel        = Ch;
+   HalDev->ChData[Ch].TxNumBuffers   = cfg_tx_num_bufs[Ch];
+   HalDev->ChData[Ch].RxNumBuffers   = cfg_rx_num_bufs[Ch];
+   HalDev->ChData[Ch].RxBufSize      = cfg_rx_buf_size[Ch];
+   HalDev->ChData[Ch].RxBufferOffset = cfg_rx_buf_offset[Ch];
+   HalDev->ChData[Ch].TxNumQueues    = cfg_tx_num_queues[Ch]; 
+   HalDev->ChData[Ch].CpcsUU         = cfg_cpcs_uu[Ch];
+   HalDev->ChData[Ch].DaMask         = cfg_da_mask[Ch];
+   HalDev->ChData[Ch].Priority       = cfg_priority[Ch];
+   HalDev->ChData[Ch].PktType        = cfg_pkt_type[Ch];
+   HalDev->ChData[Ch].Vci            = cfg_vci[Ch];
+   HalDev->ChData[Ch].Vpi            = cfg_vpi[Ch];
+   HalDev->ChData[Ch].TxVc_CellRate  = cfg_cell_rate[Ch];
+   HalDev->ChData[Ch].TxVc_QosType   = cfg_qos_type[Ch];
+   HalDev->ChData[Ch].TxVc_Mbs       = cfg_mbs[Ch];
+   HalDev->ChData[Ch].TxVc_Pcr       = cfg_pcr[Ch];
+   HalDev->ChData[Ch].Gfc            = cfg_gfc[Ch];
+   HalDev->ChData[Ch].Clp            = cfg_clp[Ch];
+   HalDev->ChData[Ch].Pti            = cfg_pti[Ch];
+   HalDev->ChData[Ch].RxServiceMax   = cfg_rx_max_service[Ch];
+   HalDev->ChData[Ch].TxServiceMax   = cfg_tx_max_service[Ch];
+  }
+
+/* 
+ * Update per channel data in the HalDev based channel structure.
+ * If a certain channel parameter has been passed with the HAL_DEFAULT
+ * value (0xFFFFFFFF), then do not copy it. 
+ */
+static void ChannelConfigUpdate(HAL_DEVICE *HalDev, CHANNEL_INFO *HalChn)
+  {
+   int Ch = HalChn->Channel;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]ChannelConfigUpdate(HalDev:%08x, HalChn:%08x)\n", (bit32u)HalDev,
+                (bit32u)HalChn);
+      osfuncSioFlush();
+     }
+#endif
+
+   HalDev->ChData[Ch].Channel = Ch;
+
+   /* ChannelUpdate is a macro defined in cpcommon.h.  It requires
+      the presence of the variables named 'Ch' and 'HalChn'.*/
+   ChannelUpdate(DaMask);
+   ChannelUpdate(Priority);
+   ChannelUpdate(PktType);
+   ChannelUpdate(Vci);
+   ChannelUpdate(Vpi);
+   ChannelUpdate(CpcsUU);
+   ChannelUpdate(Gfc);
+   ChannelUpdate(Clp);
+   ChannelUpdate(Pti);
+   /* AAL5 Stuff */
+   ChannelUpdate(TxNumBuffers);
+   ChannelUpdate(RxNumBuffers);
+   ChannelUpdate(RxBufSize);
+   ChannelUpdate(RxBufferOffset);
+   ChannelUpdate(TxNumQueues);
+   ChannelUpdate(TxServiceMax);
+   ChannelUpdate(RxServiceMax);
+   /* PDSP STATE RAM */
+   ChannelUpdate(TxVc_CellRate);
+   ChannelUpdate(TxVc_QosType);
+   ChannelUpdate(TxVc_Mbs);
+   ChannelUpdate(TxVc_Pcr);
+   /* OAM */
+   ChannelUpdate(TxVc_AtmHeader);
+   ChannelUpdate(TxVc_OamTc);
+   ChannelUpdate(TxVc_VpOffset);
+   ChannelUpdate(RxVc_OamCh);
+   ChannelUpdate(RxVc_OamToHost);
+   ChannelUpdate(RxVc_AtmHeader);
+   ChannelUpdate(RxVc_VpOffset);
+   ChannelUpdate(RxVc_OamTc);
+   ChannelUpdate(TxVp_AtmHeader);
+   ChannelUpdate(TxVp_OamTc);
+   ChannelUpdate(RxVp_AtmHeader);
+   ChannelUpdate(RxVp_OamCh);
+   ChannelUpdate(RxVp_OamTc);
+   ChannelUpdate(RxVp_OamToHost);
+   ChannelUpdate(RxVp_OamVcList);
+   ChannelUpdate(FwdUnkVc);
+  }
+
+/**
+ * @ingroup CPHAL_Functions
+ * This function opens the specified channel.  The caller must populate
+ * the @p HalCh structure.  CPHAL default values may be requested for any or all
+ * members of the @p HalCh structure by supplying a value of 0xFFFFFFFF for the
+ * given member.  The @p OsSetup parameter is a pointer to an OS defined
+ * data structure.  If the CPHAL later calls @c MallocRxBuffer(), this pointer
+ * is returned in that call.
+ *  
+ * @param   HalDev  CPHAL module instance. (set by xxxInitModule())   
+ * @param   HalCh   Per channel information structure.  Implementation specific.
+ * @param   OsSetup Pointer to an OS-defined data structure.
+ *
+ * @return  EC_NO_ERRORS (ok). <BR>
+ *          Possible Error Codes:<BR>
+ *          @ref EC_VAL_INVALID_STATE "EC_VAL_INVALID_STATE"<BR>
+ *          @ref EC_VAL_NULL_CH_STRUCT "EC_VAL_NULL_CH_STRUCT"<BR>
+ *          @ref EC_VAL_INVALID_CH "EC_VAL_INVALID_CH"<BR>
+ *          @ref EC_VAL_CH_ALREADY_OPEN "EC_VAL_CH_ALREADY_OPEN"<BR>
+ *          @ref EC_VAL_RX_STATE_RAM_NOT_CLEARED "EC_VAL_RX_STATE_RAM_NOT_CLEARED"<BR>
+ *          @ref EC_VAL_TX_STATE_RAM_NOT_CLEARED "EC_VAL_TX_STATE_RAM_NOT_CLEARED"<BR>
+ *          @ref EC_VAL_TCB_MALLOC_FAILED "EC_VAL_TCB_MALLOC_FAILED"<BR>
+ *          @ref EC_VAL_RCB_MALLOC_FAILED "EC_VAL_RCB_MALLOC_FAILED"<BR>
+ *          @ref EC_VAL_RX_BUFFER_MALLOC_FAILED "EC_VAL_RX_BUFFER_MALLOC_FAILED"<BR>
+ *          @ref EC_VAL_LUT_NOT_READY "EC_VAL_LUT_NOT_READY"<BR>
+ */
+static int halChannelSetup(HAL_DEVICE *HalDev, CHANNEL_INFO *HalCh, OS_SETUP *OsSetup)
+  {
+  int Ch, Ret;
+   
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]halChannelSetup(HalDev:%08x, HalCh:%08x, OsSetup:%08x)\n", (bit32u)HalDev,
+                (bit32u)HalCh, (bit32u)OsSetup);
+      osfuncSioFlush();
+     }
+#endif
+
+  /* Verify proper device state */
+  if (HalDev->State < enInitialized)
+    return (EC_AAL5|EC_FUNC_CHSETUP|EC_VAL_INVALID_STATE);
+
+  /* We require the channel structure to be passed, even if it only contains
+     the channel number */
+  if (HalCh == NULL)
+    {
+     return(EC_AAL5|EC_FUNC_CHSETUP|EC_VAL_NULL_CH_STRUCT);
+    }
+
+  Ch = HalCh->Channel;
+
+  if ((Ch < 0) || (Ch > MAX_AAL5_CHAN))
+    {
+     return(EC_AAL5|EC_FUNC_CHSETUP|EC_VAL_INVALID_CH);
+    }
+
+  /* if channel is already open, this call is invalid */
+  if ((HalDev->ChIsOpen[Ch][DIRECTION_TX] == TRUE) || (HalDev->ChIsOpen[Ch][DIRECTION_RX] == TRUE))
+    {
+     return(EC_AAL5|EC_FUNC_CHSETUP|EC_VAL_CH_ALREADY_OPEN);
+    }
+
+  /* channel is closed, but might be setup.  If so, reopen the hardware channel. */
+  if ((HalDev->ChIsSetup[Ch][DIRECTION_TX] == FALSE) && (HalDev->ChIsSetup[Ch][DIRECTION_RX] == FALSE))
+    {
+      /* Setup channel configuration */
+      /* Store OS_SETUP */
+      HalDev->ChData[Ch].OsSetup = OsSetup;                                         /* ~GSG 030508 */
+
+      /* setup HAL default values for this channel first */
+      ChannelConfigInit(HalDev, HalCh);
+ 
+      /* retrieve options.conf channel parameters */
+      /* currently ignoring return value, making the choice that it's okay if
+         the user does not supply channel configuration in the data store */
+      ChannelConfigGet(HalDev, HalCh);
+      
+      /* update HalDev with data given in HalCh */  
+      ChannelConfigUpdate(HalDev, HalCh);
+      
+#ifdef __CPHAL_DEBUG
+      if (DBG(8))
+        {
+         dbgChannelConfigDump(HalDev, Ch);
+        }
+#endif
+
+      /* HalDev->ChIsSetup[Ch][0] = TRUE; */
+      HalDev->ChIsSetup[Ch][DIRECTION_TX] = TRUE;
+      HalDev->ChIsSetup[Ch][DIRECTION_RX] = TRUE;
+
+      /* I don't initialize RcbStart or TcbStart here because their values may be
+         reused across several Setup/Teardown calls */
+    }
+
+  /* If the hardware has been opened (is out of reset), then configure the channel
+     in the hardware. NOTE: ChannelConfigApply calls the CPSAR ChannelSetup()! */
+  if (HalDev->State == enOpened)
+    {
+     Ret = ChannelConfigApply(HalDev, HalCh);
+     if (Ret) return (Ret);
+    }
+
+  return (EC_NO_ERRORS);
+  }
+   
+/*
+ *  This function configures the rate at which the OAM timer scheduler
+ *  channels will be scheduled.  The value of OamRate is the number of
+ *  clock ticks between cell transmissions (if OAM function is sourcing
+ *  cells), or the number of clock ticks between events or absence of events
+ *  (if OAM function is sinking cells).  The value of i indicates
+ *  which OAM function to apply the rate to.  A list is given below.
+ *
+ *  @par Oam Function Values
+ *  - 0  : Loopback source
+ *  - 1  : F4 CC source
+ *  - 2  : F5 CC source
+ *  - 3  : F4 CC sink
+ *  - 4  : F5 CC sink
+ *  - 5  : F4 TX AIS source
+ *  - 6  : F5 TX AIS source
+ *  - 7  : F4 RX RDI source
+ *  - 8  : F5 RX RDI source
+ *  - 9  : F4 AIS monitor
+ *  - 10 : F5 AIS monitor
+ *
+ *  The following is information on how to calculate the OAM rate.  There
+ *  is only one OAM timer that is shared among all channels.  Therefore, if
+ *  you wanted an OAM source function (ex. F4 CC source) to generate 1 cell/sec 
+ *  across 8 channels, you would need to configure the OAM timer to schedule 8 
+ *  cells/sec.  In addition, the credits are shared between segment and end-to-end
+ *  type OAM cells, so if you were sending both types of cells, you would
+ *  need to configure the OAM timer for 16 cells/sec.  However, the clock
+ *  rate must be specified in clock ticks between events.  Using an example
+ *  clock rate of 125 MHz, the rate in clock ticks can be calculated by 
+ *  dividing 125 Mhz by 16 cells/sec.  The results is 7812500 ticks.  Thus,
+ *  every 7812500 clock cycles, an OAM cell will be generated for the F4 CC
+ *  Source function.
+ */
+static void OamRateConfig(HAL_DEVICE *HalDev)
+  {
+   int i;
+   bit32u OamRate, Freq = HalDev->SarFrequency;
+
+   /* Configure OAM Timer State Block */
+   for (i=0; i<NUM_OAM_RATES; i++)
+     {
+      switch(i)
+        {
+         case 0:  OamRate = ((Freq/1000)*HalDev->OamLbTimeout); 
+                  break;
+         case 1: 
+         case 2:
+         case 5:
+         case 6: 
+         case 7:
+         case 8:  OamRate = (Freq/38);
+                  break;
+         case 3:
+         case 4:  OamRate = ((Freq*3) + (Freq/2))/38;
+                  break;
+         case 9:
+         case 10: OamRate = ((Freq*2) + (Freq/2))/38;
+                  break;
+         default: OamRate = (Freq*5);
+                  break;
+        }
+  
+      *(pOAM_TIMER_STATE_WORD_0(HalDev->dev_base) + (i*64) + 1) = OamRate;
+     }
+  }
+
+/**
+ *  @ingroup AAL5_Functions
+ *  This function is used to enable OAM functions (other than loopback) for a 
+ *  particular channel.  The channel (embedded within OamConfig - see below) must 
+ *  have been configured for firmware OAM (not host OAM) for these configurations
+ *  to take effect.  More than one function may be enabled at one time. 
+ *  If more than one function is enabled, they must all be of the same level, all
+ *  F4(VP) or all F5(VC).   
+ * 
+ *  The usage of the OamConfig parameter is described through the table below.  To
+ *  initiate firmware OAM, set one or more bits in OamConfig corresponding to the
+ *  various OAM functions.  To disable firmware OAM functions, set bit 30 along 
+ *  with any other combination of bits to shutdown various OAM functions at once.
+ *
+ *  Acronyms:
+ *  e2e - end to end, seg - segment, CC - continuity check, 
+ *  AIS - Alarm Indication Signal
+ *
+ *  @par Bit:   Function:               Description
+ *  - 31:       Reserved:
+ *  - 30:       Setup/Teardown:         0 - enable, 1 - disable (Note 1)
+ *  - 29:       F4  CC  Source seg:     0 - no action, 1 - configure 
+ *  - 28:       F4  CC  Source e2e:     0 - no action, 1 - configure
+ *  - 27:       F4  AIS Source seg:     0 - no action, 1 - configure
+ *  - 26:       F4  AIS Source e2e:     0 - no action, 1 - configure
+ *  - 25:       F5  CC  Source seg:     0 - no action, 1 - configure
+ *  - 24:       F5  CC  Source e2e:     0 - no action, 1 - configure
+ *  - 23:       F5  AIS Source seg:     0 - no action, 1 - configure
+ *  - 22:       F5  AIS Source e2e:     0 - no action, 1 - configure
+ *  - 21:       F4  CC  Sink seg:       0 - no action, 1 - configure
+ *  - 20:       F4  CC  Sink e2e:       0 - no action, 1 - configure
+ *  - 19:       F5  CC  Sink seg:       0 - no action, 1 - configure
+ *  - 18:       F5  CC  Sink e2e:       0 - no action, 1 - configure
+ *  - 17:8:     Reserved:
+ *  - 7:0:      Channel:                AAL5/AAL2 VC/VP channel (Note 2)
+ * 
+ *
+ *  Note 1:  This bit must be clear to enable the specified OAM function.
+ *  Note 2:  This must specify the VC channel for F5 functions, and the VP
+ *           channel for F4 functions.
+ *
+ *  @param HalDev      CPHAL module instance. (set by xxxInitModule())
+ *  @param OamConfig   A 32-bit integer field defined as follows: 
+ */
+static void halOamFuncConfig(HAL_DEVICE *HalDev, unsigned int OamConfig)
+  {
+   /* GPR 0 */
+   SAR_PDSP_HOST_OAM_CONFIG_REG(HalDev->dev_base) = OamConfig;
+  }
+
+/**
+ *  @ingroup AAL5_Functions
+ *  This function is used to enable OAM loopback functions for a particular 
+ *  channel.  The channel (embedded within OamConfig - see below) must have been 
+ *  configured for firmware OAM (not host OAM) for these configurations to take 
+ *  effect.  Only one loopback function can be enabled at a time.  
+ *
+ *  The LLID is inserted into to the OAM cell's LLID field, and it specifies the 
+ *  LLID of the connection point in the network where the generated loopback cell
+ *  should be turned around.  The LLID is composed of 4 32-bit words, and this 
+ *  function expects the caller to pass an array of 4 words in the LLID field.  
+ *  The CorrelationTag is a 32-bit word that the PDSP uses to correlate loopback 
+ *  commands with loopback responses.  It should simply be changed for each 
+ *  call, and there is no restriction on the value used for CorrelationTag.
+ * 
+ *  The usage of the OamConfig parameter is described through the table below.  To
+ *  initiate firmware OAM, set one of the bits corresponding to the
+ *  various loopback OAM functions.  Note that only one loopback source may be 
+ *  commanded at a time.
+ *
+ *  Acronyms:
+ *  e2e - end to end, seg - segment, LB - loopback
+ * 
+ *  @par Bit:   Function:               Description
+ *  - 31:16:    Reserved:
+ *  - 15:       F4  LB Source seg:      0 - no action, 1 - configure (Note 1)
+ *  - 14:       F4  LB Source seg:      0 - no action, 1 - configure (Note 1)
+ *  - 13:       F4  LB Source e2e:      0 - no action, 1 - configure (Note 1)
+ *  - 12:       F4  LB Source e2e:      0 - no action, 1 - configure (Note 1) 
+ *  - 11:8:     Reserved:
+ *  - 7:0:      Channel:                AAL5/AAL2 VC/VP channel (Note 2)
+ * 
+ *
+ *  Note 1:  Only one LB function may be enabled at one time.  Once enabled, 
+ *           the PDSP will time out after 5 seconds.  The host must wait until it 
+ *           has received the result of the current LB request before initiating 
+ *           a new request. <BR>
+ *  Note 2:  This must specify the VC channel for F5 functions, and the VP
+ *           channel for F4 functions.
+ *
+ *  @param HalDev      CPHAL module instance. (set by xxxInitModule())
+ *  @param OamConfig   A 32-bit integer field defined as follows: 
+ *  @param LLID        Loopback Location Identifier (passed as 4 word array).
+ *                     Must be configured in big endian format.
+ *  @param CorrelationTag 32-bit tag correlates loopback commands with loopback 
+ *                        responses.  Must be configured in big endian format.
+ *
+ */
+static void halOamLoopbackConfig(HAL_DEVICE *HalDev, unsigned int OamConfig, unsigned int *LLID, unsigned int CorrelationTag)
+  {
+   volatile bit32u *tmp;
+
+   /* test to see if this is a loopback command */
+   if (OamConfig & 0xf000)
+     {
+      /* write the OAM correlation tag (GPR 1) */
+      SAR_PDSP_OAM_CORR_REG(HalDev->dev_base) = CorrelationTag;
+
+      /* write the LLID */
+      tmp = pOAM_CONFIG_BLOCK_WORD_0(HalDev->dev_base);
+
+      /* advance past the CPID */
+      tmp += 4;
+
+      *tmp++ = LLID[0];
+      *tmp++ = LLID[1];
+      *tmp++ = LLID[2];
+      *tmp   = LLID[3];
+
+      /* GPR 0 */
+      SAR_PDSP_HOST_OAM_CONFIG_REG(HalDev->dev_base) = OamConfig;
+     }
+  }
+
+/*
+ *  This function allows the host software to access any register directly.
+ *  Primarily used for debug.
+ *  
+ *  @param   HalDev      CPHAL module instance. (set by xxxInitModule())  
+ *  @param   RegOffset   Hexadecimal offset to desired register (from device base addr)
+ *
+ *  @return  Volatile pointer to desired register.
+ */
+static volatile bit32u* halRegAccess(HAL_DEVICE *HalDev, bit32u RegOffset)
+  {
+   /* compute the register address */
+   return ((volatile bit32u *)(HalDev->dev_base + RegOffset)); 
+  }
+
+#ifdef __CPHAL_DEBUG
+static void dbgConfigDump(HAL_DEVICE *HalDev)
+  {
+   dbgPrintf("  AAL5 Inst %d Config Dump:\n", HalDev->Inst);
+   dbgPrintf("    Base     :%08x, offset:%08d\n", 
+             HalDev->dev_base, HalDev->offset);
+   dbgPrintf("    Interrupt:%08d, debug :%08d\n", 
+             HalDev->interrupt, HalDev->debug);
+   osfuncSioFlush();
+  }
+#endif
+
+/**
+ *  @ingroup CPHAL_Functions
+ *  Performs a variety of control functions on the CPHAL module.  It is used to
+ *  modify/read configuration parameters and to initiate internal functions.
+ *  The @p Key indicates the function to perform or the parameter to access (note 
+ *  that these Keys are identical to those used in accessing the configuration data
+ *  store).  @p Action is applicable to parameters only, and indicates what the
+ *  CPHAL should do with the parameter (i.e. "Set", "Get", etc..).  The actions
+ *  for each parameter are defined in the module specific documentation.
+ *  
+ *  @param   HalDev      CPHAL module instance. (set by xxxInitModule())
+ *  @param   Key         Key specifying the parameter to change or internal function to initiate.  See module specific documentation for available keys.
+ *  @param   Action      Specifies the action to take.  See module specific documentation for available actions.
+ *  @param   Value       Pointer to new value for given @p Key parameter ("Set"), or returned value of Key ("Get").
+ *  
+ *  @return  EC_NO_ERRORS (ok).<BR>
+ *           Possible Error Codes:<BR>
+ *           @ref EC_VAL_INVALID_STATE "EC_VAL_INVALID_STATE"<BR>
+ *           @ref EC_VAL_KEY_NOT_FOUND "EC_VAL_KEY_NOT_FOUND"<BR>
+ *           @ref EC_VAL_ACTION_NOT_FOUND "EC_VAL_ACTION_NOT_FOUND"<BR>     
+ */
+static int halControl(HAL_DEVICE *HalDev, const char *Key, const char *Action, void *Value)
+  {
+   int Level, Ch, KeyFound=0, ActionFound=0, rc=EC_NO_ERRORS, Queue;
+   char *TmpKey = (char *)Key;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]halControl(HalDev:%08x, Key:%s, Action:%s, Value:%08x)\n", (bit32u)HalDev,
+                Key, Action, (bit32u)Value);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Verify proper device state */
+   if (HalDev->State < enInitialized)
+     return (EC_AAL5|EC_FUNC_CONTROL|EC_VAL_INVALID_STATE);   
+
+   if (HalDev->OsFunc->Strcmpi(Key, "Debug") == 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         HalDev->debug = *(int *)Value;
+         /* also setup debug variable in CPSAR module */
+         rc = HalDev->SarFunc->Control(HalDev->SarDev, "Debug", "Set", Value);
+        }
+     }
+
+   if (HalDev->OsFunc->Strstr(Key, "FwdUnkVc.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+  
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("FwdUnkVc.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         HalDev->ChData[Ch].FwdUnkVc = *(int *)Value;
+
+         if ((HalDev->State == enOpened) && (HalDev->ChData[Ch].PktType == 3))
+           rc = HalDev->SarFunc->Control(HalDev->SarDev, Key, Action, Value);         
+        }
+     }
+
+   /* +GSG 030407 */
+   if (HalDev->OsFunc->Strcmpi(Key, "OamMode") == 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         rc = HalDev->SarFunc->Control(HalDev->SarDev, Key, Action, Value);         
+        }
+
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+         rc = HalDev->SarFunc->Control(HalDev->SarDev, Key, Action, Value);
+        }
+     }
+
+   /* +GSG 030307 */
+   if (HalDev->OsFunc->Strcmpi(Key, "Version") == 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+         *(const char **)Value = pszVersion_CPAAL5;
+        }
+     }
+
+   /* +GSG 030529 */
+   if (HalDev->OsFunc->Strcmpi(Key, "TurboDslErrors") == 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+         *(int *)Value = HalDev->TurboDslErrors;
+        }
+     }
+   
+   /* +GSG 030416 */
+   if (HalDev->OsFunc->Strcmpi(Key, "F4_LB_Counter") == 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+         *(int *)Value = SAR_PDSP_OAM_F4_LB_COUNT_REG(HalDev->dev_base);
+        }
+     }
+
+   /* +GSG 030416 */
+   if (HalDev->OsFunc->Strcmpi(Key, "F5_LB_Counter") == 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+         *(int *)Value = SAR_PDSP_OAM_F5_LB_COUNT_REG(HalDev->dev_base);
+        }
+     }
+   
+   if (HalDev->OsFunc->Strstr(Key, "Stats;") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+         TmpKey += HalDev->OsFunc->Strlen("Stats;");
+         Level = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+         TmpKey++;
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+         TmpKey++;
+         Queue = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+         TmpKey++;
+         StatsGet(HalDev, (void **)Value, Level, Ch, Queue);
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #100 */
+   if (HalDev->OsFunc->Strstr(Key, "Gfc.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("Gfc.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* first, store new value in our channel structure */
+         HalDev->ChData[Ch].Gfc = *(int *)Value;
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #100 */
+   if (HalDev->OsFunc->Strstr(Key, "Clp.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("Clp.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* first, store new value in our channel structure */
+         HalDev->ChData[Ch].Clp = *(int *)Value;
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #100 */
+   if (HalDev->OsFunc->Strstr(Key, "Pti.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("Pti.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* first, store new value in our channel structure */
+         HalDev->ChData[Ch].Pti = *(int *)Value;
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #100 */
+   if (HalDev->OsFunc->Strstr(Key, "CpcsUU.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("CpcsUU.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* first, store new value in our channel structure */
+         HalDev->ChData[Ch].CpcsUU = *(int *)Value;
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #100 */
+   if (HalDev->OsFunc->Strstr(Key, "TxVc_CellRate.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("TxVc_CellRate.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* first, store new value in our channel structure */
+         HalDev->ChData[Ch].TxVc_CellRate = *(int *)Value;
+
+         /* now, apply to PDSP state RAM */
+         if (HalDev->State == enOpened)
+           *(pPDSP_AAL5_TX_STATE_WORD_0(HalDev->dev_base)+(Ch*64))= HalDev->ChData[Ch].TxVc_CellRate;
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #100 */
+   if (HalDev->OsFunc->Strstr(Key, "TxVc_Mbs.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("TxVc_Mbs.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* first, store new value in our channel structure */
+         HalDev->ChData[Ch].TxVc_Mbs = *(int *)Value;
+
+         /* now, apply to PDSP state RAM */
+         if (HalDev->State == enOpened)
+           *(pPDSP_AAL5_TX_STATE_WORD_0(HalDev->dev_base)+(Ch*64)+2)= HalDev->ChData[Ch].TxVc_Mbs;
+        }
+     }
+
+   if (HalDev->OsFunc->Strstr(Key, "TxVc_AtmHeader.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("TxVc_AtmHeader.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* first, store new value in our channel structure */
+         HalDev->ChData[Ch].TxVc_AtmHeader = *(int *)Value;
+
+         /* now, apply to PDSP state RAM */
+         if (HalDev->State == enOpened)
+           *(pPDSP_AAL5_TX_STATE_WORD_0(HalDev->dev_base)+(Ch*64)+6)= HalDev->ChData[Ch].TxVc_AtmHeader;
+        }
+     }
+
+   if (HalDev->OsFunc->Strstr(Key, "TxVp_AtmHeader.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("TxVp_AtmHeader.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* first, store new value in our channel structure */
+         HalDev->ChData[Ch].TxVp_AtmHeader = *(int *)Value;
+
+         /* now, apply to PDSP state RAM */
+         if (HalDev->State == enOpened)
+           *(pPDSP_AAL5_TX_VP_STATE_WORD_0(HalDev->dev_base)+(Ch*64))= HalDev->ChData[Ch].TxVp_AtmHeader;
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #100 */
+   if (HalDev->OsFunc->Strstr(Key, "TxVc_Pcr.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("TxVc_Pcr.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* first, store new value in our channel structure */
+         HalDev->ChData[Ch].TxVc_Pcr = *(int *)Value;
+
+         /* now, apply to PDSP state RAM */
+         if (HalDev->State == enOpened)
+           *(pPDSP_AAL5_TX_STATE_WORD_0(HalDev->dev_base)+(Ch*64)+4)= HalDev->ChData[Ch].TxVc_Pcr;
+        }
+     }
+
+   /* +GSG 030428 */
+   if (HalDev->OsFunc->Strstr(Key, "RxVc_OamCh.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("RxVc_OamCh.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* first, store new value in our channel structure */
+         HalDev->ChData[Ch].RxVc_OamCh = (*(int *)Value) & 0xff;
+
+         /* now, apply to PDSP state RAM */
+         if (HalDev->State == enOpened)
+           *(pPDSP_AAL5_RX_STATE_WORD_0(HalDev->dev_base)+(Ch*64)) |= HalDev->ChData[Ch].RxVc_OamCh;
+        }
+     }
+
+   /* +GSG 030428 */
+   if (HalDev->OsFunc->Strstr(Key, "RxVp_OamCh.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("RxVp_OamCh.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* first, store new value in our channel structure */
+         HalDev->ChData[Ch].RxVp_OamCh = (*(int *)Value) & 0xff;
+
+         /* now, apply to PDSP state RAM */
+         if (HalDev->State == enOpened)
+           *(pPDSP_AAL5_RX_VP_STATE_WORD_0(HalDev->dev_base)+(Ch*64)+1) |= HalDev->ChData[Ch].RxVp_OamCh;
+        }
+     }
+
+   /* +GSG 030304 */
+   /* Fixes PITS #98 */
+   if (HalDev->OsFunc->Strstr(Key, "PdspEnable") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         
+         /* this variable is controlled by the CPSAR module */
+         if (HalDev->State == enOpened)
+           {
+            rc=HalDev->SarFunc->Control(HalDev->SarDev, "PdspEnable", "Set", Value);
+           }
+        }
+     }
+
+   if (HalDev->OsFunc->Strstr(Key, "OamLbTimeout") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         
+         HalDev->OamLbTimeout = *(int *)Value;
+         /* this variable is controlled by the CPSAR module */
+         if (HalDev->State == enOpened)
+           {
+            *(pOAM_TIMER_STATE_WORD_0(HalDev->dev_base) + 1) = 
+              ((HalDev->SarFrequency/1000) * HalDev->OamLbTimeout);
+           }
+        }
+     }
+
+   /* +GSG 030306 (PITS #114) */
+   if (HalDev->OsFunc->Strstr(Key, "DeviceCPID") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         unsigned int* local = (unsigned int *)Value;
+         ActionFound=1;
+         /* first, store new value in our hal structure */
+         HalDev->DeviceCPID[0] = local[0];
+         HalDev->DeviceCPID[1] = local[1];
+         HalDev->DeviceCPID[2] = local[2];
+         HalDev->DeviceCPID[3] = local[3];
+
+         /* now, apply to PDSP state RAM */
+         if (HalDev->State == enOpened)
+           {
+            *(bit32u *)(pOAM_CONFIG_BLOCK_WORD_0(HalDev->dev_base) + 0) = HalDev->DeviceCPID[0];
+            *(bit32u *)(pOAM_CONFIG_BLOCK_WORD_0(HalDev->dev_base) + 1) = HalDev->DeviceCPID[1];
+            *(bit32u *)(pOAM_CONFIG_BLOCK_WORD_0(HalDev->dev_base) + 2) = HalDev->DeviceCPID[2];
+            *(bit32u *)(pOAM_CONFIG_BLOCK_WORD_0(HalDev->dev_base) + 3) = HalDev->DeviceCPID[3];
+           }
+        }
+     }
+
+   /* +GSG 030304 */
+   /* Fixes PITS #99 */
+   if (HalDev->OsFunc->Strstr(Key, "StrictPriority") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+        
+         /* used in halOpen to decide which interrupt handler to use */
+         HalDev->StrictPriority = *(int *)Value;
+        }
+     }
+
+   if (HalDev->OsFunc->Strstr(Key, hcMaxFrags) != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+        
+         if ((*(int *)Value) > 0)
+           HalDev->MaxFrags = *(int *)Value;
+          else
+           rc = (EC_AAL5|EC_FUNC_CONTROL|EC_VAL_INVALID_VALUE);
+        }
+
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+
+         *(int *)Value = HalDev->MaxFrags;
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #103 */
+   if (HalDev->OsFunc->Strstr(Key, "RxVc_RDICount.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+        
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("RxVc_RDICount.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* PDSP's Rx VC State word 3 contains the value */
+         if (HalDev->State == enOpened)
+           {
+            *(int *)Value = (((*(pPDSP_AAL5_RX_STATE_WORD_0(HalDev->dev_base)+(Ch*64))) & RDI_CNT_MASK)>>RDI_CNT_SHIFT);
+           }
+        }
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+        
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("RxVc_RDICount.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* All sets write 0, this action is a clear only */
+         if (HalDev->State == enOpened)
+           {
+            (*(pPDSP_AAL5_RX_STATE_WORD_0(HalDev->dev_base)+(Ch*64))) &=~ RDI_CNT_MASK;
+           }
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #103 */
+   if (HalDev->OsFunc->Strstr(Key, "RxVc_AISseg.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+        
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("RxVc_AISseg.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* PDSP's Rx VC State word 3 contains the value */
+         if (HalDev->State == enOpened)
+           {
+            *(int *)Value = (((*(pPDSP_AAL5_RX_STATE_WORD_0(HalDev->dev_base)+(Ch*64)+3)) & AIS_SEG_MASK)>>AIS_SEG_SHIFT);
+           }
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #103 */
+   if (HalDev->OsFunc->Strstr(Key, "RxVc_AISetoe.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+        
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("RxVc_AISetoe.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* PDSP's Rx VC State word 3 contains the value */
+         if (HalDev->State == enOpened)
+           {
+            *(int *)Value = (((*(pPDSP_AAL5_RX_STATE_WORD_0(HalDev->dev_base)+(Ch*64)+3)) & AIS_ETOE_MASK)>>AIS_ETOE_SHIFT);
+           }
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #103 */
+   if (HalDev->OsFunc->Strstr(Key, "RxVp_RDICount.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+        
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("RxVp_RDICount.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* PDSP's Rx VC State word 3 contains the value */
+         if (HalDev->State == enOpened)
+           {
+            *(int *)Value = (((*(pPDSP_AAL5_RX_VP_STATE_WORD_0(HalDev->dev_base)+(Ch*64)+1)) & RDI_CNT_MASK)>>RDI_CNT_SHIFT);
+           }
+        }
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+        
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("RxVp_RDICount.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* All sets write 0, this action is a clear only */
+         if (HalDev->State == enOpened)
+           {
+            (*(pPDSP_AAL5_RX_VP_STATE_WORD_0(HalDev->dev_base)+(Ch*64)+1)) &=~ RDI_CNT_MASK;
+           }
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #103 */
+   if (HalDev->OsFunc->Strstr(Key, "RxVp_AISseg.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+        
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("RxVp_AISseg.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* PDSP's Rx VC State word 3 contains the value */
+         if (HalDev->State == enOpened)
+           {
+            *(int *)Value = (((*(pPDSP_AAL5_RX_VP_STATE_WORD_0(HalDev->dev_base)+(Ch*64)+2)) & AIS_SEG_MASK)>>AIS_SEG_SHIFT);
+           }
+        }
+     }
+
+   /* +GSG 030306 */
+   /* Fixes PITS #103 */
+   if (HalDev->OsFunc->Strstr(Key, "RxVp_AISetoe.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+        
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("RxVp_AISetoe.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* PDSP's Rx VC State word 3 contains the value */
+         if (HalDev->State == enOpened)
+           {
+            *(int *)Value = (((*(pPDSP_AAL5_RX_VP_STATE_WORD_0(HalDev->dev_base)+(Ch*64)+2)) & AIS_ETOE_MASK)>>AIS_ETOE_SHIFT);
+           }
+        }
+     }
+
+   if (KeyFound == 0)
+     rc = (EC_AAL5|EC_FUNC_CONTROL|EC_VAL_KEY_NOT_FOUND);
+
+   if (ActionFound == 0)
+     rc = (EC_AAL5|EC_FUNC_CONTROL|EC_VAL_ACTION_NOT_FOUND);
+
+   return(rc);    
+  }
+
+/*
+ * Sets up HAL default configuration parameter values.
+ */
+static void ConfigInit(HAL_DEVICE *HalDev)
+  {
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]ConfigInit(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* configure some defaults with tnetx7300 values */
+   HalDev->dev_base = 0xa3000000;
+   HalDev->offset = 0;
+   HalDev->interrupt = 15;
+   HalDev->debug = 0;
+   HalDev->MaxFrags = 46;
+   HalDev->OamLbTimeout = 5000;
+  }
+
+/*
+ * Retrieve HAL configuration parameter values.
+ */
+static bit32u ConfigGet(HAL_DEVICE *HalDev)
+  {
+   bit32u Ret;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]ConfigGet(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* get the configuration parameters common to all modules */
+   Ret = ConfigGetCommon(HalDev);
+   if (Ret) return (EC_AAL5|Ret);
+
+   /* get AAL5 specific configuration parameters here */
+   Ret = HalDev->OsFunc->Control(HalDev->OsDev, hcSarFrequency, pszGET, &HalDev->SarFrequency); /* GSG +030416*/
+   if (Ret)                                                                                /* GSG +030416*/
+     HalDev->SarFrequency = 200000000;  /* 200 Mhz default */                              /* GSG +030416*/
+
+   return (EC_NO_ERRORS);
+  }
+
+/** 
+ *  @ingroup CPHAL_Functions
+ *  This function initializes the CPHAL module. It gathers all
+ *  necessary global configuration info from the configuration file, and
+ *  performs initialization and configuration of the device.  Note that
+ *  the device operation is not started until the OS calls @c Open().
+ *
+ *  @param   HalDev   CPHAL module instance. (set by xxxInitModule())
+ *
+ *  @return  EC_NO_ERRORS (ok). <BR>
+ *           Possible Error Codes:<BR>
+ *           @ref EC_VAL_INVALID_STATE "EC_VAL_INVALID_STATE"<BR>
+ *           @ref EC_VAL_BASE_ADDR_NOT_FOUND "EC_VAL_BASE_ADDR_NOT_FOUND"<BR>
+ *           @ref EC_VAL_RESET_BIT_NOT_FOUND "EC_VAL_RESET_BIT_NOT_FOUND"<BR>
+ *           @ref EC_VAL_INTERRUPT_NOT_FOUND "EC_VAL_INTERRUPT_NOT_FOUND"<BR>
+ *           @ref EC_VAL_OFFSET_NOT_FOUND "EC_VAL_OFFSET_NOT_FOUND"<BR>
+ */
+static int halInit(HAL_DEVICE *HalDev)
+  {
+  int i;
+  bit32u error_code;
+
+#ifdef __CPHAL_DEBUG
+  if (DBG(0))
+    {
+     dbgPrintf("[aal5]halInit(HalDev:%08x)\n", (bit32u)HalDev);
+     osfuncSioFlush();
+    }
+#endif
+
+  /* Verify proper device state */
+  if (HalDev->State != enDevFound)
+    return(EC_AAL5|EC_FUNC_HAL_INIT|EC_VAL_INVALID_STATE);
+
+  /* Configure HAL defaults */
+  ConfigInit(HalDev);
+
+  /* Retrieve HAL configuration parameters from data store */
+  error_code = ConfigGet(HalDev);
+  if (error_code) return (error_code);
+ 
+  /* Other items (OAM related) that need to be passed in somehow */
+  HalDev->DeviceCPID[0] = 0xffffffff;
+  HalDev->DeviceCPID[1] = 0xffffffff;
+  HalDev->DeviceCPID[2] = 0xffffffff;
+  HalDev->DeviceCPID[3] = 0xffffffff;
+  HalDev->LBSourceLLID[0] = 0xffffffff;
+  HalDev->LBSourceLLID[1] = 0xffffffff;
+  HalDev->LBSourceLLID[2] = 0xffffffff;
+  HalDev->LBSourceLLID[3] = 0xffffffff;
+
+  /* Initialize SAR layer*/
+  error_code = HalDev->SarFunc->Init(HalDev->SarDev);
+  if (error_code) return (error_code);
+
+  /* Initialize various HalDev members.  This is probably overkill, since these
+     are initialized in ChannelSetup() and HalDev is cleared in InitModule(). */
+  for (i=0; i<NUM_AAL5_CHAN; i++)
+    { 
+     HalDev->InRxInt[i]=FALSE;
+     HalDev->ChIsOpen[i][DIRECTION_TX] = FALSE;
+     HalDev->ChIsOpen[i][DIRECTION_RX] = FALSE;
+     HalDev->TcbStart[i][0] = 0;
+     HalDev->TcbStart[i][1] = 0;
+     HalDev->RcbStart[i]  = 0;
+    }
+
+  /* initialize SAR stats */
+  StatsClear(HalDev);
+
+  /* init Stat pointers */
+ 
+  /* even though these statistics may be for multiple channels/queues, i need 
+     only configure the pointer to the beginning of the array, and I can index 
+     from there if necessary */
+  StatsTable0[0].StatPtr  = &HalDev->Stats.CrcErrors[0];
+  StatsTable0[1].StatPtr  = &HalDev->Stats.LenErrors[0];
+  StatsTable0[2].StatPtr  = &HalDev->Stats.AbortErrors[0];
+  StatsTable0[3].StatPtr  = &HalDev->Stats.StarvErrors[0];
+
+  StatsTable1[0].StatPtr  = &HalDev->Stats.DmaLenErrors[0];
+  StatsTable1[1].StatPtr  = &HalDev->Stats.TxMisQCnt[0][0];
+  StatsTable1[2].StatPtr  = &HalDev->Stats.RxMisQCnt[0];
+  StatsTable1[3].StatPtr  = &HalDev->Stats.TxEOQCnt[0][0];
+  StatsTable1[4].StatPtr  = &HalDev->Stats.RxEOQCnt[0];
+  StatsTable1[5].StatPtr  = &HalDev->Stats.RxPacketsServiced[0];
+  StatsTable1[6].StatPtr  = &HalDev->Stats.TxPacketsServiced[0][0];
+  StatsTable1[7].StatPtr  = &HalDev->Stats.RxMaxServiced;
+  StatsTable1[8].StatPtr  = &HalDev->Stats.TxMaxServiced[0][0];
+  StatsTable1[9].StatPtr  = &HalDev->Stats.RxTotal;
+  StatsTable1[10].StatPtr = &HalDev->Stats.TxTotal;
+
+  StatsTable2[0].StatPtr  = (bit32u *)&HalDev->RcbPool[0];
+  StatsTable2[1].StatPtr  = &HalDev->RxActQueueCount[0];
+  StatsTable2[2].StatPtr  = (bit32u *)&HalDev->RxActQueueHead[0];
+  StatsTable2[3].StatPtr  = (bit32u *)&HalDev->RxActQueueTail[0];
+  StatsTable2[4].StatPtr  = &HalDev->RxActive[0];
+  StatsTable2[5].StatPtr  = (bit32u *)&HalDev->RcbStart[0];
+  StatsTable2[6].StatPtr  = &HalDev->RxTeardownPending[0];
+  StatsTable2[7].StatPtr  = (bit32u *)&HalDev->TcbPool[0][0];
+  StatsTable2[8].StatPtr  = &HalDev->TxActQueueCount[0][0];
+  StatsTable2[9].StatPtr  = (bit32u *)&HalDev->TxActQueueHead[0][0];
+  StatsTable2[10].StatPtr = (bit32u *)&HalDev->TxActQueueTail[0][0];
+  StatsTable2[11].StatPtr = &HalDev->TxActive[0][0];
+  StatsTable2[12].StatPtr = (bit32u *)&HalDev->TcbStart[0][0];
+  StatsTable2[13].StatPtr = &HalDev->TxTeardownPending[0];
+
+  StatsTable4[0].StatPtr  = &HalDev->dev_base;
+  StatsTable4[1].StatPtr  = &HalDev->offset;
+  StatsTable4[2].StatPtr  = &HalDev->interrupt;
+  StatsTable4[3].StatPtr  = &HalDev->debug;
+  StatsTable4[4].StatPtr  = &HalDev->Inst;
+ 
+  StatsTable3[0].StatPtr  = &HalDev->ChData[0].RxBufSize;
+  StatsTable3[1].StatPtr  = &HalDev->ChData[0].RxBufferOffset;
+  StatsTable3[2].StatPtr  = &HalDev->ChData[0].RxNumBuffers;
+  StatsTable3[3].StatPtr  = &HalDev->ChData[0].RxServiceMax;
+  StatsTable3[4].StatPtr  = &HalDev->ChData[0].TxNumBuffers;
+  StatsTable3[5].StatPtr  = &HalDev->ChData[0].TxNumQueues;
+  StatsTable3[6].StatPtr  = &HalDev->ChData[0].TxServiceMax;
+  StatsTable3[7].StatPtr  = &HalDev->ChData[0].CpcsUU;
+  StatsTable3[8].StatPtr  = &HalDev->ChData[0].Gfc;
+  StatsTable3[9].StatPtr  = &HalDev->ChData[0].Clp;
+  StatsTable3[10].StatPtr = &HalDev->ChData[0].Pti;
+  StatsTable3[11].StatPtr = &HalDev->ChData[0].DaMask;
+  StatsTable3[12].StatPtr = &HalDev->ChData[0].Priority;
+  StatsTable3[13].StatPtr = &HalDev->ChData[0].PktType;
+  StatsTable3[14].StatPtr = &HalDev->ChData[0].Vci;
+  StatsTable3[15].StatPtr = &HalDev->ChData[0].Vpi;
+  StatsTable3[16].StatPtr = &HalDev->ChData[0].TxVc_CellRate;
+  StatsTable3[17].StatPtr = &HalDev->ChData[0].TxVc_QosType;
+  StatsTable3[18].StatPtr = &HalDev->ChData[0].TxVc_Mbs;
+  StatsTable3[19].StatPtr = &HalDev->ChData[0].TxVc_Pcr;
+
+  /* update device state */
+  HalDev->State = enInitialized;
+
+#ifdef __CPHAL_DEBUG
+  if (DBG(9))
+    dbgConfigDump(HalDev);
+#endif
+
+  return(EC_NO_ERRORS);
+  }
+
+/*
+ *  Use this function to actually send after queuing multiple packets using 
+ *  Send().  This is a debug only function that should be removed - it was 
+ *  necessary to properly implement my loopback tests. 
+ *
+ *  @param   HalDev      CPHAL module instance. (set by xxxInitModule()) 
+ *  @param   Queue       Queue number to kick. 
+ *
+ *  @return  0 OK, Non-Zero Not OK
+ */
+static int halKick(HAL_DEVICE *HalDev, int Queue)
+  {
+   int Ch;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]halKick(HalDev:%08x. Queue:%d)\n", (bit32u)HalDev, Queue);
+      osfuncSioFlush();
+     }
+#endif
+
+   for (Ch = 0; Ch < 16; Ch ++)
+     {
+      if ((!HalDev->TxActive[Ch][Queue]) && (HalDev->TxActQueueHead[Ch][Queue] != 0))
+        {
+         *(pTX_DMA_STATE_WORD_0(HalDev->dev_base)+(Ch*64)+Queue)=
+           VirtToPhys(HalDev->TxActQueueHead[Ch][Queue]);
+         HalDev->TxActive[Ch][Queue]=TRUE;
+        }
+     } 
+ 
+   return (EC_NO_ERRORS);   
+  }
+
+/*  +GSG 030305  For PITS #99
+ *  Alternate interrupt handler that uses the INT_VECTOR in order to 
+ *  provide strict priority handling among channels, beginning with Ch 0.
+ *
+ *  @param   HalDev   CPHAL module instance. (set by xxxInitModule())
+ *  @param   MoreWork (Output) When set to 1, indicates that there is more work to do.
+ *                    Caller should ensure that the value pointed at is set to 0
+ *                    prior to the call.
+ *  @return  0 OK, non-zero error.
+ */
+static int DeviceIntAlt(HAL_DEVICE *HalDev, int *MoreWork)
+  {
+   int tmp, Ch, WorkFlag;
+   bit32u rc;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]DeviceIntAlt(HalDev:%08x, MoreWork:%08x)\n", (bit32u)HalDev, (bit32u)MoreWork);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Verify proper device state - important because a call prior to Open would
+      result in a lockup */
+   if (HalDev->State != enOpened)
+     return(EC_AAL5|EC_FUNC_DEVICE_INT_ALT|EC_VAL_INVALID_STATE);
+
+   if ((tmp=SAR_INTR_VECTOR(HalDev->dev_base))&INT_PENDING)
+     {
+       /*printf("\015 %d RxQ",HalDev->RxActQueueCount[0]);
+         HalDev->OsFunc->Control(HalDev->OsDev, enSIO_FLUSH, enNULL, 0); */
+
+      if (tmp&TXH_PEND) 
+        {
+         /* decide which channel to service */
+         Ch = (SAR_INTR_VECTOR(HalDev->dev_base) & TXH_PEND_INVEC);
+
+         rc = TxInt(HalDev,Ch,0,&WorkFlag);
+         if (rc) return (rc);
+
+         if (WorkFlag == 1)
+           *MoreWork = 1;
+        }
+
+      if (tmp&TXL_PEND) 
+        {
+         /* decide which channel to service */
+         Ch = ((SAR_INTR_VECTOR(HalDev->dev_base) & TXL_PEND_INVEC) >> 4);
+
+         rc = TxInt(HalDev,Ch,1,&WorkFlag);
+         if (rc) return (rc);
+
+         if (WorkFlag == 1)
+           *MoreWork = 1;
+        }
+
+      if (tmp&RX_PEND)
+        {
+         /* decide which channel to service */
+         Ch = ((SAR_INTR_VECTOR(HalDev->dev_base) & RX_PEND_INVEC) >> 8);
+
+         rc = RxInt(HalDev,Ch,&WorkFlag);
+         if (rc) return (rc);
+
+         if (WorkFlag == 1)
+           *MoreWork = 1;
+        }
+       
+      if (tmp&STS_PEND)
+        {
+         /* GPR 2 code added for PITS 103 */
+         /* determine interrupt source */
+         Ch = ((SAR_INTR_VECTOR(HalDev->dev_base) & STS_PEND_INVEC) >> 12);
+
+         /* only if this is GPR 2 interrupt do we take action */
+         if (Ch == 26)
+           {
+            /* pass loopback result back to OS */
+            HalDev->OsFunc->Control(HalDev->OsDev, "OamLbResult", "Set",
+              (bit32u *)pSAR_PDSP_OAM_LB_RESULT_REG(HalDev->dev_base)); 
+           }
+
+         /* clear the interrupt */
+         SAR_STATUS_CLR_REG(HalDev->dev_base) |= 0x04000000;
+        }
+
+      if (tmp&AAL2_PEND)
+        { 
+          /* no action defined */
+        }
+    
+      SAR_INTR_VECTOR(HalDev->dev_base) = 0;
+     }
+
+   return (EC_NO_ERRORS);
+  }
+
+/*
+ *  Called to service a module interrupt.  This function determines
+ *  what type of interrupt occurred and dispatches the correct handler.
+ *
+ *  @param   HalDev   CPHAL module instance. (set by xxxInitModule())
+ *  @param   MoreWork (Output) When set to 1, indicates that there is more work to do.
+ *                    Caller should ensure that the value pointed at is set to 0
+ *                    prior to the call.
+ *  @return  0 OK, non-zero error.
+ */
+static int DeviceInt(HAL_DEVICE *HalDev, int *MoreWork)
+  {
+    /*static int NextRxCh=0;
+      static int NextTxCh[2]={0,0};*/
+
+   int tmp, Ch, FirstCh, WorkFlag;
+   int NextTxLCh, NextTxHCh, NextRxCh;
+   bit32u rc;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]DeviceInt(HalDev:%08x, MoreWork:%08x)\n", (bit32u)HalDev, (bit32u)MoreWork);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Verify proper device state - important because a call prior to Open would
+      result in a lockup */
+   if (HalDev->State != enOpened)
+     return(EC_AAL5|EC_FUNC_DEVICE_INT|EC_VAL_INVALID_STATE);
+
+   NextTxHCh = HalDev->NextTxCh[0];
+   NextTxLCh = HalDev->NextTxCh[1];
+   NextRxCh =  HalDev->NextRxCh;
+
+   /* service interrupts while there is more work to do */
+   /*while (((tmp=SAR_INTR_VECTOR(HalDev->dev_base))&INT_PENDING) && (TotalPkts < 500))*/
+   if ((tmp=SAR_INTR_VECTOR(HalDev->dev_base))&INT_PENDING)
+     {
+       /*printf("\015 %d RxQ",HalDev->RxActQueueCount[0]);
+         HalDev->OsFunc->Control(HalDev->OsDev, enSIO_FLUSH, enNULL, 0); */
+
+      if (tmp&TXH_PEND) 
+        {
+         /* decide which channel to service */
+         FirstCh = NextTxHCh;
+         while (1)
+           {
+            Ch = NextTxHCh++;
+            if (NextTxHCh == 16)
+              NextTxHCh = 0;
+            if (SAR_TX_MASKED_STATUS(HalDev->dev_base) & (1<<Ch))
+              break;
+            if (FirstCh == NextTxHCh)
+              {
+               /* we checked every channel and still haven't found anything to do */
+               return (EC_AAL5|EC_FUNC_DEVICE_INT|EC_VAL_NO_TXH_WORK_TO_DO);
+              }
+           }
+ 
+         rc = TxInt(HalDev,Ch,0,&WorkFlag);
+         if (rc) return (rc);
+
+         if (WorkFlag == 1)
+           *MoreWork = 1;
+        }
+
+      if (tmp&TXL_PEND)
+        {
+         /* decide which channel to service */
+         FirstCh = NextTxLCh;
+         while (1)
+           {
+            Ch = NextTxLCh++;
+            if (NextTxLCh == 16)
+              NextTxLCh = 0;
+            if (SAR_TX_MASKED_STATUS(HalDev->dev_base) & (1<<(Ch+16)))
+              break;
+            if (FirstCh == NextTxLCh)
+              {
+               /* we checked every channel and still haven't found anything to do */
+               return (EC_AAL5|EC_FUNC_DEVICE_INT|EC_VAL_NO_TXL_WORK_TO_DO);
+              }
+           }
+
+         rc = TxInt(HalDev,Ch,1,&WorkFlag);
+         if (rc) return (rc);
+
+         if (WorkFlag == 1)
+           *MoreWork = 1;       
+        }
+         
+      if (tmp&RX_PEND)
+        {
+         FirstCh = NextRxCh;
+         while (1)
+           {
+            Ch = NextRxCh++;   
+            if (NextRxCh == 16)
+              NextRxCh = 0;
+            if (SAR_RX_MASKED_STATUS(HalDev->dev_base) & (1 << Ch))
+              break;  /* found a channel to service */
+            if (FirstCh == NextRxCh)
+              {
+               /* we checked every channel and still haven't found anything to do */
+               return (EC_AAL5|EC_FUNC_DEVICE_INT|EC_VAL_NO_RX_WORK_TO_DO);
+              }
+           }
+
+         rc = RxInt(HalDev,Ch, &WorkFlag);
+         if (rc) return (rc);
+
+         if (WorkFlag == 1)
+           *MoreWork = 1;
+        }
+       
+      if (tmp&STS_PEND)
+        {
+         /* +GSG 030305 */
+         /* GPR 2 code added for PITS 103 */
+         /* determine interrupt source */
+         Ch = ((SAR_INTR_VECTOR(HalDev->dev_base) & STS_PEND_INVEC) >> 12);
+
+         /* only if this is GPR 2 interrupt do we take action */
+         if (Ch == 26)
+           {
+            /* pass loopback result back to OS */
+            HalDev->OsFunc->Control(HalDev->OsDev, "OamLbResult", "Set",
+              (bit32u *)pSAR_PDSP_OAM_LB_RESULT_REG(HalDev->dev_base)); 
+           }
+
+         /* clear the interrupt */
+         SAR_STATUS_CLR_REG(HalDev->dev_base) |= 0x04000000;
+        }
+
+      if (tmp&AAL2_PEND)
+        { 
+          /* no action defined */
+        }
+    
+      SAR_INTR_VECTOR(HalDev->dev_base) = 0;
+     }
+
+   HalDev->NextTxCh[0] = NextTxHCh;
+   HalDev->NextTxCh[1] = NextTxLCh;
+   HalDev->NextRxCh = NextRxCh;
+
+   /* This must be done by the upper layer */
+   /* SAR_EOI(HalDev->dev_base) = 0; */
+
+   return (EC_NO_ERRORS);
+  }
+
+/** 
+ *  @ingroup CPHAL_Functions
+ *  This function starts the operation of the CPHAL device.  It takes the device
+ *  out of reset, and calls @c IsrRegister().  This function should be called after 
+ *  calling the @c Init() function.
+ *
+ *  @param  HalDev   CPHAL module instance. (set by xxxInitModule())
+ *
+ *  @return EC_NO_ERRORS (ok).<BR>
+ *           Possible Error Codes:<BR>
+ *           @ref EC_VAL_INVALID_STATE "EC_VAL_INVALID_STATE"<BR>
+ *           @ref EC_VAL_KEY_NOT_FOUND "EC_VAL_KEY_NOT_FOUND"<BR>
+ *           @ref EC_VAL_FIRMWARE_TOO_LARGE "EC_VAL_FIRMWARE_TOO_LARGE"<BR>
+ *           @ref EC_VAL_PDSP_LOAD_FAIL "EC_VAL_PDSP_LOAD_FAIL"<BR>
+ *           @ref EC_VAL_RX_STATE_RAM_NOT_CLEARED "EC_VAL_RX_STATE_RAM_NOT_CLEARED"<BR>
+ *           @ref EC_VAL_TX_STATE_RAM_NOT_CLEARED "EC_VAL_TX_STATE_RAM_NOT_CLEARED"<BR>
+ *           @ref EC_VAL_TCB_MALLOC_FAILED "EC_VAL_TCB_MALLOC_FAILED"<BR>
+ *           @ref EC_VAL_RCB_MALLOC_FAILED "EC_VAL_RCB_MALLOC_FAILED"<BR>
+ *           @ref EC_VAL_RX_BUFFER_MALLOC_FAILED "EC_VAL_RX_BUFFER_MALLOC_FAILED"<BR>
+ *           @ref EC_VAL_LUT_NOT_READY "EC_VAL_LUT_NOT_READY"<BR>
+ */
+static int halOpen(HAL_DEVICE *HalDev)
+  {
+   int i,Ret;
+   bit32 SarBase = HalDev->dev_base;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]halOpen(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Verify proper device state */
+   if (HalDev->State < enInitialized)
+     return (EC_AAL5|EC_FUNC_OPEN|EC_VAL_INVALID_STATE);
+
+   /* Open the SAR (this brings the whole device out of reset */
+   Ret = HalDev->SarFunc->Open(HalDev->SarDev); /* ~GSG 030410 */
+   if (Ret)                                     /* +GSG 030410 */
+     return (Ret);                              /* +GSG 030410 */
+
+   /* Change device state */
+   HalDev->State = enOpened;
+
+
+#ifdef __CPHAL_DEBUG
+   /* print out the version information */
+   if (DBG(7))
+     {
+      dbgPrintf("[aal5 halOpen()]Module ID(AAL5-CPSAR):%d, Version:%2d.%02d\n",
+                (SAR_ID_REG(SarBase)&0xffff0000)>>16,
+                (SAR_ID_REG(SarBase)&0xff00)>>8,
+                SAR_ID_REG(SarBase)&0xff);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* GREG 11/1/02:  The State RAM clearing code was previously in cpsar.c,
+      directly after device reset.  I moved it here because I believe it is
+      AAL5 specific code.  Also the MAX_CHAN was set to 19 in cpsar.c, which
+      would have caused this code to clear too much memory! */
+
+   /* NOTE:  State RAM must be cleared prior to initializing the PDSP!! */
+
+   /* GSG 030416:  Removed all of this.  All PDSP State RAM is cleared
+      in CPSAR Open().  On Close(), all channels are torndown, thus all
+      AAL5 channel state RAM is cleared.  */
+
+   /* Clear Rx State RAM  */
+   /*for (i=0; i<NUM_AAL5_CHAN; i++)
+     for (j=0; j<NUM_RX_STATE_WORDS; j++)
+     *(pRX_DMA_STATE_WORD_0(SarBase) + (i*64) + j) = 0; */
+
+   /* Check that Rx DMA State RAM was cleared */
+   /*for (i=0; i<NUM_AAL5_CHAN; i++)
+     for (j=0; j<NUM_RX_STATE_WORDS; j++)
+       {
+        if (*(pRX_DMA_STATE_WORD_0(SarBase) + (i*64) + j) != 0)
+         {
+          return(EC_AAL5|EC_FUNC_HAL_INIT|EC_VAL_RX_STATE_RAM_NOT_CLEARED);
+         }
+         }*/
+
+   /* Clear Tx State RAM  */
+   /*for (i=0; i<NUM_AAL5_CHAN; i++)
+     for (j=0; j<NUM_TX_STATE_WORDS; j++)
+       {
+        *(pTX_DMA_STATE_WORD_0(SarBase) + (i*64) + j) = 0; 
+        }*/
+
+   /* Check that Tx DMA State RAM was cleared */
+   /*for (i=0; i<NUM_AAL5_CHAN; i++)
+     for (j=0; j<NUM_TX_STATE_WORDS; j++)
+       {
+        if (*(pTX_DMA_STATE_WORD_0(SarBase) + (i*64) + j) != 0)
+          {
+           return(EC_AAL5|EC_FUNC_HAL_INIT|EC_VAL_TX_STATE_RAM_NOT_CLEARED);
+          }
+          }*/
+
+   /* GSG +030523 Malloc space for the Rx fraglist */
+   HalDev->fraglist = HalDev->OsFunc->Malloc(HalDev->MaxFrags * sizeof(FRAGLIST));
+
+   /* For any channels that have been pre-initialized, set them up now */
+   for (i=0; i<NUM_AAL5_CHAN; i++)
+     {
+      if ((HalDev->ChIsSetup[i][0]==TRUE) && (HalDev->ChIsOpen[i][0]==FALSE))
+        {
+         CHANNEL_INFO HalChn;
+         HalChn.Channel = i;
+         Ret = ChannelConfigApply(HalDev, &HalChn);
+         if (Ret) return (Ret);
+        }
+     }
+
+   /* OAM code would be a candidate to go into ConfigApply */
+
+   /* Configure OAM Timer State Block */
+   OamRateConfig(HalDev); /* +GSG 030416 */
+
+   /* Setup OAM Configuration Block */
+   for (i=0; i<8; i++) /* ~GSG 030603 4->8 */
+     {
+      if (i < 4)
+        *(pOAM_CONFIG_BLOCK_WORD_0(SarBase) + i) = HalDev->DeviceCPID[i];
+      else
+        *(pOAM_CONFIG_BLOCK_WORD_0(SarBase) + i) = HalDev->LBSourceLLID[i-4];
+     }
+
+   /* Setup OAM Padding Block */
+   for (i=0; i<12; i++)
+     {
+      *(pOAM_PADDING_BLOCK_WORD_0(SarBase) + i) = ((i==11)?0x6a6a0000:0x6a6a6a6a);    
+     }
+
+   /* Enable Tx CPPI DMA */
+   TX_CPPI_CTL_REG(HalDev->dev_base) = 1;
+   
+   /* Enable Rx CPPI DMA */
+   RX_CPPI_CTL_REG(HalDev->dev_base) = 1;
+
+   /* +GSG 030306 */
+   /* Fix for PITS 103 */
+   /* Enable Host Interrupt for GPR 2 (OAM LB result register) */
+   SAR_HOST_INT_EN_SET_REG(HalDev->dev_base) |= 0x04000000;
+   
+   /* +GSG 030304 to fix PITS 99 (if block is new)*/
+   if (HalDev->StrictPriority == 1)
+     {
+#ifdef __CPHAL_DEBUG
+      if (DBG(1))
+        {
+         dbgPrintf("[aal5->os]IsrRegister(OsDev:%08x, halIsr:%08x, Interrupt:%d)\n",
+                   (bit32u)HalDev->OsDev, (bit32u)DeviceIntAlt, HalDev->interrupt);
+         osfuncSioFlush();
+        }
+#endif
+
+      /* "register" the interrupt handler */
+      HalDev->OsFunc->IsrRegister(HalDev->OsDev, DeviceIntAlt, HalDev->interrupt);
+     }
+    else /* +GSG 030306 */
+     { /* +GSG 030306 */
+#ifdef __CPHAL_DEBUG
+      if (DBG(1))
+        {
+         dbgPrintf("[aal5->os]IsrRegister(OsDev:%08x, halIsr:%08x, Interrupt:%d)\n",
+                   (bit32u)HalDev->OsDev, (bit32u)DeviceInt, HalDev->interrupt);
+         osfuncSioFlush();
+        }
+#endif
+
+      /* "register" the interrupt handler */
+      HalDev->OsFunc->IsrRegister(HalDev->OsDev, DeviceInt, HalDev->interrupt);
+     } /* +GSG 030306 */
+
+   return(EC_NO_ERRORS);
+  }
+
+/**
+ *  @ingroup CPHAL_Functions
+ *  Called to retrigger the interrupt mechanism after packets have been
+ *  processed.  Call this function when the HalISR function indicates that
+ *  there is no more work to do.  Proper use of this function will guarantee 
+ *  that interrupts are never missed.  
+ *
+ *  @param  HalDev   CPHAL module instance. (set by xxxInitModule())  
+ *
+ *  @return EC_NO_ERRORS (ok). <BR>
+ */
+static int halPacketProcessEnd(HAL_DEVICE *HalDev)
+  {
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]halPacketProcessEnd(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   SAR_EOI(HalDev->dev_base) = 0;
+   return (EC_NO_ERRORS);
+  }
+
+/**
+ *  @ingroup CPHAL_Functions
+ *  This function probes for the instance of the CPHAL module.  It will call
+ *  the OS function @c DeviceFindInfo() to get the information required.
+ *  
+ *  @param   HalDev      CPHAL module instance. (set by xxxInitModule())
+ *
+ *  @return  EC_NO_ERRORS (ok). <BR>
+ *           Possible Error Codes:<BR>
+ *           @ref EC_VAL_INVALID_STATE "EC_VAL_INVALID_STATE"<BR>
+ *           @ref EC_VAL_DEVICE_NOT_FOUND "EC_VAL_DEVICE_NOT_FOUND"<BR>
+ */
+static int halProbe(HAL_DEVICE *HalDev)
+  {
+   int Ret;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]halProbe(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Verify hardware state is "enConnected */
+   if (HalDev->State != enConnected)
+     return (EC_AAL5|EC_FUNC_PROBE|EC_VAL_INVALID_STATE);
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(1))
+     {
+      dbgPrintf("[aal5->os]DeviceFindInfo(Inst:%d, DeviceName:%s, DeviceInfo:%08x)\n",
+                HalDev->Inst, "aal5", (bit32u)&HalDev->DeviceInfo);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Attempt to find the device information */
+   Ret = HalDev->OsFunc->DeviceFindInfo(HalDev->Inst, "aal5", &HalDev->DeviceInfo);
+   if (Ret)
+     return(EC_AAL5|EC_FUNC_PROBE|EC_VAL_DEVICE_NOT_FOUND);
+
+   /* Call Probe for supporting CPSAR layer */
+   Ret = HalDev->SarFunc->Probe(HalDev->SarDev);
+   if (Ret)
+     return(Ret);
+
+   /* Set device state to DevFound */
+   HalDev->State = enDevFound;
+
+   return(EC_NO_ERRORS);    
+  }
+
+/** 
+ *  @ingroup CPHAL_Functions
+ *  This function shuts down the CPHAL module completely.  The caller must call
+ *  Close() to put the device in reset prior shutting down.  This call will free
+ *  the HalDev and the HAL function pointer structure, effectively ending
+ *  communications between the driver and the CPHAL.  Further use of the module
+ *  must be initiated by a call to xxxInitModule(), which starts the entire process
+ *  over again.
+ *
+ *  @param   HalDev   CPHAL module instance. (set by xxxInitModule())  
+ *
+ *  @return  EC_NO_ERRORS (ok). <BR>
+ *           Possible Error Codes:<BR>
+ *           Any error code from halClose().<BR>
+ */
+static int halShutdown(HAL_DEVICE *HalDev)
+  {
+   int Ch, Queue;                                                  /*GSG+030514*/
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]halShutdown(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Verify proper device state */
+   if (HalDev->State == enOpened)
+     halClose(HalDev, 3);                                          /*GSG+030429*/
+
+   /* Buffer/descriptor resources may still need to be freed if a Close
+      Mode 1 was performed prior to Shutdown - clean up here */    /*GSG+030514*/
+   for (Ch=0; Ch<NUM_AAL5_CHAN; Ch++)                                
+     {                                                             
+      if (HalDev->RcbStart[Ch] != 0)                           
+        FreeRx(HalDev,Ch);
+
+      for(Queue=0; Queue<MAX_QUEUE; Queue++)
+        {
+         if (HalDev->TcbStart[Ch][Queue] != 0)
+           FreeTx(HalDev,Ch,Queue);
+        }
+     }
+
+   /* shutdown the CPSAR layer */
+   HalDev->SarFunc->Shutdown(HalDev->SarDev);
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(6))
+     {
+      dbgPrintf("  [aal5 halShutdown()]Free AAL5 function pointers\n");
+      osfuncSioFlush();
+     }
+   if (DBG(1)||DBG(3))
+     {
+      dbgPrintf("[aal5->os]Free(MemPtr:%08x)\n", (bit32u)HalDev->HalFuncPtr);
+      osfuncSioFlush();
+     }
+#endif
+   /* free the HalFunc */
+   HalDev->OsFunc->Free(HalDev->HalFuncPtr);
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(6))
+     {
+      dbgPrintf("  [aal5 halShutdown]Free HalDev\n");
+      osfuncSioFlush();
+     }
+   if (DBG(1)||DBG(3))
+     {
+      dbgPrintf("[aal5->os]Free(MemPtr:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+   /* free the HAL device */
+   HalDev->OsFunc->FreeDev(HalDev);
+
+   return(EC_NO_ERRORS);
+  }
+
+/**
+ *  @ingroup CPHAL_Functions
+ *  Used to perform regular checks on the device.  This function should be 
+ *  called at a regular interval specified by the @c Tick parameter. 
+ *  
+ *  @param   HalDev      CPHAL module instance. (set by xxxInitModule())
+ *
+ *  @return  EC_NO_ERRORS (ok).<BR>
+ *           Possible Error Codes:<BR>
+ *           @ref EC_VAL_INVALID_STATE "EC_VAL_INVALID_STATE"<BR>
+ */
+static int halTick(HAL_DEVICE *HalDev)
+  {
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[aal5]halTick(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   if (HalDev->State != enOpened)
+     return(EC_AAL5|EC_FUNC_TICK|EC_VAL_INVALID_STATE);
+
+   return(EC_NO_ERRORS);
+  }
+
+/** 
+ *  @ingroup CPHAL_Functions
+ *
+ *  This function will:
+ *  -# allocate a HalDev that will be used by the OS for future communications with the device
+ *  -# save OsDev for use when calling OS functions
+ *  -# allocate and populate HalFunc with the addresses of CPHAL functions.
+ *  -# check OsFuncSize to see if it meets the minimum requirement.
+ *  -# return the size of the HAL_FUNCTIONS structure through the HalFuncSize pointer.  The OS
+ *     should check this value to ensure that the HAL meets its minimum requirement.
+ *
+ *  Version checking between the OS and the CPHAL is done using the OsFuncSize and 
+ *  HalFuncSize.  Future versions of the CPHAL may add new functions to either
+ *  HAL_FUNCTIONS or OS_FUNCTIONS, but will never remove functionality.  This enables
+ *  both the HAL and OS to check the size of the function structure to ensure that
+ *  the current OS and CPHAL are compatible.
+ *
+ *  Note:  This is the only function exported by a CPHAL module. 
+ *
+ *  Please refer to the section "@ref hal_init" for example code.
+ *
+ *  @param   HalDev  Pointer to pointer to CPHAL module information.  This will 
+ *                   be used by the OS when communicating to this module via 
+ *                   CPHAL. Allocated during the call.
+ *  @param   OsDev   Pointer to OS device information.  This will be saved by
+ *                   the CPHAL and returned to the OS when required.
+ *  @param   HalFunc Pointer to pointer to structure containing function pointers for all CPHAL 
+ *                   interfaces.  Allocated during the call.
+ *  @param   OsFunc  Pointer to structure containing function pointers for all OS
+ *                   provided interfaces.  Must be allocated by OS prior to call.
+ *  @param   OsFuncSize  Size of OS_FUNCTIONS structure.
+ *  @param   HalFuncSize    Pointer to the size of the HAL_FUNCTIONS structure.
+ *  @param   Inst    The instance number of the module to initialize. (start at
+ *                   0).
+ * 
+ *  @return  EC_NO_ERRORS (ok). <BR>
+ *           Possible Error Codes:<BR>
+ *           @ref EC_VAL_OS_VERSION_NOT_SUPPORTED "EC_VAL_OS_VERSION_NOT_SUPPORTED"<BR>
+ *           @ref EC_VAL_MALLOC_DEV_FAILED "EC_VAL_MALLOC_DEV_FAILED"<BR>
+ *           @ref EC_VAL_MALLOC_FAILED "EC_VAL_MALLOC_FAILED"<BR>
+ */
+int xxxInitModule(HAL_DEVICE **HalDev, 
+                 OS_DEVICE *OsDev, 
+                 HAL_FUNCTIONS **HalFunc, 
+                 OS_FUNCTIONS *OsFunc, 
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst);
+
+int cpaal5InitModule(HAL_DEVICE **HalDev, 
+                 OS_DEVICE *OsDev, 
+                 HAL_FUNCTIONS **HalFunc, 
+                 OS_FUNCTIONS *OsFunc, 
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst)
+  {
+   int rc, SarFuncSize;
+   HAL_DEVICE *HalPtr;
+   HAL_FUNCTIONS *HalFuncPtr;
+
+   /* NEW CODE */
+   if (OsFuncSize < sizeof(OS_FUNCTIONS))
+     return (EC_AAL5|EC_FUNC_HAL_INIT|EC_VAL_OS_VERSION_NOT_SUPPORTED);
+
+   HalPtr = (HAL_DEVICE *) OsFunc->MallocDev(sizeof(HAL_DEVICE));
+   if (!HalPtr)
+     return (EC_AAL5|EC_FUNC_HAL_INIT|EC_VAL_MALLOC_DEV_FAILED);
+
+   HalFuncPtr = (HAL_FUNCTIONS *) OsFunc->Malloc(sizeof(HAL_FUNCTIONS));
+   if (!HalFuncPtr)
+     return (EC_AAL5|EC_FUNC_HAL_INIT|EC_VAL_MALLOC_FAILED);
+
+   /* Initialize the size of hal functions */
+   *HalFuncSize = sizeof (HAL_FUNCTIONS);
+
+   /* clear the device structure */
+   OsFunc->Memset(HalPtr, 0, sizeof(HAL_DEVICE));
+
+   /* clear the function pointers */
+   OsFunc->Memset(HalFuncPtr, 0, sizeof(HAL_FUNCTIONS));
+
+   /* initialize the HAL_DEVICE structure */
+   HalPtr->OsDev  = OsDev;
+   /*HalPtr->OsOpen = OsDev;*/
+   HalPtr->Inst   = Inst; 
+   HalPtr->OsFunc = OsFunc;
+  
+   /* Supply pointers for the CPHAL API functions */
+   HalFuncPtr->RxReturn        = halRxReturn;
+   HalFuncPtr->Init            = halInit;
+   HalFuncPtr->Close           = halClose;
+   HalFuncPtr->Send            = halSend;
+   HalFuncPtr->ChannelSetup    = halChannelSetup;
+   HalFuncPtr->ChannelTeardown = halChannelTeardown;
+   HalFuncPtr->Open            = halOpen;
+   HalFuncPtr->Kick            = halKick;
+   HalFuncPtr->RegAccess       = halRegAccess; 
+   HalFuncPtr->Probe           = halProbe;
+   HalFuncPtr->Control         = halControl;
+   HalFuncPtr->Tick            = halTick;
+   HalFuncPtr->Shutdown        = halShutdown;
+   HalFuncPtr->OamFuncConfig   = halOamFuncConfig; /* +GSG 030306 */
+   HalFuncPtr->OamLoopbackConfig   = halOamLoopbackConfig; /* ~GSG 030416 */
+
+   /* Temporary */
+   /*HalFuncPtr->StatsGetOld = StatsGet;*/
+   HalFuncPtr->PacketProcessEnd = halPacketProcessEnd;
+
+   /* Now, AAL5 must connect to the CPSAR layer */
+
+   /* Attach to SAR HAL Functions */
+   /*
+   cpsarInitModule(NULL, NULL, 0, NULL, &SarFuncSize, Inst);
+
+   if (SarFuncSize!=sizeof(CPSAR_FUNCTIONS))
+    return(EC_AAL5|EC_FUNC_HAL_INIT|EC_VAL_CPSAR_VERSION_NOT_SUPPORTED); 
+
+   HalPtr->SarFunc = (CPSAR_FUNCTIONS *) OsFunc->Malloc(SarFuncSize);
+   */
+
+   rc = cpsarInitModule(&HalPtr->SarDev, OsDev, &HalPtr->SarFunc, OsFunc, sizeof(OS_FUNCTIONS), &SarFuncSize, Inst);
+
+   /* pass back the error value from the CPSAR layer if necessary */
+   if (rc)
+     return(rc);
+
+   /*
+   if (!HalPtr->SarDev)
+     return(EC_AAL5|EC_FUNC_HAL_INIT|EC_VAL_NULL_CPSAR_DEV);
+   */
+
+   /* Initialize the hardware state */
+   HalPtr->State = enConnected;
+
+   /* keep a reference to HalFuncPtr so I can free it later */
+   HalPtr->HalFuncPtr = HalFuncPtr;
+
+   /* pass the HalPtr back to the caller */
+   *HalDev = HalPtr;
+   *HalFunc = HalFuncPtr;
+
+   return(EC_NO_ERRORS);
+  }
diff -urN linux.old/drivers/atm/sangam_atm/aal5sar.h linux.dev/drivers/atm/sangam_atm/aal5sar.h
--- linux.old/drivers/atm/sangam_atm/aal5sar.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/aal5sar.h	2005-08-23 04:46:50.080846280 +0200
@@ -0,0 +1,198 @@
+/**@file************************************************************************
+ *  TNETDxxxx Software Support
+ *  Copyright (c) 2002 Texas Instruments Incorporated. All Rights Reserved.
+ *
+ *  FILE:   aal5sar.h
+ *
+ *  DESCRIPTION:
+ *      This file contains data structure definitions for the AAL5 HAL SAR.
+ *
+ *  HISTORY:
+ *      28Feb02 Greg       1.00  Original Version created.
+ *      06Mar02 Greg       1.01  Documented structures.
+ *      18Jul02 Greg       1.02  Major reorganization
+ *
+ *****************************************************************************/
+#ifndef _INC_AAL5SAR
+#define _INC_AAL5SAR
+
+/** \namespace AAL5_Version
+This documents version 01.06.06 of the AAL5 CPHAL.
+*/
+const char *pszVersion_CPAAL5="CPAAL5 01.06.06 "__DATE__" "__TIME__;
+
+#include "cpsar_cpaal5.h"
+
+#define NUM_AAL5_CHAN   16
+#define MAX_AAL5_CHAN   15
+#define MAX_QUEUE       2
+#define MAX_DIRECTION   2
+
+#define PKT_TYPE_AAL5   0   /* +GSG 030508 */
+#define PKT_TYPE_NULL   1   /* +GSG 030508 */
+#define PKT_TYPE_OAM    2   /* +GSG 030508 */
+#define PKT_TYPE_TRANS  3   /* +GSG 030508 */
+#define ATM_HEADER_SIZE 4   /* +GSG 030508 */
+
+/*
+ * HAL Default Parameter Values
+ */
+#define CFG_TX_NUM_BUFS   {256,256,256,256,256,256,256,256, 256,256,256,256,256,256,256,256}
+#define CFG_RX_NUM_BUFS   {256,256,256,256,256,256,256,256, 256,256,256,256,256,256,256,256}
+#define CFG_RX_BUF_SIZE   {1518,1518,1518,1518,1518,1518,1518,1518, 1518,1518,1518,1518,1518,1518,1518,1518}
+#define CFG_RX_BUF_OFFSET {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0}
+#define CFG_TX_NUM_QUEUES {1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1}
+#define CFG_CPCS_UU       {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0}
+#define CFG_DA_MASK       {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0}
+#define CFG_PRIORITY      {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0}
+#define CFG_PKT_TYPE      {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0}
+#define CFG_VCI           {100,101,102,103,104,105,106,107, 108,109,110,111,112,113,114,115}
+#define CFG_VPI           {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0}
+#define CFG_CELL_RATE     {0x30d4,0x30d4,0x30d4,0x30d4,0x30d4,0x30d4,0x30d4,0x30d4, 0x30d4,0x30d4,0x30d4,0x30d4,0x30d4,0x30d4,0x30d4,0x30d4}
+#define CFG_QOS_TYPE      {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0}
+#define CFG_MBS           {8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8}
+#define CFG_PCR           {1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1}
+#define CFG_GFC           {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0}
+#define CFG_CLP           {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0}
+#define CFG_PTI           {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0}
+#define CFG_RX_MAX_SERVICE {170,170,170,170,170,170,170,170, 170,170,170,170,170,170,170,170}
+#define CFG_TX_MAX_SERVICE {170,170,170,170,170,170,170,170, 170,170,170,170,170,170,170,170}
+
+static int cfg_tx_num_bufs[NUM_AAL5_CHAN]   = CFG_TX_NUM_BUFS;
+static int cfg_rx_num_bufs[NUM_AAL5_CHAN]   = CFG_RX_NUM_BUFS;
+static int cfg_rx_buf_size[NUM_AAL5_CHAN]   = CFG_RX_BUF_SIZE;
+static int cfg_rx_buf_offset[NUM_AAL5_CHAN] = CFG_RX_BUF_OFFSET;
+static int cfg_tx_num_queues[NUM_AAL5_CHAN] = CFG_TX_NUM_QUEUES;
+static bit32u cfg_cpcs_uu[NUM_AAL5_CHAN]    = CFG_CPCS_UU;
+static int cfg_da_mask[NUM_AAL5_CHAN]       = CFG_DA_MASK;
+static int cfg_priority[NUM_AAL5_CHAN]      = CFG_PRIORITY;
+static int cfg_pkt_type[NUM_AAL5_CHAN]      = CFG_PKT_TYPE;
+static int cfg_vci[NUM_AAL5_CHAN]           = CFG_VCI;
+static int cfg_vpi[NUM_AAL5_CHAN]           = CFG_VPI;
+static bit32u cfg_cell_rate[NUM_AAL5_CHAN]  = CFG_CELL_RATE;
+static int cfg_qos_type[NUM_AAL5_CHAN]      = CFG_QOS_TYPE;
+static int cfg_mbs[NUM_AAL5_CHAN]           = CFG_MBS;
+static int cfg_pcr[NUM_AAL5_CHAN]           = CFG_PCR;
+static int cfg_gfc[NUM_AAL5_CHAN]           = CFG_GFC;
+static int cfg_clp[NUM_AAL5_CHAN]           = CFG_CLP;
+static int cfg_pti[NUM_AAL5_CHAN]           = CFG_PTI;
+static int cfg_rx_max_service[NUM_AAL5_CHAN]= CFG_RX_MAX_SERVICE;
+static int cfg_tx_max_service[NUM_AAL5_CHAN]= CFG_TX_MAX_SERVICE;
+static char *channel_names[]   = CHANNEL_NAMES;
+
+/*
+ *  The HAL_FUNCTIONS struct defines the function pointers for all HAL functions
+ *  accessible to upper layer software.  It is populated by calling
+ *  halInitModules().
+ *
+ *  Note that this list is still under definition.
+ */
+
+/*
+ *  This is the data structure for a transmit buffer descriptor.  The first
+ *  four 32-bit words of the BD represent the CPPI 3.0 defined buffer descriptor
+ *  words.  The other words are SAR/HAL implementation specific.
+ */
+typedef struct
+  {
+   bit32 HNext;      /**< Hardware's pointer to next buffer descriptor */
+   bit32 BufPtr;     /**< Pointer to the data buffer */
+   bit32 Off_BLen;   /**< Contains buffer offset and buffer length */
+   bit32 mode;       /**< SOP, EOP, Ownership, EOQ, Teardown Complete bits */
+   bit32 AtmHeader;  /**< Atm Header to be used for each fragment */
+   bit32 Word5;      /**< General control information for the packet */
+   bit32 Res6;
+   bit32 Res7;
+   void *Next;
+   void *OsInfo;
+#ifdef __CPHAL_DEBUG
+   bit32 DbgSop;
+   bit32 DbgData;
+   bit32 DbgFraglist;
+#endif
+   void *Eop;
+  }HAL_TCB;
+
+/*
+ *  This is the data structure for a receive buffer descriptor.  The first
+ *  six 32-bit words of the BD represent the CPPI 3.0 defined buffer descriptor
+ *  words.  The other words are HAL implementation specific.
+ */
+typedef volatile struct hal_private
+  {
+  bit32 HNext;      /**< Hardware's pointer to next buffer descriptor */
+  bit32 BufPtr;     /**< Pointer to the data buffer */
+  bit32 Off_BLen;   /**< Contains buffer offset and buffer length */
+  bit32 mode;       /**< SOP, EOP, Ownership, EOQ, Teardown, Q Starv, Length */
+  bit32 AtmHeader;
+  bit32 UuCpi;
+  bit32 Res6;
+  bit32 Res7;
+  void *DatPtr;
+  void *Next;
+  void *OsInfo;
+  void *Eop;
+  bit32 FragCount;
+  bit32 Ch;
+  HAL_DEVICE *HalDev;
+  }HAL_RCB;
+
+
+#define MAX_NEEDS 512                                             /*MJH+030409*/
+/*
+ *  This is the data structure for a generic HAL device.  It contains all device
+ *  specific data for a single instance of that device.  This includes Rx/Tx
+ *  buffer queues, device base address, reset bit, and other information.
+ */
+typedef struct hal_device
+  {
+  HAL_RCB *RcbPool[NUM_AAL5_CHAN];
+  bit32u rxbufseq;
+  bit32 RxActQueueCount[NUM_AAL5_CHAN];
+  HAL_RCB *RxActQueueHead[NUM_AAL5_CHAN];
+  HAL_RCB *RxActQueueTail[NUM_AAL5_CHAN];
+  bit32 RxActive[NUM_AAL5_CHAN];
+  bit32 dev_base;
+  HAL_TCB *TcbPool[NUM_AAL5_CHAN][MAX_QUEUE];
+  bit32 offset;
+  bit32 TxActQueueCount[NUM_AAL5_CHAN][MAX_QUEUE];
+  HAL_TCB *TxActQueueHead[NUM_AAL5_CHAN][MAX_QUEUE];
+  HAL_TCB *TxActQueueTail[NUM_AAL5_CHAN][MAX_QUEUE];
+  bit32 TxActive[NUM_AAL5_CHAN][MAX_QUEUE];
+  bit32 TxTeardownPending[NUM_AAL5_CHAN];
+  bit32 RxTeardownPending[NUM_AAL5_CHAN];
+  bit32 ChIsOpen[NUM_AAL5_CHAN][MAX_DIRECTION];
+  bit32 ChIsSetup[NUM_AAL5_CHAN][MAX_DIRECTION];
+  bit32 interrupt;
+  bit32 debug;
+  OS_DEVICE *OsDev;
+  OS_FUNCTIONS *OsFunc;
+  CPSAR_FUNCTIONS *SarFunc;
+  CPSAR_DEVICE *SarDev;
+  /*void *OsOpen;*/
+    /*FRAGLIST fraglist[MAX_FRAG];*/
+  FRAGLIST *fraglist;
+  char *TcbStart[NUM_AAL5_CHAN][MAX_QUEUE];
+  char *RcbStart[NUM_AAL5_CHAN];
+    /*bit32 RcbSize[NUM_AAL5_CHAN];*/
+  bit32 InRxInt[NUM_AAL5_CHAN];
+  STAT_INFO Stats;
+  bit32  Inst;
+  bit32u DeviceCPID[4];
+  bit32u LBSourceLLID[4];
+  CHANNEL_INFO ChData[NUM_AAL5_CHAN];
+  DEVICE_STATE State;
+  char *DeviceInfo;
+  HAL_FUNCTIONS *HalFuncPtr;
+  int NextRxCh;
+  int NextTxCh[2];
+  int StrictPriority; /* +GSG 030304 */
+  bit32u NeedsCount;                                              /*MJH+030409*/
+  HAL_RECEIVEINFO *Needs[MAX_NEEDS];                              /*MJH+030409*/
+  bit32u SarFrequency;  /* +GSG 030416 */
+  int MaxFrags;
+  bit32u TurboDslErrors;
+  bit32u OamLbTimeout;
+  }HALDEVICE;
+
+#endif
diff -urN linux.old/drivers/atm/sangam_atm/cpcommon_cpaal5.c linux.dev/drivers/atm/sangam_atm/cpcommon_cpaal5.c
--- linux.old/drivers/atm/sangam_atm/cpcommon_cpaal5.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cpcommon_cpaal5.c	2005-08-23 04:46:50.081846128 +0200
@@ -0,0 +1,728 @@
+#ifndef _INC_CPCOMMON_C
+#define _INC_CPCOMMON_C
+
+#ifdef _CPHAL_CPMAC
+#include "cpremap_cpmac.c"
+#endif
+
+#ifdef _CPHAL_AAL5
+#include "cpremap_cpaal5.c"
+#endif
+
+#ifdef _CPHAL_CPSAR
+#include "cpremap_cpsar.c"
+#endif
+
+#ifdef _CPHAL_AAL2
+#include "cpremap_cpaal2.c"
+#endif
+
+/**
+@defgroup Common_Config_Params Common Configuration Parameters
+
+This section documents the configuration parameters that are valid across
+all CPHAL devices.
+@{
+*/
+/** This is the debug level.  The field is bit defined, such that the user
+should set to 1 all the bits corresponding to desired debug outputs.  The following 
+are the meanings for each debug bit:
+- bit0 (LSB): CPHAL Function Trace
+- b1 : OS Function call trace
+- b2 : Critical section entry/exit
+- b3 : Memory allocation/destruction
+- b4 : Detailed information in Rx path
+- b5 : Detailed information in Tx path
+- b6 : Extended error information
+- b7 : General info
+*/
+static const char pszDebug[]        = "debug";
+/** CPU Frequency. */
+/*static const char pszCpuFreq[]      = "CpuFreq";*/               /*MJH-030403*/
+/** Base address for the module. */
+static const char pszBase[]         = "base";
+/** Reset bit for the module. */
+static const char pszResetBit[]     = "reset_bit";
+/** Reset base address for the module. */
+static const char pszResetBase[]    = "ResetBase";
+/** Interrupt line for the module. */
+static const char pszIntLine[]      = "int_line";
+/** VLYNQ offset for the module.  Disregard if not using VLYNQ. */
+static const char pszOffset[]       = "offset";
+/** The OS may "Get" this parameter, which is a pointer
+    to a character string that indicates the version of CPHAL. */
+static const char pszVer[]          = "Version";
+/*@}*/
+
+/**
+@defgroup Common_Control_Params Common Keys for [os]Control()
+
+This section documents the keys used with the OS @c Control() interface that
+are required by CPHAL devices.
+
+@{
+*/
+/** Used to wait for an integer number of clock ticks, given as an integer
+    pointer in the @p Value parameter.  No actions are defined. */
+static const char pszSleep[]             = "Sleep";
+/** Requests the OS to flush it's IO buffers.  No actions are defined. */
+static const char pszSioFlush[]          = "SioFlush";
+/*@}*/
+
+static const char pszStateChange[]       = "StateChange";
+static const char pszStatus[]            = "Status";
+
+static const char pszGET[]               = "Get";
+static const char pszSET[]               = "Set";
+static const char pszCLEAR[]             = "Clear";
+static const char pszNULL[]              = "";
+static const char pszLocator[]           = "Locator";
+static const char pszOff[]               = "Off";
+static const char pszOn[]                = "On";
+static const char hcMaxFrags[]           = "MaxFrags";
+
+#ifdef _CPHAL_CPMAC
+
+/*  New method for string constants */
+const char hcClear[]  = "Clear";
+const char hcGet[]    = "Get";
+const char hcSet[]    = "Set";
+
+const char hcTick[]   = "Tick";
+
+static const CONTROL_KEY KeyCommon[] =
+   {
+     {""                   , enCommonStart},
+     {pszStatus            , enStatus},
+     {pszOff               , enOff},
+     {pszOn                , enOn},
+     {pszDebug             , enDebug},
+     {hcCpuFrequency       , enCpuFreq},                           /*MJH~030403*/
+     {""                   , enCommonEnd}
+   };
+#endif
+
+/**
+@defgroup Common_Statistics Statistics
+
+A broad array of module statistics is available.  Statistics values are accessed
+through the @c Control() interface of the CPHAL.  There are 5 different levels
+of statistics, each of which correspond to a unique set of data.  Furthermore,
+certain statistics data is indexed by using a channel number and Tx queue number.
+The following is a brief description of each statistics level, along with the
+indexes used for the level:
+
+- Level 0:  Hardware Statistics (index with channel)
+- Level 1:  CPHAL Software Statistics (channel, queue)
+- Level 2:  CPHAL Flags (channel, queue)
+- Level 3:  CPHAL Channel Configuration (channel)
+- Level 4:  CPHAL General Configuration (no index)
+
+The caller requests statistics information by providing a Key string to the
+@c Control() API in the following format: "Stats;[Level #];[Ch #];[Queue #]".
+The only valid Action parameter for statistics usage is "Get".
+
+Code Examples:
+@code
+unsigned int *StatsData;
+
+# Get Level 0 stats for Channel 1
+HalFunc->Control(OsDev->HalDev, "Stats;0;1", "Get", &StatsData);
+
+# Get Level 2 stats for Channel 0, Queue 0
+HalFunc->Control(OsDev->HalDev, "Stats;2;0;0", "Get", &StatsData);
+
+# Get Level 4 stats
+HalFunc->Control(OsDev->HalDev, "Stats;4", "Get", &StatsData);
+@endcode
+
+The information returned in the Value parameter of @c Control() is an
+array of pointers to strings.  The pointers are arranged in pairs.
+The first pointer is a pointer to a name string for a particular statistic.
+The next pointer is a pointer to a string containing the representation of
+the integer statistic value corresponding to the first pointer.  This is followed
+by another pair of pointers, and so on, until a NULL pointer is encountered.  The
+following is example code for processing the statistics data.  Note that the OS
+is responsible for freeing the memory passed back through the Value parameter of
+@c Control().
+
+@code
+unsigned int *StatsData;
+
+# Get Level 0 stats for Channel 1
+HalFunc->Control(OsDev->HalDev, "Stats;0;1", "Get", &StatsData);
+
+# output Statistics data
+PrintStats(StatsData);
+
+# the upper layer is responsible for freeing stats info
+free(&StatsPtr);
+
+...
+
+void PrintStats(unsigned int *StatsPtr)
+  {
+   while(*StatsPtr)
+     {
+      printf("%20s:",  (char *)*StatsPtr);
+      StatsPtr++;
+      printf("%11s\n", (char *)*StatsPtr);
+      StatsPtr++;
+     }
+   MySioFlush();
+  }
+@endcode
+
+Within each statistics level, there are several statistics defined.  The statistics that
+are common to every CPPI module are listed below.  In addition, each module may define
+extra statistics in each level, which will be documented within the module-specific
+documentation appendices.
+
+- Level 0 Statistics
+  - All level 0 statistics are module-specific.
+- Level 1 Statistics (CPHAL Software Statistics)
+  - DmaLenErrors: Incremented when the port DMA's more data than expected (per channel). (AAL5 Only)
+  - TxMisQCnt: Incremented when host queues a packet for transmission as the port finishes
+transmitting the previous last packet in the queue (per channel and queue).
+  - RxMisQCnt: Incremented when host queues adds buffers to a queue as the port finished the
+reception of the previous last packet in the queue (per channel).
+  - TxEOQCnt: Number of times the port has reached the end of the transmit queue (per channel and queue).
+  - RxEOQCnt: Number of times the port has reached the end of the receive queue (per channel).
+  - RxPacketsServiced: Number of received packets (per channel).
+  - TxPacketsServiced: Number of transmitted packets (per channel and queue).
+  - RxMaxServiced: Maximum number of packets that the CPHAL receive interrupt has serviced at a time (per channel).
+  - TxMaxServiced: Maximum number of packets that the CPHAL transmit interrupt has serviced at a time (per channel and queue).
+  - RxTotal: Total number of received packets, all channels.
+  - TxTotal: Total number of transmitted packets, all channels and queues.
+- Level 2 Statistics (CPHAL Flags)
+  - RcbPool: Pointer to receive descriptor pool (per channel).
+  - RxActQueueCount: Number of buffers currently available for receive (per channel).
+  - RxActQueueHead: Pointer to first buffer in receive queue (per channel).
+  - RxActQueueTail: Pointer to last buffer in receive queue (per channel).
+  - RxActive: 0 if inactive (no buffers available), or 1 if active (buffers available).
+  - RcbStart: Pointer to block of receive descriptors.
+  - RxTeardownPending: 1 if Rx teardown is pending but incomplete, 0 otherwise.
+  - TcbPool: Pointer to transmit descriptor pool (per channel and queue).
+  - TxActQueueCount: Number of buffers currently queued to be transmitted (per channel and queue).
+  - TxActQueueHead: Pointer to first buffer in transmit queue (per channel and queue).
+  - TxActQueueTail: Pointer to last buffer in transmit queue (per channel and queue).
+  - TxActive: 0 if inactive (no buffers to send), or 1 if active (buffers queued to send).
+  - TcbStart: Pointer to block of transmit descriptors.
+  - TxTeardownPending: 1 if Tx teardown is pending but incomplete, 0 otherwise.
+- Level 3 Statistics (CPHAL Channel Configuration)
+  - RxBufSize: Rx buffer size.
+  - RxBufferOffset: Rx buffer offset.
+  - RxNumBuffers: Number of Rx buffers.
+  - RxServiceMax: Maximum number of receive packets to service at a time.
+  - TxNumBuffers: Number of Tx buffer descriptors.
+  - TxNumQueues: Number of Tx queues to use.
+  - TxServiceMax: Maximum number of transmit packets to service at a time.
+- Level 4 Statistics (CPHAL General Configuration)
+  - Base Address: Base address of the module.
+  - Offset (VLYNQ): VLYNQ relative module offset.
+  - Interrupt Line: Interrupt number.
+  - Debug: Debug flag, 1 to enable debug.
+  - Inst: Instance number.
+*/
+
+/* 
+   Data Type 0 = int display
+   Data Type 1 = hex display
+   Data Type 2 = channel structure, int display
+   Data Type 3 = queue index and int display
+   Data Type 4 = queue index and hex display
+*/
+#if (defined(_CPHAL_AAL5) || defined(_CPHAL_CPMAC)) /* +GSG 030307 */
+static STATS_TABLE StatsTable0[] =
+  {
+#ifdef _CPHAL_AAL5
+   /* Name ,        Data Ptr,   Data Type */
+   {"Crc Errors",          0,          0},
+   {"Len Errors",          0,          0},
+   {"Abort Errors",        0,          0},
+   {"Starv Errors",        0,          0}
+#endif
+#ifdef _CPHAL_CPMAC
+   {"Rx Good Frames",      0,          0}
+#endif
+  };
+
+static STATS_TABLE StatsTable1[] =
+  {
+   /* Name ,        Data Ptr,   Data Type */
+   {"DmaLenErrors",        0,          0},
+   {"TxMisQCnt",           0,          3},
+   {"RxMisQCnt",           0,          0},
+   {"TxEOQCnt",            0,          3},
+   {"RxEOQCnt",            0,          0},
+   {"RxPacketsServiced",   0,          0},
+   {"TxPacketsServiced",   0,          3},
+   {"RxMaxServiced",       0,          0},
+   {"TxMaxServiced",       0,          3},
+   {"RxTotal",             0,          0},
+   {"TxTotal",             0,          0},
+  };
+
+static STATS_TABLE StatsTable2[] =
+  {
+   /* Name ,        Data Ptr,   Data Type */
+   {"RcbPool",             0,          1},
+   {"RxActQueueCount",     0,          0},
+   {"RxActQueueHead",      0,          1},
+   {"RxActQueueTail",      0,          1},
+   {"RxActive",            0,          0},
+   {"RcbStart",            0,          1},
+   {"RxTeardownPending",   0,          0},
+   {"TcbPool",             0,          4},
+   {"TxActQueueCount",     0,          3},
+   {"TxActQueueHead",      0,          4},
+   {"TxActQueueTail",      0,          4},
+   {"TxActive",            0,          3},
+   {"TcbStart",            0,          4},
+   {"TxTeardownPending",   0,          0}
+  };
+
+static STATS_TABLE StatsTable3[] =
+  {
+   /* Name ,        Data Ptr,   Data Type */
+   {"RxBufSize",           0,          2},
+   {"RxBufferOffset",      0,          2},
+   {"RxNumBuffers",        0,          2},
+   {"RxServiceMax",        0,          2},
+   {"TxNumBuffers",        0,          2},
+   {"TxNumQueues",         0,          2},
+   {"TxServiceMax",        0,          2},
+#ifdef _CPHAL_AAL5
+   {"CpcsUU",              0,          2},
+   {"Gfc",                 0,          2},
+   {"Clp",                 0,          2},
+   {"Pti",                 0,          2},
+   {"DaMask",              0,          2},
+   {"Priority",            0,          2},
+   {"PktType",             0,          2},
+   {"Vci",                 0,          2},
+   {"Vpi",                 0,          2},
+   {"CellRate",            0,          2},
+   {"QosType",             0,          2},
+   {"Mbs",                 0,          2},
+   {"Pcr",                 0,          2}
+#endif
+  };
+
+static STATS_TABLE StatsTable4[] =
+  {
+   {"Base Address",        0,          1},
+   {"Offset (VLYNQ)",      0,          0},
+   {"Interrupt Line",      0,          0},
+   {"Debug",               0,          0},
+   {"Instance",            0,          0},
+#ifdef _CPHAL_AAL5
+   {"UniNni",              0,          0}
+#endif
+  };
+
+static STATS_DB StatsDb[] =
+  {
+    {(sizeof(StatsTable0)/sizeof(STATS_TABLE)), StatsTable0},
+    {(sizeof(StatsTable1)/sizeof(STATS_TABLE)), StatsTable1},
+    {(sizeof(StatsTable2)/sizeof(STATS_TABLE)), StatsTable2},
+    {(sizeof(StatsTable3)/sizeof(STATS_TABLE)), StatsTable3},
+    {(sizeof(StatsTable4)/sizeof(STATS_TABLE)), StatsTable4}
+  };
+#endif /* +GSG 030307 */
+
+#ifdef _CPHAL_CPMAC /* +RC 3.02 */
+static void resetWait(HAL_DEVICE *HalDev)
+  {                                                                  /*+RC3.02*/
+  const int TickReset=64;
+  osfuncSleep((int*)&TickReset);
+  }                                                                  /*+RC3.02*/
+#endif /* +RC 3.02 */
+
+/* I only define the reset base function for the modules
+   that can perform a reset.  The AAL5 and AAL2 modules
+   do not perform a reset, that is done by the shared module
+   CPSAR */
+#if defined(_CPHAL_CPSAR) || defined(_CPHAL_CPMAC) || defined(_CPHAL_VDMAVT)
+/*
+ *  Determines the reset register address to be used for a particular device.
+ *  It will search the current device entry for Locator information.  If the
+ *  device is a root device, there will be no Locator information, and the
+ *  function will find and return the root reset register.  If a Locator value
+ *  is found, the function will search each VLYNQ device entry in the system
+ *  looking for a matching Locator.  Once it finds a VLYNQ device entry with
+ *  a matching Locator, it will extract the "ResetBase" parameter from that
+ *  VLYNQ device entry (thus every VLYNQ entry must have the ResetBase parameter).
+ *
+ *  @param  HalDev   CPHAL module instance. (set by xxxInitModule())
+ *  @param  ResetBase Pointer to integer address of reset register.
+ *
+ *  @return 0 OK, Non-zero not OK
+ */
+static int ResetBaseGet(HAL_DEVICE *HalDev, bit32u *ResetBase)
+  {
+   char *DeviceInfo = HalDev->DeviceInfo;
+   char *MyLocator, *NextLocator;
+   int Inst=1;
+   bit32u error_code;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpcommon]ResetBaseGet(HalDev:%08x, ResetBase:%08x)\n", (bit32u)HalDev, ResetBase);
+      osfuncSioFlush();
+     }
+#endif
+
+   error_code = HalDev->OsFunc->DeviceFindParmValue(DeviceInfo, "Locator", &MyLocator);
+   if (error_code)
+     {
+      /* if no Locator value, device is on the root, so get the "reset" device */
+      error_code = HalDev->OsFunc->DeviceFindInfo(0, "reset", &DeviceInfo);
+      if  (error_code)
+        {
+         return(EC_VAL_DEVICE_NOT_FOUND);
+        }
+
+      error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, "base", ResetBase);
+      if (error_code)
+        {
+         return(EC_VAL_BASE_ADDR_NOT_FOUND);
+        }
+
+      *ResetBase = ((bit32u)PhysToVirtNoCache(*ResetBase));
+
+      /* found base address for root device, so we're done */
+      return (EC_NO_ERRORS);
+     }
+    else
+     {
+      /* we have a Locator value, so the device is remote */
+
+      /* Find a vlynq device with a matching locator value */
+      while ((HalDev->OsFunc->DeviceFindInfo(Inst, "vlynq", &DeviceInfo)) == EC_NO_ERRORS)
+        {
+         error_code = HalDev->OsFunc->DeviceFindParmValue(DeviceInfo, "Locator", &NextLocator);
+         if (error_code)
+           {
+            /* no Locator value for this VLYNQ, so move on */
+            continue;
+           }
+         if (HalDev->OsFunc->Strcmpi(MyLocator, NextLocator)==0)
+           {
+            /* we have found a VLYNQ with a matching Locator, so extract the ResetBase */
+            error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, "ResetBase", ResetBase);
+            if (error_code)
+              {
+               return(EC_VAL_BASE_ADDR_NOT_FOUND);
+              }
+            *ResetBase = ((bit32u)PhysToVirtNoCache(*ResetBase));
+
+            /* found base address for root device, so we're done */
+            return (EC_NO_ERRORS);
+           }
+         Inst++;
+        } /* while */
+     } /* else */
+
+   return (EC_NO_ERRORS);
+  }
+#endif
+
+#ifndef _CPHAL_AAL2 /* + RC 3.02 */
+static bit32u ConfigGetCommon(HAL_DEVICE *HalDev)
+  {
+   bit32u ParmValue;
+   bit32 error_code;
+   char *DeviceInfo = HalDev->DeviceInfo;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpcommon]ConfigGetCommon(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszBase, &ParmValue);
+   if (error_code)
+     {
+      return(EC_FUNC_HAL_INIT|EC_VAL_BASE_ADDR_NOT_FOUND);
+     }
+   HalDev->dev_base = ((bit32u)PhysToVirtNoCache(ParmValue));
+
+#ifndef _CPHAL_AAL5
+#ifndef _CPHAL_AAL2
+   error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszResetBit, &ParmValue);
+   if(error_code)
+     {
+      return(EC_FUNC_HAL_INIT|EC_VAL_RESET_BIT_NOT_FOUND);
+     }
+   HalDev->ResetBit = ParmValue;
+
+   /* Get reset base address */
+   error_code = ResetBaseGet(HalDev, &ParmValue);
+   if (error_code)
+     return(EC_FUNC_HAL_INIT|EC_VAL_RESET_BASE_NOT_FOUND);
+   HalDev->ResetBase = ParmValue;
+#endif
+#endif
+
+#ifndef _CPHAL_CPSAR
+   error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszIntLine,&ParmValue);
+   if (error_code)
+     {
+      return(EC_FUNC_HAL_INIT|EC_VAL_INTERRUPT_NOT_FOUND);
+     }
+   HalDev->interrupt = ParmValue;
+#endif
+
+   /* only look for the offset if there is a Locator field, which indicates that
+      the module is a VLYNQ module */
+   error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszLocator,&ParmValue);
+   if (!error_code)
+     {
+      error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszOffset,&ParmValue);
+      if (error_code)
+        {
+         return(EC_FUNC_HAL_INIT|EC_VAL_OFFSET_NOT_FOUND);
+        }
+      HalDev->offset = ParmValue;
+     }
+    else
+      HalDev->offset = 0;
+
+   error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszDebug, &ParmValue);
+   if (!error_code) HalDev->debug = ParmValue;
+
+   return (EC_NO_ERRORS);
+  }
+#endif /* +RC 3.02 */
+
+#ifdef _CPHAL_CPMAC /* +RC 3.02 */
+static void StatsInit(HAL_DEVICE *HalDev)                             /* +() RC3.02 */
+  {
+   /* even though these statistics may be for multiple channels and
+      queues, i need only configure the pointer to the beginning
+      of the array, and I can index from there if necessary */
+
+#ifdef _CPHAL_AAL5
+   StatsTable0[0].StatPtr  = &HalDev->Stats.CrcErrors[0];
+   StatsTable0[1].StatPtr  = &HalDev->Stats.LenErrors[0];
+   StatsTable0[2].StatPtr  = &HalDev->Stats.AbortErrors[0];
+   StatsTable0[3].StatPtr  = &HalDev->Stats.StarvErrors[0];
+
+   StatsTable1[0].StatPtr  = &HalDev->Stats.DmaLenErrors[0];
+   StatsTable1[1].StatPtr  = &HalDev->Stats.TxMisQCnt[0][0];
+   StatsTable1[2].StatPtr  = &HalDev->Stats.RxMisQCnt[0];
+   StatsTable1[3].StatPtr  = &HalDev->Stats.TxEOQCnt[0][0];
+   StatsTable1[4].StatPtr  = &HalDev->Stats.RxEOQCnt[0];
+   StatsTable1[5].StatPtr  = &HalDev->Stats.RxPacketsServiced[0];
+   StatsTable1[6].StatPtr  = &HalDev->Stats.TxPacketsServiced[0][0];
+   StatsTable1[7].StatPtr  = &HalDev->Stats.RxMaxServiced;
+   StatsTable1[8].StatPtr  = &HalDev->Stats.TxMaxServiced[0][0];
+   StatsTable1[9].StatPtr  = &HalDev->Stats.RxTotal;
+   StatsTable1[10].StatPtr = &HalDev->Stats.TxTotal;
+#endif
+
+#if (defined(_CPHAL_AAL5) || defined(_CPHAL_CPMAC))
+   StatsTable2[0].StatPtr  = (bit32u *)&HalDev->RcbPool[0];
+   StatsTable2[1].StatPtr  = &HalDev->RxActQueueCount[0];
+   StatsTable2[2].StatPtr  = (bit32u *)&HalDev->RxActQueueHead[0];
+   StatsTable2[3].StatPtr  = (bit32u *)&HalDev->RxActQueueTail[0];
+   StatsTable2[4].StatPtr  = &HalDev->RxActive[0];
+   StatsTable2[5].StatPtr  = (bit32u *)&HalDev->RcbStart[0];
+   StatsTable2[6].StatPtr  = &HalDev->RxTeardownPending[0];
+   StatsTable2[7].StatPtr  = (bit32u *)&HalDev->TcbPool[0][0];
+   StatsTable2[8].StatPtr  = &HalDev->TxActQueueCount[0][0];
+   StatsTable2[9].StatPtr  = (bit32u *)&HalDev->TxActQueueHead[0][0];
+   StatsTable2[10].StatPtr = (bit32u *)&HalDev->TxActQueueTail[0][0];
+   StatsTable2[11].StatPtr = &HalDev->TxActive[0][0];
+   StatsTable2[12].StatPtr = (bit32u *)&HalDev->TcbStart[0][0];
+   StatsTable2[13].StatPtr = &HalDev->TxTeardownPending[0];
+
+   StatsTable3[0].StatPtr  = &HalDev->ChData[0].RxBufSize;
+   StatsTable3[1].StatPtr  = &HalDev->ChData[0].RxBufferOffset;
+   StatsTable3[2].StatPtr  = &HalDev->ChData[0].RxNumBuffers;
+   StatsTable3[3].StatPtr  = &HalDev->ChData[0].RxServiceMax;
+   StatsTable3[4].StatPtr  = &HalDev->ChData[0].TxNumBuffers;
+   StatsTable3[5].StatPtr  = &HalDev->ChData[0].TxNumQueues;
+   StatsTable3[6].StatPtr  = &HalDev->ChData[0].TxServiceMax;
+#ifdef _CPHAL_AAL5
+   StatsTable3[7].StatPtr  = &HalDev->ChData[0].CpcsUU;
+   StatsTable3[8].StatPtr  = &HalDev->ChData[0].Gfc;
+   StatsTable3[9].StatPtr  = &HalDev->ChData[0].Clp;
+   StatsTable3[10].StatPtr = &HalDev->ChData[0].Pti;
+   StatsTable3[11].StatPtr = &HalDev->ChData[0].DaMask;
+   StatsTable3[12].StatPtr = &HalDev->ChData[0].Priority;
+   StatsTable3[13].StatPtr = &HalDev->ChData[0].PktType;
+   StatsTable3[14].StatPtr = &HalDev->ChData[0].Vci;
+   StatsTable3[15].StatPtr = &HalDev->ChData[0].Vpi;
+   StatsTable3[16].StatPtr = &HalDev->ChData[0].TxVc_CellRate;
+   StatsTable3[17].StatPtr = &HalDev->ChData[0].TxVc_QosType;
+   StatsTable3[18].StatPtr = &HalDev->ChData[0].TxVc_Mbs;
+   StatsTable3[19].StatPtr = &HalDev->ChData[0].TxVc_Pcr;
+#endif
+#endif
+
+   StatsTable4[0].StatPtr  = &HalDev->dev_base;
+   StatsTable4[1].StatPtr  = &HalDev->offset;
+   StatsTable4[2].StatPtr  = &HalDev->interrupt;
+   StatsTable4[3].StatPtr  = &HalDev->debug;
+   StatsTable4[4].StatPtr  = &HalDev->Inst;
+  }
+#endif /* +RC 3.02 */
+
+#ifndef _CPHAL_CPSAR /* +RC 3.02 */
+#ifndef _CPHAL_AAL2 /* +RC 3.02 */
+/*
+ *  Returns statistics information.
+ *
+ *  @param  HalDev   CPHAL module instance. (set by xxxInitModule())
+ *
+ *  @return 0
+ */
+static int StatsGet(HAL_DEVICE *HalDev, void **StatPtr, int Index, int Ch, int Queue)
+  {
+   int Size;
+   bit32u *AddrPtr;
+   char *DataPtr;
+   STATS_TABLE *StatsTable;
+   int i, NumberOfStats;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpcommon]StatsGet(HalDev:%08x, StatPtr:%08x)\n",
+                (bit32u)HalDev, (bit32u)StatPtr);
+      osfuncSioFlush();
+     }
+#endif
+
+   StatsTable = StatsDb[Index].StatTable;
+   NumberOfStats = StatsDb[Index].NumberOfStats;
+
+   Size = sizeof(bit32u)*((NumberOfStats*2)+1);
+   Size += (NumberOfStats*11);
+   *StatPtr = (bit32u *)HalDev->OsFunc->Malloc(Size);
+
+   AddrPtr = (bit32u *) *StatPtr;
+   DataPtr = (char *)AddrPtr;
+   DataPtr += sizeof(bit32u)*((NumberOfStats*2)+1);
+
+   for (i=0; i<NumberOfStats; i++)
+     {
+      *AddrPtr++ = (bit32u)StatsTable[i].StatName;
+      *AddrPtr++ = (bit32u)DataPtr;
+      if (&StatsTable[i].StatPtr[Ch] != 0)
+        {
+         switch(StatsTable[i].DataType)
+           {
+            case 0:
+              HalDev->OsFunc->Sprintf(DataPtr, "%d", (bit32u *)StatsTable[i].StatPtr[Ch]);
+              break;
+            case 1:
+              HalDev->OsFunc->Sprintf(DataPtr, "0x%x", (bit32u *)StatsTable[i].StatPtr[Ch]);
+              break;
+            case 2:
+              HalDev->OsFunc->Sprintf(DataPtr, "%d", *((bit32u *)StatsTable[i].StatPtr + (Ch * (sizeof(CHANNEL_INFO)/4))));
+              break;
+            case 3:
+              HalDev->OsFunc->Sprintf(DataPtr, "%d", *((bit32u *)StatsTable[i].StatPtr + (Ch*MAX_QUEUE)+Queue));
+              break;
+            case 4:
+              HalDev->OsFunc->Sprintf(DataPtr, "0x%x", *((bit32u *)StatsTable[i].StatPtr + (Ch*MAX_QUEUE)+Queue));
+              break;
+            default:
+              /* invalid data type, due to CPHAL programming error */
+              break;
+           }
+        }
+       else
+        {
+         /* invalid statistics pointer, probably was not initialized */
+        }
+      DataPtr += HalDev->OsFunc->Strlen(DataPtr) + 1;
+     }
+
+   *AddrPtr = (bit32u) 0;
+
+   return (EC_NO_ERRORS);
+  }
+#endif /* +RC 3.02 */
+#endif /* +RC 3.02 */
+
+#ifdef _CPHAL_CPMAC
+static void gpioFunctional(int base, int bit)
+  {                                                                  /*+RC3.02*/
+  bit32u GpioEnr = base + 0xC;
+  /*  To make functional, set to zero  */
+  *(volatile bit32u *)(GpioEnr) &= ~(1 << bit);                      /*+RC3.02*/
+  }                                                                  /*+RC3.02*/
+
+
+/*+RC3.02*/
+/* Common function, Checks to see if GPIO should be in functional mode */
+static void gpioCheck(HAL_DEVICE *HalDev, void *moduleDeviceInfo)
+  {                                                                  /*+RC3.02*/
+  int rc;
+  void *DeviceInfo;
+  char *pszMuxBits;
+  char pszMuxBit[20];
+  char *pszTmp;
+  char szMuxBit[20];
+  char *ptr;
+  int base;
+  int reset_bit;
+  int bit;
+  OS_FUNCTIONS *OsFunc = HalDev->OsFunc;
+
+  rc = OsFunc->DeviceFindParmValue(moduleDeviceInfo, "gpio_mux",&pszTmp);
+  if(rc) return;
+  /*  gpio entry found, get GPIO register info and make functional  */
+
+  /* temp copy until FinParmValue fixed */
+  ptr = &szMuxBit[0];
+  while ((*ptr++ = *pszTmp++));
+
+  pszMuxBits = &szMuxBit[0];
+
+  rc = OsFunc->DeviceFindInfo(0,"gpio",&DeviceInfo);
+  if(rc) return;
+
+  rc = OsFunc->DeviceFindParmUint(DeviceInfo, "base",&base);
+  if(rc) return;
+
+  rc = OsFunc->DeviceFindParmUint(DeviceInfo, "reset_bit",&reset_bit);
+  if(rc) return;
+
+  /* If GPIO still in reset, then exit  */
+  if((VOLATILE32(HalDev->ResetBase) & (1 << reset_bit)) == 0)
+    return;
+  /*  format for gpio_mux is  gpio_mux = <int>;<int>;<int>...*/
+  while (*pszMuxBits)
+    {
+    pszTmp = &pszMuxBit[0];
+    if(*pszMuxBits == ';') pszMuxBits++;
+    while ((*pszMuxBits != ';') && (*pszMuxBits != '\0'))
+      {
+      osfuncSioFlush();
+      /*If value not a number, skip */
+      if((*pszMuxBits < '0') || (*pszMuxBits > '9'))
+        pszMuxBits++;
+      else
+        *pszTmp++ = *pszMuxBits++;
+      }
+    *pszTmp = '\0';
+    bit = OsFunc->Strtoul(pszMuxBit, &pszTmp, 10);
+    gpioFunctional(base, bit);
+    resetWait(HalDev);  /* not sure if this is needed */
+    }
+  }                                                                  /*+RC3.02*/
+#endif  /* CPMAC  */
+
+#ifdef _CPHAL_AAL5
+const char hcSarFrequency[] = "SarFreq";
+#endif
+
+#endif  /* _INC  */
diff -urN linux.old/drivers/atm/sangam_atm/cpcommon_cpaal5.h linux.dev/drivers/atm/sangam_atm/cpcommon_cpaal5.h
--- linux.old/drivers/atm/sangam_atm/cpcommon_cpaal5.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cpcommon_cpaal5.h	2005-08-23 04:46:50.082845976 +0200
@@ -0,0 +1,79 @@
+#ifndef _INC_CPCOMMON_H
+#define _INC_CPCOMMON_H
+
+#define VOLATILE32(addr)  (*(volatile bit32u *)(addr))
+#ifndef dbgPrintf
+#define dbgPrintf HalDev->OsFunc->Printf
+#endif
+
+#define ChannelUpdate(Field) if(HalChn->Field != 0xFFFFFFFF) HalDev->ChData[Ch].Field = HalChn->Field
+
+#define DBG(level)  (HalDev->debug & (1<<(level)))
+/*
+#define DBG0()      DBG(0)
+#define DBG1()      DBG(1)
+#define DBG2()      DBG(2)
+#define DBG3()      DBG(3)
+#define DBG4()      DBG(4)
+#define DBG5()      DBG(5)
+#define DBG6()      DBG(6)
+#define DBG7()      DBG(7)
+*/
+
+/*
+ *  List of defined actions for use with Control().
+ */
+typedef enum 
+  {
+   enGET=0,     /**< Get the value associated with a key */
+   enSET,       /**< Set the value associates with a key */
+   enCLEAR,     /**<Clear the value */ 
+   enNULL       /**< No data action, used to initiate a service or send a message */
+  }ACTION;
+
+/*
+ *  Enumerated hardware states.
+ */
+typedef enum
+  {
+   enConnected=1, enDevFound, enInitialized, enOpened
+  }DEVICE_STATE;
+
+typedef enum 
+  {
+   enCommonStart=0,
+   /* General  */
+   enOff, enOn, enDebug, 
+   /* Module General */
+   enCpuFreq, 
+   enStatus,
+   enCommonEnd
+   }COMMON_KEY;
+
+typedef struct
+  {
+   const char  *strKey;
+   int  enKey;
+  }CONTROL_KEY;
+
+typedef struct
+  {
+   char *StatName;
+   unsigned int *StatPtr;
+   int DataType; /* 0: int, 1: hex int, 2:channel data */
+  }STATS_TABLE;
+
+typedef struct
+  {
+   int NumberOfStats;
+   STATS_TABLE *StatTable;
+  }STATS_DB;
+
+#define osfuncSioFlush()    HalDev->OsFunc->Control(HalDev->OsDev,"SioFlush",pszNULL,0)
+#define osfuncSleep(Ticks)  HalDev->OsFunc->Control(HalDev->OsDev,pszSleep,pszNULL,Ticks)
+#define osfuncStateChange() HalDev->OsFunc->Control(HalDev->OsDev,pszStateChange,pszNULL,0)
+
+#define CHANNEL_NAMES {"Ch0","Ch1","Ch2","Ch3","Ch4","Ch5","Ch6","Ch7","Ch8","Ch9","Ch10","Ch11","Ch12","Ch13","Ch14","Ch15"}
+
+#endif
+
diff -urN linux.old/drivers/atm/sangam_atm/cpcommon_cpsar.c linux.dev/drivers/atm/sangam_atm/cpcommon_cpsar.c
--- linux.old/drivers/atm/sangam_atm/cpcommon_cpsar.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cpcommon_cpsar.c	2005-08-23 04:46:50.082845976 +0200
@@ -0,0 +1,728 @@
+#ifndef _INC_CPCOMMON_C
+#define _INC_CPCOMMON_C
+
+#ifdef _CPHAL_CPMAC
+#include "cpremap_cpmac.c"
+#endif
+
+#ifdef _CPHAL_AAL5
+#include "cpremap_cpaal5.c"
+#endif
+
+#ifdef _CPHAL_CPSAR
+#include "cpremap_cpsar.c"
+#endif
+
+#ifdef _CPHAL_AAL2
+#include "cpremap_cpaal2.c"
+#endif
+
+/**
+@defgroup Common_Config_Params Common Configuration Parameters
+
+This section documents the configuration parameters that are valid across
+all CPHAL devices.
+@{
+*/
+/** This is the debug level.  The field is bit defined, such that the user
+should set to 1 all the bits corresponding to desired debug outputs.  The following 
+are the meanings for each debug bit:
+- bit0 (LSB): CPHAL Function Trace
+- b1 : OS Function call trace
+- b2 : Critical section entry/exit
+- b3 : Memory allocation/destruction
+- b4 : Detailed information in Rx path
+- b5 : Detailed information in Tx path
+- b6 : Extended error information
+- b7 : General info
+*/
+static const char pszDebug[]        = "debug";
+/** CPU Frequency. */
+/*static const char pszCpuFreq[]      = "CpuFreq";*/               /*MJH-030403*/
+/** Base address for the module. */
+static const char pszBase[]         = "base";
+/** Reset bit for the module. */
+static const char pszResetBit[]     = "reset_bit";
+/** Reset base address for the module. */
+static const char pszResetBase[]    = "ResetBase";
+/** Interrupt line for the module. */
+static const char pszIntLine[]      = "int_line";
+/** VLYNQ offset for the module.  Disregard if not using VLYNQ. */
+static const char pszOffset[]       = "offset";
+/** The OS may "Get" this parameter, which is a pointer
+    to a character string that indicates the version of CPHAL. */
+static const char pszVer[]          = "Version";
+/*@}*/
+
+/**
+@defgroup Common_Control_Params Common Keys for [os]Control()
+
+This section documents the keys used with the OS @c Control() interface that
+are required by CPHAL devices.
+
+@{
+*/
+/** Used to wait for an integer number of clock ticks, given as an integer
+    pointer in the @p Value parameter.  No actions are defined. */
+static const char pszSleep[]             = "Sleep";
+/** Requests the OS to flush it's IO buffers.  No actions are defined. */
+static const char pszSioFlush[]          = "SioFlush";
+/*@}*/
+
+static const char pszStateChange[]       = "StateChange";
+static const char pszStatus[]            = "Status";
+
+static const char pszGET[]               = "Get";
+static const char pszSET[]               = "Set";
+static const char pszCLEAR[]             = "Clear";
+static const char pszNULL[]              = "";
+static const char pszLocator[]           = "Locator";
+static const char pszOff[]               = "Off";
+static const char pszOn[]                = "On";
+static const char hcMaxFrags[]           = "MaxFrags";
+
+#ifdef _CPHAL_CPMAC
+
+/*  New method for string constants */
+const char hcClear[]  = "Clear";
+const char hcGet[]    = "Get";
+const char hcSet[]    = "Set";
+
+const char hcTick[]   = "Tick";
+
+static const CONTROL_KEY KeyCommon[] =
+   {
+     {""                   , enCommonStart},
+     {pszStatus            , enStatus},
+     {pszOff               , enOff},
+     {pszOn                , enOn},
+     {pszDebug             , enDebug},
+     {hcCpuFrequency       , enCpuFreq},                           /*MJH~030403*/
+     {""                   , enCommonEnd}
+   };
+#endif
+
+/**
+@defgroup Common_Statistics Statistics
+
+A broad array of module statistics is available.  Statistics values are accessed
+through the @c Control() interface of the CPHAL.  There are 5 different levels
+of statistics, each of which correspond to a unique set of data.  Furthermore,
+certain statistics data is indexed by using a channel number and Tx queue number.
+The following is a brief description of each statistics level, along with the
+indexes used for the level:
+
+- Level 0:  Hardware Statistics (index with channel)
+- Level 1:  CPHAL Software Statistics (channel, queue)
+- Level 2:  CPHAL Flags (channel, queue)
+- Level 3:  CPHAL Channel Configuration (channel)
+- Level 4:  CPHAL General Configuration (no index)
+
+The caller requests statistics information by providing a Key string to the
+@c Control() API in the following format: "Stats;[Level #];[Ch #];[Queue #]".
+The only valid Action parameter for statistics usage is "Get".
+
+Code Examples:
+@code
+unsigned int *StatsData;
+
+# Get Level 0 stats for Channel 1
+HalFunc->Control(OsDev->HalDev, "Stats;0;1", "Get", &StatsData);
+
+# Get Level 2 stats for Channel 0, Queue 0
+HalFunc->Control(OsDev->HalDev, "Stats;2;0;0", "Get", &StatsData);
+
+# Get Level 4 stats
+HalFunc->Control(OsDev->HalDev, "Stats;4", "Get", &StatsData);
+@endcode
+
+The information returned in the Value parameter of @c Control() is an
+array of pointers to strings.  The pointers are arranged in pairs.
+The first pointer is a pointer to a name string for a particular statistic.
+The next pointer is a pointer to a string containing the representation of
+the integer statistic value corresponding to the first pointer.  This is followed
+by another pair of pointers, and so on, until a NULL pointer is encountered.  The
+following is example code for processing the statistics data.  Note that the OS
+is responsible for freeing the memory passed back through the Value parameter of
+@c Control().
+
+@code
+unsigned int *StatsData;
+
+# Get Level 0 stats for Channel 1
+HalFunc->Control(OsDev->HalDev, "Stats;0;1", "Get", &StatsData);
+
+# output Statistics data
+PrintStats(StatsData);
+
+# the upper layer is responsible for freeing stats info
+free(&StatsPtr);
+
+...
+
+void PrintStats(unsigned int *StatsPtr)
+  {
+   while(*StatsPtr)
+     {
+      printf("%20s:",  (char *)*StatsPtr);
+      StatsPtr++;
+      printf("%11s\n", (char *)*StatsPtr);
+      StatsPtr++;
+     }
+   MySioFlush();
+  }
+@endcode
+
+Within each statistics level, there are several statistics defined.  The statistics that
+are common to every CPPI module are listed below.  In addition, each module may define
+extra statistics in each level, which will be documented within the module-specific
+documentation appendices.
+
+- Level 0 Statistics
+  - All level 0 statistics are module-specific.
+- Level 1 Statistics (CPHAL Software Statistics)
+  - DmaLenErrors: Incremented when the port DMA's more data than expected (per channel). (AAL5 Only)
+  - TxMisQCnt: Incremented when host queues a packet for transmission as the port finishes
+transmitting the previous last packet in the queue (per channel and queue).
+  - RxMisQCnt: Incremented when host queues adds buffers to a queue as the port finished the
+reception of the previous last packet in the queue (per channel).
+  - TxEOQCnt: Number of times the port has reached the end of the transmit queue (per channel and queue).
+  - RxEOQCnt: Number of times the port has reached the end of the receive queue (per channel).
+  - RxPacketsServiced: Number of received packets (per channel).
+  - TxPacketsServiced: Number of transmitted packets (per channel and queue).
+  - RxMaxServiced: Maximum number of packets that the CPHAL receive interrupt has serviced at a time (per channel).
+  - TxMaxServiced: Maximum number of packets that the CPHAL transmit interrupt has serviced at a time (per channel and queue).
+  - RxTotal: Total number of received packets, all channels.
+  - TxTotal: Total number of transmitted packets, all channels and queues.
+- Level 2 Statistics (CPHAL Flags)
+  - RcbPool: Pointer to receive descriptor pool (per channel).
+  - RxActQueueCount: Number of buffers currently available for receive (per channel).
+  - RxActQueueHead: Pointer to first buffer in receive queue (per channel).
+  - RxActQueueTail: Pointer to last buffer in receive queue (per channel).
+  - RxActive: 0 if inactive (no buffers available), or 1 if active (buffers available).
+  - RcbStart: Pointer to block of receive descriptors.
+  - RxTeardownPending: 1 if Rx teardown is pending but incomplete, 0 otherwise.
+  - TcbPool: Pointer to transmit descriptor pool (per channel and queue).
+  - TxActQueueCount: Number of buffers currently queued to be transmitted (per channel and queue).
+  - TxActQueueHead: Pointer to first buffer in transmit queue (per channel and queue).
+  - TxActQueueTail: Pointer to last buffer in transmit queue (per channel and queue).
+  - TxActive: 0 if inactive (no buffers to send), or 1 if active (buffers queued to send).
+  - TcbStart: Pointer to block of transmit descriptors.
+  - TxTeardownPending: 1 if Tx teardown is pending but incomplete, 0 otherwise.
+- Level 3 Statistics (CPHAL Channel Configuration)
+  - RxBufSize: Rx buffer size.
+  - RxBufferOffset: Rx buffer offset.
+  - RxNumBuffers: Number of Rx buffers.
+  - RxServiceMax: Maximum number of receive packets to service at a time.
+  - TxNumBuffers: Number of Tx buffer descriptors.
+  - TxNumQueues: Number of Tx queues to use.
+  - TxServiceMax: Maximum number of transmit packets to service at a time.
+- Level 4 Statistics (CPHAL General Configuration)
+  - Base Address: Base address of the module.
+  - Offset (VLYNQ): VLYNQ relative module offset.
+  - Interrupt Line: Interrupt number.
+  - Debug: Debug flag, 1 to enable debug.
+  - Inst: Instance number.
+*/
+
+/* 
+   Data Type 0 = int display
+   Data Type 1 = hex display
+   Data Type 2 = channel structure, int display
+   Data Type 3 = queue index and int display
+   Data Type 4 = queue index and hex display
+*/
+#if (defined(_CPHAL_AAL5) || defined(_CPHAL_CPMAC)) /* +GSG 030307 */
+static STATS_TABLE StatsTable0[] =
+  {
+#ifdef _CPHAL_AAL5
+   /* Name ,        Data Ptr,   Data Type */
+   {"Crc Errors",          0,          0},
+   {"Len Errors",          0,          0},
+   {"Abort Errors",        0,          0},
+   {"Starv Errors",        0,          0}
+#endif
+#ifdef _CPHAL_CPMAC
+   {"Rx Good Frames",      0,          0}
+#endif
+  };
+
+static STATS_TABLE StatsTable1[] =
+  {
+   /* Name ,        Data Ptr,   Data Type */
+   {"DmaLenErrors",        0,          0},
+   {"TxMisQCnt",           0,          3},
+   {"RxMisQCnt",           0,          0},
+   {"TxEOQCnt",            0,          3},
+   {"RxEOQCnt",            0,          0},
+   {"RxPacketsServiced",   0,          0},
+   {"TxPacketsServiced",   0,          3},
+   {"RxMaxServiced",       0,          0},
+   {"TxMaxServiced",       0,          3},
+   {"RxTotal",             0,          0},
+   {"TxTotal",             0,          0},
+  };
+
+static STATS_TABLE StatsTable2[] =
+  {
+   /* Name ,        Data Ptr,   Data Type */
+   {"RcbPool",             0,          1},
+   {"RxActQueueCount",     0,          0},
+   {"RxActQueueHead",      0,          1},
+   {"RxActQueueTail",      0,          1},
+   {"RxActive",            0,          0},
+   {"RcbStart",            0,          1},
+   {"RxTeardownPending",   0,          0},
+   {"TcbPool",             0,          4},
+   {"TxActQueueCount",     0,          3},
+   {"TxActQueueHead",      0,          4},
+   {"TxActQueueTail",      0,          4},
+   {"TxActive",            0,          3},
+   {"TcbStart",            0,          4},
+   {"TxTeardownPending",   0,          0}
+  };
+
+static STATS_TABLE StatsTable3[] =
+  {
+   /* Name ,        Data Ptr,   Data Type */
+   {"RxBufSize",           0,          2},
+   {"RxBufferOffset",      0,          2},
+   {"RxNumBuffers",        0,          2},
+   {"RxServiceMax",        0,          2},
+   {"TxNumBuffers",        0,          2},
+   {"TxNumQueues",         0,          2},
+   {"TxServiceMax",        0,          2},
+#ifdef _CPHAL_AAL5
+   {"CpcsUU",              0,          2},
+   {"Gfc",                 0,          2},
+   {"Clp",                 0,          2},
+   {"Pti",                 0,          2},
+   {"DaMask",              0,          2},
+   {"Priority",            0,          2},
+   {"PktType",             0,          2},
+   {"Vci",                 0,          2},
+   {"Vpi",                 0,          2},
+   {"CellRate",            0,          2},
+   {"QosType",             0,          2},
+   {"Mbs",                 0,          2},
+   {"Pcr",                 0,          2}
+#endif
+  };
+
+static STATS_TABLE StatsTable4[] =
+  {
+   {"Base Address",        0,          1},
+   {"Offset (VLYNQ)",      0,          0},
+   {"Interrupt Line",      0,          0},
+   {"Debug",               0,          0},
+   {"Instance",            0,          0},
+#ifdef _CPHAL_AAL5
+   {"UniNni",              0,          0}
+#endif
+  };
+
+static STATS_DB StatsDb[] =
+  {
+    {(sizeof(StatsTable0)/sizeof(STATS_TABLE)), StatsTable0},
+    {(sizeof(StatsTable1)/sizeof(STATS_TABLE)), StatsTable1},
+    {(sizeof(StatsTable2)/sizeof(STATS_TABLE)), StatsTable2},
+    {(sizeof(StatsTable3)/sizeof(STATS_TABLE)), StatsTable3},
+    {(sizeof(StatsTable4)/sizeof(STATS_TABLE)), StatsTable4}
+  };
+#endif /* +GSG 030307 */
+
+#ifdef _CPHAL_CPMAC /* +RC 3.02 */
+static void resetWait(HAL_DEVICE *HalDev)
+  {                                                                  /*+RC3.02*/
+  const int TickReset=64;
+  osfuncSleep((int*)&TickReset);
+  }                                                                  /*+RC3.02*/
+#endif /* +RC 3.02 */
+
+/* I only define the reset base function for the modules
+   that can perform a reset.  The AAL5 and AAL2 modules
+   do not perform a reset, that is done by the shared module
+   CPSAR */
+#if defined(_CPHAL_CPSAR) || defined(_CPHAL_CPMAC) || defined(_CPHAL_VDMAVT)
+/*
+ *  Determines the reset register address to be used for a particular device.
+ *  It will search the current device entry for Locator information.  If the
+ *  device is a root device, there will be no Locator information, and the
+ *  function will find and return the root reset register.  If a Locator value
+ *  is found, the function will search each VLYNQ device entry in the system
+ *  looking for a matching Locator.  Once it finds a VLYNQ device entry with
+ *  a matching Locator, it will extract the "ResetBase" parameter from that
+ *  VLYNQ device entry (thus every VLYNQ entry must have the ResetBase parameter).
+ *
+ *  @param  HalDev   CPHAL module instance. (set by xxxInitModule())
+ *  @param  ResetBase Pointer to integer address of reset register.
+ *
+ *  @return 0 OK, Non-zero not OK
+ */
+static int ResetBaseGet(HAL_DEVICE *HalDev, bit32u *ResetBase)
+  {
+   char *DeviceInfo = HalDev->DeviceInfo;
+   char *MyLocator, *NextLocator;
+   int Inst=1;
+   bit32u error_code;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpcommon]ResetBaseGet(HalDev:%08x, ResetBase:%08x)\n", (bit32u)HalDev, ResetBase);
+      osfuncSioFlush();
+     }
+#endif
+
+   error_code = HalDev->OsFunc->DeviceFindParmValue(DeviceInfo, "Locator", &MyLocator);
+   if (error_code)
+     {
+      /* if no Locator value, device is on the root, so get the "reset" device */
+      error_code = HalDev->OsFunc->DeviceFindInfo(0, "reset", &DeviceInfo);
+      if  (error_code)
+        {
+         return(EC_VAL_DEVICE_NOT_FOUND);
+        }
+
+      error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, "base", ResetBase);
+      if (error_code)
+        {
+         return(EC_VAL_BASE_ADDR_NOT_FOUND);
+        }
+
+      *ResetBase = ((bit32u)PhysToVirtNoCache(*ResetBase));
+
+      /* found base address for root device, so we're done */
+      return (EC_NO_ERRORS);
+     }
+    else
+     {
+      /* we have a Locator value, so the device is remote */
+
+      /* Find a vlynq device with a matching locator value */
+      while ((HalDev->OsFunc->DeviceFindInfo(Inst, "vlynq", &DeviceInfo)) == EC_NO_ERRORS)
+        {
+         error_code = HalDev->OsFunc->DeviceFindParmValue(DeviceInfo, "Locator", &NextLocator);
+         if (error_code)
+           {
+            /* no Locator value for this VLYNQ, so move on */
+            continue;
+           }
+         if (HalDev->OsFunc->Strcmpi(MyLocator, NextLocator)==0)
+           {
+            /* we have found a VLYNQ with a matching Locator, so extract the ResetBase */
+            error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, "ResetBase", ResetBase);
+            if (error_code)
+              {
+               return(EC_VAL_BASE_ADDR_NOT_FOUND);
+              }
+            *ResetBase = ((bit32u)PhysToVirtNoCache(*ResetBase));
+
+            /* found base address for root device, so we're done */
+            return (EC_NO_ERRORS);
+           }
+         Inst++;
+        } /* while */
+     } /* else */
+
+   return (EC_NO_ERRORS);
+  }
+#endif
+
+#ifndef _CPHAL_AAL2 /* + RC 3.02 */
+static bit32u ConfigGetCommon(HAL_DEVICE *HalDev)
+  {
+   bit32u ParmValue;
+   bit32 error_code;
+   char *DeviceInfo = HalDev->DeviceInfo;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpcommon]ConfigGetCommon(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszBase, &ParmValue);
+   if (error_code)
+     {
+      return(EC_FUNC_HAL_INIT|EC_VAL_BASE_ADDR_NOT_FOUND);
+     }
+   HalDev->dev_base = ((bit32u)PhysToVirtNoCache(ParmValue));
+
+#ifndef _CPHAL_AAL5
+#ifndef _CPHAL_AAL2
+   error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszResetBit, &ParmValue);
+   if(error_code)
+     {
+      return(EC_FUNC_HAL_INIT|EC_VAL_RESET_BIT_NOT_FOUND);
+     }
+   HalDev->ResetBit = ParmValue;
+
+   /* Get reset base address */
+   error_code = ResetBaseGet(HalDev, &ParmValue);
+   if (error_code)
+     return(EC_FUNC_HAL_INIT|EC_VAL_RESET_BASE_NOT_FOUND);
+   HalDev->ResetBase = ParmValue;
+#endif
+#endif
+
+#ifndef _CPHAL_CPSAR
+   error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszIntLine,&ParmValue);
+   if (error_code)
+     {
+      return(EC_FUNC_HAL_INIT|EC_VAL_INTERRUPT_NOT_FOUND);
+     }
+   HalDev->interrupt = ParmValue;
+#endif
+
+   /* only look for the offset if there is a Locator field, which indicates that
+      the module is a VLYNQ module */
+   error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszLocator,&ParmValue);
+   if (!error_code)
+     {
+      error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszOffset,&ParmValue);
+      if (error_code)
+        {
+         return(EC_FUNC_HAL_INIT|EC_VAL_OFFSET_NOT_FOUND);
+        }
+      HalDev->offset = ParmValue;
+     }
+    else
+      HalDev->offset = 0;
+
+   error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo, pszDebug, &ParmValue);
+   if (!error_code) HalDev->debug = ParmValue;
+
+   return (EC_NO_ERRORS);
+  }
+#endif /* +RC 3.02 */
+
+#ifdef _CPHAL_CPMAC /* +RC 3.02 */
+static void StatsInit(HAL_DEVICE *HalDev)                             /* +() RC3.02 */
+  {
+   /* even though these statistics may be for multiple channels and
+      queues, i need only configure the pointer to the beginning
+      of the array, and I can index from there if necessary */
+
+#ifdef _CPHAL_AAL5
+   StatsTable0[0].StatPtr  = &HalDev->Stats.CrcErrors[0];
+   StatsTable0[1].StatPtr  = &HalDev->Stats.LenErrors[0];
+   StatsTable0[2].StatPtr  = &HalDev->Stats.AbortErrors[0];
+   StatsTable0[3].StatPtr  = &HalDev->Stats.StarvErrors[0];
+
+   StatsTable1[0].StatPtr  = &HalDev->Stats.DmaLenErrors[0];
+   StatsTable1[1].StatPtr  = &HalDev->Stats.TxMisQCnt[0][0];
+   StatsTable1[2].StatPtr  = &HalDev->Stats.RxMisQCnt[0];
+   StatsTable1[3].StatPtr  = &HalDev->Stats.TxEOQCnt[0][0];
+   StatsTable1[4].StatPtr  = &HalDev->Stats.RxEOQCnt[0];
+   StatsTable1[5].StatPtr  = &HalDev->Stats.RxPacketsServiced[0];
+   StatsTable1[6].StatPtr  = &HalDev->Stats.TxPacketsServiced[0][0];
+   StatsTable1[7].StatPtr  = &HalDev->Stats.RxMaxServiced;
+   StatsTable1[8].StatPtr  = &HalDev->Stats.TxMaxServiced[0][0];
+   StatsTable1[9].StatPtr  = &HalDev->Stats.RxTotal;
+   StatsTable1[10].StatPtr = &HalDev->Stats.TxTotal;
+#endif
+
+#if (defined(_CPHAL_AAL5) || defined(_CPHAL_CPMAC))
+   StatsTable2[0].StatPtr  = (bit32u *)&HalDev->RcbPool[0];
+   StatsTable2[1].StatPtr  = &HalDev->RxActQueueCount[0];
+   StatsTable2[2].StatPtr  = (bit32u *)&HalDev->RxActQueueHead[0];
+   StatsTable2[3].StatPtr  = (bit32u *)&HalDev->RxActQueueTail[0];
+   StatsTable2[4].StatPtr  = &HalDev->RxActive[0];
+   StatsTable2[5].StatPtr  = (bit32u *)&HalDev->RcbStart[0];
+   StatsTable2[6].StatPtr  = &HalDev->RxTeardownPending[0];
+   StatsTable2[7].StatPtr  = (bit32u *)&HalDev->TcbPool[0][0];
+   StatsTable2[8].StatPtr  = &HalDev->TxActQueueCount[0][0];
+   StatsTable2[9].StatPtr  = (bit32u *)&HalDev->TxActQueueHead[0][0];
+   StatsTable2[10].StatPtr = (bit32u *)&HalDev->TxActQueueTail[0][0];
+   StatsTable2[11].StatPtr = &HalDev->TxActive[0][0];
+   StatsTable2[12].StatPtr = (bit32u *)&HalDev->TcbStart[0][0];
+   StatsTable2[13].StatPtr = &HalDev->TxTeardownPending[0];
+
+   StatsTable3[0].StatPtr  = &HalDev->ChData[0].RxBufSize;
+   StatsTable3[1].StatPtr  = &HalDev->ChData[0].RxBufferOffset;
+   StatsTable3[2].StatPtr  = &HalDev->ChData[0].RxNumBuffers;
+   StatsTable3[3].StatPtr  = &HalDev->ChData[0].RxServiceMax;
+   StatsTable3[4].StatPtr  = &HalDev->ChData[0].TxNumBuffers;
+   StatsTable3[5].StatPtr  = &HalDev->ChData[0].TxNumQueues;
+   StatsTable3[6].StatPtr  = &HalDev->ChData[0].TxServiceMax;
+#ifdef _CPHAL_AAL5
+   StatsTable3[7].StatPtr  = &HalDev->ChData[0].CpcsUU;
+   StatsTable3[8].StatPtr  = &HalDev->ChData[0].Gfc;
+   StatsTable3[9].StatPtr  = &HalDev->ChData[0].Clp;
+   StatsTable3[10].StatPtr = &HalDev->ChData[0].Pti;
+   StatsTable3[11].StatPtr = &HalDev->ChData[0].DaMask;
+   StatsTable3[12].StatPtr = &HalDev->ChData[0].Priority;
+   StatsTable3[13].StatPtr = &HalDev->ChData[0].PktType;
+   StatsTable3[14].StatPtr = &HalDev->ChData[0].Vci;
+   StatsTable3[15].StatPtr = &HalDev->ChData[0].Vpi;
+   StatsTable3[16].StatPtr = &HalDev->ChData[0].TxVc_CellRate;
+   StatsTable3[17].StatPtr = &HalDev->ChData[0].TxVc_QosType;
+   StatsTable3[18].StatPtr = &HalDev->ChData[0].TxVc_Mbs;
+   StatsTable3[19].StatPtr = &HalDev->ChData[0].TxVc_Pcr;
+#endif
+#endif
+
+   StatsTable4[0].StatPtr  = &HalDev->dev_base;
+   StatsTable4[1].StatPtr  = &HalDev->offset;
+   StatsTable4[2].StatPtr  = &HalDev->interrupt;
+   StatsTable4[3].StatPtr  = &HalDev->debug;
+   StatsTable4[4].StatPtr  = &HalDev->Inst;
+  }
+#endif /* +RC 3.02 */
+
+#ifndef _CPHAL_CPSAR /* +RC 3.02 */
+#ifndef _CPHAL_AAL2 /* +RC 3.02 */
+/*
+ *  Returns statistics information.
+ *
+ *  @param  HalDev   CPHAL module instance. (set by xxxInitModule())
+ *
+ *  @return 0
+ */
+static int StatsGet(HAL_DEVICE *HalDev, void **StatPtr, int Index, int Ch, int Queue)
+  {
+   int Size;
+   bit32u *AddrPtr;
+   char *DataPtr;
+   STATS_TABLE *StatsTable;
+   int i, NumberOfStats;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpcommon]StatsGet(HalDev:%08x, StatPtr:%08x)\n",
+                (bit32u)HalDev, (bit32u)StatPtr);
+      osfuncSioFlush();
+     }
+#endif
+
+   StatsTable = StatsDb[Index].StatTable;
+   NumberOfStats = StatsDb[Index].NumberOfStats;
+
+   Size = sizeof(bit32u)*((NumberOfStats*2)+1);
+   Size += (NumberOfStats*11);
+   *StatPtr = (bit32u *)HalDev->OsFunc->Malloc(Size);
+
+   AddrPtr = (bit32u *) *StatPtr;
+   DataPtr = (char *)AddrPtr;
+   DataPtr += sizeof(bit32u)*((NumberOfStats*2)+1);
+
+   for (i=0; i<NumberOfStats; i++)
+     {
+      *AddrPtr++ = (bit32u)StatsTable[i].StatName;
+      *AddrPtr++ = (bit32u)DataPtr;
+      if (&StatsTable[i].StatPtr[Ch] != 0)
+        {
+         switch(StatsTable[i].DataType)
+           {
+            case 0:
+              HalDev->OsFunc->Sprintf(DataPtr, "%d", (bit32u *)StatsTable[i].StatPtr[Ch]);
+              break;
+            case 1:
+              HalDev->OsFunc->Sprintf(DataPtr, "0x%x", (bit32u *)StatsTable[i].StatPtr[Ch]);
+              break;
+            case 2:
+              HalDev->OsFunc->Sprintf(DataPtr, "%d", *((bit32u *)StatsTable[i].StatPtr + (Ch * (sizeof(CHANNEL_INFO)/4))));
+              break;
+            case 3:
+              HalDev->OsFunc->Sprintf(DataPtr, "%d", *((bit32u *)StatsTable[i].StatPtr + (Ch*MAX_QUEUE)+Queue));
+              break;
+            case 4:
+              HalDev->OsFunc->Sprintf(DataPtr, "0x%x", *((bit32u *)StatsTable[i].StatPtr + (Ch*MAX_QUEUE)+Queue));
+              break;
+            default:
+              /* invalid data type, due to CPHAL programming error */
+              break;
+           }
+        }
+       else
+        {
+         /* invalid statistics pointer, probably was not initialized */
+        }
+      DataPtr += HalDev->OsFunc->Strlen(DataPtr) + 1;
+     }
+
+   *AddrPtr = (bit32u) 0;
+
+   return (EC_NO_ERRORS);
+  }
+#endif /* +RC 3.02 */
+#endif /* +RC 3.02 */
+
+#ifdef _CPHAL_CPMAC
+static void gpioFunctional(int base, int bit)
+  {                                                                  /*+RC3.02*/
+  bit32u GpioEnr = base + 0xC;
+  /*  To make functional, set to zero  */
+  *(volatile bit32u *)(GpioEnr) &= ~(1 << bit);                      /*+RC3.02*/
+  }                                                                  /*+RC3.02*/
+
+
+/*+RC3.02*/
+/* Common function, Checks to see if GPIO should be in functional mode */
+static void gpioCheck(HAL_DEVICE *HalDev, void *moduleDeviceInfo)
+  {                                                                  /*+RC3.02*/
+  int rc;
+  void *DeviceInfo;
+  char *pszMuxBits;
+  char pszMuxBit[20];
+  char *pszTmp;
+  char szMuxBit[20];
+  char *ptr;
+  int base;
+  int reset_bit;
+  int bit;
+  OS_FUNCTIONS *OsFunc = HalDev->OsFunc;
+
+  rc = OsFunc->DeviceFindParmValue(moduleDeviceInfo, "gpio_mux",&pszTmp);
+  if(rc) return;
+  /*  gpio entry found, get GPIO register info and make functional  */
+
+  /* temp copy until FinParmValue fixed */
+  ptr = &szMuxBit[0];
+  while ((*ptr++ = *pszTmp++));
+
+  pszMuxBits = &szMuxBit[0];
+
+  rc = OsFunc->DeviceFindInfo(0,"gpio",&DeviceInfo);
+  if(rc) return;
+
+  rc = OsFunc->DeviceFindParmUint(DeviceInfo, "base",&base);
+  if(rc) return;
+
+  rc = OsFunc->DeviceFindParmUint(DeviceInfo, "reset_bit",&reset_bit);
+  if(rc) return;
+
+  /* If GPIO still in reset, then exit  */
+  if((VOLATILE32(HalDev->ResetBase) & (1 << reset_bit)) == 0)
+    return;
+  /*  format for gpio_mux is  gpio_mux = <int>;<int>;<int>...*/
+  while (*pszMuxBits)
+    {
+    pszTmp = &pszMuxBit[0];
+    if(*pszMuxBits == ';') pszMuxBits++;
+    while ((*pszMuxBits != ';') && (*pszMuxBits != '\0'))
+      {
+      osfuncSioFlush();
+      /*If value not a number, skip */
+      if((*pszMuxBits < '0') || (*pszMuxBits > '9'))
+        pszMuxBits++;
+      else
+        *pszTmp++ = *pszMuxBits++;
+      }
+    *pszTmp = '\0';
+    bit = OsFunc->Strtoul(pszMuxBit, &pszTmp, 10);
+    gpioFunctional(base, bit);
+    resetWait(HalDev);  /* not sure if this is needed */
+    }
+  }                                                                  /*+RC3.02*/
+#endif  /* CPMAC  */
+
+#ifdef _CPHAL_AAL5
+const char hcSarFrequency[] = "SarFreq";
+#endif
+
+#endif  /* _INC  */
diff -urN linux.old/drivers/atm/sangam_atm/cpcommon_cpsar.h linux.dev/drivers/atm/sangam_atm/cpcommon_cpsar.h
--- linux.old/drivers/atm/sangam_atm/cpcommon_cpsar.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cpcommon_cpsar.h	2005-08-23 04:46:50.083845824 +0200
@@ -0,0 +1,79 @@
+#ifndef _INC_CPCOMMON_H
+#define _INC_CPCOMMON_H
+
+#define VOLATILE32(addr)  (*(volatile bit32u *)(addr))
+#ifndef dbgPrintf
+#define dbgPrintf HalDev->OsFunc->Printf
+#endif
+
+#define ChannelUpdate(Field) if(HalChn->Field != 0xFFFFFFFF) HalDev->ChData[Ch].Field = HalChn->Field
+
+#define DBG(level)  (HalDev->debug & (1<<(level)))
+/*
+#define DBG0()      DBG(0)
+#define DBG1()      DBG(1)
+#define DBG2()      DBG(2)
+#define DBG3()      DBG(3)
+#define DBG4()      DBG(4)
+#define DBG5()      DBG(5)
+#define DBG6()      DBG(6)
+#define DBG7()      DBG(7)
+*/
+
+/*
+ *  List of defined actions for use with Control().
+ */
+typedef enum 
+  {
+   enGET=0,     /**< Get the value associated with a key */
+   enSET,       /**< Set the value associates with a key */
+   enCLEAR,     /**<Clear the value */ 
+   enNULL       /**< No data action, used to initiate a service or send a message */
+  }ACTION;
+
+/*
+ *  Enumerated hardware states.
+ */
+typedef enum
+  {
+   enConnected=1, enDevFound, enInitialized, enOpened
+  }DEVICE_STATE;
+
+typedef enum 
+  {
+   enCommonStart=0,
+   /* General  */
+   enOff, enOn, enDebug, 
+   /* Module General */
+   enCpuFreq, 
+   enStatus,
+   enCommonEnd
+   }COMMON_KEY;
+
+typedef struct
+  {
+   const char  *strKey;
+   int  enKey;
+  }CONTROL_KEY;
+
+typedef struct
+  {
+   char *StatName;
+   unsigned int *StatPtr;
+   int DataType; /* 0: int, 1: hex int, 2:channel data */
+  }STATS_TABLE;
+
+typedef struct
+  {
+   int NumberOfStats;
+   STATS_TABLE *StatTable;
+  }STATS_DB;
+
+#define osfuncSioFlush()    HalDev->OsFunc->Control(HalDev->OsDev,"SioFlush",pszNULL,0)
+#define osfuncSleep(Ticks)  HalDev->OsFunc->Control(HalDev->OsDev,pszSleep,pszNULL,Ticks)
+#define osfuncStateChange() HalDev->OsFunc->Control(HalDev->OsDev,pszStateChange,pszNULL,0)
+
+#define CHANNEL_NAMES {"Ch0","Ch1","Ch2","Ch3","Ch4","Ch5","Ch6","Ch7","Ch8","Ch9","Ch10","Ch11","Ch12","Ch13","Ch14","Ch15"}
+
+#endif
+
diff -urN linux.old/drivers/atm/sangam_atm/cppi_cpaal5.c linux.dev/drivers/atm/sangam_atm/cppi_cpaal5.c
--- linux.old/drivers/atm/sangam_atm/cppi_cpaal5.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cppi_cpaal5.c	2005-08-23 04:46:50.084845672 +0200
@@ -0,0 +1,1483 @@
+/*************************************************************************
+ *  TNETDxxxx Software Support
+ *  Copyright (c) 2002,2003 Texas Instruments Incorporated. All Rights Reserved.
+ *
+ *  FILE: cppi.c
+ *
+ *  DESCRIPTION:
+ *      This file contains shared code for all CPPI modules.
+ *
+ *  HISTORY:
+ *   7Aug02 Greg RC1.00  Original Version created.
+ *  27Sep02 Mick RC1.01  Merged for use by CPMAC/CPSAR
+ *  16Oct02 Mick RC1.02  Performance Tweaks (see cppihist.txt)
+ *  12Nov02 Mick RC1.02  Updated to use cpmac_reg.h
+ *  09Jan03 Mick RC3.01  Removed modification to RxBuffer ptr
+ *  28Mar03 Mick 1.03    RxReturn now returns error if Malloc Fails
+ *  10Apr03 Mick 1.03.02 Added Needs Buffer Support
+ *  11Jun03 Mick 1.06.02 halSend() errors corrected
+ *
+ *  @author  Greg Guyotte
+ *  @version 1.00
+ *  @date    7-Aug-2002
+ *****************************************************************************/
+/* each CPPI module must modify this file, the rest of the
+                     code in cppi.c should be totally shared *//* Each CPPI module MUST properly define all constants shown below */
+
+/* CPPI registers */
+
+/* the following defines are not CPPI specific, but still used by cppi.c */
+
+static void FreeRx(HAL_DEVICE *HalDev, int Ch)
+  {
+   HAL_RCB *rcb_ptr;                                                /*+GSG 030303*/
+   int rcbSize = (sizeof(HAL_RCB)+0xf)&~0xf;                        /*+GSG 030303*/
+   int Num = HalDev->ChData[Ch].RxNumBuffers, i;                    /*+GSG 030303*/
+
+   /* Free Rx data buffers attached to descriptors, if necessary */
+   if (HalDev->RcbStart[Ch] != 0)                                   /*+GSG 030303*/
+     {                                                              /*+GSG 030303*/
+      for(i=0;i<Num;i++)                                            /*+GSG 030303*/
+        {                                                           /*+GSG 030303*/
+         rcb_ptr = (HAL_RCB *)(HalDev->RcbStart[Ch] + (i*rcbSize)); /*+GSG 030303*/
+
+         /* free the data buffer */
+         if (rcb_ptr->DatPtr != 0)
+       {
+
+        HalDev->OsFunc->FreeRxBuffer((void *)rcb_ptr->OsInfo, (void *)rcb_ptr->DatPtr);
+        rcb_ptr->OsInfo=0;                                        /*MJH+030522*/
+        rcb_ptr->DatPtr=0;                                        /*MJH+030522*/
+       }
+    }                                                           /*+GSG 030303*/
+     }                                                              /*+GSG 030303*/
+
+   /* free up all desciptors at once */
+   HalDev->OsFunc->FreeDmaXfer(HalDev->RcbStart[Ch]);
+
+   /* mark buffers as freed */
+   HalDev->RcbStart[Ch] = 0;
+  }
+
+static void FreeTx(HAL_DEVICE *HalDev, int Ch, int Queue)
+  {
+
+/*+GSG 030303*/
+
+   /* free all descriptors at once */
+   HalDev->OsFunc->FreeDmaXfer(HalDev->TcbStart[Ch][Queue]);
+
+   HalDev->TcbStart[Ch][Queue] = 0;
+  }
+
+/* return of 0 means that this code executed, -1 means the interrupt was not
+   a teardown interrupt */
+static int RxTeardownInt(HAL_DEVICE *HalDev, int Ch)
+  {
+   bit32u base = HalDev->dev_base;
+
+   int i;
+   volatile bit32u *pTmp;
+
+   /* check to see if the interrupt is a teardown interrupt */
+   if (((*(pRX_CPPI_COMP_PTR( base )+( Ch *64)))  & TEARDOWN_VAL) == TEARDOWN_VAL)
+     {
+      /* finish channel teardown */
+
+      /* Free channel resources on a FULL teardown */
+      if (HalDev->RxTeardownPending[Ch] & FULL_TEARDOWN)
+        {
+         FreeRx(HalDev, Ch);
+        }
+
+      /* bug fix - clear Rx channel pointers on teardown */
+      HalDev->RcbPool[Ch] = 0;
+      HalDev->RxActQueueHead[Ch]  = 0;
+      HalDev->RxActQueueCount[Ch] = 0;
+      HalDev->RxActive[Ch] = FALSE;
+
+      /* write completion pointer */
+      (*(pRX_CPPI_COMP_PTR( base )+( Ch *64)))  = TEARDOWN_VAL;
+
+      /* use direction bit as a teardown pending bit! May be able to
+         use only one teardown pending integer in HalDev */
+
+      HalDev->RxTeardownPending[Ch] &= ~RX_TEARDOWN;
+
+      HalDev->ChIsOpen[Ch][DIRECTION_RX] = 0;
+
+      /* call OS Teardown Complete (if TX is also done) */
+      if ((HalDev->TxTeardownPending[Ch] & TX_TEARDOWN) == 0)
+    {
+     /* mark channel as closed */
+         HalDev->ChIsOpen[Ch][DIRECTION_TX] = 0;
+
+     /* disable channel interrupt */
+     SAR_TX_MASK_CLR(HalDev->dev_base) = (1<<Ch);
+         SAR_TX_MASK_CLR(HalDev->dev_base) = (1<<(Ch+16)); /* +GSG 030307 */
+     SAR_RX_MASK_CLR(HalDev->dev_base) = (1<<Ch);
+
+     /* Clear PDSP Channel State RAM */
+     pTmp = (pPDSP_BLOCK_0(HalDev->dev_base)+(Ch*64));
+     for (i=0; i<NUM_PDSP_AAL5_STATE_WORDS; i++)
+       *pTmp++ = 0;
+
+     if ((HalDev->RxTeardownPending[Ch] & BLOCKING_TEARDOWN) == 0)
+       {
+
+        HalDev->OsFunc->TeardownComplete(HalDev->OsDev, Ch, DIRECTION_TX|DIRECTION_RX);
+       }
+     /* clear all teardown pending information for this channel */
+     HalDev->RxTeardownPending[Ch] = 0;
+     HalDev->TxTeardownPending[Ch] = 0;
+    }
+
+      return (EC_NO_ERRORS);
+     }
+   return (-1);
+  }
+
+/* return of 0 means that this code executed, -1 means the interrupt was not
+   a teardown interrupt */
+static int TxTeardownInt(HAL_DEVICE *HalDev, int Ch, int Queue)
+  {
+   bit32u base = HalDev->dev_base;
+   HAL_TCB *Last, *Curr, *First;                                    /*+GSG 030303*/
+
+   int i;
+   volatile bit32u *pTmp;
+
+   if (((*(pTXH_CPPI_COMP_PTR( base )+( Ch *64)+( Queue )))  & TEARDOWN_VAL) == TEARDOWN_VAL)
+     {
+      /* return outstanding buffers to OS                             +RC3.02*/
+      Curr = HalDev->TxActQueueHead[Ch][Queue];                     /*+GSG 030303*/
+      First = Curr;                                                 /*+GSG 030303*/
+      while (Curr)                                                  /*+GSG 030303*/
+    {                                                           /*+GSG 030303*/
+     /* Pop TCB(s) for packet from the stack */                 /*+GSG 030303*/
+         Last = Curr->Eop;                                          /*+GSG 030303*/
+         HalDev->TxActQueueHead[Ch][Queue] = Last->Next;            /*+GSG 030303*/
+                                                                    /*+GSG 030303*/
+         /* return to OS */                                         /*+GSG 030303*/
+         HalDev->OsFunc->SendComplete(Curr->OsInfo);                /*+GSG 030303*/
+                                                                    /*+GSG 030303*/
+         /* Push Tcb(s) back onto the stack */                      /*+GSG 030303*/
+         Curr = Last->Next;                                         /*+GSG 030303*/
+         Last->Next = HalDev->TcbPool[Ch][Queue];                   /*+GSG 030303*/
+         HalDev->TcbPool[Ch][Queue] = First;                        /*+GSG 030303*/
+                                                                    /*+GSG 030303*/
+         /* set the first(SOP) pointer for the next packet */       /*+GSG 030303*/
+         First = Curr;                                              /*+GSG 030303*/
+    }                                                           /*+GSG 030303*/
+
+      /* finish channel teardown */
+
+      /* save the OsInfo to pass to upper layer
+         THIS WAS CRASHING - because it's possible that I get the teardown
+     notification and the TcbHPool is null.  In this case, the buffers
+     to free can be found in the TxHActiveQueue.  If I need to get OsInfo
+     in the future, I can get it from one of those buffers.
+     OsInfo = HalDev->TcbHPool[Ch]->OsInfo; */
+
+      if (HalDev->TxTeardownPending[Ch] & FULL_TEARDOWN)
+        {
+     FreeTx(HalDev, Ch, Queue);
+    } /* if FULL teardown */
+
+      /* bug fix - clear Tx channel pointers on teardown */
+      HalDev->TcbPool[Ch][Queue] = 0;
+      HalDev->TxActQueueHead[Ch][Queue]  = 0;
+      HalDev->TxActQueueCount[Ch][Queue] = 0;
+      HalDev->TxActive[Ch][Queue]        = FALSE;
+
+      /* write completion pointer */
+      (*(pTXH_CPPI_COMP_PTR( base )+( Ch *64)+( Queue )))  = TEARDOWN_VAL;
+
+      /* no longer pending teardown */
+      HalDev->TxTeardownPending[Ch] &= ~TX_TEARDOWN;
+
+      HalDev->ChIsOpen[Ch][DIRECTION_TX] = 0;
+
+      /* call OS Teardown Complete (if Rx is also done) */
+      if ((HalDev->RxTeardownPending[Ch] & RX_TEARDOWN) == 0)
+    {
+     /* mark channel as closed */
+     HalDev->ChIsOpen[Ch][DIRECTION_RX] = 0;
+
+     /* disable channel interrupt */
+     SAR_TX_MASK_CLR(HalDev->dev_base) = (1<<Ch);
+         SAR_TX_MASK_CLR(HalDev->dev_base) = (1<<(Ch+16)); /* +GSG 030307 */
+     SAR_RX_MASK_CLR(HalDev->dev_base) = (1<<Ch);
+
+     /* Clear PDSP Channel State RAM */
+     pTmp = (pPDSP_BLOCK_0(HalDev->dev_base)+(Ch*64));
+     for (i=0; i<NUM_PDSP_AAL5_STATE_WORDS; i++)
+       *pTmp++ = 0;
+
+     if ((HalDev->TxTeardownPending[Ch] & BLOCKING_TEARDOWN) == 0)
+       {
+
+        HalDev->OsFunc->TeardownComplete(HalDev->OsDev, Ch, DIRECTION_TX|DIRECTION_RX);
+       }
+
+     /* clear all teardown pending information for this channel */
+     HalDev->RxTeardownPending[Ch] = 0;
+     HalDev->TxTeardownPending[Ch] = 0;
+    }
+
+      return (EC_NO_ERRORS);
+     }
+   return (-1);
+  }
+
+/* +GSG 030421 */
+static void AddToRxQueue(HAL_DEVICE *HalDev, HAL_RCB *FirstRcb, HAL_RCB *LastRcb, int FragCount, int Ch)
+  {
+   HAL_RCB *OldTailRcb;
+
+   if (HalDev->RxActQueueCount[Ch]==0)
+     {
+
+      HalDev->RxActQueueHead[Ch]=FirstRcb;
+      HalDev->RxActQueueTail[Ch]=LastRcb;
+      HalDev->RxActQueueCount[Ch]=FragCount;
+      if ((!HalDev->InRxInt[Ch])&&(!HalDev->RxActive[Ch]))
+        {
+         /* write Rx Queue Head Descriptor Pointer */
+         (*(pRX_DMA_STATE_WORD_1( HalDev->dev_base )+( Ch *64)))  = VirtToPhys(FirstRcb) - HalDev->offset;
+         HalDev->RxActive[Ch]=TRUE;
+        }
+     }
+    else
+     {
+
+      OldTailRcb=HalDev->RxActQueueTail[Ch];
+      OldTailRcb->Next=(void *)FirstRcb;
+
+      /* Emerald fix 10/29 (Denis) */
+      *((bit32u *) VirtToVirtNoCache(&OldTailRcb->HNext))=VirtToPhys(FirstRcb) - HalDev->offset;
+
+      HalDev->RxActQueueTail[Ch]=LastRcb;
+      HalDev->RxActQueueCount[Ch]+=FragCount;
+     }
+  }
+
+/**
+ *  @ingroup CPHAL_Functions
+ *  This function is called to indicate to the CPHAL that the upper layer
+ *  software has finished processing the receive data (given to it by
+ *  osReceive()).  The CPHAL will then return the appropriate receive buffers
+ *  and buffer descriptors to the available pool.
+ *
+ *  @param   HalReceiveInfo   Start of receive buffer descriptor chain returned to
+ *                      CPHAL.
+ *  @param   StripFlag  Flag indicating whether the upper layer software has
+ *                      retained ownership of the receive data buffers.
+ *<BR>
+ * 'FALSE' means  that the CPHAL can reuse the receive data buffers.
+ *<BR>
+ * 'TRUE' : indicates the data buffers were retained by the OS
+ *<BR>
+ * NOTE:  If StripFlag is TRUE, it is the responsibility of the upper layer software to free the buffers when they are no longer needed.
+ *
+ *  @return EC_NO_ERRORS (ok). <BR>
+ *          Possible Error Codes:<BR>
+ *          @ref EC_VAL_INVALID_STATE "EC_VAL_INVALID_STATE"<BR>
+ *          @ref EC_VAL_RCB_NEEDS_BUFFER "EC_VAL_RCB_NEEDS_BUFFER"<BR>
+ *          @ref EC_VAL_RCB_DROPPED "EC_VAL_RCB_DROPPED"<BR>
+ */
+static int halRxReturn(HAL_RECEIVEINFO *HalReceiveInfo,
+            int StripFlag)
+  {
+   int Ch = HalReceiveInfo->Ch, i;
+   HAL_RCB *LastRcb, *TempRcb;
+   char *pBuf;
+   HAL_RCB *CurrHeadRcb = HalReceiveInfo, *LastGoodRcb=0;         /* +GSG 030421 */
+   HAL_DEVICE *HalDev = HalReceiveInfo->HalDev;
+   int RcbSize = HalDev->ChData[Ch].RxBufSize;
+   int FragCount = HalReceiveInfo->FragCount;
+   int rc=0;                                                      /*MJH+030417*/
+   int GoodCount=0;                                               /*GSG+030421*/
+
+   if (HalDev->State != enOpened)
+     return(EC_AAL5 |EC_FUNC_RXRETURN|EC_VAL_INVALID_STATE);
+
+   LastRcb=(HAL_RCB *)HalReceiveInfo->Eop;
+   LastRcb->HNext=0;
+   LastRcb->Next=0;
+
+   if (FragCount>1)
+     {
+      LastRcb->Off_BLen=RcbSize;
+      LastRcb->mode=CB_OWNERSHIP_BIT;
+     }
+
+   HalReceiveInfo->Off_BLen=RcbSize;
+   HalReceiveInfo->mode=CB_OWNERSHIP_BIT;
+
+   /* If OS has kept the buffers for this packet, attempt to alloc new buffers */
+   if (StripFlag)
+     {
+      TempRcb = HalReceiveInfo;
+      for (i=0; i<FragCount; i++)
+        {
+         if (TempRcb == 0)
+           {
+            dbgPrintf("Rx Return error while allocating new buffers\n");
+            dbgPrintf("Rcb = %08x, Rcb->Eop = %08x, FragCount = %d:%d\n",
+              (bit32u)HalReceiveInfo, (bit32u)HalReceiveInfo->Eop, FragCount,i);
+            osfuncSioFlush();
+
+            return(EC_CPPI|EC_FUNC_RXRETURN|EC_VAL_CORRUPT_RCB_CHAIN);
+           }
+
+         /* size = ((RcbSize+15) & ~15) + 15;*/                      /*-3.01b*/
+         /*size = RcbSize + 15;*/                                               /* -GSG 030421 */
+         pBuf= (char *) HalDev->OsFunc->MallocRxBuffer(RcbSize,0,
+                             0xF,HalDev->ChData[Ch].OsSetup,
+                             (void *)TempRcb,
+                             (void *)&TempRcb->OsInfo,
+                             (void *) HalDev->OsDev);
+         if (!pBuf)
+           {
+            /* malloc failed, add this RCB to Needs Buffer List */
+            TempRcb->FragCount = 1;                                             /*MJH+030417*/
+            (HAL_RCB *)TempRcb->Eop = TempRcb;                                  /* GSG +030430 */
+
+            if(HalDev->NeedsCount < MAX_NEEDS)                                  /* +MJH 030410 */
+              {                                                                 /* +MJH 030410 */
+               HalDev->Needs[HalDev->NeedsCount] = (HAL_RECEIVEINFO *) TempRcb; /* +MJH 030410 */
+               HalDev->NeedsCount++;                                            /* +MJH 030410 */
+               rc = (EC_CPPI|EC_FUNC_RXRETURN|EC_VAL_RCB_NEEDS_BUFFER);         /* ~MJH 030417 */
+              }                                                                 /* +MJH 030410 */
+             else                                                               /* +MJH 030410 */
+               rc = (EC_CPPI|EC_FUNC_RXRETURN|EC_VAL_RCB_DROPPED);              /* ~MJH 030417 */
+
+            /* requeue any previous RCB's that were ready to go before this one */
+            if (GoodCount > 0)                                                  /* +GSG 030421 */
+              {                                                                 /* +GSG 030421 */
+               LastGoodRcb->HNext=0;                                            /* +GSG 030430 */
+               LastGoodRcb->Next=0;                                             /* +GSG 030430 */
+               osfuncDataCacheHitWriteback((void *)LastGoodRcb, 16);            /* +GSG 030430 */
+
+               AddToRxQueue(HalDev, CurrHeadRcb, LastGoodRcb, GoodCount, Ch);   /* +GSG 030421 */
+               GoodCount = 0;                                                   /* +GSG 030421 */
+              }                                                                 /* +GSG 030421 */
+
+            CurrHeadRcb = TempRcb->Next;                                        /* +GSG 030421 */
+           }
+          else                                                                  /* +GSG 030421 */
+           {                                                                    /* +GSG 030421 */
+            /* malloc succeeded, requeue the RCB to the hardware */
+            TempRcb->BufPtr=VirtToPhys(pBuf) - HalDev->offset;
+            TempRcb->DatPtr=pBuf;
+            /* Emerald fix 10/29 */
+            osfuncDataCacheHitWriteback((void *)TempRcb, 16);
+
+            /* i store the last good RCB in case the malloc fails for the
+               next fragment.  This ensures that I can go ahead and return
+               a partial chain of RCB's to the hardware */
+            LastGoodRcb = TempRcb;                                              /* +GSG 030421 */
+            GoodCount++;                                                        /* +GSG 030421 */
+           }                                                                    /* +GSG 030421 */
+         TempRcb = TempRcb->Next;
+        } /*  end of Frag loop */
+      /* if there any good RCB's to requeue, do so here */
+      if (GoodCount > 0)                                                        /* +GSG 030421 */
+        {
+         AddToRxQueue(HalDev, CurrHeadRcb, LastGoodRcb, GoodCount, Ch);          /* +GSG 030421 */
+        }
+      return(rc);                                                               /* ~GSG 030421 */
+     }
+   else
+     {
+      /*  Not Stripping */
+      /* Emerald */
+      /* Write Back SOP and last RCB */
+      osfuncDataCacheHitWriteback((void *)HalReceiveInfo, 16);
+
+      if (FragCount > 1)
+        {
+         osfuncDataCacheHitWriteback((void *)LastRcb, 16);
+        }
+      /* if not stripping buffers, always add to queue */
+      AddToRxQueue(HalDev, HalReceiveInfo, LastRcb, FragCount, Ch); /*MJH~030520*/
+     }
+
+   return(EC_NO_ERRORS);
+  }
+
+/* +MJH 030410
+   Trys to liberate an RCB until liberation fails.
+   Note: If liberation fails then RxReturn will re-add the RCB to the
+         Needs list.
+*/
+static void NeedsCheck(HAL_DEVICE *HalDev)
+{
+    HAL_RECEIVEINFO* HalRcb;
+    int rc;
+    HalDev->OsFunc->CriticalOn();
+    while(HalDev->NeedsCount)
+      {
+      HalDev->NeedsCount--;
+      HalRcb = HalDev->Needs[HalDev->NeedsCount];
+      rc =  halRxReturn(HalRcb, 1);
+      /* short circuit if RxReturn starts to fail */
+      if (rc != 0)
+        break;
+      }
+    HalDev->OsFunc->CriticalOff();
+}
+
+/*
+ *  This function allocates transmit buffer descriptors (internal CPHAL function).
+ *  It creates a high priority transmit queue by default for a single Tx
+ *  channel.  If QoS is enabled for the given CPHAL device, this function
+ *  will also allocate a low priority transmit queue.
+ *
+ *  @param   HalDev   CPHAL module instance. (set by cphalInitModule())
+ *  @param   Ch       Channel number.
+ *
+ *  @return  0 OK, Non-Zero Not OK
+ */
+static int InitTcb(HAL_DEVICE *HalDev, int Ch)
+  {
+   int i, Num = HalDev->ChData[Ch].TxNumBuffers;
+   HAL_TCB *pTcb=0;
+   char *AllTcb;
+   int  tcbSize, Queue;
+   int SizeMalloc;
+
+   tcbSize = (sizeof(HAL_TCB)+0xf)&~0xf;
+   SizeMalloc = (tcbSize*Num)+0xf;
+
+   for (Queue=0; Queue < HalDev->ChData[Ch].TxNumQueues; Queue++)
+     {
+      if (HalDev->TcbStart[Ch][Queue] == 0)
+        {
+
+         /* malloc all TCBs at once */
+         AllTcb = (char *)HalDev->OsFunc->MallocDmaXfer(SizeMalloc,0,0xffffffff);
+         if (!AllTcb)
+           {
+            return(EC_CPPI|EC_FUNC_HAL_INIT|EC_VAL_TCB_MALLOC_FAILED);
+           }
+
+         HalDev->OsFunc->Memset(AllTcb, 0, SizeMalloc);
+
+         /* keep this address for freeing later */
+         HalDev->TcbStart[Ch][Queue] = AllTcb;
+        }
+       else
+        {
+         /* if the memory has already been allocated, simply reuse it! */
+         AllTcb = HalDev->TcbStart[Ch][Queue];
+        }
+
+      /* align to cache line */
+      AllTcb = (char *)(((bit32u)AllTcb + 0xf) &~ 0xf); /*PITS #143  MJH~030522*/
+
+      /* default High priority transmit queue */
+      HalDev->TcbPool[Ch][Queue]=0;
+      for(i=0;i<Num;i++)
+        {
+         /*pTcb=(HAL_TCB *) OsFunc->MallocDmaXfer(sizeof(HAL_TCB),0,0xffffffff); */
+         pTcb= (HAL_TCB *)(AllTcb + (i*tcbSize));
+         pTcb->mode=0;
+         pTcb->BufPtr=0;
+         pTcb->Next=HalDev->TcbPool[Ch][Queue];
+         pTcb->Off_BLen=0;
+         HalDev->TcbPool[Ch][Queue]=pTcb;
+        }
+      /*HalDev->TcbEnd = pTcb;*/
+     }
+
+   return(EC_NO_ERRORS);
+  }
+
+/*
+ *  This function allocates receive buffer descriptors (internal CPHAL function).
+ *  After allocation, the function 'queues' (gives to the hardware) the newly
+ *  created receive buffers to enable packet reception.
+ *
+ *  @param   HalDev   CPHAL module instance. (set by cphalInitModule())
+ *  @param   Ch    Channel number.
+ *
+ *  @return  0 OK, Non-Zero Not OK
+ */
+static int InitRcb(HAL_DEVICE *HalDev, int Ch)
+  {
+   int i, Num = HalDev->ChData[Ch].RxNumBuffers;
+   int Size = HalDev->ChData[Ch].RxBufSize;
+   HAL_RCB *pRcb;
+   char *pBuf;
+   char *AllRcb;
+   int  rcbSize;
+   int  DoMalloc = 0;
+   int SizeMalloc;
+   int MallocSize;
+
+   rcbSize = (sizeof(HAL_RCB)+0xf)&~0xf;
+   SizeMalloc = (rcbSize*Num)+0xf;
+
+   if (HalDev->RcbStart[Ch] == 0)
+     {
+      DoMalloc = 1;
+
+      /* malloc all RCBs at once */
+      AllRcb= (char *)HalDev->OsFunc->MallocDmaXfer(SizeMalloc,0,0xffffffff);
+      if (!AllRcb)
+        {
+         return(EC_CPPI|EC_FUNC_HAL_INIT|EC_VAL_RCB_MALLOC_FAILED);
+        }
+
+      HalDev->OsFunc->Memset(AllRcb, 0, SizeMalloc);
+
+      /* keep this address for freeing later */
+      HalDev->RcbStart[Ch] = AllRcb;
+     }
+    else
+     {
+      /* if the memory has already been allocated, simply reuse it! */
+      AllRcb = HalDev->RcbStart[Ch];
+     }
+
+   /* align to cache line */
+   AllRcb = (char *)(((bit32u)AllRcb + 0xf)&~0xf);  /*PITS #143  MJH~030522*/
+
+   HalDev->RcbPool[Ch]=0;
+   for(i=0;i<Num;i++)
+     {
+      pRcb = (HAL_RCB *)(AllRcb + (i*rcbSize));
+
+      if (DoMalloc == 1)
+        {
+
+         MallocSize = Size;                                       /*~3.01 */
+         pBuf= (char *) HalDev->OsFunc->MallocRxBuffer(MallocSize,0,0xF,HalDev->ChData[Ch].OsSetup, (void *)pRcb, (void *)&pRcb->OsInfo, (void *) HalDev->OsDev);
+         if(!pBuf)
+             {
+            return(EC_CPPI|EC_FUNC_HAL_INIT|EC_VAL_RX_BUFFER_MALLOC_FAILED);
+             }
+           /* -RC3.01 pBuf = (char *)(((bit32u)pBuf+0xF) & ~0xF); */
+         pRcb->BufPtr=VirtToPhys(pBuf) - HalDev->offset;
+         pRcb->DatPtr=pBuf;
+         /*pRcb->BufSize=Size;*/
+        }
+      pRcb->mode=0;
+      pRcb->Ch=Ch;
+      pRcb->Next=(void *)HalDev->RcbPool[Ch];
+      pRcb->Off_BLen=0;
+      pRcb->HalDev = HalDev;
+      HalDev->RcbPool[Ch]=pRcb;
+     }
+
+   /* Give all of the Rx buffers to hardware */
+
+   while(HalDev->RcbPool[Ch])
+     {
+      pRcb=HalDev->RcbPool[Ch];
+      HalDev->RcbPool[Ch]=pRcb->Next;
+      pRcb->Eop=(void*)pRcb;
+      pRcb->FragCount=1;
+      halRxReturn((HAL_RECEIVEINFO *)pRcb, 0);
+     }
+
+   return(EC_NO_ERRORS);
+  }
+
+/**
+ *  @ingroup CPHAL_Functions
+ *  This function transmits the data in FragList using available transmit
+ *  buffer descriptors.  More information on the use of the Mode parameter
+ *  is available in the module-specific appendices.  Note:  The OS should
+ *  not call Send() for a channel that has been requested to be torndown.
+ *
+ *  @param   HalDev      CPHAL module instance. (set by cphalInitModule())
+ *  @param   FragList    Fragment List structure.
+ *  @param   FragCount   Number of fragments in FragList.
+ *  @param   PacketSize  Number of bytes to transmit.
+ *  @param   OsSendInfo  OS Send Information structure. <BR>
+ *  @param   Mode        32-bit value with the following bit fields: <BR>
+ *                       31-16: Mode  (used for module specific data). <BR>
+ *                       15-08: Queue (transmit queue to send on). <BR>
+ *                       07-00: Channel (channel number to send on).
+ *
+ *  @return  EC_NO_ERRORS (ok). <BR>
+ *           Possible Error Codes:<BR>
+ *           @ref EC_VAL_INVALID_STATE "EC_VAL_INVALID_STATE"<BR>
+ *           @ref EC_VAL_NOT_LINKED "EC_VAL_NOT_LINKED"<BR>
+ *           @ref EC_VAL_INVALID_CH "EC_VAL_INVALID_CH"<BR>
+ *           @ref EC_VAL_OUT_OF_TCBS "EC_VAL_OUT_OF_TCBS"<BR>
+ *           @ref EC_VAL_NO_TCBS "EC_VAL_NO_TCBS"<BR>
+ */
+static int halSend(HAL_DEVICE *HalDev,FRAGLIST *FragList,
+                      int FragCount,int PacketSize, OS_SENDINFO *OsSendInfo,
+                      bit32u Mode)
+  {
+  HAL_TCB *tcb_ptr, *head;
+  int i;
+  bit32u base = HalDev->dev_base;
+  int rc = EC_NO_ERRORS;
+  int Ch = Mode & 0xFF;
+  int Queue = (Mode>>8)&0xFF;
+
+  int WaitFlag = (Mode>>30)&1; /* This is for AAL5 testing only */                     /* ~GSG 030508 */
+  int Offset = (FragList[0].len >> 16);
+  int PktType = (Mode>>16)&3; /* 0=AAL5, 1=Null AAL, 2=OAM, 3=Transparent */           /* +GSG 030508 */
+  int AtmHeaderInData = (Mode>>31)&1;                                                 /* +GSG 030508 */
+  int FragIndex = 0;
+
+  if (HalDev->State != enOpened)
+     return(EC_CPPI|EC_FUNC_SEND|EC_VAL_INVALID_STATE);
+
+  if (HalDev->ChIsOpen[Ch][DIRECTION_TX] == 0)                    /*MJH~030611*/ /*PITS 148*/
+    return(EC_AAL5 |EC_FUNC_SEND|EC_VAL_INVALID_CH);              /*+GSG 030303*/
+
+  HalDev->OsFunc->CriticalOn();
+
+  tcb_ptr = head = HalDev->TcbPool[Ch][Queue];
+
+  if (tcb_ptr)
+    {
+
+     /* these two TCB words are only valid on SOP */
+     if (AtmHeaderInData == 1)
+       {
+        tcb_ptr->AtmHeader = 0;  /* bug fix for transparent mode PTI problem */
+        /* Expect AtmHeader in the data */
+        tcb_ptr->AtmHeader |= *((bit8u *)FragList[FragIndex].data++) << 24;
+        tcb_ptr->AtmHeader |= *((bit8u *)FragList[FragIndex].data++) << 16;
+        tcb_ptr->AtmHeader |= *((bit8u *)FragList[FragIndex].data++) << 8;
+        tcb_ptr->AtmHeader |= *((bit8u *)FragList[FragIndex].data++);
+
+        /* decrement data buffer length accordingly */
+        FragList[FragIndex].len -= ATM_HEADER_SIZE;
+
+        /* if the first fragment was ATM Header only, go to next fragment for loop */
+        if (FragList[FragIndex].len == 0)
+          FragIndex++;
+
+        /* No CPCS_UU/CPI if not AAL5 */
+        tcb_ptr->Word5 = ((PktType & 0x3)<<16);
+       }
+      else
+       {
+        /* calculate AtmHeader from fields */
+        tcb_ptr->AtmHeader = atmheader(HalDev->ChData[Ch].Gfc, /* ~GSG 030306 */
+          HalDev->ChData[Ch].Vpi, HalDev->ChData[Ch].Vci,
+          HalDev->ChData[Ch].Pti, HalDev->ChData[Ch].Clp);
+
+        tcb_ptr->Word5 = HalDev->ChData[Ch].CpcsUU | ((HalDev->ChData[Ch].PktType &0x3)<<16);
+       }
+
+     for (i=FragIndex; i<FragCount; i++)
+
+       {
+        /* Setup Tx mode and size */
+        tcb_ptr->HNext    = VirtToPhys((bit32 *)tcb_ptr->Next) - HalDev->offset;
+        tcb_ptr->Off_BLen = FragList[i].len;
+
+        if (i==0)
+          tcb_ptr->Off_BLen |= (Offset << 16);
+
+        tcb_ptr->mode     = 0;  /* MUST clear this for each frag !!! */
+        tcb_ptr->BufPtr   = VirtToPhys((bit32 *)FragList[i].data) -
+          HalDev->offset;
+
+        /* first fragment */
+        if (i == 0)
+          {
+           tcb_ptr->mode |= CB_SOF_BIT;
+
+          }
+
+        tcb_ptr->mode |= (PacketSize | CB_OWNERSHIP_BIT);
+        tcb_ptr->OsInfo = OsSendInfo;
+
+        if (i == (FragCount - 1))
+          {
+           /* last fragment */
+           tcb_ptr->mode |= CB_EOF_BIT;
+
+           /* since this is the last fragment, set the TcbPool pointer before
+              nulling out the Next pointers */
+
+           HalDev->TcbPool[Ch][Queue] = tcb_ptr->Next;
+
+           tcb_ptr->Next = 0;
+           tcb_ptr->HNext = 0;
+
+           /* In the Tx Interrupt handler, we will need to know which TCB is EOP,
+              so we can save that information in the SOP */
+           head->Eop = tcb_ptr;
+
+           /* Emerald fix 10/29 */
+       osfuncDataCacheHitWriteback((void *)tcb_ptr, 16);
+
+       osfuncDataCacheHitWriteback((void *)((bit32u)tcb_ptr + 16), 16);
+
+          }
+         else
+          {
+       /* Emerald fix 10/29 */
+       osfuncDataCacheHitWriteback((void *)tcb_ptr, 16);
+
+       osfuncDataCacheHitWriteback((void *)((bit32u)tcb_ptr + 16), 16);
+
+           tcb_ptr = tcb_ptr->Next;  /* what about the end of TCB list?? */
+
+           if (tcb_ptr == 0)
+             {
+          rc = EC_CPPI|EC_FUNC_SEND|EC_VAL_OUT_OF_TCBS;
+              goto ExitSend;
+             }
+      }
+       } /* for */
+
+     /* put it on the high priority queue */
+     if (HalDev->TxActQueueHead[Ch][Queue] == 0)
+       {
+        HalDev->TxActQueueHead[Ch][Queue]=head;
+        HalDev->TxActQueueTail[Ch][Queue]=tcb_ptr;
+/*+GSG 030303*//*+GSG 030303*/
+        if (!HalDev->TxActive[Ch][Queue])
+          {
+
+           if (!WaitFlag)
+         {
+
+          /* write CPPI TX HDP */
+              (*(pTX_DMA_STATE_WORD_0( base )+( Ch *64)+( Queue )))  = VirtToPhys(head)  - HalDev->offset;
+              HalDev->TxActive[Ch][Queue]=TRUE;
+
+         }
+
+          }
+       }
+      else
+       {
+        HalDev->TxActQueueTail[Ch][Queue]->Next=head;
+        /* Emerald fix 10/29 */
+        *((bit32u *) VirtToVirtNoCache(&HalDev->TxActQueueTail[Ch][Queue]->HNext))=VirtToPhys(head)  - HalDev->offset;
+        HalDev->TxActQueueTail[Ch][Queue]=tcb_ptr;
+/*+GSG 030303*//*+GSG 030303*/
+       }
+     rc = EC_NO_ERRORS;
+     goto ExitSend;
+    } /* if (tcb_ptr) */
+   else
+    {
+     rc = EC_CPPI|EC_FUNC_SEND|EC_VAL_NO_TCBS;
+     goto ExitSend;
+    }
+ExitSend:
+
+    HalDev->OsFunc->CriticalOff();
+    return(rc);
+  }
+
+/*
+ *  This function processes receive interrupts.  It traverses the receive
+ *  buffer queue, extracting the data and passing it to the upper layer software via
+ *  osReceive().  It handles all error conditions and fragments without valid data by
+ *  immediately returning the RCB's to the RCB pool.
+ *
+ *  @param   HalDev   CPHAL module instance. (set by cphalInitModule())
+ *  @param   Ch       Channel Number.
+ *  @param   MoreWork Flag that indicates that there is more work to do when set to 1.
+ *
+ *  @return  0 if OK, non-zero otherwise.
+ */
+static int RxInt(HAL_DEVICE *HalDev, int Ch, int *MoreWork)
+  {
+  HAL_RCB *CurrentRcb, *LastRcb=0, *SopRcb, *EofRcb, *EopRcb;
+  bit32u RxBufStatus,PacketsServiced, RxPktLen = 0, RxSopStatus,
+    FrmFrags, TotalFrags, CurrDmaLen, DmaLen, FrmLen;
+  int base = HalDev->dev_base, Ret;
+  OS_FUNCTIONS *OsFunc = HalDev->OsFunc;
+  int RxServiceMax = HalDev->ChData[Ch].RxServiceMax;
+  int FragIndex; /* +GSG 030508 */
+  int EarlyReturn = 0; /* +GSG 030521 */
+
+  bit32u PktType, ExpDmaSize, Cells;
+  int PassHeader=0;
+
+  int mode;
+
+  bit32u SopOffset;
+
+  if(HalDev->NeedsCount) /* +MJH 030410 */
+    NeedsCheck(HalDev);  /* +MJH 030410 */
+
+  /* Handle case of teardown interrupt */
+  if (HalDev->RxTeardownPending[Ch] != 0)
+    {
+     Ret = RxTeardownInt(HalDev, Ch);
+     if (Ret == 0)
+       {                                                              /*+GSG 030303*/
+        *MoreWork = 0; /* bug fix 1/6 */                              /*+GSG 030303*/
+        return (EC_NO_ERRORS);
+       }                                                              /*+GSG 030303*/
+    }
+
+  CurrentRcb=HalDev->RxActQueueHead[Ch];
+
+  osfuncDataCacheHitInvalidate((void*)CurrentRcb, 16);
+
+  RxBufStatus=CurrentRcb->mode;
+
+  /* I think I need to do this to ensure that i read UuCpi properly,
+     which is on the second cache line of the Rcb */
+  osfuncDataCacheHitInvalidate((void*)((bit32u)CurrentRcb+16), 16);
+
+  PacketsServiced=0;
+  HalDev->InRxInt[Ch]=TRUE;
+
+  while((CurrentRcb)&&((RxBufStatus&CB_OWNERSHIP_BIT)==0)&&
+    (PacketsServiced<RxServiceMax)) /* ~GSG 030307 */
+    {
+
+    PacketsServiced++; /* ~GSG 030307 */
+    SopRcb=CurrentRcb;
+    RxSopStatus=RxBufStatus;
+
+    RxPktLen = RxSopStatus&CB_SIZE_MASK;
+    /* Not sure what MAC needs to do for next block */
+
+    PktType=((SopRcb->UuCpi & 0x00030000) >> 16);                           /* GSG ~030508 */
+    /* Calculate the expected DMA length */
+    if (RxPktLen != 0)
+      {
+       Cells=RxPktLen/48;
+       if ((RxPktLen%48) > 40)
+         Cells++;
+       if (PktType == PKT_TYPE_AAL5)                                        /* ~GSG 030508 */
+         Cells++;
+       ExpDmaSize=Cells*48;
+      }
+     else
+      {
+       ExpDmaSize=0;
+      }
+
+    SopOffset=(SopRcb->Off_BLen&CB_OFFSET_MASK)>>16;
+
+    CurrDmaLen=0;
+    FrmFrags=0;
+    TotalFrags=0;
+    FragIndex=0;
+    FrmLen=0;
+    EofRcb=0;
+
+/* +GSG 030508 */
+    if ((PktType == PKT_TYPE_OAM) || (PktType == PKT_TYPE_TRANS))            /* +GSG 030508 */
+      {                                                                      /* +GSG 030508 */
+       /* first frag is ATM Header */                                        /* +GSG 030508 */
+       PassHeader = 1;                                                       /* +GSG 030508 */
+       HalDev->fraglist[FragIndex].data = (void *)&SopRcb->AtmHeader;        /* +GSG 030508 */
+       HalDev->fraglist[FragIndex].len = 4;                                  /* +GSG 030508 */
+       HalDev->fraglist[FragIndex].OsInfo = SopRcb->OsInfo;                  /* +GSG 030701 */
+       FragIndex++;                                                          /* +GSG 030508 */
+      }                                                                      /* +GSG 030508 */
+/* +GSG 030508 */
+
+    do
+      {
+
+      DmaLen=CurrentRcb->Off_BLen&CB_SIZE_MASK;
+
+      CurrDmaLen+=DmaLen;
+      FrmLen+=DmaLen;
+      TotalFrags++;
+      if (!EofRcb)
+        {
+        HalDev->fraglist[FragIndex].data=((char *)CurrentRcb->DatPtr);       /* ~GSG 030508 */
+
+        HalDev->fraglist[FragIndex].data+=((FrmFrags==0)?SopOffset:0);       /* ~GSG 030508 */
+
+        HalDev->fraglist[FragIndex].len=DmaLen;                              /* ~GSG 030508 */
+
+        /* GSG 12/9 */
+        HalDev->fraglist[FragIndex].OsInfo = CurrentRcb->OsInfo;             /* ~GSG 030508 */
+
+        /* Upper layer must do the data invalidate */
+
+        FrmFrags++;
+        FragIndex++;                                                         /* ~GSG 030508 */
+        if (FrmLen>=RxPktLen)
+          EofRcb=CurrentRcb;
+        }
+      LastRcb=CurrentRcb;
+      CurrentRcb=LastRcb->Next;
+      if (CurrentRcb)
+        {
+         osfuncDataCacheHitInvalidate((void*)CurrentRcb,16);
+         /*         RxBufStatus=CurrentRcb->mode; */ /*DRB~030522*/
+        }
+      }while(((LastRcb->mode&CB_EOF_BIT)==0)&&(CurrentRcb));
+
+    /* New location for interrupt acknowledge */
+    /* Write the completion pointer */
+    (*(pRX_CPPI_COMP_PTR( base )+( Ch *64)))  = VirtToPhys(LastRcb) - HalDev->offset;
+
+    EopRcb=LastRcb;
+    HalDev->RxActQueueHead[Ch]=CurrentRcb;
+    HalDev->RxActQueueCount[Ch]-=TotalFrags;
+
+    if (LastRcb->mode&CB_EOQ_BIT)
+      {
+       if (CurrentRcb)
+         {
+
+          HalDev->Stats.RxMisQCnt[Ch]++;
+
+          (*(pRX_DMA_STATE_WORD_1( base )+( Ch *64)))  = LastRcb->HNext;
+         }
+        else
+         {
+
+          /* Rx EOQ */
+          HalDev->Stats.RxMisQCnt[Ch]++;
+
+          HalDev->RxActive[Ch]=FALSE;
+         }
+      }
+
+    EopRcb->Next=0;
+
+    /* setup SopRcb for the packet */
+    SopRcb->Eop=(void*)EopRcb;
+    SopRcb->FragCount=TotalFrags;
+
+    if ((ExpDmaSize!=CurrDmaLen)||(RxSopStatus&RX_ERROR_MASK))
+      {
+       /* check for Rx errors (only valid on SOP) */
+       if (RxSopStatus & RX_ERROR_MASK)
+         {
+          if (RxSopStatus & CRC_ERROR_MASK)
+            HalDev->Stats.CrcErrors[Ch]++;
+
+          if (RxSopStatus & LENGTH_ERROR_MASK)
+            HalDev->Stats.LenErrors[Ch]++;
+
+          if (RxSopStatus & ABORT_ERROR_MASK)
+            HalDev->Stats.AbortErrors[Ch]++;
+
+          if (RxSopStatus & STARV_ERROR_MASK)
+            HalDev->Stats.StarvErrors[Ch]++;
+         }
+        else
+         {
+          HalDev->Stats.DmaLenErrors[Ch]++; /* different type of length error */
+         }
+
+       EarlyReturn = 1;
+      }
+
+    /* do not pass up the packet if we're out of RCB's (or have an errored packet)*/
+    if ((CurrentRcb == 0) || (EarlyReturn == 1))
+      {
+       halRxReturn((HAL_RECEIVEINFO *)SopRcb,0);
+      }
+     else
+      {
+
+      if (EopRcb!=EofRcb)
+        {
+         HAL_RCB *FirstEmptyRcb;
+
+         FirstEmptyRcb = EofRcb->Next;
+         FirstEmptyRcb->Eop = (void*)EopRcb;
+         FirstEmptyRcb->FragCount = TotalFrags-FrmFrags;
+
+         halRxReturn((HAL_RECEIVEINFO *)FirstEmptyRcb,0);
+         SopRcb->Eop=(void*)EofRcb;
+         SopRcb->FragCount=FrmFrags;
+         EofRcb->Next=0;  /* Optional */
+        }
+
+      mode = Ch | (PktType << 16) | (PassHeader << 31);   /* ~GSG 030508 */
+
+      OsFunc->Receive(HalDev->OsDev,HalDev->fraglist,FragIndex,RxPktLen,             /* ~GSG 030508 */
+           (HAL_RECEIVEINFO *)SopRcb,mode);
+      } /* else */
+    
+    if (CurrentRcb)                                                                  /*MJH+030522*/
+      {
+       RxBufStatus=CurrentRcb->mode;
+      }
+    } /* while */
+
+  if ((CurrentRcb)&&((RxBufStatus&CB_OWNERSHIP_BIT)==0)) /*~GSG 030307*/
+    {
+     *MoreWork = 1;
+    }
+   else
+    {
+     *MoreWork = 0;
+    }
+
+  if (PacketsServiced != 0)
+    {
+      /* REMOVED when removing InRxInt */
+     if ((!HalDev->RxActive[Ch]) && (HalDev->RxActQueueCount[Ch]))
+       {
+        (*(pRX_DMA_STATE_WORD_1( base )+( Ch *64)))  = VirtToPhys(HalDev->RxActQueueHead[Ch]);
+    HalDev->RxActive[Ch]=TRUE;
+       }
+    }
+
+  HalDev->InRxInt[Ch]=FALSE;
+
+  /* update stats */
+  HalDev->Stats.RxPacketsServiced[Ch] += PacketsServiced;
+  HalDev->Stats.RxTotal += PacketsServiced;
+  if (HalDev->Stats.RxMaxServiced < PacketsServiced)
+    HalDev->Stats.RxMaxServiced = PacketsServiced;
+
+  return (EC_NO_ERRORS);
+  }
+
+/*
+ *  This function processes transmit interrupts.  It traverses the
+ *  transmit buffer queue, detecting sent data buffers and notifying the upper
+ *  layer software via osSendComplete().  (for SAR, i originally had this split
+ *  into two functions, one for each queue, but joined them on 8/8/02)
+ *
+ *  @param   HalDev   CPHAL module instance. (set by cphalInitModule())
+ *  @param   Queue    Queue number to service (always 0 for MAC, Choose 1 for SAR to service low priority queue)
+ *  @param   MoreWork Flag that indicates that there is more work to do when set to 1.
+ *
+ *  @return  0 if OK, non-zero otherwise.
+ */
+static int TxInt(HAL_DEVICE *HalDev, int Ch, int Queue, int *MoreWork)
+  {
+  HAL_TCB *CurrentTcb,*LastTcbProcessed,*FirstTcbProcessed;
+  int PacketsServiced;
+  bit32u TxFrameStatus;
+  int base = HalDev->dev_base, Ret;
+  int TxServiceMax = HalDev->ChData[Ch].TxServiceMax;
+  OS_FUNCTIONS *OsFunc = HalDev->OsFunc;
+
+  int OtherQueue = Queue^1;
+
+/*+GSG 030303*//*+GSG 030303*/
+
+  /* Handle case of teardown interrupt.  This must be checked at
+     the top of the function rather than the bottom, because
+     the normal data processing can wipe out the completion
+     pointer which is used to determine teardown complete. */
+  if (HalDev->TxTeardownPending[Ch] != 0)
+    {
+     Ret = TxTeardownInt(HalDev, Ch, Queue);
+     if (Ret == 0)
+       {                                                              /*+GSG 030303*/
+        *MoreWork = 0; /* bug fix 1/6 */                              /*+GSG 030303*/
+        return (EC_NO_ERRORS);
+       }                                                              /*+GSG 030303*/
+    }
+
+  CurrentTcb = HalDev->TxActQueueHead[Ch][Queue];
+  FirstTcbProcessed=CurrentTcb;
+
+  if (CurrentTcb==0)
+    {
+     /* I saw this error a couple of times when multi-channels were added */
+     dbgPrintf("[cppi TxInt()]TxH int with no TCB in queue!\n");
+     dbgPrintf("              Ch=%d, CurrentTcb = 0x%08x\n", Ch, (bit32u)CurrentTcb);
+     dbgPrintf("              HalDev = 0x%08x\n", (bit32u)HalDev);
+     osfuncSioFlush();
+     return(EC_CPPI|EC_FUNC_TXINT|EC_VAL_NULL_TCB);
+    }
+
+  osfuncDataCacheHitInvalidate((void *)CurrentTcb, 16);
+  TxFrameStatus=CurrentTcb->mode;
+  PacketsServiced=0;
+
+  /* should the ownership bit check be inside of the loop?? could make it a
+     while-do loop and take this check away */
+  if ((TxFrameStatus&CB_OWNERSHIP_BIT)==0)
+    {
+    OsFunc->CriticalOn(); /* +GSG 030307 */
+    do
+      {
+      /* Pop TCB(s) for packet from the stack */
+      LastTcbProcessed=CurrentTcb->Eop;
+
+      /* new location for acknowledge */
+      /* Write the completion pointer */
+      (*(pTXH_CPPI_COMP_PTR( base )+( Ch *64)+( Queue )))  = VirtToPhys(LastTcbProcessed);
+
+      HalDev->TxActQueueHead[Ch][Queue] = LastTcbProcessed->Next;
+
+/*+GSG 030303*//*+GSG 030303*/
+
+      osfuncDataCacheHitInvalidate((void *)LastTcbProcessed, 16);
+
+      if (LastTcbProcessed->mode&CB_EOQ_BIT)
+        {
+        if (LastTcbProcessed->Next)
+          {
+       /* Misqueued packet */
+
+           HalDev->Stats.TxMisQCnt[Ch][Queue]++;
+
+           (*(pTX_DMA_STATE_WORD_0( base )+( Ch *64)+( Queue )))  = LastTcbProcessed->HNext;
+          }
+         else
+          {
+       /* Tx End of Queue */
+
+       HalDev->Stats.TxEOQCnt[Ch][Queue]++;
+
+       HalDev->TxActive[Ch][Queue]=FALSE;
+          }
+        }
+
+      OsFunc->SendComplete(CurrentTcb->OsInfo);
+
+      /* Push Tcb(s) back onto the stack */
+      CurrentTcb = LastTcbProcessed->Next;
+
+      LastTcbProcessed->Next=HalDev->TcbPool[Ch][Queue];
+
+      HalDev->TcbPool[Ch][Queue]=FirstTcbProcessed;
+
+      PacketsServiced++;
+
+      TxFrameStatus=CB_OWNERSHIP_BIT;
+      /* set the first(SOP) pointer for the next packet */
+      FirstTcbProcessed = CurrentTcb;
+      if (CurrentTcb)
+        {
+     osfuncDataCacheHitInvalidate((void *)CurrentTcb, 16);
+         TxFrameStatus=CurrentTcb->mode;
+        }
+
+      }while(((TxFrameStatus&CB_OWNERSHIP_BIT)==0)
+             &&(PacketsServiced<TxServiceMax));
+
+    /* this fixes the SAR TurboDSL hardware bug (multiple queue failure) */
+    if (HalDev->TxActive[Ch][OtherQueue])
+      if (HalDev->TxActQueueHead[Ch][OtherQueue])
+        if ((*(pTX_DMA_STATE_WORD_0( base )+( Ch *64)+( OtherQueue )))  == 0)
+          {
+           osfuncDataCacheHitInvalidate(HalDev->TxActQueueHead[Ch][OtherQueue],16);
+           if ((HalDev->TxActQueueHead[Ch][OtherQueue]->mode) & CB_OWNERSHIP_BIT)
+             { 
+              HalDev->TurboDslErrors++;
+              (*(pTX_DMA_STATE_WORD_0( base )+( Ch *64)+( OtherQueue )))  = 
+                VirtToPhys(HalDev->TxActQueueHead[Ch][OtherQueue]);
+             }
+          }
+
+    OsFunc->CriticalOff(); /* +GSG 030307 */
+    if (((TxFrameStatus&CB_OWNERSHIP_BIT)==0)
+             &&(PacketsServiced==TxServiceMax))
+      {
+       *MoreWork = 1;
+      }
+     else
+      {
+       *MoreWork = 0;
+      }
+    }
+
+  /* update stats */
+  HalDev->Stats.TxPacketsServiced[Ch][Queue] += PacketsServiced;
+  HalDev->Stats.TxTotal += PacketsServiced;
+  if (HalDev->Stats.TxMaxServiced[Ch][Queue] < PacketsServiced)
+    HalDev->Stats.TxMaxServiced[Ch][Queue] = PacketsServiced;
+
+  return(EC_NO_ERRORS);
+  }
+
+/**
+ *  @ingroup CPHAL_Functions
+ *  This function performs a teardown for the given channel.  The value of the
+ *  Mode parameter controls the operation of the function, as documented below.
+ *
+ *  Note: If bit 3 of Mode is set, this call is blocking, and will not return
+ *  until the teardown interrupt has occurred and been processed. While waiting
+ *  for a blocking teardown to complete, ChannelTeardown() will signal the OS
+ *  (via Control(.."Sleep"..)) to allow the OS to perform other tasks if
+ *  necessary.  If and only if bit 3 of Mode is clear, the CPHAL will call the
+ *  OS TeardownComplete() function to indicate that the teardown has completed.
+ *
+ *  @param   HalDev  CPHAL module instance. (set by xxxInitModule())
+ *  @param   Ch      Channel number.
+ *  @param   Mode    Bit 0 (LSB): Perform Tx teardown (if set).<BR>
+ *                   Bit 1: Perform Rx teardown (if set). <BR>
+ *                   Bit 2: If set, perform full teardown (free buffers/descriptors).
+ *                          If clear, perform partial teardown (keep buffers). <BR>
+ *                   Bit 3 (MSB): If set, call is blocking.
+ *                            If clear, call is non-blocking.
+ *
+ *  @return  EC_NO_ERRORS (ok). <BR>
+ *           Possible Error Codes:<BR>
+ *           @ref EC_VAL_INVALID_STATE "EC_VAL_INVALID_STATE"<BR>
+ *           @ref EC_VAL_INVALID_CH "EC_VAL_INVALID_CH"<BR>
+ *           @ref EC_VAL_TX_TEARDOWN_ALREADY_PEND "EC_VAL_TX_TEARDOWN_ALREADY_PEND"<BR>
+ *           @ref EC_VAL_RX_TEARDOWN_ALREADY_PEND "EC_VAL_RX_TEARDOWN_ALREADY_PEND"<BR>
+ *           @ref EC_VAL_TX_CH_ALREADY_TORNDOWN "EC_VAL_TX_CH_ALREADY_TORNDOWN"<BR>
+ *           @ref EC_VAL_RX_CH_ALREADY_TORNDOWN "EC_VAL_RX_CH_ALREADY_TORNDOWN"<BR>
+ *           @ref EC_VAL_TX_TEARDOWN_TIMEOUT "EC_VAL_TX_TEARDOWN_TIMEOUT"<BR>
+ *           @ref EC_VAL_RX_TEARDOWN_TIMEOUT "EC_VAL_RX_TEARDOWN_TIMEOUT"<BR>
+ *           @ref EC_VAL_LUT_NOT_READY "EC_VAL_LUT_NOT_READY"<BR>
+ */
+static int halChannelTeardown(HAL_DEVICE *HalDev, int Ch, bit32 Mode)
+  {
+   int DoTx, DoRx, Sleep=2048, timeout=0;                         /*MJH~030306*/
+   bit32u base = HalDev->dev_base;
+
+/* Set the module, used for error returns */
+
+   int Ret;
+
+   /* AAL5 only supports tearing down both sides at once (currently)*/
+   Mode = (Mode | TX_TEARDOWN | RX_TEARDOWN);
+
+   DoTx = (Mode & TX_TEARDOWN);
+   DoRx = (Mode & RX_TEARDOWN);
+
+   if (HalDev->State < enInitialized)
+     return(EC_AAL5 |EC_FUNC_CHTEARDOWN|EC_VAL_INVALID_STATE);
+
+   if ((Ch < 0) || (Ch > MAX_AAL5_CHAN ))
+     {
+     return(EC_AAL5 |EC_FUNC_CHTEARDOWN|EC_VAL_INVALID_CH);
+     }
+
+   /* set teardown pending bits before performing the teardown, because they
+      will be used in the int handler (this is done for AAL5) */
+   if (DoTx)
+     {
+      if (HalDev->TxTeardownPending[Ch] != 0)
+        return(EC_AAL5 |EC_FUNC_CHTEARDOWN|EC_VAL_TX_TEARDOWN_ALREADY_PEND);
+
+      /* If a full teardown, this also means that the user must
+      setup all channels again to use them */
+      if (Mode & FULL_TEARDOWN)
+        HalDev->ChIsSetup[Ch][DIRECTION_TX] = 0;
+
+      if (HalDev->State < enOpened)
+        {
+         /* if the hardware has never been opened, the channel has never actually
+         been setup in the hardware, so I just need to reset the software flag
+         and leave */
+         HalDev->ChIsSetup[Ch][DIRECTION_TX] = 0;
+         return (EC_NO_ERRORS);
+    }
+       else
+    {
+         if (HalDev->ChIsOpen[Ch][DIRECTION_TX] == 0)
+       {
+            return(EC_AAL5 |EC_FUNC_CHTEARDOWN|EC_VAL_TX_CH_ALREADY_TORNDOWN);
+       }
+
+         /* set teardown flag */
+         HalDev->TxTeardownPending[Ch] = Mode;
+    }
+     }
+
+   if (DoRx)
+     {
+      if (HalDev->RxTeardownPending[Ch] != 0)
+        return(EC_AAL5 |EC_FUNC_CHTEARDOWN|EC_VAL_RX_TEARDOWN_ALREADY_PEND);
+
+      if (Mode & FULL_TEARDOWN)
+        HalDev->ChIsSetup[Ch][DIRECTION_RX] = 0;
+
+      if (HalDev->State < enOpened)
+        {
+         HalDev->ChIsSetup[Ch][DIRECTION_RX] = 0;
+         return (EC_NO_ERRORS);
+    }
+       else
+    {
+         if (HalDev->ChIsOpen[Ch][DIRECTION_RX] == 0)
+           return(EC_AAL5 |EC_FUNC_CHTEARDOWN|EC_VAL_RX_CH_ALREADY_TORNDOWN);
+
+         HalDev->RxTeardownPending[Ch] = Mode;
+    }
+     }
+
+   /* Perform Tx Teardown Duties */
+   if ((DoTx) && (HalDev->State == enOpened))
+     {
+      /* Request TX channel teardown */
+      (TX_CPPI_TEARDOWN_REG( base ))  = Ch;
+
+      /* wait until teardown has completed */
+      if (Mode & BLOCKING_TEARDOWN)
+        {
+     timeout = 0;
+         while (HalDev->ChIsOpen[Ch][DIRECTION_TX] == TRUE)
+       {
+            osfuncSleep(&Sleep);
+
+            timeout++;
+        if (timeout > 100000)
+          {
+               return(EC_AAL5 |EC_FUNC_CHTEARDOWN|EC_VAL_TX_TEARDOWN_TIMEOUT);
+          }
+       }
+    }
+     } /* if DoTx */
+
+   /* Perform Rx Teardown Duties */
+   if ((DoRx) && (HalDev->State == enOpened))
+     {
+
+      /* call main teardown routine for Rx */
+      Ret = HalDev->SarFunc->ChannelTeardown(HalDev->SarDev, Ch, Mode);
+      if (Ret) return (Ret);
+
+      if (Mode & BLOCKING_TEARDOWN)
+        {
+     timeout = 0;
+         while (HalDev->ChIsOpen[Ch][DIRECTION_RX] == TRUE)
+       {
+            osfuncSleep(&Sleep);
+
+            timeout++;
+        if (timeout > 100000)
+          {
+               return(EC_AAL5 |EC_FUNC_CHTEARDOWN|EC_VAL_RX_TEARDOWN_TIMEOUT);
+          }
+       }
+        }
+     } /* if DoRx */
+
+   return (EC_NO_ERRORS);
+  }
+
+/**
+ *  @ingroup CPHAL_Functions
+ *  This function closes the CPHAL module.  The module will be reset.
+ *  The Mode parameter should be used to determine the actions taken by
+ *  Close().
+ *
+ *  @param   HalDev   CPHAL module instance. (set by xxxInitModule())
+ *  @param   Mode     Indicates actions to take on close.  The following integer
+ *                    values are valid: <BR>
+ *                    1:  Does not free buffer resources, init parameters remain
+ *                        intact.  User can then call Open() without calling Init()
+ *                        to attempt to reset the device and bring it back to the
+ *                        last known state.<BR>
+ *                    2:  Frees the buffer resources, but keeps init parameters.  This
+ *                        option is a more aggressive means of attempting a device reset.
+ *                    3:  Frees the buffer resources, and clears all init parameters. <BR>
+ *                        At this point, the caller would have to call to completely
+ *                        reinitialize the device (Init()) before being able to call
+ *                        Open().  Use this mode if you are shutting down the module
+ *                        and do not plan to restart.
+ *
+ *  @return  EC_NO_ERRORS (ok).<BR>
+ *           Possible Error Codes:<BR>
+ *           @ref EC_VAL_INVALID_STATE "EC_VAL_INVALID_STATE"<BR>
+ *           Any error code from halChannelTeardown().<BR>
+ */
+static int halClose(HAL_DEVICE *HalDev, bit32 Mode)
+  {
+   int Ch, Inst, Ret;
+   OS_DEVICE *TmpOsDev;
+   OS_FUNCTIONS *TmpOsFunc;
+   HAL_FUNCTIONS *TmpHalFunc;
+   char *TmpDeviceInfo;
+
+   CPSAR_FUNCTIONS *TmpSarFunc;
+   CPSAR_DEVICE *TmpSarDev;
+
+   /* Verify proper device state */
+   if (HalDev->State != enOpened)
+     return (EC_AAL5  | EC_FUNC_CLOSE|EC_VAL_INVALID_STATE);
+
+   /* Teardown all open channels */
+   for (Ch = 0; Ch <= MAX_AAL5_CHAN ; Ch++)
+     {
+      if (HalDev->ChIsOpen[Ch][DIRECTION_TX] == TRUE)
+        {
+         if (Mode == 1)
+           {
+            Ret = halChannelTeardown(HalDev, Ch, TX_TEARDOWN | PARTIAL_TEARDOWN | BLOCKING_TEARDOWN);
+            if (Ret) return (Ret);
+           }
+          else
+           {
+            Ret = halChannelTeardown(HalDev, Ch, TX_TEARDOWN | FULL_TEARDOWN | BLOCKING_TEARDOWN);
+            if (Ret) return (Ret);
+           }
+        }
+
+      if (HalDev->ChIsOpen[Ch][DIRECTION_RX] == TRUE)
+        {
+         if (Mode == 1)
+           {
+            Ret = halChannelTeardown(HalDev, Ch, RX_TEARDOWN | PARTIAL_TEARDOWN | BLOCKING_TEARDOWN);
+            if (Ret) return (Ret);
+           }
+          else
+           {
+            Ret = halChannelTeardown(HalDev, Ch, RX_TEARDOWN | FULL_TEARDOWN | BLOCKING_TEARDOWN);
+            if (Ret) return (Ret);
+           }
+        }
+     }
+
+   /* free fraglist in HalDev */
+   HalDev->OsFunc->Free(HalDev->fraglist);
+   HalDev->fraglist = 0;
+
+   /* unregister the interrupt */
+   HalDev->OsFunc->IsrUnRegister(HalDev->OsDev, HalDev->interrupt);
+
+   /* Disable the Tx CPPI DMA */
+   TX_CPPI_CTL_REG(HalDev->dev_base) = 0;
+
+   /* Disable the Rx CPPI DMA */
+   RX_CPPI_CTL_REG(HalDev->dev_base) = 0;
+
+   /* Close the SAR hardware - puts the device in reset if this module is the
+      "last one out" */
+   HalDev->SarFunc->Close(HalDev->SarDev, Mode);
+
+   /* If mode is 3, than clear the HalDev and set next state to DevFound*/
+   if (Mode == 3)
+     {
+      /* I need to keep the HalDev parameters that were setup in InitModule */
+      TmpOsDev = HalDev->OsDev;
+      TmpOsFunc = HalDev->OsFunc;
+      TmpDeviceInfo = HalDev->DeviceInfo;
+
+      TmpSarFunc = HalDev->SarFunc;
+      TmpSarDev = HalDev->SarDev;
+
+      TmpHalFunc = HalDev->HalFuncPtr;
+      Inst = HalDev->Inst;
+
+      /* Clear HalDev */
+
+      HalDev->OsFunc->Memset(HalDev, 0, sizeof(HAL_DEVICE));
+
+      /* Restore key parameters */
+      HalDev->OsDev = TmpOsDev;
+      HalDev->OsFunc = TmpOsFunc;
+      HalDev->DeviceInfo = TmpDeviceInfo;
+
+      HalDev->SarFunc = TmpSarFunc;
+      HalDev->SarDev = TmpSarDev;
+
+      HalDev->HalFuncPtr = TmpHalFunc;
+      HalDev->Inst = Inst;
+
+      HalDev->State = enDevFound;
+     }
+    else
+     {
+      HalDev->State = enInitialized;
+     }
+
+   return(EC_NO_ERRORS);
+  }
diff -urN linux.old/drivers/atm/sangam_atm/cpremap_cpaal5.c linux.dev/drivers/atm/sangam_atm/cpremap_cpaal5.c
--- linux.old/drivers/atm/sangam_atm/cpremap_cpaal5.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cpremap_cpaal5.c	2005-08-23 04:46:50.084845672 +0200
@@ -0,0 +1,27 @@
+#ifndef _INC_CPREMAP_C
+#define _INC_CPREMAP_C
+
+#ifdef __ADAM2
+static inline void osfuncDataCacheHitInvalidate(void *ptr, int Size)
+  {
+  asm(" cache  17, (%0)" : : "r" (ptr));
+  }
+
+static inline void osfuncDataCacheHitWriteback(void *ptr, int Size)
+  { 
+  asm(" cache  25, (%0)" : : "r" (ptr));
+  }
+
+#else
+  #define osfuncDataCacheHitInvalidate(MemPtr, Size)   HalDev->OsFunc->DataCacheHitInvalidate(MemPtr, Size)
+  #define osfuncDataCacheHitWriteback(MemPtr, Size)    HalDev->OsFunc->DataCacheHitWriteback(MemPtr, Size)
+#endif
+
+/*
+#define osfuncDataCacheHitInvalidate(ptr, Size) asm(" cache  17, (%0)" : : "r" (ptr))
+#define osfuncDataCacheHitWriteback(ptr, Size)  asm(" cache  25, (%0)" : : "r" (ptr))
+*/
+
+
+
+#endif
diff -urN linux.old/drivers/atm/sangam_atm/cpremap_cpsar.c linux.dev/drivers/atm/sangam_atm/cpremap_cpsar.c
--- linux.old/drivers/atm/sangam_atm/cpremap_cpsar.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cpremap_cpsar.c	2005-08-23 04:46:50.084845672 +0200
@@ -0,0 +1,27 @@
+#ifndef _INC_CPREMAP_C
+#define _INC_CPREMAP_C
+
+#ifdef __ADAM2
+static inline void osfuncDataCacheHitInvalidate(void *ptr, int Size)
+  {
+  asm(" cache  17, (%0)" : : "r" (ptr));
+  }
+
+static inline void osfuncDataCacheHitWriteback(void *ptr, int Size)
+  { 
+  asm(" cache  25, (%0)" : : "r" (ptr));
+  }
+
+#else
+  #define osfuncDataCacheHitInvalidate(MemPtr, Size)   HalDev->OsFunc->DataCacheHitInvalidate(MemPtr, Size)
+  #define osfuncDataCacheHitWriteback(MemPtr, Size)    HalDev->OsFunc->DataCacheHitWriteback(MemPtr, Size)
+#endif
+
+/*
+#define osfuncDataCacheHitInvalidate(ptr, Size) asm(" cache  17, (%0)" : : "r" (ptr))
+#define osfuncDataCacheHitWriteback(ptr, Size)  asm(" cache  25, (%0)" : : "r" (ptr))
+*/
+
+
+
+#endif
diff -urN linux.old/drivers/atm/sangam_atm/cpsar.c linux.dev/drivers/atm/sangam_atm/cpsar.c
--- linux.old/drivers/atm/sangam_atm/cpsar.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cpsar.c	2005-08-23 04:46:50.086845368 +0200
@@ -0,0 +1,881 @@
+/**
+ *  cpsar.c
+ *
+ *  TNETDxxxx Software Support\n
+ *  Copyright (c) 2002 Texas Instruments Incorporated. All Rights Reserved.
+ *
+ *  This file contains the HAL for the CPSAR module.  In the software
+ *  architecture, the CPSAR module is used exclusively by the AAL5 and AAL2
+ *  CPHAL modules.  AAL5 and AAL2 may utilize the same CPSAR instance
+ *  simulataneously.
+ *
+ *  version
+ *      5Sep02 Greg        1.00  Original Version created.
+ */
+
+/* register files */
+#include "cp_sar_reg.h"  
+
+#define _CPHAL_CPSAR
+#define _CPHAL 
+
+#define WAIT_THRESH           200000
+#define IRAM_SIZE             1536
+#define MAX_INST              2
+
+/*  OS Data Structure definition  */
+
+typedef void OS_PRIVATE;
+typedef void OS_DEVICE;
+typedef void OS_SENDINFO;
+typedef void OS_RECEIVEINFO;
+typedef void OS_SETUP;
+
+/*  CPHAL Data Structure definitions  */
+
+typedef struct cpsar_device  CPSAR_DEVICE;
+typedef struct cpsar_device  HAL_DEVICE;
+typedef void HAL_RECEIVEINFO;
+
+#define MAX_QUEUE  2
+#define MAX_CHAN 19
+
+#include "cpcommon_cpsar.h"
+#include "cpswhal_cpsar.h"
+#include "cpsar.h"
+#include "cpcommon_cpsar.c"
+
+static CPSAR_DEVICE *CpsarDev[MAX_INST]= {0,0};
+
+/*
+ *  Returns statistics information.
+ *
+ *  @param  HalDev   CPHAL module instance. (set by xxxInitModule())  
+ *
+ *  @return 0
+ */
+static int StatsGet3(CPSAR_DEVICE *HalDev)
+  {
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpsar]StatsGet3(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+   /*
+   dbgPrintf("CPSAR General Stats:\n");
+   DispHexStat(HalDev, "Base Address",HalDev->dev_base);
+   DispStat(HalDev, "Offset (VLYNQ)",HalDev->offset);
+   DispStat(HalDev, "Debug Level",HalDev->debug);
+   DispStat(HalDev, "Instance",HalDev->Inst);
+   DispHexStat(HalDev, "Reset Address",HalDev->ResetBase);
+   DispStat(HalDev, "Reset Bit",HalDev->ResetBit);
+   */
+   return (EC_NO_ERRORS);
+  }
+
+/* +GSG 030407 */
+static void SetOamMode(HAL_DEVICE *HalDev)
+  {
+   int Ch;
+   volatile bit32u *pTmp;
+   int OamMode = (1<<8);
+
+   /* any configuration of OamMode affects all VC's, including AAL2 */
+   for (Ch = 0; Ch < MAX_CHAN; Ch++)
+     {
+      if (Ch < 16)
+        pTmp = (pPDSP_AAL5_RX_STATE_WORD_0(HalDev->dev_base) + (Ch*64));
+       else
+        pTmp = (pPDSP_AAL2_RX_STATE_WORD_0(HalDev->dev_base) + ((Ch-16)*64));
+
+      if (HalDev->OamMode == 0)
+        {
+         *pTmp &=~ OamMode;
+        }
+       else
+        {
+         *pTmp |= OamMode;
+        }
+     }
+  }
+
+static int halControl(CPSAR_DEVICE *HalDev, const char *Key, const char *Action, void *Value)
+  {
+   int KeyFound=0, ActionFound=0, rc=EC_NO_ERRORS, Ch;  /* +RC3.02*/
+   char *TmpKey = (char *)Key;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpsar]halControl(HalDev:%08x, Key:%s, Action:%s, Value:%08x)\n", (bit32u)HalDev,
+                Key, Action, (bit32u)Value);
+      osfuncSioFlush();
+     }
+#endif  
+
+   if (HalDev->OsFunc->Strcmpi(Key, "Debug") == 0)
+     {
+      KeyFound=1; /* +RC3.02*/
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1; /* +RC3.02*/
+         HalDev->debug = *(int *)Value;
+        }
+     }
+
+   /* +GSG 030407 */
+   if (HalDev->OsFunc->Strcmpi(Key, "OamMode") == 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         HalDev->OamMode = *(int *)Value;
+
+         /* only do this if we're open */
+         if (HalDev->OpenCount > 0)
+           SetOamMode(HalDev);
+        }
+
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        {
+         ActionFound=1;
+         *(int *)Value = HalDev->OamMode;
+        }
+     }
+
+   if (HalDev->OsFunc->Strcmpi(Key, "Stats3") == 0)
+     {
+      if (HalDev->OsFunc->Strcmpi(Action, "Get") == 0)
+        StatsGet3(HalDev);
+     }
+
+   /* +RC3.02  (if statement) */
+   /* Fixes PITS #98 */
+   if (HalDev->OsFunc->Strstr(Key, "PdspEnable") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         
+         /* Configure PDSP enable bit based on Value*/
+         if (*(int *)Value & 1)
+           {
+            /* enable PDSP */
+            PDSP_CTRL_REG(HalDev->dev_base) |= 0x2;
+           }
+          else
+           {
+            /* disable PDSP */
+            PDSP_CTRL_REG(HalDev->dev_base) &=~ 0x2;
+           }
+        }
+     }
+
+   if (HalDev->OsFunc->Strstr(Key, "FwdUnkVc.") != 0)
+     {
+      KeyFound=1;
+      if (HalDev->OsFunc->Strcmpi(Action, "Set") == 0)
+        {
+         ActionFound=1;
+         
+         /* extract channel number */
+         TmpKey += HalDev->OsFunc->Strlen("FwdUnkVc.");
+         Ch = HalDev->OsFunc->Strtoul(TmpKey, &TmpKey, 10);
+
+         /* Configure forwarding of unknown VCI/VPI cells */
+         SAR_PDSP_FWD_UNK_VC_REG(HalDev->dev_base) = (((*(int*)Value)<<31) | Ch);
+        }
+     }
+
+   if (KeyFound == 0) /* +RC3.02 */
+     rc = (EC_CPSAR|EC_FUNC_CONTROL|EC_VAL_KEY_NOT_FOUND); /* +RC3.02 */
+
+   if (ActionFound == 0) /* +RC3.02 */
+     rc = (EC_CPSAR|EC_FUNC_CONTROL|EC_VAL_ACTION_NOT_FOUND); /* +RC3.02 */
+
+   return(rc);   /* ~RC3.02 */
+  }
+
+/*
+ * This function opens the specified channel.
+ *  
+ * @param   HalDev  CPHAL module instance. (set by cphalInitModule())   
+ * @param   Ch      Channel number.
+ *
+ * @return  0 OK, Non-zero Not OK
+ */
+static int halChannelSetup(CPSAR_DEVICE *HalDev, CHANNEL_INFO *HalCh)
+  {
+  int i;
+  int Ch = HalCh->Channel;
+  int PdspChBlock = Ch;
+  int PdspBlockOffset = 0;
+  volatile bit32u *pTmp;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpsar]halChannelSetup(HalDev:%08x, HalCh:%08x)\n", (bit32u)HalDev,
+                (bit32u)HalCh);
+      osfuncSioFlush();
+     }
+#endif
+
+  /* Figure out the correct offset from the start of the PDSP
+     Scratchpad RAM (starting at 0x8050 in the SAR) */
+  if (Ch > 15)
+    {
+     /* this is an AAL2 channel, which are channels 16-18 */
+     PdspChBlock = Ch - 16;  
+     /* Get the offset to the AAL2 portion of the block (in words) */
+     PdspBlockOffset = NUM_PDSP_AAL5_STATE_WORDS + (PdspChBlock*64);
+     /* Clear PDSP State RAM */
+     /*pTmp = (pPDSP_BLOCK_0(HalDev->dev_base)+PdspBlockOffset);
+     for (i=0; i<NUM_PDSP_AAL2_STATE_WORDS; i++)
+     *pTmp++ = 0;*/
+    }
+   else
+    {
+     /* Get the offset to the AAL5 portion of the block (in words) */
+     PdspBlockOffset = (PdspChBlock*64);
+     /* Clear PDSP State RAM */
+     /*pTmp = (pPDSP_BLOCK_0(HalDev->dev_base)+PdspBlockOffset);
+     for (i=0; i<NUM_PDSP_AAL5_STATE_WORDS; i++)
+     *pTmp++ = 0;*/
+    }
+
+  /* Configure PDSP State RAM */
+
+  /* Setup TX PDSP State RAM */
+  pTmp = (pPDSP_BLOCK_0(HalDev->dev_base)+PdspBlockOffset);
+  *pTmp++ = HalCh->TxVc_CellRate;        /* Set the cell rate in cells/sec */
+  *pTmp++ = HalCh->TxVc_QosType;         /* Configure the QoS Type */
+  *pTmp++ = HalCh->TxVc_Mbs;             /* Set minimum burst size */
+  *pTmp++ = 0;                           /* (skip a register) */
+  *pTmp++ = HalCh->TxVc_Pcr;             /* set the peak cell rate */
+  *pTmp++ = 0;                           /* new addition 4.9.02 */
+  *pTmp++ = HalCh->TxVc_AtmHeader;       /* give the ATM header */
+  *pTmp++ = (HalCh->TxVc_OamTc << 8) 
+            |(HalCh->TxVc_VpOffset);     /* Set the OAM TC Path and VP Offset */
+   
+  /* Setup RX PDSP State RAM */
+  *pTmp++ = (HalCh->RxVc_OamCh)|
+    (HalDev->OamMode << 8) |
+    (HalCh->RxVc_OamToHost<<9);          /* Set OAM Channel, Mode, and ToHost options */
+  *pTmp++ = HalCh->RxVc_AtmHeader;       /* ATM hdr put on firmware generated OAM */
+  *pTmp++ = (HalCh->RxVc_VpOffset)|      /* Set Rx OAM TC Path and VP Offset */
+    (HalCh->RxVc_OamTc<<8);                 
+           
+  /* Setup TX VP PDSP State RAM */
+  pTmp = (pPDSP_BLOCK_0(HalDev->dev_base)+PdspBlockOffset+16); /*GSG~030703 12->16 */
+  *pTmp++ = HalCh->TxVp_AtmHeader;
+  *pTmp++ = (HalCh->TxVp_OamTc << 8);
+
+  /* Setup RX VP PDSP State RAM */
+  pTmp = (pPDSP_BLOCK_0(HalDev->dev_base)+PdspBlockOffset+20); /*GSG~030703 16->20 */
+  *pTmp++ = HalCh->RxVp_AtmHeader;
+  *pTmp++ = (HalCh->RxVp_OamCh)|
+    (HalCh->RxVp_OamTc<<8)|
+    (HalCh->RxVp_OamToHost<<9);           /* Set OAM Channel, Mode, and ToHost options */
+  *pTmp++ = 0;
+  *pTmp++ = HalCh->RxVp_OamVcList;
+
+  /* Configure forwarding of unknown VCI/VPI cells */
+  if (HalCh->PktType == 3)
+    SAR_PDSP_FWD_UNK_VC_REG(HalDev->dev_base) = ((HalCh->FwdUnkVc<<31)|Ch);
+
+  /* Configure Tx Channel Mapping Register (turn channel "ON") */
+  TX_CH_MAPPING_REG(HalDev->dev_base) = 0x80000000  | 
+                                        (HalCh->DaMask << 30) 
+                                        | (HalCh->Priority << 24) | Ch;
+
+  /* Setup Rx Channel in the LUT */
+  i=0;
+  while (!(RX_LUT_CH_SETUP_REQ_REG(HalDev->dev_base) & 0x80000000))
+    {
+    if (i > WAIT_THRESH)
+      {
+       return(EC_CPSAR|EC_FUNC_CHSETUP|EC_VAL_LUT_NOT_READY);
+      }
+    else
+      i++;
+    }
+
+  /* RX LUT is ready */
+  RX_LUT_CH_SETUP_REQ_REG(HalDev->dev_base) = (HalCh->PktType << 24) | Ch;
+  RX_LUT_CH_SETUP_REQ_VC_REG(HalDev->dev_base) = ((HalCh->Vpi << 20) |  
+    (HalCh->Vci << 4));
+
+  return (EC_NO_ERRORS);
+  }
+
+static int halChannelTeardown(CPSAR_DEVICE *HalDev, int Ch, bit32 Mode)
+  {
+   int waitcnt = 0;
+   int PdspBlockOffset = 0, i;
+   volatile bit32u *pTmp;
+
+#ifdef __CPHAL_DEBUG
+  if (DBG(0))
+    {
+     dbgPrintf("[cpsar]halChannelTeardown(HalDev:%08x, Ch:%d, Mode:%d\n", 
+                            (bit32u)HalDev, Ch, Mode);
+     osfuncSioFlush();
+    }
+#endif
+
+   if ((Ch < 0) || (Ch > MAX_CHAN)) 
+     return(EC_CPSAR|EC_FUNC_CHTEARDOWN|EC_VAL_INVALID_CH);
+
+   /* Request RX channel teardown through LUT */
+   while ((RX_LUT_CH_TEARDOWN_REQ_REG(HalDev->dev_base) & 0x80000000) == 0)
+     {
+      waitcnt++;
+      if (waitcnt == WAIT_THRESH)
+        {
+         return(EC_CPSAR|EC_FUNC_CHTEARDOWN|EC_VAL_LUT_NOT_READY);
+        }
+     }
+
+   RX_LUT_CH_TEARDOWN_REQ_REG(HalDev->dev_base) = (Ch & 0xffff);
+
+   /* for AAL2, clear channel PDSP RAM here.  AAL5 does it when the teardown
+      has completed (which is asynchronous)*/
+   if (Ch > 15)
+     {
+      /* Get the offset to the AAL2 portion of the block (in words) */
+      PdspBlockOffset = NUM_PDSP_AAL5_STATE_WORDS + ((Ch-16)*64);
+      /* Clear PDSP State RAM */
+      pTmp = (pPDSP_BLOCK_0(HalDev->dev_base)+PdspBlockOffset);
+      for (i=0; i<NUM_PDSP_AAL2_STATE_WORDS; i++)
+        *pTmp++ = 0;
+     }
+
+   return (EC_NO_ERRORS);
+  }
+
+int InitPdsp(CPSAR_DEVICE *HalDev)
+  {
+   bit32u NumOfEntries,i,IRamAddress,iTmp;
+   int *SarPdspFirmware; /* ~GSG 030403 */
+   int FirmwareSize, rc; /* ~GSG 030403 */
+
+#ifdef __CPHAL_DEBUG
+  if (DBG(0))
+    {
+     dbgPrintf("[cpsar]InitPdsp(HalDev:%08x)\n", (bit32u)HalDev);
+     osfuncSioFlush();
+    }
+#endif
+
+   /* Get firmware */
+   rc = HalDev->OsFunc->Control(HalDev->OsDev, "Firmware", "Get", &SarPdspFirmware);  /* ~GSG 030403 */
+   if (rc)                                                  /* +GSG 030403 */
+     return (EC_CPSAR|EC_FUNC_OPEN|EC_VAL_KEY_NOT_FOUND);   /* +GSG 030403 */
+
+   /* Get firmware size */
+   rc = HalDev->OsFunc->Control(HalDev->OsDev, "FirmwareSize", "Get", &FirmwareSize); /* ~GSG 030403 */
+   if (rc)                                                  /* +GSG 030403 */
+     return (EC_CPSAR|EC_FUNC_OPEN|EC_VAL_KEY_NOT_FOUND);   /* +GSG 030403 */
+
+   IRamAddress = (bit32u) pPDSP_CTRL_REG(HalDev->dev_base);
+ 
+   NumOfEntries = (FirmwareSize)/4;                         /* ~GSG 030403 */
+   if (NumOfEntries > IRAM_SIZE)
+     {
+       /* Note: On Avalanche, they truncated the PDSP firmware and warned */
+       /* NumOfEntries = IRAM_SIZE; */
+       return(EC_CPSAR|EC_FUNC_INIT|EC_VAL_FIRMWARE_TOO_LARGE);
+     }
+   for(i=8;i<NumOfEntries;i++)
+     (*((bit32 *) (IRamAddress+(i*4))))=SarPdspFirmware[i]; /* ~GSG 030403 */
+
+      /* Check code */
+   for(i=8;i<NumOfEntries;i++)
+     {
+       iTmp=(*((bit32 *) (IRamAddress+(i*4))));
+       if (iTmp != SarPdspFirmware[i])                      /* ~GSG 030403 */
+         {
+           return(EC_CPSAR|EC_FUNC_OPEN|EC_VAL_PDSP_LOAD_FAIL);
+         }
+     }
+      
+   return(EC_NO_ERRORS);
+  }
+
+/*
+ *  This function probes for the instance of the CPHAL module.  It will call
+ *  the OS function @c DeviceFindInfo() to get the information required.
+ *  
+ *  @param   HalDev      CPHAL module instance. (set by xxxInitModule())
+ *
+ *  @return  0 OK, Otherwise error.
+ */
+static int halProbe(CPSAR_DEVICE *HalDev)
+  {
+   int Ret;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpsar]halProbe(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(1))
+     {
+      dbgPrintf("[os]DeviceFindInfo(Inst:%d, DeviceName:%s, DeviceInfo:%08x)\n",
+                HalDev->Inst, "sar", (bit32u)&HalDev->DeviceInfo);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Attempt to find the device information */
+   Ret = HalDev->OsFunc->DeviceFindInfo(HalDev->Inst, "sar", &HalDev->DeviceInfo);
+   if (Ret)
+     return(EC_CPSAR|EC_FUNC_PROBE|EC_VAL_DEVICE_NOT_FOUND);
+
+   return(EC_NO_ERRORS);    
+  }
+
+#ifdef __CPHAL_DEBUG
+static void dbgConfigDump(HAL_DEVICE *HalDev)
+  {
+   dbgPrintf("  [cpsar Inst %d] Config Dump:\n", HalDev->Inst);
+   dbgPrintf("    Base    :%08x, offset   :%08d\n", 
+             HalDev->dev_base, HalDev->offset);
+   dbgPrintf("    ResetBit:%08d, ResetBase:%08x\n", 
+             HalDev->ResetBit, HalDev->ResetBase);
+   dbgPrintf("    UniNni  :%08d, debug    :%08d\n", 
+             HalDev->ResetBit, HalDev->debug);
+   osfuncSioFlush();
+  }
+#endif
+
+/*
+ * Sets up HAL default configuration parameter values.
+ */
+static void ConfigInit(CPSAR_DEVICE *HalDev)
+  {
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpsar]ConfigInit(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+   /* configure some defaults with tnetd7300 values */
+   HalDev->dev_base = 0xa3000000;
+   HalDev->offset = 0;
+   HalDev->UniNni = CFG_UNI_NNI;
+   HalDev->ResetBit = 9;
+   HalDev->debug = 0;
+   HalDev->ResetBase = 0xa8611600;
+  }
+
+/*
+ * Retrieve HAL configuration parameter values.
+ */
+static bit32u ConfigGet(HAL_DEVICE *HalDev)
+  {
+   bit32u ParmValue, error_code;
+   char *DeviceInfo = HalDev->DeviceInfo;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpsar]ConfigGet(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* get the configuration parameters common to all modules */
+   error_code = ConfigGetCommon(HalDev);
+   if (error_code) return (EC_CPSAR|error_code);
+
+   /* get SAR specific configuration parameters */
+   error_code = HalDev->OsFunc->DeviceFindParmUint(DeviceInfo,"UniNni",&ParmValue);
+   if (!error_code) HalDev->UniNni = ParmValue;
+
+   return (EC_NO_ERRORS);
+  }
+
+static int halInit(CPSAR_DEVICE *HalDev)
+  {
+   bit32u Ret;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpsar]halInit(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(7))
+     {
+      dbgPrintf("[cpsar halInit()]InitCount = %d\n", HalDev->InitCount);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Only run the init code for the first calling module per instance */
+   if (HalDev->InitCount > 1)
+     {
+      return (EC_NO_ERRORS);
+     }
+
+   /* Configure HAL defaults */
+   ConfigInit(HalDev);
+
+   /* Retrieve HAL configuration parameters from data store */
+   Ret = ConfigGet(HalDev);
+   if (Ret) return (Ret);
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(9))
+     dbgConfigDump(HalDev);
+#endif
+
+   return(EC_NO_ERRORS);
+  }
+
+static int halOpen(CPSAR_DEVICE *HalDev)
+  {
+   int Ret, Ticks=64;
+   int i;              /*+GSG 030407*/
+   volatile int *pTmp; /*+GSG 030407*/
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpsar]halOpen(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(7))
+     {
+      dbgPrintf("[cpsar halOpen()]OpenCount = %d\n", HalDev->OpenCount);      
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Only run the open code for the first calling module per instance */
+   if (HalDev->OpenCount++ > 0)
+     {
+      return (EC_NO_ERRORS);
+     }
+
+   /* Take SAR out of reset */
+   if (((*(volatile bit32u *)(HalDev->ResetBase)) & (1<<HalDev->ResetBit)) != 0)
+     {
+       /** @todo Should I somehow call AAL5/AAL2 Close() here? All I've done
+           here is copy the Close code from each and paste it here. */   
+
+#ifdef __CPHAL_DEBUG
+      if (DBG(7))
+        {
+         dbgPrintf("[cpsar halOpen()]Module was already out of reset.\n");
+         dbgPrintf("                 Closing module and resetting.\n");
+         osfuncSioFlush();
+        }
+#endif
+
+      /* Disable the Tx CPPI DMA */
+      TX_CPPI_CTL_REG(HalDev->dev_base) = 0;
+
+      /* Disable the Rx CPPI DMA */
+      RX_CPPI_CTL_REG(HalDev->dev_base) = 0;
+
+      /* Disable the PDSP */
+      PDSP_CTRL_REG(HalDev->dev_base) &=~ 0x00000002;
+
+      /* disable interrupt masks */
+      SAR_TX_MASK_CLR(HalDev->dev_base) = 0xffffffff;
+      SAR_RX_MASK_CLR(HalDev->dev_base) = 0xffffffff;
+
+#ifndef NO_RESET /* GSG+ 030428 */
+      /* clear reset bit */
+      (*(volatile bit32u *)(HalDev->ResetBase)) &=~ (1<<HalDev->ResetBit); /* ~GSG 030307 */
+      HalDev->OsFunc->Control(HalDev->OsDev, "Sleep", "", &Ticks);
+
+      /* set reset bit */
+      (*(volatile bit32u *)(HalDev->ResetBase)) |= (1<<HalDev->ResetBit); /* ~GSG 030307 */
+      HalDev->OsFunc->Control(HalDev->OsDev, "Sleep", "", &Ticks);
+#endif /* GSG+ 030428 */
+     }
+    else
+     {
+      (*(volatile bit32u *)(HalDev->ResetBase)) |= (1<<HalDev->ResetBit); /* ~GSG 030307 */
+      HalDev->OsFunc->Control(HalDev->OsDev, "Sleep", "", &Ticks);
+     }
+
+   /* Configure UNI/NNI */
+   RX_LUT_GLOBAL_CFG_REG(HalDev->dev_base) |= (HalDev->UniNni & 0x1);
+
+   /* Clear entire PDSP state RAM */                /*+GSG 030407*/
+   pTmp = (pTX_DMA_STATE_WORD_0(HalDev->dev_base)); /*+GSG 030407*/
+   for (i=0; i<PDSP_STATE_RAM_SIZE; i++)            /*+GSG 030407*/
+     *pTmp++ = 0;                                   /*+GSG 030407*/
+
+   /* Configure Oam Mode */                         /*+GSG 030407*/
+   SetOamMode(HalDev);                              /*+GSG 030407*/
+
+   /* Initialize PDSP */
+   Ret=InitPdsp(HalDev);
+   if(Ret)
+     return(Ret);
+
+   /* Reset and Enable the PDSP */
+   PDSP_CTRL_REG(HalDev->dev_base) = 0x00080003;
+
+   return(EC_NO_ERRORS);
+  }
+
+static int halClose(CPSAR_DEVICE *HalDev, int Mode)
+  {
+   int Ticks = 64;
+
+#ifdef __CPHAL_DEBUG
+  if (DBG(0))
+    {
+     dbgPrintf("[cpsar]halClose(HalDev:%08x, Mode:%d)\n", (bit32u)HalDev, Mode);
+     osfuncSioFlush();
+    }
+#endif
+
+   /* handle the error case if there is nothing open */
+   if (HalDev->OpenCount == 0)
+     {
+      return(EC_CPSAR|EC_FUNC_CLOSE|EC_VAL_MODULE_ALREADY_CLOSED);
+     }
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(7))
+     {
+      dbgPrintf("[cpsar halClose()]OpenCount = %d\n", HalDev->OpenCount);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Only run the close code for the last calling module per instance */
+   if (HalDev->OpenCount-- > 1)
+     {
+      return (EC_NO_ERRORS);
+     }
+
+   /* Disable the PDSP */
+   PDSP_CTRL_REG(HalDev->dev_base) &=~ 0x00000002;
+
+#ifndef NO_RESET /* GSG +030428 */
+   /* put device back into reset */
+   (*(volatile bit32u *)(HalDev->ResetBase)) &=~ (1<<HalDev->ResetBit); /* ~GSG 030307 */
+   HalDev->OsFunc->Control(HalDev->OsDev, "Sleep", "", &Ticks);
+#endif /* GSG +030428 */
+
+   return(EC_NO_ERRORS);
+  }
+
+static int halShutdown(CPSAR_DEVICE *HalDev)
+  {
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpsar]halShutdown(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* handle the error case */
+   if (HalDev->InitCount == 0)
+     {
+      return(EC_CPSAR|EC_FUNC_CLOSE|EC_VAL_MODULE_ALREADY_SHUTDOWN);
+     }
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(7))
+     {
+      dbgPrintf("[cpsar halShutdown()]InitCount = %d\n", HalDev->InitCount);
+      osfuncSioFlush();
+     }
+#endif
+
+   /* Only run the shutdown code for the last calling module per instance */
+   if (HalDev->InitCount-- > 1)
+     {
+      return (EC_NO_ERRORS);
+     }
+
+   /* free the SAR functions */
+#ifdef __CPHAL_DEBUG
+   if (DBG(6))
+     {
+      dbgPrintf("  [cpsar halShutdown()]: Free CPSAR function pointers\n");
+      osfuncSioFlush();
+     }
+   if (DBG(1)||DBG(3))
+     {
+      dbgPrintf("[os]Free(MemPtr:%08x)\n", (bit32u)HalDev->HalFuncPtr);
+      osfuncSioFlush();
+     }
+#endif
+   /* free the HalFunc */
+   HalDev->OsFunc->Free(HalDev->HalFuncPtr);
+
+   /* we have a static global, so I should clear it's value as well */
+   CpsarDev[HalDev->Inst] = 0;
+
+#ifdef __CPHAL_DEBUG
+   if (DBG(6))
+     {
+      dbgPrintf("  [cpsar halShutdown()]Free HalDev\n");
+      osfuncSioFlush();
+     }
+   if (DBG(1)||DBG(3))
+     {
+      dbgPrintf("[os]Free(MemPtr:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+   /* free the CPSAR device */
+   HalDev->OsFunc->Free(HalDev);
+
+   return(EC_NO_ERRORS);
+  }
+
+static int halTick(CPSAR_DEVICE *HalDev)
+  {   
+#ifdef __CPHAL_DEBUG
+   if (DBG(0))
+     {
+      dbgPrintf("[cpsar]halTick(HalDev:%08x)\n", (bit32u)HalDev);
+      osfuncSioFlush();
+     }
+#endif
+
+   return(EC_NO_ERRORS); 
+  }
+
+/*
+ *  The CPSAR version of InitModule() should be passed the OS_FUNCTIONS pointer,
+ *  and will return the HalDev pointer.
+ *
+ *  @param   HalDev  Pointer to CPSAR module information.  This will 
+ *                   be used by the OS when communicating to this module via 
+ *                   CPSAR. 
+ *  @param   OsDev   Pointer to OS device information.  This will be saved by
+ *                   the CPSAR and returned to the OS when required.
+ *  @param   HalFunc HAL_FUNCTIONS pointer.
+ *  @param   Size    Pointer to the size of the HAL_FUNCTIONS structure.  (If
+ *                   HalFunc is 0, the value will be set by CPSAR, otherwise 
+ *                   ignored)
+ *  @param   Inst    The instance number of the module to initialize. (start at
+ *                   0).
+ * 
+ *  @return  0 OK, Nonzero - error.
+ */
+/*
+int cpsarInitModule(CPSAR_DEVICE **HalDev, 
+                 OS_DEVICE *OsDev, 
+                 CPSAR_FUNCTIONS *HalFunc,
+                 OS_FUNCTIONS *OsFunc,
+                 int *Size,
+                 int Inst)
+*/
+int cpsarInitModule(CPSAR_DEVICE **HalDev, 
+                 OS_DEVICE *OsDev, 
+                 CPSAR_FUNCTIONS **HalFunc, 
+                 OS_FUNCTIONS *OsFunc, 
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst)
+  {
+   CPSAR_DEVICE *HalPtr;
+   CPSAR_FUNCTIONS *HalFuncPtr;
+
+   /*
+   if ( HalFunc == 0 )
+     {
+      *Size = sizeof(CPSAR_FUNCTIONS);
+      return(EC_NO_ERRORS);   
+     }
+   */
+
+   if (CpsarDev[Inst] != 0)
+     {
+      /* this SAR module has been connected to before, so do not
+         allocate another CPSAR_DEVICE */
+      HalPtr = CpsarDev[Inst];
+  
+      /* increase count of attached modules */
+      HalPtr->InitCount++;
+     }
+    else
+     {
+      /* allocate the CPSAR_DEVICE structure */
+      HalPtr = (CPSAR_DEVICE *) OsFunc->MallocDev(sizeof(CPSAR_DEVICE));
+      if(!HalPtr)
+        return(EC_CPSAR|EC_FUNC_HAL_INIT|EC_VAL_MALLOC_DEV_FAILED);
+
+      HalFuncPtr = (CPSAR_FUNCTIONS *) OsFunc->Malloc(sizeof(CPSAR_FUNCTIONS));
+      if (!HalFuncPtr)
+        return (EC_CPSAR|EC_FUNC_HAL_INIT|EC_VAL_MALLOC_FAILED);
+
+      /* Initialize the size of hal functions */
+      *HalFuncSize = sizeof (CPSAR_FUNCTIONS);
+
+      /* ensure the device structure is cleared */
+      OsFunc->Memset(HalPtr, 0, sizeof(CPSAR_DEVICE));
+      
+      /* clear the function pointers */
+      OsFunc->Memset(HalFuncPtr, 0, sizeof(CPSAR_FUNCTIONS));
+
+      /* Supply pointers for the CPSAR API functions */
+      HalFuncPtr->ChannelSetup    = halChannelSetup;
+      HalFuncPtr->ChannelTeardown = halChannelTeardown;
+      HalFuncPtr->Close           = halClose;
+      HalFuncPtr->Control         = halControl;
+      HalFuncPtr->Init            = halInit;
+      HalFuncPtr->Open            = halOpen;
+      HalFuncPtr->Probe           = halProbe;
+      HalFuncPtr->Shutdown        = halShutdown;
+      HalFuncPtr->Tick            = halTick;
+
+      /* keep a reference to HalFuncPtr so I can free it later */
+      HalPtr->HalFuncPtr = HalFuncPtr;
+
+      /* store the CPSAR_DEVICE, so the CPSAR module will know whether
+         it is in use for the given instance */
+      CpsarDev[Inst] = HalPtr;
+     
+      /* increase count of attached modules */
+      HalPtr->InitCount++;
+     }
+
+   /* @todo Does this need modification to deal with multiple callers/
+      drivers?  If different callers will use different OsDev/OsFunc,
+      then the current code will not work.
+   */
+
+   /* initialize the CPSAR_DEVICE structure */
+   HalPtr->OsDev  = OsDev;
+   /*HalPtr->OsOpen = OsDev;*/
+   HalPtr->Inst   = Inst;
+   HalPtr->OsFunc = OsFunc;
+
+   /* pass the HalPtr back to the caller */
+   *HalDev = HalPtr;
+   *HalFunc = HalPtr->HalFuncPtr;
+
+   return (EC_NO_ERRORS);
+  }
diff -urN linux.old/drivers/atm/sangam_atm/cpsar_cpaal5.h linux.dev/drivers/atm/sangam_atm/cpsar_cpaal5.h
--- linux.old/drivers/atm/sangam_atm/cpsar_cpaal5.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cpsar_cpaal5.h	2005-08-23 04:46:50.087845216 +0200
@@ -0,0 +1,103 @@
+/*******************************************************************************
+ *  TNETDxxxx Software Support
+ *  Copyright (c) 2002 Texas Instruments Incorporated. All Rights Reserved.
+ *
+ *  FILE:   cpsar.h
+ *
+ *  DESCRIPTION:
+ *      This file contains data structure definitions for the CPSAR HAL.
+ *
+ *  HISTORY:
+ *      6Sep02 Greg        1.00  Original Version created. 
+ *
+ *****************************************************************************/
+#ifndef _INC_CPSAR
+#define _INC_CPSAR
+
+#define NUM_RX_STATE_WORDS    7
+#define NUM_TX_STATE_WORDS    9
+#define MAX_CHAN        19
+
+
+#ifndef _CPHAL_CPSAR
+typedef void CPSAR_DEVICE;
+#endif
+
+/* 
+ * HAL Default Parameter Values
+ */
+#define  CFG_UNI_NNI  0
+
+/**
+ *  @ingroup shared_data
+ * 
+ *  List of defined keys for use with Control().
+ */
+typedef enum 
+  {
+   /* SAR */
+   enGET_FIRMWARE,        /**< Used by the SAR to request a pointer to firmware */
+   enGET_FIRMWARE_SIZE,   /**< Used by the SAR to request the size of the firmware */
+   enEND=9999 /* Last entry */
+  }INFO_KEY;
+
+/*
+ *  The CPHAL_FUNCTIONS struct defines the CPHAL function pointers used by upper layer 
+ *  software.  The upper layer software receives these pointers through the
+ *  call to cphalInitModule().
+ */
+typedef struct
+  {
+  int  (*ChannelSetup)(CPSAR_DEVICE *HalDev, CHANNEL_INFO *HalCh);
+  int  (*ChannelTeardown)(CPSAR_DEVICE *HalDev, int Ch, int Mode);
+  int  (*Close)(CPSAR_DEVICE *HalDev, int Mode);
+  int  (*Control)(CPSAR_DEVICE *HalDev, const char *Key, const char *Action, void *Value); 
+  int  (*Init)(CPSAR_DEVICE *HalDev);
+  int  (*ModeChange)(CPSAR_DEVICE *HalDev, char *DeviceParms);
+  int  (*Open)(CPSAR_DEVICE *HalDev);
+  int  (*Probe)(CPSAR_DEVICE *HalDev);
+  int  (*Shutdown)(CPSAR_DEVICE *HalDev);
+  int  (*Tick)(CPSAR_DEVICE *HalDev);
+  } CPSAR_FUNCTIONS;
+
+/*
+ *  This is the data structure for a generic HAL device.  It contains all device
+ *  specific data for a single instance of that device.  This includes Rx/Tx 
+ *  buffer queues, device base address, reset bit, and other information.
+ */
+typedef struct cpsar_device
+  {    
+   bit32  dev_base;
+   bit32  offset;
+   bit32  TxTeardownPending[MAX_CHAN];
+   bit32  RxTeardownPending[MAX_CHAN];
+   bit32  ChIsOpen[MAX_CHAN];
+   bit32  ResetBit;
+   bit32  debug;
+   OS_DEVICE *OsDev;
+   OS_FUNCTIONS *OsFunc;
+    /*void   *OsOpen;*/
+   bit32  UniNni;
+   bit32  Inst;
+   bit32u DeviceCPID[4];
+   bit32u LBSourceLLID[4];
+   bit32u OamRate[11];
+   CHANNEL_INFO ChData[MAX_CHAN];
+   int    InitCount;
+   int    OpenCount;
+   char   *DeviceInfo;
+   bit32u ResetBase;
+   DEVICE_STATE State;
+   CPSAR_FUNCTIONS *HalFuncPtr;
+   int    OamMode; /* +GSG 030407 */
+  }CPSARDEVICE;
+
+extern int cpsarInitModule(CPSAR_DEVICE **HalDev, 
+                 OS_DEVICE *OsDev, 
+                 CPSAR_FUNCTIONS **HalFunc, 
+                 OS_FUNCTIONS *OsFunc, 
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst);
+
+#endif
diff -urN linux.old/drivers/atm/sangam_atm/cpsar.h linux.dev/drivers/atm/sangam_atm/cpsar.h
--- linux.old/drivers/atm/sangam_atm/cpsar.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cpsar.h	2005-08-23 04:46:50.087845216 +0200
@@ -0,0 +1,103 @@
+/*******************************************************************************
+ *  TNETDxxxx Software Support
+ *  Copyright (c) 2002 Texas Instruments Incorporated. All Rights Reserved.
+ *
+ *  FILE:   cpsar.h
+ *
+ *  DESCRIPTION:
+ *      This file contains data structure definitions for the CPSAR HAL.
+ *
+ *  HISTORY:
+ *      6Sep02 Greg        1.00  Original Version created. 
+ *
+ *****************************************************************************/
+#ifndef _INC_CPSAR
+#define _INC_CPSAR
+
+#define NUM_RX_STATE_WORDS    7
+#define NUM_TX_STATE_WORDS    9
+#define MAX_CHAN        19
+
+
+#ifndef _CPHAL_CPSAR
+typedef void CPSAR_DEVICE;
+#endif
+
+/* 
+ * HAL Default Parameter Values
+ */
+#define  CFG_UNI_NNI  0
+
+/**
+ *  @ingroup shared_data
+ * 
+ *  List of defined keys for use with Control().
+ */
+typedef enum 
+  {
+   /* SAR */
+   enGET_FIRMWARE,        /**< Used by the SAR to request a pointer to firmware */
+   enGET_FIRMWARE_SIZE,   /**< Used by the SAR to request the size of the firmware */
+   enEND=9999 /* Last entry */
+  }INFO_KEY;
+
+/*
+ *  The CPHAL_FUNCTIONS struct defines the CPHAL function pointers used by upper layer 
+ *  software.  The upper layer software receives these pointers through the
+ *  call to cphalInitModule().
+ */
+typedef struct
+  {
+  int  (*ChannelSetup)(CPSAR_DEVICE *HalDev, CHANNEL_INFO *HalCh);
+  int  (*ChannelTeardown)(CPSAR_DEVICE *HalDev, int Ch, int Mode);
+  int  (*Close)(CPSAR_DEVICE *HalDev, int Mode);
+  int  (*Control)(CPSAR_DEVICE *HalDev, const char *Key, const char *Action, void *Value); 
+  int  (*Init)(CPSAR_DEVICE *HalDev);
+  int  (*ModeChange)(CPSAR_DEVICE *HalDev, char *DeviceParms);
+  int  (*Open)(CPSAR_DEVICE *HalDev);
+  int  (*Probe)(CPSAR_DEVICE *HalDev);
+  int  (*Shutdown)(CPSAR_DEVICE *HalDev);
+  int  (*Tick)(CPSAR_DEVICE *HalDev);
+  } CPSAR_FUNCTIONS;
+
+/*
+ *  This is the data structure for a generic HAL device.  It contains all device
+ *  specific data for a single instance of that device.  This includes Rx/Tx 
+ *  buffer queues, device base address, reset bit, and other information.
+ */
+typedef struct cpsar_device
+  {    
+   bit32  dev_base;
+   bit32  offset;
+   bit32  TxTeardownPending[MAX_CHAN];
+   bit32  RxTeardownPending[MAX_CHAN];
+   bit32  ChIsOpen[MAX_CHAN];
+   bit32  ResetBit;
+   bit32  debug;
+   OS_DEVICE *OsDev;
+   OS_FUNCTIONS *OsFunc;
+    /*void   *OsOpen;*/
+   bit32  UniNni;
+   bit32  Inst;
+   bit32u DeviceCPID[4];
+   bit32u LBSourceLLID[4];
+   bit32u OamRate[11];
+   CHANNEL_INFO ChData[MAX_CHAN];
+   int    InitCount;
+   int    OpenCount;
+   char   *DeviceInfo;
+   bit32u ResetBase;
+   DEVICE_STATE State;
+   CPSAR_FUNCTIONS *HalFuncPtr;
+   int    OamMode; /* +GSG 030407 */
+  }CPSARDEVICE;
+
+extern int cpsarInitModule(CPSAR_DEVICE **HalDev, 
+                 OS_DEVICE *OsDev, 
+                 CPSAR_FUNCTIONS **HalFunc, 
+                 OS_FUNCTIONS *OsFunc, 
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst);
+
+#endif
diff -urN linux.old/drivers/atm/sangam_atm/cp_sar_reg.h linux.dev/drivers/atm/sangam_atm/cp_sar_reg.h
--- linux.old/drivers/atm/sangam_atm/cp_sar_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cp_sar_reg.h	2005-08-23 04:46:50.087845216 +0200
@@ -0,0 +1,217 @@
+/***************************************************************************
+        TNETD73xx Software Support
+        Copyright(c) 2000, Texas Instruments Incorporated. All Rights Reserved.
+
+        FILE: cp_sar_reg.h   Register definitions for the SAR module
+
+        DESCRIPTION:
+                This include file contains register definitions for the
+                SAR module.
+
+        HISTORY:
+                15 Jan 02    G. Guyotte   Original version written
+                03 Oct 02    G. Guyotte   C++ style comments removed
+****************************************************************************/
+#ifndef _INC_SAR_REG
+#define _INC_SAR_REG
+
+/* Global Registers */
+#define pSAR_ID_REG(base)                   ((volatile bit32u *)(base+0x0000))
+#define SAR_ID_REG(base)                    (*pSAR_ID_REG(base))
+#define pSAR_STATUS_SET_REG(base)           ((volatile bit32u *)(base+0x0008))
+#define SAR_STATUS_SET_REG(base)            (*pSAR_STATUS_SET_REG(base))
+#define pSAR_STATUS_CLR_REG(base)           ((volatile bit32u *)(base+0x000C))
+#define SAR_STATUS_CLR_REG(base)            (*pSAR_STATUS_CLR_REG(base))
+#define pSAR_HOST_INT_EN_SET_REG(base)      ((volatile bit32u *)(base+0x0010))
+#define SAR_HOST_INT_EN_SET_REG(base)       (*pSAR_HOST_INT_EN_SET_REG(base))
+#define pSAR_HOST_INT_EN_CLR_REG(base)      ((volatile bit32u *)(base+0x0014))
+#define SAR_HOST_INT_EN_CLR_REG(base)       (*pSAR_HOST_INT_EN_CLR_REG(base))
+#define pSAR_PDSP_INT_EN_SET_REG(base)      ((volatile bit32u *)(base+0x0018))
+#define SAR_PDSP_INT_EN_SET_REG(base)       (*pSAR_PDSP_INT_EN_SET_REG(base))
+#define pSAR_PDSP_INT_EN_CLR_REG(base)      ((volatile bit32u *)(base+0x001C))
+#define SAR_PDSP_INT_EN_CLR_REG(base)       (*pSAR_PDSP_INT_EN_CLR_REG(base))
+
+/* PDSP OAM General Purpose Registers */
+#define pSAR_PDSP_HOST_OAM_CONFIG_REG(base) ((volatile bit32u *)(base+0x0020))
+#define SAR_PDSP_HOST_OAM_CONFIG_REG(base)  (*pSAR_PDSP_HOST_OAM_CONFIG_REG(base))
+#define pSAR_PDSP_OAM_CORR_REG(base)        ((volatile bit32u *)(base+0x0024))
+#define SAR_PDSP_OAM_CORR_REG(base)         (*pSAR_PDSP_OAM_CORR_REG(base))
+#define pSAR_PDSP_OAM_LB_RESULT_REG(base)   ((volatile bit32u *)(base+0x0028))
+#define SAR_PDSP_OAM_LB_RESULT_REG(base)    (*pSAR_PDSP_OAM_LB_RESULT_REG(base))
+#define pSAR_PDSP_OAM_F5_LB_COUNT_REG(base) ((volatile bit32u *)(base+0x002c))     /* +GSG 030416 */
+#define SAR_PDSP_OAM_F5_LB_COUNT_REG(base)  (*pSAR_PDSP_OAM_F5_LB_COUNT_REG(base)) /* +GSG 030416 */
+#define pSAR_PDSP_OAM_F4_LB_COUNT_REG(base) ((volatile bit32u *)(base+0x0030))     /* +GSG 030416 */
+#define SAR_PDSP_OAM_F4_LB_COUNT_REG(base)  (*pSAR_PDSP_OAM_F4_LB_COUNT_REG(base)) /* +GSG 030416 */
+#define pSAR_PDSP_FWD_UNK_VC_REG(base)      ((volatile bit32u *)(base+0x0034))     /* +GSG 030701 */
+#define SAR_PDSP_FWD_UNK_VC_REG(base)       (*pSAR_PDSP_FWD_UNK_VC_REG(base))      /* +GSG 030701 */
+
+
+/* Rx Lookup Table Registers */
+#define pRX_LUT_GLOBAL_CFG_REG(base)        ((volatile bit32u *)(base+0x0080))
+#define RX_LUT_GLOBAL_CFG_REG(base)         (*pRX_LUT_GLOBAL_CFG_REG(base))
+#define pRX_LUT_CH_SETUP_REQ_REG(base)      ((volatile bit32u *)(base+0x0090))
+#define RX_LUT_CH_SETUP_REQ_REG(base)       (*pRX_LUT_CH_SETUP_REQ_REG(base))
+#define pRX_LUT_CH_SETUP_REQ_VC_REG(base)   ((volatile bit32u *)(base+0x0094))
+#define RX_LUT_CH_SETUP_REQ_VC_REG(base)    (*pRX_LUT_CH_SETUP_REQ_VC_REG(base))
+#define pRX_LUT_CH_TEARDOWN_REQ_REG(base)   ((volatile bit32u *)(base+0x009C))
+#define RX_LUT_CH_TEARDOWN_REQ_REG(base)    (*pRX_LUT_CH_TEARDOWN_REQ_REG(base))
+
+/* Tx Scheduler Registers */
+#define pTX_CH_MAPPING_REG(base)            ((volatile bit32u *)(base+0x0170))
+#define TX_CH_MAPPING_REG(base)             (*pTX_CH_MAPPING_REG(base))
+
+/* Tx CPPI DMA Controller Registers */
+#define pTX_CPPI_CTL_REG(base)              ((volatile bit32u *)(base+0x0700))
+#define TX_CPPI_CTL_REG(base)               (*pTX_CPPI_CTL_REG(base))
+#define pTX_CPPI_TEARDOWN_REG(base)         ((volatile bit32u *)(base+0x0704))
+#define TX_CPPI_TEARDOWN_REG(base)          (*pTX_CPPI_TEARDOWN_REG(base))
+
+/* EOI Interrupt Additions */
+#define pSAR_EOI(base)                      ((volatile bit32u *)(base+0x0708))
+#define SAR_EOI(base)                       (*pSAR_EOI(base))
+#define pSAR_INTR_VECTOR(base)              ((volatile bit32u *)(base+0x070c))
+#define SAR_INTR_VECTOR(base)               (*pSAR_INTR_VECTOR(base))
+#define pSAR_TX_MASKED_STATUS(base)         ((volatile bit32u *)(base+0x0710))
+#define SAR_TX_MASKED_STATUS(base)          (*pSAR_TX_MASKED_STATUS(base))
+#define pSAR_TX_RAW_STATUS(base)            ((volatile bit32u *)(base+0x0714))
+#define SAR_TX_RAW_STATUS(base)             (*pSAR_TX_RAW_STATUS(base))
+#define pSAR_TX_MASK_SET(base)              ((volatile bit32u *)(base+0x0718))
+#define SAR_TX_MASK_SET(base)               (*pSAR_TX_MASK_SET(base))
+#define pSAR_TX_MASK_CLR(base)              ((volatile bit32u *)(base+0x071c))
+#define SAR_TX_MASK_CLR(base)               (*pSAR_TX_MASK_CLR(base))
+
+/* Rx CPPI DMA Controller Registers */
+#define pRX_CPPI_CTL_REG(base)              ((volatile bit32u *)(base+0x0780))
+#define RX_CPPI_CTL_REG(base)               (*pRX_CPPI_CTL_REG(base))
+#define pSAR_RX_MASKED_STATUS(base)         ((volatile bit32u *)(base+0x0790))
+#define SAR_RX_MASKED_STATUS(base)          (*pSAR_RX_MASKED_STATUS(base))
+#define pSAR_RX_RAW_STATUS(base)            ((volatile bit32u *)(base+0x0794))
+#define SAR_RX_RAW_STATUS(base)             (*pSAR_RX_RAW_STATUS(base))
+#define pSAR_RX_MASK_SET(base)              ((volatile bit32u *)(base+0x0798))
+#define SAR_RX_MASK_SET(base)               (*pSAR_RX_MASK_SET(base))
+#define pSAR_RX_MASK_CLR(base)              ((volatile bit32u *)(base+0x079c))
+#define SAR_RX_MASK_CLR(base)               (*pSAR_RX_MASK_CLR(base))
+
+/* PDSP Control/Status Registers */
+#define pPDSP_CTRL_REG(base)                ((volatile bit32u *)(base+0x4000))
+#define PDSP_CTRL_REG(base)                 (*pPDSP_CTRL_REG(base))
+
+/* PDSP Instruction RAM */
+#define pPDSP_IRAM(base)                    ((volatile bit32u *)(base+0x4020))
+#define PDSP_IRAM(base)                     (*pPDSP_IRAM(base))
+
+/*
+ * Channel 0 State/Scratchpad RAM Block
+ * 
+ * The following registers (Tx DMA State, Rx DMA State, CPPI Completion PTR, 
+ * and PDSP Data) have been given the correct address for channel 0.  To
+ * reach the registers for channel X, add (X * 0x100) to the pointer address.
+ *
+ */
+
+#define PDSP_STATE_RAM_SIZE   1024
+
+/* Tx DMA State RAM */
+#define pTX_DMA_STATE_WORD_0(base)          ((volatile bit32u *)(base+0x8000))
+#define TX_DMA_STATE_WORD_0(base)           (*pTX_DMA_STATE_WORD_0(base))
+#define pTX_DMA_STATE_WORD_1(base)          ((volatile bit32u *)(base+0x8004))
+#define TX_DMA_STATE_WORD_1(base)           (*pTX_DMA_STATE_WORD_1(base))
+#define pTX_DMA_STATE_WORD_2(base)          ((volatile bit32u *)(base+0x8008))
+#define TX_DMA_STATE_WORD_2(base)           (*pTX_DMA_STATE_WORD_2(base))
+#define pTX_DMA_STATE_WORD_3(base)          ((volatile bit32u *)(base+0x800C))
+#define TX_DMA_STATE_WORD_3(base)           (*pTX_DMA_STATE_WORD_3(base))
+#define pTX_DMA_STATE_WORD_4(base)          ((volatile bit32u *)(base+0x8010))
+#define TX_DMA_STATE_WORD_4(base)           (*pTX_DMA_STATE_WORD_4(base))
+#define pTX_DMA_STATE_WORD_5(base)          ((volatile bit32u *)(base+0x8014))
+#define TX_DMA_STATE_WORD_5(base)           (*pTX_DMA_STATE_WORD_5(base))
+#define pTX_DMA_STATE_WORD_6(base)          ((volatile bit32u *)(base+0x8018))
+#define TX_DMA_STATE_WORD_6(base)           (*pTX_DMA_STATE_WORD_6(base))
+#define pTX_DMA_STATE_WORD_7(base)          ((volatile bit32u *)(base+0x801C))
+#define TX_DMA_STATE_WORD_7(base)           (*pTX_DMA_STATE_WORD_7(base))
+#define pTX_DMA_STATE_WORD_8(base)          ((volatile bit32u *)(base+0x8020))
+#define TX_DMA_STATE_WORD_8(base)           (*pTX_DMA_STATE_WORD_8(base))
+
+/* Rx DMA State RAM */
+#define pRX_DMA_STATE_WORD_0(base)          ((volatile bit32u *)(base+0x8024))
+#define RX_DMA_STATE_WORD_0(base)           (*pRX_DMA_STATE_WORD_0(base))
+#define pRX_DMA_STATE_WORD_1(base)          ((volatile bit32u *)(base+0x8028))
+#define RX_DMA_STATE_WORD_1(base)           (*pRX_DMA_STATE_WORD_1(base))
+#define pRX_DMA_STATE_WORD_2(base)          ((volatile bit32u *)(base+0x802C))
+#define RX_DMA_STATE_WORD_2(base)           (*pRX_DMA_STATE_WORD_2(base))
+#define pRX_DMA_STATE_WORD_3(base)          ((volatile bit32u *)(base+0x8030))
+#define RX_DMA_STATE_WORD_3(base)           (*pRX_DMA_STATE_WORD_3(base))
+#define pRX_DMA_STATE_WORD_4(base)          ((volatile bit32u *)(base+0x8034))
+#define RX_DMA_STATE_WORD_4(base)           (*pRX_DMA_STATE_WORD_4(base))
+#define pRX_DMA_STATE_WORD_5(base)          ((volatile bit32u *)(base+0x8038))
+#define RX_DMA_STATE_WORD_5(base)           (*pRX_DMA_STATE_WORD_5(base))
+#define pRX_DMA_STATE_WORD_6(base)          ((volatile bit32u *)(base+0x803C))
+#define RX_DMA_STATE_WORD_6(base)           (*pRX_DMA_STATE_WORD_6(base))
+
+/* Tx CPPI Completion Pointers */
+#define pTXH_CPPI_COMP_PTR(base)            ((volatile bit32u *)(base+0x8040))
+#define TXH_CPPI_COMP_PTR(base)             (*pTXH_CPPI_COMP_PTR(base))
+#define pTXL_CPPI_COMP_PTR(base)            ((volatile bit32u *)(base+0x8044))
+#define TXL_CPPI_COMP_PTR(base)             (*pTXL_CPPI_COMP_PTR(base))
+
+/* Rx CPPI Completion Pointer */
+#define pRX_CPPI_COMP_PTR(base)             ((volatile bit32u *)(base+0x8048))
+#define RX_CPPI_COMP_PTR(base)              (*pRX_CPPI_COMP_PTR(base))
+
+/* Tx PDSP Defines */
+#define NUM_PDSP_AAL5_STATE_WORDS           24
+#define NUM_PDSP_AAL2_STATE_WORDS           20
+
+/* PDSP State RAM Block 0 */
+#define pPDSP_BLOCK_0(base)                 ((volatile bit32u *)(base+0x8050))
+#define PDSP_BLOCK_0(base)                  (*pPDSP_BLOCK_0(base))
+
+/* AAL5 Tx PDSP State RAM */
+#define pPDSP_AAL5_TX_STATE_WORD_0(base)    ((volatile bit32u *)(base+0x8050))
+#define PDSP_AAL5_TX_STATE_WORD_0(base)     (*pPDSP_AAL5_TX_STATE_WORD_0(base))
+
+/* AAL5 Rx PDSP State RAM */
+#define pPDSP_AAL5_RX_STATE_WORD_0(base)    ((volatile bit32u *)(base+0x8070))
+#define PDSP_AAL5_RX_STATE_WORD_0(base)     (*pPDSP_AAL5_RX_STATE_WORD_0(base))
+
+/* AAL5 Tx VP PDSP State RAM */
+#define pPDSP_AAL5_TX_VP_STATE_WORD_0(base) ((volatile bit32u *)(base+0x8090))
+#define PDSP_AAL5_TX_VP_STATE_WORD_0(base)  (*pPDSP_AAL5_TX_VP_STATE_WORD_0(base))
+
+/* AAL5 Rx VP PDSP State RAM */
+#define pPDSP_AAL5_RX_VP_STATE_WORD_0(base) ((volatile bit32u *)(base+0x80A0))
+#define PDSP_AAL5_RX_VP_STATE_WORD_0(base)  (*pPDSP_AAL5_RX_VP_STATE_WORD_0(base))
+
+/* AAL2 Tx PDSP State RAM */
+#define pPDSP_AAL2_TX_STATE_WORD_0(base)    ((volatile bit32u *)(base+0x80B0))
+#define PDSP_AAL2_TX_STATE_WORD_0(base)     (*pPDSP_AAL2_TX_STATE_WORD_0(base))
+
+/* AAL2 Rx PDSP State RAM */
+#define pPDSP_AAL2_RX_STATE_WORD_0(base)    ((volatile bit32u *)(base+0x80D0))
+#define PDSP_AAL2_RX_STATE_WORD_0(base)     (*pPDSP_AAL2_RX_STATE_WORD_0(base))
+
+/* AAL2 Tx VP PDSP State RAM */
+#define pPDSP_AAL2_TX_VP_STATE_WORD_0(base) ((volatile bit32u *)(base+0x80E0))
+#define PDSP_AAL2_TX_VP_STATE_WORD_0(base)  (*pPDSP_AAL2_TX_VP_STATE_WORD_0(base))
+
+/* AAL2 Rx VP PDSP State RAM */
+#define pPDSP_AAL2_RX_VP_STATE_WORD_0(base) ((volatile bit32u *)(base+0x80F0))
+#define PDSP_AAL2_RX_VP_STATE_WORD_0(base)  (*pPDSP_AAL2_RX_VP_STATE_WORD_0(base))
+
+/* PDSP OAM Configuration Block */
+#define pOAM_CONFIG_BLOCK_WORD_0(base)      ((volatile bit32u *)(base+0x83C0))
+#define OAM_CONFIG_BLOCK_WORD_0(base)       (*pOAM_CONFIG_BLOCK_WORD_0(base))
+
+/* PDSP OAM Padding Block */
+#define pOAM_PADDING_BLOCK_WORD_0(base)     ((volatile bit32u *)(base+0x84C0))
+#define OAM_PADDING_BLOCK_WORD_0(base)      (*pOAM_PADDING_BLOCK_WORD_0(base))
+
+#define NUM_OAM_RATES 11
+
+/* PDSP OAM Timer State RAM */
+#define pOAM_TIMER_STATE_WORD_0(base)       ((volatile bit32u *)(base+0x85B0))
+#define OAM_TIMER_STATE_WORD_0(base)        (*pOAM_TIMER_STATE_WORD_0(base))
+
+
+/* END OF FILE */
+
+#endif _INC_SAR_REG
diff -urN linux.old/drivers/atm/sangam_atm/cpswhal_cpaal5.h linux.dev/drivers/atm/sangam_atm/cpswhal_cpaal5.h
--- linux.old/drivers/atm/sangam_atm/cpswhal_cpaal5.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cpswhal_cpaal5.h	2005-08-23 04:46:50.088845064 +0200
@@ -0,0 +1,629 @@
+/************************************************************************
+ *  TNETDxxxx Software Support
+ *  Copyright (c) 2002 Texas Instruments Incorporated. All Rights Reserved.
+ *
+ *  FILE: cphal.h
+ *
+ *  DESCRIPTION:
+ *      User include file, contains data definitions shared between the CPHAL
+ *      and the upper-layer software.
+ *
+ *  HISTORY:
+ *      Date      Modifier  Ver    Notes
+ *      28Feb02   Greg      1.00   Original
+ *      06Mar02   Greg      1.01   Documentation enhanced
+ *      18Jul02   Greg      1.02   Many updates (OAM additions, general reorg)
+ *      22Nov02   Mick      RC2    Additions from Denis' input on Control
+ *
+ *  author  Greg Guyotte
+ *  version 1.02
+ *  date    18-Jul-2002
+ *****************************************************************************/
+#ifndef _INC_CPHAL_H
+#define _INC_CPHAL_H
+
+#ifdef _CPHAL_CPMAC
+#include "ec_errors_cpmac.h"
+#endif
+
+#ifdef _CPHAL_AAL5
+#include "ec_errors_cpaal5.h"
+#endif
+
+#ifdef _CPHAL_CPSAR
+#include "ec_errors_cpsar.h"
+#endif
+
+#ifdef _CPHAL_AAL2
+#include "ec_errors_cpaal2.h"
+#endif
+
+#ifndef __ADAM2
+typedef char           bit8;
+typedef short          bit16;
+typedef int            bit32;
+
+typedef unsigned char  bit8u;
+typedef unsigned short bit16u;
+typedef unsigned int   bit32u;
+
+/*
+typedef char           INT8;
+typedef short          INT16;
+typedef int            INT32;
+typedef unsigned char  UINT8;
+typedef unsigned short UINT16;
+typedef unsigned int   UINT32;
+*/
+/*typedef unsigned int   size_t;*/
+#endif
+
+#ifdef _CPHAL
+
+#ifndef TRUE
+#define TRUE (1==1)
+#endif
+
+#ifndef FALSE
+#define FALSE (1==2)
+#endif
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#endif
+
+#define        VirtToPhys(a)                 (((int)a)&~0xe0000000)
+#define        VirtToVirtNoCache(a)          ((void*)((VirtToPhys(a))|0xa0000000))
+#define        VirtToVirtCache(a)            ((void*)((VirtToPhys(a))|0x80000000))
+#define        PhysToVirtNoCache(a)          ((void*)(((int)a)|0xa0000000))
+#define        PhysToVirtCache(a)            ((void*)(((int)a)|0x80000000))
+/*
+#define        DataCacheHitInvalidate(a)     {__asm__(" cache  17, (%0)" :   : "r" (a));}
+#define        DataCacheHitWriteback(a)      {__asm__(" cache  25, (%0)" :   : "r" (a));}
+*/
+
+#define PARTIAL 1     /**< Used in @c Close() and @c ChannelTeardown() */
+#define FULL 2        /**< Used in @c Close() and @c ChannelTeardown() */
+
+/* Channel Teardown Defines */
+#define RX_TEARDOWN 2
+#define TX_TEARDOWN 1
+#define BLOCKING_TEARDOWN 8
+#define FULL_TEARDOWN 4
+#define PARTIAL_TEARDOWN 0
+
+#define MAX_DIR 2
+#define DIRECTION_TX 0
+#define DIRECTION_RX 1
+#define TX_CH 0
+#define RX_CH 1
+#define HAL_ERROR_DEVICE_NOT_FOUND    1
+#define HAL_ERROR_FAILED_MALLOC       2
+#define HAL_ERROR_OSFUNC_SIZE         3
+#define HAL_DEFAULT  0xFFFFFFFF
+#define VALID(val)    (val!=HAL_DEFAULT)
+
+/*
+ERROR REPORTING
+
+HAL Module Codes.  Each HAL module reporting an error code
+should OR the error code with the respective Module error code
+from the list below.
+*/
+#define EC_AAL5                                EC_HAL|EC_DEV_AAL5
+#define EC_AAL2                                EC_HAL|EC_DEV_AAL2
+#define EC_CPSAR                               EC_HAL|EC_DEV_CPSAR
+#define EC_CPMAC                               EC_HAL|EC_DEV_CPMAC
+#define EC_VDMA                                EC_HAL|EC_DEV_VDMA
+#define EC_VLYNQ                               EC_HAL|EC_DEV_VLYNQ
+#define EC_CPPI                                EC_HAL|EC_DEV_CPPI
+
+/*
+HAL Function Codes.  Each HAL module reporting an error code
+should OR the error code with one of the function codes from
+the list below.
+*/
+#define EC_FUNC_HAL_INIT                       EC_FUNC(1)
+#define EC_FUNC_CHSETUP                        EC_FUNC(2)
+#define EC_FUNC_CHTEARDOWN                     EC_FUNC(3)
+#define EC_FUNC_RXRETURN                       EC_FUNC(4)
+#define EC_FUNC_SEND                           EC_FUNC(5)
+#define EC_FUNC_RXINT                          EC_FUNC(6)
+#define EC_FUNC_TXINT                          EC_FUNC(7)
+#define EC_FUNC_AAL2_VDMA                      EC_FUNC(8)
+#define EC_FUNC_OPTIONS                        EC_FUNC(9)
+#define EC_FUNC_PROBE                          EC_FUNC(10)
+#define EC_FUNC_OPEN                           EC_FUNC(11)
+#define EC_FUNC_CONTROL                        EC_FUNC(12)
+#define EC_FUNC_DEVICE_INT                     EC_FUNC(13)
+#define EC_FUNC_STATUS                         EC_FUNC(14)
+#define EC_FUNC_TICK                           EC_FUNC(15)
+#define EC_FUNC_CLOSE                          EC_FUNC(16)
+#define EC_FUNC_SHUTDOWN                       EC_FUNC(17)
+#define EC_FUNC_DEVICE_INT_ALT                 EC_FUNC(18) /* +GSG 030306 */
+
+/*
+HAL Error Codes.  The list below defines every type of error
+used in all HAL modules. DO NOT CHANGE THESE VALUES!  Add new
+values in integer order to the bottom of the list.
+*/
+#define EC_VAL_PDSP_LOAD_FAIL                 EC_ERR(0x01)|EC_CRITICAL
+#define EC_VAL_FIRMWARE_TOO_LARGE             EC_ERR(0x02)|EC_CRITICAL
+#define EC_VAL_DEVICE_NOT_FOUND               EC_ERR(0x03)|EC_CRITICAL
+#define EC_VAL_BASE_ADDR_NOT_FOUND            EC_ERR(0x04)|EC_CRITICAL
+#define EC_VAL_RESET_BIT_NOT_FOUND            EC_ERR(0x05)|EC_CRITICAL
+#define EC_VAL_CH_INFO_NOT_FOUND              EC_ERR(0x06)
+#define EC_VAL_RX_STATE_RAM_NOT_CLEARED       EC_ERR(0x07)|EC_CRITICAL
+#define EC_VAL_TX_STATE_RAM_NOT_CLEARED       EC_ERR(0x08)|EC_CRITICAL
+#define EC_VAL_MALLOC_DEV_FAILED              EC_ERR(0x09)
+#define EC_VAL_OS_VERSION_NOT_SUPPORTED       EC_ERR(0x0A)|EC_CRITICAL
+#define EC_VAL_CPSAR_VERSION_NOT_SUPPORTED    EC_ERR(0x0B)|EC_CRITICAL
+#define EC_VAL_NULL_CPSAR_DEV                 EC_ERR(0x0C)|EC_CRITICAL
+
+#define EC_VAL_LUT_NOT_READY                  EC_ERR(0x0D)
+#define EC_VAL_INVALID_CH                     EC_ERR(0x0E)
+#define EC_VAL_NULL_CH_STRUCT                 EC_ERR(0x0F)
+#define EC_VAL_RX_TEARDOWN_ALREADY_PEND       EC_ERR(0x10)
+#define EC_VAL_TX_TEARDOWN_ALREADY_PEND       EC_ERR(0x11)
+#define EC_VAL_RX_CH_ALREADY_TORNDOWN         EC_ERR(0x12)
+#define EC_VAL_TX_CH_ALREADY_TORNDOWN         EC_ERR(0x13)
+#define EC_VAL_TX_TEARDOWN_TIMEOUT            EC_ERR(0x14)
+#define EC_VAL_RX_TEARDOWN_TIMEOUT            EC_ERR(0x15)
+#define EC_VAL_CH_ALREADY_TORNDOWN            EC_ERR(0x16)
+#define EC_VAL_VC_SETUP_NOT_READY             EC_ERR(0x17)
+#define EC_VAL_VC_TEARDOWN_NOT_READY          EC_ERR(0x18)
+#define EC_VAL_INVALID_VC                     EC_ERR(0x19)
+#define EC_VAL_INVALID_LC                     EC_ERR(0x20)
+#define EC_VAL_INVALID_VDMA_CH                EC_ERR(0x21)
+#define EC_VAL_INVALID_CID                    EC_ERR(0x22)
+#define EC_VAL_INVALID_UUI                    EC_ERR(0x23)
+#define EC_VAL_INVALID_UUI_DISCARD            EC_ERR(0x24)
+#define EC_VAL_CH_ALREADY_OPEN                EC_ERR(0x25)
+
+#define EC_VAL_RCB_MALLOC_FAILED              EC_ERR(0x26)
+#define EC_VAL_RX_BUFFER_MALLOC_FAILED        EC_ERR(0x27)
+#define EC_VAL_OUT_OF_TCBS                    EC_ERR(0x28)
+#define EC_VAL_NO_TCBS                        EC_ERR(0x29)
+#define EC_VAL_NULL_RCB                       EC_ERR(0x30)|EC_CRITICAL
+#define EC_VAL_SOP_ERROR                      EC_ERR(0x31)|EC_CRITICAL
+#define EC_VAL_EOP_ERROR                      EC_ERR(0x32)|EC_CRITICAL
+#define EC_VAL_NULL_TCB                       EC_ERR(0x33)|EC_CRITICAL
+#define EC_VAL_CORRUPT_RCB_CHAIN              EC_ERR(0x34)|EC_CRITICAL
+#define EC_VAL_TCB_MALLOC_FAILED              EC_ERR(0x35)
+
+#define EC_VAL_DISABLE_POLLING_FAILED         EC_ERR(0x36)
+#define EC_VAL_KEY_NOT_FOUND                  EC_ERR(0x37)
+#define EC_VAL_MALLOC_FAILED                  EC_ERR(0x38)
+#define EC_VAL_RESET_BASE_NOT_FOUND           EC_ERR(0x39)|EC_CRITICAL
+#define EC_VAL_INVALID_STATE                  EC_ERR(0x40)
+#define EC_VAL_NO_TXH_WORK_TO_DO              EC_ERR(0x41)
+#define EC_VAL_NO_TXL_WORK_TO_DO              EC_ERR(0x42)
+#define EC_VAL_NO_RX_WORK_TO_DO               EC_ERR(0x43)
+#define EC_VAL_NOT_LINKED                     EC_ERR(0x44)
+#define EC_VAL_INTERRUPT_NOT_FOUND            EC_ERR(0x45)
+#define EC_VAL_OFFSET_NOT_FOUND               EC_ERR(0x46)
+#define EC_VAL_MODULE_ALREADY_CLOSED          EC_ERR(0x47)
+#define EC_VAL_MODULE_ALREADY_SHUTDOWN        EC_ERR(0x48)
+#define EC_VAL_ACTION_NOT_FOUND               EC_ERR(0x49)
+#define EC_VAL_RX_CH_ALREADY_SETUP            EC_ERR(0x50)
+#define EC_VAL_TX_CH_ALREADY_SETUP            EC_ERR(0x51)
+#define EC_VAL_RX_CH_ALREADY_OPEN             EC_ERR(0x52)
+#define EC_VAL_TX_CH_ALREADY_OPEN             EC_ERR(0x53)
+#define EC_VAL_CH_ALREADY_SETUP               EC_ERR(0x54)
+#define EC_VAL_RCB_NEEDS_BUFFER               EC_ERR(0x55) /* +GSG 030410 */
+#define EC_VAL_RCB_DROPPED                    EC_ERR(0x56) /* +GSG 030410 */
+#define EC_VAL_INVALID_VALUE                  EC_ERR(0x57)
+
+/**
+@defgroup shared_data Shared Data Structures
+
+The data structures documented here are shared by all modules.
+*/
+
+/**
+ *  @ingroup shared_data
+ *  This is the fragment list structure.  Each fragment list entry contains a
+ *  length and a data buffer.
+ */
+typedef struct
+  {
+   bit32u   len;    /**< Length of the fragment in bytes (lower 16 bits are valid).  For SOP, upper 16 bits is the buffer offset. */
+   void     *data;  /**< Pointer to fragment data. */
+   void     *OsInfo; /**< Pointer to OS defined data. */
+  }FRAGLIST;
+
+#if defined (_CPHAL_CPMAC)
+#define CB_PASSCRC_BIT     (1<<26)
+
+/* CPMAC CPHAL STATUS */
+#define CPMAC_STATUS_LINK               (1 << 0)
+#define CPMAC_STATUS_LINK_DUPLEX        (1 << 1)  /* 0 - HD, 1 - FD */
+#define CPMAC_STATUS_LINK_SPEED         (1 << 2)  /* 0 - 10, 1 - 100 */
+
+/*   ADAPTER CHECK Codes */
+
+#define CPMAC_STATUS_ADAPTER_CHECK             (1 << 7)
+#define CPMAC_STATUS_HOST_ERR_DIRECTION        (1 << 8)
+#define CPMAC_STATUS_HOST_ERR_CODE             (0xF << 9)
+#define CPMAC_STATUS_HOST_ERR_CH               (0x7 << 13)
+
+#define _CPMDIO_DISABLE                 (1 << 0)
+#define _CPMDIO_HD                      (1 << 1)
+#define _CPMDIO_FD                      (1 << 2)
+#define _CPMDIO_10                      (1 << 3)
+#define _CPMDIO_100                     (1 << 4)
+#define _CPMDIO_NEG_OFF                 (1 << 5)
+#define _CPMDIO_LOOPBK                  (1 << 16)
+#define _CPMDIO_NOPHY                   (1 << 20)
+#endif
+
+/**
+ *  @ingroup shared_data
+ *  Channel specific configuration information.  This structure should be
+ *  populated by upper-layer software prior to calling @c ChannelSetup().  Any
+ *  configuration item that can be changed on a per channel basis should
+ *  be represented here.  Each module may define this structure with additional
+ *  module-specific members.
+ */
+typedef struct
+  {
+   int Channel;        /**< Channel number. */
+   int Direction;      /**< DIRECTION_RX(1) or DIRECTION_TX(0). */
+   OS_SETUP *OsSetup;  /**< OS defined information associated with this channel. */
+
+#if defined(_CPHAL_AAL5) || defined (_CPHAL_CPSAR) || defined (_CPHAL_CPMAC)
+   int RxBufSize;      /**< Size (in bytes) for each Rx buffer.*/
+   int RxBufferOffset; /**< Number of bytes to offset rx data from start of buffer (must be less than buffer size). */
+   int RxNumBuffers;   /**< The number of Rx buffer descriptors to allocate for Ch. */
+   int RxServiceMax;   /**< Maximum number of packets to service at one time. */
+
+   int TxNumBuffers;   /**< The number of Tx buffer descriptors to allocate for Ch. */
+   int TxNumQueues;    /**< Number of Tx queues for this channel (1-2). Choosing 2 enables a low priority SAR queue. */
+   int TxServiceMax;   /**< Maximum number of packets to service at one time. */
+#endif
+
+#if defined(_CPHAL_AAL5) || defined(_CPHAL_CPSAR)
+   int CpcsUU;      /**< The 2-byte CPCS UU and CPI information. */
+   int Gfc;         /**< Generic Flow Control. */
+   int Clp;         /**< Cell Loss Priority. */
+   int Pti;         /**< Payload Type Indication. */
+#endif
+
+#if defined(_CPHAL_AAL2) || defined(_CPHAL_AAL5) || defined(_CPHAL_CPSAR)
+   int DaMask;      /**< Specifies whether credit issuance is paused when Tx data not available. */
+   int Priority;    /**< Priority bin this channel will be scheduled within. */
+   int PktType;     /**< 0=AAL5,1=Null AAL,2=OAM,3=Transparent,4=AAL2. */
+   int Vci;         /**< Virtual Channel Identifier. */
+   int Vpi;         /**< Virtual Path Identifier. */
+   int FwdUnkVc;    /**< Enables forwarding of unknown VCI/VPI cells to host. 1=enable, 0=disable. */
+
+   /* Tx VC State */
+   int TxVc_CellRate;  /**< Tx rate, set as clock ticks between transmissions (SCR for VBR, CBR for CBR). */
+   int TxVc_QosType;   /**< 0=CBR,1=VBR,2=UBR,3=UBRmcr. */
+   int TxVc_Mbs;       /**< Min Burst Size in cells.*/
+   int TxVc_Pcr;       /**< Peak Cell Rate for VBR in clock ticks between transmissions. */
+
+   bit32 TxVc_AtmHeader; /**< ATM Header placed on firmware gen'd OAM cells for this Tx Ch (must be big endian with 0 PTI). */
+   int TxVc_OamTc;     /**< TC Path to transmit OAM cells for TX connection (0,1). */
+   int TxVc_VpOffset;  /**< Offset to the OAM VP state table. */
+   /* Rx VC State */
+   int RxVc_OamCh;     /**< Ch to terminate rx'd OAM cells to be forwarded to the host. */
+   int RxVc_OamToHost; /**< 0=do not pass, 1=pass. */
+   bit32 RxVc_AtmHeader; /**< ATM Header placed on firmware gen'd OAM cells for this Rx conn (must be big endian with 0 PTI). */
+   int RxVc_OamTc;     /**< TC Path to transmit OAM cells for RX connection (0,1). */
+   int RxVc_VpOffset;  /**< Offset to the OAM VP state table. */
+   /* Tx VP State */
+   int TxVp_OamTc;     /**< TC Path to transmit OAM cells for TX VP connection (0,1). */
+   bit32 TxVp_AtmHeader; /**< ATM Header placed on firmware gen'd VP OAM cells for this Tx VP conn (must be big endian with 0 VCI). */
+   /* Rx VP State  */
+   int RxVp_OamCh;     /**< Ch to terminate rx'd OAM cells to be forwarded to the host. */
+   int RxVp_OamToHost; /**< 0=do not pass, 1=pass. */
+   bit32 RxVp_AtmHeader; /**< ATM Header placed on firmware gen'd OAM cells for this Rx VP conn (must be big endian with 0 VCI). */
+   int RxVp_OamTc;     /**< TC Path to transmit OAM cells for RX VP connection (0,1). */
+   int RxVp_OamVcList; /**< Indicates all VC channels associated with this VP channel (one-hot encoded). */
+#endif
+
+
+#ifdef _CPHAL_VDMAVT
+   bit32u RemFifoAddr; /* Mirror mode only. */
+   bit32u FifoAddr;
+   bit32  PollInt;
+   bit32  FifoSize;
+   int    Ready;
+#endif
+
+  }CHANNEL_INFO;
+
+/*
+ *  This structure contains each statistic value gathered by the CPHAL.
+ *  Applications may access statistics data by using the @c StatsGet() routine.
+ */
+/* STATS */
+#if defined(_CPHAL_AAL2) || defined(_CPHAL_AAL5) || defined(_CPHAL_CPSAR)
+typedef struct
+  {
+   bit32u CrcErrors[16];
+   bit32u LenErrors[16];
+   bit32u DmaLenErrors[16];
+   bit32u AbortErrors[16];
+   bit32u StarvErrors[16];
+   bit32u TxMisQCnt[16][2];
+   bit32u RxMisQCnt[16];
+   bit32u RxEOQCnt[16];
+   bit32u TxEOQCnt[16][2];
+   bit32u RxPacketsServiced[16];
+   bit32u TxPacketsServiced[16][2];
+   bit32u RxMaxServiced;
+   bit32u TxMaxServiced[16][2];
+   bit32u RxTotal;
+   bit32u TxTotal;
+  } STAT_INFO;
+#endif
+
+/*
+ *  VDMA Channel specific configuration information
+ */
+#ifdef _CPHAL_AAL2
+typedef struct
+  {
+   int Ch;           /**< Channel Number */
+   int RemoteEndian; /**< Endianness of remote VDMA-VT device */
+   int CpsSwap;      /**< When 0, octet 0 in CPS pkt located in LS byte of 16-bit word sent to rem VDMA device.  When 1, in MS byte. */
+  }VdmaChInfo;
+#endif
+
+#ifndef _CPHAL
+  typedef void HAL_DEVICE;
+  typedef void HAL_PRIVATE;
+  typedef void HAL_RCB;
+  typedef void HAL_RECEIVEINFO;
+#endif
+
+/**
+ *  @ingroup shared_data
+ *  The HAL_FUNCTIONS struct defines the function pointers used by upper layer
+ *  software.  The upper layer software receives these pointers through the
+ *  call to xxxInitModule().
+ */
+typedef struct
+  {
+  int  (*ChannelSetup)    (HAL_DEVICE *HalDev, CHANNEL_INFO *Channel, OS_SETUP *OsSetup);
+  int  (*ChannelTeardown) (HAL_DEVICE *HalDev, int Channel, int Mode);
+  int  (*Close)           (HAL_DEVICE *HalDev, int Mode);
+  int  (*Control)         (HAL_DEVICE *HalDev, const char *Key, const char *Action, void *Value);
+  int  (*Init)            (HAL_DEVICE *HalDev);
+  int  (*Open)            (HAL_DEVICE *HalDev);
+  int  (*PacketProcessEnd) (HAL_DEVICE *HalDev);
+  int  (*Probe)           (HAL_DEVICE *HalDev);
+  int  (*RxReturn)        (HAL_RECEIVEINFO *HalReceiveInfo, int StripFlag);
+  int  (*Send)            (HAL_DEVICE *HalDev, FRAGLIST *FragList, int FragCount, int PacketSize, OS_SENDINFO *OsSendInfo, bit32u Mode);
+  int  (*Shutdown)        (HAL_DEVICE *HalDev);
+  int  (*Tick)            (HAL_DEVICE *HalDev);
+
+#ifdef _CPHAL_AAL5
+  int  (*Kick) (HAL_DEVICE *HalDev, int Queue);
+  void (*OamFuncConfig)   (HAL_DEVICE *HalDev, unsigned int OamConfig);
+  void (*OamLoopbackConfig)   (HAL_DEVICE *HalDev, unsigned int OamConfig, unsigned int *LLID, unsigned int CorrelationTag);
+  volatile bit32u* (*RegAccess)(HAL_DEVICE *HalDev, bit32u RegOffset);
+  STAT_INFO*  (*StatsGetOld)(HAL_DEVICE *HalDev);
+#endif
+  } HAL_FUNCTIONS;
+
+/**
+ *  @ingroup shared_data
+ *  The OS_FUNCTIONS struct defines the function pointers for all upper layer
+ *  functions accessible to the CPHAL.  The upper layer software is responsible
+ *  for providing the correct OS-specific implementations for the following
+ *  functions. It is populated by calling InitModule() (done by the CPHAL in
+ *  xxxInitModule().
+ */
+typedef struct
+  {
+  int   (*Control)(OS_DEVICE *OsDev, const char *Key, const char *Action, void *Value);
+  void  (*CriticalOn)(void);
+  void  (*CriticalOff)(void);
+  void  (*DataCacheHitInvalidate)(void *MemPtr, int Size);
+  void  (*DataCacheHitWriteback)(void *MemPtr, int Size);
+  int   (*DeviceFindInfo)(int Inst, const char *DeviceName, void *DeviceInfo);
+  int   (*DeviceFindParmUint)(void *DeviceInfo, const char *Parm, bit32u *Value);
+  int   (*DeviceFindParmValue)(void *DeviceInfo, const char *Parm, void *Value);
+  void  (*Free)(void *MemPtr);
+  void  (*FreeRxBuffer)(OS_RECEIVEINFO *OsReceiveInfo, void *MemPtr);
+  void  (*FreeDev)(void *MemPtr);
+  void  (*FreeDmaXfer)(void *MemPtr);
+  void  (*IsrRegister)(OS_DEVICE *OsDev, int (*halISR)(HAL_DEVICE*, int*), int InterruptBit);
+  void  (*IsrUnRegister)(OS_DEVICE *OsDev, int InterruptBit);
+  void* (*Malloc)(bit32u size);
+  void* (*MallocDev)(bit32u Size);
+  void* (*MallocDmaXfer)(bit32u size, void *MemBase, bit32u MemRange);
+  void* (*MallocRxBuffer)(bit32u size, void *MemBase, bit32u MemRange,
+                       OS_SETUP *OsSetup, HAL_RECEIVEINFO *HalReceiveInfo,
+                       OS_RECEIVEINFO **OsReceiveInfo, OS_DEVICE *OsDev);
+  void* (*Memset)(void *Dest, int C, bit32u N);
+  int   (*Printf)(const char *Format, ...);
+  int   (*Receive)(OS_DEVICE *OsDev,FRAGLIST *FragList,bit32u FragCount,
+                 bit32u PacketSize,HAL_RECEIVEINFO *HalReceiveInfo, bit32u Mode);
+  int   (*SendComplete)(OS_SENDINFO *OsSendInfo);
+  int   (*Sprintf)(char *S, const char *Format, ...);
+  int   (*Strcmpi)(const char *Str1, const char *Str2);
+  unsigned int (*Strlen)(const char *S);
+  char* (*Strstr)(const char *S1, const char *S2);
+  unsigned long  (*Strtoul)(const char *Str, char **Endptr, int Base);
+  void  (*TeardownComplete)(OS_DEVICE *OsDev, int Ch, int Direction);
+  } OS_FUNCTIONS;
+
+/************** MODULE SPECIFIC STUFF BELOW **************/
+
+#ifdef _CPHAL_CPMAC
+
+/*
+int halCpmacInitModule(HAL_DEVICE **HalDev, OS_DEVICE *OsDev, HAL_FUNCTIONS *HalFunc, int (*osBridgeInitModule)(OS_FUNCTIONS *), void* (*osMallocDev) (bit32u), int *Size, int inst);
+*/
+
+int halCpmacInitModule(HAL_DEVICE **HalDev,
+                 OS_DEVICE *OsDev,
+                 HAL_FUNCTIONS **HalFunc,
+                 OS_FUNCTIONS *OsFunc,
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst);
+#endif
+
+#ifdef _CPHAL_AAL5
+/*
+ *  @ingroup shared_data
+ *  The AAL5_FUNCTIONS struct defines the AAL5 function pointers used by upper layer
+ *  software.  The upper layer software receives these pointers through the
+ *  call to cphalInitModule().
+ */
+/*
+typedef struct
+  {
+  int  (*ChannelSetup)(HAL_DEVICE *HalDev, CHANNEL_INFO *HalCh, OS_SETUP *OsSetup);
+  int  (*ChannelTeardown)(HAL_DEVICE *HalDev, int Ch, int Mode);
+  int  (*Close)(HAL_DEVICE *HalDev, int Mode);
+  int  (*Init)(HAL_DEVICE *HalDev);
+  int  (*ModeChange)(HAL_DEVICE *HalDev, char *DeviceParms);
+  int  (*Open)(HAL_DEVICE *HalDev);
+  int  (*InfoGet)(HAL_DEVICE *HalDev, int Key, void *Value);
+  int  (*Probe)(HAL_DEVICE *HalDev);
+  int  (*RxReturn)(HAL_RECEIVEINFO *HalReceiveInfo, int StripFlag);
+  int  (*Send)(HAL_DEVICE *HalDev,FRAGLIST *FragList,int FragCount,
+                 int PacketSize,OS_SENDINFO *OsSendInfo,int Ch, int Queue,
+                 bit32u Mode);
+  int  (*StatsClear)(HAL_DEVICE *HalDev);
+  STAT_INFO*  (*StatsGet)(HAL_DEVICE *HalDev);
+  int  (*Status)(HAL_DEVICE *HalDev);
+  void (*Tick)(HAL_DEVICE *HalDev);
+  int  (*Kick)(HAL_DEVICE *HalDev, int Queue);
+  volatile bit32u* (*RegAccess)(HAL_DEVICE *HalDev, bit32u RegOffset);
+  } AAL5_FUNCTIONS;
+*/
+
+int cpaal5InitModule(HAL_DEVICE **HalDev,
+                 OS_DEVICE *OsDev,
+                 HAL_FUNCTIONS **HalFunc,
+                 OS_FUNCTIONS *OsFunc,
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst);
+#endif
+
+#ifdef _CPHAL_AAL2
+/**
+ *  @ingroup shared_data
+ *  The AAL2_FUNCTIONS struct defines the AAL2 function pointers used by upper layer
+ *  software.  The upper layer software receives these pointers through the
+ *  call to cphalInitModule().
+ */
+typedef struct
+  {
+  int  (*ChannelSetup)(HAL_DEVICE *HalDev, CHANNEL_INFO *HalCh, OS_SETUP *OsSetup);
+  int  (*ChannelTeardown)(HAL_DEVICE *HalDev, int Ch, int Mode);
+  int  (*Close)(HAL_DEVICE *HalDev, int Mode);
+  int  (*Init)(HAL_DEVICE *HalDev);
+  int  (*ModeChange)(HAL_DEVICE *HalDev, char *DeviceParms);
+  int  (*Open)(HAL_DEVICE *HalDev);
+  int  (*OptionsGet)(HAL_DEVICE *HalDev, char *Key, bit32u *Value);
+  int  (*Probe)(HAL_DEVICE *HalDev);
+
+  int  (*StatsClear)(HAL_DEVICE *HalDev);
+  STAT_INFO*  (*StatsGet)(HAL_DEVICE *HalDev);
+  int  (*Status)(HAL_DEVICE *HalDev);
+  void (*Tick)(HAL_DEVICE *HalDev);
+  int  (*Aal2UuiMappingSetup)(HAL_DEVICE *HalDev, int VC, int UUI,
+                                    int VdmaCh, int UUIDiscard);
+  int  (*Aal2RxMappingSetup)(HAL_DEVICE *HalDev, int VC, int CID,
+                                   int LC);
+  int  (*Aal2TxMappingSetup)(HAL_DEVICE *HalDev, int VC, int LC, int VdmaCh);
+  int  (*Aal2VdmaChSetup)(HAL_DEVICE *HalDev, bit32u RemVdmaVtAddr,
+                               VdmaChInfo *VdmaCh);
+  volatile bit32u* (*RegAccess)(HAL_DEVICE *HalDev, bit32u RegOffset);
+  int  (*Aal2ModeChange)(HAL_DEVICE *HalDev, int Vc, int RxCrossMode,
+                           int RxMultiMode, int TxMultiMode, int SchedMode,
+                           int TcCh);
+  void (*Aal2VdmaEnable)(HAL_DEVICE *HalDev, int Ch);
+  int  (*Aal2VdmaDisable)(HAL_DEVICE *HalDev, int Ch);
+  } AAL2_FUNCTIONS;
+
+int cpaal2InitModule(HAL_DEVICE **HalDev,
+                 OS_DEVICE *OsDev,
+                 AAL2_FUNCTIONS **HalFunc,
+                 OS_FUNCTIONS *OsFunc,
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst);
+#endif
+
+#ifdef _CPHAL_VDMAVT
+/**
+ *  @ingroup shared_data
+ *  The VDMA_FUNCTIONS struct defines the HAL function pointers used by upper layer
+ *  software.  The upper layer software receives these pointers through the
+ *  call to InitModule().
+ *
+ *  Note that this list is still under definition.
+ */
+typedef struct
+  {
+  bit32  (*Init)( HAL_DEVICE *VdmaVtDev);
+    /*  bit32  (*SetupTxFifo)(HAL_DEVICE *VdmaVtDev, bit32u LclRem,
+                  bit32u Addr, bit32u Size, bit32u PollInt);
+    bit32  (*SetupRxFifo)(HAL_DEVICE *VdmaVtDev, bit32u LclRem,
+                  bit32u Addr, bit32u Size, bit32u PollInt); */
+  bit32  (*Tx)(HAL_DEVICE *VdmaVtDev);
+  bit32  (*Rx)(HAL_DEVICE *VdmaVtDev);
+  bit32  (*SetRemoteChannel)(HAL_DEVICE *VdmaVtDev, bit32u RemAddr,
+                         bit32u RemDevID);
+  bit32  (*ClearRxInt)(HAL_DEVICE *VdmaVtDev);
+  bit32  (*ClearTxInt)(HAL_DEVICE *VdmaVtDev);
+  bit32  (*Open)(HAL_DEVICE *VdmaVtDev);
+  bit32  (*Close)(HAL_DEVICE *VdmaVtDev);
+  int    (*Control)         (HAL_DEVICE *HalDev, const char *Key, const char *Action, void *Value);
+  int    (*ChannelSetup)(HAL_DEVICE *VdmaVtDev, CHANNEL_INFO *HalCh, OS_SETUP *OsSetup);
+  int    (*ChannelTeardown)(HAL_DEVICE *VdmaVtDev, int Ch, int Mode);
+  int    (*Send)(HAL_DEVICE *VdmaVtDev,FRAGLIST *FragList,int FragCount,
+                 int PacketSize,OS_SENDINFO *OsSendInfo,bit32u Mode);
+  } VDMA_FUNCTIONS;
+
+int VdmaInitModule(HAL_DEVICE **VdmaVt,
+                 OS_DEVICE *OsDev,
+                 VDMA_FUNCTIONS **VdmaVtFunc,
+                 OS_FUNCTIONS *OsFunc,
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst);
+#endif
+
+/*
+extern int cphalInitModule(MODULE_TYPE ModuleType, HAL_DEVICE **HalDev, OS_DEVICE *OsDev, HAL_FUNCTIONS *HalFunc,
+                      int (*osInitModule)(OS_FUNCTIONS *), void* (*osMallocDev)(bit32u),
+                      int *Size, int Inst);
+*/
+
+
+#ifdef _CPHAL_AAL5
+extern const char hcSarFrequency[];
+#endif
+
+#ifdef _CPHAL_CPMAC
+/* following will be common, once 'utl' added */
+extern const char hcClear[];
+extern const char hcGet[];
+extern const char hcSet[];
+extern const char hcTick[];
+
+extern const char hcCpuFrequency[];
+extern const char hcCpmacFrequency[];
+extern const char hcMdioBusFrequency[];
+extern const char hcMdioClockFrequency[];
+extern const char hcCpmacBase[];
+extern const char hcPhyNum[];
+extern const char hcSize[];
+extern const char hcCpmacSize[];
+extern const char hcPhyAccess[];
+#endif
+
+#endif  /*  end of _INC_    */
diff -urN linux.old/drivers/atm/sangam_atm/cpswhal_cpsar.h linux.dev/drivers/atm/sangam_atm/cpswhal_cpsar.h
--- linux.old/drivers/atm/sangam_atm/cpswhal_cpsar.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/cpswhal_cpsar.h	2005-08-23 04:46:50.089844912 +0200
@@ -0,0 +1,629 @@
+/************************************************************************
+ *  TNETDxxxx Software Support
+ *  Copyright (c) 2002 Texas Instruments Incorporated. All Rights Reserved.
+ *
+ *  FILE: cphal.h
+ *
+ *  DESCRIPTION:
+ *      User include file, contains data definitions shared between the CPHAL
+ *      and the upper-layer software.
+ *
+ *  HISTORY:
+ *      Date      Modifier  Ver    Notes
+ *      28Feb02   Greg      1.00   Original
+ *      06Mar02   Greg      1.01   Documentation enhanced
+ *      18Jul02   Greg      1.02   Many updates (OAM additions, general reorg)
+ *      22Nov02   Mick      RC2    Additions from Denis' input on Control
+ *
+ *  author  Greg Guyotte
+ *  version 1.02
+ *  date    18-Jul-2002
+ *****************************************************************************/
+#ifndef _INC_CPHAL_H
+#define _INC_CPHAL_H
+
+#ifdef _CPHAL_CPMAC
+#include "ec_errors_cpmac.h"
+#endif
+
+#ifdef _CPHAL_AAL5
+#include "ec_errors_cpaal5.h"
+#endif
+
+#ifdef _CPHAL_CPSAR
+#include "ec_errors_cpsar.h"
+#endif
+
+#ifdef _CPHAL_AAL2
+#include "ec_errors_cpaal2.h"
+#endif
+
+#ifndef __ADAM2
+typedef char           bit8;
+typedef short          bit16;
+typedef int            bit32;
+
+typedef unsigned char  bit8u;
+typedef unsigned short bit16u;
+typedef unsigned int   bit32u;
+
+/*
+typedef char           INT8;
+typedef short          INT16;
+typedef int            INT32;
+typedef unsigned char  UINT8;
+typedef unsigned short UINT16;
+typedef unsigned int   UINT32;
+*/
+/*typedef unsigned int   size_t;*/
+#endif
+
+#ifdef _CPHAL
+
+#ifndef TRUE
+#define TRUE (1==1)
+#endif
+
+#ifndef FALSE
+#define FALSE (1==2)
+#endif
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#endif
+
+#define        VirtToPhys(a)                 (((int)a)&~0xe0000000)
+#define        VirtToVirtNoCache(a)          ((void*)((VirtToPhys(a))|0xa0000000))
+#define        VirtToVirtCache(a)            ((void*)((VirtToPhys(a))|0x80000000))
+#define        PhysToVirtNoCache(a)          ((void*)(((int)a)|0xa0000000))
+#define        PhysToVirtCache(a)            ((void*)(((int)a)|0x80000000))
+/*
+#define        DataCacheHitInvalidate(a)     {__asm__(" cache  17, (%0)" :   : "r" (a));}
+#define        DataCacheHitWriteback(a)      {__asm__(" cache  25, (%0)" :   : "r" (a));}
+*/
+
+#define PARTIAL 1     /**< Used in @c Close() and @c ChannelTeardown() */
+#define FULL 2        /**< Used in @c Close() and @c ChannelTeardown() */
+
+/* Channel Teardown Defines */
+#define RX_TEARDOWN 2
+#define TX_TEARDOWN 1
+#define BLOCKING_TEARDOWN 8
+#define FULL_TEARDOWN 4
+#define PARTIAL_TEARDOWN 0
+
+#define MAX_DIR 2
+#define DIRECTION_TX 0
+#define DIRECTION_RX 1
+#define TX_CH 0
+#define RX_CH 1
+#define HAL_ERROR_DEVICE_NOT_FOUND    1
+#define HAL_ERROR_FAILED_MALLOC       2
+#define HAL_ERROR_OSFUNC_SIZE         3
+#define HAL_DEFAULT  0xFFFFFFFF
+#define VALID(val)    (val!=HAL_DEFAULT)
+
+/*
+ERROR REPORTING
+
+HAL Module Codes.  Each HAL module reporting an error code
+should OR the error code with the respective Module error code
+from the list below.
+*/
+#define EC_AAL5                                EC_HAL|EC_DEV_AAL5
+#define EC_AAL2                                EC_HAL|EC_DEV_AAL2
+#define EC_CPSAR                               EC_HAL|EC_DEV_CPSAR
+#define EC_CPMAC                               EC_HAL|EC_DEV_CPMAC
+#define EC_VDMA                                EC_HAL|EC_DEV_VDMA
+#define EC_VLYNQ                               EC_HAL|EC_DEV_VLYNQ
+#define EC_CPPI                                EC_HAL|EC_DEV_CPPI
+
+/*
+HAL Function Codes.  Each HAL module reporting an error code
+should OR the error code with one of the function codes from
+the list below.
+*/
+#define EC_FUNC_HAL_INIT                       EC_FUNC(1)
+#define EC_FUNC_CHSETUP                        EC_FUNC(2)
+#define EC_FUNC_CHTEARDOWN                     EC_FUNC(3)
+#define EC_FUNC_RXRETURN                       EC_FUNC(4)
+#define EC_FUNC_SEND                           EC_FUNC(5)
+#define EC_FUNC_RXINT                          EC_FUNC(6)
+#define EC_FUNC_TXINT                          EC_FUNC(7)
+#define EC_FUNC_AAL2_VDMA                      EC_FUNC(8)
+#define EC_FUNC_OPTIONS                        EC_FUNC(9)
+#define EC_FUNC_PROBE                          EC_FUNC(10)
+#define EC_FUNC_OPEN                           EC_FUNC(11)
+#define EC_FUNC_CONTROL                        EC_FUNC(12)
+#define EC_FUNC_DEVICE_INT                     EC_FUNC(13)
+#define EC_FUNC_STATUS                         EC_FUNC(14)
+#define EC_FUNC_TICK                           EC_FUNC(15)
+#define EC_FUNC_CLOSE                          EC_FUNC(16)
+#define EC_FUNC_SHUTDOWN                       EC_FUNC(17)
+#define EC_FUNC_DEVICE_INT_ALT                 EC_FUNC(18) /* +GSG 030306 */
+
+/*
+HAL Error Codes.  The list below defines every type of error
+used in all HAL modules. DO NOT CHANGE THESE VALUES!  Add new
+values in integer order to the bottom of the list.
+*/
+#define EC_VAL_PDSP_LOAD_FAIL                 EC_ERR(0x01)|EC_CRITICAL
+#define EC_VAL_FIRMWARE_TOO_LARGE             EC_ERR(0x02)|EC_CRITICAL
+#define EC_VAL_DEVICE_NOT_FOUND               EC_ERR(0x03)|EC_CRITICAL
+#define EC_VAL_BASE_ADDR_NOT_FOUND            EC_ERR(0x04)|EC_CRITICAL
+#define EC_VAL_RESET_BIT_NOT_FOUND            EC_ERR(0x05)|EC_CRITICAL
+#define EC_VAL_CH_INFO_NOT_FOUND              EC_ERR(0x06)
+#define EC_VAL_RX_STATE_RAM_NOT_CLEARED       EC_ERR(0x07)|EC_CRITICAL
+#define EC_VAL_TX_STATE_RAM_NOT_CLEARED       EC_ERR(0x08)|EC_CRITICAL
+#define EC_VAL_MALLOC_DEV_FAILED              EC_ERR(0x09)
+#define EC_VAL_OS_VERSION_NOT_SUPPORTED       EC_ERR(0x0A)|EC_CRITICAL
+#define EC_VAL_CPSAR_VERSION_NOT_SUPPORTED    EC_ERR(0x0B)|EC_CRITICAL
+#define EC_VAL_NULL_CPSAR_DEV                 EC_ERR(0x0C)|EC_CRITICAL
+
+#define EC_VAL_LUT_NOT_READY                  EC_ERR(0x0D)
+#define EC_VAL_INVALID_CH                     EC_ERR(0x0E)
+#define EC_VAL_NULL_CH_STRUCT                 EC_ERR(0x0F)
+#define EC_VAL_RX_TEARDOWN_ALREADY_PEND       EC_ERR(0x10)
+#define EC_VAL_TX_TEARDOWN_ALREADY_PEND       EC_ERR(0x11)
+#define EC_VAL_RX_CH_ALREADY_TORNDOWN         EC_ERR(0x12)
+#define EC_VAL_TX_CH_ALREADY_TORNDOWN         EC_ERR(0x13)
+#define EC_VAL_TX_TEARDOWN_TIMEOUT            EC_ERR(0x14)
+#define EC_VAL_RX_TEARDOWN_TIMEOUT            EC_ERR(0x15)
+#define EC_VAL_CH_ALREADY_TORNDOWN            EC_ERR(0x16)
+#define EC_VAL_VC_SETUP_NOT_READY             EC_ERR(0x17)
+#define EC_VAL_VC_TEARDOWN_NOT_READY          EC_ERR(0x18)
+#define EC_VAL_INVALID_VC                     EC_ERR(0x19)
+#define EC_VAL_INVALID_LC                     EC_ERR(0x20)
+#define EC_VAL_INVALID_VDMA_CH                EC_ERR(0x21)
+#define EC_VAL_INVALID_CID                    EC_ERR(0x22)
+#define EC_VAL_INVALID_UUI                    EC_ERR(0x23)
+#define EC_VAL_INVALID_UUI_DISCARD            EC_ERR(0x24)
+#define EC_VAL_CH_ALREADY_OPEN                EC_ERR(0x25)
+
+#define EC_VAL_RCB_MALLOC_FAILED              EC_ERR(0x26)
+#define EC_VAL_RX_BUFFER_MALLOC_FAILED        EC_ERR(0x27)
+#define EC_VAL_OUT_OF_TCBS                    EC_ERR(0x28)
+#define EC_VAL_NO_TCBS                        EC_ERR(0x29)
+#define EC_VAL_NULL_RCB                       EC_ERR(0x30)|EC_CRITICAL
+#define EC_VAL_SOP_ERROR                      EC_ERR(0x31)|EC_CRITICAL
+#define EC_VAL_EOP_ERROR                      EC_ERR(0x32)|EC_CRITICAL
+#define EC_VAL_NULL_TCB                       EC_ERR(0x33)|EC_CRITICAL
+#define EC_VAL_CORRUPT_RCB_CHAIN              EC_ERR(0x34)|EC_CRITICAL
+#define EC_VAL_TCB_MALLOC_FAILED              EC_ERR(0x35)
+
+#define EC_VAL_DISABLE_POLLING_FAILED         EC_ERR(0x36)
+#define EC_VAL_KEY_NOT_FOUND                  EC_ERR(0x37)
+#define EC_VAL_MALLOC_FAILED                  EC_ERR(0x38)
+#define EC_VAL_RESET_BASE_NOT_FOUND           EC_ERR(0x39)|EC_CRITICAL
+#define EC_VAL_INVALID_STATE                  EC_ERR(0x40)
+#define EC_VAL_NO_TXH_WORK_TO_DO              EC_ERR(0x41)
+#define EC_VAL_NO_TXL_WORK_TO_DO              EC_ERR(0x42)
+#define EC_VAL_NO_RX_WORK_TO_DO               EC_ERR(0x43)
+#define EC_VAL_NOT_LINKED                     EC_ERR(0x44)
+#define EC_VAL_INTERRUPT_NOT_FOUND            EC_ERR(0x45)
+#define EC_VAL_OFFSET_NOT_FOUND               EC_ERR(0x46)
+#define EC_VAL_MODULE_ALREADY_CLOSED          EC_ERR(0x47)
+#define EC_VAL_MODULE_ALREADY_SHUTDOWN        EC_ERR(0x48)
+#define EC_VAL_ACTION_NOT_FOUND               EC_ERR(0x49)
+#define EC_VAL_RX_CH_ALREADY_SETUP            EC_ERR(0x50)
+#define EC_VAL_TX_CH_ALREADY_SETUP            EC_ERR(0x51)
+#define EC_VAL_RX_CH_ALREADY_OPEN             EC_ERR(0x52)
+#define EC_VAL_TX_CH_ALREADY_OPEN             EC_ERR(0x53)
+#define EC_VAL_CH_ALREADY_SETUP               EC_ERR(0x54)
+#define EC_VAL_RCB_NEEDS_BUFFER               EC_ERR(0x55) /* +GSG 030410 */
+#define EC_VAL_RCB_DROPPED                    EC_ERR(0x56) /* +GSG 030410 */
+#define EC_VAL_INVALID_VALUE                  EC_ERR(0x57)
+
+/**
+@defgroup shared_data Shared Data Structures
+
+The data structures documented here are shared by all modules.
+*/
+
+/**
+ *  @ingroup shared_data
+ *  This is the fragment list structure.  Each fragment list entry contains a
+ *  length and a data buffer.
+ */
+typedef struct
+  {
+   bit32u   len;    /**< Length of the fragment in bytes (lower 16 bits are valid).  For SOP, upper 16 bits is the buffer offset. */
+   void     *data;  /**< Pointer to fragment data. */
+   void     *OsInfo; /**< Pointer to OS defined data. */
+  }FRAGLIST;
+
+#if defined (_CPHAL_CPMAC)
+#define CB_PASSCRC_BIT     (1<<26)
+
+/* CPMAC CPHAL STATUS */
+#define CPMAC_STATUS_LINK               (1 << 0)
+#define CPMAC_STATUS_LINK_DUPLEX        (1 << 1)  /* 0 - HD, 1 - FD */
+#define CPMAC_STATUS_LINK_SPEED         (1 << 2)  /* 0 - 10, 1 - 100 */
+
+/*   ADAPTER CHECK Codes */
+
+#define CPMAC_STATUS_ADAPTER_CHECK             (1 << 7)
+#define CPMAC_STATUS_HOST_ERR_DIRECTION        (1 << 8)
+#define CPMAC_STATUS_HOST_ERR_CODE             (0xF << 9)
+#define CPMAC_STATUS_HOST_ERR_CH               (0x7 << 13)
+
+#define _CPMDIO_DISABLE                 (1 << 0)
+#define _CPMDIO_HD                      (1 << 1)
+#define _CPMDIO_FD                      (1 << 2)
+#define _CPMDIO_10                      (1 << 3)
+#define _CPMDIO_100                     (1 << 4)
+#define _CPMDIO_NEG_OFF                 (1 << 5)
+#define _CPMDIO_LOOPBK                  (1 << 16)
+#define _CPMDIO_NOPHY                   (1 << 20)
+#endif
+
+/**
+ *  @ingroup shared_data
+ *  Channel specific configuration information.  This structure should be
+ *  populated by upper-layer software prior to calling @c ChannelSetup().  Any
+ *  configuration item that can be changed on a per channel basis should
+ *  be represented here.  Each module may define this structure with additional
+ *  module-specific members.
+ */
+typedef struct
+  {
+   int Channel;        /**< Channel number. */
+   int Direction;      /**< DIRECTION_RX(1) or DIRECTION_TX(0). */
+   OS_SETUP *OsSetup;  /**< OS defined information associated with this channel. */
+
+#if defined(_CPHAL_AAL5) || defined (_CPHAL_CPSAR) || defined (_CPHAL_CPMAC)
+   int RxBufSize;      /**< Size (in bytes) for each Rx buffer.*/
+   int RxBufferOffset; /**< Number of bytes to offset rx data from start of buffer (must be less than buffer size). */
+   int RxNumBuffers;   /**< The number of Rx buffer descriptors to allocate for Ch. */
+   int RxServiceMax;   /**< Maximum number of packets to service at one time. */
+
+   int TxNumBuffers;   /**< The number of Tx buffer descriptors to allocate for Ch. */
+   int TxNumQueues;    /**< Number of Tx queues for this channel (1-2). Choosing 2 enables a low priority SAR queue. */
+   int TxServiceMax;   /**< Maximum number of packets to service at one time. */
+#endif
+
+#if defined(_CPHAL_AAL5) || defined(_CPHAL_CPSAR)
+   int CpcsUU;      /**< The 2-byte CPCS UU and CPI information. */
+   int Gfc;         /**< Generic Flow Control. */
+   int Clp;         /**< Cell Loss Priority. */
+   int Pti;         /**< Payload Type Indication. */
+#endif
+
+#if defined(_CPHAL_AAL2) || defined(_CPHAL_AAL5) || defined(_CPHAL_CPSAR)
+   int DaMask;      /**< Specifies whether credit issuance is paused when Tx data not available. */
+   int Priority;    /**< Priority bin this channel will be scheduled within. */
+   int PktType;     /**< 0=AAL5,1=Null AAL,2=OAM,3=Transparent,4=AAL2. */
+   int Vci;         /**< Virtual Channel Identifier. */
+   int Vpi;         /**< Virtual Path Identifier. */
+   int FwdUnkVc;    /**< Enables forwarding of unknown VCI/VPI cells to host. 1=enable, 0=disable. */
+
+   /* Tx VC State */
+   int TxVc_CellRate;  /**< Tx rate, set as clock ticks between transmissions (SCR for VBR, CBR for CBR). */
+   int TxVc_QosType;   /**< 0=CBR,1=VBR,2=UBR,3=UBRmcr. */
+   int TxVc_Mbs;       /**< Min Burst Size in cells.*/
+   int TxVc_Pcr;       /**< Peak Cell Rate for VBR in clock ticks between transmissions. */
+
+   bit32 TxVc_AtmHeader; /**< ATM Header placed on firmware gen'd OAM cells for this Tx Ch (must be big endian with 0 PTI). */
+   int TxVc_OamTc;     /**< TC Path to transmit OAM cells for TX connection (0,1). */
+   int TxVc_VpOffset;  /**< Offset to the OAM VP state table. */
+   /* Rx VC State */
+   int RxVc_OamCh;     /**< Ch to terminate rx'd OAM cells to be forwarded to the host. */
+   int RxVc_OamToHost; /**< 0=do not pass, 1=pass. */
+   bit32 RxVc_AtmHeader; /**< ATM Header placed on firmware gen'd OAM cells for this Rx conn (must be big endian with 0 PTI). */
+   int RxVc_OamTc;     /**< TC Path to transmit OAM cells for RX connection (0,1). */
+   int RxVc_VpOffset;  /**< Offset to the OAM VP state table. */
+   /* Tx VP State */
+   int TxVp_OamTc;     /**< TC Path to transmit OAM cells for TX VP connection (0,1). */
+   bit32 TxVp_AtmHeader; /**< ATM Header placed on firmware gen'd VP OAM cells for this Tx VP conn (must be big endian with 0 VCI). */
+   /* Rx VP State  */
+   int RxVp_OamCh;     /**< Ch to terminate rx'd OAM cells to be forwarded to the host. */
+   int RxVp_OamToHost; /**< 0=do not pass, 1=pass. */
+   bit32 RxVp_AtmHeader; /**< ATM Header placed on firmware gen'd OAM cells for this Rx VP conn (must be big endian with 0 VCI). */
+   int RxVp_OamTc;     /**< TC Path to transmit OAM cells for RX VP connection (0,1). */
+   int RxVp_OamVcList; /**< Indicates all VC channels associated with this VP channel (one-hot encoded). */
+#endif
+
+
+#ifdef _CPHAL_VDMAVT
+   bit32u RemFifoAddr; /* Mirror mode only. */
+   bit32u FifoAddr;
+   bit32  PollInt;
+   bit32  FifoSize;
+   int    Ready;
+#endif
+
+  }CHANNEL_INFO;
+
+/*
+ *  This structure contains each statistic value gathered by the CPHAL.
+ *  Applications may access statistics data by using the @c StatsGet() routine.
+ */
+/* STATS */
+#if defined(_CPHAL_AAL2) || defined(_CPHAL_AAL5) || defined(_CPHAL_CPSAR)
+typedef struct
+  {
+   bit32u CrcErrors[16];
+   bit32u LenErrors[16];
+   bit32u DmaLenErrors[16];
+   bit32u AbortErrors[16];
+   bit32u StarvErrors[16];
+   bit32u TxMisQCnt[16][2];
+   bit32u RxMisQCnt[16];
+   bit32u RxEOQCnt[16];
+   bit32u TxEOQCnt[16][2];
+   bit32u RxPacketsServiced[16];
+   bit32u TxPacketsServiced[16][2];
+   bit32u RxMaxServiced;
+   bit32u TxMaxServiced[16][2];
+   bit32u RxTotal;
+   bit32u TxTotal;
+  } STAT_INFO;
+#endif
+
+/*
+ *  VDMA Channel specific configuration information
+ */
+#ifdef _CPHAL_AAL2
+typedef struct
+  {
+   int Ch;           /**< Channel Number */
+   int RemoteEndian; /**< Endianness of remote VDMA-VT device */
+   int CpsSwap;      /**< When 0, octet 0 in CPS pkt located in LS byte of 16-bit word sent to rem VDMA device.  When 1, in MS byte. */
+  }VdmaChInfo;
+#endif
+
+#ifndef _CPHAL
+  typedef void HAL_DEVICE;
+  typedef void HAL_PRIVATE;
+  typedef void HAL_RCB;
+  typedef void HAL_RECEIVEINFO;
+#endif
+
+/**
+ *  @ingroup shared_data
+ *  The HAL_FUNCTIONS struct defines the function pointers used by upper layer
+ *  software.  The upper layer software receives these pointers through the
+ *  call to xxxInitModule().
+ */
+typedef struct
+  {
+  int  (*ChannelSetup)    (HAL_DEVICE *HalDev, CHANNEL_INFO *Channel, OS_SETUP *OsSetup);
+  int  (*ChannelTeardown) (HAL_DEVICE *HalDev, int Channel, int Mode);
+  int  (*Close)           (HAL_DEVICE *HalDev, int Mode);
+  int  (*Control)         (HAL_DEVICE *HalDev, const char *Key, const char *Action, void *Value);
+  int  (*Init)            (HAL_DEVICE *HalDev);
+  int  (*Open)            (HAL_DEVICE *HalDev);
+  int  (*PacketProcessEnd) (HAL_DEVICE *HalDev);
+  int  (*Probe)           (HAL_DEVICE *HalDev);
+  int  (*RxReturn)        (HAL_RECEIVEINFO *HalReceiveInfo, int StripFlag);
+  int  (*Send)            (HAL_DEVICE *HalDev, FRAGLIST *FragList, int FragCount, int PacketSize, OS_SENDINFO *OsSendInfo, bit32u Mode);
+  int  (*Shutdown)        (HAL_DEVICE *HalDev);
+  int  (*Tick)            (HAL_DEVICE *HalDev);
+
+#ifdef _CPHAL_AAL5
+  int  (*Kick) (HAL_DEVICE *HalDev, int Queue);
+  void (*OamFuncConfig)   (HAL_DEVICE *HalDev, unsigned int OamConfig);
+  void (*OamLoopbackConfig)   (HAL_DEVICE *HalDev, unsigned int OamConfig, unsigned int *LLID, unsigned int CorrelationTag);
+  volatile bit32u* (*RegAccess)(HAL_DEVICE *HalDev, bit32u RegOffset);
+  STAT_INFO*  (*StatsGetOld)(HAL_DEVICE *HalDev);
+#endif
+  } HAL_FUNCTIONS;
+
+/**
+ *  @ingroup shared_data
+ *  The OS_FUNCTIONS struct defines the function pointers for all upper layer
+ *  functions accessible to the CPHAL.  The upper layer software is responsible
+ *  for providing the correct OS-specific implementations for the following
+ *  functions. It is populated by calling InitModule() (done by the CPHAL in
+ *  xxxInitModule().
+ */
+typedef struct
+  {
+  int   (*Control)(OS_DEVICE *OsDev, const char *Key, const char *Action, void *Value);
+  void  (*CriticalOn)(void);
+  void  (*CriticalOff)(void);
+  void  (*DataCacheHitInvalidate)(void *MemPtr, int Size);
+  void  (*DataCacheHitWriteback)(void *MemPtr, int Size);
+  int   (*DeviceFindInfo)(int Inst, const char *DeviceName, void *DeviceInfo);
+  int   (*DeviceFindParmUint)(void *DeviceInfo, const char *Parm, bit32u *Value);
+  int   (*DeviceFindParmValue)(void *DeviceInfo, const char *Parm, void *Value);
+  void  (*Free)(void *MemPtr);
+  void  (*FreeRxBuffer)(OS_RECEIVEINFO *OsReceiveInfo, void *MemPtr);
+  void  (*FreeDev)(void *MemPtr);
+  void  (*FreeDmaXfer)(void *MemPtr);
+  void  (*IsrRegister)(OS_DEVICE *OsDev, int (*halISR)(HAL_DEVICE*, int*), int InterruptBit);
+  void  (*IsrUnRegister)(OS_DEVICE *OsDev, int InterruptBit);
+  void* (*Malloc)(bit32u size);
+  void* (*MallocDev)(bit32u Size);
+  void* (*MallocDmaXfer)(bit32u size, void *MemBase, bit32u MemRange);
+  void* (*MallocRxBuffer)(bit32u size, void *MemBase, bit32u MemRange,
+                       OS_SETUP *OsSetup, HAL_RECEIVEINFO *HalReceiveInfo,
+                       OS_RECEIVEINFO **OsReceiveInfo, OS_DEVICE *OsDev);
+  void* (*Memset)(void *Dest, int C, bit32u N);
+  int   (*Printf)(const char *Format, ...);
+  int   (*Receive)(OS_DEVICE *OsDev,FRAGLIST *FragList,bit32u FragCount,
+                 bit32u PacketSize,HAL_RECEIVEINFO *HalReceiveInfo, bit32u Mode);
+  int   (*SendComplete)(OS_SENDINFO *OsSendInfo);
+  int   (*Sprintf)(char *S, const char *Format, ...);
+  int   (*Strcmpi)(const char *Str1, const char *Str2);
+  unsigned int (*Strlen)(const char *S);
+  char* (*Strstr)(const char *S1, const char *S2);
+  unsigned long  (*Strtoul)(const char *Str, char **Endptr, int Base);
+  void  (*TeardownComplete)(OS_DEVICE *OsDev, int Ch, int Direction);
+  } OS_FUNCTIONS;
+
+/************** MODULE SPECIFIC STUFF BELOW **************/
+
+#ifdef _CPHAL_CPMAC
+
+/*
+int halCpmacInitModule(HAL_DEVICE **HalDev, OS_DEVICE *OsDev, HAL_FUNCTIONS *HalFunc, int (*osBridgeInitModule)(OS_FUNCTIONS *), void* (*osMallocDev) (bit32u), int *Size, int inst);
+*/
+
+int halCpmacInitModule(HAL_DEVICE **HalDev,
+                 OS_DEVICE *OsDev,
+                 HAL_FUNCTIONS **HalFunc,
+                 OS_FUNCTIONS *OsFunc,
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst);
+#endif
+
+#ifdef _CPHAL_AAL5
+/*
+ *  @ingroup shared_data
+ *  The AAL5_FUNCTIONS struct defines the AAL5 function pointers used by upper layer
+ *  software.  The upper layer software receives these pointers through the
+ *  call to cphalInitModule().
+ */
+/*
+typedef struct
+  {
+  int  (*ChannelSetup)(HAL_DEVICE *HalDev, CHANNEL_INFO *HalCh, OS_SETUP *OsSetup);
+  int  (*ChannelTeardown)(HAL_DEVICE *HalDev, int Ch, int Mode);
+  int  (*Close)(HAL_DEVICE *HalDev, int Mode);
+  int  (*Init)(HAL_DEVICE *HalDev);
+  int  (*ModeChange)(HAL_DEVICE *HalDev, char *DeviceParms);
+  int  (*Open)(HAL_DEVICE *HalDev);
+  int  (*InfoGet)(HAL_DEVICE *HalDev, int Key, void *Value);
+  int  (*Probe)(HAL_DEVICE *HalDev);
+  int  (*RxReturn)(HAL_RECEIVEINFO *HalReceiveInfo, int StripFlag);
+  int  (*Send)(HAL_DEVICE *HalDev,FRAGLIST *FragList,int FragCount,
+                 int PacketSize,OS_SENDINFO *OsSendInfo,int Ch, int Queue,
+                 bit32u Mode);
+  int  (*StatsClear)(HAL_DEVICE *HalDev);
+  STAT_INFO*  (*StatsGet)(HAL_DEVICE *HalDev);
+  int  (*Status)(HAL_DEVICE *HalDev);
+  void (*Tick)(HAL_DEVICE *HalDev);
+  int  (*Kick)(HAL_DEVICE *HalDev, int Queue);
+  volatile bit32u* (*RegAccess)(HAL_DEVICE *HalDev, bit32u RegOffset);
+  } AAL5_FUNCTIONS;
+*/
+
+int cpaal5InitModule(HAL_DEVICE **HalDev,
+                 OS_DEVICE *OsDev,
+                 HAL_FUNCTIONS **HalFunc,
+                 OS_FUNCTIONS *OsFunc,
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst);
+#endif
+
+#ifdef _CPHAL_AAL2
+/**
+ *  @ingroup shared_data
+ *  The AAL2_FUNCTIONS struct defines the AAL2 function pointers used by upper layer
+ *  software.  The upper layer software receives these pointers through the
+ *  call to cphalInitModule().
+ */
+typedef struct
+  {
+  int  (*ChannelSetup)(HAL_DEVICE *HalDev, CHANNEL_INFO *HalCh, OS_SETUP *OsSetup);
+  int  (*ChannelTeardown)(HAL_DEVICE *HalDev, int Ch, int Mode);
+  int  (*Close)(HAL_DEVICE *HalDev, int Mode);
+  int  (*Init)(HAL_DEVICE *HalDev);
+  int  (*ModeChange)(HAL_DEVICE *HalDev, char *DeviceParms);
+  int  (*Open)(HAL_DEVICE *HalDev);
+  int  (*OptionsGet)(HAL_DEVICE *HalDev, char *Key, bit32u *Value);
+  int  (*Probe)(HAL_DEVICE *HalDev);
+
+  int  (*StatsClear)(HAL_DEVICE *HalDev);
+  STAT_INFO*  (*StatsGet)(HAL_DEVICE *HalDev);
+  int  (*Status)(HAL_DEVICE *HalDev);
+  void (*Tick)(HAL_DEVICE *HalDev);
+  int  (*Aal2UuiMappingSetup)(HAL_DEVICE *HalDev, int VC, int UUI,
+                                    int VdmaCh, int UUIDiscard);
+  int  (*Aal2RxMappingSetup)(HAL_DEVICE *HalDev, int VC, int CID,
+                                   int LC);
+  int  (*Aal2TxMappingSetup)(HAL_DEVICE *HalDev, int VC, int LC, int VdmaCh);
+  int  (*Aal2VdmaChSetup)(HAL_DEVICE *HalDev, bit32u RemVdmaVtAddr,
+                               VdmaChInfo *VdmaCh);
+  volatile bit32u* (*RegAccess)(HAL_DEVICE *HalDev, bit32u RegOffset);
+  int  (*Aal2ModeChange)(HAL_DEVICE *HalDev, int Vc, int RxCrossMode,
+                           int RxMultiMode, int TxMultiMode, int SchedMode,
+                           int TcCh);
+  void (*Aal2VdmaEnable)(HAL_DEVICE *HalDev, int Ch);
+  int  (*Aal2VdmaDisable)(HAL_DEVICE *HalDev, int Ch);
+  } AAL2_FUNCTIONS;
+
+int cpaal2InitModule(HAL_DEVICE **HalDev,
+                 OS_DEVICE *OsDev,
+                 AAL2_FUNCTIONS **HalFunc,
+                 OS_FUNCTIONS *OsFunc,
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst);
+#endif
+
+#ifdef _CPHAL_VDMAVT
+/**
+ *  @ingroup shared_data
+ *  The VDMA_FUNCTIONS struct defines the HAL function pointers used by upper layer
+ *  software.  The upper layer software receives these pointers through the
+ *  call to InitModule().
+ *
+ *  Note that this list is still under definition.
+ */
+typedef struct
+  {
+  bit32  (*Init)( HAL_DEVICE *VdmaVtDev);
+    /*  bit32  (*SetupTxFifo)(HAL_DEVICE *VdmaVtDev, bit32u LclRem,
+                  bit32u Addr, bit32u Size, bit32u PollInt);
+    bit32  (*SetupRxFifo)(HAL_DEVICE *VdmaVtDev, bit32u LclRem,
+                  bit32u Addr, bit32u Size, bit32u PollInt); */
+  bit32  (*Tx)(HAL_DEVICE *VdmaVtDev);
+  bit32  (*Rx)(HAL_DEVICE *VdmaVtDev);
+  bit32  (*SetRemoteChannel)(HAL_DEVICE *VdmaVtDev, bit32u RemAddr,
+                         bit32u RemDevID);
+  bit32  (*ClearRxInt)(HAL_DEVICE *VdmaVtDev);
+  bit32  (*ClearTxInt)(HAL_DEVICE *VdmaVtDev);
+  bit32  (*Open)(HAL_DEVICE *VdmaVtDev);
+  bit32  (*Close)(HAL_DEVICE *VdmaVtDev);
+  int    (*Control)         (HAL_DEVICE *HalDev, const char *Key, const char *Action, void *Value);
+  int    (*ChannelSetup)(HAL_DEVICE *VdmaVtDev, CHANNEL_INFO *HalCh, OS_SETUP *OsSetup);
+  int    (*ChannelTeardown)(HAL_DEVICE *VdmaVtDev, int Ch, int Mode);
+  int    (*Send)(HAL_DEVICE *VdmaVtDev,FRAGLIST *FragList,int FragCount,
+                 int PacketSize,OS_SENDINFO *OsSendInfo,bit32u Mode);
+  } VDMA_FUNCTIONS;
+
+int VdmaInitModule(HAL_DEVICE **VdmaVt,
+                 OS_DEVICE *OsDev,
+                 VDMA_FUNCTIONS **VdmaVtFunc,
+                 OS_FUNCTIONS *OsFunc,
+                 int OsFuncSize,
+                 int *HalFuncSize,
+                 int Inst);
+#endif
+
+/*
+extern int cphalInitModule(MODULE_TYPE ModuleType, HAL_DEVICE **HalDev, OS_DEVICE *OsDev, HAL_FUNCTIONS *HalFunc,
+                      int (*osInitModule)(OS_FUNCTIONS *), void* (*osMallocDev)(bit32u),
+                      int *Size, int Inst);
+*/
+
+
+#ifdef _CPHAL_AAL5
+extern const char hcSarFrequency[];
+#endif
+
+#ifdef _CPHAL_CPMAC
+/* following will be common, once 'utl' added */
+extern const char hcClear[];
+extern const char hcGet[];
+extern const char hcSet[];
+extern const char hcTick[];
+
+extern const char hcCpuFrequency[];
+extern const char hcCpmacFrequency[];
+extern const char hcMdioBusFrequency[];
+extern const char hcMdioClockFrequency[];
+extern const char hcCpmacBase[];
+extern const char hcPhyNum[];
+extern const char hcSize[];
+extern const char hcCpmacSize[];
+extern const char hcPhyAccess[];
+#endif
+
+#endif  /*  end of _INC_    */
diff -urN linux.old/drivers/atm/sangam_atm/dev_host_interface.h linux.dev/drivers/atm/sangam_atm/dev_host_interface.h
--- linux.old/drivers/atm/sangam_atm/dev_host_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/dev_host_interface.h	2005-08-23 04:46:50.091844608 +0200
@@ -0,0 +1,1162 @@
+#ifndef __DEV_HOST_INTERFACE_H__
+#define __DEV_HOST_INTERFACE_H__ 1
+
+/*******************************************************************************
+*  FILE PURPOSE: Public header file for the Host-to-DSP interface
+********************************************************************************
+*
+*  TEXAS INSTRUMENTS PROPRIETARTY INFORMATION
+*
+*  (C) Copyright Texas Instruments Inc. 2002.  All rights reserved.
+*
+*  Property of Texas Instruments Incorporated
+*
+*  Restricted Rights - Use, duplication, or disclosure is subject to
+*  restrictions set forth in TI's program license agreement and
+*  associated documentation
+*
+*
+*  FILE NAME: dev_host_interface.h
+*
+*  DESCRIPTION:
+*       This header file defines the variables and parameters used between the
+*       host processor and the DSP.  This file is included in both the DSP
+*       software and the host software.
+*
+*  RULES FOR MODIFICATION AND USE OF THIS FILE:
+*
+*  --The main pointer to the struct of pointers will always be at the same fixed
+*      location (0x80000000).
+*
+*  --Each pointer element in the struct of pointers (indicated by the main pointer)
+*      will always point to a struct only.
+*
+*  --Any new structures added to the host interface in subsequent versions must
+*      each have a corresponding new pointer element added to the END of the struct
+*      of pointers.  Other than this, there will never be any moving or rearranging
+*      of the pointer elements in the struct of pointers.
+*
+*  --Any new elements added to existing structures will be added at the END of the
+*      structure.  Other than this, there will never be any moving or rearranging
+*      of structure elements.
+*
+*  --A new structure will never be added as a new element in an old structure.
+*      New structures must be added separately with a new entry in the struct of
+*      pointers, as noted above.
+*
+*  --Also, the sizes of existing arrays within old structures will never be changed.
+*
+*  --The modem code in the DSP will never reference the struct of pointers in order
+*      to avoid aliasing issues in the DSP code.  The modem code will only use the
+*      specific structures directly.
+*
+*  --The host processor never accesses the DSP side of the ATM-TC hardware directly.
+*      The DSP interfaces directly to the ATM-TC hardware and relays information to
+*      the host processor through the host interface.
+*
+*  --The host processor can track the modem's transition through important states
+*      by accessing the Modem State Bit Field in the host interface.  Each bit in
+*      the bit field represents an important state to track in the modem.  As the
+*      modem transitions through each important state, the corresponding bit will
+*      change from a zero to a one.  Each bit in the bit field will only be reset to
+*      zero if the modem retrains.  If new states need to be tracked and are added
+*      in subsequent versions of the host interface, a corresponding bit will be
+*      added at the END of the bit field to ensure backwards compatibility.  The
+*      Modem State Bit Field is reset if the modem retrains or falls out of Showtime.
+*
+*  --An interrupt will be sent to the host processor when a change occurs in the
+*      Modem State Bit Field.  There is an interrupt masking register which can mask
+*      specific interrupts corresponding to the bits of the Modem State Bit Field.
+*      This allows the host to keep an interrupt from being generated for those
+*      states that are masked.
+*
+*  HISTORY:
+*
+*  11/20/02  J. Bergsagel    Written from the previous host interface file
+*  11/27/02  J. Bergsagel    Added comments for mailbox control struct and
+*                              fixed a couple items for overlay page stuff.
+*                            Also, added temporary elements for SWTC code.
+*  12/04/02  J. Bergsagel    Added extra dummy byte to DEV_HOST_eocVarDef_t
+*                              for proper word alignment.
+*  12/12/02  J. Bergsagel    Changed initial states in the modem state bit field
+*                              and added more instructions for adding more states.
+*  12/16/02  J. Bergsagel    Changed name "hostVersion_p" to "hostIntfcVersion_p".
+*                            Removed dspAturState from DEV_HOST_modemStateBitField_t.
+*                            Reorganized several struct elements to clean up the
+*                              host interface.
+*  12/27/02  Sameer V        Added missing channel 0 statistics for TC. Added
+*                            ocd error information.
+*  12/27/02  Sameer V        Added overlayState to OlayDP_Parms to indicate whether
+*                              overlays are being executed in current state.
+*  01/06/03  J. Bergsagel    Added maxAllowedMargin and minRequiredMargin to
+*                              DEV_HOST_msg_t.
+*                            Renamed TC chan 1 items to be chan 0 items to start out.
+*  01/17/03  Sameer V        Moved delineationState to atmStats structure.
+*  01/21/03  Barnett         Implemented Ax7 UNIT-MODULE modular software framework.
+*  01/22/03  J. Bergsagel    Added warning comments for certain struct typedefs.
+*  01/23/03  C. Perez-N.     Removed old AX5-only diags. command/response entries in the
+*                            HOST and DSP ennumerations, and added the AX7 new ones
+*                            Added pointer entries in the DEV_HOST_dspOamSharedInterface_t
+*                            structure pointing to the analog diags. input/output/options
+*                            structures.
+*  01/29/03  Sameer V        Removed TC_IDLE in enum for delineation state. Hardware
+*                            only reports TC_HUNT, TC_PRESYNC and TC_SYNC.
+*  03/07/03  Sameer/Jonathan Put SWTC token around structs and elements only used by SWTC
+*  03/12/03  Mannering       Add CO profile data structures
+*  03/18/03  J. Bergsagel    Removed the obsolete DSP_CHECK_TC response message.
+*  03/24/03  J. Bergsagel    Added DEV_HOST_hostInterruptMask_t for masking DSP interrupt sources
+*  03/28/03  C. Perez-N      Changed the C-style comments and made them C++ sytle instead.
+*                            Replaced the occurrences of "SINT32 *" pointer declarations with
+*                            "PSINT32"
+*  03/28/03  Mannering       Update CO profile data structures
+*  04/04/03  S. Yim          Add host I/F hooks for switchable hybrid and RJ11
+*                              inner/outer pair selection
+*  04/11/03  J. Bergsagel    Changed modem state bit field struct types to enums instead and used
+*                            a single integer variable for each "bitfield".
+*                            Changed bit field for host interrupt masks to an integer value also.
+*  04/14/03  J. Bergsagel    Changed name of table pointer "meanSquareTblDstrm_p" to "marginTblDstrm_p".
+*  04/03/03  Umesh Iyer      CMsg1 and RMsg1 use the same storage as CMSGPCB and RMSGPCB.
+*                            The string lengths for these have been adjusted to hold the longest
+*                            message in each case. The PCB messages from ADSL2 are longer.
+*  04/21/03  Sameeer V       Added new host mailbox message for shutting down the DSLSS peripherals.
+*  04/23/03  J. Bergsagel    Fixed comments for overlay mailbox messages and for losErrors.
+*  04/28/03  Mannering       Added skip phase op flag to  CO profile data structure
+*  05/05/03  Mannering       Review Comments - Removed "#if CO_PROFILE" from around structure
+*                            definitions and define the number of profiles (DEV_HOST_LIST_ENTRIES)
+*  05/13/03  J. Bergsagel    Added new elements to DEV_HOST_phyPerf_t for host control of hybrid.
+*  05/15/03  J. Bergsagel    Added "farEndLosErrors" and "farEndRdiErrors" to DEV_HOST_modemStatsDef_t.
+*  05/16/03  Mannering       Updated CO profile structure to support updated bit allocation and
+*                            interopability.
+*  05/20/03  Sameer V        Added DSP message to inicate DYING GASP.
+*  05/22/03  J. Bergsagel    Added a new struct typedef "DEV_HOST_hostInterruptSource_t".
+*                            Added "atucGhsRevisionNum" to "DEV_HOST_dspWrNegoParaDef_t".
+*                            Moved the following struct typedef's here to the public host interface:
+*                              DEV_HOST_dspBitSwapDef_t
+*                              DEV_HOST_atmDsBert_t
+*  05/28/03  A. Redfern      Changed pointer type and location for margin reporting.
+*  05/28/03  Mannering       Moved CO profile defines to dev_host_interface_pvt.h
+*  05/28/03  J. Bergsagel    Moved subStateIndex and STM BERT controls into new struct "DEV_HOST_modemEnvPublic_t"
+*  05/29/03  J. Bergsagel    Added elements to "DEV_HOST_modemEnvPublic_t" for host control of DSLSS LED's.
+*  06/10/03  Umesh Iyer      Modified trainMode check to be compliant with the new host i/f mods.
+*  06/05/03  J. Bergsagel    Added enum that will eventually replace the bitfield: DEV_HOST_diagAnlgOptionsVar_t.
+*                            Added new element "currentHybridNumUsed" in the DEV_HOST_phyPerf_t typedef
+*                            Added new host control flags for LPR signal detection on GPIO[0].
+*  06/06/03  A. Redfern      Removed fine gain scale from the CO profile and added max downstream power cutback.
+*                            Changed "test1" in CO profile struct to "phyEcDelayAdjustment".
+*  06/26/03  J. Bergsagel    Added genericStructure typedef and two pointer elements of this type in the big table.
+*  07/03/03  Jack Huang      Renamed test2 to bSwapThresholdUpdate
+*  07/07/03  Mallesh         Changed phySigTxPowerCutback_f flag to a variable phySigTxGainReductionAt0kft which indicates the
+*                            amount of gain reduction in linear scale.
+*  07/15/03  Sameer V        Changed DEV_HOST_diagAnlgOptionsVar_t to be an enum instead of a bit field. Host code
+*                            does not support setting bit fields.
+*  07/22/03  Jack Huang      Added bitswap control flag in host i/f for API calls
+*  08/06/03  Sameer V        Added missingToneDs_p to the DEV_HOST_oamWrNegoParaDef_t to enable host to switch off
+*                            DS tones on specified bins
+*  08/21/03  Jack Huang      Added pcbEnabled flag in the DEV_HOST_modemEnvPublic_t structure
+*                            Added g.hs buffer definitions to DEV_HOST_dspOamSharedInterface_t
+*                            Added DEV_HOST_consBufDef_t to the DEV_HOST_dspOamSharedInterface_t structure
+*  08/26/03  J. Bergsagel    Fixed name of "missingToneDs_p" to be "missingToneDsAddr" instead (since it is
+*                            not really used as a pointer).
+*  09/11/03  Mallesh         Added a flag "usPilotInT1413ModeInMedley" to determine the need to send Upstream Pilot
+*                            in medley in T1.413 mode.
+*  09/12/03  J. Bergsagel    Changed "test3" to "phyBitaFastPathExcessFineGainBump" in CO profile struct.
+*                            Changed "test4" to "phyBitaSkipGapAdjustment" in CO profile struct.
+*  09/23/03  J. Bergsagel    Changed "T1413vendorRevisionNumber" to "vendorRevisionNumber" in DEV_HOST_msg_t.
+*                            Added ADSL2 and ADSL2 diag. states to the modem state bit field.
+*  10/01/03  J. Bergsagel    Changed define of "MULTI_MODE" to be 255 to indicate that all possible bits
+*                            in the 8-bit bit field are turned on for any current and future training modes.
+*  10/09/03  M. Turkboylari  Added DSP_TRAINING_MSGS and adsl2DeltMsgs_p, which is a pointer to a pointer,
+*                            in order to pass the ADSL2 training and DELT messages to the host side. This is for ACT.
+*  10/20/03  Mallesh         Added a GHS state enumerator for cleardown
+*  10/20/03  Xiaohui Li      Add definition for READSL2_MODE and READSL2_DELT
+*  11/07/03  J. Bergsagel    Removed all code for when SWTC==1, which therefore allows removal of include of
+*                            "env_def_defines.h".  We shouldn't have any compile tokens used in this file.
+*                            (the SWTC token is always off in any Ax7 code).
+*  11/14/03  J. Bergsagel    Also removed READSL2_ENABLE token (no more compile tokens to be used in this .h file).
+*  12/12/03  Sameer/Ram      Added DEV_HOST_EOCAOC_INTERRUPT_MASK to enable host to disable response code for AOC/EOC 
+*                            mailbox messages
+*  12/09/03  Jack Huang      Changed G.hs txbuf size from 60 to 64 to fit the max segment size 
+*  12/15/03  Mallesh         Changed vendor ID type defenition from SINT16 to UINT16
+*  12/23/03  Sameer V        Added ability to turn off constellation display reporting to host using oamFeature bit field.
+*  12/24/03  Sameer V        Changed comment for Constellation Display Current Address to Host Write instead of DSP Write.
+*  12/26/03  Sameer/Ram      Added DEV_HOST_GHSMSG_INTERRUPT_MASK to enable host to disable response code for GHS Messages 
+*  (C) Copyright Texas Instruments Inc. 2002.  All rights reserved.
+*******************************************************************************/
+
+#include "dev_host_verdef.h"
+
+// ---------------------------------------------------------------------------------
+// Address of the pointer to the DEV_HOST_dspOamSharedInterface_s struct of pointers
+// This is where it all starts.
+// ---------------------------------------------------------------------------------
+#define DEV_HOST_DSP_OAM_POINTER_LOCATION 0x80000000
+
+// The define "MAX_NUM_UPBINS" is used in "DEV_HOST_diagAnlgInputVar_t" below.
+// This value can never be changed (for host intf. backwards compatibility)
+#define MAX_NUM_UPBINS 64
+
+// -----------------------------------------------
+// Begin common enumerations between DSP and host.
+// -----------------------------------------------
+
+// These Host-to-DSP commands are organized into two groups:
+// immediate state change commands and status affecting commands.
+// Do not add or remove commands except at the bottom since the DSP assumes this sequence.
+
+enum
+{
+  HOST_ACTREQ,         // Send R-ACKREQ and monitor for C-ACKx
+  HOST_QUIET,          // Sit quietly doing nothing for about 60 seconds, DEFAULT STATE; R_IDLE
+  HOST_XMITBITSWAP,    // Perform upstream bitswap - FOR INTERNAL USE ONLY
+  HOST_RCVBITSWAP,     // Perform downstream bitswap - FOR INTERNAL USE ONLY
+  HOST_RTDLPKT,        // Send a remote download packet - FOR INTERNAL USE ONLY
+  HOST_CHANGELED,      // Read the LED settings and change accordingly
+  HOST_IDLE,           // Sit quiet
+  HOST_REVERBTEST,     // Generate REVERB for manufacturing test
+  HOST_CAGCTEST,       // Set coarse receive gain for manufacturing test
+  HOST_DGASP,          // send Dying Gasp messages through EOC channel
+  HOST_GHSREQ,         // G.hs - FOR INTERNAL USE ONLY
+  HOST_GHSMSG,         // G.hs - FOR INTERNAL USE ONLY
+  HOST_GHS_SENDGALF,   // G.hs - FOR INTERNAL USE ONLY
+  HOST_GHSEXIT,        // G.hs - FOR INTERNAL USE ONLY
+  HOST_GHSMSG1,        // G.hs - FOR INTERNAL USE ONLY
+  HOST_HYBRID,         // Enable/Disable automatic hybrid switch
+  HOST_RJ11SELECT,     // RJ11 inner/outer pair select
+  HOST_DIGITAL_MEM,    // Digital Diags: run external memory tests
+  HOST_TXREVERB,       // AFE Diags: TX path Reverb
+  HOST_TXMEDLEY,       // AFE Diags: TX path Medley
+  HOST_RXNOISEPOWER,   // AFE Diags: RX noise power
+  HOST_ECPOWER,        // AFE Diags: RX eco power
+  HOST_ALL_ADIAG,      // AFE Diags: all major analog diagnostic modes. Host is responsible to initiate each diagnostic sessions
+  HOST_USER_ADIAG,     // AFE Diags: Host fills in analog diagnostic input data structure as specified and requests DSP to perform measurements as specified
+  HOST_QUIT_ADIAG,     // AFE Diags: Host requests DSP to quit current diagnostic session. This is used for stopping the transmit REVERB/MEDLEY
+  HOST_NO_CMD,         // All others - G.hs - FOR INTERNAL USE ONLY
+  HOST_DSLSS_SHUTDOWN, // Host initiated DSLSS shutdown message
+  HOST_SET_GENERIC,    // Set generic CO profile
+  HOST_UNDO_GENERIC,   // Set profile previous to Generic
+  HOST_GHS_CLEARDOWN   // G.hs - FOR INTERNAL USE ONLY to start cleardown
+};
+
+// These DSP-to-Host responses are organized into two groups:
+// responses to commands and requests for OAM services.
+
+enum
+{
+  DSP_IDLE,               // R_IDLE state entered
+  DSP_ACTMON,             // R_ACTMON state entered
+  DSP_TRAIN,              // R_TRAIN state entered
+  DSP_ACTIVE,             // R_ACTIVE state entered
+  DSP_XMITBITSWAP,        // Upstream bitswap complete - FOR INTERNAL USE ONLY
+  DSP_RCVBITSWAP,         // Downstream bitswap complete - FOR INTERNAL USE ONLY
+  DSP_RTDL,               // R_RTDL state entered - FOR INTERNAL USE ONLY
+  DSP_RRTDLPKT,           // RTDL packet received - FOR INTERNAL USE ONLY
+  DSP_XRTDLPKT,           // RTDL packet transmitted - FOR INTERNAL USE ONLY
+  DSP_ERROR,              // Command rejected, wrong state for this command
+  DSP_REVERBTEST,         // Manufacturing REVERB test mode entered
+  DSP_CAGCTEST,           // Manufacturing receive gain test done
+  DSP_OVERLAY_START,      // Notify host that page overlay has started - overlay number indicated by "tag"
+  DSP_OVERLAY_END,        // Notify host that page overlay has ended   - overlay number indicated by "tag"
+  DSP_CRATES1,            // CRATES1 message is valid and should be copied to host memory now
+  DSP_SNR,                // SNR calculations are ready and should be copied to host memory now
+  DSP_GHSMSG,             // G.hs - FOR INTERNAL USE ONLY
+  DSP_RCVBITSWAP_TIMEOUT, // Acknowledge Message was not received within ~500 msec (26 Superframes).
+  DSP_ATM_TC_SYNC,        // Indicates true TC sync on both the upstream and downstream. Phy layer ready for data xfer.
+  DSP_ATM_NO_TC_SYNC,     // Indicates loss of sync on phy layer on either US or DS.
+  DSP_HYBRID,             // DSP completed hybrid switch
+  DSP_RJ11SELECT,         // DSP completed RJ11 inner/outer pair select
+  DSP_INVALID_CMD,        // Manufacturing (Digital and AFE) diags: CMD received not recognized
+  DSP_TEST_PASSED,        // Manufacturing diags: test passed
+  DSP_TEST_FAILED,        // Manufacturing diags: test failed
+  DSP_TXREVERB,           // Manufacturing AFE diags: Response to HOST_TXREVERB
+  DSP_TXMEDLEY,           // Manufacturing AFE diags: Response to HOST_TXMEDLEY
+  DSP_RXNOISEPOWER,       // Manufacturing AFE diags: Response to HOST_RXNOISEPOWER
+  DSP_ECPOWER,            // Manufacturing AFE diags: Response to HOST_ECPOWER
+  DSP_ALL_ADIAG,          // Manufacturing AFE diags: Response to HOST_ALL_ADIAG
+  DSP_USER_ADIAG,         // Manufacturing AFE diags: Response to HOST_USER_ADIAG
+  DSP_QUIT_ADIAG,         // Manufacturing AFE diags: Response to HOST_QUIT_ADIAG
+  DSP_DGASP,              // DSP Message to indicate dying gasp
+  DSP_EOC,                // DSP Message to indicate that DSP sent an EOC message to CO
+  DSP_TRAINING_MSGS       // DSP Message to indicate that host has to copy the training message specified in the tag field.
+};
+
+// Define different ADSL training modes.
+//Defintions as per new host interface.
+#define NO_MODE             0
+#define GDMT_MODE           2
+#define GLITE_MODE          4
+#define ADSL2_MODE          8
+#define ADSL2_DELT          (ADSL2_MODE+1)
+#define ADSL2PLUS_MODE      16
+#define ADSL2PLUS_DELT      (ADSL2PLUS_MODE+1)
+#define READSL2_MODE        32
+#define READSL2_DELT        (READSL2_MODE+1)
+#define T1413_MODE          128
+#define MULTI_MODE          255 // all possible bits are set in the bit field
+
+// Define the reason for dropping the connection
+
+enum
+{
+  REASON_LOS         = 0x01,
+  REASON_DYING_GASP  = 0x02,
+  REASON_USCRCERR    = 0x04,
+  REASON_MARGIN_DROP = 0x08
+};
+
+
+// ----------------------------------------------------
+// Begin modem state bit field definitions - DSP write.
+// ----------------------------------------------------
+
+// BitField1 for initial states and G.hs states.
+// If more values need to be added, they will be added at the end (up to 32 total entries).  However, if this causes
+// the state transitions to tick off out of normal bit order, then the C code will have to be re-written
+// that causes the proper values to be entered into the modem state bit fields.
+typedef enum
+{
+  ZERO_STATE1 = 0,
+  RTEST       = 0x1,
+  RIDLE       = 0x2,
+  RINIT       = 0x4,
+  RRESET      = 0x8,
+  GNSFLR      = 0x10,
+  GTONE       = 0x20,
+  GSILENT     = 0x40,
+  GNEGO       = 0x80,
+  GFAIL       = 0x100,
+  GACKX       = 0x200,
+  GQUIET2     = 0x400
+} DEV_HOST_stateBitField1_t; // this enum should only have 32 bit entries in it.  Add another enum if you need more.
+
+// BitField2 for T1.413 states and for the rest of the modem states (so far)
+// If more values need to be added, they will be added at the end (up to 32 total entries).  However, if this causes
+// the state transitions to tick off out of normal bit order, then the C code will have to be re-written
+// that causes the proper values to be entered into the modem state bit fields.
+typedef enum
+{
+  ZERO_STATE2 = 0,
+  TNSFLR      = 0x1,
+  TACTREQ     = 0x2,
+  TACTMON     = 0x4,
+  TFAIL       = 0x8,
+  TACKX       = 0x10,
+  TQUIET2     = 0x20,
+  RQUIET2     = 0x40,
+  RREVERB1    = 0x80,
+  RQUIET3     = 0x100,
+  RECT        = 0x200,
+  RREVERB2    = 0x400,
+  RSEGUE1     = 0x800,
+  RREVERB3    = 0x1000,
+  RSEGUE2     = 0x2000,
+  RRATES1     = 0x4000,
+  RMSGS1      = 0x8000,
+  RMEDLEY     = 0x10000,
+  RREVERB4    = 0x20000,
+  RSEGUE3     = 0x40000,
+  RMSGSRA     = 0x80000,
+  RRATESRA    = 0x100000,
+  RREVERBRA   = 0x200000,
+  RSEGUERA    = 0x400000,
+  RMSGS2      = 0x800000,
+  RRATES2     = 0x1000000,
+  RREVERB5    = 0x2000000,
+  RSEGUE4     = 0x4000000,
+  RBNG        = 0x8000000,
+  RREVERB6    = 0x10000000,
+  RSHOWTIME   = 0x20000000
+} DEV_HOST_stateBitField2_t;  // this enum should only have 32 bit entries in it.  Add another enum if you need more.
+
+// BitField3 for ADSL2 states
+// If more values need to be added, they will be added at the end (up to 32 total entries).  However, if this causes
+// the state transitions to tick off out of normal bit order, then the C code will have to be re-written
+// that causes the proper values to be entered into the modem state bit fields.
+typedef enum
+{
+  ZERO_STATE3 = 0,
+  G2QUIET1    = 0x1,
+  G2COMB1     = 0x2,
+  G2QUIET2    = 0x4,
+  G2COMB2     = 0x8,
+  G2ICOMB1    = 0x10,
+  G2LINEPROBE = 0x20,
+  G2QUIET3    = 0x40,
+  G2COMB3     = 0x80,
+  G2ICOMB2    = 0x100,
+  G2RMSGFMT   = 0x200,
+  G2RMSGPCB   = 0x400,
+  G2REVERB1   = 0x800,
+  G2QUIET4    = 0x1000,
+  G2REVERB2   = 0x2000,
+  G2QUIET5    = 0x4000,
+  G2REVERB3   = 0x8000,
+  G2ECT       = 0x10000,
+  G2REVERB4   = 0x20000,
+  G2SEGUE1    = 0x40000,
+  G2REVERB5   = 0x80000,
+  G2SEGUE2    = 0x100000,
+  G2RMSG1     = 0x200000,
+  G2MEDLEY    = 0x400000,
+  G2EXCHANGE  = 0x800000,
+  G2RMSG2     = 0x1000000,
+  G2REVERB6   = 0x2000000,
+  G2SEGUE3    = 0x4000000,
+  G2RPARAMS   = 0x8000000,
+  G2REVERB7   = 0x10000000,
+  G2SEGUE4    = 0x20000000
+} DEV_HOST_stateBitField3_t;  // this enum should only have 32 bit entries in it.  Add another enum if you need more.
+
+// BitField4 for ADSL2 diag. states
+// If more values need to be added, they will be added at the end (up to 32 total entries).  However, if this causes
+// the state transitions to tick off out of normal bit order, then the C code will have to be re-written
+// that causes the proper values to be entered into the modem state bit fields.
+typedef enum
+{
+  ZERO_STATE4 = 0,
+  GDSEGUE1    = 0x1,
+  GDREVERB5   = 0x2,
+  GDSEGUE2    = 0x4,
+  GDEXCHANGE  = 0x8,
+  GDSEGUELD   = 0x10,
+  GDRMSGLD    = 0x20,
+  GDQUIET1LD  = 0x40,
+  GDQUIET2LD  = 0x80,
+  GDRACK1     = 0x100,
+  GDRNACK1    = 0x200,
+  GDQUIETLAST = 0x400
+} DEV_HOST_stateBitField4_t;  // this enum should only have 32 bit entries in it.  Add another enum if you need more.
+
+// This struct collects all of the bitfield types listed above for the modem state bit field(s)
+typedef struct
+{
+  DEV_HOST_stateBitField1_t bitField1; // this is the first modem state bit field (mostly init. and G.hs)
+  DEV_HOST_stateBitField2_t bitField2; // this is the second modem state bit field (T1.413 and G.dmt)
+  DEV_HOST_stateBitField3_t bitField3; // this is the third modem state bit field (ADSL2)
+  DEV_HOST_stateBitField4_t bitField4; // this is the fourth modem state bit field (ADSL2 diag.)
+} DEV_HOST_modemStateBitField_t;
+
+
+// -----------------------------------------------
+// Begin NegoPara message definitions - DSP write.
+// -----------------------------------------------
+
+typedef struct
+{
+  UINT8  trainMode;          // Train mode selected.  See training modes defined above.
+  UINT8  bDummy1;            // dummy byte for explicit 32-bit alignment
+  UINT16 lineLength;         // Contains loop length estimate.  Accuracy w/i 500 ft.  LSbit = 1 for straight loop, = 0 for bridge tap
+  UINT32 atucVendorId;       // Pass the vendor id of the CO to the host
+  UINT8  cMsgs1[8];          // CMsgs1 and CMSGPCB
+  UINT16 adsl2DSRate;        //
+  UINT8  cRates2;            //
+  UINT8  rRates2;            //
+  UINT8  rRates1[4][11];     //
+  UINT8  cMsgs2[4];          //
+  UINT8  cRates1[4][30];     //
+  UINT8  rMsgs2[4];          //
+  UINT16 adsl2USRate;        //
+  UINT8  atucGhsRevisionNum; // Pass the G.hs Revision number of the CO to the host
+  UINT8  reserved1;          //
+  PUINT8 *adsl2DeltMsgs_p;   // This pointer to a pointer passes the address of the globalvar.pString, which is also
+                             // a pointer list of pointers. It will be used to pass all the new ADSL2 DELT messages to
+                             // host side. This is for ACT.
+} DEV_HOST_dspWrNegoParaDef_t;
+
+
+// ----------------------------------------------------
+// Begin OAM NegoPara message definitions - Host write.
+// ----------------------------------------------------
+
+// OAM Feature bit fields.
+//
+// Bit    0 - Enable auto retrain of modem
+// Bit    1 - Detect and report TC sync to host
+// Bit 2-31 - Reserved
+
+#define DEV_HOST_AUTORETRAIN_ON       0x00000001
+#define DEV_HOST_TC_SYNC_DETECT_ON    0x00000002
+
+#define DEV_HOST_AUTORETRAIN_MASK       0x00000001
+#define DEV_HOST_TC_SYNC_DETECT_MASK    0x00000002
+#define DEV_HOST_EOCAOC_INTERRUPT_MASK  0x00000004
+#define DEV_HOST_CONS_DISP_DISABLE_MASK 0x00000008
+#define DEV_HOST_GHSMSG_INTERRUPT_MASK  0x00000010
+
+typedef struct
+{
+  UINT8   stdMode;              // Desired train mode.  See training modes defined above.
+  UINT8   ghsSequence;          // Selected G.hs session as shown in Appendix 1
+  UINT8   usPilotFlag;          // Value of 1 indicates transmit an upstream pilot on bin 16
+  UINT8   bDummy1;              // dummy byte for 32-bit alignment
+  UINT8   rMsgs1[38];           // RMSG-1(6) and RMSG_PCB (38)
+  UINT8   bDummy2[2];           // dummy bytes for 32-bit alignment
+  UINT32  oamFeature;           // 32 bit wide bit field to set OAM-specific features.
+  SINT8   marginThreshold;      // Threshold for margin reporting
+  UINT8   hostFixAgc;           // flag to force datapump to bypass AGC training and use the following values
+  UINT8   hostFixEqualizer;     // forced analog equalizer value used during AGC training when hostfix_agc is on
+  UINT8   hostFixPga1;          // forced pga1 value used during AGC training when hostFixAgc is on
+  UINT8   hostFixPga2;          // forced pga2 value used during AGC training when hostFixAgc is on
+  UINT8   hostFixPga3;          // forced pga3 value used during AGC training when hostFixAgc is on
+  UINT8   marginMonitorShwtme;  // margin monitoring flag (during showtime)
+  UINT8   marginMonitorTrning;  // margin monitoring flag (during training)
+  UINT8   disableLosAlarm;      // flag to disable training based on los
+  UINT8   usCrcRetrain;         // flag to disable retrain due to excessive USCRC
+  UINT8   t1413VendorId[2];     // Vendor ID used for T1.413 trainings
+  UINT8   gdmtVendorId[8];      // Vendor ID used for G.dmt trainings (ITU VendorID)
+  UINT8   missingTones[64];     // 64 element array to define missing tones for TX_MEDLEY and TX REVERB tests
+  UINT32  missingToneDsAddr;    // Address given to DSP for tones to be switched off in DS direction
+  UINT8   dsToneTurnoff_f;      // This flag controls the DS tone turn off logic
+  UINT8   reserved1;            // Dummy bytes
+  UINT8   reserved2;            // Dummy bytes
+  UINT8   reserved3;            // Dummy bytes
+} DEV_HOST_oamWrNegoParaDef_t;
+
+
+// ----------------------------------------
+// Begin Rate-adaptive message definitions.
+// ----------------------------------------
+
+// The four values below can never be changed (for host intf. backwards compatibility)
+#define DEV_HOST_RMSGSRA_LENGTH  10
+#define DEV_HOST_RRATESRA_LENGTH 1
+#define DEV_HOST_CRATESRA_LENGTH 120
+#define DEV_HOST_CMSGSRA_LENGTH  6
+
+typedef struct
+{
+  UINT8 rRatesRaString[DEV_HOST_RRATESRA_LENGTH+3];
+  UINT8 rMsgsRaString[DEV_HOST_RMSGSRA_LENGTH+2];
+  UINT8 cMsgsRaString[DEV_HOST_CMSGSRA_LENGTH+2];
+} DEV_HOST_raMsgsDef_t;
+
+
+// ----------------------------------------------
+// Begin superframe cnts definitions - DSP write.
+// ----------------------------------------------
+
+#define DEV_HOST_FRAMES_PER_SUPER   68
+#define DEV_HOST_SUPERFRAMECNTDSTRM 0
+#define DEV_HOST_SUPERFRAMECNTUSTRM 4
+
+// Although only the least significant 8 bits should be used as an
+// unsigned char for computing the bitswap superframe number, a
+// full 32 bit counter is provided here in order to have an
+// accurate indicator of the length of time that the modem has
+// been connected.  This counter will overflow after 2.35 years
+// of connect time.
+
+typedef struct
+{
+  UINT32 wSuperFrameCntDstrm;
+  UINT32 wSuperFrameCntUstrm;
+} DEV_HOST_dspWrSuperFrameCntDef_t;
+
+
+// --------------------------------
+// Begin ATUR/ATUC msg definitions.
+// --------------------------------
+
+// Grouping used by the DSP to simplify parameter passing.
+// All of these are written by the DSP.
+
+typedef struct
+{
+  UINT16 vendorId;          // TI's vendor ID = 0x0004; Amati's vendor ID = 0x0006
+  UINT8  versionNum;        // T1.413 issue number
+  UINT8  rateAdapt;         // 0 = fix rate (Default); 1= adaptive rate
+  UINT8  trellis;           // 0 = disable trellis(default); 1 = enable trellis
+  UINT8  echoCancelling;    // 0 = disable echo cancelling; 1 = enable echo cancelling(default)
+  UINT8  maxBits;           // value range: 0-15; default = 15
+  UINT8  maxPsd;            //
+  UINT8  actualPsd;         //
+  UINT8  maxIntlvDepth;     // 0, 1, 2, or 3 for 64, 128, 256, or 512 max depth
+  UINT8  framingMode;       // 0 for asynchronous, 1 for synchronous full overhead
+                            // 2 for reduced overhead, 3 for merged reduced overhead DSP write.
+  UINT8  maxFrameMode;      // maximum framing mode desired.  Nor 0 or 3.
+  SINT16 targetMargin;      //
+  SINT16 maxAllowedMargin;  //
+  SINT16 minRequiredMargin; //
+  SINT16 maxTotBits;        //
+  UINT8  grossGain;         //
+  UINT8  ntr;               // Enable/disable NTR support
+  SINT16 loopAttn;          // Loop Attenuation
+  UINT8  vendorRevisionNumber;  // Reported Vendor Revision Number
+  UINT8  reserved1;         // for 32-bit alignment
+  UINT8  reserved2;         // for 32-bit alignment
+  UINT8  reserved3;         // for 32-bit alignment
+} DEV_HOST_msg_t;
+
+
+// --------------------------------------
+// Begin bits and gains table definitions
+// --------------------------------------
+
+typedef struct
+{
+  PUINT8  aturBng_p;            // pointer to ATU-R bits and gains table
+  PUINT8  atucBng_p;            // pointer to ATU-C bits and gains table
+  PUINT8  bitAllocTblDstrm_p;   // pointer to Downstream Bit Allocation table
+  PUINT8  bitAllocTblUstrm_p;   // pointer to Upstream Bit Allocation table
+  PSINT8  marginTblDstrm_p;     // pointer to Downstream Margin table
+} DEV_HOST_dspWrSharedTables_t;
+
+
+// ----------------------------------------
+// Begin datapump code overlay definitions.
+// ----------------------------------------
+
+#define DEV_HOST_PAGE_NUM 4   // number of overlay pages
+
+// Never access a struct of this typedef directly.  Always go through the DEV_HOST_olayDpDef_t struct
+typedef struct
+{
+  UINT32 overlayHostAddr;     // source address in host memory
+  UINT32 overlayXferCount;    // number of 32bit words to be transfered
+  UINT32 overlayDspAddr;      // destination address in DSP's PMEM
+} DEV_HOST_olayDpPageDef_t;
+
+
+typedef struct
+{
+  UINT32 overlayStatus;                      // Status of current overlay to DSP PMEM
+  UINT32 overlayNumber;                      // DSP PMEM overlay page number
+  UINT32 overlayState;                       // Indicates whether current state is an overlay state
+  DEV_HOST_olayDpPageDef_t *olayDpPage_p[DEV_HOST_PAGE_NUM]; // Def's for the Pages
+} DEV_HOST_olayDpDef_t;
+
+
+// -------------------------
+// Begin ATM-TC definitions.
+// -------------------------
+
+// TC cell states.
+typedef enum
+{
+  TC_HUNT,
+  TC_PRESYNC,
+  TC_SYNC
+} DEV_HOST_cellDelinState_t;
+
+
+// --------------------------------------------
+// Begin datapump error/statistics definitions.
+// --------------------------------------------
+
+// Never access a struct of this typedef directly.  Always go through the DEV_HOST_modemStatsDef_t struct.
+typedef struct
+{
+  UINT32 crcErrors;   // Num of CRC errored ADSL frames
+  UINT32 fecErrors;   // Num of FEC errored (corrected) ADSL frames
+  UINT32 ocdErrors;   // Out of Cell Delineation
+  UINT32 ncdError;    // No Cell Delineation
+  UINT32 lcdErrors;   // Loss of Cell Delineation (within the same connection)
+  UINT32 hecErrors;   // Num of HEC errored ADSL frames
+} DEV_HOST_errorStats_t;
+
+
+typedef struct
+{
+  DEV_HOST_errorStats_t *usErrorStatsIntlv_p; // us error stats - interleave path
+  DEV_HOST_errorStats_t *dsErrorStatsIntlv_p; // ds error stats - interleave path
+  DEV_HOST_errorStats_t *usErrorStatsFast_p;  // us error stats - fast path
+  DEV_HOST_errorStats_t *dsErrorStatsFast_p;  // ds error stats - fast path
+  UINT32                losErrors;   // Num of ADSL frames where loss-of-signal
+  UINT32                sefErrors;   // Num of severly errored ADSL frames - LOS > MAXBADSYNC ADSL frames
+  UINT32                farEndLosErrors; // Number of reported LOS defects by the CO.
+  UINT32                farEndRdiErrors; // Number of reported RDI defects by the CO.
+} DEV_HOST_modemStatsDef_t;
+
+// Never access a struct of this typedef directly.  Always go through the DEV_HOST_atmStats_t struct.
+typedef struct
+{
+  UINT32 goodCount;   // Upstream Good Cell Count
+  UINT32 idleCount;   // Upstream Idle Cell Count
+} DEV_HOST_usAtmStats_t;
+
+// Never access a struct of this typedef directly.  Always go through the DEV_HOST_atmStats_t struct.
+typedef struct
+{
+  UINT32 goodCount;      // Downstream Good Cell Count
+  UINT32 idleCount;      // Downstream Idle Cell Count
+  UINT32 badHecCount;    // Downstream Bad Hec Cell Count
+  UINT32 ovflwDropCount; // Downstream Overflow Dropped Cell Count
+  DEV_HOST_cellDelinState_t delineationState; // Indicates current delineation state
+} DEV_HOST_dsAtmStats_t;
+
+
+typedef struct
+{
+  DEV_HOST_usAtmStats_t *us0_p; // US ATM stats for TC channel 0
+  DEV_HOST_dsAtmStats_t *ds0_p; // DS ATM stats for TC channel 0
+  DEV_HOST_usAtmStats_t *us1_p; // US ATM stats for TC channel 1
+  DEV_HOST_dsAtmStats_t *ds1_p; // DS ATM stats for TC channel 1
+} DEV_HOST_atmStats_t;
+
+
+// ----------------------
+// Begin EOC definitions.
+// ----------------------
+
+// The two values below can never change (for backwards compatibility of host intf.)
+#define DEV_HOST_EOCREG4LENGTH   32
+#define DEV_HOST_EOCREG5LENGTH   32
+
+typedef struct
+{
+  UINT8        eocReg4[DEV_HOST_EOCREG4LENGTH];    // Host/Dsp Write, vendor specific EOC Register 4
+  UINT8        eocReg5[DEV_HOST_EOCREG5LENGTH];    // Host/Dsp Write, vendor specific EOC Register 5
+  UINT8        vendorId[8];               // Host write
+  UINT8        revNumber[4];              // Host, ATU-R Revision Number
+  UINT8        serialNumber[32];          // Host write
+  UINT8        eocReg4Length;             // Host Write, valid length for EOC register 4
+  UINT8        eocReg5Length;             // Host Write, valid length for EOC register 5
+  UINT8        dummy[2];                  // dummy bytes for 32-bit alignment
+  UINT32       eocModemStatusReg;         // Dsp Write, status bits to host
+  UINT8        lineAtten;                 // Dsp Write, line attenuation in 0.5 db step
+  SINT8        dsMargin;                  // DSP Write, measured DS margin
+  UINT8        aturConfig[30];            // Dsp Write, also used by EOC for ATUR Configuration
+} DEV_HOST_eocVarDef_t;
+
+typedef struct
+{
+  UINT16       endEocThresh;              // Host Write, end of Clear EOC stream threshold
+  UINT16       dummy;                     // dummy value to fill gap
+  UINT32       dropEocCount;              // Dsp Write, counter of dropped Clear EOC bytes
+  UINT16       eocRxLength;               // Host/DSP write, number of valid Rx Clear EOC bytes
+  UINT16       eocTxLength;               // Host/DSP write, number of valid Tx Clear EOC bytes
+  UINT8        eocRxBuf[64];              // Dsp Write, Buffer for receiving Rx Clear EOC bytes
+  UINT8        eocTxBuf[64];              // Host Write, Buffer for writing Tx Clear EOC bytes
+} DEV_HOST_clearEocVarDef_t;
+
+
+// -----------------------------------
+// Begin CO profile Definitions.
+// -----------------------------------
+
+/* struct size must be a word size            */
+typedef struct
+{
+
+  SINT16 devCodecRxdf4Coeff[12] ;             // (BOTH) IIR Coefficients
+  SINT16 devCodecTxdf2aCoeff[64] ;            // (BOTH) FIR filter coefficients
+  SINT16 devCodecTxdf2bCoeff[64] ;            // (BOTH) FIR filter coefficients
+  SINT16 devCodecTxdf1Coeff[12] ;             // (BOTH) IIR filter coefficients
+  UINT16 devCodecTxDf2aDen;                   // (BOTH) denominator for IIR filter
+  UINT16 devCodecTxDf2bDen;                   // (BOTH) denominator for IIR filter
+  SINT16 ctrlMsmSpecGain[32];                 // (BOTH)
+
+  SINT16 phyBitaRateNegIntNoTrellis ;         // (BOTH) value to set
+  SINT16 phyBitaRateNegIntTrellis ;           // (BOTH) value to set
+  SINT16 phyBitaRateNegFastNoTrellis ;        // (BOTH) value to set
+  SINT16 phyBitaRateNegFastTrellis ;          // (BOTH) value to set
+  SINT16 phyBitaRsFlag ;                      // (BOTH)
+  SINT16 phyBitaFirstSubChannel ;             // (BOTH)
+  SINT16 phyBitaMaxFineGainBump;              // max fine gain bump
+  SINT16 phyBitaFineGainReduction;            // fine gain reduction
+  SINT16 phyBitaMaxDownstreamPowerCutback;    // max downstream power cutback
+
+  SINT16 phySigTxGainReductionAt0kft;         // upstream power reduction at 0 kft.
+
+  SINT16 phyAgcPgaTarget ;                    // (BOTH) compare value
+
+  UINT16 imsg413TxRate ;                      // (BOTH) Tx rate
+  SINT16 imsg413RsBytesAdjust ;               // (BOTH) subtract value
+  UINT16 imsg413PstringMask ;                 // (POTS) Or'ed into pString[RMSGS1_INDEX][1]
+  SINT16 imsg413UsPilot ;                     // (BOTH)??
+  UINT16 imsg413SkipPhaseOp ;                 // (POTS)
+
+  UINT16 ctrlMsmSensitivity1 ;                // (BOTH) value to set
+  UINT16 ctrlMsmTxPsdShape_f;                 // (BOTH) upstream spectral shaping flag
+
+  UINT16 ovhdAocUsBswapReq_f ;                // (BOTH)value to set
+  UINT16 ovhdAocScanMse_f  ;                  // (BOTH)value to set
+
+  SINT16 phyRevFullFirstBin ;                 //
+  SINT16 phyRevFullLastBin ;                  //
+  SINT16 phyRevFirstBin ;                     //
+  SINT16 phyRevLastBin ;                      //
+  SINT16 phyMedFirstBin ;                     //
+  SINT16 phyMedLastBin ;                      //
+  SINT16 phyMedOptionalLastBin;               // Medley last bin - optional
+
+  SINT16 phyEcDelayAdjustment;                // Echo delay adjustment
+  SINT16 bSwapThresholdUpdate;                // bSwapThresholdUpdate
+  SINT16 phyBitaFastPathExcessFineGainBump;   // Used in phy_bita.c
+  SINT16 phyBitaSkipGapAdjustment;            // Used in phy_bita.c
+  SINT16 usPilotInT1413ModeInMedley;          // To send Upstream Pilot in medley in T1.413 mode.
+
+  UINT32 profileVendorId ;                    // vendor id
+
+} DEV_HOST_coData_t ;
+
+typedef struct
+{
+  DEV_HOST_coData_t *  hostProfileBase_p;     // base address of profile list
+} DEV_HOST_profileBase_t ;
+
+
+
+// -----------------------------------
+// Begin DSP/Host Mailbox Definitions.
+// -----------------------------------
+
+// The 3 values below can never be decreased, only increased.
+// If you increase one of the values, you must add more to the
+//   initializers in "dev_host_interface.c".
+#define DEV_HOST_HOSTQUEUE_LENGTH  8
+#define DEV_HOST_DSPQUEUE_LENGTH   8
+#define DEV_HOST_TEXTQUEUE_LENGTH  8
+
+// Never access a struct of this typedef directly.  Always go through the DEV_HOST_mailboxControl_t struct.
+typedef struct
+{
+  UINT8 cmd;
+  UINT8 tag;
+  UINT8 param1;
+  UINT8 param2;
+} DEV_HOST_dspHostMsg_t;
+
+// Never access a struct of this typedef directly.  Always go through the DEV_HOST_mailboxControl_t struct.
+typedef struct
+{
+  UINT32 msgPart1;
+  UINT32 msgPart2;
+} DEV_HOST_textMsg_t;
+
+// The structure below has been ordered so that the Host need only write to
+// even byte locations to update the indices.
+
+// The Buffer pointers in the struct below each point to a different
+//   struct array that has an array size of one of the matching Queue Length
+//   values defined above (DEV_HOST_HOSTQUEUE_LENGTH, DEV_HOST_DSPQUEUE_LENGTH,
+//   and DEV_HOST_TEXTQUEUE_LENGTH).
+
+typedef struct
+{
+  UINT8 hostInInx;  // Host write, DSP must never write except for init
+  UINT8 bDummy0[3]; //   dummy bytes for explicit 32-bit alignment
+  UINT8 hostOutInx; // DSP write, Host must never write
+  UINT8 bDummy1[3]; //   dummy bytes for explicit 32-bit alignment
+  UINT8 dspOutInx;  // Host write, DSP must never write except for init
+  UINT8 bDummy2[3]; //   dummy bytes for explicit 32-bit alignment
+  UINT8 dspInInx;   // DSP write, Host must never write
+  UINT8 bDummy3[3]; //   dummy bytes for explicit 32-bit alignment
+  UINT8 textInInx;  // DSP write, Host must never write
+  UINT8 bDummy4[3]; //   dummy bytes for explicit 32-bit alignment
+  UINT8 textOutInx; // Host write, DSP must never write except for init
+  UINT8 bDummy5[3]; //   dummy bytes for explicit 32-bit alignment
+  DEV_HOST_dspHostMsg_t *hostMsgBuf_p;  // pointer to Host Mailbox Buffer (Host writes the buffer)
+  DEV_HOST_dspHostMsg_t *dspMsgBuf_p;   // pointer to DSP Mailbox Buffer (DSP writes the buffer)
+  DEV_HOST_textMsg_t *textMsgBuf_p;     // pointer to Text Mailbox Buffer (DSP writes the buffer)
+} DEV_HOST_mailboxControl_t;
+
+
+//-----------------------------------------
+// Physical layer performance parameter
+//-----------------------------------------
+typedef struct
+{
+  SINT32 hybridCost[5];             // Cost functions for hybrids (0: none, 1-4 hybrid options)
+  SINT32 usAvgGain;                 // upstream average gain in 20log10 (Q8)
+  SINT32 dsAvgGain;                 // downstream average gain in 20log10 (Q8)
+  UINT8  disableDspHybridSelect_f;  // Allows host to disable the automatic hybrid selection by the DSP
+  UINT8  hostSelectHybridNum;       // DSP will use this hybrid number only if DSP Select is disabled (values: 1-4)
+  UINT8  currentHybridNumUsed;      // DSP indicates to the host the current hybrid number in use
+  UINT8  reserved1;                 // reserved for future use
+} DEV_HOST_phyPerf_t;
+
+
+/***********************************************************
+ * The 3 structures below are used only for analog
+ * diagnostic functions originally defined in diag.h
+ * Moved here by Carlos A. Perez under J. Bergsagel request
+ ***********************************************************/
+
+/****************************************************************************/
+/* Options for the Analog Diagnostic user input data structure              */
+/* (MUST be word aligned)                                                   */
+/****************************************************************************/
+typedef enum
+{
+  ZERO_DIAG_OPT   = 0,       // dummy value for zero place-holder
+  NOISE_ONLY      = 0x1,     // diagnostic in noise only mode (on=1, off=0), disregard diagMode 0-4
+  EXTERNAL_CO     = 0x2,     // operates against external CO (external=1, internal=0)
+  DIAG_AGC        = 0x4,     // agc selects gains control (agc=1, manual=0)
+  CROSSTALK_TEQ   = 0x8,     // crosstalk selects teq (crosstalk=1, manual=0)
+  LEAKY_TEQ       = 0x10,    // use leaky teq (on=1, off=0)
+  AUX_AMPS        = 0x20,    // auxamps (on=1, off=0)
+  BW_SELECT       = 0x40,    // change rxhpf/txlpf fc (modify=1, default=0)
+  DIAG_HYB_SELECT = 0x80,    // change hybrid (modify=1, default=0)
+  POWER_DOWN_CDC  = 0x100,   // power down codec (power down=1, no power down=0)
+  ISDN_OP_MODE    = 0x200,   // operation mode (pots=0, isdn=1)
+  BYPASS_RXAF2    = 0x400,   // Bypass except RXAF2 (on=1, off = 0)
+  TX_TEST_CONT    = 0x800,   // Continuous tx test (on=1, off=0)
+  TX_SCALE_MTT    = 0x1000   // Scale tx signal for Mtt test (on=1, off=0)
+} DEV_HOST_diagAnlgOptionsVar_t;
+
+/****************************************************************************/
+/* Analog Diagnostic user input data structure (MUST be word align)         */
+/****************************************************************************/
+
+typedef struct
+{
+  DEV_HOST_diagAnlgOptionsVar_t   diagOption; // Other diagnostic optional settings
+
+  UINT8                     diagMode;     // Performance diagnostic mode
+  UINT8                     txMode;       // transmit mode
+  UINT8                     rxMode;       // receive mode
+  UINT8                     teqSp;        // Select teq starting pt
+  UINT8                     txDf1;        // see dev_codec_filters.c and
+  UINT8                     txDf2a;       // dev_codec.h for filter coefficients
+  UINT8                     txDf2b;
+  UINT8                     rxDf4;
+
+  UINT16                    codingGain256Log2;  // 256*Log2(coding gain)
+  UINT16                    noiseMargin256Log2; // 256*Log2(noise margin)
+
+  UINT16                    rxPga1;       // PGA1
+  UINT16                    rxPga2;       // PGA2
+  UINT16                    rxPga3;       // PGA3
+  UINT16                    anlgEq;       // AEQ settings (dB/MHz)
+
+  SINT8                     pilotBin;     // Select  pilot subchannel
+  SINT8                     txSwGain;     // manual set for bridge tap loop
+  SINT8                     tdw1Len;      // TDW1 length - 0,2,4,8,16
+  SINT8                     tdw2Len;      // TDW2 length - 0,2,4,8,16
+
+  UINT8                     teqEcMode;    // TEQ/EC mode
+  UINT8                     hybrid;
+  UINT8                     txAttn;       // Codec Tx attenuation
+  UINT8                     txGain;       // Codec Tx gain (Sangam only)
+
+  SINT16                    txPda;        //Codec Tx Digital gain/attn
+  UINT8                     txTone[MAX_NUM_UPBINS];  // Turning tones on/off
+                                                     // Still govern by lastbin
+  UINT16                   rsvd;          //for 32 bits alignment
+}DEV_HOST_diagAnlgInputVar_t;
+
+/****************************************************************************/
+/* Analog diagnostic output data structure                                  */
+/****************************************************************************/
+typedef struct
+{
+  PSINT32  rxSnr_p[2];                  // Pointer to estimated snr
+  PSINT32  rxSubChannelCapacity_p[2];   // Pointer to estimated subchan capacity
+  PSINT32  rxSignalPower_p[2];          // Pointer to estimated signal power
+  PSINT32  rxNoisePower_p[2];           // Pointer to estimated noise power
+  PSINT32  rxAvg_p;                     // Pointer to average of rcvd signal
+  SINT32   chanCapacity[2] ;            // Channel total capacity
+  SINT32   dataRate[2];                 // Modem data rate (SNR)
+  SINT32   avgNoiseFloor;               // Average noise floor
+  SINT16   snrGap256Log2;               // 256*Log2(snr gap)
+  SINT16   rxPga1;                      // PGA1
+  SINT16   rxPga2;                      // PGA2
+  SINT16   rxPga3;                      // PGA3
+  SINT16   anlgEq;                      // AEQ settings (dB/MHz)
+  SINT16   rsvd;
+}DEV_HOST_diagAnlgOutputVar_t;
+
+
+// Bit field structure that allows the host to mask off interrupt sources for possible DSP-to-Host interrupts.
+// Each bit represents a possible source of interrupts in the DSP code that might cause a DSP-to-Host
+//   interrupt to occur.
+// This mask structure is not intended to show how interrupt sources in the DSP code correspond to the actual
+//   DSP-to-Host interrupts.  There could be multiple ways to cause an interrupt in the DSP code, but they all
+//   eventually tie into one of the three possible DSP-to-Host interrupts.
+// The host should write a "1" to an individual bit when it wants to mask possible interrupts from that source.
+
+// enum that represents individual bits in maskBitField1
+typedef enum
+{
+  ZERO_MASK1      = 0,   // dummy value for zero place-holder
+  DSP_MSG_BUF     = 0x1, // mask interrupts due to DSP-to-Host message mailbox updates
+  STATE_BIT_FIELD = 0x2, // mask interrupts due to changes in the modem state bit fields
+  DSP_HEARTBEAT   = 0x4  // mask interrupts for the DSP hearbeat
+} DEV_HOST_intMask1_t; // this enum should only have 32 values in it (maximum).
+
+// Add more "mask bit fields" at the end of this struct if you need more mask values
+typedef struct
+{
+  DEV_HOST_intMask1_t maskBitField1;
+} DEV_HOST_hostInterruptMask_t;  // this struct should only have 32 bits in it.
+
+// Bit field structure that allows the host to determine the source(s) of DSP-to-Host interrupts in case
+//   several of the interrupt sources get combined onto a single DSP-to-Host interrupt.
+// DSP will set each bit to a "1"as an interrupt occurs.
+// Host has the reponsibility to clear each bit to a "0" after it has determined the source(s) of interrupts.
+// Each source bit field in this struct will use the same enum typedef that matches the corresponding mask
+//   bit field in "DEV_HOST_hostInterruptMask_t"
+typedef struct
+{
+  DEV_HOST_intMask1_t sourceBitField1;
+} DEV_HOST_hostInterruptSource_t;
+
+
+// --------------------------
+// Begin bitswap definitions.
+// --------------------------
+
+// bitSwapSCnt contains the superframe to perform bit swap
+// The entries must be ordered so that the first group only contains bit change commands
+// The other entries may contain power adjustment instructions and must be
+// written with something.  NOP (0) is an available instruction.
+typedef struct
+{
+  PUINT8 fineGains_p;          // pointer to bng string, needed to check fine gains for powerswap
+  UINT8  bitSwapNewIndices[6]; // Bin before bitSwapBin to process
+  UINT8  bitSwapCmd[6];        // Bitswap command for bitSwapBin
+  UINT8  bitSwapBin[6];        // bin to modify
+  UINT8  bitSwapSCnt;          // Superframe count on which to perform bitswap
+  UINT8  bitSwapEnabled;       // bitSwapEnabled
+} DEV_HOST_dspBitSwapDef_t;
+
+
+// ---------------------------
+// Begin ATM BERT definitions.
+// ---------------------------
+
+// Structure used for ATM Idle Cells based bit error rate computation.
+typedef struct
+{
+  UINT8  atmBertFlag;      // Feature enable/disable flag (Host write)
+  UINT8  dummy1;
+  UINT8  dummy[2];         // Dummy bytes for 32-bit alignment
+  UINT32 bitCountLow;      // Low part of 64-bit BERT bit count (DSP write)
+  UINT32 bitCountHigh;     // High part of 64-bit BERT bit count (DSP write)
+  UINT32 bitErrorCountLow; // Low part of 64-bit BERT bit count (DSP write)
+  UINT32 bitErrorCountHigh;// High part of 64-bit BERT bit count (DSP write)
+} DEV_HOST_atmDsBert_t;
+
+
+// ------------------------------------
+// Misc. modem environment definitions.
+// ------------------------------------
+
+
+typedef struct
+{
+  SINT16 subStateIndex;        // Index that signifies datapump substate. (DSP write)
+  UINT8  externalBert;         // Turn on/off external BERT interface. 0 = OFF; 1 = ON. (Host write)
+  UINT8  usBertPattern;        // BERT pattern for US TX data. 0 = 2^15-1; 1 = 2^23-1. (Host write)
+  UINT8  overrideDslLinkLed_f; // Overrides DSP operation of the DSL_LINK LED. (Host write)
+                               //   0 = DSP is in control; 1 = Host is in control.
+  UINT8  dslLinkLedState_f;    // DSL_LINK LED state when override flag has been set. (Host write)
+                               //   DSL_LINK LED will be updated with this value once per frame.
+                               //   LED is active-low: 0 = ON, 1 = OFF.
+  UINT8  overrideDslActLed_f;  // Overrides DSP operation of the DSL_ACT LED. (Host write)
+                               //   0 = DSP is in control; 1 = Host is in control.
+  UINT8  dslActLedState_f;     // DSL_ACT LED state when override flag has been set. (Host write)
+                               //   DSL_ACT LED will be updated with this value once per frame.
+                               //   LED is active-low: 0 = ON, 1 = OFF.
+  UINT8  dGaspLprIndicator_f;  // How LPR signal (GPIO[0]) is to be interpreted. (Host write)
+                               //   0 = LPR is active-low; 1 = LPR is active-high.
+  UINT8  overrideDspLprGasp_f; // Overrides DSP detection of LPR signal to send out DGASP. (Host write)
+                               //   0 = DSP detects LPR; 1 = Host detects LPR and sends "HOST_DGASP" to DSP.
+  UINT8  pcbEnabled;           // DS power cut back
+  UINT8  maxAvgFineGainCtrl_f; // If maxAvgFineGainCtrl_f == 0, then the datapump controls the maximum average fine gain value.
+                               // If maxAvgFineGainCtrl_f == 1, then the host controls the maximum average fine gain value.
+  UINT32 reasonForDrop;        // This field will tell the host what might be the reason for a dropped connection.
+  SINT16 maxAverageFineGain;   // When maxAvgFineGainCtrl_f == 1, the value in maxAverageFineGain is the maximum average fine gain level in 256log2 units.
+  UINT8  reserved1;            // These are for 32-bit alignment.
+  UINT8  reserved2;            // These are for 32-bit alignment.
+} DEV_HOST_modemEnvPublic_t;
+
+
+// -----------------------------
+// Generic structure definition.
+// -----------------------------
+
+typedef struct
+{
+  PSINT8  parameter1_p;
+  PSINT16 parameter2_p;
+  PSINT32 parameter3_p;
+  PUINT8  parameter4_p;
+  PUINT16 parameter5_p;
+  PUINT32 parameter6_p;
+} DEV_HOST_genericStructure_t;
+
+
+// ------------------------------
+// Begin G.hs buffer definitions.
+// ------------------------------
+
+typedef struct
+{
+  UINT8 txBuf[64]; // G.hs xmt buffer
+} DEV_HOST_ghsDspTxBufDef_t;
+
+
+typedef struct
+{
+  UINT8 rxBuf[80]; // G.hs rcv buffer
+} DEV_HOST_ghsDspRxBufDef_t;
+
+// -----------------------------------------
+// Begin Constellation Display definitions.
+// -----------------------------------------
+
+typedef struct
+{
+  UINT32  consDispStartAddr;     // Host write
+  UINT32  consDispCurrentAddr;   // Host write
+  UINT32  consDispBufLen;        // Constellation Buffer Length
+  UINT32  consDispBin;           // Host write, DS band only
+} DEV_HOST_consBufDef_t;
+
+typedef struct
+{
+  PSINT16 buffer1_p;          //DSP write
+  PSINT16 buffer2_p;          //DSP write
+} DEV_HOST_snrBuffer_t;
+
+// --------------------------------------------------------------------------------------
+// Typedef to be used for the DEV_HOST_dspOamSharedInterface_s struct of pointers
+//  (this is used in dev_host_interface.c).
+// NOTE: This struct of pointers is NEVER to be referenced anywhere else in the DSP code.
+// IMPORTANT: Only pointers to other structs go into this struct !!
+// --------------------------------------------------------------------------------------
+typedef struct
+{
+  DEV_HOST_hostIntfcVersionDef_t   *hostIntfcVersion_p;
+  DEV_HOST_dspVersionDef_t         *datapumpVersion_p;
+  DEV_HOST_modemStateBitField_t    *modemStateBitField_p;
+  DEV_HOST_dspWrNegoParaDef_t      *dspWriteNegoParams_p;
+  DEV_HOST_oamWrNegoParaDef_t      *oamWriteNegoParams_p;
+  DEV_HOST_raMsgsDef_t             *raMsgs_p;
+  DEV_HOST_dspWrSuperFrameCntDef_t *dspWriteSuperFrameCnt_p;
+  DEV_HOST_msg_t                   *atucMsg_p;
+  DEV_HOST_msg_t                   *aturMsg_p;
+  DEV_HOST_dspWrSharedTables_t     *dspWrSharedTables_p;
+  DEV_HOST_olayDpDef_t             *olayDpParms_p;
+  DEV_HOST_eocVarDef_t             *eocVar_p;
+  DEV_HOST_clearEocVarDef_t        *clearEocVar_p;
+  DEV_HOST_modemStatsDef_t         *modemStats_p;
+  DEV_HOST_atmStats_t              *atmStats_p;
+  DEV_HOST_mailboxControl_t        *dspHostMailboxControl_p;
+  DEV_HOST_phyPerf_t               *phyPerf_p;
+  DEV_HOST_diagAnlgInputVar_t      *analogInputVar_p;
+  DEV_HOST_diagAnlgOutputVar_t     *analogOutputVar_p;
+  DEV_HOST_hostInterruptMask_t     *hostInterruptMask_p;
+  DEV_HOST_profileBase_t           *profileList_p;
+  DEV_HOST_hostInterruptSource_t   *hostInterruptSource_p;
+  DEV_HOST_dspBitSwapDef_t         *dspBitSwapDstrm_p;
+  DEV_HOST_dspBitSwapDef_t         *dspBitSwapUstrm_p;
+  DEV_HOST_atmDsBert_t             *atmDsBert_p;
+  DEV_HOST_modemEnvPublic_t        *modemEnvPublic_p;
+  DEV_HOST_genericStructure_t      *genericStructure1_p;
+  DEV_HOST_genericStructure_t      *genericStructure2_p;
+  DEV_HOST_ghsDspTxBufDef_t        *ghsDspTxBuf_p;
+  DEV_HOST_ghsDspRxBufDef_t        *ghsDspRxBuf_p;
+  DEV_HOST_consBufDef_t            *consDispVar_p;
+  DEV_HOST_snrBuffer_t             *snrBuffer_p;
+} DEV_HOST_dspOamSharedInterface_t;
+
+
+// ---------------------------------------------------------------------------------
+// Typedef to be used for the pointer to the DEV_HOST_dspOamSharedInterface_s struct
+//  of pointers (this is used in dev_host_interface.c).
+// ---------------------------------------------------------------------------------
+typedef DEV_HOST_dspOamSharedInterface_t *DEV_HOST_dspOamSharedInterfacePtr_t;
+
+#endif
diff -urN linux.old/drivers/atm/sangam_atm/dev_host_verdef.h linux.dev/drivers/atm/sangam_atm/dev_host_verdef.h
--- linux.old/drivers/atm/sangam_atm/dev_host_verdef.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/dev_host_verdef.h	2005-08-23 04:46:50.091844608 +0200
@@ -0,0 +1,102 @@
+#ifndef __DEV_HOST_VERDEF_H__
+#define __DEV_HOST_VERDEF_H__ 1
+
+//********************************************************************
+//*
+//*    DMT-BASE ADSL MODEM PROGRAM
+//*    TEXAS INSTRUMENTS PROPRIETARTY INFORMATION
+//*    AMATI CONFIDENTIAL PROPRIETARY
+//*
+//* (c) Copyright April 1999, Texas Instruments Incorporated.
+//*     All Rights Reserved.
+//*
+//*   Property of Texas Instruments Incorporated and Amati Communications Corp.
+//*
+//* Restricted Rights - Use, duplication, or disclosure is subject to
+//* restrictions set forth in TI's and Amati program license agreement and
+//* associated documentation
+//*
+//*********************************************************************
+//*
+//* FILENAME: dev_host_verdef.h
+//*
+//* ABSTRACT: This file defines the version structure
+//*
+//* TARGET:  Non specific.
+//*
+//* TOOLSET:  Non specific.
+//*
+//* ACTIVATION:
+//*
+//* HISTORY:  DATE        AUTHOR   DESCRIPTION
+//*           04/29/99    FLW      Created
+//*           01/17/00    Barnett  Mod's in support of merging NIC
+//*                                hardware rev 6/7 T1.413 codebases.
+//*           01/21/00    Wagner   derfmake mods
+//*           05/11/00    Barnett  hardware_rev is a 2 char string.
+//*           07/24/00    Barnett  Rework as part of host interface redesign.
+//*           11/29/00    Hunt     added chipset_id2
+//*           03/30/01    Barnett  Prefixed all public elements with DSPDP_.
+//*                                This insures uniqueness of names that might
+//*                                match host names by coincidence.
+//*           03/30/01    Barnett  Added DSPDP_Host_VersionDef to facilitate
+//*                                representing a version id for the host i/f
+//*                                separate from the firmware version id as
+//*                                a courtesy to the host.
+//*           07/23/01    JEB      Changed name from verdef_u.h to dpsys_verdef.h
+//*           04/12/02    Barnett  Make timestamp unsigned 32-bit field.
+//*                                Generalizes for all kinds of hosts.
+//*           11/15/02    JEB      Changed name from dpsys_verdef.h to dev_host_verdef.h
+//*                                Updated structs according to coding guidelines
+//*           12/16/02    JEB      Renamed some struct elements for new usage in Ax7
+//*           01/21/03    MCB      Implemented Ax7 UNIT-MODULE modular software framework.
+//*           03/19/03    JEB      Added back in "bugFix" elements into each struct type.
+//*                                Rearranged elements.
+//*
+//********************************************************************
+
+#include "env_def_typedefs.h"
+
+#define DSPDP_FLAVOR_NEWCODES 0xFF // Other values are valid old-style flavors
+
+// ------------------------------
+// ------------------------------
+// Begin DSP version definitions.
+// ------------------------------
+// ------------------------------
+
+typedef struct
+{
+  UINT32 timestamp;    // Number of seconds since 01/01/1970
+  UINT8  major;        // Major "00".00.00.00 revision nomenclature
+  UINT8  minor;        // Minor 00."00".00.00 revision nomenclature
+  UINT8  bugFix;       // Bug Fix 00.00."00".00 revision nomenclature
+  UINT8  buildNum;     // Build Number 00.00.00."00" revision nomenclature
+  UINT8  netService;   // Network service identifier
+  UINT8  chipsetGen;   // chipset generation
+  UINT8  chipsetId;    // chipset identifier
+  UINT8  chipsetId2;   // second byte for "RV" chipset et al.
+  UINT8  hardwareRev1; // hardware revision, 1st char
+  UINT8  hardwareRev2; // hardware revision, 2nd char
+  UINT8  featureCode;  // feature code
+  UINT8  dummy1;       // dummy byte for explicit 32-bit alignment
+} DEV_HOST_dspVersionDef_t;
+
+// -------------------------------
+// -------------------------------
+// Begin host version definitions.
+// -------------------------------
+// -------------------------------
+
+typedef struct
+{
+  UINT8 major;        // Major "00".00.00.00 revision nomenclature
+  UINT8 minor;        // Minor 00."00".00.00 revision nomenclature
+  UINT8 bugFix;       // Bug Fix 00.00."00".00 revision nomenclature
+  UINT8 buildNum;     // Build Number 00.00.00."00" revision nomenclature
+  UINT8 netService;   // Network service identifier
+  UINT8 dummy[3];     // dummy bytes for explicit 32-bit alignment
+} DEV_HOST_hostIntfcVersionDef_t;
+
+
+#endif // __DEV_HOST_VERDEF_H__
diff -urN linux.old/drivers/atm/sangam_atm/dsl_hal_api.c linux.dev/drivers/atm/sangam_atm/dsl_hal_api.c
--- linux.old/drivers/atm/sangam_atm/dsl_hal_api.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/dsl_hal_api.c	2005-08-23 04:46:50.095844000 +0200
@@ -0,0 +1,3339 @@
+/*******************************************************************************
+* FILE PURPOSE:     DSL Driver API functions for Sangam
+*
+********************************************************************************
+* FILE NAME:        dsl_hal_basicapi.c
+*
+* DESCRIPTION:  
+*       Contains basic DSL HAL APIs for Sangam
+*  
+*                    
+* (C) Copyright 2001-02, Texas Instruments, Inc.
+*    History
+*    Date        Version            Notes
+*    06Feb03     0.00.00            RamP   Original Version Created
+*    10Mar03     0.00.01            RamP   Initial Revision for Modular Code Branch
+*    19Mar03     0.00.02            RamP   Fixed DSL and DSP Version API Structures
+*    20Mar03     0.00.03            RamP   Changed byteswap function names
+*    21Mar03     0.00.03         RamP/ZT   Malloc for DSP f/w done in dslStartup
+*    25Mar03     0.00.04            RamP   Removed statistics used only by SWTC
+*                                          Created Checkpoint 3
+*    26Mar03     0.00.05            RamP   Added Memory allocation for fwimage in
+*                                          dslStartup function.
+*    07Apr03     0.00.06            RamP   Implemented new error reporting scheme
+*                                          Changed Commenting to C style only
+*    09Apr03     0.00.07            RamP   Reorganized code to delete POST_SILICON
+*    10Apr03     0.00.08            RamP   Removed ptidsl from loadFWImage function
+*                                          moved size and fwimage initialization to
+*                                          dslStartup function
+*    14Apr03     0.00.09            RamP   Moved modemStateBitField processing to a
+*                                          support function; deleted stateHistory
+*                                          renamed the REG32 macro
+*    15Apr03     0.00.10            RamP   Changed firmware allocate to shim_ 
+*                                          osAllocateVMemory function
+*    15Apr03     0.00.11            RamP   Changed host version number to 07.00.00.01
+*    16Apr03     0.00.12            RamP   Modified return condition on dslShutdown
+*    16Apr03     0.00.13            RamP   Changed host version number to 07.00.00.02
+*    21Apr03     0.01.00            RamP   Cleaned up dslShutdown function
+*                                          Added new function calls to allocate
+*                (Alpha)                   /free overlay pages for different OS
+*                                          Fixed typecasting for allocate/free fxns
+*                                          Added Interrupt Acknowledge logic
+*    22Apr03     0.01.01            RamP   Moved acknowledgeInterrupt into api
+*                                          Added static global for intr source
+*    24Apr03     0.01.02            RamP   Added processing for OVERLAY_END in
+*                                          DSP message handlers, verified crc32
+*                                          recovery for overlays
+*    28Apr03     0.01.03            RamP   Removed global variable intrSource
+*                                          Added parameter to handleInterrupt fxn
+*                (Alpha Plus)              to indicate interrupt source
+*                                          Changed version number to 01.00.01.00    
+*                                          Fixed setTrainingMode function problem 
+*    07May03     0.01.04            RamP   Removed delineation state check in 
+*                                          message handling functions, added more
+*                                          safety for setting lConnected in TC_SYNC
+*                                          Changed version number to 01.00.01.01                                      
+*    14May03     0.01.05            RamP   Added 3 Switchable Hybrid APIs
+*                                          Added additional statistics us/ds TxPower,
+*                                          us margin,attenuation, us/ds bitallocation
+*                                          moved versioning to dsl_hal_version.h
+*    14May03     0.01.06            RamP   Fixed problem with CMsgs2 parsing
+*    20May03     0.01.07            RamP   Added Inner/Outer pair API support. Added
+*                                          dying gasp message.
+*    29May03     0.01.08         ZT/RamP   Added memory optimizations for overlay pages
+*                                          and coProfiles; added functions to free,
+*                                          reload overlays and profiles
+*    04Jun03     0.01.09            RamP   Added tick counters, fail states reporting
+*                                          Made statistics fixes for higher data rates
+*                                          Added Margin per tone to statistics
+*                                          Added configuration checks for trellis/FEC
+*    06Jun03     0.01.10            RamP   Added LED, STM Bert, dGasp LPR Config APIs
+*                                          Modified interrupt acknowledge logic 
+*                                          Added current hybrid flag as statistic
+*    09Jun03     0.01.11            RamP   Added function to send dying Gasp to Modem
+*                                          fixed problem with reading OamNegoPara var
+*                (Beta)                    fixed problem with reading current config
+*                                          Added function to configure ATM Bert
+*                                          fixed memory leak due to coProfiles
+*                                          Added us/ds R/S FEC statistics
+*                                          Added additional config capability for LED
+*                                          fixed problem in free memory for CO profiles
+*    18Jul03     0.01.12            RamP   Fixed problem with reading modemEnv structure
+*                                          affects LED, DGaspLpr APIs   
+*                                          Sending Dying Gasp from shutdown function
+*    01Aug03     0.01.13            RamP   Added preferred training mode to statistics
+*    13Aug03     0.01.14            MCB    Set rev id for D3/R1.1 (ADSL2).
+*    21Aug03     0.01.15            RamP   Added g.hs and aoc bitswap message gathering
+*                                          Added new references to bits n gains table
+*                                          Decoupled modem idle/retrain from pair select 
+*                                          Added line length and gross gain to statistics 
+*    29Sep03     0.01.16            RamP   Replaced advcfg function calls with support
+*                                          module function switches
+*    01Oct03     0.01.17            RamP   Added enum translation to set training mode
+*                                          & to read statistics
+*    08Oct03     0.01.18            RamP   Fixed problems with usTxPower statistic in 
+*                                          Annex B target, fixed problem with Trellis
+*    12Oct03     0.01.19            RamP   Added API calls to gather ADSL2 Messages
+*    29Oct03     0.01.20            RamP   Restored TC_SYNC detect logic
+*    30Oct03     0.01.21            RamP   Removed Scaling factor for adsl2DSConRate
+*                                          Setting Showtime state upon DSP_ACTIVE
+*    14Nov03     0.01.22            RamP   Fixed scaling for usTxPower & dsTxPower
+*    14Nov03     0.01.23            RamP   Added logic to gather CRates1/RRates1
+*                                          by parsing DSP_CRATES1
+*    20Nov03     0.01.24            RamP   Added generic & interface Read
+*                                          and Write functions to read from 
+*                                          DSP - Host Interface
+*    24Nov03     0.01.25            RamP   Modified interface Read/Write functions
+*                                          to seperate element offsets from pointers
+*    19Dec03     0.01.26            RamP   Modified pointer accessing problems with
+*                                          block read functions
+*    26Dec03     0.01.27            RamP   Made ghsIndex a local variable & added 
+*                                          check to avoid buffer overflow     
+*    30Dec03     0.01.28            RamP   Added generic mailbox command function
+*******************************************************************************/
+#include "dsl_hal_register.h"
+#include "dsl_hal_support.h"
+#include "dsl_hal_logtable.h"
+#include "dsl_hal_version.h"
+
+static unsigned int hybrid_selected;
+static unsigned int showtimeFlag = FALSE;
+
+#ifdef PRE_SILICON
+/*********************************************/
+/*   Base Addresses                          */
+/*********************************************/
+#define DEV_MDMA_BASE                 0x02000500
+
+/*********************************************/
+/*   MC DMA Control Registers in DSL         */
+/*********************************************/
+
+#define DEV_MDMA0_SRC_ADDR         (DEV_MDMA_BASE + 0x00000000)
+#define DEV_MDMA0_DST_ADDR         (DEV_MDMA_BASE + 0x00000004)
+#define DEV_MDMA0_CTL_ADDR         (DEV_MDMA_BASE + 0x00000008)
+#define DEV_MDMA1_SRC_ADDR         (DEV_MDMA_BASE + 0x00000040)
+#define DEV_MDMA1_DST_ADDR         (DEV_MDMA_BASE + 0x00000044)
+#define DEV_MDMA1_CTL_ADDR         (DEV_MDMA_BASE + 0x00000048)
+#define DEV_MDMA2_SRC_ADDR         (DEV_MDMA_BASE + 0x00000080)
+#define DEV_MDMA2_DST_ADDR         (DEV_MDMA_BASE + 0x00000084)
+#define DEV_MDMA2_CTL_ADDR         (DEV_MDMA_BASE + 0x00000088)
+#define DEV_MDMA3_SRC_ADDR         (DEV_MDMA_BASE + 0x000000C0)
+#define DEV_MDMA3_DST_ADDR         (DEV_MDMA_BASE + 0x000000C4)
+#define DEV_MDMA3_CTL_ADDR         (DEV_MDMA_BASE + 0x000000C8)
+
+#define DEV_MDMA0_SRC           (*((volatile UINT32 *) DEV_MDMA0_SRC_ADDR))
+#define DEV_MDMA0_DST           (*((volatile UINT32 *) DEV_MDMA0_DST_ADDR))
+#define DEV_MDMA0_CTL           (*((volatile UINT32 *) DEV_MDMA0_CTL_ADDR))
+#define DEV_MDMA1_SRC           (*((volatile UINT32 *) DEV_MDMA1_SRC_ADDR))
+#define DEV_MDMA1_DST           (*((volatile UINT32 *) DEV_MDMA1_DST_ADDR))
+#define DEV_MDMA1_CTL           (*((volatile UINT32 *) DEV_MDMA1_CTL_ADDR))
+#define DEV_MDMA2_SRC           (*((volatile UINT32 *) DEV_MDMA2_SRC_ADDR))
+#define DEV_MDMA2_DST           (*((volatile UINT32 *) DEV_MDMA2_DST_ADDR))
+#define DEV_MDMA2_CTL           (*((volatile UINT32 *) DEV_MDMA2_CTL_ADDR))
+#define DEV_MDMA3_SRC           (*((volatile UINT32 *) DEV_MDMA3_SRC_ADDR))
+#define DEV_MDMA3_DST           (*((volatile UINT32 *) DEV_MDMA3_DST_ADDR))
+#define DEV_MDMA3_CTL           (*((volatile UINT32 *) DEV_MDMA3_CTL_ADDR))
+
+/* MDMA control bits                     */
+
+#define DEV_MDMA_START             0x80000000
+#define DEV_MDMA_STOP              0x00000000
+#define DEV_MDMA_STATUS            0x40000000
+#define DEV_MDMA_DST_INC           0x00000000
+#define DEV_MDMA_DST_FIX           0x02000000   
+#define DEV_MDMA_SRC_INC           0x00000000
+#define DEV_MDMA_SRC_FIX           0x00800000 
+#define DEV_MDMA_BURST1            0x00000000
+#define DEV_MDMA_BURST2            0x00100000
+#define DEV_MDMA_BURST4            0x00200000 
+
+#define DEV_MDMA_LEN_SHF           2
+#define DEV_MDMA_LEN_MASK          0x0000FFFF
+
+#define DMA0   0
+#define DMA1   1
+#define DMA2   2
+#define DMA3   3
+#endif
+#ifdef DMA
+SINT32 getDmaStatus(UINT32 mask)
+{
+  if(!(IFR & mask))
+  {
+   return DSLHAL_ERROR_NO_ERRORS;
+  }
+  else
+  {
+   ICR = mask ;
+   return 1 ;
+  }
+}
+
+void programMdma(UINT32 dma, UINT32 source, UINT32 destination, UINT32 length, UINT32 wait)
+{
+  volatile UINT32 statusMask ;
+
+  switch(dma)
+  {
+  case DMA0:
+    {
+      DEV_MDMA0_SRC = source ;
+      DEV_MDMA0_DST = destination ;
+      DEV_MDMA0_CTL = (DEV_MDMA_START | DEV_MDMA_DST_INC | DEV_MDMA_SRC_INC |
+                       DEV_MDMA_BURST1 | (length << DEV_MDMA_LEN_SHF)) ;
+      statusMask = 0x00000010 ;
+    }
+    break ;
+  case DMA1:
+    {
+          DEV_MDMA1_SRC = source ;
+          DEV_MDMA1_DST = destination ;
+          DEV_MDMA1_CTL = (DEV_MDMA_START | DEV_MDMA_DST_INC | DEV_MDMA_SRC_INC |
+                           DEV_MDMA_BURST1 | (length << DEV_MDMA_LEN_SHF)) ;
+          statusMask = 0x00000020 ;
+        }
+    break ;
+  case DMA2:
+    {
+          DEV_MDMA2_SRC = source ;
+          DEV_MDMA2_DST = destination ;
+          DEV_MDMA2_CTL = (DEV_MDMA_START | DEV_MDMA_DST_INC | DEV_MDMA_SRC_INC |
+                           DEV_MDMA_BURST1 | (length << DEV_MDMA_LEN_SHF)) ;
+          statusMask = 0x00000040 ;
+        }
+    break ;
+  case DMA3:
+    {
+          DEV_MDMA3_SRC = source ;
+          DEV_MDMA3_DST = destination ;
+          DEV_MDMA3_CTL = (DEV_MDMA_START | DEV_MDMA_DST_INC | DEV_MDMA_SRC_INC |
+                           DEV_MDMA_BURST1 | (length << DEV_MDMA_LEN_SHF)) ;
+          statusMask = 0x00000080 ;
+        }
+    break ;
+
+  }
+
+  if(wait)
+  {
+    while(!(getDmaStatus(statusMask))) ;
+  }
+
+}
+#endif
+
+
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_dslStartup
+*
+*******************************************************************************************
+* DESCRIPTION: Entry point to initialize and load ax5 daughter board
+*
+* INPUT:   PITIDSLHW_T *ppIHw  
+*
+* RETURN:  0 --succeeded
+*          1 --Failed
+*
+*****************************************************************************************/
+
+int dslhal_api_dslStartup(PITIDSLHW_T *ppIHw)
+{
+  
+  ITIDSLHW_T *ptidsl;
+  int  i;
+  int rc;
+  dprintf(4,"dslhal_api_dslStartup() NEW 1\n");
+  
+  ptidsl=(ITIDSLHW_T *)shim_osAllocateMemory(sizeof(ITIDSLHW_T));
+  if(ptidsl==NULL)
+    {
+    dprintf(1, "unable to allocate memory for ptidsl\n");
+    return 1;
+    }
+  *ppIHw=ptidsl;
+  shim_osZeroMemory((char *) ptidsl, sizeof(ITIDSLHW_T));
+
+  /* Unreset the ADSL Subsystem  */
+  rc=dslhal_support_unresetDslSubsystem();
+  if(rc)
+    {
+    dprintf(1, "unable to reset ADSL Subsystem \n");
+    shim_osFreeMemory((void *) ptidsl, sizeof(ITIDSLHW_T));
+    return DSLHAL_ERROR_UNRESET_ADSLSS;
+    }
+  ptidsl->fwimage = shim_osAllocateVMemory(DSP_FIRMWARE_MALLOC_SIZE);
+  if(!ptidsl->fwimage)
+    {
+      dprintf(1,"Failed to Allocate Memory for DSP firmware binary \n");
+      return DSLHAL_ERROR_FIRMWARE_MALLOC;
+    }
+  /* read firmware file from flash   */
+  rc=shim_osLoadFWImage(ptidsl->fwimage);
+  if(rc<0)
+    {
+    dprintf(1, "unable to get fw image\n");
+    shim_osFreeVMemory((void *)ptidsl->fwimage,DSP_FIRMWARE_MALLOC_SIZE);
+    shim_osFreeMemory((void *) ptidsl, sizeof(ITIDSLHW_T));
+    return DSLHAL_ERROR_NO_FIRMWARE_IMAGE;
+    }
+  else
+    {
+      ptidsl->imagesize = rc;
+     }
+  /* Compute the CRC checksum on the image and validate the image */
+
+  /* Validate the image in the RAM */
+
+  /* load fw to DSP  */
+ 
+  if(dslhal_support_hostDspCodeDownload(ptidsl))
+    {
+    dprintf(0,"dsp load error\n");
+    for(i=0; i<NUM_PAGES; i++)
+      {
+      if(ptidsl->olayDpPage[i].PmemStartWtAddr !=NULL)
+        {
+        shim_osFreeDmaMemory((void *) ptidsl->olayDpPage[i].PmemStartWtAddr, 
+                     ptidsl->olayDpPage[i].OverlayXferCount);
+        }
+      }
+     if(ptidsl->coProfiles.PmemStartWtAddr != NULL)
+      shim_osFreeDmaMemory((void *)ptidsl->coProfiles.PmemStartWtAddr, ptidsl->coProfiles.OverlayXferCount);
+     if(ptidsl->constDisplay.PmemStartWtAddr != NULL)
+      shim_osFreeDmaMemory((void *)ptidsl->constDisplay.PmemStartWtAddr, ptidsl->constDisplay.OverlayXferCount);
+    shim_osFreeVMemory((void *)ptidsl->fwimage,DSP_FIRMWARE_MALLOC_SIZE);
+    shim_osFreeMemory((void *) ptidsl, sizeof(ITIDSLHW_T));
+    return DSLHAL_ERROR_CODE_DOWNLOAD;
+    }
+  
+  /* set flag to indicated overlay pages are loaded */
+  ptidsl->bOverlayPageLoaded = 1;
+  /* set auto retrain to 1 to disble the overlay page reload */
+  ptidsl->bAutoRetrain = 1;
+
+  /* unreset Raptor */
+  /* change this to new function */ 
+  /* This function should basically bring DSP out of reset bit 23  of PRCR */
+  /* Function is ready but bypassed for Pre-Silicon */
+   
+  rc=dslhal_support_unresetDsp();
+  if (rc)
+    {
+    dprintf(0,"unable to bring DSP out of Reset\n");
+    for(i=0; i<NUM_PAGES; i++)
+      {
+      if(ptidsl->olayDpPage[i].PmemStartWtAddr !=NULL)
+        {
+        shim_osFreeDmaMemory((void *) ptidsl->olayDpPage[i].PmemStartWtAddr, 
+                     ptidsl->olayDpPage[i].OverlayXferCount);
+        }
+      }
+    if(ptidsl->coProfiles.PmemStartWtAddr != NULL)
+      shim_osFreeDmaMemory((void *)ptidsl->coProfiles.PmemStartWtAddr, ptidsl->coProfiles.OverlayXferCount);
+     if(ptidsl->constDisplay.PmemStartWtAddr != NULL)
+      shim_osFreeDmaMemory((void *)ptidsl->constDisplay.PmemStartWtAddr, ptidsl->constDisplay.OverlayXferCount);
+    shim_osFreeVMemory((void *)ptidsl->fwimage,DSP_FIRMWARE_MALLOC_SIZE);
+    shim_osFreeMemory((void *) ptidsl, sizeof(ITIDSLHW_T));
+    return DSLHAL_ERROR_UNRESET_DSP;
+    }
+  shim_osFreeVMemory((void *)ptidsl->fwimage,DSP_FIRMWARE_MALLOC_SIZE);
+  dprintf(4,"dslhal_api_dslStartup() done\n");
+
+  /* Add the code to initialize the host interface variables */
+  /* Add code to tickle the host interface */
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+
+/******************************************************************************************
+ * FUNCTION NAME:    dslhal_api_dslShutdown
+ *
+ *******************************************************************************************
+ * DESCRIPTION: routine to shutdown ax5 modem and free the resource
+ *
+ * INPUT:   tidsl_t *ptidsl  
+ *
+ * RETURN:  NULL
+ *          
+ *
+ *****************************************************************************************/
+
+int dslhal_api_dslShutdown(tidsl_t *ptidsl)
+{
+  int rc= DSLHAL_ERROR_NO_ERRORS;
+  int i;
+  
+  dprintf(5, "dslhal_api_dslShutdown\n");
+  rc = dslhal_support_writeHostMailbox(ptidsl, HOST_DSLSS_SHUTDOWN, 0, 0, 0);  
+  if(rc)
+    {
+     dprintf(1, " unable to reset DSP \n");
+     rc = DSLHAL_ERROR_RESET_DSP;
+    }
+  /* DSP need 50 ms to send out the message*/
+
+  shim_osClockWait(60 * 1000);
+
+  rc = dslhal_support_writeHostMailbox(ptidsl, HOST_DGASP, 0, 0, 0);
+  
+  /* free memory allocated*/
+
+  for(i=0; i<NUM_PAGES; i++)
+    {
+    if(ptidsl->olayDpPage[i].PmemStartWtAddr !=NULL)
+      {
+      shim_osFreeDmaMemory((void *) ptidsl->olayDpPage[i].PmemStartWtAddr, 
+                   ptidsl->olayDpPage[i].OverlayXferCount);
+      }
+    }
+  if(ptidsl->coProfiles.PmemStartWtAddr != NULL)
+     shim_osFreeDmaMemory((void *)ptidsl->coProfiles.PmemStartWtAddr, ptidsl->coProfiles.OverlayXferCount);
+  if(ptidsl->constDisplay.PmemStartWtAddr != NULL)
+     shim_osFreeDmaMemory((void *)ptidsl->constDisplay.PmemStartWtAddr, ptidsl->constDisplay.OverlayXferCount);
+  shim_osFreeMemory((void *)ptidsl, sizeof(tidsl_t));  
+  rc = dslhal_support_resetDsp();
+  if(rc)
+    {
+     dprintf(1, " unable to reset ADSL subsystem \n");
+     rc = DSLHAL_ERROR_RESET_DSP;
+    }
+  rc = dslhal_support_resetDslSubsystem();
+  if(rc)
+    {
+     dprintf(1, " unable to reset ADSL subsystem \n");
+     rc = DSLHAL_ERROR_RESET_ADSLSS;
+    }
+return rc; 
+}
+  
+ 
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_getDslHalVersion
+*
+*******************************************************************************************
+* DESCRIPTION: This routine supply DSL Driver version.
+*
+* INPUT:  tidsl_t * ptidsl
+*         void *pVer, DSP Driver Version Pointer
+*         
+* RETURN:  0 --succeeded
+*          1 --Failed
+* Note: See verdef_u.h for version structure definition.
+*****************************************************************************************/
+
+void dslhal_api_getDslHalVersion(void  *pVer)
+{
+  dslVer *pVersion;
+  pVersion = (dslVer *)pVer;
+  pVersion->major = (unsigned char) DSLHAL_VERSION_MAJOR;
+  pVersion->minor = (unsigned char) DSLHAL_VERSION_MINOR;
+  pVersion->bugfix = (unsigned char) DSLHAL_VERSION_BUGFIX;
+  pVersion->buildNum = (unsigned char) DSLHAL_VERSION_BUILDNUM;
+  pVersion->timeStamp = (unsigned char) DSLHAL_VERSION_TIMESTAMP;  
+}
+  
+/********************************************************************************************
+ * FUNCTION NAME: dslhal_api_pollTrainingStatus()
+ *
+ *********************************************************************************************
+ * DESCRIPTION: code to decode modem status and to start modem training 
+ * Input: tidsl_t *ptidsl
+ * 
+ * Return: modem status   
+ *         -1    failed
+ *
+ ********************************************************************************************/
+
+int dslhal_api_pollTrainingStatus(tidsl_t *ptidsl)
+{
+  int cmd;
+  int tag;
+  int parm1,parm2;
+  int rc;
+  unsigned int failState;
+  static unsigned int pollGhsIndex=0;
+
+  /*char *tmp;*/
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+#if SWTC
+  DEV_HOST_tcHostCommDef_t          TCHostCommDef;
+#endif
+  
+  dprintf(5,"dslhal_api_pollTrainingStatus\n");
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterface_t *) ptidsl->pmainAddr;
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface, 
+                                     sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+#if SWTC
+  dspOamSharedInterface.tcHostComm_p =(DEV_HOST_tcHostCommDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.tcHostComm_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.tcHostComm_p, 
+                                    &TCHostCommDef, sizeof(DEV_HOST_tcHostCommDef_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+#endif
+  
+  rc = dslhal_support_processTrainingState(ptidsl);
+  if(rc)
+    {
+      dprintf(0,"Error Reading Modem Training State \n");
+      return DSLHAL_ERROR_MODEMSTATE;
+    }
+  rc = dslhal_support_processModemStateBitField(ptidsl);
+  if(rc)
+    {
+      dprintf(0,"Error Reading Modem Training State \n");
+      return DSLHAL_ERROR_MODEMSTATE;
+    }
+  /*
+  rc = dslhal_support_readDelineationState(ptidsl);
+  if(rc)
+    {
+      dprintf(0,"Error Reading Delineation State \n");
+      return DSLHAL_ERROR_MODEMSTATE;
+    }
+  */
+  while (dslhal_support_readDspMailbox(ptidsl,&cmd, &tag, &parm1, &parm2) == DSLHAL_ERROR_NO_ERRORS )
+    {
+    dprintf(4,"mailbox message: 0x%x\n", cmd);
+    /*    
+    for(rc=0;rc<8;rc++)
+      {
+        dslhal_support_readTextMailbox(ptidsl,&msg1, &msg2);
+      }
+    */ 
+
+    if (cmd == DSP_IDLE) 
+      {
+      dprintf(4,"DSP_IDLE\n");
+      ptidsl->lConnected=0; 
+      hybrid_selected=888;
+      /* add code for reload overlay pages */
+      if(ptidsl->bAutoRetrain == 0)
+       {
+         while(ptidsl->bOverlayPageLoaded == 0)
+         {
+           shim_osClockWait(6400);
+         }
+         //dslhal_support_restoreTrainingInfo(ptidsl);
+         //ptidsl->bOverlayPageLoaded = 1;
+       }
+      /* command DSP to ACTREQ */
+      if(showtimeFlag == TRUE)
+        {
+           dslhal_api_resetTrainFailureLog(ptidsl);
+           dslhal_support_advancedIdleProcessing(ptidsl);
+           showtimeFlag = FALSE;
+        }
+      failState = (unsigned int)parm1;
+      if(failState!=0)
+        {
+          ptidsl->AppData.trainFailStates[ptidsl->AppData.trainFails]=failState;
+          ptidsl->AppData.trainFails++;
+          if(ptidsl->AppData.trainFails > 30)
+             ptidsl->AppData.trainFails=0;
+        }
+      for(pollGhsIndex=0;pollGhsIndex<10;pollGhsIndex++)
+        {
+          for(rc=0;rc<62;rc++)
+            ptidsl->AppData.dsl_ghsRxBuf[pollGhsIndex][rc]=0;
+        }  
+      pollGhsIndex=0;
+      rc = dslhal_support_writeHostMailbox(ptidsl,HOST_ACTREQ, 0, 0, 0);
+      if (rc)
+        return DSLHAL_ERROR_MAILBOX_WRITE;
+      }
+
+    if(cmd == DSP_ATM_TC_SYNC)
+      {
+      dprintf(4,"\nTC_SYNC\n");
+      showtimeFlag = TRUE;
+      ptidsl->lConnected=1; 
+      if(ptidsl->bAutoRetrain == 0 && ptidsl->bOverlayPageLoaded == 1)
+       {
+         dslhal_support_clearTrainingInfo(ptidsl);
+         ptidsl->bOverlayPageLoaded = 0;
+        }
+      }
+    if(cmd == DSP_ACTIVE)
+      {
+      dprintf(4,"DSP_ACTIVE");
+      ptidsl->lConnected=0;
+      ptidsl->AppData.bState = RSTATE_SHOWTIME;
+      dprintf(4,"US Connect Rate: %u \n",ptidsl->AppData.USConRate);
+      dprintf(4,"DS Connect Rate: %u \n",ptidsl->AppData.DSConRate);
+      }
+    if(cmd == DSP_ATM_NO_TC_SYNC)
+      {
+      dprintf(4,"\nTC_NOSYNC\n");
+      ptidsl->lConnected=0; 
+      }
+    if(cmd == DSP_DGASP)
+      {
+      dprintf(0,"\n GASP!!! \n");
+      }          
+    if(cmd == DSP_OVERLAY_END)
+       {
+         dprintf(4,"Overlay Page Done %d \n",tag);
+         rc = dslhal_support_checkOverlayPage(ptidsl,tag);
+         if(rc == DSLHAL_ERROR_OVERLAY_CORRUPTED)
+          {
+            dprintf(0,"Overlay Page: %d CORRUPTED \n",tag);
+            return (0-DSLHAL_ERROR_OVERLAY_CORRUPTED);
+          }
+        }   
+    if(cmd == DSP_HYBRID)
+       {
+         dprintf(2,"Hybrid Metrics Available: %d\n",tag);
+         hybrid_selected = tag;
+       }
+    if(cmd == DSP_DGASP)
+      {
+      dprintf(0,"\n GASP!!! \n");
+      }   
+    if(cmd == DSP_XMITBITSWAP)
+      {
+       dslhal_support_aocBitSwapProcessing(ptidsl,0);
+      }
+    if(cmd == DSP_RCVBITSWAP)
+      {
+       dslhal_support_aocBitSwapProcessing(ptidsl,1);
+      }
+    if(cmd == DSP_GHSMSG)
+      {
+       dprintf(3,"Ghs Message Received, bytes: %d \n",tag);
+       dprintf(3,"Addr: 0x%x\n",dspOamSharedInterface.ghsDspRxBuf_p);
+       if(pollGhsIndex > 9)
+           pollGhsIndex=0;
+       rc = dslhal_support_blockRead((void *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.ghsDspRxBuf_p), &ptidsl->AppData.dsl_ghsRxBuf[pollGhsIndex++][0], tag);
+      }
+    if(cmd == DSP_CRATES1)
+      {
+       dprintf(3,"DSP C-Rates1 Data Ready \n");
+       rc = dslhal_support_gatherRateMessages(ptidsl);
+      }
+    if(cmd == DSP_SNR)
+      {
+       dprintf(3,"DSP SNR Data Ready \n");
+       rc = dslhal_support_gatherSnrPerBin(ptidsl,tag);
+      }
+    if(cmd == DSP_EOC)
+      {
+       dprintf(3,"DSP_EOC message \n"); 
+       rc = dslhal_support_gatherEocMessages(ptidsl,tag,parm1,parm2);
+      }
+    
+    if(cmd == DSP_TRAINING_MSGS)
+      {
+       dprintf(3,"DSP_TRAINING_MSGS \n"); 
+       rc = dslhal_support_gatherAdsl2Messages(ptidsl,tag,parm1,parm2);
+      }
+    }
+  dprintf(6,"dslhal_api_pollTrainingStatus done\n");
+  return(ptidsl->AppData.bState);
+  
+}  /* end of dslhal_api_pollTrainingStatus() */
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_handleTrainingInterrupt()
+*
+*********************************************************************************************
+* DESCRIPTION: Code to handle ax5 hardware interrupts
+*
+* Input: tidsl_t *ptidsl
+*        int *pMsg, pointer to returned hardware messages. Each byte represent a messge
+*        int *pTag, pointer to returned hardware message tags. Each byte represent a tag.
+* Return: 0    success  
+*         1    failed
+*
+********************************************************************************************/
+int dslhal_api_handleTrainingInterrupt(tidsl_t *ptidsl, int intrSource)
+{
+  int cmd;
+  int tag;
+  int parm1,parm2;
+  unsigned int msg1;
+  unsigned int msg2;
+  int rc;
+  unsigned int failState;
+  static unsigned int interruptGhsIndex=0;
+    /*char *tmp;*/
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+#if SWTC
+  DEV_HOST_tcHostCommDef_t          TCHostCommDef;
+#endif
+  dprintf(6,"dslhal_api_handleTrainingInterrupt\n");
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterface_t *) ptidsl->pmainAddr;
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface, 
+                                     sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+#if SWTC
+  dspOamSharedInterface.tcHostComm_p =(DEV_HOST_tcHostCommDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.tcHostComm_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.tcHostComm_p, 
+                                    &TCHostCommDef, sizeof(DEV_HOST_tcHostCommDef_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+#endif
+  
+  if(intrSource & MASK_BITFIELD_INTERRUPTS)
+    {
+      dspOamSharedInterface.modemStateBitField_p =(DEV_HOST_modemStateBitField_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.modemStateBitField_p);
+      rc = dslhal_support_processTrainingState(ptidsl);
+      if(rc)
+       {
+        dprintf(0,"Error Reading Modem Training State \n");
+        return DSLHAL_ERROR_MODEMSTATE;
+        }
+       rc = dslhal_support_processModemStateBitField(ptidsl);
+       if(rc)
+       {
+        dprintf(0,"Error Reading Modem Training State \n");
+        return DSLHAL_ERROR_MODEMSTATE;
+        }
+    }
+  if(intrSource & MASK_MAILBOX_INTERRUPTS)
+    {
+      /*
+       rc = dslhal_support_readDelineationState(ptidsl); 
+       if(rc)
+       {
+         dprintf(0,"Error Reading Delineation State \n");
+         return DSLHAL_ERROR_MODEMSTATE;
+        }
+      */
+       while (dslhal_support_readDspMailbox(ptidsl,&cmd, &tag, &parm1, &parm2) == DSLHAL_ERROR_NO_ERRORS )
+       {
+         dprintf(4,"mailbox message: 0x%x\n", cmd);
+         /*    
+         for(rc=0;rc<8;rc++)
+         {
+           dslhal_support_readTextMailbox(ptidsl,&msg1, &msg2);
+         }
+          */ 
+         if (cmd == DSP_IDLE) 
+         {
+           dprintf(4,"DSP_IDLE\n");
+           ptidsl->lConnected=0;
+           hybrid_selected=888;
+           if(showtimeFlag == TRUE)
+           {
+             dslhal_api_resetTrainFailureLog(ptidsl);
+             dslhal_support_advancedIdleProcessing(ptidsl);
+             showtimeFlag = FALSE;
+            }
+           failState = (unsigned int)parm1;
+           if(failState!=0)
+           {
+             ptidsl->AppData.trainFailStates[ptidsl->AppData.trainFails]=failState;
+             ptidsl->AppData.trainFails++;
+             if(ptidsl->AppData.trainFails > 30)
+               ptidsl->AppData.trainFails=0;
+            }
+           for(interruptGhsIndex=0;interruptGhsIndex<10;interruptGhsIndex++)
+             {
+               for(rc=0;rc<62;rc++)
+                 ptidsl->AppData.dsl_ghsRxBuf[interruptGhsIndex][rc]=0;
+             }  
+           interruptGhsIndex=0;
+
+           /* add code for reload overlay pages */
+           if(ptidsl->bAutoRetrain == 0 && ptidsl->bOverlayPageLoaded == 0)
+             {
+             dslhal_support_restoreTrainingInfo(ptidsl);
+             ptidsl->bOverlayPageLoaded = 1;
+             }
+           /* command DSP to ACTREQ */
+           rc = dslhal_support_writeHostMailbox(ptidsl, HOST_ACTREQ, 0, 0, 0);
+           if (rc)
+             return DSLHAL_ERROR_MAILBOX_WRITE;
+         }
+         if(cmd == DSP_ATM_TC_SYNC)
+           {
+           dprintf(4,"\nTC_SYNC\n");
+           showtimeFlag = TRUE;
+           ptidsl->lConnected=1;
+           if(ptidsl->bAutoRetrain == 0 && ptidsl->bOverlayPageLoaded == 1)
+             {
+             dslhal_support_clearTrainingInfo(ptidsl);
+             ptidsl->bOverlayPageLoaded = 0;
+             }
+           }
+         if(cmd == DSP_ACTIVE)
+           {
+             ptidsl->lConnected=0;
+             ptidsl->AppData.bState = RSTATE_SHOWTIME;
+             dprintf(4,"DSP_ACTIVE");
+             dprintf(4,"US Connect Rate: %u \n",ptidsl->AppData.USConRate);
+             dprintf(4,"DS Connect Rate: %u \n",ptidsl->AppData.DSConRate);
+           }
+         if(cmd == DSP_ATM_NO_TC_SYNC)
+           {
+             dprintf(4,"\nTC_NOSYNC\n");
+             ptidsl->lConnected=0;
+             /* add code for reload overlay pages */
+           }
+         if(cmd == DSP_OVERLAY_END)
+           {
+             dprintf(4,"Overlay Page Done %d \n",tag);
+             rc = dslhal_support_checkOverlayPage(ptidsl,tag);
+             if(rc == DSLHAL_ERROR_OVERLAY_CORRUPTED)
+               {
+                 dprintf(4,"Overlay Page: %d CORRUPTED \n",tag);
+                 return(0-DSLHAL_ERROR_OVERLAY_CORRUPTED);
+               }
+           }
+         if(cmd == DSP_HYBRID)
+           {
+             dprintf(2,"Hybrid Metrics Available\n");
+             hybrid_selected = tag;
+           }
+         if(cmd == DSP_XMITBITSWAP)
+           {
+            rc = dslhal_support_aocBitSwapProcessing(ptidsl,0);
+           }
+         if(cmd == DSP_RCVBITSWAP)
+           {
+            rc = dslhal_support_aocBitSwapProcessing(ptidsl,1);
+           }
+         if(cmd == DSP_GHSMSG)
+           {
+            dprintf(3,"Ghs Message Received, bytes: %d \n",tag);
+            dprintf(3,"Addr: 0x%x\n",dspOamSharedInterface.ghsDspRxBuf_p);
+            if(interruptGhsIndex > 9)
+              interruptGhsIndex=0;
+            rc = dslhal_support_blockRead((void *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.ghsDspRxBuf_p), &ptidsl->AppData.dsl_ghsRxBuf[interruptGhsIndex++][0], tag);
+            }
+         if(cmd == DSP_CRATES1)
+          {
+           dprintf(3,"DSP C-Rates1 Data Ready \n");
+           rc = dslhal_support_gatherRateMessages(ptidsl);
+          }
+         if(cmd == DSP_SNR)
+          {
+           dprintf(3,"DSP SNR Data Ready \n");
+           rc = dslhal_support_gatherSnrPerBin(ptidsl,tag);
+          }
+         if(cmd == DSP_EOC)
+          {
+           dprintf(3,"DSP_EOC message \n");
+           rc = dslhal_support_gatherEocMessages(ptidsl,tag,parm1,parm2);
+          }
+         if(cmd == DSP_TRAINING_MSGS)
+          {
+           dprintf(3,"DSP_TRAINING_MSGS \n"); 
+           rc = dslhal_support_gatherAdsl2Messages(ptidsl,tag,parm1,parm2);
+          }
+        }       
+     
+       dslhal_support_readTextMailbox(ptidsl,&msg1, &msg2);
+       dprintf(5,"Text Message Part1: 0x%x \t Text Message Part2: 0x%x \n",msg1,msg2);
+    }     
+  dprintf(6,"dslhal_api_handleTrainingInterrupt done\n");
+  return(ptidsl->AppData.bState);
+} /* end of dslhal_api_handleTrainingInterrupt() */
+
+  
+
+
+/******************************************************************************************    
+ * FUNCTION NAME:    dslhal_api_dslRetrain(tidsl_t *ptidsl)    
+ *    
+ *******************************************************************************************    
+ * DESCRIPTION: This fuction sends CMD_ACTREQ to the DSP to issue a retrain    
+ *    
+ * INPUT:  PITIDSLHW_T *ptidsl    
+ *           
+ * RETURN: 0 SUCCESS    
+ *         1 FAILED    
+ *      
+ *****************************************************************************************/    
+unsigned int dslhal_api_dslRetrain(tidsl_t *ptidsl)
+{
+   int rc; 
+   
+   dprintf(5, "dslhal_cfg_dslRetrain \n"); 
+   rc = dslhal_support_writeHostMailbox(ptidsl, HOST_QUIET, 0, 0, 0); 
+   if(rc)
+    {  
+      dprintf(1,"dslhal_cfg_dslRetrain failed\n");  
+      return DSLHAL_ERROR_CTRL_API_FAILURE;  
+    }  
+    return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/******************************************************************************************    
+ * FUNCTION NAME:    dslhal_api_sendQuiet(tidsl_t *ptidsl)    
+ *    
+ *******************************************************************************************    
+ * DESCRIPTION: This fuction sends the CMD_QUIET message to the DSP    
+ *    
+ * INPUT:  PITIDSLHW_T *ptidsl    
+ *           
+ * RETURN: 0 SUCCESS    
+ *         1 FAILED    
+ *      
+ *****************************************************************************************/    
+unsigned int dslhal_api_sendQuiet(tidsl_t *ptidsl)
+{
+   int rc; 
+   
+   dprintf(5, "dslhal_api_sendQuiet\n"); 
+   rc = dslhal_support_writeHostMailbox(ptidsl, HOST_QUIET, 0, 0, 0); 
+   if(rc)
+    {  
+      dprintf(1,"dslhal_api_sendQuiet failed\n");  
+      return DSLHAL_ERROR_CTRL_API_FAILURE;    
+    }  
+    return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/******************************************************************************************     
+ * FUNCTION NAME:    dslhal_api_sendIdle(tidsl_t *ptidsl)     
+ *     
+ *******************************************************************************************     
+ * DESCRIPTION: This fuction sends the CMD_IDLE message to the DSP     
+ *     
+ * INPUT:  PITIDSLHW_T *ptidsl     
+ *            
+ * RETURN: 0 SUCCESS     
+ *         1 FAILED     
+ *       
+ *****************************************************************************************/     
+unsigned int dslhal_api_sendIdle(tidsl_t *ptidsl) 
+{ 
+   int rc;  
+    
+   dprintf(5, "dslhal_api_sendIdle\n");  
+   rc = dslhal_support_writeHostMailbox(ptidsl, HOST_IDLE, 0, 0, 0);  
+   if(rc) 
+     {   
+      dprintf(1,"dslhal_api_sendIdle failed\n");   
+      return DSLHAL_ERROR_CTRL_API_FAILURE;    
+     }   
+    return DSLHAL_ERROR_NO_ERRORS; 
+} 
+
+/******************************************************************************************    
+ * FUNCTION NAME:    dslhal_api_sendDgasp(tidsl_t *ptidsl)    
+ *    
+ *******************************************************************************************    
+ * DESCRIPTION: This fuction sends the HOST_DGASP message to the DSP    
+ *    
+ * INPUT:  PITIDSLHW_T *ptidsl    
+ *           
+ * RETURN: 0 SUCCESS    
+ *         1 FAILED    
+ *      
+ *****************************************************************************************/    
+unsigned int dslhal_api_sendDgasp(tidsl_t *ptidsl)
+{
+   int rc; 
+   
+   dprintf(5, "dslhal_api_sendDgasp\n"); 
+   rc = dslhal_support_writeHostMailbox(ptidsl, HOST_DGASP, 0, 0, 0); 
+   if(rc)
+    {  
+      dprintf(1,"dslhal_api_sendDgasp failed\n");  
+      return DSLHAL_ERROR_CTRL_API_FAILURE;    
+    }  
+    return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_setTrainingMode(tidsl_t *ptidsl,unsigned int trainmode)
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction Sets the Desired Training Mode {None/Multimode/G.dmt/lite
+*
+* INPUT:  PITIDSLHW_T *ptidsl
+*         unsigned int trainmode :Should be between 0 and 4; 0:No Mode 1:Multimode
+*                                 2: T1.413, 3:G.dmt, 4: G.lite
+* RETURN: 0 SUCCESS
+*         1 FAILED
+*
+*****************************************************************************************/
+unsigned int dslhal_api_setTrainingMode(tidsl_t *ptidsl,unsigned int trainmode)
+{
+   DEV_HOST_oamWrNegoParaDef_t NegoPara;
+   DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+   int rc;
+   dprintf(5," dslhal_api_setTrainingMode()\n");
+   if(trainmode>255)
+     {
+       dprintf(3,"Invalid Value for Desired Training Mode (must be <255)\n");
+       return DSLHAL_ERROR_INVALID_PARAM;
+     }
+
+   if(!ptidsl)
+    {
+      dprintf(3, "Error: PTIDSL pointer invalid\n");
+      return DSLHAL_ERROR_INVALID_PARAM;
+    }
+
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface, 
+                                     sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+
+  dspOamSharedInterface.oamWriteNegoParams_p = (DEV_HOST_oamWrNegoParaDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.oamWriteNegoParams_p);
+
+   rc = dslhal_support_blockRead((PVOID) dspOamSharedInterface.oamWriteNegoParams_p,&NegoPara, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  /* Enum Translation to maintain backwards compatibility for train modes */
+  if(trainmode == DSLTRAIN_MULTI_MODE)
+    trainmode = MULTI_MODE;
+  if(trainmode == DSLTRAIN_T1413_MODE)
+    trainmode = T1413_MODE;
+  if(trainmode == DSLTRAIN_GDMT_MODE)
+    trainmode = GDMT_MODE;
+   
+  NegoPara.stdMode = trainmode;
+  dprintf(5,"Train Mode: 0x%x\n",trainmode); 
+  rc = dslhal_support_blockWrite(&NegoPara,(PVOID)dspOamSharedInterface.oamWriteNegoParams_p, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+  if(rc)
+    return DSLHAL_ERROR_CONFIG_API_FAILURE;
+ 
+  dprintf(5," dslhal_api_setTrainingMode() Done\n");
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_getDspVersion
+*
+*******************************************************************************************
+* DESCRIPTION: This routine supply AX5 daugther card DSP version.
+*
+* INPUT:  tidsl_t * ptidsl
+*         void *pVer, DSP version struct is returned starting at this pointer
+*         
+* RETURN:  0 --succeeded
+*          1 --Failed
+* Note: See verdef_u.h for version structure definition.
+*****************************************************************************************/
+int dslhal_api_getDspVersion(tidsl_t *ptidsl, void  *pVer)
+{
+  /*  DEV_HOST_dspVersionDef_t  dspVersion; */
+   DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+   int rc;
+   dprintf(5, "dslhal_api_getDspVersion\n");
+   if(!ptidsl)
+     {
+       dprintf(3, "Error: PTIDSL pointer invalid\n");
+       return DSLHAL_ERROR_INVALID_PARAM;
+     }
+   if(!pVer)
+     return DSLHAL_ERROR_INVALID_PARAM;
+   
+   *(unsigned int *) pVer = 0;
+ 
+   pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   dspOamSharedInterface.datapumpVersion_p = (DEV_HOST_dspVersionDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.datapumpVersion_p);
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.datapumpVersion_p,
+                                      pVer, sizeof(dspVer));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+  pVer = (DEV_HOST_dspVersionDef_t *)(dslhal_support_byteSwap32((unsigned int)pVer)); 
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_gatherStatistics()
+*
+*********************************************************************************************
+* DESCRIPTION: Read statistical infromation from ax5 modem daugter card. 
+* Input: tidsl_t *ptidsl
+* 
+* Return: 0    success
+*         1    failed
+*
+********************************************************************************************/
+void dslhal_api_gatherStatistics(tidsl_t * ptidsl)
+{
+  int rc,optIdxU,optIdxD,i; 
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  DEV_HOST_dspWrNegoParaDef_t   rateparms;
+  DEV_HOST_oamWrNegoParaDef_t   configParms;
+  DEV_HOST_modemStatsDef_t      StatisticsDef;
+  DEV_HOST_errorStats_t usIntlvError, usFastError, dsIntlvError, dsFastError;
+  DEV_HOST_atmStats_t           atmStats;
+  DEV_HOST_usAtmStats_t         usAtmStats0, usAtmStats1;
+  DEV_HOST_dsAtmStats_t         dsAtmStats0,dsAtmStats1;
+  DEV_HOST_dspWrSuperFrameCntDef_t   SuperFrameCnt;
+  DEV_HOST_msg_t                atuc_msg, aturMsg;
+  DEV_HOST_eocVarDef_t          eocVar;
+  DEV_HOST_dspWrSharedTables_t  sharedTables;
+  DEV_HOST_phyPerf_t            phyPerf;
+  unsigned char                 usBits[64],dsBits[256];
+  unsigned char                 dsPowerCutBack;
+  int                           usNumLoadedTones=0, dsNumLoadedTones=0;
+
+  dprintf(5, "dslhal_api_gatherStatistics\n");
+  
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+  
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface, 
+                                     sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+  if(!ptidsl->bStatisticsInitialized && ptidsl->lConnected == LINE_CONNECTED)
+  {
+    dslhal_api_initStatistics(ptidsl);
+    ptidsl->bStatisticsInitialized = TRUE;
+  }
+
+  dspOamSharedInterface.dspWriteNegoParams_p = (DEV_HOST_dspWrNegoParaDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.dspWriteNegoParams_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.dspWriteNegoParams_p, 
+                               &rateparms, sizeof(DEV_HOST_dspWrNegoParaDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+  if(!rc) 
+    {    
+      /* trained mode */
+    ptidsl->AppData.dsl_modulation = (unsigned int)rateparms.trainMode;
+    if(rateparms.trainMode == T1413_MODE)
+      ptidsl->AppData.dsl_modulation = DSLTRAIN_T1413_MODE;
+    if(rateparms.trainMode == GDMT_MODE)
+      ptidsl->AppData.dsl_modulation = DSLTRAIN_GDMT_MODE;
+      /* rate */
+    /*    shim_osMoveMemory((void *)ptidsl->AppData.bCRates1, (void *)rateparms.cRates1, 120); */
+    ptidsl->AppData.bCRates2 = rateparms.cRates2;
+    /*    shim_osMoveMemory((void *)ptidsl->AppData.bRRates1, (void *)rateparms.rRates1, 44); */
+    ptidsl->AppData.bRRates2 = rateparms.rRates2;
+    shim_osMoveMemory((void *)ptidsl->AppData.bCMsgs1, (void *)rateparms.cMsgs1, 6);
+    shim_osMoveMemory((void *)ptidsl->AppData.bCMsgs2, (void *)rateparms.cMsgs2, 4);
+    shim_osMoveMemory((void *)ptidsl->AppData.bRMsgs2, (void *)rateparms.rMsgs2, 4);
+    ptidsl->AppData.atucVendorId = (unsigned int)rateparms.atucVendorId;
+    ptidsl->AppData.lineLength = (unsigned int)dslhal_support_byteSwap16((unsigned short)rateparms.lineLength);
+    ptidsl->AppData.atucRevisionNum = (unsigned int)rateparms.atucGhsRevisionNum;         
+    ptidsl->AppData.usLineAttn = (ptidsl->AppData.bCMsgs2[3] >>2)&0x003f;
+    ptidsl->AppData.usMargin = (ptidsl->AppData.bCMsgs2[2])&0x001f;
+    
+    if((rateparms.cRates2 & 0x0f) == 0x01) 
+      optIdxU = 0;
+    else if((rateparms.cRates2 & 0x0f) == 0x02)  
+      optIdxU = 1;
+    else if((rateparms.cRates2 & 0x0f) == 0x04) 
+      optIdxU = 2;
+    else if((rateparms.cRates2 & 0x0f) == 0x08)  
+      optIdxU = 3;
+    else 
+      optIdxU = -1;
+    
+    dprintf(5, "optIdxU=%d\n", optIdxU);
+   
+    /* Obtain the US Rates using Opt# and CRates1 Table */
+    /* Rate(US) = [Bf(LS0) + Bi(LS0)]*32                */
+    if(ptidsl->AppData.dsl_modulation <= DSLTRAIN_GLITE_MODE)
+      ptidsl->AppData.USConRate = ((rateparms.cRates1[optIdxU][CRATES1_BF_LS0] + rateparms.cRates1[optIdxU][CRATES1_BI_LS0]) * 32);
+    else
+      ptidsl->AppData.USConRate =  32 * dslhal_support_byteSwap16((unsigned short)rateparms.adsl2USRate);
+
+    ptidsl->AppData.USPeakCellRate = ptidsl->AppData.USConRate; 
+    
+    if(((rateparms.cRates2 >> 4) & 0x0f) == 0x01) 
+      optIdxD = 0;
+    else if(((rateparms.cRates2 >> 4) & 0x0f) == 0x02)  
+      optIdxD = 1;
+    else if(((rateparms.cRates2 >> 4) & 0x0f) == 0x04) 
+      optIdxD = 2;
+    else if(((rateparms.cRates2 >> 4) & 0x0f) == 0x08)  
+      optIdxD = 3;
+    else 
+      optIdxD = -1;
+    /* Obtain the DS Rates using Opt# and CRates1 Table */
+    /* Rate(DS) = [Bf(AS0) + Bi(AS0)]*32                */
+    if(ptidsl->AppData.dsl_modulation <= DSLTRAIN_GLITE_MODE)
+      ptidsl->AppData.DSConRate =  (((rateparms.cRates1[optIdxD][CRATES1_BF_AS0]|((rateparms.cRates1[optIdxD][CRATES1_BF_DSRS]&0x80)<<1))+ (rateparms.cRates1[optIdxD][CRATES1_BI_AS0]|((rateparms.cRates1[optIdxD][CRATES1_BI_DSRS]&0x80)<<1)))* 32);
+    else
+      ptidsl->AppData.DSConRate = dslhal_support_byteSwap16((unsigned short)rateparms.adsl2DSRate);
+
+    dprintf(5, "ptidsl->AppData.wDSConRate=%d\n", ptidsl->AppData.DSConRate);
+    /* Determine which Path has Modem Trained with */
+    if((rateparms.cRates1[optIdxU][CRATES1_BF_LS0]) && (rateparms.cRates1[optIdxD][CRATES1_BF_AS0]))
+      ptidsl->AppData.TrainedPath = FAST_PATH;
+    else
+      ptidsl->AppData.TrainedPath = INTERLEAVED_PATH;
+
+    /* Set the mode in which the modem is trained */
+    ptidsl->AppData.TrainedMode = (unsigned int)rateparms.trainMode;
+    if(rateparms.trainMode == T1413_MODE)
+      ptidsl->AppData.TrainedMode = DSLTRAIN_T1413_MODE;
+    if(rateparms.trainMode == GDMT_MODE)
+      ptidsl->AppData.TrainedMode = DSLTRAIN_GDMT_MODE;
+
+    if(ptidsl->AppData.TrainedPath == FAST_PATH)
+       ptidsl->AppData.dsFastParityBytesPerSymbol = (rateparms.cRates1[optIdxU][CRATES1_BF_DSRS]&0x1f);
+    else
+       ptidsl->AppData.dsIntlvParityBytesPerSymbol = (rateparms.cRates1[optIdxU][CRATES1_BI_DSRS]&0x1f);
+    ptidsl->AppData.dsSymbolsPerCodeWord = (rateparms.cRates1[optIdxU][CRATES1_BFI_DSS]&0x1f);
+    ptidsl->AppData.dsInterleaverDepth = ((rateparms.cRates1[optIdxU][CRATES1_BFI_DSI])|((rateparms.cRates1[optIdxU][CRATES1_BFI_DSS]&0xc0)<<2));
+
+    if(ptidsl->AppData.TrainedPath == FAST_PATH)
+       ptidsl->AppData.usFastParityBytesPerSymbol = (rateparms.cRates1[optIdxU][CRATES1_BF_USRS]&0x1f);
+    else
+       ptidsl->AppData.usIntlvParityBytesPerSymbol = (rateparms.cRates1[optIdxU][CRATES1_BI_USRS]&0x1f);
+    ptidsl->AppData.usSymbolsPerCodeWord = (rateparms.cRates1[optIdxU][CRATES1_BFI_USS]&0x1f);
+    ptidsl->AppData.usInterleaverDepth = ((rateparms.cRates1[optIdxU][CRATES1_BFI_USI])|((rateparms.cRates1[optIdxU][CRATES1_BFI_USS]&0xc0)<<2));
+    }
+
+  dspOamSharedInterface.modemStats_p = (DEV_HOST_modemStatsDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.modemStats_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.modemStats_p,&StatisticsDef, sizeof(DEV_HOST_modemStatsDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+  /* Populate the Error Structure Variables */
+
+  /* US Interleave Path Error Statistics */
+
+  /* Change the endianness of the Pointer */
+  StatisticsDef.usErrorStatsIntlv_p = (DEV_HOST_errorStats_t *) dslhal_support_byteSwap32((unsigned int)StatisticsDef.usErrorStatsIntlv_p);
+
+  rc = dslhal_support_blockRead((PVOID)StatisticsDef.usErrorStatsIntlv_p,&usIntlvError, (sizeof(DEV_HOST_errorStats_t)));
+  
+  if (rc) 
+    return;
+
+  /* DS Interleave Path Error Statistics */
+
+  /* Change the endianness of the Pointer */
+  StatisticsDef.dsErrorStatsIntlv_p = (DEV_HOST_errorStats_t *) dslhal_support_byteSwap32((unsigned int)StatisticsDef.dsErrorStatsIntlv_p);
+
+  rc = dslhal_support_blockRead((PVOID)StatisticsDef.dsErrorStatsIntlv_p,&dsIntlvError, (sizeof(DEV_HOST_errorStats_t)));
+  
+  if (rc) 
+    return;
+
+  /* US Fast Path Error Statistics */
+
+  /* Change the endianness of the Pointer */
+  StatisticsDef.usErrorStatsFast_p = (DEV_HOST_errorStats_t *) dslhal_support_byteSwap32((unsigned int)StatisticsDef.usErrorStatsFast_p);
+
+  rc = dslhal_support_blockRead((PVOID)StatisticsDef.usErrorStatsFast_p,&usFastError, (sizeof(DEV_HOST_errorStats_t)));
+  
+  if (rc) 
+    return;
+
+  /* DS Fast Path Error Statistics */
+
+  /* Change the endianness of the Pointer */
+  StatisticsDef.dsErrorStatsFast_p = (DEV_HOST_errorStats_t *) dslhal_support_byteSwap32((unsigned int)StatisticsDef.dsErrorStatsFast_p);
+
+  rc = dslhal_support_blockRead((PVOID)StatisticsDef.dsErrorStatsFast_p,&dsFastError, (sizeof(DEV_HOST_errorStats_t)));
+  
+  if (rc) 
+    return;
+  if(!rc) 
+  {
+    if(ptidsl->AppData.bState > 2)
+    {
+      /* Get CRC Errors Stats for both US and DS */
+      ptidsl->AppData.dsICRC_errors   = dslhal_support_byteSwap32((unsigned int)dsIntlvError.crcErrors);
+      ptidsl->AppData.dsFCRC_errors   = dslhal_support_byteSwap32((unsigned int)dsFastError.crcErrors);
+      ptidsl->AppData.usICRC_errors   = dslhal_support_byteSwap32((unsigned int)usIntlvError.crcErrors);
+      ptidsl->AppData.usFCRC_errors   = dslhal_support_byteSwap32((unsigned int)usFastError.crcErrors);
+      /* Get FEC Errors Stats for both US and DS */
+      ptidsl->AppData.dsIFEC_errors   = dslhal_support_byteSwap32((unsigned int)dsIntlvError.fecErrors);
+      ptidsl->AppData.dsFFEC_errors   = dslhal_support_byteSwap32((unsigned int)dsFastError.fecErrors);
+      ptidsl->AppData.usIFEC_errors   = dslhal_support_byteSwap32((unsigned int)usIntlvError.fecErrors);
+      ptidsl->AppData.usFFEC_errors   = dslhal_support_byteSwap32((unsigned int)usFastError.fecErrors);
+      /* Get NCD Errors Stats for both US and DS */
+      ptidsl->AppData.dsINCD_error   = dslhal_support_byteSwap32((unsigned int)dsIntlvError.ncdError);
+      ptidsl->AppData.dsFNCD_error   = dslhal_support_byteSwap32((unsigned int)dsFastError.ncdError);
+      ptidsl->AppData.usINCD_error   = dslhal_support_byteSwap32((unsigned int)usIntlvError.ncdError);
+      ptidsl->AppData.usFNCD_error   = dslhal_support_byteSwap32((unsigned int)usFastError.ncdError);
+      /* Get LCD Errors Stats for both US and DS */
+      ptidsl->AppData.dsILCD_errors   = dslhal_support_byteSwap32((unsigned int)dsIntlvError.lcdErrors);
+      ptidsl->AppData.dsFLCD_errors   = dslhal_support_byteSwap32((unsigned int)dsFastError.lcdErrors);
+      ptidsl->AppData.usILCD_errors   = dslhal_support_byteSwap32((unsigned int)usIntlvError.lcdErrors);
+      ptidsl->AppData.usFLCD_errors   = dslhal_support_byteSwap32((unsigned int)usFastError.lcdErrors);
+      /*Get HEC Errors Stats for both US and DS */
+      ptidsl->AppData.dsIHEC_errors   = dslhal_support_byteSwap32((unsigned int)dsIntlvError.hecErrors);
+      ptidsl->AppData.dsFHEC_errors   = dslhal_support_byteSwap32((unsigned int)dsFastError.hecErrors);
+      ptidsl->AppData.usIHEC_errors   = dslhal_support_byteSwap32((unsigned int)usIntlvError.hecErrors);
+      ptidsl->AppData.usFHEC_errors   = dslhal_support_byteSwap32((unsigned int)usFastError.hecErrors);
+
+      /* Get LOS and SEF error Stats */
+      ptidsl->AppData.LOS_errors      = dslhal_support_byteSwap32(StatisticsDef.losErrors);            
+      ptidsl->AppData.SEF_errors      = dslhal_support_byteSwap32(StatisticsDef.sefErrors);
+      ptidsl->AppData.coLosErrors = dslhal_support_byteSwap32(StatisticsDef.farEndLosErrors);
+      ptidsl->AppData.coRdiErrors = dslhal_support_byteSwap32(StatisticsDef.farEndRdiErrors);
+  
+  dspOamSharedInterface.atmStats_p = (DEV_HOST_atmStats_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.atmStats_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.atmStats_p,&atmStats, sizeof(DEV_HOST_atmStats_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+
+  /* Populate the US/DS ATM Stats Variables */
+
+  /* US ATM Statistics */
+
+  /* Change the endianness of the Pointer */
+  atmStats.us0_p = (DEV_HOST_usAtmStats_t *) dslhal_support_byteSwap32((unsigned int)atmStats.us0_p);
+
+  rc = dslhal_support_blockRead((PVOID)atmStats.us0_p,&usAtmStats0, (sizeof(DEV_HOST_usAtmStats_t)));
+  
+  if (rc) 
+    return;
+
+  atmStats.us1_p = (DEV_HOST_usAtmStats_t *) dslhal_support_byteSwap32((unsigned int)atmStats.us1_p);
+
+  rc = dslhal_support_blockRead((PVOID)atmStats.us1_p,&usAtmStats1, (sizeof(DEV_HOST_usAtmStats_t)));
+  
+  if (rc) 
+    return;
+
+ /* DS ATM Statistics */
+
+  /* Change the endianness of the Pointer */
+  atmStats.ds0_p = (DEV_HOST_dsAtmStats_t *) dslhal_support_byteSwap32((unsigned int)atmStats.ds0_p);
+
+  rc = dslhal_support_blockRead((PVOID)atmStats.ds0_p,&dsAtmStats0, (sizeof(DEV_HOST_dsAtmStats_t)));
+  
+  if (rc) 
+    return;
+  atmStats.ds1_p = (DEV_HOST_dsAtmStats_t *) dslhal_support_byteSwap32((unsigned int)atmStats.ds1_p);
+
+  rc = dslhal_support_blockRead((PVOID)atmStats.ds1_p,&dsAtmStats1, (sizeof(DEV_HOST_dsAtmStats_t)));
+  
+  if (rc) 
+    return;
+
+      /* Get ATM Stats for both US and DS for Channel 0*/
+      ptidsl->AppData.usAtm_count[0]     = dslhal_support_byteSwap32(usAtmStats0.goodCount);
+      ptidsl->AppData.usIdle_count[0]    = dslhal_support_byteSwap32(usAtmStats0.idleCount);
+#if SWTC
+      ptidsl->AppData.usPdu_count[0]     = dslhal_support_byteSwap32(usAtmStats0.pduCount);
+#endif
+      ptidsl->AppData.dsGood_count[0]    = dslhal_support_byteSwap32(dsAtmStats0.goodCount);
+      ptidsl->AppData.dsIdle_count[0]    = dslhal_support_byteSwap32(dsAtmStats0.idleCount);
+#if SWTC
+      ptidsl->AppData.dsPdu_count[0]     = dslhal_support_byteSwap32(dsAtmStats0.pduCount);
+#endif
+      ptidsl->AppData.dsBadHec_count[0]  = dslhal_support_byteSwap32((dsAtmStats0.badHecCount));
+      ptidsl->AppData.dsOVFDrop_count[0] = dslhal_support_byteSwap32((dsAtmStats0.ovflwDropCount));
+      /* Get ATM Stats for both US and DS for Channel 1*/
+      ptidsl->AppData.usAtm_count[1]     = dslhal_support_byteSwap32(usAtmStats1.goodCount);
+      ptidsl->AppData.usIdle_count[1]    = dslhal_support_byteSwap32(usAtmStats1.idleCount);
+#if SWTC
+      ptidsl->AppData.usPdu_count[1]     = dslhal_support_byteSwap32(usAtmStats1.pduCount);
+#endif
+      ptidsl->AppData.dsGood_count[1]    = dslhal_support_byteSwap32(dsAtmStats1.goodCount);
+      ptidsl->AppData.dsIdle_count[1]    = dslhal_support_byteSwap32(dsAtmStats1.idleCount);
+#if SWTC
+      ptidsl->AppData.dsPdu_count[1]     = dslhal_support_byteSwap32(dsAtmStats1.pduCount);
+#endif
+      ptidsl->AppData.dsBadHec_count[1]  = dslhal_support_byteSwap32((dsAtmStats1.badHecCount));
+      ptidsl->AppData.dsOVFDrop_count[1] = dslhal_support_byteSwap32((dsAtmStats1.ovflwDropCount));
+
+    /* Determine the US and DS Superframe Count */
+
+  dspOamSharedInterface.dspWriteSuperFrameCnt_p = (DEV_HOST_dspWrSuperFrameCntDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.dspWriteSuperFrameCnt_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.dspWriteSuperFrameCnt_p,&SuperFrameCnt, sizeof(DEV_HOST_dspWrSuperFrameCntDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+      ptidsl->AppData.usSuperFrmCnt   = dslhal_support_byteSwap32(SuperFrameCnt.wSuperFrameCntUstrm);
+      ptidsl->AppData.dsSuperFrmCnt   = dslhal_support_byteSwap32(SuperFrameCnt.wSuperFrameCntDstrm);
+      
+      /* Determine Frame Mode and Max Frame Mode */
+
+  dspOamSharedInterface.atucMsg_p = (DEV_HOST_msg_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.atucMsg_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.atucMsg_p,&atuc_msg, sizeof(DEV_HOST_msg_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+
+  ptidsl->AppData.FrmMode         = (unsigned int)atuc_msg.framingMode;
+  ptidsl->AppData.MaxFrmMode      = (unsigned int)atuc_msg.maxFrameMode;
+
+  /* Determine Gross Gain */
+
+  dspOamSharedInterface.aturMsg_p = (DEV_HOST_msg_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.aturMsg_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.aturMsg_p,&aturMsg, sizeof(DEV_HOST_msg_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+  ptidsl->AppData.grossGain = (unsigned int)aturMsg.grossGain;
+
+      /* Determine DS Line Attenuation & Margin */
+  dspOamSharedInterface.eocVar_p = (DEV_HOST_eocVarDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.eocVar_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.eocVar_p,&eocVar, sizeof(DEV_HOST_eocVarDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+      ptidsl->AppData.dsLineAttn      = (unsigned int)eocVar.lineAtten;
+      ptidsl->AppData.dsMargin        = (unsigned int)eocVar.dsMargin;
+    }
+  } 
+
+  /* Read in the Shared Tables structure */      
+  dspOamSharedInterface.dspWrSharedTables_p = (DEV_HOST_dspWrSharedTables_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.dspWrSharedTables_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.dspWrSharedTables_p,&sharedTables, sizeof(DEV_HOST_dspWrSharedTables_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+
+  /* Read the ATU-R Bits and Gains Table */
+  sharedTables.aturBng_p = (unsigned char *)dslhal_support_byteSwap32((unsigned int)sharedTables.aturBng_p);
+  rc = dslhal_support_blockRead((PVOID)sharedTables.aturBng_p,ptidsl->AppData.rBng,255*2*sizeof(unsigned char));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+  /* Read the ATU-C Bits and Gains Table */
+  sharedTables.atucBng_p = (unsigned char *)dslhal_support_byteSwap32((unsigned int)sharedTables.atucBng_p);
+  if(ptidsl->netService == 2) /* for Annex_B */
+    {
+      rc = dslhal_support_blockRead((PVOID)sharedTables.atucBng_p,ptidsl->AppData.cBng,126*sizeof(unsigned char));
+      if (rc)
+       {
+        dprintf(1,"dslhal_support_blockRead failed\n");
+        return;
+        }
+      for(i=0;i<US_BNG_LENGTH*2;i++)
+         usBits[i]=0;
+      for(i=1;i<US_BNG_LENGTH*2;i++)
+       {
+        usBits[i]=((ptidsl->AppData.cBng[(i-1)*2])&0xf);
+        dprintf(5,"Bit #%d : 0x%x\n",i,usBits[i]);
+        }
+      for(i=1;i<US_BNG_LENGTH*2;i++)
+       {
+        if(usBits[i])
+        usNumLoadedTones++;
+        }
+    }
+  else
+    {
+      rc = dslhal_support_blockRead((PVOID)sharedTables.atucBng_p,ptidsl->AppData.cBng,62*sizeof(unsigned char));
+      if (rc)
+       {
+        dprintf(1,"dslhal_support_blockRead failed\n");
+        return;
+        }
+      for(i=0;i<US_BNG_LENGTH;i++)
+         usBits[i]=0;
+      for(i=1;i<US_BNG_LENGTH;i++)
+       {
+        usBits[i]=((ptidsl->AppData.cBng[(i-1)*2])&0xf);
+        dprintf(5,"Bit #%d : 0x%x\n",i,usBits[i]);
+        }
+      for(i=1;i<US_BNG_LENGTH;i++)
+       {
+        if(usBits[i])
+        usNumLoadedTones++;
+        }
+    }
+
+  /* Determine Number U/S of Loaded Tones */
+
+  /* U/S Power Computation */
+  dspOamSharedInterface.phyPerf_p = (DEV_HOST_phyPerf_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.phyPerf_p);
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.phyPerf_p,
+                                &phyPerf, sizeof(DEV_HOST_phyPerf_t));
+  if (rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return;
+    }  
+  ptidsl->AppData.currentHybridNum = phyPerf.currentHybridNumUsed;
+  phyPerf.usAvgGain = dslhal_support_byteSwap32(phyPerf.usAvgGain);
+  ptidsl->AppData.usTxPower = LOG43125 + phyPerf.usAvgGain + (256*US_NOMINAL_POWER)+log10[usNumLoadedTones-1];
+  dprintf(7,"Avg Gain: 0x%x  usNumLoadedTones: 0x%x    log: 0x%x\n",phyPerf.usAvgGain, usNumLoadedTones, log10[usNumLoadedTones-1]);
+  
+  /* Determine Number D/S of Loaded Tones */
+  dsBits[0]=0;
+  for(i=0;i<DS_BNG_LENGTH;i++)
+    {
+     dsBits[i]=0;
+     /* ptidsl->AppData.rBng[i-1]=dslhal_support_byteSwap32((unsigned int)ptidsl->AppData.rBng[i-1]);*/
+    }
+  for(i=1;i<DS_BNG_LENGTH;i++)
+    {
+     dsBits[i]=((ptidsl->AppData.rBng[(i-1)*2])&0xf);
+     dprintf(5,"Bit #%d : 0x%x\n",i,dsBits[i]);
+    }
+  for(i=1;i<DS_BNG_LENGTH;i++)
+    {
+     if(dsBits[i])
+       dsNumLoadedTones++;
+    }
+  /* D/S Power Computation */
+  dspOamSharedInterface.phyPerf_p = (DEV_HOST_phyPerf_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.phyPerf_p);
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.phyPerf_p,
+                                &phyPerf, sizeof(DEV_HOST_phyPerf_t));
+  if (rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return;
+    }  
+  /* D/S Power Cutback */
+  dsPowerCutBack = (unsigned char)((((ptidsl->AppData.bCMsgs1[0]) >>6) &0x3)+(((ptidsl->AppData.bCMsgs1[1]) &0x1) <<2));
+  phyPerf.dsAvgGain = dslhal_support_byteSwap32(phyPerf.dsAvgGain);
+  ptidsl->AppData.dsTxPower = LOG43125 + phyPerf.dsAvgGain + (256*((2*(dsPowerCutBack-1))-52)) + log10[dsNumLoadedTones-1];
+  dprintf(7,"Avg Gain: %d  dsNumLoadedTones: %d  log: %d  pcb: %d \n",phyPerf.dsAvgGain, dsNumLoadedTones, log10[dsNumLoadedTones-1], dsPowerCutBack);
+  /* ds bit allocation */
+  sharedTables.bitAllocTblDstrm_p = (unsigned char *)dslhal_support_byteSwap32((unsigned int)sharedTables.bitAllocTblDstrm_p);
+  rc = dslhal_support_blockRead((PVOID)sharedTables.bitAllocTblDstrm_p,ptidsl->AppData.BitAllocTblDstrm, 256*sizeof(unsigned char));
+  if(rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed \n");
+      return;
+    }
+
+    /* us bit allocation */
+  sharedTables.bitAllocTblUstrm_p = (unsigned char *)dslhal_support_byteSwap32((unsigned int)sharedTables.bitAllocTblUstrm_p);
+  rc = dslhal_support_blockRead((PVOID)sharedTables.bitAllocTblUstrm_p,ptidsl->AppData.BitAllocTblUstrm, 32*sizeof(unsigned char));
+  if(rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed \n");
+      return;
+    }
+    /* margin per tone */
+  sharedTables.marginTblDstrm_p = (signed char *)dslhal_support_byteSwap32((unsigned int)sharedTables.marginTblDstrm_p);
+  rc = dslhal_support_blockRead((PVOID)sharedTables.marginTblDstrm_p,ptidsl->AppData.marginTblDstrm, 256*sizeof(signed char));
+  if(rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed \n");
+      return;
+    }
+  /* Read Configured Options */
+  dspOamSharedInterface.oamWriteNegoParams_p = (DEV_HOST_oamWrNegoParaDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.oamWriteNegoParams_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.oamWriteNegoParams_p, 
+                               &configParms, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+  else 
+    {
+      /* r-Msg1 */
+    ptidsl->AppData.StdMode = (unsigned int)configParms.stdMode;
+    if(configParms.stdMode == T1413_MODE)
+      ptidsl->AppData.StdMode = DSLTRAIN_T1413_MODE;
+    if(configParms.stdMode == GDMT_MODE)
+      ptidsl->AppData.StdMode = DSLTRAIN_GDMT_MODE; 
+    if(configParms.stdMode == MULTI_MODE)
+      ptidsl->AppData.StdMode = DSLTRAIN_MULTI_MODE; 
+
+    shim_osMoveMemory((void *)ptidsl->AppData.bRMsgs1, (void *)configParms.rMsgs1, 6*sizeof(char));
+    if((ptidsl->AppData.bRMsgs1[2] & 0x02) == 0x02) 
+      { 
+      dprintf(7,"Trellis!\n");
+      ptidsl->configFlag |= CONFIG_FLAG_TRELLIS;
+      }
+    else
+      ptidsl->configFlag &= ~CONFIG_FLAG_TRELLIS;  
+    if(ptidsl->AppData.bRMsgs1[2]&0x01)
+      ptidsl->configFlag |= CONFIG_FLAG_EC;
+    else
+      ptidsl->configFlag &= ~CONFIG_FLAG_EC;      
+    }
+    return;
+}
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_initStatistics()
+*
+*********************************************************************************************
+* DESCRIPTION: init statistical information of ax5 modem daugter card. 
+*
+* Input: tidsl_t *ptidsl
+* 
+* Return: NULL
+*         
+********************************************************************************************/
+void dslhal_api_initStatistics(tidsl_t * ptidsl)
+{
+  int rc;
+  /*TCHostCommDef TCHostCommParms; */
+  int optIdxU, optIdxD;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  DEV_HOST_dspWrNegoParaDef_t   rateparms;
+  DEV_HOST_modemStatsDef_t      StatisticsDef;
+  DEV_HOST_errorStats_t usIntlvError, usFastError, dsIntlvError, dsFastError;
+  DEV_HOST_atmStats_t           atmStats;
+  DEV_HOST_usAtmStats_t         usAtmStats0, usAtmStats1;
+  DEV_HOST_dsAtmStats_t         dsAtmStats0,dsAtmStats1;
+  DEV_HOST_dspWrSuperFrameCntDef_t   SuperFrameCnt;
+  DEV_HOST_msg_t                atuc_msg, aturMsg;
+  DEV_HOST_eocVarDef_t          eocVar;
+  
+  dprintf(5, "dslhal_api_initStatistics\n");
+  
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterface_t *) ptidsl->pmainAddr;
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+  dspOamSharedInterface.dspWriteNegoParams_p = (DEV_HOST_dspWrNegoParaDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.dspWriteNegoParams_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.dspWriteNegoParams_p,&rateparms, sizeof(DEV_HOST_dspWrNegoParaDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+  if(!rc) 
+    {
+      /*    shim_osMoveMemory((void *)ptidsl->AppData.bCRates1, (void *)rateparms.cRates1, SIZE_OF_CRATES1_TABLE); */
+    ptidsl->AppData.bCRates2 = rateparms.cRates2;
+    /*    shim_osMoveMemory((void *)ptidsl->AppData.bRRates1, (void *)rateparms.rRates1, 44); */
+    ptidsl->AppData.bRRates2 = rateparms.rRates2;
+    shim_osMoveMemory((void *)ptidsl->AppData.bCMsgs1, (void *)rateparms.cMsgs1, 6);
+    shim_osMoveMemory((void *)ptidsl->AppData.bCMsgs2, (void *)rateparms.cMsgs2, 4);
+    shim_osMoveMemory((void *)ptidsl->AppData.bRMsgs2, (void *)rateparms.rMsgs2, 4); 
+    
+    ptidsl->AppData.atucVendorId = dslhal_support_byteSwap32((unsigned int)rateparms.atucVendorId);
+    ptidsl->AppData.lineLength = (unsigned int)dslhal_support_byteSwap16((unsigned short)rateparms.lineLength);
+    ptidsl->AppData.atucRevisionNum = rateparms.atucGhsRevisionNum;
+    ptidsl->AppData.usLineAttn = (ptidsl->AppData.bCMsgs2[3] >>2)&0x003f;
+    ptidsl->AppData.usMargin = (ptidsl->AppData.bCMsgs2[2])&0x001f;
+    
+    /* Get the UpStream Connection Rate */
+    /* Based on the Bit Pattern Get the Opt# */
+    if((rateparms.cRates2 & 0x0f) == 0x01) 
+      optIdxU = 0;
+    else if((rateparms.cRates2 & 0x0f) == 0x02)  
+      optIdxU = 1;
+    else if((rateparms.cRates2 & 0x0f) == 0x04) 
+      optIdxU = 2;
+    else if((rateparms.cRates2 & 0x0f) == 0x08)  
+      optIdxU = 3;
+    else 
+      optIdxU = -1;
+    dprintf(5, "optIdxU=%d\n", optIdxU);
+    /* Obtain the US Rates using Opt# and CRates1 Table */
+    /* Rate(US) = [Bf(LS0) + Bi(LS0)]*32                */
+    if(ptidsl->AppData.dsl_modulation <= DSLTRAIN_GLITE_MODE)
+      ptidsl->AppData.USConRate = ((rateparms.cRates1[optIdxU][CRATES1_BF_LS0] + rateparms.cRates1[optIdxU][CRATES1_BI_LS0]) * 32);
+    else
+      ptidsl->AppData.USConRate =  dslhal_support_byteSwap16((unsigned short)rateparms.adsl2USRate);
+    ptidsl->AppData.USPeakCellRate = ptidsl->AppData.USConRate; 
+    
+    /* Get the DownStream Connection Rate */
+    /* Based on the Bit Pattern Get the Opt# */
+    if(((rateparms.cRates2 >> 4) & 0x0f) == 0x01) 
+      optIdxD = 0;
+    else if(((rateparms.cRates2 >> 4) & 0x0f) == 0x02)  
+      optIdxD = 1;
+    else if(((rateparms.cRates2 >> 4) & 0x0f) == 0x04) 
+      optIdxD = 2;
+    else if(((rateparms.cRates2 >> 4) & 0x0f) == 0x08)  
+      optIdxD = 3;
+    else 
+      optIdxD = -1;
+    /* Obtain the DS Rates using Opt# and CRates1 Table */
+    /* Rate(DS) = [Bf(AS0) + Bi(AS0)]*32                */
+    if(ptidsl->AppData.dsl_modulation <= DSLTRAIN_GLITE_MODE)
+      ptidsl->AppData.DSConRate =  (((rateparms.cRates1[optIdxD][CRATES1_BF_AS0]|((rateparms.cRates1[optIdxD][CRATES1_BF_DSRS]&0x80)<<1))+ (rateparms.cRates1[optIdxD][CRATES1_BI_AS0]|((rateparms.cRates1[optIdxD][CRATES1_BI_DSRS]&0x80)<<1)))* 32);
+    else
+      ptidsl->AppData.DSConRate =  dslhal_support_byteSwap16((unsigned short)rateparms.adsl2DSRate);
+    dprintf(5, "ptidsl->AppData.wDSConRate=%d\n", ptidsl->AppData.DSConRate);
+    /* Determine which Path has Modem Trained with */
+    if((rateparms.cRates1[optIdxU][CRATES1_BF_LS0]) && (rateparms.cRates1[optIdxD][CRATES1_BF_AS0]))
+      ptidsl->AppData.TrainedPath = FAST_PATH;
+    else
+      ptidsl->AppData.TrainedPath = INTERLEAVED_PATH;
+
+    /* Set the mode in which the modem is trained */
+    ptidsl->AppData.TrainedMode = (unsigned int)rateparms.trainMode;
+    if(rateparms.trainMode == T1413_MODE)
+      ptidsl->AppData.TrainedMode = DSLTRAIN_T1413_MODE;
+    if(rateparms.trainMode == GDMT_MODE)
+      ptidsl->AppData.TrainedMode = DSLTRAIN_GDMT_MODE;
+
+    if(ptidsl->AppData.TrainedPath == FAST_PATH)
+       ptidsl->AppData.dsFastParityBytesPerSymbol = (rateparms.cRates1[optIdxU][CRATES1_BF_DSRS]&0x1f);
+    else
+       ptidsl->AppData.dsIntlvParityBytesPerSymbol = (rateparms.cRates1[optIdxU][CRATES1_BI_DSRS]&0x1f);
+    ptidsl->AppData.dsSymbolsPerCodeWord = (rateparms.cRates1[optIdxU][CRATES1_BFI_DSS]&0x1f);
+    ptidsl->AppData.dsInterleaverDepth = ((rateparms.cRates1[optIdxU][CRATES1_BFI_DSI])|((rateparms.cRates1[optIdxU][CRATES1_BFI_DSS]&0xc0)<<2));
+
+    if(ptidsl->AppData.TrainedPath == FAST_PATH)
+       ptidsl->AppData.usFastParityBytesPerSymbol = (rateparms.cRates1[optIdxU][CRATES1_BF_USRS]&0x1f);
+    else
+       ptidsl->AppData.usIntlvParityBytesPerSymbol = (rateparms.cRates1[optIdxU][CRATES1_BI_USRS]&0x1f);
+    ptidsl->AppData.usSymbolsPerCodeWord = (rateparms.cRates1[optIdxU][CRATES1_BFI_USS]&0x1f);
+    ptidsl->AppData.usInterleaverDepth = ((rateparms.cRates1[optIdxU][CRATES1_BFI_USI])|((rateparms.cRates1[optIdxU][CRATES1_BFI_USS]&0xc0)<<2));
+    }
+  
+  /* get the Statistics itself */
+
+  dspOamSharedInterface.modemStats_p = (DEV_HOST_modemStatsDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.modemStats_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.modemStats_p,&StatisticsDef, sizeof(DEV_HOST_modemStatsDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return;
+    }
+
+  /* Populate the Error Structure Variables */
+
+  /* US Interleave Path Error Statistics */
+
+  /* Change the endianness of the Pointer */
+  StatisticsDef.usErrorStatsIntlv_p = (DEV_HOST_errorStats_t *) dslhal_support_byteSwap32((unsigned int)StatisticsDef.usErrorStatsIntlv_p);
+
+  rc = dslhal_support_blockRead((PVOID)StatisticsDef.usErrorStatsIntlv_p,&usIntlvError, (sizeof(DEV_HOST_errorStats_t)));
+  
+  if (rc) 
+    return;
+
+  /* DS Interleave Path Error Statistics */
+
+  /* Change the endianness of the Pointer */
+  StatisticsDef.dsErrorStatsIntlv_p = (DEV_HOST_errorStats_t *) dslhal_support_byteSwap32((unsigned int)StatisticsDef.dsErrorStatsIntlv_p);
+
+  rc = dslhal_support_blockRead((PVOID)StatisticsDef.dsErrorStatsIntlv_p,&dsIntlvError, (sizeof(DEV_HOST_errorStats_t)));
+  
+  if (rc) 
+    return;
+
+  /* US Fast Path Error Statistics */
+
+  /* Change the endianness of the Pointer */
+  StatisticsDef.usErrorStatsFast_p = (DEV_HOST_errorStats_t *) dslhal_support_byteSwap32((unsigned int)StatisticsDef.usErrorStatsFast_p);
+
+  rc = dslhal_support_blockRead((PVOID)StatisticsDef.usErrorStatsFast_p,&usFastError, (sizeof(DEV_HOST_errorStats_t)));
+  
+  if (rc) 
+    return;
+
+
+  /* DS Fast Path Error Statistics */
+
+  /* Change the endianness of the Pointer */
+  StatisticsDef.dsErrorStatsFast_p = (DEV_HOST_errorStats_t *) dslhal_support_byteSwap32((unsigned int)StatisticsDef.dsErrorStatsFast_p);
+
+  rc = dslhal_support_blockRead((PVOID)StatisticsDef.dsErrorStatsFast_p,&dsFastError, (sizeof(DEV_HOST_errorStats_t)));
+  
+  if (rc) 
+    return;
+
+  if(ptidsl->AppData.bState > 2)
+  {
+    /* Get CRC Errors Stats for both US and DS */
+    ptidsl->AppData.dsICRC_errors   = dslhal_support_byteSwap32((unsigned int)dsIntlvError.crcErrors);
+    ptidsl->AppData.dsFCRC_errors   = dslhal_support_byteSwap32((unsigned int)dsFastError.crcErrors);
+    ptidsl->AppData.usICRC_errors   = dslhal_support_byteSwap32((unsigned int)usIntlvError.crcErrors);
+    ptidsl->AppData.usFCRC_errors   = dslhal_support_byteSwap32((unsigned int)usFastError.crcErrors);
+    /* Get FEC Errors Stats for both US and DS */
+    ptidsl->AppData.dsIFEC_errors   = dslhal_support_byteSwap32((unsigned int)dsIntlvError.fecErrors);
+    ptidsl->AppData.dsFFEC_errors   = dslhal_support_byteSwap32((unsigned int)dsFastError.fecErrors);
+    ptidsl->AppData.usIFEC_errors   = dslhal_support_byteSwap32((unsigned int)usIntlvError.fecErrors);
+    ptidsl->AppData.usFFEC_errors   = dslhal_support_byteSwap32((unsigned int)usFastError.fecErrors);
+    /* Get NCD Errors Stats for both US and DS */
+    ptidsl->AppData.dsINCD_error   = dslhal_support_byteSwap32((unsigned int)dsIntlvError.ncdError);
+    ptidsl->AppData.dsFNCD_error   = dslhal_support_byteSwap32((unsigned int)dsFastError.ncdError);
+    ptidsl->AppData.usINCD_error   = dslhal_support_byteSwap32((unsigned int)usIntlvError.ncdError);
+    ptidsl->AppData.usFNCD_error   = dslhal_support_byteSwap32((unsigned int)usFastError.ncdError);
+    /* Get LCD Errors Stats for both US and DS */
+    ptidsl->AppData.dsILCD_errors   = dslhal_support_byteSwap32((unsigned int)dsIntlvError.lcdErrors);
+    ptidsl->AppData.dsFLCD_errors   = dslhal_support_byteSwap32((unsigned int)dsFastError.lcdErrors);
+    ptidsl->AppData.usILCD_errors   = dslhal_support_byteSwap32((unsigned int)usIntlvError.lcdErrors);
+    ptidsl->AppData.usFLCD_errors   = dslhal_support_byteSwap32((unsigned int)usFastError.lcdErrors);
+    /*Get HEC Errors Stats for both US and DS */
+    ptidsl->AppData.dsIHEC_errors   = dslhal_support_byteSwap32((unsigned int)dsIntlvError.hecErrors);
+    ptidsl->AppData.dsFHEC_errors   = dslhal_support_byteSwap32((unsigned int)dsFastError.hecErrors);
+    ptidsl->AppData.usIHEC_errors   = dslhal_support_byteSwap32((unsigned int)usIntlvError.hecErrors);
+    ptidsl->AppData.usFHEC_errors   = dslhal_support_byteSwap32((unsigned int)usFastError.hecErrors);
+    
+    /* Get LOS and SEF error Stats */
+    ptidsl->AppData.LOS_errors      = dslhal_support_byteSwap32(StatisticsDef.losErrors);              
+    ptidsl->AppData.SEF_errors      = dslhal_support_byteSwap32(StatisticsDef.sefErrors);
+    ptidsl->AppData.coLosErrors = dslhal_support_byteSwap32(StatisticsDef.farEndLosErrors);
+    ptidsl->AppData.coRdiErrors = dslhal_support_byteSwap32(StatisticsDef.farEndRdiErrors);    
+    
+    dspOamSharedInterface.atmStats_p = (DEV_HOST_atmStats_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.atmStats_p);
+    
+    rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.atmStats_p,&atmStats, sizeof(DEV_HOST_atmStats_t));
+    
+    if (rc)
+      {
+        dprintf(1,"dslhal_support_blockRead failed\n");
+        return;
+      }
+
+    /* Populate the US/DS ATM Stats Variables */
+    
+    /* US ATM Statistics */
+
+    /* Change the endianness of the Pointer */
+    atmStats.us0_p = (DEV_HOST_usAtmStats_t *) dslhal_support_byteSwap32((unsigned int)atmStats.us0_p);
+    
+    rc = dslhal_support_blockRead((PVOID)atmStats.us0_p,&usAtmStats0, (sizeof(DEV_HOST_usAtmStats_t)));
+                                       
+    if (rc) 
+     return;
+
+    /* Change the endianness of the Pointer */
+    atmStats.us1_p = (DEV_HOST_usAtmStats_t *) dslhal_support_byteSwap32((unsigned int)atmStats.us1_p);
+    
+    rc = dslhal_support_blockRead((PVOID)atmStats.us1_p,&usAtmStats1, (sizeof(DEV_HOST_usAtmStats_t)));
+                                       
+    if (rc) 
+     return;
+
+
+  /* DS ATM Statistics */
+                                       
+  /* Change the endianness of the Pointer */
+    atmStats.ds0_p = (DEV_HOST_dsAtmStats_t *) dslhal_support_byteSwap32((unsigned int)atmStats.ds0_p);
+    
+    rc = dslhal_support_blockRead((PVOID)atmStats.ds0_p,&dsAtmStats0, (sizeof(DEV_HOST_dsAtmStats_t)));
+                                       
+    if (rc) 
+    return;
+
+  /* Change the endianness of the Pointer */
+    atmStats.ds1_p = (DEV_HOST_dsAtmStats_t *) dslhal_support_byteSwap32((unsigned int)atmStats.ds1_p);
+    
+    rc = dslhal_support_blockRead((PVOID)atmStats.ds1_p,&dsAtmStats1, (sizeof(DEV_HOST_dsAtmStats_t)));
+                                       
+    if (rc) 
+    return;
+    /* Get ATM Stats for both US and DS Channel 0*/
+    ptidsl->AppData.usAtm_count[0]     = dslhal_support_byteSwap32(usAtmStats0.goodCount);
+    ptidsl->AppData.usIdle_count[0]    = dslhal_support_byteSwap32(usAtmStats0.idleCount);
+#if SWTC
+    ptidsl->AppData.usPdu_count[0]     = dslhal_support_byteSwap32(usAtmStats0.pduCount);
+#endif
+    ptidsl->AppData.dsGood_count[0]    = dslhal_support_byteSwap32(dsAtmStats0.goodCount);
+    ptidsl->AppData.dsIdle_count[0]    = dslhal_support_byteSwap32(dsAtmStats0.idleCount);
+#if SWTC
+    ptidsl->AppData.dsPdu_count[0]     = dslhal_support_byteSwap32(dsAtmStats0.pduCount);
+#endif
+    ptidsl->AppData.dsBadHec_count[0]  = dslhal_support_byteSwap32((dsAtmStats0.badHecCount));
+    ptidsl->AppData.dsOVFDrop_count[0] = dslhal_support_byteSwap32((dsAtmStats0.ovflwDropCount));
+
+    /* Get ATM Stats for both US and DS Channel 1*/
+    ptidsl->AppData.usAtm_count[1]     = dslhal_support_byteSwap32(usAtmStats1.goodCount);
+    ptidsl->AppData.usIdle_count[1]    = dslhal_support_byteSwap32(usAtmStats1.idleCount);
+#if SWTC
+    ptidsl->AppData.usPdu_count[1]     = dslhal_support_byteSwap32(usAtmStats1.pduCount);
+#endif
+    ptidsl->AppData.dsGood_count[1]    = dslhal_support_byteSwap32(dsAtmStats1.goodCount);
+    ptidsl->AppData.dsIdle_count[1]    = dslhal_support_byteSwap32(dsAtmStats1.idleCount);
+#if SWTC
+    ptidsl->AppData.dsPdu_count[1]     = dslhal_support_byteSwap32(dsAtmStats1.pduCount);
+#endif
+    ptidsl->AppData.dsBadHec_count[1]  = dslhal_support_byteSwap32((dsAtmStats1.badHecCount));
+    ptidsl->AppData.dsOVFDrop_count[1] = dslhal_support_byteSwap32((dsAtmStats1.ovflwDropCount));
+
+    
+    /* Determine the US and DS Superframe Count */
+
+    dspOamSharedInterface.dspWriteSuperFrameCnt_p = (DEV_HOST_dspWrSuperFrameCntDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.dspWriteSuperFrameCnt_p);
+    
+    rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.dspWriteSuperFrameCnt_p,&SuperFrameCnt, sizeof(DEV_HOST_dspWrSuperFrameCntDef_t));
+    
+    if (rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return;
+    }
+
+    ptidsl->AppData.usSuperFrmCnt   = dslhal_support_byteSwap32(SuperFrameCnt.wSuperFrameCntUstrm);
+    ptidsl->AppData.dsSuperFrmCnt   = dslhal_support_byteSwap32(SuperFrameCnt.wSuperFrameCntDstrm);
+    
+    /* Determine Frame Mode and Max Frame Mode */
+    
+    dspOamSharedInterface.atucMsg_p = (DEV_HOST_msg_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.atucMsg_p);
+    
+    rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.atucMsg_p,&atuc_msg, sizeof(DEV_HOST_msg_t));
+  
+    if (rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return;
+    }
+
+    ptidsl->AppData.FrmMode         = (unsigned int)atuc_msg.framingMode;
+    ptidsl->AppData.MaxFrmMode      = (unsigned int)atuc_msg.maxFrameMode;
+    
+    /* Determine Gross Gain */
+
+    dspOamSharedInterface.aturMsg_p = (DEV_HOST_msg_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.aturMsg_p);
+
+    rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.aturMsg_p,&aturMsg, sizeof(DEV_HOST_msg_t));
+  
+    if (rc)
+      {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return;
+      }
+    ptidsl->AppData.grossGain = (unsigned int)aturMsg.grossGain;
+    /* Determine DS Line Attenuation & Margin */
+    dspOamSharedInterface.eocVar_p = (DEV_HOST_eocVarDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.eocVar_p);
+    
+    rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.eocVar_p,&eocVar, sizeof(DEV_HOST_eocVarDef_t));
+    
+    if (rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return;
+    }
+
+    ptidsl->AppData.dsLineAttn      = (unsigned int)eocVar.lineAtten;
+    ptidsl->AppData.dsMargin        = (unsigned int)eocVar.dsMargin;
+    }
+    
+#if __HOST_FORINTERNALUSEONLY_R_H__
+  ptidsl->AppData.BER =  dslhal_INTERNAL_computeAtmBitErrorRate(ptidsl);
+#endif
+    dprintf(5, "initstatistics done\n");
+    return;
+  }
+
+/****************************************************************************************** 
+ * FUNCTION NAME:    dslhal_api_disableLosAlarm(tidsl_t *ptidsl,unsigned int set) 
+ * 
+ ******************************************************************************************* 
+ * DESCRIPTION: This fuction enables/disables all the LOS alarms 
+ * 
+ * INPUT:  PITIDSLHW_T *ptidsl 
+ *         unsigned int set; //if set is TRUE: LOS Alarms are disabled else enabled
+ * RETURN: 0 SUCCESS 
+ *         1 FAILED 
+ * NOTES:  Currently not supported in any version other than MR4 Patch release..  
+ *****************************************************************************************/ 
+unsigned int dslhal_api_disableLosAlarm(tidsl_t *ptidsl,unsigned int set) 
+{ 
+   DEV_HOST_oamWrNegoParaDef_t NegoPara;
+   DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+   int rc;
+   dprintf(5," dslhal_api_setTrainingMode()\n");
+   if(!ptidsl)
+    {
+      dprintf(3, "Error: PTIDSL pointer invalid\n");
+      return DSLHAL_ERROR_INVALID_PARAM;
+    }
+
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface, 
+                                     sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+
+  dspOamSharedInterface.oamWriteNegoParams_p = (DEV_HOST_oamWrNegoParaDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.oamWriteNegoParams_p);
+
+   rc = dslhal_support_blockRead((PVOID) dspOamSharedInterface.oamWriteNegoParams_p,&NegoPara, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  if(set) 
+    {
+   NegoPara.disableLosAlarm = TRUE;
+   /*  NegoPara.marginMonitorTrning = TRUE;
+       NegoPara.marginMonitorShwtme = TRUE;*/
+    } 
+  else
+    {
+    NegoPara.disableLosAlarm = FALSE;
+    /*  NegoPara.marginMonitorTrning = FALSE;
+        NegoPara.marginMonitorShwtme = FALSE;*/
+    }
+
+  rc = dslhal_support_blockWrite(&NegoPara,(PVOID)dspOamSharedInterface.oamWriteNegoParams_p, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+  if(rc)
+    return DSLHAL_ERROR_CONFIG_API_FAILURE;
+  dprintf(5," dslhal_api_disableLosAlarm() Done\n"); 
+  return DSLHAL_ERROR_NO_ERRORS; 
+} 
+
+/******************************************************************************************  
+ * FUNCTION NAME:    dslhal_api_setMarginThreshold(tidsl_t *ptidsl,int threshold)  
+ *  
+ *******************************************************************************************  
+ * DESCRIPTION: This fuction does sets the Margin threshold 
+ *  
+ * INPUT:  PITIDSLHW_T *ptidsl  
+ *         int threshold 
+ *        
+ *                                  
+ * RETURN: 0 SUCCESS  
+ *         1 FAILED  
+ *  
+ *****************************************************************************************/  
+unsigned int dslhal_api_setMarginThreshold(tidsl_t *ptidsl, int threshold)  
+{  
+   DEV_HOST_oamWrNegoParaDef_t NegoPara;  
+   DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+   int rc;  
+   
+   dprintf(5," dslhal_ctrl_setThreshold()\n");  
+    
+   if(!ptidsl)  
+     {  
+      dprintf(3, "Error: PTIDSL pointer invalid\n");  
+      return DSLHAL_ERROR_INVALID_PARAM;  
+     }  
+  
+   pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+
+  dspOamSharedInterface.oamWriteNegoParams_p = (DEV_HOST_oamWrNegoParaDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.oamWriteNegoParams_p);
+
+
+   rc = dslhal_support_blockRead((PVOID) dspOamSharedInterface.oamWriteNegoParams_p,&NegoPara, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+
+  NegoPara.marginThreshold = threshold;
+  
+  rc = dslhal_support_blockWrite(&NegoPara,dspOamSharedInterface.oamWriteNegoParams_p, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+
+  if(rc)
+    return DSLHAL_ERROR_MARGIN_API_FAILURE;
+
+  dprintf(5," dslhal_api_setThreshold() Done\n");  
+  return DSLHAL_ERROR_NO_ERRORS;  
+}  
+
+
+/****************************************************************************************** 
+ * FUNCTION NAME:    dslhal_api_setMonitorFlags(tidsl_t *ptidsl, unsigned int trainflag,unsigned int shwtflag) 
+ * 
+ ******************************************************************************************* 
+ * DESCRIPTION: This fuction does sets the Margin monitoring flag
+ * 
+ * INPUT:  PITIDSLHW_T *ptidsl 
+ *         unsigned int trainflag
+ *         unsigned int shwtflag 
+ *                                 
+ * RETURN: 0 SUCCESS 
+ *         1 FAILED 
+ * 
+ *****************************************************************************************/ 
+unsigned int dslhal_api_setMarginMonitorFlags(tidsl_t *ptidsl,unsigned int trainflag,unsigned int shwtflag) 
+{ 
+   DEV_HOST_oamWrNegoParaDef_t NegoPara; 
+   DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+   int rc; 
+  
+   dprintf(5," dslhal_ctrl_setMonitorFlags()\n"); 
+   
+   if(!ptidsl) 
+     { 
+      dprintf(3, "Error: PTIDSL pointer invalid\n"); 
+      return DSLHAL_ERROR_INVALID_PARAM; 
+     } 
+
+   pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+
+  dspOamSharedInterface.oamWriteNegoParams_p = (DEV_HOST_oamWrNegoParaDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.oamWriteNegoParams_p);
+
+
+   rc = dslhal_support_blockRead((PVOID) dspOamSharedInterface.oamWriteNegoParams_p,&NegoPara, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+
+  if (trainflag) 
+    { 
+        NegoPara.marginMonitorTrning = TRUE; 
+    } 
+  else 
+    { 
+        NegoPara.marginMonitorTrning = FALSE; 
+    } 
+  if (shwtflag) 
+    { 
+        NegoPara.marginMonitorShwtme = TRUE; 
+    } 
+  else 
+    { 
+        NegoPara.marginMonitorShwtme = FALSE; 
+    } 
+ 
+  rc = dslhal_support_blockWrite(&NegoPara,dspOamSharedInterface.oamWriteNegoParams_p, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+    if(rc)
+      return DSLHAL_ERROR_MARGIN_API_FAILURE;
+  dprintf(5," dslhal_api_setMonitorFlags() Done\n"); 
+  return DSLHAL_ERROR_NO_ERRORS; 
+} 
+
+/******************************************************************************************  
+ * FUNCTION NAME:    dslhal_api_setEocSerialNumber(tidsl_t *ptidsl,char *SerialNum)  
+ *  
+ *******************************************************************************************  
+ * DESCRIPTION: This fuction Sets the eoc Serial Number  
+ *  
+ * INPUT:  PITIDSLHW_T *ptidsl  
+ *         char *SerialNum : Input eoc Serial Number
+ *  
+ * RETURN: 0 SUCCESS  
+ *         1 FAILED  
+ *  
+ *****************************************************************************************/  
+unsigned int dslhal_api_setEocSerialNumber(tidsl_t *ptidsl,char *SerialNumber)  
+{  
+   DEV_HOST_eocVarDef_t eocVar;
+   DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+   int rc;  
+   dprintf(5," dslhal_api_setEocSerialNumber()\n");  
+ 
+   if(!ptidsl) 
+     { 
+      dprintf(3, "Error: PTIDSL pointer invalid\n"); 
+      return DSLHAL_ERROR_INVALID_PARAM; 
+     } 
+
+   pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+
+  dspOamSharedInterface.eocVar_p = (DEV_HOST_eocVarDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.eocVar_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.eocVar_p, 
+                               &eocVar, sizeof(DEV_HOST_eocVarDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+   
+  shim_osMoveMemory(eocVar.serialNumber,SerialNumber,32); 
+
+  rc= dslhal_support_blockWrite(&eocVar,dspOamSharedInterface.eocVar_p,sizeof(DEV_HOST_eocVarDef_t)); 
+    if(rc)
+      return DSLHAL_ERROR_EOCREG_API_FAILURE;
+  dprintf(5," dslhal_api_setEocSerialNumber() Done\n");  
+   
+  return DSLHAL_ERROR_NO_ERRORS;
+  
+}  
+
+
+/****************************************************************************************** 
+ * FUNCTION NAME:    dslhal_api_setEocVendorId(tidsl_t *ptidsl,char *VendorID) 
+ * 
+ ******************************************************************************************* 
+ * DESCRIPTION: This fuction Sets the eoc Vendor ID 
+ * 
+ * INPUT:  PITIDSLHW_T *ptidsl 
+ *         char *VendorID : Input eoc Vendor ID
+ * 
+ * RETURN: 0 SUCCESS 
+ *         1 FAILED 
+ * 
+ *****************************************************************************************/ 
+unsigned int dslhal_api_setEocVendorId(tidsl_t *ptidsl,char *VendorID) 
+{ 
+  DEV_HOST_oamWrNegoParaDef_t NegoPara;  
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  int rc; 
+  dprintf(5," dslhal_api_setEocVendorId()\n"); 
+
+  if(!ptidsl) 
+    { 
+      dprintf(3, "Error: PTIDSL pointer invalid\n"); 
+      return DSLHAL_ERROR_INVALID_PARAM; 
+    }   
+  
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+  
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return DSLHAL_ERROR_BLOCK_READ;
+    }
+
+  dspOamSharedInterface.oamWriteNegoParams_p = (DEV_HOST_oamWrNegoParaDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.oamWriteNegoParams_p);
+
+
+   rc = dslhal_support_blockRead((PVOID) dspOamSharedInterface.oamWriteNegoParams_p,&NegoPara, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  
+  shim_osMoveMemory(NegoPara.gdmtVendorId,VendorID,8);
+  rc= dslhal_support_blockWrite(&NegoPara,dspOamSharedInterface.oamWriteNegoParams_p, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+    if(rc)
+      return DSLHAL_ERROR_EOCREG_API_FAILURE;
+  
+  dprintf(5," dslhal_api_setEocVendorId() Done\n"); 
+  return DSLHAL_ERROR_NO_ERRORS; 
+} 
+
+/******************************************************************************************   
+ * FUNCTION NAME:    dslhal_api_setEocRevisionNumber(tidsl_t *ptidsl,char *RevNum)   
+ *   
+ *******************************************************************************************   
+ * DESCRIPTION: This fuction Sets the eoc Revision Number   
+ *   
+ * INPUT:  PITIDSLHW_T *ptidsl   
+ *         char *RevNum : Input eoc Revision Number 
+ *   
+ * RETURN: 0 SUCCESS   
+ *         1 FAILED   
+ *   
+ *****************************************************************************************/   
+unsigned int dslhal_api_setEocRevisionNumber(tidsl_t *ptidsl,char *RevNumber)   
+{   
+
+   DEV_HOST_eocVarDef_t eocVar;
+   DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+   int rc;  
+   /*add for UR2 test */
+   UINT8        selfTestResults[2];
+   memset(selfTestResults,0x00,sizeof(selfTestResults));
+   /* add for UR2 test */
+   dprintf(5," dslhal_api_setEocRevisionNumber()\n");   
+   
+  if(!ptidsl)  
+     {  
+      dprintf(3, "Error: PTIDSL pointer invalid\n");  
+      return DSLHAL_ERROR_INVALID_PARAM;  
+     }  
+
+   pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+     dprintf(1,"dslhal_support_blockRead failed\n");
+     return DSLHAL_ERROR_BLOCK_READ;
+     }
+
+  dspOamSharedInterface.eocVar_p = (DEV_HOST_eocVarDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.eocVar_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.eocVar_p, 
+                               &eocVar, sizeof(DEV_HOST_eocVarDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  shim_osMoveMemory(eocVar.revNumber,RevNumber,4);
+  /* add for UR2 test */
+  shim_osMoveMemory(eocVar.dummy,selfTestResults,2);
+  /* add for UR2 test */
+  rc=dslhal_support_blockWrite(&eocVar,dspOamSharedInterface.eocVar_p,sizeof(DEV_HOST_eocVarDef_t)); 
+    if(rc)
+      return DSLHAL_ERROR_EOCREG_API_FAILURE;
+  dprintf(5," dslhal_api_setEocRevisionNumber Done\n");   
+  return DSLHAL_ERROR_NO_ERRORS;   
+}   
+
+/******************************************************************************************      
+ * FUNCTION NAME:    dslhal_api_setAturConfig(tidsl_t *ptidsl,char *ATURConfig)      
+ *      
+ *******************************************************************************************      
+ * DESCRIPTION: This fuction Sets the eoc ATUR Config Register  
+ *      
+ * INPUT:  PITIDSLHW_T *ptidsl      
+ *         char *ATURConfig : Input eoc ATUR Config Register    
+ *      
+ * RETURN: 0 SUCCESS      
+ *         1 FAILED      
+ *      
+ *****************************************************************************************/      
+unsigned int dslhal_api_setAturConfig(tidsl_t *ptidsl,char *ATURConfig)
+{    
+
+  DEV_HOST_eocVarDef_t eocVar;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  int rc;  
+  dprintf(5," dslhal_api_setAturConfig()\n");    
+
+  if(!ptidsl)  
+     {  
+      dprintf(3, "Error: PTIDSL pointer invalid\n");  
+      return DSLHAL_ERROR_INVALID_PARAM;  
+     }  
+
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+  
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  
+  dspOamSharedInterface.eocVar_p = (DEV_HOST_eocVarDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.eocVar_p);
+  
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.eocVar_p,
+                                     &eocVar, sizeof(DEV_HOST_eocVarDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }  
+     shim_osMoveMemory(eocVar.aturConfig,ATURConfig,30);
+   rc= dslhal_support_blockWrite(&eocVar,dspOamSharedInterface.eocVar_p,sizeof(DEV_HOST_eocVarDef_t)); 
+    if(rc)
+      return DSLHAL_ERROR_EOCREG_API_FAILURE;
+  dprintf(5," dslhal_api_setAturConfig() Done\n");    
+  return DSLHAL_ERROR_NO_ERRORS;   
+}
+
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_setRateAdaptFlag(tidsl_t *ptidsl,unsigned int flag)
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction Sets the Rate Adapt Enable Flag
+*
+* INPUT:  PITIDSLHW_T *ptidsl
+*         unsigned int flag; //if flag = TRUE set rateadapt flag else reset it
+* RETURN: 0 SUCCESS
+*         1 FAILED
+*
+*****************************************************************************************/
+unsigned int dslhal_api_setRateAdaptFlag(tidsl_t *ptidsl,unsigned int flag)
+{
+   DEV_HOST_msg_t aturMsg;
+   DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+   int rc;
+   dprintf(5," dslhal_api_setRateAdaptFlag()\n");
+   
+  if(!ptidsl)  
+     {  
+      dprintf(3, "Error: PTIDSL pointer invalid\n");  
+      return DSLHAL_ERROR_INVALID_PARAM;  
+     }  
+
+   pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   dspOamSharedInterface.aturMsg_p = (DEV_HOST_msg_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.aturMsg_p);
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.aturMsg_p,
+                                      &aturMsg, sizeof(DEV_HOST_msg_t));
+   if (rc)
+     {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   if(flag)
+     aturMsg.rateAdapt = TRUE;
+   else
+     aturMsg.rateAdapt = FALSE;
+   
+   rc= dslhal_support_blockWrite(&aturMsg,dspOamSharedInterface.aturMsg_p,sizeof(DEV_HOST_msg_t)); 
+   if(rc)
+     return DSLHAL_ERROR_CONFIG_API_FAILURE;
+   dprintf(5," dslhal_api_setRateAdaptFlag() Done\n");
+   return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_setTrellisFlag(tidsl_t *ptidsl,unsigned int flag)
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction Sets the Trellis Coding Enable Flag
+*
+* INPUT:  PITIDSLHW_T *ptidsl
+*         unsigned int flag;  // if flag = TRUE, set trellis flag else reset
+* RETURN: 0 SUCCESS
+*         1 FAILED
+*
+*****************************************************************************************/
+unsigned int dslhal_api_setTrellisFlag(tidsl_t *ptidsl,unsigned int flag)
+{
+
+   DEV_HOST_msg_t aturMsg;
+   DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+   DEV_HOST_oamWrNegoParaDef_t negoPara;
+   int rc;
+   dprintf(5," dslhal_api_setTrellisFlag()\n");   
+   if(!ptidsl)
+     {
+       dprintf(3, "Error: PTIDSL pointer invalid\n");
+       return DSLHAL_ERROR_INVALID_PARAM;
+     }
+   pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   dspOamSharedInterface.aturMsg_p = (DEV_HOST_msg_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.aturMsg_p);
+   rc += dslhal_support_blockRead((PVOID)dspOamSharedInterface.aturMsg_p,&aturMsg, sizeof(DEV_HOST_msg_t));
+   dspOamSharedInterface.oamWriteNegoParams_p = (DEV_HOST_oamWrNegoParaDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.oamWriteNegoParams_p);
+   rc += dslhal_support_blockRead((PVOID) dspOamSharedInterface.oamWriteNegoParams_p,&negoPara, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+
+  if(flag)
+    {
+      aturMsg.trellis = TRUE;
+      negoPara.rMsgs1[2] |= 0x02;
+    }
+  else
+    {
+      aturMsg.trellis = FALSE;
+      negoPara.rMsgs1[2] &= 0xFD;
+    }   
+  rc=0;
+  rc+=dslhal_support_blockWrite(&aturMsg,dspOamSharedInterface.aturMsg_p,sizeof(DEV_HOST_msg_t)); 
+  rc+= dslhal_support_blockWrite(&negoPara,dspOamSharedInterface.oamWriteNegoParams_p, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+  if(rc)
+     return DSLHAL_ERROR_CONFIG_API_FAILURE;
+
+  dprintf(5," dslhal_api_setTrellisFlag() Done\n");
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_setMaxBitsPerCarrier(tidsl_t *ptidsl,unsigned int maxbits)
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction Sets the Maximum bits per carrier value
+*
+* INPUT:  PITIDSLHW_T *ptidsl
+*         unsigned int maxbits : should be a value between 0-15
+*
+* RETURN: 0 SUCCESS
+*         1 FAILED
+*
+*****************************************************************************************/
+unsigned int dslhal_api_setMaxBitsPerCarrier(tidsl_t *ptidsl,unsigned int maxbits)
+{
+
+   DEV_HOST_msg_t aturMsg;
+   DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+   int rc;
+
+   dprintf(5," dslhal_api_setMaxBitsPerCarrier()\n");
+   if(maxbits>15)
+     {
+       dprintf(3,"Maximum Number of Bits per carrier cannot exceed 15!\n");
+       return DSLHAL_ERROR_INVALID_PARAM;
+     }
+
+   if(!ptidsl)
+    {
+      dprintf(3, "Error: PTIDSL pointer invalid\n");
+       return DSLHAL_ERROR_INVALID_PARAM;
+    }
+   pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   dspOamSharedInterface.aturMsg_p = (DEV_HOST_msg_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.aturMsg_p);
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.aturMsg_p,
+                                      &aturMsg, sizeof(DEV_HOST_msg_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+
+  aturMsg.maxBits = maxbits;
+   
+   rc=dslhal_support_blockWrite(&aturMsg,dspOamSharedInterface.aturMsg_p,sizeof(DEV_HOST_msg_t)); 
+   if(rc)
+     return DSLHAL_ERROR_CONFIG_API_FAILURE;
+   dprintf(5," dslhal_api_setMaxBitsPerCarrier() Done\n");
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_setMaxInterleaverDepth(tidsl_t *ptidsl,unsigned int maxdepth)
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction Sets the Maximum Interleave Depth Supported
+*
+* INPUT:  PITIDSLHW_T *ptidsl
+*         unsigned int maxdepth : Should be between 0 and 3 depending on intlv buffer
+*                                 size 64-512
+* RETURN: 0 SUCCESS
+*         1 FAILED
+*
+*****************************************************************************************/
+unsigned int dslhal_api_setMaxInterleaverDepth(tidsl_t *ptidsl,unsigned int maxdepth)
+{
+   DEV_HOST_msg_t aturMsg;
+   DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+   int rc;
+   dprintf(5," dslhal_api_setMaxInterleaverDepth()\n");
+   if(maxdepth>3)
+     {
+       dprintf(3,"Invalid Value for maximum interleave depth (must be <3)\n");
+       return DSLHAL_ERROR_INVALID_PARAM;
+     }
+
+   if(!ptidsl)
+    {
+      dprintf(3, "Error: PTIDSL pointer invalid\n");
+       return DSLHAL_ERROR_INVALID_PARAM;
+    }
+   pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   dspOamSharedInterface.aturMsg_p = (DEV_HOST_msg_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.aturMsg_p);
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.aturMsg_p,
+                                      &aturMsg, sizeof(DEV_HOST_msg_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+
+  aturMsg.maxIntlvDepth = maxdepth;
+   
+   rc=dslhal_support_blockWrite(&aturMsg,dspOamSharedInterface.aturMsg_p,sizeof(DEV_HOST_msg_t)); 
+   if(rc)
+     return DSLHAL_ERROR_CONFIG_API_FAILURE;
+   dprintf(5," dslhal_api_setMaxInterleaverDepth() Done\n");
+   return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_acknowledgeInterrupt()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_acknowledgeInterrupt(tidsl_t * ptidsl)
+{
+  unsigned int interruptSources=0;
+  /* Clear out the DSLSS Interrupt Registers to acknowledge Interrupt */
+  if(DSLHAL_REG32(dslhal_support_hostDspAddressTranslate(DSP_INTERRUPT_SOURCE_REGISTER))&MASK_MAILBOX_INTERRUPTS)
+    {
+      DSLHAL_REG32(dslhal_support_hostDspAddressTranslate(DSP_INTERRUPT_CLEAR_REGISTER))|=MASK_MAILBOX_INTERRUPTS;
+      dprintf(5,"Mailbox Interrupt \n");
+    }
+  if(DSLHAL_REG32(dslhal_support_hostDspAddressTranslate(DSP_INTERRUPT_SOURCE_REGISTER))&MASK_BITFIELD_INTERRUPTS)
+    {
+      DSLHAL_REG32(dslhal_support_hostDspAddressTranslate(DSP_INTERRUPT_CLEAR_REGISTER))|=MASK_BITFIELD_INTERRUPTS;
+      dprintf(5,"Bitfield Interrupt \n");
+    }
+  if(DSLHAL_REG32(dslhal_support_hostDspAddressTranslate(DSP_INTERRUPT_SOURCE_REGISTER))&MASK_HEARTBEAT_INTERRUPTS)
+    {
+      DSLHAL_REG32(dslhal_support_hostDspAddressTranslate(DSP_INTERRUPT_CLEAR_REGISTER))|=MASK_HEARTBEAT_INTERRUPTS;
+      dprintf(5,"HeartBeat Interrupt \n");
+    }
+  interruptSources = dslhal_support_parseInterruptSource(ptidsl);
+  if(interruptSources < 0)
+    return DSLHAL_ERROR_INTERRUPT_FAILURE;
+  else  
+    return interruptSources;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_disableDspHybridSelect()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_disableDspHybridSelect(tidsl_t * ptidsl,unsigned int disable)
+{
+  int rc;
+  DEV_HOST_phyPerf_t phyPerf;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   dspOamSharedInterface.phyPerf_p = (DEV_HOST_phyPerf_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.phyPerf_p);
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.phyPerf_p,
+                                      &phyPerf, sizeof(DEV_HOST_phyPerf_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   if(disable==1)
+     {
+       phyPerf.disableDspHybridSelect_f = TRUE;
+       //       hybrid_selected = 888;
+     }
+   else
+     {
+       phyPerf.disableDspHybridSelect_f = FALSE;
+       //       hybrid_selected = 888;
+     }
+  rc=dslhal_support_blockWrite(&phyPerf,dspOamSharedInterface.phyPerf_p,sizeof(DEV_HOST_phyPerf_t)); 
+   if(rc)
+     return DSLHAL_ERROR_HYBRID_API_FAILURE;
+   else
+     return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_selectHybrid()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_selectHybrid(tidsl_t * ptidsl,unsigned int hybridNum)
+{
+  int rc;
+  DEV_HOST_phyPerf_t phyPerf;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  if(hybridNum<1||hybridNum>4)
+   {
+     dprintf(3,"Invalid Value for Hybrid Number \n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+
+  if(!ptidsl)
+   {
+     dprintf(3, "Error: PTIDSL pointer invalid\n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   dspOamSharedInterface.phyPerf_p = (DEV_HOST_phyPerf_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.phyPerf_p);
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.phyPerf_p,
+                                      &phyPerf, sizeof(DEV_HOST_phyPerf_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   phyPerf.hostSelectHybridNum = hybridNum;
+   rc=dslhal_support_blockWrite(&phyPerf,dspOamSharedInterface.phyPerf_p,sizeof(DEV_HOST_phyPerf_t)); 
+   if(rc)
+     return DSLHAL_ERROR_HYBRID_API_FAILURE;
+   else
+     return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_reportHybridMetrics()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_reportHybridMetrics(tidsl_t * ptidsl,int *metric)
+{
+  int rc,i;
+  DEV_HOST_phyPerf_t phyPerf;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  if(hybrid_selected>5)
+    {
+      dprintf(4,"Hybrid Metrics Not Yet Available \n");
+    }
+  if(!ptidsl)
+   {
+     dprintf(3, "Error: PTIDSL pointer invalid\n");
+     return (0-DSLHAL_ERROR_INVALID_PARAM);
+   }  
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return (0-DSLHAL_ERROR_BLOCK_READ);
+     }
+   
+   dspOamSharedInterface.phyPerf_p = (DEV_HOST_phyPerf_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.phyPerf_p);
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.phyPerf_p,
+                                      &phyPerf, sizeof(DEV_HOST_phyPerf_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return (0-DSLHAL_ERROR_BLOCK_READ);
+     }
+   rc = sizeof(phyPerf.hybridCost);
+   for(i=0;i<(rc/4);i++)
+     {
+       metric[i] = dslhal_support_byteSwap32(phyPerf.hybridCost[i]);
+     }
+   return hybrid_selected;
+}
+
+/******************************************************************************************    
+ * FUNCTION NAME:    dslhal_api_selectInnerOuterPair(tidsl_t *ptidsl,unsigned int pairSelect)
+ *    
+ *******************************************************************************************    
+ * DESCRIPTION: This fuction selects inner/outer pair on RJ11.  
+ *    
+ * INPUT:  PITIDSLHW_T *ptidsl , unsigned int pairSelect
+ *           
+ * RETURN: 0 SUCCESS    
+ *         1 FAILED    
+ *      
+ *****************************************************************************************/    
+unsigned int dslhal_api_selectInnerOuterPair(tidsl_t *ptidsl,unsigned int pairSelect)
+{
+   int rc; 
+   
+   dprintf(5, "dslhal_api_sendQuiet\n"); 
+   rc = dslhal_support_writeHostMailbox(ptidsl, HOST_RJ11SELECT, (unsigned int)pairSelect, 0, 0); 
+   if(rc)
+    {  
+      dprintf(1,"dslhal_api_sendQuiet failed\n");  
+      return DSLHAL_ERROR_CTRL_API_FAILURE;    
+    }  
+    return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/******************************************************************************************    
+ * FUNCTION NAME:    dslhal_api_resetTrainFailureLog(tidsl_t *ptidsl)
+ *    
+ *******************************************************************************************    
+ * DESCRIPTION: This fuction resets the failed state log stored
+ *    
+ * INPUT:  PITIDSLHW_T *ptidsl
+ *           
+ * RETURN: 0 SUCCESS    
+ *         1 FAILED    
+ *      
+ *****************************************************************************************/    
+unsigned int dslhal_api_resetTrainFailureLog(tidsl_t *ptidsl)
+{
+    
+   int rc;
+   dprintf(5, "dslhal_api_resetTrainFailureLog \n"); 
+   for(rc=0;rc<ptidsl->AppData.trainFails;rc++)
+     {
+       ptidsl->AppData.trainFailStates[rc]=0;
+     }
+   ptidsl->AppData.trainFails = 0;
+   return DSLHAL_ERROR_NO_ERRORS; 
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_configureLed()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_configureLed(tidsl_t * ptidsl,unsigned int idLed, unsigned int onOff)
+{
+  int rc;
+  DEV_HOST_modemEnvPublic_t modemEnv;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  if(idLed>2 || onOff>2)
+   {
+     dprintf(3,"Invalid input parameter \n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+
+  if(!ptidsl)
+   {
+     dprintf(3, "Error: PTIDSL pointer invalid\n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   dspOamSharedInterface.modemEnvPublic_p = (DEV_HOST_modemEnvPublic_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.modemEnvPublic_p);
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.modemEnvPublic_p,
+                                      &modemEnv, sizeof(DEV_HOST_modemEnvPublic_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   if(idLed==ID_DSL_LINK_LED)
+     {
+       modemEnv.overrideDslLinkLed_f = TRUE;
+       if(onOff!=2)
+          modemEnv.dslLinkLedState_f = onOff;
+     }
+   if(idLed==ID_DSL_ACT_LED)
+     {
+       modemEnv.overrideDslLinkLed_f = TRUE;
+       if(onOff!=2)
+          modemEnv.dslLinkLedState_f = onOff;
+     }
+   if(idLed==ID_RESTORE_DEFAULT_LED)
+     {
+       modemEnv.overrideDslLinkLed_f = FALSE;
+       modemEnv.overrideDslActLed_f = FALSE;
+     }
+   rc=dslhal_support_blockWrite(&modemEnv,dspOamSharedInterface.modemEnvPublic_p,sizeof(DEV_HOST_modemEnvPublic_t)); 
+   if(rc)
+     return DSLHAL_ERROR_MODEMENV_API_FAILURE;
+   else
+     return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_configureExternBert()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_configureExternBert(tidsl_t * ptidsl,unsigned int configParm, unsigned int parmVal)
+{
+  int rc;
+  DEV_HOST_modemEnvPublic_t modemEnv;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  if(configParm>1 || parmVal>1)
+   {
+     dprintf(3,"Invalid input parameter \n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+
+  if(!ptidsl)
+   {
+     dprintf(3, "Error: PTIDSL pointer invalid\n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   dspOamSharedInterface.modemEnvPublic_p = (DEV_HOST_modemEnvPublic_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.modemEnvPublic_p);
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.modemEnvPublic_p,
+                                      &modemEnv, sizeof(DEV_HOST_modemEnvPublic_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   if(configParm==0)
+     {
+       modemEnv.externalBert = parmVal;
+     }
+   if(configParm==1)
+     {
+       modemEnv.usBertPattern = parmVal;
+     }
+   rc=dslhal_support_blockWrite(&modemEnv,dspOamSharedInterface.modemEnvPublic_p,sizeof(DEV_HOST_modemEnvPublic_t)); 
+   if(rc)
+     return DSLHAL_ERROR_MODEMENV_API_FAILURE;
+   else
+     return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_configureAtmBert()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_configureAtmBert(tidsl_t * ptidsl,unsigned int configParm, unsigned int parmVal)
+{
+  int rc;
+  DEV_HOST_atmDsBert_t atmDsBert;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  if(configParm>1 || parmVal>1)
+   {
+     dprintf(3,"Invalid input parameter \n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+
+  if(!ptidsl)
+   {
+     dprintf(3, "Error: PTIDSL pointer invalid\n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   dspOamSharedInterface.atmDsBert_p = (DEV_HOST_atmDsBert_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.atmDsBert_p);
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.atmDsBert_p,
+                                      &atmDsBert, sizeof(DEV_HOST_atmDsBert_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   if(configParm==0)
+     {
+       atmDsBert.atmBertFlag = parmVal;
+       rc=dslhal_support_blockWrite(&atmDsBert,dspOamSharedInterface.atmDsBert_p,sizeof(DEV_HOST_atmDsBert_t)); 
+       if(rc)
+         return DSLHAL_ERROR_CONFIG_API_FAILURE;
+     }
+   if(configParm==1)
+     {
+       ptidsl->AppData.atmBertBitCountLow = atmDsBert.bitCountLow;
+       ptidsl->AppData.atmBertBitCountHigh = atmDsBert.bitCountHigh;
+       ptidsl->AppData.atmBertBitErrorCountLow = atmDsBert.bitErrorCountLow;
+       ptidsl->AppData.atmBertBitErrorCountHigh = atmDsBert.bitErrorCountHigh;
+     }
+   return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_configureDgaspLpr()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Configures dying gasp LPR signal
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_configureDgaspLpr(tidsl_t * ptidsl,unsigned int configParm, unsigned int parmVal)
+{
+  int rc;
+  DEV_HOST_modemEnvPublic_t modemEnv;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  if(configParm>1 || parmVal>1)
+   {
+     dprintf(3,"Invalid input parameter \n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+
+  if(!ptidsl)
+   {
+     dprintf(3, "Error: PTIDSL pointer invalid\n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+   
+   rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   
+   dspOamSharedInterface.modemEnvPublic_p = (DEV_HOST_modemEnvPublic_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.modemEnvPublic_p);
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.modemEnvPublic_p,
+                                      &modemEnv, sizeof(DEV_HOST_modemEnvPublic_t));
+   if (rc)
+     {
+       dprintf(1,"dslhal_support_blockRead failed\n");
+       return DSLHAL_ERROR_BLOCK_READ;
+     }
+   if(configParm==0)
+     {
+       modemEnv.dGaspLprIndicator_f = parmVal;
+     }
+   if(configParm==1)
+     {
+       modemEnv.overrideDspLprGasp_f = parmVal;
+     }
+   rc=dslhal_support_blockWrite(&modemEnv,dspOamSharedInterface.modemEnvPublic_p,sizeof(DEV_HOST_modemEnvPublic_t)); 
+   if(rc)
+     return DSLHAL_ERROR_MODEMENV_API_FAILURE;
+   else
+     return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_genericDspRead()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Reads from a Generic Location in the DSP Host Interface
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_genericDspRead(tidsl_t * ptidsl,unsigned int offset1, unsigned int offset2, 
+                                       unsigned int offset3, unsigned char *localBuffer, unsigned int numBytes)
+{
+  int rc=0;
+  unsigned int  hostIfLoc,structLoc,elementLoc;
+  hostIfLoc = (unsigned int)ptidsl->pmainAddr;
+  if(numBytes<=0 || !localBuffer || !ptidsl)
+   {
+     dprintf(3,"Invalid input parameter \n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+  rc += dslhal_support_blockRead((PVOID)(hostIfLoc+sizeof(int)*offset1), &structLoc,sizeof(int));
+  structLoc = dslhal_support_byteSwap32(structLoc);  
+  rc += dslhal_support_blockRead((PVOID)(structLoc+sizeof(int)*offset2), &elementLoc,sizeof(int));
+  elementLoc = dslhal_support_byteSwap32(elementLoc);    
+  dprintf(3,"Host IF Location: 0x%x  Struct1 Location: 0x%x Element Location: 0x%x \n",hostIfLoc, structLoc, elementLoc);
+  rc += dslhal_support_blockRead((PVOID)(elementLoc+(offset3*4)), localBuffer,numBytes);
+  if (rc)
+       return DSLHAL_ERROR_BLOCK_READ;
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_genericDspWrite()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Writes to a Generic Location in the DSP Host Interface
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_genericDspWrite(tidsl_t * ptidsl,unsigned int offset1, unsigned int offset2, 
+                                        unsigned int offset3, unsigned char *localBuffer, unsigned int numBytes)
+{
+
+  int rc=0;
+  unsigned int  hostIfLoc,structLoc,elementLoc;
+  hostIfLoc = (unsigned int)ptidsl->pmainAddr;
+  if(numBytes<=0 || !localBuffer || !ptidsl)
+   {
+     dprintf(3,"Invalid input parameter \n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+  rc += dslhal_support_blockRead((PVOID)(hostIfLoc+(offset1*4)), &structLoc,4);  
+  structLoc = dslhal_support_byteSwap32(structLoc);  
+  rc += dslhal_support_blockRead((PVOID)(structLoc+(offset2*4)), &elementLoc,4);
+  elementLoc = dslhal_support_byteSwap32(elementLoc);  
+  dprintf(3,"Host IF Location: 0x%x  Struct1 Location: 0x%x Element Location: 0x%x \n",hostIfLoc, structLoc, elementLoc);
+  rc += dslhal_support_blockWrite(localBuffer,(PVOID)(elementLoc+(offset3*4)),numBytes);
+  if (rc)
+       return DSLHAL_ERROR_BLOCK_READ;
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_dspInterfaceRead()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Reads from a Generic Location in the DSP Host Interface
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_dspInterfaceRead(tidsl_t * ptidsl,unsigned int baseAddr, unsigned int numOffsets, 
+                                         unsigned int *offsets, unsigned char *localBuffer, unsigned int numBytes)
+{
+  int rc=0, off=0;
+  unsigned int  prevAddr,currAddr;
+  prevAddr = baseAddr;
+  if(numBytes<=0 || !localBuffer || !ptidsl || !offsets)
+   {
+     dprintf(3,"Invalid input parameter \n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }
+  for(off=0;off<numOffsets-1;off++)
+    {
+      rc += dslhal_support_blockRead((PVOID)(prevAddr+(4*offsets[off])), &currAddr,4);
+      currAddr = dslhal_support_byteSwap32(currAddr);  
+      prevAddr = currAddr;
+      dprintf(5,"Curr Addr = 0x%x  Current Level: %d \n",currAddr,off);
+    }
+  currAddr = currAddr + offsets[numOffsets-1]*4;
+  rc += dslhal_support_blockRead((PVOID)(currAddr),localBuffer,numBytes);
+  if (rc)
+       return DSLHAL_ERROR_BLOCK_READ;
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_dspInterfaceWrite()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Writes to a Generic Location in the DSP Host Interface
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_dspInterfaceWrite(tidsl_t * ptidsl,unsigned int baseAddr, unsigned int numOffsets, 
+                                          unsigned int *offsets,unsigned char *localBuffer, unsigned int numBytes)
+{
+
+  int rc=0, off=0;
+  unsigned int  prevAddr,currAddr;
+  prevAddr = baseAddr;
+  if(numBytes<=0 || !localBuffer || !ptidsl || !offsets)
+   {
+     dprintf(3,"Invalid input parameter \n");
+     return DSLHAL_ERROR_INVALID_PARAM;
+   }  
+  for(off=0;off<numOffsets-1;off++)
+    {
+      rc += dslhal_support_blockRead((PVOID)(prevAddr+(4*offsets[off])), &currAddr,4);
+      currAddr = dslhal_support_byteSwap32(currAddr);  
+      prevAddr = currAddr;
+      dprintf(5,"Curr Addr = 0x%x  Current Level: %d \n",currAddr,off);
+    }
+  currAddr = currAddr + offsets[numOffsets-1]*4;
+  rc += dslhal_support_blockWrite(localBuffer,(PVOID)(currAddr),numBytes);
+  if (rc)
+       return DSLHAL_ERROR_BLOCK_READ;
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+
+/******************************************************************************************     
+ * FUNCTION NAME:    dslhal_api_sendMailboxCommand(tidsl_t *ptidsl, unsigned int cmd)     
+ *     
+ *******************************************************************************************     
+ * DESCRIPTION: This fuction sends the passed mailbox command to the DSP     
+ *     
+ * INPUT:  PITIDSLHW_T *ptidsl     
+ *         unsigned int cmd
+ *            
+ * RETURN: 0 SUCCESS     
+ *         1 FAILED     
+ *       
+ *****************************************************************************************/     
+/* Function is commented out for now since, its not tested */
+ /*unsigned int dslhal_api_sendMailboxCommand(tidsl_t *ptidsl, unsigned int cmd) 
+{ 
+   int rc;  
+    
+   dprintf(5, "dslhal_api_sendMailboxCommand\n");  
+   rc = dslhal_support_writeHostMailbox(ptidsl, cmd, 0, 0, 0);  
+   if(rc) 
+     {   
+      dprintf(1,"dslhal_api_sendMailboxCommand failed\n");   
+      return DSLHAL_ERROR_CTRL_API_FAILURE;    
+     }   
+    return DSLHAL_ERROR_NO_ERRORS; 
+} */
+
+
diff -urN linux.old/drivers/atm/sangam_atm/dsl_hal_api.h linux.dev/drivers/atm/sangam_atm/dsl_hal_api.h
--- linux.old/drivers/atm/sangam_atm/dsl_hal_api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/dsl_hal_api.h	2005-08-23 04:46:50.097843696 +0200
@@ -0,0 +1,1721 @@
+#ifndef __DSL_HAL_API_H__
+#define __DSL_HAL_API_H__ 1
+/*******************************************************************************
+* FILE PURPOSE:     DSL HAL to Application Interface for Sangam
+*
+********************************************************************************
+* FILE NAME:        dsl_application_interface.h
+*
+* DESCRIPTION:  
+*       DSL-Application Interface Structures
+*                
+*
+* By: Ramakrishnan Parasuraman
+*                    
+* (C) Copyright 2003, Texas Instruments, Inc.
+*    History
+*    Data        Version    By               Notes
+*    06Feb03     0.00       RamP            Initial Version Written 
+*    07Apr03     0.01       RamP            Commented out typedefs
+*    09Apr03     0.02       RamP            Added deviceContext and extended
+*                                           dspVer to include bugfixes
+*    14Apr03     0.03       RamP            Added stateTransition to structure
+*    16Apr03     0.04       RamP            Removed typedefs; changed dspVer
+*    22Apr03     0.05       RamP            Moved acknowledgeInterrupt from
+*               (alpha)                     support module into this
+*    24Apr03     0.06       RamP            Moved the RSTATE enum from register
+*
+*    28Apr03     0.07       RamP            Added additional parameter to the
+*               (alpha +)                   handleInterrupt function for intrSrc
+*    14May03     0.08       RamP            Added hybrid switching APIs
+*               (alpha ++)                  Added statistics fields in AppData
+*                                           Added netService identifier
+*    20May03     0.09       RamP            Added Inner/Outer pair API support. 
+*                                           Added dying gasp message.
+*    29May03     0.10       RamP            Added coProfile structure                                       
+*    04Jun03     0.11       RamP            Added margin per tone statistics,
+*                                           Added timing counters, added train
+*                                           failure functions,added config flags
+*    06Jun03     0.12       RamP            Added LED, STM Bert, dGasp LPR 
+*                                           config API functions 
+*    09Jun03     0.13       RamP            Added ATM Bert function, CO stats
+*                                           Moved stateTransition to ITIDSLHW
+*               (Beta)                      Moved configFlag to ITIDSLHW, 
+*                                           Cleaned up fifoInfo structure
+*                                           Added US/DS R/S FEC parameters
+*    21Aug03     0.14       RamP            Added g.hs message buffer, us/ds
+*                                           bits n gains table, negoMsgs struct
+*               (act)                       bitswap stucts/indices, trainstate,
+*                                           Added functions for advanced config
+*                                           Added gross gain and line length
+*    29Sep03     0.15       RamP            Added tokens for advanced config 
+*                                           module api functions
+*    12Oct03     0.16       RamP            Added adsl2Msgs structure with worst
+*                                           case size for variable length msgs 
+*                                           Added API function prototypes
+*    21Oct03     0.17       RamP            Added typedef for current modem 
+*                                           user settings
+*    28Oct03     0.18       RamP            Added function to config blackout
+*                                           bitmap in the RMSGPCB message
+*    20Nov03     0.19       RamP            Added functions for generic and
+*                                           host interface read - write
+*    24Nov03     0.20       RamP            Added enum for detailed state track
+*                                           Added element for state bit fields
+*                                           Addded rState for encoded main state
+*                                           Added blackout valid flag
+*    26Dec03     0.21       RamP            Added defines for oamFeature masks
+*    30Dec03     0.22       RamP            Increased sizes for cMsgPcb,RMsgPcb
+*                                           to incorporate DELT mode messages
+*    30Dec03     0.23       RamP            Added generic mailbox command fxn
+*******************************************************************************/
+
+#ifdef INTERNAL_BUILD
+#include <dsl_hal_api_pvt.h>
+#endif
+
+#define NUM_PAGES 4
+#define OAMFEATURE_AUTORETRAIN_MASK       0x00000001
+#define OAMFEATURE_TC_SYNC_DETECT_MASK    0x00000002
+#define OAMFEATURE_EOCAOC_INTERRUPT_MASK  0x00000004
+#define OAMFEATURE_CONS_DISP_DISABLE_MASK 0x00000008
+#define OAMFEATURE_GHSMSG_INTERRUPT_MASK  0x00000010
+
+typedef struct tagTIOIDINFO
+{
+  unsigned int   bState;           /* addr->bDSPATURState    */ 
+  unsigned int   USConRate;        /* US Conection Rates */
+  unsigned int   DSConRate;        /* DS Connection Rates */
+  unsigned int   USPayload;        /* ennic_tx_pullup*/
+  unsigned int   DSPayload;        /* ennic_indicate_receive_packet*/
+  unsigned int   FrmMode;          /* addr->atur_msg.framing_mode*/
+  unsigned int   MaxFrmMode;          
+  unsigned int   TrainedPath;      /* Status of the Modem in which trained (Fast or Interleaved Path) */
+  unsigned int   TrainedMode;      /* Status of the mode in which the modem is trained (G.dmt, T1.413, etc) */
+  
+  /* Superframe Count */
+  unsigned int   usSuperFrmCnt;    /* Num of US Superframes */
+  unsigned int   dsSuperFrmCnt;    /* Num of DS Superframes */
+
+  /* LOS & SEF Stats */
+  unsigned int   LOS_errors;       /* Num of ADSL frames where loss-of-sync */
+  unsigned int   SEF_errors;       /* Num of severly errored ADSL frames - LOS > MAXBADSYNC ADSL frames */
+  unsigned int   coLosErrors; /* CO LOS Defects */
+  unsigned int   coRdiErrors; /* CO RDI defects */
+  /* CRC Stats */
+  unsigned int   usICRC_errors;    /* Num of Upstream CRC errored ADSL frames on Interleaved Path */
+  unsigned int   usFCRC_errors;    /* Num of Upstream CRC errored ADSL frames on Fast Path */
+  unsigned int   dsICRC_errors;    /* Num of Downstream CRC errored ADSL frames on Interleaved Path */
+  unsigned int   dsFCRC_errors;    /* Num of Downstream CRC errored ADSL frames on Fast Path */
+
+  /* FEC Stats */
+  unsigned int   usIFEC_errors;    /* Num of Upstream FEC errored (corrected) ADSL frames on Interleaved Path */
+  unsigned int   usFFEC_errors;    /* Num of Upstream FEC errored (corrected) ADSL frames on Fast Path */
+  unsigned int   dsIFEC_errors;    /* Num of Downstream FEC errored (corrected) ADSL frames on Interleaved Path */
+  unsigned int   dsFFEC_errors;    /* Num of Downstream FEC errored (corrected) ADSL frames on Fast Path */
+
+  /* NCD Stats */
+  unsigned int   usINCD_error;     /* UpStream No Cell Delineation on Interleaved Path */
+  unsigned int   usFNCD_error;     /* UpStream No Cell Delineation on Fast Path */
+  unsigned int   dsINCD_error;     /* Downstream No Cell Delineation on Interleaved Path */
+  unsigned int   dsFNCD_error;     /* Downstream No Cell Delineation on Fast Path */
+
+  /* LCD Stats */
+  unsigned int   usILCD_errors;    /* UpStream Loss of Cell Delineation (within the same connection) on Interleaved Path */
+  unsigned int   usFLCD_errors;    /* UpStream Loss of Cell Delineation (within the same connection) on Fast Path */
+  unsigned int   dsILCD_errors;    /* Downstream Loss of Cell Delineation (within the same connection) on Interleaved Path */
+  unsigned int   dsFLCD_errors;    /* Downstream Loss of Cell Delineation (within the same connection) on Fast Path */
+
+  /* HEC Stats */
+  unsigned int   usIHEC_errors;    /* Num of Upstream HEC errored ADSL frames on Interleaved Path */
+  unsigned int   usFHEC_errors;    /* Num of Upstream HEC errored ADSL frames on Fast Path */
+  unsigned int   dsIHEC_errors;    /* Num of Downstream HEC errored ADSL frames on Interleaved Path */
+  unsigned int   dsFHEC_errors;    /* Num of Downstream HEC errored ADSL frames on Fast Path */
+
+  /* Upstream ATM Stats */
+  unsigned int   usAtm_count[2];      /* Upstream Good Cell Count */
+  unsigned int   usIdle_count[2];     /* Upstream Idle Cell Count */
+  unsigned int   usPdu_count[2];      /* UpStream PDU Count */
+
+  /* Downstream ATM Stats */
+  unsigned int   dsGood_count[2];     /* Downstream Good Cell Count */
+  unsigned int   dsIdle_count[2];     /* Downstream Idle Cell Count */
+  unsigned int   dsBadHec_count[2];   /* Downstream Bad Hec Cell Count */
+  unsigned int   dsOVFDrop_count[2];  /* Downstream Overflow Dropped Cell Count */
+  unsigned int   dsPdu_count[2];      /* Downstream PDU Count */
+                             /* (only looks for end of pdu on good atm cells received, */
+                             /* not on Bad_Hec or Overflow cell) */
+
+  unsigned int   dsLineAttn;       /* DS Line Attenuation */
+  unsigned int   dsMargin;         /* Measured DS MArgin */
+
+  unsigned int   usLineAttn;
+  unsigned int   usMargin;
+
+  unsigned char    bCMsgs1[6];
+  unsigned char    bRMsgs1[6];
+  unsigned char    bCRates2;
+  unsigned char    bRRates2;
+  unsigned char    bRRates1[4][11];
+  unsigned char    bCMsgs2[4];
+  unsigned char    bCRates1[4][30];
+  unsigned char    bRMsgs2[4];
+   
+  unsigned int   USPeakCellRate; 
+  
+  unsigned int   dsl_status;
+  unsigned int   dsl_modulation;
+  unsigned char  dsl_ghsRxBuf[10][64];
+  unsigned char  dsl_GHS_msg_type[2];
+   
+  int     TxVCs[12];
+  int     RxVCs[12];
+
+  unsigned int   vci_vpi_val;
+
+  unsigned char  BitAllocTblDstrm[256]; 
+  unsigned char  BitAllocTblUstrm[32];  
+    signed char  marginTblDstrm[256];
+  unsigned char  rBng[512];
+  unsigned char  cBng[126];
+           int   usTxPower;
+           int   dsTxPower;
+         short   rxSnrPerBin0[256];
+         short   rxSnrPerBin1[256];
+         short   rxSnrPerBin2[256];
+
+  unsigned int   StdMode;
+  unsigned int   atucVendorId;
+  unsigned char  currentHybridNum;
+  unsigned char  atucRevisionNum; 
+  unsigned int   trainFails;
+  unsigned int   trainFailStates[30];
+  unsigned int   idleTick;
+  unsigned int   initTick;
+  unsigned int   showtimeTick; 
+  unsigned char  dsFastParityBytesPerSymbol;
+  unsigned char  dsIntlvParityBytesPerSymbol;
+  unsigned char  dsSymbolsPerCodeWord;
+  unsigned int   dsInterleaverDepth;
+  unsigned char  usFastParityBytesPerSymbol;
+  unsigned char  usIntlvParityBytesPerSymbol;
+  unsigned char  usSymbolsPerCodeWord;
+  unsigned int   usInterleaverDepth;
+  unsigned int   atmBertBitCountLow;
+  unsigned int   atmBertBitCountHigh;
+  unsigned int   atmBertBitErrorCountLow;
+  unsigned int   atmBertBitErrorCountHigh;
+  unsigned int   lineLength;
+  unsigned int   grossGain;
+           int   rxNoisePower0[256];
+           int   rxNoisePower1[256];
+}TIOIDINFO,*PTIOIDINFO;
+
+typedef struct{
+  unsigned char    bCMsgs1[6];
+  unsigned char    bCRates2;
+  unsigned char    bRRates2;
+  unsigned char    bRRates1[4][11];
+  unsigned char    bCMsgs2[4];
+  unsigned char    bCRates1[4][30];
+  unsigned char    bCRatesRA[4][30];
+  unsigned char    bRMsgs2[4];
+  unsigned char    bRRatesRA[4];
+  unsigned char    bRMsgsRA[12];
+  unsigned char    bCMsgsRA[6];
+}negoMsgs;
+
+typedef struct{
+  unsigned char    cMsgFmt[2];
+  unsigned char    rMsgFmt[2];
+  unsigned char    cMsgPcb[12];
+  unsigned char    rMsgPcb[70];
+  unsigned char    dummy1[2];
+  unsigned char    cMsg1[40];
+  unsigned char    rMsg1[4]; 
+  unsigned char    cMsg2[8];
+  unsigned char    rMsg2[64];
+  unsigned char    cParams[264];
+  unsigned char    rParams[2088];
+  unsigned short   cMsgPcbLen; 
+  unsigned short   rMsgPcbLen;
+  unsigned short   cMsg1Len; 
+  unsigned short   rMsg1Len;
+  unsigned short   cMsg2Len;
+  unsigned short   rMsg2Len;
+  unsigned short   cParamsLen;
+  unsigned short   rParamsLen;    
+}adsl2Msgs;
+
+typedef struct{
+  unsigned char    rMsg1Ld[16];
+  unsigned char    rMsg2Ld[260];
+  unsigned char    rMsg3Ld[260];
+  unsigned char    rMsg4Ld[260];
+  unsigned char    rMsg5Ld[260];
+  unsigned char    rMsg6Ld[260];
+  unsigned char    rMsg7Ld[260];
+  unsigned char    rMsg8Ld[260];
+  unsigned char    rMsg9Ld[260];
+  unsigned char    cMsg1Ld[16];
+  unsigned char    cMsg2Ld[260];
+  unsigned char    cMsg3Ld[132];
+  unsigned char    cMsg4Ld[68];
+  unsigned char    cMsg5Ld[68];
+  unsigned short   rMsg1LdLen;
+  unsigned short   rMsgxLdLen;
+  unsigned short   cMsg1LdLen;
+  unsigned short   cMsg2LdLen;
+  unsigned short   cMsg3LdLen;
+  unsigned short   cMsg4LdLen;
+  unsigned short   cMsg5LdLen;
+  unsigned short   dummy8;
+}adsl2DeltMsgs;
+
+typedef struct{
+  unsigned char    trellisFlag;
+  unsigned char    rateAdaptFlag;
+  unsigned char    marginMonitorTraining;
+  unsigned char    marginMonitorShowtime;  
+    signed char    marginThreshold;    
+  unsigned char    disableLosFlag;
+  unsigned char    aturConfig[30]; 
+  unsigned char    eocVendorId[8];
+  unsigned char    eocSerialNumber[32];
+  unsigned char    eocRevisionNumber[4];
+}currentPhySettings;
+
+
+typedef struct
+{
+  unsigned int  PmemStartWtAddr;              /* source address in host memory */
+  unsigned int  OverlayXferCount;             /* number of 32bit words to be transfered */
+  unsigned int  BinAddr;                      /* destination address in dsp's pmem */
+  unsigned int  overlayHostAddr;
+  unsigned int  olayPageCrc32;
+  unsigned int  SecOffset;
+} OlayDP_Def;
+
+typedef struct
+{
+  unsigned int    timeStamp; /* TimeStp revision  */
+  unsigned char   major;     /* Major revision    */
+  unsigned char   minor;     /* Minor revision    */
+  unsigned char   bugFix;    /* BugFix revision   */
+  unsigned char   buildNum;  /* BuildNum revision */
+  unsigned char   reserved;  /* for future use    */
+}dspVer;
+
+typedef struct{
+  unsigned char major;
+  unsigned char minor;
+  unsigned char bugfix;
+  unsigned char buildNum;
+  unsigned int  timeStamp;
+}dslVer;
+
+typedef struct{
+  unsigned char bitSwapCommand[6];
+  unsigned char bitSwapBinNum[6];
+  unsigned char bitSwapSFrmCnt;
+}dslBitSwapDef;
+
+typedef struct{
+  unsigned int aturState;
+  unsigned int subStateIndex;
+  unsigned int timeStamp;
+}trainStateInfo;
+
+typedef struct{
+  unsigned char ctrlBits;
+  unsigned char infoBits;
+}eocMessageDef;
+      
+enum
+{
+  RSTATE_TEST,
+  RSTATE_IDLE,
+  RSTATE_INIT,
+  RSTATE_HS,
+  RSTATE_RTDL,
+  RSTATE_SHOWTIME,
+};
+
+typedef enum
+{
+  ATU_RZERO1      = 100,
+  ATU_RTEST       = 101,
+  ATU_RIDLE       = 102,
+  ATU_RINIT       = 103,
+  ATU_RRESET      = 104,
+  GDMT_NSFLR      = 105,
+  GDMT_TONE       = 106,
+  GDMT_SILENT     = 107,
+  GDMT_NEGO       = 108,
+  GDMT_FAIL       = 109,
+  GDMT_ACKX       = 110,
+  GDMT_QUIET2     = 111,
+  ATU_RZERO2      = 200,
+  T1413_NSFLR     = 201,
+  T1413_ACTREQ    = 202,
+  T1413_ACTMON    = 203,
+  T1413_FAIL      = 204,
+  T1413_ACKX      = 205,
+  T1413_QUIET2    = 206,
+  ATU_RQUIET2     = 207,
+  ATU_RREVERB1    = 208,
+  ATU_RQUIET3     = 209,
+  ATU_RECT        = 210,
+  ATU_RREVERB2    = 211,
+  ATU_RSEGUE1     = 212,
+  ATU_RREVERB3    = 213,
+  ATU_RSEGUE2     = 214,
+  ATU_RRATES1     = 215,
+  ATU_RMSGS1      = 216,
+  ATU_RMEDLEY     = 217,
+  ATU_RREVERB4    = 218,
+  ATU_RSEGUE3     = 219,
+  ATU_RMSGSRA     = 220,
+  ATU_RRATESRA    = 221,
+  ATU_RREVERBRA   = 222,
+  ATU_RSEGUERA    = 223,
+  ATU_RMSGS2      = 224,
+  ATU_RRATES2     = 225,
+  ATU_RREVERB5    = 226,
+  ATU_RSEGUE4     = 227,
+  ATU_RBNG        = 228,
+  ATU_RREVERB6    = 229,
+  ATU_RSHOWTIME   = 230,
+  ATU_RZERO3      = 300,
+  ADSL2_QUIET1    = 301,
+  ADSL2_COMB1     = 302,
+  ADSL2_QUIET2    = 303,
+  ADSL2_COMB2     = 304,
+  ADSL2_ICOMB1    = 305,
+  ADSL2_LINEPROBE = 306,
+  ADSL2_QUIET3    = 307,
+  ADSL2_COMB3     = 308,
+  ADSL2_ICOMB2    = 309,
+  ADSL2_RMSGFMT   = 310,
+  ADSL2_RMSGPCB   = 311,
+  ADSL2_REVERB1   = 312,
+  ADSL2_QUIET4    = 313,
+  ADSL2_REVERB2   = 314,
+  ADSL2_QUIET5    = 315,
+  ADSL2_REVERB3   = 316,
+  ADSL2_ECT       = 317,
+  ADSL2_REVERB4   = 318,
+  ADSL2_SEGUE1    = 319,
+  ADSL2_REVERB5   = 320,
+  ADSL2_SEGUE2    = 321,
+  ADSL2_RMSG1     = 322,
+  ADSL2_MEDLEY    = 323,
+  ADSL2_EXCHANGE  = 324,
+  ADSL2_RMSG2     = 325,
+  ADSL2_REVERB6   = 326,
+  ADSL2_SEGUE3    = 327,
+  ADSL2_RPARAMS   = 328,
+  ADSL2_REVERB7   = 329,
+  ADSL2_SEGUE4    = 330,
+  ATU_RZERO4      = 400,
+  DELT_SEGUE1     = 401,
+  DELT_REVERB5    = 402,
+  DELT_SEGUE2     = 403,
+  DELT_EXCHANGE   = 404,
+  DELT_SEGUELD    = 405,
+  DELT_RMSGLD     = 406,
+  DELT_QUIET1LD   = 407,
+  DELT_QUIET2LD   = 408,
+  DELT_RACK1      = 409,
+  DELT_RNACK1     = 410,
+  DELT_QUIETLAST  = 411
+} modemStates_t;  
+
+enum
+{
+  DSLTRAIN_NO_MODE,
+  DSLTRAIN_MULTI_MODE,
+  DSLTRAIN_T1413_MODE,
+  DSLTRAIN_GDMT_MODE,
+  DSLTRAIN_GLITE_MODE
+};
+
+enum
+{
+  ID_RESTORE_DEFAULT_LED,
+  ID_DSL_LINK_LED,
+  ID_DSL_ACT_LED
+};
+
+typedef struct _ITIDSLHW
+{
+  /* struct _TIDSL_IHwVtbl * pVtbl; */
+  unsigned char*     fwimage;
+  void*     pmainAddr;
+  void*     pOsContext;
+  unsigned int     ReferenceCount;
+  unsigned int     netService;  
+
+  int     InitFlag;
+
+  int     imagesize;
+  
+  unsigned int     lConnected;
+  unsigned int     bStatisticsInitialized;
+  unsigned int     rState;
+  unsigned int     bShutdown; 
+  unsigned int     blackOutValid_f;
+  unsigned char    blackOutBits[64];
+  unsigned int     bAutoRetrain;
+  volatile unsigned int     bOverlayPageLoaded;
+  unsigned int     stateTransition;
+  unsigned int     configFlag;
+  unsigned int     dsBitSwapInx;
+  unsigned int     usBitSwapInx;
+  unsigned int     trainStateInx;
+  unsigned int     usEocMsgInx;
+  unsigned int     dsEocMsgInx;
+  unsigned int     reasonForDrop;
+  TIOIDINFO  AppData;
+  dspVer     dspVer;
+
+  OlayDP_Def olayDpPage[NUM_PAGES];
+  OlayDP_Def coProfiles;
+  OlayDP_Def constDisplay;
+  dslBitSwapDef dsBitSwap[30];
+  dslBitSwapDef usBitSwap[30];  
+  trainStateInfo trainHistory[120];
+  eocMessageDef usEocMsgBuf[30];
+  eocMessageDef dsEocMsgBuf[30];
+  adsl2Msgs     adsl2TrainingMessages;
+  adsl2DeltMsgs adsl2DiagnosticMessages;
+  unsigned int modemStateBitField[4];
+#ifdef INTERNAL_BUILD
+  internalParameters internalVars;
+#endif
+} ITIDSLHW_T, *PITIDSLHW_T, tidsl_t;
+
+
+/**********************************************************************************
+* API proto type defines
+**********************************************************************************/
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_dslStartup
+*
+*******************************************************************************************
+* DESCRIPTION: Entry point to initialize and load ax5 daughter board
+*
+* INPUT:   PITIDSLHW_T *ppIHw  
+*
+* RETURN:  0 --succeeded
+*          1 --Failed
+*
+* Notes: external function osAllocateMemory(), osZeroMemory(), osLoadFWImage() are required
+*****************************************************************************************/
+int dslhal_api_dslStartup
+(
+ PITIDSLHW_T *ppIHw
+);
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_gatherStatistics
+*
+*********************************************************************************************
+* DESCRIPTION: Read statistical infromation from ax5 modem daugter card. 
+* Input: tidsl_t *ptidsl
+* 
+* Return: 0    success
+*         1    failed
+*
+********************************************************************************************/
+
+void dslhal_api_gatherStatistics
+(
+ tidsl_t * ptidsl
+);
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_initStatistics
+*
+*********************************************************************************************
+* DESCRIPTION: init statistical infromation of ax5 modem daugter card. 
+*
+* Input: tidsl_t *ptidsl
+* 
+* Return: NULL
+*         
+********************************************************************************************/
+
+void dslhal_api_initStatistics
+(
+ tidsl_t * ptidsl
+);
+
+
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_getDslDriverVersion
+*
+*******************************************************************************************
+* DESCRIPTION: This routine supply DSL Driver version.
+*
+* INPUT:  tidsl_t * ptidsl
+*         void *pVer, DSP Driver Version Pointer
+*         
+* RETURN:  0 --succeeded
+*          1 --Failed
+* Note: See verdef_u.h for version structure definition.
+*****************************************************************************************/
+
+void dslhal_api_getDslHalVersion
+(
+ void  *pVer
+);
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_dslShutdown
+*
+*******************************************************************************************
+* DESCRIPTION: routine to shutdown ax5 modem and free the resource
+*
+* INPUT:   tidsl_t *ptidsl  
+*
+* RETURN:  NULL
+*          
+* Notes: external function osFreeMemory() is required.
+*****************************************************************************************/
+
+int dslhal_api_dslShutdown
+(
+ tidsl_t *ptidsl
+);
+
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_getDspVersion
+*
+*******************************************************************************************
+* DESCRIPTION: This routine supply AX5 daugther card DSP version.
+*
+* INPUT:  tidsl_t * ptidsl
+*         void *pVer, DSP version struct is returned starting at this pointer
+*         
+* RETURN:  0 --succeeded
+*          1 --Failed
+* 
+*****************************************************************************************/
+
+int dslhal_api_getDspVersion
+(
+ tidsl_t *ptidsl,
+ void  *pVer
+);
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_digi_memTestA()
+*
+*********************************************************************************************
+* DESCRIPTION: This function does the digital tests on the DSP. It does the DSP ID test,
+*              memory tests on the external and internal memories of DSP, Codec Interconnect 
+*              test and Interrupt Test.
+*
+* Input:       Test selects the test to be performed based on the elements set of 9 element
+*              array passed the the parameter. 
+*             
+* Return:      Status of the Tests Failed
+*         
+********************************************************************************************/
+
+unsigned int dslhal_diags_digi_memTestA
+(
+unsigned int*   Test
+);
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_digi_memTestB()
+*
+*********************************************************************************************
+* DESCRIPTION: This function does the digital tests on the DSP. It does the DSP ID test,
+*              memory tests on the external and internal memories of DSP, Codec Interconnect 
+*              test and Interrupt Test.
+*
+* Input:       Test selects the digital test to be performed.
+* 
+* Return:      Status of the Tests Failed
+*         
+********************************************************************************************/
+
+unsigned int dslhal_diags_digi_memTestB
+(
+unsigned int   Test,
+unsigned int   *Status
+);
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_anlg_tonesTestA()
+*
+*********************************************************************************************
+* DESCRIPTION: This function instructs the Transciever to transmit the Reverb with missing
+*              tones and Medley's with missing tones. These signals are defined in ITU 
+*              G.992.1 ADSL Standards.
+*
+* Input: Test selects between the Reverb or Medley tests. 0 - Reverb, 1 - Medley
+*        Array is a 64 element unsigned integer type array. The element of this array
+*              describe which tones are to be generated by selecting the element of
+*              the array to be non zero.
+* Return: NULL
+*         
+********************************************************************************************/
+
+void dslhal_diags_anlg_tonesTestA
+(
+unsigned int   Test, 
+unsigned int* Array
+);
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_anlg_tonesTestB()
+*
+*********************************************************************************************
+* DESCRIPTION: This function instructs the Transciever to transmit the Reverb with missing
+*              tones and Medley's with missing tones. These signals are defined in ITU 
+*              G.992.1 ADSL Standards.
+*
+* Input: Test selects between the Reverb or Medley tests. 0 - Reverb, 1 - Medley
+*        Array is a 64 element unsigned integer type array. The element of this array
+*              describe which tones are to be generated by selecting the element of
+*              the array to be non zero.
+* Return: NULL
+*         
+********************************************************************************************/
+
+void dslhal_diags_anlg_tonesTestB
+(
+unsigned int   Test, 
+unsigned int  Tones
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_anlg_rxNoiseTest()
+*
+*********************************************************************************************
+* DESCRIPTION: This function instructs the Transciever to transmit the Reverb with missing
+*              tones and Medley's with missing tones. These signals are defined in ITU 
+*              G.992.1 ADSL Standards.
+*
+* Input: Test selects between the Reverb or Medley tests. 0 - Reverb, 1 - Medley
+*        Tones selects the .
+* Return: NULL
+*         
+********************************************************************************************/
+
+void dslhal_diags_anlg_rxNoiseTest
+(int agcFlag,
+short pga1, 
+short pga2, 
+short pga3, 
+short aeq
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_anlg_ecNoiseTest()
+*
+*********************************************************************************************
+* DESCRIPTION: This function instructs the Transciever to transmit the Reverb with missing
+*              tones and Medley's with missing tones. These signals are defined in ITU 
+*              G.992.1 ADSL Standards.
+*
+* Input: Test selects between the Reverb or Medley tests. 0 - Reverb, 1 - Medley
+*        Tones selects the .
+* Return: NULL
+*         
+********************************************************************************************/
+
+void dslhal_diags_anlg_ecNoiseTest
+(int agcFlag,
+short pga1, 
+short pga2, 
+short pga3, 
+short aeq
+);
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_pollTrainingStatus()
+*
+*********************************************************************************************
+* DESCRIPTION: code to decode modem status and to start modem training 
+*
+* Input: tidsl_t *ptidsl
+* 
+* Return: 0-? status mode training
+*         -1    failed
+*
+********************************************************************************************/
+int dslhal_api_pollTrainingStatus
+(
+ tidsl_t *ptidsl
+);
+
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_handleTrainingInterrupt()
+*
+*********************************************************************************************
+* DESCRIPTION: Code to handle ax5 hardware interrupts
+*
+* Input: tidsl_t *ptidsl
+*        int *pMsg, pointer to returned hardware messages. Each byte represent a messge
+*        int *pTag, pointer to returned hardware message tags. Each byte represent a tag.
+* Return: 0    success  
+*         1    failed
+*
+********************************************************************************************/
+int dslhal_api_handleTrainingInterrupt
+(
+ tidsl_t *ptidsl,
+ int intrSource
+);
+
+/******************************************************************************************    
+ * FUNCTION NAME:    dslhal_api_setEocSerialNumber(tidsl_t *ptidsl,char *SerialNumber)    
+ *    
+ *******************************************************************************************    
+ * DESCRIPTION: This fuction Sets the EOC Serial Number    
+ *    
+ * INPUT:  PITIDSLHW_T *ptidsl    
+ *         char *SerialNumber : Input EOC Serial Number  
+ *    
+ * RETURN: 0 SUCCESS    
+ *         1 FAILED    
+ *    
+ *****************************************************************************************/    
+unsigned int dslhal_api_setEocSerialNumber 
+( 
+tidsl_t *ptidsl, 
+char *SerialNumber 
+);    
+ 
+/******************************************************************************************     
+ * FUNCTION NAME:    dslhal_api_setEocVendorId(tidsl_t *ptidsl,char *VendorID)     
+ *     
+ *******************************************************************************************     
+ * DESCRIPTION: This fuction Sets the EOC Serial Number     
+ *     
+ * INPUT:  PITIDSLHW_T *ptidsl     
+ *         char *VendorID : EOC Vendor ID   
+ *     
+ * RETURN: 0 SUCCESS     
+ *         1 FAILED     
+ *     
+ *****************************************************************************************/     
+unsigned int dslhal_api_setEocVendorId  
+(  
+tidsl_t *ptidsl,  
+char *VendorID  
+);     
+ 
+/******************************************************************************************     
+ * FUNCTION NAME:    dslhal_api_setEocRevisionNumber(tidsl_t *ptidsl,char *RevNum)     
+ *     
+ *******************************************************************************************     
+ * DESCRIPTION: This fuction Sets the EOC Revision Number     
+ *     
+ * INPUT:  PITIDSLHW_T *ptidsl     
+ *         char *RevNum : Input EOC Revision Number   
+ *     
+ * RETURN: 0 SUCCESS     
+ *         1 FAILED     
+ *     
+ *****************************************************************************************/     
+unsigned int dslhal_api_setEocRevisionNumber 
+( 
+tidsl_t *ptidsl, 
+char *RevNumber 
+);     
+ 
+/******************************************************************************************      
+ * FUNCTION NAME:    dslhal_api_setAturConfig(tidsl_t *ptidsl,char *ATURConfig)      
+ *      
+ *******************************************************************************************      
+ * DESCRIPTION: This fuction Sets the EOC ATUR Config Register  
+ *      
+ * INPUT:  PITIDSLHW_T *ptidsl      
+ *         char *RevNum : Input EOC ATUR Config Register    
+ *      
+ * RETURN: 0 SUCCESS      
+ *         1 FAILED      
+ *      
+ *****************************************************************************************/      
+unsigned int dslhal_api_setAturConfig 
+(  
+tidsl_t *ptidsl,  
+char *ATURConfig 
+);      
+ 
+/******************************************************************************************   
+ * FUNCTION NAME:    dslhal_api_disableLosAlarm(tidsl_t *ptidsl, unsigned int set)   
+ *   
+ *******************************************************************************************   
+ * DESCRIPTION: This fuction disables all the LOS alarms   
+ *   
+ * INPUT:  PITIDSLHW_T *ptidsl   
+ *         unsigned int set // if set == TRUE : Disable LOS alarms, else enable
+ *          
+ * RETURN: 0 SUCCESS   
+ *         1 FAILED   
+ * NOTES:  Currently not supported in any version other than MR4 Patch release..    
+ *****************************************************************************************/   
+unsigned int dslhal_api_disableLosAlarm 
+( 
+tidsl_t *ptidsl,
+unsigned int 
+);   
+  
+/******************************************************************************************   
+ * FUNCTION NAME:    dslhal_api_sendIdle(tidsl_t *ptidsl)   
+ *   
+ *******************************************************************************************   
+ * DESCRIPTION: This fuction sends the CMD_IDLE message to the DSP   
+ *   
+ * INPUT:  PITIDSLHW_T *ptidsl   
+ *          
+ * RETURN: 0 SUCCESS   
+ *         1 FAILED   
+ *     
+ *****************************************************************************************/   
+unsigned int dslhal_api_sendIdle 
+( 
+tidsl_t *ptidsl 
+);   
+ 
+/******************************************************************************************    
+ * FUNCTION NAME:    dslhal_api_sendQuiet(tidsl_t *ptidsl)    
+ *    
+ *******************************************************************************************    
+ * DESCRIPTION: This fuction sends the CMD_QUIET message to the DSP    
+ *    
+ * INPUT:  PITIDSLHW_T *ptidsl    
+ *           
+ * RETURN: 0 SUCCESS    
+ *         1 FAILED    
+ *      
+ *****************************************************************************************/    
+unsigned int dslhal_api_sendQuiet  
+(  
+tidsl_t *ptidsl  
+);    
+
+/******************************************************************************************    
+ * FUNCTION NAME:    dslhal_api_sendDgasp(tidsl_t *ptidsl)    
+ *    
+ *******************************************************************************************    
+ * DESCRIPTION: This fuction sends the HOST_DGASP message to the DSP    
+ *    
+ * INPUT:  PITIDSLHW_T *ptidsl    
+ *           
+ * RETURN: 0 SUCCESS    
+ *         1 FAILED    
+ *      
+ *****************************************************************************************/    
+unsigned int dslhal_api_sendDgasp  
+(  
+tidsl_t *ptidsl  
+);    
+
+/******************************************************************************************    
+ * FUNCTION NAME:    dslhal_api_setMarginThreshold(tidsl_t *ptidsl, int threshold)    
+ *    
+ *******************************************************************************************    
+ * DESCRIPTION: This fuction does sets the Margin threshold   
+ *    
+ * INPUT:  PITIDSLHW_T *ptidsl    
+ *         int threshold   
+ *          
+ *                                    
+ * RETURN: 0 SUCCESS    
+ *         1 FAILED    
+ *    
+ *****************************************************************************************/    
+unsigned int dslhal_api_setMarginThreshold 
+( 
+tidsl_t *ptidsl, 
+int threshold 
+); 
+
+
+/******************************************************************************************  
+ * FUNCTION NAME:    dslhal_api_setMarginMonitorFlags(tidsl_t *ptidsl, unsigned int trainflag,unsigned int shwtflag)  
+ *  
+ *******************************************************************************************  
+ * DESCRIPTION: This fuction does sets the Margin monitoring flag 
+ *  
+ * INPUT:  PITIDSLHW_T *ptidsl  
+ *         unsigned int trainflag 
+ *         unsigned int shwtflag  
+ *                                  
+ * RETURN: 0 SUCCESS  
+ *         1 FAILED  
+ *  
+ *****************************************************************************************/  
+unsigned int dslhal_api_setMarginMonitorFlags
+(
+tidsl_t *ptidsl,
+unsigned int trainflag,
+unsigned int shwtflag
+);  
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_setRateAdaptFlag(tidsl_t *ptidsl)
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction Sets the Rate Adapt Enable Flag
+*
+* INPUT:  PITIDSLHW_T *ptidsl
+*         unsigned int flag //if flag = TRUE set flag else reset
+* RETURN: 0 SUCCESS
+*         1 FAILED
+*
+*****************************************************************************************/
+unsigned int dslhal_api_setRateAdaptFlag
+(
+tidsl_t *ptidsl,
+unsigned int flag
+);
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_setTrellisFlag(tidsl_t *ptidsl, unsigned int flag)
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction Sets the Trellis Coding Enable Flag
+*
+* INPUT:  PITIDSLHW_T *ptidsl
+*         unsigned int flag //if flag = TRUE set flag else reset
+* RETURN: 0 SUCCESS
+*         1 FAILED
+*
+*****************************************************************************************/
+unsigned int dslhal_api_setTrellisFlag
+(
+tidsl_t *ptidsl,
+unsigned int flag
+);
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_setMaxBitsPerCarrier(tidsl_t *ptidsl,unsigned int maxbits)
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction Sets the Maximum bits per carrier value
+*
+* INPUT:  PITIDSLHW_T *ptidsl
+*         unsigned int maxbits : should be a value between 0-15
+*
+* RETURN: 0 SUCCESS
+*         1 FAILED
+*
+*****************************************************************************************/
+unsigned int dslhal_api_setMaxBitsPerCarrier
+(
+tidsl_t *ptidsl,
+unsigned int maxbits
+);
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_setMaxInterleaverDepth(tidsl_t *ptidsl,unsigned int maxdepth)
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction Sets the Maximum Interleave Depth Supported
+*
+* INPUT:  PITIDSLHW_T *ptidsl
+*         unsigned int maxdepth : Should be between 0 and 3 depending on intlv buffer
+*                                 size 64-512
+* RETURN: 0 SUCCESS
+*         1 FAILED
+*
+*****************************************************************************************/
+unsigned int dslhal_api_setMaxInterleaverDepth
+(
+tidsl_t *ptidsl,
+unsigned int maxdepth
+);
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_api_setTrainingMode(tidsl_t *ptidsl,unsigned int trainmode)
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction Sets the desired training mode(none/T1.413/G.dmt/G.lite)
+*
+* INPUT:  PITIDSLHW_T *ptidsl
+*         unsigned int trainmode :Should be between 0 and 4; 0:No Mode 1:Multimode
+*                                 2: T1.413, 3:G.dmt, 4: G.lite
+* RETURN: 0 SUCCESS
+*         1 FAILED
+*
+*****************************************************************************************/
+
+unsigned int dslhal_api_setTrainingMode
+(
+tidsl_t *ptidsl,
+unsigned int trainmode
+);
+
+/******************************************************************************************   
+ * FUNCTION NAME:    dslhal_api_dslRetrain(tidsl_t *ptidsl)   
+ *   
+ *******************************************************************************************   
+ * DESCRIPTION: This fuction sends the CMD_QUIET message to the DSP   
+ *   
+ * INPUT:  PITIDSLHW_T *ptidsl   
+ *          
+ * RETURN: 0 SUCCESS   
+ *         1 FAILED   
+ *     
+ *****************************************************************************************/   
+unsigned int dslhal_api_dslRetrain 
+( 
+tidsl_t *ptidsl 
+);   
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_acknowledgeInterrupt()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_acknowledgeInterrupt
+(tidsl_t * ptidsl
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_disableDspHybridSelect()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_disableDspHybridSelect
+(tidsl_t * ptidsl,
+ unsigned int disable
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_disableDspHybridSelect()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_selectHybrid
+(tidsl_t * ptidsl,
+ unsigned int hybridNum
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_reportHybridMetrics()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_reportHybridMetrics
+(tidsl_t * ptidsl,
+ int     *metric
+);
+
+/******************************************************************************************   
+ * FUNCTION NAME:    dslhal_api_selectInnerOuterPair(tidsl_t *ptidsl, unsigned int pairSelect)   
+ *   
+ *******************************************************************************************   
+ * DESCRIPTION: This fuction sends the CMD_QUIET message to the DSP   
+ *   
+ * INPUT:  PITIDSLHW_T *ptidsl   
+ *          
+ * RETURN: 0 SUCCESS   
+ *         1 FAILED   
+ *     
+ *****************************************************************************************/   
+
+unsigned int dslhal_api_selectInnerOuterPair
+(tidsl_t *ptidsl,
+unsigned int pairSelect
+);
+
+/******************************************************************************************   
+ * FUNCTION NAME:    dslhal_api_resetTrainFailureLog(tidsl_t *ptidsl, unsigned int pairSelect)   
+ *   
+ *******************************************************************************************   
+ * DESCRIPTION: This fuction sends the CMD_QUIET message to the DSP   
+ *   
+ * INPUT:  PITIDSLHW_T *ptidsl   
+ *          
+ * RETURN: 0 SUCCESS   
+ *         1 FAILED   
+ *     
+ *****************************************************************************************/   
+
+unsigned int dslhal_api_resetTrainFailureLog
+(tidsl_t *ptidsl
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_controlLed()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_configureLed
+(tidsl_t * ptidsl,
+unsigned int idLed, 
+unsigned int onOff
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_configureExternBert()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_configureExternBert
+(tidsl_t * ptidsl,
+unsigned int configParm, 
+unsigned int parmVal
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_configureAtmBert()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_configureAtmBert
+(tidsl_t * ptidsl,
+unsigned int configParm, 
+unsigned int parmVal
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_configureDgaspLpr()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_configureDgaspLpr
+(tidsl_t * ptidsl,
+unsigned int configParm, 
+unsigned int parmVal
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_onOffPcb()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_advcfg_onOffPcb
+(tidsl_t * ptidsl,
+unsigned int onOff
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_onOffBitSwap()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Turns on / off the power cutback feature; 
+* Input
+*         usDs;  0 = us  and 1 = ds;
+*         onOff; 0 = OFF and 1 = ON
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_advcfg_onOffBitSwap
+(tidsl_t * ptidsl,
+ unsigned int usDs, 
+ unsigned int onOff
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_configDsTones()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Turns on / off specific tones in the downstream direction; 
+* Input
+*        pointer to the array specifying the tones to be turned on/off 
+*        
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_advcfg_configDsTones
+(tidsl_t * ptidsl,
+ unsigned int *dsTones
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_getAocBitSwapBuffer()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Fetches the Tx/Rx AOC bitswap Buffer; 
+* Input
+*        Transmit / Receive buffer to be fetched 
+*        
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_advcfg_getAocBitswapBuffer
+(tidsl_t * ptidsl,
+unsigned int usDs
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_readTrainingMessages()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Reads all the training messages on demand; 
+* Input
+*        tidsl_t *ptidsl : Pointer to application structure
+*        void *msgStruct : Pointer to Message Structure 
+*        
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_advcfg_readTrainingMessages
+(tidsl_t * ptidsl,
+void *msgPtr
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_getTrainingState()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Reads all the training messages on demand; 
+* Input
+*        tidsl_t *ptidsl : Pointer to application structure
+*        void *msgStruct : Pointer to training state structure 
+*        
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_advcfg_getTrainingState
+(tidsl_t * ptidsl,
+void *statePtr
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_resetBitSwapMessageLog()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Clears the Aoc Bitswap Message Log 
+* Input
+*        tidsl_t *ptidsl : Pointer to application structure
+*        unsigned int usDs ; Upstream=0, Downstream=1
+*
+* Return: 0  success
+*         1  failed
+* 
+********************************************************************************************/
+unsigned int dslhal_advcfg_resetBitSwapMessageLog
+(tidsl_t * ptidsl, 
+ unsigned int usDs
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_setConstellationBinNumber()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Specifies the bin number for which constellation data should be fetched
+* Input
+*        tidsl_t *ptidsl : Pointer to application structure
+*        unsigned int binNum : constellation bin number whose data is required
+*
+* Return: 0  success
+*         1  failed
+* 
+********************************************************************************************/
+unsigned int dslhal_advcfg_setConstellationBinNumber
+(tidsl_t * ptidsl, 
+ unsigned int binNum
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_resetTrainStateHistory()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Clears the Training State History Log 
+* Input
+*        tidsl_t *ptidsl : Pointer to application structure
+*        
+*
+* Return: 0  success
+*         1  failed
+* 
+********************************************************************************************/
+unsigned int dslhal_advcfg_resetTrainStateHistory
+(tidsl_t * ptidsl
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_getSnrPerBin()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Get SNR data per bin 
+* Input
+*        tidsl_t *ptidsl : Pointer to application structure
+*        
+*
+* Return: 0  success
+*         1  failed
+* 
+********************************************************************************************/
+unsigned int dslhal_advcfg_getSnrPerBin
+(tidsl_t * ptidsl,
+ unsigned int snrBufferOpt
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_logEocMessages()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Logs EOC messages sent by the Modem to the CO
+* Input
+*        tidsl_t *ptidsl : Pointer to application structure
+*        unsigned int eocLowerBytes : Lower [1-5] bits of EOC Message
+*        unsigned int eocUpperBytes : Upper [6-13] bits of EOC Message
+*
+* Return: 0  success
+*         1  failed
+* 
+********************************************************************************************/
+unsigned int dslhal_advcfg_logEocMessages
+(tidsl_t * ptidsl, 
+ unsigned int usDs,
+ unsigned int eocLowerBytes, 
+ unsigned int eocUpperBytes
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_getReasonForDrop()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Reads the reason for dropping DSL connection; 
+* Input
+*        tidsl_t *ptidsl : Pointer to application structure
+
+*        
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_advcfg_getReasonForDrop
+(tidsl_t * ptidsl
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_ctrlMaxAvgFineGains()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Turns on / off the host control for Max Avg Fine Gains; 0 = OFF and 1 = ON
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_advcfg_ctrlMaxAvgFineGains
+(tidsl_t * ptidsl,
+unsigned int onOff
+);
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_setMaxAvgFineGain()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Set the Maximum Average Fine Gain Value
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_advcfg_setMaxAvgFineGain
+(tidsl_t * ptidsl,
+ short fineGain
+);
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_readPhySettings()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Reads the advanced Phy layer settings on demand; 
+* Input
+*        tidsl_t *ptidsl : Pointer to application structure
+*        void *cfgStruct : Pointer to Phy Config Structure 
+*        
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_advcfg_readPhySettings
+(tidsl_t * ptidsl,
+void *cfgPtr
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_advcfg_setBlackOutBits()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the Blackout Bits in the RMSGPCB message
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_advcfg_setBlackOutBits
+(tidsl_t * ptidsl
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_genericDspRead()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*  Reads from a generic location in the host interface
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_genericDspRead
+(tidsl_t * ptidsl,
+ unsigned int offset1,
+ unsigned int offset2,
+ unsigned int offset3,
+ unsigned char* localBuffer,
+ unsigned int numBytes
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_genericDspWrite()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*  Writes to a generic location in the host interface
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_genericDspWrite
+(tidsl_t * ptidsl,
+ unsigned int offset1,
+ unsigned int offset2,
+ unsigned int offset3,
+ unsigned char* localBuffer,
+ unsigned int numBytes
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_dspInterfaceRead()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*  Reads from a generic location in the host interface
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_dspInterfaceRead
+(tidsl_t * ptidsl,
+ unsigned int baseAddr,
+ unsigned int numOffsets,
+ unsigned int *offsets,
+ unsigned char* localBuffer,
+ unsigned int numBytes
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_api_dspInterfaceWrite()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*  Writes to a generic location in the host interface
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_api_dspInterfaceWrite
+(tidsl_t * ptidsl,
+ unsigned int baseAddr,
+ unsigned int numOffsets,
+ unsigned int *offsets,
+ unsigned char* localBuffer,
+ unsigned int numBytes
+);
+
+/******************************************************************************************     
+ * FUNCTION NAME:    dslhal_api_sendMailboxCommand(tidsl_t *ptidsl, unsigned int cmd)     
+ *     
+ *******************************************************************************************     
+ * DESCRIPTION: This fuction sends the passed mailbox command to the DSP     
+ *     
+ * INPUT:  PITIDSLHW_T *ptidsl     
+ *         unsigned int cmd
+ *            
+ * RETURN: 0 SUCCESS     
+ *         1 FAILED     
+ *       
+ *****************************************************************************************/     
+unsigned int dslhal_api_sendMailboxCommand
+(tidsl_t *ptidsl, 
+unsigned int cmd
+); 
+
+#ifdef INTERNAL_BUILD
+#include <dsl_hal_internal_api.h>
+#endif
+
+
+#endif /* pairs #ifndef __DSL_APPLICATION_INTERFACE_H__ */
diff -urN linux.old/drivers/atm/sangam_atm/dsl_hal_logtable.h linux.dev/drivers/atm/sangam_atm/dsl_hal_logtable.h
--- linux.old/drivers/atm/sangam_atm/dsl_hal_logtable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/dsl_hal_logtable.h	2005-08-23 04:46:50.097843696 +0200
@@ -0,0 +1,259 @@
+unsigned int log10[]=
+{
+           0,
+         771,
+        1221,
+        1541,
+        1789,
+        1992,
+        2163,
+        2312,
+        2443,
+        2560,
+        2666,
+        2763,
+        2852,
+        2934,
+        3011,
+        3083,
+        3150,
+        3213,
+        3274,
+        3331,
+        3385,
+        3437,
+        3486,
+        3533,
+        3579,
+        3622,
+        3664,
+        3705,
+        3744,
+        3781,
+        3818,
+        3853,
+        3887,
+        3921,
+        3953,
+        3984,
+        4015,
+        4044,
+        4073,
+        4101,
+        4129,
+        4156,
+        4182,
+        4207,
+        4232,
+        4257,
+        4281,
+        4304,
+        4327,
+        4349,
+        4371,
+        4393,
+        4414,
+        4435,
+        4455,
+        4475,
+        4495,
+        4514,
+        4533,
+        4552,
+        4570,
+        4589,
+        4606,
+        4624,
+        4641,
+        4658,
+        4675,
+        4691,
+        4707,
+        4723,
+        4739,
+        4755,
+        4770,
+        4785,
+        4800,
+        4815,
+        4829,
+        4844,
+        4858,
+        4872,
+        4886,
+        4899,
+        4913,
+        4926,
+        4939,
+        4952,
+        4965,
+        4978,
+        4990,
+        5003,
+        5015,
+        5027,
+        5039,
+        5051,
+        5063,
+        5075,
+        5086,
+        5098,
+        5109,
+        5120,
+        5131,
+        5142,
+        5153,
+        5164,
+        5174,
+        5185,
+        5195,
+        5206,
+        5216,
+        5226,
+        5236,
+        5246,
+        5256,
+        5266,
+        5275,
+        5285,
+        5295,
+        5304,
+        5313,
+        5323,
+        5332,
+        5341,
+        5350,
+        5359,
+        5368,
+        5377,
+        5386,
+        5394,
+        5403,
+        5412,
+        5420,
+        5429,
+        5437,
+        5445,
+        5454,
+        5462,
+        5470,
+        5478,
+        5486,
+        5494,
+        5502,
+        5510,
+        5518,
+        5525,
+        5533,
+        5541,
+        5548,
+        5556,
+        5563,
+        5571,
+        5578,
+        5586,
+        5593,
+        5600,
+        5607,
+        5614,
+        5622,
+        5629,
+        5636,
+        5643,
+        5649,
+        5656,
+        5663,
+        5670,
+        5677,
+        5683,
+        5690,
+        5697,
+        5703,
+        5710,
+        5716,
+        5723,
+        5729,
+        5736,
+        5742,
+        5749,
+        5755,
+        5761,
+        5767,
+        5773,
+        5780,
+        5786,
+        5792,
+        5798,
+        5804,
+        5810,
+        5816,
+        5822,
+        5828,
+        5834,
+        5839,
+        5845,
+        5851,
+        5857,
+        5862,
+        5868,
+        5874,
+        5879,
+        5885,
+        5891,
+        5896,
+        5902,
+        5907,
+        5913,
+        5918,
+        5924,
+        5929,
+        5934,
+        5940,
+        5945,
+        5950,
+        5955,
+        5961,
+        5966,
+        5971,
+        5976,
+        5981,
+        5986,
+        5992,
+        5997,
+        6002,
+        6007,
+        6012,
+        6017,
+        6022,
+        6027,
+        6031,
+        6036,
+        6041,
+        6046,
+        6051,
+        6056,
+        6060,
+        6065,
+        6070,
+        6075,
+        6079,
+        6084,
+        6089,
+        6093,
+        6098,
+        6103,
+        6107,
+        6112,
+        6116,
+        6121,
+        6125,
+        6130,
+        6134,
+        6139,
+        6143,
+        6148,
+        6152,
+        6156,
+        6161,
+        6165
+    };
diff -urN linux.old/drivers/atm/sangam_atm/dsl_hal_register.h linux.dev/drivers/atm/sangam_atm/dsl_hal_register.h
--- linux.old/drivers/atm/sangam_atm/dsl_hal_register.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/dsl_hal_register.h	2005-08-23 04:46:50.097843696 +0200
@@ -0,0 +1,337 @@
+#ifndef ___DSL_REGISTER_DEFINES_H___
+#define ___DSL_REGISTER_DEFINES_H___ 1
+
+/*******************************************************************************
+* FILE PURPOSE:     DSL HAL H/W Registers and Constant Declarations for Sangam
+*
+********************************************************************************
+* FILE NAME:        dsl_hal_register.h
+*
+* DESCRIPTION:  
+*       Contains DSL HAL APIs for Adam2 OS functions
+*  
+*                    
+* (C) Copyright 2001-02, Texas Instruments, Inc.
+*    History
+*    Date        Version            Notes
+*    06Feb03     0.00.00            RamP   Created
+*    21Mar03     0.00.01            RamP   Changed header files for Modular 
+*                                          build framework
+*    21Mar03     0.00.02            RamP   Introduced malloc size for DSP f/w
+*    07Apr03     0.00.03            RamP   Implemented new error reporting scheme
+*                                          Changed Commenting to C style only
+*    12Apr03     0.00.04            RamP   Added Interrupt Mask defines
+*    14Apr03     0.00.05            RamP   Renamed macros for REG8, REG16 & REG32
+*    21Apr03     0.01.00            RamP   Added Interrupt source/clear registers
+*                                          Changed enum RSTATE_SHOWTIME to 5
+*    24Apr03     0.01.01            RamP   Moved the RSTATE enum to api.h
+*                                          Added olay recovery error condition
+*    14May03     0.01.02            RamP   Added defines for power computation
+*                                          Added error condition for hybrids
+*    04Jun03     0.01.03            RamP   Added enum for config flags, 
+*                                          Cleaned up AR5 register defines
+*                                          Added defines for higher data rate
+*    06Jun03     0.01.04            RamP   Added error & interrupt defines
+*    09Jun03     0.01.05            RamP   Modified enum for current config
+*                                          Added additional C-Rates defines
+*    18Jul03     0.01.06            RamP   Modified internal build flow
+*    21Aug03     0.01.07            RamP   Added constellation buffer size
+*    08Oct03     0.01.08            RamP   Added us/ds Bits n gains size
+*    12Oct03     0.01.08            RamP   Added ADSL2 Message sizes, lengths 
+*                                          and offsets for various formats
+*    29Oct03     0.01.09            RamP   Added ADSL2 Delt offsets & sizes
+*    24Nov03     0.01.10            RamP   Added bit field number, scan vector
+*    26Dec03     0.01.11            RamP   Removed the oamFeature masks to api.h
+*******************************************************************************/
+
+#include "env_def_typedefs.h"
+#ifdef INTERNAL_BUILD
+#include "dev_host_internalinterface.h"
+#endif
+#include "dev_host_interface.h"
+#include "dsl_hal_api.h"
+
+#define ADSLSS_BASE                                                     0x01000000
+#define BBIF_BASE                                                       0x02000000
+
+#define ADSLSSADR                                                       (BBIF_BASE+0x0000)
+#define ADSLSSADRMASK                                                   0xff000000
+#define WAKEUP_DSP                                            0x00000001
+
+/* Ax7 Reset Control */
+
+#define RST_CNTRL_BASE                                                  0x8611600
+#define RST_CNTRL_PRCR                                                  (RST_CNTRL_BASE + 0x00 )
+
+#define    RST_CNTRL_PRCR_GPIO                                  0x00000040
+#define    RST_CNTRL_PRCR_ADSLSS                                0x00000080
+#define    RST_CNTRL_PRCR_USB                                   0x00000100
+#define    RST_CNTRL_PRCR_SAR                                   0x00000200
+#define    RST_CNTRL_PRCR_DSP                                   0x00800000
+#define    RST_CNTRL_PRCR_EMAC1                                 0x00200000      /* EMAC1 reset */
+
+#define    RST_CNTRL_SWRCR                                      (RST_CNTRL_BASE + 0x04 )
+#define    RST_SWRCR_SWR0                                       0x00000001
+#define    RST_SWRCR_SWR1                                       0x00000002
+
+#define    RST_CNTRL_RSR                                        (TNETD53XX_RST_CNTRL_BASE + 0x08 )
+#define    RST_RSR_RSCAUSE                                      0x00000003   /* Software Reset Caused by writing to SWR1 bit */
+
+
+/* ******************************************************
+Interrupt sources on Ax7 interrupt controller.
+The reserved sources are noted.
+********************************************************* */
+
+#define INTR_CNTRL_SRC_SECOND                                   0
+#define INTR_CNTRL_SRC_EXTERNAL0                                1
+#define INTR_CNTRL_SRC_EXTERNAL1                                2
+/* reserved sources ... */
+#define INTR_CNTRL_SRC_TIMER0                                   5
+#define INTR_CNTRL_SRC_TIMER1                                   6
+#define INTR_CNTRL_SRC_UART0                                    7
+#define INTR_CNTRL_SRC_UART1                                    8
+#define INTR_CNTRL_SRC_DMA0                                     9
+#define INTR_CNTRL_SRC_DMA1                                     10
+/* reserved sources ... */
+#define INTR_CNTRL_SRC_SAR                                      15
+/* reserved sources ... */
+#define INTR_CNTRL_SRC_EMAC0                                    19
+/* reserved sources ... */
+#define INTR_CNTRL_SRC_VLYNQ0                                   21
+#define INTR_CNTRL_SRC_CODEC_WAKE                               22
+/* reserved sources ... */
+#define INTR_CNTRL_SRC_USB                                      24
+#define INTR_CNTRL_SRC_VLYNQ1                                   25
+/* reserved sources ... */
+#define INTR_CNTRL_SRC_EMAC1                                    28
+#define INTR_CNTRL_SRC_I2C                                      29
+#define INTR_CNTRL_SRC_DMA2                                     30
+#define INTR_CNTRL_SRC_DMA3                                     31
+/* reserved sources ... */
+#define INTR_CNTRL_SRC_VDMA_RX                                  37
+#define INTR_CNTRL_SRC_VDMA_TX                                  38
+#define INTR_CNTRL_SRC_ADSLSS                                   39
+
+#ifndef K0BASE 
+#define K0BASE                                                          0x80000000
+#endif
+
+#ifndef K1BASE 
+#define K1BASE                                                          0xA0000000
+#endif
+
+#ifndef PHYS_ADDR
+#define PHYS_ADDR(X)                                                    ((X) & 0X1FFFFFFF)
+#endif
+
+#ifndef PHYS_TO_K0
+#define PHYS_TO_K0(X)                                                   (PHYS_ADDR(X)|K0BASE)
+#endif
+
+#ifndef PHYS_TO_K1
+#define PHYS_TO_K1(X)                                                   (PHYS_ADDR(X)|K1BASE)
+#endif
+
+#ifndef DSLHAL_REG8
+#define DSLHAL_REG8( addr )                                          (*(volatile unsigned short *) PHYS_TO_K1(addr))
+#endif
+
+#ifndef DSLHAL_REG16
+#define DSLHAL_REG16( addr )                                         (*(volatile unsigned short *)PHYS_TO_K1(addr))
+#endif
+
+#ifndef DSLHAL_REG32
+#define DSLHAL_REG32( addr )                                         (*(volatile unsigned int *)PHYS_TO_K1(addr))
+#endif
+
+#ifndef NULL
+#define NULL    0
+#endif
+
+#ifndef TRUE
+#define TRUE    (1==1)
+#endif
+
+#ifndef FALSE
+#define FALSE   (1==2)
+#endif
+
+/*******************************************************************************
+* Type Defines for Library
+********************************************************************************/
+typedef unsigned int size_t;
+
+#define TIDSL_HW_CREATED                                                0x00000001
+#define TIDSL_HW_OPENED                                                 0x00000002
+#define TIDSL_HW_STARTED                                                0x00000004
+#define TIDSL_OS_INITIALIZED                                            0x00000008
+
+/* Data Pump CRATES Table Defines */
+#define SIZE_OF_CRATES1_TABLE                                           120
+#define CRATES1_BF_LS0                                                  7
+#define CRATES1_BI_LS0                                                  17
+#define CRATES1_BF_AS0                                                  0
+#define CRATES1_BI_AS0                                                  10
+#define CRATES1_BF_DSRS                                                 20
+#define CRATES1_BI_DSRS                                                 21
+#define CRATES1_BFI_DSS                                                 22
+#define CRATES1_BFI_DSI                                                 23
+#define CRATES1_BF_USRS                                                 25
+#define CRATES1_BI_USRS                                                 26
+#define CRATES1_BFI_USS                                                 27
+#define CRATES1_BFI_USI                                                 28
+
+#define FAST_PATH                                                       0
+#define INTERLEAVED_PATH                                                1
+
+#define LINE_NOT_CONNECTED                                              0
+#define LINE_CONNECTED                                                  1
+#define LINE_DISCONNECTED                                               2 
+#define LINE_NOT_TO_CONNECT                                             3 
+
+#define MAXSECTIONS                                                     125
+
+/*****************************************************************************************
+ * Localstructure declarations
+ *
+ ****************************************************************************************/
+enum
+{
+  DSLHAL_ERROR_NO_ERRORS,                /* 00 */
+  DSLHAL_ERROR_UNRESET_ADSLSS,           /* 01 */
+  DSLHAL_ERROR_RESET_ADSLSS,             /* 02 */
+  DSLHAL_ERROR_UNRESET_DSP,              /* 03 */ 
+  DSLHAL_ERROR_RESET_DSP,                /* 04 */    
+  DSLHAL_ERROR_NO_FIRMWARE_IMAGE,        /* 05 */
+  DSLHAL_ERROR_MALLOC,                   /* 06 */
+  DSLHAL_ERROR_FIRMWARE_MALLOC,          /* 07 */
+  DSLHAL_ERROR_DIAG_MALLOC,              /* 08 */
+  DSLHAL_ERROR_OVERLAY_MALLOC,           /* 09 */
+  DSLHAL_ERROR_CODE_DOWNLOAD,            /* 10 */
+  DSLHAL_ERROR_DIAGCODE_DOWNLOAD,        /* 11 */
+  DSLHAL_ERROR_BLOCK_READ,               /* 12 */  
+  DSLHAL_ERROR_BLOCK_WRITE,              /* 13 */  
+  DSLHAL_ERROR_MAILBOX_READ,             /* 14 */  
+  DSLHAL_ERROR_MAILBOX_WRITE,            /* 15 */
+  DSLHAL_ERROR_MAILBOX_NOMAIL,           /* 16 */
+  DSLHAL_ERROR_MAILBOX_OVERFLOW,         /* 17 */
+  DSLHAL_ERROR_INVALID_PARAM,            /* 18 */
+  DSLHAL_ERROR_ADDRESS_TRANSLATE,        /* 19 */
+  DSLHAL_ERROR_FIRMWARE_CRC,             /* 20 */
+  DSLHAL_ERROR_FIRMWARE_OFFSET,          /* 21 */
+  DSLHAL_ERROR_CONFIG_API_FAILURE,       /* 22 */ 
+  DSLHAL_ERROR_EOCREG_API_FAILURE,       /* 23 */
+  DSLHAL_ERROR_VERSION_API_FAILURE,      /* 24 */
+  DSLHAL_ERROR_STATS_API_FAILURE,        /* 25 */
+  DSLHAL_ERROR_MARGIN_API_FAILURE,       /* 26 */
+  DSLHAL_ERROR_CTRL_API_FAILURE,         /* 27 */
+  DSLHAL_ERROR_HYBRID_API_FAILURE,       /* 28 */
+  DSLHAL_ERROR_MODEMENV_API_FAILURE,     /* 29 */
+  DSLHAL_ERROR_INTERRUPT_FAILURE,        /* 30 */
+  DSLHAL_ERROR_INTERNAL_API_FAILURE,     /* 31 */
+  DSLHAL_ERROR_DIGIDIAG_FAILURE,         /* 32 */
+  DSLHAL_ERROR_TONETEST_FAILURE,         /* 33 */
+  DSLHAL_ERROR_NOISETEST_FAILURE,        /* 34 */
+  DSLHAL_ERROR_MODEMSTATE,               /* 35 */
+  DSLHAL_ERROR_OVERLAY_CORRUPTED         /* 36 */
+};
+ 
+enum 
+{
+  CONFIG_FLAG_NOFLAG,                    /* 00 */
+  CONFIG_FLAG_TRELLIS,                   /* 01 */
+  CONFIG_FLAG_EC,                        /* 02 */
+  CONFIG_FLAG_RS                         /* 03 */
+};
+
+#define USE_EMIF_REV    0
+#define USE_CVR_REV     1
+#define TNETD53XX_MAXLOOP       10000
+#define REVERB          0
+#define MEDLEY          1
+#define NONINTENSE      0
+#define slavespace0 0xa1000000
+
+#define MASK_MAILBOX_INTERRUPTS 0x00000001
+#define MASK_BITFIELD_INTERRUPTS 0x00000002
+#define MASK_HEARTBEAT_INTERRUPTS 0x00000004
+#define DSP_INTERRUPT_SOURCE_REGISTER  0x020007A0
+#define DSP_INTERRUPT_CLEAR_REGISTER   0x020007A4
+
+#define DIGITAL_DIAG_MEMSIZE 1048576
+#define CRC32_QUOTIENT 0x04c11db7
+#define DSP_FIRMWARE_MALLOC_SIZE 0x7ffff
+#define DSP_CONSTELLATION_BUFFER_SIZE 1024*4
+#define LOG43125 9303
+#define US_NOMINAL_POWER (-38)
+#define US_BNG_LENGTH 32
+#define DS_BNG_LENGTH 256
+#define NUMBER_OF_BITFIELDS 4
+#define BITFIELD_SCAN 0x80000000
+
+/* ADSL Message offsets from Host Interface Pointer */
+
+/* ADSL2 Messages Index and Length defines */
+
+#define CMSGFMT_INDEX      0
+#define CMSGPCB_INDEX      1
+#define RMSGFMT_INDEX      2
+#define RMSGPCB_INDEX      3
+#define RMSG1LD_INDEX     13
+#define RMSG2LD_INDEX     14
+#define RMSG3LD_INDEX     15
+#define RMSG4LD_INDEX     16
+#define RMSG5LD_INDEX     17
+#define RMSG6LD_INDEX     18
+#define RMSG7LD_INDEX     19
+#define RMSG8LD_INDEX     20
+#define RMSG9LD_INDEX     21
+#define CMSG1LD_INDEX     22
+#define CMSG2LD_INDEX     23
+#define CMSG3LD_INDEX     24
+#define CMSG4LD_INDEX     25
+#define CMSG5LD_INDEX     26
+#define CMSGPCB2_INDEX    28
+#define CMSGPCB2L_INDEX   29
+#define RMSGFMT2_INDEX    30
+#define RMSGPCB2L_INDEX   31
+#define CMSG1ADSL2_INDEX  32
+#define RMSG1ADSL2_INDEX  33
+#define CMSG2ADSL2_INDEX  34
+#define RMSG2ADSL2_INDEX  35
+#define CPARAMS_INDEX     36
+#define RPARAMS_INDEX     37
+
+/* ADSL2 Message Sizes */
+
+#define CMSGFMT_SIZE       2
+#define RMSGFMT_SIZE       2
+#define CMSGPCB_SIZE       2
+#define CMSGPCB2_SIZE      6    /* Annex A with Blackout */
+#define CMSGPCB2L_SIZE    10    /* Annex B with Blackout */
+#define RMSGPCB_SIZE      36
+#define RMSG1LD_SIZE      16
+#define RMSGxLD_SIZE     258
+#define CMSG1LD_SIZE      16
+#define CMSG2LD_SIZE     130
+#define CMSG3LD_SIZE      66
+#define CMSG4LD_SIZE      34
+#define CMSG5LD_SIZE      34
+#define CMSG1ADSL2_SIZE   24   
+#define RMSG1ADSL2_SIZE    4
+#define CMSG2ADSL2_SIZE    4
+#define RMSG2ADSL2_SIZE   32
+#define CPARAMS_SIZE     136 
+#define RPARAMS_SIZE     808
+
+/* ADSL2 Plus Message Sizes (if Different from ADSL2) */
+
+#define RMSGPCB_P_SIZE     68
+#define CMSG1ADSL2P_SIZE   40 /* With Blackout */
+#define CPARAMS_PA_SIZE   168 
+#define RPARAMS_PA_SIZE  2088
+#define CPARAMS_PB_SIZE   296
+#define RPARAMS_PB_SIZE  2088
+
+#endif /* pairs #ifndef ___DSL_REGISTER_DEFINES_H___ */
diff -urN linux.old/drivers/atm/sangam_atm/dsl_hal_support.c linux.dev/drivers/atm/sangam_atm/dsl_hal_support.c
--- linux.old/drivers/atm/sangam_atm/dsl_hal_support.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/dsl_hal_support.c	2005-08-23 04:46:50.100843240 +0200
@@ -0,0 +1,2788 @@
+/*******************************************************************************
+* FILE PURPOSE:     DSL Driver API functions for Sangam
+*********************************************************************************
+* FILE NAME:        dsl_hal_support.c
+*
+* DESCRIPTION:  
+*       Contains DSL HAL APIs for Modem Control
+*  
+*                    
+* (C) Copyright 2001-02, Texas Instruments, Inc.
+*    History
+*    Date        Version            Notes
+*    06Feb03     0.00.00            RamP   Created
+*    21Mar03     0.00.01            RamP   Inserted byteswap functions
+*    07Apr03     0.00.02            RamP   Implemented new error reporting scheme
+*                                          Changed Commenting to C style only
+*    12Apr03     0.00.03            RamP   Added function to set Interrupt Bit
+*                                          Masks for bitfield & Mailboxes
+*    14Apr03     0.00.04            RamP   Added function to process modem state
+*                                          bit fields; renamed REG32 macros
+*                                          Changed interrupt bit field settings
+*    15Apr03     0.00.05            RamP   Fixed exit condition on dslShutdown
+*    21Apr03     0.01.00            RamP   Fixed dslShutdown function & changed
+*                                          loop counter for overlay byteswaps
+*                (Alpha)                   Added cache writeback for overlays
+*                                          Added function acknowledgeInterrupt
+*    22Apr03     0.01.01            RamP   Moved acknowledgeInterrupt into api
+*    24Apr03     0.01.02            RamP   Added function to compare crc32 with
+*                                          pre-computed value as a recovery 
+*                                          scheme for corrupt overlay pages
+*    28Apr03     0.01.03            RamP   Fixed a parameter in crc32 fxn call
+*    05May03     0.01.04            RamP   Fixed Message structure access in
+*                                          writeHostMailbox function
+*    14May03     0.01.05            RamP   Lookup to netService of dsp version
+*                (alpha ++)                to determine pots/isdn service
+*    21May03     0.01.06            RamP   Added support for CO profiles
+*    29May03     0.01.07            RamP   Added critical section tabs for block
+*                                          read/write operations
+*                                          Added functions to reload overlay pages
+*                                          and CO Profiles
+*    04Jun03     0.01.08            RamP   Added state transition timing counters
+*    06Jun03     0.01.09            RamP   Added Interrupt source parsing function
+*                                          Interrupt masking for heartbeat added
+*    09Jun03     0.01.10            RamP   Modified modem state bit field processing
+*                                          for structure changes in ITIDSLHW
+*                                          fixed problem in free memory for CO prof
+*    18Jul03     0.01.11            RamP   Optimized free memory for CO profiles &
+*                                          overlay pages in the supporting APIs  
+*    28Jul03     0.02.00            RamP   Modified the process bitfield functn
+*                                          for LED & Application State report
+*    21Aug03     0.03.00            RamP   Added logic to allocate & communicate
+*                                          memory for constellation buffer display
+*    29Sep03     0.03.01            RamP   Added API switch calls to advcfg module
+*                                          to abstract them from the API module
+*    12Oct03     0.03.02            RamP   Added API to gather ADSL2 Messages
+*    14Oct03     0.03.03            RamP   Added function to read CMsgsRA
+*    23Oct03     0.03.04            RamP   Changed train history index to circular 
+*                                          buffer upon rollover
+*    29Oct03     0.03.05            RamP   Added Adsl2 Delt Message Parsing 
+*    12Nov03     0.03.06            RamP   Fixed endianness issues with 
+*                                          Constellation Display
+*    14Nov03     0.03.07            RamP   Added function to gather CRates1/RRates1
+*                                          before they get overwritten by CRatesRA
+*    19Nov03     0.03.08            JohnP  Revised dslhal_support_aocBitSwapProcessing to
+*                                          prevent duplicate ATU-R bitswaps going to ACT
+*    24Nov03     0.03.09            RamP   Implemented detailed State Tracking through
+*                                          Modem State bit fields for ADSL/2
+*    12Dec03     0.03.10            RamP   Tokenized advanced configuration code
+*    12Dec03     0.03.11            RamP   Added state reset upon IDLE
+*    19Dec03     0.03.12            RamP   Added static adsl2 byteswap function for
+*                                          handling pointer to pointer cases 
+*                                          Changed adsl2 messages to correct pointer to 
+*                                          pointer dereferencing problems in some OS
+*    26Dec03     0.03.13            RamP   Setting Current Address for Constellation
+*                                          buffer in addition to start address
+*                                          Added additional check to overlay page malloc
+*******************************************************************************/
+#include "dsl_hal_register.h"
+#include "dsl_hal_support.h"
+
+static unsigned int dslhal_support_adsl2ByteSwap32(unsigned int in32Bits);
+
+/******************************************************************************************
+* FUNCTION NAME:     dslhal_support_unresetDslSubsystem
+*
+*******************************************************************************************
+* DESCRIPTION: This function unreset Dsl Subsystem
+*
+* INPUT:  None
+*
+* RETURN: 0 if Pass; 1 if Fail
+*
+*****************************************************************************************/
+int  dslhal_support_unresetDslSubsystem(void)
+{
+  dprintf(4," dslhal_support_unresetDslSubsystem()\n");
+  /* Put ADSLSS in to reset */
+  DSLHAL_REG32(0xa8611a10) = 0x1;
+  shim_osClockWait(64);
+  dprintf(5,"Selected APLL Reg \n");
+
+  DSLHAL_REG32(0xa8610a90) = 0x4;
+  shim_osClockWait(64);
+  dprintf(5,"Enable Analog PLL \n"); 
+
+  DSLHAL_REG32(0xa8610a90) = 0x77fe;
+  shim_osClockWait(64);
+  dprintf(5,"Set PLL for DSP\n");
+
+  /*  DSLHAL_REG32(0xa8611600) = 0x007f1bdf;*/
+  DSLHAL_REG32(0xa8611600) |= RST_CNTRL_PRCR_ADSLSS;
+  shim_osClockWait(64);
+  dprintf(5,"Brought ADSLSS out of Reset \n");
+
+  DSLHAL_REG32(0xa861090c) &= ~((1<<20)|(1<<21)|(1<<22)|(1<<23)|(1<<24)|(1<<25));
+  shim_osClockWait(64);
+  dprintf(5,"Configured GPIO 20-25 for McBSP \n"); 
+
+  /*DSLHAL_REG32(0xa8611600)           |= RST_CNTRL_PRCR_ADSLSS;*/
+
+  
+  /*  DSLHAL_REG32(0xa8611a04) = 0x00000001; 
+      shim_osClockWait(64); */
+
+  dprintf(4," dslhal_support_unresetDslSubsystem done\n");
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+
+/******************************************************************************************
+* FUNCTION NAME:     dslhal_support_resetDslSubsystem
+*
+*******************************************************************************************
+* DESCRIPTION: This function unreset Dsl Subsystem
+*
+* INPUT:  None
+*
+* RETURN: 0 if Pass; 1 if Fail
+*
+*****************************************************************************************/
+int  dslhal_support_resetDslSubsystem(void)
+{
+  dprintf(4, "dslhal_support_resetDslSubsystem \n");
+  /* Put ADSLSS into reset */
+  DSLHAL_REG32(0xa8611600) &= ~RST_CNTRL_PRCR_ADSLSS;
+  shim_osClockWait(64);
+  /*  DSLHAL_REG32(0xa8611a04) = 0x00000000;
+      shim_osClockWait(64); */
+  dprintf(4, "dslhal_support_resetDslSubsystem Done \n");
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_support_unresetDsp()
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction takes ax5 daugter board out of reset.
+*
+* INPUT:  None
+*
+* RETURN: 0  --successful.
+*         1  --failed
+*
+*****************************************************************************************/
+int dslhal_support_unresetDsp(void)
+{
+#ifdef PRE_SILICON
+  /* unsigned char value; */
+  int rc;
+
+  rc=dslhal_support_hostDspAddressTranslate((unsigned int)DEV_MDMA0_SRC_ADDR);
+  if(rc==DSLHAL_ERROR_ADDRESS_TRANSLATE)
+    {
+    dprintf(1, "dslhal_support_hostDspAddressTranslate failed\n");
+    return DSLHAL_ERROR_ADDRESS_TRANSLATE;
+    }
+  dprintf(5,"MDMA SRC: %08x\n", rc);
+  DSLHAL_REG32(rc) = 0x80000001;
+  rc=dslhal_support_hostDspAddressTranslate((unsigned int)DEV_MDMA0_DST_ADDR);
+  if(rc==DSLHAL_ERROR_ADDRESS_TRANSLATE)
+    {
+    dprintf(1, "dslhal_support_hostDspAddressTranslate failed\n");
+    return DSLHAL_ERROR_ADDRESS_TRANSLATE;
+    }
+  dprintf(5,"MDMA DST: %08x\n", rc);
+  DSLHAL_REG32(rc) = 0x02090001;
+  rc=dslhal_support_hostDspAddressTranslate((unsigned int)DEV_MDMA0_CTL_ADDR);
+  if(rc== DSLHAL_ERROR_ADDRESS_TRANSLATE)
+    {
+    dprintf(1, "dslhal_support_hostDspAddressTranslate failed\n");
+    return DSLHAL_ERROR_ADDRESS_TRANSLATE;
+    }
+  dprintf(5,"MDMA CTL: %08x\n", rc);
+  DSLHAL_REG32(rc) = (DEV_MDMA_START | DEV_MDMA_DST_INC | DEV_MDMA_SRC_INC |
+                         DEV_MDMA_BURST1 | (1 << DEV_MDMA_LEN_SHF));
+  /* statusMask = 0x00000010;*/
+#else
+  dprintf(4, "dslhal_support_unresetDsp()\n");
+  
+  /* Bring the DSP core out of reset */
+  /* DSLHAL_REG32(0xa8611600) = 0x00ff1bdf; */
+  DSLHAL_REG32(0xa8611600) |= RST_CNTRL_PRCR_DSP;
+  shim_osClockWait(64);
+  dprintf(5,"Brought DSP out of Reset \n");
+  dprintf(6,"Current Contents of PRCR: 0x%x\n",(unsigned int)DSLHAL_REG32(0xa8611600));
+  /* DSLHAL_REG32(0xa8611a0c) = 0x00000007;
+     shim_osClockWait(64); */
+#endif  
+
+  dprintf(4, "dslhal_support_unresetDsp() done\n");
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_support_resetDsp()
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction takes ax5 daugter board into reset.
+*
+* INPUT:  None
+*
+* RETURN: 0  --successful.
+*         1  --failed
+*
+*****************************************************************************************/
+int dslhal_support_resetDsp(void)
+{
+  dprintf(4, "dslhal_support_resetDsp \n");
+  /* Put ADSLSS into reset */
+  DSLHAL_REG32(0xa8611600) &= ~RST_CNTRL_PRCR_DSP;
+  shim_osClockWait(64);
+  dprintf(4, "dslhal_support_resetDsp Done \n");
+  return DSLHAL_ERROR_NO_ERRORS;
+}  
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_hostDspAddressTranslate()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Maps ax5 daugter card dsp memory address to avalanche memory space
+*
+* Input: unsigned int addr,  dsp memory address.
+*
+* Return: >=0, unsigned int, mapped Avalanche address(VBUS address). 
+*         -1,  mapping failed
+*         
+*
+********************************************************************************************/
+/* static unsigned int bbifmap0,bbifmap1; */
+
+unsigned int dslhal_support_hostDspAddressTranslate( unsigned int addr )
+{
+  unsigned int addrMap;
+  /* This function should just be used to move the memory window of the ADSLSS */
+  dprintf(5, "dslhal_support_hostDspAddressTranslate()\n");
+  
+  /*  select vbus to xbus memory  */
+  /*  addrMap = addr & 0xff000000; */
+  addrMap = addr & ADSLSSADRMASK;
+  
+  DSLHAL_REG32(ADSLSSADR) = addrMap;
+  
+  dprintf(6, "dslhal_support_hostDspAddressTranslate() done\n");
+#ifdef PRE_SILICON
+  return ((ADSLSS_BASE | (~ADSLSSADRMASK & addr))+ 0x00000100);
+  /* Added 0x100 for Pre-Silicon VLNQ offset.. to be removed for Silicon */
+#else
+  return ((ADSLSS_BASE | (~ADSLSSADRMASK & addr)));
+  /* Added 0x100 for Pre-Silicon VLNQ offset.. to be removed for Silicon */
+#endif
+
+}
+
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_support_blockWrite
+*
+*******************************************************************************************
+* DESCRIPTION: This rouin simulates DSP memory write as done in ax5 pci nic card 
+*
+* INPUT:  void *buffer, data need to written
+*         void *adde,   memory address to be written
+*         size_t count, number of bytes to be written
+*
+* RETURN:  0 --succeeded
+*          1 --Failed
+*
+*****************************************************************************************/
+
+int dslhal_support_blockWrite(void *buffer, void *addr, size_t count) 
+{
+  int rc, byteCnt=0;
+  unsigned char* ptr;
+  union 
+    {
+    unsigned char *cptr;
+    short *sptr;
+    int *iptr;
+    } src;
+  union 
+    {
+    int anint;                   /* DSP location */
+    unsigned char *cptr;         /* to avoid casts */
+    } dst;
+  union
+    {
+    unsigned int anint;
+    unsigned char byte[4];
+    }data,dword,sword;
+        
+  /* Enter Critical Section */
+  shim_osCriticalEnter();
+
+  dprintf(6, "dslhal_support_blockWrite\n");
+  
+  dprintf(6,"addr=0x%X, length=0x%X, buffer=0x%X\n", (unsigned int) addr, (unsigned int) count, (unsigned int)buffer); 
+  
+  src.cptr = (unsigned char*) buffer;      /* local buffer */
+  dst.cptr = addr;        /* DSP memory location */
+  
+  /*Maps address first*/
+  rc=dslhal_support_hostDspAddressTranslate((unsigned int)addr);
+  dprintf(5, "NewAddr: %08x\n", rc);
+  if(rc== DSLHAL_ERROR_ADDRESS_TRANSLATE)
+    {
+    dprintf(1, "dslhal_support_hostDspAddressTranslate failed\n");
+    return  DSLHAL_ERROR_ADDRESS_TRANSLATE;
+    }
+
+  dst.cptr=(unsigned char *)rc;
+  
+  /* check wether address is at 32bits boundary */
+  
+  if ((dst.anint & 0x3) && count)
+    {
+    sword.anint = *(unsigned int*)((unsigned int)src.cptr & 0xfffffffc);
+    dword.anint = DSLHAL_REG32((unsigned int)dst.cptr & 0xfffffffc);
+    sword.anint = (unsigned int) dslhal_support_byteSwap32(sword.anint);
+    dword.anint = (unsigned int) dslhal_support_byteSwap32(dword.anint);
+    ptr = (unsigned char *)((unsigned int)dst.cptr & 0xfffffffc);
+
+    if((dst.anint & 3) ==3)     /* last byte of a dword */
+      {
+      dword.byte[3] = sword.byte[3];
+      dst.anint++;            /* bump the address by one */
+      byteCnt++;
+      count--;  
+      }
+    
+    if((dst.anint & 3) ==1)     /* second byte */
+      {
+        if(count>3)
+          {
+            dword.byte[3] = sword.byte[3];
+            dst.anint++;
+            count--;
+            byteCnt++;
+          }
+        if(count>2)
+          {
+            dword.byte[2] = sword.byte[2];
+            dst.anint++;
+            count--;
+            byteCnt++;
+          }
+        if(count)
+          {
+            dword.byte[1] = sword.byte[1];
+            dst.anint++;
+            count--;
+            byteCnt++;
+          }
+      }
+    
+    if((dst.anint & 3) && (count >1))
+      {
+      dword.byte[2] = sword.byte[2];
+      dword.byte[3] = sword.byte[3];
+      byteCnt+=2;
+      dst.anint += 2;         /* bump the address by two */
+      count -= 2;             /* decrement the byte count by two */
+      }
+    
+    if((dst.anint & 3) && (count==1))
+      {
+      dword.byte[2] = sword.byte[2];
+      dst.anint++;
+      byteCnt++;
+      count--;
+      }
+    src.cptr = (char *)((unsigned int)src.cptr & 0xfffffffc); /* fix 032802 */
+    dword.anint = dslhal_support_byteSwap32(dword.anint); 
+    DSLHAL_REG32((unsigned int)ptr) = dword.anint;
+    ptr = src.cptr;
+    for(rc=0;rc<count;rc++)
+      {
+        *ptr = *(ptr+byteCnt);
+        ptr++;
+      }
+    }
+  
+  /* the dst pointer should now be on a 32-bit boundary   */
+
+  while (count > 3) 
+    {
+     DSLHAL_REG32((unsigned int)dst.cptr) = dslhal_support_byteSwap32(*src.iptr);
+     src.iptr++;                  /* bump the data pointer by four */
+     dst.anint += 4;              /* bump the address by four */
+     count -= 4;                  /* decrement the byte count by four */
+     }
+  
+  /* write remaining bytes */
+  if(count)
+    {
+    int i;
+    
+    data.anint= DSLHAL_REG32((unsigned int)dst.cptr);
+    data.anint=dslhal_support_byteSwap32(data.anint);
+    for (i=0; i< count; i++)
+      {
+        data.byte[i]=*(src.cptr+i);             
+      }
+    data.anint=dslhal_support_byteSwap32(data.anint);
+    DSLHAL_REG32((unsigned int)dst.cptr) = data.anint;
+    src.cptr +=count;
+    dst.anint +=count;
+    count=0;
+    }
+  dprintf(6, "dslhal_support_blockWrite done\n");
+  /* Exit Critical Section */
+  shim_osCriticalExit();
+  return DSLHAL_ERROR_NO_ERRORS;
+}   /* end of dslhal_support_blockWrite() */
+
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_support_blockRead
+*
+*********************************************************************************************
+* DESCRIPTION: This rouin simulates DSP memory read as done in ax5 pci nic card
+*
+* INPUT:  void *addr,   memory address to be read
+*         void *buffer, dat buffer to be filled with from memmory
+*         size_t count, number of bytes to be written
+*
+* RETURN:  0 --succeeded
+*          1 --Failed
+*
+*****************************************************************************************/
+
+int dslhal_support_blockRead(void *addr, void *buffer, size_t count) 
+{
+    int rc;
+    union 
+        {
+        int anint;          /* DSP location */
+        char *cptr;         /* to avoid casts */
+        } src;
+    union 
+        {
+        char byte[4];
+        int anint;          /* DSP data */
+        } data;
+    union 
+        {
+        char *cptr;
+        int *iptr;
+        } dst;
+
+    /* Enter Critical Section */
+    shim_osCriticalEnter();
+
+    dprintf(6,"dslhal_support_blockRead\n");
+
+  
+    src.cptr = addr;        /* DSP memory location */
+    dst.cptr = buffer;      /* local buffer */
+
+    dprintf(6, "Read addr=0x%X, size=0x%X\n", (unsigned int)addr, count);
+
+
+    /*Maps address first*/
+    rc=dslhal_support_hostDspAddressTranslate((unsigned int)addr);
+    if(rc== DSLHAL_ERROR_ADDRESS_TRANSLATE)
+      {
+      dprintf(1, "dslhal_support_hostDspAddressTranslate failed\n");
+      return DSLHAL_ERROR_ADDRESS_TRANSLATE;
+      }
+
+    src.cptr=(unsigned char *)rc;
+
+    /**********************************************
+    *  if the source is NOT on a 32-bit boundary  *
+    *  then we read the full word                 *
+    *  and ignore the first part of it            *
+    **********************************************/
+
+    if ((src.anint & 3) && count) 
+        {
+                unsigned int anword;
+
+                anword = DSLHAL_REG32((unsigned int)src.cptr & 0xfffffffc);
+                data.anint = dslhal_support_byteSwap32(anword);
+
+        /************************************
+        *  there is no need for case 0      *
+        *  notice that there are no breaks  *
+        *  each falls through to the next   *
+        ************************************/
+
+        switch (src.anint & 3) 
+                {
+            case 1:
+                /* use only byte[1-3] */
+                *(dst.cptr++) = data.byte[1];
+                src.anint++;
+                count--;
+            case 2:
+                /* use byte[2-3] */
+                if (count) 
+                                {
+                    *(dst.cptr++) = data.byte[2];
+                    src.anint++;
+                    count--;
+                                }
+            case 3:
+                /* use byte[3] */
+                if (count) 
+                                {
+                    *(dst.cptr++) = data.byte[3];
+                    src.anint++;
+                    count--;
+                                }
+                }
+        }
+
+    /* the src pointer should now be on a 32-bit boundary */
+    while (count > 3) 
+        {
+                unsigned int anword;
+        
+                anword=DSLHAL_REG32((unsigned int)src.cptr);
+                
+                *dst.iptr = dslhal_support_byteSwap32(anword);
+        src.anint += 4;         /* bump the address by four */
+        dst.iptr++;             /* bump the data pointer by four */
+        count -= 4;             /* decrement the byte count by four */
+        }
+
+    /*******************************
+    *  if there's any count left   *
+    *  then we read the next word  *
+    *  and ignore the end of it    *
+    *******************************/
+    if (count) 
+        {
+                unsigned int anword;
+
+                anword= DSLHAL_REG32((unsigned int)src.cptr);
+                data.anint = dslhal_support_byteSwap32(anword);
+
+        /************************************
+        *  there is no need for case 0      *
+        *  notice that there are no breaks  *
+        *  each falls through to the next   *
+        ************************************/
+        switch (count) 
+                {
+            case 1:
+                /* use byte[0] */
+                *(dst.cptr++) = data.byte[0];
+                src.anint++;
+                count--;
+                break;
+            case 2:
+                /* use byte[0-1] */
+                *(dst.cptr++) = data.byte[0];
+                *(dst.cptr++) = data.byte[1];
+                src.anint +=2;
+                count -= 2;
+                break;
+            case 3:
+                /* use only byte[0-2] */
+                *(dst.cptr++) = data.byte[0];
+                *(dst.cptr++) = data.byte[1];
+                *(dst.cptr++) = data.byte[2];
+                src.anint +=3;
+                count -= 3;
+                break;
+                }
+        }
+  /* Exit Critical Section */
+  shim_osCriticalExit();
+
+  return DSLHAL_ERROR_NO_ERRORS;
+  
+}   /* end of dslhal_support_blockRead() */
+
+
+/********************************************************************************************
+* FUNCTION NAME:    dslhal_support_readDspMailbox
+*
+*********************************************************************************************
+* DESCRIPTION: Reads a message from the mailbox
+*
+* ARGUMENTS:   int *pcmd           Pointer to command read
+*
+* RETURNS:     0 if successful
+*              1 if no mail
+*              NZ otherwise
+*
+*****************************************************************************************/
+
+int dslhal_support_readDspMailbox(tidsl_t *ptidsl, int *pcmd, int *ptag, int *pprm1, int *pprm2) 
+{
+  int rc;
+  int cmd;
+  int tag;
+  int prm1;
+  int prm2;
+  unsigned char dspOutInx;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  DEV_HOST_mailboxControl_t mailboxControl;
+  DEV_HOST_dspHostMsg_t dspMailboxMsg[DEV_HOST_DSPQUEUE_LENGTH];
+  
+  dprintf(6,"dslhal_support_readDspMailbox\n");
+  
+  /* get the DSP main pointer */
+
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface, 
+                                     sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+
+  /* Read in the command/response buffer */
+  dspOamSharedInterface.dspHostMailboxControl_p = (DEV_HOST_mailboxControl_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.dspHostMailboxControl_p);
+  
+ 
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.dspHostMailboxControl_p, 
+                               &mailboxControl, sizeof(DEV_HOST_mailboxControl_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  
+  /* Change the endianness of the Mailbox Pointer */
+  mailboxControl.dspMsgBuf_p = (DEV_HOST_dspHostMsg_t *) dslhal_support_byteSwap32((unsigned int)mailboxControl.dspMsgBuf_p);
+
+  rc = dslhal_support_blockRead((PVOID)mailboxControl.dspMsgBuf_p, 
+                                     &dspMailboxMsg, (sizeof(DEV_HOST_dspHostMsg_t)*DEV_HOST_DSPQUEUE_LENGTH));
+  
+  if (rc) 
+    return DSLHAL_ERROR_BLOCK_READ;
+  /* Extract the command/response message index */
+  mailboxControl.hostInInx &= 7;   
+  mailboxControl.hostOutInx &= 7;
+  mailboxControl.dspOutInx &= 7;
+  mailboxControl.dspInInx &= 7;
+  
+  
+  /* check for messages in the mailbox */
+  
+  if (mailboxControl.dspOutInx == mailboxControl.dspInInx) 
+    {
+    return DSLHAL_ERROR_MAILBOX_NOMAIL;
+    /* no messages to read */ 
+    }
+  
+  /* use bDRESPOutInx as index to DRESPMsgBuf */
+  
+  cmd = dspMailboxMsg[mailboxControl.dspOutInx].cmd;
+  tag = dspMailboxMsg[mailboxControl.dspOutInx].tag;
+  prm1= dspMailboxMsg[mailboxControl.dspOutInx].param1;
+  prm2= dspMailboxMsg[mailboxControl.dspOutInx].param2;
+  
+  mailboxControl.dspOutInx++;      /* increment count */ 
+  mailboxControl.dspOutInx &= 7;   /* only two bits */
+  
+  dspOutInx = mailboxControl.dspOutInx;
+  
+  /* Read in the command response buffer again to take care of changes */
+  mailboxControl.dspOutInx = dspOutInx;
+  rc = dslhal_support_blockWrite(&mailboxControl.dspOutInx, 
+                                      &dspOamSharedInterface.dspHostMailboxControl_p->dspOutInx, sizeof(BYTE));
+  
+  if (rc) 
+    return DSLHAL_ERROR_BLOCK_WRITE;
+  
+  /* Is the input parameter address non-zero*/
+  
+  if (pcmd)
+    {
+    *pcmd = cmd;
+    }
+  if (ptag) 
+    {
+    *ptag = tag;
+    }
+  if (pprm1)
+    {
+    *pprm1 = prm1;
+    }
+  if (pprm2)
+    {
+    *pprm2 = prm2;
+    }
+ 
+  dprintf(6,"dslhal_support_readDspMailbox done\n");
+  dprintf(6,"cmd=%d, tag=%d\n", cmd, tag);
+  dprintf(6,"dslhal_support_readDspMailbox:cmd: 0x%x, tag=%d\n", cmd, tag);
+  return DSLHAL_ERROR_NO_ERRORS;
+  
+} /* end of dslhal_support_readDspMailbox() */
+
+/*******************************************************************************************
+* FUNCTION NAME:    dslhal_support_writeHostMailbox
+*
+********************************************************************************************
+* DESCRIPTION: Send a message to a mailbox
+*
+* ARGUMENTS:   int cmd             command to write
+*              int tag             tag (currently unused)
+*              int p1              parameter 1 (currently unused)
+*              int p2              parameter 2 (currently unused)
+*
+* RETURNS:     0 if successful
+*              NZ otherwise
+*
+*******************************************************************************************/
+
+int dslhal_support_writeHostMailbox(tidsl_t *ptidsl, int cmd, int tag, int p1, int p2) 
+{
+  int rc;
+  int index;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  DEV_HOST_mailboxControl_t mailboxControl;
+  DEV_HOST_dspHostMsg_t hostMailboxMsg[DEV_HOST_HOSTQUEUE_LENGTH];
+  unsigned char hostInInx;
+  
+  dprintf(6,"dslhal_support_writeHostMailbox:cmd: 0x%x, tag=%d\n", cmd, tag);
+  
+  dprintf(6,"cmd=%d, tag=%d\n", cmd, tag);  
+  
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+  
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface, 
+                                sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  /* Read in the command/response buffer */
+  dspOamSharedInterface.dspHostMailboxControl_p = (DEV_HOST_mailboxControl_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.dspHostMailboxControl_p);
+  
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.dspHostMailboxControl_p, 
+                                &mailboxControl, sizeof(DEV_HOST_mailboxControl_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  /* Change the endianness of the Mailbox Control Pointer */
+  mailboxControl.hostMsgBuf_p = (DEV_HOST_dspHostMsg_t *) dslhal_support_byteSwap32((unsigned int)mailboxControl.hostMsgBuf_p);
+  rc = dslhal_support_blockRead((PVOID)mailboxControl.hostMsgBuf_p, 
+                                &hostMailboxMsg, (sizeof(DEV_HOST_dspHostMsg_t)*DEV_HOST_HOSTQUEUE_LENGTH));
+  
+  if (rc) 
+    return DSLHAL_ERROR_BLOCK_READ;
+  /* Extract the command/response message index */ 
+  mailboxControl.hostInInx &= 7;       
+  mailboxControl.hostOutInx &= 7;
+  mailboxControl.dspOutInx &= 7;
+  mailboxControl.dspInInx &= 7;
+  
+  /* make sure there's room in the mailbox */
+  
+  index = mailboxControl.hostInInx;
+  mailboxControl.hostInInx++;
+  mailboxControl.hostInInx &= 7;  
+  hostInInx = mailboxControl.hostInInx;
+  if (mailboxControl.hostInInx == mailboxControl.hostOutInx) 
+    {
+      /* mailbox is full */ 
+      return DSLHAL_ERROR_MAILBOX_OVERFLOW;
+    }
+  
+  /* use bOCMDInInx as index to OCMDMsgBuf */
+  hostMailboxMsg[index].cmd = (BYTE) cmd;
+  hostMailboxMsg[index].tag = (BYTE) tag;
+  hostMailboxMsg[index].param1 = (BYTE) p1;
+  hostMailboxMsg[index].param2 = (BYTE) p2;
+  rc = dslhal_support_blockWrite(&hostMailboxMsg,
+                                 (PVOID)mailboxControl.hostMsgBuf_p,
+                                 sizeof(DEV_HOST_dspHostMsg_t)*DEV_HOST_HOSTQUEUE_LENGTH);
+  if (rc)
+    {
+      dprintf(1,"dslhal_support_blockWrite failed\n");
+      return DSLHAL_ERROR_BLOCK_READ;
+    }
+  rc = dslhal_support_blockWrite(&mailboxControl,
+                                 &dspOamSharedInterface.dspHostMailboxControl_p,
+                                 sizeof(DEV_HOST_mailboxControl_t));
+  if (rc) 
+    return DSLHAL_ERROR_BLOCK_WRITE;
+  /* update the index */
+  mailboxControl.hostInInx = hostInInx; 
+  rc = dslhal_support_blockWrite(&mailboxControl.hostInInx,
+                                 &dspOamSharedInterface.dspHostMailboxControl_p->hostInInx,
+                                 sizeof(BYTE));
+  if (rc) 
+    return DSLHAL_ERROR_BLOCK_WRITE;
+  
+  dprintf(6,"dslhal_support_writeHostMailbox done\n");
+ return DSLHAL_ERROR_NO_ERRORS;
+ 
+}  
+/* end of dslhal_support_writeHostMailbox() */
+
+
+/********************************************************************************************
+* FUNCTION NAME:    dslhal_support_readTextMailbox
+*
+*********************************************************************************************
+* DESCRIPTION: Reads a message from the mailbox
+*
+* ARGUMENTS:   int *pcmd           Pointer to command read
+*
+* RETURNS:     0 if successful
+*              1 if no mail
+*              NZ otherwise
+*
+*****************************************************************************************/
+
+int dslhal_support_readTextMailbox(tidsl_t *ptidsl, int *pmsg1, int *pmsg2) 
+{
+  int rc;
+  unsigned int msg1;
+  unsigned int msg2;
+  unsigned char textOutInx;
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  DEV_HOST_mailboxControl_t mailboxControl;
+  DEV_HOST_textMsg_t textMailboxMsg[DEV_HOST_TEXTQUEUE_LENGTH];
+  
+  dprintf(6,"dslhal_support_readTextMailbox\n");
+  
+  /* get the DSP main pointer */
+
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterfacePtr_t) ptidsl->pmainAddr;
+
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface, 
+                                     sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+
+  /* Read in the command/response buffer */
+  dspOamSharedInterface.dspHostMailboxControl_p = (DEV_HOST_mailboxControl_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.dspHostMailboxControl_p);
+  
+ 
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.dspHostMailboxControl_p, 
+                               &mailboxControl, sizeof(DEV_HOST_mailboxControl_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  
+  /* Change the endianness of the Mailbox Pointer */
+  mailboxControl.textMsgBuf_p = (DEV_HOST_textMsg_t *) dslhal_support_byteSwap32((unsigned int)mailboxControl.textMsgBuf_p);
+
+  rc = dslhal_support_blockRead((PVOID)mailboxControl.textMsgBuf_p, 
+                                     &textMailboxMsg, (sizeof(DEV_HOST_textMsg_t)*DEV_HOST_DSPQUEUE_LENGTH));
+  
+  if (rc) 
+    return DSLHAL_ERROR_BLOCK_READ;
+  /* Extract the command/response message index */
+  
+  mailboxControl.textInInx &= 7;   
+  mailboxControl.textOutInx &= 7;
+   
+  /* check for messages in the mailbox */
+  
+  if (mailboxControl.textOutInx == mailboxControl.textInInx) 
+    {
+    return DSLHAL_ERROR_MAILBOX_NOMAIL;
+    /* no messages to read */ 
+    }
+  
+  /* use bDRESPOutInx as index to DRESPMsgBuf */
+  
+  msg1 = textMailboxMsg[mailboxControl.textOutInx].msgPart1;
+  msg2 = textMailboxMsg[mailboxControl.textOutInx].msgPart2;
+  msg1 = (unsigned int) dslhal_support_byteSwap32((unsigned int)msg1);
+  msg2 = (unsigned int) dslhal_support_byteSwap32((unsigned int)msg2);
+
+  mailboxControl.textOutInx++;      /* increment count */ 
+  mailboxControl.textOutInx &= 7;   /* only two bits */
+  
+  textOutInx = mailboxControl.textOutInx;
+  
+  /* Read in the command response buffer again to take care of changes */
+
+  mailboxControl.textOutInx = textOutInx;
+  
+  rc = dslhal_support_blockWrite(&mailboxControl.textOutInx, 
+                                      &dspOamSharedInterface.dspHostMailboxControl_p->textOutInx, sizeof(BYTE));
+  
+  if (rc) 
+    return DSLHAL_ERROR_BLOCK_WRITE;
+  
+  /* Is the input parameter address non-zero*/
+  
+  if (pmsg1)
+    {
+    *pmsg1 = msg1;
+    }
+  if (pmsg2) 
+    {
+    *pmsg2 = msg2;
+    }
+
+  dprintf(6,"dslhal_support_readTextMailbox done\n");
+  dprintf(6,"msgPart1=%d, msgPart2=%d\n", msg1, msg2);
+  dprintf(6,"dslhal_support_readTextMailbox:Message Part1: 0x%x, tag=0x%x\n", msg1, msg2);
+  return DSLHAL_ERROR_NO_ERRORS;
+  
+} /* end of dslhal_support_readTextMailbox() */
+
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_hostDspCodeDownload()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   download DSP image from host memory to dsp memory
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+int dslhal_support_hostDspCodeDownload(tidsl_t * ptidsl)
+{
+
+  unsigned int index;
+  int rc = 0, i;
+  unsigned char *iptr;             /* image pointer */
+  unsigned int numbytes,olayXfer,olayStore;
+  /*  unsigned int holdSecPhyAddr=0,holdSecVirtAddr; */
+  unsigned int *olayStart;
+  size_t len;             /* size of the file */
+  size_t expoffset;       /* expected offset for next section header */
+  unsigned short checksum;
+  unsigned int crc32;
+  unsigned char * image;
+  char *tmp = (char *)DEV_HOST_DSP_OAM_POINTER_LOCATION;
+  DEV_HOST_dspVersionDef_t        dspVersion;
+#if SWTC 
+  DEV_HOST_tcHostCommDef_t        TCHostCommDef;
+#endif
+  DEV_HOST_oamWrNegoParaDef_t     OamWrNegoParaDef;
+  DEV_HOST_dspOamSharedInterface_t dspOamSharedInterface, *pdspOamSharedInterface;
+  DEV_HOST_olayDpDef_t            olayDpParms;
+  DEV_HOST_profileBase_t          profileList;
+#ifndef NO_ACT
+  DEV_HOST_consBufDef_t           constDisp;
+#endif
+#if CO_PROFILES
+  DEV_HOST_coData_t               coData;
+#endif
+  DEV_HOST_olayDpPageDef_t        olayDpPageDef[NUM_PAGES];
+  union 
+  {
+  char byte[4];
+  unsigned short hword[2];
+  unsigned int aword;
+  } data;
+  
+  struct _header
+  {
+  char signature[6];
+  unsigned short sectcount;
+  unsigned int length;
+  } header;
+  
+  struct _section 
+  {
+  unsigned int addr;
+  unsigned int length;
+  unsigned int offset;
+  unsigned int page;
+  };/* section[MAXSECTIONS]; */
+  
+  struct _section *sptr;
+  unsigned int secAddr, secLength, secOffset, secPage;
+  
+  
+  dprintf(5,"dslhal_support_hostDspCodeDownload\n"); 
+  image = ptidsl->fwimage;
+  
+  if (!image) 
+    {
+      dprintf(1,"no image file\n"); 
+    return DSLHAL_ERROR_NO_FIRMWARE_IMAGE;
+    }
+  
+  iptr=image;
+  
+  numbytes = sizeof(header); 
+  
+  shim_osMoveMemory((char *) &header, (char *)iptr, numbytes);
+  header.length = dslhal_support_byteSwap32(header.length);
+  header.sectcount = dslhal_support_byteSwap16(header.sectcount);
+#if 0 
+  crc32 = dslhal_support_computeCrc32((unsigned char*)&crcTest[0],20);
+  dprintf(6,"CRC-32 for the crcTest: 0x%x",crc32);
+  dprintf(4,"header.length=%d, header.sectcount=0x%X\n", header.length, header.sectcount);
+#endif
+  /* point to the checksum */
+  /* compute the checksum on CRC32 here */
+  iptr = image + header.length-4;
+  numbytes = sizeof(data.aword);
+  
+  dprintf(5,"tiload: check checksum\n"); 
+  shim_osMoveMemory((char *)&(data.byte), (char *)iptr, numbytes);
+  
+  crc32 = dslhal_support_computeCrc32(image,ptidsl->imagesize);
+  dprintf(5,"CRC-32 for the Binary: 0x%x",crc32);
+  /* CRC currently not added to the DSP binary, so this code is commented out */
+  /* 
+  data.aword = dslhal_support_byteSwap32(data.aword);
+  if (data.aword != crc32) 
+    {
+      dprintf(1,"Checksum error\n");
+    }
+  */
+  /* Verify signature - Changed from "320C6x" to "TIDSL" for load 80 */
+  
+  header.signature[5]='\0';
+  dprintf(5, "signature=%s\n", header.signature);
+  
+  if (shim_osStringCmp(header.signature, "TIDSL")) 
+    {
+      dprintf(1,"Signature not match\n");
+      return DSLHAL_ERROR_FIRMWARE_OFFSET;
+    }
+  
+  dprintf(5,"tiload: check sect count\n");
+  /* check section count */
+ 
+  if (header.sectcount > MAXSECTIONS) 
+    {
+      dprintf(1,"Section # %d exceeds max %d\n", header.sectcount, MAXSECTIONS);
+      return DSLHAL_ERROR_FIRMWARE_OFFSET;
+    } 
+  else
+    {
+    dprintf(5,"found %d sections\n", header.sectcount);
+    }
+
+  /* Validation of Section offsets */
+  
+  /* point to the first section */
+  len = header.length;              /* file size in bytes */
+  expoffset = sizeof(struct _header) + header.sectcount * sizeof(struct _section);
+  
+  dprintf(5,"tiload: check offset\n");
+  for (index=0; index<header.sectcount; index++) /* parse the sections one by one */
+    {
+      numbytes = sizeof(struct _header) + index * sizeof(struct _section); /* Compute Section Offset */
+      sptr = (struct _section *)(image + numbytes); /* Section Pointer to beginning of the section */
+      
+    secAddr   = dslhal_support_byteSwap32(sptr->addr);
+    secOffset = dslhal_support_byteSwap32(sptr->offset);
+    secLength = dslhal_support_byteSwap32(sptr->length);
+    secPage   = dslhal_support_byteSwap32(sptr->page);
+    
+    /* validate offset */
+    if ( secOffset== 0xffffffff) 
+      {
+      /* special case: zero fill */
+      /* offset is valid, don't change expoffset */
+      } 
+    else 
+      {
+      if (secOffset > len-4) 
+        {
+          dprintf(5,"Offset error\n"); 
+          return DSLHAL_ERROR_FIRMWARE_OFFSET;
+        }
+      
+      /* determine expected offset of NEXT section  */
+      expoffset = secLength + secOffset;
+      
+      /* all addresses must be on word boundaries */
+      if (secAddr & 3) 
+        {
+          
+        }
+      }
+    }
+  
+  /* check final offset - should just be a checksum left */
+/* IMPORTANT 11/24/02 --> Got this error... but bypassed for Pf of Concept*/
+  /*
+  if (expoffset != len-4) 
+    {
+      dprintf(5,"Final offset error\n");
+      return DSLHAL_ERROR_FIRMWARE_OFFSET;
+    }
+  */
+
+  /* Actual Code loading to DSP Memory */  
+
+  /* Initialize DSP Data Memory before code load*/
+  dprintf(5,"Zero Prefill DSP DMEM\n");
+  DSLHAL_REG32(ADSLSSADR)=0x80000000;
+  shim_osZeroMemory((char *)0xa1000000, 0x10000);
+  /* Load sections from the image */
+  for (index=0; index<header.sectcount; index++) /* Parse each section */
+    {
+    numbytes = sizeof(header) + index * sizeof(struct _section); /* Compute offset to next section */
+    sptr = (struct _section *)(image + numbytes);   /* Point to next section */
+   
+    secAddr   = dslhal_support_byteSwap32(sptr->addr);
+    secOffset = dslhal_support_byteSwap32(sptr->offset);
+    secLength = dslhal_support_byteSwap32(sptr->length);
+    secPage   = dslhal_support_byteSwap32(sptr->page);
+    
+    data.aword = secAddr;
+    checksum += data.byte[0] + data.byte[1] + data.byte[2] + data.byte[3];
+    
+    data.aword = secLength;
+    checksum += data.byte[0] + data.byte[1] + data.byte[2] + data.byte[3];
+    
+    data.aword = secOffset;
+    checksum += data.byte[0] + data.byte[1] + data.byte[2] + data.byte[3];
+    
+    data.aword = secPage;
+    checksum += data.byte[0] + data.byte[1] + data.byte[2] + data.byte[3];
+    
+    
+    /* validate offset */
+    if (secOffset == 0xffffffff) 
+      {
+      /* special case: zero fill */
+      /* offset is valid, don't change expoffset */
+      } 
+    else 
+      {
+      /* real offset */
+      if(secOffset > len-4) 
+        {
+        dprintf(5,"section[%u] offset too big (%X/%X)\n", index,
+                secOffset, len-4);
+        
+        return DSLHAL_ERROR_FIRMWARE_OFFSET;
+        }
+      
+      /* determine expected offset of NEXT section */
+      expoffset = secLength + secOffset;
+      
+      }
+    
+    }  
+  
+  /* check final offset - should just be a checksum left */
+  /*
+  if(expoffset != len-4) 
+    {
+      dprintf(1,"sections don't span full file (%X/%X)\n",expoffset,len-2);   
+      return DSLHAL_ERROR_FIRMWARE_OFFSET;
+    }
+  */
+  dprintf(5,"tiload: load binary\n");
+  
+  for (index=0; index<header.sectcount; index++)
+    {
+    numbytes = sizeof(header) + index * sizeof(struct _section);
+    sptr = (struct _section *)(image + numbytes);  
+    
+    secAddr   = dslhal_support_byteSwap32(sptr->addr);
+    secOffset = dslhal_support_byteSwap32(sptr->offset);
+    secLength = dslhal_support_byteSwap32(sptr->length);
+    secPage   = dslhal_support_byteSwap32(sptr->page);
+    dprintf(5,"loading section %u\n", index);
+    dprintf(5,"section %u: addr: %X\n", index, secAddr);
+    dprintf(5,"section %u: length: %X\n", index, secLength);
+    dprintf(5,"section %u: offset: %X\n", index, secOffset);
+    dprintf(5,"section %u: page: %X\n", index, secPage);
+
+    /* point to the section's data */
+    if(secOffset != 0xffffffff) 
+      {
+      /* Load this section of data */
+      iptr = image + secOffset;
+      dprintf(6, "iptr %8x\n", (unsigned int)iptr);
+      }
+    
+    if(secPage)
+      { 
+      dprintf(6,"OVERLAY PAGE #%d\n",secPage);
+      /* overlay page, don't write to dsp yet, save into host memory*/
+
+      dprintf(6,"Section Length: %d \n",secLength);
+      ptidsl->olayDpPage[secPage].PmemStartWtAddr  = (unsigned int) shim_osAllocateDmaMemory(secLength);
+      if(ptidsl->olayDpPage[secPage].PmemStartWtAddr == NULL)
+       {
+          dprintf(1, "overlay page allocate error\n");
+          return DSLHAL_ERROR_OVERLAY_MALLOC;
+        }
+#ifdef PRE_SILICON
+      ptidsl->olayDpPage[secPage].overlayHostAddr = ((((ptidsl->olayDpPage[secPage].PmemStartWtAddr)-0x84000000)-0x10000000)+0x030b0000);
+#else
+      /*      ptidsl->olayDpPage[secPage].overlayHostAddr = ((unsigned int)(ptidsl->olayDpPage[secPage].PmemStartWtAddr)&~0xe0000000); */
+      ptidsl->olayDpPage[secPage].overlayHostAddr = virtual2Physical((unsigned int)ptidsl->olayDpPage[secPage].PmemStartWtAddr);
+#endif
+      dprintf(6,"Allocated Addr: 0x%x \t Xlated Addr: 0x%x \n",ptidsl->olayDpPage[secPage].PmemStartWtAddr,ptidsl->olayDpPage[secPage].overlayHostAddr);
+
+      ptidsl->olayDpPage[secPage].overlayHostAddr = (unsigned int)dslhal_support_byteSwap32(ptidsl->olayDpPage[secPage].overlayHostAddr);
+      ptidsl->olayDpPage[secPage].OverlayXferCount = secLength;
+      ptidsl->olayDpPage[secPage].BinAddr          = secAddr;
+      ptidsl->olayDpPage[secPage].SecOffset        = secOffset;
+      shim_osMoveMemory((char *)ptidsl->olayDpPage[secPage].PmemStartWtAddr, (char *)iptr, secLength);
+      /*   RamP Image ByteSwap test */
+      olayStart = (unsigned int *)ptidsl->olayDpPage[secPage].PmemStartWtAddr;
+            
+      for(olayXfer=0;olayXfer< secLength/4;olayXfer++)
+        {
+          olayStore = *(unsigned int *)olayStart;
+          olayStore = (unsigned int)dslhal_support_byteSwap32(olayStore);
+          *(unsigned int*)olayStart = olayStore;
+          dprintf(5, "Addr:0x%x \t Content: 0x%x \n",olayStart,olayStore);
+          olayStart++;
+          olayStore=0;
+        }
+      /* RamP Image ByteSwap test */
+      /* compute the CRC of each overlay page and Store the Checksum in a local global variable */
+      /* This Value of CRC is to be compared with the header where all the CRC bytes are lumped together */
+      ptidsl->olayDpPage[secPage].olayPageCrc32 = dslhal_support_computeCrc32((char *)ptidsl->olayDpPage[secPage].PmemStartWtAddr, ptidsl->olayDpPage[secPage].OverlayXferCount);
+
+      shim_osWriteBackCache((void *)ptidsl->olayDpPage[secPage].PmemStartWtAddr, secLength);
+      }
+    else
+      {      
+       rc = secAddr&0xff000000;
+       if(rc && rc!=0x80000000)
+        {
+          dprintf(4,"Not DSP PMEM/DMEM\n");
+          /* don't write to dsp, save into host memory*/
+          dprintf(4,"Section Addr: %x Section Length: %d \n",secAddr,secLength);
+          ptidsl->coProfiles.PmemStartWtAddr = (unsigned int) shim_osAllocateDmaMemory(secLength);
+          if(ptidsl->coProfiles.PmemStartWtAddr == NULL)
+          {
+           dprintf(1, "memory allocate error\n");
+           return DSLHAL_ERROR_OVERLAY_MALLOC;
+          }
+      ptidsl->coProfiles.overlayHostAddr =  virtual2Physical((unsigned int)ptidsl->coProfiles.PmemStartWtAddr);
+      dprintf(4,"Allocated Addr: 0x%x \t Xlated Addr: 0x%x \n",ptidsl->coProfiles.PmemStartWtAddr, ptidsl->coProfiles.overlayHostAddr);
+      ptidsl->coProfiles.overlayHostAddr = (unsigned int)dslhal_support_byteSwap32(ptidsl->coProfiles.overlayHostAddr);
+      ptidsl->coProfiles.OverlayXferCount = secLength;
+      ptidsl->coProfiles.BinAddr = secAddr;
+      ptidsl->coProfiles.SecOffset = secOffset;
+
+      shim_osMoveMemory((char *)ptidsl->coProfiles.PmemStartWtAddr, (char *)iptr, secLength);
+      /*   RamP Image ByteSwap test */
+      olayStart = (unsigned int *)ptidsl->coProfiles.PmemStartWtAddr;
+            
+      for(olayXfer=0;olayXfer< secLength/4;olayXfer++)
+        {
+          olayStore = *(unsigned int *)olayStart;
+          olayStore = (unsigned int)dslhal_support_byteSwap32(olayStore);
+          *(unsigned int*)olayStart = olayStore;
+          dprintf(5, "Addr:0x%x \t Content: 0x%x \n",olayStart,olayStore);
+          olayStart++;
+          olayStore=0;
+        }
+      shim_osWriteBackCache((void *)ptidsl->coProfiles.PmemStartWtAddr, secLength);
+        }
+      else
+        {
+      /* IMPORTANT: write image to DSP memory */
+      rc=dslhal_support_blockWrite((void *)iptr, (void *)secAddr, secLength);
+      if(rc)
+        {
+        dprintf(1,"dslhal_support_blockRead failed\n");
+        return DSLHAL_ERROR_BLOCK_READ;
+        }
+       shim_osClockWait(0x50000);
+      /*
+      rc=dslhal_support_blockRead((void*)secAddr, (void*)tmpBuffer, secLength);
+      if(rc)
+        {
+        dprintf(1,"dslhal_support_blockRead failed\n");
+        return DSLHAL_ERROR_BLOCK_READ;
+        }
+      for(i=0;i<secLength;i++)
+        {
+        if(*iptr
+        }*/
+        }
+      }
+    } /* end of write dsp image */
+
+  /***********************************************************************************
+   * Start to fillup various values to our hardware structure for late use
+   ************************************************************************************/
+  
+  /* get main pointer for data */
+
+  rc = dslhal_support_blockRead(tmp, &pdspOamSharedInterface, sizeof(unsigned int));
+  dprintf(5, "tmp=0x%X, addr=0x%X\n", (unsigned int)tmp, (unsigned int)pdspOamSharedInterface);
+  pdspOamSharedInterface= (DEV_HOST_dspOamSharedInterface_t *)dslhal_support_byteSwap32((unsigned int)pdspOamSharedInterface);
+  dprintf(5, "tmp=0x%X, addr=0x%X\n", (unsigned int)tmp, (unsigned int)pdspOamSharedInterface);
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  
+  if(!pdspOamSharedInterface)
+    {
+    dprintf(1,"Couldn't read main pointer\n");
+    return DSLHAL_ERROR_INVALID_PARAM;
+    }
+  
+  ptidsl->pmainAddr=pdspOamSharedInterface;
+
+  /* read the OamSharedInterfaceStructure */
+  
+  dprintf(5,"ptidsl->hostIf.mainAddr=0x%X\n", (unsigned int)ptidsl->pmainAddr);
+  
+  /* get the pointer to DSP-OAM Shared Interface */
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface, 
+                                     sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  /* Communicate the Allocated Memory Address to DSP to choose CO Profiles */
+
+  /* Change the Endianness of the profileList pointer */
+  dspOamSharedInterface.profileList_p = (DEV_HOST_profileBase_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.profileList_p);
+  /* Access the profileList Structure */
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.profileList_p,&profileList, sizeof(DEV_HOST_profileBase_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  dprintf(2,"Old Addr:%x  New: %x \n",profileList.hostProfileBase_p,ptidsl->coProfiles.overlayHostAddr); 
+  profileList.hostProfileBase_p = (DEV_HOST_coData_t *)ptidsl->coProfiles.overlayHostAddr;
+  rc = dslhal_support_blockWrite(&profileList,(PVOID)dspOamSharedInterface.profileList_p,sizeof(DEV_HOST_profileBase_t));
+     if (rc) 
+       return DSLHAL_ERROR_BLOCK_WRITE;
+
+  /* Communicate the Allocated Memory Address to DSP to do overlays */
+
+  /* Change the Endianness of the olayDpDef pointer */
+  dspOamSharedInterface.olayDpParms_p = (DEV_HOST_olayDpDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.olayDpParms_p);
+  /* Access the olayDpDef Structure */
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.olayDpParms_p,&olayDpParms, sizeof(DEV_HOST_olayDpDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+
+
+  for(i=1;i<NUM_PAGES;i++)
+   {
+  /* Change the endianness of the olayDpPageDef Pointer */
+     olayDpParms.olayDpPage_p[i] = (DEV_HOST_olayDpPageDef_t *) dslhal_support_byteSwap32((unsigned int)olayDpParms.olayDpPage_p[i]);
+     /* Access the olayDpPageDef Structure */
+     rc = dslhal_support_blockRead((PVOID)olayDpParms.olayDpPage_p[i],&olayDpPageDef[i],sizeof(DEV_HOST_olayDpPageDef_t));
+     if (rc) 
+       return DSLHAL_ERROR_BLOCK_READ;
+     olayDpPageDef[i].overlayHostAddr = ptidsl->olayDpPage[i].overlayHostAddr;
+     rc = dslhal_support_blockWrite(&olayDpPageDef[i],(PVOID)olayDpParms.olayDpPage_p[i],sizeof(DEV_HOST_olayDpPageDef_t));
+     if (rc) 
+       return DSLHAL_ERROR_BLOCK_WRITE;
+   }
+  
+  /* Change the endianness of the Datapump Version Pointer */    
+  dspOamSharedInterface.datapumpVersion_p = (DEV_HOST_dspVersionDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.datapumpVersion_p);
+
+  /* get DSPVersion itself */
+   
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.datapumpVersion_p,&dspVersion, sizeof(DEV_HOST_dspVersionDef_t));
+ 
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  
+  /* table_dsp info */
+#if SWTC
+  dspOamSharedInterface.tcHostComm_p = (DEV_HOST_tcHostCommDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.tcHostComm_p);
+  rc = dslhal_support_blockRead(&pdspOamSharedInterface->tcHostComm_p,
+                                    &pTCHostCommDef, 4);
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  
+    pTCHostCommDef=(DEV_HOST_tcHostCommDef_t *) dslhal_support_byteSwap32((unsigned int)pTCHostCommDef);
+  
+   rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.tcHostComm_p, 
+                               &TCHostCommDef, sizeof(DEV_HOST_tcHostCommDef_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+#endif
+  /* Select the Multimode Training */
+  dspOamSharedInterface.oamWriteNegoParams_p = (DEV_HOST_oamWrNegoParaDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.oamWriteNegoParams_p);
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.oamWriteNegoParams_p, &OamWrNegoParaDef, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+switch(dspVersion.netService)
+  {
+  case 1:  OamWrNegoParaDef.stdMode = MULTI_MODE;
+           dprintf(5,"POTS Service \n");
+           ptidsl->netService = 1;
+           break;
+  case 2:  OamWrNegoParaDef.stdMode = GDMT_MODE;
+           dprintf(5,"ISDN Service \n");
+           ptidsl->netService = 2;
+           break;
+  default: OamWrNegoParaDef.stdMode = T1413_MODE;
+           dprintf(5,"Default Service \n");
+           break;
+  }
+
+   ptidsl->AppData.StdMode = (unsigned int)OamWrNegoParaDef.stdMode;
+
+   OamWrNegoParaDef.oamFeature = dslhal_support_byteSwap32((OAMFEATURE_TC_SYNC_DETECT_MASK));
+  /* Set the flag to start retraining if the margin of the modem drops below 
+     default margin during showtime */
+  
+  OamWrNegoParaDef.marginMonitorShwtme = FALSE; 
+    /*  Set the flag to start retraining if the margin of the modem drops below default margin during training */
+   
+  OamWrNegoParaDef.marginMonitorTrning = FALSE;
+  OamWrNegoParaDef.dsToneTurnoff_f = 0;
+  dslhal_support_blockWrite(&OamWrNegoParaDef, 
+                                 (PVOID)dspOamSharedInterface.oamWriteNegoParams_p, sizeof(DEV_HOST_oamWrNegoParaDef_t));
+  rc=dslhal_support_setInterruptMask(ptidsl,0);
+  if(rc!=DSLHAL_ERROR_NO_ERRORS)
+    return rc;
+  /* Co Profile Test */
+#if CO_PROFILES
+  dspOamSharedInterface.profileList_p = (DEV_HOST_profileBase_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.profileList_p);
+  /* Access the profileList Structure */
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.profileList_p,&profileList, sizeof(DEV_HOST_profileBase_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  profileList.hostProfileBase_p = (DEV_HOST_coData_t *)dslhal_support_byteSwap32((unsigned int)profileList.hostProfileBase_p);
+  rc = dslhal_support_blockRead((PVOID)profileList.hostProfileBase_p,&coData, sizeof(DEV_HOST_coData_t));
+  if (rc)
+   {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  dprintf(2,"Current Profile Vendor Id: %x \n",coData.phyAgcPgaTarget);
+  coData.phyAgcPgaTarget = 0xcaba;
+  rc = dslhal_support_blockWrite(&coData,(PVOID)profileList.hostProfileBase_p,sizeof(DEV_HOST_coData_t));
+  if(rc)
+    return DSLHAL_ERROR_BLOCK_WRITE;
+#endif
+  /* End of CO Profile Test */
+
+#ifndef NO_ACT
+  /* Constellation Display Buffer Allocate */
+  ptidsl->constDisplay.PmemStartWtAddr = (unsigned int) shim_osAllocateDmaMemory(DSP_CONSTELLATION_BUFFER_SIZE);
+  if(ptidsl->constDisplay.PmemStartWtAddr == NULL)
+    {
+      dprintf(1, "memory allocate error\n");
+      return DSLHAL_ERROR_OVERLAY_MALLOC;
+     }
+  shim_osZeroMemory((void*)ptidsl->constDisplay.PmemStartWtAddr,DSP_CONSTELLATION_BUFFER_SIZE);
+  ptidsl->constDisplay.overlayHostAddr =  virtual2Physical((unsigned int)ptidsl->constDisplay.PmemStartWtAddr);
+      dprintf(4,"Allocated Addr: 0x%x \t Xlated Addr: 0x%x \n",ptidsl->constDisplay.PmemStartWtAddr, ptidsl->constDisplay.overlayHostAddr);
+      ptidsl->constDisplay.OverlayXferCount = DSP_CONSTELLATION_BUFFER_SIZE;
+
+  /* Communicate the Allocated Buffer for DSP load Constellation Data */
+
+  /* Change the Endianness of the profileList pointer */
+  dspOamSharedInterface.consDispVar_p = (DEV_HOST_consBufDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.consDispVar_p);
+  /* Access the profileList Structure */
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.consDispVar_p,&constDisp, sizeof(DEV_HOST_consBufDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  dprintf(2,"Constellation Old Addr:%x  New: %x \n",constDisp.consDispStartAddr,ptidsl->constDisplay.overlayHostAddr); 
+  constDisp.consDispStartAddr = (unsigned int)dslhal_support_byteSwap32(ptidsl->constDisplay.overlayHostAddr);
+  constDisp.consDispCurrentAddr = constDisp.consDispStartAddr;
+  constDisp.consDispBufLen = (unsigned int)dslhal_support_byteSwap32(DSP_CONSTELLATION_BUFFER_SIZE);
+  rc = dslhal_support_blockWrite(&constDisp,(PVOID)dspOamSharedInterface.consDispVar_p,sizeof(DEV_HOST_consBufDef_t));
+     if (rc) 
+       return DSLHAL_ERROR_BLOCK_WRITE;
+#endif
+  dprintf(5,"dslhal_support_hostDspCodeDownload() completed.\n");
+  return DSLHAL_ERROR_NO_ERRORS;
+  
+}  /* end of dslhal_support_hostDspCodeDownload() */
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_readDelineationState()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   download DSP image from host memory to dsp memory
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+unsigned int dslhal_support_readDelineationState(tidsl_t * ptidsl)
+{
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  DEV_HOST_atmStats_t           atmStats;
+  DEV_HOST_dsAtmStats_t         dsAtmStats0;
+  unsigned int rc=0, delinState=0;
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterface_t *) ptidsl->pmainAddr;
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return DSLHAL_ERROR_BLOCK_READ;
+    }
+  
+  dspOamSharedInterface.atmStats_p = (DEV_HOST_atmStats_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.atmStats_p);
+  
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.atmStats_p,&atmStats, sizeof(DEV_HOST_atmStats_t));
+  
+  if (rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return DSLHAL_ERROR_BLOCK_READ;
+    }
+  
+  atmStats.ds0_p = (DEV_HOST_dsAtmStats_t *) dslhal_support_byteSwap32((unsigned int)atmStats.ds0_p);
+  
+  rc = dslhal_support_blockRead((PVOID)atmStats.ds0_p,&dsAtmStats0, (sizeof(DEV_HOST_dsAtmStats_t)));
+
+  if (rc) 
+    return rc;
+  delinState = dslhal_support_byteSwap32(dsAtmStats0.delineationState);
+  if(delinState == TC_SYNC)
+     ptidsl->lConnected = 1;
+  else
+     ptidsl->lConnected = 0;
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_processModemStateBitField()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   download DSP image from host memory to dsp memory
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+unsigned int dslhal_support_processModemStateBitField(tidsl_t * ptidsl)
+{
+  int rc, offset[2]={2,0};
+  int modemStateBitFields[NUMBER_OF_BITFIELDS],changedField=0;
+  rc = dslhal_api_dspInterfaceRead(ptidsl,(unsigned int)ptidsl->pmainAddr,2,(unsigned int *)&offset,
+                                  (unsigned char *)&modemStateBitFields,NUMBER_OF_BITFIELDS*sizeof(int));
+  if (rc)
+    return DSLHAL_ERROR_BLOCK_READ;
+  for(rc=0;rc<NUMBER_OF_BITFIELDS;rc++)
+    dprintf(4,"Bit Field %d: 0x%x \n",rc+1,dslhal_support_byteSwap32((unsigned int)modemStateBitFields[rc]));
+
+  for(rc=NUMBER_OF_BITFIELDS;rc>0;rc--)
+    {
+     if(ptidsl->modemStateBitField[rc-1]!=modemStateBitFields[rc-1])
+       {
+         changedField = rc;
+         break;
+       }
+    }
+  if(changedField)
+    {
+      for(rc=0;rc<32;rc++)
+        {
+           if(modemStateBitFields[changedField-1] & dslhal_support_byteSwap32((BITFIELD_SCAN >> rc)))
+             break;
+         }
+      dprintf(5,"Changed Field : %d  Changed Bit : %d \n",changedField,(31-rc));
+      ptidsl->rState = ((changedField*100) + (31-rc));
+      dprintf(5,"Modem State : %d \n",ptidsl->rState);
+      shim_osMoveMemory((void *)ptidsl->modemStateBitField,(void *)modemStateBitFields, 4*NUMBER_OF_BITFIELDS);
+    }
+
+  switch(changedField)
+    {
+    case 1:  if((ptidsl->rState >= ATU_RIDLE) && (ptidsl->AppData.bState < RSTATE_IDLE))
+                   ptidsl->AppData.bState = RSTATE_IDLE;
+             if((ptidsl->rState >= GDMT_NSFLR) && (ptidsl->AppData.bState < RSTATE_INIT))
+                 ptidsl->AppData.bState = RSTATE_INIT;
+             if((ptidsl->rState >= GDMT_ACKX) && (ptidsl->AppData.bState < RSTATE_HS))
+                 ptidsl->AppData.bState = RSTATE_HS;
+             break;
+
+    case 2:  if((ptidsl->rState >= T1413_NSFLR) && (ptidsl->AppData.bState < RSTATE_INIT))
+                 ptidsl->AppData.bState = RSTATE_INIT;
+             if((ptidsl->rState >= T1413_ACKX) && (ptidsl->AppData.bState < RSTATE_HS))
+                 ptidsl->AppData.bState = RSTATE_HS;
+             if((ptidsl->rState == ATU_RSHOWTIME) && (ptidsl->AppData.bState < RSTATE_SHOWTIME))
+                 ptidsl->AppData.bState = RSTATE_SHOWTIME;
+             break;
+ 
+    case 3:  if((ptidsl->rState >= ADSL2_COMB3) && (ptidsl->AppData.bState < RSTATE_INIT))
+                 ptidsl->AppData.bState = RSTATE_INIT;
+             if((ptidsl->rState >= ADSL2_RPARAMS) && (ptidsl->AppData.bState < RSTATE_HS))
+                 ptidsl->AppData.bState = RSTATE_HS;
+             break;
+ 
+    case 4:  break;
+    default: break;
+    }
+
+  ptidsl->stateTransition = modemStateBitFields[1];
+  switch(ptidsl->AppData.bState)
+    {
+    case RSTATE_IDLE:       ptidsl->AppData.idleTick=shim_osClockTick();
+                            ptidsl->AppData.initTick=0;
+                            ptidsl->AppData.showtimeTick=0;
+                            break;
+    case RSTATE_HS:         if(!ptidsl->AppData.initTick)
+                              {
+                                ptidsl->AppData.initTick=shim_osClockTick();
+                                }
+                            ptidsl->AppData.showtimeTick=0;  
+                            break;
+    case RSTATE_SHOWTIME:   if(!ptidsl->AppData.showtimeTick)
+                              ptidsl->AppData.showtimeTick=shim_osClockTick();
+                            break;
+    default:                break;
+                              }
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_setInterruptMask()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+unsigned int dslhal_support_setInterruptMask(tidsl_t * ptidsl,unsigned int inputMask)
+{
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  DEV_HOST_hostInterruptMask_t interruptMask;
+  unsigned int rc=0;
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterface_t *) ptidsl->pmainAddr;
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return DSLHAL_ERROR_BLOCK_READ;
+    }
+  dspOamSharedInterface.hostInterruptMask_p =(DEV_HOST_hostInterruptMask_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.hostInterruptMask_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.hostInterruptMask_p,
+                                     &interruptMask, sizeof(DEV_HOST_hostInterruptMask_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  if(inputMask & MASK_MAILBOX_INTERRUPTS)
+    {
+      dprintf(7,"Mailbox Interrupts Masked \n");
+      dprintf(7,"interruptMask.maskBitField1 = %d \n",dslhal_support_byteSwap32(interruptMask.maskBitField1));
+      interruptMask.maskBitField1 |= dslhal_support_byteSwap32(MASK_MAILBOX_INTERRUPTS);
+      dprintf(7,"interruptMask.maskBitField1 = %d \n",dslhal_support_byteSwap32(interruptMask.maskBitField1));
+    }
+  if(inputMask & MASK_BITFIELD_INTERRUPTS)
+    {
+      dprintf(7,"Bit field Interrupts Masked \n");
+      dprintf(7,"interruptMask.maskBitField1 = %d \n",dslhal_support_byteSwap32(interruptMask.maskBitField1));
+      interruptMask.maskBitField1 |= dslhal_support_byteSwap32(MASK_BITFIELD_INTERRUPTS);
+      dprintf(7,"interruptMask.maskBitField1 = %d \n",dslhal_support_byteSwap32(interruptMask.maskBitField1));
+    }
+  if(inputMask & MASK_HEARTBEAT_INTERRUPTS)
+    {
+      dprintf(7,"Bit field Interrupts Masked \n");
+      dprintf(7,"interruptMask.maskBitField1 = %d \n",dslhal_support_byteSwap32(interruptMask.maskBitField1));
+      interruptMask.maskBitField1 |= dslhal_support_byteSwap32(MASK_HEARTBEAT_INTERRUPTS);
+      dprintf(7,"interruptMask.maskBitField1 = %d \n",dslhal_support_byteSwap32(interruptMask.maskBitField1));
+    }
+  dslhal_support_blockWrite(&interruptMask, 
+                                 dspOamSharedInterface.hostInterruptMask_p, sizeof(DEV_HOST_hostInterruptMask_t));
+  dprintf(5,"dslhal_support_setInterruptMask() completed.\n");
+  return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_parseInterruptSource()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Parses the Interrupt Source Bit Field
+*
+* Return: interrupt Code if successful
+*         negative error code if failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+unsigned int dslhal_support_parseInterruptSource(tidsl_t * ptidsl)
+{
+  DEV_HOST_dspOamSharedInterface_t *pdspOamSharedInterface, dspOamSharedInterface;
+  DEV_HOST_hostInterruptSource_t interruptSource;
+  unsigned int rc=0,intrCode=0;
+  pdspOamSharedInterface = (DEV_HOST_dspOamSharedInterface_t *) ptidsl->pmainAddr;
+  rc = dslhal_support_blockRead(pdspOamSharedInterface, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+      dprintf(1,"dslhal_support_blockRead failed\n");
+      return (0-DSLHAL_ERROR_BLOCK_READ);
+    }
+  dspOamSharedInterface.hostInterruptSource_p =(DEV_HOST_hostInterruptSource_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.hostInterruptSource_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.hostInterruptSource_p,
+                                     &interruptSource, sizeof(DEV_HOST_hostInterruptSource_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return (0-DSLHAL_ERROR_BLOCK_READ);
+    }
+  if(interruptSource.sourceBitField1 & dslhal_support_byteSwap32(MASK_MAILBOX_INTERRUPTS))
+    {
+      dprintf(7,"Mailbox Interrupts Acknowledge \n");
+      intrCode |= 0x00000011;
+    }
+  if(interruptSource.sourceBitField1 & dslhal_support_byteSwap32(MASK_BITFIELD_INTERRUPTS))
+    {
+      dprintf(7,"Bit field Interrupt Acknowledge \n");
+      intrCode |= 0x00001002;
+    }
+  if(interruptSource.sourceBitField1 & dslhal_support_byteSwap32(MASK_HEARTBEAT_INTERRUPTS))
+    {
+      dprintf(7,"HeartBeat Interrupt Acknowledge \n");
+      intrCode |= 0x00100004;
+    }
+  
+  interruptSource.sourceBitField1 &=0x0;
+  rc=dslhal_support_blockWrite(&interruptSource, 
+                                 dspOamSharedInterface.hostInterruptSource_p, sizeof(DEV_HOST_hostInterruptSource_t));
+  if(rc)
+    return (0-DSLHAL_ERROR_BLOCK_WRITE);
+  dprintf(5,"dslhal_support_parseInterruptSource() completed.\n");
+  return intrCode;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_byteSwap16()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   input 16 bit short, byte swap from little endian to big endian or vise versa
+*
+********************************************************************************************/
+
+unsigned short dslhal_support_byteSwap16(unsigned short in16Bits)
+{
+    unsigned short out16Bits;
+    
+#ifdef EB
+    unsigned char *pchar;
+    unsigned char tmp;
+#endif
+    
+    out16Bits = in16Bits;
+
+#ifdef EB    
+    pchar = (unsigned char *)(&out16Bits);
+    
+    tmp = *pchar;
+    *pchar = *(pchar + 1);
+    *(pchar + 1) = tmp;
+#endif
+    
+    return out16Bits;
+    
+} /* end of dslhal_support_byteSwap16() */
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_byteSwap32()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   input 32 bit int, byte swap from little endian to big endian or vise versa
+*
+********************************************************************************************/
+
+unsigned int dslhal_support_byteSwap32(unsigned int in32Bits)
+{
+    int out32Bits;
+
+#ifdef EB
+    unsigned char tmp;
+    unsigned char *pchar;
+#endif    
+
+    out32Bits = in32Bits;
+    
+#ifdef EB
+    pchar = (unsigned char *)(&out32Bits);
+    
+    tmp = *pchar;
+    *pchar = *(pchar + 3);
+    *(pchar + 3) = tmp;
+    
+    tmp = *(pchar + 1);
+    *(pchar + 1) = *(pchar + 2);
+    *(pchar + 2) = tmp;
+#endif
+    
+    return out32Bits;
+    
+} /* end of dslhal_support_byteSwap32() */
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_computeCrc32()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Computes the CRC-32 for the input data
+*
+* Return: 32 bit CRC of the input data
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_computeCrc32(unsigned char *data, int len)
+{
+    unsigned int        result;
+    int                 i,j;
+    unsigned char       octet;
+   
+    if ((len < 4) || (data==NULL))
+        return(0xdeaddead);
+    result = *data++ << 24;
+    result |= *data++ << 16;
+    result |= *data++ << 8;
+    result |= *data++;
+    result = ~ result;
+
+    len -=4;
+
+    for (i=0; i<len; i++)
+    {
+        octet = *(data++);
+        for (j=0; j<8; j++)
+        {
+            if (result & 0x80000000)
+            {
+               result = (result << 1) ^ CRC32_QUOTIENT ^ (octet >> 7);
+            }
+            else
+            {
+               result = (result << 1) ^ (octet >> 7);
+            }
+            octet <<= 1;
+        }
+    }
+    return ~result;            /* The complement of the remainder */
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_checkOverlayPage()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Computes the CRC-32 for the input data and compares it with reference
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_checkOverlayPage(tidsl_t *ptidsl, unsigned int tag)
+{
+  unsigned int computedCrc;
+  if((unsigned char *)ptidsl->olayDpPage[tag].PmemStartWtAddr == NULL)
+  {
+     dprintf(5,"Null Address for Page: %d\n",tag);
+         return DSLHAL_ERROR_OVERLAY_MALLOC;
+  }
+  computedCrc = dslhal_support_computeCrc32((unsigned char *)ptidsl->olayDpPage[tag].PmemStartWtAddr, ptidsl->olayDpPage[tag].OverlayXferCount);
+  dprintf(6,"\n Pre-Computed CRC32 = 0x%x \t Current CRC32 = 0x%x \n",ptidsl->olayDpPage[tag].olayPageCrc32,computedCrc); 
+  if(computedCrc != ptidsl->olayDpPage[tag].olayPageCrc32)
+      return DSLHAL_ERROR_OVERLAY_CORRUPTED;
+  else
+      return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_clearTrainingInfo()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Computes the CRC-32 for the input data and compares it with reference
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+int dslhal_support_clearTrainingInfo(tidsl_t *ptidsl)
+{
+  int i;
+  
+  for(i=0; i<NUM_PAGES; i++)
+    {
+    if(ptidsl->olayDpPage[i].PmemStartWtAddr !=NULL)
+      {
+      shim_osFreeDmaMemory((void *) ptidsl->olayDpPage[i].PmemStartWtAddr, 
+                   ptidsl->olayDpPage[i].OverlayXferCount);
+      ptidsl->olayDpPage[i].PmemStartWtAddr =NULL;
+      }
+    }
+  if(ptidsl->coProfiles.PmemStartWtAddr != NULL)
+    {
+     shim_osFreeDmaMemory((void *)ptidsl->coProfiles.PmemStartWtAddr, ptidsl->coProfiles.OverlayXferCount);
+     ptidsl->coProfiles.PmemStartWtAddr = NULL;
+    }
+  return 0;
+}
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_reloadTrainingInfo()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Reload overlay pages from flash or memory
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+int dslhal_support_reloadTrainingInfo(tidsl_t * ptidsl)
+{
+
+  int rc = 0, i;
+  unsigned int olayXfer,olayStore;
+  unsigned int *olayStart;
+  
+  unsigned int crc32;
+  DEV_HOST_dspOamSharedInterface_t dspOamSharedInterface;
+  DEV_HOST_olayDpDef_t            olayDpParms;
+  DEV_HOST_olayDpPageDef_t        olayDpPageDef[NUM_PAGES];
+  DEV_HOST_profileBase_t          profileList;
+  
+  unsigned int secLength, secOffset, secPage;
+
+  /* co profile */
+  secLength = ptidsl->coProfiles.OverlayXferCount;
+  secOffset = ptidsl->coProfiles.SecOffset;
+  ptidsl->coProfiles.PmemStartWtAddr = (unsigned int) shim_osAllocateDmaMemory(secLength);
+  if(ptidsl->coProfiles.PmemStartWtAddr == NULL)
+  {
+    dprintf(1, "memory allocate error\n");
+    return DSLHAL_ERROR_OVERLAY_MALLOC;
+  }
+          /* holdSecPhyAddr = virtual2Physical((unsigned int)holdSecVirtAddr); */
+  ptidsl->coProfiles.overlayHostAddr =  virtual2Physical((unsigned int)ptidsl->coProfiles.PmemStartWtAddr);
+  dprintf(4,"Allocated Addr: 0x%x \t Xlated Addr: 0x%x \n",ptidsl->coProfiles.PmemStartWtAddr, ptidsl->coProfiles.overlayHostAddr);
+  ptidsl->coProfiles.overlayHostAddr = (unsigned int)dslhal_support_byteSwap32(ptidsl->coProfiles.overlayHostAddr);
+  
+  rc = shim_read_overlay_page((void *)ptidsl->coProfiles.PmemStartWtAddr, secOffset, secLength);
+  if(rc != secLength)
+  {
+    dprintf(1, "shim_read_overlay_page failed\n");
+    return DSLHAL_ERROR_OVERLAY_MALLOC;
+  }
+
+  /*shim_osMoveMemory((char *)ptidsl->coProfiles.PmemStartWtAddr, (char *)iptr, secLength);*/
+  /*   RamP Image ByteSwap test */
+  olayStart = (unsigned int *)ptidsl->coProfiles.PmemStartWtAddr;
+            
+  for(olayXfer=0;olayXfer< secLength/4;olayXfer++)
+  {
+    olayStore = *(unsigned int *)olayStart;
+    olayStore = (unsigned int)dslhal_support_byteSwap32(olayStore);
+    *(unsigned int*)olayStart = olayStore;
+    dprintf(5, "Addr:0x%x \t Content: 0x%x \n",olayStart,olayStore);
+    olayStart++;
+    olayStore=0;
+  }
+  shim_osWriteBackCache((void *)ptidsl->coProfiles.PmemStartWtAddr, secLength);
+ 
+
+  for (secPage=1;secPage<NUM_PAGES; secPage++)
+  {
+
+    dprintf(6,"OVERLAY PAGE #%d\n",secPage);
+   
+    secLength = ptidsl->olayDpPage[secPage].OverlayXferCount;
+
+    dprintf(4,"Section[%d] Length: %d \n",secPage, secLength);
+
+    secOffset = ptidsl->olayDpPage[secPage].SecOffset;
+    ptidsl->olayDpPage[secPage].PmemStartWtAddr  = (unsigned int) shim_osAllocateDmaMemory(secLength);
+    if(ptidsl->olayDpPage[secPage].PmemStartWtAddr == NULL)
+    {
+      dprintf(1, "overlay page allocate error\n");
+      return DSLHAL_ERROR_OVERLAY_MALLOC;
+    }
+
+    rc = shim_read_overlay_page((void *)ptidsl->olayDpPage[secPage].PmemStartWtAddr,secOffset, secLength);
+    if(rc != secLength)
+    {
+      dprintf(1, "overlay page read error\n");
+      return DSLHAL_ERROR_OVERLAY_MALLOC;
+    }
+
+    /* ptidsl->olayDpPage[secPage].overlayHostAddr = ((unsigned int)(ptidsl->olayDpPage[secPage].PmemStartWtAddr)&~0xe0000000); */
+    ptidsl->olayDpPage[secPage].overlayHostAddr = virtual2Physical((unsigned int)ptidsl->olayDpPage[secPage].PmemStartWtAddr);
+    dprintf(6,"Allocated Addr: 0x%x \t Xlated Addr: 0x%x \n",ptidsl->olayDpPage[secPage].PmemStartWtAddr,ptidsl->olayDpPage[secPage].overlayHostAddr);
+
+    ptidsl->olayDpPage[secPage].overlayHostAddr = (unsigned int)dslhal_support_byteSwap32(ptidsl->olayDpPage[secPage].overlayHostAddr);
+    /*ptidsl->olayDpPage[secPage].OverlayXferCount = secLength;
+      ptidsl->olayDpPage[secPage].BinAddr          = secAddr;
+      shim_osMoveMemory((char *)ptidsl->olayDpPage[secPage].PmemStartWtAddr, (char *)iptr, secLength);
+    */
+    olayStart = (unsigned int *)ptidsl->olayDpPage[secPage].PmemStartWtAddr;
+            
+    for(olayXfer=0;olayXfer< secLength/4;olayXfer++)
+    {
+      olayStore = *(unsigned int *)olayStart;
+      olayStore = (unsigned int)dslhal_support_byteSwap32(olayStore);
+      *(unsigned int*)olayStart = olayStore;
+      dprintf(5, "Addr:0x%x \t Content: 0x%x \n",olayStart,olayStore);
+      olayStart++;
+      olayStore=0;
+    }
+      /* RamP Image ByteSwap test */
+      /* compute the CRC of each overlay page and Store the Checksum in a local global variable */
+      /* This Value of CRC is to be compared with the header where all the CRC bytes are lumped together */
+    crc32 = dslhal_support_computeCrc32((char *)ptidsl->olayDpPage[secPage].PmemStartWtAddr, ptidsl->olayDpPage[secPage].OverlayXferCount);
+    if(crc32 != ptidsl->olayDpPage[secPage].olayPageCrc32)
+      return DSLHAL_ERROR_OVERLAY_MALLOC;
+
+    shim_osWriteBackCache((void *)ptidsl->olayDpPage[secPage].PmemStartWtAddr, secLength);
+  }
+
+  
+  dprintf(5,"ptidsl->hostIf.mainAddr=0x%X\n", (unsigned int)ptidsl->pmainAddr);
+  
+  /* get the pointer to DSP-OAM Shared Interface */
+  rc = dslhal_support_blockRead(ptidsl->pmainAddr, &dspOamSharedInterface, 
+                                     sizeof(DEV_HOST_dspOamSharedInterface_t));
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+
+  /* Communicate the Allocated Memory Address to DSP to choose CO Profiles */
+
+  /* Change the Endianness of the profileList pointer */
+  dspOamSharedInterface.profileList_p = (DEV_HOST_profileBase_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.profileList_p);
+  /* Access the profileList Structure */
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.profileList_p,&profileList, sizeof(DEV_HOST_profileBase_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+  dprintf(2,"Old Addr:%x  New: %x \n",profileList.hostProfileBase_p,ptidsl->coProfiles.overlayHostAddr); 
+  profileList.hostProfileBase_p = (DEV_HOST_coData_t *)ptidsl->coProfiles.overlayHostAddr;
+  rc = dslhal_support_blockWrite(&profileList,(PVOID)dspOamSharedInterface.profileList_p,sizeof(DEV_HOST_profileBase_t));
+     if (rc) 
+       return DSLHAL_ERROR_BLOCK_WRITE;
+
+  /* Communicate the Allocated Memory Address to DSP to do overlays */
+
+  /* Change the Endianness of the olayDpDef pointer */
+  dspOamSharedInterface.olayDpParms_p = (DEV_HOST_olayDpDef_t *)dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.olayDpParms_p);
+  /* Access the olayDpDef Structure */
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.olayDpParms_p,&olayDpParms, sizeof(DEV_HOST_olayDpDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+
+
+  for(i=1;i<NUM_PAGES;i++)
+   {
+  /* Change the endianness of the olayDpPageDef Pointer */
+     olayDpParms.olayDpPage_p[i] = (DEV_HOST_olayDpPageDef_t *) dslhal_support_byteSwap32((unsigned int)olayDpParms.olayDpPage_p[i]);
+     /* Access the olayDpPageDef Structure */
+     rc = dslhal_support_blockRead((PVOID)olayDpParms.olayDpPage_p[i],&olayDpPageDef[i],sizeof(DEV_HOST_olayDpPageDef_t));
+     if (rc) 
+       return DSLHAL_ERROR_BLOCK_READ;
+     olayDpPageDef[i].overlayHostAddr = ptidsl->olayDpPage[i].overlayHostAddr;
+     rc = dslhal_support_blockWrite(&olayDpPageDef[i],(PVOID)olayDpParms.olayDpPage_p[i],sizeof(DEV_HOST_olayDpPageDef_t));
+     if (rc) 
+       return DSLHAL_ERROR_BLOCK_WRITE;
+   }
+  
+  ptidsl->bOverlayPageLoaded = 1;
+  return DSLHAL_ERROR_NO_ERRORS;
+}  
+  /* end of dslhal_support_reloadTrainingInfo() */
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_restoreTrainingInfo()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Computes the CRC-32 for the input data and compares it with reference
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+
+int dslhal_support_restoreTrainingInfo(tidsl_t *ptidsl)
+{
+  int rc;
+  
+  rc=1;
+  while(rc != 0)
+    {
+    dslhal_support_clearTrainingInfo(ptidsl);
+    //shim_osCriticalEnter();
+    rc = dslhal_support_reloadTrainingInfo(ptidsl);
+    //shim_osCriticalExit();
+    shim_osClockWait(6400);
+    }
+  return 0;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_advancedIdleProcessing()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced Idle State Processing Functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_advancedIdleProcessing(tidsl_t *ptidsl)
+{
+  int rc=0;
+  ptidsl->AppData.bState = RSTATE_IDLE;
+#ifndef NO_ACT
+  rc +=  dslhal_advcfg_resetBitSwapMessageLog(ptidsl,0);
+  rc += dslhal_advcfg_resetBitSwapMessageLog(ptidsl,1);
+  rc += dslhal_advcfg_resetTrainStateHistory(ptidsl);
+  rc += dslhal_advcfg_getReasonForDrop(ptidsl);
+#endif
+  if(rc)
+    return DSLHAL_ERROR_CONFIG_API_FAILURE;
+  else
+    return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_aocBitSwapProcessing()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced Idle State Processing Functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_aocBitSwapProcessing(tidsl_t *ptidsl,unsigned int usDs)
+{
+  int rc=0;
+#ifndef NO_ACT
+  int i;
+  int differentCmd_f;
+  unsigned int dsSwapInx;
+
+  static UINT8 lastAturBitSwapCommands[6] = {0, 0, 0, 0, 0, 0};
+  static UINT8 lastAturBitSwapBinNum[6] = {0, 0, 0, 0, 0, 0};
+
+  if (usDs == 0)
+  {
+    dprintf(4," DSP_XMITBITSWAP\n");
+    rc += dslhal_advcfg_getAocBitswapBuffer(ptidsl,0);
+    ptidsl->usBitSwapInx++;
+    if (ptidsl->usBitSwapInx > 29)
+      ptidsl->usBitSwapInx=0;
+  }
+
+  if (usDs == 1)
+  {
+    dprintf(4," DSP_RCVBITSWAP\n");
+    rc += dslhal_advcfg_getAocBitswapBuffer(ptidsl,1);
+    differentCmd_f = FALSE;
+    dsSwapInx = ptidsl->dsBitSwapInx;
+    if (! rc)
+    {
+      for (i = 0; i < 6; i++)
+      {
+        if (lastAturBitSwapCommands[i] != ptidsl->dsBitSwap[dsSwapInx].bitSwapCommand[i])
+        {
+          differentCmd_f = TRUE;
+          break;
+        }
+      }
+      if (! differentCmd_f)
+      {
+        for (i = 0; i < 6; i++)
+        {
+          if (lastAturBitSwapBinNum[i] != ptidsl->dsBitSwap[dsSwapInx].bitSwapBinNum[i])
+          {
+            differentCmd_f = TRUE;
+            break;
+          }
+        }
+      }
+      //CPE data pump seems to occasionally send us the same bit swap twice in a row with different sframe counter.
+      //Since these are never counted twice by the debug output of AC5, we should not count them twice either.
+      //So, we ignore the sframe_counter in determining whether the most recent bitswap is a duplicate.
+      if (differentCmd_f)
+      {
+          shim_osMoveMemory((void *)lastAturBitSwapCommands, (void *)ptidsl->dsBitSwap[dsSwapInx].bitSwapCommand, 6);
+          shim_osMoveMemory((void *)lastAturBitSwapBinNum, (void *)ptidsl->dsBitSwap[dsSwapInx].bitSwapBinNum, 6);
+          ptidsl->dsBitSwapInx++;
+          if (ptidsl->dsBitSwapInx > 29)
+            ptidsl->dsBitSwapInx = 0;
+      }
+    }
+  }
+#endif
+  if(rc)
+    return DSLHAL_ERROR_CONFIG_API_FAILURE;
+  else
+    return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_gatherEocMessages()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced EOC Buffering functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_gatherEocMessages(tidsl_t *ptidsl,int usDs, int msgPart1, int msgPart2)
+{
+  int rc=0;
+#ifndef NO_ACT
+  rc = dslhal_advcfg_logEocMessages(ptidsl,usDs, msgPart1, msgPart2);
+#endif
+  if(rc)
+    return DSLHAL_ERROR_CONFIG_API_FAILURE;
+  else
+    return DSLHAL_ERROR_NO_ERRORS;
+}
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_gatherSnrPerBin()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced Snr per bin buffering Functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_gatherSnrPerBin(tidsl_t *ptidsl,unsigned int snrParam)
+{
+  int rc=0;
+#ifndef NO_ACT
+  rc = dslhal_advcfg_getSnrPerBin(ptidsl,snrParam);
+#endif
+  if(rc)
+    return DSLHAL_ERROR_CONFIG_API_FAILURE;
+  else
+    return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_processTrainingState()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced Training State Processing Functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_processTrainingState(tidsl_t *ptidsl)
+{
+  int rc=0;
+#ifndef NO_ACT
+
+  if(ptidsl->trainStateInx<120)
+    {
+     rc = dslhal_advcfg_getTrainingState(ptidsl,(void *)&ptidsl->trainHistory[ptidsl->trainStateInx++]);
+     if(ptidsl->trainHistory[(ptidsl->trainStateInx-1)].subStateIndex ==
+        ptidsl->trainHistory[(ptidsl->trainStateInx-2)].subStateIndex)
+        ptidsl->trainStateInx--;
+    }
+  else
+      ptidsl->trainStateInx = 0;
+#endif
+  if(rc)
+    return DSLHAL_ERROR_CONFIG_API_FAILURE;
+  else
+    return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_gatherAdsl2Messages()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Gathers ADSL2 Training Messages
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_gatherAdsl2Messages(tidsl_t *ptidsl,int tag, int param1, int param2)
+{
+  int rc=0;
+  unsigned int adsl2MsgLoc;
+  switch(tag)
+    {
+    case CMSGFMT_INDEX:
+       dprintf(5,"C-Msg-FMT rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CMSGFMT_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.cMsgFmt,CMSGFMT_SIZE);
+       break;
+    case RMSGFMT_INDEX:  
+    case RMSGFMT2_INDEX:
+       dprintf(5,"R-Msg-FMT rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSGFMT_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.rMsgFmt,RMSGFMT_SIZE);
+       break;
+    case CMSGPCB_INDEX:
+       dprintf(5,"C-Msg-PCB rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CMSGPCB_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.cMsgPcb,CMSGPCB_SIZE);
+       ptidsl->adsl2TrainingMessages.cMsgPcbLen = CMSGPCB_SIZE;
+       break;
+    case CMSGPCB2_INDEX:  
+       dprintf(5,"C-Msg-PCB2 rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CMSGPCB2_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.cMsgPcb,CMSGPCB2_SIZE);
+       ptidsl->adsl2TrainingMessages.cMsgPcbLen = CMSGPCB2_SIZE;
+#ifndef NO_ACT
+       rc += dslhal_advcfg_setBlackOutBits(ptidsl);
+#endif
+       break;
+    case CMSGPCB2L_INDEX:
+       dprintf(5,"C-Msg-PCB2L rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CMSGPCB2L_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.cMsgPcb,CMSGPCB2L_SIZE);
+       ptidsl->adsl2TrainingMessages.cMsgPcbLen = CMSGPCB2L_SIZE;
+       break;
+    case RMSGPCB_INDEX:
+    case RMSGPCB2L_INDEX:
+       dprintf(5,"R-Msg-PCB rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSGPCB_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.rMsgPcb,RMSGPCB_SIZE);
+       ptidsl->adsl2TrainingMessages.rMsgPcbLen = RMSGPCB_SIZE;
+       break;
+
+    case CMSG1ADSL2_INDEX:
+       dprintf(5,"C-Msg1 rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CMSG1ADSL2_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.cMsg1,CMSG1ADSL2_SIZE);
+       ptidsl->adsl2TrainingMessages.cMsg1Len = CMSG1ADSL2_SIZE;
+       break;
+    case CMSG2ADSL2_INDEX:
+       dprintf(5,"C-Msg2 rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CMSG2ADSL2_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.cMsg2,CMSG2ADSL2_SIZE);
+       ptidsl->adsl2TrainingMessages.cMsg2Len = CMSG2ADSL2_SIZE;
+       break;
+    case RMSG1ADSL2_INDEX:
+       dprintf(5,"R-Msg1 rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSG1ADSL2_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.rMsg1,RMSG1ADSL2_SIZE);
+       ptidsl->adsl2TrainingMessages.rMsg1Len = RMSG1ADSL2_SIZE;
+       break;
+    case RMSG2ADSL2_INDEX:
+       dprintf(5,"R-Msg2 rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSG2ADSL2_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.rMsg2,RMSG2ADSL2_SIZE);
+       ptidsl->adsl2TrainingMessages.rMsg2Len = RMSG2ADSL2_SIZE;
+       break;
+    case CPARAMS_INDEX:
+       dprintf(5,"C-Params rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CPARAMS_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.cParams,CPARAMS_SIZE);
+       ptidsl->adsl2TrainingMessages.cParamsLen = CPARAMS_SIZE;
+       break;
+    case RPARAMS_INDEX:
+       dprintf(5,"R-Params rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RPARAMS_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2TrainingMessages.rParams,RPARAMS_SIZE);
+       ptidsl->adsl2TrainingMessages.rParamsLen = RPARAMS_SIZE;
+       break;
+    case RMSG1LD_INDEX:
+       dprintf(5,"R-Msg1 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSG1LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.rMsg1Ld,RMSG1LD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.rMsg1LdLen = RMSG1LD_SIZE;
+       break;
+    case RMSG2LD_INDEX:
+       dprintf(5,"R-Msg2 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSG2LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.rMsg2Ld,RMSGxLD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.rMsgxLdLen = RMSGxLD_SIZE;
+       break;
+    case RMSG3LD_INDEX:
+       dprintf(5,"R-Msg3 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSG3LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.rMsg3Ld,RMSGxLD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.rMsgxLdLen = RMSGxLD_SIZE;
+       break;
+    case RMSG4LD_INDEX:
+       dprintf(5,"R-Msg4 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSG4LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.rMsg4Ld,RMSGxLD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.rMsgxLdLen = RMSGxLD_SIZE;
+       break;
+    case RMSG5LD_INDEX:
+       dprintf(5,"R-Msg5 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSG5LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.rMsg5Ld,RMSGxLD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.rMsgxLdLen = RMSGxLD_SIZE;
+       break;
+    case RMSG6LD_INDEX:
+       dprintf(5,"R-Msg6 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSG6LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.rMsg6Ld,RMSGxLD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.rMsgxLdLen = RMSGxLD_SIZE;
+       break;
+    case RMSG7LD_INDEX:
+       dprintf(5,"R-Msg7 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSG7LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.rMsg7Ld,RMSGxLD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.rMsgxLdLen = RMSGxLD_SIZE;
+       break;
+    case RMSG8LD_INDEX:
+       dprintf(5,"R-Msg8 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSG8LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.rMsg8Ld,RMSGxLD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.rMsgxLdLen = RMSGxLD_SIZE;
+       break;
+    case RMSG9LD_INDEX:
+       dprintf(5,"R-Msg9 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, RMSG9LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.rMsg9Ld,RMSGxLD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.rMsgxLdLen = RMSGxLD_SIZE;
+       break;
+    case CMSG1LD_INDEX:
+       dprintf(5,"C-Msg1 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CMSG1LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.cMsg1Ld,CMSG1LD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.cMsg1LdLen = CMSG1LD_SIZE;
+       break;
+    case CMSG2LD_INDEX:
+       dprintf(5,"C-Msg2 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CMSG2LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.cMsg2Ld,CMSG2LD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.cMsg2LdLen = CMSG2LD_SIZE;
+       break;
+    case CMSG3LD_INDEX:
+       dprintf(5,"C-Msg3 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CMSG3LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.cMsg3Ld,CMSG3LD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.cMsg3LdLen = CMSG3LD_SIZE;
+       break;
+    case CMSG4LD_INDEX:
+       dprintf(5,"C-Msg4 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CMSG4LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.cMsg4Ld,CMSG4LD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.cMsg4LdLen = CMSG4LD_SIZE;
+       break;
+    case CMSG5LD_INDEX:
+       dprintf(5,"C-Msg5 LD rec'd\n");
+       adsl2MsgLoc = dslhal_support_getAdsl2MessageLocation
+                     (ptidsl, CMSG5LD_INDEX);
+       rc += dslhal_support_blockRead((PVOID)adsl2MsgLoc,
+             ptidsl->adsl2DiagnosticMessages.cMsg5Ld,CMSG5LD_SIZE);
+       ptidsl->adsl2DiagnosticMessages.cMsg5LdLen = CMSG5LD_SIZE;
+       break;
+    default:
+       dprintf(5,"Unknown ADSL2 Message rec'd\n");
+       break;
+    }
+  if(rc)
+    return DSLHAL_ERROR_CONFIG_API_FAILURE;
+  else
+    return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_getAdsl2MessageLocation()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Gets the address to the ADSL2 Message being looked up
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_getAdsl2MessageLocation(tidsl_t *ptidsl,int msgOffset)
+{
+  int rc=0;
+
+  DEV_HOST_dspOamSharedInterface_t *pSharedInterface, sharedInterface;  
+  DEV_HOST_dspWrNegoParaDef_t   dspNegoPara;
+  int  adsl2MsgString, adsl2MsgAddr;
+
+  pSharedInterface = (DEV_HOST_dspOamSharedInterface_t *) ptidsl->pmainAddr;
+  rc += dslhal_support_blockRead(pSharedInterface, &sharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+  sharedInterface.dspWriteNegoParams_p = (DEV_HOST_dspWrNegoParaDef_t *) dslhal_support_adsl2ByteSwap32((unsigned int)sharedInterface.dspWriteNegoParams_p);
+  rc += dslhal_support_blockRead((PVOID)sharedInterface.dspWriteNegoParams_p,&dspNegoPara, sizeof(DEV_HOST_dspWrNegoParaDef_t));
+  
+  if (rc)
+    {
+    dprintf(1,"dslhal_support_blockRead failed\n");
+    return DSLHAL_ERROR_BLOCK_READ;
+    }
+
+  adsl2MsgString = dslhal_support_adsl2ByteSwap32((unsigned int)dspNegoPara.adsl2DeltMsgs_p);
+  dprintf(5,"ADSL2 Message String Address: 0x%x\n",adsl2MsgString);
+  rc += dslhal_support_blockRead((PVOID)(adsl2MsgString +
+                                  ((sizeof(unsigned char *)*msgOffset))),
+                                  &adsl2MsgAddr, sizeof(int));
+  adsl2MsgAddr = dslhal_support_adsl2ByteSwap32((unsigned int)adsl2MsgAddr);
+  dprintf(5," Message Address: 0x%x\n",adsl2MsgAddr);
+
+       if(rc)
+          return DSLHAL_ERROR_BLOCK_READ;
+       else
+          return adsl2MsgAddr;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_getCMsgsRa()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced Training Message functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_getCMsgsRa(tidsl_t *ptidsl,void *cMsg)
+{
+  int rc=0;
+  DEV_HOST_raMsgsDef_t         raMsgParms;
+  DEV_HOST_dspOamSharedInterface_t  dspOamSharedInterface;
+  rc += dslhal_support_blockRead(ptidsl->pmainAddr, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+
+  dspOamSharedInterface.raMsgs_p = (DEV_HOST_raMsgsDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.raMsgs_p);
+
+  rc += dslhal_support_blockRead((PVOID)dspOamSharedInterface.raMsgs_p, 
+                               &raMsgParms, sizeof(DEV_HOST_raMsgsDef_t));
+  shim_osMoveMemory((void *)cMsg,(void *)raMsgParms.cMsgsRaString,6);
+  
+  if(rc)
+    return DSLHAL_ERROR_CONFIG_API_FAILURE;
+  else
+    return DSLHAL_ERROR_NO_ERRORS;
+}
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_gatherRateMessages()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*        Gathers Rate Training Messages
+* Input
+*        tidsl_t *ptidsl : Pointer to application structure
+*        
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_gatherRateMessages(tidsl_t * ptidsl)
+{
+  int rc;
+  DEV_HOST_dspWrNegoParaDef_t  negoParms;
+  DEV_HOST_dspOamSharedInterface_t  dspOamSharedInterface;
+  
+  dprintf(1, "dslhal_support_gatherRateMessages\n");
+
+  rc += dslhal_support_blockRead(ptidsl->pmainAddr, &dspOamSharedInterface,sizeof(DEV_HOST_dspOamSharedInterface_t));
+  dspOamSharedInterface.dspWriteNegoParams_p = (DEV_HOST_dspWrNegoParaDef_t *) dslhal_support_byteSwap32((unsigned int)dspOamSharedInterface.dspWriteNegoParams_p);
+
+  rc = dslhal_support_blockRead((PVOID)dspOamSharedInterface.dspWriteNegoParams_p, &negoParms, sizeof(DEV_HOST_dspWrNegoParaDef_t));
+  if (rc)
+    return DSLHAL_ERROR_BLOCK_READ;  
+  else 
+    {
+      shim_osMoveMemory((void *)ptidsl->AppData.bCRates1, (void *)negoParms.cRates1, 120);
+      shim_osMoveMemory((void *)ptidsl->AppData.bRRates1, (void *)negoParms.rRates1, 44);
+    }
+return DSLHAL_ERROR_NO_ERRORS;
+}
+
+static unsigned int dslhal_support_adsl2ByteSwap32(unsigned int in32Bits)
+{
+    int out32Bits=0; 
+
+#ifdef EB
+  out32Bits = (in32Bits << 24);
+  out32Bits |=((in32Bits & 0x0000ff00) << 8);
+  out32Bits |=((in32Bits & 0xff000000) >> 24);
+  out32Bits |=((in32Bits & 0x00ff0000) >> 8);    
+#else
+    out32Bits = in32Bits;
+#endif
+    
+    return out32Bits;
+
+} /* end of dslhal_support_byteSwap32() */
diff -urN linux.old/drivers/atm/sangam_atm/dsl_hal_support.h linux.dev/drivers/atm/sangam_atm/dsl_hal_support.h
--- linux.old/drivers/atm/sangam_atm/dsl_hal_support.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/dsl_hal_support.h	2005-08-23 04:46:50.101843088 +0200
@@ -0,0 +1,718 @@
+#ifndef DSL_HAL_SUPPORT_H__
+#define DSL_HAL_SUPPORT_H__ 1
+
+/*******************************************************************************
+* FILE PURPOSE:     DSL Driver API functions for Sangam
+*
+********************************************************************************
+* FILE NAME:        dsl_hal_functiondefines.c
+*
+* DESCRIPTION:  
+*       Contains basic DSL HAL API declarations for Sangam
+*  
+*                    
+* (C) Copyright 2001-02, Texas Instruments, Inc.
+*    History
+*    Date        Version            Notes
+*    06Feb03     0.00.00            RamP   Created
+*    21Mar03     0.00.01            RamP   Removed byteswap functions
+*    21Mar03     0.00.02            RamP   Added extern osFreeVMemory declaration
+*    10Apr03     0.00.03            RamP   Changed declaration for loadFWImage &
+*                                          loadDebugFWImage to remove ptidsl param
+*    12Apr03     0.00.04            RamP   Added function to set Interrupt Bit
+*                                          Masks for bitfield & Mailboxes
+*    14Apr03     0.00.05            RamP   Added modem state bit field processing
+*    15Apr03     0.00.06            RamP   Added function osAllocateVMemory
+*    21Apr03     0.01.00            RamP   Added function osAllocateDmaMemory
+*                                          Added function osFreeDmaMemory
+*                (Alpha)                   Added macro virtual2Physical, 
+*    22Apr03     0.01.01            RamP   Moved acknowledgeInterrupt to api.h
+*    24Apr03     0.01.02            RamP   Added checkOvelayPage function
+*    29May03     0.01.03            RamP   Added critical enter/exit function decl
+*    06Jun03     0.01.04            RamP   Added Interrupt source parsing function
+*    06Oct03     0.01.05            RamP   Added function abstraction switches
+*    12Oct03     0.01.06            RamP   Added ADSL2 Message function prototypes
+*    14Nov03     0.03.07            RamP   Added function to gather Rate Messages
+*******************************************************************************/
+
+#include "dsl_hal_api.h"
+
+#define virtual2Physical(a)    (((int)a)&~0xe0000000)
+/* External Function Prototype Declarations */
+
+extern unsigned int shim_osGetCpuFrequency(void);
+extern void shim_osClockWait(int val);
+extern unsigned int shim_osClockTick(void);
+
+extern int shim_osStringCmp(const char *s1, const char *s2);
+
+extern void dprintf( int uDbgLevel, char * szFmt, ...);
+
+extern int shim_osLoadFWImage(unsigned char *firmwareImage);
+extern int shim_osLoadDebugFWImage(unsigned char *debugFirmwareImage);
+extern unsigned int shim_read_overlay_page(void *ptr, unsigned int secOffset, unsigned int secLength);
+extern void shim_osMoveMemory(char *dst, char *src, unsigned int numBytes);
+extern void shim_osZeroMemory(char *dst, unsigned int numBytes);
+
+extern void *shim_osAllocateMemory(unsigned int size);
+extern void *shim_osAllocateVMemory(unsigned int size);
+extern void *shim_osAllocateDmaMemory(unsigned int size);
+
+extern void shim_osFreeMemory(void *ptr, unsigned int size);
+extern void shim_osFreeVMemory(void *ptr, unsigned int size);
+extern void shim_osFreeDmaMemory(void *ptr, unsigned int size);
+
+extern void shim_osWriteBackCache(void *pMem, unsigned int size);
+extern void shim_osCriticalEnter(void);
+extern void shim_osCriticalExit(void);
+
+
+/*******************************************************************************************
+* FUNCTION NAME:    dslhal_support_writeHostMailbox
+*
+********************************************************************************************
+* DESCRIPTION: Send a message to a mailbox
+*
+* ARGUMENTS:   int cmd             command to write
+*              int tag             tag (currently unused)
+*              int p1              parameter 1 (currently unused)
+*              int p2              parameter 2 (currently unused)
+*
+* RETURNS:     0 if successful
+*              NZ otherwise
+*
+*******************************************************************************************/
+
+int dslhal_support_writeHostMailbox
+(tidsl_t *ptidsl, 
+ int cmd, 
+ int tag, 
+ int p1, 
+ int p2);
+
+/********************************************************************************************
+* FUNCTION NAME:    dslhal_support_readDspMailbox
+*
+*********************************************************************************************
+* DESCRIPTION: Reads a message from the mailbox
+*
+* ARGUMENTS:   int *pcmd           Pointer to command read
+*
+* RETURNS:     0 if successful
+*              1 if no mail
+*              NZ otherwise
+*
+*****************************************************************************************/
+
+int dslhal_support_readDspMailbox
+(tidsl_t *ptidsl, 
+ int *pcmd, 
+ int *ptag, 
+ int *pprm1, 
+ int *pprm2);
+
+/********************************************************************************************
+* FUNCTION NAME:    dslhal_support_readTextMailbox
+*
+*********************************************************************************************
+* DESCRIPTION: Reads a message from the mailbox
+*
+* ARGUMENTS:   int *pcmd           Pointer to command read
+*
+* RETURNS:     0 if successful
+*              1 if no mail
+*              NZ otherwise
+*
+*****************************************************************************************/
+
+int dslhal_support_readTextMailbox
+(tidsl_t *ptidsl, 
+ int *pmsg1, 
+ int *pmsg2);
+ 
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_support_blockRead
+*
+*********************************************************************************************
+* DESCRIPTION: This rouin simulates DSP memory read as done in ax5 pci nic card
+*
+* INPUT:  void *addr,   memory address to be read
+*         void *buffer, dat buffer to be filled with from memmory
+*         size_t count, number of bytes to be written
+*
+* RETURN:  0 --succeeded
+*          1 --Failed
+*
+*****************************************************************************************/
+
+int dslhal_support_blockRead
+(void *addr, 
+ void *buffer, 
+ size_t count);
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_support_blockWrite
+*
+*******************************************************************************************
+* DESCRIPTION: This rouin simulates DSP memory write as done in ax5 pci nic card 
+*
+* INPUT:  void *buffer, data need to written
+*         void *adde,   memory address to be written
+*         size_t count, number of bytes to be written
+*
+* RETURN:  0 --succeeded
+*          1 --Failed
+*
+*****************************************************************************************/
+
+int dslhal_support_blockWrite
+(void *buffer, 
+ void *addr, 
+ size_t count);
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_support_hostDspAddressTranslate
+*
+*******************************************************************************************
+* DESCRIPTION: This function moves the address window to translate physical address 
+*
+* INPUT:  unsigned int addr : address that requires translation
+*
+* RETURN:  Translated address or error condition
+*          
+*
+*****************************************************************************************/
+
+unsigned int dslhal_support_hostDspAddressTranslate
+( unsigned int addr 
+);
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_support_unresetDslSubsystem
+*
+*******************************************************************************************
+* DESCRIPTION: This function unreset Dsl Subsystem
+*
+* INPUT:  None
+*
+* RETURN: 0 if Pass; 1 if Fail
+*
+*****************************************************************************************/
+int dslhal_support_unresetDslSubsystem
+(void
+);
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_support_unresetDsp()
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction takes ax5 daugter board out of reset.
+*
+* INPUT:  None
+*
+* RETURN: 0  --successful.
+*         1  --failed
+*
+*****************************************************************************************/
+int dslhal_support_unresetDsp
+(void
+);
+
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_support_resetDslSubsystem
+*
+*******************************************************************************************
+* DESCRIPTION: This function unreset Dsl Subsystem
+*
+* INPUT:  None
+*
+* RETURN: 0 if Pass; 1 if Fail
+*
+*****************************************************************************************/
+int dslhal_support_resetDslSubsystem
+(void
+);
+
+/******************************************************************************************
+* FUNCTION NAME:    dslhal_support_resetDsp()
+*
+*******************************************************************************************
+* DESCRIPTION: This fuction takes ax5 daugter board out of reset.
+*
+* INPUT:  None
+*
+* RETURN: 0  --successful.
+*         1  --failed
+*
+*****************************************************************************************/
+int dslhal_support_resetDsp
+(void
+);
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_hostDspCodeDownload()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   download DSP image from host memory to dsp memory
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+int dslhal_support_hostDspCodeDownload
+(tidsl_t * ptidsl 
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_digi_assignMemTestSpace()
+*
+*********************************************************************************************
+* DESCRIPTION: Assigns Memory Space in SDRAM for External Memory Test 
+* Input: tidsl_t *ptidsl
+* 
+* Return: 0    success
+*         1    failed
+*
+********************************************************************************************/
+
+unsigned int dslhal_diags_digi_assignMemTestSpace
+(tidsl_t *ptidsl
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_digi_readMemTestResult()
+*
+*********************************************************************************************
+* DESCRIPTION: Reads Results of External Memory Test 
+* Input: tidsl_t *ptidsl
+* 
+* Return: 0    success
+*         1    failed
+*
+********************************************************************************************/
+
+unsigned int dslhal_diags_digi_readMemTestResult
+(tidsl_t *ptidsl,
+unsigned int testResult
+);
+
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_codeDownload()
+*
+*********************************************************************************************
+* DESCRIPTION: Brings DSLSS out of Reset, Downloads Diag Firmware, 
+*              brings DSP out of Reset 
+* Input: tidsl_t *ptidsl
+* 
+* Return: 0    success
+*         1    failed
+*
+********************************************************************************************/
+
+unsigned int dslhal_diags_codeDownload
+(tidsl_t *ptidsl,
+unsigned char* missingTones
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_anlg_setPgaParams()
+*
+*********************************************************************************************
+* DESCRIPTION: This function instructs the Transciever to transmit the Reverb with missing
+*              tones and Medley's with missing tones. These signals are defined in ITU 
+*              G.992.1 ADSL Standards.
+*
+* Input: Test selects between the Reverb or Medley tests. 0 - Reverb, 1 - Medley
+*        Tones selects the .
+* Return: NULL
+*         
+********************************************************************************************/
+
+unsigned int  dslhal_diags_anlg_setPgaParams
+(tidsl_t *ptidsl,
+int agcFlag,
+short pga1, 
+short pga2, 
+short pga3, 
+short aeq
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_anlg_getRxNoisePower()
+*
+*********************************************************************************************
+* DESCRIPTION: This function instructs the Transciever to transmit the Reverb with missing
+*              tones and Medley's with missing tones. These signals are defined in ITU 
+*              G.992.1 ADSL Standards.
+*
+* Input: Test selects between the Reverb or Medley tests. 0 - Reverb, 1 - Medley
+*        Tones selects the .
+* Return: NULL
+*         
+********************************************************************************************/
+
+unsigned int dslhal_diags_anlg_getRxNoisePower
+(tidsl_t *ptidsl
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_diags_anlg_setMissingTones()
+*
+*********************************************************************************************
+* DESCRIPTION: This function instructs the Transciever to transmit the Reverb with missing
+*              tones and Medley's with missing tones. These signals are defined in ITU 
+*              G.992.1 ADSL Standards.
+*
+* Input: Test selects between the Reverb or Medley tests. 0 - Reverb, 1 - Medley
+*        Tones selects the .
+* Return: NULL
+*         
+********************************************************************************************/
+
+unsigned int dslhal_diags_anlg_setMissingTones
+(tidsl_t *ptidsl,
+unsigned char* missingTones
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_readDelineationState()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   download DSP image from host memory to dsp memory
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_readDelineationState
+(tidsl_t *ptidsl
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_processModemStateBitField()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   download DSP image from host memory to dsp memory
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_processModemStateBitField
+(tidsl_t *ptidsl
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_setInterruptMask()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+unsigned int dslhal_support_setInterruptMask
+(tidsl_t * ptidsl,
+unsigned int inputMask
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_computeCrc32()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Computes the CRC-32 for the input data
+*
+* Return: 32 bit CRC of the input data
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_computeCrc32
+(unsigned char *data, 
+int len
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_checkOverlayPage()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Computes the CRC-32 for the input data and compares it with reference
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_checkOverlayPage
+(tidsl_t *ptidsl, 
+unsigned int tag
+);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_restoreTrainingInfo()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Computes the CRC-32 for the input data and compares it with reference
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+int dslhal_support_restoreTrainingInfo(tidsl_t * ptidsl);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_reloadTrainingInfo()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Computes the CRC-32 for the input data and compares it with reference
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+int dslhal_support_reloadTrainingInfo(tidsl_t * ptidsl);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_clearTrainingInfo()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Computes the CRC-32 for the input data and compares it with reference
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+int dslhal_support_clearTrainingInfo(tidsl_t * ptidsl);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_parseInterruptSource()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Sets the host interrupt bit masks
+*
+* Return: 0  success
+*         1  failed
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+
+unsigned int dslhal_support_parseInterruptSource(tidsl_t * ptidsl);
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_advancedIdleProcessing()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced Idle State Processing Functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_advancedIdleProcessing(tidsl_t *ptidsl);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_aocBitSwapProcessing()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced Bitswap buffer Processing Functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_aocBitSwapProcessing(tidsl_t *ptidsl,unsigned int usDs);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_gatherEocMessages()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced EOC Buffering functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_gatherEocMessages(tidsl_t *ptidsl,int usDs, int msgPart1, int msgPart2);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_gatherSnrPerBin()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced Snr per bin buffering Functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_gatherSnrPerBin(tidsl_t *ptidsl,unsigned int snrParm);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_processTrainingState()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced Training State Processing Functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_processTrainingState(tidsl_t *ptidsl);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_gatherAdsl2Messages()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced EOC Buffering functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_gatherAdsl2Messages(tidsl_t *ptidsl,int msgTag, int param1, int param2);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_getAdsl2MsgLocation()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Gets the address to the ADSL2 Message being looked up
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_getAdsl2MessageLocation(tidsl_t *ptidsl,int msgOffset);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_getCMsgsRa()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Calls Advanced Training Message functions
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_getCMsgsRa(tidsl_t *ptidsl,void *cMsg);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_gatherRateMessages()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   Gathers Advanced Training Messages
+*
+* Return: Error Condition (if any)
+*      
+* 
+* NOTE: 
+*   DSP image is based on LITTLE endian
+*
+********************************************************************************************/
+unsigned int dslhal_support_gatherRateMessages(tidsl_t *ptidsl);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_byteSwap16()
+*
+*********************************************************************************************
+* DESCRIPTION:
+* byteswap a short  
+* 
+* INPUT: 
+* Return: NULL
+*
+********************************************************************************************/
+
+unsigned short dslhal_support_byteSwap16(unsigned short in16Bits);
+
+/********************************************************************************************
+* FUNCTION NAME: dslhal_support_byteSwap32()
+*
+*********************************************************************************************
+* DESCRIPTION:
+*   byteswap a word
+* 
+* INPUT: 
+* Return: NULL
+*
+********************************************************************************************/
+
+unsigned int dslhal_support_byteSwap32(unsigned int in32Bits);
+
+#endif /* Pairs #ifndef DSL_HAL_FUNCTIONDEFINES_H__ */
diff -urN linux.old/drivers/atm/sangam_atm/dsl_hal_version.h linux.dev/drivers/atm/sangam_atm/dsl_hal_version.h
--- linux.old/drivers/atm/sangam_atm/dsl_hal_version.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/dsl_hal_version.h	2005-08-23 04:46:50.102842936 +0200
@@ -0,0 +1,94 @@
+#ifndef __SYSSW_VERSION_H__
+#define __SYSSW_VERSION_H__ 1
+
+/*******************************************************************************
+* FILE PURPOSE:     DSL Driver API functions for Sangam
+*
+********************************************************************************
+* FILE NAME:        dsl_hal_basicapi.c
+*
+* DESCRIPTION:  
+*       Contains basic DSL HAL APIs for Sangam
+*  
+* (C) Copyright 2003-04, Texas Instruments, Inc.
+*    History
+*    Date        Version            Notes
+*    14May03     0.00.00            RamP   Original Version Created
+*    14May03     0.00.01            RamP   Initial Rev numbers inserted 
+*    14May03     0.00.02            RamP   Bumped version numbers for Dsl Hal
+*                                          & dhalapp for alpha plus
+*    19May03     0.00.03            MCB    Bumped dslhal version number
+*                                          because of dependant changes
+*                                          wrt. linux-nsp atm drivers.
+*    22May03     0.00.04            RamP   Bumped dslhal & dhalapp buildnum
+*                                          for inner/outer pair & DGASP code
+*    06Jun03     0.00.05            RamP   Bumped up buildnum for LED, STM, 
+*                                          interrupt processing, statistics
+*                                          and other pre-beta features
+*    09Jun03     0.00.06            JEB    Fixed error in DHALAPP bugfix/buildnum
+*    09Jun03     0.00.07            RamP   Bumped up buildnum for incremental
+*                                          changes to apis, statistics, memory
+*                                          fixes, parameter configurations
+*    11Jun03     0.00.08            RamP   Bumped up buildnum for Co profile
+*                                          free memory fix
+*    12Jun03     0.00.09            JEB    Bumped version numbers for AR7 1.00 Beta
+*    02Jul03     0.00.10            ZT     Bumped HAL version for overlay page
+*    18Jul03     0.00.11            RamP   Bumped HAL version for analog diags
+*    22Jul03     0.00.12            JEB    Bumped DHALAPP buildnum for analog diags
+*    31Jul03     0.00.13            RamP   Bumped HAL version for engr. drop
+*    04Aug03     0.00.14            JEB    Bumped HAL version buildnum for CHECKPOINT65 changes
+*                                          Bumped LINUX version buildnum for CHECKPOINT65 changes
+*    06Aug03     0.00.15            MCB    Bumped all version numbers in prep for AR7 1.0 R2 release for POTS.
+*    13Aug03     0.00.16            MCB    Set rev id's for D3/R1.1 (ADSL2).
+*    21Aug03     0.00.17            JEB    Bumped up build numbers for merge of code additions from D1
+*    26Sep03     0.00.18            JEB    Set rev id's for another D3/R1 (ADSL2).
+*    14Oct03     0.00.19            JEB    Bumped Linux minor number and reset bugfix number for release.
+*                                          Bumped build numbers on DSLHAL and DHALAPP for this checkpoint.
+*    14Oct03     0.00.20            JEB    Bumped build numbers on DSLHAL and DHALAPP for CHECKPOINT15.
+*    21Oct03     0.00.21            JEB    Bumped build number on DSLHAL for CHECKPOINT16.
+*    22Oct03     0.00.22            MCB    Bumped all version numbers in support of D3R1 release.
+*    27Oct03     0.00.23            JEB    Bumped build numbers on DSLHAL and DHALAPP for CHECKPOINT19.
+*                                          Updated version for DSLAGENT to be 02.01.00.01 for ACT 2.1 R0.
+*    30Oct03     0.00.24            JEB    Bumped bugfix number on LINUXATM Version for next release.
+*                                          Bumped build numbers on DSLHAL and DHALAPP
+*    31Oct03     0.00.25            MCB    Bumped all version numbers in support of D3R2 release.
+*    14Nov03     0.00.26            JEB    Bumped build numbers on DSLHAL and DHALAPP
+*                                          Changed version for DSLAGENT to be 02.00.01.01 for an ACT 2.0 R0
+*    20Nov03     0.00.27            JEB    Bumped build number on DSLHAL.
+*                                          Changed version for DSLAGENT to be 02.00.02.00 for the next ACT 2.0 R2
+*    21Nov03     0.00.28            MCB    Bumped all version numbers in support of D3R2 release.
+*    21Nov03     0.00.29            JEB    Bumped build numbers on DSLHAL and DHALAPP for D3-R0 drop on 11/21.
+*    16Dec03     0.00.30            JEB    Bumped build numbers on DSLHAL and DHALAPP for CHECKPOINT31.
+*    21Dec03     0.00.31            MCB    Bumped all version numbers in support of D3R2 release.
+*    05Jan04     0.00.32            JEB    Bumped build numbers on DSLHAL and Linux ATM for CHECKPOINT 34.
+*    15Jan04     0.00.33            JEB    Bumped build numbers on DSLHAL and Linux ATM for CHECKPOINT 36.
+*    26Jan04     0.00.34            JEB    Changed Linux ATM version number to be 04.02.03.00.
+*    27Jan04     0.00.35            MCB    Bumped all version numbers in support of D3R2 release.
+*******************************************************************************/
+
+/* Dsl Hal API Version Numbers */
+#define DSLHAL_VERSION_MAJOR       03
+#define DSLHAL_VERSION_MINOR       00
+#define DSLHAL_VERSION_BUGFIX      06
+#define DSLHAL_VERSION_BUILDNUM    00
+#define DSLHAL_VERSION_TIMESTAMP   00
+
+/* dhalapp Adam2 Application Version Numbers */
+#define DHALAPP_VERSION_MAJOR      03
+#define DHALAPP_VERSION_MINOR      00
+#define DHALAPP_VERSION_BUGFIX     05
+#define DHALAPP_VERSION_BUILDNUM   00
+
+/* Linux ATM Driver Version Numbers */
+#define LINUXATM_VERSION_MAJOR     04
+#define LINUXATM_VERSION_MINOR     02
+#define LINUXATM_VERSION_BUGFIX    04
+#define LINUXATM_VERSION_BUILDNUM  00
+
+/* DSL Agent Version Numbers */
+#define DSLAGENT_VERSION_MAJOR     02
+#define DSLAGENT_VERSION_MINOR     00
+#define DSLAGENT_VERSION_BUGFIX    02
+#define DSLAGENT_VERSION_BUILDNUM  00
+
+#endif /* pairs with #ifndef __SYSSW_VERSION_H__ */
diff -urN linux.old/drivers/atm/sangam_atm/ec_errors_cpaal5.h linux.dev/drivers/atm/sangam_atm/ec_errors_cpaal5.h
--- linux.old/drivers/atm/sangam_atm/ec_errors_cpaal5.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/ec_errors_cpaal5.h	2005-08-23 04:46:50.102842936 +0200
@@ -0,0 +1,118 @@
+/***************************************************************************
+ Copyright(c) 2001, Texas Instruments Incorporated. All Rights Reserved.
+
+ FILE:  ec_errors.h
+
+ DESCRIPTION:
+   This file contains definitions and function declarations for
+   error code support.
+
+ HISTORY:
+   14Dec00 MJH             Added masking to EC_CLASS etc macros
+   17Sep02 GSG             Added HAL support (new class&devices)
+   03Oct02 GSG             Removed C++ style comments
+***************************************************************************/
+#ifndef _INC_EC_ERRORS
+#define _INC_EC_ERRORS
+
+/*
+  31    - CRITICAL
+  30-28 - CLASS         (ie. DIAG, KERNEL, FLASH, etc)
+  27-24 - INSTANCE      (ie. 1, 2, 3, etc )
+  23-16 - DEVICE        (ie. EMAC, IIC, etc)
+  15-08 - FUNCTION      (ie. RX, TX, INIT, etc)
+  07-00 - ERROR CODE    (ie. NO_BASE, FILE_NOT_FOUND, etc )
+*/
+
+/*---------------------------------------------------------------------------
+  Useful defines for accessing fields within error code
+---------------------------------------------------------------------------*/
+#define CRITICAL_SHIFT    31
+#define CLASS_SHIFT       28
+#define INST_SHIFT        24
+#define DEVICE_SHIFT      16
+#define FUNCTION_SHIFT     8
+#define ERROR_CODE_SHIFT   0
+
+#define CRITICAL_MASK     1
+#define CLASS_MASK        0x07
+#define DEVICE_MASK       0xFF
+#define INST_MASK         0x0F
+#define FUNCTION_MASK     0xFF
+#define ERROR_CODE_MASK   0xFF
+
+#define EC_CLASS(val)     ((val&CLASS_MASK)      << CLASS_SHIFT)
+#define EC_DEVICE(val)    ((val&DEVICE_MASK)     << DEVICE_SHIFT)
+#define EC_INST(val)      ((val&INST_MASK)       << INST_SHIFT)
+#define EC_FUNC(val)      ((val&FUNCTION_MASK)   << FUNCTION_SHIFT)
+#define EC_ERR(val)       ((val&ERROR_CODE_MASK) << ERROR_CODE_SHIFT)
+
+/*---------------------------------------------------------------------------
+   Operation classes
+---------------------------------------------------------------------------*/
+#define EC_HAL              EC_CLASS(0)
+#define EC_DIAG             EC_CLASS(8)
+
+/*---------------------------------------------------------------------------
+   Device types
+---------------------------------------------------------------------------*/
+#define EC_DEV_EMAC         EC_DEVICE(1)
+#define EC_DEV_IIC          EC_DEVICE(2)
+#define EC_DEV_RESET        EC_DEVICE(3)
+#define EC_DEV_ATMSAR       EC_DEVICE(4)
+#define EC_DEV_MEM          EC_DEVICE(5)
+#define EC_DEV_DES          EC_DEVICE(6)
+#define EC_DEV_DMA          EC_DEVICE(7)
+#define EC_DEV_DSP          EC_DEVICE(8)
+#define EC_DEV_TMR          EC_DEVICE(9)
+#define EC_DEV_WDT          EC_DEVICE(10)
+#define EC_DEV_DCL          EC_DEVICE(11)
+#define EC_DEV_BBIF         EC_DEVICE(12)
+#define EC_DEV_PCI              EC_DEVICE(13)
+#define EC_DEV_XBUS         EC_DEVICE(14)
+#define EC_DEV_DSLIF            EC_DEVICE(15)
+#define EC_DEV_USB                      EC_DEVICE(16)
+#define EC_DEV_CLKC                     EC_DEVICE(17)
+#define EC_DEV_RAPTOR       EC_DEVICE(18)
+#define EC_DEV_DSPC                     EC_DEVICE(19)
+#define EC_DEV_INTC                     EC_DEVICE(20)
+#define EC_DEV_GPIO                     EC_DEVICE(21)
+#define EC_DEV_BIST                     EC_DEVICE(22)
+#define EC_DEV_HDLC                     EC_DEVICE(23)
+#define EC_DEV_UART                     EC_DEVICE(24)
+#define EC_DEV_VOIC                     EC_DEVICE(25)
+/* 9.17.02 (new HAL modules) */
+#define EC_DEV_CPSAR        EC_DEVICE(0x1A)
+#define EC_DEV_AAL5         EC_DEVICE(0x1B)
+#define EC_DEV_AAL2         EC_DEVICE(0x1C)
+#define EC_DEV_CPMAC        EC_DEVICE(0x1D)
+#define EC_DEV_VDMA         EC_DEVICE(0x1E)
+#define EC_DEV_VLYNQ        EC_DEVICE(0x1F)
+#define EC_DEV_CPPI         EC_DEVICE(0x20)
+#define EC_DEV_CPMDIO       EC_DEVICE(0x21)
+
+/*---------------------------------------------------------------------------
+   Function types
+---------------------------------------------------------------------------*/
+#define EC_FUNC_READ_CONF   EC_FUNC(1)
+#define EC_FUNC_INIT        EC_FUNC(2)
+
+/*---------------------------------------------------------------------------
+   Error codes
+---------------------------------------------------------------------------*/
+#define EC_CRITICAL         (1<<CRITICAL_SHIFT)
+#define EC_NO_ERRORS        0
+#define EC_VAL_NO_BASE      EC_ERR(1)
+#define EC_VAL_NO_RESET_BIT EC_ERR(2)
+#define EC_VAL_NO_RESET     EC_ERR(3)
+#define EC_VAL_BAD_BASE     EC_ERR(4)
+#define EC_VAL_MALLOCFAILED EC_ERR(5)
+#define EC_VAL_NO_RESETBASE EC_ERR(6)
+#define EC_DEVICE_NOT_FOUND EC_ERR(7)
+
+/*---------------------------------------------------------------------------
+   Function declarations
+---------------------------------------------------------------------------*/
+extern void ec_log_error( unsigned int );
+
+#endif /* _INC_EC_ERRORS */
diff -urN linux.old/drivers/atm/sangam_atm/ec_errors_cpsar.h linux.dev/drivers/atm/sangam_atm/ec_errors_cpsar.h
--- linux.old/drivers/atm/sangam_atm/ec_errors_cpsar.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/ec_errors_cpsar.h	2005-08-23 04:46:50.102842936 +0200
@@ -0,0 +1,118 @@
+/***************************************************************************
+ Copyright(c) 2001, Texas Instruments Incorporated. All Rights Reserved.
+
+ FILE:  ec_errors.h
+
+ DESCRIPTION:
+   This file contains definitions and function declarations for
+   error code support.
+
+ HISTORY:
+   14Dec00 MJH             Added masking to EC_CLASS etc macros
+   17Sep02 GSG             Added HAL support (new class&devices)
+   03Oct02 GSG             Removed C++ style comments
+***************************************************************************/
+#ifndef _INC_EC_ERRORS
+#define _INC_EC_ERRORS
+
+/*
+  31    - CRITICAL
+  30-28 - CLASS         (ie. DIAG, KERNEL, FLASH, etc)
+  27-24 - INSTANCE      (ie. 1, 2, 3, etc )
+  23-16 - DEVICE        (ie. EMAC, IIC, etc)
+  15-08 - FUNCTION      (ie. RX, TX, INIT, etc)
+  07-00 - ERROR CODE    (ie. NO_BASE, FILE_NOT_FOUND, etc )
+*/
+
+/*---------------------------------------------------------------------------
+  Useful defines for accessing fields within error code
+---------------------------------------------------------------------------*/
+#define CRITICAL_SHIFT    31
+#define CLASS_SHIFT       28
+#define INST_SHIFT        24
+#define DEVICE_SHIFT      16
+#define FUNCTION_SHIFT     8
+#define ERROR_CODE_SHIFT   0
+
+#define CRITICAL_MASK     1
+#define CLASS_MASK        0x07
+#define DEVICE_MASK       0xFF
+#define INST_MASK         0x0F
+#define FUNCTION_MASK     0xFF
+#define ERROR_CODE_MASK   0xFF
+
+#define EC_CLASS(val)     ((val&CLASS_MASK)      << CLASS_SHIFT)
+#define EC_DEVICE(val)    ((val&DEVICE_MASK)     << DEVICE_SHIFT)
+#define EC_INST(val)      ((val&INST_MASK)       << INST_SHIFT)
+#define EC_FUNC(val)      ((val&FUNCTION_MASK)   << FUNCTION_SHIFT)
+#define EC_ERR(val)       ((val&ERROR_CODE_MASK) << ERROR_CODE_SHIFT)
+
+/*---------------------------------------------------------------------------
+   Operation classes
+---------------------------------------------------------------------------*/
+#define EC_HAL              EC_CLASS(0)
+#define EC_DIAG             EC_CLASS(8)
+
+/*---------------------------------------------------------------------------
+   Device types
+---------------------------------------------------------------------------*/
+#define EC_DEV_EMAC         EC_DEVICE(1)
+#define EC_DEV_IIC          EC_DEVICE(2)
+#define EC_DEV_RESET        EC_DEVICE(3)
+#define EC_DEV_ATMSAR       EC_DEVICE(4)
+#define EC_DEV_MEM          EC_DEVICE(5)
+#define EC_DEV_DES          EC_DEVICE(6)
+#define EC_DEV_DMA          EC_DEVICE(7)
+#define EC_DEV_DSP          EC_DEVICE(8)
+#define EC_DEV_TMR          EC_DEVICE(9)
+#define EC_DEV_WDT          EC_DEVICE(10)
+#define EC_DEV_DCL          EC_DEVICE(11)
+#define EC_DEV_BBIF         EC_DEVICE(12)
+#define EC_DEV_PCI              EC_DEVICE(13)
+#define EC_DEV_XBUS         EC_DEVICE(14)
+#define EC_DEV_DSLIF            EC_DEVICE(15)
+#define EC_DEV_USB                      EC_DEVICE(16)
+#define EC_DEV_CLKC                     EC_DEVICE(17)
+#define EC_DEV_RAPTOR       EC_DEVICE(18)
+#define EC_DEV_DSPC                     EC_DEVICE(19)
+#define EC_DEV_INTC                     EC_DEVICE(20)
+#define EC_DEV_GPIO                     EC_DEVICE(21)
+#define EC_DEV_BIST                     EC_DEVICE(22)
+#define EC_DEV_HDLC                     EC_DEVICE(23)
+#define EC_DEV_UART                     EC_DEVICE(24)
+#define EC_DEV_VOIC                     EC_DEVICE(25)
+/* 9.17.02 (new HAL modules) */
+#define EC_DEV_CPSAR        EC_DEVICE(0x1A)
+#define EC_DEV_AAL5         EC_DEVICE(0x1B)
+#define EC_DEV_AAL2         EC_DEVICE(0x1C)
+#define EC_DEV_CPMAC        EC_DEVICE(0x1D)
+#define EC_DEV_VDMA         EC_DEVICE(0x1E)
+#define EC_DEV_VLYNQ        EC_DEVICE(0x1F)
+#define EC_DEV_CPPI         EC_DEVICE(0x20)
+#define EC_DEV_CPMDIO       EC_DEVICE(0x21)
+
+/*---------------------------------------------------------------------------
+   Function types
+---------------------------------------------------------------------------*/
+#define EC_FUNC_READ_CONF   EC_FUNC(1)
+#define EC_FUNC_INIT        EC_FUNC(2)
+
+/*---------------------------------------------------------------------------
+   Error codes
+---------------------------------------------------------------------------*/
+#define EC_CRITICAL         (1<<CRITICAL_SHIFT)
+#define EC_NO_ERRORS        0
+#define EC_VAL_NO_BASE      EC_ERR(1)
+#define EC_VAL_NO_RESET_BIT EC_ERR(2)
+#define EC_VAL_NO_RESET     EC_ERR(3)
+#define EC_VAL_BAD_BASE     EC_ERR(4)
+#define EC_VAL_MALLOCFAILED EC_ERR(5)
+#define EC_VAL_NO_RESETBASE EC_ERR(6)
+#define EC_DEVICE_NOT_FOUND EC_ERR(7)
+
+/*---------------------------------------------------------------------------
+   Function declarations
+---------------------------------------------------------------------------*/
+extern void ec_log_error( unsigned int );
+
+#endif /* _INC_EC_ERRORS */
diff -urN linux.old/drivers/atm/sangam_atm/env_def_defines.h linux.dev/drivers/atm/sangam_atm/env_def_defines.h
--- linux.old/drivers/atm/sangam_atm/env_def_defines.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/env_def_defines.h	2005-08-23 04:46:50.103842784 +0200
@@ -0,0 +1,926 @@
+#ifndef __ENV_DEF_DEFINES_H__
+#define __ENV_DEF_DEFINES_H__ 1
+
+//********************************************************************
+//*    DMT-BASE ADSL MODEM PROGRAM
+//*    TEXAS INSTRUMENTS PROPRIETARTY INFORMATION
+//*    AMATI CONFIDENTIAL PROPRIETARY
+//*
+//* (c) Copyright May 1999, Texas Instruments Incorporated.
+//*     All Rights Reserved.
+//*
+//*   Property of Texas Instruments Incorporated and Amati Communications Corp.
+//*
+//* Restricted Rights - Use, duplication, or disclosure is subject to
+//* restrictions set forth in TI's and Amati program license agreement and
+//* associated documentation
+//*
+//*********************************************************************
+//*
+//* FILENAME: dpsys_defines.h
+//*
+//* ABSTRACT: This file provides a mechanism for defining standard
+//*           preprocessor flag sets for datapump.
+//*
+//* TARGET:  Non specific.
+//*
+//* TOOLSET:  Non specific.
+//*
+//* ACTIVATION:
+//*
+//* HISTORY:  DATE        AUTHOR         DESCRIPTION
+//*           05/11/99    FLW            Created
+//*           01/21/00    FLW            derfmake changes
+//*           02/07/00    FLW/M.Seidl    added _debug targets
+//*           02/23/00    FLW/M.Barnett  merged in from G.lite branch
+//*           03/03/00    FLW/M.Barnett  added TRELLIS token
+//*           05/11/00    Barnett        Added ap036btp & ap037btp support.
+//*           02/07/00    M.Seidl        added HW_TEQ, HW_DEC and DC_BIAS tokens
+//*           02/28/00    Derf/Seidl     Mod's in support of suppressing compiler warnings for empty source files
+//*           02/28/00    M. Seidl       added SWTC token
+//*           02/28/00    M. Seidl       added ap0501tp and its _debug target
+//*           03/03/00    M. Seidl       added MODPILOT token, ap0307tp_debug has SWDI and FDD enabled
+//*           03/08/00    Jack Huang     Added HWRSDEC token
+//*           03/29/00    Derf/Seidl     Mod's in support Soft-TC and derfmake
+//*           04/10/00    Jack Huang     Added PCIMASTER token
+//*           04/11/00    Jack Huang     Added STBFIX token
+//*           04/24/00    M. Seidl       ap0500tp has OLAYDP turned on, ap0500tp_debug has OLAYDP turned off now
+//*           04/28/00    M.Seidl        added KAPIL token for ap0501tp targets
+//*           06/02/00    P.Sexton       Added OAM_EOC token
+//*           06/06/00    M. Seidl       added au0501tp target
+//*           06/12/00    Michael Seidl  activated h/w TEQ for KAPIL targets, disabled STBFIX for all targets
+//*           06/14/00    Derf           added ap0308tp, alphabetized token lists
+//*           06/16/00    Jack Huang     added au0501tp_debug target
+//*           06/22/00    M. Seidl       Enabled code overlays through EMIF from external memory. Now there are 3
+//*                                      different code overlay schemes that are differentiated by the following tokens:
+//*                                      OLAYDP_PCI:  uses PCI DMA in PCI Master Mode
+//*                                      OLAYDP_HOST: Host downloads overlay code into DMEM upon request from DSP
+//*                                      OLAYDP_EMIF: Host downloads overlay code into ext. mem at boot-time. DSP uses
+//*                                                 DMA channel 0 to load code into on-chip PMEM
+//*                                      OLAYDP:    turns overlays generally on or off
+//*           07/15/00    B.Srinivasan   Cleaned up default tokens and tokens for au0501tp, au0501tp_debug,
+//*                                      ap0501tp and ap0501tp_debug targets as well
+//*           07/19/00    B.Srinivasan   Made changes w.r.t cleaning/fixing Rufus Interrupt related code
+//*                                      (changed token TC_INTRPT_RUFUS to INTRPT_RUFUS
+//*           06/14/00    Derf           added au0501cp
+//*           08/12/00    Yinong Ding    Added DPLL_MODE token.
+//*           08/16/00    F. Mujica      Moved DOUBLE_XMT_RATE, RX_HPF, and LEAKY_LMS tokens here.
+//*           09/05/00    M. Seidl       Changed ap0501tp back to do overlay through PCI (OLAY_PCI = 1)
+//*           09/11/00    M. Seidl       moved USB and OLAYDP_HOST definitions to be CHIPSET specific, not target specific
+//*           09/21/00    U.Dasgupta/    Added a token for separate transmit and receive buffers.
+//*                       F.Mujica       (SEPARATE_TX_RX_BUFFERS).
+//*           10/02/00    U.Dasgupta/    Added DPLL and SEPARATE_TX_RX_BUFFER tokens for au0502 target.
+//*                       F.Mujica
+//*           10/02/00    M. Castellano  Added new tokens for new Host/EMIF DSP code overlay.
+//*                                      OLAYDP_2STEP: Host downloads overlay code into ext. mem upon DSP request.  DSP
+//*                                      DMA channel 0 to load code into on-chip PMEM.  It is a somewhat hybrid version
+//*                                      of OLAYDP_HOST and OLAYDP_EMIF.  The test target is ap0502tp.
+//*           10/25/00    Balaji         Added tokens for arv500tp target
+//*           10/31/00    U. Iyer        Added TEQ_AVG token and set it one for Ax5
+//*           11/02/00    Barnett        Added OAM_EOC=0 in defaults at bottom of file.
+//*           11/21/00    M. Seidl       turned OLAYDP and AOC off for ap0307tp to make binary compatible w. whql'ed driver
+//*           11/28/00    Paul Hunt      added FASTRETRAIN token for fast retrain specific code
+//*           11/28/00    Paul Hunt      added PILOTDATA token to control channel estimation and transmission
+//*                                      of data on the upstream pilot tone for ITU standard code loads
+//*           12/20/00    Jack Huang     added EIGHTBITSRAM toekn for the targets that use 8-bit SRAM for
+//*                                      interleaver/deinterleaver
+//*           01/11/01    U.Dasgupta     Added mp targets and cleaned up GHS/PILOTDATA variables
+//*           01/23/01    U.Dasgupta     Cleaned up code within GLITE tokens
+//*           01/23/00    Barnett        Added in full EOC support for AP3/Ax5.  Got rid of UTC.  No longer needed.
+//*           02/08/01    Barnett        Added DDC token.
+//*           03/09/01    Nirmal Warke   Added in TOKEN definition for line diagnostics (LINE_DIAG): IMP DEPENDENCIES -
+//*                                      TEQ_AVG must be off when LINE_DIAG is on (since they share a union buffer at the same time)
+//*           03/13/01    M. Seidl       Recovered ap0500tp target. Added GHS token as PMEM saving option
+//*           03/14/01    Barnett        Added ap0500mb target support.  Look-and-feel is similar to ap0500tp.
+//*                                      Added seperate-but-equal def's wrt. ISDN Annex B, Annex C, and PROP.
+//*           03/14/01    J. Bergsagel   Added EXTERNBERT token.
+//*           03/15/01    Barnett/Balaji Merged AR5(H) -> 03.00.00 datapump.
+//*           03/16/01    Nirmal Warke   Added in TOKEN definition for crosstalk performance mods (CROSSTALK): IMP DEPENDENCIES -
+//*                                      TEQ_AVG must be off and LEAKY_LMS must be on when CROSSTALK is on
+//*           03/21/01    Barnett        Added support for ar0500lp, ar0500mp, ar0500dp, arv500lp, arv500mp, and arv500dp.
+//*           03/26/01    M. Seidl       enabled 64pt IFFT for ap0500mb (Raptor+AD11, FDM)
+//*           03/28/01    J. Bergsagel   Removed EXTERNBERT token (now use host intf. var. instead)
+//*           04/03/01    J. Bergsagel   Removed condition of DSPDP_CHIPSET_GEN==5 for default defines
+//*                                      Removed LEAKY_LMS token (assumed always 1)
+//*                                      Removed OLAYDP_HOST token (assumed always 0)
+//*                                      Removed RX_HPF token (assumed always 1)
+//*                                      Removed TRIBRID token (not used any more)
+//*                                      Removed FDD token (assumed always 1)
+//*                                      Removed HW_DEC token (assumed always 1)
+//*                                      Removed HW_TEQ token (assumed always 1)
+//*                                      Removed HWRSDEC token (assumed always 1)
+//*                                      Removed ILEC_AD11_ALCATEL337 token (assumed always 0)
+//*                                      Removed ILEC_AD11_HDSLNOISEFIX token (assumed always 0)
+//*                                      Removed ILEC_AD11_MODULATEPILOT token (assumed always 0)
+//*                                      Removed ILEC_AD11_NEWINTERPOLATE token (assumed always 0)
+//*                                      Removed ILEC_AD11_USTXHPF token (assumed always 0)
+//*                                      Removed SWDI token (assumed always 1)
+//*                                      Removed TD_AGC token (assumed always 1)
+//*                                      Removed DSPDP_LEGACY_TARGET token (assumed always 0)
+//*                                      Removed AD11_20, AD11_20NL and AD11_20_NEWPREC token (always 1)
+//*                                      Removed AI token (assumed always 1)
+//*                                      Removed ATUC token (assumed always 0)
+//*                                      Removed EU token (assumed always 0)
+//*                                      Removed EVM2 token (assumed always 0)
+//*                                      Removed INTRPT_RUFUS token (assumed always 0)
+//*                                      Removed MODPILOT token (assumed always 0)
+//*                                      Removed SL and SL_EVM tokens (assumed always 0)
+//*                                      Removed STBIFX token (assumed always 0)
+//*                                      Removed STD token (assumed always 1)
+//*                                      Removed SWDI_LOOPBACK token (assumed always 0)
+//*                                      Removed TID token (assumed always 0)
+//*                                      Removed TII token (assumed always 1)
+//*                                      Removed TIPCI token (assumed always 1)
+//*                                      Removed UDI token (assumed always 1)
+//*                                      Removed DC_BIAS token (assumed always 1)
+//*           04/05/01    Barnett        Added DSPDP_ prefix to tokens that originate
+//*                                      in the public interface.
+//*           05/07/01    Jack Huang     Removed DOUBLE_XMT_RATE token.
+//*           05/16/01    Barnett        Added back in EXTERNBERT token in support
+//*                                      of saving PMEM.
+//*           06/05/01    Jack Huang     Fixed the rules for ar0500mp_debug target
+//*           04/23/01    M. Halleck     Merge Astro Wu's DDC enhancements
+//*           06/05/01    M. Capps       Changed DSP_DEBUG to ENHANCED_SERIAL_DEBUG
+//*           07/03/01    M. Capps       Replaced ESD token with !DDC, added DEV_DEBUG
+//*           06/26/01    J. Bergsagel   Removed all the old ap03... stuff
+//*                                      Removed OLAYDP_HOST token (again)
+//*                                      Removed CROSSTALK token (assumed always 1)
+//*                                      Removed TEQ_AVG token (assumed always 0)
+//*                                      Removed DE token (assumed always 1)
+//*                                      Removed PVAT token and au0501cp target
+//*                                      Removed FASTRETRAIN token (assumed always 0)
+//*           07/05/01    J. Bergsagel   Changed PCIMASTER token to TC_ATM_PCIMASTER
+//*           07/20/01    Umesh Iyer     Added ATMBERT token. ATMBERT is conditional on SWTC definition. if SWTC is 0
+//*                                      ATMBERT should be 0. Else it can be 0/1. Default 0.
+//*           07/23/01    J. Bergsagel   Changed name from defines_u.h to dpsys_defines.h
+//*           07/24/01    Barnett        Added support for build of $(TARGET)_diag mfgr'ing targets.
+//*           08/02/01    Michael Seidl  renamed KAPIL token to !AD1X
+//*           08/02/01    Michael Seidl  renamed GHS token to PMEMSAVE_GHS
+//*           08/03/01    S.Yim          Added MFGR_DIAG token for afe diagnostic
+//*                                      Added AFEDEV token for afe device driver
+//*                                      Added DSPBIOSII token for dsp bios
+//*           09/21/01    Sameer         Enable EXTERNBERT.  Disable ATMBERT.
+//*           10/01/01    U.Dasgupta     Turned off SMART_MARGIN for ap0500mb because of FECs/CRCs;
+//*           10/09/01    Barnett        Added support for ar0500db.
+//*           10/12/01    Barnett        Disable EXTERNBERT.
+//*           10/15/01    Barnett        Turn off SMART_MARGIN.
+//*           11/07/01    Barnett        Def'ed ISDN_DEBUG for all targets to avoid compiler warnings.
+//*                                      Assumed defaul value is zero.
+//*           11/13/01    Barnett        Reworked ar0500db_debug to build JTAG-bootable load.
+//*                                      The equivalent production target should only be flash-bootable.
+//*           01/11/02    Yim            Added TOKEN JTAG to build JTAG load ar0500db_diag.
+//*           01/23/02    U Iyer         Added DEBUG_LOG token. Default value 0
+//*           01/31/02    Barnett        Added support for ar0700mp target.
+//*           02/04/02    S.Yim          Added TOKEN JTAG to build JTAG load ar0500mp_diag
+//*           02/11/02    U Iyer         Added MARGIN_DELTA_RETRAIN token. Default value 1
+//*           05/15/02    Sameer V       Enabled EXTERNBERT token for AR5 and AU5 platforms. EXTERNBERT is
+//*                                      not supported on AR5H.
+//*           02/14/02    Barnett        Don't ref the SWTC feature token if mfgr'ing diag target.
+//*           02/19/02    Yim            Added support to build au0502db_diag target.
+//*           03/08/02    Nirmal Warke   Added feature token HYBRID_SWITCH
+//*           03/15/02    U G Jani       Turned ON Bitswap support for AU5I (au0502db) targets.
+//*           04/08/02    U G Jani       Enabled NLNOISEADJSNR token for AU5I targets.
+//*           06/24/02    Seungmok Oh    Added PERTONE_EQ token support for those targets:
+//*                                      (ar0500mp_debug, au0502mp_debug, ar0500mp, au0502mp)
+//*           06/26/02    Mallesh        Added DS_PWR_CUTBACK token. Default value 1.
+//*           06/27/02    Mallesh        Changed default value of DS_PWR_CUTBACK token to 0.
+//*           06/29/02    U.Dasgupta     Token cleanup: Removed ISDN_DEBUG token
+//*           04/29/02    Mannering      Remove EIGHTBITSRAM, Combined DOUBLEBUFFER with
+//*                                      BITSWAP, added FPGA token
+//*           05/03/02    Mannering      cleanup token changed by the new routine names
+//*           05/06/02    Mannering      Add tokens OUTBAND and INBAND for codec commands
+//*                                      If both OUTBAND and INBAND are 0 codec register are
+//*                                      memory mapped.
+//*           05/29/2002  S.Yim          Removed AD1X, AFEDEV
+//*           08/31/2002  Paul Hunt      Added PERTONE_EQ and HYBRID_SWITCH for ar0700mp
+//*           09/12/2002  Paul Hunt      Added support for ar0700db target.
+//*           08/07/2002  U.Dasgupta     Turned off MARGIN_DELTA_RETRAIN feature for ISDN platforms
+//*           11/14/2002  Paul Hunt      Merged AX5 MR6 PC modifications into AR7 codebase, specifically
+//*                                      turned off MARGIN_DELTA_RETRAIN feature for ar0700db target
+//*           08/26/2002  N. Warke       Added DUAL_TEQ token. Active only for Ax7 target
+//*           09/26/2002  Mannering      Add token CODEC_EMU for codec emulator board
+//*           10/15/2002  Iyer/Molla     Added DMT_BIS token for DELT support
+//*           10/21/2002  A. Redfern     Added PHY_EC_ENABLE and PHY_PATH_ENABLE tokens
+//*           10/23/2002  A. Redfern     Removed LINE_DIAG token
+//*           10/28/2002  J. Bergsagel   Cleaned up old targets and cleaned up the token list
+//*           10/30/2002  A. Redfern     Added PHY_TDW_ENABLE
+//*           11/01/2002  A. Redfern     Removed SMART_MARGIN token
+//*           11/01/2002  Mustafa        Turned on SPECTRAL_SHAPING features for Lucent AnyMedia O.69 Interop.
+//*           11/15/2002  Yim/Mannering  Added CODEC_EMU token for analog emulation board specifics
+//*           11/15/2002  Iyer/Molla     Added DEBUG_DELT and MEM_STR token to support DELT debug
+//*           12/27/2002  Sameer V       Added ATM_TC_HW token for Sangam.
+//*           01/06/2003  J. Bergsagel   Added default values for NLNOISEADJSNR, ARTT and DS_PWR_CUTBACK
+//*           01/07/2003  S.Yim          Modified ar0700db_diag target to turn on ISDN token
+//*           01/22/2003  J. Bergsagel   Added back in defines for the debug targets.
+//*           01/21/2003  MCB            Implemented Ax7 UNIT-MODULE modular software framework.
+//*           01/31/2003  J. Bergsagel   Made debug targets to be for the FPGA platform; non-debug for Sangam.
+//*                                      Turned off DUAL_TEQ, PHY_EC_ENABLE and PHY_PATH_ENABLE by default
+//*                                      for the Sangam (non-debug) targets.
+//*                                      Turned off OLAYDP token by default.
+//*                                      Turned off SWTC and turned on ATM_TC_HW by default for Sangam targets.
+//*           01/29/2003  Sameer V       Added ATMBERT_HW token for Sangam.
+//*           02/04/2003  D. Mannering   Added CO_PROFILE token
+//*           02/19/2003  Sameer V       Added back EXTERNBERT token for ar0700mp_dp and ar0700db_dp targets.
+//*                                      Disabled EXTERNBERT for debug target since it is not supported on the
+//*                                      FPGA platform.
+//*           02/21/2003  A. Redfern     Turned off OAM_EOC, AOC and BITSWAP (until memory issues are resolved).
+//*                                      Turned on DUAL_TEQ, PHY_PATH_ENABLE and PHY_EC_ENABLE.
+//*           02/21/2003  D. Mannering   Added DEBUG_DUMP.
+//*           03/06/2003  J. Bergsagel   Cleaned up tokens for each target and switched diag targets
+//*                                      over to the Sangam platform (instead of the FPGA platform).
+//*           03/07/2003  J. Bergsagel   Cleaned up TC and BERT tokens
+//*           03/11/2003  J. Bergsagel   Turned on AOC and BITSWAP for Sangam POTS and ISDN targets.
+//*           03/20/2003  Mallesh        Added SHALF token.
+//*           03/24/2003  F. Mujica      Enable hybrid selection
+//*           03/26/2003  A. Redfern     Removed PMEMSAVE_GHS (always = 1).
+//*           04/08/2003  F. Mujica      Renamed HYBRID_SWITCH token to PHY_HYB_ENABLE
+//*           04/08/2003  J. Bergsagel   Turned off PHY_HYB_ENABLE for _debug targets (FPGA board builds)
+//*           04/09/2003  J. Bergsagel   Turned on OLAYDP only for ar0700mp and ar0700db.
+//*                                      Turned on AOC, BITSWAP, and OAM_EOC for ar0700mp and ar0700db.
+//*           04/09/2003  J. Bergsagel   Corrected name "PHY_HYB_SELECT" to "PHY_HYB_ENABLE"
+//*           04/15/2003  A. Redfern     Turned on ECI_PULSECOM_INTEROP because phase optimization was enabled.
+//*           05/05/2003  D. Mannering   Review Comments - turn on AOC, EXTERNBERT, SHALF, for ar0700mp; amd
+//*                                      turn on AOC for ar0700db
+//*           05/11/2003  Prashant S     Added DMT_BIS token for AR7 Soft DI work
+//*           05/13/2003  J. Bergsagel   Turned on IMPROVED_STAT_SUPPORT_06_03_00 by default for necessary statistics
+//*           05/15/2003  J. Bergsagel   Turned off CO_PROFILE for diag targets.
+//*           05/27/2003  U.Dasgupta     Added NLNOISEADJSNR_EC token for ISDN - to take care of non-linear noise
+//*                                      (from ISDN splitter) compensation.
+//*           06/02/2003  Z. Yang        Added PHY_NDIAG_ENABLE token.
+//*           06/02/2003  Z. Yang        Added COMB_LINEDIAG_ENABLE token.
+//*           06/05/2003  P. Hunt        Turned on ATUC_CLEARDOWN_CHANGE token for all targets.
+//*           06/05/2003  Mallesh        Turned on CENTILLIUM_VENDORID_AND_TXRATE_CHNG to enable logging the vendor ID
+//*                                      for centillium and litespan
+//*           06/05/2003  U.Dasgupta     Turned on SHALF token for ISDN.
+//*           06/06/2003  U.Dasgupta     Turned on G.hs nonstandard field token for ar0700db target.
+//*           06/12/2003  J. Bergsagel   Changed *_debug targets to be for JTAG=1 instead of FPGA targets
+//*                                      IMPORTANT: For non-JTAG cases, "JTAG" should be undefined.
+//*                                      Therefore, "JTAG" should not have a default case at the bottom (JTAG 0)
+//*           06/18/2003  A. Redfern     Turned on spectral shaping token for all targets.
+//*           06/23/2003  J. Bergsagel   Turned off GHS_NON_STD_FIELD token for ar0700db until bugs are fixed.
+//*           06/23/2003  U G Jani       Undid the above change since the bug is fixed.
+//*           06/27/2003  Mallesh        Removed all the interop tokens which are no longer required.
+//*           08/20/2003  J. Bergsagel   Added default value for OVHD_PMDTEST_PARA and put default section
+//*                                      tokens in alphabetical order.
+//*           10/09/2003  Hanyu Liu      Defined token ADSL2_1BIT_TONE to support Rx one bit constellation.
+//*           10/12/2003  Hanyu Liu      Defined token ADSL2_BSWP for bitswap.
+//*           10/20/2003  Xiaohui Li     Added READSL2_ENABLE token.
+//*           12/01/2003  Seungmok Oh    Added TXDF2B_PROFILING token, which is active only for POTS target.
+//*           12/09/2003  Jack Huang     Turned on GHS_NON_STD_FIELD support for AR7 POTS targets
+//*           12/16/2003  Mustafa T.     Added the necessary definitions for diag target.  
+//*****************************************************************************************************
+//*
+//* The default flag settings are:
+//*
+//*   -dATUC=1 -dSTD=0 -dISDN=0 -dTIPCI=0 -dTID=0 -dTII=0 -dAI=0
+//*   -dEVM2=0 -dEU=0 -dSL=0 -dSL_EVM=1 -dGLITE=0
+//*
+//* and are set after all the per-suffix options have had a chance to
+//* set them.  Each flag is only set if it has not previously been set, so
+//* per-suffix settings  can override defaults, and command-line defines can
+//* override per-suffix settings.
+//*
+//*****************************************************************************
+
+
+//* ===========================================================================
+//*   Suffix codes
+//*     The command-line can include -dOBJSFX_xxx to get a flag set
+//*     instead of explicitly setting each flag on each CC/ASM command-line.
+//*     and the object suffix will control the settings of "feature" constants.
+//* ===========================================================================
+//
+//* ===========================================================================
+//   Flag settings for new suffixes (in alphabetical order of suffix)
+//     Each suffix has to specify only those flags which differ from the
+//     default settings.
+//* ===========================================================================
+//  NOTE: Try to keep feature flags in alphabetical order to ease maintenance.
+//* ===========================================================================
+//*
+
+#define CHIPSET_ID_UNKN '?'
+#define CHIPSET_ID_AH   'H'
+#define CHIPSET_ID_AP   'P'
+#define CHIPSET_ID_AR   'R'
+#define CHIPSET_ID_ARV  'R'
+#define CHIPSET_ID_AT   'T'
+#define CHIPSET_ID_AU   'U'
+
+#define CHIPSET_ID2_GENERIC '0'
+#define CHIPSET_ID2_ARV  'R'
+
+  #define DSPDP_IMAGE_ID_STANDARD(code) ( \
+      STANDARD_is_MULTIMODE(code) ? "M" : \
+      STANDARD_is_GDMT(code)      ? "D" : \
+      STANDARD_is_GLITE(code)     ? "L" : \
+      STANDARD_is_T1413(code)     ? "T" : "_")
+
+  #define DSPDP_IMAGE_ID_SERVICE(code)  ( \
+      SERVICE_is_POTS(code)        ? "P" : \
+      SERVICE_is_ISDN_ANNEXB(code) ? "B" : \
+      SERVICE_is_ISDN_ANNEXC(code) ? "C" : \
+      SERVICE_is_ISDN_PROP(code)   ? "I" : "")
+
+// Bit-codes for feature byte in new version.
+//
+// 0000 0000
+// |||| ||||
+// |||| |||+ -- POTS
+// |||| ||+---- ISDN_ANNEXB
+// |||| |+----- ISDN_ANNEXC
+// |||| +------ ISDN_PROP
+// |||+--------
+// ||+--------- GHS
+// |+---------- GLITE
+// +----------- T1413
+//
+//
+#define FEATURE_BIT_T1413       0x80
+#define FEATURE_BIT_GLITE       0x40
+#define FEATURE_BIT_GHS         0x20
+#define FEATURE_BIT_ISDN_PROP   0x08
+#define FEATURE_BIT_ISDN_ANNEXC 0x04
+#define FEATURE_BIT_ISDN_ANNEXB 0x02
+#define FEATURE_BIT_POTS        0x01
+
+#define STANDARD_BITS_MASK      (FEATURE_BIT_T1413 | FEATURE_BIT_GLITE | FEATURE_BIT_GHS)
+#define STANDARD_BITS_T1413      FEATURE_BIT_T1413
+#define STANDARD_BITS_GHS        FEATURE_BIT_GHS
+#define STANDARD_BITS_GLITE     (FEATURE_BIT_GLITE | FEATURE_BIT_GHS)
+#define STANDARD_BITS_GDMT      (STANDARD_BITS_T1413 | STANDARD_BITS_GHS)
+#define STANDARD_BITS_MULTIMODE (STANDARD_BITS_T1413 | STANDARD_BITS_GLITE | STANDARD_BITS_GDMT)
+
+#define SERVICE_BIT_ISDN_ANNEXB  FEATURE_BIT_ISDN_ANNEXB
+#define SERVICE_BIT_ISDN_ANNEXC  FEATURE_BIT_ISDN_ANNEXC
+#define SERVICE_BIT_ISDN_PROP    FEATURE_BIT_ISDN_PROP
+#define SERVICE_BIT_POTS         FEATURE_BIT_POTS
+
+//
+//  Debug new-style suffixes
+//
+//
+
+#if defined(OBJSFX_ar0700db_debugobj)
+#ifndef OBJSFX_ar0700dbobj
+#define OBJSFX_ar0700dbobj 1
+#endif
+// Here, in alphabetic order, are the feature tokens that
+// distinguish this suffix from its non-_debug partner:
+// (All other tokens from the non-_debug partner that are non-conflicting will also be picked up)
+
+#ifndef JTAG
+#define JTAG 1
+#endif
+
+#elif defined(OBJSFX_ar0700mp_debugobj)
+#ifndef OBJSFX_ar0700mpobj
+#define OBJSFX_ar0700mpobj 1
+#endif
+// Here, in alphabetic order, are the feature tokens that
+// distinguish this suffix from its non-_debug partner:
+// (All other tokens from the non-_debug partner that are non-conflicting will also be picked up)
+
+#ifndef ADSL2_BSWP
+#define ADSL2_BSWP 1 
+#endif
+#ifndef AOC 
+#define AOC 1 
+#endif
+#ifndef BITSWAP
+#define BITSWAP 1 
+#endif
+#ifndef DEBUG_ADSL2
+#define DEBUG_ADSL2  0
+#endif
+#ifndef DEBUG_LOG 
+#define DEBUG_LOG 0 
+#endif
+#ifndef GHS_NON_STD_FIELD
+#define GHS_NON_STD_FIELD 1
+#endif
+#ifndef JTAG
+#define JTAG 1
+#endif
+#endif  // end of the series of "#elif defined" for debug targets
+
+
+//
+//  Standard new-style suffixes for operational and mfgr'ing diag.
+//
+
+#if defined(OBJSFX_ar0700dbobj)
+#define CHIPSET_AR07    1
+#define PLATFORM_AR0700 1
+#define DSPDP_CHIPSET_ID      CHIPSET_ID_AR
+#define DSPDP_CHIPSET_ID2     CHIPSET_ID2_GENERIC
+#define DSPDP_CHIPSET_GEN     7
+#define DSPDP_HARDWARE_REV1   '0'
+#define DSPDP_HARDWARE_REV2   '0'
+#define DSPDP_FEATURE_CODE   (STANDARD_BITS_GDMT|SERVICE_BIT_ISDN_ANNEXB)
+#ifndef AOC
+#define AOC 1
+#endif
+// ATM_TC_HW and SWTC are mutually exclusive
+#ifndef ATM_TC_HW
+#define ATM_TC_HW 1
+#endif
+#ifndef SWTC
+#define SWTC 0
+#endif
+#ifndef BITSWAP
+#define BITSWAP 1
+#endif
+#ifndef EXTERNBERT
+#define EXTERNBERT 0
+#endif
+#ifndef GHS_NON_STD_FIELD
+#define GHS_NON_STD_FIELD 1
+#endif
+#ifndef MARGIN_DELTA_RETRAIN
+#define MARGIN_DELTA_RETRAIN 0
+#endif
+#ifndef NLNOISEADJSNR_EC
+#define NLNOISEADJSNR_EC 1
+#endif
+#ifndef OLAYDP
+#define OLAYDP 1
+#endif
+#ifndef SHALF
+#define SHALF 1
+#endif
+
+
+#elif defined(OBJSFX_ar0700db_diagobj)
+#define CHIPSET_AR07    1
+#define PLATFORM_AR0700 1
+#define DSPDP_CHIPSET_ID      CHIPSET_ID_AR
+#define DSPDP_CHIPSET_ID2     CHIPSET_ID2_GENERIC
+#define DSPDP_CHIPSET_GEN     7
+#define DSPDP_HARDWARE_REV1   '0'
+#define DSPDP_HARDWARE_REV2   '0'
+#define DSPDP_FEATURE_CODE   (STANDARD_BITS_GDMT|SERVICE_BIT_ISDN_ANNEXB)
+#ifndef AOC
+#define AOC 0
+#endif
+// ATM_TC_HW and SWTC are mutually exclusive (or both must be off)
+#ifndef ATM_TC_HW
+#define ATM_TC_HW 0
+#endif
+#ifndef SWTC
+#define SWTC 0
+#endif
+#ifndef BITSWAP
+#define BITSWAP 0
+#endif
+#ifndef CO_PROFILE
+#define CO_PROFILE 0
+#endif
+#ifndef MARGIN_DELTA_RETRAIN
+#define MARGIN_DELTA_RETRAIN 0
+#endif
+#ifndef MFGR_DIAG
+#define MFGR_DIAG 1
+#endif
+#ifndef OAM_EOC
+#define OAM_EOC 0
+#endif
+#ifndef OLAYDP
+#define OLAYDP 0
+#endif
+#ifndef SNR_UPDATE
+#define SNR_UPDATE 0
+#endif
+
+#elif defined(OBJSFX_ar0700mpobj)
+#define CHIPSET_AR07    1
+#define PLATFORM_AR0700 1
+#define DSPDP_CHIPSET_ID      CHIPSET_ID_AR
+#define DSPDP_CHIPSET_ID2     CHIPSET_ID2_GENERIC
+#define DSPDP_CHIPSET_GEN     7
+#define DSPDP_HARDWARE_REV1   '0'
+#define DSPDP_HARDWARE_REV2   '0'
+#define DSPDP_FEATURE_CODE   (STANDARD_BITS_MULTIMODE|SERVICE_BIT_POTS)
+#ifndef AOC
+#define AOC 1
+#endif
+// ATM_TC_HW and SWTC are mutually exclusive
+#ifndef ADSL2_1BIT_TONE
+#define ADSL2_1BIT_TONE 0
+#endif
+#ifndef ADSL2_BSWP
+#define ADSL2_BSWP 1 
+#endif
+#ifndef ATM_TC_HW
+#define ATM_TC_HW 1
+#endif
+#ifndef SWTC
+#define SWTC 0
+#endif
+#ifndef BITSWAP
+#define BITSWAP 1
+#endif
+#ifndef EXTERNBERT
+#define EXTERNBERT 0
+#endif
+#ifndef OLAYDP
+#define OLAYDP 1
+#endif
+#ifndef DMT_BIS
+#define DMT_BIS 1 
+#endif
+#ifndef SHALF
+#define SHALF 1 
+#endif
+#ifndef MEM_STR
+#define MEM_STR 0
+#endif
+#ifndef DS_LOOP_BACK
+#define DS_LOOP_BACK 0
+#endif
+#ifndef LOOP_BACK_DEBUG
+#define LOOP_BACK_DEBUG 0
+#endif
+#ifndef US_LOOP_BACK
+#define US_LOOP_BACK 0
+#endif
+#ifndef OVHD_PMDTEST_PARA
+#define OVHD_PMDTEST_PARA 0
+#endif
+#ifndef DS_RX_CODEWORD
+#define DS_RX_CODEWORD 1 
+#endif
+#ifndef READSL2_ENABLE
+#define READSL2_ENABLE 1
+#endif
+#ifndef GHS_NON_STD_FIELD
+#define GHS_NON_STD_FIELD 1
+#endif
+
+#elif defined(OBJSFX_ar0700mp_diagobj)
+#define CHIPSET_AR07    1
+#define PLATFORM_AR0700 1
+#define DSPDP_CHIPSET_ID      CHIPSET_ID_AR
+#define DSPDP_CHIPSET_ID2     CHIPSET_ID2_GENERIC
+#define DSPDP_CHIPSET_GEN     7
+#define DSPDP_HARDWARE_REV1   '0'
+#define DSPDP_HARDWARE_REV2   '0'
+#define DSPDP_FEATURE_CODE   (STANDARD_BITS_MULTIMODE|SERVICE_BIT_POTS)
+#ifndef ADSL2_BSWP
+#define ADSL2_BSWP 0
+#endif
+#ifndef AOC
+#define AOC 0
+#endif
+// ATM_TC_HW and SWTC are mutually exclusive (or both must be off)
+#ifndef ATM_TC_HW
+#define ATM_TC_HW 0
+#endif
+#ifndef SWTC
+#define SWTC 0
+#endif
+#ifndef BITSWAP
+#define BITSWAP 0
+#endif
+#ifndef CO_PROFILE
+#define CO_PROFILE 0
+#endif
+#ifndef DMT_BIS
+#define DMT_BIS 0
+#endif
+#ifndef MARGIN_DELTA_RETRAIN
+#define MARGIN_DELTA_RETRAIN 0
+#endif
+#ifndef MFGR_DIAG
+#define MFGR_DIAG 1
+#endif
+#ifndef OAM_EOC
+#define OAM_EOC 0
+#endif
+#ifndef OLAYDP
+#define OLAYDP 0
+#endif
+#ifndef SNR_UPDATE
+#define SNR_UPDATE 0
+#endif
+#ifndef US_CRC_RETRAIN
+#define US_CRC_RETRAIN 0
+#endif
+#ifndef ADSL2_BSWP
+#define ADSL2_BSWP 0
+#endif
+#ifndef DMT_BIS
+#define DMT_BIS  0
+#endif
+#ifndef DS_RX_CODEWORD
+#define DS_RX_CODEWORD 0
+#endif
+
+#else
+#define DSPDP_CHIPSET_ID      CHIPSET_ID_UNKN
+#define DSPDP_CHIPSET_ID2     CHIPSET_ID2_GENERIC
+#define DSPDP_CHIPSET_GEN     0
+#define DSPDP_HARDWARE_REV1   '0'
+#define DSPDP_HARDWARE_REV2   '0'
+#define DSPDP_FEATURE_CODE    0
+#endif
+
+// For use in checking the code in drivers -- indented to avoid .h->.ah
+ #define STANDARD_is_T1413(code)      (!(((code) & STANDARD_BITS_MASK) ^  STANDARD_BITS_T1413))
+ #define STANDARD_is_GLITE(code)      (!(((code) & STANDARD_BITS_MASK) ^  STANDARD_BITS_GLITE))
+ #define STANDARD_is_GHS(code)          (((code) & STANDARD_BITS_MASK) &  STANDARD_BITS_GHS)
+ #define STANDARD_is_GDMT(code)       (!(((code) & STANDARD_BITS_MASK) ^ (STANDARD_BITS_T1413 | STANDARD_BITS_GHS)))
+ #define STANDARD_is_MULTIMODE(code)  (!(((code) & STANDARD_BITS_MASK) ^ (STANDARD_BITS_T1413 | STANDARD_BITS_GLITE | STANDARD_BITS_GDMT)))
+ #define SERVICE_is_POTS(code)           ((code) & SERVICE_BIT_POTS)
+ #define SERVICE_is_ISDN_ANNEXB(code)    ((code) & SERVICE_BIT_ISDN_ANNEXB)
+ #define SERVICE_is_ISDN_ANNEXC(code)    ((code) & SERVICE_BIT_ISDN_ANNEXC)
+ #define SERVICE_is_ISDN_PROP(code)      ((code) & SERVICE_BIT_ISDN_PROP)
+
+#define STANDARD_T1413     (!((DSPDP_FEATURE_CODE & STANDARD_BITS_MASK) ^  STANDARD_BITS_T1413))
+#define STANDARD_GLITE     (!((DSPDP_FEATURE_CODE & STANDARD_BITS_MASK) ^  STANDARD_BITS_GLITE))
+#define STANDARD_GHS         ((DSPDP_FEATURE_CODE & STANDARD_BITS_MASK) &  STANDARD_BITS_GHS)
+#define STANDARD_GDMT      (!((DSPDP_FEATURE_CODE & STANDARD_BITS_MASK) ^ (STANDARD_BITS_T1413 | STANDARD_BITS_GHS)))
+#define STANDARD_MULTIMODE (!((DSPDP_FEATURE_CODE & STANDARD_BITS_MASK) ^ (STANDARD_BITS_T1413 | STANDARD_BITS_GLITE | STANDARD_BITS_GDMT)))
+
+#define SERVICE_POTS        (DSPDP_FEATURE_CODE & SERVICE_BIT_POTS)
+#define SERVICE_ISDN_ANNEXB (DSPDP_FEATURE_CODE & SERVICE_BIT_ISDN_ANNEXB)
+#define SERVICE_ISDN_ANNEXC (DSPDP_FEATURE_CODE & SERVICE_BIT_ISDN_ANNEXC)
+#define SERVICE_ISDN_PROP   (DSPDP_FEATURE_CODE & SERVICE_BIT_ISDN_PROP)
+#define SERVICE_ISDN        (SERVICE_ISDN_ANNEXB | SERVICE_ISDN_ANNEXC | SERVICE_ISDN_PROP)
+
+
+//
+//  Backwards compatibility with old tokens
+//
+
+#if (SERVICE_POTS)
+#ifndef ISDN
+#define ISDN 0
+#endif
+#endif
+
+#if (SERVICE_ISDN_ANNEXB | SERVICE_ISDN_PROP)
+#ifndef ISDN
+#define ISDN 1
+#endif
+#endif
+
+
+//
+//* ===========================================================================
+//  More Default settings
+//* ===========================================================================
+//
+
+//
+//  BEGIN Could automatically generate showdefs code
+//
+#ifndef AOC
+#define AOC 1
+#endif
+#ifndef ARTT
+#define ARTT 0
+#endif
+#ifndef ATMBERT
+#define ATMBERT 0
+#endif
+// ATM_TC_HW and SWTC are mutually exclusive
+#ifndef ATM_TC_HW
+#define ATM_TC_HW 1
+#endif
+#if ATM_TC_HW
+#ifndef ATMBERT_HW
+#define ATMBERT_HW 1
+#endif
+#ifndef SWTC
+#define SWTC 0
+#endif
+#else // else case for #if ATM_TC_HW
+#ifndef ATMBERT_HW
+#define ATMBERT_HW 0
+#endif
+#ifndef SWTC
+#define SWTC 1
+#endif
+#endif // end of #if ATM_TC_HW
+#ifndef ATM_TC_PATH1_ON
+#define ATM_TC_PATH1_ON 0
+#endif
+#ifndef BITSWAP
+#define BITSWAP 1
+#endif
+#ifndef COMB_LINEDIAG_ENABLE
+#define COMB_LINEDIAG_ENABLE  0
+#endif
+#ifndef CODEC_EMU
+#define CODEC_EMU 0
+#endif
+#ifndef CO_PROFILE
+#define CO_PROFILE 1
+#endif
+#ifndef DDC
+#define DDC 0
+#endif
+#ifndef DEBUG_ADSL2
+#define DEBUG_ADSL2 0 
+#endif
+#ifndef DEBUG_DUMP
+#define DEBUG_DUMP 0
+#endif
+#ifndef DEBUG_LOG
+#define DEBUG_LOG 0
+#endif
+#ifndef DEV_DEBUG
+#define DEV_DEBUG 0
+#endif
+#ifndef DS_LOOP_BACK
+#define DS_LOOP_BACK 0
+#endif
+#ifndef DS_RX_CODEWORD
+#define DS_RX_CODEWORD 1
+#endif
+#ifndef LOOP_BACK_DEBUG
+#define LOOP_BACK_DEBUG 0
+#endif
+#ifndef US_LOOP_BACK
+#define US_LOOP_BACK 0
+#endif
+#ifndef DPLL_MODE
+#define DPLL_MODE 0
+#endif
+#ifndef DSPBIOSII
+#define DSPBIOSII 0
+#endif
+#ifndef DMT_BIS
+#define DMT_BIS 1
+#endif
+#ifndef ADSL2_1BIT_TONE
+#define ADSL2_1BIT_TONE 0
+#endif
+#ifndef ADSL2_BSWP
+#define ADSL2_BSWP 1
+#endif
+#ifndef MEM_STR
+#define MEM_STR 0
+#endif
+#ifndef DS_PWR_CUTBACK
+#define DS_PWR_CUTBACK 0
+#endif
+#ifndef DUAL_TEQ
+#define DUAL_TEQ 1
+#endif
+#ifndef EXTERNBERT
+#define EXTERNBERT 0
+#endif
+#ifndef FPGA
+#define FPGA 0
+#endif
+#ifndef INBAND
+#define INBAND 0
+#endif
+#ifndef ISDN
+#define ISDN 0
+#endif
+#ifndef ISDN_DEBUG
+#define ISDN_DEBUG 0
+#endif
+#ifndef LINE_DIAG
+#define LINE_DIAG 1
+#endif
+#ifndef LOOP_BACK_DEBUG
+#define LOOP_BACK_DEBUG 0
+#endif
+#ifndef MANUFACTURING_TESTS
+#define MANUFACTURING_TESTS 0
+#endif
+#ifndef MARGIN_DELTA_RETRAIN
+#define MARGIN_DELTA_RETRAIN 1
+#endif
+#ifndef MEM_STR
+#define MEM_STR 0
+#endif
+#ifndef MFGR_DIAG
+#define MFGR_DIAG 0
+#endif
+#ifndef NLNOISEADJSNR
+#define NLNOISEADJSNR 0
+#endif
+#ifndef NLNOISEADJSNR_EC
+#define NLNOISEADJSNR_EC 0
+#endif
+#ifndef NTR_MODE
+#define NTR_MODE 0
+#endif
+#ifndef OAM_EOC
+#define OAM_EOC 1
+#endif
+#ifndef OLAYDP
+#define OLAYDP 0
+#endif
+#ifndef OLAYDP_EMIF
+#define OLAYDP_EMIF 0
+#endif
+#ifndef OLAYDP_2STEP
+#define OLAYDP_2STEP 0
+#endif
+#ifndef OLAYDP_PCI
+#define OLAYDP_PCI 0
+#endif
+#ifndef OUTBAND
+#define OUTBAND 0
+#endif
+#ifndef OVHD_PMDTEST_PARA
+#define OVHD_PMDTEST_PARA 0
+#endif
+#ifndef PERTONE_EQ
+#define PERTONE_EQ 0
+#endif
+#ifndef PHY_EC_ENABLE
+#define PHY_EC_ENABLE 1
+#endif
+#ifndef PHY_HYB_ENABLE
+#define PHY_HYB_ENABLE 1
+#endif
+#ifndef PHY_NDIAG_ENABLE
+#define PHY_NDIAG_ENABLE 0
+#endif
+#ifndef PHY_PATH_ENABLE
+#define PHY_PATH_ENABLE 1
+#endif
+#ifndef PHY_TDW_ENABLE
+#define PHY_TDW_ENABLE 0
+#endif
+#ifndef TC_ATM_PCIMASTER
+#define TC_ATM_PCIMASTER 0
+#endif
+#ifndef SEPARATE_TX_RX_BUFFERS
+#define SEPARATE_TX_RX_BUFFERS 0
+#endif
+#ifndef SHALF
+#define SHALF 0
+#endif
+#ifndef SPECTRAL_SHAPING
+#define SPECTRAL_SHAPING 1
+#endif
+#ifndef SNR_UPDATE
+#define SNR_UPDATE 1
+#endif
+#ifndef TC_DEBUG
+#define TC_DEBUG 0
+#endif
+#ifndef TC_LOOPBACK
+#define TC_LOOPBACK 0
+#endif
+#ifndef TESTMODE
+#define TESTMODE 0
+#endif
+#ifndef TRELLIS
+#define TRELLIS 1
+#endif
+#ifndef TXDF2B_PROFILING
+#if (SERVICE_POTS & (!MFGR_DIAG) & (CO_PROFILE))
+#define TXDF2B_PROFILING 1
+#else
+#define TXDF2B_PROFILING 0
+#endif
+#endif
+#ifndef US_CRC_RETRAIN
+#define US_CRC_RETRAIN 1
+#endif
+#ifndef US_LOOP_BACK
+#define US_LOOP_BACK 0
+#endif
+#ifndef USB
+#define USB 0
+#endif
+#ifndef READSL2_ENABLE
+#define READSL2_ENABLE 1
+#endif
+
+// Interop tokens
+#ifndef GHS_NON_STD_FIELD
+#define GHS_NON_STD_FIELD 0
+#endif
+#ifndef LUCENT_ANYMEDIA_ENIATT_INTEROP
+#define LUCENT_ANYMEDIA_ENIATT_INTEROP 0
+#endif
+
+
+//
+//  END Could automatically generate showdefs code
+//
+#if DSPDP_FEATURE_CODE
+#else
+// Unrecognized_suffix____check_spelling
+#endif
+//
+//  LNK_CMD is set when running CPP to generate lnk_cpe.cmd file
+//  -- the linker is not happy when it sees C code show up in the
+//  result!
+//
+#ifndef LNK_CMD
+extern int compile_happy;  // Keep the compiler from complaining about an empty file
+#endif
+
+#endif
+
diff -urN linux.old/drivers/atm/sangam_atm/env_def_typedefs.h linux.dev/drivers/atm/sangam_atm/env_def_typedefs.h
--- linux.old/drivers/atm/sangam_atm/env_def_typedefs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/env_def_typedefs.h	2005-08-23 04:46:50.104842632 +0200
@@ -0,0 +1,228 @@
+#ifndef __ENV_DEF_TYPEDEFS_H__
+#define __ENV_DEF_TYPEDEFS_H__ 1
+
+/*******************************************************************************
+*  FILE PURPOSE: Define data types for C and TMS320C6x C compilers
+********************************************************************************
+*
+*  FILE NAME: dpsys_typedefs.h
+*
+*  DESCRIPTION:
+*        This file contains the main typedefs that we need.
+*
+*  HISTORY:
+*
+*  03/11/97  Bob Lee      Created
+*  03/13/97  Chishtie
+*  03/14/97  Bob Lee      Format change to meet "Engineering Model
+*                         - System Architucture Specification"
+*                         Rev AP3.  Jan. 29, 1997
+*  07/21/00  Barnett      Moved many common typedefs from
+*                         host i/f header file to here.
+*  03/30/01  Barnett      Mod's per driver team feedback.
+*                         Some tokens cannot be def'ed
+*                         if _WINDEF_ is def'ed.
+*  04/05/01  Barnett      Added DSPDP_ prefix to tokens that originate
+*                         in the public interface.
+*  06/01/01  J. Bergsagel Modified to add standard typedefs
+*  07/25/01  J. Bergsagel Changed name from typedefs.h to dpsys_typedefs.h
+*  07/30/01  J. Bergsagel Moved typedefs that were conflicting with Windows
+*                         driver software to the "#ifndef _WINDEF_" section.
+*  08/09/01  S. Yim       Moved FALSE/TRUE definitions from ctl_interface_u.h
+*                         (conflict with BIOS/std.h)
+*  09/03/01  S. Yim       Do not include typedef char and float if _STD defined
+*                         (conflict with BIOS/std.h)
+*  01/21/03  MCB          Implemented Ax7 UNIT-MODULE modular software framework.
+*  03/20/03  Mallesh      Defined size of basic variables
+*  03/27/03  F. Mujica    Added SINT40 and UINT40 definitions.
+*
+*  (C) Copyright Texas Instruments Inc. 1997-2001.  All rights reserved.
+*******************************************************************************/
+
+// Common type definitions
+
+// Basic constants needed everywhere
+#ifndef STD_
+#define FALSE 0
+#define TRUE 1
+#endif
+
+// Read-Write Data Types
+typedef signed char           SINT8;      // Signed 8-bit integer (7-bit magnitude)
+typedef unsigned char         UINT8;      // Unsigned 8-bit integer
+typedef signed short          SINT16;     // Signed 16-bit integer (15-bit magnitude)
+typedef unsigned short        UINT16;     // Unsigned 16-bit integer
+typedef signed int            SINT32;     // Signed 32-bit integer (31-bit magnitude)
+typedef unsigned int          UINT32;     // Unsigned 32-bit integer
+typedef long signed int       SINT40;     // Long signed 40-bit integer
+typedef long unsigned int     UINT40;     // Long unsigned 40-bit integer
+
+// All pointers are 32 bits long
+typedef SINT8                 *PSINT8;    // Pointer to SINT8
+typedef UINT8                 *PUINT8;    // Pointer to UINT8
+typedef SINT16                *PSINT16;   // Pointer to SINT16
+typedef UINT16                *PUINT16;   // Pointer to UINT16
+typedef SINT32                *PSINT32;   // Pointer to SINT32
+typedef UINT32                *PUINT32;   // Pointer to UINT32
+
+#define SIZEOF_SINT8          1
+#define SIZEOF_UINT8          1
+#define SIZEOF_SINT16         2
+#define SIZEOF_UINT16         2
+#define SIZEOF_SINT32         4
+#define SIZEOF_UINT32         4
+#define SIZEOF_SINT40         8
+#define SIZEOF_UINT40         8
+
+// Size of Read-Write Data Types - in bytes
+#define SIZEOF_char   1
+#define SIZEOF_Int8   1
+#define SIZEOF_UChar  1
+#define SIZEOF_UInt8  1
+#define SIZEOF_Float  4
+#define SIZEOF_Double 8
+#define SIZEOF_byte   1
+
+// Read-Only Data Types - should be only used for ROM code
+typedef const char            CharRom;    // 8 bit signed character
+typedef const signed char     Int8Rom;    // 8 bit signed integer
+typedef const unsigned char   UCharRom;    // 8 bit unsigned character
+typedef const unsigned char   UInt8Rom;   // 8 bit unsigned integer
+typedef const float           FloatRom;   // IEEE 32-bit
+typedef const double          DoubleRom;  // IEEE 64-bit
+
+#ifndef _WINDEF_ 
+
+// Read-Write Data Types
+typedef signed char           Int8;       // 8 bit signed integer
+typedef unsigned char         UChar;      // 8 bit unsigned character
+typedef unsigned char         UInt8;      // 8 bit unsigned integer
+#ifndef STD_
+typedef char                  Char;       // 8 bit signed character
+typedef float                 Float;      // IEEE 32-bit
+#endif
+typedef double                Double;     // IEEE 64-bit
+typedef signed char           byte;       // 8 bit signed integer
+
+
+// These typedefs collide with those in Win2k DDK inc\WINDEF.H
+
+// common type definition
+typedef unsigned char   BYTE;    // 8-bit
+typedef signed short    SHORT;   // 16-bit signed
+typedef unsigned short  WORD;    // 16-bit
+typedef unsigned int    DWORD;   // 32-bit, TI DSP has 40 bit longs
+
+// All pointers are 32 bits long
+typedef BYTE           *PBYTE;  // pointer to 8 bit data
+typedef unsigned char  *PCHAR;  // pointer to 8 bit data
+typedef SHORT          *PSHORT; // pointer to 16 bit data
+typedef WORD           *PWORD;  // pointer to 16 bit data
+typedef DWORD          *PDWORD; // pointer to 32 bit data
+
+#endif // #ifndef _WINDEF_
+
+
+#define SIZEOF_BYTE   1
+#define SIZEOF_SHORT  2
+#define SIZEOF_WORD   2
+#define SIZEOF_DWORD  4
+#define SIZEOF_PCHAR  4
+#define SIZEOF_PWORD  4
+#define SIZEOF_PDWORD 4
+
+// Size of Read-Only Data Types - in bytes
+#define SIZEOF_CharRom   1
+#define SIZEOF_Int8Rom   1
+#define SIZEOF_UCharRom  1
+#define SIZEOF_UInt8Rom  1
+#define SIZEOF_FloatRom  4
+#define SIZEOF_DoubleRom 8
+
+#define SIZEOF_complex_byte     (2*SIZEOF_byte)
+#define SIZEOF_PTR_complex_byte 4
+typedef struct {
+  byte    re;
+  byte    im;
+} complex_byte, *PTR_complex_byte;
+
+#define SIZEOF_complex_short   4
+#define SIZEOF_PTR_complex_short 4
+typedef struct {
+  short   re;
+  short   im;
+} complex_short, *PTR_complex_short;
+
+#define SIZEOF_complex_int     8
+#define SIZEOF_PTR_complex_int 4
+typedef struct {
+  int     re;
+  int     im;
+} complex_int, *PTR_complex_int;
+
+typedef struct {
+  int high;
+  unsigned int low;
+} int64;
+
+typedef struct {
+  int64 real;
+  int64 imag;
+} complex_int64;
+
+#define SIZEOF_PVOID 4
+typedef void *PVOID;            // pointer to void
+
+//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+
+#if defined(_TMS320C6X)           // TMS320C6xx type definitions 
+
+// Read-Write Data Types 
+typedef short                   Int16;      // 16 bit signed integer 
+typedef unsigned short          UInt16;     // 16 bit unsigned integer 
+typedef int                     Int32;      // 32 bit signed integer 
+typedef unsigned int            UInt32;     // 32 bit unsigned signed integer 
+typedef long                    Long40;     // 40 bit signed integer 
+typedef unsigned long           ULong40;    // 40 bit unsigned signed integer 
+
+// Size of Read-Write Data Types - in bytes
+#define SIZEOF_Int16   2
+#define SIZEOF_UInt16  2
+#define SIZEOF_Int32   4
+#define SIZEOF_UInt32  4
+#define SIZEOF_Long40  5
+#define SIZEOF_ULong40 5
+
+// Read-Only Data Types - should be only used for ROM code
+typedef const short             Int16Rom;   // 16 bit signed integer 
+typedef const unsigned short    UInt16Rom;  // 16 bit unsigned integer 
+typedef const int               Int32Rom;   // 32 bit signed integer 
+typedef const unsigned int      UInt32Rom;  // 32 bit unsigned signed integer 
+typedef const long              Long40Rom;  // 40 bit signed integer 
+typedef const unsigned long     ULong40Rom; // 40 bit unsigned signed integer 
+
+// Size of Read-Only Data Types - in bytes
+#define SIZEOF_Int16Rom   2
+#define SIZEOF_UInt16Rom  2
+#define SIZEOF_Int32Rom   4
+#define SIZEOF_UInt32Rom  4
+#define SIZEOF_Long40Rom  5
+#define SIZEOF_ULong40Rom 5
+
+#else                             // 32 bits PC Host type definitions 
+
+// Read-Write Data Types 
+typedef short                   Int16;      // 16 bit signed integer 
+typedef unsigned short          UInt16;     // 16 bit unsigned integer 
+typedef int                     Int32;      // 32 bit signed integer 
+typedef unsigned int            UInt32;     // 32 bit unsigned integer 
+
+// Read-Only Data Types - should be only used for ROM code 
+typedef const short             Int16Rom;   // 16 bit signed integer 
+typedef const unsigned short    UInt16Rom;  // 16 bit unsigned integer 
+typedef const int               Int32Rom;   // 32 bit signed integer 
+typedef const unsigned int      UInt32Rom;  // 32 bit unsigned integer 
+
+#endif
+
+#endif
diff -urN linux.old/drivers/atm/sangam_atm/Makefile linux.dev/drivers/atm/sangam_atm/Makefile
--- linux.old/drivers/atm/sangam_atm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/Makefile	2005-08-23 04:46:50.104842632 +0200
@@ -0,0 +1,35 @@
+# File: drivers/net/avalanche_cpmac/Makefile
+#
+# Makefile for the Linux network (CPMAC) device drivers.
+#
+
+
+O_TARGET := tiatm.o
+obj-$(CONFIG_MIPS_SANGAM_ATM) += tiatm.o
+list-multi      := tiatm.o
+
+tiatm-objs	:= tn7atm.o tn7dsl.o tn7sar.o dsl_hal_api.o dsl_hal_support.o cpsar.o aal5sar.o
+
+EXTRA_CFLAGS += -DEL -I$(TOPDIR)/drivers/atm/sangam_atm -DPOST_SILICON -DCOMMON_NSP -DCONFIG_LED_MODULE -DDEREGISTER_LED -DNO_ACT
+
+ifeq ($(ANNEX),B)
+EXTRA_CFLAGS += -DANNEX_B -DB
+else
+ifeq ($(ANNEX),C)
+EXTRA_CFLAGS += -DANNEX_C -DC
+else
+EXTRA_CFLAGS += -DANNEX_A -DP
+endif
+endif
+
+
+include $(TOPDIR)/Rules.make
+
+tiatm.o:      $(tiatm-objs)
+	$(LD) -r -o $@ $(tiatm-objs)
+
+#avalanche_cpmac.o:      $(avalanche_cpmac-objs)
+#	$(LD) -r -o $@ $(avalanche_cpmac-objs)
+
+clean:
+	rm -f core *.o *.a *.s
diff -urN linux.old/drivers/atm/sangam_atm/queue.h linux.dev/drivers/atm/sangam_atm/queue.h
--- linux.old/drivers/atm/sangam_atm/queue.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/queue.h	2005-08-23 04:46:50.104842632 +0200
@@ -0,0 +1,167 @@
+
+#if !defined( __QUEUE_H__ )
+#define __QUEUE_H__
+
+typedef spinlock_t OS_SPIN_LOCK;
+#define osFreeSpinLock(pLock) while(0)
+void osAcquireSpinLock(OS_SPIN_LOCK *pLock);
+void osReleaseSpinLock(OS_SPIN_LOCK *pLock);
+void osAllocateSpinLock(OS_SPIN_LOCK *pLock);
+
+//#define osAcquireSpinLock(pLock) spin_lock(pLock)
+//#define osReleaseSpinLock(pLock) spin_unlock(pLock)
+//#define osAllocateSpinLock(pLock) spin_lock_init(pLock)
+
+
+typedef struct _TI_LIST_ENTRY {
+  struct _TI_LIST_ENTRY *Flink;
+  struct _TI_LIST_ENTRY *Blink;
+} TI_LIST_ENTRY, *PTI_LIST_ENTRY, TQE, *PTQE;
+
+typedef struct _TIATM_LIST_ENTRY 
+{
+  TI_LIST_ENTRY  Link;
+} TIATM_LIST_ENTRY, *PTIATM_LIST_ENTRY;
+
+//-------------------------------------------------------------------------
+// QueueInitList -- Macro which will initialize a queue to NULL.
+//-------------------------------------------------------------------------
+#define QueueInitList(_L) (_L)->Link.Flink = (_L)->Link.Blink = (PTI_LIST_ENTRY)0;
+
+//-------------------------------------------------------------------------
+// QueueEmpty -- Macro which checks to see if a queue is empty.
+//-------------------------------------------------------------------------
+#define QueueEmpty(_L) (QueueGetHead((_L)) == (PTIATM_LIST_ENTRY)0)
+
+//-------------------------------------------------------------------------
+// QueueGetHead -- Macro which returns the head of the queue, but does not
+// remove the head from the queue.
+//-------------------------------------------------------------------------
+#define QueueGetHead(_L) ((PTIATM_LIST_ENTRY)((_L)->Link.Flink))
+
+#define QueueGetNext(Elem) ((PTIATM_LIST_ENTRY)((Elem)->Link.Flink))
+
+//-------------------------------------------------------------------------
+// QueuePushHead -- Macro which puts an element at the head of the queue.
+//-------------------------------------------------------------------------
+#define QueuePushHead(_L,_E) \
+  if (!((_E)->Link.Flink = (_L)->Link.Flink)) \
+  { \
+    (_L)->Link.Blink = (PTI_LIST_ENTRY)(_E); \
+  } \
+(_L)->Link.Flink = (PTI_LIST_ENTRY)(_E);
+
+//-------------------------------------------------------------------------
+// QueueRemoveHead -- Macro which removes the head of the head of queue.
+//-------------------------------------------------------------------------
+#define QueueRemoveHead(_L) \
+{                                                     \
+  PTIATM_LIST_ENTRY ListElem;                        \
+  if (ListElem = (PTIATM_LIST_ENTRY)(_L)->Link.Flink) \
+  {   \
+    if(!((_L)->Link.Flink = ListElem->Link.Flink)) \
+      (_L)->Link.Blink = (PTI_LIST_ENTRY) 0; \
+  } \
+}
+
+//-------------------------------------------------------------------------
+// QueuePutTail -- Macro which puts an element at the tail (end) of the queue.
+//-------------------------------------------------------------------------
+#define QueuePutTail(_L,_E) \
+{ \
+  if ((_L)->Link.Blink) \
+  { \
+    ((PTIATM_LIST_ENTRY)(_L)->Link.Blink)->Link.Flink = (PTI_LIST_ENTRY)(_E); \
+    (_L)->Link.Blink = (PTI_LIST_ENTRY)(_E); \
+  } \
+  else \
+  { \
+    (_L)->Link.Flink = \
+    (_L)->Link.Blink = (PTI_LIST_ENTRY)(_E); \
+  } \
+  (_E)->Link.Flink = (PTI_LIST_ENTRY)0; \
+}
+
+//-------------------------------------------------------------------------
+// QueuePutTailWithLock -- Macro which puts an element at the tail (end) of 
+// the queue, using spin lock.
+//-------------------------------------------------------------------------
+#define QueuePutTailWithLock(_L,_E, pLock) \
+{ \
+  osAcquireSpinLock(pLock); \
+  if ((_L)->Link.Blink) \
+  { \
+    ((PTIATM_LIST_ENTRY)(_L)->Link.Blink)->Link.Flink = (PTI_LIST_ENTRY)(_E); \
+    (_L)->Link.Blink = (PTI_LIST_ENTRY)(_E); \
+  } \
+  else \
+  { \
+    (_L)->Link.Flink = \
+    (_L)->Link.Blink = (PTI_LIST_ENTRY)(_E); \
+  } \
+  (_E)->Link.Flink = (PTI_LIST_ENTRY)0; \
+  osReleaseSpinLock(pLock); \
+}
+
+//-------------------------------------------------------------------------
+// QueueGetTail -- Macro which returns the tail of the queue, but does not
+// remove the tail from the queue.
+//-------------------------------------------------------------------------
+#define QueueGetTail(_L) ((PTIATM_LIST_ENTRY)((_L)->Link.Blink))
+
+//-------------------------------------------------------------------------
+// QueuePopHead -- Macro which  will pop the head off of a queue (list), and
+//                 return it (this differs only from queueremovehead only in 
+//                 the 1st line)
+//-------------------------------------------------------------------------
+#define QueuePopHead(_L) \
+(PTIATM_LIST_ENTRY) (_L)->Link.Flink; QueueRemoveHead(_L);
+
+#define QueueRemoveTail(_L)  \
+{                                                     \
+  PTIATM_LIST_ENTRY ListElem;                        \
+  ListElem = (PTIATM_LIST_ENTRY)(_L)->Link.Flink; \
+  if(ListElem == (PTIATM_LIST_ENTRY)(_L)->Link.Blink) \
+  {   \
+    (_L)->Link.Flink = (_L)->Link.Blink = (PTI_LIST_ENTRY) 0; \
+  } \
+  else \
+  {    \
+    while(ListElem->Link.Flink != (PTI_LIST_ENTRY)(_L)->Link.Blink) \
+    { \
+      ListElem = (PTIATM_LIST_ENTRY)ListElem->Link.Flink; \
+    } \
+    (_L)->Link.Blink = (PTI_LIST_ENTRY) ListElem; \
+    ListElem->Link.Flink = (PTI_LIST_ENTRY)0; \
+  } \
+}
+
+#define QueueRemoveItem(_L, Elem)  \
+{                                                     \
+  PTIATM_LIST_ENTRY ListElem;                        \
+  ListElem = (PTIATM_LIST_ENTRY)(_L)->Link.Flink; \
+  if(ListElem == Elem) \
+  { \
+    QueueRemoveHead(_L); \
+  } \
+  else \
+  { \
+    while(ListElem) \
+    { \
+      if(Elem == (PTIATM_LIST_ENTRY)ListElem->Link.Flink) \
+      { \
+        ListElem->Link.Flink = ((PTIATM_LIST_ENTRY)Elem)->Link.Flink; \
+        if(Elem == (PTIATM_LIST_ENTRY)(_L)->Link.Blink) \
+          (_L)->Link.Blink = (PTI_LIST_ENTRY) 0; \
+        break; \
+      } \
+      ListElem = (PTIATM_LIST_ENTRY)ListElem->Link.Flink; \
+    }\
+  } \
+  ((PTIATM_LIST_ENTRY)Elem)->Link.Flink = (PTI_LIST_ENTRY) 0; \
+}
+
+#define QueuePopTail(_L)  \
+((PTIATM_LIST_ENTRY)((_L)->Link.Blink)); QueueRemoveTail(_L); 
+
+#endif
diff -urN linux.old/drivers/atm/sangam_atm/release.txt linux.dev/drivers/atm/sangam_atm/release.txt
--- linux.old/drivers/atm/sangam_atm/release.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/release.txt	2005-08-23 04:46:50.104842632 +0200
@@ -0,0 +1,118 @@
+This is release notes for AR7 Linux ATM driver.
+
+version 04.02.04.00
+-------------------
+
+1. Corrected the conditional logic from logical AND to logical OR in the case
+   of check for DSL line down condition.  This is to fix PPPoA crashing
+   problem when DSL line is unplugged.
+
+version 04.02.03.00
+-------------------
+1. Changed overlay page to static allocation.
+2. Added flag to stop TX during channel closing.
+3. Changed DMA memory allocation back to "GFP_ATOMIC" flag.
+
+version 04.02.02.00
+-------------------
+1. Changed DMA memory allocation from "GFP_ATOMIC" to  "GFP_KERNEL" flag.
+2. Added "DoMask" setting for VBR channel setup.
+
+version 04.02.01.01
+-------------------
+1. Modified priority check scheme per SPTC request.
+
+Version 04.02.01.00
+-------------------
+1. Add check to skb->priority to place packets to either normal or priority queue.
+2. Add spin lock to increment and decrement of queued buffer number.
+
+Version 04.02.00.00
+-------------------
+Features:
+1. Add MBS and CDVT QoS support for ATM driver.
+2. Add "stop/start queue" for ToS application.
+3. Add Showtime margin retrain based on EOC message.
+4. Add EOC vendor ID customalization logic for Annex B.
+5. Supports D3 datapump.
+
+Version 04.01.00.00
+-------------------
+Re-release of 04.00.07.00 for D1.1 datapump.
+
+Version 04.00.07.00
+-------------------
+Features:
+1. Add marging retrain capability by setting following Adam2 Env.
+   setenv enable_margin_retrain 1
+   setenv margin_threshold xx, xx is in half db, i.e., 10 means 5db.
+
+Bugfixs:
+1. New PDSP firmware that fix the F5 OAM cell loopback probelm in Cisco DSLAM.
+
+Version 04.00.06.00
+-------------------
+1. ATM interrupt pacing is defauted to 2 interrupts/s.
+2. Rx Service MAX changed ftom 16 to 8.
+
+Version 04.00.05.00
+-------------------
+Features:
+1. Add Adam2 env to disable the TurboDSL by entering "setenv TurboDSL 0".
+2. Add ability to set interrupt pacing for ATM driver.
+
+Bugfixs:
+1. Fixed the RFC2684 and CLIP problems for Cisco router.
+2. Fixed LED blinking problem when DSL cable is unplugged.
+3. Fixed problem that "selected mode" is not updated.
+
+Version 04.00.04.00
+-------------------
+Features:
+1. Added feature so OAM F5 ping will not require a corresponding PVC channel to
+   be setup.
+2. Added timeout value for F5 OAM ping. The new command are "exxxpyyycdzzzt" for
+   end-to-end and "sxxxpyyycdzzzt" for segment. "zzz" is timeout value in milli-second.
+3. Added proc entry "avsar_pvc_table" to record received VPIs and VCIs. The format is 
+	vpi,vci
+   seperated by new line. To search for PVCs, an application can do the following.
+	i) Send a (or several) F5 OAM cell on a VPI/VPI pairs with command 
+	   echo exxxpyyycd2t > /proc/sys/dev/dslmod
+	ii) Wait >2ms or poll proc entry /proc/avalanche/avsar_oam_ping until the result
+	   indicates a failure. (It will be failed all the time with 2ms timeout.)
+	iii) Repeat above two steps for new VPI/VCI pairs.
+      iv) Check proc entry /proc/avalanche/avsar_pvc_table any time for PVCs that responded.
+  
+Version 04.00.03.00
+-------------------
+Bug Fixs:
+1. Fixed bug that caused crash when phone cable is unplugged.
+2. Fixed LED operation for "flexible LEDs".
+
+Features:
+1. Added the proc entry "avsar_oam_ping" to signal oam ping result.
+   0 - failed; 1 - success; 2 - in progress.
+2. Added oam ping timeout env variable. The timeout can be specified by
+   adding Adam2 env "oam_lb_timeout". The value is in millisecond.
+
+Version 04.00.02.00
+-------------------
+1. The driver uses hardware queue for Turbo DSL.
+2. Added new modem statistics listed below:
+	US and DS TX powers, atuc Vendor ID and revision, training mode selected, 
+	Hybrid Selected, and etc.
+
+Version 04.00.01.00
+-------------------
+
+1. This driver release contains all the features that exists in AR5 Linux ATM 
+   3.1 driver.
+
+2. F4 OAM generation is added.
+
+3. Software queuing is used for TURBO DSL.
+
+4. Porting guide "is created. Please look into that document for detailed 
+   information.
+
+   
diff -urN linux.old/drivers/atm/sangam_atm/syssw_version.h linux.dev/drivers/atm/sangam_atm/syssw_version.h
--- linux.old/drivers/atm/sangam_atm/syssw_version.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/syssw_version.h	2005-08-23 04:46:50.105842480 +0200
@@ -0,0 +1,94 @@
+#ifndef __SYSSW_VERSION_H__
+#define __SYSSW_VERSION_H__ 1
+
+/*******************************************************************************
+* FILE PURPOSE:     DSL Driver API functions for Sangam
+*
+********************************************************************************
+* FILE NAME:        dsl_hal_basicapi.c
+*
+* DESCRIPTION:  
+*       Contains basic DSL HAL APIs for Sangam
+*  
+* (C) Copyright 2003-04, Texas Instruments, Inc.
+*    History
+*    Date        Version            Notes
+*    14May03     0.00.00            RamP   Original Version Created
+*    14May03     0.00.01            RamP   Initial Rev numbers inserted 
+*    14May03     0.00.02            RamP   Bumped version numbers for Dsl Hal
+*                                          & dhalapp for alpha plus
+*    19May03     0.00.03            MCB    Bumped dslhal version number
+*                                          because of dependant changes
+*                                          wrt. linux-nsp atm drivers.
+*    22May03     0.00.04            RamP   Bumped dslhal & dhalapp buildnum
+*                                          for inner/outer pair & DGASP code
+*    06Jun03     0.00.05            RamP   Bumped up buildnum for LED, STM, 
+*                                          interrupt processing, statistics
+*                                          and other pre-beta features
+*    09Jun03     0.00.06            JEB    Fixed error in DHALAPP bugfix/buildnum
+*    09Jun03     0.00.07            RamP   Bumped up buildnum for incremental
+*                                          changes to apis, statistics, memory
+*                                          fixes, parameter configurations
+*    11Jun03     0.00.08            RamP   Bumped up buildnum for Co profile
+*                                          free memory fix
+*    12Jun03     0.00.09            JEB    Bumped version numbers for AR7 1.00 Beta
+*    02Jul03     0.00.10            ZT     Bumped HAL version for overlay page
+*    18Jul03     0.00.11            RamP   Bumped HAL version for analog diags
+*    22Jul03     0.00.12            JEB    Bumped DHALAPP buildnum for analog diags
+*    31Jul03     0.00.13            RamP   Bumped HAL version for engr. drop
+*    04Aug03     0.00.14            JEB    Bumped HAL version buildnum for CHECKPOINT65 changes
+*                                          Bumped LINUX version buildnum for CHECKPOINT65 changes
+*    06Aug03     0.00.15            MCB    Bumped all version numbers in prep for AR7 1.0 R2 release for POTS.
+*    13Aug03     0.00.16            MCB    Set rev id's for D3/R1.1 (ADSL2).
+*    21Aug03     0.00.17            JEB    Bumped up build numbers for merge of code additions from D1
+*    26Sep03     0.00.18            JEB    Set rev id's for another D3/R1 (ADSL2).
+*    14Oct03     0.00.19            JEB    Bumped Linux minor number and reset bugfix number for release.
+*                                          Bumped build numbers on DSLHAL and DHALAPP for this checkpoint.
+*    14Oct03     0.00.20            JEB    Bumped build numbers on DSLHAL and DHALAPP for CHECKPOINT15.
+*    21Oct03     0.00.21            JEB    Bumped build number on DSLHAL for CHECKPOINT16.
+*    22Oct03     0.00.22            MCB    Bumped all version numbers in support of D3R1 release.
+*    27Oct03     0.00.23            JEB    Bumped build numbers on DSLHAL and DHALAPP for CHECKPOINT19.
+*                                          Updated version for DSLAGENT to be 02.01.00.01 for ACT 2.1 R0.
+*    30Oct03     0.00.24            JEB    Bumped bugfix number on LINUXATM Version for next release.
+*                                          Bumped build numbers on DSLHAL and DHALAPP
+*    31Oct03     0.00.25            MCB    Bumped all version numbers in support of D3R2 release.
+*    14Nov03     0.00.26            JEB    Bumped build numbers on DSLHAL and DHALAPP
+*                                          Changed version for DSLAGENT to be 02.00.01.01 for an ACT 2.0 R0
+*    20Nov03     0.00.27            JEB    Bumped build number on DSLHAL.
+*                                          Changed version for DSLAGENT to be 02.00.02.00 for the next ACT 2.0 R2
+*    21Nov03     0.00.28            MCB    Bumped all version numbers in support of D3R2 release.
+*    21Nov03     0.00.29            JEB    Bumped build numbers on DSLHAL and DHALAPP for D3-R0 drop on 11/21.
+*    16Dec03     0.00.30            JEB    Bumped build numbers on DSLHAL and DHALAPP for CHECKPOINT31.
+*    21Dec03     0.00.31            MCB    Bumped all version numbers in support of D3R2 release.
+*    05Jan04     0.00.32            JEB    Bumped build numbers on DSLHAL and Linux ATM for CHECKPOINT 34.
+*    15Jan04     0.00.33            JEB    Bumped build numbers on DSLHAL and Linux ATM for CHECKPOINT 36.
+*    26Jan04     0.00.34            JEB    Changed Linux ATM version number to be 04.02.03.00.
+*    27Jan04     0.00.35            MCB    Bumped all version numbers in support of D3R2 release.
+*******************************************************************************/
+
+/* Dsl Hal API Version Numbers */
+#define DSLHAL_VERSION_MAJOR       03
+#define DSLHAL_VERSION_MINOR       00
+#define DSLHAL_VERSION_BUGFIX      06
+#define DSLHAL_VERSION_BUILDNUM    00
+#define DSLHAL_VERSION_TIMESTAMP   00
+
+/* dhalapp Adam2 Application Version Numbers */
+#define DHALAPP_VERSION_MAJOR      03
+#define DHALAPP_VERSION_MINOR      00
+#define DHALAPP_VERSION_BUGFIX     05
+#define DHALAPP_VERSION_BUILDNUM   00
+
+/* Linux ATM Driver Version Numbers */
+#define LINUXATM_VERSION_MAJOR     04
+#define LINUXATM_VERSION_MINOR     02
+#define LINUXATM_VERSION_BUGFIX    04
+#define LINUXATM_VERSION_BUILDNUM  00
+
+/* DSL Agent Version Numbers */
+#define DSLAGENT_VERSION_MAJOR     02
+#define DSLAGENT_VERSION_MINOR     00
+#define DSLAGENT_VERSION_BUGFIX    02
+#define DSLAGENT_VERSION_BUILDNUM  00
+
+#endif /* pairs with #ifndef __SYSSW_VERSION_H__ */
diff -urN linux.old/drivers/atm/sangam_atm/tn7api.h linux.dev/drivers/atm/sangam_atm/tn7api.h
--- linux.old/drivers/atm/sangam_atm/tn7api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/tn7api.h	2005-08-23 04:46:50.105842480 +0200
@@ -0,0 +1,54 @@
+/* 
+ *    Tnetd73xx ATM driver.
+ *    by Zhicheng Tang, ztang@ti.com
+ *    2000 (c) Texas Instruments Inc.
+ *
+ *
+*/
+
+#ifndef __SAPI_H
+#define __SAPI_H
+
+/* tn7atm.c */
+void xdump(unsigned char *buff, int len, int debugLev);
+int tn7atm_receive(void *os_dev, int ch, unsigned int packet_size, void *os_receive_info, void *data);
+void *tn7atm_allocate_rx_skb(void *os_dev, void **os_receive_info, unsigned int size);
+void tn7atm_free_rx_skb(void *skb);
+void tn7atm_sarhal_isr_register(void *os_dev, void *hal_isr, int interrupt_num);
+int tn7atm_send_complete(void *osSendInfo);
+int tn7atm_device_connect_status(void *priv, int state);
+int tn7atm_lut_find(short vpi, int vci);
+
+/* tn7dsl.h */
+void tn7dsl_exit(void);
+int tn7dsl_init(void *priv);
+int tn7dsl_proc_stats(char* buf, char **start, off_t offset, int count,int *eof, void *data);
+int tn7dsl_proc_modem(char* buf, char **start, off_t offset, int count,int *eof, void *data);
+int tn7dsl_handle_interrupt(void);
+void dprintf( int uDbgLevel, char * szFmt, ...);
+void tn7dsl_dslmod_sysctl_register(void);
+void tn7dsl_dslmod_sysctl_unregister(void);
+int tn7dsl_get_dslhal_version(char *pVer);
+int tn7dsl_get_dsp_version(char *pVer);
+
+int os_atoi(const char *pStr);
+int os_atoh(const char *pStr);
+unsigned long os_atoul(const char *pStr);
+
+/* tn7sar.c */
+int tn7sar_activate_vc(Tn7AtmPrivate *priv, short vpi, int vci, int pcr, int scr, int mbs, int cdvt, int chan, int qos);
+int tn7sar_init(struct atm_dev *dev, Tn7AtmPrivate *priv);
+int tn7sar_register_interrupt_handle(void *os_dev, void *hal_isr, int *interrupt_num);
+void tn7sar_exit(struct atm_dev *dev, Tn7AtmPrivate *priv);
+int tn7sar_deactivate_vc(Tn7AtmPrivate *priv, int chan);
+int tn7sar_handle_interrupt(struct atm_dev *dev, Tn7AtmPrivate *priv);
+int tn7sar_send_packet(Tn7AtmPrivate *priv, int chan, void *new_skb, void *data,unsigned int len, int priority);
+void tn7sar_get_sar_version(Tn7AtmPrivate *priv, char **pVer);
+int tn7sar_get_near_end_loopback_count(unsigned int *pF4count, unsigned int *pF5count);
+int tn7sar_oam_generation(void *privContext, int chan, int type, int vpi, int vci, int timeout);
+int tn7sar_get_stats(void *priv1);
+int tn7sar_proc_sar_stat(char* buf, char **start, off_t offset, int count,int *eof, void *data);
+void tn7sar_get_sar_firmware_version(unsigned int *pdsp_version_ms, unsigned int *pdsp_version_ls);
+int tn7sar_proc_oam_ping(char* buf, char **start, off_t offset, int count,int *eof, void *data);
+int tn7sar_proc_pvc_table(char* buf, char **start, off_t offset, int count,int *eof, void *data);
+#endif
diff -urN linux.old/drivers/atm/sangam_atm/tn7atm.c linux.dev/drivers/atm/sangam_atm/tn7atm.c
--- linux.old/drivers/atm/sangam_atm/tn7atm.c	2005-08-28 01:52:26.000000000 -0600
+++ linux.dev/drivers/atm/sangam_atm/tn7atm.c	2005-08-28 02:08:07.000000000 -0600
@@ -0,0 +1,1233 @@
+/* 
+ *   tn7.c
+ *   Linux atm module implementation.
+ *   Zhicheng Tang 01/08/2003
+ *   2003 (c) Texas Instruments Inc.
+ *
+ *
+*/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/atmdev.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <asm/io.h>
+#include <asm/mips-boards/prom.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include "tn7atm.h"
+#include "tn7api.h"
+#include "syssw_version.h"
+
+#ifdef CONFIG_LED_MODULE
+#include <asm/ar7/ledapp.h>
+#endif
+#include <asm/ar7/avalanche_intc.h>
+
+#ifdef MODULE
+MODULE_DESCRIPTION ("Tnetd73xx ATM Device Driver");
+MODULE_AUTHOR ("Zhicheng Tang");
+#endif
+
+/* Version Information */
+//static char atm_version[] ="1.0.0.1";
+
+#define TRUE   1
+#define FALSE  0
+
+#define STOP_EMPTY_BUFF 2
+#define START_EMPTY_BUFF 3
+/* externs */
+
+/*end of externs */
+
+#define tn7atm_kfree_skb(x)     dev_kfree_skb(x)
+
+/* prototypes */
+int tn7atm_open (struct atm_vcc *vcc, short vpi, int vci);
+
+void tn7atm_close (struct atm_vcc *vcc);
+
+static int tn7atm_ioctl (struct atm_dev *dev, unsigned int cmd, void *arg);
+
+int tn7atm_send (struct atm_vcc *vcc, struct sk_buff *skb);
+
+static int tn7atm_change_qos (struct atm_vcc *vcc, struct atm_qos *qos,int flags);
+
+static int tn7atm_detect(void);
+static int tn7atm_init(struct atm_dev* dev);
+//static int tn7atm_reset(void);
+static int tn7atm_irq_request(struct atm_dev* dev);
+static int tn7atm_proc_version(char* buf, char **start, off_t offset, int count,int *eof, void *data);
+static void tn7atm_exit(void);
+static int tn7atm_proc_channels(char* buf, char **start, off_t offset, int count,int *eof, void *data);
+static int tn7atm_proc_private(char* buf, char **start, off_t offset, int count,int *eof,void *data);
+//static void tn7atm_free_packet(void *vcc1, void *priv, void *skb1);
+static int tn7atm_queue_packet_to_sar(void *vcc1, void *skb1);
+
+#include "turbodsl.c"
+
+/* ATM device operations */
+
+struct atm_dev *mydev;
+
+static const struct atmdev_ops tn7atm_ops = {
+        open:           tn7atm_open,
+        close:          tn7atm_close,
+        ioctl:          tn7atm_ioctl,
+        getsockopt:     NULL,
+        setsockopt:     NULL,
+        send:           tn7atm_send,
+        sg_send:          NULL,
+        phy_put:          NULL,
+        phy_get:          NULL,
+        change_qos:     tn7atm_change_qos,
+};
+
+
+int __guDbgLevel = 1;
+
+
+void xdump(unsigned char *buff, int len, int debugLev)
+{
+#ifdef DEBUG_BUILD
+  int i, j;
+  if( __guDbgLevel < debugLev)
+    return;
+
+  j=0;
+  for(i=0;i<len;i++)
+  {
+    printk("%02x ", buff[i]);
+    j++;
+    if(j==8)
+    {
+      j=0;
+      printk("\n");
+    }
+  }
+  printk("\n");
+#endif
+}
+
+
+#if 0 /* by nbd */
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_walk_vccs(struct atm_dev *dev, short *vcc, int *vci)
+ *
+ *  Description: retrieve VPI/VCI for connection
+ *
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+static int
+tn7atm_walk_vccs(struct atm_vcc *vcc, short *vpi, int *vci)
+{
+  struct atm_vcc* walk;
+
+  //    printk(tn7 "tn7atm_walk_vccs\n");
+  /* find a free VPI */
+  if (*vpi == ATM_VPI_ANY) {
+
+    for (*vpi = 0, walk = vcc->dev->vccs; walk; walk = walk->next) {
+
+      if ((walk->vci == *vci) && (walk->vpi == *vpi)) {
+        (*vpi)++;
+        walk = vcc->dev->vccs;
+      }
+    }
+  }
+
+  /* find a free VCI */
+  if (*vci == ATM_VCI_ANY) {
+        
+    for (*vci = ATM_NOT_RSV_VCI, walk = vcc->dev->vccs; walk; walk = walk->next) {
+
+      if ((walk->vpi = *vpi) && (walk->vci == *vci)) {
+        *vci = walk->vci + 1;
+        walk = vcc->dev->vccs;
+      }
+    }
+  }
+
+  return 0;
+}
+#endif
+
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_sar_irq(void)
+ *
+ *  Description: tnetd73xx SAR interrupt.
+ *
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+static void
+tn7atm_sar_irq(int irq , void *voiddev , struct pt_regs *regs)
+{
+  struct atm_dev *atmdev;
+  Tn7AtmPrivate *priv;
+
+  dprintf(6, "tn7atm_sar_irq\n");
+  atmdev = (struct atm_dev *) voiddev;
+  priv = (Tn7AtmPrivate *)atmdev->dev_data;
+
+  tn7sar_handle_interrupt(atmdev, priv);
+ 
+  dprintf(6, "Leaving tn7atm_sar_irq\n");
+}
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_dsl_irq(void)
+ *
+ *  Description: tnetd73xx DSL interrupt.
+ *
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+static void
+tn7atm_dsl_irq(int irq , void *voiddev , struct pt_regs *regs)
+{
+  struct atm_dev *atmdev;
+  Tn7AtmPrivate *priv;
+
+  dprintf(4, "tn7atm_dsl_irq\n");
+  atmdev = (struct atm_dev *) voiddev;
+  priv = (Tn7AtmPrivate *)atmdev->dev_data;
+
+  tn7dsl_handle_interrupt();
+ 
+  dprintf(4, "Leaving tn7atm_dsl_irq\n");
+}
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_Inittxcomp(struct tn7* tn7)
+ *
+ *  Description: Initialize Interrupt handler
+ *
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
+static int __init
+tn7atm_irq_request (struct atm_dev *dev)
+{
+  Tn7AtmPrivate *priv;
+  char *ptr;
+  int ipace=2;
+
+  dprintf(4, "tn7atm_irq_request()\n");
+  priv = (Tn7AtmPrivate *) dev->dev_data;
+
+  /* Register SAR interrupt */
+  priv->sar_irq = LNXINTNUM(ATM_SAR_INT);       /* Interrupt line # */
+  if (request_irq(priv->sar_irq, tn7atm_sar_irq, SA_INTERRUPT, "SAR ", dev))
+    printk ("Could not register tn7atm_sar_irq\n");
+
+  /* interrupt pacing */
+  ptr= prom_getenv("sar_ipacemax");
+  if(ptr)
+  {
+    ipace=os_atoi(ptr);
+  }
+  avalanche_request_pacing(priv->sar_irq, ATM_SAR_INT_PACING_BLOCK_NUM, ipace);
+
+  /* Reigster Receive interrupt A */
+  priv->dsl_irq = LNXINTNUM(ATM_DSL_INT);       /* Interrupt line # */
+  if (request_irq(priv->dsl_irq, tn7atm_dsl_irq, SA_INTERRUPT, "DSL ", dev))
+    printk ("Could not register tn7atm_dsl_irq\n");
+
+  return 0;
+}
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_lut_find(struct atm_vcc *vcc)
+ *
+ *  Description: find an TX DMA channel
+ *               that matches a vpi/vci pair
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
+int
+tn7atm_lut_find(short vpi, int vci)
+{
+  int      i;
+  Tn7AtmPrivate *priv;
+  
+  priv = (Tn7AtmPrivate *)mydev->dev_data;
+
+  if(vci==0) // find first vpi channel
+  {
+    for(i=0; i< MAX_DMA_CHAN; i++)
+    {  
+      if((priv->lut[i].vpi == vpi))
+      return i;
+    }
+  }
+
+  dprintf(4, "vpi=%d, vci=%d\n", vpi, vci);
+  for(i=0; i< MAX_DMA_CHAN; i++)
+  {  
+    if((priv->lut[i].vpi == vpi) && (priv->lut[i].vci == vci))
+      return i;
+  }
+
+  
+
+  return ATM_NO_DMA_CHAN;
+}
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_lut_clear(struct atm_vcc *vcc,int chan)
+ *
+ *  Description: find an TX DMA channel
+ *               that matches a vpi/vci pair
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
+static int
+tn7atm_lut_clear(struct atm_vcc *vcc, int chan)
+{
+  Tn7AtmPrivate *priv;
+  
+  priv = (Tn7AtmPrivate *)vcc->dev->dev_data;
+
+  memset(&priv->lut[chan], 0, sizeof(priv->lut[chan]));
+
+  return 0;
+}
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_walk_lut(void)
+ *
+ *  Description: find an available TX DMA channel
+ *               and initialize LUT
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
+static int 
+tn7atm_walk_lut(Tn7AtmPrivate *priv)
+{
+  int i;
+
+  for(i=0; i< MAX_DMA_CHAN; i++){ 
+    if(!priv->lut[i].inuse)
+    {    
+      return i;                            /* return available dma channel number */
+    }
+  }
+  return ATM_NO_DMA_CHAN;       /* no tx dma channels available */
+}
+
+static int 
+tn7atm_set_lut(Tn7AtmPrivate *priv, struct atm_vcc *vcc, int chan)
+{
+  
+  if(!priv->lut[chan].inuse)
+  {
+    priv->lut[chan].vpi = (int)vcc->vpi;
+    priv->lut[chan].vci = vcc->vci;
+    priv->lut[chan].chanid = chan;
+    priv->lut[chan].inuse = 1;         /* claim the channel */
+    priv->lut[chan].vcc = (void *)vcc;
+    priv->lut[chan].bClosing = 0;
+    priv->lut[chan].ready = 0;
+    priv->lut[chan].tx_total_bufs = TX_BUFFER_NUM;
+    priv->lut[chan].tx_used_bufs[0] = 0;
+    priv->lut[chan].tx_used_bufs[1] = 0;
+    return 0;
+  }
+  return -1;       /* no tx dma channels available */
+}
+
+#if 0
+static void tn7atm_free_packet(void *pVc, void *pDev, void *pPacket)
+  {
+  Tn7AtmPrivate *priv;
+  struct atm_vcc *vcc;
+  struct sk_buff *skb;
+
+  vcc = (struct atm_vcc *)pVc;
+  priv = (Tn7AtmPrivate *)pDev;
+  skb = (struct sk_buff *) pPacket;
+
+  if(vcc->pop)
+    vcc->pop(vcc, skb);   
+  else
+    tn7atm_kfree_skb(skb);
+  }
+#endif
+
+static void str2eaddr(char *pMac, char *pStr)
+{
+  char tmp[3];
+  int i;
+
+  for(i=0;i<6;i++)
+  {
+    tmp[0]=pStr[i*3];
+    tmp[1]=pStr[i*3+1];
+    tmp[2]=0;
+    pMac[i]=os_atoh(tmp);
+  }
+}
+
+static int __init
+tn7atm_get_ESI(struct atm_dev *dev)
+{
+  int  i;
+  char  esi_addr[ESI_LEN]={0x00,0x00,0x11,0x22,0x33,0x44};
+  char  *esiaddr_str = NULL;
+
+  esiaddr_str = prom_getenv("macc");
+
+  if (!esiaddr_str) {
+    //printk("macc address not set in adam2 environment space\n");
+    //printk("Using default macc address = 00:01:02:03:04:05\n");
+    esiaddr_str = "00:00:02:03:04:05";
+  }
+  str2eaddr(esi_addr, esiaddr_str);
+
+  for(i=0; i < ESI_LEN; i++)
+    dev->esi[i] = esi_addr[i];
+
+  return 0;
+}
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_open(struct atm_vcc *vcc, short vpi, int vci)
+ *
+ *  Description: Device operation: open
+ *
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
+//static int
+int tn7atm_open (struct atm_vcc *vcc, short vpi, int vci)
+{
+  Tn7AtmPrivate *priv;
+  int dmachan;
+  int rc;
+  int traffic_type;
+  int pcr = 0x20000;
+  int scr = 0x20000;
+  int mbs = 0x20000;
+  int cdvt = 10000;
+  int err;
+
+  dprintf(1, "tn7atm_open()\n");
+
+  priv = (Tn7AtmPrivate *)vcc->dev->dev_data; 
+  if(priv==NULL)
+  {
+    printk("null priv\n");
+    return -1;
+  }
+
+  MOD_INC_USE_COUNT;
+
+#if 0 /* by nbd */
+  /* find a free VPI/VCI */
+  tn7atm_walk_vccs(vcc, &vpi, &vci);
+#else
+  if ((err = atm_find_ci(vcc, &vpi, &vci))) {
+    printk("atm_find_ci err = %d\n", err);
+    return err;
+  }
+  
+#endif
+        
+  vcc->vpi = vpi;
+  vcc->vci = vci;
+
+  if (vci == ATM_VCI_UNSPEC || vpi == ATM_VCI_UNSPEC)
+  {
+    MOD_DEC_USE_COUNT;
+    return -EBUSY;
+  }
+  
+  /* check to see whether PVC is opened or not */
+  if((dmachan = tn7atm_lut_find(vcc->vpi, vcc->vci)) != ATM_NO_DMA_CHAN) 
+  {
+    MOD_DEC_USE_COUNT;  
+    printk("PVC already opened. dmachan = %d\n", dmachan);
+    return -EBUSY;
+  }
+  /*check for available channel */
+  if((dmachan = tn7atm_walk_lut(priv)) == ATM_NO_DMA_CHAN)
+  {
+    printk("No TX DMA channels available\n");
+    return -EBUSY;
+  }
+
+  set_bit(ATM_VF_ADDR, &vcc->flags);  /* claim address    */
+        
+  vcc->itf = vcc->dev->number;        /* interface number */
+
+  switch(vcc->qos.txtp.traffic_class)
+  {
+    case ATM_CBR: /* Constant Bit Rate */
+      traffic_type = 0;
+      pcr = vcc->qos.txtp.pcr;
+      scr = vcc->qos.txtp.pcr;
+      cdvt = vcc->qos.txtp.max_cdv;
+      printk("cdvt=%d\n", cdvt);
+      break;
+    case ATM_UBR: /* Unspecified Bit Rate */
+      traffic_type = 2;
+      break;
+
+	/* Disable ATM_VBR until pppd ppoatm plugin supports it.
+         * NOTE: Support ATM_VBR requires the addition of a scr
+         * field to the atm_trafprm structure which will cause
+	 * a change in the SO_ATMQOS ioctl. Make sure that the
+	 * revised header file becomes visible to the pppd
+	 * pppoatm plugin source, or the SO_ATMQOS ioctl will fail.
+	 */
+#if 0
+    case ATM_VBR: /* Variable Bit Rate */
+      traffic_type = 1;
+      pcr = vcc->qos.txtp.pcr;
+      scr = vcc->qos.txtp.scr;
+      if(vcc->qos.txtp.max_pcr >= 0)
+        mbs = vcc->qos.txtp.max_pcr;
+      cdvt = vcc->qos.txtp.max_cdv;
+      printk("cdvt=%d\n", cdvt);
+      printk("mbs=%d\n", mbs);
+      break;
+#endif
+    default:
+        traffic_type = 2;
+  }
+
+  dprintf(4, "vpi=%d, vci=%d, pcr=%d, dmachan=%d, qos=%d\n", vpi,vci,pcr,dmachan,traffic_type);
+  /* Activate SAR channel */
+  rc = tn7sar_activate_vc(priv, vpi, vci, pcr, scr, mbs, cdvt, dmachan, traffic_type);
+  if(rc < 0)
+  {
+    
+    MOD_DEC_USE_COUNT;
+    return -EBUSY;
+  }
+  
+  /* insure that the the vcc struct points to the correct entry
+       in the lookup table */
+
+  tn7atm_set_lut(priv,vcc, dmachan);
+  vcc->dev_data = (void *)&priv->lut[dmachan];
+  set_bit(ATM_VF_READY, &vcc->flags);
+
+  mdelay(100);
+  priv->lut[dmachan].ready = 1;
+  dprintf (1, "Leave tn7atm_open\n"); 
+  return 0;     
+}
+
+
+//static void
+void tn7atm_close (struct atm_vcc *vcc)
+{
+  Tn7AtmPrivate *priv;
+  int dmachan;
+
+  priv = (Tn7AtmPrivate *)vcc->dev->dev_data;
+  dprintf(4, "closing %d.%d.%d.%d\n", vcc->itf, vcc->vpi, vcc->vci, vcc->qos.aal);
+ 
+  clear_bit(ATM_VF_READY, &vcc->flags);  /* ATM_VF_READY: channel is ready to transfer data */
+
+  dmachan = tn7atm_lut_find(vcc->vpi, vcc->vci);
+  printk("closing channel: %d\n", dmachan);
+  if(dmachan == ATM_NO_DMA_CHAN)
+  {
+    printk("Closing channel not found.\n");
+    return;
+  }
+  priv->lut[dmachan].bClosing = 1;
+  priv->lut[dmachan].ready = 0;
+  if(tn7sar_deactivate_vc(priv,dmachan))  /* tear down channel */
+  {
+    printk("failed to close channel %d.\n", dmachan);
+  }
+
+  clear_bit(ATM_VF_READY, &vcc->flags);  /* ATM_VF_READY: channel is ready to transfer data */
+  tn7atm_lut_clear(vcc, dmachan);
+
+  MOD_DEC_USE_COUNT;
+
+  dprintf (1, "Leave tn7atm_close\n");
+}
+
+#define ATM_TXSTOP 0x800c61f4 
+static int
+tn7atm_ioctl (struct atm_dev *dev, unsigned int cmd, void *arg)
+{
+  Tn7AtmPrivate *priv;
+  priv = (Tn7AtmPrivate *) dev->dev_data;
+  
+    //printk("tn7atm_ioctl\n");
+    //printk("arg = %x\n", *(int *)arg);
+    //printk("cmd =%x\n", cmd);
+    switch(cmd)
+    {
+
+      case ATM_TXSTOP: /*temp fix for SAR tear down problem */
+//        printk("ioctl cmd = 0x%x (%u), arg = 0x%p (%lu)\n", cmd, cmd, arg, (unsigned long)arg);
+//        printk("arg = %d\n", *(int*)arg);
+        priv->xmitStop = *(int *)arg;
+        //printk("Executing ATM_SETLOOP for tn7 \n");
+        //printk("Stop variable = :%d: \n",priv->xmitStop);
+        return 0;
+
+      //case SAR_DSL_RESET_SOFTBOOT:
+      //  return tn7atm_dsl_clean_reboot();
+    case 0:
+        return 0;
+    }
+    
+    return -ENOSYS;
+  
+}
+
+static int
+tn7atm_change_qos (struct atm_vcc *vcc, struct atm_qos *qos,int flags)
+{
+  dprintf (1, "Enter tn7atm_change_qos\n");
+  dprintf (1, "Leave tn7atm_change_qos\n");
+  return 0;
+}
+
+
+int tn7atm_send (struct atm_vcc *vcc, struct sk_buff *skb)
+{
+  
+  Tn7AtmPrivate *priv;
+  int bret;
+  int chan;
+  
+  dprintf(4, "tn7atm_send()\n");
+  
+  priv = (Tn7AtmPrivate*)vcc->dev->dev_data;
+
+  //if(skb->len < 64)
+    //xdump((unsigned char *)skb->data, skb->len, 1);
+  //else
+    //xdump((unsigned char *)skb->data, 64, 1);
+  /* check for dsl line connection */
+
+  /* add vcc field in skb for clip inATMARP fix */
+  ATM_SKB(skb)->vcc = vcc;
+	/* Ron change 2.3 -> 2.4 ??*/
+  //if(priv->lConnected != 1 || priv->xmitStop == 1)
+  if(priv->lConnected != 1 && priv->xmitStop == 1)
+  {
+    dprintf(4,"dsl line down\n");
+    if(vcc->pop)
+      vcc->pop(vcc, skb);   
+    else
+     tn7atm_kfree_skb(skb);
+    return 1;
+  }
+  
+  /* check whether PVC is closing */
+  chan = tn7atm_lut_find(vcc->vpi, vcc->vci);
+  /* set br2684 dev pointer */
+  priv->lut[chan].net_device = skb->dev;
+  if(chan == ATM_NO_DMA_CHAN || priv->lut[chan].bClosing == 1)
+  {
+    dprintf(4, "can find sar channel\n");
+    if(vcc->pop)
+      vcc->pop(vcc, skb);   
+    else
+     tn7atm_kfree_skb(skb);
+    return 1;
+  }
+
+  bret=tn7atm_queue_packet_to_sar(vcc, skb);
+
+  return bret;
+}
+
+
+static int tn7atm_queue_packet_to_sar(void *vcc1, void *skb1)
+{
+  struct atm_vcc *vcc;
+  struct sk_buff *skb;
+  int priority = 1;
+  Tn7AtmPrivate *priv;
+  int dmachan;
+
+  vcc = (struct atm_vcc *)vcc1;
+  skb = (struct sk_buff *)skb1;
+
+  priv = (Tn7AtmPrivate*)vcc->dev->dev_data;
+
+  dprintf(4, "vcc->vci=%d\n", vcc->vci);
+  dmachan = tn7atm_lut_find(vcc->vpi, vcc->vci);
+  if(dmachan == ATM_NO_DMA_CHAN)
+  {
+    dprintf(4, "can find sar channel\n");
+    if(vcc->pop)
+      vcc->pop(vcc, skb);   
+    else
+     tn7atm_kfree_skb(skb);
+    return 1;
+  }
+
+  // turbo dsl TCP ack check
+  if(priv->bTurboDsl)
+    priority = turbodsl_check_priority_type(skb->data);
+
+  //skb priority check
+  if(priority != 0)
+  {
+    if((skb->cb[47])>>1)
+      priority=1;
+    else
+      priority = 0;
+  }
+  
+  /* add queue info here */
+  skb->cb[47] = (char)priority;
+  spin_lock_irqsave(&priv->netifqueueLock, priv->netifqueueLockFlag);
+  priv->lut[dmachan].tx_used_bufs[priority]++;
+  spin_unlock_irqrestore(&priv->netifqueueLock, priv->netifqueueLockFlag);
+
+  if(tn7sar_send_packet(priv,dmachan, skb, skb->data, skb->len, priority) != 0)
+  {
+    dprintf(1, "failed to send packet\n");
+    if(vcc->pop)
+      vcc->pop(vcc, skb);   
+    else
+     tn7atm_kfree_skb(skb);
+
+    spin_lock_irqsave(&priv->netifqueueLock, priv->netifqueueLockFlag);
+    priv->lut[dmachan].tx_used_bufs[priority]--;
+    spin_unlock_irqrestore(&priv->netifqueueLock, priv->netifqueueLockFlag);
+    return 1;
+  }
+  
+  /* check for whether tx queue is full or not */
+  //printk("bufs used = %d\n", priv->lut[dmachan].tx_used_bufs[1]);
+  spin_lock_irqsave(&priv->netifqueueLock, priv->netifqueueLockFlag);
+  if(priv->lut[dmachan].tx_used_bufs[1] >= (priv->lut[dmachan].tx_total_bufs - STOP_EMPTY_BUFF) ||
+      priv->lut[dmachan].tx_used_bufs[0] >= (priv->lut[dmachan].tx_total_bufs - STOP_EMPTY_BUFF))
+  {
+    //printk("net queue stoped\n");
+    netif_stop_queue(priv->lut[dmachan].net_device);
+    priv->lut[dmachan].netqueue_stop = 1;
+  }
+  spin_unlock_irqrestore(&priv->netifqueueLock, priv->netifqueueLockFlag);
+
+  return 0;
+}
+
+/* functions needed by SAR HAL */
+
+int tn7atm_send_complete(void *osSendInfo)
+{
+  Tn7AtmPrivate *priv;
+  //struct atm_dev *dev;
+  struct sk_buff *skb;
+  struct atm_vcc *vcc;
+  int chan;
+
+  dprintf(4, "tn7atm_send_complete()\n");
+
+
+  skb = (struct sk_buff *)osSendInfo;
+  //dev = (struct atm_dev *) (skb->dev);
+  priv = (Tn7AtmPrivate *)mydev->dev_data;
+  vcc =ATM_SKB(skb)->vcc;
+  if(vcc)
+  {
+    dprintf(4, "vcc->vci=%d\n",vcc->vci );
+    chan = tn7atm_lut_find(vcc->vpi, vcc->vci);
+    if(chan==ATM_NO_DMA_CHAN)
+      return 1;
+
+    /*decreament packet queued number */
+    spin_lock_irqsave(&priv->netifqueueLock, priv->netifqueueLockFlag);
+    priv->lut[chan].tx_used_bufs[(int)skb->cb[47]] --;
+    if(priv->lut[chan].tx_used_bufs[1] < priv->lut[chan].tx_total_bufs - START_EMPTY_BUFF &&
+       priv->lut[chan].tx_used_bufs[0] < priv->lut[chan].tx_total_bufs - START_EMPTY_BUFF)
+    {
+      if(priv->lut[chan].netqueue_stop)
+      {
+        //printk("net queue restarted\n");
+        netif_wake_queue(priv->lut[chan].net_device);
+        priv->lut[chan].netqueue_stop = 0;
+      }
+    }
+    spin_unlock_irqrestore(&priv->netifqueueLock, priv->netifqueueLockFlag);
+
+    if(vcc->pop)
+    {
+      dprintf(5, "free packet\n");
+      vcc->pop(vcc, skb);
+    }
+
+    
+  }
+    
+  
+
+  /* Update Stats: There may be a better place to do this, but this is a start */
+  priv->stats.tx_packets++;
+#ifdef CONFIG_LED_MODULE
+//    led_operation(MOD_ADSL, DEF_ADSL_ACTIVITY);           
+#endif
+
+  /* track number of buffer used */
+  
+  dprintf(4, "tn7atm_send_complete() done\n");
+
+  return 0;
+}
+
+void *tn7atm_allocate_rx_skb(void *os_dev, void **os_receive_info, unsigned int size)
+{
+  struct sk_buff *skb;
+  dprintf(4, "tn7atm_allocate_rx_skb size=%d\n", size);
+  size = ((size+3)&0xfffffffc);
+  skb = dev_alloc_skb(size);
+  if(skb==NULL)
+  {
+    //printk("rx allocate skb failed\n");
+    return NULL;
+  }
+  *os_receive_info = (void *)skb;
+  return (skb->data);
+}
+
+void tn7atm_free_rx_skb(void *skb)
+{
+  dprintf(4, "tn7atm_free_rx_skb\n");
+  tn7atm_kfree_skb((struct sk_buff *)skb);
+}
+
+
+int tn7atm_receive(void *os_dev, int ch, unsigned int packet_size, void *os_receive_info, void *data)
+{
+  Tn7AtmPrivate *priv;
+  struct atm_dev *dev;
+  struct sk_buff *skb;
+  struct atm_vcc *vcc;
+  
+
+  dprintf(4, "tn7atm_receive()\n");
+  dev = (struct atm_dev *)os_dev;
+
+  priv = (Tn7AtmPrivate *)dev->dev_data;
+
+  if(priv->lConnected != 1 || priv->lut[ch].ready == 0)
+  {
+    //printk("channel not ready\n");
+    return 1;
+  }
+
+  vcc = (struct atm_vcc *)priv->lut[ch].vcc;
+  if(vcc == NULL)
+  {
+    printk("vcc=Null");
+    return 1;
+  }
+
+
+  /* assume no fragment packet for now */
+  skb = (struct sk_buff *)os_receive_info;
+  
+  if(skb==NULL)
+  {
+    dprintf(1, "received empty skb.\n");
+    return 1;
+  }
+  /* see skbuff->cb definition in include/linux/skbuff.h */
+  ATM_SKB(skb)->vcc = vcc;
+
+  skb->len = packet_size;
+  dprintf(3, "skb:[0x%p]:0x%x pdu_len: 0x%04x\n",skb,skb->len,packet_size);
+  dprintf(3, "data location: 0x%x, 0x%x\n", (unsigned int)skb->data, (unsigned int)data);
+  
+  /*skb_trim(skb,skb->len); */   /* skb size is incorrect for large packets > 1428 bytes ?? */
+  __skb_trim(skb,skb->len); /* change to correct > 1500 ping when firewall is on */
+
+  dprintf(3, "pushing the skb...\n");
+  skb->stamp = xtime;
+
+  xdump((unsigned char *)skb->data, skb->len, 5);
+  
+  if(atm_charge(vcc, skb->truesize) == 0)
+  {
+    dprintf(1,"Receive buffers saturated for %d.%d.%d - PDU dropped\n", vcc->itf, vcc->vci, vcc->vpi);
+    return 1;
+  }
+
+  /*pass it up to kernel networking layer and update stats*/
+  vcc->push(vcc,skb);
+
+  /* Update receive packet stats */
+  priv->stats.rx_packets++;
+  atomic_inc(&vcc->stats->rx);
+
+#ifdef CONFIG_LED_MODULE
+//    led_operation(MOD_ADSL, DEF_ADSL_ACTIVITY);           
+#endif
+  dprintf(3, "(a) Receiving:vpi/vci[%d/%d] chan_id: %d  skb len:0x%x  skb truesize:0x%x\n",
+                vcc->vpi,vcc->vci,ch,skb->len, skb->truesize);
+  
+  return 0;
+}
+
+static int
+tn7atm_proc_channels(char* buf, char **start, off_t offset, int count,int *eof, void *data)
+{
+  int len = 0;
+  int limit = count - 80;
+  int i;
+
+  struct atm_dev *dev;
+  Tn7AtmPrivate *priv;
+
+  dev = (struct atm_dev *)data;
+  priv = (Tn7AtmPrivate *)dev->dev_data;
+
+  if(len<=limit)
+      len += sprintf(buf+len,"Chan  Inuse   ChanID   VPI     VCI \n");
+  if(len<=limit)
+      len += sprintf(buf+len,"------------------------------------------------------------------\n");
+
+  for(i=0; i < MAX_DMA_CHAN; i++)
+    {
+      if(len<=limit)
+        {
+          len += sprintf(buf+len, 
+                        " %02d    %05d   %05d   %05d   %05d \n",
+                        i,priv->lut[i].inuse,priv->lut[i].chanid,
+                        priv->lut[i].vpi,priv->lut[i].vci);
+        }
+    }
+
+  return len;
+}
+
+static int
+tn7atm_proc_private(char* buf, char **start, off_t offset, int count,int *eof, void *data)
+{
+  int len = 0;
+  int limit = count - 80;
+  struct atm_dev *dev;
+  Tn7AtmPrivate *priv;
+
+  dev = (struct atm_dev *)data;
+  priv = (Tn7AtmPrivate *)dev->dev_data;
+  
+  if(len<=limit)
+      len += sprintf(buf+len, "\nPrivate Data Structure(%s):\n",priv->name);
+  if(len<=limit)
+      len += sprintf(buf+len, "----------------------------------------\n");
+  if(len<=limit)
+      len += sprintf(buf+len, "priv:  0x%p\n",priv);
+  if(len<=limit)
+      len += sprintf(buf+len, "next:  0x%p",priv->next);
+  if(len<=limit)
+        len += sprintf(buf+len, "\tdev:   0x%p\n",priv->dev);
+ 
+  if(len<=limit)
+      len += sprintf(buf+len, "tx_irq: %02d",priv->sar_irq);
+  if(len<=limit)
+      len += sprintf(buf+len, "rx_irq: %02d",priv->dsl_irq);
+  
+
+  return len;
+}
+
+void tn7atm_sarhal_isr_register(void *os_dev, void *hal_isr, int interrupt_num)
+{
+  struct atm_dev *dev;
+  Tn7AtmPrivate *priv;
+
+  dprintf(4, "tn7atm_sarhal_isr_register()\n");
+
+  dev = (struct atm_dev *)os_dev;
+  priv = (Tn7AtmPrivate *)dev->dev_data;
+  priv->halIsr = (void *)hal_isr;
+  priv->int_num = interrupt_num;
+}
+
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_exit(void)
+ *
+ *  Description: Avalanche SAR exit function
+ *
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+
+static void
+tn7atm_exit (void)
+{
+
+  struct atm_dev        *dev;
+
+  Tn7AtmPrivate *priv;
+
+  dprintf(4, "tn7atm_exit()\n");
+
+  dev=mydev;
+  priv = (Tn7AtmPrivate *)dev->dev_data;
+  priv->lConnected = 0;
+  tn7dsl_exit();
+
+  tn7sar_exit(dev, priv);
+
+  /* freeup irq's */
+  free_irq(priv->dsl_irq,priv->dev);
+  free_irq(priv->sar_irq,priv->dev);
+  
+  kfree (dev->dev_data);
+
+  //    atm_dev_deregister (dev);
+  shutdown_atm_dev(dev);
+
+  /* remove proc entries */
+  remove_proc_entry("tiatm/avsar_ver",NULL);
+  remove_proc_entry("tiatm/avsar_modem_stats",NULL);
+  remove_proc_entry("tiatm/avsar_modem_training",NULL);
+  remove_proc_entry("tiatm/avsar_channels",NULL);
+  remove_proc_entry("tiatm/avsar_private",NULL);
+  remove_proc_entry("tiatm/avsar_sarhal_stats",NULL);
+  remove_proc_entry("tiatm/avsar_oam_ping",NULL);
+  remove_proc_entry("tiatm/avsar_pvc_table",NULL);
+  remove_proc_entry("tiatm",NULL);
+  tn7dsl_dslmod_sysctl_unregister();
+  
+  printk ("Module Removed\n");
+
+}
+
+
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_registration(struct tn7* tn7)
+ *
+ *  Description: ATM driver registration
+ *
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+
+static int __init
+tn7atm_register (Tn7AtmPrivate * priv)
+{
+  /* allocate memory for the device */
+
+  dprintf(4,"device %s being registered\n", priv->name);
+
+  mydev = atm_dev_register (priv->proc_name, &tn7atm_ops, -1, NULL);
+
+  if (mydev == NULL)
+    {
+      printk ("atm_dev_register returning NULL\n");     
+      return ATM_REG_FAILED;
+    }
+
+  printk ("registered device %s\n", priv->name);
+
+  mydev->dev_data = priv;       /* setup device data in atm_dev struct */
+  priv->dev = mydev;    /* setup atm_device in avalanche sar struct */
+
+  mydev->ci_range.vpi_bits = ATM_CI_MAX;        /* atm supports 11 bits */
+  mydev->ci_range.vci_bits = 16;        /* atm VCI max = 16 bits */
+
+  
+  return ATM_REG_OK;
+}
+
+static int 
+tn7atm_proc_version(char* buf, char **start, off_t offset, int count,int *eof, void *data)
+{
+  int len = 0;
+  char dslVer[8];
+  char dspVer[10];
+  char *pSarVer;
+  Tn7AtmPrivate *priv;
+  int i;
+  unsigned int pdspV1, pdspV2;
+
+  priv = mydev->dev_data;
+
+  len += sprintf(buf+len, "ATM Driver version:[%d.%02d.%02d.%02d]\n",LINUXATM_VERSION_MAJOR, LINUXATM_VERSION_MINOR,
+                                                                   LINUXATM_VERSION_BUGFIX, LINUXATM_VERSION_BUILDNUM);
+
+  tn7dsl_get_dslhal_version(dslVer);
+
+  len += sprintf(buf+len, "DSL HAL version: [%d.%02d.%02d.%02d]\n", dslVer[0], dslVer[1], dslVer[2],
+                                            dslVer[3]);
+  tn7dsl_get_dsp_version(dspVer);
+
+  len += sprintf(buf+len, "DSP Datapump version: [%d.%02d.%02d.%02d] ", dspVer[4], dspVer[5], dspVer[6],
+                                            dspVer[7]);
+  if(dspVer[8]==2) // annex B
+    len += sprintf(buf+len, "Annex B\n");
+  else if(dspVer[8]==3) //annex c
+    len += sprintf(buf+len, "Annex c\n");
+  else
+    len += sprintf(buf+len, "Annex A\n");
+
+  tn7sar_get_sar_version(priv, &pSarVer);
+
+  len += sprintf(buf+len, "SAR HAL version: [");
+  for(i=0;i<8;i++)
+  {
+    len += sprintf(buf+len, "%c", pSarVer[i+7]);
+  }
+  len += sprintf(buf+len, "]\n");
+
+  tn7sar_get_sar_firmware_version(&pdspV1, &pdspV2);
+  len += sprintf(buf+len, "PDSP Firmware version:[%01x.%02x]\n",
+                 pdspV1,pdspV2);
+
+  return len;
+}
+
+/*
+static struct net_device_stats
+*tn7atm_get_stats(struct atm_dev *dev)
+{
+  Tn7AtmPrivate *priv;
+  //unsigned long flags;
+
+  //spin_lock_irqsave(&priv->stats_lock,flags);
+  priv= (Tn7AtmPrivate *)dev->dev_data;
+  //spin_unlock_irqrestore(&priv->stats_lock,flags);
+  
+  return &priv->stats;
+  
+}
+*/
+/* Device detection */
+
+static int __init
+tn7atm_detect (void)
+{
+  Tn7AtmPrivate *priv;
+  //static struct proc_dir_entry *proc_dir;
+
+  dprintf(4, "tn7atm_detect().\n");
+  /* Device allocated as a global static structure at top of code "mydev" */
+
+  /* Alloc priv struct */
+  priv=kmalloc(sizeof(Tn7AtmPrivate),GFP_KERNEL);
+  if(!priv)
+    {
+      printk("unable to kmalloc priv structure. Killing autoprobe.\n");
+      return -ENODEV;
+    }
+  memset(priv, 0, sizeof(Tn7AtmPrivate));
+#ifdef COMMON_NSP
+  priv->name = "TI Avalanche SAR";
+  priv->proc_name = "avsar";
+#else
+  priv->name = "TI tnetd73xx ATM Driver";
+  priv->proc_name = "tn7";
+#endif
+
+  if ((tn7atm_register (priv)) == ATM_REG_FAILED)
+    return -ENODEV;
+
+  tn7atm_init(mydev);
+
+  /* Set up proc entry for atm stats */
+  proc_mkdir("tiatm", NULL);
+  create_proc_read_entry("tiatm/avsar_modem_stats",0,NULL,tn7dsl_proc_stats,NULL);
+  create_proc_read_entry("tiatm/avsar_modem_training",0,NULL,tn7dsl_proc_modem,NULL);
+  create_proc_read_entry("tiatm/avsar_ver",0,NULL,tn7atm_proc_version,NULL);
+  create_proc_read_entry("tiatm/avsar_channels",0,NULL,tn7atm_proc_channels,mydev);
+  create_proc_read_entry("tiatm/avsar_private",0,NULL,tn7atm_proc_private,mydev);
+  create_proc_read_entry("tiatm/avsar_sarhal_stats",0,NULL,tn7sar_proc_sar_stat,mydev);
+  create_proc_read_entry("tiatm/avsar_oam_ping",0,NULL,tn7sar_proc_oam_ping,mydev);
+  create_proc_read_entry("tiatm/avsar_pvc_table",0,NULL,tn7sar_proc_pvc_table,mydev);
+
+  tn7dsl_dslmod_sysctl_register();
+
+  printk("Texas Instruments ATM driver: version:[%d.%02d.%02d.%02d]\n",LINUXATM_VERSION_MAJOR, LINUXATM_VERSION_MINOR,
+                                                                   LINUXATM_VERSION_BUGFIX, LINUXATM_VERSION_BUILDNUM);
+  return 0;
+}
+
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_probe(void)
+ *
+ *  Description: Avalanche SAR driver probe (see net/atm/pvc.c)
+ *               this is utilized when the SAR driver is built
+ *               into the kernel and needs to be configured.
+ *
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+int __init tn7atm_probe(void)
+{
+  tn7atm_detect();
+  return -ENODEV;
+}
+
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int tn7atm_init(struct atm_dev *dev)
+ *
+ *  Description: Device Initialization
+ *
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+static int __init
+tn7atm_init(struct atm_dev *dev)
+{
+  Tn7AtmPrivate *priv;
+  char *ptr;
+
+  dprintf(4, "tn7atm_init()\n");
+
+  priv = (Tn7AtmPrivate *)dev->dev_data;
+
+  if(tn7sar_init(dev, priv) != 0)
+  {
+    printk("Failed to init SAR.\n");
+    return -ENODEV;
+  }
+
+  if(tn7dsl_init(priv) < 0)
+  {
+    printk("Failed to init DSL.\n");
+    return -ENODEV;
+  }
+  
+  if(tn7atm_get_ESI(dev) < 0)                 /* set ESI */  
+    return -ENODEV;
+
+  if(tn7atm_irq_request(dev) < 0)     
+    return -EBUSY;
+
+  priv->bTurboDsl = 1;
+  // read config for turbo dsl
+  ptr = prom_getenv("TurboDSL");
+  if(ptr)
+  {
+    priv->bTurboDsl = os_atoi(ptr);
+  }
+
+  return 0;
+}
+
+int tn7atm_device_connect_status(void *priv, int state)
+{
+  Tn7AtmPrivate *priv1;
+
+  dprintf(5, "tn7atm_device_connect_status()\n");
+  priv1 = (Tn7AtmPrivate *)priv;
+
+  priv1->lConnected = state;
+  dprintf(5, "priv1->lConnected=%d\n", priv1->lConnected);
+  return 0;
+}
+
+
+#ifdef MODULE
+module_init (tn7atm_detect);
+module_exit (tn7atm_exit);
+#endif /* MODULE */
diff -urN linux.old/drivers/atm/sangam_atm/tn7atm.h linux.dev/drivers/atm/sangam_atm/tn7atm.h
--- linux.old/drivers/atm/sangam_atm/tn7atm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/tn7atm.h	2005-08-23 04:46:50.107842176 +0200
@@ -0,0 +1,115 @@
+/* 
+ *    Tnetd73xx ATM driver.
+ *    by Zhicheng Tang, ztang@ti.com
+ *    2000 (c) Texas Instruments Inc.
+ *
+ *
+*/
+
+#ifndef __TN7ATM_H
+#define __TN7ATM_H
+
+//#include  "mips_support.h"
+#include  <linux/list.h>
+
+#define ATM_REG_OK 1
+#define ATM_REG_FAILED 0
+
+#define TX_SERVICE_MAX    32
+#define RX_SERVICE_MAX    20
+#define TX_BUFFER_NUM     64
+#define RX_BUFFER_NUM     28
+#define TX_QUEUE_NUM      2
+#define RX_BUFFER_SIZE    1582
+
+#define TX_DMA_CHAN       16    /* number of tx dma channels available */
+#define MAX_DMA_CHAN      16
+#define ATM_NO_DMA_CHAN   MAX_DMA_CHAN + 1  /* no tx dma channels available */
+#define ATM_SAR_INT       15
+#define ATM_SAR_INT_PACING_BLOCK_NUM 2
+#define ATM_DSL_INT       39
+
+#define CONFIG_ATM_TN7ATM_DEBUG 0 /* Debug level (0=no mtn7s 5=verbose) */
+
+#define TN7ATM_DEV(d)          ((struct tn7atm*)((d)->dev_data))
+
+
+/* Avalanche SAR state information */
+
+typedef enum tn7atm_state 
+{
+  TN7ATM_STATE_REGISTER             /* device registered */
+}tn7atm_state;
+
+typedef struct _sar_stat
+{
+  unsigned int txErrors;
+  unsigned int rxErrors;
+  unsigned int rxPktCnt;
+  unsigned int txPktCnt;
+  unsigned int rxBytes;
+  unsigned int txBytes;
+}sar_stat_t;
+
+/* Host based look up table to xref Channel Id's, VPI/VCI, LC, CID, packet type */
+typedef struct _tn7atm_tx_lut
+{
+  int         inuse;       /* is DMA channel available (1=y)  */
+  int         chanid;      /*  DMA channel ID   (0-0x1f) This corresponds to the Channel ID
+                              that is used in the connection config reg (TN7ATM_CONN_CONFIG) */
+  int         vpi;         /* Virtual path identifier         */
+  int         vci;         /* Virtual channel identifier      */
+  void        *vcc;
+  int         bClosing;
+  int         ready;
+  void        *net_device;
+  int         tx_total_bufs;
+  int         tx_used_bufs[2];
+  int         netqueue_stop;
+}tn7atm_lut_t;              
+
+/* per device data */
+
+typedef struct _tn7atm_private
+{
+  struct _tn7atm_private       *next;               /* next device */
+  struct atm_dev              *dev;                /* ATM device */
+  struct net_device_stats     stats;         /* Used to report Tx/Rx frames from ifconfig */
+  tn7atm_lut_t                 lut[MAX_DMA_CHAN];  /* Tx DMA look up table (LUT) */
+  int                         dsl_irq;            /* ATM SAR TransmitA interrupt number */
+  int                         sar_irq;            /* ATM SAR ReceiveA interrupt number */
+  char*                       name;                /* device name */
+  char*                       proc_name;           /* board name under /proc/atm */
+  unsigned int                available_cell_rate; /* cell rate */
+  unsigned int                connection_cell_rate; /* cell rate */
+  int                         lConnected;
+
+  /* Tnetd73xx CPHAL */
+  void                        *pSarHalDev;
+  void                        *pSarHalFunc;
+  void                        *pSarOsFunc;
+  void                        *halIsr;
+  int                         int_num;
+
+  /* turbo dsl */
+  int                          bTurboDsl;
+
+  /* spin lock for netifqueue */
+  spinlock_t                   netifqueueLock;
+  int                          netifqueueLockFlag;
+  int                          xmitStop; /* temp fix for SAR problem */
+}tn7atm_private_t, Tn7AtmPrivate;
+
+
+
+/* ATM adaptation layer id */
+typedef enum tn7atm_aal {
+    TN7ATM_AAL0  = 0,
+    TN7ATM_AAL2  = 2,
+    TN7ATM_AAL5  = 5,
+} tn7atm_aal_t;
+
+
+
+
+#endif
diff -urN linux.old/drivers/atm/sangam_atm/tn7dsl.c linux.dev/drivers/atm/sangam_atm/tn7dsl.c
--- linux.old/drivers/atm/sangam_atm/tn7dsl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/tn7dsl.c	2005-08-23 04:46:50.109841872 +0200
@@ -0,0 +1,1780 @@
+/* 
+ *  $Id$
+ *
+ *   Avalanche SAR driver
+ *
+ *   Zhicheng Tang, ztang@ti.com
+ *   2000 (c) Texas Instruments Inc.
+ *
+ *
+*/
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/atmdev.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <asm/io.h>
+#include <asm/mips-boards/prom.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/sysctl.h>
+#include <linux/timer.h>
+#include <linux/vmalloc.h>
+#include <linux/file.h>
+#include <asm/uaccess.h>
+
+#include "tn7atm.h"
+#include "tn7api.h"
+#include "dsl_hal_api.h"
+
+#ifdef CONFIG_LED_MODULE
+#include <asm/ar7/ledapp.h>
+#define MOD_ADSL 1
+#define DEF_ADSL_IDLE     1
+#define DEF_ADSL_TRAINING 2
+#define DEF_ADSL_SYNC     3
+#define DEF_ADSL_ACTIVITY 4
+
+#define LED_NUM_1 3
+#define LED_NUM_2 4
+
+led_reg_t ledreg[2];
+
+static int led_on;
+#endif
+
+extern int  __guDbgLevel;
+extern sar_stat_t sarStat;
+static int dslInSync = 0;
+static int bMarginThConfig;
+static int bMarginRetrainEnable;
+static char EOCVendorID[8]= {0xb5, 0x00, 0x54, 0x53, 0x54, 0x43, 0x00, 0x00};
+
+#define TC_SYNC          1
+#define SYNC_TIME_DELAY  500000
+
+
+#define DEV_DSLMOD       1
+#define MAX_STR_SIZE     256
+#define DSL_MOD_SIZE     256
+
+#define TRUE   1
+#define FALSE  0
+
+
+enum
+{
+  NO_MODE,
+  MULTI_MODE,
+  T1413_MODE,
+  GDMT_MODE,
+  GLITE_MODE
+};
+
+
+
+/* a structure to store all information we need
+   for our thread */
+typedef struct kthread_struct
+{
+  /* private data */
+
+  /* Linux task structure of thread */
+  struct task_struct *thread;
+  /* Task queue need to launch thread */
+  struct tq_struct tq;
+  /* function to be started as thread */
+  void (*function) (struct kthread_struct *kthread);
+  /* semaphore needed on start and creation of thread. */
+  struct semaphore startstop_sem;
+
+  /* public data */
+
+  /* queue thread is waiting on. Gets initialized by
+  init_kthread, can be used by thread itself.
+  */
+  wait_queue_head_t queue;
+  /* flag to tell thread whether to die or not.
+    When the thread receives a signal, it must check
+    the value of terminate and call exit_kthread and terminate
+    if set.
+  */
+  int terminate;
+  /* additional data to pass to kernel thread */
+  void *arg;
+} kthread_t;
+
+#ifndef ADIAG
+#define DSP_FIRMWARE_PATH "/lib/modules/ar0700xx.bin"
+#else
+#define DSP_FIRMWARE_PATH "/var/tmp/ar0700xx_diag.bin"
+#endif
+
+/* externs */
+extern struct atm_dev *mydev;
+extern unsigned int oamFarLBCount[4];
+extern int dslhal_support_restoreTrainingInfo(PITIDSLHW_T pIhw);
+/* gloabal functions */
+
+/* end of global functions */
+
+/* module wide declars */
+static PITIDSLHW_T    pIhw;
+static char    mod_req[16]={'\t'};
+static volatile int bshutdown; 
+static char info[MAX_STR_SIZE];
+static DECLARE_MUTEX_LOCKED(adsl_sem_overlay); /* Used for DSL Polling enable     */
+kthread_t overlay_thread;
+/* end of module wide declars */
+
+/* Internal Functions */
+static void tn7dsl_chng_modulation(void* data);
+static void tn7dsl_set_modulation(void* data);
+static int tn7dsl_reload_overlay(void);
+static int dslmod_sysctl(ctl_table *ctl, int write, struct file * filp, void *buffer, size_t *lenp);
+static void tn7dsl_register_dslss_led(void);
+void tn7dsl_dslmod_sysctl_register(void);
+void tn7dsl_dslmod_sysctl_unregister(void);
+/* end of internal functions */
+
+
+
+
+
+/* prototypes */
+
+/* start new kthread (called by creator) */
+void start_kthread(void (*func)(kthread_t *), kthread_t *kthread);
+
+/* stop a running thread (called by "killer") */
+void stop_kthread(kthread_t *kthread);
+
+/* setup thread environment (called by new thread) */
+void init_kthread(kthread_t *kthread, char *name);
+
+/* cleanup thread environment (called by thread upon receiving termination signal) */
+void exit_kthread(kthread_t *kthread);
+
+
+
+/* private functions */
+static void kthread_launcher(void *data)
+{
+        kthread_t *kthread = data;
+        kernel_thread((int (*)(void *))kthread->function, (void *)kthread, 0);
+        
+}
+
+/* public functions */
+
+/* create a new kernel thread. Called by the creator. */
+void start_kthread(void (*func)(kthread_t *), kthread_t *kthread)
+{
+        /* initialize the semaphore:
+           we start with the semaphore locked. The new kernel
+           thread will setup its stuff and unlock it. This
+           control flow (the one that creates the thread) blocks
+           in the down operation below until the thread has reached
+           the up() operation.
+         */
+        //init_MUTEX_LOCKED(&kthread->startstop_sem);
+
+        /* store the function to be executed in the data passed to
+           the launcher */
+        kthread->function=func;
+        
+        /* create the new thread my running a task through keventd */
+
+        /* initialize the task queue structure */
+        kthread->tq.sync = 0;
+        INIT_LIST_HEAD(&kthread->tq.list);
+        kthread->tq.routine =  kthread_launcher;
+        kthread->tq.data = kthread;
+
+        /* and schedule it for execution */
+        schedule_task(&kthread->tq);
+
+        /* wait till it has reached the setup_thread routine */
+        //down(&kthread->startstop_sem);
+               
+}
+
+/* stop a kernel thread. Called by the removing instance */
+void stop_kthread(kthread_t *kthread)
+{
+        if (kthread->thread == NULL)
+        {
+                printk("stop_kthread: killing non existing thread!\n");
+                return;
+        }
+
+        /* this function needs to be protected with the big
+       kernel lock (lock_kernel()). The lock must be
+           grabbed before changing the terminate
+       flag and released after the down() call. */
+        lock_kernel();
+        
+        /* initialize the semaphore. We lock it here, the
+           leave_thread call of the thread to be terminated
+           will unlock it. As soon as we see the semaphore
+           unlocked, we know that the thread has exited.
+    */
+        //init_MUTEX_LOCKED(&kthread->startstop_sem);
+
+        /* We need to do a memory barrier here to be sure that
+           the flags are visible on all CPUs. 
+        */
+        mb();
+
+        /* set flag to request thread termination */
+        kthread->terminate = 1;
+
+        /* We need to do a memory barrier here to be sure that
+           the flags are visible on all CPUs. 
+        */
+        mb();
+        kill_proc(kthread->thread->pid, SIGKILL, 1);
+       
+        /* block till thread terminated */
+        //down(&kthread->startstop_sem);
+
+        /* release the big kernel lock */
+        unlock_kernel();
+
+        /* now we are sure the thread is in zombie state. We
+           notify keventd to clean the process up.
+        */
+        kill_proc(2, SIGCHLD, 1);
+
+}
+
+/* initialize new created thread. Called by the new thread. */
+void init_kthread(kthread_t *kthread, char *name)
+{
+        /* lock the kernel. A new kernel thread starts without
+           the big kernel lock, regardless of the lock state
+           of the creator (the lock level is *not* inheritated)
+        */
+        lock_kernel();
+
+        /* fill in thread structure */
+        kthread->thread = current;
+
+        /* set signal mask to what we want to respond */
+        siginitsetinv(&current->blocked, sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM));
+
+        /* initialise wait queue */
+        init_waitqueue_head(&kthread->queue);
+
+        /* initialise termination flag */
+        kthread->terminate = 0;
+
+        /* set name of this process (max 15 chars + 0 !) */
+        sprintf(current->comm, name);
+        
+        /* let others run */
+        unlock_kernel();
+
+        /* tell the creator that we are ready and let him continue */
+        //up(&kthread->startstop_sem);
+
+}
+
+/* cleanup of thread. Called by the exiting thread. */
+void exit_kthread(kthread_t *kthread)
+{
+        /* we are terminating */
+
+    /* lock the kernel, the exit will unlock it */
+        lock_kernel();
+        kthread->thread = NULL;
+        mb();
+
+        /* notify the stop_kthread() routine that we are terminating. */
+    //up(&kthread->startstop_sem);
+    /* the kernel_thread that called clone() does a do_exit here. */
+
+    /* there is no race here between execution of the "killer" and real termination
+       of the thread (race window between up and do_exit), since both the
+       thread and the "killer" function are running with the kernel lock held.
+       The kernel lock will be freed after the thread exited, so the code
+       is really not executed anymore as soon as the unload functions gets
+       the kernel lock back.
+       The init process may not have made the cleanup of the process here,
+       but the cleanup can be done safely with the module unloaded.
+    */
+
+}
+
+
+
+int os_atoi(const char *pStr)
+{
+  int retVal = -1;
+
+  if(*pStr=='-')
+    retVal =  -simple_strtoul(pStr+1, (char **)NULL, 10);
+  else
+    retVal =  simple_strtoul(pStr, (char **)NULL, 10);  
+  return retVal ;
+}
+
+
+int os_atoh(const char *pStr)
+{
+  int retVal = -1;
+
+  if(*pStr=='-')
+    retVal =  -simple_strtoul(pStr+1, (char **)NULL, 16);
+  else
+    retVal =  simple_strtoul(pStr, (char **)NULL, 16);  
+  return retVal ;
+}
+
+unsigned long os_atoul(const char *pStr)
+{
+  unsigned long retVal = -1;
+
+  retVal =  simple_strtoul(pStr, (char **)NULL, 10);  
+  return retVal ;
+}
+
+void dprintf( int uDbgLevel, char * szFmt, ...)
+{
+#ifdef DEBUG_BUILD
+    static char     buff[256];
+    va_list  ap; 
+
+    if( __guDbgLevel < uDbgLevel) 
+        return;
+
+    va_start( ap, szFmt); 
+    vsprintf((char *)buff, szFmt, ap); 
+    va_end(ap); 
+    printk("%s", buff);
+#endif
+}
+
+/*int strcmp(const char *s1, const char *s2)
+{
+
+  int i=0;
+  
+  while(s1[i] !=0)
+  {
+    if(s2[i]==0)
+      return -1;
+    if(s1[i] != s2[i])
+      return 1;
+    i++;
+  }
+  if(s2[i] != 0)
+    return 1;
+  return 0;
+}
+*/
+
+int shim_osLoadFWImage(unsigned char *ptr)
+{
+  unsigned int bytesRead;
+  mm_segment_t  oldfs;  
+  static struct file *filp;
+  unsigned int imageLength=0x4ffff;  
+   
+    
+  dprintf(4, "tn7dsl_read_dsp()\n");
+
+  dprintf(4,"open file %s\n", DSP_FIRMWARE_PATH);
+  
+  filp=filp_open(DSP_FIRMWARE_PATH
+                                  ,00,O_RDONLY);
+      
+  if(filp ==NULL)
+  {
+    printk("Failed: Could not open DSP binary file\n");
+          return -1;
+  }
+      
+  if (filp->f_op->read==NULL)
+          return -1;  /* File(system) doesn't allow reads */
+
+        /* Now read bytes from postion "StartPos" */
+        filp->f_pos = 0;
+  oldfs = get_fs();
+        set_fs(KERNEL_DS);
+        bytesRead = filp->f_op->read(filp,ptr,imageLength,&filp->f_pos);
+
+  dprintf(4,"file length = %d\n", bytesRead);
+
+  set_fs(oldfs);
+
+        /* Close the file */
+        fput(filp); 
+    
+  return bytesRead;
+}
+
+unsigned int shim_read_overlay_page(void *ptr, unsigned int secOffset, unsigned int secLength)
+{
+  unsigned int bytesRead;
+  mm_segment_t  oldfs;  
+  struct file *filp;
+  
+  dprintf(4,"shim_read_overlay_page\n");
+  //dprintf(4,"sec offset=%d, sec length =%d\n", secOffset, secLength);
+  
+  filp=filp_open(DSP_FIRMWARE_PATH,00,O_RDONLY);  
+  if(filp ==NULL)
+  {
+    printk("Failed: Could not open DSP binary file\n");
+          return -1;
+  }
+      
+  if (filp->f_op->read==NULL)
+          return -1;  /* File(system) doesn't allow reads */
+
+  /* Now read bytes from postion "StartPos" */
+
+  if(filp->f_op->llseek)
+    filp->f_op->llseek(filp,secOffset, 0);
+  oldfs = get_fs();
+  set_fs(KERNEL_DS);
+  filp->f_pos = secOffset;
+  bytesRead = filp->f_op->read(filp,ptr,secLength,&filp->f_pos);
+
+  set_fs(oldfs);
+   /* Close the file */
+  fput(filp);  
+  return bytesRead;
+}
+
+int shim_osLoadDebugFWImage(unsigned char *ptr)
+{
+  return 0;
+}
+int shim_osStringCmp(const char *s1, const char *s2)
+{
+  return strcmp(s1, s2);
+}
+
+void *shim_osAllocateMemory(unsigned int size)
+{
+  return ((void *)kmalloc(size, GFP_KERNEL));
+}
+
+void *shim_osAllocateDmaMemory(unsigned int size)
+{
+  /*
+  int order;
+
+  order=1;
+  size=size/4096;
+  while(size >= 1)
+  {
+    order++;
+    size=size/2;
+  }
+
+  return ( (void *)__get_free_pages(GFP_ATOMIC, order));
+  */
+  //return ((void *)kmalloc(size, GFP_ATOMIC));
+  //return ((void *)kmalloc(size, GFP_KERNEL));
+  void *ptr;
+
+  ptr = kmalloc(size, GFP_ATOMIC);
+  if(ptr==NULL)
+  {
+    printk("failed atomic\n");
+    ptr = kmalloc(size, GFP_KERNEL);
+    if(ptr==NULL)
+    {
+      printk("failed kernel\n");
+      ptr = kmalloc(size, GFP_KERNEL|GFP_DMA);
+    }
+  }
+  printk("size=%d\n", size);
+  return ptr;
+
+}
+
+
+void shim_osFreeMemory(void *ptr, unsigned int size)
+{
+  
+  kfree(ptr);
+}
+
+void shim_osFreeDmaMemory(void *ptr, unsigned int size)
+{
+/*
+  int order;
+
+  order=1;
+  size=size/4096;
+  while(size >=1)
+  {
+    order++;
+    size=size/2;
+  }
+  free_pages(ptr, order);
+*/
+  kfree(ptr);
+}
+
+void *shim_osAllocateVMemory(unsigned int size)
+{
+
+  return ((void *)vmalloc(size));
+}
+
+void shim_osFreeVMemory(void *ptr, unsigned int size)
+{
+  vfree(ptr);
+}
+
+void shim_osMoveMemory(char *dst, char *src, unsigned int numBytes)
+{
+  memcpy(dst, src, numBytes);
+}
+
+void shim_osZeroMemory(char *dst, unsigned int numBytes)
+{
+  memset(dst, 0, numBytes);
+}
+
+void shim_osWriteBackCache(void *addr, unsigned int size)
+{
+  unsigned int i,Size=(((unsigned int)addr)&0xf)+size;
+
+  for (i=0;i<Size;i+=16,addr+=16)
+  {
+    __asm__(" .set mips3 ");
+    __asm__(" cache  25, (%0)" : : "r" (addr));
+    __asm__(" .set mips0 ");
+  }
+}
+
+void shim_osInvalidateCache(void *addr, unsigned int size)
+{
+  unsigned int i,Size=(((unsigned int)addr)&0xf)+size;
+
+  for (i=0;i<Size;i+=16,addr+=16)
+  {
+    __asm__(" .set mips3 ");
+    __asm__("cache  17, (%0)" : : "r" (addr));
+    __asm__(" .set mips0 ");
+  }
+}
+
+void shim_osClockWait(int val)
+{
+  unsigned int chkvalue;
+  chkvalue=val/64;
+  
+  if(chkvalue > 1000)
+    {
+      mdelay(chkvalue/1000);
+      return;
+    }
+  else
+    udelay(val/64);
+} /* end of cwait() */
+
+unsigned int shim_osClockTick(int val)
+{
+  return jiffies;
+}
+
+int flags;
+spinlock_t shimLock;
+
+void shim_osCriticalEnter(void)
+{
+  spin_lock_irqsave(&shimLock, flags);
+
+}
+
+
+void shim_osCriticalExit(void)
+{
+  spin_unlock_irqrestore(&shimLock, flags);
+}
+
+
+int tn7dsl_proc_stats(char* buf, char **start, off_t offset, int count,
+                 int *eof, void *data)
+{
+  
+  int len = 0;
+  int limit = count - 80;
+  int F4count, F5count;
+  
+  
+  /* Read Ax5 Stats */
+  dslhal_api_gatherStatistics(pIhw);
+  
+  if(len<=limit)
+    len += sprintf(buf+len, "\nAR7 DSL Modem Statistics:\n");
+  if(len<=limit)
+    len += sprintf(buf+len, "--------------------------------\n");
+  /* us and ds Connection Rates */
+  if(len<=limit)
+    len += sprintf(buf+len, "[DSL Modem Stats]\n");
+
+
+  if(len<=limit)
+  {
+    if(pIhw->lConnected != 1)
+    {
+      pIhw->AppData.USConRate = 0;
+      pIhw->AppData.DSConRate = 0;
+    }
+    len += sprintf(buf+len, "\tUS Connection Rate:\t%u\tDS Connection Rate:\t%u\n",
+                   (unsigned int)pIhw->AppData.USConRate,
+                   (unsigned int)pIhw->AppData.DSConRate );
+  }
+  if(len<=limit)
+    len += sprintf(buf+len, "\tDS Line Attenuation:\t%u\tDS Margin:\t\t%u\n",
+                   (unsigned int)pIhw->AppData.dsLineAttn/2,
+                   (unsigned int)pIhw->AppData.dsMargin/2 );
+  if(len<=limit)
+    len += sprintf(buf+len, "\tUS Line Attenuation:\t%u\tUS Margin:\t\t%u\n",
+                   (unsigned int)pIhw->AppData.usLineAttn,
+                   (unsigned int)pIhw->AppData.usMargin );
+  if(len<=limit)
+    len += sprintf(buf+len, "\tUS Payload :\t\t%u\tDS Payload:\t\t%u\n",
+                   ((unsigned int)pIhw->AppData.usAtm_count[0] + (unsigned int)pIhw->AppData.usAtm_count[1])*48,
+                   ((unsigned int)pIhw->AppData.dsGood_count[0] + (unsigned int)pIhw->AppData.dsGood_count[1])*48);
+  /* Superframe Count */
+  if(len<=limit)
+    len += sprintf(buf+len, "\tUS Superframe Cnt :\t%u\tDS Superframe Cnt:\t%u\n",
+                   (unsigned int)pIhw->AppData.usSuperFrmCnt,
+                   (unsigned int)pIhw->AppData.dsSuperFrmCnt );
+
+  /* US and DS power */
+  if(len<=limit)
+    len += sprintf(buf+len, "\tUS Transmit Power :\t%u\tDS Transmit Power:\t%u\n",
+                   (unsigned int)pIhw->AppData.usTxPower/256,
+                   (unsigned int)pIhw->AppData.dsTxPower/256 );
+  /* DSL Stats Errors*/  
+  if(len<=limit)
+    len += sprintf(buf+len, "\tLOS errors:\t\t%u\tSEF errors:\t\t%u\n",
+                   (unsigned int)pIhw->AppData.LOS_errors,
+                   (unsigned int)pIhw->AppData.SEF_errors );
+  if(len<=limit)
+    len += sprintf(buf+len, "\tFrame mode:\t\t%u\tMax Frame mode:\t\t%u\n",
+                   (unsigned int)pIhw->AppData.FrmMode,
+                   (unsigned int)pIhw->AppData.MaxFrmMode );
+  if(len<=limit)
+    len += sprintf(buf+len, "\tTrained Path:\t\t%u\tUS Peak Cell Rate:\t%u\n",
+                   (unsigned int)pIhw->AppData.TrainedPath,
+                   (unsigned int)pIhw->AppData.USConRate*1000/8/53 );
+  if(len<=limit)
+    len += sprintf(buf+len, "\tTrained Mode:\t\t%u\tSelected Mode:\t\t%u\n",
+                   (unsigned int)pIhw->AppData.TrainedMode, (unsigned int)pIhw->AppData.StdMode );
+
+  if(len<=limit)
+    len += sprintf(buf+len, "\tATUC Vendor ID:\t%u\tATUC Revision:\t\t%u\n",
+                   (unsigned int)pIhw->AppData.atucVendorId, pIhw->AppData.atucRevisionNum);
+  if(len<=limit)
+    len += sprintf(buf+len, "\tHybrid Selected:\t%u\n",
+                   (unsigned int)pIhw->AppData.currentHybridNum);
+ 
+  /* Upstream Interleaved Errors */
+  if(len<=limit)
+    len += sprintf(buf+len, "\n\t[Upstream (TX) Interleave path]\n");
+  if(len<=limit)
+    len += sprintf(buf+len, "\tCRC: \t%u\tFEC: \t%u\tNCD: \t%u\n",
+                   (unsigned int)pIhw->AppData.usICRC_errors,
+                   (unsigned int)pIhw->AppData.usIFEC_errors,
+                   (unsigned int)pIhw->AppData.usINCD_error);
+  if(len<=limit)
+    len += sprintf(buf+len, "\tLCD: \t%u\tHEC: \t%u\n",
+                   (unsigned int)pIhw->AppData.usILCD_errors,
+                   (unsigned int)pIhw->AppData.usIHEC_errors);
+  /* Downstream Interleaved Errors */
+  if(len<=limit)
+    len += sprintf(buf+len, "\n\t[Downstream (RX) Interleave path]\n");
+  if(len<=limit)
+    len += sprintf(buf+len, "\tCRC: \t%u\tFEC: \t%u\tNCD: \t%u\n",
+                   (unsigned int)pIhw->AppData.dsICRC_errors,
+                   (unsigned int)pIhw->AppData.dsIFEC_errors,
+                   (unsigned int)pIhw->AppData.dsINCD_error);
+  if(len<=limit)
+    len += sprintf(buf+len, "\tLCD: \t%u\tHEC: \t%u\n",
+                   (unsigned int)pIhw->AppData.dsILCD_errors,
+                   (unsigned int)pIhw->AppData.dsIHEC_errors);
+  /* Upstream Fast Errors */
+  if(len<=limit)
+    len += sprintf(buf+len, "\n\t[Upstream (TX) Fast path]\n");
+  if(len<=limit)
+    len += sprintf(buf+len, "\tCRC: \t%u\tFEC: \t%u\tNCD: \t%u\n",
+                   (unsigned int)pIhw->AppData.usFCRC_errors,
+                   (unsigned int)pIhw->AppData.usFFEC_errors,
+                   (unsigned int)pIhw->AppData.usFNCD_error);
+  if(len<=limit)
+    len += sprintf(buf+len, "\tLCD: \t%u\tHEC: \t%u\n",
+                   (unsigned int)pIhw->AppData.usFLCD_errors,
+                   (unsigned int)pIhw->AppData.usFHEC_errors);
+  /* Downstream Fast Errors */
+  if(len<=limit)
+    len += sprintf(buf+len, "\n\t[Downstream (RX) Fast path]\n");
+  if(len<=limit)
+    len += sprintf(buf+len, "\tCRC: \t%u\tFEC: \t%u\tNCD: \t%u\n",
+                   (unsigned int)pIhw->AppData.dsFCRC_errors,
+                   (unsigned int)pIhw->AppData.dsFFEC_errors,
+                   (unsigned int)pIhw->AppData.dsFNCD_error);
+  if(len<=limit)
+    len += sprintf(buf+len, "\tLCD: \t%u\tHEC: \t%u\n",
+                   (unsigned int)pIhw->AppData.dsFLCD_errors,
+                   (unsigned int)pIhw->AppData.dsFHEC_errors);
+  /* ATM stats upstream */
+  if(len<=limit)
+    len += sprintf(buf+len, "\n[ATM Stats]");
+  if(len<=limit)
+    len += sprintf(buf+len, "\n\t[Upstream/TX]\n");
+  if(len<=limit)
+    len += sprintf(buf+len, "\tGood Cell Cnt:\t%u\n\tIdle Cell Cnt:\t%u\n\n",
+                   (unsigned int)pIhw->AppData.usAtm_count[0] + (unsigned int)pIhw->AppData.usAtm_count[1],
+                   (unsigned int)pIhw->AppData.usIdle_count[0] + (unsigned int)pIhw->AppData.usIdle_count[1]);
+  /* ATM stats downstream */
+  if(len<=limit)
+    len += sprintf(buf+len, "\n\t[Downstream/RX)]\n");
+  if(len<=limit)
+    len += sprintf(buf+len, "\tGood Cell Cnt:\t%u\n\tIdle Cell Cnt:\t%u\n\tBad Hec Cell Cnt:\t%u\n",
+                   (unsigned int)pIhw->AppData.dsGood_count[0] + (unsigned int)pIhw->AppData.dsGood_count[1],
+                   (unsigned int)pIhw->AppData.dsIdle_count[0] + (unsigned int)pIhw->AppData.dsIdle_count[1],
+                   (unsigned int)pIhw->AppData.dsBadHec_count[0] + (unsigned int)pIhw->AppData.dsBadHec_count[1]);
+  if(len<=limit)
+    len += sprintf(buf+len, "\tOverflow Dropped Cell Cnt:\t%u\n",
+                   (unsigned int)pIhw->AppData.dsOVFDrop_count[0] + (unsigned int)pIhw->AppData.dsOVFDrop_count[1]);
+  tn7sar_get_stats(pIhw->pOsContext);
+  if(len<=limit)
+    len += sprintf(buf+len, "\n[SAR AAL5 Stats]\n");
+  if(len<=limit)
+    len += sprintf(buf+len, "\tTx PDU's:\t%u\n\tRx PDU's:\t%u\n",
+                   sarStat.txPktCnt,
+                   sarStat.rxPktCnt);
+  if(len<=limit)
+    len += sprintf(buf+len, "\tTx Total Bytes:\t%u\n\tRx Total Bytes:\t%u\n",
+                   sarStat.txBytes,
+                   sarStat.rxBytes);
+  if(len<=limit)
+    len += sprintf(buf+len, "\tTx Total Error Counts:\t%u\n\tRx Total Error Counts:\t%u\n\n",
+                   sarStat.txErrors,
+                   sarStat.rxErrors);
+
+  /* oam loopback info */
+  if(len<=limit)
+    len += sprintf(buf+len, "\n[OAM Stats]\n");
+
+  tn7sar_get_near_end_loopback_count(&F4count, &F5count);
+
+  if(len<=limit)
+    {
+    len += sprintf(buf+len, "\tNear End F5 Loop Back Count:\t%u\n\tNear End F4 Loop Back Count:\t%u\n\tFar End F5 Loop Back Count:\t%u\n\tFar End F4 Loop Back Count:\t%u\n",
+                  F5count,
+                  F4count,
+                  oamFarLBCount[0] + oamFarLBCount[2],
+                  oamFarLBCount[1] + oamFarLBCount[3]);
+    }
+  return len;
+}
+
+int
+tn7dsl_proc_modem(char* buf, char **start, off_t offset, int count,
+                 int *eof, void *data)
+{
+  
+  int len = 0;
+  int limit = count - 80;
+
+  char *state;
+  int tag;
+   
+  tag= dslhal_api_pollTrainingStatus(pIhw);
+  tag = pIhw->AppData.bState;
+  
+  switch(tag){
+    case 0:       state = "ACTREQ";     break;
+    case 1:       state = "QUIET1";     break;
+    case 2:       state = "IDLE";       break;
+    case 3:       state = "INIT";       break;
+    case 4:       state = "RTDL";       break;
+    case 5:       state = "SHOWTIME";   break;
+    default:      state = "unknown";    break;
+  }
+  
+  if(pIhw->lConnected == 1)
+    state = "SHOWTIME";
+  if(len<=limit)
+    len += sprintf(buf+len,"%s\n",state);
+  
+  return len;
+}
+
+
+
+int tn7dsl_handle_interrupt(void)
+{
+  int intsrc;
+  unsigned char cMsgRa[6];
+  short margin;
+
+  dprintf(4, "tn7dsl_handle_dsl_interrupt()\n");
+  if(pIhw)
+  {
+    intsrc=dslhal_api_acknowledgeInterrupt(pIhw);
+    dslhal_api_handleTrainingInterrupt(pIhw, intsrc);
+
+    if(pIhw->lConnected == TC_SYNC)
+    {
+      
+      if(dslInSync == 0)
+      {
+        printk("DSL in Sync\n");
+        tn7atm_device_connect_status(pIhw->pOsContext, 1);
+        dslhal_api_initStatistics(pIhw);
+        dslhal_api_gatherStatistics(pIhw);
+#ifdef CONFIG_LED_MODULE
+//        led_operation(MOD_ADSL, DEF_ADSL_SYNC);           
+        led_on = DEF_ADSL_SYNC;
+#endif
+        /* add auto margin retrain */
+        if(pIhw->AppData.TrainedMode < 5)
+        {
+          if(bMarginRetrainEnable && bMarginThConfig == 0)
+          {
+            dslhal_support_getCMsgsRa(pIhw, cMsgRa);
+            margin = *(unsigned short *)&cMsgRa[4];
+            margin = (margin >> 6) & 0x3f;
+            if(margin & 0x20) // highest bit is 1
+            {
+              margin = -(margin & 0x1f);
+            }
+          
+            //printk("margin = %d, cmsg-ra = %02x %02x %02x %02x %02x %02x\n", margin, cMsgRa[0],cMsgRa[1],cMsgRa[2],cMsgRa[3],cMsgRa[4],cMsgRa[5]);
+            dslhal_api_setMarginThreshold(pIhw, margin*2); /* DSL margin is in 0.5db */
+          }
+        }
+
+      }
+      dslInSync = 1;
+    }
+    else
+    {
+      if(dslInSync == 1)
+      {
+        dslInSync = 0;
+        tn7atm_device_connect_status(pIhw->pOsContext, 0);
+        up(&adsl_sem_overlay);
+        printk("DSL out of syn\n");
+      }
+#ifdef CONFIG_LED_MODULE
+      if(pIhw->AppData.bState < RSTATE_INIT)
+      {
+        if(led_on != DEF_ADSL_IDLE)
+        {
+//          led_operation(MOD_ADSL, DEF_ADSL_IDLE);           
+          led_on = DEF_ADSL_IDLE;
+        }
+      }
+      else
+      {
+        if(led_on != DEF_ADSL_TRAINING)
+        {
+//          led_operation(MOD_ADSL, DEF_ADSL_TRAINING);           
+          led_on = DEF_ADSL_TRAINING;
+        }
+
+      }
+      
+#endif
+
+    }
+  }
+  return 0;
+}
+
+
+int tn7dsl_get_dslhal_version(char *pVer)
+{
+  dslVer ver;
+
+  dslhal_api_getDslHalVersion(&ver);
+
+  memcpy(pVer,&ver,8);
+  return 0;
+}
+
+int tn7dsl_get_dsp_version(char *pVer)
+{
+  dspVer ver;
+  dslhal_api_getDspVersion(pIhw, &ver);
+  memcpy(pVer, &ver, 9);
+  return 0;
+}
+
+
+static int
+tn7dsl_get_modulation(void)
+{
+  char  *ptr = NULL;
+  
+  dprintf(4, "tn7dsl_get_modulation\n");
+  //printk("tn7dsl_get_modulation\n");
+  ptr = prom_getenv("modulation");
+
+  if (!ptr) {
+    //printk("modulation is not set in adam2 env\n");
+    //printk("Using multimode\n");
+    return 0;
+  }
+  printk("dsl modulation = %s\n", ptr);
+
+  tn7dsl_set_modulation(ptr);
+
+  return 0;
+}
+
+
+static int tn7dsl_set_dsl(void)
+{
+
+  char  *ptr = NULL;
+  int value;
+  int i, offset[2]={4,11},oamFeature=0;
+  char tmp[4];
+  char dspVer[10];
+ 
+  // OAM Feature Configuration
+  dslhal_api_dspInterfaceRead(pIhw,(unsigned int)pIhw->pmainAddr, 2, (unsigned int *)&offset, (unsigned char *)&oamFeature, 4);
+  oamFeature |= dslhal_support_byteSwap32(0x0000000C);
+  dslhal_api_dspInterfaceWrite(pIhw,(unsigned int)pIhw->pmainAddr, 2, (unsigned int *)&offset, (unsigned char *)&oamFeature, 4);
+
+  // modulation 
+  ptr = prom_getenv("modulation");
+  if (ptr) 
+  {
+    printk("dsl modulation = %s\n", ptr);
+    tn7dsl_set_modulation(ptr);  
+  }
+
+  // margin retrain
+  ptr = NULL;
+  ptr = prom_getenv("enable_margin_retrain");
+  if(ptr)
+  {
+    value = os_atoi(ptr);
+    if(value == 1)
+    {
+      dslhal_api_setMarginMonitorFlags(pIhw, 0, 1);
+      bMarginRetrainEnable = 1;
+      printk("enable showtime margin monitor.\n");
+      ptr = NULL;
+      ptr = prom_getenv("margin_threshold");
+      if(ptr)
+      {
+        value = os_atoi(ptr);
+        printk("Set margin threshold to %d x 0.5 db\n",value);
+        if(value >= 0)
+        {
+          dslhal_api_setMarginThreshold(pIhw, value);
+          bMarginThConfig=1;
+        }
+      }
+    }
+  }
+
+  // rate adapt
+  ptr = NULL;
+  ptr = prom_getenv("enable_rate_adapt");
+  if(ptr)
+  {
+    dslhal_api_setRateAdaptFlag(pIhw, os_atoi(ptr));
+  }
+
+  // trellis
+  ptr = NULL;
+  ptr = prom_getenv("enable_trellis");
+  if(ptr)
+  {
+    dslhal_api_setTrellisFlag(pIhw, os_atoi(ptr));
+  }
+
+  // maximum bits per carrier
+  ptr = NULL;
+  ptr = prom_getenv("maximum_bits_per_carrier");
+  if(ptr)
+  {
+    dslhal_api_setMaxBitsPerCarrier(pIhw, os_atoi(ptr));
+  }
+
+  // maximum interleave depth
+  ptr = NULL;
+  ptr = prom_getenv("maximum_interleave_depth");
+  if(ptr)
+  {
+    dslhal_api_setMaxInterleaverDepth(pIhw, os_atoi(ptr));
+  }
+
+  // inner and outer pairs
+  ptr = NULL;
+  ptr = prom_getenv("pair_selection");
+  if(ptr)
+  {
+    dslhal_api_selectInnerOuterPair(pIhw, os_atoi(ptr));
+  }
+  
+  ptr = NULL;
+  ptr = prom_getenv("dgas_polarity");
+  if(ptr)
+  {
+    dslhal_api_configureDgaspLpr(pIhw, 1, 1);
+    dslhal_api_configureDgaspLpr(pIhw, 0, os_atoi(ptr));
+  }
+
+  ptr = NULL;
+  ptr = prom_getenv("los_alarm");
+  if(ptr)
+  {
+    dslhal_api_disableLosAlarm(pIhw, os_atoi(ptr));
+  }
+
+  ptr = NULL;
+  ptr = prom_getenv("eoc_vendor_id");
+  if(ptr)
+  {
+    for(i=0;i<8;i++)
+    {
+      tmp[0]=ptr[i*2];
+      tmp[1]=ptr[i*2+1];
+      tmp[2]=0;
+      EOCVendorID[i] = os_atoh(tmp);
+      //printk("tmp=%s--", tmp);
+      //printk("ID[%d]=0x%02x ", i, (unsigned char)EOCVendorID[i]);
+    }
+    tn7dsl_get_dsp_version(dspVer);
+    //printk("Annex =%d\n", dspVer[8]);
+    if(dspVer[8]==2) // annex b
+    {
+      //printk("EOCVendorID=%02x %02x %02x %02x %02x %02x %02x %02x\n", EOCVendorID[0], EOCVendorID[1], EOCVendorID[2], EOCVendorID[3],
+      //                                                                EOCVendorID[4], EOCVendorID[5], EOCVendorID[6], EOCVendorID[7]);
+      dslhal_api_setEocVendorId(pIhw, EOCVendorID);
+    }
+    
+  }
+  
+  return 0;
+}
+  
+
+
+  
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * 
+ *  Function: static void tn7dsl_init(void)
+ *
+ *  Description: This function initializes
+ *               Ar7 DSL interface
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+
+int tn7dsl_init(void *priv)
+{
+  
+  printk("Initializing DSL interface\n");
+  
+  
+  /* start dsl */
+  if(dslhal_api_dslStartup(&pIhw) !=0 )
+  {
+    printk("DSL start failed.\n");
+    return -1;
+  }
+ 
+  // set dsl into overlay page reload mode
+  pIhw->bAutoRetrain = 1;
+
+  // set default training properties
+  tn7dsl_set_dsl();
+
+  pIhw->pOsContext = priv;
+
+  //start_kthread(tn7dsl_reload_overlay, &overlay_thread);
+
+  /*register dslss LED with led module */
+#ifdef CONFIG_LED_MODULE
+  tn7dsl_register_dslss_led();
+#endif
+
+  
+  return 0;  /* What do we return here? */
+}
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
+ *
+ *  Function: int avsar_exit(void)
+ *
+ *  Description: Avalanche SAR exit function
+ *
+ *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+
+void tn7dsl_exit (void)
+{
+ 
+  bshutdown = 1;
+#ifdef CONFIG_LED_MODULE
+#ifdef DEREGISTER_LED
+  //down(&adsl_sem_overlay);
+  deregister_led_drv(LED_NUM_1);
+  deregister_led_drv(LED_NUM_2);
+#else
+//  led_operation(MOD_ADSL,DEF_ADSL_IDLE);
+#endif
+#endif
+  stop_kthread(&overlay_thread);
+  dslhal_api_dslShutdown(pIhw);
+
+}
+
+
+static int tn7dsl_process_oam_string(int *type, int *pvpi, int *pvci, int *pdelay)
+{
+  int i=1;
+  int j=0;
+  int vci, vpi;
+  char tmp[16];
+  int chan;
+  int tt;
+
+  while(j<8)
+  {
+    tmp[j] = mod_req[i];
+    //printk("tmp[%d]=%c, %d\n", j, tmp[j], tmp[j]); 
+    if(tmp[j] == 0x50 || tmp[j] == 0x70)
+      break;
+    j++;
+    i++;
+  }
+
+  tmp[j] = 0;
+  vpi = os_atoi(tmp);
+
+  i++;
+  j=0;
+  while(j<8)
+  {
+    tmp[j] = mod_req[i];
+    //printk("tmp[%d]=%c, %d\n", j, tmp[j], tmp[j]); 
+    if(tmp[j] == 0x43 || tmp[j] == 0x63)
+      break;
+
+    j++;
+    i++;
+  }
+
+  vci = os_atoi(tmp);
+
+  if(vci==0) // f4 oam
+    *type = 1;
+  else
+    *type = 0;
+
+
+  tt=5000;
+  i++;
+  j=0;
+  tmp[j] = mod_req[i];
+  if(tmp[j]==0x44 || tmp[j]==0x64)
+  {
+    i++;
+    while(j<8)
+    {
+      tmp[j] = mod_req[i];
+
+      //printk("tmp[%d]=%c, %d\n", j, tmp[j], tmp[j]); 
+      if(tmp[j] == 0x54 || tmp[j] == 0x74)
+        break;
+
+      j++;
+      i++;
+    }
+    tt = os_atoi(tmp);
+  }
+
+  chan = tn7atm_lut_find(vpi, vci);
+  
+  *pvci=vci;
+  *pvpi=vpi;
+  *pdelay =tt;
+  dprintf(2, "oam chan=%d, type =%d\n", chan, *type);
+ 
+  return chan;
+}
+
+static void tn7dsl_dump_memory(void)
+{
+  unsigned int *pUi;
+  int i=1;
+  int j=0;
+  int addr, len;
+  char tmp[16];
+
+
+  while(j<8)
+  {
+    tmp[j] = mod_req[i];
+    j++;
+    i++;
+  }
+
+  tmp[j] = 0;
+          
+  addr = os_atoh(tmp);
+
+  printk("start dump address =0x%x\n", addr);
+  pUi = (unsigned int *)addr;
+  i++;
+  j=0;
+  while(j<8)
+  {
+    tmp[j] = mod_req[i];
+    //printk("tmp[%d]=%c, %d\n", j, tmp[j], tmp[j]); 
+    if(tmp[j] == 0x43 || tmp[j] == 0x63)
+      break;
+
+    j++;
+    i++;
+  }
+
+  len = os_atoi(tmp);
+  j=0;
+  for(i=0; i<len; i++)
+  {
+    if(j==0)
+      printk("0x%08x: ", (unsigned int)pUi);
+    printk("%08x ", *pUi);
+    pUi++;
+    j++;
+    if(j==4)
+    {
+      printk("\n");
+      j=0;
+    }
+  }
+     
+}
+
+
+
+static int dslmod_sysctl(ctl_table *ctl, int write, struct file * filp,
+      void *buffer, size_t *lenp)
+{
+  char *ptr;
+  int ret, len = 0;
+  int chan;
+  int type;
+  int vpi,vci,timeout;
+  
+  if (!*lenp || (filp->f_pos && !write)) {
+    *lenp = 0;
+    return 0;
+    }
+  /* DSL MODULATION is changed */
+  if(write)
+    {
+    ret = proc_dostring(ctl, write, filp, buffer, lenp);
+    
+    switch (ctl->ctl_name)
+      {
+      case DEV_DSLMOD:
+      ptr = strpbrk(info, " \t");
+      strcpy(mod_req, info);
+
+      /* parse the string to determine the action */
+      if(mod_req[0] == 0x45 || mod_req[0] == 0x65 ) // 'e', or 'E' f5 end to end 
+      {
+        chan = tn7dsl_process_oam_string(&type, &vpi, &vci, &timeout);
+        tn7sar_oam_generation(pIhw->pOsContext, chan, type, vpi, vci, timeout);
+      }
+      else if(mod_req[0] == 0x53 || mod_req[0] == 0x73 ) // 's', or 'S' f5 seg to seg
+      {
+        chan=tn7dsl_process_oam_string(&type, &vpi, &vci,&timeout);
+        type = type | (1<<1);
+        tn7sar_oam_generation(pIhw->pOsContext, chan, type, vpi, vci,timeout);
+      }
+    //debug only. Dump memory
+      else if(mod_req[0] == 0x44 || mod_req[0] == 0x64 ) // 'd' or 'D'
+        tn7dsl_dump_memory();
+      else
+        tn7dsl_chng_modulation(info);
+      break;
+      }
+    }
+  else
+    {
+    len += sprintf(info+len, mod_req);
+    ret = proc_dostring(ctl, write, filp, buffer, lenp);
+    }
+  return ret;
+}
+
+
+ctl_table dslmod_table[] = {
+  {DEV_DSLMOD, "dslmod", info, DSL_MOD_SIZE, 0644, NULL, &dslmod_sysctl},
+  {0}
+  };
+
+/* Make sure that /proc/sys/dev is there */
+ctl_table dslmod_root_table[] = {
+#ifdef CONFIG_PROC_FS
+  {CTL_DEV, "dev", NULL, 0, 0555, dslmod_table},
+#endif /* CONFIG_PROC_FS */
+  {0}
+  };
+
+static struct ctl_table_header *dslmod_sysctl_header;
+
+void tn7dsl_dslmod_sysctl_register(void)
+{
+  static int initialized;
+  
+  if (initialized == 1)
+    return;
+  
+  dslmod_sysctl_header = register_sysctl_table(dslmod_root_table, 1);
+  dslmod_root_table->child->de->owner = THIS_MODULE;
+  
+  /* set the defaults */
+  info[0] = 0;
+  
+  initialized = 1;
+}
+
+void tn7dsl_dslmod_sysctl_unregister(void)
+{
+  unregister_sysctl_table(dslmod_sysctl_header);
+}
+
+static void 
+tn7dsl_set_modulation(void* data)
+{
+  dprintf(4,"tn7dsl_set_modulation\n");
+  
+  if(!strcmp(data, "T1413"))
+  {
+    printk("retraining in T1413 mode\n");
+    dslhal_api_setTrainingMode(pIhw, T1413_MODE);
+    return;
+  }
+  if(!strcmp(data, "GDMT"))
+  {
+    dslhal_api_setTrainingMode(pIhw, GDMT_MODE);
+    return;
+  }
+  if(!strcmp(data, "GLITE"))
+  {
+    dslhal_api_setTrainingMode(pIhw, GLITE_MODE);
+    return;
+  }
+  if(!strcmp(data, "MMODE"))
+  {
+    dslhal_api_setTrainingMode(pIhw, MULTI_MODE);
+    return;
+  }
+  if(!strcmp(data, "NMODE"))
+  {
+    dslhal_api_setTrainingMode(pIhw, NO_MODE);
+    return;
+  }
+
+  return;
+}
+
+
+/* Codes added for compiling tiadiag.o for Analog Diagnostic tests */
+#ifdef ADIAG
+
+enum
+{
+  HOST_ACTREQ,         // Send R-ACKREQ and monitor for C-ACKx
+  HOST_QUIET,          // Sit quietly doing nothing for about 60 seconds, DEFAULT STATE; R_IDLE
+  HOST_XMITBITSWAP,    // Perform upstream bitswap - FOR INTERNAL USE ONLY
+  HOST_RCVBITSWAP,     // Perform downstream bitswap - FOR INTERNAL USE ONLY
+  HOST_RTDLPKT,        // Send a remote download packet - FOR INTERNAL USE ONLY
+  HOST_CHANGELED,      // Read the LED settings and change accordingly
+  HOST_IDLE,           // Sit quiet
+  HOST_REVERBTEST,     // Generate REVERB for manufacturing test
+  HOST_CAGCTEST,       // Set coarse receive gain for manufacturing test
+  HOST_DGASP,          // send Dying Gasp messages through EOC channel
+  HOST_GHSREQ,         // G.hs - FOR INTERNAL USE ONLY
+  HOST_GHSMSG,         // G.hs - FOR INTERNAL USE ONLY
+  HOST_GHS_SENDGALF,   // G.hs - FOR INTERNAL USE ONLY
+  HOST_GHSEXIT,        // G.hs - FOR INTERNAL USE ONLY
+  HOST_GHSMSG1,        // G.hs - FOR INTERNAL USE ONLY
+  HOST_HYBRID,         // Enable/Disable automatic hybrid switch
+  HOST_RJ11SELECT,     // RJ11 inner/outer pair select
+  HOST_DIGITAL_MEM,    // Digital Diags: run external memory tests
+  HOST_TXREVERB,       // AFE Diags: TX path Reverb
+  HOST_TXMEDLEY,       // AFE Diags: TX path Medley
+  HOST_RXNOISEPOWER,   // AFE Diags: RX noise power
+  HOST_ECPOWER,        // AFE Diags: RX eco power
+  HOST_ALL_ADIAG,      // AFE Diags: all major analog diagnostic modes. Host is responsible to initiate each diagnostic sessions
+  HOST_USER_ADIAG,     // AFE Diags: Host fills in analog diagnostic input data structure as specified and requests DSP to perform measurements as specified
+  HOST_QUIT_ADIAG,     // AFE Diags: Host requests DSP to quit current diagnostic session. This is used for stopping the transmit REVERB/MEDLEY
+  HOST_NO_CMD,         // All others - G.hs - FOR INTERNAL USE ONLY
+  HOST_DSLSS_SHUTDOWN, // Host initiated DSLSS shutdown message
+  HOST_SET_GENERIC,    // Set generic CO profile
+  HOST_UNDO_GENERIC    // Set profile previous to Generic
+};
+
+enum
+{
+  DSP_IDLE,               // R_IDLE state entered
+  DSP_ACTMON,             // R_ACTMON state entered
+  DSP_TRAIN,              // R_TRAIN state entered
+  DSP_ACTIVE,             // R_ACTIVE state entered
+  DSP_XMITBITSWAP,        // Upstream bitswap complete - FOR INTERNAL USE ONLY
+  DSP_RCVBITSWAP,         // Downstream bitswap complete - FOR INTERNAL USE ONLY
+  DSP_RTDL,               // R_RTDL state entered - FOR INTERNAL USE ONLY
+  DSP_RRTDLPKT,           // RTDL packet received - FOR INTERNAL USE ONLY
+  DSP_XRTDLPKT,           // RTDL packet transmitted - FOR INTERNAL USE ONLY
+  DSP_ERROR,              // Command rejected, wrong state for this command
+  DSP_REVERBTEST,         // Manufacturing REVERB test mode entered
+  DSP_CAGCTEST,           // Manufacturing receive gain test done
+  DSP_OVERLAY_START,      // Notify host that page overlay has started - overlay number indicated by "tag"
+  DSP_OVERLAY_END,        // Notify host that page overlay has ended   - overlay number indicated by "tag"
+  DSP_CRATES1,            // CRATES1 message is valid and should be copied to host memory now
+  DSP_SNR,                // SNR calculations are ready and should be copied to host memory now
+  DSP_GHSMSG,             // G.hs - FOR INTERNAL USE ONLY
+  DSP_RCVBITSWAP_TIMEOUT, // Acknowledge Message was not received within ~500 msec (26 Superframes).
+  DSP_ATM_TC_SYNC,        // Indicates true TC sync on both the upstream and downstream. Phy layer ready for data xfer.
+  DSP_ATM_NO_TC_SYNC,     // Indicates loss of sync on phy layer on either US or DS.
+  DSP_HYBRID,             // DSP completed hybrid switch
+  DSP_RJ11SELECT,         // DSP completed RJ11 inner/outer pair select
+  DSP_INVALID_CMD,        // Manufacturing (Digital and AFE) diags: CMD received not recognized
+  DSP_TEST_PASSED,        // Manufacturing diags: test passed
+  DSP_TEST_FAILED,        // Manufacturing diags: test failed
+  DSP_TXREVERB,           // Manufacturing AFE diags: Response to HOST_TXREVERB
+  DSP_TXMEDLEY,           // Manufacturing AFE diags: Response to HOST_TXMEDLEY
+  DSP_RXNOISEPOWER,       // Manufacturing AFE diags: Response to HOST_RXNOISEPOWER
+  DSP_ECPOWER,            // Manufacturing AFE diags: Response to HOST_ECPOWER
+  DSP_ALL_ADIAG,          // Manufacturing AFE diags: Response to HOST_ALL_ADIAG
+  DSP_USER_ADIAG,         // Manufacturing AFE diags: Response to HOST_USER_ADIAG
+  DSP_QUIT_ADIAG,         // Manufacturing AFE diags: Response to HOST_QUIT_ADIAG
+  DSP_DGASP               // DSP Message to indicate dying gasp
+};
+
+static unsigned char analogNoTonesTestArray[64]=
+  {
+    0,0,0,0,0,0,0,0,  // Tones 01-08
+    0,0,0,0,0,0,0,0,  // Tones 09-16
+    0,0,0,0,0,0,0,0,  // Tones 17-24
+    0,0,0,0,0,0,0,0,  // Tones 25-32
+    0,0,0,0,0,0,0,0,  // Tones 33-40
+    0,0,0,0,0,0,0,0,  // Tones 41-48
+    0,0,0,0,0,0,0,0,  // Tones 49-56
+    0,0,0,0,0,0,0,0   // Tones 57-64
+  };
+
+static unsigned char analogAllTonesTestArray[64]=
+  {
+    1,1,1,1,1,1,1,1,  // Tones 01-08
+    1,1,1,1,1,1,1,1,  // Tones 09-16
+    1,1,1,1,1,1,1,1,  // Tones 17-24
+    1,1,1,1,1,1,1,1,  // Tones 25-32
+    1,1,1,1,1,1,1,1,  // Tones 33-40
+    1,1,1,1,1,1,1,1,  // Tones 41-48
+    1,1,1,1,1,1,1,1,  // Tones 49-56
+    1,1,1,1,1,1,1,1   // Tones 57-64
+  };
+
+static unsigned char analogEvenTonesTestArray[64]=
+  {
+    0,1,0,1,0,1,0,1,  // Tones 01-08
+    0,1,0,1,0,1,0,1,  // Tones 09-16
+    0,1,0,1,0,1,0,1,  // Tones 17-24
+    0,1,0,1,0,1,0,1,  // Tones 25-32
+    0,1,0,1,0,1,0,1,  // Tones 33-40
+    0,1,0,1,0,1,0,1,  // Tones 41-48
+    0,1,0,1,0,1,0,1,  // Tones 49-56
+    0,1,0,1,0,1,0,1   // Tones 57-64
+  };
+
+static unsigned char analogOddTonesTestArray[64]=
+  {
+    1,0,1,0,1,0,1,0,  // Tones 01-08
+    1,0,1,0,1,0,1,0,  // Tones 09-16
+    1,0,1,0,1,0,1,0,  // Tones 17-24
+    1,0,1,0,1,0,1,0,  // Tones 25-32
+    1,0,1,0,1,0,1,0,  // Tones 33-40
+    1,0,1,0,1,0,1,0,  // Tones 41-48
+    1,0,1,0,1,0,1,0,  // Tones 49-56
+    1,0,1,0,1,0,1,0   // Tones 57-64
+  };
+
+unsigned int shim_osGetCpuFrequency(void)
+{
+  return 150;
+}
+
+static void tn7dsl_adiag(int Test, unsigned char *missingTones)
+{
+  int rc,cmd, tag;
+
+  rc = dslhal_diags_anlg_setMissingTones(pIhw,missingTones);
+  if(rc)
+  {
+    printk(" failed to set Missing town\n");
+    return;
+  }
+
+/*********** Start the actual test **********************/
+
+ if(Test==0)
+   {
+   printk("TX REVERB Test\n");
+   rc = dslhal_support_writeHostMailbox(pIhw, HOST_TXREVERB, 0, 0, 0);
+   if (rc)
+     {
+     printk("HOST_TXREVERB failed\n");
+     return;
+     }
+
+   }
+ if(Test==1)
+   {
+     dprintf(0,"TX MEDLEY Test\n");
+     rc = dslhal_support_writeHostMailbox(pIhw, HOST_TXMEDLEY, 0, 0, 0);
+     if (rc)
+       return;
+   }
+ dprintf(4,"dslhal_diags_anlg_testA() done\n");
+ return;
+}
+  
+
+static void tn7dsl_diagnostic_test(char *data)
+{
+  if(!strcmp(data, "ADIAGRALL"))
+  {
+    printk("TX Reverb All tone\n");
+    tn7dsl_adiag(0,analogAllTonesTestArray);
+    return;
+  }
+  if(!strcmp(data, "ADIAGRNONE"))
+  {
+    printk("TX Reverb No tone\n");
+    tn7dsl_adiag(0,analogNoTonesTestArray);
+    return;
+  }
+  if(!strcmp(data, "ADIAGREVEN"))
+  {
+    printk("TX Reverb Even tone\n");
+    tn7dsl_adiag(0,analogEvenTonesTestArray);
+    return;
+  }
+  if(!strcmp(data, "ADIAGRODD"))
+  {
+    printk("TX Reverb Odd tone\n");
+    tn7dsl_adiag(0,analogOddTonesTestArray);
+    return;
+  }
+  if(!strcmp(data, "ADIAGMALL"))
+  {
+    printk("TX Mdelay All tone\n");
+    tn7dsl_adiag(1,analogAllTonesTestArray);
+    return;
+  }
+  if(!strcmp(data, "ADIAGMNONE"))
+  {
+    printk("TX Mdelay No tone\n");
+    tn7dsl_adiag(1,analogNoTonesTestArray);
+    return;
+  }
+  if(!strcmp(data, "ADIAGMEVEN"))
+  {
+    printk("TX Mdelay Even tone\n");
+    tn7dsl_adiag(1,analogEvenTonesTestArray);
+    return;
+  }
+  if(!strcmp(data, "ADIAGMODD"))
+  {
+    printk("TX Mdelay Odd tone\n");
+    tn7dsl_adiag(1,analogOddTonesTestArray);
+    return;
+  }
+  if(!strcmp(data, "ADIAGQUIET"))
+  {
+    dslhal_api_sendIdle(pIhw);
+    return;
+  }
+  if(!strncmp(data, "ADIAGRN", 7))
+  {
+    char tones[64], tmp[4];
+    int  nth, i;
+    
+    tmp[0]=data[7];
+    tmp[1]=data[8];
+    tmp[2]=data[9];
+    
+    nth = os_atoi(tmp);
+
+    for(i=0;i<64;i++)
+    {
+      if(((i+1)% nth)==0)
+      {
+        tones[i]=0;
+      }
+      else
+      {
+        tones[i]=1;
+      }
+    }
+    printk("TX Reverb with %dth tones missing.\n", nth);
+    tn7dsl_adiag(0,tones);
+    return;
+  }
+  if(!strncmp(data, "ADIAGMN", 7))
+  {
+    char tones[64], tmp[4];
+    int  nth, i;
+
+    tmp[0]=data[7];
+    tmp[1]=data[8];
+    tmp[2]=data[9];
+    nth = os_atoi(tmp);
+
+    for(i=0;i<64;i++)
+    {
+      if(((i+1)% nth)==0)
+      {
+        tones[i]=0;
+      }
+      else
+      {
+        tones[i]=1;
+      }
+    }
+    printk("TX Mdelay with %dth tones missing.\n", nth);
+    tn7dsl_adiag(1,tones);
+    return;
+  }
+
+
+}
+
+#endif
+
+static void 
+tn7dsl_chng_modulation(void* data)
+{
+  //printk("DSL Modem Retraining\n");
+  
+  if(!strcmp(data, "T1413"))
+  {
+    printk("retraining in T1413 mode\n");
+    dslhal_api_setTrainingMode(pIhw, T1413_MODE);
+    dslhal_api_sendQuiet(pIhw);
+    return;
+  }
+  if(!strcmp(data, "GDMT"))
+  {
+    dslhal_api_setTrainingMode(pIhw, GDMT_MODE);
+    dslhal_api_sendQuiet(pIhw);
+    return;
+  }
+  if(!strcmp(data, "GLITE"))
+  {
+    dslhal_api_setTrainingMode(pIhw, GLITE_MODE);
+    dslhal_api_sendQuiet(pIhw);
+    return;
+  }
+  if(!strcmp(data, "MMODE"))
+  {
+    dslhal_api_setTrainingMode(pIhw, MULTI_MODE);
+    dslhal_api_sendQuiet(pIhw);
+    return;
+  }
+  if(!strcmp(data, "NMODE"))
+  {
+    dslhal_api_setTrainingMode(pIhw, NO_MODE);
+    dslhal_api_sendQuiet(pIhw);
+    return;
+  }
+
+#ifdef ADIAG
+  tn7dsl_diagnostic_test(data);
+#endif
+
+
+  return;
+}
+
+#ifdef CONFIG_LED_MODULE
+static void tn7dsl_led_on(unsigned long parm)
+{
+  dslhal_api_configureLed(pIhw,parm, 0);
+}
+
+
+static void tn7dsl_led_off(unsigned long parm)
+{
+  dslhal_api_configureLed(pIhw,parm, 1);
+}
+
+static void tn7dsl_led_init(unsigned long parm)
+{
+  dslhal_api_configureLed(pIhw,parm, 2);
+}
+#endif
+
+static void tn7dsl_register_dslss_led(void)
+{
+#ifdef CONFIG_LED_MODULE
+    
+    // register led0 with led module
+    ledreg[0].param = 0;
+    ledreg[0].init = (void *)tn7dsl_led_init;
+    ledreg[0].onfunc = (void *)tn7dsl_led_on;
+    ledreg[0].offfunc = (void *)tn7dsl_led_off;
+    register_led_drv(LED_NUM_1, &ledreg[0]);
+
+    // register led1 output with led module
+    ledreg[1].param = 1;
+    ledreg[1].init = (void *)tn7dsl_led_init;
+    ledreg[1].onfunc = (void *)tn7dsl_led_on;
+    ledreg[1].offfunc = (void *)tn7dsl_led_off;
+    register_led_drv(LED_NUM_2, &ledreg[1]);
+#endif  
+}
+
+static int tn7dsl_reload_overlay(void)
+{
+  int overlayFlag;
+  spinlock_t overlayLock;
+
+  init_kthread(&overlay_thread, "adsl");
+  down(&adsl_sem_overlay);
+  while(1)
+  {
+    mdelay(500);
+    if(pIhw->lConnected == 0)
+    {
+      spin_lock_irqsave(&overlayLock, overlayFlag);
+      dslhal_support_restoreTrainingInfo(pIhw);
+      spin_unlock_irqrestore(&overlayLock, overlayFlag);
+    }
+    down(&adsl_sem_overlay);
+  }
+  return 0;
+}
+
+
+
+
diff -urN linux.old/drivers/atm/sangam_atm/tn7sar.c linux.dev/drivers/atm/sangam_atm/tn7sar.c
--- linux.old/drivers/atm/sangam_atm/tn7sar.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/tn7sar.c	2005-08-23 04:46:50.110841720 +0200
@@ -0,0 +1,1376 @@
+/******************************************************************************
+ * FILE PURPOSE:    OS files for CPSAR
+ ******************************************************************************
+ * FILE NAME:       tn7sar.c
+ *
+ * DESCRIPTION:     This file contains source for required os files for CPSAR
+ * 
+ * (C) Copyright 2002, Texas Instruments Inc
+ *
+ *
+ * Revision History:
+ * 0/11/02         Zhicheng Tang, created.
+ *
+ *******************************************************************************/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/atmdev.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <asm/io.h>
+#include <asm/mips-boards/prom.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+
+#define _CPHAL_AAL5
+#define _CPHAL_SAR
+#define _CPHAL_HAL
+typedef void OS_PRIVATE;
+typedef void OS_DEVICE;
+typedef void OS_SENDINFO;
+typedef void OS_RECEIVEINFO;
+typedef void OS_SETUP;
+
+#include "cpswhal_cpsar.h"
+#include "tn7atm.h"
+#include "tn7api.h"
+
+
+/* PDSP Firmware files */
+#include "tnetd7300_sar_firm.h"
+
+
+enum
+{
+  PACKET_TYPE_AAL5,
+  PACKET_TYPE_NULL,
+  PACKET_TYPE_OAM,
+  PACKET_TYPE_TRANS,
+  PACKET_TYPE_AAL2
+}PACKET_TYPE;
+
+enum
+{
+  OAM_PING_FAILED,
+  OAM_PING_SUCCESS,
+  OAM_PING_PENDING,
+  OAM_PING_NOT_STARTED
+}OAM_PING;
+
+/* PDSP OAM General Purpose Registers (@todo: These need to be used in the HAL!) */
+
+#define SAR_PDSP_HOST_OAM_CONFIG_REG_ADDR 0xa3000020
+#define SAR_PDSP_OAM_CORR_REG_ADDR        0xa3000024
+#define SAR_PDSP_OAM_LB_RESULT_REG_ADDR   0xa3000028
+#define SAR_PDSP_OAM_F5LB_COUNT_REG_ADDR  0xa300002c
+#define SAR_PDSP_OAM_F4LB_COUNT_REG_ADDR  0xa3000030
+
+#define SAR_FREQUNCY 50000000
+
+#define AAL5_PARM "id=aal5, base = 0x03000000, offset = 0, int_line=15, ch0=[RxBufSize=1522; RxNumBuffers = 32; RxServiceMax = 50; TxServiceMax=50; TxNumBuffers=32; CpcsUU=0x5aa5; TxVc_CellRate=0x3000; TxVc_AtmHeader=0x00000640]"
+#define SAR_PARM "id=sar,base = 0x03000000, reset_bit = 9, offset = 0; UniNni = 0, PdspEnable = 1"
+#define RESET_PARM "id=ResetControl, base=0xA8611600"
+#define CH0_PARM "RxBufSize=1522, RxNumBuffers = 32, RxServiceMax = 50, TxServiceMax=50, TxNumBuffers=32, CpcsUU=0x5aa5, TxVc_CellRate=0x3000, TxVc_AtmHeader=0x00000640"
+
+#define MAX_PVC_TABLE_ENTRY 16
+
+sar_stat_t sarStat;
+ 
+typedef struct _channel_parm
+{
+  unsigned int     RxBufSize;
+  unsigned int     RxNumBuffers;
+  unsigned int     RxServiceMax;
+  unsigned int     TxServiceMax;
+  unsigned int     TxNumBuffers;
+  unsigned int     CpcsUU;
+  unsigned int     TxVc_CellRate;
+  unsigned int     TxVc_AtmHeader;
+}channel_parm_t;
+
+typedef struct _aal5_parm
+{
+  unsigned int        base;
+  unsigned int        offset;
+  unsigned int        int_line;
+  channel_parm_t      chan[8];
+}aal5_parm_t;
+
+
+typedef struct _sar_parm
+{
+  unsigned int        base;
+  unsigned int        reset_bit;
+  unsigned int        offset;
+  unsigned int        UniNni;
+}sar_parm_t;
+
+typedef struct _pvc_table
+{
+  int bInUse;
+  int vpi;
+  int vci;
+}pvc_table;
+
+static aal5_parm_t aal5Parm;
+static sar_parm_t  sarParm;
+static char *pAal5, *pSar, *pReset;
+static int oam_type;
+static unsigned int oamPingStatus;
+static int oamAtmHdr;
+static int oamLbTimeout;
+static char parm_data[1024];
+static char aal5Data[1024];
+static char sarData[1024];
+static char resetData[256];
+static pvc_table pvc_result[MAX_PVC_TABLE_ENTRY];
+
+/* external function */
+extern int __guDbgLevel;
+
+/* gloabal function */
+unsigned int oamFarLBCount[4];
+/* end of gloabal function */
+
+/* internal APIs */
+static int tn7sar_atm_header(int vpi, int vci);
+static void tn7sar_record_pvc(int atmheader);
+
+/*end of internal APIs */
+spinlock_t sar_lock;
+
+/* HAL OS support functions */
+
+
+unsigned long tn7sar_strtoul(const char *str, char **endptr, int base)
+{
+  unsigned long ret;
+
+  ret= simple_strtoul(str, endptr, base); 
+  return ret;
+}
+
+static void *tn7sar_malloc(unsigned int size)
+{
+  return(kmalloc(size, GFP_KERNEL));
+}
+
+static unsigned long lockflags;
+static void tn7sar_critical_on(void)
+{
+  spin_lock_irqsave(&sar_lock,lockflags);
+}
+
+static void tn7sar_critical_off(void)
+{
+  spin_unlock_irqrestore(&sar_lock,lockflags);
+}
+
+static void tn7sar_data_invalidate(void *pmem, int size)
+{
+  unsigned int i,Size=(((unsigned int)pmem)&0xf)+size;
+
+  for (i=0;i<Size;i+=16,pmem+=16)
+  {
+    __asm__(" .set mips3 ");
+    __asm__("cache  17, (%0)" : : "r" (pmem));
+    __asm__(" .set mips0 ");
+  }
+
+}
+
+static void tn7sar_data_writeback(void *pmem, int size)
+{
+  unsigned int i,Size=(((unsigned int)pmem)&0xf)+size;
+
+  for (i=0;i<Size;i+=16,pmem+=16)
+  {
+    __asm__(" .set mips3 ");
+    __asm__(" cache  25, (%0)" : : "r" (pmem));
+    __asm__(" .set mips0 ");
+  }
+}
+
+
+static int 
+tn7sar_find_device(int unit, const char *find_name, void *device_info)
+{
+  int ret_val = 0;
+  char **ptr;
+
+  ptr = (char **)device_info;
+  dprintf(3,"tn7sar_find_device\n");
+  if(strcmp(find_name, "aal5")==0)
+  {
+    //dprintf(4,"pAal5=%s\n", pAal5);
+    *ptr = pAal5;
+  }
+  else if(strcmp(find_name, "sar")==0)
+  {
+    dprintf(3, "pSar=%s\n", pSar);
+    *ptr = pSar;
+  }  
+  else if(strcmp(find_name, "reset")==0)
+  {
+    dprintf(3, "pReset=%s\n", pReset);
+    *ptr = pReset;
+  }
+
+  device_info = NULL;
+
+  return(ret_val);
+}
+
+static int 
+tn7sar_get_device_parm_uint(void *dev_info, const char *param, unsigned int *value)
+{
+  char *dev_str;
+  char *pMatch;
+  int i=0, j=0;
+  char val_str[64];
+  unsigned int val;
+  int base = 10;
+
+  dprintf(6, "tn7sar_get_device_parm_uint()\n");
+
+  dev_str = (char *)dev_info;
+  dprintf(3, "parm=%s\n", param);
+  pMatch = strstr(dev_str, param);
+  //dprintf(4, "pMatch=%s\n", pMatch);
+  if(pMatch)
+  {
+    //get "=" position
+    while(pMatch[i] != 0x3d)
+    {
+      i++;
+    }
+    i++;
+    // get rid of spaces
+    while(pMatch[i]==0x20)
+    {
+      i++;
+    }
+    //get rid of 0x
+    if(pMatch[i]==0x30)
+    {
+      if(pMatch[i+1] == 0x58 || pMatch[i+1] == 0x78)
+      {
+        i+=2;
+        base = 16;
+      }
+    }
+
+    // get next delineator
+    while(pMatch[i] != 0x2c && pMatch[i] != 0x0)
+    {
+      val_str[j]=pMatch[i];
+      j++;
+      i++;
+    }
+    val_str[j]=0;
+    //dprintf(4, "val_str=\n%s\n", val_str);
+    //xdump(val_str, strlen(val_str) + 1, 4);
+    val = simple_strtoul(val_str, (char **)NULL, base);
+    dprintf(4, "val =%d\n", val);
+    *value = val;
+    return 0;
+  }
+
+
+  dprintf(3, "match not found.\n");
+  if(strcmp(dev_str, "debug")==0)
+  {
+    dprintf(6,"debug..\n");
+    *value = 6;
+    return 0;
+  }
+  return (1);
+}
+
+static int tn7sar_get_device_parm_value(void *dev_info, const char *param, void *value)
+{
+  char *dev_str;
+  char *pMatch;
+  int i=0, j=0;
+  char *pVal;
+
+  
+  dprintf(3, "tn7sar_get_device_parm_value().\n");
+  
+  pVal = (char *) parm_data;
+  dev_str = (char *)dev_info;
+  dprintf(3, "dev_info: \n%s\n", dev_str);
+  dprintf(3, "param=%s\n", param);
+  if(strcmp(param, "Ch0")==0)
+  {
+    *(char **)value = CH0_PARM;
+    dprintf(3, "value =%s\n", *(char **)value);
+    return 0;
+  }
+
+  pMatch = strstr(dev_str, param);
+  if(pMatch)
+  {
+    //get "=" position
+    while(pMatch[i] != 0x3d)
+    {
+      i++;
+    }
+    i++;
+    // get rid of spaces
+    while(pMatch[i]==0x20)
+    {
+      i++;
+    }
+
+    if(pMatch[i] != 0x5b) //"["
+    {
+      // get next delineator
+      while(pMatch[i] != 0x2c && pMatch[i] != 0x0)
+      {
+        pVal[j] = pMatch[i];
+        j++;
+        i++;
+      }
+      pVal[j]=0;
+
+      *(char **)value = pVal;
+      return 0;
+    }
+    else
+    {
+      i++; //skip "["
+      while(pMatch[i] != 0x5d)
+      {
+        if(pMatch[i] == 0x3b) //";"
+          pVal[j] = 0x2c;
+        else
+          pVal[j] = pMatch[i];
+        j++;
+        i++;
+      }
+      pVal[j] = 0;
+      *(char **)value = pVal;
+      return 0;
+    }
+ 
+  }
+  
+  return (1);
+}
+
+static void tn7sar_free(void *pmem)
+{
+    kfree(pmem);
+}
+
+static void 
+tn7sar_free_buffer(OS_RECEIVEINFO *os_receive_info, void *pmem)
+{
+  tn7atm_free_rx_skb(os_receive_info);
+}
+
+static void tn7sar_free_dev(void *pmem)
+{
+  kfree(pmem);
+}
+
+static void tn7sar_free_dma_xfer(void *pmem)
+{
+  kfree(pmem);
+}
+
+
+static int
+tn7sar_control(void *dev_info, const char *key, const char *action, void *value)
+{
+        int ret_val = -1;
+
+  if (strcmp(key, "Firmware") == 0)
+  {
+    if (strcmp(action, "Get") == 0)
+    {
+      *(int **)value = &SarPdspFirmware[0];
+    }
+    ret_val=0;
+  }
+        
+  if (strcmp(key, "FirmwareSize") == 0)
+  {
+    if (strcmp(action, "Get") == 0)
+    {       
+      *(int *)value = sizeof(SarPdspFirmware);
+    }
+    ret_val=0;
+  }
+  
+  if (strcmp(key, "OamLbResult") == 0)
+  {
+    dprintf(2, "get looback source call back\n");
+    if (strcmp(action, "Set") == 0)
+    {       
+      dprintf(2, "oam result = %d\n", *(unsigned int *)value);
+      oamFarLBCount[oam_type] = oamFarLBCount[oam_type] + *(unsigned int *)value;
+      if(oamPingStatus == OAM_PING_PENDING)
+      {
+        oamPingStatus = *(unsigned int *)value;
+        if(oamPingStatus == OAM_PING_SUCCESS)
+        {
+          /* record pvc */
+          tn7sar_record_pvc(oamAtmHdr);
+        }
+      }
+      
+    }
+    ret_val=0;
+  }
+  
+  if (strcmp(key, "SarFreq") == 0)
+  {
+    if (strcmp(action, "Get") == 0)
+    {       
+      *(int *)value = SAR_FREQUNCY;
+    }
+    ret_val=0;
+  }
+  return(ret_val);
+}
+
+
+static void
+tn7sar_sarhal_isr_register(OS_DEVICE *os_dev, int(*hal_isr)(HAL_DEVICE *, int *), int interrupt_num)
+{
+  tn7atm_sarhal_isr_register(os_dev, hal_isr, interrupt_num);
+}
+
+static void 
+tn7sar_isr_unregister(OS_DEVICE *os_dev, int interrupt_num)
+{
+    /* TODO */
+}
+
+
+static void *
+tn7sar_malloc_rxbuffer(unsigned int size, void *mem_base, unsigned int mem_range, HAL_DEVICE *hal_dev, 
+                       HAL_RECEIVEINFO *hal_info, OS_RECEIVEINFO **os_receive_info, OS_DEVICE *os_dev)
+{
+   return tn7atm_allocate_rx_skb(os_dev, os_receive_info, size);
+}
+
+static void *
+tn7sar_malloc_dev(unsigned int size)
+{
+  return(kmalloc(size, GFP_KERNEL));
+}
+
+static void *
+tn7sar_malloc_dma_xfer(unsigned int size, void *mem_base, unsigned int mem_range)
+{
+  dprintf(4, "tn7sar_malloc_dma_xfer, size =%d\n", size);
+
+  return (kmalloc(size, GFP_DMA |GFP_KERNEL));
+  
+}
+
+static void * 
+tn7sar_memset(void *dst, int set_char, size_t count)
+{
+    return (memset(dst, set_char, count));
+}
+
+static int tn7sar_printf(const char *format, ...)
+{
+  /* TODO: add debug levels */
+  static char buff[256];
+  va_list  ap; 
+
+  va_start( ap, format); 
+  vsprintf((char *)buff, format, ap); 
+  va_end(ap); 
+
+  printk("SAR HAL: %s\n", buff);
+  return(0);
+}
+
+static void tn7sar_record_pvc(int atmheader)
+{
+  int vci,vpi;
+  int i;
+
+  vci = 0xffff & (atmheader >> 4);
+  vpi = 0xff & (atmheader >> 20);
+  for(i=0;i<MAX_PVC_TABLE_ENTRY;i++)
+  {
+    if(pvc_result[i].bInUse)
+    {
+      if(pvc_result[i].vpi == vpi && pvc_result[i].vci == vci)
+      {
+        return;
+      }
+    }
+  }
+  for(i=0;i<MAX_PVC_TABLE_ENTRY;i++)
+  {
+    if(pvc_result[i].bInUse == 0)
+    {
+      pvc_result[i].bInUse = 1;
+      pvc_result[i].vpi = vpi;
+      pvc_result[i].vci = vci;
+      return;
+    }
+  }
+  return;
+}
+
+static void tn7sar_clear_pvc_table(void)
+{
+  int i;
+ 
+  for(i=0;i<MAX_PVC_TABLE_ENTRY; i++)
+  {
+    pvc_result[i].bInUse = 0;
+    pvc_result[i].vpi = 0;
+    pvc_result[i].vci = 0;
+  }
+}
+
+int tn7sar_process_unmatched_oam(FRAGLIST *frag_list, unsigned int frag_count, unsigned int packet_size, unsigned int mode)
+{
+
+  FRAGLIST *local_list;
+  int i;
+  unsigned int atmHdr;
+
+  local_list = frag_list;
+
+  for(i=0;i<(int)frag_count;i++)
+  {
+    tn7sar_data_invalidate(local_list->data, (int)local_list->len);
+    local_list ++;
+  }
+  local_list = frag_list;
+  if((mode>>31)) /*vci, vpi is attached */
+  {
+    atmHdr = *(unsigned int *)frag_list->data;
+    tn7sar_record_pvc(atmHdr);
+    if(atmHdr & 0x8) //oam cell
+    {
+      atmHdr &= 0xfffffff0;
+      if(atmHdr == oamAtmHdr)
+      {
+        if(oamPingStatus == OAM_PING_PENDING)
+        {
+          oamPingStatus = OAM_PING_SUCCESS;
+          oamFarLBCount[oam_type] = oamFarLBCount[oam_type] + 1;
+        }
+        return 0;
+      }
+    }
+  }
+ 
+  return 0;
+}
+
+
+static int 
+tn7sar_receive(OS_DEVICE *os_dev,FRAGLIST *frag_list, unsigned int frag_count, unsigned int packet_size, 
+                 HAL_RECEIVEINFO *hal_receive_info, unsigned int mode)
+{   
+  int ch;
+  struct atm_dev *dev;
+  Tn7AtmPrivate *priv;
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+  int bRet;
+
+
+  dprintf(4, "tn7sar_receive\n");
+
+  dev = (struct atm_dev *)os_dev;
+  priv= (Tn7AtmPrivate *)dev->dev_data;
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+
+  
+  /* Mode contains channel info */
+  ch = (mode & 0xFF);
+ 
+  if(ch == 15)
+  {
+    tn7sar_process_unmatched_oam(frag_list, frag_count, packet_size, mode);
+    pHalFunc->RxReturn(hal_receive_info, 0);
+    return 0;
+  }
+
+  if(frag_count > 1 || frag_list->len == 0)
+  {
+    printk("Packet fragment count > 1, not handdle.\n");
+    return 1;
+  }
+ 
+  tn7sar_data_invalidate(frag_list->data, (int)frag_list->len);
+  bRet=tn7atm_receive(os_dev, ch, packet_size, frag_list->OsInfo, frag_list->data);
+
+  if(bRet==0)
+  {
+    sarStat.rxPktCnt++;
+    sarStat.rxBytes += packet_size;
+    pHalFunc->RxReturn(hal_receive_info, 1);
+  }
+  else
+  {
+    pHalFunc->RxReturn(hal_receive_info, 0);
+  }
+
+  return bRet;
+}
+
+static int 
+tn7sar_send_complete(OS_SENDINFO *osSendInfo)
+{  
+  return (tn7atm_send_complete(osSendInfo));
+}
+
+void
+tn7sar_teardown_complete(OS_DEVICE *OsDev, int ch, int Dir)
+{
+  return;
+}
+  
+
+/*
+unsigned int tn7sar_virt(unsigned int address)
+{
+  return phys_to_virt(address);
+}
+*/
+
+int tn7sar_init_module(OS_FUNCTIONS *os_funcs)
+{
+  dprintf(4, "tn7sar_init_module\n");
+  if( os_funcs == 0 )
+  {
+    return(-1);   
+  }
+  os_funcs->Control                  = tn7sar_control;
+  os_funcs->CriticalOn               = tn7sar_critical_on;
+  os_funcs->CriticalOff              = tn7sar_critical_off;
+  os_funcs->DataCacheHitInvalidate   = tn7sar_data_invalidate;
+  os_funcs->DataCacheHitWriteback    = tn7sar_data_writeback;
+  os_funcs->DeviceFindInfo           = tn7sar_find_device;
+  os_funcs->DeviceFindParmUint       = tn7sar_get_device_parm_uint;
+  os_funcs->DeviceFindParmValue      = tn7sar_get_device_parm_value;
+  os_funcs->Free                     = tn7sar_free;
+  os_funcs->FreeRxBuffer             = tn7sar_free_buffer;
+  os_funcs->FreeDev                  = tn7sar_free_dev;
+  os_funcs->FreeDmaXfer              = tn7sar_free_dma_xfer;
+  os_funcs->IsrRegister              = tn7sar_sarhal_isr_register;
+  os_funcs->IsrUnRegister            = tn7sar_isr_unregister;
+  os_funcs->Malloc                   = tn7sar_malloc;
+  os_funcs->MallocRxBuffer           = tn7sar_malloc_rxbuffer;
+  os_funcs->MallocDev                = tn7sar_malloc_dev;
+  os_funcs->MallocDmaXfer            = tn7sar_malloc_dma_xfer;
+  os_funcs->Memset                   = tn7sar_memset;
+  os_funcs->Printf                   = tn7sar_printf;
+  os_funcs->Receive                  = tn7sar_receive;
+  os_funcs->SendComplete             = tn7sar_send_complete;
+  os_funcs->Strcmpi                  = strcmp;
+  os_funcs->Sprintf                  = sprintf;
+  os_funcs->Strlen                   = strlen;
+  os_funcs->Strstr                   = strstr;
+  os_funcs->Strtoul                  = tn7sar_strtoul;
+  os_funcs->TeardownComplete         = tn7sar_teardown_complete;
+    
+  return(0);
+}
+
+
+static void tn7sar_init_dev_parm(void)
+{
+  int i;
+  
+  
+  /* aal5 */
+  //strcpy(aal5Parm.id, "aal5");
+  aal5Parm.base = 0x03000000;
+  aal5Parm.offset = 0;
+  aal5Parm.int_line=15;
+  aal5Parm.chan[0].RxBufSize=1600;
+  aal5Parm.chan[0].RxNumBuffers = 32;
+  aal5Parm.chan[0].RxServiceMax = 50;
+  aal5Parm.chan[0].TxServiceMax=50;
+  aal5Parm.chan[0].TxNumBuffers=32;
+  aal5Parm.chan[0].CpcsUU=0x5aa5;
+  aal5Parm.chan[0].TxVc_CellRate=0x3000;
+  aal5Parm.chan[0].TxVc_AtmHeader=0x00000640;
+  for(i=1;i<8;i++)
+  {
+    memcpy(&aal5Parm.chan[i], &aal5Parm.chan[0], sizeof(aal5Parm.chan[0]));
+  }
+  
+
+  /* sar */
+  //strcpy(sarParm.id, "sar");
+  sarParm.base = 0x03000000;
+  sarParm.reset_bit = 9;
+  sarParm.offset = 0;
+  sarParm.UniNni = 0;
+
+  pAal5 = aal5Data;
+  pSar  = sarData;
+  pReset = resetData;
+  strcpy(pAal5, AAL5_PARM);
+  strcpy(pSar, SAR_PARM);
+  strcpy(pReset, RESET_PARM);
+
+}
+
+ 
+int tn7sar_get_stats(void *priv1)
+{
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+  Tn7AtmPrivate *priv;
+  int i, j;
+  unsigned int *pSarStat, *pStateBase;
+  char statString[64];
+  int len;
+  
+  dprintf(2, "tn7sar_get_stats\n");
+
+  priv = (Tn7AtmPrivate *)priv1;
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+
+  //memset(&sarStat, 0, sizeof(sarStat));
+  sarStat.txErrors = 0;
+  sarStat.rxErrors = 0;
+  for(i=0;i<MAX_DMA_CHAN;i++)
+  {
+    if(priv->lut[i].inuse)
+    {
+      for(j=0;j<1;j++)
+      {
+        len=sprintf(statString, "Stats;0;%d", priv->lut[i].chanid);
+        statString[len]=0;
+        dprintf(2, "statString=%s\n",statString);
+        pHalFunc->Control(pHalDev, statString, "Get", &pSarStat);
+        pStateBase = pSarStat;
+        while(pSarStat)
+        {
+          if((char *)*pSarStat == NULL)
+            break;
+          dprintf(2, "%s\n", (char *) *pSarStat);
+          pSarStat++;
+          dprintf(2, "%s\n", (char *) *pSarStat);
+          sarStat.rxErrors += os_atoul((char *) *pSarStat);
+          pSarStat++;
+        }
+          
+        kfree(pStateBase);
+      }
+    }
+  }
+  return 0;
+}
+          
+int tn7sar_setup_oam_channel(Tn7AtmPrivate *priv)
+{
+
+  CHANNEL_INFO chInfo;
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+  int chan=15;  
+  dprintf(4, "tn7sar_setup_oam_channel\n");
+
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+
+  memset(&chInfo, 0xff, sizeof(chInfo));
+
+  /* channel specific */
+  chInfo.Channel = 15; /* hardcoded for last channel */
+  chInfo.Direction = 0;
+  chInfo.Vci = 30; /* just need below 32 */
+  chInfo.Vpi = 0;
+  chInfo.TxVc_QosType = 2;
+
+  /*default */
+  chInfo.PktType      = PACKET_TYPE_TRANS;
+  chInfo.TxServiceMax = 2;
+  chInfo.RxServiceMax = 2;
+  chInfo.TxNumQueues  = 1;
+  chInfo.TxNumBuffers = 4;
+  chInfo.RxNumBuffers = 4;
+  chInfo.RxBufSize    = 256;
+  chInfo.RxVc_OamToHost = 0;
+  chInfo.RxVp_OamToHost = 0;
+  chInfo.FwdUnkVc       = 1; //enable forwarding of unknown vc
+  chInfo.TxVc_AtmHeader = tn7sar_atm_header((int)chInfo.Vpi, chInfo.Vci);
+  chInfo.RxVc_AtmHeader = tn7sar_atm_header((int)chInfo.Vpi, chInfo.Vci);
+  chInfo.TxVp_AtmHeader = tn7sar_atm_header((int)chInfo.Vpi, 0);
+  chInfo.RxVp_AtmHeader = tn7sar_atm_header((int)chInfo.Vpi, 0);
+
+  dprintf(4, "TxVc_AtmHeader=0x%x\n", chInfo.TxVc_AtmHeader);
+
+  if(pHalFunc->ChannelSetup(pHalDev, &chInfo, NULL))
+  {
+    printk("failed to setup channel =%d.\n", chan);
+    return -1;
+  }
+ 
+  // claiming the channel
+  priv->lut[chan].vpi = 0;
+  priv->lut[chan].vci = 30;
+  priv->lut[chan].chanid = chan;
+  priv->lut[chan].inuse = 1;   
+  return 0;
+}
+
+int tn7sar_init(struct atm_dev *dev, Tn7AtmPrivate *priv)
+{
+  int retCode;
+  int hal_funcs_size;
+ 
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+  OS_FUNCTIONS  *pOsFunc;
+  int oamMod;
+  char *pLbTimeout;
+  int lbTimeout;
+
+
+  dprintf(4, "tn7sar_init\n");
+
+  pOsFunc = (OS_FUNCTIONS  *)kmalloc(sizeof(OS_FUNCTIONS), GFP_KERNEL);
+
+  
+  priv->pSarOsFunc = ( void *)pOsFunc;
+
+  /* init boot parms */
+  tn7sar_init_dev_parm();
+
+  /* init sar os call back functions */
+  retCode = tn7sar_init_module(pOsFunc);
+  if (retCode != 0) /* error */
+  {
+    printk("Failed to init SAR OS Functions\n");
+    return (1);
+  }
+                
+        /* Init sar hal */
+  retCode = cpaal5InitModule(&pHalDev, (OS_DEVICE*) dev, &pHalFunc, 
+                               pOsFunc, sizeof(OS_FUNCTIONS), &hal_funcs_size, 0);
+  if (retCode != 0) /* error */
+  {
+    printk("Failed to init SAR HAL\n");
+    return (1);
+  }
+
+  /* sanity check */
+  if (pHalDev == NULL || pHalFunc == NULL || hal_funcs_size != sizeof(HAL_FUNCTIONS) )
+  {
+    printk("Invalid SAR hal and/or functions.\n");
+    return (1);
+  }
+   
+  /* remeber HAL pointers */
+  priv->pSarHalDev = (void *)pHalDev;
+  priv->pSarHalFunc = (void *)pHalFunc;
+
+        /* Probe for the Device to get hardware info from driver */
+  retCode = pHalFunc->Probe(pHalDev);
+  if (retCode !=0)
+  {
+    printk("SAR hal probing error.\n");
+    return (1);
+  }
+
+  /* init sar hal */
+  retCode = pHalFunc->Init(pHalDev);
+  if (retCode != 0) /* error */
+  {
+    
+    printk("pHalFunc->Init failed. err code =%d\n", retCode);
+    return (1);
+  }
+
+  /* open hal module */
+  retCode = pHalFunc->Open(pHalDev);
+  if (retCode != 0) /* error */
+  {
+     printk("pHalFunc->open failed, err code: %d\n",retCode ); 
+     return (1);
+  }
+
+  /* init sar for firmware oam */
+  oamMod= 1;
+  pHalFunc->Control(pHalDev,"OamMode", "Set", &oamMod);
+
+  /* read in oam lb timeout value */
+  pLbTimeout = prom_getenv("oam_lb_timeout");
+  if(pLbTimeout)
+  {
+    lbTimeout =tn7sar_strtoul(pLbTimeout, NULL, 10);
+    oamLbTimeout = lbTimeout;
+    pHalFunc->Control(pHalDev,"OamLbTimeout", "Set", &lbTimeout);
+  }
+  else
+  {
+    oamLbTimeout = 5000;
+  }
+
+  oamFarLBCount[0]=0;
+  oamFarLBCount[1]=0;
+  oamFarLBCount[2]=0;
+  oamFarLBCount[3]=0;
+
+  memset(&sarStat, 0 , sizeof(sarStat));
+
+  /* setup channel 15 for oam operation */
+  tn7sar_setup_oam_channel(priv);
+  dprintf(4, "tn7sar_init done");
+  return 0;
+}
+
+static int
+tn7sar_atm_header(int vpi, int vci)
+{
+  union
+  {
+    unsigned char byte[4];
+    unsigned int  dword;
+  }atm_h;
+  int itmp = 0;
+
+  //vci 
+  itmp = vci &0xf;
+  atm_h.byte[0] = 0;
+  atm_h.byte[0] |= (itmp << 4);
+  atm_h.byte[1] = ((vci & 0xff0) >> 4);
+  atm_h.byte[2] = 0;
+  atm_h.byte[2] |= ((vci & 0xf000) >>12);;
+  atm_h.byte[2] |= ((vpi & 0xf) << 4);
+  atm_h.byte[3] = 0;
+  atm_h.byte[3] = ((vpi & 0xff0) >> 4);
+  return atm_h.dword;
+}
+
+int tn7sar_activate_vc(Tn7AtmPrivate *priv, short vpi, int vci, int pcr, int scr, int mbs, int cdvt, int chan, int qos)
+{
+  CHANNEL_INFO chInfo;
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+  
+  dprintf(4, "tn7sar_activate_vc\n");
+
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+
+  memset(&chInfo, 0xff, sizeof(chInfo));
+
+  /* channel specific */
+  chInfo.Channel = chan;
+  chInfo.Direction = 0;
+  chInfo.Vci = vci;
+  chInfo.Vpi = vpi;
+  chInfo.TxVc_QosType = qos;
+  chInfo.Priority = qos;
+  
+  if(chInfo.TxVc_QosType == 1) /* if the connection is VBR than set the DaMask value to tell the schedular to accumalte the credit */
+  {
+    chInfo.DaMask = 1;
+  }  
+  chInfo.TxVc_Mbs = mbs; /* use pcr as MBS */
+  pcr = SAR_FREQUNCY/pcr;
+  scr = SAR_FREQUNCY/scr;
+  chInfo.TxVc_CellRate = scr;
+  chInfo.TxVc_Pcr = pcr;
+
+  /*default */
+  chInfo.PktType      = PACKET_TYPE_AAL5;
+  chInfo.TxServiceMax = TX_SERVICE_MAX;
+  chInfo.RxServiceMax = RX_SERVICE_MAX;
+  chInfo.TxNumQueues  = TX_QUEUE_NUM;
+  chInfo.TxNumBuffers = TX_BUFFER_NUM;
+  chInfo.RxNumBuffers = RX_BUFFER_NUM;
+  chInfo.RxBufSize    = RX_BUFFER_SIZE;
+  chInfo.RxVc_OamToHost = 0;
+  chInfo.RxVp_OamToHost = 0;
+  chInfo.TxVc_AtmHeader = tn7sar_atm_header((int)vpi, vci);
+  chInfo.RxVc_AtmHeader = tn7sar_atm_header((int)vpi, vci);
+  chInfo.TxVp_AtmHeader = tn7sar_atm_header((int)vpi, 0);
+  chInfo.RxVp_AtmHeader = tn7sar_atm_header((int)vpi, 0);
+  chInfo.CpcsUU = 0;
+
+  dprintf(4, "TxVc_AtmHeader=0x%x\n", chInfo.TxVc_AtmHeader);
+
+  if(pHalFunc->ChannelSetup(pHalDev, &chInfo, NULL))
+  {
+    printk("failed to setup channel =%d.\n", chan);
+    return -1;
+  }
+ 
+
+  return 0;
+}
+
+int tn7sar_send_packet(Tn7AtmPrivate *priv, int chan, void *new_skb, void *data,unsigned int len, int priority)
+{
+  FRAGLIST fragList;
+  unsigned int mode;
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+
+  dprintf(4, "tn7sar_send_packet\n");
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+
+  fragList.len = len;
+  fragList.data = (void *)data;
+
+  xdump((char *)fragList.data , fragList.len, 6);
+
+  /*mode bit 
+  31-19 unused
+  18    oam cell, 1 = true, 0=false
+  17-16 oam type, 0=F4 seg, 1=F4 End, 2=F5 seg, 3=F5 end
+  15-08 transimit queue, current, 0=priority queue, 1=normal queue
+  07-00 channel number
+  */
+  mode = 0;
+  mode |= (0xff & chan);
+  mode |= ((0xff & priority) << 8);
+  
+  dprintf(4, "mode = %d\n", mode);
+
+  tn7sar_data_writeback(fragList.data, len);
+  if(pHalFunc->Send(pHalDev, &fragList, 1, len, new_skb, mode) != 0)
+  {
+    dprintf(1, "SAR hal failed to send packet.\n");
+    return 1;
+  }
+  //tn7sar_get_stats(priv);
+  sarStat.txPktCnt++;
+  sarStat.txBytes +=len;
+  return 0;
+}
+
+
+
+int tn7sar_handle_interrupt(struct atm_dev *dev, Tn7AtmPrivate *priv)
+{
+  int more;
+  int rc;
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+  int (*halIsr)(HAL_DEVICE *halDev, int *work);
+
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+  halIsr = priv->halIsr;
+
+  rc = halIsr(pHalDev, &more);
+  
+  pHalFunc->PacketProcessEnd(pHalDev);
+
+  return rc;
+}
+
+
+int tn7sar_deactivate_vc(Tn7AtmPrivate *priv, int chan)
+{
+  unsigned int mode;
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+
+  dprintf(4, "tn7sar_deactivate_vc\n");
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+
+  mode = 0xf; //tear down everything, wait for return;
+
+  pHalFunc->ChannelTeardown(pHalDev, chan, mode);
+  return 0;
+}
+
+void tn7sar_exit(struct atm_dev *dev, Tn7AtmPrivate *priv)
+{
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+
+  dprintf(4, "tn7sar_exit()\n");
+
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+  
+  tn7sar_deactivate_vc(priv, 15); // de-activate oam channel
+
+  pHalFunc->Close(pHalDev, 2);
+  pHalFunc->Shutdown(pHalDev);
+
+  kfree(priv->pSarOsFunc);
+  
+}
+
+void tn7sar_get_sar_version(Tn7AtmPrivate *priv, char **pVer)
+{
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+
+  dprintf(4, "tn7sar_get_sar_version()\n");
+
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+  pHalFunc->Control(pHalDev, "Version", "Get", pVer);
+}
+
+
+int tn7sar_get_near_end_loopback_count(unsigned int *pF4count, unsigned int *pF5count)
+{
+  unsigned int f4c, f5c;
+
+  f4c = *(volatile unsigned int *)SAR_PDSP_OAM_F4LB_COUNT_REG_ADDR;
+  f5c = *(volatile unsigned int *)SAR_PDSP_OAM_F5LB_COUNT_REG_ADDR;
+  *pF4count = f4c;
+  *pF5count = f5c;
+
+  return 0;
+}
+
+
+int tn7sar_unmatched_oam_generation(void *privContext, int vpi, int vci, int type)
+{
+
+  unsigned int regv = 0;
+  int chan=15;
+  static unsigned int tag;
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+  Tn7AtmPrivate *priv;
+  unsigned int llid[4]={0xffffffff,0xffffffff,0xffffffff,0xffffffff};
+
+  dprintf(4, "tn7sar_unknow_oam_generation()\n");
+ 
+  priv = (Tn7AtmPrivate *)privContext;
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+
+  if(vci==0)
+  {
+    oamPingStatus = OAM_PING_FAILED;
+    return 0;
+  }
+  /* calculate atm header */
+  oamAtmHdr = tn7sar_atm_header(vpi,vci);
+
+  /* config the atm header */
+  pHalFunc->Control(pHalDev,"TxVc_AtmHeader.15", "Set", &oamAtmHdr);
+
+  /*record oam type */
+  oam_type = type;
+
+  regv = (0xff & chan);
+  
+  switch(type)
+  {
+    case 0:
+      regv |= (1<<12); //f5 end 
+      dprintf(2, "f5 loop back\n");
+      break;
+    case 1:
+      regv |= (1<<13); // f4 end
+      break;
+    case 2:
+      regv |= (1<<14); //f5 seg
+      break;
+    case 3:
+      regv |= (1<<15); //f4 seg
+      break;
+    default:
+      break;
+  }
+  oamPingStatus = OAM_PING_PENDING;
+  pHalFunc->OamLoopbackConfig(pHalDev, regv, llid, tag);
+  tag++;
+  return 0;
+
+}
+
+int tn7sar_oam_generation(void *privContext, int chan, int type, int vpi, int vci, int timeout)
+{
+  unsigned int regv = 0;
+  static unsigned int tag;
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+  Tn7AtmPrivate *priv;
+  unsigned int llid[4]={0xffffffff,0xffffffff,0xffffffff,0xffffffff};
+
+  dprintf(2, "tn7sar_oam_generation()\n");
+
+  priv = (Tn7AtmPrivate *)privContext;
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+
+  if(timeout >= 5000)
+  {
+    if(timeout == 6000)
+    {
+      tn7sar_clear_pvc_table();
+      return 0;
+    }
+    timeout = oamLbTimeout;
+  }
+
+
+  pHalFunc->Control(pHalDev,"OamLbTimeout", "Set", &timeout);
+
+  if(chan == ATM_NO_DMA_CHAN)
+  {
+    tn7sar_unmatched_oam_generation(priv, vpi, vci, type);
+    return 0;
+  }
+
+  /* calculate atm header */
+  oamAtmHdr = tn7sar_atm_header(vpi,vci);
+  
+  oam_type = type;
+
+  regv = (0xff & chan);
+  switch(type)
+  {
+    case 0:
+      regv |= (1<<12); //f5 end 
+      dprintf(2, "f5 loop back\n");
+      break;
+    case 1:
+      regv |= (1<<13); // f4 end
+      break;
+    case 2:
+      regv |= (1<<14); //f5 seg
+      break;
+    case 3:
+      regv |= (1<<15); //f4 seg
+      break;
+    default:
+      break;
+  }
+  oamPingStatus = OAM_PING_PENDING;
+  pHalFunc->OamLoopbackConfig(pHalDev, regv, llid, tag);
+  tag++;
+
+  return 0;
+}
+
+int tn7sar_proc_oam_ping(char* buf, char **start, off_t offset, int count,int *eof, void *data)
+{
+  int len = 0;
+
+  len += sprintf(buf+len, "%d\n", oamPingStatus);
+
+  return len;
+}
+
+int tn7sar_proc_pvc_table(char* buf, char **start, off_t offset, int count,int *eof, void *data)
+{
+  int len = 0;
+  int i;
+ 
+  for(i=0;i<16;i++)
+  {
+    if(pvc_result[i].bInUse)
+    {
+      len += sprintf(buf+len, "%d,%d\n", pvc_result[i].vpi,pvc_result[i].vci);
+    }
+    else
+    {
+      len += sprintf(buf+len, "0,0\n");
+    }
+  }
+  return len;
+}
+
+ 
+
+int tn7sar_proc_sar_stat(char* buf, char **start, off_t offset, int count,int *eof, void *data)
+{
+  int len = 0;
+  int limit = count - 80;
+  struct atm_dev *dev;
+  Tn7AtmPrivate *priv;
+  int i, j, k;
+  int stat_len;
+  char statString[32];
+  unsigned int *pStateBase, *pSarStat;
+  HAL_FUNCTIONS *pHalFunc;
+  HAL_DEVICE    *pHalDev;
+  int dBytes;
+
+  dev = (struct atm_dev *)data;
+  priv = (Tn7AtmPrivate *)dev->dev_data;
+
+  pHalFunc = (HAL_FUNCTIONS *)priv->pSarHalFunc;
+  pHalDev  = (HAL_DEVICE *)priv->pSarHalDev;
+
+  len += sprintf(buf+len, "SAR HAL Statistics\n");
+  for(i=0;i<MAX_DMA_CHAN;i++)
+  {
+    if(priv->lut[i].inuse)
+    {
+      if(len<=limit)
+      len += sprintf(buf+len, "\nChannel %d:\n",priv->lut[i].chanid);
+      k=0;
+      for(j=0;j<4;j++)
+      {
+        stat_len =sprintf(statString, "Stats;%d;%d", j,priv->lut[i].chanid);
+        statString[stat_len]=0;
+        pHalFunc->Control(pHalDev, statString, "Get", &pSarStat);
+        pStateBase = pSarStat;
+        while(pSarStat)
+        {          
+          if((char *)*pSarStat == NULL)
+            break;
+          if(len<=limit)
+          {
+            dBytes = sprintf(buf+len, "%s: ",(char *) *pSarStat);
+            len += dBytes;
+            k += dBytes;
+          }
+          pSarStat++;
+          if(len<=limit)
+          {
+            dBytes = sprintf(buf+len, "%s;  ",(char *) *pSarStat);
+            len += dBytes;
+            k += dBytes;
+          }
+          pSarStat++;
+          
+          if(k > 60)
+          {
+            k=0;
+            if(len<=limit)
+            len += sprintf(buf+len, "\n");
+          }
+        }
+          
+        kfree(pStateBase);
+      }
+    }
+  }
+ 
+  return len;
+}
+
+void tn7sar_get_sar_firmware_version(unsigned int *pdsp_version_ms, unsigned int *pdsp_version_ls)
+{
+
+  *pdsp_version_ms = (SarPdspFirmware[9]>>20) & 0xF;
+  *pdsp_version_ls = (SarPdspFirmware[9]>>12) & 0xFF;
+  return;
+}
diff -urN linux.old/drivers/atm/sangam_atm/tnetd7300_sar_firm.h linux.dev/drivers/atm/sangam_atm/tnetd7300_sar_firm.h
--- linux.old/drivers/atm/sangam_atm/tnetd7300_sar_firm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/tnetd7300_sar_firm.h	2005-08-23 04:46:50.111841568 +0200
@@ -0,0 +1,988 @@
+//SarPdspFirmware Revision:  49
+
+static int SarPdspFirmware[] = {
+                             0xb0a8d1f1,
+                             0x000003d8,
+                             0x00000000,
+                             0x00000004,
+                             0x00000000,
+                             0x00000000,
+                             0x00000000,
+                             0x00000000,
+                             0x21000900,
+                             0x24049080,
+                             0x24000080,
+                             0x240000c0,
+                             0x10e0e0e1,
+                             0x10e0e0e2,
+                             0x10e0e0e3,
+                             0x10e0e0e4,
+                             0x10e0e0e5,
+                             0x10e0e0e6,
+                             0x10e0e0e7,
+                             0x10e0e0e8,
+                             0x10e0e0e9,
+                             0x10e0e0ea,
+                             0x10e0e0eb,
+                             0x10e0e0ec,
+                             0x10e0e0ed,
+                             0x10e0e0ee,
+                             0x10e0e0ef,
+                             0x10e0e0f0,
+                             0x10e0e0f1,
+                             0x10e0e0f2,
+                             0x10e0e0f3,
+                             0x10e0e0f4,
+                             0x10e0e0f5,
+                             0x10e0e0f6,
+                             0x10e0e0f7,
+                             0x10e0e0f8,
+                             0x10e0e0f9,
+                             0x10e0e0fa,
+                             0x10e0e0fb,
+                             0x10e0e0fc,
+                             0x10e0e0fd,
+                             0x10e0e0fe,
+                             0x10e0e0ff,
+                             0x81042680,
+                             0x810c2680,
+                             0x81042680,
+                             0x2483c080,
+                             0x81180b80,
+                             0x2484c080,
+                             0x811a0b80,
+                             0x2485c080,
+                             0x811c0b80,
+                             0x240100dd,
+                             0xa07d06fd,
+                             0x240400dd,
+                             0xa07d04fd,
+                             0x24c000dd,
+                             0x2400169d,
+                             0xa07d5cfd,
+                             0x511f9d03,
+                             0x01019d9d,
+                             0x7f0000fd,
+                             0xd11eff05,
+                             0x97c06890,
+                             0x1d00e5e5,
+                             0x2301229e,
+                             0x81bc2890,
+                             0x24000000,
+                             0xc917ff02,
+                             0x81000100,
+                             0x01010000,
+                             0xc918ff02,
+                             0x81000100,
+                             0x01010000,
+                             0xc919ff02,
+                             0x81000100,
+                             0xd110e70a,
+                             0xd11cff09,
+                             0x1d00e5e5,
+                             0xd100e704,
+                             0xd114ff06,
+                             0x2301179e,
+                             0x79000004,
+                             0xd70ffffd,
+                             0x91382486,
+                             0x2301059e,
+                             0xc903ff07,
+                             0xa06047e0,
+                             0xb10043e6,
+                             0xc910e602,
+                             0x81000106,
+                             0x24006025,
+                             0x2300d39e,
+                             0xd11dff09,
+                             0x1f00e5e5,
+                             0xc901e705,
+                             0xd111ff06,
+                             0x91382586,
+                             0x2301059e,
+                             0x79000003,
+                             0xd715fffc,
+                             0x2301179e,
+                             0xc910e706,
+                             0x110f2760,
+                             0x240000c6,
+                             0x24000086,
+                             0x13106006,
+                             0x7b00005a,
+                             0x11079f80,
+                             0x51008010,
+                             0xc912ff0f,
+                             0xd100ff04,
+                             0xd101ff05,
+                             0xa06046e0,
+                             0x79000004,
+                             0xa06044e0,
+                             0x79000002,
+                             0xa06045e0,
+                             0xb10043e6,
+                             0x61150602,
+                             0x2101c500,
+                             0xc910e602,
+                             0xa1001006,
+                             0x24000025,
+                             0x2300d39e,
+                             0xd11fff05,
+                             0x97c06a90,
+                             0x1f00e5e5,
+                             0x2301229e,
+                             0x81bc2a90,
+                             0xd11cff09,
+                             0x1d00e5e5,
+                             0xc900e705,
+                             0xd10fff06,
+                             0x91382486,
+                             0x2301059e,
+                             0x79000003,
+                             0xd714fffc,
+                             0x2301179e,
+                             0xc907ff07,
+                             0xa0604be0,
+                             0xb10043e6,
+                             0xc910e602,
+                             0x81000106,
+                             0x24006025,
+                             0x2300d39e,
+                             0xd111e70a,
+                             0xd11dff09,
+                             0x1f00e5e5,
+                             0xd101e704,
+                             0xd115ff06,
+                             0x2301179e,
+                             0x79000004,
+                             0xd711fffd,
+                             0x91382586,
+                             0x2301059e,
+                             0xc911e706,
+                             0x0b042760,
+                             0x240000c6,
+                             0x24000086,
+                             0x13106006,
+                             0x7b000024,
+                             0x11709f80,
+                             0x5100800e,
+                             0xc913ff0d,
+                             0xd104ff04,
+                             0xd105ff05,
+                             0xa0604ae0,
+                             0x79000004,
+                             0xa06048e0,
+                             0x79000002,
+                             0xa06049e0,
+                             0xb10043e6,
+                             0xc910e602,
+                             0xa1001106,
+                             0x24000025,
+                             0x2300d39e,
+                             0xc90bff02,
+                             0x7900000b,
+                             0xc90aff02,
+                             0x79000012,
+                             0xcf08ff89,
+                             0xb10002e0,
+                             0xcf18e087,
+                             0x790000b6,
+                             0x24000080,
+                             0x24fb00c0,
+                             0xa06003e0,
+                             0x7f000082,
+                             0xb10024e6,
+                             0xb10025e0,
+                             0xa06628e6,
+                             0xa06029e0,
+                             0x248000c6,
+                             0xa06624e6,
+                             0x671006f0,
+                             0x81082186,
+                             0x7f0000ee,
+                             0xb10027e6,
+                             0x61100604,
+                             0xa0662be6,
+                             0x810c2186,
+                             0x79000006,
+                             0xd70cffea,
+                             0xa0662be6,
+                             0x1f1be6e6,
+                             0x81382686,
+                             0x813c2680,
+                             0x248000c6,
+                             0xa06627e6,
+                             0x7f0000e3,
+                             0x110f0600,
+                             0x81100b00,
+                             0x01502545,
+                             0x90457888,
+                             0x5103091c,
+                             0x6901092a,
+                             0xc910e603,
+                             0xd108e90d,
+                             0x79000027,
+                             0x01582545,
+                             0x9045788a,
+                             0xd108e904,
+                             0x1f08e9e9,
+                             0x01552545,
+                             0x80451829,
+                             0x50eaeb20,
+                             0x0101ebeb,
+                             0x015c2545,
+                             0x8045388b,
+                             0x7900001c,
+                             0x015c2545,
+                             0x9045788b,
+                             0x6900eb05,
+                             0x1d08e9e9,
+                             0x01552545,
+                             0x80451829,
+                             0x79000004,
+                             0x0501ebeb,
+                             0x015c2545,
+                             0x8045388b,
+                             0x10ecece8,
+                             0x79000010,
+                             0x24000000,
+                             0x5110000e,
+                             0x690f6903,
+                             0x24000069,
+                             0x79000002,
+                             0x01016969,
+                             0x01010000,
+                             0x81100b69,
+                             0x01542545,
+                             0x90451809,
+                             0x6f0209f7,
+                             0xa1001069,
+                             0x81100b06,
+                             0x01572545,
+                             0x80451869,
+                             0xa06841e8,
+                             0xa1414006,
+                             0x209e0000,
+                             0x81100b06,
+                             0xd11fe603,
+                             0x9164388d,
+                             0x8108248d,
+                             0xd100e507,
+                             0x97406490,
+                             0x9108248d,
+                             0x813c2480,
+                             0x2302b4de,
+                             0x1d00e7e7,
+                             0x79000006,
+                             0x97406590,
+                             0x9108258d,
+                             0x813c2580,
+                             0x1d01e7e7,
+                             0x2302b9de,
+                             0x8164388d,
+                             0x209e0000,
+                             0x81040105,
+                             0x91002286,
+                             0x97086290,
+                             0x81042280,
+                             0xd100e504,
+                             0x2302b4de,
+                             0x1f00e7e7,
+                             0x209e0000,
+                             0x2302b9de,
+                             0x1f01e7e7,
+                             0x209e0000,
+                             0xd109ff00,
+                             0xa0702cf0,
+                             0x79000001,
+                             0xd109ff00,
+                             0xb1002de6,
+                             0xd11ee609,
+                             0xb1000de0,
+                             0xc91fe044,
+                             0x24c338c6,
+                             0x10000006,
+                             0x81382686,
+                             0x87406690,
+                             0x813c2680,
+                             0x7900003e,
+                             0x110f0600,
+                             0x81100b00,
+                             0x24000045,
+                             0x24000025,
+                             0x61100603,
+                             0x24006045,
+                             0x24006025,
+                             0x01704545,
+                             0x90451888,
+                             0x0b034600,
+                             0x11070000,
+                             0x69040004,
+                             0xc916ff2c,
+                             0x01019e9e,
+                             0x7900002f,
+                             0xc90cff04,
+                             0x6f0200fd,
+                             0xd308e8a1,
+                             0x7f0000fb,
+                             0x69020008,
+                             0xd308e89e,
+                             0xb1002fe6,
+                             0x91b82880,
+                             0xc91ce002,
+                             0x1f1ce6e6,
+                             0x10080806,
+                             0x79000015,
+                             0xb1002fe6,
+                             0x69030003,
+                             0x13c06666,
+                             0x79000011,
+                             0x91807809,
+                             0xc910ea09,
+                             0x81082689,
+                             0x01018a8a,
+                             0xc91ee60a,
+                             0x1d10eaea,
+                             0x240557c0,
+                             0x60c08a07,
+                             0x1f1de6e6,
+                             0x79000005,
+                             0x2400018a,
+                             0x1f10eaea,
+                             0x1f1fe6e6,
+                             0xd71ee6f8,
+                             0x51000002,
+                             0x11c76666,
+                             0x81382686,
+                             0x87406690,
+                             0x91082689,
+                             0x813c2680,
+                             0xb1002ee6,
+                             0xd103e609,
+                             0x81807809,
+                             0xc908e807,
+                             0x21039400,
+                             0x81002386,
+                             0x87086390,
+                             0x81042380,
+                             0xc908e802,
+                             0x21039400,
+                             0x209e0000,
+                             0xb10008ef,
+                             0x110f0f00,
+                             0x81100b00,
+                             0x24000025,
+                             0x61100f02,
+                             0x24005025,
+                             0x01952545,
+                             0x9045382e,
+                             0xc91def03,
+                             0x24000900,
+                             0x2301c09e,
+                             0xc91cef03,
+                             0x24001900,
+                             0x2301c09e,
+                             0xc91bef03,
+                             0x24000a00,
+                             0x2301c09e,
+                             0xc91aef03,
+                             0x24001a00,
+                             0x2301c09e,
+                             0x8045382e,
+                             0x01a82545,
+                             0x9045388e,
+                             0xc915ef03,
+                             0x24000000,
+                             0x2301c09e,
+                             0xc914ef03,
+                             0x24001000,
+                             0x2301c09e,
+                             0x8045388e,
+                             0x61100f02,
+                             0x24006025,
+                             0x016d2545,
+                             0x9045382e,
+                             0xc919ef03,
+                             0x24000900,
+                             0x2301c09e,
+                             0xc918ef03,
+                             0x24001900,
+                             0x2301c09e,
+                             0xc917ef03,
+                             0x24000a00,
+                             0x2301c09e,
+                             0xc916ef03,
+                             0x24001a00,
+                             0x2301c09e,
+                             0x8045382e,
+                             0x017c2545,
+                             0x9045388e,
+                             0xc913ef03,
+                             0x24000000,
+                             0x2301c09e,
+                             0xc912ef03,
+                             0x24001000,
+                             0x2301c09e,
+                             0x8045388e,
+                             0xd11eef19,
+                             0x11f02f00,
+                             0x51000017,
+                             0x24001520,
+                             0x81140b20,
+                             0x81b01a0f,
+                             0x1f02e7e7,
+                             0x24c000c0,
+                             0x24001580,
+                             0xa0605ce0,
+                             0xc90fef04,
+                             0x1d04e7e7,
+                             0x1d05e7e7,
+                             0x7900000c,
+                             0xc90eef04,
+                             0x1d04e7e7,
+                             0x1f05e7e7,
+                             0x79000008,
+                             0xc90def04,
+                             0x1f04e7e7,
+                             0x1d05e7e7,
+                             0x79000004,
+                             0xc90cef03,
+                             0x1f04e7e7,
+                             0x1f05e7e7,
+                             0x2100b900,
+                             0xd11eef03,
+                             0x1e00eeee,
+                             0x209e0000,
+                             0x1c00eeee,
+                             0x209e0000,
+                             0x110f0606,
+                             0x81140b06,
+                             0x13100606,
+                             0x91b01a83,
+                             0x24000025,
+                             0x61100304,
+                             0x24005025,
+                             0xc905e702,
+                             0x24006025,
+                             0x110f0300,
+                             0x81100b00,
+                             0x81120b00,
+                             0x51150611,
+                             0x61100302,
+                             0x24005025,
+                             0x1d01e5e5,
+                             0x51160639,
+                             0x511a0650,
+                             0x511c0657,
+                             0x5118065e,
+                             0x511e0685,
+                             0x61100302,
+                             0x24006025,
+                             0x1f01e5e5,
+                             0x51170634,
+                             0x511b064b,
+                             0x511d0652,
+                             0x51190658,
+                             0x511f067f,
+                             0xc903e708,
+                             0x1d03e7e7,
+                             0x24000060,
+                             0xa1000a60,
+                             0x244000c0,
+                             0x24001580,
+                             0xa0605ce0,
+                             0x21007d00,
+                             0xcf02e7fc,
+                             0x1d02e7e7,
+                             0x1f03e7e7,
+                             0xc904e703,
+                             0x1f08e3e3,
+                             0x79000002,
+                             0x1d08e3e3,
+                             0xc905e705,
+                             0x01682545,
+                             0x9045588d,
+                             0x2302879e,
+                             0x79000004,
+                             0x01902545,
+                             0x9045588d,
+                             0x2302819e,
+                             0x24001872,
+                             0x24000152,
+                             0xb10009e0,
+                             0x108080d3,
+                             0x10c0c092,
+                             0x2400102c,
+                             0x2302c8de,
+                             0x91021c97,
+                             0x91001cd8,
+                             0x91061c98,
+                             0x91041cd9,
+                             0x910a1c99,
+                             0x91081cda,
+                             0x910e1c9a,
+                             0x910c1cdb,
+                             0x91261d9b,
+                             0x91287d9c,
+                             0x23028dde,
+                             0x1f02e7e7,
+                             0x1d03e7e7,
+                             0x7d000070,
+                             0x01902545,
+                             0x9045798d,
+                             0x79000003,
+                             0x01682545,
+                             0x9045788d,
+                             0x0b09eee0,
+                             0x24001472,
+                             0xd108e303,
+                             0xc900e00b,
+                             0x79000002,
+                             0xc910e009,
+                             0xd101e503,
+                             0x2302819e,
+                             0x79000002,
+                             0x2302879e,
+                             0x91013d12,
+                             0x9504bd93,
+                             0x23028dde,
+                             0x7d00005d,
+                             0xd108ee03,
+                             0x1d10e7e7,
+                             0x7900009a,
+                             0x1d11e7e7,
+                             0x79000098,
+                             0x01902545,
+                             0x9045798d,
+                             0x79000003,
+                             0x01682545,
+                             0x9045788d,
+                             0x0b0aeee0,
+                             0x24001072,
+                             0x7f0000e8,
+                             0x01a02545,
+                             0x9045b98d,
+                             0x79000003,
+                             0x01742545,
+                             0x9045b88d,
+                             0x0b01efe0,
+                             0x24001172,
+                             0x7f0000e0,
+                             0x2302d1de,
+                             0x79000002,
+                             0x2302d6de,
+                             0x000c2545,
+                             0x9045198f,
+                             0xd100ef07,
+                             0x1d02efef,
+                             0xc901ef0c,
+                             0xc905ef0b,
+                             0x1d01efef,
+                             0x1d05efef,
+                             0x79000008,
+                             0xd102ef04,
+                             0x1f02efef,
+                             0x8045198f,
+                             0x79000078,
+                             0xd101ef04,
+                             0x1f01efef,
+                             0x1f05efef,
+                             0x8045198f,
+                             0x69180673,
+                             0x01ac2545,
+                             0x2302dbde,
+                             0xd100ef03,
+                             0x23036c9e,
+                             0x7900006e,
+                             0xc800e40b,
+                             0x110f0020,
+                             0x81100b20,
+                             0x100c0c45,
+                             0x61100002,
+                             0x01604545,
+                             0x9045188f,
+                             0xd101ef04,
+                             0x1f01efef,
+                             0x1f07efef,
+                             0x8045188f,
+                             0x01010000,
+                             0x6f1300f4,
+                             0x79000060,
+                             0x2302d1de,
+                             0x79000002,
+                             0x2302d6de,
+                             0x000c2545,
+                             0x9045198f,
+                             0xc903ef05,
+                             0x1d03efef,
+                             0x1f04efef,
+                             0x8045198f,
+                             0x79000056,
+                             0xc904ef55,
+                             0x1d04efef,
+                             0xc901ef04,
+                             0xc906ef03,
+                             0x1d01efef,
+                             0x1d06efef,
+                             0x8045198f,
+                             0x691e064e,
+                             0x01ac2545,
+                             0x2302dbde,
+                             0xc800e40c,
+                             0x110f0020,
+                             0x81100b20,
+                             0x100c0c45,
+                             0x61100002,
+                             0x01604545,
+                             0x9045188f,
+                             0xc901ef05,
+                             0xc908ef04,
+                             0x1d01efef,
+                             0x1d07efef,
+                             0x8045188f,
+                             0x01010000,
+                             0x6f1300f3,
+                             0x7900003d,
+                             0x10ededf0,
+                             0xc908e303,
+                             0x13401010,
+                             0x209e0000,
+                             0x13301010,
+                             0x209e0000,
+                             0x10ededf0,
+                             0xc908e303,
+                             0x130a1010,
+                             0x209e0000,
+                             0x13081010,
+                             0x209e0000,
+                             0x24000266,
+                             0x2400c800,
+                             0x24000020,
+                             0xd108ee17,
+                             0x01012020,
+                             0xc91cff09,
+                             0x6e0020fe,
+                             0xc910e702,
+                             0x20de0000,
+                             0x1f10e7e7,
+                             0x110f0600,
+                             0x11f02727,
+                             0x12002727,
+                             0x20de0000,
+                             0x1d10e7e7,
+                             0x2302b4de,
+                             0x511d0605,
+                             0x511c0602,
+                             0x7900001e,
+                             0x01a62545,
+                             0x79000002,
+                             0x01722545,
+                             0x90451880,
+                             0x01018080,
+                             0x80451880,
+                             0x79000017,
+                             0x01012020,
+                             0xc91dff09,
+                             0x6e0020fe,
+                             0xc911e702,
+                             0x20de0000,
+                             0x1f11e7e7,
+                             0x09040600,
+                             0x110f2727,
+                             0x12002727,
+                             0x20de0000,
+                             0x1d11e7e7,
+                             0x2302b9de,
+                             0x7f0000ea,
+                             0x81b82786,
+                             0x240000d1,
+                             0x87c06790,
+                             0x81bc2780,
+                             0x20de0000,
+                             0x81b82986,
+                             0x87c06990,
+                             0x81bc2980,
+                             0x20de0000,
+                             0x91b43a88,
+                             0x2301029e,
+                             0x51150608,
+                             0xc908e305,
+                             0x51120303,
+                             0x01010303,
+                             0x79000002,
+                             0x24000003,
+                             0x01012323,
+                             0x81b01a83,
+                             0x21007d00,
+                             0x902cfc88,
+                             0x10c8c893,
+                             0x108888d4,
+                             0x10c9c994,
+                             0x108989d5,
+                             0x10caca95,
+                             0x108a8ad6,
+                             0x10cbcb96,
+                             0x108b8bd7,
+                             0xd108e303,
+                             0x2400a80c,
+                             0x20de0000,
+                             0x2400aa0c,
+                             0x20de0000,
+                             0xd108e303,
+                             0x24007c0c,
+                             0x20de0000,
+                             0x24007e0c,
+                             0x20de0000,
+                             0x24000000,
+                             0x90453904,
+                             0xd108e303,
+                             0x24007c0c,
+                             0x20de0000,
+                             0x24007e0c,
+                             0x20de0000,
+                             0xb1002fe6,
+                             0x91b82880,
+                             0xc91ce002,
+                             0x209e0000,
+                             0xb1002ee6,
+                             0x69187279,
+                             0xd110f230,
+                             0xc903e769,
+                             0xc90be604,
+                             0xc904e767,
+                             0xd105e766,
+                             0x7900000c,
+                             0xc90ae604,
+                             0xd104e763,
+                             0xd105e762,
+                             0x79000008,
+                             0xc907e604,
+                             0xc904e75f,
+                             0xc905e75e,
+                             0x79000004,
+                             0xc906e65c,
+                             0xd104e75b,
+                             0xc905e75a,
+                             0x91003c80,
+                             0x6897c058,
+                             0x68d88057,
+                             0x91043c80,
+                             0x6898c055,
+                             0x68d98054,
+                             0x91083c80,
+                             0x6899c052,
+                             0x68da8051,
+                             0x910c3c80,
+                             0x689ac04f,
+                             0x68db804e,
+                             0xb10009e0,
+                             0x6892c04c,
+                             0x68d3804b,
+                             0x24000160,
+                             0xa1000a60,
+                             0x244000c0,
+                             0x24001580,
+                             0xa0605ce0,
+                             0x1d03e7e7,
+                             0x109393c8,
+                             0x10d4d488,
+                             0x109494c9,
+                             0x10d5d589,
+                             0x109595ca,
+                             0x10d6d68a,
+                             0x109696cb,
+                             0x10d7d78b,
+                             0x8110fc88,
+                             0x209e0000,
+                             0x91003c80,
+                             0x6893c00c,
+                             0x68d4800b,
+                             0x91043c80,
+                             0x6894c009,
+                             0x68d58008,
+                             0x91083c80,
+                             0x6895c006,
+                             0x68d68005,
+                             0x910c3c80,
+                             0x6896c003,
+                             0x68d78002,
+                             0x79000010,
+                             0x24ffff80,
+                             0x24ffffc0,
+                             0x68809306,
+                             0x68e0f405,
+                             0x68e0f504,
+                             0x68e0f603,
+                             0x6880d702,
+                             0x79000008,
+                             0x24000080,
+                             0x240000c0,
+                             0x68809323,
+                             0x68e0f422,
+                             0x68e0f521,
+                             0x68e0f620,
+                             0x6880d71f,
+                             0x1d10f2f2,
+                             0x2400002c,
+                             0x2302c8de,
+                             0x24000f80,
+                             0x240000c0,
+                             0x0101c0c0,
+                             0xd100e504,
+                             0xc91cff06,
+                             0x6e80c0fd,
+                             0x21016d00,
+                             0xc91dff03,
+                             0x6e80c0fa,
+                             0x21016d00,
+                             0xd104e606,
+                             0xc909e608,
+                             0xb1000ce0,
+                             0x0101e0e0,
+                             0xa0600ce0,
+                             0x79000004,
+                             0xb1000be0,
+                             0x0101e0e0,
+                             0xa0600be0,
+                             0xb1002fe6,
+                             0xd100e504,
+                             0x2302b4de,
+                             0x24000022,
+                             0x209e0000,
+                             0x2302b9de,
+                             0x24000042,
+                             0x209e0000,
+                             0xd104e609,
+                             0x01782545,
+                             0x9045180e,
+                             0x110f0e00,
+                             0x81100b00,
+                             0x2400a445,
+                             0x51002502,
+                             0x01504545,
+                             0x90451888,
+                             0xc909e87d,
+                             0xb1002fe6,
+                             0x1f1fe6e6,
+                             0x10080806,
+                             0x21015f00,
+                             0x6914721b,
+                             0x01782545,
+                             0x2303bade,
+                             0x900c188f,
+                             0x1d02efef,
+                             0xc901ef05,
+                             0xc905ef04,
+                             0x1d01efef,
+                             0x1d05efef,
+                             0x800c188f,
+                             0xc909e66e,
+                             0x2303d0de,
+                             0xc800e40c,
+                             0x110f0020,
+                             0x81100b20,
+                             0x100c0c45,
+                             0x61100002,
+                             0x01604545,
+                             0x9045188f,
+                             0xc901ef05,
+                             0xc907ef04,
+                             0x1d01efef,
+                             0x1d07efef,
+                             0x8045188f,
+                             0x01010000,
+                             0x6f1300f3,
+                             0x7900005e,
+                             0x6910725d,
+                             0x01782545,
+                             0x2303bade,
+                             0x900c188f,
+                             0x1f03efef,
+                             0xd101ef03,
+                             0x1f01efef,
+                             0x1f06efef,
+                             0x800c188f,
+                             0xc909e654,
+                             0x2303d0de,
+                             0xc800e40b,
+                             0x110f0020,
+                             0x81100b20,
+                             0x100c0c45,
+                             0x61100002,
+                             0x01604545,
+                             0x9045188f,
+                             0xd101ef04,
+                             0x1f01efef,
+                             0x1f08efef,
+                             0x8045188f,
+                             0x01010000,
+                             0x6f1300f4,
+                             0x79000045,
+                             0x01782545,
+                             0x9045788e,
+                             0x1d02efef,
+                             0x1d12efef,
+                             0xc905ef04,
+                             0x1d05efef,
+                             0x1d01efef,
+                             0x7900000c,
+                             0xc915ef04,
+                             0x1d15efef,
+                             0x1d11efef,
+                             0x79000008,
+                             0xc907ef04,
+                             0x1d07efef,
+                             0x1d01efef,
+                             0x79000004,
+                             0xc917ef03,
+                             0x1d17efef,
+                             0x1d11efef,
+                             0x017c2545,
+                             0x8045388f,
+                             0x110f0e00,
+                             0x81100b00,
+                             0x2400a845,
+                             0x51002502,
+                             0x01504545,
+                             0x9045388f,
+                             0x1d02efef,
+                             0x1d12efef,
+                             0xc905ef04,
+                             0x1d05efef,
+                             0x1d01efef,
+                             0x79000004,
+                             0xc915ef03,
+                             0x1d15efef,
+                             0x1d11efef,
+                             0x8045388f,
+                             0x7900001f,
+                             0xc909e60d,
+                             0x9045180e,
+                             0x110f0e00,
+                             0x81100b00,
+                             0xc90ae603,
+                             0x2400a80c,
+                             0x79000003,
+                             0xc90be617,
+                             0x2400aa0c,
+                             0x51002503,
+                             0x01500c0c,
+                             0x24005025,
+                             0x20de0000,
+                             0xc904e611,
+                             0xc906e603,
+                             0x24007c0c,
+                             0x79000003,
+                             0xc907e60d,
+                             0x24007e0c,
+                             0x51002502,
+                             0x01600c0c,
+                             0x20de0000,
+                             0x01ac2545,
+                             0x24000000,
+                             0x90453804,
+                             0xd10be603,
+                             0x24007c0c,
+                             0x20de0000,
+                             0x24007e0c,
+                             0x20de0000,
+                             0x209e0000};
diff -urN linux.old/drivers/atm/sangam_atm/turbodsl.c linux.dev/drivers/atm/sangam_atm/turbodsl.c
--- linux.old/drivers/atm/sangam_atm/turbodsl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/atm/sangam_atm/turbodsl.c	2005-08-23 04:46:50.111841568 +0200
@@ -0,0 +1,223 @@
+
+
+/*
+ *
+ *  Turbo DSL Implementaion
+ *
+ *  Zhicheng Tang   ztang@ti.com
+ *
+ *  2002 (c) Texas Instruments Inc.
+ *
+*/
+
+/* defines and variables */
+#define RFC2684_BRIDGED_HDR_SIZE 10
+unsigned char LLC_BRIDGED_HEADER_2684[RFC2684_BRIDGED_HDR_SIZE] =
+  {0xAA, 0xAA, 0x03, 0x00, 0x80, 0xC2, 0x00, 0x07, 0x00, 0x00};
+
+#define RFC2684_ROUTED_HDR_SIZE 6
+unsigned char LLC_ROUTED_HEADER_2684[6] ={0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
+
+unsigned long PPP_LLC_HEADER  = 0xCF03FEFE;
+
+/* struct definition */
+enum
+{  
+  AAL5_ENCAP_PPP_LLC,
+  AAL5_ENCAP_PPP_VCMUX,
+  AAL5_ENCAP_RFC2684_LLC_BRIDGED,
+  AAL5_ENCAP_RFC2684_LLC_ROUTED
+};
+
+/* Etherent header */
+typedef struct _turbodsl_ether_header 
+{
+        unsigned char dst_mac_addr[6];
+        unsigned char src_mac_addr[6];
+        unsigned short ether_type;
+} turbodsl_ether_header_t;
+
+
+/* Ip header define */
+typedef struct _turbodsl_ip_header
+{
+
+        unsigned short vit;
+        unsigned short total_length;
+        unsigned short ip_id;
+        unsigned char  flag;            /* bit 0 = 0, bit1 = don't fragment, bit2=more frag */
+  unsigned char  fragment_offset; /* offset include remaining 5 bits above, which make it 13 bits */
+        unsigned char  time_to_live;
+        unsigned char  protocol;
+        unsigned short checksum;
+        unsigned int  src_ip;
+        unsigned int  dst_ip;
+} turbodsl_ip_header_t;
+
+/* Arp packet define */
+typedef struct _turbodsl_arp_header
+{
+        unsigned short hardware_type;
+        unsigned short protocol_type;
+        unsigned char  h_len;
+        unsigned char  p_len;
+        unsigned short operation  ;
+        unsigned char  snd_hw_address[6];
+        unsigned char  snd_pt_address[4];
+        unsigned char  dst_hw_address[6];
+        unsigned char  dst_pt_address[4];
+} turbodsl_arp_header_t;
+
+#define FIN_FLAG 1
+#define SYN_FLAG 1<<1
+#define RST_FLAG 1<<2
+#define PSH_FLAG 1<<3
+#define ACK_FLAG 1<<4
+#define URG_FLAG 1<<5
+
+typedef struct _turbodsl_tcp_header
+{
+        unsigned short src_port;
+        unsigned short dst_port;
+        unsigned int seq_num;
+        unsigned int ack_num;
+  unsigned char  offset; /* only bits 4-7 are for offset */
+  unsigned char  flags;  /* bits: 0-FIN, 1-SYN, 2-RST, 3-PSH, 4-ACK, 5-URG */
+  unsigned short windows; 
+        unsigned short checksum;
+        unsigned short urgent_ptr;
+} turbodsl_tcp_header_t;
+ 
+
+
+/***************************************************************************
+ * Function: turbodsl_memory_compare
+ * Descripation: Memory compare
+ ****************************************************************************/
+int turbodsl_memory_compare(unsigned char *pIn, unsigned char *pOut, unsigned int len)
+  {
+  int i;
+  
+  for(i=0;i<(int)len; i++)
+    {
+    if(pIn[i] != pOut[i])
+      return 0;
+    }
+  return 1;
+  }
+
+/***************************************************************************
+ * Function: turbodsl_check_aal5_encap_type
+ * Descripation: Determine AAL5 Encapsulation type
+ * Input:
+ *        unsigned char *pData, AAL5 Packet buffer pointer
+ ****************************************************************************/
+int turbodsl_check_aal5_encap_type(unsigned char *pData)
+  {
+  
+  if(turbodsl_memory_compare(pData, LLC_BRIDGED_HEADER_2684, 6))
+    return AAL5_ENCAP_RFC2684_LLC_BRIDGED;
+  if(turbodsl_memory_compare(pData, LLC_ROUTED_HEADER_2684, 6))
+    return AAL5_ENCAP_RFC2684_LLC_ROUTED;
+  if(turbodsl_memory_compare(pData, (unsigned char *)&PPP_LLC_HEADER, sizeof(PPP_LLC_HEADER)))
+    return AAL5_ENCAP_PPP_LLC;
+ 
+  return AAL5_ENCAP_PPP_VCMUX;
+  }
+  
+/***************************************************************************
+ * Function: turbodsl_check_priority_type
+ * Descripation: Determine AAL5 Encapsulation type
+ * Input:
+ *        unsigned char *pData, AAL5 Packet buffer pointer.
+ *        short vpi, VPI.
+ *        int vci,  VCI
+ ****************************************************************************/
+int turbodsl_check_priority_type(unsigned char *pData)
+  {
+  int encap;
+  unsigned char *pP;
+  unsigned short etherType;
+  turbodsl_ip_header_t *pIp;
+  turbodsl_tcp_header_t *pTcp;
+  unsigned short ip_length;
+  
+  dprintf(2, "turbodsl_check_priority_type ==>\n");
+
+  encap = turbodsl_check_aal5_encap_type(pData);
+  pP = pData;
+
+  switch(encap)
+    {
+    case AAL5_ENCAP_RFC2684_LLC_BRIDGED:
+      pP += RFC2684_BRIDGED_HDR_SIZE; //skip off aal5 encap
+      pP += 12;               //skip of mac address
+      etherType = *(unsigned short *)pP;
+      if(etherType != 0x6488 && etherType != 0x0008)
+        {
+        //Not an IP packet
+        return 1;
+        }
+
+      pP +=2;                 //skip ether type
+      if(etherType == 0x6488)
+        {
+        pP += 6;
+        }
+      break;
+    case AAL5_ENCAP_RFC2684_LLC_ROUTED:
+      pP += RFC2684_ROUTED_HDR_SIZE; //skip of encap
+      pP += 2; //skip ether type
+      break;
+    case AAL5_ENCAP_PPP_LLC:
+      pP += sizeof(PPP_LLC_HEADER);
+      if(*pP == 0xff && *(pP+1) == 0x03) //ppp hdlc header
+        pP += 2;
+      break;
+    case AAL5_ENCAP_PPP_VCMUX:
+      if(*pP == 0xff && *(pP+1) == 0x03) //ppp hdlc header
+        pP += 2;
+      break;
+    default:
+      return 1;
+    }
+
+  pIp = (turbodsl_ip_header_t *)pP;
+  if(pIp->vit != 0x0045)
+    {
+    //Not a IP packet
+    return 1;
+    }
+
+  if(pIp->protocol != 0x06) 
+    {
+    //not tcp packet
+    return 1;
+    }
+  
+  pTcp = (turbodsl_tcp_header_t *)(pP + sizeof(turbodsl_ip_header_t));
+
+  ip_length = (pIp->total_length>>8) + (pIp->total_length<<8);
+  
+  if((pTcp->flags & ACK_FLAG) && ip_length <=40)
+    return 0;
+
+  return 1;
+  }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  
diff -urN linux.old/include/linux/atmdev.h linux.dev/include/linux/atmdev.h
--- linux.old/include/linux/atmdev.h	2005-08-22 23:18:37.812526104 +0200
+++ linux.dev/include/linux/atmdev.h	2005-08-23 06:33:33.425389944 +0200
@@ -30,6 +30,9 @@
 #define ATM_DS3_PCR	(8000*12)
 			/* DS3: 12 cells in a 125 usec time slot */
 
+#define ATM_PDU_OVHD	0	/* number of bytes to charge against buffer
+				   quota per PDU */
+
 #define ATM_SD(s)	((s)->sk->protinfo.af_atm)
 
 
@@ -94,7 +97,8 @@
 					/* set backend handler */
 #define ATM_NEWBACKENDIF _IOW('a',ATMIOC_SPECIAL+3,atm_backend_t)
 					/* use backend to make new if */
-
+#define ATM_STOPTX      _IOW('a',ATMIOC_SPECIAL+4,struct atmif_sioc)
+					/* Stop Tx on Sangam DSL */
 /*
  * These are backend handkers that can be set via the ATM_SETBACKEND call
  * above.  In the future we may support dynamic loading of these - for now,
@@ -199,7 +203,9 @@
     "SESSION",	"HASSAP",	"BOUND",	"CLOSE"
 
 
-#ifdef __KERNEL__
+#ifndef __KERNEL__
+#undef __AAL_STAT_ITEMS
+#else
 
 #include <linux/sched.h> /* wait_queue_head_t */
 #include <linux/time.h> /* struct timeval */
@@ -291,6 +297,7 @@
 	int (*send)(struct atm_vcc *vcc,struct sk_buff *skb);
 	void		*dev_data;	/* per-device data */
 	void		*proto_data;	/* per-protocol data */
+	struct timeval	timestamp;	/* AAL timestamps */
 	struct k_atm_aal_stats *stats;	/* pointer to AAL stats group */
 	wait_queue_head_t sleep;	/* if socket is busy */
 	struct sock	*sk;		/* socket backpointer */
@@ -333,13 +340,14 @@
 	struct k_atm_dev_stats stats;	/* statistics */
 	char		signal;		/* signal status (ATM_PHY_SIG_*) */
 	int		link_rate;	/* link rate (default: OC3) */
-	atomic_t	refcnt;		/* reference count */
-	spinlock_t	lock;		/* protect internal members */
+        atomic_t        refcnt;         /* reference count */
+        spinlock_t      lock;           /* protect internal members */
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry *proc_entry; /* proc entry */
 	char *proc_name;		/* proc entry name */
 #endif
-	struct list_head dev_list;	/* linkage */
+	struct list_head dev_list;      /* linkage */
+
 };
 
 
