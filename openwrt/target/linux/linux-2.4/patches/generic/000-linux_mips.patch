diff -Nur linux-2.4.30/Makefile linux-2.4.30-mips/Makefile
--- linux-2.4.30/Makefile	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30-mips/Makefile	2005-04-05 21:09:54.000000000 +0200
@@ -5,7 +5,7 @@
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
-ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+ARCH = mips
 KERNELPATH=kernel-$(shell echo $(KERNELRELEASE) | sed -e "s/-//g")
 
 CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
@@ -462,10 +462,11 @@
 	$(MAKE) -C Documentation/DocBook mrproper
 
 distclean: mrproper
-	rm -f core `find . \( -not -type d \) -and \
-		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
-		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
-		-o -name '.*.rej' -o -name '.SUMS' -o -size 0 \) -type f -print` TAGS tags
+	find . \( -not -type d \) -and \
+		\( -name core -o -name '*.orig' -o -name '*.rej' \
+		-o -name '*~' -o -name '*.bak' -o -name '#*#' \
+		-o -name '.*.rej' -o -name '.SUMS' -o -size 0 \
+		-o -name TAGS -o -name tags \) -print | env -i xargs rm -f
 
 backup: mrproper
 	cd .. && tar cf - linux/ | gzip -9 > backup.gz
@@ -492,7 +493,7 @@
 	$(MAKE) -C Documentation/DocBook man
 
 sums:
-	find . -type f -print | sort | xargs sum > .SUMS
+	find . -type f -print | sort | env -i xargs sum > .SUMS
 
 dep-files: scripts/mkdep archdep include/linux/version.h
 	rm -f .depend .hdepend
diff -Nur linux-2.4.30/arch/mips/Makefile linux-2.4.30-mips/arch/mips/Makefile
--- linux-2.4.30/arch/mips/Makefile	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/Makefile	2005-01-30 09:01:26.000000000 +0100
@@ -211,7 +211,7 @@
 endif
 
 #
-# Au1000 (Alchemy Semi PB1000) eval board
+# Au1x AMD Alchemy eval boards
 #
 ifdef CONFIG_MIPS_PB1000
 LIBS		+= arch/mips/au1000/pb1000/pb1000.o \
@@ -220,9 +220,6 @@
 LOADADDR	:= 0x80100000
 endif
 
-#
-# Au1100 (Alchemy Semi PB1100) eval board
-#
 ifdef CONFIG_MIPS_PB1100
 LIBS          += arch/mips/au1000/pb1100/pb1100.o \
                  arch/mips/au1000/common/au1000.o
@@ -230,9 +227,6 @@
 LOADADDR      += 0x80100000
 endif
 
-#
-# Au1500 (Alchemy Semi PB1500) eval board
-#
 ifdef CONFIG_MIPS_PB1500
 LIBS		+= arch/mips/au1000/pb1500/pb1500.o \
 		   arch/mips/au1000/common/au1000.o
@@ -240,9 +234,6 @@
 LOADADDR	:= 0x80100000
 endif
 
-#
-# Au1x00 (AMD/Alchemy) eval boards
-#
 ifdef CONFIG_MIPS_DB1000
 LIBS          += arch/mips/au1000/db1x00/db1x00.o \
                  arch/mips/au1000/common/au1000.o
@@ -313,6 +304,27 @@
 LOADADDR      += 0x80100000
 endif
 
+ifdef CONFIG_MIPS_PB1200
+LIBS          += arch/mips/au1000/pb1200/pb1200.o \
+                 arch/mips/au1000/common/au1000.o
+SUBDIRS       += arch/mips/au1000/pb1200 arch/mips/au1000/common
+LOADADDR      += 0x80100000
+endif
+
+ifdef CONFIG_MIPS_DB1200
+LIBS          += arch/mips/au1000/pb1200/pb1200.o \
+                 arch/mips/au1000/common/au1000.o
+SUBDIRS       += arch/mips/au1000/pb1200 arch/mips/au1000/common
+LOADADDR      += 0x80100000
+endif
+
+ifdef CONFIG_MIPS_FICMMP
+LIBS          += arch/mips/au1000/ficmmp/ficmmp.o \
+                 arch/mips/au1000/common/au1000.o
+SUBDIRS       += arch/mips/au1000/ficmmp arch/mips/au1000/common
+LOADADDR      += 0x80100000
+endif
+
 
 #
 # Cogent CSB250
diff -Nur linux-2.4.30/arch/mips/au1000/common/Makefile linux-2.4.30-mips/arch/mips/au1000/common/Makefile
--- linux-2.4.30/arch/mips/au1000/common/Makefile	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/Makefile	2005-01-30 09:01:27.000000000 +0100
@@ -19,9 +19,9 @@
 export-objs		= prom.o clocks.o power.o usbdev.o
 
 obj-y := prom.o int-handler.o irq.o puts.o time.o reset.o cputable.o \
-	au1xxx_irqmap.o clocks.o power.o setup.o sleeper.o dma.o dbdma.o
+	au1xxx_irqmap.o clocks.o power.o setup.o sleeper.o dma.o dbdma.o gpio.o
   
-export-objs += dma.o dbdma.o
+export-objs += dma.o dbdma.o gpio.o
 
 obj-$(CONFIG_AU1X00_USB_DEVICE) += usbdev.o
 obj-$(CONFIG_KGDB) += dbg_io.o
diff -Nur linux-2.4.30/arch/mips/au1000/common/au1xxx_irqmap.c linux-2.4.30-mips/arch/mips/au1000/common/au1xxx_irqmap.c
--- linux-2.4.30/arch/mips/au1000/common/au1xxx_irqmap.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/au1xxx_irqmap.c	2005-01-30 09:01:27.000000000 +0100
@@ -172,14 +172,14 @@
 	{ AU1550_PSC1_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1550_PSC2_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1550_PSC3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
-	{ AU1550_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1550_NAND_INT, INTC_INT_RISE_EDGE, 0},
 	{ AU1550_USB_DEV_REQ_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1550_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
@@ -200,14 +200,14 @@
 	{ AU1200_PSC1_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1200_AES_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1200_CAMERA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1200_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
-	{ AU1200_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1200_NAND_INT, INTC_INT_RISE_EDGE, 0},
 	{ AU1200_USB_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1200_LCD_INT, INTC_INT_HIGH_LEVEL, 0},
diff -Nur linux-2.4.30/arch/mips/au1000/common/cputable.c linux-2.4.30-mips/arch/mips/au1000/common/cputable.c
--- linux-2.4.30/arch/mips/au1000/common/cputable.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/cputable.c	2005-01-30 09:01:27.000000000 +0100
@@ -39,7 +39,8 @@
     { 0xffffffff, 0x02030203, "Au1100 BD", 0, 1 },
     { 0xffffffff, 0x02030204, "Au1100 BE", 0, 1 },
     { 0xffffffff, 0x03030200, "Au1550 AA", 0, 1 },
-    { 0xffffffff, 0x04030200, "Au1200 AA", 0, 1 },
+    { 0xffffffff, 0x04030200, "Au1200 AB", 0, 0 },
+    { 0xffffffff, 0x04030201, "Au1200 AC", 0, 0 },
     { 0x00000000, 0x00000000, "Unknown Au1xxx", 1, 0 },
 };
 
diff -Nur linux-2.4.30/arch/mips/au1000/common/dbdma.c linux-2.4.30-mips/arch/mips/au1000/common/dbdma.c
--- linux-2.4.30/arch/mips/au1000/common/dbdma.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/dbdma.c	2005-02-08 07:28:37.000000000 +0100
@@ -41,6 +41,8 @@
 #include <asm/au1xxx_dbdma.h>
 #include <asm/system.h>
 
+#include <linux/module.h>
+
 #if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
 
 /*
@@ -60,37 +62,10 @@
 */
 #define ALIGN_ADDR(x, a)	((((u32)(x)) + (a-1)) & ~(a-1))
 
-static volatile dbdma_global_t *dbdma_gptr = (dbdma_global_t *)DDMA_GLOBAL_BASE;
-static int dbdma_initialized;
+static dbdma_global_t *dbdma_gptr = (dbdma_global_t *)DDMA_GLOBAL_BASE;
+static int dbdma_initialized=0;
 static void au1xxx_dbdma_init(void);
 
-typedef struct dbdma_device_table {
-	u32		dev_id;
-	u32		dev_flags;
-	u32		dev_tsize;
-	u32		dev_devwidth;
-	u32		dev_physaddr;		/* If FIFO */
-	u32		dev_intlevel;
-	u32		dev_intpolarity;
-} dbdev_tab_t;
-
-typedef struct dbdma_chan_config {
-	u32			chan_flags;
-	u32			chan_index;
-	dbdev_tab_t		*chan_src;
-	dbdev_tab_t		*chan_dest;
-	au1x_dma_chan_t		*chan_ptr;
-	au1x_ddma_desc_t	*chan_desc_base;
-	au1x_ddma_desc_t	*get_ptr, *put_ptr, *cur_ptr;
-	void			*chan_callparam;
-	void (*chan_callback)(int, void *, struct pt_regs *);
-} chan_tab_t;
-
-#define	DEV_FLAGS_INUSE		(1 << 0)
-#define	DEV_FLAGS_ANYUSE	(1 << 1)
-#define DEV_FLAGS_OUT		(1 << 2)
-#define DEV_FLAGS_IN		(1 << 3)
-
 static dbdev_tab_t dbdev_tab[] = {
 #ifdef CONFIG_SOC_AU1550
 	/* UARTS */
@@ -156,13 +131,13 @@
 	{ DSCR_CMD0_MAE_BOTH, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 	{ DSCR_CMD0_LCD, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 
-	{ DSCR_CMD0_SDMS_TX0, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_SDMS_RX0, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_SDMS_TX1, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_SDMS_RX1, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_SDMS_TX0, DEV_FLAGS_OUT, 4, 8, 0x10600000, 0, 0 },
+	{ DSCR_CMD0_SDMS_RX0, DEV_FLAGS_IN, 4, 8, 0x10600004, 0, 0 },
+	{ DSCR_CMD0_SDMS_TX1, DEV_FLAGS_OUT, 4, 8, 0x10680000, 0, 0 },
+	{ DSCR_CMD0_SDMS_RX1, DEV_FLAGS_IN, 4, 8, 0x10680004, 0, 0 },
 
-	{ DSCR_CMD0_AES_TX, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_AES_RX, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_AES_RX, DEV_FLAGS_IN , 4, 32, 0x10300008, 0, 0 },
+	{ DSCR_CMD0_AES_TX, DEV_FLAGS_OUT, 4, 32, 0x10300004, 0, 0 },
 
 	{ DSCR_CMD0_PSC0_TX, DEV_FLAGS_OUT, 0, 0, 0x11a0001c, 0, 0 },
 	{ DSCR_CMD0_PSC0_RX, DEV_FLAGS_IN, 0, 0, 0x11a0001c, 0, 0 },
@@ -172,9 +147,9 @@
 	{ DSCR_CMD0_PSC1_RX, DEV_FLAGS_IN, 0, 0, 0x11b0001c, 0, 0 },
 	{ DSCR_CMD0_PSC1_SYNC, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 
-	{ DSCR_CMD0_CIM_RXA, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_CIM_RXB, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_CIM_RXC, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_CIM_RXA, DEV_FLAGS_IN, 0, 32, 0x14004020, 0, 0 },
+	{ DSCR_CMD0_CIM_RXB, DEV_FLAGS_IN, 0, 32, 0x14004040, 0, 0 },
+	{ DSCR_CMD0_CIM_RXC, DEV_FLAGS_IN, 0, 32, 0x14004060, 0, 0 },
 	{ DSCR_CMD0_CIM_SYNC, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 
 	{ DSCR_CMD0_NAND_FLASH, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
@@ -183,6 +158,24 @@
 
 	{ DSCR_CMD0_THROTTLE, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 	{ DSCR_CMD0_ALWAYS, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+
+	/* Provide 16 user definable device types */
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
 };
 
 #define DBDEV_TAB_SIZE (sizeof(dbdev_tab) / sizeof(dbdev_tab_t))
@@ -202,6 +195,30 @@
 	return NULL;
 }
 
+u32
+au1xxx_ddma_add_device(dbdev_tab_t *dev)
+{
+	u32 ret = 0;
+	dbdev_tab_t *p=NULL;
+	static u16 new_id=0x1000;
+
+	p = find_dbdev_id(0);
+	if ( NULL != p )
+	{
+		memcpy(p, dev, sizeof(dbdev_tab_t));
+ 		p->dev_id = DSCR_DEV2CUSTOM_ID(new_id,dev->dev_id);
+		ret = p->dev_id;
+		new_id++;
+#if 0
+		printk("add_device: id:%x flags:%x padd:%x\n", 
+				p->dev_id, p->dev_flags, p->dev_physaddr );
+#endif
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(au1xxx_ddma_add_device);
+
 /* Allocate a channel and return a non-zero descriptor if successful.
 */
 u32
@@ -214,7 +231,7 @@
 	int		i;
 	dbdev_tab_t	*stp, *dtp;
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 
 	/* We do the intialization on the first channel allocation.
 	 * We have to wait because of the interrupt handler initialization
@@ -224,9 +241,6 @@
 		au1xxx_dbdma_init();
 	dbdma_initialized = 1;
 
-	if ((srcid > DSCR_NDEV_IDS) || (destid > DSCR_NDEV_IDS))
-		return 0;
-	
 	if ((stp = find_dbdev_id(srcid)) == NULL) return 0;
 	if ((dtp = find_dbdev_id(destid)) == NULL) return 0;
 
@@ -268,9 +282,9 @@
 				/* If kmalloc fails, it is caught below same
 				 * as a channel not available.
 				 */
-				ctp = (chan_tab_t *)kmalloc(sizeof(chan_tab_t), GFP_KERNEL);
+				ctp = (chan_tab_t *)
+					kmalloc(sizeof(chan_tab_t), GFP_KERNEL);
 				chan_tab_ptr[i] = ctp;
-				ctp->chan_index = chan = i;
 				break;
 			}
 		}
@@ -278,10 +292,11 @@
 
 		if (ctp != NULL) {
 			memset(ctp, 0, sizeof(chan_tab_t));
+			ctp->chan_index = chan = i;
 			dcp = DDMA_CHANNEL_BASE;
 			dcp += (0x0100 * chan);
 			ctp->chan_ptr = (au1x_dma_chan_t *)dcp;
-			cp = (volatile au1x_dma_chan_t *)dcp;
+			cp = (au1x_dma_chan_t *)dcp;
 			ctp->chan_src = stp;
 			ctp->chan_dest = dtp;
 			ctp->chan_callback = callback;
@@ -298,6 +313,9 @@
 				i |= DDMA_CFG_DED;
 			if (dtp->dev_intpolarity)
 				i |= DDMA_CFG_DP;
+			if ((stp->dev_flags & DEV_FLAGS_SYNC) ||
+				(dtp->dev_flags & DEV_FLAGS_SYNC))
+					i |= DDMA_CFG_SYNC;
 			cp->ddma_cfg = i;
 			au_sync();
 
@@ -308,14 +326,14 @@
 			rv = (u32)(&chan_tab_ptr[chan]);
 		}
 		else {
-			/* Release devices.
-			*/
+			/* Release devices */
 			stp->dev_flags &= ~DEV_FLAGS_INUSE;
 			dtp->dev_flags &= ~DEV_FLAGS_INUSE;
 		}
 	}
 	return rv;
 }
+EXPORT_SYMBOL(au1xxx_dbdma_chan_alloc);
 
 /* Set the device width if source or destination is a FIFO.
  * Should be 8, 16, or 32 bits.
@@ -343,6 +361,7 @@
 
 	return rv;
 }
+EXPORT_SYMBOL(au1xxx_dbdma_set_devwidth);
 
 /* Allocate a descriptor ring, initializing as much as possible.
 */
@@ -369,7 +388,8 @@
 	 * and if we try that first we are likely to not waste larger
 	 * slabs of memory.
 	 */
-	desc_base = (u32)kmalloc(entries * sizeof(au1x_ddma_desc_t), GFP_KERNEL);
+	desc_base = (u32)kmalloc(entries * sizeof(au1x_ddma_desc_t), 
+			GFP_KERNEL|GFP_DMA);
 	if (desc_base == 0)
 		return 0;
 	
@@ -380,7 +400,7 @@
 		kfree((const void *)desc_base);
 		i = entries * sizeof(au1x_ddma_desc_t);
 		i += (sizeof(au1x_ddma_desc_t) - 1);
-		if ((desc_base = (u32)kmalloc(i, GFP_KERNEL)) == 0)
+		if ((desc_base = (u32)kmalloc(i, GFP_KERNEL|GFP_DMA)) == 0)
 			return 0;
 
 		desc_base = ALIGN_ADDR(desc_base, sizeof(au1x_ddma_desc_t));
@@ -460,9 +480,14 @@
 	/* If source input is fifo, set static address.
 	*/
 	if (stp->dev_flags & DEV_FLAGS_IN) {
-		src0 = stp->dev_physaddr;
-		src1 |= DSCR_SRC1_SAM(DSCR_xAM_STATIC);
+		if ( stp->dev_flags & DEV_FLAGS_BURSTABLE ) 
+			src1 |= DSCR_SRC1_SAM(DSCR_xAM_BURST);
+		else 
+			src1 |= DSCR_SRC1_SAM(DSCR_xAM_STATIC);
+
 	}
+	if (stp->dev_physaddr) 
+		src0 = stp->dev_physaddr;
 
 	/* Set up dest1.  For now, assume no stride and increment.
 	 * A channel attribute update can change this later.
@@ -486,10 +511,18 @@
 	/* If destination output is fifo, set static address.
 	*/
 	if (dtp->dev_flags & DEV_FLAGS_OUT) {
-		dest0 = dtp->dev_physaddr;
+		if ( dtp->dev_flags & DEV_FLAGS_BURSTABLE )
+	                dest1 |= DSCR_DEST1_DAM(DSCR_xAM_BURST);
+				else
 		dest1 |= DSCR_DEST1_DAM(DSCR_xAM_STATIC);
 	}
+	if (dtp->dev_physaddr) 
+		dest0 = dtp->dev_physaddr;
 	
+#if 0
+		printk("did:%x sid:%x cmd0:%x cmd1:%x source0:%x source1:%x dest0:%x dest1:%x\n",
+			dtp->dev_id, stp->dev_id, cmd0, cmd1, src0, src1, dest0, dest1 );
+#endif
 	for (i=0; i<entries; i++) {
 		dp->dscr_cmd0 = cmd0;
 		dp->dscr_cmd1 = cmd1;
@@ -498,6 +531,7 @@
 		dp->dscr_dest0 = dest0;
 		dp->dscr_dest1 = dest1;
 		dp->dscr_stat = 0;
+				dp->sw_context = dp->sw_status = 0;
 		dp->dscr_nxtptr = DSCR_NXTPTR(virt_to_phys(dp + 1));
 		dp++;
 	}
@@ -510,13 +544,14 @@
 
 	return (u32)(ctp->chan_desc_base);
 }
+EXPORT_SYMBOL(au1xxx_dbdma_ring_alloc);
 
 /* Put a source buffer into the DMA ring.
  * This updates the source pointer and byte count.  Normally used
  * for memory to fifo transfers.
  */
 u32
-au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes)
+_au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags)
 {
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
@@ -543,24 +578,40 @@
 	*/
 	dp->dscr_source0 = virt_to_phys(buf);
 	dp->dscr_cmd1 = nbytes;
-	dp->dscr_cmd0 |= DSCR_CMD0_V;	/* Let it rip */
-	ctp->chan_ptr->ddma_dbell = 0xffffffff;	/* Make it go */
-	
+	/* Check flags  */
+	if (flags & DDMA_FLAGS_IE) 
+		dp->dscr_cmd0 |= DSCR_CMD0_IE;
+	if (flags & DDMA_FLAGS_NOIE)
+		dp->dscr_cmd0 &= ~DSCR_CMD0_IE;
 	/* Get next descriptor pointer.
 	*/
 	ctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 
+	/*
+	 * There is an errata on the Au1200/Au1550 parts that could result 
+	 * in "stale" data being DMA'd. It has to do with the snoop logic on 
+	 * the dache eviction buffer.  NONCOHERENT_IO is on by default for 
+	 * these parts. If it is fixedin the future, these dma_cache_inv will 
+	 * just be nothing more than empty macros. See io.h.
+	 * */
+	dma_cache_wback_inv(buf,nbytes);
+        dp->dscr_cmd0 |= DSCR_CMD0_V;        /* Let it rip */
+	au_sync();
+	dma_cache_wback_inv(dp, sizeof(dp));
+        ctp->chan_ptr->ddma_dbell = 0;
+
 	/* return something not zero.
 	*/
 	return nbytes;
 }
+EXPORT_SYMBOL(_au1xxx_dbdma_put_source);
 
 /* Put a destination buffer into the DMA ring.
  * This updates the destination pointer and byte count.  Normally used
  * to place an empty buffer into the ring for fifo to memory transfers.
  */
 u32
-au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes)
+_au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags)
 {
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
@@ -582,11 +633,33 @@
 	if (dp->dscr_cmd0 & DSCR_CMD0_V)
 		return 0;
 	
-	/* Load up buffer address and byte count.
-	*/
+	/* Load up buffer address and byte count */
+
+	/* Check flags  */
+	if (flags & DDMA_FLAGS_IE) 
+		dp->dscr_cmd0 |= DSCR_CMD0_IE;
+	if (flags & DDMA_FLAGS_NOIE)
+		dp->dscr_cmd0 &= ~DSCR_CMD0_IE;
+
 	dp->dscr_dest0 = virt_to_phys(buf);
 	dp->dscr_cmd1 = nbytes;
+#if 0
+	printk("cmd0:%x cmd1:%x source0:%x source1:%x dest0:%x dest1:%x\n", 
+			dp->dscr_cmd0, dp->dscr_cmd1, dp->dscr_source0, 
+			dp->dscr_source1, dp->dscr_dest0, dp->dscr_dest1 );
+#endif
+	/*
+	 * There is an errata on the Au1200/Au1550 parts that could result in 
+	 * "stale" data being DMA'd. It has to do with the snoop logic on the 
+	 * dache eviction buffer. NONCOHERENT_IO is on by default for these 
+	 * parts. If it is fixedin the future, these dma_cache_inv will just 
+	 * be nothing more than empty macros. See io.h. 
+	 * */
+	dma_cache_inv(buf,nbytes);
 	dp->dscr_cmd0 |= DSCR_CMD0_V;	/* Let it rip */
+	au_sync();
+	dma_cache_wback_inv(dp, sizeof(dp));
+        ctp->chan_ptr->ddma_dbell = 0;
 	
 	/* Get next descriptor pointer.
 	*/
@@ -596,6 +669,7 @@
 	*/
 	return nbytes;
 }
+EXPORT_SYMBOL(_au1xxx_dbdma_put_dest);
 
 /* Get a destination buffer into the DMA ring.
  * Normally used to get a full buffer from the ring during fifo
@@ -645,7 +719,7 @@
 au1xxx_dbdma_stop(u32 chanid)
 {
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 	int halt_timeout = 0;
 
 	ctp = *((chan_tab_t **)chanid);
@@ -665,6 +739,7 @@
 	cp->ddma_stat |= (DDMA_STAT_DB | DDMA_STAT_V);
 	au_sync();
 }
+EXPORT_SYMBOL(au1xxx_dbdma_stop);
 
 /* Start using the current descriptor pointer.  If the dbdma encounters
  * a not valid descriptor, it will stop.  In this case, we can just
@@ -674,17 +749,17 @@
 au1xxx_dbdma_start(u32 chanid)
 {
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 
 	ctp = *((chan_tab_t **)chanid);
-
 	cp = ctp->chan_ptr;
 	cp->ddma_desptr = virt_to_phys(ctp->cur_ptr);
 	cp->ddma_cfg |= DDMA_CFG_EN;	/* Enable channel */
 	au_sync();
-	cp->ddma_dbell = 0xffffffff;	/* Make it go */
+	cp->ddma_dbell = 0;
 	au_sync();
 }
+EXPORT_SYMBOL(au1xxx_dbdma_start);
 
 void
 au1xxx_dbdma_reset(u32 chanid)
@@ -703,15 +778,21 @@
 
 	do {
 		dp->dscr_cmd0 &= ~DSCR_CMD0_V;
+		/* reset our SW status -- this is used to determine 
+		 * if a descriptor is in use by upper level SW. Since 
+		 * posting can reset 'V' bit. 
+		 */
+		dp->sw_status = 0;
 		dp = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 	} while (dp != ctp->chan_desc_base);
 }
+EXPORT_SYMBOL(au1xxx_dbdma_reset);
 
 u32
 au1xxx_get_dma_residue(u32 chanid)
 {
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 	u32		rv;
 
 	ctp = *((chan_tab_t **)chanid);
@@ -746,15 +827,16 @@
 
 	kfree(ctp);
 }
+EXPORT_SYMBOL(au1xxx_dbdma_chan_free);
 
 static void
 dbdma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	u32	intstat;
+	u32        				intstat, flags;
 	u32	chan_index;
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 
 	intstat = dbdma_gptr->ddma_intstat;
 	au_sync();
@@ -773,18 +855,26 @@
 		(ctp->chan_callback)(irq, ctp->chan_callparam, regs);
 
 	ctp->cur_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
-	
 }
 
-static void
-au1xxx_dbdma_init(void)
+static void au1xxx_dbdma_init(void)
 {
+	int irq_nr;
+
 	dbdma_gptr->ddma_config = 0;
 	dbdma_gptr->ddma_throttle = 0;
 	dbdma_gptr->ddma_inten = 0xffff;
 	au_sync();
 
-	if (request_irq(AU1550_DDMA_INT, dbdma_interrupt, SA_INTERRUPT,
+#if defined(CONFIG_SOC_AU1550)
+	irq_nr = AU1550_DDMA_INT;
+#elif defined(CONFIG_SOC_AU1200)
+	irq_nr = AU1200_DDMA_INT;
+#else
+	#error Unknown Au1x00 SOC
+#endif
+
+	if (request_irq(irq_nr, dbdma_interrupt, SA_INTERRUPT,
 			"Au1xxx dbdma", (void *)dbdma_gptr))
 		printk("Can't get 1550 dbdma irq");
 }
@@ -795,7 +885,8 @@
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
 	dbdev_tab_t		*stp, *dtp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
+		u32			i = 0;
 
 	ctp = *((chan_tab_t **)chanid);
 	stp = ctp->chan_src;
@@ -820,15 +911,64 @@
 	dp = ctp->chan_desc_base;
 
 	do {
-		printk("dp %08x, cmd0 %08x, cmd1 %08x\n",
-			(u32)dp, dp->dscr_cmd0, dp->dscr_cmd1);
-		printk("src0 %08x, src1 %08x, dest0 %08x\n",
-			dp->dscr_source0, dp->dscr_source1, dp->dscr_dest0);
-		printk("dest1 %08x, stat %08x, nxtptr %08x\n",
-			dp->dscr_dest1, dp->dscr_stat, dp->dscr_nxtptr);
+                printk("Dp[%d]= %08x, cmd0 %08x, cmd1 %08x\n",
+                        i++, (u32)dp, dp->dscr_cmd0, dp->dscr_cmd1);
+                printk("src0 %08x, src1 %08x, dest0 %08x, dest1 %08x\n",
+                        dp->dscr_source0, dp->dscr_source1, dp->dscr_dest0, dp->dscr_dest1);
+                printk("stat %08x, nxtptr %08x\n",
+                        dp->dscr_stat, dp->dscr_nxtptr);
 		dp = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 	} while (dp != ctp->chan_desc_base);
 }
 
+/* Put a descriptor into the DMA ring.
+ * This updates the source/destination pointers and byte count.
+ */
+u32
+au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr )
+{
+	chan_tab_t *ctp;
+	au1x_ddma_desc_t *dp;
+	u32 nbytes=0;
+
+	/* I guess we could check this to be within the
+	* range of the table......
+	*/
+	ctp = *((chan_tab_t **)chanid);
+
+	/* We should have multiple callers for a particular channel,
+	* an interrupt doesn't affect this pointer nor the descriptor,
+	* so no locking should be needed.
+	*/
+	dp = ctp->put_ptr;
+
+	/* If the descriptor is valid, we are way ahead of the DMA
+	* engine, so just return an error condition.
+	*/
+	if (dp->dscr_cmd0 & DSCR_CMD0_V)
+		return 0;
+
+	/* Load up buffer addresses and byte count.
+	*/
+	dp->dscr_dest0 = dscr->dscr_dest0;
+	dp->dscr_source0 = dscr->dscr_source0;
+	dp->dscr_dest1 = dscr->dscr_dest1;
+	dp->dscr_source1 = dscr->dscr_source1;
+	dp->dscr_cmd1 = dscr->dscr_cmd1;
+	nbytes = dscr->dscr_cmd1;
+	/* Allow the caller to specifiy if an interrupt is generated */
+	dp->dscr_cmd0 &= ~DSCR_CMD0_IE;
+	dp->dscr_cmd0 |= dscr->dscr_cmd0 | DSCR_CMD0_V;
+	ctp->chan_ptr->ddma_dbell = 0;
+
+	/* Get next descriptor pointer.
+	*/
+	ctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
+
+	/* return something not zero.
+	*/
+	return nbytes;
+}
+
 #endif /* defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200) */
 
diff -Nur linux-2.4.30/arch/mips/au1000/common/gpio.c linux-2.4.30-mips/arch/mips/au1000/common/gpio.c
--- linux-2.4.30/arch/mips/au1000/common/gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/gpio.c	2005-01-30 09:01:27.000000000 +0100
@@ -0,0 +1,118 @@
+/*
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <asm/au1000.h>
+#include <asm/au1xxx_gpio.h>
+
+#define gpio1 sys
+#if !defined(CONFIG_SOC_AU1000)
+static AU1X00_GPIO2 * const gpio2 = (AU1X00_GPIO2 *)GPIO2_BASE;
+
+#define GPIO2_OUTPUT_ENABLE_MASK 0x00010000
+
+int au1xxx_gpio2_read(int signal)
+{
+	signal -= 200;
+/*	gpio2->dir &= ~(0x01 << signal);						//Set GPIO to input */
+	return ((gpio2->pinstate >> signal) & 0x01);
+}
+
+void au1xxx_gpio2_write(int signal, int value)
+{
+	signal -= 200;
+
+	gpio2->output = (GPIO2_OUTPUT_ENABLE_MASK << signal) | 
+		(value << signal);
+}
+
+void au1xxx_gpio2_tristate(int signal)
+{
+	signal -= 200;
+	gpio2->dir &= ~(0x01 << signal); 	/* Set GPIO to input */
+}
+#endif
+
+int au1xxx_gpio1_read(int signal)
+{
+/*	gpio1->trioutclr |= (0x01 << signal); */
+	return ((gpio1->pinstaterd >> signal) & 0x01);
+}
+
+void au1xxx_gpio1_write(int signal, int value)
+{
+	if(value)
+		gpio1->outputset = (0x01 << signal);
+	else
+		gpio1->outputclr = (0x01 << signal);	/* Output a Zero */
+}
+
+void au1xxx_gpio1_tristate(int signal)
+{
+	gpio1->trioutclr = (0x01 << signal);		/* Tristate signal */
+}
+
+
+int au1xxx_gpio_read(int signal)
+{
+	if(signal >= 200)
+#if defined(CONFIG_SOC_AU1000)
+		return 0;
+#else
+		return au1xxx_gpio2_read(signal);
+#endif
+	else
+		return au1xxx_gpio1_read(signal);
+}
+
+void au1xxx_gpio_write(int signal, int value)
+{
+	if(signal >= 200)
+#if defined(CONFIG_SOC_AU1000)
+		;
+#else
+		au1xxx_gpio2_write(signal, value);
+#endif
+	else
+		au1xxx_gpio1_write(signal, value);
+}
+
+void au1xxx_gpio_tristate(int signal)
+{
+	if(signal >= 200)
+#if defined(CONFIG_SOC_AU1000)
+		;
+#else
+		au1xxx_gpio2_tristate(signal);
+#endif
+	else
+		au1xxx_gpio1_tristate(signal);
+}
+
+void au1xxx_gpio1_set_inputs(void)
+{
+	gpio1->pininputen = 0;
+}
+
+EXPORT_SYMBOL(au1xxx_gpio1_set_inputs);
+EXPORT_SYMBOL(au1xxx_gpio_tristate);
+EXPORT_SYMBOL(au1xxx_gpio_write);
+EXPORT_SYMBOL(au1xxx_gpio_read);
diff -Nur linux-2.4.30/arch/mips/au1000/common/irq.c linux-2.4.30-mips/arch/mips/au1000/common/irq.c
--- linux-2.4.30/arch/mips/au1000/common/irq.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/irq.c	2005-03-13 08:56:57.000000000 +0100
@@ -303,8 +303,30 @@
 };
 
 #ifdef CONFIG_PM
-void startup_match20_interrupt(void)
+void startup_match20_interrupt(void (*handler)(int, void *, struct pt_regs *))
 {
+	static struct irqaction action;
+	/* This is a big problem.... since we didn't use request_irq
+	   when kernel/irq.c calls probe_irq_xxx this interrupt will
+	   be probed for usage. This will end up disabling the device :(
+
+       Give it a bogus "action" pointer -- this will keep it from
+	   getting auto-probed!
+
+       By setting the status to match that of request_irq() we
+       can avoid it.  --cgray
+	*/
+	action.dev_id = handler;
+	action.flags = 0;
+	action.mask = 0;
+	action.name = "Au1xxx TOY";
+	action.handler = handler;
+	action.next = NULL;
+
+	irq_desc[AU1000_TOY_MATCH2_INT].action = &action; 
+	irq_desc[AU1000_TOY_MATCH2_INT].status 
+		 &= ~(IRQ_DISABLED | IRQ_AUTODETECT | IRQ_WAITING | IRQ_INPROGRESS);
+
 	local_enable_irq(AU1000_TOY_MATCH2_INT);
 }
 #endif
@@ -508,6 +530,7 @@
 
 	if (!intc0_req0) return;
 
+#ifdef AU1000_USB_DEV_REQ_INT
 	/*
 	 * Because of the tight timing of SETUP token to reply
 	 * transactions, the USB devices-side packet complete
@@ -518,6 +541,7 @@
 		do_IRQ(AU1000_USB_DEV_REQ_INT, regs);
 		return;
 	}
+#endif
 
 	irq = au_ffs(intc0_req0) - 1;
 	intc0_req0 &= ~(1<<irq);
@@ -536,17 +560,7 @@
 
 	irq = au_ffs(intc0_req1) - 1;
 	intc0_req1 &= ~(1<<irq);
-#ifdef CONFIG_PM
-	if (irq == AU1000_TOY_MATCH2_INT) {
-		mask_and_ack_rise_edge_irq(irq);
-		counter0_irq(irq, NULL, regs);
-		local_enable_irq(irq);
-	}
-	else
-#endif
-	{
-		do_IRQ(irq, regs);
-	}
+	do_IRQ(irq, regs);
 }
 
 
diff -Nur linux-2.4.30/arch/mips/au1000/common/pci_fixup.c linux-2.4.30-mips/arch/mips/au1000/common/pci_fixup.c
--- linux-2.4.30/arch/mips/au1000/common/pci_fixup.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/pci_fixup.c	2004-12-03 09:00:32.000000000 +0100
@@ -75,9 +75,13 @@
 
 #ifdef CONFIG_NONCOHERENT_IO
 	/* 
-	 *  Set the NC bit in controller for pre-AC silicon
+         *  Set the NC bit in controller for Au1500 pre-AC silicon
 	 */
-	au_writel( 1<<16 | au_readl(Au1500_PCI_CFG), Au1500_PCI_CFG);
+	u32 prid = read_c0_prid();
+	if ( (prid & 0xFF000000) == 0x01000000 && prid < 0x01030202) {
+	       au_writel( 1<<16 | au_readl(Au1500_PCI_CFG), Au1500_PCI_CFG);
+	       printk("Non-coherent PCI accesses enabled\n");
+	}
 	printk("Non-coherent PCI accesses enabled\n");
 #endif
 
diff -Nur linux-2.4.30/arch/mips/au1000/common/pci_ops.c linux-2.4.30-mips/arch/mips/au1000/common/pci_ops.c
--- linux-2.4.30/arch/mips/au1000/common/pci_ops.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/pci_ops.c	2005-02-27 23:14:24.000000000 +0100
@@ -162,6 +162,7 @@
 static int config_access(unsigned char access_type, struct pci_dev *dev, 
 			 unsigned char where, u32 * data)
 {
+	int error = PCIBIOS_SUCCESSFUL;
 #if defined( CONFIG_SOC_AU1500 ) || defined( CONFIG_SOC_AU1550 )
 	unsigned char bus = dev->bus->number;
 	unsigned int dev_fn = dev->devfn;
@@ -170,7 +171,6 @@
 	unsigned long offset, status;
 	unsigned long cfg_base;
 	unsigned long flags;
-	int error = PCIBIOS_SUCCESSFUL;
 	unsigned long entryLo0, entryLo1;
 
 	if (device > 19) {
@@ -205,9 +205,8 @@
 		last_entryLo0  = last_entryLo1 = 0xffffffff;
 	}
 
-	/* Since the Au1xxx doesn't do the idsel timing exactly to spec,
-	 * many board vendors implement their own off-chip idsel, so call
-	 * it now.  If it doesn't succeed, may as well bail out at this point.
+	/* Allow board vendors to implement their own off-chip idsel.  
+	 * If it doesn't succeed, may as well bail out at this point.
 	 */
 	if (board_pci_idsel) {
 		if (board_pci_idsel(device, 1) == 0) {
@@ -271,8 +270,11 @@
 	}
 
 	local_irq_restore(flags);
-	return error;
+#else
+	/* Fake out Config space access with no responder */
+	*data = 0xFFFFFFFF;
 #endif
+	return error;
 }
 #endif
 
diff -Nur linux-2.4.30/arch/mips/au1000/common/power.c linux-2.4.30-mips/arch/mips/au1000/common/power.c
--- linux-2.4.30/arch/mips/au1000/common/power.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/power.c	2005-04-07 02:37:19.000000000 +0200
@@ -50,7 +50,6 @@
 
 static void calibrate_delay(void);
 
-extern void set_au1x00_speed(unsigned int new_freq);
 extern unsigned int get_au1x00_speed(void);
 extern unsigned long get_au1x00_uart_baud_base(void);
 extern void set_au1x00_uart_baud_base(unsigned long new_baud_base);
@@ -116,6 +115,7 @@
 	sleep_uart0_clkdiv = au_readl(UART0_ADDR + UART_CLK);
 	sleep_uart0_enable = au_readl(UART0_ADDR + UART_MOD_CNTRL);
 
+#ifndef CONFIG_SOC_AU1200
 	/* Shutdown USB host/device.
 	*/
 	sleep_usbhost_enable = au_readl(USB_HOST_CONFIG);
@@ -127,6 +127,7 @@
 
 	sleep_usbdev_enable = au_readl(USBD_ENABLE);
 	au_writel(0, USBD_ENABLE); au_sync();
+#endif
 
 	/* Save interrupt controller state.
 	*/
@@ -212,14 +213,12 @@
 int au_sleep(void)
 {
 	unsigned long wakeup, flags;
-	extern	void	save_and_sleep(void);
+	extern unsigned int save_and_sleep(void);
 
 	spin_lock_irqsave(&pm_lock,flags);
 
 	save_core_regs();
 
-	flush_cache_all();
-
 	/** The code below is all system dependent and we should probably
 	 ** have a function call out of here to set this up.  You need
 	 ** to configure the GPIO or timer interrupts that will bring
@@ -227,27 +226,26 @@
 	 ** For testing, the TOY counter wakeup is useful.
 	 **/
 
-#if 0
+#if 1
 	au_writel(au_readl(SYS_PINSTATERD) & ~(1 << 11), SYS_PINSTATERD);
 
 	/* gpio 6 can cause a wake up event */
 	wakeup = au_readl(SYS_WAKEMSK);
 	wakeup &= ~(1 << 8);	/* turn off match20 wakeup */
-	wakeup |= 1 << 6;	/* turn on gpio 6 wakeup   */
+	wakeup = 1 << 5;	/* turn on gpio 6 wakeup   */
 #else
-	/* For testing, allow match20 to wake us up.
-	*/
+	/* For testing, allow match20 to wake us up.  */
 #ifdef SLEEP_TEST_TIMEOUT
 	wakeup_counter0_set(sleep_ticks);
 #endif
 	wakeup = 1 << 8;	/* turn on match20 wakeup   */
 	wakeup = 0;
 #endif
-	au_writel(1, SYS_WAKESRC);	/* clear cause */
+	au_writel(0, SYS_WAKESRC);	/* clear cause */
 	au_sync();
 	au_writel(wakeup, SYS_WAKEMSK);
 	au_sync();
-
+	DPRINTK("Entering sleep!\n");
 	save_and_sleep();
 
 	/* after a wakeup, the cpu vectors back to 0x1fc00000 so
@@ -255,6 +253,7 @@
 	 */
 	restore_core_regs();
 	spin_unlock_irqrestore(&pm_lock, flags);
+	DPRINTK("Leaving sleep!\n");
 	return 0;
 }
 
@@ -285,7 +284,6 @@
 
 		if (retval)
 			return retval;
-
 		au_sleep();
 		retval = pm_send_all(PM_RESUME, (void *) 0);
 	}
@@ -296,7 +294,6 @@
 			 void *buffer, size_t * len)
 {
 	int retval = 0;
-	void	au1k_wait(void);
 
 	if (!write) {
 		*len = 0;
@@ -305,119 +302,9 @@
 		if (retval)
 			return retval;
 		suspend_mode = 1;
-		au1k_wait();
-		retval = pm_send_all(PM_RESUME, (void *) 0);
-	}
-	return retval;
-}
 
-
-static int pm_do_freq(ctl_table * ctl, int write, struct file *file,
-		      void *buffer, size_t * len)
-{
-	int retval = 0, i;
-	unsigned long val, pll;
-#define TMPBUFLEN 64
-#define MAX_CPU_FREQ 396
-	char buf[TMPBUFLEN], *p;
-	unsigned long flags, intc0_mask, intc1_mask;
-	unsigned long old_baud_base, old_cpu_freq, baud_rate, old_clk,
-	    old_refresh;
-	unsigned long new_baud_base, new_cpu_freq, new_clk, new_refresh;
-
-	spin_lock_irqsave(&pm_lock, flags);
-	if (!write) {
-		*len = 0;
-	} else {
-		/* Parse the new frequency */
-		if (*len > TMPBUFLEN - 1) {
-			spin_unlock_irqrestore(&pm_lock, flags);
-			return -EFAULT;
-		}
-		if (copy_from_user(buf, buffer, *len)) {
-			spin_unlock_irqrestore(&pm_lock, flags);
-			return -EFAULT;
-		}
-		buf[*len] = 0;
-		p = buf;
-		val = simple_strtoul(p, &p, 0);
-		if (val > MAX_CPU_FREQ) {
-			spin_unlock_irqrestore(&pm_lock, flags);
-			return -EFAULT;
-		}
-
-		pll = val / 12;
-		if ((pll > 33) || (pll < 7)) {	/* 396 MHz max, 84 MHz min */
-			/* revisit this for higher speed cpus */
-			spin_unlock_irqrestore(&pm_lock, flags);
-			return -EFAULT;
-		}
-
-		old_baud_base = get_au1x00_uart_baud_base();
-		old_cpu_freq = get_au1x00_speed();
-
-		new_cpu_freq = pll * 12 * 1000000;
-	        new_baud_base =  (new_cpu_freq / (2 * ((int)(au_readl(SYS_POWERCTRL)&0x03) + 2) * 16));
-		set_au1x00_speed(new_cpu_freq);
-		set_au1x00_uart_baud_base(new_baud_base);
-
-		old_refresh = au_readl(MEM_SDREFCFG) & 0x1ffffff;
-		new_refresh =
-		    ((old_refresh * new_cpu_freq) /
-		     old_cpu_freq) | (au_readl(MEM_SDREFCFG) & ~0x1ffffff);
-
-		au_writel(pll, SYS_CPUPLL);
-		au_sync_delay(1);
-		au_writel(new_refresh, MEM_SDREFCFG);
-		au_sync_delay(1);
-
-		for (i = 0; i < 4; i++) {
-			if (au_readl
-			    (UART_BASE + UART_MOD_CNTRL +
-			     i * 0x00100000) == 3) {
-				old_clk =
-				    au_readl(UART_BASE + UART_CLK +
-					  i * 0x00100000);
-				// baud_rate = baud_base/clk
-				baud_rate = old_baud_base / old_clk;
-				/* we won't get an exact baud rate and the error
-				 * could be significant enough that our new
-				 * calculation will result in a clock that will
-				 * give us a baud rate that's too far off from
-				 * what we really want.
-				 */
-				if (baud_rate > 100000)
-					baud_rate = 115200;
-				else if (baud_rate > 50000)
-					baud_rate = 57600;
-				else if (baud_rate > 30000)
-					baud_rate = 38400;
-				else if (baud_rate > 17000)
-					baud_rate = 19200;
-				else
-					(baud_rate = 9600);
-				// new_clk = new_baud_base/baud_rate
-				new_clk = new_baud_base / baud_rate;
-				au_writel(new_clk,
-				       UART_BASE + UART_CLK +
-				       i * 0x00100000);
-				au_sync_delay(10);
-			}
-		}
+		retval = pm_send_all(PM_RESUME, (void *) 0);
 	}
-
-
-	/* We don't want _any_ interrupts other than
-	 * match20. Otherwise our calibrate_delay()
-	 * calculation will be off, potentially a lot.
-	 */
-	intc0_mask = save_local_and_disable(0);
-	intc1_mask = save_local_and_disable(1);
-	local_enable_irq(AU1000_TOY_MATCH2_INT);
-	spin_unlock_irqrestore(&pm_lock, flags);
-	calibrate_delay();
-	restore_local_and_enable(0, intc0_mask);
-	restore_local_and_enable(1, intc1_mask);
 	return retval;
 }
 
@@ -425,7 +312,6 @@
 static struct ctl_table pm_table[] = {
 	{ACPI_S1_SLP_TYP, "suspend", NULL, 0, 0600, NULL, &pm_do_suspend},
 	{ACPI_SLEEP, "sleep", NULL, 0, 0600, NULL, &pm_do_sleep},
-	{CTL_ACPI, "freq", NULL, 0, 0600, NULL, &pm_do_freq},
 	{0}
 };
 
diff -Nur linux-2.4.30/arch/mips/au1000/common/reset.c linux-2.4.30-mips/arch/mips/au1000/common/reset.c
--- linux-2.4.30/arch/mips/au1000/common/reset.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/reset.c	2005-03-19 08:17:51.000000000 +0100
@@ -37,8 +37,6 @@
 #include <asm/system.h>
 #include <asm/au1000.h>
 
-extern int au_sleep(void);
-
 void au1000_restart(char *command)
 {
 	/* Set all integrated peripherals to disabled states */
@@ -144,6 +142,26 @@
 		au_writel(0x00, 0xb1900064); /* sys_auxpll */
 		au_writel(0x00, 0xb1900100); /* sys_pininputen */
 		break;
+	case 0x04000000: /* Au1200 */
+		au_writel(0x00, 0xb400300c); /* ddma */
+		au_writel(0x00, 0xb1a00004); /* psc 0 */
+		au_writel(0x00, 0xb1b00004); /* psc 1 */
+		au_writel(0x00d02000, 0xb4020004); /* ehci, ohci, udc, otg */
+		au_writel(0x00, 0xb5000004); /* lcd */
+		au_writel(0x00, 0xb060000c); /* sd0 */
+		au_writel(0x00, 0xb068000c); /* sd1 */
+		au_writel(0x00, 0xb1100100); /* swcnt */
+		au_writel(0x00, 0xb0300000); /* aes */
+		au_writel(0x00, 0xb4004000); /* cim */
+		au_writel(0x00, 0xb1100100); /* uart0_enable */
+		au_writel(0x00, 0xb1200100); /* uart1_enable */
+		au_writel(0x00, 0xb1900020); /* sys_freqctrl0 */
+		au_writel(0x00, 0xb1900024); /* sys_freqctrl1 */
+		au_writel(0x00, 0xb1900028); /* sys_clksrc */
+		au_writel(0x10, 0xb1900060); /* sys_cpupll */
+		au_writel(0x00, 0xb1900064); /* sys_auxpll */
+		au_writel(0x00, 0xb1900100); /* sys_pininputen */
+		break;
 
 	default:
 		break;
@@ -163,32 +181,23 @@
 
 void au1000_halt(void)
 {
-#if defined(CONFIG_MIPS_PB1550)
-	/* power off system */
-	printk("\n** Powering off Pb1550\n");
-	au_writew(au_readw(0xAF00001C) | (3<<14), 0xAF00001C); 
-	au_sync();
-	while(1); /* should not get here */
-#endif
-	printk(KERN_NOTICE "\n** You can safely turn off the power\n");
-#ifdef CONFIG_MIPS_MIRAGE
-	au_writel((1 << 26) | (1 << 10), GPIO2_OUTPUT);
-#endif
-#ifdef CONFIG_PM
-	au_sleep();
-
-	/* should not get here */
-	printk(KERN_ERR "Unable to put cpu in sleep mode\n");
-	while(1);
-#else
-	while (1)
+	/* Use WAIT in a low-power infinite spin loop */
+	while (1) {
 		__asm__(".set\tmips3\n\t"
 	                "wait\n\t"
 			".set\tmips0");
-#endif
+	}
 }
 
 void au1000_power_off(void)
 {
+	extern void board_power_off (void);
+
+	printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+
+	/* Give board a chance to power-off */
+	board_power_off();
+
+	/* If board can't power-off, spin forever */
 	au1000_halt();
 }
diff -Nur linux-2.4.30/arch/mips/au1000/common/setup.c linux-2.4.30-mips/arch/mips/au1000/common/setup.c
--- linux-2.4.30/arch/mips/au1000/common/setup.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/setup.c	2005-01-30 09:01:27.000000000 +0100
@@ -174,6 +174,40 @@
 	initrd_end = (unsigned long)&__rd_end;
 #endif
 
+#if defined(CONFIG_SOC_AU1200)
+#ifdef CONFIG_USB_EHCI_HCD
+	if ((argptr = strstr(argptr, "usb_ehci=")) == NULL) {
+	        char usb_args[80];
+		argptr = prom_getcmdline();
+		memset(usb_args, 0, sizeof(usb_args));
+		sprintf(usb_args, " usb_ehci=base:0x%x,len:0x%x,irq:%d",
+			USB_EHCI_BASE, USB_EHCI_LEN, AU1000_USB_HOST_INT);
+		strcat(argptr, usb_args);
+	}
+#ifdef CONFIG_USB_AMD5536UDC
+	/* enable EHC + OHC + UDC clocks, memory and bus mastering */
+/*	au_writel( 0x00DF207F, USB_MSR_BASE + 4); */
+	au_writel( 0xC0DF207F, USB_MSR_BASE + 4);  // incl. prefetch
+#else
+	/* enable EHC + OHC clocks, memory and bus mastering */
+/*	au_writel( 0x00DB200F, USB_MSR_BASE + 4); */
+	au_writel( 0xC0DB200F, USB_MSR_BASE + 4);  /* incl. prefetch */
+#endif
+	udelay(1000);
+
+#else /* CONFIG_USB_EHCI_HCD */
+
+#ifdef CONFIG_USB_AMD5536UDC
+#ifndef CONFIG_USB_OHCI
+	/* enable UDC clocks, memory and bus mastering */
+/*	au_writel( 0x00DC2070, USB_MSR_BASE + 4); */
+	au_writel( 0xC0DC2070, USB_MSR_BASE + 4);  // incl. prefetch
+	udelay(1000);
+#endif
+#endif
+#endif /* CONFIG_USB_EHCI_HCD */
+#endif /* CONFIG_SOC_AU1200 */
+
 #if defined (CONFIG_USB_OHCI) || defined (CONFIG_AU1X00_USB_DEVICE)
 #ifdef CONFIG_USB_OHCI
 	if ((argptr = strstr(argptr, "usb_ohci=")) == NULL) {
@@ -187,19 +221,38 @@
 #endif
 
 #ifdef CONFIG_USB_OHCI
-	// enable host controller and wait for reset done
+#if defined(CONFIG_SOC_AU1200)
+#ifndef CONFIG_USB_EHCI_HCD
+#ifdef CONFIG_USB_AMD5536UDC
+	/* enable OHC + UDC clocks, memory and bus mastering */
+/*	au_writel( 0x00DD2073, USB_MSR_BASE + 4); */
+	au_writel( 0xC0DD2073, USB_MSR_BASE + 4);  // incl. prefetch
+#else
+	/* enable OHC clocks, memory and bus mastering */
+	au_writel( 0x00D12003, USB_MSR_BASE + 4);
+#endif
+	udelay(1000);
+printk("DEBUG: Reading Au1200 USB2 reg 0x%x\n", au_readl(USB_MSR_BASE + 4));
+#endif
+#else
+	/* Au1000, Au1500, Au1100, Au1550 */
+	/* enable host controller and wait for reset done */
 	au_writel(0x08, USB_HOST_CONFIG);
 	udelay(1000);
 	au_writel(0x0E, USB_HOST_CONFIG);
 	udelay(1000);
-	au_readl(USB_HOST_CONFIG); // throw away first read
+	au_readl(USB_HOST_CONFIG); /* throw away first read */
 	while (!(au_readl(USB_HOST_CONFIG) & 0x10))
 		au_readl(USB_HOST_CONFIG);
+#endif /* CONFIG_SOC_AU1200 */
 #endif
-#endif // defined (CONFIG_USB_OHCI) || defined (CONFIG_AU1X00_USB_DEVICE)
+#else
+
+#endif /* defined (CONFIG_USB_OHCI) || defined (CONFIG_AU1X00_USB_DEVICE) */
+
 
 #ifdef CONFIG_FB
-	// Needed if PCI video card in use
+	/* Needed if PCI video card in use */
 	conswitchp = &dummy_con;
 #endif
 
@@ -209,8 +262,7 @@
 #endif
 
 #ifdef CONFIG_BLK_DEV_IDE
-	/* Board setup takes precedence for unique devices.
-	*/
+	/* Board setup takes precedence for unique devices.  */
 	if ((ide_ops == NULL) || (ide_ops == &no_ide_ops))
 		ide_ops = &std_ide_ops;
 #endif
diff -Nur linux-2.4.30/arch/mips/au1000/common/sleeper.S linux-2.4.30-mips/arch/mips/au1000/common/sleeper.S
--- linux-2.4.30/arch/mips/au1000/common/sleeper.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/sleeper.S	2005-01-30 09:01:27.000000000 +0100
@@ -15,17 +15,48 @@
 #include <asm/addrspace.h>
 #include <asm/regdef.h>
 #include <asm/stackframe.h>
+#include <asm/au1000.h>
+
+/*
+ * Note: This file is *not* conditional on CONFIG_PM since Alchemy sleep 
+ * need not be tied to any particular power management scheme.
+ */
+
+	.extern ___flush_cache_all
 
 	.text
-	.set	macro
-	.set	noat
 	.align	5
 
-/* Save all of the processor general registers and go to sleep.
- * A wakeup condition will get us back here to restore the registers.
+/*
+ * Save the processor general registers and go to sleep. A wakeup
+ * condition will get us back here to restore the registers.
  */
-LEAF(save_and_sleep)
 
+/* still need to fix alignment issues here */
+save_and_sleep_frmsz = 48
+NESTED(save_and_sleep, save_and_sleep_frmsz, ra)
+	.set noreorder
+	.set nomacro
+	.set noat
+	subu sp, save_and_sleep_frmsz
+	sw ra, save_and_sleep_frmsz-4(sp)
+	sw s0, save_and_sleep_frmsz-8(sp)
+	sw s1, save_and_sleep_frmsz-12(sp)
+	sw s2, save_and_sleep_frmsz-16(sp)
+	sw s3, save_and_sleep_frmsz-20(sp)
+	sw s4, save_and_sleep_frmsz-24(sp)
+	sw s5, save_and_sleep_frmsz-28(sp)
+	sw s6, save_and_sleep_frmsz-32(sp)
+	sw s7, save_and_sleep_frmsz-36(sp)
+	sw s8, save_and_sleep_frmsz-40(sp)
+	sw gp, save_and_sleep_frmsz-44(sp)
+
+	/* We only need to save the registers that the calling function 
+	 * hasn't saved for us.  0 is always zero.  8 - 15, 24 and 25 are 
+	 * temporaries and can be used without saving. 26 and 27 are reserved 
+	 * for interrupt/trap handling and expected to change.  29 is the 
+	 * stack pointer which is handled as a special case here.
+	 */
 	subu	sp, PT_SIZE
 	sw	$1, PT_R1(sp)
 	sw	$2, PT_R2(sp)
@@ -34,14 +65,6 @@
 	sw	$5, PT_R5(sp)
 	sw	$6, PT_R6(sp)
 	sw	$7, PT_R7(sp)
-	sw	$8, PT_R8(sp)
-	sw	$9, PT_R9(sp)
-	sw	$10, PT_R10(sp)
-	sw	$11, PT_R11(sp)
-	sw	$12, PT_R12(sp)
-	sw	$13, PT_R13(sp)
-	sw	$14, PT_R14(sp)
-	sw	$15, PT_R15(sp)
 	sw	$16, PT_R16(sp)
 	sw	$17, PT_R17(sp)
 	sw	$18, PT_R18(sp)
@@ -50,32 +73,47 @@
 	sw	$21, PT_R21(sp)
 	sw	$22, PT_R22(sp)
 	sw	$23, PT_R23(sp)
-	sw	$24, PT_R24(sp)
-	sw	$25, PT_R25(sp)
-	sw	$26, PT_R26(sp)
-	sw	$27, PT_R27(sp)
 	sw	$28, PT_R28(sp)
-	sw	$29, PT_R29(sp)
 	sw	$30, PT_R30(sp)
 	sw	$31, PT_R31(sp)
+#define PT_C0STATUS PT_LO
+#define PT_CONTEXT PT_HI
+#define PT_PAGEMASK PT_EPC
+#define PT_CONFIG PT_BVADDR
 	mfc0	k0, CP0_STATUS
-	sw	k0, 0x20(sp)
+	sw	k0, PT_C0STATUS(sp) // 0x20
 	mfc0	k0, CP0_CONTEXT
-	sw	k0, 0x1c(sp)
+	sw	k0, PT_CONTEXT(sp) // 0x1c
 	mfc0	k0, CP0_PAGEMASK
-	sw	k0, 0x18(sp)
+	sw	k0, PT_PAGEMASK(sp) // 0x18
 	mfc0	k0, CP0_CONFIG
-	sw	k0, 0x14(sp)
+	sw	k0, PT_CONFIG(sp) // 0x14
+
+	.set macro
+	.set at
+
+	li t0, SYS_SLPPWR
+	sw	zero, 0(t0)	/* Get the processor ready to sleep */
+	sync
 
 	/* Now set up the scratch registers so the boot rom will
 	 * return to this point upon wakeup.
+	 * sys_scratch0 : SP
+	 * sys_scratch1 : RA
+	 */
+	li	t0, SYS_SCRATCH0
+	li	t1, SYS_SCRATCH1
+	sw	sp, 0(t0)
+	la	k0, resume_from_sleep
+	sw	k0, 0(t1)
+
+/*
+ * Flush DCACHE to make sure context is in memory
 	 */
-	la	k0, 1f
-	lui	k1, 0xb190
-	ori	k1, 0x18
-	sw	sp, 0(k1)
-	ori 	k1, 0x1c
-	sw	k0, 0(k1)
+	la 	t1,___flush_cache_all   /* _flush_cache_all is a function pointer */
+	lw 	t0,0(t1)
+	jal t0
+	nop
 
 /* Put SDRAM into self refresh.  Preload instructions into cache,
  * issue a precharge, then auto refresh, then sleep commands to it.
@@ -88,30 +126,65 @@
  	cache	0x14, 96(t0)
 	.set	mips0
 
+	/* Put SDRAM to sleep */
 sdsleep:
-	lui 	k0, 0xb400
-	sw	zero, 0x001c(k0)	/* Precharge */
-	sw	zero, 0x0020(k0)	/* Auto refresh */
-	sw	zero, 0x0030(k0)	/* SDRAM sleep */
+	li 	a0, MEM_PHYS_ADDR
+	or 	a0, a0, 0xA0000000
+#if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1100) || defined(CONFIG_SOC_AU1500)
+	lw 	k0, MEM_SDMODE0(a0)
+	sw	zero, MEM_SDPRECMD(a0) 	/* Precharge */
+	sw	zero, MEM_SDAUTOREF(a0)	/* Auto Refresh */
+	sw	zero, MEM_SDSLEEP(a0)  	/* Sleep */
 	sync
-
-	lui 	k1, 0xb190
-	sw	zero, 0x0078(k1)	/* get ready  to sleep */
+#endif
+#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
+	sw	zero, MEM_SDPRECMD(a0) 	/* Precharge */
+	sw 	zero, MEM_SDSREF(a0)
+	
+	#lw 	t0, MEM_SDSTAT(a0)
+	#and t0, t0, 0x01000000
+	li 	t0, 0x01000000
+refresh_not_set:
+	lw 	t1, MEM_SDSTAT(a0)
+	and	t2, t1, t0
+	beq	zero, t2, refresh_not_set
+	nop
+
+	li	t0, ~0x30000000
+	lw 	t1, MEM_SDCONFIGA(a0)
+	and t1, t0, t1
+	sw 	t1, MEM_SDCONFIGA(a0)
 	sync
-	sw	zero, 0x007c(k1)	/* Put processor to sleep */
+#endif
+
+	li	t0, SYS_SLEEP
+	sw	zero, 0(t0)	/* Put processor to sleep */
 	sync
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
 
 	/* This is where we return upon wakeup.
 	 * Reload all of the registers and return.
 	 */
-1:	nop
-	lw	k0, 0x20(sp)
+resume_from_sleep:
+	nop
+	.set nomacro
+	.set noat
+
+	lw	k0, PT_C0STATUS(sp) // 0x20
 	mtc0	k0, CP0_STATUS
-	lw	k0, 0x1c(sp)
+	lw	k0, PT_CONTEXT(sp) // 0x1c
 	mtc0	k0, CP0_CONTEXT
-	lw	k0, 0x18(sp)
+	lw	k0, PT_PAGEMASK(sp) // 0x18
 	mtc0	k0, CP0_PAGEMASK
-	lw	k0, 0x14(sp)
+	lw	k0, PT_CONFIG(sp) // 0x14
 	mtc0	k0, CP0_CONFIG
 	lw	$1, PT_R1(sp)
 	lw	$2, PT_R2(sp)
@@ -120,14 +193,6 @@
 	lw	$5, PT_R5(sp)
 	lw	$6, PT_R6(sp)
 	lw	$7, PT_R7(sp)
-	lw	$8, PT_R8(sp)
-	lw	$9, PT_R9(sp)
-	lw	$10, PT_R10(sp)
-	lw	$11, PT_R11(sp)
-	lw	$12, PT_R12(sp)
-	lw	$13, PT_R13(sp)
-	lw	$14, PT_R14(sp)
-	lw	$15, PT_R15(sp)
 	lw	$16, PT_R16(sp)
 	lw	$17, PT_R17(sp)
 	lw	$18, PT_R18(sp)
@@ -136,15 +201,36 @@
 	lw	$21, PT_R21(sp)
 	lw	$22, PT_R22(sp)
 	lw	$23, PT_R23(sp)
-	lw	$24, PT_R24(sp)
-	lw	$25, PT_R25(sp)
-	lw	$26, PT_R26(sp)
-	lw	$27, PT_R27(sp)
 	lw	$28, PT_R28(sp)
-	lw	$29, PT_R29(sp)
 	lw	$30, PT_R30(sp)
 	lw	$31, PT_R31(sp)
+
+	.set macro
+	.set at
+
+	/* clear the wake source, but save it as the return value of the function */
+	li	t0, SYS_WAKESRC
+	lw v0, 0(t0)
+	sw v0, PT_R2(sp)
+	sw zero, 0(t0)
+
 	addiu	sp, PT_SIZE
 
+	lw gp, save_and_sleep_frmsz-44(sp)
+	lw s8, save_and_sleep_frmsz-40(sp)
+	lw s7, save_and_sleep_frmsz-36(sp)
+	lw s6, save_and_sleep_frmsz-32(sp)
+	lw s5, save_and_sleep_frmsz-28(sp)
+	lw s4, save_and_sleep_frmsz-24(sp)
+	lw s3, save_and_sleep_frmsz-20(sp)
+	lw s2, save_and_sleep_frmsz-16(sp)
+	lw s1, save_and_sleep_frmsz-12(sp)
+	lw s0, save_and_sleep_frmsz-8(sp)
+	lw ra, save_and_sleep_frmsz-4(sp)
+
+	addu sp, save_and_sleep_frmsz
 	jr	ra
+	nop
+	.set reorder
 END(save_and_sleep)
+
diff -Nur linux-2.4.30/arch/mips/au1000/common/time.c linux-2.4.30-mips/arch/mips/au1000/common/time.c
--- linux-2.4.30/arch/mips/au1000/common/time.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/common/time.c	2005-04-08 10:33:17.000000000 +0200
@@ -50,7 +50,6 @@
 #include <linux/mc146818rtc.h>
 #include <linux/timex.h>
 
-extern void startup_match20_interrupt(void);
 extern void do_softirq(void);
 extern volatile unsigned long wall_jiffies;
 unsigned long missed_heart_beats = 0;
@@ -59,14 +58,14 @@
 static unsigned long r4k_cur;    /* What counter should be at next timer irq */
 extern rwlock_t xtime_lock;
 int	no_au1xxx_32khz;
-void	(*au1k_wait_ptr)(void);
+extern int allow_au1k_wait; 	/* default off for CP0 Counter */
 
 /* Cycle counter value at the previous timer interrupt.. */
 static unsigned int timerhi = 0, timerlo = 0;
 
 #ifdef CONFIG_PM
 #define MATCH20_INC 328
-extern void startup_match20_interrupt(void);
+extern void startup_match20_interrupt(void (*handler)(int, void *, struct pt_regs *));
 static unsigned long last_pc0, last_match20;
 #endif
 
@@ -385,7 +384,6 @@
 {
         unsigned int est_freq;
 	extern unsigned long (*do_gettimeoffset)(void);
-	extern void au1k_wait(void);
 
 	printk("calculating r4koff... ");
 	r4k_offset = cal_r4koff();
@@ -437,9 +435,6 @@
 		au_writel(0, SYS_TOYWRITE);
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C0S);
 
-		au_writel(au_readl(SYS_WAKEMSK) | (1<<8), SYS_WAKEMSK);
-		au_writel(~0, SYS_WAKESRC);
-		au_sync();
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20);
 
 		/* setup match20 to interrupt once every 10ms */
@@ -447,13 +442,13 @@
 		au_writel(last_match20 + MATCH20_INC, SYS_TOYMATCH2);
 		au_sync();
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20);
-		startup_match20_interrupt();
+		startup_match20_interrupt(counter0_irq);
 
 		do_gettimeoffset = do_fast_pm_gettimeoffset;
 
 		/* We can use the real 'wait' instruction.
 		*/
-		au1k_wait_ptr = au1k_wait;
+		allow_au1k_wait = 1;
 	}
 
 #else
diff -Nur linux-2.4.30/arch/mips/au1000/db1x00/Makefile linux-2.4.30-mips/arch/mips/au1000/db1x00/Makefile
--- linux-2.4.30/arch/mips/au1000/db1x00/Makefile	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/db1x00/Makefile	2005-01-30 09:06:19.000000000 +0100
@@ -17,4 +17,11 @@
 obj-y := init.o board_setup.o irqmap.o
 obj-$(CONFIG_WM97XX_COMODULE) += mirage_ts.o
 
+ifdef CONFIG_MIPS_DB1100
+ifdef CONFIG_MMC
+obj-y += mmc_support.o
+export-objs += mmc_support.o
+endif
+endif
+
 include $(TOPDIR)/Rules.make
diff -Nur linux-2.4.30/arch/mips/au1000/db1x00/board_setup.c linux-2.4.30-mips/arch/mips/au1000/db1x00/board_setup.c
--- linux-2.4.30/arch/mips/au1000/db1x00/board_setup.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/db1x00/board_setup.c	2005-03-19 08:17:51.000000000 +0100
@@ -46,10 +46,22 @@
 #include <asm/au1000.h>
 #include <asm/db1x00.h>
 
-extern struct rtc_ops no_rtc_ops;
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX) && defined(CONFIG_MIPS_DB1550)
+#include <asm/au1xxx_dbdma.h>
+extern struct ide_ops *ide_ops;
+extern struct ide_ops au1xxx_ide_ops;
+extern u32 au1xxx_ide_virtbase;
+extern u64 au1xxx_ide_physbase;
+extern int au1xxx_ide_irq;
+
+/* Ddma */
+chan_tab_t *ide_read_ch, *ide_write_ch;
+u32 au1xxx_ide_ddma_enable = 0, switch4ddma = 1; // PIO+ddma
+
+dbdev_tab_t new_dbdev_tab_element = { DSCR_CMD0_THROTTLE, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 };
+#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX */
 
-/* not correct for db1550 */
-static BCSR * const bcsr = (BCSR *)0xAE000000;
+extern struct rtc_ops no_rtc_ops;
 
 void board_reset (void)
 {
@@ -57,6 +69,13 @@
 	au_writel(0x00000000, 0xAE00001C);
 }
 
+void board_power_off (void)
+{
+#ifdef CONFIG_MIPS_MIRAGE
+	au_writel((1 << 26) | (1 << 10), GPIO2_OUTPUT);
+#endif
+}
+
 void __init board_setup(void)
 {
 	u32 pin_func;
@@ -108,8 +127,42 @@
 	au_writel(0x02000200, GPIO2_OUTPUT);
 #endif
 
+#if defined(CONFIG_AU1XXX_SMC91111)
+#define CPLD_CONTROL (0xAF00000C)
+	{
+	extern uint32_t au1xxx_smc91111_base;
+	extern unsigned int au1xxx_smc91111_irq;
+	extern int au1xxx_smc91111_nowait;
+
+	au1xxx_smc91111_base = 0xAC000300;
+	au1xxx_smc91111_irq = AU1000_GPIO_8;
+	au1xxx_smc91111_nowait = 1;
+
+	/* set up the Static Bus timing - only 396Mhz */
+	bcsr->resets |= 0x7;
+	au_writel(0x00010003, MEM_STCFG0);
+	au_writel(0x000c00c0, MEM_STCFG2);
+	au_writel(0x85E1900D, MEM_STTIME2);
+	}
+#endif /* end CONFIG_SMC91111 */
 	au_sync();
 
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX) && defined(CONFIG_MIPS_DB1550)
+	/*
+	 * Iniz IDE parameters
+	 */
+	ide_ops = &au1xxx_ide_ops;
+	au1xxx_ide_irq = DAUGHTER_CARD_IRQ;
+	au1xxx_ide_physbase = AU1XXX_ATA_PHYS_ADDR;
+	au1xxx_ide_virtbase = KSEG1ADDR(AU1XXX_ATA_PHYS_ADDR);
+
+	/*
+	 * change PIO or PIO+Ddma
+	 * check the GPIO-6 pin condition. db1550:s6_dot
+	 */
+	switch4ddma = (au_readl(SYS_PINSTATERD) & (1 << 6)) ? 1 : 0;
+#endif
+
 #ifdef CONFIG_MIPS_DB1000
     printk("AMD Alchemy Au1000/Db1000 Board\n");
 #endif
diff -Nur linux-2.4.30/arch/mips/au1000/db1x00/irqmap.c linux-2.4.30-mips/arch/mips/au1000/db1x00/irqmap.c
--- linux-2.4.30/arch/mips/au1000/db1x00/irqmap.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/db1x00/irqmap.c	2005-01-30 09:06:19.000000000 +0100
@@ -53,6 +53,7 @@
 #ifdef CONFIG_MIPS_DB1550
 	{ AU1000_GPIO_3, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 0 IRQ#
 	{ AU1000_GPIO_5, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 1 IRQ#
+	{ AU1000_GPIO_8, INTC_INT_LOW_LEVEL, 0 }, // Daughtercard IRQ#
 #else
 	{ AU1000_GPIO_0, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 0 Fully_Interted#
 	{ AU1000_GPIO_1, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 0 STSCHG#
diff -Nur linux-2.4.30/arch/mips/au1000/db1x00/mmc_support.c linux-2.4.30-mips/arch/mips/au1000/db1x00/mmc_support.c
--- linux-2.4.30/arch/mips/au1000/db1x00/mmc_support.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/db1x00/mmc_support.c	2005-01-30 09:07:01.000000000 +0100
@@ -0,0 +1,126 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *
+ *	MMC support routines for DB1100.
+ *
+ *
+ * Copyright (c) 2003-2004 Embedded Edge, LLC.
+ * Author: Embedded Edge, LLC.
+ * Contact: dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/irq.h>
+#include <asm/au1000.h>
+#include <asm/au1100_mmc.h>
+#include <asm/db1x00.h>
+
+
+/* SD/MMC controller support functions */
+
+/*
+ * Detect card.
+ */
+void mmc_card_inserted(int _n_, int *_res_)
+{
+	u32 gpios = au_readl(SYS_PINSTATERD);
+	u32 emptybit = (_n_) ? (1<<20) : (1<<19);
+	*_res_ = ((gpios & emptybit) == 0);
+}
+
+/*
+ * Check card write protection.
+ */
+void mmc_card_writable(int _n_, int *_res_)
+{
+	BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	unsigned long mmc_wp, board_specific;
+
+	if (_n_) {
+		mmc_wp = BCSR_BOARD_SD1_WP;
+	} else {
+		mmc_wp = BCSR_BOARD_SD0_WP;
+	}
+
+	board_specific = au_readl((unsigned long)(&bcsr->specific));
+
+	if (!(board_specific & mmc_wp)) {/* low means card writable */
+		*_res_ = 1;
+	} else {
+		*_res_ = 0;
+	}
+}
+
+/*
+ * Apply power to card slot.
+ */
+void mmc_power_on(int _n_)
+{
+	BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	unsigned long mmc_pwr, board_specific;
+
+	if (_n_) {
+		mmc_pwr = BCSR_BOARD_SD1_PWR;
+	} else {
+		mmc_pwr = BCSR_BOARD_SD0_PWR;
+	}
+
+	board_specific = au_readl((unsigned long)(&bcsr->specific));
+	board_specific |= mmc_pwr;
+
+	au_writel(board_specific, (int)(&bcsr->specific));
+	au_sync_delay(1);
+}
+
+/*
+ * Remove power from card slot.
+ */
+void mmc_power_off(int _n_)
+{
+	BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	unsigned long mmc_pwr, board_specific;
+
+	if (_n_) {
+		mmc_pwr = BCSR_BOARD_SD1_PWR;
+	} else {
+		mmc_pwr = BCSR_BOARD_SD0_PWR;
+	}
+
+	board_specific = au_readl((unsigned long)(&bcsr->specific));
+	board_specific &= ~mmc_pwr;
+
+	au_writel(board_specific, (int)(&bcsr->specific));
+	au_sync_delay(1);
+}
+
+EXPORT_SYMBOL(mmc_card_inserted);
+EXPORT_SYMBOL(mmc_card_writable);
+EXPORT_SYMBOL(mmc_power_on);
+EXPORT_SYMBOL(mmc_power_off);
+
diff -Nur linux-2.4.30/arch/mips/au1000/ficmmp/Makefile linux-2.4.30-mips/arch/mips/au1000/ficmmp/Makefile
--- linux-2.4.30/arch/mips/au1000/ficmmp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/ficmmp/Makefile	2005-01-30 09:01:27.000000000 +0100
@@ -0,0 +1,25 @@
+#
+#  Copyright 2000 MontaVista Software Inc.
+#  Author: MontaVista Software, Inc.
+#     	ppopov@mvista.com or source@mvista.com
+#
+# Makefile for the Alchemy Semiconductor FIC board.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+USE_STANDARD_AS_RULE := true
+
+O_TARGET := ficmmp.o
+
+obj-y := init.o board_setup.o irqmap.o au1200_ibutton.o au1xxx_dock.o
+
+ifdef CONFIG_MMC
+obj-y += mmc_support.o
+export-objs +=mmc_support.o
+endif
+
+
+include $(TOPDIR)/Rules.make
diff -Nur linux-2.4.30/arch/mips/au1000/ficmmp/au1200_ibutton.c linux-2.4.30-mips/arch/mips/au1000/ficmmp/au1200_ibutton.c
--- linux-2.4.30/arch/mips/au1000/ficmmp/au1200_ibutton.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/ficmmp/au1200_ibutton.c	2005-02-03 07:35:29.000000000 +0100
@@ -0,0 +1,270 @@
+/* ---------------------------------------------------------------------- 
+ *  mtwilson_keys.c
+ *
+ *  Copyright (C) 2003 Intrinsyc Software Inc.
+ *
+ *  Intel Personal Media Player buttons
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  May 02, 2003 : Initial version [FB]
+ *
+ ------------------------------------------------------------------------*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/miscdevice.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+
+#include <asm/au1000.h>
+#include <asm/uaccess.h>
+#include <asm/au1xxx_gpio.h>
+#include <asm/irq.h>
+#include <asm/keyboard.h>
+#include <linux/time.h>
+
+#define DRIVER_VERSION	"V1.0"
+#define DRIVER_AUTHOR	"FIC"
+#define DRIVER_DESC		"FIC Travis Media Player Button Driver"
+#define DRIVER_NAME		"Au1200Button"
+
+#define BUTTON_MAIN		(1<<1)
+#define BUTTON_SELECT	(1<<6)
+#define BUTTON_GUIDE	(1<<12)
+#define BUTTON_DOWN		(1<<17)
+#define BUTTON_LEFT		(1<<19)
+#define BUTTON_RIGHT	(1<<26)
+#define BUTTON_UP		(1<<28)
+
+#define BUTTON_MASK (\
+    BUTTON_MAIN   \
+    | BUTTON_SELECT	\
+    | BUTTON_GUIDE	\
+    | BUTTON_DOWN	\
+    | BUTTON_LEFT	\
+    | BUTTON_RIGHT	\
+    | BUTTON_UP		\
+    )
+
+#define BUTTON_INVERT (\
+    BUTTON_MAIN   \
+    | 0				\
+    | BUTTON_GUIDE	\
+    | 0				\
+    | 0				\
+    | 0				\
+    | 0				\
+    )
+
+char button_map[32]={0,KEY_S,0,0,0,0,KEY_ENTER,0,0,0,0,0,KEY_G,0,0,0,0,KEY_DOWN,0,KEY_LEFT,0,0,0,0,0,0,KEY_RIGHT,0,KEY_UP,0,0,0};
+//char button_map[32]={0,0,0,0,0,0,KEY_ENTER,0,0,0,0,0,KEY_G,0,0,0,0,KEY_DOWN,0,KEY_LEFT,0,0,0,0,0,0,KEY_RIGHT,0,KEY_UP,0,0,0};
+
+//char button_map[32]={0,KEY_TAB,0,0,0,0,KEY_M,0,0,0,0,0,KEY_S,0,0,0,0,KEY_DOWN,0,KEY_LEFT,0,0,0,0,0,0,KEY_RIGHT,0,KEY_UP,0,0,0};
+//char button_map[32]={0,0,0,0,0,0,KEY_M,0,0,0,0,0,KEY_S,0,0,0,0,KEY_DOWN,0,KEY_LEFT,0,0,0,0,0,0,KEY_RIGHT,0,KEY_UP,0,0,0};
+
+#define BUTTON_COUNT (sizeof (button_map) / sizeof (button_map[0]))
+
+struct input_dev dev;
+struct timeval cur_tv;
+
+static unsigned int old_tv_usec = 0;
+
+static unsigned int read_button_state(void)
+{
+	unsigned int state;
+
+	state = au_readl(SYS_PINSTATERD) & BUTTON_MASK; /* get gpio status */
+
+	state ^= BUTTON_INVERT;		/* invert main & guide button */
+
+	/* printk("au1200_ibutton.c: button state [0x%X]\r\n",state); */
+	return state;
+}
+
+//This function returns 0 if the allowed microseconds have elapsed since the last call to ths function, otherwise it returns 1 to indicate a bounce condition
+static unsigned int bounce() 
+{
+
+	unsigned int elapsed_time;
+
+	do_gettimeofday (&cur_tv);    
+
+	if (!old_tv_usec) {
+		old_tv_usec = cur_tv.tv_usec;
+		return 0;
+	}
+
+	if(cur_tv.tv_usec > old_tv_usec) {
+		/* If there hasn't been rollover */
+		elapsed_time =  ((cur_tv.tv_usec - old_tv_usec));
+	}
+	else {
+		/* Accounting for rollover */
+		elapsed_time =  ((1000000 - old_tv_usec + cur_tv.tv_usec));
+	}
+
+	if (elapsed_time > 250000) {
+		old_tv_usec = 0;	/* reset the bounce time */
+		return 0;
+	}
+
+	return 1;
+}
+
+/* button interrupt handler */
+static void button_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+
+	unsigned int i,bit_mask, key_choice;
+	u32 button_state;
+	
+	/* Report state to upper level */
+	
+	button_state = read_button_state() & BUTTON_MASK; /* get new gpio status */
+
+	/* Return if this is a repeated (bouncing) event */
+	if(bounce())
+		return;
+
+	/* we want to make keystrokes */
+	for( i=0; i< BUTTON_COUNT; i++) {
+		bit_mask = 1<<i;
+		if (button_state & bit_mask) {
+			key_choice = button_map[i];
+			/* toggle key down */
+			input_report_key(dev, key_choice, 1);
+			/* toggle key up */
+			input_report_key(dev, key_choice, 0);
+			printk("ibutton gpio %d stat %x scan code %d\r\n", 
+					i, button_state, key_choice);
+			/* Only report the first key event; it doesn't make 
+			 * sense for two keys to be pressed at the same time, 
+			 * and causes problems with the directional keys 
+			 * return;	
+			 */
+		}
+	}
+}
+
+static int 
+button_translate(unsigned char scancode, unsigned char *keycode, char raw_mode) 
+{
+	static int prev_scancode;
+	
+	printk( "ibutton.c: translate: scancode=%x raw_mode=%x\n", 
+			scancode, raw_mode);
+
+	if (scancode == 0xe0 || scancode == 0xe1) {
+		prev_scancode = scancode;
+		return 0;
+	}
+
+	if (scancode == 0x00 || scancode == 0xff) {
+		prev_scancode = 0;
+		return 0;
+	}
+
+	*keycode = scancode;
+
+	return 1;
+}
+
+/* init button hardware */
+static int button_hw_init(void)
+{
+	unsigned int	ipinfunc=0;	
+
+	printk("au1200_ibutton.c: Initializing buttons hardware\n");
+
+	// initialize GPIO pin function assignments	
+
+	ipinfunc = au_readl(SYS_PINFUNC);
+
+	ipinfunc &= ~(SYS_PINFUNC_DMA | SYS_PINFUNC_S0A | SYS_PINFUNC_S0B);	
+	au_writel( ipinfunc ,SYS_PINFUNC);
+	
+	ipinfunc |=  (SYS_PINFUNC_S0C);
+	au_writel( ipinfunc ,SYS_PINFUNC);
+	
+	return 0;
+}
+
+/* button driver init */
+static int __init button_init(void)
+{
+	int ret, i;
+	unsigned int flag=0;
+
+	printk("au1200_ibutton.c: button_init()\r\n");
+	
+	button_hw_init();
+	
+	/* register all button irq handler */
+	
+	for(i=0; i< sizeof(button_map)/sizeof(button_map[0]); i++)
+	{
+		/* register irq <-- gpio 1 ,6 ,12 , 17 ,19 , 26 ,28 */
+		if(button_map[i] != 0)	
+		{
+			ret = request_irq(AU1000_GPIO_0 + i , 
+					&button_interrupt , SA_INTERRUPT , 
+					DRIVER_NAME , &dev);
+			if(ret) flag |= 1<<i;
+		}
+	}
+
+	printk("au1200_ibutton.c: request_irq,ret:0x%x\r\n",ret);
+	
+	if (ret) {
+		printk("au1200_ibutton.c: request_irq:%X failed\r\n",flag);
+		return ret;
+	}
+		
+	dev.name = DRIVER_NAME;
+	dev.evbit[0] = BIT(EV_KEY) | BIT(EV_REP);
+
+	for (i=0;i<sizeof(button_map)/sizeof(button_map[0]);i++)
+	{
+		dev.keybit[LONG(button_map[i])] |= BIT(button_map[i]);
+	}
+	
+	input_register_device(&dev);
+
+	/* ready to receive interrupts */
+
+	return 0;
+}
+
+/* button driver exit */
+static void __exit button_exit(void)
+{
+	int i;
+	
+	for(i=0;i<sizeof(button_map)/sizeof(button_map[0]);i++)
+	{
+		if(button_map[i] != 0)
+		{
+			free_irq( AU1000_GPIO_0 + i, &dev);
+		}
+	}
+	
+	input_unregister_device(&dev);
+	
+	printk("au1200_ibutton.c: button_exit()\r\n");
+}
+
+module_init(button_init);
+module_exit(button_exit);
+
+MODULE_AUTHOR( DRIVER_AUTHOR );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE("GPL");
diff -Nur linux-2.4.30/arch/mips/au1000/ficmmp/au1xxx_dock.c linux-2.4.30-mips/arch/mips/au1000/ficmmp/au1xxx_dock.c
--- linux-2.4.30/arch/mips/au1000/ficmmp/au1xxx_dock.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/ficmmp/au1xxx_dock.c	2005-01-30 09:01:27.000000000 +0100
@@ -0,0 +1,261 @@
+/*
+ *  Copyright (C) 2003 Metrowerks, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/miscdevice.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <asm/au1000.h>
+#include <asm/uaccess.h>
+#include <asm/au1xxx_gpio.h>
+
+
+#if defined(CONFIG_MIPS_FICMMP)
+	#define DOCK_GPIO	215
+#else
+	#error Unsupported Au1xxx Platform
+#endif
+
+#define MAKE_FLAG 0x20
+
+#undef DEBUG
+
+#define DEBUG 0
+//#define DEBUG 1
+
+#if DEBUG
+#define DPRINTK(format, args...) printk(__FUNCTION__ ": "  format, ## args)
+#else
+#define DPRINTK(format, args...) do { } while (0)
+#endif
+
+/* Please note that this driver is based on a timer and is not interrupt
+ * driven.  If you are going to make use of this driver, you will need to have
+ * your application open the dock listing from the /dev directory first.
+ */
+
+struct au1xxx_dock {
+	struct fasync_struct *fasync;
+	wait_queue_head_t     read_wait;
+	int open_count;
+	unsigned int debounce;
+	unsigned int current;
+	unsigned int last;
+};
+
+static struct au1xxx_dock dock_info;
+
+
+static void dock_timer_periodic(void *data);
+
+static struct tq_struct dock_task = {
+	routine:	dock_timer_periodic,
+	data:		NULL
+};
+
+static int cleanup_flag = 0;
+static DECLARE_WAIT_QUEUE_HEAD(cleanup_wait_queue);
+
+
+static unsigned int read_dock_state(void)
+{
+	u32 state;
+
+	state = au1xxx_gpio_read(DOCK_GPIO);
+	
+	/* printk( "Current Dock State: %d\n", state ); */
+
+	return state;
+}
+
+
+static void dock_timer_periodic(void *data)
+{
+	struct au1xxx_dock *dock = (struct au1xxx_dock *)data;
+	unsigned long dock_state;
+	
+	/* If cleanup wants us to die */
+	if (cleanup_flag) {
+		/* now cleanup_module can return */
+		wake_up(&cleanup_wait_queue); 
+	} else {
+		/* put ourselves back in the task queue */
+		queue_task(&dock_task, &tq_timer);	
+	}
+
+	/* read current dock */
+	dock_state = read_dock_state();
+
+	/* if dock states hasn't changed */
+	/* save time and be done. */
+	if (dock_state == dock->current) {
+		return;
+	}
+	
+	if (dock_state == dock->debounce) {
+		dock->current = dock_state;
+	} else {
+		dock->debounce = dock_state;
+	}
+	if (dock->current != dock->last) {
+		if (waitqueue_active(&dock->read_wait)) {
+		    wake_up_interruptible(&dock->read_wait);
+		}
+	}
+}
+
+
+static ssize_t au1xxx_dock_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
+{
+	struct au1xxx_dock *dock = filp->private_data;
+	char event[3];
+	int last;
+	int cur;
+	int err;
+	
+try_again:
+
+	while (dock->current == dock->last) {
+		if (filp->f_flags & O_NONBLOCK) {
+			return -EAGAIN;
+		}
+		interruptible_sleep_on(&dock->read_wait);
+		if (signal_pending(current)) {
+			return -ERESTARTSYS;
+		}
+	}
+	
+	cur  = dock->current;
+	last = dock->last;
+
+	if(cur != last)
+	{
+		event[0] = cur ? 'D' : 'U';
+		event[1] = '\r';
+		event[2] = '\n';
+	}
+	else
+		goto try_again;
+	
+	dock->last = cur;
+	err = copy_to_user(buffer, &event, 3);
+	if (err) {
+		return err;
+	}
+	
+	return 3;
+}
+
+
+static int au1xxx_dock_open(struct inode *inode, struct file *filp)
+{
+	struct au1xxx_dock *dock = &dock_info;
+
+	MOD_INC_USE_COUNT;
+
+	filp->private_data = dock;
+
+	if (dock->open_count++ == 0) {
+		dock_task.data = dock;
+		cleanup_flag = 0;
+		queue_task(&dock_task, &tq_timer);
+	}
+
+	return 0;
+}
+
+
+static unsigned int au1xxx_dock_poll(struct file *filp, poll_table *wait)
+{
+	struct au1xxx_dock *dock = filp->private_data;
+	int ret = 0;
+
+	DPRINTK("start\n");
+	poll_wait(filp, &dock->read_wait, wait);
+	if (dock->current != dock->last) {
+		ret = POLLIN | POLLRDNORM;
+	}
+	return ret;
+}
+
+
+static int au1xxx_dock_release(struct inode *inode, struct file *filp)
+{
+	struct au1xxx_dock *dock = filp->private_data;
+
+	DPRINTK("start\n");
+
+	if (--dock->open_count == 0) {
+		cleanup_flag = 1;
+		sleep_on(&cleanup_wait_queue);
+	}
+	MOD_DEC_USE_COUNT;
+	
+	return 0;
+}
+
+
+
+static struct file_operations au1xxx_dock_fops = {
+	owner:		THIS_MODULE,
+	read:		au1xxx_dock_read,
+	poll:		au1xxx_dock_poll,
+	open:		au1xxx_dock_open,
+	release:	au1xxx_dock_release,
+};
+
+/*
+ * The au1xxx dock is a misc device:
+ * Major 10 char
+ * Minor 22        /dev/dock
+ * 
+ * This is /dev/misc/dock if devfs is used.
+ */
+
+static struct miscdevice au1xxx_dock_dev = {
+	minor:	23,
+	name:	"dock",
+	fops:	&au1xxx_dock_fops,
+};
+
+static int __init au1xxx_dock_init(void)
+{
+	struct au1xxx_dock *dock = &dock_info;
+	int ret;
+
+	DPRINTK("Initializing dock driver\n");
+	dock->open_count = 0;
+	cleanup_flag        = 0;
+	init_waitqueue_head(&dock->read_wait);
+
+
+	/* yamon configures GPIO pins for the dock
+	 * no initialization needed
+	 */
+
+	ret = misc_register(&au1xxx_dock_dev);
+
+	DPRINTK("dock driver fully initialized.\n");
+
+	return ret;
+}
+
+
+static void __exit au1xxx_dock_exit(void)
+{
+	DPRINTK("unloading dock driver\n");
+	misc_deregister(&au1xxx_dock_dev);
+}
+
+
+module_init(au1xxx_dock_init);
+module_exit(au1xxx_dock_exit);
diff -Nur linux-2.4.30/arch/mips/au1000/ficmmp/board_setup.c linux-2.4.30-mips/arch/mips/au1000/ficmmp/board_setup.c
--- linux-2.4.30/arch/mips/au1000/ficmmp/board_setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/ficmmp/board_setup.c	2005-03-19 08:17:51.000000000 +0100
@@ -0,0 +1,226 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Alchemy Pb1200 board setup.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/mc146818rtc.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+#include <linux/ide.h>
+#endif
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/keyboard.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/au1000.h>
+#include <asm/ficmmp.h>
+#include <asm/au1xxx_dbdma.h>
+#include <asm/au1xxx_gpio.h>
+
+extern struct rtc_ops no_rtc_ops;
+
+/* value currently in the board configuration register */
+u16 ficmmp_config = 0;
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+extern struct ide_ops *ide_ops;
+extern struct ide_ops au1xxx_ide_ops;
+extern u32 au1xxx_ide_virtbase;
+extern u64 au1xxx_ide_physbase;
+extern int au1xxx_ide_irq;
+
+u32 led_base_addr;
+/* Ddma */
+chan_tab_t *ide_read_ch, *ide_write_ch;
+u32 au1xxx_ide_ddma_enable = 0, switch4ddma = 1; // PIO+ddma
+
+dbdev_tab_t new_dbdev_tab_element = { DSCR_CMD0_THROTTLE, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 };
+#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX */
+
+void board_reset (void)
+{
+	au_writel(0, 0xAD80001C);
+}
+
+void board_power_off (void)
+{
+}
+
+void __init board_setup(void)
+{
+	char *argptr = NULL;
+	u32 pin_func;
+	rtc_ops = &no_rtc_ops;
+
+	ficmmp_config_init();	//Initialize FIC control register
+	
+#if 0
+	/* Enable PSC1 SYNC for AC97.  Normaly done in audio driver,
+	 * but it is board specific code, so put it here.
+	 */
+	pin_func = au_readl(SYS_PINFUNC);
+	au_sync();
+	pin_func |= SYS_PF_MUST_BE_SET | SYS_PF_PSC1_S1;
+	au_writel(pin_func, SYS_PINFUNC);
+
+	au_writel(0, (u32)bcsr|0x10); /* turn off pcmcia power */
+	au_sync();
+#endif
+
+#if defined( CONFIG_I2C_ALGO_AU1550 )
+	{
+	u32 freq0, clksrc;
+
+	/* Select SMBUS in CPLD */
+	/* bcsr->resets &= ~(BCSR_RESETS_PCS0MUX); */
+
+	pin_func = au_readl(SYS_PINFUNC);
+	au_sync();
+	pin_func &= ~(3<<17 | 1<<4);
+	/* Set GPIOs correctly */
+	pin_func |= 2<<17;
+	au_writel(pin_func, SYS_PINFUNC);
+	au_sync();
+
+	/* The i2c driver depends on 50Mhz clock */
+	freq0 = au_readl(SYS_FREQCTRL0);
+	au_sync();
+	freq0 &= ~(SYS_FC_FRDIV1_MASK | SYS_FC_FS1 | SYS_FC_FE1);
+	freq0 |= (3<<SYS_FC_FRDIV1_BIT);
+	/* 396Mhz / (3+1)*2 == 49.5Mhz */
+	au_writel(freq0, SYS_FREQCTRL0);
+	au_sync();
+	freq0 |= SYS_FC_FE1;
+	au_writel(freq0, SYS_FREQCTRL0);
+	au_sync();
+
+	clksrc = au_readl(SYS_CLKSRC);
+	au_sync();
+	clksrc &= ~0x01f00000;
+	/* bit 22 is EXTCLK0 for PSC0 */
+	clksrc |= (0x3 << 22);
+	au_writel(clksrc, SYS_CLKSRC);
+	au_sync();
+	}
+#endif
+
+#ifdef CONFIG_FB_AU1200
+	argptr = prom_getcmdline();
+	strcat(argptr, " video=au1200fb:");
+#endif
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+	/*
+	 * Iniz IDE parameters
+	 */
+	ide_ops = &au1xxx_ide_ops;
+	au1xxx_ide_irq = FICMMP_IDE_INT;
+	au1xxx_ide_physbase = AU1XXX_ATA_PHYS_ADDR;
+	au1xxx_ide_virtbase = KSEG1ADDR(AU1XXX_ATA_PHYS_ADDR);
+	switch4ddma = 0;
+	/*
+	ide_ops = &au1xxx_ide_ops;
+	au1xxx_ide_irq = FICMMP_IDE_INT;
+	au1xxx_ide_base = KSEG1ADDR(AU1XXX_ATA_BASE);
+	*/
+	au1xxx_gpio_write(9, 1);
+	printk("B4001010: %X\n", *((u32*)0xB4001010));
+	printk("B4001014: %X\n", *((u32*)0xB4001014));
+	printk("B4001018: %X\n", *((u32*)0xB4001018));
+	printk("B1900100: %X\n", *((u32*)0xB1900100));
+	
+#if 0
+	ficmmp_config_clear(FICMMP_CONFIG_IDERST);
+	mdelay(100);
+	ficmmp_config_set(FICMMP_CONFIG_IDERST);
+	mdelay(100);
+#endif
+	/*
+	 * change PIO or PIO+Ddma
+	 * check the GPIO-5 pin condition. pb1200:s18_dot
+	 */
+/*	switch4ddma = 0; //(au_readl(SYS_PINSTATERD) & (1 << 5)) ? 1 : 0; */
+#endif
+
+	/* The Pb1200 development board uses external MUX for PSC0 to
+	support SMB/SPI. bcsr->resets bit 12: 0=SMB 1=SPI
+	*/
+#if defined(CONFIG_AU1550_PSC_SPI) && defined(CONFIG_I2C_ALGO_AU1550)
+	#error I2C and SPI are mutually exclusive. Both are physically connected to PSC0.\
+			Refer to Pb1200 documentation.
+#elif defined( CONFIG_AU1550_PSC_SPI )
+	//bcsr->resets |= BCSR_RESETS_PCS0MUX;
+#elif defined( CONFIG_I2C_ALGO_AU1550 )
+	//bcsr->resets &= (~BCSR_RESETS_PCS0MUX);
+#endif
+	au_sync();
+
+	printk("FIC Multimedia Player Board\n");
+	au1xxx_gpio_tristate(5);
+	printk("B1900100: %X\n", *((volatile u32*)0xB1900100));
+	printk("B190002C: %X\n", *((volatile u32*)0xB190002C));
+}
+
+int
+board_au1200fb_panel (void)
+{
+	au1xxx_gpio_tristate(6);
+
+	if (au1xxx_gpio_read(12) == 0)
+		return 9; /* FS453_640x480 (Composite/S-Video) */
+	else
+		return 7; /* Sharp 320x240 TFT */
+}
+
+int
+board_au1200fb_panel_init (void)
+{
+	/*Enable data buffers*/
+	ficmmp_config_clear(FICMMP_CONFIG_LCMDATAOUT);
+	/*Take LCD out of reset*/
+	ficmmp_config_set(FICMMP_CONFIG_LCMPWREN | FICMMP_CONFIG_LCMEN);
+	return 0;
+}
+
+int 
+board_au1200fb_panel_shutdown (void)
+{
+	/*Disable data buffers*/
+	ficmmp_config_set(FICMMP_CONFIG_LCMDATAOUT);
+	/*Put LCD in reset, remove power*/
+	ficmmp_config_clear(FICMMP_CONFIG_LCMEN | FICMMP_CONFIG_LCMPWREN);
+	return 0;
+}
+
diff -Nur linux-2.4.30/arch/mips/au1000/ficmmp/init.c linux-2.4.30-mips/arch/mips/au1000/ficmmp/init.c
--- linux-2.4.30/arch/mips/au1000/ficmmp/init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/ficmmp/init.c	2005-01-30 09:01:27.000000000 +0100
@@ -0,0 +1,76 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	PB1200 board setup
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <linux/config.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+extern void  __init prom_init_cmdline(void);
+extern char *prom_getenv(char *envname);
+
+const char *get_system_type(void)
+{
+	return "FIC Multimedia Player (Au1200)";
+}
+
+u32 mae_memsize = 0;
+
+int __init prom_init(int argc, char **argv, char **envp, int *prom_vec)
+{
+	unsigned char *memsize_str;
+	unsigned long memsize;
+
+	prom_argc = argc;
+	prom_argv = argv;
+	prom_envp = envp;
+
+	mips_machgroup = MACH_GROUP_ALCHEMY;
+	mips_machtype = MACH_PB1000;	/* set the platform # */   
+	prom_init_cmdline();
+
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x08000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+
+	/* reserved 32MB for MAE driver */
+	memsize -= (32 * 1024 * 1024);
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+	mae_memsize = memsize; /* for drivers/char/au1xxx_mae.c */
+	return 0;
+}
+
diff -Nur linux-2.4.30/arch/mips/au1000/ficmmp/irqmap.c linux-2.4.30-mips/arch/mips/au1000/ficmmp/irqmap.c
--- linux-2.4.30/arch/mips/au1000/ficmmp/irqmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/ficmmp/irqmap.c	2005-01-30 09:01:27.000000000 +0100
@@ -0,0 +1,61 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1xxx irq map table
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/au1000.h>
+#include <asm/ficmmp.h>
+
+au1xxx_irq_map_t au1xxx_irq_map[] = {
+	{ FICMMP_IDE_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1XXX_SMC91111_IRQ, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_GPIO_1 , INTC_INT_FALL_EDGE, 0 },		// main button
+	{ AU1000_GPIO_6 , INTC_INT_RISE_EDGE, 0 },		// select button
+	{ AU1000_GPIO_12, INTC_INT_FALL_EDGE, 0 },		// guide button
+	{ AU1000_GPIO_17, INTC_INT_RISE_EDGE, 0 },		// down button
+	{ AU1000_GPIO_19, INTC_INT_RISE_EDGE, 0 },		// left button
+	{ AU1000_GPIO_26, INTC_INT_RISE_EDGE, 0 },		// right button
+	{ AU1000_GPIO_28, INTC_INT_RISE_EDGE, 0 },		// up button
+};
+
+int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
+
diff -Nur linux-2.4.30/arch/mips/au1000/hydrogen3/Makefile linux-2.4.30-mips/arch/mips/au1000/hydrogen3/Makefile
--- linux-2.4.30/arch/mips/au1000/hydrogen3/Makefile	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/hydrogen3/Makefile	2005-02-11 22:09:55.000000000 +0100
@@ -14,6 +14,11 @@
 
 O_TARGET := hydrogen3.o
 
-obj-y := init.o board_setup.o irqmap.o
+obj-y := init.o board_setup.o irqmap.o buttons.o
+
+ifdef CONFIG_MMC
+obj-y += mmc_support.o
+export-objs +=mmc_support.o
+endif
 
 include $(TOPDIR)/Rules.make
diff -Nur linux-2.4.30/arch/mips/au1000/hydrogen3/board_setup.c linux-2.4.30-mips/arch/mips/au1000/hydrogen3/board_setup.c
--- linux-2.4.30/arch/mips/au1000/hydrogen3/board_setup.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/hydrogen3/board_setup.c	2005-03-19 08:17:51.000000000 +0100
@@ -51,12 +51,19 @@
 {
 }
 
+void board_power_off (void)
+{
+}
+
 void __init board_setup(void)
 {
 	u32 pin_func;
 
 	rtc_ops = &no_rtc_ops;
 
+	/* Set GPIO14 high to make CD/DAT1 high for MMC to work */
+	au_writel(1<<14, SYS_OUTPUTSET);
+
 #ifdef CONFIG_AU1X00_USB_DEVICE
 	// 2nd USB port is USB device
 	pin_func = au_readl(SYS_PINFUNC) & (u32)(~0x8000);
diff -Nur linux-2.4.30/arch/mips/au1000/hydrogen3/buttons.c linux-2.4.30-mips/arch/mips/au1000/hydrogen3/buttons.c
--- linux-2.4.30/arch/mips/au1000/hydrogen3/buttons.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/hydrogen3/buttons.c	2005-02-11 22:09:55.000000000 +0100
@@ -0,0 +1,308 @@
+/*
+ *  Copyright (C) 2003 Metrowerks, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/miscdevice.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <asm/au1000.h>
+#include <asm/uaccess.h>
+
+#define BUTTON_SELECT	(1<<1)
+#define BUTTON_1	(1<<2)
+#define BUTTON_2	(1<<3)
+#define BUTTON_ONOFF	(1<<6)
+#define BUTTON_3	(1<<7)
+#define BUTTON_4	(1<<8)
+#define BUTTON_LEFT	(1<<9)
+#define BUTTON_DOWN	(1<<10)
+#define BUTTON_RIGHT	(1<<11)
+#define BUTTON_UP	(1<<12)
+
+#define BUTTON_MASK (\
+    BUTTON_SELECT	\
+    | BUTTON_1   	\
+    | BUTTON_2		\
+    | BUTTON_ONOFF	\
+    | BUTTON_3		\
+    | BUTTON_4		\
+    | BUTTON_LEFT	\
+    | BUTTON_DOWN	\
+    | BUTTON_RIGHT	\
+    | BUTTON_UP		\
+    )
+
+#define BUTTON_INVERT (\
+    BUTTON_SELECT	\
+    | BUTTON_1   	\
+    | BUTTON_2		\
+    | BUTTON_3		\
+    | BUTTON_4		\
+    | BUTTON_LEFT	\
+    | BUTTON_DOWN	\
+    | BUTTON_RIGHT	\
+    | BUTTON_UP		\
+    )
+
+
+
+#define MAKE_FLAG 0x20
+
+#undef DEBUG
+
+#define DEBUG 0
+//#define DEBUG 1
+
+#if DEBUG
+#define DPRINTK(format, args...) printk(__FUNCTION__ ": "  format, ## args)
+#else
+#define DPRINTK(format, args...) do { } while (0)
+#endif
+
+/* Please note that this driver is based on a timer and is not interrupt
+ * driven.  If you are going to make use of this driver, you will need to have
+ * your application open the buttons listing from the /dev directory first.
+ */
+
+struct hydrogen3_buttons {
+	struct fasync_struct *fasync;
+	wait_queue_head_t     read_wait;
+	int open_count;
+	unsigned int debounce;
+	unsigned int current;
+	unsigned int last;
+};
+
+static struct hydrogen3_buttons buttons_info;
+
+
+static void button_timer_periodic(void *data);
+
+static struct tq_struct button_task = {
+	routine:	button_timer_periodic,
+	data:		NULL
+};
+
+static int cleanup_flag = 0;
+static DECLARE_WAIT_QUEUE_HEAD(cleanup_wait_queue);
+
+
+static unsigned int read_button_state(void)
+{
+	unsigned long state;
+
+	state = inl(SYS_PINSTATERD) & BUTTON_MASK;
+	state ^= BUTTON_INVERT;
+	
+	DPRINTK( "Current Button State: %d\n", state );
+
+	return state;
+}
+
+
+static void button_timer_periodic(void *data)
+{
+	struct hydrogen3_buttons *buttons = (struct hydrogen3_buttons *)data;
+	unsigned long button_state;
+	
+	// If cleanup wants us to die
+	if (cleanup_flag) {
+		wake_up(&cleanup_wait_queue);		// now cleanup_module can return
+	} else {
+		queue_task(&button_task, &tq_timer);	// put ourselves back in the task queue
+	}
+
+	// read current buttons
+	button_state = read_button_state();
+
+	// if no buttons are down and nothing to do then
+	// save time and be done.
+	if ((button_state == 0) && (buttons->current == 0)) {
+		return;
+	}
+	
+	if (button_state == buttons->debounce) {
+		buttons->current = button_state;
+	} else {
+		buttons->debounce = button_state;
+	}
+//	printk("0x%04x\n", button_state);
+	if (buttons->current != buttons->last) {
+		if (waitqueue_active(&buttons->read_wait)) {
+		    wake_up_interruptible(&buttons->read_wait);
+		}
+	}
+}
+
+
+static ssize_t hydrogen3_buttons_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
+{
+	struct hydrogen3_buttons *buttons = filp->private_data;
+	char events[16];
+	int index;
+	int last;
+	int cur;
+	int bit;
+	int bit_mask;
+	int err;
+	
+	DPRINTK("start\n");
+
+try_again:
+
+	while (buttons->current == buttons->last) {
+		if (filp->f_flags & O_NONBLOCK) {
+			return -EAGAIN;
+		}
+		interruptible_sleep_on(&buttons->read_wait);
+		if (signal_pending(current)) {
+			return -ERESTARTSYS;
+		}
+	}
+	
+	cur  = buttons->current;
+	last = buttons->last;
+	
+	index    = 0;
+	bit_mask = 1;
+	for (bit = 0; (bit < 16) && count; bit++) {
+		if ((cur ^ last) & bit_mask) {
+			if (cur & bit_mask) {
+				events[index] = (bit | MAKE_FLAG) + 'A';
+				last |= bit_mask;
+			} else {
+				events[index] = bit + 'A';
+				last &= ~bit_mask;
+			}
+			index++;
+			count--;
+		}
+		bit_mask <<= 1;
+	}
+	buttons->last = last;
+	
+	if (index == 0) {
+		goto try_again;
+	}
+	
+	err = copy_to_user(buffer, events, index);
+	if (err) {
+		return err;
+	}
+	
+	return index;
+}
+
+
+static int hydrogen3_buttons_open(struct inode *inode, struct file *filp)
+{
+	struct hydrogen3_buttons *buttons = &buttons_info;
+
+	DPRINTK("start\n");
+	MOD_INC_USE_COUNT;
+
+	filp->private_data = buttons;
+
+	if (buttons->open_count++ == 0) {
+		button_task.data = buttons;
+		cleanup_flag = 0;
+		queue_task(&button_task, &tq_timer);
+	}
+
+	return 0;
+}
+
+
+static unsigned int hydrogen3_buttons_poll(struct file *filp, poll_table *wait)
+{
+	struct hydrogen3_buttons *buttons = filp->private_data;
+	int ret = 0;
+
+	DPRINTK("start\n");
+	poll_wait(filp, &buttons->read_wait, wait);
+	if (buttons->current != buttons->last) {
+		ret = POLLIN | POLLRDNORM;
+	}
+	return ret;
+}
+
+
+static int hydrogen3_buttons_release(struct inode *inode, struct file *filp)
+{
+	struct hydrogen3_buttons *buttons = filp->private_data;
+
+	DPRINTK("start\n");
+
+	if (--buttons->open_count == 0) {
+		cleanup_flag = 1;
+		sleep_on(&cleanup_wait_queue);
+	}
+	MOD_DEC_USE_COUNT;
+	
+	return 0;
+}
+
+
+
+static struct file_operations hydrogen3_buttons_fops = {
+	owner:		THIS_MODULE,
+	read:		hydrogen3_buttons_read,
+	poll:		hydrogen3_buttons_poll,
+	open:		hydrogen3_buttons_open,
+	release:	hydrogen3_buttons_release,
+};
+
+/*
+ * The hydrogen3 buttons is a misc device:
+ * Major 10 char
+ * Minor 22        /dev/buttons
+ * 
+ * This is /dev/misc/buttons if devfs is used.
+ */
+
+static struct miscdevice hydrogen3_buttons_dev = {
+	minor:	22,
+	name:	"buttons",
+	fops:	&hydrogen3_buttons_fops,
+};
+
+static int __init hydrogen3_buttons_init(void)
+{
+	struct hydrogen3_buttons *buttons = &buttons_info;
+	int ret;
+
+	DPRINTK("Initializing buttons driver\n");
+	buttons->open_count = 0;
+	cleanup_flag        = 0;
+	init_waitqueue_head(&buttons->read_wait);
+
+
+	// yamon configures GPIO pins for the buttons
+	// no initialization needed
+
+	ret = misc_register(&hydrogen3_buttons_dev);
+
+	DPRINTK("Buttons driver fully initialized.\n");
+
+	return ret;
+}
+
+
+static void __exit hydrogen3_buttons_exit(void)
+{
+	DPRINTK("unloading buttons driver\n");
+	misc_deregister(&hydrogen3_buttons_dev);
+}
+
+
+module_init(hydrogen3_buttons_init);
+module_exit(hydrogen3_buttons_exit);
diff -Nur linux-2.4.30/arch/mips/au1000/hydrogen3/mmc_support.c linux-2.4.30-mips/arch/mips/au1000/hydrogen3/mmc_support.c
--- linux-2.4.30/arch/mips/au1000/hydrogen3/mmc_support.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/hydrogen3/mmc_support.c	2005-02-02 05:27:06.000000000 +0100
@@ -0,0 +1,89 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *
+ *	MMC support routines for Hydrogen3.
+ *
+ *
+ * Copyright (c) 2003-2004 Embedded Edge, LLC.
+ * Author: Embedded Edge, LLC.
+ * Contact: dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/irq.h>
+#include <asm/au1000.h>
+#include <asm/au1100_mmc.h>
+
+#define GPIO_17_WP 0x20000
+
+/* SD/MMC controller support functions */
+
+/*
+ * Detect card.
+ */
+void mmc_card_inserted(int _n_, int *_res_)
+{
+	u32 gpios = au_readl(SYS_PINSTATERD);
+	u32 emptybit = (1<<16);
+	*_res_ = ((gpios & emptybit) == 0);
+}
+
+/*
+ * Check card write protection.
+ */
+void mmc_card_writable(int _n_, int *_res_)
+{
+	unsigned long mmc_wp, board_specific; 
+		board_specific = au_readl(SYS_OUTPUTSET);
+		mmc_wp=GPIO_17_WP;
+		if (!(board_specific & mmc_wp)) {/* low means card writable */ 
+			*_res_ = 1; 
+		} else {
+			*_res_ = 0; 
+		} 
+}
+/*
+ * Apply power to card slot.
+ */
+void mmc_power_on(int _n_)
+{
+}
+
+/*
+ * Remove power from card slot.
+ */
+void mmc_power_off(int _n_)
+{
+}
+
+EXPORT_SYMBOL(mmc_card_inserted);
+EXPORT_SYMBOL(mmc_card_writable);
+EXPORT_SYMBOL(mmc_power_on);
+EXPORT_SYMBOL(mmc_power_off);
+
diff -Nur linux-2.4.30/arch/mips/au1000/mtx-1/board_setup.c linux-2.4.30-mips/arch/mips/au1000/mtx-1/board_setup.c
--- linux-2.4.30/arch/mips/au1000/mtx-1/board_setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/mtx-1/board_setup.c	2004-11-26 09:37:16.000000000 +0100
@@ -48,6 +48,12 @@
 
 extern struct rtc_ops no_rtc_ops;
 
+void board_reset (void)
+{
+	/* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
+	au_writel(0x00000000, 0xAE00001C);
+}
+
 void __init board_setup(void)
 {
 	rtc_ops = &no_rtc_ops;
diff -Nur linux-2.4.30/arch/mips/au1000/mtx-1/irqmap.c linux-2.4.30-mips/arch/mips/au1000/mtx-1/irqmap.c
--- linux-2.4.30/arch/mips/au1000/mtx-1/irqmap.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/mtx-1/irqmap.c	2004-11-26 09:37:16.000000000 +0100
@@ -72,10 +72,10 @@
 	 *	A       B       C       D
 	 */
 	{
-		{INTA, INTB, INTC, INTD},   /* IDSEL 0 */
-		{INTA, INTB, INTC, INTD},   /* IDSEL 1 */
-		{INTA, INTB, INTC, INTD},   /* IDSEL 2 */
-		{INTA, INTB, INTC, INTD},   /* IDSEL 3 */
+		{INTA, INTB, INTX, INTX},   /* IDSEL 0 */
+		{INTB, INTA, INTX, INTX},   /* IDSEL 1 */
+		{INTC, INTD, INTX, INTX},   /* IDSEL 2 */
+		{INTD, INTC, INTX, INTX},   /* IDSEL 3 */
 	};
 	const long min_idsel = 0, max_idsel = 3, irqs_per_slot = 4;
 	return PCI_IRQ_TABLE_LOOKUP;
diff -Nur linux-2.4.30/arch/mips/au1000/pb1000/board_setup.c linux-2.4.30-mips/arch/mips/au1000/pb1000/board_setup.c
--- linux-2.4.30/arch/mips/au1000/pb1000/board_setup.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/pb1000/board_setup.c	2005-03-19 08:17:51.000000000 +0100
@@ -58,6 +58,10 @@
 {
 }
 
+void board_power_off (void)
+{
+}
+
 void __init board_setup(void)
 {
 	u32 pin_func, static_cfg0;
diff -Nur linux-2.4.30/arch/mips/au1000/pb1100/Makefile linux-2.4.30-mips/arch/mips/au1000/pb1100/Makefile
--- linux-2.4.30/arch/mips/au1000/pb1100/Makefile	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.30-mips/arch/mips/au1000/pb1100/Makefile	2005-01-30 09:10:29.000000000 +0100
@@ -16,4 +16,10 @@
 
 obj-y := init.o board_setup.o irqmap.o
 
+
+ifdef CONFIG_MMC
+obj-y += mmc_support.o
+export-objs += mmc_support.o
+endif
+
 include $(TOPDIR)/Rules.make
diff -Nur linux-2.4.30/arch/mips/au1000/pb1100/board_setup.c linux-2.4.30-mips/arch/mips/au1000/pb1100/board_setup.c
--- linux-2.4.30/arch/mips/au1000/pb1100/board_setup.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/pb1100/board_setup.c	2005-03-19 08:17:51.000000000 +0100
@@ -62,6 +62,10 @@
     au_writel(0x00000000, 0xAE00001C);
 }
 
+void board_power_off (void)
+{
+}
+
 void __init board_setup(void)
 {
 	u32 pin_func;
diff -Nur linux-2.4.30/arch/mips/au1000/pb1100/mmc_support.c linux-2.4.30-mips/arch/mips/au1000/pb1100/mmc_support.c
--- linux-2.4.30/arch/mips/au1000/pb1100/mmc_support.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/pb1100/mmc_support.c	2005-01-30 09:10:29.000000000 +0100
@@ -0,0 +1,126 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *
+ *	MMC support routines for PB1100.
+ *
+ *
+ * Copyright (c) 2003-2004 Embedded Edge, LLC.
+ * Author: Embedded Edge, LLC.
+ * Contact: dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/irq.h>
+#include <asm/au1000.h>
+#include <asm/au1100_mmc.h>
+#include <asm/pb1100.h>
+
+
+/* SD/MMC controller support functions */
+
+/*
+ * Detect card.
+ */
+void mmc_card_inserted(int _n_, int *_res_)
+{
+	u32 gpios = au_readl(SYS_PINSTATERD);
+	u32 emptybit = (_n_) ? (1<<15) : (1<<14);
+	*_res_ = ((gpios & emptybit) == 0);
+}
+
+/*
+ * Check card write protection.
+ */
+void mmc_card_writable(int _n_, int *_res_)
+{
+	BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	unsigned long mmc_wp, board_specific;
+
+	if (_n_) {
+		mmc_wp = BCSR_PCMCIA_SD1_WP;
+	} else {
+		mmc_wp = BCSR_PCMCIA_SD0_WP;
+	}
+
+	board_specific = au_readl((unsigned long)(&bcsr->pcmcia));
+
+	if (!(board_specific & mmc_wp)) {/* low means card writable */
+		*_res_ = 1;
+	} else {
+		*_res_ = 0;
+	}
+}
+
+/*
+ * Apply power to card slot.
+ */
+void mmc_power_on(int _n_)
+{
+	BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	unsigned long mmc_pwr, board_specific;
+
+	if (_n_) {
+		mmc_pwr = BCSR_PCMCIA_SD1_PWR;
+	} else {
+		mmc_pwr = BCSR_PCMCIA_SD0_PWR;
+	}
+
+	board_specific = au_readl((unsigned long)(&bcsr->pcmcia));
+	board_specific |= mmc_pwr;
+
+	au_writel(board_specific, (int)(&bcsr->pcmcia));
+	au_sync_delay(1);
+}
+
+/*
+ * Remove power from card slot.
+ */
+void mmc_power_off(int _n_)
+{
+	BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	unsigned long mmc_pwr, board_specific;
+
+	if (_n_) {
+		mmc_pwr = BCSR_PCMCIA_SD1_PWR;
+	} else {
+		mmc_pwr = BCSR_PCMCIA_SD0_PWR;
+	}
+
+	board_specific = au_readl((unsigned long)(&bcsr->pcmcia));
+	board_specific &= ~mmc_pwr;
+
+	au_writel(board_specific, (int)(&bcsr->pcmcia));
+	au_sync_delay(1);
+}
+
+EXPORT_SYMBOL(mmc_card_inserted);
+EXPORT_SYMBOL(mmc_card_writable);
+EXPORT_SYMBOL(mmc_power_on);
+EXPORT_SYMBOL(mmc_power_off);
+
diff -Nur linux-2.4.30/arch/mips/au1000/pb1200/Makefile linux-2.4.30-mips/arch/mips/au1000/pb1200/Makefile
--- linux-2.4.30/arch/mips/au1000/pb1200/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/pb1200/Makefile	2005-01-30 09:01:27.000000000 +0100
@@ -0,0 +1,25 @@
+#
+#  Copyright 2000 MontaVista Software Inc.
+#  Author: MontaVista Software, Inc.
+#     	ppopov@mvista.com or source@mvista.com
+#
+# Makefile for the Alchemy Semiconductor PB1000 board.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+USE_STANDARD_AS_RULE := true
+
+O_TARGET := pb1200.o
+
+obj-y := init.o board_setup.o irqmap.o
+
+ifdef CONFIG_MMC
+obj-y += mmc_support.o
+export-objs +=mmc_support.o
+endif
+
+
+include $(TOPDIR)/Rules.make
diff -Nur linux-2.4.30/arch/mips/au1000/pb1200/board_setup.c linux-2.4.30-mips/arch/mips/au1000/pb1200/board_setup.c
--- linux-2.4.30/arch/mips/au1000/pb1200/board_setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/pb1200/board_setup.c	2005-03-19 08:17:51.000000000 +0100
@@ -0,0 +1,221 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Alchemy Pb1200 board setup.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/mc146818rtc.h>
+#include <linux/delay.h>
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+#include <linux/ide.h>
+#endif
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/keyboard.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/au1000.h>
+#include <asm/au1xxx_dbdma.h>
+
+#ifdef CONFIG_MIPS_PB1200
+#include <asm/pb1200.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+#include <asm/db1200.h>
+#define PB1200_ETH_INT DB1200_ETH_INT
+#define PB1200_IDE_INT DB1200_IDE_INT
+#endif
+
+extern struct rtc_ops no_rtc_ops;
+
+extern void _board_init_irq(void);
+extern void	(*board_init_irq)(void);
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX
+extern struct ide_ops *ide_ops;
+extern struct ide_ops au1xxx_ide_ops;
+extern u32 au1xxx_ide_virtbase;
+extern u64 au1xxx_ide_physbase;
+extern int au1xxx_ide_irq;
+
+u32 led_base_addr;
+/* Ddma */
+chan_tab_t *ide_read_ch, *ide_write_ch;
+u32 au1xxx_ide_ddma_enable = 0, switch4ddma = 1; // PIO+ddma
+
+dbdev_tab_t new_dbdev_tab_element = { DSCR_CMD0_THROTTLE, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 };
+#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX */
+
+void board_reset (void)
+{
+	bcsr->resets = 0;
+}
+
+void board_power_off (void)
+{
+	bcsr->resets = 0xC000;
+}
+
+void __init board_setup(void)
+{
+	char *argptr = NULL;
+	u32 pin_func;
+	rtc_ops = &no_rtc_ops;
+
+#if 0
+	/* Enable PSC1 SYNC for AC97.  Normaly done in audio driver,
+	 * but it is board specific code, so put it here.
+	 */
+	pin_func = au_readl(SYS_PINFUNC);
+	au_sync();
+	pin_func |= SYS_PF_MUST_BE_SET | SYS_PF_PSC1_S1;
+	au_writel(pin_func, SYS_PINFUNC);
+
+	au_writel(0, (u32)bcsr|0x10); /* turn off pcmcia power */
+	au_sync();
+#endif
+
+#if defined( CONFIG_I2C_ALGO_AU1550 )
+	{
+	u32 freq0, clksrc;
+
+	/* Select SMBUS in CPLD */
+	bcsr->resets &= ~(BCSR_RESETS_PCS0MUX);
+
+	pin_func = au_readl(SYS_PINFUNC);
+	au_sync();
+	pin_func &= ~(3<<17 | 1<<4);
+	/* Set GPIOs correctly */
+	pin_func |= 2<<17;
+	au_writel(pin_func, SYS_PINFUNC);
+	au_sync();
+
+	/* The i2c driver depends on 50Mhz clock */
+	freq0 = au_readl(SYS_FREQCTRL0);
+	au_sync();
+	freq0 &= ~(SYS_FC_FRDIV1_MASK | SYS_FC_FS1 | SYS_FC_FE1);
+	freq0 |= (3<<SYS_FC_FRDIV1_BIT);
+	/* 396Mhz / (3+1)*2 == 49.5Mhz */
+	au_writel(freq0, SYS_FREQCTRL0);
+	au_sync();
+	freq0 |= SYS_FC_FE1;
+	au_writel(freq0, SYS_FREQCTRL0);
+	au_sync();
+
+	clksrc = au_readl(SYS_CLKSRC);
+	au_sync();
+	clksrc &= ~0x01f00000;
+	/* bit 22 is EXTCLK0 for PSC0 */
+	clksrc |= (0x3 << 22);
+	au_writel(clksrc, SYS_CLKSRC);
+	au_sync();
+	}
+#endif
+
+#ifdef CONFIG_FB_AU1200
+	argptr = prom_getcmdline();
+	strcat(argptr, " video=au1200fb:");
+#endif
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+	/*
+	 * Iniz IDE parameters
+	 */
+	ide_ops = &au1xxx_ide_ops;
+	au1xxx_ide_irq = PB1200_IDE_INT;
+	au1xxx_ide_physbase = AU1XXX_ATA_PHYS_ADDR;
+	au1xxx_ide_virtbase = KSEG1ADDR(AU1XXX_ATA_PHYS_ADDR);
+	/*
+	 * change PIO or PIO+Ddma
+	 * check the GPIO-5 pin condition. pb1200:s18_dot */
+	switch4ddma = (au_readl(SYS_PINSTATERD) & (1 << 5)) ? 1 : 0; 
+#endif
+
+	/* The Pb1200 development board uses external MUX for PSC0 to
+	support SMB/SPI. bcsr->resets bit 12: 0=SMB 1=SPI
+	*/
+#if defined(CONFIG_AU1550_PSC_SPI) && defined(CONFIG_I2C_ALGO_AU1550)
+	#error I2C and SPI are mutually exclusive. Both are physically connected to PSC0.\
+			Refer to Pb1200/Db1200 documentation.
+#elif defined( CONFIG_AU1550_PSC_SPI )
+	bcsr->resets |= BCSR_RESETS_PCS0MUX;
+#elif defined( CONFIG_I2C_ALGO_AU1550 )
+	bcsr->resets &= (~BCSR_RESETS_PCS0MUX);
+#endif
+	au_sync();
+
+#ifdef CONFIG_MIPS_PB1200
+	printk("AMD Alchemy Pb1200 Board\n");
+#endif
+#ifdef CONFIG_MIPS_DB1200
+	printk("AMD Alchemy Db1200 Board\n");
+#endif
+
+	/* Setup Pb1200 External Interrupt Controller */
+	{
+		extern void (*board_init_irq)(void);
+		extern void _board_init_irq(void);
+		board_init_irq = _board_init_irq;
+	}
+}
+
+int
+board_au1200fb_panel (void)
+{
+	BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	int p;
+
+	p = bcsr->switches;
+	p >>= 8;
+	p &= 0x0F;
+	return p;
+}
+
+int
+board_au1200fb_panel_init (void)
+{
+	/* Apply power */
+    BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	bcsr->board |= (BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD | BCSR_BOARD_LCDBL);
+	return 0;
+}
+
+int
+board_au1200fb_panel_shutdown (void)
+{
+	/* Remove power */
+    BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	bcsr->board &= ~(BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD | BCSR_BOARD_LCDBL);
+	return 0;
+}
+
diff -Nur linux-2.4.30/arch/mips/au1000/pb1200/init.c linux-2.4.30-mips/arch/mips/au1000/pb1200/init.c
--- linux-2.4.30/arch/mips/au1000/pb1200/init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/pb1200/init.c	2005-01-30 09:01:28.000000000 +0100
@@ -0,0 +1,72 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	PB1200 board setup
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <linux/config.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+extern void  __init prom_init_cmdline(void);
+extern char *prom_getenv(char *envname);
+
+const char *get_system_type(void)
+{
+	return "AMD Alchemy Au1200/Pb1200";
+}
+
+u32 mae_memsize = 0;
+
+int __init prom_init(int argc, char **argv, char **envp, int *prom_vec)
+{
+	unsigned char *memsize_str;
+	unsigned long memsize;
+
+	prom_argc = argc;
+	prom_argv = argv;
+	prom_envp = envp;
+
+	mips_machgroup = MACH_GROUP_ALCHEMY;
+	mips_machtype = MACH_PB1000;	/* set the platform # */   
+	prom_init_cmdline();
+
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x08000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+	return 0;
+}
+
diff -Nur linux-2.4.30/arch/mips/au1000/pb1200/irqmap.c linux-2.4.30-mips/arch/mips/au1000/pb1200/irqmap.c
--- linux-2.4.30/arch/mips/au1000/pb1200/irqmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/pb1200/irqmap.c	2005-01-30 09:01:28.000000000 +0100
@@ -0,0 +1,180 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1xxx irq map table
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/au1000.h>
+
+#ifdef CONFIG_MIPS_PB1200
+#include <asm/pb1200.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+#include <asm/db1200.h>
+#define PB1200_INT_BEGIN DB1200_INT_BEGIN
+#define PB1200_INT_END DB1200_INT_END
+#endif
+
+au1xxx_irq_map_t au1xxx_irq_map[] = {
+	{ AU1000_GPIO_7, INTC_INT_LOW_LEVEL, 0 }, // This is exteranl interrupt cascade
+};
+
+int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
+
+/*
+ *	Support for External interrupts on the PbAu1200 Development platform.
+ */
+static volatile int pb1200_cascade_en=0;
+
+void pb1200_cascade_handler( int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned short bisr = bcsr->int_status;
+	int extirq_nr = 0;
+
+	/* Clear all the edge interrupts. This has no effect on level */
+	bcsr->int_status = bisr;
+	for( ; bisr; bisr &= (bisr-1) )
+	{
+		extirq_nr = (PB1200_INT_BEGIN-1) + au_ffs(bisr);
+		/* Ack and dispatch IRQ */
+		do_IRQ(extirq_nr,regs);
+	}
+}
+
+inline void pb1200_enable_irq(unsigned int irq_nr)
+{
+	bcsr->intset_mask = 1<<(irq_nr - PB1200_INT_BEGIN);
+	bcsr->intset = 1<<(irq_nr - PB1200_INT_BEGIN);
+}
+
+inline void pb1200_disable_irq(unsigned int irq_nr)
+{
+	bcsr->intclr_mask = 1<<(irq_nr - PB1200_INT_BEGIN);
+	bcsr->intclr = 1<<(irq_nr - PB1200_INT_BEGIN);
+}
+
+static unsigned int pb1200_startup_irq( unsigned int irq_nr )
+{
+	if (++pb1200_cascade_en == 1)
+	{
+		request_irq(AU1000_GPIO_7, &pb1200_cascade_handler,
+			0, "Pb1200 Cascade", &pb1200_cascade_handler );
+#ifdef CONFIG_MIPS_PB1200
+    /* We have a problem with CPLD rev3. Enable a workaround */
+	if( ((bcsr->whoami & BCSR_WHOAMI_CPLD)>>4) <= 3)
+	{
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("Pb1200 must be at CPLD rev4. Please have Pb1200\n");
+		printk("updated to latest revision. This software will not\n");
+		printk("work on anything less than CPLD rev4\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		while(1);
+	}
+#endif
+	}
+	pb1200_enable_irq(irq_nr);
+	return 0;
+}
+
+static void pb1200_shutdown_irq( unsigned int irq_nr )
+{
+	pb1200_disable_irq(irq_nr);
+	if (--pb1200_cascade_en == 0)
+	{
+		free_irq(AU1000_GPIO_7,&pb1200_cascade_handler );
+	}
+	return;
+}
+
+static inline void pb1200_mask_and_ack_irq(unsigned int irq_nr)
+{
+	pb1200_disable_irq( irq_nr );
+}
+
+static void pb1200_end_irq(unsigned int irq_nr)
+{
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		pb1200_enable_irq(irq_nr);
+	}
+}
+
+static struct hw_interrupt_type external_irq_type =
+{
+#ifdef CONFIG_MIPS_PB1200
+	"Pb1200 Ext",
+#endif
+#ifdef CONFIG_MIPS_DB1200
+	"Db1200 Ext",
+#endif
+	pb1200_startup_irq,
+	pb1200_shutdown_irq,
+	pb1200_enable_irq,
+	pb1200_disable_irq,
+	pb1200_mask_and_ack_irq,
+	pb1200_end_irq,
+	NULL
+};
+
+void _board_init_irq(void)
+{
+	int irq_nr;
+
+	for (irq_nr = PB1200_INT_BEGIN; irq_nr <= PB1200_INT_END; irq_nr++)
+	{
+		irq_desc[irq_nr].handler = &external_irq_type;
+		pb1200_disable_irq(irq_nr);
+	}
+
+	/* GPIO_7 can not be hooked here, so it is hooked upon first
+	request of any source attached to the cascade */
+}
+
diff -Nur linux-2.4.30/arch/mips/au1000/pb1200/mmc_support.c linux-2.4.30-mips/arch/mips/au1000/pb1200/mmc_support.c
--- linux-2.4.30/arch/mips/au1000/pb1200/mmc_support.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/pb1200/mmc_support.c	2005-01-30 09:01:28.000000000 +0100
@@ -0,0 +1,141 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *
+ *	MMC support routines for PB1200.
+ *
+ *
+ * Copyright (c) 2003-2004 Embedded Edge, LLC.
+ * Author: Embedded Edge, LLC.
+ * Contact: dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/irq.h>
+#include <asm/au1000.h>
+#include <asm/au1100_mmc.h>
+
+#ifdef CONFIG_MIPS_PB1200
+#include <asm/pb1200.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+/* NOTE: DB1200 only has SD0 pinned out and usable */
+#include <asm/db1200.h>
+#endif
+
+/* SD/MMC controller support functions */
+
+/*
+ * Detect card.
+ */
+void mmc_card_inserted(int socket, int *result)
+{
+	u16 mask;
+
+	if (socket)
+#ifdef CONFIG_MIPS_DB1200
+		mask = 0;
+#else
+		mask = BCSR_INT_SD1INSERT; 
+#endif
+	else
+		mask = BCSR_INT_SD0INSERT;
+
+	*result = ((bcsr->sig_status & mask) != 0);
+}
+
+/*
+ * Check card write protection.
+ */
+void mmc_card_writable(int socket, int *result)
+{
+	u16 mask;
+
+	if (socket)
+#ifdef CONFIG_MIPS_DB1200
+		mask = 0;
+#else
+		mask = BCSR_STATUS_SD1WP; 
+#endif
+	else
+		mask = BCSR_STATUS_SD0WP;
+
+	/* low means card writable */
+	if (!(bcsr->status & mask)) {
+		*result = 1;
+	} else {
+		*result = 0;
+	}
+}
+
+/*
+ * Apply power to card slot.
+ */
+void mmc_power_on(int socket)
+{
+	u16 mask;
+
+	if (socket)
+#ifdef CONFIG_MIPS_DB1200
+		mask = 0;
+#else
+		mask = BCSR_BOARD_SD1PWR;
+#endif
+	else
+		mask = BCSR_BOARD_SD0PWR;
+
+	bcsr->board |= mask;
+	au_sync_delay(1);
+}
+
+/*
+ * Remove power from card slot.
+ */
+void mmc_power_off(int socket)
+{
+	u16 mask;
+
+	if (socket)
+#ifdef CONFIG_MIPS_DB1200
+		mask = 0;
+#else
+		mask = BCSR_BOARD_SD1PWR;
+#endif
+	else
+		mask = BCSR_BOARD_SD0PWR;
+
+	bcsr->board &= ~mask;
+	au_sync_delay(1);
+}
+
+EXPORT_SYMBOL(mmc_card_inserted);
+EXPORT_SYMBOL(mmc_card_writable);
+EXPORT_SYMBOL(mmc_power_on);
+EXPORT_SYMBOL(mmc_power_off);
+
diff -Nur linux-2.4.30/arch/mips/au1000/pb1500/board_setup.c linux-2.4.30-mips/arch/mips/au1000/pb1500/board_setup.c
--- linux-2.4.30/arch/mips/au1000/pb1500/board_setup.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/pb1500/board_setup.c	2005-03-19 08:17:51.000000000 +0100
@@ -62,6 +62,10 @@
     au_writel(0x00000000, 0xAE00001C);
 }
 
+void board_power_off (void)
+{
+}
+
 void __init board_setup(void)
 {
 	u32 pin_func;
diff -Nur linux-2.4.30/arch/mips/au1000/pb1550/board_setup.c linux-2.4.30-mips/arch/mips/au1000/pb1550/board_setup.c
--- linux-2.4.30/arch/mips/au1000/pb1550/board_setup.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/pb1550/board_setup.c	2005-03-19 08:17:51.000000000 +0100
@@ -48,12 +48,31 @@
 
 extern struct rtc_ops no_rtc_ops;
 
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+extern struct ide_ops *ide_ops;
+extern struct ide_ops au1xxx_ide_ops;
+extern u32 au1xxx_ide_virtbase;
+extern u64 au1xxx_ide_physbase;
+extern unsigned int au1xxx_ide_irq;
+
+u32 au1xxx_ide_ddma_enable = 0, switch4ddma = 1; // PIO+ddma
+#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX */
+
 void board_reset (void)
 {
     /* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
 	au_writew(au_readw(0xAF00001C) & ~(1<<15), 0xAF00001C);
 }
 
+void board_power_off (void)
+{
+	/* power off system */
+	printk("\n** Powering off Pb1550\n");
+	au_writew(au_readw(0xAF00001C) | (3<<14), 0xAF00001C); 
+	au_sync();
+	while(1); /* should not get here */
+}
+
 void __init board_setup(void)
 {
 	u32 pin_func;
@@ -78,5 +97,36 @@
 	au_writel(0, (u32)bcsr|0x10); /* turn off pcmcia power */
 	au_sync();
 
+#if defined(CONFIG_AU1XXX_SMC91111)
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+#error "Resource conflict occured. Disable either Ethernet or IDE daughter card."
+#else
+#define CPLD_CONTROL (0xAF00000C)
+	{
+	/* set up the Static Bus timing */
+	/* only 396Mhz */
+	/* reset the DC */
+	au_writew(au_readw(CPLD_CONTROL) | 0x0f, CPLD_CONTROL);
+	au_writel(0x00010003, MEM_STCFG0);
+	au_writel(0x000c00c0, MEM_STCFG2);
+	au_writel(0x85E1900D, MEM_STTIME2);
+	}
+#endif
+#endif /* end CONFIG_SMC91111 */
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+	/*
+	 * Iniz IDE parameters
+	 */
+	ide_ops = &au1xxx_ide_ops;
+	au1xxx_ide_irq = DAUGHTER_CARD_IRQ;;
+	au1xxx_ide_physbase = AU1XXX_ATA_PHYS_ADDR;
+	au1xxx_ide_virtbase = KSEG1ADDR(AU1XXX_ATA_PHYS_ADDR);
+	/*
+	 * change PIO or PIO+Ddma
+	 * check the GPIO-6 pin condition. pb1550:s15_dot
+	 */
+	switch4ddma = (au_readl(SYS_PINSTATERD) & (1 << 6)) ? 1 : 0;
+#endif
 	printk("AMD Alchemy Pb1550 Board\n");
 }
diff -Nur linux-2.4.30/arch/mips/au1000/pb1550/irqmap.c linux-2.4.30-mips/arch/mips/au1000/pb1550/irqmap.c
--- linux-2.4.30/arch/mips/au1000/pb1550/irqmap.c	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/au1000/pb1550/irqmap.c	2005-01-30 09:01:28.000000000 +0100
@@ -50,6 +50,9 @@
 au1xxx_irq_map_t au1xxx_irq_map[] = {
 	{ AU1000_GPIO_0, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1000_GPIO_1, INTC_INT_LOW_LEVEL, 0 },
+#ifdef CONFIG_AU1XXX_SMC91111
+	{ AU1000_GPIO_3, INTC_INT_LOW_LEVEL, 0 },
+#endif
 };
 
 int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
diff -Nur linux-2.4.30/arch/mips/config-shared.in linux-2.4.30-mips/arch/mips/config-shared.in
--- linux-2.4.30/arch/mips/config-shared.in	2005-01-19 15:09:27.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/config-shared.in	2005-01-30 09:01:26.000000000 +0100
@@ -21,16 +21,19 @@
 comment 'Machine selection'
 dep_bool 'Support for Acer PICA 1 chipset (EXPERIMENTAL)' CONFIG_ACER_PICA_61 $CONFIG_EXPERIMENTAL
 dep_bool 'Support for Alchemy Bosporus board' CONFIG_MIPS_BOSPORUS $CONFIG_MIPS32
+dep_bool 'Support for FIC Multimedia Player board' CONFIG_MIPS_FICMMP $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Mirage board' CONFIG_MIPS_MIRAGE $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Db1000 board' CONFIG_MIPS_DB1000 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Db1100 board' CONFIG_MIPS_DB1100 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Db1500 board' CONFIG_MIPS_DB1500 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Db1550 board' CONFIG_MIPS_DB1550 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Db1200 board' CONFIG_MIPS_DB1200 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1000 board' CONFIG_MIPS_PB1000 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1100 board' CONFIG_MIPS_PB1100 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1500 board' CONFIG_MIPS_PB1500 $CONFIG_MIPS32
-dep_bool 'Support for Alchemy Hydrogen3 board' CONFIG_MIPS_HYDROGEN3 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1550 board' CONFIG_MIPS_PB1550 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy PB1200 board' CONFIG_MIPS_PB1200 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Hydrogen3 board' CONFIG_MIPS_HYDROGEN3 $CONFIG_MIPS32
 dep_bool 'Support for MyCable XXS1500 board' CONFIG_MIPS_XXS1500 $CONFIG_MIPS32
 dep_bool 'Support for 4G Systems MTX-1 board' CONFIG_MIPS_MTX1 $CONFIG_MIPS32
 dep_bool 'Support for Cogent CSB250 board' CONFIG_COGENT_CSB250 $CONFIG_MIPS32
@@ -249,6 +252,12 @@
    define_bool CONFIG_PC_KEYB y
    define_bool CONFIG_NONCOHERENT_IO y
 fi
+if [ "$CONFIG_MIPS_FICMMP" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1200 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
 if [ "$CONFIG_MIPS_BOSPORUS" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
@@ -263,6 +272,12 @@
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
 fi
+if [ "$CONFIG_MIPS_PB1500" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
 if [ "$CONFIG_MIPS_PB1100" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1100 y
@@ -271,9 +286,15 @@
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
 fi
-if [ "$CONFIG_MIPS_PB1500" = "y" ]; then
+if [ "$CONFIG_MIPS_PB1550" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
-   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_SOC_AU1550 y
+   define_bool CONFIG_NONCOHERENT_IO n
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_PB1200" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1200 y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
@@ -290,18 +311,24 @@
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
+if [ "$CONFIG_MIPS_DB1100" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1100 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_SWAP_IO_SPACE y
+fi
 if [ "$CONFIG_MIPS_DB1550" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1550 y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
-if [ "$CONFIG_MIPS_DB1100" = "y" ]; then
+if [ "$CONFIG_MIPS_DB1200" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
-   define_bool CONFIG_SOC_AU1100 y
+   define_bool CONFIG_SOC_AU1200 y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
-   define_bool CONFIG_SWAP_IO_SPACE y
 fi
 if [ "$CONFIG_MIPS_HYDROGEN3" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
@@ -327,12 +354,6 @@
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
-if [ "$CONFIG_MIPS_PB1550" = "y" ]; then
-   define_bool CONFIG_SOC_AU1X00 y
-   define_bool CONFIG_SOC_AU1550 y
-   define_bool CONFIG_NONCOHERENT_IO n
-   define_bool CONFIG_PC_KEYB y
-fi
 if [ "$CONFIG_MIPS_COBALT" = "y" ]; then
    define_bool CONFIG_BOOT_ELF32 y
    define_bool CONFIG_COBALT_LCD y
@@ -729,6 +750,13 @@
      "$CONFIG_MIPS_PB1000" = "y" -o \
      "$CONFIG_MIPS_PB1100" = "y" -o \
      "$CONFIG_MIPS_PB1500" = "y" -o \
+     "$CONFIG_MIPS_PB1550" = "y" -o \
+     "$CONFIG_MIPS_PB1200" = "y" -o \
+     "$CONFIG_MIPS_DB1000" = "y" -o \
+     "$CONFIG_MIPS_DB1100" = "y" -o \
+     "$CONFIG_MIPS_DB1500" = "y" -o \
+     "$CONFIG_MIPS_DB1550" = "y" -o \
+     "$CONFIG_MIPS_DB1200" = "y" -o \
      "$CONFIG_NEC_OSPREY" = "y" -o \
      "$CONFIG_NEC_EAGLE" = "y" -o \
      "$CONFIG_NINO" = "y" -o \
diff -Nur linux-2.4.30/arch/mips/defconfig linux-2.4.30-mips/arch/mips/defconfig
--- linux-2.4.30/arch/mips/defconfig	2005-01-19 15:09:27.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -235,11 +235,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -319,9 +314,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -465,7 +462,6 @@
 # CONFIG_SERIAL is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-atlas linux-2.4.30-mips/arch/mips/defconfig-atlas
--- linux-2.4.30/arch/mips/defconfig-atlas	2005-01-19 15:09:27.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-atlas	2005-03-18 13:13:21.000000000 +0100
@@ -28,8 +28,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -235,11 +235,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -317,9 +312,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -528,7 +525,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-bosporus linux-2.4.30-mips/arch/mips/defconfig-bosporus
--- linux-2.4.30/arch/mips/defconfig-bosporus	2005-01-19 15:09:27.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-bosporus	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -208,9 +208,7 @@
 CONFIG_MTD_BOSPORUS=y
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -229,7 +227,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -373,11 +370,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -457,9 +449,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -681,7 +675,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-capcella linux-2.4.30-mips/arch/mips/defconfig-capcella
--- linux-2.4.30/arch/mips/defconfig-capcella	2005-01-19 15:09:27.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-capcella	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -228,11 +228,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -472,7 +467,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
diff -Nur linux-2.4.30/arch/mips/defconfig-cobalt linux-2.4.30-mips/arch/mips/defconfig-cobalt
--- linux-2.4.30/arch/mips/defconfig-cobalt	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-cobalt	2005-03-18 13:13:21.000000000 +0100
@@ -28,8 +28,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -222,11 +222,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -505,7 +500,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=16
 
diff -Nur linux-2.4.30/arch/mips/defconfig-csb250 linux-2.4.30-mips/arch/mips/defconfig-csb250
--- linux-2.4.30/arch/mips/defconfig-csb250	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-csb250	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 CONFIG_COGENT_CSB250=y
@@ -268,11 +268,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -556,7 +551,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-db1000 linux-2.4.30-mips/arch/mips/defconfig-db1000
--- linux-2.4.30/arch/mips/defconfig-db1000	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-db1000	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -214,11 +214,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-CONFIG_MTD_DB1X00=y
-CONFIG_MTD_DB1X00_BOOT=y
-CONFIG_MTD_DB1X00_USER=y
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -237,7 +233,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -342,11 +337,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -636,7 +626,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-db1100 linux-2.4.30-mips/arch/mips/defconfig-db1100
--- linux-2.4.30/arch/mips/defconfig-db1100	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-db1100	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -214,11 +214,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-CONFIG_MTD_DB1X00=y
-# CONFIG_MTD_DB1X00_BOOT is not set
-CONFIG_MTD_DB1X00_USER=y
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -237,7 +233,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -342,11 +337,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -636,7 +626,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -884,6 +873,7 @@
 # CONFIG_FB_PM2 is not set
 # CONFIG_FB_PM3 is not set
 # CONFIG_FB_CYBER2000 is not set
+CONFIG_FB_AU1100=y
 # CONFIG_FB_MATROX is not set
 # CONFIG_FB_ATY is not set
 # CONFIG_FB_RADEON is not set
@@ -895,7 +885,6 @@
 # CONFIG_FB_VOODOO1 is not set
 # CONFIG_FB_TRIDENT is not set
 # CONFIG_FB_E1356 is not set
-CONFIG_FB_AU1100=y
 # CONFIG_FB_IT8181 is not set
 # CONFIG_FB_VIRTUAL is not set
 CONFIG_FBCON_ADVANCED=y
diff -Nur linux-2.4.30/arch/mips/defconfig-db1200 linux-2.4.30-mips/arch/mips/defconfig-db1200
--- linux-2.4.30/arch/mips/defconfig-db1200	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-db1200	2005-03-18 13:13:21.000000000 +0100
@@ -0,0 +1,1032 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_MIPS=y
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Machine selection
+#
+# CONFIG_ACER_PICA_61 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_COGENT_CSB250 is not set
+# CONFIG_BAGET_MIPS is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_HP_LASERJET is not set
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MAGNUM_4000 is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
+# CONFIG_PMC_STRETCH is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_NEC_OSPREY is not set
+# CONFIG_NEC_EAGLE is not set
+# CONFIG_OLIVETTI_M700 is not set
+# CONFIG_NINO is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TANBAC_TB0226 is not set
+# CONFIG_TANBAC_TB0229 is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+# CONFIG_MIPS_AU1000 is not set
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32=y
+# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_VTAG_ICACHE is not set
+CONFIG_64BIT_PHYS_ADDR=y
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+# CONFIG_CPU_HAS_LLDSCD is not set
+# CONFIG_CPU_HAS_WB is not set
+CONFIG_CPU_HAS_SYNC=y
+
+#
+# General setup
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_BUILD_ELF64 is not set
+CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
+# CONFIG_PCI_NAMES is not set
+# CONFIG_ISA is not set
+# CONFIG_TC is not set
+# CONFIG_MCA is not set
+# CONFIG_SBUS is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=m
+# CONFIG_CARDBUS is not set
+# CONFIG_TCIC is not set
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_MIPS32_COMPAT is not set
+# CONFIG_MIPS32_O32 is not set
+# CONFIG_MIPS32_N32 is not set
+# CONFIG_BINFMT_ELF32 is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_OOM_KILLER is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="mem=96M"
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_CISS_MONITOR_THREAD is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+
+#
+#   IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+
+#
+#   IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+
+#
+#    SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+# CONFIG_PHONE_IXJ is not set
+# CONFIG_PHONE_IXJ_PCMCIA is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_IDEDISK_STROKE=y
+CONFIG_BLK_DEV_IDECS=m
+# CONFIG_BLK_DEV_DELKIN is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
+# CONFIG_BLK_DEV_ATARAID_SII is not set
+
+#
+# SCSI support
+#
+CONFIG_SCSI=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_SD_EXTRA_DEVS=40
+CONFIG_CHR_DEV_ST=y
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_SR_EXTRA_DEVS=2
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_DEBUG_QUEUES is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_7000FASST is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AHA1740 is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_ATA_PIIX is not set
+# CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_ULI is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CPQFCTS is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_DMA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_NCR53C7xx is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_NCR53C8XX is not set
+# CONFIG_SCSI_SYM53C8XX is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PCI2000 is not set
+# CONFIG_SCSI_PCI2220I is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_SIM710 is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_SCSI_PCMCIA is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_BOOT is not set
+# CONFIG_FUSION_ISENSE is not set
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LAN is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_PCI is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input core support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_KEYBDEV=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_UINPUT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_VT_CONSOLE is not set
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_ESPSERIAL is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+# CONFIG_SERIAL_TX3912 is not set
+# CONFIG_SERIAL_TX3912_CONSOLE is not set
+# CONFIG_SERIAL_TXX9 is not set
+# CONFIG_SERIAL_TXX9_CONSOLE is not set
+# CONFIG_TXX927_SERIAL is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200 is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+
+#
+# Direct Rendering Manager (XFree86 DRI support)
+#
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_PCMCIA_SERIAL_CS is not set
+# CONFIG_SYNCLINK_CS is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_AUTOFS_FS=y
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+# CONFIG_UMSDOS_FS is not set
+CONFIG_VFAT_FS=y
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_TRACE is not set
+# CONFIG_XFS_DEBUG is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMB_NLS is not set
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Console drivers
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+
+#
+# Frame-buffer support
+#
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_CLGEN is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_INTEL is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_E1356 is not set
+# CONFIG_FB_IT8181 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_FBCON_ADVANCED=y
+# CONFIG_FBCON_MFB is not set
+# CONFIG_FBCON_CFB2 is not set
+# CONFIG_FBCON_CFB4 is not set
+# CONFIG_FBCON_CFB8 is not set
+CONFIG_FBCON_CFB16=y
+# CONFIG_FBCON_CFB24 is not set
+CONFIG_FBCON_CFB32=y
+# CONFIG_FBCON_AFB is not set
+# CONFIG_FBCON_ILBM is not set
+# CONFIG_FBCON_IPLAN2P2 is not set
+# CONFIG_FBCON_IPLAN2P4 is not set
+# CONFIG_FBCON_IPLAN2P8 is not set
+# CONFIG_FBCON_MAC is not set
+# CONFIG_FBCON_VGA_PLANES is not set
+# CONFIG_FBCON_VGA is not set
+# CONFIG_FBCON_HGA is not set
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+CONFIG_FBCON_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+# CONFIG_SOUND_ALI5455 is not set
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_MIDI_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+# CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_RME96XX is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_MIDI_VIA82CXXX is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+# CONFIG_SOUND_AD1980 is not set
+# CONFIG_SOUND_WM97XX is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_UHCI is not set
+# CONFIG_USB_UHCI_ALT is not set
+CONFIG_USB_OHCI=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_MIDI is not set
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+CONFIG_USB_HIDDEV=y
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_DC2XX is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_SCANNER is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+
+#
+#   Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_CDCETHER is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_USS720 is not set
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_BRLVGER is not set
+# CONFIG_USB_LCD is not set
+
+#
+# Support for USB gadgets
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Kernel hacking
+#
+CONFIG_CROSSCOMPILE=y
+# CONFIG_RUNTIME_DEBUG is not set
+# CONFIG_KGDB is not set
+# CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_MIPS_UNCACHED is not set
+CONFIG_LOG_BUF_SHIFT=0
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
+# CONFIG_FW_LOADER is not set
diff -Nur linux-2.4.30/arch/mips/defconfig-db1500 linux-2.4.30-mips/arch/mips/defconfig-db1500
--- linux-2.4.30/arch/mips/defconfig-db1500	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-db1500	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -267,11 +267,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -555,7 +550,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-db1550 linux-2.4.30-mips/arch/mips/defconfig-db1550
--- linux-2.4.30/arch/mips/defconfig-db1550	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-db1550	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -213,11 +213,9 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 CONFIG_MTD_PB1550=y
 CONFIG_MTD_PB1550_BOOT=y
 CONFIG_MTD_PB1550_USER=y
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -236,7 +234,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -343,11 +340,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -633,7 +625,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-ddb5476 linux-2.4.30-mips/arch/mips/defconfig-ddb5476
--- linux-2.4.30/arch/mips/defconfig-ddb5476	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-ddb5476	2005-03-18 13:13:21.000000000 +0100
@@ -28,8 +28,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -226,11 +226,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -517,7 +512,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-ddb5477 linux-2.4.30-mips/arch/mips/defconfig-ddb5477
--- linux-2.4.30/arch/mips/defconfig-ddb5477	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-ddb5477	2005-03-18 13:13:21.000000000 +0100
@@ -28,8 +28,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -226,11 +226,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -434,7 +429,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-decstation linux-2.4.30-mips/arch/mips/defconfig-decstation
--- linux-2.4.30/arch/mips/defconfig-decstation	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-decstation	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -223,11 +223,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -306,9 +301,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -477,7 +474,6 @@
 CONFIG_SERIAL_DEC_CONSOLE=y
 CONFIG_DZ=y
 CONFIG_ZS=y
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-e55 linux-2.4.30-mips/arch/mips/defconfig-e55
--- linux-2.4.30/arch/mips/defconfig-e55	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-e55	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -222,11 +222,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -426,7 +421,6 @@
 # CONFIG_SERIAL_MULTIPORT is not set
 # CONFIG_HUB6 is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
diff -Nur linux-2.4.30/arch/mips/defconfig-eagle linux-2.4.30-mips/arch/mips/defconfig-eagle
--- linux-2.4.30/arch/mips/defconfig-eagle	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-eagle	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -208,8 +208,8 @@
 # Mapping drivers for chip access
 #
 CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_PHYSMAP_START=1c000000
-CONFIG_MTD_PHYSMAP_LEN=2000000
+CONFIG_MTD_PHYSMAP_START=0x1c000000
+CONFIG_MTD_PHYSMAP_LEN=0x2000000
 CONFIG_MTD_PHYSMAP_BUSWIDTH=4
 # CONFIG_MTD_PB1000 is not set
 # CONFIG_MTD_PB1500 is not set
@@ -217,9 +217,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -238,7 +236,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -327,11 +324,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -587,7 +579,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
diff -Nur linux-2.4.30/arch/mips/defconfig-ev64120 linux-2.4.30-mips/arch/mips/defconfig-ev64120
--- linux-2.4.30/arch/mips/defconfig-ev64120	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-ev64120	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -230,11 +230,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -443,7 +438,6 @@
 # CONFIG_SERIAL_CONSOLE is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-ev96100 linux-2.4.30-mips/arch/mips/defconfig-ev96100
--- linux-2.4.30/arch/mips/defconfig-ev96100	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-ev96100	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -232,11 +232,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -441,7 +436,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-ficmmp linux-2.4.30-mips/arch/mips/defconfig-ficmmp
--- linux-2.4.30/arch/mips/defconfig-ficmmp	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-ficmmp	2005-03-18 13:13:21.000000000 +0100
@@ -0,0 +1,862 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_MIPS=y
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Machine selection
+#
+# CONFIG_ACER_PICA_61 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_COGENT_CSB250 is not set
+# CONFIG_BAGET_MIPS is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_HP_LASERJET is not set
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MAGNUM_4000 is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
+# CONFIG_PMC_STRETCH is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_NEC_OSPREY is not set
+# CONFIG_NEC_EAGLE is not set
+# CONFIG_OLIVETTI_M700 is not set
+# CONFIG_NINO is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TANBAC_TB0226 is not set
+# CONFIG_TANBAC_TB0229 is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+# CONFIG_MIPS_AU1000 is not set
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32=y
+# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_VTAG_ICACHE is not set
+CONFIG_64BIT_PHYS_ADDR=y
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+# CONFIG_CPU_HAS_LLDSCD is not set
+# CONFIG_CPU_HAS_WB is not set
+CONFIG_CPU_HAS_SYNC=y
+
+#
+# General setup
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_BUILD_ELF64 is not set
+CONFIG_NET=y
+# CONFIG_PCI is not set
+# CONFIG_PCI_NEW is not set
+CONFIG_PCI_AUTO=y
+# CONFIG_ISA is not set
+# CONFIG_TC is not set
+# CONFIG_MCA is not set
+# CONFIG_SBUS is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+# CONFIG_HOTPLUG_PCI is not set
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_MIPS32_COMPAT is not set
+# CONFIG_MIPS32_O32 is not set
+# CONFIG_MIPS32_N32 is not set
+# CONFIG_BINFMT_ELF32 is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_OOM_KILLER is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="ide3=dma mem=96M root=/dev/hda2 rootflags=data=journal"
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_CISS_MONITOR_THREAD is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+
+#
+#   IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+
+#
+#   IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+
+#
+#    SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+# CONFIG_PHONE_IXJ is not set
+# CONFIG_PHONE_IXJ_PCMCIA is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+CONFIG_BLK_DEV_HD_IDE=y
+CONFIG_BLK_DEV_HD=y
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_IDEDISK_STROKE=y
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_DELKIN is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
+# CONFIG_BLK_DEV_ATARAID_SII is not set
+
+#
+# SCSI support
+#
+CONFIG_SCSI=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_SD_EXTRA_DEVS=40
+CONFIG_CHR_DEV_ST=y
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_SR_EXTRA_DEVS=2
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_DEBUG_QUEUES is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_7000FASST is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AHA1740 is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_ATA_PIIX is not set
+# CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_ULI is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_DMA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_NCR53C7xx is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PCI2000 is not set
+# CONFIG_SCSI_PCI2220I is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_SIM710 is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_BOOT is not set
+# CONFIG_FUSION_ISENSE is not set
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LAN is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input core support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_KEYBDEV=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_UINPUT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_ESPSERIAL is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+# CONFIG_SERIAL_TX3912 is not set
+# CONFIG_SERIAL_TX3912_CONSOLE is not set
+# CONFIG_SERIAL_TXX9 is not set
+# CONFIG_SERIAL_TXX9_CONSOLE is not set
+# CONFIG_TXX927_SERIAL is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_PROC is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200 is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+
+#
+# Direct Rendering Manager (XFree86 DRI support)
+#
+# CONFIG_DRM is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_AUTOFS_FS=y
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+# CONFIG_UMSDOS_FS is not set
+CONFIG_VFAT_FS=y
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_TMPFS is not set
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_TRACE is not set
+# CONFIG_XFS_DEBUG is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+# CONFIG_NFS_FS is not set
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+# CONFIG_SUNRPC is not set
+# CONFIG_LOCKD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMB_NLS is not set
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Console drivers
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+
+#
+# Frame-buffer support
+#
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_FBCON_ADVANCED=y
+# CONFIG_FBCON_MFB is not set
+# CONFIG_FBCON_CFB2 is not set
+# CONFIG_FBCON_CFB4 is not set
+# CONFIG_FBCON_CFB8 is not set
+CONFIG_FBCON_CFB16=y
+# CONFIG_FBCON_CFB24 is not set
+# CONFIG_FBCON_CFB32 is not set
+# CONFIG_FBCON_AFB is not set
+# CONFIG_FBCON_ILBM is not set
+# CONFIG_FBCON_IPLAN2P2 is not set
+# CONFIG_FBCON_IPLAN2P4 is not set
+# CONFIG_FBCON_IPLAN2P8 is not set
+# CONFIG_FBCON_MAC is not set
+# CONFIG_FBCON_VGA_PLANES is not set
+# CONFIG_FBCON_VGA is not set
+# CONFIG_FBCON_HGA is not set
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+CONFIG_FBCON_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+# CONFIG_SOUND_ALI5455 is not set
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_MIDI_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+# CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_RME96XX is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_MIDI_VIA82CXXX is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+# CONFIG_SOUND_AD1980 is not set
+# CONFIG_SOUND_WM97XX is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# Support for USB gadgets
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Kernel hacking
+#
+CONFIG_CROSSCOMPILE=y
+# CONFIG_RUNTIME_DEBUG is not set
+# CONFIG_KGDB is not set
+# CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_MIPS_UNCACHED is not set
+CONFIG_LOG_BUF_SHIFT=0
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Nur linux-2.4.30/arch/mips/defconfig-hp-lj linux-2.4.30-mips/arch/mips/defconfig-hp-lj
--- linux-2.4.30/arch/mips/defconfig-hp-lj	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-hp-lj	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -184,8 +184,8 @@
 # Mapping drivers for chip access
 #
 CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_PHYSMAP_START=10040000
-CONFIG_MTD_PHYSMAP_LEN=00fc0000
+CONFIG_MTD_PHYSMAP_START=0x10040000
+CONFIG_MTD_PHYSMAP_LEN=0x00fc0000
 CONFIG_MTD_PHYSMAP_BUSWIDTH=4
 # CONFIG_MTD_PB1000 is not set
 # CONFIG_MTD_PB1500 is not set
@@ -193,9 +193,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -214,7 +212,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -304,11 +301,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -604,7 +596,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
diff -Nur linux-2.4.30/arch/mips/defconfig-hydrogen3 linux-2.4.30-mips/arch/mips/defconfig-hydrogen3
--- linux-2.4.30/arch/mips/defconfig-hydrogen3	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-hydrogen3	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-CONFIG_MIPS_HYDROGEN3=y
 # CONFIG_MIPS_PB1550 is not set
+CONFIG_MIPS_HYDROGEN3=y
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -214,9 +214,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-CONFIG_MTD_HYDROGEN3=y
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -235,7 +233,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -340,11 +337,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -590,7 +582,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-CONFIG_MIPS_HYDROGEN3_BUTTONS=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -838,6 +829,7 @@
 # CONFIG_FB_PM2 is not set
 # CONFIG_FB_PM3 is not set
 # CONFIG_FB_CYBER2000 is not set
+CONFIG_FB_AU1100=y
 # CONFIG_FB_MATROX is not set
 # CONFIG_FB_ATY is not set
 # CONFIG_FB_RADEON is not set
@@ -849,7 +841,6 @@
 # CONFIG_FB_VOODOO1 is not set
 # CONFIG_FB_TRIDENT is not set
 # CONFIG_FB_E1356 is not set
-CONFIG_FB_AU1100=y
 # CONFIG_FB_IT8181 is not set
 # CONFIG_FB_VIRTUAL is not set
 CONFIG_FBCON_ADVANCED=y
diff -Nur linux-2.4.30/arch/mips/defconfig-ip22 linux-2.4.30-mips/arch/mips/defconfig-ip22
--- linux-2.4.30/arch/mips/defconfig-ip22	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-ip22	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -235,11 +235,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -319,9 +314,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -465,7 +462,6 @@
 # CONFIG_SERIAL is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-it8172 linux-2.4.30-mips/arch/mips/defconfig-it8172
--- linux-2.4.30/arch/mips/defconfig-it8172	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-it8172	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -186,8 +186,8 @@
 # Mapping drivers for chip access
 #
 CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_PHYSMAP_START=8000000
-CONFIG_MTD_PHYSMAP_LEN=2000000
+CONFIG_MTD_PHYSMAP_START=0x8000000
+CONFIG_MTD_PHYSMAP_LEN=0x2000000
 CONFIG_MTD_PHYSMAP_BUSWIDTH=4
 # CONFIG_MTD_PB1000 is not set
 # CONFIG_MTD_PB1500 is not set
@@ -195,9 +195,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -216,7 +214,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -304,11 +301,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -592,7 +584,6 @@
 CONFIG_PC_KEYB=y
 # CONFIG_IT8172_SCR0 is not set
 # CONFIG_IT8172_SCR1 is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-ivr linux-2.4.30-mips/arch/mips/defconfig-ivr
--- linux-2.4.30/arch/mips/defconfig-ivr	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-ivr	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -226,11 +226,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -516,7 +511,6 @@
 CONFIG_QTRONIX_KEYBOARD=y
 CONFIG_IT8172_CIR=y
 # CONFIG_IT8172_SCR0 is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-jmr3927 linux-2.4.30-mips/arch/mips/defconfig-jmr3927
--- linux-2.4.30/arch/mips/defconfig-jmr3927	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-jmr3927	2005-03-18 13:13:21.000000000 +0100
@@ -28,8 +28,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -225,11 +225,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -454,7 +449,6 @@
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 CONFIG_TXX927_SERIAL=y
 CONFIG_TXX927_SERIAL_CONSOLE=y
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
diff -Nur linux-2.4.30/arch/mips/defconfig-lasat linux-2.4.30-mips/arch/mips/defconfig-lasat
--- linux-2.4.30/arch/mips/defconfig-lasat	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-lasat	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -198,9 +198,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -219,7 +217,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -303,11 +300,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -584,7 +576,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-malta linux-2.4.30-mips/arch/mips/defconfig-malta
--- linux-2.4.30/arch/mips/defconfig-malta	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-malta	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -237,11 +237,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -319,9 +314,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -524,7 +521,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-mirage linux-2.4.30-mips/arch/mips/defconfig-mirage
--- linux-2.4.30/arch/mips/defconfig-mirage	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-mirage	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -209,9 +209,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 CONFIG_MTD_MIRAGE=y
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -230,7 +228,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -335,11 +332,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -560,7 +552,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-mpc30x linux-2.4.30-mips/arch/mips/defconfig-mpc30x
--- linux-2.4.30/arch/mips/defconfig-mpc30x	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-mpc30x	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -228,11 +228,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -400,7 +395,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
diff -Nur linux-2.4.30/arch/mips/defconfig-mtx-1 linux-2.4.30-mips/arch/mips/defconfig-mtx-1
--- linux-2.4.30/arch/mips/defconfig-mtx-1	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-mtx-1	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 CONFIG_MIPS_MTX1=y
 # CONFIG_COGENT_CSB250 is not set
@@ -193,9 +193,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 CONFIG_MTD_MTX1=y
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -214,7 +212,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -371,11 +368,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 CONFIG_BRIDGE=m
 # CONFIG_X25 is not set
@@ -479,9 +471,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -700,7 +694,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-nino linux-2.4.30-mips/arch/mips/defconfig-nino
--- linux-2.4.30/arch/mips/defconfig-nino	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-nino	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -226,11 +226,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -339,7 +334,6 @@
 # CONFIG_SERIAL_TXX9 is not set
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
diff -Nur linux-2.4.30/arch/mips/defconfig-ocelot linux-2.4.30-mips/arch/mips/defconfig-ocelot
--- linux-2.4.30/arch/mips/defconfig-ocelot	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-ocelot	2005-03-18 13:13:21.000000000 +0100
@@ -28,8 +28,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -194,9 +194,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 CONFIG_MTD_OCELOT=y
@@ -215,7 +213,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 CONFIG_MTD_DOC2000=y
 # CONFIG_MTD_DOC2001 is not set
 CONFIG_MTD_DOCPROBE=y
@@ -307,11 +304,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -513,7 +505,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-osprey linux-2.4.30-mips/arch/mips/defconfig-osprey
--- linux-2.4.30/arch/mips/defconfig-osprey	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-osprey	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -227,11 +227,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -388,7 +383,6 @@
 # CONFIG_SERIAL_MULTIPORT is not set
 # CONFIG_HUB6 is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
diff -Nur linux-2.4.30/arch/mips/defconfig-pb1000 linux-2.4.30-mips/arch/mips/defconfig-pb1000
--- linux-2.4.30/arch/mips/defconfig-pb1000	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-pb1000	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 CONFIG_MIPS_PB1000=y
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -215,9 +215,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -236,7 +234,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -324,11 +321,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -622,7 +614,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -707,7 +698,7 @@
 #
 # CONFIG_PCMCIA_SERIAL_CS is not set
 # CONFIG_SYNCLINK_CS is not set
-CONFIG_AU1X00_GPIO=m
+CONFIG_AU1X00_GPIO=y
 # CONFIG_TS_AU1X00_ADS7846 is not set
 
 #
diff -Nur linux-2.4.30/arch/mips/defconfig-pb1100 linux-2.4.30-mips/arch/mips/defconfig-pb1100
--- linux-2.4.30/arch/mips/defconfig-pb1100	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-pb1100	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 CONFIG_MIPS_PB1100=y
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -198,9 +198,7 @@
 # CONFIG_MTD_MTX1 is not set
 CONFIG_MTD_PB1500_BOOT=y
 CONFIG_MTD_PB1500_USER=y
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -219,7 +217,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -324,11 +321,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -613,7 +605,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -859,6 +850,7 @@
 # CONFIG_FB_PM2 is not set
 # CONFIG_FB_PM3 is not set
 # CONFIG_FB_CYBER2000 is not set
+CONFIG_FB_AU1100=y
 # CONFIG_FB_MATROX is not set
 # CONFIG_FB_ATY is not set
 # CONFIG_FB_RADEON is not set
@@ -870,7 +862,6 @@
 # CONFIG_FB_VOODOO1 is not set
 # CONFIG_FB_TRIDENT is not set
 # CONFIG_FB_E1356 is not set
-CONFIG_FB_AU1100=y
 # CONFIG_FB_IT8181 is not set
 # CONFIG_FB_VIRTUAL is not set
 CONFIG_FBCON_ADVANCED=y
diff -Nur linux-2.4.30/arch/mips/defconfig-pb1200 linux-2.4.30-mips/arch/mips/defconfig-pb1200
--- linux-2.4.30/arch/mips/defconfig-pb1200	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-pb1200	2005-03-18 13:13:21.000000000 +0100
@@ -0,0 +1,1060 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_MIPS=y
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Machine selection
+#
+# CONFIG_ACER_PICA_61 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_COGENT_CSB250 is not set
+# CONFIG_BAGET_MIPS is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_HP_LASERJET is not set
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MAGNUM_4000 is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
+# CONFIG_PMC_STRETCH is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_NEC_OSPREY is not set
+# CONFIG_NEC_EAGLE is not set
+# CONFIG_OLIVETTI_M700 is not set
+# CONFIG_NINO is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TANBAC_TB0226 is not set
+# CONFIG_TANBAC_TB0229 is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_SOC_AU1X00=y
+CONFIG_SOC_AU1200=y
+CONFIG_NONCOHERENT_IO=y
+CONFIG_PC_KEYB=y
+# CONFIG_MIPS_AU1000 is not set
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32=y
+# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_VTAG_ICACHE is not set
+CONFIG_64BIT_PHYS_ADDR=y
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+# CONFIG_CPU_HAS_LLDSCD is not set
+# CONFIG_CPU_HAS_WB is not set
+CONFIG_CPU_HAS_SYNC=y
+
+#
+# General setup
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_BUILD_ELF64 is not set
+CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
+# CONFIG_PCI_NAMES is not set
+# CONFIG_ISA is not set
+# CONFIG_TC is not set
+# CONFIG_MCA is not set
+# CONFIG_SBUS is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=m
+# CONFIG_CARDBUS is not set
+# CONFIG_TCIC is not set
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+CONFIG_PCMCIA_AU1X00=m
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_MIPS32_COMPAT is not set
+# CONFIG_MIPS32_O32 is not set
+# CONFIG_MIPS32_N32 is not set
+# CONFIG_BINFMT_ELF32 is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_OOM_KILLER is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="mem=96M"
+# CONFIG_PM is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_CISS_MONITOR_THREAD is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+
+#
+#   IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+
+#
+#   IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+
+#
+#    SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+# CONFIG_PHONE_IXJ is not set
+# CONFIG_PHONE_IXJ_PCMCIA is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_IDEDISK_STROKE=y
+CONFIG_BLK_DEV_IDECS=m
+# CONFIG_BLK_DEV_DELKIN is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
+# CONFIG_BLK_DEV_ATARAID_SII is not set
+
+#
+# SCSI support
+#
+CONFIG_SCSI=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_SD_EXTRA_DEVS=40
+CONFIG_CHR_DEV_ST=y
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_SR_EXTRA_DEVS=2
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_DEBUG_QUEUES is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_7000FASST is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AHA1740 is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_ATA_PIIX is not set
+# CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_ULI is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CPQFCTS is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_DMA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_NCR53C7xx is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_NCR53C8XX is not set
+# CONFIG_SCSI_SYM53C8XX is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PCI2000 is not set
+# CONFIG_SCSI_PCI2220I is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_SIM710 is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_SCSI_PCMCIA is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_BOOT is not set
+# CONFIG_FUSION_ISENSE is not set
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LAN is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_PCI is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MIPS_AU1X00_ENET is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=m
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+CONFIG_PPPOE=m
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input core support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_KEYBDEV=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_UINPUT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_VT_CONSOLE is not set
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_ESPSERIAL is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+# CONFIG_SERIAL_TX3912 is not set
+# CONFIG_SERIAL_TX3912_CONSOLE is not set
+# CONFIG_SERIAL_TXX9 is not set
+# CONFIG_SERIAL_TXX9_CONSOLE is not set
+CONFIG_AU1X00_UART=y
+CONFIG_AU1X00_SERIAL_CONSOLE=y
+# CONFIG_AU1X00_USB_TTY is not set
+# CONFIG_AU1X00_USB_RAW is not set
+# CONFIG_TXX927_SERIAL is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_PROC=y
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200 is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+
+#
+# Direct Rendering Manager (XFree86 DRI support)
+#
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_PCMCIA_SERIAL_CS is not set
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_AU1X00_GPIO is not set
+# CONFIG_TS_AU1X00_ADS7846 is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_AUTOFS_FS=y
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+# CONFIG_UMSDOS_FS is not set
+CONFIG_VFAT_FS=y
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_TRACE is not set
+# CONFIG_XFS_DEBUG is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMB_NLS is not set
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Console drivers
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+
+#
+# Frame-buffer support
+#
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_CLGEN is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_INTEL is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_E1356 is not set
+# CONFIG_FB_IT8181 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_FBCON_ADVANCED=y
+# CONFIG_FBCON_MFB is not set
+# CONFIG_FBCON_CFB2 is not set
+# CONFIG_FBCON_CFB4 is not set
+# CONFIG_FBCON_CFB8 is not set
+CONFIG_FBCON_CFB16=y
+# CONFIG_FBCON_CFB24 is not set
+CONFIG_FBCON_CFB32=y
+# CONFIG_FBCON_AFB is not set
+# CONFIG_FBCON_ILBM is not set
+# CONFIG_FBCON_IPLAN2P2 is not set
+# CONFIG_FBCON_IPLAN2P4 is not set
+# CONFIG_FBCON_IPLAN2P8 is not set
+# CONFIG_FBCON_MAC is not set
+# CONFIG_FBCON_VGA_PLANES is not set
+# CONFIG_FBCON_VGA is not set
+# CONFIG_FBCON_HGA is not set
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+CONFIG_FBCON_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+# CONFIG_SOUND_ALI5455 is not set
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_MIDI_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+# CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_RME96XX is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_AU1X00 is not set
+CONFIG_SOUND_AU1550_PSC=y
+# CONFIG_SOUND_AU1550_I2S is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_MIDI_VIA82CXXX is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+# CONFIG_SOUND_AD1980 is not set
+# CONFIG_SOUND_WM97XX is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_UHCI is not set
+# CONFIG_USB_UHCI_ALT is not set
+CONFIG_USB_OHCI=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_MIDI is not set
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+CONFIG_USB_HIDDEV=y
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_DC2XX is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_SCANNER is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+
+#
+#   Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_CDCETHER is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_USS720 is not set
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_BRLVGER is not set
+# CONFIG_USB_LCD is not set
+
+#
+# Support for USB gadgets
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Kernel hacking
+#
+CONFIG_CROSSCOMPILE=y
+# CONFIG_RUNTIME_DEBUG is not set
+# CONFIG_KGDB is not set
+# CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_MIPS_UNCACHED is not set
+CONFIG_LOG_BUF_SHIFT=0
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
+# CONFIG_FW_LOADER is not set
diff -Nur linux-2.4.30/arch/mips/defconfig-pb1500 linux-2.4.30-mips/arch/mips/defconfig-pb1500
--- linux-2.4.30/arch/mips/defconfig-pb1500	2005-01-19 15:09:28.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-pb1500	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 CONFIG_MIPS_PB1500=y
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -215,9 +215,7 @@
 # CONFIG_MTD_MTX1 is not set
 CONFIG_MTD_PB1500_BOOT=y
 # CONFIG_MTD_PB1500_USER is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -236,7 +234,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -341,11 +338,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -675,7 +667,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-pb1550 linux-2.4.30-mips/arch/mips/defconfig-pb1550
--- linux-2.4.30/arch/mips/defconfig-pb1550	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-pb1550	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 CONFIG_MIPS_PB1550=y
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -213,11 +213,9 @@
 # CONFIG_MTD_BOSPORUS is not set
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 CONFIG_MTD_PB1550=y
 CONFIG_MTD_PB1550_BOOT=y
 CONFIG_MTD_PB1550_USER=y
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -236,7 +234,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -343,11 +340,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -633,7 +625,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-rbtx4927 linux-2.4.30-mips/arch/mips/defconfig-rbtx4927
--- linux-2.4.30/arch/mips/defconfig-rbtx4927	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-rbtx4927	2005-03-18 13:13:21.000000000 +0100
@@ -28,8 +28,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -223,11 +223,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -466,7 +461,6 @@
 CONFIG_SERIAL_TXX9=y
 CONFIG_SERIAL_TXX9_CONSOLE=y
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
diff -Nur linux-2.4.30/arch/mips/defconfig-rm200 linux-2.4.30-mips/arch/mips/defconfig-rm200
--- linux-2.4.30/arch/mips/defconfig-rm200	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-rm200	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -229,11 +229,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -340,7 +335,6 @@
 # CONFIG_SERIAL is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-sb1250-swarm linux-2.4.30-mips/arch/mips/defconfig-sb1250-swarm
--- linux-2.4.30/arch/mips/defconfig-sb1250-swarm	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-sb1250-swarm	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -90,6 +90,7 @@
 # CONFIG_SIBYTE_TBPROF is not set
 CONFIG_SIBYTE_GENBUS_IDE=y
 CONFIG_SMP_CAPABLE=y
+CONFIG_MIPS_RTC=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TANBAC_TB0226 is not set
 # CONFIG_TANBAC_TB0229 is not set
@@ -253,11 +254,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -469,7 +465,6 @@
 CONFIG_SIBYTE_SB1250_DUART=y
 CONFIG_SIBYTE_SB1250_DUART_CONSOLE=y
 CONFIG_SERIAL_CONSOLE=y
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-sead linux-2.4.30-mips/arch/mips/defconfig-sead
--- linux-2.4.30/arch/mips/defconfig-sead	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-sead	2005-03-18 13:13:21.000000000 +0100
@@ -28,8 +28,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -244,7 +244,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
diff -Nur linux-2.4.30/arch/mips/defconfig-stretch linux-2.4.30-mips/arch/mips/defconfig-stretch
--- linux-2.4.30/arch/mips/defconfig-stretch	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-stretch	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -240,11 +240,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -324,9 +319,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -516,7 +513,6 @@
 # CONFIG_SERIAL_TXX9 is not set
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-tb0226 linux-2.4.30-mips/arch/mips/defconfig-tb0226
--- linux-2.4.30/arch/mips/defconfig-tb0226	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-tb0226	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -228,11 +228,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -312,9 +307,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -518,7 +515,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
diff -Nur linux-2.4.30/arch/mips/defconfig-tb0229 linux-2.4.30-mips/arch/mips/defconfig-tb0229
--- linux-2.4.30/arch/mips/defconfig-tb0229	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-tb0229	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -230,11 +230,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -445,7 +440,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
diff -Nur linux-2.4.30/arch/mips/defconfig-ti1500 linux-2.4.30-mips/arch/mips/defconfig-ti1500
--- linux-2.4.30/arch/mips/defconfig-ti1500	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-ti1500	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 CONFIG_MIPS_XXS1500=y
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -213,9 +213,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 CONFIG_MTD_XXS1500=y
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -234,7 +232,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -339,11 +336,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -600,7 +592,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-workpad linux-2.4.30-mips/arch/mips/defconfig-workpad
--- linux-2.4.30/arch/mips/defconfig-workpad	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-workpad	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -222,11 +222,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -426,7 +421,6 @@
 # CONFIG_SERIAL_MULTIPORT is not set
 # CONFIG_HUB6 is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
diff -Nur linux-2.4.30/arch/mips/defconfig-xxs1500 linux-2.4.30-mips/arch/mips/defconfig-xxs1500
--- linux-2.4.30/arch/mips/defconfig-xxs1500	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-xxs1500	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 CONFIG_MIPS_XXS1500=y
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -213,9 +213,7 @@
 # CONFIG_MTD_BOSPORUS is not set
 CONFIG_MTD_XXS1500=y
 # CONFIG_MTD_MTX1 is not set
-# CONFIG_MTD_DB1X00 is not set
 # CONFIG_MTD_PB1550 is not set
-# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -234,7 +232,6 @@
 #
 # Disk-On-Chip Device Drivers
 #
-# CONFIG_MTD_DOC1000 is not set
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOCPROBE is not set
@@ -339,11 +336,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -671,7 +663,6 @@
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/defconfig-yosemite linux-2.4.30-mips/arch/mips/defconfig-yosemite
--- linux-2.4.30/arch/mips/defconfig-yosemite	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/defconfig-yosemite	2005-03-18 13:13:21.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -227,11 +227,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -310,9 +305,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -477,7 +474,6 @@
 # CONFIG_SERIAL_TXX9 is not set
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips/kernel/cpu-probe.c linux-2.4.30-mips/arch/mips/kernel/cpu-probe.c
--- linux-2.4.30/arch/mips/kernel/cpu-probe.c	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/kernel/cpu-probe.c	2005-04-08 10:33:17.000000000 +0200
@@ -34,16 +34,12 @@
 		".set\tmips0");
 }
 
-/* The Au1xxx wait is available only if we run CONFIG_PM and
- * the timer setup found we had a 32KHz counter available.
- * There are still problems with functions that may call au1k_wait
- * directly, but that will be discovered pretty quickly.
- */
-extern void (*au1k_wait_ptr)(void);
-void au1k_wait(void)
+/* The Au1xxx wait is available only if using 32khz counter or
+ * external timer source, but specifically not CP0 Counter. */
+int allow_au1k_wait; 
+static void au1k_wait(void)
 {
-#ifdef CONFIG_PM
-	unsigned long addr;
+	unsigned long addr = 0;
 	/* using the wait instruction makes CP0 counter unusable */
 	__asm__("la %0,au1k_wait\n\t"
 		".set mips3\n\t"
@@ -58,10 +54,6 @@
 		"nop\n\t"
 		".set mips0\n\t"
 		: : "r" (addr));
-#else
-	__asm__("nop\n\t"
-		"nop");
-#endif
 }
 
 static inline void check_wait(void)
@@ -100,20 +92,17 @@
 		cpu_wait = r4k_wait;
 		printk(" available.\n");
 		break;
-#ifdef CONFIG_PM
 	case CPU_AU1000:
 	case CPU_AU1100:
 	case CPU_AU1500:
 	case CPU_AU1550:
-		if (au1k_wait_ptr != NULL) {
-			cpu_wait = au1k_wait_ptr;
+	case CPU_AU1200:
+		if (allow_au1k_wait) {
+			cpu_wait = au1k_wait;
 			printk(" available.\n");
-		}
-		else {
+		} else
 			printk(" unavailable.\n");
-		}
 		break;
-#endif
 	default:
 		printk(" unavailable.\n");
 		break;
diff -Nur linux-2.4.30/arch/mips/kernel/head.S linux-2.4.30-mips/arch/mips/kernel/head.S
--- linux-2.4.30/arch/mips/kernel/head.S	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/kernel/head.S	2004-11-22 14:38:23.000000000 +0100
@@ -43,9 +43,9 @@
 
 		/* Cache Error */
 		LEAF(except_vec2_generic)
+		.set	push
 		.set	noreorder
 		.set	noat
-		.set    mips0
 		/*
 		 * This is a very bad place to be.  Our cache error
 		 * detection has triggered.  If we have write-back data
@@ -64,10 +64,9 @@
 
 		j	cache_parity_error
 		 nop
+		.set	pop
 		END(except_vec2_generic)
 
-		.set	at
-
 		/*
 		 * Special interrupt vector for embedded MIPS.  This is a
 		 * dedicated interrupt vector which reduces interrupt processing
@@ -76,8 +75,11 @@
 		 * size!
 		 */
 		NESTED(except_vec4, 0, sp)
+		.set	push
+		.set	noreorder
 1:		j	1b			/* Dummy, will be replaced */
 		 nop
+		.set	pop
 		END(except_vec4)
 
 		/*
@@ -87,8 +89,11 @@
 		 * unconditional jump to this vector.
 		 */
 		NESTED(except_vec_ejtag_debug, 0, sp)
+		.set	push
+		.set	noreorder
 		j	ejtag_debug_handler
 		 nop
+		.set	pop
 		END(except_vec_ejtag_debug)
 
 		__FINIT
@@ -97,6 +102,7 @@
 		 * EJTAG debug exception handler.
 		 */
 		NESTED(ejtag_debug_handler, PT_SIZE, sp)
+		.set	push
 		.set	noat
 		.set	noreorder
 		mtc0	k0, CP0_DESAVE
@@ -120,7 +126,7 @@
 		deret
 		.set	mips0
 		 nop
-		.set	at
+		.set	pop
 		END(ejtag_debug_handler)
 
 		__INIT
@@ -132,13 +138,17 @@
 		* unconditional jump to this vector.
 		*/
 		NESTED(except_vec_nmi, 0, sp)
+		.set	push
+		.set	noreorder
 		j       nmi_handler
 		 nop
+		.set	pop
 		END(except_vec_nmi)
 
 		__FINIT
 
 		NESTED(nmi_handler, PT_SIZE, sp)
+		.set	push
 		.set    noat
 		.set    noreorder
 		.set    mips3
@@ -147,8 +157,7 @@
 		 move   a0, sp
 		RESTORE_ALL
 		eret
-		.set    at
-		.set    mips0
+		.set	pop
 		END(nmi_handler)
 
 		__INIT
@@ -157,7 +166,20 @@
 		 * Kernel entry point
 		 */
 		NESTED(kernel_entry, 16, sp)
+		.set	push
+		/*
+		 * For the moment disable interrupts and mark the kernel mode.
+		 * A full initialization of the CPU's status register is done
+		 * later in per_cpu_trap_init().
+		 */
+		mfc0	t0, CP0_STATUS
+		or	t0, ST0_CU0|0x1f
+		xor	t0, 0x1f
+		mtc0	t0, CP0_STATUS
+
 		.set	noreorder
+		sll	zero,3				# ehb
+		.set	reorder
 
 		/*
 		 * The firmware/bootloader passes argc/argp/envp
@@ -170,8 +192,8 @@
 		la	t1, (_end - 4)
 1:
 		addiu	t0, 4
+		sw	zero, (t0)
 		bne	t0, t1, 1b
-		 sw	zero, (t0)
 
 		/*
 		 * Stack for kernel and init, current variable
@@ -182,7 +204,7 @@
 		sw	t0, kernelsp
 
 		jal	init_arch
-		 nop
+		.set	pop
 		END(kernel_entry)
 
 
@@ -193,17 +215,26 @@
  * function after setting up the stack and gp registers.
  */
 		LEAF(smp_bootstrap)
-		.set push
-		.set noreorder
-		mtc0	zero, CP0_WIRED
-		CLI
+		.set	push
+		/*
+		 * For the moment disable interrupts and bootstrap exception
+		 * vectors and mark the kernel mode.  A full initialization of
+		 * the CPU's status register is done later in
+		 * per_cpu_trap_init().
+		 */
 		mfc0	t0, CP0_STATUS
-		li	t1, ~(ST0_CU1|ST0_CU2|ST0_CU3|ST0_KX|ST0_SX|ST0_UX)
-		and	t0, t1
-		or	t0, (ST0_CU0);
+		or	t0, ST0_CU0|ST0_BEV|0x1f
+		xor	t0, ST0_BEV|0x1f
+		mtc0	t0, CP0_STATUS
+
+		.set	noreorder
+		sll	zero,3				# ehb
+		.set	reorder
+
+		mtc0	zero, CP0_WIRED
+
 		jal	start_secondary
-		 mtc0	t0, CP0_STATUS
-		.set pop
+		.set	pop
 		END(smp_bootstrap)
 #endif
 
diff -Nur linux-2.4.30/arch/mips/kernel/scall_o32.S linux-2.4.30-mips/arch/mips/kernel/scall_o32.S
--- linux-2.4.30/arch/mips/kernel/scall_o32.S	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/kernel/scall_o32.S	2005-02-07 22:21:53.000000000 +0100
@@ -121,15 +121,14 @@
 
 trace_a_syscall:
 	SAVE_STATIC
-	sw	t2, PT_R1(sp)
+	move	s0, t2
 	jal	syscall_trace
-	lw	t2, PT_R1(sp)
 
 	lw	a0, PT_R4(sp)		# Restore argument registers
 	lw	a1, PT_R5(sp)
 	lw	a2, PT_R6(sp)
 	lw	a3, PT_R7(sp)
-	jalr	t2
+	jalr	s0
 
 	li	t0, -EMAXERRNO - 1	# error?
 	sltu	t0, t0, v0
diff -Nur linux-2.4.30/arch/mips/kernel/setup.c linux-2.4.30-mips/arch/mips/kernel/setup.c
--- linux-2.4.30/arch/mips/kernel/setup.c	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/kernel/setup.c	2005-01-13 22:15:57.000000000 +0100
@@ -5,7 +5,7 @@
  *
  * Copyright (C) 1995  Linus Torvalds
  * Copyright (C) 1995  Waldorf Electronics
- * Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001  Ralf Baechle
+ * Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 01, 05  Ralf Baechle
  * Copyright (C) 1996  Stoned Elipot
  * Copyright (C) 2000, 2001, 2002  Maciej W. Rozycki
  */
@@ -71,6 +71,8 @@
 extern struct rtc_ops no_rtc_ops;
 struct rtc_ops *rtc_ops;
 
+EXPORT_SYMBOL(rtc_ops);
+
 #ifdef CONFIG_PC_KEYB
 struct kbd_ops *kbd_ops;
 #endif
@@ -132,10 +134,6 @@
 	 */
 	load_mmu();
 
-	/* Disable coprocessors and set FPU for 16/32 FPR register model */
-	clear_c0_status(ST0_CU1|ST0_CU2|ST0_CU3|ST0_KX|ST0_SX|ST0_FR);
-	set_c0_status(ST0_CU0);
-
 	start_kernel();
 }
 
diff -Nur linux-2.4.30/arch/mips/kernel/traps.c linux-2.4.30-mips/arch/mips/kernel/traps.c
--- linux-2.4.30/arch/mips/kernel/traps.c	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/kernel/traps.c	2005-04-12 22:25:34.000000000 +0200
@@ -452,9 +452,10 @@
 	}
 	ll_task = current;
 
+	compute_return_epc(regs);
+
 	regs->regs[(opcode & RT) >> 16] = value;
 
-	compute_return_epc(regs);
 	return;
 
 sig:
@@ -485,8 +486,8 @@
 		goto sig;
 	}
 	if (ll_bit == 0 || ll_task != current) {
-		regs->regs[reg] = 0;
 		compute_return_epc(regs);
+		regs->regs[reg] = 0;
 		return;
 	}
 
@@ -495,9 +496,9 @@
 		goto sig;
 	}
 
+	compute_return_epc(regs);
 	regs->regs[reg] = 1;
 
-	compute_return_epc(regs);
 	return;
 
 sig:
@@ -887,12 +888,18 @@
 void __init per_cpu_trap_init(void)
 {
 	unsigned int cpu = smp_processor_id();
+	unsigned int status_set = ST0_CU0;
 
-	/* Some firmware leaves the BEV flag set, clear it.  */
-	clear_c0_status(ST0_CU3|ST0_CU2|ST0_CU1|ST0_BEV|ST0_KX|ST0_SX|ST0_UX);
-
+	/*
+	 * Disable coprocessors and 64-bit addressing and set FPU for
+	 * the 16/32 FPR register model.  Reset the BEV flag that some
+	 * firmware may have left set and the TS bit (for IP27).  Set
+	 * XX for ISA IV code to work.
+	 */
 	if (current_cpu_data.isa_level == MIPS_CPU_ISA_IV)
-		set_c0_status(ST0_XX);
+		status_set |= ST0_XX;
+	change_c0_status(ST0_CU|ST0_FR|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
+			 status_set);
 
 	/*
 	 * Some MIPS CPUs have a dedicated interrupt vector which reduces the
@@ -902,7 +909,7 @@
 		set_c0_cause(CAUSEF_IV);
 
 	cpu_data[cpu].asid_cache = ASID_FIRST_VERSION;
-	write_c0_context(cpu << 23);
+	TLBMISS_HANDLER_SETUP();
 
 	atomic_inc(&init_mm.mm_count);
 	current->active_mm = &init_mm;
@@ -918,8 +925,6 @@
 	extern char except_vec4;
 	unsigned long i;
 
-	per_cpu_trap_init();
-
 	/* Copy the generic exception handler code to it's final destination. */
 	memcpy((void *)(KSEG0 + 0x80), &except_vec1_generic, 0x80);
 
@@ -1020,10 +1025,5 @@
 
 	flush_icache_range(KSEG0, KSEG0 + 0x400);
 
-	atomic_inc(&init_mm.mm_count);	/* XXX UP?  */
-	current->active_mm = &init_mm;
-
-	/* XXX Must be done for all CPUs  */
-	current_cpu_data.asid_cache = ASID_FIRST_VERSION;
-	TLBMISS_HANDLER_SETUP();
+	per_cpu_trap_init();
 }
diff -Nur linux-2.4.30/arch/mips/lib/rtc-no.c linux-2.4.30-mips/arch/mips/lib/rtc-no.c
--- linux-2.4.30/arch/mips/lib/rtc-no.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/lib/rtc-no.c	2005-01-13 22:15:57.000000000 +0100
@@ -6,10 +6,9 @@
  * Stub RTC routines to keep Linux from crashing on machine which don't
  * have a RTC chip.
  *
- * Copyright (C) 1998, 2001 by Ralf Baechle
+ * Copyright (C) 1998, 2001, 2005 by Ralf Baechle
  */
 #include <linux/kernel.h>
-#include <linux/module.h>
 #include <linux/mc146818rtc.h>
 
 static unsigned int shouldnt_happen(void)
@@ -29,5 +28,3 @@
     .rtc_write_data = (void *) &shouldnt_happen,
     .rtc_bcd_mode   = (void *) &shouldnt_happen
 };
-
-EXPORT_SYMBOL(rtc_ops);
diff -Nur linux-2.4.30/arch/mips/lib/rtc-std.c linux-2.4.30-mips/arch/mips/lib/rtc-std.c
--- linux-2.4.30/arch/mips/lib/rtc-std.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/lib/rtc-std.c	2005-01-13 22:15:57.000000000 +0100
@@ -5,9 +5,8 @@
  *
  * RTC routines for PC style attached Dallas chip.
  *
- * Copyright (C) 1998, 2001 by Ralf Baechle
+ * Copyright (C) 1998, 2001, 05 by Ralf Baechle
  */
-#include <linux/module.h>
 #include <linux/mc146818rtc.h>
 #include <asm/io.h>
 
@@ -33,5 +32,3 @@
 	&std_rtc_write_data,
 	&std_rtc_bcd_mode
 };
-
-EXPORT_SYMBOL(rtc_ops);
diff -Nur linux-2.4.30/arch/mips/mm/c-r4k.c linux-2.4.30-mips/arch/mips/mm/c-r4k.c
--- linux-2.4.30/arch/mips/mm/c-r4k.c	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/mm/c-r4k.c	2005-02-06 22:55:42.000000000 +0100
@@ -867,9 +867,16 @@
 	 * normally they'd suffer from aliases but magic in the hardware deals
 	 * with that for us so we don't need to take care ourselves.
 	 */
-	if (c->cputype != CPU_R10000 && c->cputype != CPU_R12000)
-		if (c->dcache.waysize > PAGE_SIZE)
-		        c->dcache.flags |= MIPS_CACHE_ALIASES;
+	switch (c->cputype) {
+	case CPU_R10000:
+	case CPU_R12000:
+		break;
+	case CPU_24K:
+		if (!(read_c0_config7() & (1 << 16)))
+	default:
+			if (c->dcache.waysize > PAGE_SIZE)
+				c->dcache.flags |= MIPS_CACHE_ALIASES;
+	}
 
 	switch (c->cputype) {
 	case CPU_20KC:
@@ -1069,9 +1076,6 @@
 	probe_pcache();
 	setup_scache();
 
-	if (c->dcache.sets * c->dcache.ways > PAGE_SIZE)
-		c->dcache.flags |= MIPS_CACHE_ALIASES;
-
 	r4k_blast_dcache_page_setup();
 	r4k_blast_dcache_page_indexed_setup();
 	r4k_blast_dcache_setup();
diff -Nur linux-2.4.30/arch/mips/mm/cerr-sb1.c linux-2.4.30-mips/arch/mips/mm/cerr-sb1.c
--- linux-2.4.30/arch/mips/mm/cerr-sb1.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/mm/cerr-sb1.c	2004-12-13 18:37:23.000000000 +0100
@@ -252,14 +252,14 @@
 
 /* Masks to select bits for Hamming parity, mask_72_64[i] for bit[i] */
 static const uint64_t mask_72_64[8] = {
-	0x0738C808099264FFL,
-	0x38C808099264FF07L,
-	0xC808099264FF0738L,
-	0x08099264FF0738C8L,
-	0x099264FF0738C808L,
-	0x9264FF0738C80809L,
-	0x64FF0738C8080992L,
-	0xFF0738C808099264L
+	0x0738C808099264FFULL,
+	0x38C808099264FF07ULL,
+	0xC808099264FF0738ULL,
+	0x08099264FF0738C8ULL,
+	0x099264FF0738C808ULL,
+	0x9264FF0738C80809ULL,
+	0x64FF0738C8080992ULL,
+	0xFF0738C808099264ULL
 };
 
 /* Calculate the parity on a range of bits */
@@ -331,9 +331,9 @@
 				    ((lru >> 4) & 0x3),
 				    ((lru >> 6) & 0x3));
 		}
-		va = (taglo & 0xC0000FFFFFFFE000) | addr;
+		va = (taglo & 0xC0000FFFFFFFE000ULL) | addr;
 		if ((taglo & (1 << 31)) && (((taglo >> 62) & 0x3) == 3))
-			va |= 0x3FFFF00000000000;
+			va |= 0x3FFFF00000000000ULL;
 		valid = ((taghi >> 29) & 1);
 		if (valid) {
 			tlo_tmp = taglo & 0xfff3ff;
@@ -474,7 +474,7 @@
 		: "r" ((way << 13) | addr));
 
 		taglo = ((unsigned long long)taglohi << 32) | taglolo;
-		pa = (taglo & 0xFFFFFFE000) | addr;
+		pa = (taglo & 0xFFFFFFE000ULL) | addr;
 		if (way == 0) {
 			lru = (taghi >> 14) & 0xff;
 			prom_printf("[Bank %d Set 0x%02x]  LRU > %d %d %d %d > MRU\n",
diff -Nur linux-2.4.30/arch/mips/mm/tlb-r4k.c linux-2.4.30-mips/arch/mips/mm/tlb-r4k.c
--- linux-2.4.30/arch/mips/mm/tlb-r4k.c	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/mm/tlb-r4k.c	2004-11-25 23:18:38.000000000 +0100
@@ -3,17 +3,12 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * r4xx0.c: R4000 processor variant specific MMU/Cache routines.
- *
  * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
  * Copyright (C) 1997, 1998, 1999, 2000 Ralf Baechle ralf@gnu.org
- *
- * To do:
- *
- *  - this code is a overbloated pig
- *  - many of the bug workarounds are not efficient at all, but at
- *    least they are functional ...
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2002 MIPS Technologies, Inc.  All rights reserved.
  */
+#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
@@ -25,9 +20,6 @@
 #include <asm/pgtable.h>
 #include <asm/system.h>
 
-#undef DEBUG_TLB
-#undef DEBUG_TLBUPDATE
-
 extern char except_vec0_nevada, except_vec0_r4000, except_vec0_r4600;
 
 /* CP0 hazard avoidance. */
@@ -41,33 +33,23 @@
 	unsigned long old_ctx;
 	int entry;
 
-#ifdef DEBUG_TLB
-	printk("[tlball]");
-#endif
-
 	local_irq_save(flags);
 	/* Save old context and create impossible VPN2 value */
 	old_ctx = read_c0_entryhi();
 	write_c0_entrylo0(0);
 	write_c0_entrylo1(0);
-	BARRIER;
 
 	entry = read_c0_wired();
 
 	/* Blast 'em all away. */
 	while (entry < current_cpu_data.tlbsize) {
-		/*
-		 * Make sure all entries differ.  If they're not different
-		 * MIPS32 will take revenge ...
-		 */
 		write_c0_entryhi(KSEG0 + entry*0x2000);
 		write_c0_index(entry);
-		BARRIER;
+		mtc0_tlbw_hazard();
 		tlb_write_indexed();
-		BARRIER;
 		entry++;
 	}
-	BARRIER;
+	tlbw_use_hazard();
 	write_c0_entryhi(old_ctx);
 	local_irq_restore(flags);
 }
@@ -76,12 +58,8 @@
 {
 	int cpu = smp_processor_id();
 
-	if (cpu_context(cpu, mm) != 0) {
-#ifdef DEBUG_TLB
-		printk("[tlbmm<%d>]", cpu_context(cpu, mm));
-#endif
+	if (cpu_context(cpu, mm) != 0)
 		drop_mmu_context(mm,cpu);
-	}
 }
 
 void local_flush_tlb_range(struct mm_struct *mm, unsigned long start,
@@ -93,10 +71,6 @@
 		unsigned long flags;
 		int size;
 
-#ifdef DEBUG_TLB
-		printk("[tlbrange<%02x,%08lx,%08lx>]",
-		       cpu_asid(cpu, mm), start, end);
-#endif
 		local_irq_save(flags);
 		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 		size = (size + 1) >> 1;
@@ -112,7 +86,7 @@
 
 				write_c0_entryhi(start | newpid);
 				start += (PAGE_SIZE << 1);
-				BARRIER;
+				mtc0_tlbw_hazard();
 				tlb_probe();
 				BARRIER;
 				idx = read_c0_index();
@@ -122,10 +96,10 @@
 					continue;
 				/* Make sure all entries differ. */
 				write_c0_entryhi(KSEG0 + idx*0x2000);
-				BARRIER;
+				mtc0_tlbw_hazard();
 				tlb_write_indexed();
-				BARRIER;
 			}
+			tlbw_use_hazard();
 			write_c0_entryhi(oldpid);
 		} else {
 			drop_mmu_context(mm, cpu);
@@ -138,34 +112,30 @@
 {
 	int cpu = smp_processor_id();
 
-	if (!vma || cpu_context(cpu, vma->vm_mm) != 0) {
+	if (cpu_context(cpu, vma->vm_mm) != 0) {
 		unsigned long flags;
-		int oldpid, newpid, idx;
+		unsigned long oldpid, newpid, idx;
 
-#ifdef DEBUG_TLB
-		printk("[tlbpage<%d,%08lx>]", cpu_context(cpu, vma->vm_mm),
-		       page);
-#endif
 		newpid = cpu_asid(cpu, vma->vm_mm);
 		page &= (PAGE_MASK << 1);
 		local_irq_save(flags);
 		oldpid = read_c0_entryhi();
 		write_c0_entryhi(page | newpid);
-		BARRIER;
+		mtc0_tlbw_hazard();
 		tlb_probe();
 		BARRIER;
 		idx = read_c0_index();
 		write_c0_entrylo0(0);
 		write_c0_entrylo1(0);
-		if(idx < 0)
+		if (idx < 0)
 			goto finish;
 		/* Make sure all entries differ. */
 		write_c0_entryhi(KSEG0+idx*0x2000);
-		BARRIER;
+		mtc0_tlbw_hazard();
 		tlb_write_indexed();
+		tlbw_use_hazard();
 
 	finish:
-		BARRIER;
 		write_c0_entryhi(oldpid);
 		local_irq_restore(flags);
 	}
@@ -185,7 +155,7 @@
 
 	local_irq_save(flags);
 	write_c0_entryhi(page);
-	BARRIER;
+	mtc0_tlbw_hazard();
 	tlb_probe();
 	BARRIER;
 	idx = read_c0_index();
@@ -194,18 +164,19 @@
 	if (idx >= 0) {
 		/* Make sure all entries differ. */
 		write_c0_entryhi(KSEG0+idx*0x2000);
+		mtc0_tlbw_hazard();
 		tlb_write_indexed();
+		tlbw_use_hazard();
 	}
-	BARRIER;
 	write_c0_entryhi(oldpid);
+
 	local_irq_restore(flags);
 }
 
 EXPORT_SYMBOL(local_flush_tlb_one);
 
-/* We will need multiple versions of update_mmu_cache(), one that just
- * updates the TLB with the new pte(s), and another which also checks
- * for the R4k "end of page" hardware bug and does the needy.
+/*
+ * Updates the TLB with the new pte(s).
  */
 void __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)
 {
@@ -223,25 +194,16 @@
 
 	pid = read_c0_entryhi() & ASID_MASK;
 
-#ifdef DEBUG_TLB
-	if ((pid != cpu_asid(cpu, vma->vm_mm)) ||
-	    (cpu_context(vma->vm_mm) == 0)) {
-		printk("update_mmu_cache: Wheee, bogus tlbpid mmpid=%d "
-		       "tlbpid=%d\n", (int) (cpu_asid(cpu, vma->vm_mm)), pid);
-	}
-#endif
-
 	local_irq_save(flags);
 	address &= (PAGE_MASK << 1);
 	write_c0_entryhi(address | pid);
 	pgdp = pgd_offset(vma->vm_mm, address);
-	BARRIER;
+	mtc0_tlbw_hazard();
 	tlb_probe();
 	BARRIER;
 	pmdp = pmd_offset(pgdp, address);
 	idx = read_c0_index();
 	ptep = pte_offset(pmdp, address);
-	BARRIER;
 #if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
 	write_c0_entrylo0(ptep->pte_high);
 	ptep++;
@@ -251,15 +213,13 @@
 	write_c0_entrylo1(pte_val(*ptep) >> 6);
 #endif
 	write_c0_entryhi(address | pid);
-	BARRIER;
-	if (idx < 0) {
+	mtc0_tlbw_hazard();
+	if (idx < 0)
 		tlb_write_random();
-	} else {
+	else
 		tlb_write_indexed();
-	}
-	BARRIER;
+	tlbw_use_hazard();
 	write_c0_entryhi(pid);
-	BARRIER;
 	local_irq_restore(flags);
 }
 
@@ -279,24 +239,26 @@
 	asid = read_c0_entryhi() & ASID_MASK;
 	write_c0_entryhi(address | asid);
 	pgdp = pgd_offset(vma->vm_mm, address);
+	mtc0_tlbw_hazard();
 	tlb_probe();
+	BARRIER;
 	pmdp = pmd_offset(pgdp, address);
 	idx = read_c0_index();
 	ptep = pte_offset(pmdp, address);
 	write_c0_entrylo0(pte_val(*ptep++) >> 6);
 	write_c0_entrylo1(pte_val(*ptep) >> 6);
-	BARRIER;
+	mtc0_tlbw_hazard();
 	if (idx < 0)
 		tlb_write_random();
 	else
 		tlb_write_indexed();
-	BARRIER;
+	tlbw_use_hazard();
 	local_irq_restore(flags);
 }
 #endif
 
 void __init add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
-		     unsigned long entryhi, unsigned long pagemask)
+			    unsigned long entryhi, unsigned long pagemask)
 {
 	unsigned long flags;
 	unsigned long wired;
@@ -315,9 +277,9 @@
 	write_c0_entryhi(entryhi);
 	write_c0_entrylo0(entrylo0);
 	write_c0_entrylo1(entrylo1);
-	BARRIER;
+	mtc0_tlbw_hazard();
 	tlb_write_indexed();
-	BARRIER;
+	tlbw_use_hazard();
 
 	write_c0_entryhi(old_ctx);
 	BARRIER;
@@ -355,17 +317,15 @@
 	}
 
 	write_c0_index(temp_tlb_entry);
-	BARRIER;
 	write_c0_pagemask(pagemask);
 	write_c0_entryhi(entryhi);
 	write_c0_entrylo0(entrylo0);
 	write_c0_entrylo1(entrylo1);
-	BARRIER;
+	mtc0_tlbw_hazard();
 	tlb_write_indexed();
-	BARRIER;
+	tlbw_use_hazard();
 
 	write_c0_entryhi(old_ctx);
-	BARRIER;
 	write_c0_pagemask(old_pagemask);
 out:
 	local_irq_restore(flags);
@@ -375,7 +335,7 @@
 static void __init probe_tlb(unsigned long config)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
-	unsigned int reg;
+	unsigned int config1;
 
 	/*
 	 * If this isn't a MIPS32 / MIPS64 compliant CPU.  Config 1 register
@@ -385,16 +345,16 @@
 	if ((c->processor_id  & 0xff0000) == PRID_COMP_LEGACY)
 		return;
 
-	reg = read_c0_config1();
+	config1 = read_c0_config1();
 	if (!((config >> 7) & 3))
 		panic("No TLB present");
 
-	c->tlbsize = ((reg >> 25) & 0x3f) + 1;
+	c->tlbsize = ((config1 >> 25) & 0x3f) + 1;
 }
 
 void __init r4k_tlb_init(void)
 {
-	u32 config = read_c0_config();
+	unsigned int config = read_c0_config();
 
 	/*
 	 * You should never change this register:
diff -Nur linux-2.4.30/arch/mips/mm/tlbex-mips32.S linux-2.4.30-mips/arch/mips/mm/tlbex-mips32.S
--- linux-2.4.30/arch/mips/mm/tlbex-mips32.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/mm/tlbex-mips32.S	2004-11-29 00:33:15.000000000 +0100
@@ -196,7 +196,7 @@
 	.set	noat; \
 	SAVE_ALL; \
 	mfc0	a2, CP0_BADVADDR; \
-	STI; \
+	KMODE; \
 	.set	at; \
 	move	a0, sp; \
 	jal	do_page_fault; \
diff -Nur linux-2.4.30/arch/mips/mm/tlbex-r4k.S linux-2.4.30-mips/arch/mips/mm/tlbex-r4k.S
--- linux-2.4.30/arch/mips/mm/tlbex-r4k.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips/mm/tlbex-r4k.S	2004-11-25 23:18:38.000000000 +0100
@@ -184,13 +184,10 @@
 	P_MTC0	k0, CP0_ENTRYLO0		# load it
 	PTE_SRL	k1, k1, 6			# convert to entrylo1
 	P_MTC0	k1, CP0_ENTRYLO1		# load it
-	b	1f
-	rm9000_tlb_hazard
+	mtc0_tlbw_hazard
 	tlbwr					# write random tlb entry
-1:
-	nop
-	rm9000_tlb_hazard
-	eret					# return from trap
+	tlbw_eret_hazard
+	eret
 	END(except_vec0_r4000)
 
 	/* TLB refill, EXL == 0, R4600 version */
@@ -468,13 +465,10 @@
 	PTE_PRESENT(k0, k1, nopage_tlbl)
 	PTE_MAKEVALID(k0, k1)
 	PTE_RELOAD(k1, k0)
-	rm9000_tlb_hazard
-	nop
-	b	1f
-	 tlbwi
-1:
+	mtc0_tlbw_hazard
+	tlbwi
 	nop
-	rm9000_tlb_hazard
+	tlbw_eret_hazard
 	.set	mips3
 	eret
 	.set	mips0
@@ -496,13 +490,10 @@
 	PTE_WRITABLE(k0, k1, nopage_tlbs)
 	PTE_MAKEWRITE(k0, k1)
 	PTE_RELOAD(k1, k0)
-	rm9000_tlb_hazard
-	nop
-	b	1f
-	 tlbwi
-1:
+	mtc0_tlbw_hazard
+	tlbwi
 	nop
-	rm9000_tlb_hazard
+	tlbw_eret_hazard
 	.set	mips3
 	eret
 	.set	mips0
@@ -529,13 +520,10 @@
 
 	/* Now reload the entry into the tlb. */
 	PTE_RELOAD(k1, k0)
-	rm9000_tlb_hazard
-	nop
-	b	1f
-	 tlbwi
-1:
-	rm9000_tlb_hazard
+	mtc0_tlbw_hazard
+	tlbwi
 	nop
+	tlbw_eret_hazard
 	.set	mips3
 	eret
 	.set	mips0
diff -Nur linux-2.4.30/arch/mips64/defconfig linux-2.4.30-mips/arch/mips64/defconfig
--- linux-2.4.30/arch/mips64/defconfig	2005-01-19 15:09:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/defconfig	2005-03-18 13:13:23.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -470,9 +470,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -658,7 +660,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips64/defconfig-atlas linux-2.4.30-mips/arch/mips64/defconfig-atlas
--- linux-2.4.30/arch/mips64/defconfig-atlas	2005-01-19 15:09:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/defconfig-atlas	2005-03-18 13:13:23.000000000 +0100
@@ -28,8 +28,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -232,11 +232,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -314,9 +309,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -474,7 +471,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips64/defconfig-decstation linux-2.4.30-mips/arch/mips64/defconfig-decstation
--- linux-2.4.30/arch/mips64/defconfig-decstation	2005-01-19 15:09:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/defconfig-decstation	2005-03-18 13:13:23.000000000 +0100
@@ -28,8 +28,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -224,11 +224,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -307,9 +302,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -477,7 +474,6 @@
 CONFIG_SERIAL_DEC_CONSOLE=y
 # CONFIG_DZ is not set
 CONFIG_ZS=y
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips64/defconfig-ip22 linux-2.4.30-mips/arch/mips64/defconfig-ip22
--- linux-2.4.30/arch/mips64/defconfig-ip22	2005-01-19 15:09:31.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/defconfig-ip22	2005-03-18 13:13:23.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -235,11 +235,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -319,9 +314,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -488,7 +485,6 @@
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 # CONFIG_TXX927_SERIAL is not set
 CONFIG_IP22_SERIAL=y
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips64/defconfig-ip27 linux-2.4.30-mips/arch/mips64/defconfig-ip27
--- linux-2.4.30/arch/mips64/defconfig-ip27	2005-01-19 15:09:31.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/defconfig-ip27	2005-03-18 13:13:23.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -470,9 +470,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -658,7 +660,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips64/defconfig-jaguar linux-2.4.30-mips/arch/mips64/defconfig-jaguar
--- linux-2.4.30/arch/mips64/defconfig-jaguar	2005-01-19 15:09:31.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/defconfig-jaguar	2005-03-18 13:13:23.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -227,11 +227,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -403,7 +398,6 @@
 # CONFIG_SERIAL_TXX9 is not set
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips64/defconfig-malta linux-2.4.30-mips/arch/mips64/defconfig-malta
--- linux-2.4.30/arch/mips64/defconfig-malta	2005-01-19 15:09:31.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/defconfig-malta	2005-03-18 13:13:23.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -235,11 +235,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -317,9 +312,11 @@
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_AHCI is not set
 # CONFIG_SCSI_SATA_SVW is not set
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_SX4 is not set
 # CONFIG_SCSI_SATA_SIL is not set
@@ -477,7 +474,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips64/defconfig-ocelotc linux-2.4.30-mips/arch/mips64/defconfig-ocelotc
--- linux-2.4.30/arch/mips64/defconfig-ocelotc	2005-01-19 15:09:31.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/defconfig-ocelotc	2005-03-18 13:13:23.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -231,11 +231,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -453,7 +448,6 @@
 # CONFIG_SERIAL_TXX9 is not set
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 # CONFIG_TXX927_SERIAL is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips64/defconfig-sb1250-swarm linux-2.4.30-mips/arch/mips64/defconfig-sb1250-swarm
--- linux-2.4.30/arch/mips64/defconfig-sb1250-swarm	2005-01-19 15:09:31.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/defconfig-sb1250-swarm	2005-03-18 13:13:23.000000000 +0100
@@ -30,8 +30,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -90,6 +90,7 @@
 # CONFIG_SIBYTE_TBPROF is not set
 CONFIG_SIBYTE_GENBUS_IDE=y
 CONFIG_SMP_CAPABLE=y
+CONFIG_MIPS_RTC=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TANBAC_TB0226 is not set
 # CONFIG_TANBAC_TB0229 is not set
@@ -253,11 +254,6 @@
 #
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-
-#
-# Appletalk devices
-#
-# CONFIG_DEV_APPLETALK is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_X25 is not set
@@ -432,7 +428,6 @@
 CONFIG_SIBYTE_SB1250_DUART=y
 CONFIG_SIBYTE_SB1250_DUART_CONSOLE=y
 CONFIG_SERIAL_CONSOLE=y
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -Nur linux-2.4.30/arch/mips64/defconfig-sead linux-2.4.30-mips/arch/mips64/defconfig-sead
--- linux-2.4.30/arch/mips64/defconfig-sead	2005-01-19 15:09:31.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/defconfig-sead	2005-03-18 13:13:23.000000000 +0100
@@ -28,8 +28,8 @@
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -242,7 +242,6 @@
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
diff -Nur linux-2.4.30/arch/mips64/kernel/binfmt_elfn32.c linux-2.4.30-mips/arch/mips64/kernel/binfmt_elfn32.c
--- linux-2.4.30/arch/mips64/kernel/binfmt_elfn32.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.30-mips/arch/mips64/kernel/binfmt_elfn32.c	2005-01-26 03:40:47.000000000 +0100
@@ -116,4 +116,7 @@
 #undef MODULE_DESCRIPTION
 #undef MODULE_AUTHOR
 
+#undef TASK_SIZE
+#define TASK_SIZE TASK_SIZE32
+
 #include "../../../fs/binfmt_elf.c"
diff -Nur linux-2.4.30/arch/mips64/kernel/binfmt_elfo32.c linux-2.4.30-mips/arch/mips64/kernel/binfmt_elfo32.c
--- linux-2.4.30/arch/mips64/kernel/binfmt_elfo32.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.30-mips/arch/mips64/kernel/binfmt_elfo32.c	2005-01-26 03:40:47.000000000 +0100
@@ -137,4 +137,7 @@
 #undef MODULE_DESCRIPTION
 #undef MODULE_AUTHOR
 
+#undef TASK_SIZE
+#define TASK_SIZE TASK_SIZE32
+
 #include "../../../fs/binfmt_elf.c"
diff -Nur linux-2.4.30/arch/mips64/kernel/head.S linux-2.4.30-mips/arch/mips64/kernel/head.S
--- linux-2.4.30/arch/mips64/kernel/head.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/kernel/head.S	2004-11-22 14:38:26.000000000 +0100
@@ -91,6 +91,21 @@
 	__INIT
 
 NESTED(kernel_entry, 16, sp)			# kernel entry point
+	.set	push
+	/*
+	 * For the moment disable interrupts, mark the kernel mode and
+	 * set ST0_KX so that the CPU does not spit fire when using
+	 * 64-bit addresses.  A full initialization of the CPU's status
+	 * register is done later in per_cpu_trap_init().
+	 */
+	mfc0	t0, CP0_STATUS
+	or	t0, ST0_CU0|ST0_KX|0x1f
+	xor	t0, 0x1f
+	mtc0	t0, CP0_STATUS
+
+	.set	noreorder
+	sll	zero,3				# ehb
+	.set	reorder
 
 	ori	sp, 0xf				# align stack on 16 byte.
 	xori	sp, 0xf
@@ -103,8 +118,6 @@
 
 	ARC64_TWIDDLE_PC
 
-	CLI					# disable interrupts
-
 	/*
 	 * The firmware/bootloader passes argc/argp/envp
 	 * to us as arguments.  But clear bss first because
@@ -125,6 +138,7 @@
 	dsubu	sp, 4*SZREG			# init stack pointer
 
 	j	init_arch
+	.set	pop
 	END(kernel_entry)
 
 #ifdef CONFIG_SMP
@@ -133,6 +147,23 @@
  * function after setting up the stack and gp registers.
  */
 NESTED(smp_bootstrap, 16, sp)
+	.set	push
+	/*
+	 * For the moment disable interrupts and bootstrap exception
+	 * vectors, mark the kernel mode and set ST0_KX so that the CPU
+	 * does not spit fire when using 64-bit addresses.  A full
+	 * initialization of the CPU's status register is done later in
+	 * per_cpu_trap_init().
+	 */
+	mfc0	t0, CP0_STATUS
+	or	t0, ST0_CU0|ST0_BEV|ST0_KX|0x1f
+	xor	t0, ST0_BEV|0x1f
+	mtc0	t0, CP0_STATUS
+
+	.set	noreorder
+	sll	zero,3				# ehb
+	.set	reorder
+
 #ifdef CONFIG_SGI_IP27
 	GET_NASID_ASM	t1
 	dli	t0, KLDIR_OFFSET + (KLI_KERN_VARS * KLDIR_ENT_SIZE) + \
@@ -146,19 +177,8 @@
 	ARC64_TWIDDLE_PC
 #endif /* CONFIG_SGI_IP27 */
 
-	CLI
-
-	/*
-	 * For the moment set ST0_KU so the CPU will not spit fire when
-	 * executing 64-bit instructions.  The full initialization of the
-	 * CPU's status register is done later in per_cpu_trap_init().
-	 */
-        mfc0	t0, CP0_STATUS
-        or	t0, ST0_KX
-	mtc0	t0, CP0_STATUS
-
 	jal	start_secondary			# XXX: IP27: cboot
-
+	.set	pop
 	END(smp_bootstrap)
 #endif /* CONFIG_SMP */
 
diff -Nur linux-2.4.30/arch/mips64/kernel/ioctl32.c linux-2.4.30-mips/arch/mips64/kernel/ioctl32.c
--- linux-2.4.30/arch/mips64/kernel/ioctl32.c	2005-01-19 15:09:31.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/kernel/ioctl32.c	2005-01-26 03:36:17.000000000 +0100
@@ -2352,7 +2352,7 @@
 	IOCTL32_HANDLER(AUTOFS_IOC_SETTIMEOUT32, ioc_settimeout),
 	IOCTL32_DEFAULT(AUTOFS_IOC_EXPIRE),
 	IOCTL32_DEFAULT(AUTOFS_IOC_EXPIRE_MULTI),
-	IOCTL32_DEFAULT(AUTOFS_IOC_PROTSUBVER),
+	IOCTL32_DEFAULT(AUTOFS_IOC_PROTOSUBVER),
 	IOCTL32_DEFAULT(AUTOFS_IOC_ASKREGHOST),
 	IOCTL32_DEFAULT(AUTOFS_IOC_TOGGLEREGHOST),
 	IOCTL32_DEFAULT(AUTOFS_IOC_ASKUMOUNT),
diff -Nur linux-2.4.30/arch/mips64/kernel/linux32.c linux-2.4.30-mips/arch/mips64/kernel/linux32.c
--- linux-2.4.30/arch/mips64/kernel/linux32.c	2005-04-04 03:42:19.000000000 +0200
+++ linux-2.4.30-mips/arch/mips64/kernel/linux32.c	2005-03-18 13:13:23.000000000 +0100
@@ -1187,72 +1187,19 @@
    lseek back to original location.  They fail just like lseek does on
    non-seekable files.  */
 
-asmlinkage ssize_t sys32_pread(unsigned int fd, char * buf,
-			       size_t count, u32 unused, u64 a4, u64 a5)
+asmlinkage ssize_t sys32_pread(unsigned int fd, char *buf,
+                                 size_t count, u32 unused, u64 a4, u64 a5)
 {
-	ssize_t ret;
-	struct file * file;
-	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
-	loff_t pos;
-
-	ret = -EBADF;
-	file = fget(fd);
-	if (!file)
-		goto bad_file;
-	if (!(file->f_mode & FMODE_READ))
-		goto out;
-	pos = merge_64(a4, a5);
-	ret = locks_verify_area(FLOCK_VERIFY_READ, file->f_dentry->d_inode,
-				file, pos, count);
-	if (ret)
-		goto out;
-	ret = -EINVAL;
-	if (!file->f_op || !(read = file->f_op->read))
-		goto out;
-	if (pos < 0)
-		goto out;
-	ret = read(file, buf, count, &pos);
-	if (ret > 0)
-		dnotify_parent(file->f_dentry, DN_ACCESS);
-out:
-	fput(file);
-bad_file:
-	return ret;
+	return sys_pread(fd, buf, count, merge_64(a4, a5));
 }
 
 asmlinkage ssize_t sys32_pwrite(unsigned int fd, const char * buf,
 			        size_t count, u32 unused, u64 a4, u64 a5)
 {
-	ssize_t ret;
-	struct file * file;
-	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
-	loff_t pos;
-
-	ret = -EBADF;
-	file = fget(fd);
-	if (!file)
-		goto bad_file;
-	if (!(file->f_mode & FMODE_WRITE))
-		goto out;
-	pos = merge_64(a4, a5);
-	ret = locks_verify_area(FLOCK_VERIFY_WRITE, file->f_dentry->d_inode,
-				file, pos, count);
-	if (ret)
-		goto out;
-	ret = -EINVAL;
-	if (!file->f_op || !(write = file->f_op->write))
-		goto out;
-	if (pos < 0)
-		goto out;
-
-	ret = write(file, buf, count, &pos);
-	if (ret > 0)
-		dnotify_parent(file->f_dentry, DN_MODIFY);
-out:
-	fput(file);
-bad_file:
-	return ret;
+	return sys_pwrite(fd, buf, count, merge_64(a4, a5));
 }
+
+
 /*
  * Ooo, nasty.  We need here to frob 32-bit unsigned longs to
  * 64-bit unsigned longs.
diff -Nur linux-2.4.30/arch/mips64/kernel/scall_64.S linux-2.4.30-mips/arch/mips64/kernel/scall_64.S
--- linux-2.4.30/arch/mips64/kernel/scall_64.S	2005-01-19 15:09:32.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/kernel/scall_64.S	2005-02-07 22:21:54.000000000 +0100
@@ -102,15 +102,14 @@
 
 trace_a_syscall:
 	SAVE_STATIC
-	sd	t2,PT_R1(sp)
+	move	s0, t2
 	jal	syscall_trace
-	ld	t2,PT_R1(sp)
 
 	ld	a0, PT_R4(sp)		# Restore argument registers
 	ld	a1, PT_R5(sp)
 	ld	a2, PT_R6(sp)
 	ld	a3, PT_R7(sp)
-	jalr	t2
+	jalr	s0
 
 	li	t0, -EMAXERRNO - 1	# error?
 	sltu	t0, t0, v0
diff -Nur linux-2.4.30/arch/mips64/kernel/scall_n32.S linux-2.4.30-mips/arch/mips64/kernel/scall_n32.S
--- linux-2.4.30/arch/mips64/kernel/scall_n32.S	2005-01-19 15:09:32.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/kernel/scall_n32.S	2005-02-07 22:21:54.000000000 +0100
@@ -106,15 +106,14 @@
 
 trace_a_syscall:
 	SAVE_STATIC
-	sd	t2,PT_R1(sp)
+	move	s0, t2
 	jal	syscall_trace
-	ld	t2,PT_R1(sp)
 
 	ld	a0, PT_R4(sp)		# Restore argument registers
 	ld	a1, PT_R5(sp)
 	ld	a2, PT_R6(sp)
 	ld	a3, PT_R7(sp)
-	jalr	t2
+	jalr	s0
 
 	li	t0, -EMAXERRNO - 1	# error?
 	sltu	t0, t0, v0
diff -Nur linux-2.4.30/arch/mips64/kernel/scall_o32.S linux-2.4.30-mips/arch/mips64/kernel/scall_o32.S
--- linux-2.4.30/arch/mips64/kernel/scall_o32.S	2005-01-19 15:09:32.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/kernel/scall_o32.S	2005-02-14 04:52:57.000000000 +0100
@@ -118,9 +118,8 @@
 	sd	a6, PT_R10(sp)
 	sd	a7, PT_R11(sp)
 
-	sd	t2,PT_R1(sp)
+	move	s0, t2
 	jal	syscall_trace
-	ld	t2,PT_R1(sp)
 
 	ld	a0, PT_R4(sp)		# Restore argument registers
 	ld	a1, PT_R5(sp)
@@ -129,7 +128,7 @@
 	ld	a4, PT_R8(sp)
 	ld	a5, PT_R9(sp)
 
-	jalr	t2
+	jalr	s0
 
 	li	t0, -EMAXERRNO - 1	# error?
 	sltu	t0, t0, v0
@@ -576,6 +575,8 @@
 sys_call_table:
 	syscalltable
 
+	.purgem	sys
+
 	.macro	sys function, nargs
 	.byte	\nargs
 	.endm
diff -Nur linux-2.4.30/arch/mips64/kernel/setup.c linux-2.4.30-mips/arch/mips64/kernel/setup.c
--- linux-2.4.30/arch/mips64/kernel/setup.c	2005-01-19 15:09:32.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/kernel/setup.c	2004-11-22 14:38:26.000000000 +0100
@@ -129,14 +129,6 @@
 	 */
 	load_mmu();
 
-	/*
-	 * On IP27, I am seeing the TS bit set when the kernel is loaded.
-	 * Maybe because the kernel is in ckseg0 and not xkphys? Clear it
-	 * anyway ...
-	 */
-	clear_c0_status(ST0_BEV|ST0_TS|ST0_CU1|ST0_CU2|ST0_CU3);
-	set_c0_status(ST0_CU0|ST0_KX|ST0_SX|ST0_FR);
-
 	start_kernel();
 }
 
diff -Nur linux-2.4.30/arch/mips64/kernel/signal_n32.c linux-2.4.30-mips/arch/mips64/kernel/signal_n32.c
--- linux-2.4.30/arch/mips64/kernel/signal_n32.c	2005-01-19 15:09:33.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/kernel/signal_n32.c	2005-02-07 22:10:53.000000000 +0100
@@ -68,7 +68,7 @@
 };
 
 extern asmlinkage int restore_sigcontext(struct pt_regs *regs, struct sigcontext *sc);
-extern int inline setup_sigcontext(struct pt_regs *regs, struct sigcontext *sc);
+extern int setup_sigcontext(struct pt_regs *regs, struct sigcontext *sc);
 
 asmlinkage void sysn32_rt_sigreturn(abi64_no_regargs, struct pt_regs regs)
 {
diff -Nur linux-2.4.30/arch/mips64/kernel/traps.c linux-2.4.30-mips/arch/mips64/kernel/traps.c
--- linux-2.4.30/arch/mips64/kernel/traps.c	2005-01-19 15:09:33.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/kernel/traps.c	2005-04-12 22:25:34.000000000 +0200
@@ -462,9 +462,10 @@
 	}
 	ll_task = current;
 
+	compute_return_epc(regs);
+
 	regs->regs[(opcode & RT) >> 16] = value;
 
-	compute_return_epc(regs);
 	return;
 
 sig:
@@ -495,8 +496,8 @@
 		goto sig;
 	}
 	if (ll_bit == 0 || ll_task != current) {
-		regs->regs[reg] = 0;
 		compute_return_epc(regs);
+		regs->regs[reg] = 0;
 		return;
 	}
 
@@ -505,9 +506,9 @@
 		goto sig;
 	}
 
+	compute_return_epc(regs);
 	regs->regs[reg] = 1;
 
-	compute_return_epc(regs);
 	return;
 
 sig:
@@ -809,13 +810,18 @@
 void __init per_cpu_trap_init(void)
 {
 	unsigned int cpu = smp_processor_id();
+	unsigned int status_set = ST0_CU0|ST0_FR|ST0_KX|ST0_SX|ST0_UX;
 
-	/* Some firmware leaves the BEV flag set, clear it.  */
-	clear_c0_status(ST0_CU1|ST0_CU2|ST0_CU3|ST0_BEV);
-	set_c0_status(ST0_CU0|ST0_FR|ST0_KX|ST0_SX|ST0_UX);
-
+	/*
+	 * Disable coprocessors, enable 64-bit addressing and set FPU
+	 * for the 32/32 FPR register model.  Reset the BEV flag that
+	 * some firmware may have left set and the TS bit (for IP27).
+	 * Set XX for ISA IV code to work.
+	 */
 	if (current_cpu_data.isa_level == MIPS_CPU_ISA_IV)
-		set_c0_status(ST0_XX);
+		status_set |= ST0_XX;
+	change_c0_status(ST0_CU|ST0_FR|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
+			 status_set);
 
 	/*
 	 * Some MIPS CPUs have a dedicated interrupt vector which reduces the
@@ -825,13 +831,11 @@
 		set_c0_cause(CAUSEF_IV);
 
 	cpu_data[cpu].asid_cache = ASID_FIRST_VERSION;
-	write_c0_context(((long)(&pgd_current[cpu])) << 23);
-	write_c0_wired(0);
+	TLBMISS_HANDLER_SETUP();
 
 	atomic_inc(&init_mm.mm_count);
 	current->active_mm = &init_mm;
-	if (current->mm)
-		BUG();
+	BUG_ON(current->mm);
 	enter_lazy_tlb(&init_mm, current, cpu);
 }
 
@@ -842,8 +846,6 @@
 	extern char except_vec4;
 	unsigned long i;
 
-	per_cpu_trap_init();
-
 	/* Copy the generic exception handlers to their final destination. */
 	memcpy((void *) KSEG0         , &except_vec0_generic, 0x80);
 	memcpy((void *)(KSEG0 + 0x180), &except_vec3_generic, 0x80);
@@ -933,6 +935,5 @@
 
 	flush_icache_range(KSEG0, KSEG0 + 0x400);
 
-	atomic_inc(&init_mm.mm_count);	/* XXX UP?  */
-	current->active_mm = &init_mm;
+	per_cpu_trap_init();
 }
diff -Nur linux-2.4.30/arch/mips64/mm/c-r4k.c linux-2.4.30-mips/arch/mips64/mm/c-r4k.c
--- linux-2.4.30/arch/mips64/mm/c-r4k.c	2005-01-19 15:09:33.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/mm/c-r4k.c	2005-02-06 22:55:42.000000000 +0100
@@ -867,9 +867,16 @@
 	 * normally they'd suffer from aliases but magic in the hardware deals
 	 * with that for us so we don't need to take care ourselves.
 	 */
-	if (c->cputype != CPU_R10000 && c->cputype != CPU_R12000)
-		if (c->dcache.waysize > PAGE_SIZE)
-		        c->dcache.flags |= MIPS_CACHE_ALIASES;
+	switch (c->cputype) {
+	case CPU_R10000:
+	case CPU_R12000:
+		break;
+	case CPU_24K:
+		if (!(read_c0_config7() & (1 << 16)))
+	default:
+			if (c->dcache.waysize > PAGE_SIZE)
+				c->dcache.flags |= MIPS_CACHE_ALIASES;
+	}
 
 	switch (c->cputype) {
 	case CPU_20KC:
@@ -1070,9 +1077,6 @@
 	setup_scache();
 	coherency_setup();
 
-	if (c->dcache.sets * c->dcache.ways > PAGE_SIZE)
-		c->dcache.flags |= MIPS_CACHE_ALIASES;
-
 	r4k_blast_dcache_page_setup();
 	r4k_blast_dcache_page_indexed_setup();
 	r4k_blast_dcache_setup();
diff -Nur linux-2.4.30/arch/mips64/mm/cerr-sb1.c linux-2.4.30-mips/arch/mips64/mm/cerr-sb1.c
--- linux-2.4.30/arch/mips64/mm/cerr-sb1.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/mm/cerr-sb1.c	2004-12-13 18:37:26.000000000 +0100
@@ -252,14 +252,14 @@
 
 /* Masks to select bits for Hamming parity, mask_72_64[i] for bit[i] */
 static const uint64_t mask_72_64[8] = {
-	0x0738C808099264FFL,
-	0x38C808099264FF07L,
-	0xC808099264FF0738L,
-	0x08099264FF0738C8L,
-	0x099264FF0738C808L,
-	0x9264FF0738C80809L,
-	0x64FF0738C8080992L,
-	0xFF0738C808099264L
+	0x0738C808099264FFULL,
+	0x38C808099264FF07ULL,
+	0xC808099264FF0738ULL,
+	0x08099264FF0738C8ULL,
+	0x099264FF0738C808ULL,
+	0x9264FF0738C80809ULL,
+	0x64FF0738C8080992ULL,
+	0xFF0738C808099264ULL
 };
 
 /* Calculate the parity on a range of bits */
@@ -331,9 +331,9 @@
 				    ((lru >> 4) & 0x3),
 				    ((lru >> 6) & 0x3));
 		}
-		va = (taglo & 0xC0000FFFFFFFE000) | addr;
+		va = (taglo & 0xC0000FFFFFFFE000ULL) | addr;
 		if ((taglo & (1 << 31)) && (((taglo >> 62) & 0x3) == 3))
-			va |= 0x3FFFF00000000000;
+			va |= 0x3FFFF00000000000ULL;
 		valid = ((taghi >> 29) & 1);
 		if (valid) {
 			tlo_tmp = taglo & 0xfff3ff;
@@ -474,7 +474,7 @@
 		: "r" ((way << 13) | addr));
 
 		taglo = ((unsigned long long)taglohi << 32) | taglolo;
-		pa = (taglo & 0xFFFFFFE000) | addr;
+		pa = (taglo & 0xFFFFFFE000ULL) | addr;
 		if (way == 0) {
 			lru = (taghi >> 14) & 0xff;
 			prom_printf("[Bank %d Set 0x%02x]  LRU > %d %d %d %d > MRU\n",
diff -Nur linux-2.4.30/arch/mips64/mm/tlb-r4k.c linux-2.4.30-mips/arch/mips64/mm/tlb-r4k.c
--- linux-2.4.30/arch/mips64/mm/tlb-r4k.c	2005-01-19 15:09:33.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/mm/tlb-r4k.c	2004-11-25 23:18:38.000000000 +0100
@@ -1,24 +1,12 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2002 MIPS Technologies, Inc.  All rights reserved.
- *
- * This program is free software; you can distribute it and/or modify it
- * under the terms of the GNU General Public License (Version 2) as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
- *
- * MIPS64 CPU variant specific MMU routines.
- * These routine are not optimized in any way, they are done in a generic way
- * so they can be used on all MIPS64 compliant CPUs, and also done in an
- * attempt not to break anything for the R4xx0 style CPUs.
+ * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ * Copyright (C) 1997, 1998, 1999, 2000 Ralf Baechle ralf@gnu.org
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2002 MIPS Technologies, Inc.  All rights reserved.
  */
 #include <linux/init.h>
 #include <linux/sched.h>
@@ -30,9 +18,6 @@
 #include <asm/pgtable.h>
 #include <asm/system.h>
 
-#undef DEBUG_TLB
-#undef DEBUG_TLBUPDATE
-
 extern void except_vec1_r4k(void);
 
 /* CP0 hazard avoidance. */
@@ -46,31 +31,23 @@
 	unsigned long old_ctx;
 	int entry;
 
-#ifdef DEBUG_TLB
-	printk("[tlball]");
-#endif
-
 	local_irq_save(flags);
 	/* Save old context and create impossible VPN2 value */
 	old_ctx = read_c0_entryhi();
-	write_c0_entryhi(XKPHYS);
 	write_c0_entrylo0(0);
 	write_c0_entrylo1(0);
-	BARRIER;
 
 	entry = read_c0_wired();
 
 	/* Blast 'em all away. */
-	while(entry < current_cpu_data.tlbsize) {
-	        /* Make sure all entries differ. */
-	        write_c0_entryhi(XKPHYS+entry*0x2000);
+	while (entry < current_cpu_data.tlbsize) {
+	        write_c0_entryhi(XKPHYS + entry*0x2000);
 		write_c0_index(entry);
-		BARRIER;
+		mtc0_tlbw_hazard();
 		tlb_write_indexed();
-		BARRIER;
 		entry++;
 	}
-	BARRIER;
+	tlbw_use_hazard();
 	write_c0_entryhi(old_ctx);
 	local_irq_restore(flags);
 }
@@ -79,12 +56,8 @@
 {
 	int cpu = smp_processor_id();
 
-	if (cpu_context(cpu, mm) != 0) {
-#ifdef DEBUG_TLB
-		printk("[tlbmm<%d>]", mm->context);
-#endif
+	if (cpu_context(cpu, mm) != 0)
 		drop_mmu_context(mm,cpu);
-	}
 }
 
 void local_flush_tlb_range(struct mm_struct *mm, unsigned long start,
@@ -96,10 +69,6 @@
 		unsigned long flags;
 		int size;
 
-#ifdef DEBUG_TLB
-		printk("[tlbrange<%02x,%08lx,%08lx>]", (mm->context & ASID_MASK),
-		       start, end);
-#endif
 		local_irq_save(flags);
 		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 		size = (size + 1) >> 1;
@@ -110,25 +79,25 @@
 			start &= (PAGE_MASK << 1);
 			end += ((PAGE_SIZE << 1) - 1);
 			end &= (PAGE_MASK << 1);
-			while(start < end) {
+			while (start < end) {
 				int idx;
 
 				write_c0_entryhi(start | newpid);
 				start += (PAGE_SIZE << 1);
-				BARRIER;
+				mtc0_tlbw_hazard();
 				tlb_probe();
 				BARRIER;
 				idx = read_c0_index();
 				write_c0_entrylo0(0);
 				write_c0_entrylo1(0);
-				if(idx < 0)
+				if (idx < 0)
 					continue;
 				/* Make sure all entries differ. */
 				write_c0_entryhi(XKPHYS+idx*0x2000);
-				BARRIER;
+				mtc0_tlbw_hazard();
 				tlb_write_indexed();
-				BARRIER;
 			}
+			tlbw_use_hazard();
 			write_c0_entryhi(oldpid);
 		} else {
 			drop_mmu_context(mm, cpu);
@@ -145,28 +114,26 @@
 		unsigned long flags;
 		unsigned long oldpid, newpid, idx;
 
-#ifdef DEBUG_TLB
-		printk("[tlbpage<%d,%08lx>]", vma->vm_mm->context, page);
-#endif
 		newpid = cpu_asid(cpu, vma->vm_mm);
 		page &= (PAGE_MASK << 1);
 		local_irq_save(flags);
 		oldpid = read_c0_entryhi();
 		write_c0_entryhi(page | newpid);
-		BARRIER;
+		mtc0_tlbw_hazard();
 		tlb_probe();
 		BARRIER;
 		idx = read_c0_index();
 		write_c0_entrylo0(0);
 		write_c0_entrylo1(0);
-		if(idx < 0)
+		if (idx < 0)
 			goto finish;
 		/* Make sure all entries differ. */
 		write_c0_entryhi(XKPHYS+idx*0x2000);
-		BARRIER;
+		mtc0_tlbw_hazard();
 		tlb_write_indexed();
+		tlbw_use_hazard();
+
 	finish:
-		BARRIER;
 		write_c0_entryhi(oldpid);
 		local_irq_restore(flags);
 	}
@@ -186,7 +153,7 @@
 
 	local_irq_save(flags);
 	write_c0_entryhi(page);
-	BARRIER;
+	mtc0_tlbw_hazard();
 	tlb_probe();
 	BARRIER;
 	idx = read_c0_index();
@@ -195,10 +162,12 @@
 	if (idx >= 0) {
 		/* Make sure all entries differ. */
 		write_c0_entryhi(KSEG0+idx*0x2000);
+		mtc0_tlbw_hazard();
 		tlb_write_indexed();
+		tlbw_use_hazard();
 	}
-	BARRIER;
 	write_c0_entryhi(oldpid);
+
 	local_irq_restore(flags);
 }
 
@@ -208,7 +177,6 @@
 void __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)
 {
 	unsigned long flags;
-	unsigned int asid;
 	pgd_t *pgdp;
 	pmd_t *pmdp;
 	pte_t *ptep;
@@ -222,70 +190,58 @@
 
 	pid = read_c0_entryhi() & ASID_MASK;
 
-#ifdef DEBUG_TLB
-	if ((pid != (cpu_asid(smp_processor_id(), vma->vm_mm))) ||
-	   (cpu_context(smp_processor_id(), vma->vm_mm) == 0)) {
-		printk("update_mmu_cache: Wheee, bogus tlbpid mmpid=%d"
-		       "tlbpid=%d\n", (int) (cpu_context(smp_processor_id(),
-		       vma->vm_mm) & ASID_MASK), pid);
-	}
-#endif
-
 	local_irq_save(flags);
 	address &= (PAGE_MASK << 1);
-	write_c0_entryhi(address | (pid));
+	write_c0_entryhi(address | pid);
 	pgdp = pgd_offset(vma->vm_mm, address);
-	BARRIER;
+	mtc0_tlbw_hazard();
 	tlb_probe();
 	BARRIER;
 	pmdp = pmd_offset(pgdp, address);
 	idx = read_c0_index();
 	ptep = pte_offset(pmdp, address);
-	BARRIER;
 	write_c0_entrylo0(pte_val(*ptep++) >> 6);
 	write_c0_entrylo1(pte_val(*ptep) >> 6);
-	write_c0_entryhi(address | (pid));
-	BARRIER;
-	if(idx < 0) {
+	write_c0_entryhi(address | pid);
+	mtc0_tlbw_hazard();
+	if (idx < 0)
 		tlb_write_random();
-	} else {
+	else
 		tlb_write_indexed();
-	}
-	BARRIER;
+	tlbw_use_hazard();
 	write_c0_entryhi(pid);
-	BARRIER;
 	local_irq_restore(flags);
 }
 
-void add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
-				      unsigned long entryhi, unsigned long pagemask)
+void __init add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
+			    unsigned long entryhi, unsigned long pagemask)
 {
-        unsigned long flags;
-        unsigned long wired;
-        unsigned long old_pagemask;
-        unsigned long old_ctx;
-
-        local_irq_save(flags);
-        /* Save old context and create impossible VPN2 value */
-        old_ctx = (read_c0_entryhi() & ASID_MASK);
-        old_pagemask = read_c0_pagemask();
-        wired = read_c0_wired();
-        write_c0_wired(wired + 1);
-        write_c0_index(wired);
-        BARRIER;
-        write_c0_pagemask(pagemask);
-        write_c0_entryhi(entryhi);
-        write_c0_entrylo0(entrylo0);
-        write_c0_entrylo1(entrylo1);
-        BARRIER;
-        tlb_write_indexed();
-        BARRIER;
-
-        write_c0_entryhi(old_ctx);
-        BARRIER;
-        write_c0_pagemask(old_pagemask);
-        local_flush_tlb_all();
-        local_irq_restore(flags);
+	unsigned long flags;
+	unsigned long wired;
+	unsigned long old_pagemask;
+	unsigned long old_ctx;
+
+	local_irq_save(flags);
+	/* Save old context and create impossible VPN2 value */
+	old_ctx = read_c0_entryhi() & ASID_MASK;
+	old_pagemask = read_c0_pagemask();
+	wired = read_c0_wired();
+	write_c0_wired(wired + 1);
+	write_c0_index(wired);
+	BARRIER;
+	write_c0_pagemask(pagemask);
+	write_c0_entryhi(entryhi);
+	write_c0_entrylo0(entrylo0);
+	write_c0_entrylo1(entrylo1);
+	mtc0_tlbw_hazard();
+	tlb_write_indexed();
+	tlbw_use_hazard();
+
+	write_c0_entryhi(old_ctx);
+	BARRIER;
+	write_c0_pagemask(old_pagemask);
+	local_flush_tlb_all();
+	local_irq_restore(flags);
 }
 
 /*
@@ -317,17 +273,15 @@
 	}
 
 	write_c0_index(temp_tlb_entry);
-	BARRIER;
 	write_c0_pagemask(pagemask);
 	write_c0_entryhi(entryhi);
 	write_c0_entrylo0(entrylo0);
 	write_c0_entrylo1(entrylo1);
-	BARRIER;
+	mtc0_tlbw_hazard();
 	tlb_write_indexed();
-	BARRIER;
+	tlbw_use_hazard();
 
 	write_c0_entryhi(old_ctx);
-	BARRIER;
 	write_c0_pagemask(old_pagemask);
 out:
 	local_irq_restore(flags);
@@ -348,15 +302,23 @@
 		return;
 
 	config1 = read_c0_config1();
-	if (!((config1 >> 7) & 3))
-		panic("No MMU present");
+	if (!((config >> 7) & 3))
+		panic("No TLB present");
 
 	c->tlbsize = ((config1 >> 25) & 0x3f) + 1;
 }
 
 void __init r4k_tlb_init(void)
 {
-	unsigned long config = read_c0_config();
+	unsigned int config = read_c0_config();
+
+	/*
+	 * You should never change this register:
+	 *   - On R4600 1.7 the tlbp never hits for pages smaller than
+	 *     the value in the c0_pagemask register.
+	 *   - The entire mm handling assumes the c0_pagemask register to
+	 *     be set for 4kb pages.
+	 */
 	probe_tlb(config);
 	write_c0_pagemask(PM_DEFAULT_MASK);
 	write_c0_wired(0);
diff -Nur linux-2.4.30/arch/mips64/mm/tlbex-r4k.S linux-2.4.30-mips/arch/mips64/mm/tlbex-r4k.S
--- linux-2.4.30/arch/mips64/mm/tlbex-r4k.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4.30-mips/arch/mips64/mm/tlbex-r4k.S	2004-11-25 23:18:38.000000000 +0100
@@ -151,11 +151,9 @@
 	ld	k0, 0(k1)			# get even pte
 	ld	k1, 8(k1)			# get odd pte
 	PTE_RELOAD k0 k1
-	rm9000_tlb_hazard
-	b	1f
-	 tlbwr
-1:	nop
-	rm9000_tlb_hazard
+	mtc0_tlbw_hazard
+	tlbwr
+1:	tlbw_eret_hazard
 	eret
 
 9:						# handle the vmalloc range
@@ -163,11 +161,9 @@
 	ld	k0, 0(k1)			# get even pte
 	ld	k1, 8(k1)			# get odd pte
 	PTE_RELOAD k0 k1
-	rm9000_tlb_hazard
-	b	1f
-	 tlbwr
-1:	nop
-	rm9000_tlb_hazard
+	mtc0_tlbw_hazard
+	tlbwr
+1:	tlbw_eret_hazard
 	eret
 END(handle_vec1_r4k)
 
@@ -195,10 +191,9 @@
 	ld	k0, 0(k1)			# get even pte
 	ld	k1, 8(k1)			# get odd pte
 	PTE_RELOAD k0 k1
-	rm9000_tlb_hazard
-	nop
+	mtc0_tlbw_hazard
 	tlbwr
-	rm9000_tlb_hazard
+	tlbw_eret_hazard
 	eret
 
 9:						# handle the vmalloc range
@@ -206,10 +201,9 @@
 	ld	k0, 0(k1)			# get even pte
 	ld	k1, 8(k1)			# get odd pte
 	PTE_RELOAD k0 k1
-	rm9000_tlb_hazard
-	nop
+	mtc0_tlbw_hazard
 	tlbwr
-	rm9000_tlb_hazard
+	tlbw_eret_hazard
 	eret
 END(handle_vec1_r10k)
 
diff -Nur linux-2.4.30/drivers/char/Config.in linux-2.4.30-mips/drivers/char/Config.in
--- linux-2.4.30/drivers/char/Config.in	2004-08-08 01:26:04.000000000 +0200
+++ linux-2.4.30-mips/drivers/char/Config.in	2005-02-11 22:09:56.000000000 +0100
@@ -313,14 +313,11 @@
 if [ "$CONFIG_OBSOLETE" = "y" -a "$CONFIG_ALPHA_BOOK1" = "y" ]; then
    bool 'Tadpole ANA H8 Support (OBSOLETE)'  CONFIG_H8
 fi
-if [ "$CONFIG_MIPS" = "y" -a "$CONFIG_NEW_TIME_C" = "y" ]; then
-   tristate 'Generic MIPS RTC Support' CONFIG_MIPS_RTC
-fi
 if [ "$CONFIG_SGI_IP22" = "y" ]; then
-   bool 'SGI DS1286 RTC support' CONFIG_SGI_DS1286
+   tristate 'Dallas DS1286 RTC support' CONFIG_DS1286
 fi
 if [ "$CONFIG_SGI_IP27" = "y" ]; then
-   bool 'SGI M48T35 RTC support' CONFIG_SGI_IP27_RTC
+   tristate 'SGI M48T35 RTC support' CONFIG_SGI_IP27_RTC
 fi
 if [ "$CONFIG_TOSHIBA_RBTX4927" = "y" -o "$CONFIG_TOSHIBA_JMR3927" = "y" ]; then
    tristate 'Dallas DS1742 RTC support' CONFIG_DS1742
@@ -383,6 +380,11 @@
       source drivers/char/drm/Config.in
    fi
 fi
+
+if [ "$CONFIG_X86" = "y" ]; then
+   tristate 'ACP Modem (Mwave) support' CONFIG_MWAVE
+fi
+
 endmenu
 
 if [ "$CONFIG_HOTPLUG" = "y" -a "$CONFIG_PCMCIA" != "n" ]; then
@@ -391,6 +393,7 @@
 if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
    tristate ' Alchemy Au1x00 GPIO device support' CONFIG_AU1X00_GPIO
    tristate ' Au1000/ADS7846 touchscreen support' CONFIG_TS_AU1X00_ADS7846
+   #tristate ' Alchemy Au1550 PSC SPI support' CONFIG_AU1550_PSC_SPI
 fi
 if [ "$CONFIG_MIPS_ITE8172" = "y" ]; then
   tristate ' ITE GPIO' CONFIG_ITE_GPIO
diff -Nur linux-2.4.30/drivers/char/Makefile linux-2.4.30-mips/drivers/char/Makefile
--- linux-2.4.30/drivers/char/Makefile	2004-08-08 01:26:04.000000000 +0200
+++ linux-2.4.30-mips/drivers/char/Makefile	2005-02-11 22:09:56.000000000 +0100
@@ -48,7 +48,12 @@
     KEYBD    =
   endif
   ifeq ($(CONFIG_VR41XX_KIU),y)
-    KEYMAP   =
+    ifeq ($(CONFIG_IBM_WORKPAD),y)
+      KEYMAP = ibm_workpad_keymap.o
+    endif
+    ifeq ($(CONFIG_VICTOR_MPC30X),y)
+      KEYMAP = victor_mpc30x_keymap.o
+    endif
     KEYBD    = vr41xx_keyb.o
   endif
 endif
@@ -251,7 +256,6 @@
 obj-$(CONFIG_RTC) += rtc.o
 obj-$(CONFIG_GEN_RTC) += genrtc.o
 obj-$(CONFIG_EFI_RTC) += efirtc.o
-obj-$(CONFIG_SGI_DS1286) += ds1286.o
 obj-$(CONFIG_MIPS_RTC) += mips_rtc.o
 obj-$(CONFIG_SGI_IP27_RTC) += ip27-rtc.o
 ifeq ($(CONFIG_PPC),)
@@ -259,6 +263,7 @@
 endif
 obj-$(CONFIG_TOSHIBA) += toshiba.o
 obj-$(CONFIG_I8K) += i8k.o
+obj-$(CONFIG_DS1286) += ds1286.o
 obj-$(CONFIG_DS1620) += ds1620.o
 obj-$(CONFIG_DS1742) += ds1742.o
 obj-$(CONFIG_INTEL_RNG) += i810_rng.o
@@ -269,6 +274,7 @@
 
 obj-$(CONFIG_ITE_GPIO) += ite_gpio.o
 obj-$(CONFIG_AU1X00_GPIO) += au1000_gpio.o
+obj-$(CONFIG_AU1550_PSC_SPI) += au1550_psc_spi.o
 obj-$(CONFIG_AU1X00_USB_TTY) += au1000_usbtty.o
 obj-$(CONFIG_AU1X00_USB_RAW) += au1000_usbraw.o
 obj-$(CONFIG_COBALT_LCD) += lcd.o
@@ -353,3 +359,9 @@
 
 qtronixmap.c: qtronixmap.map
 	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
+
+ibm_workpad_keymap.c: ibm_workpad_keymap.map
+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
+
+victor_mpc30x_keymap.c: victor_mpc30x_keymap.map
+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
diff -Nur linux-2.4.30/drivers/char/au1000_gpio.c linux-2.4.30-mips/drivers/char/au1000_gpio.c
--- linux-2.4.30/drivers/char/au1000_gpio.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-2.4.30-mips/drivers/char/au1000_gpio.c	2003-12-20 14:18:51.000000000 +0100
@@ -246,7 +246,7 @@
 
 static struct miscdevice au1000gpio_miscdev =
 {
-	GPIO_MINOR,
+	MISC_DYNAMIC_MINOR,
 	"au1000_gpio",
 	&au1000gpio_fops
 };
diff -Nur linux-2.4.30/drivers/char/au1550_psc_spi.c linux-2.4.30-mips/drivers/char/au1550_psc_spi.c
--- linux-2.4.30/drivers/char/au1550_psc_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/char/au1550_psc_spi.c	2005-02-11 21:37:24.000000000 +0100
@@ -0,0 +1,466 @@
+/*
+ *  Driver for Alchemy Au1550 SPI on the PSC.
+ *
+ * Copyright 2004 Embedded Edge, LLC.
+ *	dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/au1000.h>
+#include <asm/au1550_spi.h>
+#include <asm/au1xxx_psc.h>
+
+#ifdef CONFIG_MIPS_PB1550
+#include <asm/pb1550.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1550
+#include <asm/db1x00.h>
+#endif
+
+#ifdef CONFIG_MIPS_PB1200
+#include <asm/pb1200.h>
+#endif
+
+/* This is just a simple programmed I/O SPI interface on the PSC of the 1550.
+ * We support open, close, write, and ioctl.  The SPI is a full duplex
+ * interface, you can't read without writing.  So, the write system call
+ * copies the bytes out to the SPI, and whatever is returned is placed
+ * in the same buffer.  Kinda weird, maybe we'll change it, but for now
+ * it works OK.
+ * I didn't implement any DMA yet, and it's a debate about the necessity.
+ * The SPI clocks are usually quite fast, so data is sent/received as
+ * quickly as you can stuff the FIFO.  The overhead of DMA and interrupts
+ * are usually far greater than the data transfer itself.  If, however,
+ * we find applications that move large amounts of data, we may choose
+ * use the overhead of buffering and DMA to do the work.
+ */
+
+/* The maximum clock rate specified in the manual is 2mHz.
+*/
+#define MAX_BAUD_RATE	(2 * 1000000)
+#define PSC_INTCLK_RATE (32 * 1000000)
+
+static	int	inuse;
+
+/* We have to know what the user requested for the data length
+ * so we know how to stuff the fifo.  The FIFO is 32 bits wide,
+ * and we have to load it with the bits to go in a single transfer.
+ */
+static	uint	spi_datalen;
+
+static int
+au1550spi_master_done( int ms )
+{
+	int timeout=ms;
+	volatile psc_spi_t *sp;
+
+	sp = (volatile psc_spi_t *)SPI_PSC_BASE;
+
+	/* Loop until MD is set or timeout has expired */
+	while(!(sp->psc_spievent & PSC_SPIEVNT_MD) &&  timeout--) udelay(1000);
+
+	if ( !timeout )
+		return 0;
+	else
+		sp->psc_spievent |= PSC_SPIEVNT_MD;
+
+	return 1;
+}
+
+static int
+au1550spi_open(struct inode *inode, struct file *file)
+{
+	if (inuse)
+		return -EBUSY;
+
+	inuse = 1;
+
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+static ssize_t
+au1550spi_write(struct file *fp, const char *bp, size_t count, loff_t *ppos)
+{
+	int	bytelen, i;
+	size_t	rcount, retval;
+	unsigned char	sb, *rp, *wp;
+	uint	fifoword, pcr, stat;
+	volatile psc_spi_t *sp;
+
+	/* Get the number of bytes per transfer.
+	*/
+	bytelen = ((spi_datalen - 1) / 8) + 1;
+
+	/* User needs to send us multiple of this count.
+	*/
+	if ((count % bytelen) != 0)
+		return -EINVAL;
+
+	rp = wp = (unsigned char *)bp;
+	retval = rcount = count;
+
+	/* Reset the FIFO.
+	*/
+	sp = (volatile psc_spi_t *)SPI_PSC_BASE;
+	sp->psc_spipcr = (PSC_SPIPCR_RC | PSC_SPIPCR_TC);
+	au_sync();
+	do {
+		pcr = sp->psc_spipcr;
+		au_sync();
+	} while (pcr != 0);
+
+	/* Prime the transmit FIFO.
+	*/
+	while (count > 0) {
+		fifoword = 0;
+		for (i=0; i<bytelen; i++) {
+			fifoword <<= 8;
+			if (get_user(sb, wp) < 0)
+				return -EFAULT;
+			fifoword |= sb;
+			wp++;
+		}
+		count -= bytelen;
+		if (count <= 0)
+			fifoword |= PSC_SPITXRX_LC;
+		sp->psc_spitxrx = fifoword;
+		au_sync();
+		stat = sp->psc_spistat;
+		au_sync();
+		if (stat & PSC_SPISTAT_TF)
+			break;
+	}
+
+	/* Start the transfer.
+	*/
+	sp->psc_spipcr = PSC_SPIPCR_MS;
+	au_sync();
+
+	/* Now, just keep the transmit fifo full and empty the receive.
+	*/
+	while (count > 0) {
+		stat = sp->psc_spistat;
+		au_sync();
+		while ((stat & PSC_SPISTAT_RE) == 0) {
+			fifoword = sp->psc_spitxrx;
+			au_sync();
+			for (i=0; i<bytelen; i++) {
+				sb = fifoword & 0xff;
+				if (put_user(sb, rp) < 0)
+					return -EFAULT;
+				fifoword >>= 8;
+				rp++;
+			}
+			rcount -= bytelen;
+			stat = sp->psc_spistat;
+			au_sync();
+		}
+		if ((stat & PSC_SPISTAT_TF) == 0) {
+			fifoword = 0;
+			for (i=0; i<bytelen; i++) {
+				fifoword <<= 8;
+				if (get_user(sb, wp) < 0)
+					return -EFAULT;
+				fifoword |= sb;
+				wp++;
+			}
+			count -= bytelen;
+			if (count <= 0)
+				fifoword |= PSC_SPITXRX_LC;
+			sp->psc_spitxrx = fifoword;
+			au_sync();
+		}
+	}
+
+	/* All of the bytes for transmit have been written.  Hang
+	 * out waiting for any residual bytes that are yet to be
+	 * read from the fifo.
+	 */
+	while (rcount > 0) {
+		stat = sp->psc_spistat;
+		au_sync();
+		if ((stat & PSC_SPISTAT_RE) == 0) {
+			fifoword = sp->psc_spitxrx;
+			au_sync();
+			for (i=0; i<bytelen; i++) {
+				sb = fifoword & 0xff;
+				if (put_user(sb, rp) < 0)
+					return -EFAULT;
+				fifoword >>= 8;
+				rp++;
+			}
+			rcount -= bytelen;
+		}
+	}
+
+	/* Wait for MasterDone event. 30ms timeout */
+	if (!au1550spi_master_done(30) ) retval = -EFAULT;
+	return retval;
+}
+
+static int
+au1550spi_release(struct inode *inode, struct file *file)
+{
+	MOD_DEC_USE_COUNT;
+
+	inuse = 0;
+
+	return 0;
+}
+
+/* Set the baud rate closest to the request, then return the actual
+ * value we are using.
+ */
+static uint
+set_baud_rate(uint baud)
+{
+	uint	rate, tmpclk, brg, ctl, stat;
+	volatile psc_spi_t *sp;
+
+	/* For starters, the input clock is divided by two.
+	*/
+	tmpclk = PSC_INTCLK_RATE/2;
+
+	rate = tmpclk / baud;
+
+	/* The dividers work as follows:
+	 *	baud = tmpclk / (2 * (brg + 1))
+	 */
+	 brg = (rate/2) - 1;
+
+	 /* Test BRG to ensure it will fit into the 6 bits allocated.
+	 */
+
+	 /* Make sure the device is disabled while we make the change.
+	 */
+	sp = (volatile psc_spi_t *)SPI_PSC_BASE;
+	ctl = sp->psc_spicfg;
+	au_sync();
+	sp->psc_spicfg = ctl & ~PSC_SPICFG_DE_ENABLE;
+	au_sync();
+	ctl = PSC_SPICFG_CLR_BAUD(ctl);
+	ctl |= PSC_SPICFG_SET_BAUD(brg);
+	sp->psc_spicfg = ctl;
+	au_sync();
+
+	/* If the device was running prior to getting here, wait for
+	 * it to restart.
+	 */
+	if (ctl & PSC_SPICFG_DE_ENABLE) {
+		do {
+			stat = sp->psc_spistat;
+			au_sync();
+		} while ((stat & PSC_SPISTAT_DR) == 0);
+	}
+
+	/* Return the actual value.
+	*/
+	rate = tmpclk / (2 * (brg + 1));
+
+	return(rate);
+}
+
+static uint
+set_word_len(uint len)
+{
+	uint	ctl, stat;
+	volatile psc_spi_t *sp;
+
+	if ((len < 4) || (len > 24))
+		return -EINVAL;
+
+	 /* Make sure the device is disabled while we make the change.
+	 */
+	sp = (volatile psc_spi_t *)SPI_PSC_BASE;
+	ctl = sp->psc_spicfg;
+	au_sync();
+	sp->psc_spicfg = ctl & ~PSC_SPICFG_DE_ENABLE;
+	au_sync();
+	ctl = PSC_SPICFG_CLR_LEN(ctl);
+	ctl |= PSC_SPICFG_SET_LEN(len);
+	sp->psc_spicfg = ctl;
+	au_sync();
+
+	/* If the device was running prior to getting here, wait for
+	 * it to restart.
+	 */
+	if (ctl & PSC_SPICFG_DE_ENABLE) {
+		do {
+			stat = sp->psc_spistat;
+			au_sync();
+		} while ((stat & PSC_SPISTAT_DR) == 0);
+	}
+
+	return 0;
+}
+
+static int
+au1550spi_ioctl(struct inode *inode, struct file *file,
+			    unsigned int cmd, unsigned long arg)
+{
+	int status;
+	u32 val;
+
+	status = 0;
+
+	switch(cmd) {
+	case AU1550SPI_WORD_LEN:
+		status = set_word_len(arg);
+		break;
+
+	case AU1550SPI_SET_BAUD:
+		if (get_user(val, (u32 *)arg)) 
+			return -EFAULT;
+
+		val = set_baud_rate(val);
+		if (put_user(val, (u32 *)arg)) 
+			return -EFAULT;
+		break;
+
+	default:
+		status = -ENOIOCTLCMD;
+
+	}
+
+	return status;
+}
+
+
+static struct file_operations au1550spi_fops =
+{
+	owner:		THIS_MODULE,
+	write:		au1550spi_write,
+	ioctl:		au1550spi_ioctl,
+	open:		au1550spi_open,
+	release:	au1550spi_release,
+};
+
+
+static struct miscdevice au1550spi_miscdev =
+{
+	MISC_DYNAMIC_MINOR,
+	"au1550_spi",
+	&au1550spi_fops
+};
+
+
+int __init
+au1550spi_init(void)
+{
+	uint	clk, rate, stat;
+	volatile psc_spi_t *sp;
+
+	/* Wire up Freq3 as a clock for the SPI.  The PSC does
+	 * factor of 2 divisor, so run a higher rate so we can
+	 * get some granularity to the clock speeds.
+	 * We can't do this in board set up because the frequency
+	 * is computed too late.
+	 */
+	rate = get_au1x00_speed();
+	rate /= PSC_INTCLK_RATE;
+
+	/* The FRDIV in the frequency control is (FRDIV + 1) * 2
+	*/
+	rate /=2;
+	rate--;
+	clk = au_readl(SYS_FREQCTRL1);
+	au_sync();
+	clk &= ~SYS_FC_FRDIV3_MASK;
+	clk |= (rate << SYS_FC_FRDIV3_BIT);
+	clk |= SYS_FC_FE3;
+	au_writel(clk, SYS_FREQCTRL1);
+	au_sync();
+
+	/* Set up the clock source routing to get Freq3 to PSC0_intclk.
+	*/
+	clk = au_readl(SYS_CLKSRC);
+	au_sync();
+	clk &= ~0x03e0;
+	clk |= (5 << 7);
+	au_writel(clk, SYS_CLKSRC);
+	au_sync();
+
+	/* Set up GPIO pin function to drive PSC0_SYNC1, which is
+	 * the SPI Select.
+	 */
+	clk = au_readl(SYS_PINFUNC);
+	au_sync();
+	clk |= 1;
+	au_writel(clk, SYS_PINFUNC);
+	au_sync();
+
+	/* Now, set up the PSC for SPI PIO mode.
+	*/
+	sp = (volatile psc_spi_t *)SPI_PSC_BASE;
+	sp->psc_ctrl = PSC_CTRL_DISABLE;
+	au_sync();
+	sp->psc_sel = PSC_SEL_PS_SPIMODE;
+	sp->psc_spicfg = 0;
+	au_sync();
+	sp->psc_ctrl = PSC_CTRL_ENABLE;
+	au_sync();
+	do {
+		stat = sp->psc_spistat;
+		au_sync();
+	} while ((stat & PSC_SPISTAT_SR) == 0);
+
+	sp->psc_spicfg = (PSC_SPICFG_RT_FIFO8 | PSC_SPICFG_TT_FIFO8 |
+				PSC_SPICFG_DD_DISABLE | PSC_SPICFG_MO);
+	sp->psc_spicfg |= PSC_SPICFG_SET_LEN(8);
+	spi_datalen = 8;
+	sp->psc_spimsk = PSC_SPIMSK_ALLMASK;
+	au_sync();
+
+	set_baud_rate(1000000);
+
+	sp->psc_spicfg |= PSC_SPICFG_DE_ENABLE;
+	do {
+		stat = sp->psc_spistat;
+		au_sync();
+	} while ((stat & PSC_SPISTAT_DR) == 0);
+
+	misc_register(&au1550spi_miscdev);
+	printk("Au1550 SPI driver\n");
+	return 0;
+}	
+
+
+void __exit
+au1550spi_exit(void)
+{
+	misc_deregister(&au1550spi_miscdev);
+}
+
+
+module_init(au1550spi_init);
+module_exit(au1550spi_exit);
diff -Nur linux-2.4.30/drivers/char/decserial.c linux-2.4.30-mips/drivers/char/decserial.c
--- linux-2.4.30/drivers/char/decserial.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-2.4.30-mips/drivers/char/decserial.c	2004-09-28 02:53:01.000000000 +0200
@@ -3,95 +3,105 @@
  *      choose the right serial device at boot time
  *
  * triemer 6-SEP-1998
- *      sercons.c is designed to allow the three different kinds 
+ *      sercons.c is designed to allow the three different kinds
  *      of serial devices under the decstation world to co-exist
- *      in the same kernel.  The idea here is to abstract 
+ *      in the same kernel.  The idea here is to abstract
  *      the pieces of the drivers that are common to this file
  *      so that they do not clash at compile time and runtime.
  *
  * HK 16-SEP-1998 v0.002
  *      removed the PROM console as this is not a real serial
  *      device. Added support for PROM console in drivers/char/tty_io.c
- *      instead. Although it may work to enable more than one 
+ *      instead. Although it may work to enable more than one
  *      console device I strongly recommend to use only one.
+ *
+ *	Copyright (C) 2004  Maciej W. Rozycki
  */
 
 #include <linux/config.h>
+#include <linux/errno.h>
 #include <linux/init.h>
+
 #include <asm/dec/machtype.h>
+#include <asm/dec/serial.h>
+
+extern int register_zs_hook(unsigned int channel,
+			    struct dec_serial_hook *hook);
+extern int unregister_zs_hook(unsigned int channel);
+
+extern int register_dz_hook(unsigned int channel,
+			    struct dec_serial_hook *hook);
+extern int unregister_dz_hook(unsigned int channel);
 
+int register_dec_serial_hook(unsigned int channel,
+			     struct dec_serial_hook *hook)
+{
 #ifdef CONFIG_ZS
-extern int zs_init(void);
+	if (IOASIC)
+		return register_zs_hook(channel, hook);
 #endif
-
 #ifdef CONFIG_DZ
-extern int dz_init(void);
+	if (!IOASIC)
+		return register_dz_hook(channel, hook);
 #endif
+	return 0;
+}
 
-#ifdef CONFIG_SERIAL_DEC_CONSOLE
-
+int unregister_dec_serial_hook(unsigned int channel)
+{
 #ifdef CONFIG_ZS
-extern void zs_serial_console_init(void);
+	if (IOASIC)
+		return unregister_zs_hook(channel);
 #endif
-
 #ifdef CONFIG_DZ
-extern void dz_serial_console_init(void);
-#endif
-
+	if (!IOASIC)
+		return unregister_dz_hook(channel);
 #endif
+	return 0;
+}
 
-/* rs_init - starts up the serial interface -
-   handle normal case of starting up the serial interface */
 
-#ifdef CONFIG_SERIAL_DEC
+extern int zs_init(void);
+extern int dz_init(void);
 
+/*
+ * rs_init - starts up the serial interface -
+ * handle normal case of starting up the serial interface
+ */
 int __init rs_init(void)
 {
-
-#if defined(CONFIG_ZS) && defined(CONFIG_DZ)
-    if (IOASIC)
-	return zs_init();
-    else
-	return dz_init();
-#else
-
 #ifdef CONFIG_ZS
-    return zs_init();
+	if (IOASIC)
+		return zs_init();
 #endif
-
 #ifdef CONFIG_DZ
-    return dz_init();
-#endif
-
+	if (!IOASIC)
+		return dz_init();
 #endif
+	return -ENXIO;
 }
 
 __initcall(rs_init);
 
-#endif
 
 #ifdef CONFIG_SERIAL_DEC_CONSOLE
 
-/* dec_serial_console_init handles the special case of starting
- *   up the console on the serial port
+extern void zs_serial_console_init(void);
+extern void dz_serial_console_init(void);
+
+/*
+ * dec_serial_console_init handles the special case of starting
+ * up the console on the serial port
  */
 void __init dec_serial_console_init(void)
 {
-#if defined(CONFIG_ZS) && defined(CONFIG_DZ)
-    if (IOASIC)
-	zs_serial_console_init();
-    else
-	dz_serial_console_init();
-#else
-
 #ifdef CONFIG_ZS
-    zs_serial_console_init();
+	if (IOASIC)
+		zs_serial_console_init();
 #endif
-
 #ifdef CONFIG_DZ
-    dz_serial_console_init();
-#endif
-
+	if (!IOASIC)
+		dz_serial_console_init();
 #endif
 }
 
diff -Nur linux-2.4.30/drivers/char/ds1286.c linux-2.4.30-mips/drivers/char/ds1286.c
--- linux-2.4.30/drivers/char/ds1286.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/char/ds1286.c	2004-01-10 06:21:39.000000000 +0100
@@ -1,6 +1,10 @@
 /*
  * DS1286 Real Time Clock interface for Linux
  *
+ * Copyright (C) 2003 TimeSys Corp.
+ *                    S. James Hill (James.Hill@timesys.com)
+ *                                  (sjhill@realitydiluted.com)
+ *
  * Copyright (C) 1998, 1999, 2000 Ralf Baechle
  *
  * Based on code written by Paul Gortmaker.
@@ -29,6 +33,7 @@
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/miscdevice.h>
+#include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
 #include <linux/fcntl.h>
@@ -95,6 +100,12 @@
 	return -EIO;
 }
 
+void rtc_ds1286_wait(void)
+{
+	unsigned char sec = CMOS_READ(RTC_SECONDS);
+	while (sec == CMOS_READ(RTC_SECONDS));
+}
+
 static int ds1286_ioctl(struct inode *inode, struct file *file,
                         unsigned int cmd, unsigned long arg)
 {
@@ -249,23 +260,22 @@
 {
 	spin_lock_irq(&ds1286_lock);
 
-	if (ds1286_status & RTC_IS_OPEN)
-		goto out_busy;
+	if (ds1286_status & RTC_IS_OPEN) {
+		spin_unlock_irq(&ds1286_lock);
+		return -EBUSY;
+	}
 
 	ds1286_status |= RTC_IS_OPEN;
 
-	spin_lock_irq(&ds1286_lock);
+	spin_unlock_irq(&ds1286_lock);
 	return 0;
-
-out_busy:
-	spin_lock_irq(&ds1286_lock);
-	return -EBUSY;
 }
 
 static int ds1286_release(struct inode *inode, struct file *file)
 {
+	spin_lock_irq(&ds1286_lock);
 	ds1286_status &= ~RTC_IS_OPEN;
-
+	spin_unlock_irq(&ds1286_lock);
 	return 0;
 }
 
@@ -276,32 +286,6 @@
 	return 0;
 }
 
-/*
- *	The various file operations we support.
- */
-
-static struct file_operations ds1286_fops = {
-	.llseek		= no_llseek,
-	.read		= ds1286_read,
-	.poll		= ds1286_poll,
-	.ioctl		= ds1286_ioctl,
-	.open		= ds1286_open,
-	.release	= ds1286_release,
-};
-
-static struct miscdevice ds1286_dev=
-{
-	.minor	= RTC_MINOR,
-	.name	= "rtc",
-	.fops	= &ds1286_fops,
-};
-
-int __init ds1286_init(void)
-{
-	printk(KERN_INFO "DS1286 Real Time Clock Driver v%s\n", DS1286_VERSION);
-	return misc_register(&ds1286_dev);
-}
-
 static char *days[] = {
 	"***", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
 };
@@ -528,3 +512,38 @@
 	BCD_TO_BIN(alm_tm->tm_hour);
 	alm_tm->tm_sec = 0;
 }
+
+static struct file_operations ds1286_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= ds1286_read,
+	.poll		= ds1286_poll,
+	.ioctl		= ds1286_ioctl,
+	.open		= ds1286_open,
+	.release	= ds1286_release,
+};
+
+static struct miscdevice ds1286_dev =
+{
+	.minor	= RTC_MINOR,
+	.name	= "rtc",
+	.fops	= &ds1286_fops,
+};
+
+static int __init ds1286_init(void)
+{
+	printk(KERN_INFO "DS1286 Real Time Clock Driver v%s\n", DS1286_VERSION);
+	return misc_register(&ds1286_dev);
+}
+
+static void __exit ds1286_exit(void)
+{
+	misc_deregister(&ds1286_dev);
+}
+
+module_init(ds1286_init);
+module_exit(ds1286_exit);
+EXPORT_NO_SYMBOLS;
+
+MODULE_AUTHOR("Ralf Baechle");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.4.30/drivers/char/ds1742.c linux-2.4.30-mips/drivers/char/ds1742.c
--- linux-2.4.30/drivers/char/ds1742.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/char/ds1742.c	2004-01-09 20:27:16.000000000 +0100
@@ -142,6 +142,7 @@
 	CMOS_WRITE(RTC_WRITE, RTC_CONTROL);
 
 	/* convert */
+	memset(&tm, 0, sizeof(struct rtc_time));
 	to_tm(t, &tm);
 
 	/* check each field one by one */
@@ -216,6 +217,7 @@
 	unsigned long curr_time;
 
 	curr_time = rtc_ds1742_get_time();
+	memset(&tm, 0, sizeof(struct rtc_time));
 	to_tm(curr_time, &tm);
 
 	p = buf;
@@ -251,8 +253,8 @@
 
 void rtc_ds1742_wait(void)
 {
-	while (CMOS_READ(RTC_SECONDS) & 1);
-	while (!(CMOS_READ(RTC_SECONDS) & 1));
+	unsigned char sec = CMOS_READ(RTC_SECONDS);
+	while (sec == CMOS_READ(RTC_SECONDS));
 }
 
 static int ds1742_ioctl(struct inode *inode, struct file *file,
@@ -264,6 +266,7 @@
 	switch (cmd) {
 	case RTC_RD_TIME:	/* Read the time/date from RTC  */
 		curr_time = rtc_ds1742_get_time();
+		memset(&rtc_tm, 0, sizeof(struct rtc_time));
 		to_tm(curr_time, &rtc_tm);
 		rtc_tm.tm_year -= 1900;
 		return copy_to_user((void *) arg, &rtc_tm, sizeof(rtc_tm)) ? 
diff -Nur linux-2.4.30/drivers/char/dummy_keyb.c linux-2.4.30-mips/drivers/char/dummy_keyb.c
--- linux-2.4.30/drivers/char/dummy_keyb.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-2.4.30-mips/drivers/char/dummy_keyb.c	2004-01-09 09:53:08.000000000 +0100
@@ -140,3 +140,7 @@
 {
 	printk("Dummy keyboard driver installed.\n");
 }
+#ifdef CONFIG_MAGIC_SYSRQ
+unsigned char kbd_sysrq_key;
+unsigned char kbd_sysrq_xlate[128];
+#endif
diff -Nur linux-2.4.30/drivers/char/dz.c linux-2.4.30-mips/drivers/char/dz.c
--- linux-2.4.30/drivers/char/dz.c	2005-01-19 15:09:44.000000000 +0100
+++ linux-2.4.30-mips/drivers/char/dz.c	2004-12-27 05:13:42.000000000 +0100
@@ -1,11 +1,13 @@
 /*
- * dz.c: Serial port driver for DECStations equiped 
+ * dz.c: Serial port driver for DECstations equipped 
  *       with the DZ chipset.
  *
  * Copyright (C) 1998 Olivier A. D. Lebaillif 
  *             
  * Email: olivier.lebaillif@ifrsys.com
  *
+ * Copyright (C) 2004  Maciej W. Rozycki
+ *
  * [31-AUG-98] triemer
  * Changed IRQ to use Harald's dec internals interrupts.h
  * removed base_addr code - moving address assignment to setup.c
@@ -24,6 +26,7 @@
 #undef DEBUG_DZ
 
 #include <linux/config.h>
+#include <linux/delay.h>
 #include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -54,33 +57,56 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 
-#define CONSOLE_LINE (3)	/* for definition of struct console */
+#ifdef CONFIG_MAGIC_SYSRQ
+#include <linux/sysrq.h>
+#endif
 
 #include "dz.h"
 
-#define DZ_INTR_DEBUG 1
-
 DECLARE_TASK_QUEUE(tq_serial);
 
-static struct dz_serial *lines[4];
-static unsigned char tmp_buffer[256];
+static struct dz_serial multi[DZ_NB_PORT];    /* Four serial lines in the DZ chip */
+static struct tty_driver serial_driver, callout_driver;
+
+static struct tty_struct *serial_table[DZ_NB_PORT];
+static struct termios *serial_termios[DZ_NB_PORT];
+static struct termios *serial_termios_locked[DZ_NB_PORT];
+
+static int serial_refcount;
 
-#ifdef DEBUG_DZ
 /*
- * debugging code to send out chars via prom 
+ * tmp_buf is used as a temporary buffer by serial_write.  We need to
+ * lock it in case the copy_from_user blocks while swapping in a page,
+ * and some other program tries to do a serial write at the same time.
+ * Since the lock will only come under contention when the system is
+ * swapping and available memory is low, it makes sense to share one
+ * buffer across all the serial ports, since it significantly saves
+ * memory if large numbers of serial ports are open.
  */
-static void debug_console(const char *s, int count)
-{
-	unsigned i;
+static unsigned char *tmp_buf;
+static DECLARE_MUTEX(tmp_buf_sem);
 
-	for (i = 0; i < count; i++) {
-		if (*s == 10)
-			prom_printf("%c", 13);
-		prom_printf("%c", *s++);
-	}
-}
+static char *dz_name __initdata = "DECstation DZ serial driver version ";
+static char *dz_version __initdata = "1.03";
+
+static struct dz_serial *lines[DZ_NB_PORT];
+static unsigned char tmp_buffer[256];
+
+#ifdef CONFIG_SERIAL_DEC_CONSOLE
+static struct console dz_sercons;
+#endif
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
+static unsigned long break_pressed; /* break, really ... */
 #endif
 
+static void change_speed (struct dz_serial *);
+
+static int baud_table[] = {
+        0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800,
+        9600, 0
+};
+
 /*
  * ------------------------------------------------------------
  * dz_in () and dz_out ()
@@ -94,15 +120,16 @@
 {
 	volatile unsigned short *addr =
 		(volatile unsigned short *) (info->port + offset);
+
 	return *addr;
 }
 
 static inline void dz_out(struct dz_serial *info, unsigned offset,
                           unsigned short value)
 {
-
 	volatile unsigned short *addr =
 		(volatile unsigned short *) (info->port + offset);
+
 	*addr = value;
 }
 
@@ -143,25 +170,24 @@
 
 	tmp |= mask;		/* set the TX flag */
 	dz_out(info, DZ_TCR, tmp);
-
 }
 
 /*
  * ------------------------------------------------------------
- * Here starts the interrupt handling routines.  All of the 
- * following subroutines are declared as inline and are folded 
- * into dz_interrupt.  They were separated out for readability's 
- * sake. 
  *
- * Note: rs_interrupt() is a "fast" interrupt, which means that it
+ * Here starts the interrupt handling routines.  All of the following
+ * subroutines are declared as inline and are folded into
+ * dz_interrupt().  They were separated out for readability's sake.
+ *
+ * Note: dz_interrupt() is a "fast" interrupt, which means that it
  * runs with interrupts turned off.  People who may want to modify
- * rs_interrupt() should try to keep the interrupt handler as fast as
+ * dz_interrupt() should try to keep the interrupt handler as fast as
  * possible.  After you are done making modifications, it is not a bad
  * idea to do:
  * 
  * gcc -S -DKERNEL -Wall -Wstrict-prototypes -O6 -fomit-frame-pointer dz.c
  *
- * and look at the resulting assemble code in serial.s.
+ * and look at the resulting assemble code in dz.s.
  *
  * ------------------------------------------------------------
  */
@@ -188,101 +214,97 @@
  * This routine deals with inputs from any lines.
  * ------------------------------------------------------------
  */
-static inline void receive_chars(struct dz_serial *info_in)
+static inline void receive_chars(struct dz_serial *info_in,
+				 struct pt_regs *regs)
 {
-
 	struct dz_serial *info;
-	struct tty_struct *tty = 0;
+	struct tty_struct *tty;
 	struct async_icount *icount;
-	int ignore = 0;
-	unsigned short status, tmp;
-	unsigned char ch;
-
-	/* this code is going to be a problem...
-	   the call to tty_flip_buffer is going to need
-	   to be rethought...
-	 */
-	do {
-		status = dz_in(info_in, DZ_RBUF);
-		info = lines[LINE(status)];
+	int lines_rx[DZ_NB_PORT] = { [0 ... DZ_NB_PORT - 1] = 0 };
+	unsigned short status;
+	unsigned char ch, flag;
+	int i;
 
-		/* punt so we don't get duplicate characters */
-		if (!(status & DZ_DVAL))
-			goto ignore_char;
-
-		ch = UCHAR(status);	/* grab the char */
-
-#if 0
-		if (info->is_console) {
-			if (ch == 0)
-				return;	/* it's a break ... */
-		}
-#endif
+	while ((status = dz_in(info_in, DZ_RBUF)) & DZ_DVAL) {
+		info = lines[LINE(status)];
+		tty = info->tty;		/* point to the proper dev */
 
-		tty = info->tty;	/* now tty points to the proper dev */
-		icount = &info->icount;
+		ch = UCHAR(status);		/* grab the char */
 
-		if (!tty)
-			break;
-		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
-			break;
+		if (!tty && (!info->hook || !info->hook->rx_char))
+			continue;
 
-		*tty->flip.char_buf_ptr = ch;
-		*tty->flip.flag_buf_ptr = 0;
+		icount = &info->icount;
 		icount->rx++;
 
-		/* keep track of the statistics */
-		if (status & (DZ_OERR | DZ_FERR | DZ_PERR)) {
-			if (status & DZ_PERR)	/* parity error */
-				icount->parity++;
-			else if (status & DZ_FERR)	/* frame error */
-				icount->frame++;
-			if (status & DZ_OERR)	/* overrun error */
-				icount->overrun++;
-
-			/*  check to see if we should ignore the character
-			   and mask off conditions that should be ignored
+		flag = 0;
+		if (status & DZ_FERR) {		/* frame error */
+			/*
+			 * There is no separate BREAK status bit, so
+			 * treat framing errors as BREAKs for Magic SysRq
+			 * and SAK; normally, otherwise.
 			 */
-
-			if (status & info->ignore_status_mask) {
-				if (++ignore > 100)
-					break;
-				goto ignore_char;
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
+			if (info->line == dz_sercons.index) {
+				if (!break_pressed)
+					break_pressed = jiffies;
+				continue;
 			}
-			/* mask off the error conditions we want to ignore */
-			tmp = status & info->read_status_mask;
-
-			if (tmp & DZ_PERR) {
-				*tty->flip.flag_buf_ptr = TTY_PARITY;
-#ifdef DEBUG_DZ
-				debug_console("PERR\n", 5);
-#endif
-			} else if (tmp & DZ_FERR) {
-				*tty->flip.flag_buf_ptr = TTY_FRAME;
-#ifdef DEBUG_DZ
-				debug_console("FERR\n", 5);
 #endif
+			flag = TTY_BREAK;
+			if (info->flags & DZ_SAK)
+				do_SAK(tty);
+			else
+				flag = TTY_FRAME;
+		} else if (status & DZ_OERR)	/* overrun error */
+			flag = TTY_OVERRUN;
+		else if (status & DZ_PERR)	/* parity error */
+			flag = TTY_PARITY;
+
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
+		if (break_pressed && info->line == dz_sercons.index) {
+			if (time_before(jiffies, break_pressed + HZ * 5)) {
+				handle_sysrq(ch, regs, NULL, NULL);
+				break_pressed = 0;
+				continue;
 			}
-			if (tmp & DZ_OERR) {
-#ifdef DEBUG_DZ
-				debug_console("OERR\n", 5);
+			break_pressed = 0;
+		}
 #endif
-				if (tty->flip.count < TTY_FLIPBUF_SIZE) {
-					tty->flip.count++;
-					tty->flip.flag_buf_ptr++;
-					tty->flip.char_buf_ptr++;
-					*tty->flip.flag_buf_ptr = TTY_OVERRUN;
-				}
-			}
+
+		if (info->hook && info->hook->rx_char) {
+			(*info->hook->rx_char)(ch, flag);
+			return;
 		}
-		tty->flip.flag_buf_ptr++;
-		tty->flip.char_buf_ptr++;
-		tty->flip.count++;
-	      ignore_char:
-	} while (status & DZ_DVAL);
 
-	if (tty)
-		tty_flip_buffer_push(tty);
+		/* keep track of the statistics */
+		switch (flag) {
+		case TTY_FRAME:
+			icount->frame++;
+			break;
+		case TTY_PARITY:
+			icount->parity++;
+			break;
+		case TTY_OVERRUN:
+			icount->overrun++;
+			break;
+		case TTY_BREAK:
+			icount->brk++;
+			break;
+		default:
+			break;
+		}
+
+		if ((status & info->ignore_status_mask) == 0) {
+			tty_insert_flip_char(tty, ch, flag);
+			lines_rx[LINE(status)] = 1;
+		}
+	}
+	for (i = 0; i < DZ_NB_PORT; i++)
+		if (lines_rx[i])
+			tty_flip_buffer_push(lines[i]->tty);
 }
 
 /*
@@ -292,20 +314,34 @@
  * This routine deals with outputs to any lines.
  * ------------------------------------------------------------
  */
-static inline void transmit_chars(struct dz_serial *info)
+static inline void transmit_chars(struct dz_serial *info_in)
 {
+	struct dz_serial *info;
+	unsigned short status;
 	unsigned char tmp;
 
+	status = dz_in(info_in, DZ_CSR);
+	info = lines[LINE(status)];
 
+	if (info->hook || !info->tty) {
+		unsigned short mask, tmp;
 
-	if (info->x_char) {	/* XON/XOFF chars */
+		mask = 1 << info->line;
+		tmp = dz_in(info, DZ_TCR);	/* read the TX flag */
+		tmp &= ~mask;			/* clear the TX flag */
+		dz_out(info, DZ_TCR, tmp);
+		return;
+	}
+
+	if (info->x_char) {			/* XON/XOFF chars */
 		dz_out(info, DZ_TDR, info->x_char);
 		info->icount.tx++;
 		info->x_char = 0;
 		return;
 	}
 	/* if nothing to do or stopped or hardware stopped */
-	if ((info->xmit_cnt <= 0) || info->tty->stopped || info->tty->hw_stopped) {
+	if (info->xmit_cnt <= 0 ||
+	    info->tty->stopped || info->tty->hw_stopped) {
 		dz_stop(info->tty);
 		return;
 	}
@@ -359,15 +395,14 @@
  */
 static void dz_interrupt(int irq, void *dev, struct pt_regs *regs)
 {
-	struct dz_serial *info;
+	struct dz_serial *info = (struct dz_serial *)dev;
 	unsigned short status;
 
 	/* get the reason why we just got an irq */
-	status = dz_in((struct dz_serial *) dev, DZ_CSR);
-	info = lines[LINE(status)];	/* re-arrange info the proper port */
+	status = dz_in(info, DZ_CSR);
 
 	if (status & DZ_RDONE)
-		receive_chars(info);	/* the receive function */
+		receive_chars(info, regs);
 
 	if (status & DZ_TRDY)
 		transmit_chars(info);
@@ -514,7 +549,7 @@
 
 
 	info->cflags &= ~DZ_CREAD;	/* turn off receive enable flag */
-	dz_out(info, DZ_LPR, info->cflags);
+	dz_out(info, DZ_LPR, info->cflags | info->line);
 
 	if (info->xmit_buf) {	/* free Tx buffer */
 		free_page((unsigned long) info->xmit_buf);
@@ -545,18 +580,21 @@
 {
 	unsigned long flags;
 	unsigned cflag;
-	int baud;
+	int baud, i;
 
-	if (!info->tty || !info->tty->termios)
-		return;
+	if (!info->hook) {
+		if (!info->tty || !info->tty->termios)
+			return;
+		cflag = info->tty->termios->c_cflag;
+	} else {
+		cflag = info->hook->cflags;
+	}
 
 	save_flags(flags);
 	cli();
 
 	info->cflags = info->line;
 
-	cflag = info->tty->termios->c_cflag;
-
 	switch (cflag & CSIZE) {
 	case CS5:
 		info->cflags |= DZ_CS5;
@@ -579,7 +617,16 @@
 	if (cflag & PARODD)
 		info->cflags |= DZ_PARODD;
 
-	baud = tty_get_baud_rate(info->tty);
+	i = cflag & CBAUD;
+	if (i & CBAUDEX) {
+		i &= ~CBAUDEX;
+		if (!info->hook)
+			info->tty->termios->c_cflag &= ~CBAUDEX;
+		else
+			info->hook->cflags &= ~CBAUDEX;
+	}
+        baud = baud_table[i];
+
 	switch (baud) {
 	case 50:
 		info->cflags |= DZ_B50;
@@ -629,16 +676,16 @@
 	}
 
 	info->cflags |= DZ_RXENAB;
-	dz_out(info, DZ_LPR, info->cflags);
+	dz_out(info, DZ_LPR, info->cflags | info->line);
 
 	/* setup accept flag */
 	info->read_status_mask = DZ_OERR;
-	if (I_INPCK(info->tty))
+	if (info->tty && I_INPCK(info->tty))
 		info->read_status_mask |= (DZ_FERR | DZ_PERR);
 
 	/* characters to ignore */
 	info->ignore_status_mask = 0;
-	if (I_IGNPAR(info->tty))
+	if (info->tty && I_IGNPAR(info->tty))
 		info->ignore_status_mask |= (DZ_FERR | DZ_PERR);
 
 	restore_flags(flags);
@@ -694,7 +741,7 @@
 
 		down(&tmp_buf_sem);
 		while (1) {
-			c = MIN(count, MIN(DZ_XMIT_SIZE - info->xmit_cnt - 1, DZ_XMIT_SIZE - info->xmit_head));
+			c = min(count, min(DZ_XMIT_SIZE - info->xmit_cnt - 1, DZ_XMIT_SIZE - info->xmit_head));
 			if (c <= 0)
 				break;
 
@@ -707,7 +754,7 @@
 			save_flags(flags);
 			cli();
 
-			c = MIN(c, MIN(DZ_XMIT_SIZE - info->xmit_cnt - 1, DZ_XMIT_SIZE - info->xmit_head));
+			c = min(c, min(DZ_XMIT_SIZE - info->xmit_cnt - 1, DZ_XMIT_SIZE - info->xmit_head));
 			memcpy(info->xmit_buf + info->xmit_head, tmp_buf, c);
 			info->xmit_head = ((info->xmit_head + c) & (DZ_XMIT_SIZE - 1));
 			info->xmit_cnt += c;
@@ -727,7 +774,7 @@
 			save_flags(flags);
 			cli();
 
-			c = MIN(count, MIN(DZ_XMIT_SIZE - info->xmit_cnt - 1, DZ_XMIT_SIZE - info->xmit_head));
+			c = min(count, min(DZ_XMIT_SIZE - info->xmit_cnt - 1, DZ_XMIT_SIZE - info->xmit_head));
 			if (c <= 0) {
 				restore_flags(flags);
 				break;
@@ -845,7 +892,7 @@
 
 /*
  * ------------------------------------------------------------
- * rs_ioctl () and friends
+ * dz_ioctl () and friends
  * ------------------------------------------------------------
  */
 static int get_serial_info(struct dz_serial *info,
@@ -958,6 +1005,9 @@
 	struct dz_serial *info = (struct dz_serial *) tty->driver_data;
 	int retval;
 
+	if (info->hook)
+		return -ENODEV;
+
 	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
 	    (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGWILD) &&
 	    (cmd != TIOCSERSWILD) && (cmd != TIOCSERGSTRUCT)) {
@@ -1252,19 +1302,14 @@
 	int retval, line;
 
 	line = MINOR(tty->device) - tty->driver.minor_start;
-
-	/* The dz lines for the mouse/keyboard must be
-	 * opened using their respective drivers.
-	 */
 	if ((line < 0) || (line >= DZ_NB_PORT))
 		return -ENODEV;
+	info = lines[line];
 
-	if ((line == DZ_KEYBOARD) || (line == DZ_MOUSE))
+	if (info->hook)
 		return -ENODEV;
 
-	info = lines[line];
 	info->count++;
-
 	tty->driver_data = info;
 	info->tty = tty;
 
@@ -1285,14 +1330,21 @@
 		else
 			*tty->termios = info->callout_termios;
 		change_speed(info);
-
 	}
+#ifdef CONFIG_SERIAL_DEC_CONSOLE
+	if (dz_sercons.cflag && dz_sercons.index == line) {
+		tty->termios->c_cflag = dz_sercons.cflag;
+		dz_sercons.cflag = 0;
+		change_speed(info);
+        }
+#endif
+
 	info->session = current->session;
 	info->pgrp = current->pgrp;
 	return 0;
 }
 
-static void show_serial_version(void)
+static void __init show_serial_version(void)
 {
 	printk("%s%s\n", dz_name, dz_version);
 }
@@ -1300,7 +1352,6 @@
 int __init dz_init(void)
 {
 	int i;
-	long flags;
 	struct dz_serial *info;
 
 	/* Setup base handler, and timer table. */
@@ -1311,9 +1362,9 @@
 	memset(&serial_driver, 0, sizeof(struct tty_driver));
 	serial_driver.magic = TTY_DRIVER_MAGIC;
 #if (LINUX_VERSION_CODE > 0x2032D && defined(CONFIG_DEVFS_FS))
-	serial_driver.name = "ttyS";
-#else
 	serial_driver.name = "tts/%d";
+#else
+	serial_driver.name = "ttyS";
 #endif
 	serial_driver.major = TTY_MAJOR;
 	serial_driver.minor_start = 64;
@@ -1352,9 +1403,9 @@
 	 */
 	callout_driver = serial_driver;
 #if (LINUX_VERSION_CODE > 0x2032D && defined(CONFIG_DEVFS_FS))
-	callout_driver.name = "cua";
-#else
 	callout_driver.name = "cua/%d";
+#else
+	callout_driver.name = "cua";
 #endif
 	callout_driver.major = TTYAUX_MAJOR;
 	callout_driver.subtype = SERIAL_TYPE_CALLOUT;
@@ -1363,25 +1414,27 @@
 		panic("Couldn't register serial driver");
 	if (tty_register_driver(&callout_driver))
 		panic("Couldn't register callout driver");
-	save_flags(flags);
-	cli();
 
 	for (i = 0; i < DZ_NB_PORT; i++) {
 		info = &multi[i];
 		lines[i] = info;
-		info->magic = SERIAL_MAGIC;
-
+		info->tty = 0;
+		info->x_char = 0;
 		if (mips_machtype == MACH_DS23100 ||
 		    mips_machtype == MACH_DS5100)
 			info->port = (unsigned long) KN01_DZ11_BASE;
 		else
 			info->port = (unsigned long) KN02_DZ11_BASE;
-
 		info->line = i;
-		info->tty = 0;
+
+		if (info->hook && info->hook->init_info) {
+			(*info->hook->init_info)(info);
+			continue;
+		}
+
+		info->magic = SERIAL_MAGIC;
 		info->close_delay = 50;
 		info->closing_wait = 3000;
-		info->x_char = 0;
 		info->event = 0;
 		info->count = 0;
 		info->blocked_open = 0;
@@ -1393,25 +1446,16 @@
 		info->normal_termios = serial_driver.init_termios;
 		init_waitqueue_head(&info->open_wait);
 		init_waitqueue_head(&info->close_wait);
-
-		/*
-		 * If we are pointing to address zero then punt - not correctly
-		 * set up in setup.c to handle this.
-		 */
-		if (!info->port)
-			return 0;
-
-		printk("ttyS%02d at 0x%08x (irq = %d)\n", info->line,
-		       info->port, dec_interrupt[DEC_IRQ_DZ11]);
-
+		printk("ttyS%02d at 0x%08x (irq = %d) is a DC7085 DZ\n",
+		       info->line, info->port, dec_interrupt[DEC_IRQ_DZ11]);
 		tty_register_devfs(&serial_driver, 0,
-				 serial_driver.minor_start + info->line);
+				   serial_driver.minor_start + info->line);
 		tty_register_devfs(&callout_driver, 0,
-				callout_driver.minor_start + info->line);
+				   callout_driver.minor_start + info->line);
 	}
 
-	/* reset the chip */
 #ifndef CONFIG_SERIAL_DEC_CONSOLE
+	/* reset the chip */
 	dz_out(info, DZ_CSR, DZ_CLR);
 	while (dz_in(info, DZ_CSR) & DZ_CLR);
 	iob();
@@ -1420,43 +1464,104 @@
 	dz_out(info, DZ_CSR, DZ_MSE);
 #endif
 
-	/* order matters here... the trick is that flags
-	   is updated... in request_irq - to immediatedly obliterate
-	   it is unwise. */
-	restore_flags(flags);
-
-
 	if (request_irq(dec_interrupt[DEC_IRQ_DZ11], dz_interrupt,
-			SA_INTERRUPT, "DZ", lines[0]))
+			0, "DZ", lines[0]))
 		panic("Unable to register DZ interrupt");
 
+	for (i = 0; i < DZ_NB_PORT; i++)
+		if (lines[i]->hook) {
+			startup(lines[i]);
+			if (lines[i]->hook->init_channel)
+				(*lines[i]->hook->init_channel)(lines[i]);
+		}
+
 	return 0;
 }
 
-#ifdef CONFIG_SERIAL_DEC_CONSOLE
-static void dz_console_put_char(unsigned char ch)
+/*
+ * polling I/O routines
+ */
+static int dz_poll_tx_char(void *handle, unsigned char ch)
 {
 	unsigned long flags;
-	int loops = 2500;
-	unsigned short tmp = ch;
-	/* this code sends stuff out to serial device - spinning its
-	   wheels and waiting. */
+	struct dz_serial *info = handle;
+	unsigned short csr, tcr, trdy, mask;
+	int loops = 10000;
+	int ret;
 
-	/* force the issue - point it at lines[3] */
-	dz_console = &multi[CONSOLE_LINE];
+	local_irq_save(flags);
+	csr = dz_in(info, DZ_CSR);
+	dz_out(info, DZ_CSR, csr & ~DZ_TIE);
+	tcr = dz_in(info, DZ_TCR);
+	tcr |= 1 << info->line;
+	mask = tcr;
+	dz_out(info, DZ_TCR, mask);
+	iob();
+	local_irq_restore(flags);
 
-	save_flags(flags);
-	cli();
+	while (loops--) {
+		trdy = dz_in(info, DZ_CSR);
+		if (!(trdy & DZ_TRDY))
+			continue;
+		trdy = (trdy & DZ_TLINE) >> 8;
+		if (trdy == info->line)
+			break;
+		mask &= ~(1 << trdy);
+		dz_out(info, DZ_TCR, mask);
+		iob();
+		udelay(2);
+	}
 
+	if (loops) {
+		dz_out(info, DZ_TDR, ch);
+		ret = 0;
+	} else
+		ret = -EAGAIN;
 
-	/* spin our wheels */
-	while (((dz_in(dz_console, DZ_CSR) & DZ_TRDY) != DZ_TRDY) && loops--);
+	dz_out(info, DZ_TCR, tcr);
+	dz_out(info, DZ_CSR, csr);
 
-	/* Actually transmit the character. */
-	dz_out(dz_console, DZ_TDR, tmp);
+	return ret;
+}
 
-	restore_flags(flags);
+static int dz_poll_rx_char(void *handle)
+{
+	return -ENODEV;
+}
+
+int register_dz_hook(unsigned int channel, struct dec_serial_hook *hook)
+{
+	struct dz_serial *info = multi + channel;
+
+	if (info->hook) {
+		printk("%s: line %d has already a hook registered\n",
+		       __FUNCTION__, channel);
+
+		return 0;
+	} else {
+		hook->poll_rx_char = dz_poll_rx_char;
+		hook->poll_tx_char = dz_poll_tx_char;
+		info->hook = hook;
+
+		return 1;
+	}
+}
+
+int unregister_dz_hook(unsigned int channel)
+{
+	struct dz_serial *info = &multi[channel];
+
+	if (info->hook) {
+		info->hook = NULL;
+		return 1;
+	} else {
+		printk("%s: trying to unregister hook on line %d,"
+		       " but none is registered\n", __FUNCTION__, channel);
+		return 0;
+	}
 }
+
+#ifdef CONFIG_SERIAL_DEC_CONSOLE
 /* 
  * -------------------------------------------------------------------
  * dz_console_print ()
@@ -1465,17 +1570,19 @@
  * The console must be locked when we get here.
  * ------------------------------------------------------------------- 
  */
-static void dz_console_print(struct console *cons,
+static void dz_console_print(struct console *co,
 			     const char *str,
 			     unsigned int count)
 {
+	struct dz_serial *info = multi + co->index;
+
 #ifdef DEBUG_DZ
 	prom_printf((char *) str);
 #endif
 	while (count--) {
 		if (*str == '\n')
-			dz_console_put_char('\r');
-		dz_console_put_char(*str++);
+			dz_poll_tx_char(info, '\r');
+		dz_poll_tx_char(info, *str++);
 	}
 }
 
@@ -1486,12 +1593,12 @@
 
 static int __init dz_console_setup(struct console *co, char *options)
 {
+	struct dz_serial *info = multi + co->index;
 	int baud = 9600;
 	int bits = 8;
 	int parity = 'n';
 	int cflag = CREAD | HUPCL | CLOCAL;
 	char *s;
-	unsigned short mask, tmp;
 
 	if (options) {
 		baud = simple_strtoul(options, NULL, 10);
@@ -1542,44 +1649,31 @@
 	}
 	co->cflag = cflag;
 
-	/* TOFIX: force to console line */
-	dz_console = &multi[CONSOLE_LINE];
 	if ((mips_machtype == MACH_DS23100) || (mips_machtype == MACH_DS5100))
-		dz_console->port = KN01_DZ11_BASE;
+		info->port = KN01_DZ11_BASE;
 	else
-		dz_console->port = KN02_DZ11_BASE;
-	dz_console->line = CONSOLE_LINE;
+		info->port = KN02_DZ11_BASE;
+	info->line = co->index;
 
-	dz_out(dz_console, DZ_CSR, DZ_CLR);
-	while ((tmp = dz_in(dz_console, DZ_CSR)) & DZ_CLR);
+	dz_out(info, DZ_CSR, DZ_CLR);
+	while (dz_in(info, DZ_CSR) & DZ_CLR);
 
 	/* enable scanning */
-	dz_out(dz_console, DZ_CSR, DZ_MSE);
+	dz_out(info, DZ_CSR, DZ_MSE);
 
 	/*  Set up flags... */
-	dz_console->cflags = 0;
-	dz_console->cflags |= DZ_B9600;
-	dz_console->cflags |= DZ_CS8;
-	dz_console->cflags |= DZ_PARENB;
-	dz_out(dz_console, DZ_LPR, dz_console->cflags);
-
-	mask = 1 << dz_console->line;
-	tmp = dz_in(dz_console, DZ_TCR);	/* read the TX flag */
-	if (!(tmp & mask)) {
-		tmp |= mask;	/* set the TX flag */
-		dz_out(dz_console, DZ_TCR, tmp);
-	}
+	dz_out(info, DZ_LPR, cflag | info->line);
+
 	return 0;
 }
 
-static struct console dz_sercons =
-{
-    .name	= "ttyS",
-    .write	= dz_console_print,
-    .device	= dz_console_device,
-    .setup	= dz_console_setup,
-    .flags	= CON_CONSDEV | CON_PRINTBUFFER,
-    .index	= CONSOLE_LINE,
+static struct console dz_sercons = {
+	.name	= "ttyS",
+	.write	= dz_console_print,
+	.device	= dz_console_device,
+	.setup	= dz_console_setup,
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
 };
 
 void __init dz_serial_console_init(void)
diff -Nur linux-2.4.30/drivers/char/dz.h linux-2.4.30-mips/drivers/char/dz.h
--- linux-2.4.30/drivers/char/dz.h	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.30-mips/drivers/char/dz.h	2004-09-28 02:53:01.000000000 +0200
@@ -10,6 +10,8 @@
 #ifndef DZ_SERIAL_H
 #define DZ_SERIAL_H
 
+#include <asm/dec/serial.h>
+
 #define SERIAL_MAGIC 0x5301
 
 /*
@@ -17,6 +19,7 @@
  */
 #define DZ_TRDY        0x8000                 /* Transmitter empty */
 #define DZ_TIE         0x4000                 /* Transmitter Interrupt Enable */
+#define DZ_TLINE       0x0300                 /* Transmitter Line Number */
 #define DZ_RDONE       0x0080                 /* Receiver data ready */
 #define DZ_RIE         0x0040                 /* Receive Interrupt Enable */
 #define DZ_MSE         0x0020                 /* Master Scan Enable */
@@ -37,19 +40,30 @@
 #define UCHAR(x) (unsigned char)(x & DZ_RBUF_MASK)
 
 /*
- * Definitions for the Transmit Register.
+ * Definitions for the Transmit Control Register.
  */
 #define DZ_LINE_KEYBOARD 0x0001
 #define DZ_LINE_MOUSE    0x0002
 #define DZ_LINE_MODEM    0x0004
 #define DZ_LINE_PRINTER  0x0008
 
+#define DZ_MODEM_RTS     0x0800               /* RTS for the modem line (2) */
 #define DZ_MODEM_DTR     0x0400               /* DTR for the modem line (2) */
+#define DZ_PRINT_RTS     0x0200               /* RTS for the printer line (3) */
+#define DZ_PRINT_DTR     0x0100               /* DTR for the printer line (3) */
+#define DZ_LNENB         0x000f               /* Transmitter Line Enable */
 
 /*
  * Definitions for the Modem Status Register.
  */
+#define DZ_MODEM_RI      0x0800               /* RI for the modem line (2) */
+#define DZ_MODEM_CD      0x0400               /* CD for the modem line (2) */
 #define DZ_MODEM_DSR     0x0200               /* DSR for the modem line (2) */
+#define DZ_MODEM_CTS     0x0100               /* CTS for the modem line (2) */
+#define DZ_PRINT_RI      0x0008               /* RI for the printer line (2) */
+#define DZ_PRINT_CD      0x0004               /* CD for the printer line (2) */
+#define DZ_PRINT_DSR     0x0002               /* DSR for the printer line (2) */
+#define DZ_PRINT_CTS     0x0001               /* CTS for the printer line (2) */
 
 /*
  * Definitions for the Transmit Data Register.
@@ -115,9 +129,6 @@
 
 #define DZ_EVENT_WRITE_WAKEUP   0
 
-#ifndef MIN
-#define MIN(a,b)        ((a) < (b) ? (a) : (b))
-
 #define DZ_INITIALIZED       0x80000000 /* Serial port was initialized */
 #define DZ_CALLOUT_ACTIVE    0x40000000 /* Call out device is active */
 #define DZ_NORMAL_ACTIVE     0x20000000 /* Normal device is active */
@@ -129,6 +140,7 @@
 #define DZ_CLOSING_WAIT_INF  0
 #define DZ_CLOSING_WAIT_NONE 65535
 
+#define DZ_SAK             0x0004 /* Secure Attention Key (Orange book) */
 #define DZ_SPLIT_TERMIOS   0x0008 /* Separate termios for dialin/callout */
 #define DZ_SESSION_LOCKOUT 0x0100 /* Lock out cua opens based on session */
 #define DZ_PGRP_LOCKOUT    0x0200 /* Lock out cua opens based on pgrp */
@@ -166,79 +178,9 @@
   long                    session;             /* Session of opening process */
   long                    pgrp;                /* pgrp of opening process */
 
+  struct dec_serial_hook  *hook;               /* Hook on this channel.  */
   unsigned char           is_console;          /* flag indicating a serial console */
   unsigned char           is_initialized;
 };
 
-static struct dz_serial multi[DZ_NB_PORT];    /* Four serial lines in the DZ chip */
-static struct dz_serial *dz_console;
-static struct tty_driver serial_driver, callout_driver;
-
-static struct tty_struct *serial_table[DZ_NB_PORT];
-static struct termios *serial_termios[DZ_NB_PORT];
-static struct termios *serial_termios_locked[DZ_NB_PORT];
-
-static int serial_refcount;
-
-/*
- * tmp_buf is used as a temporary buffer by serial_write.  We need to
- * lock it in case the copy_from_user blocks while swapping in a page,
- * and some other program tries to do a serial write at the same time.
- * Since the lock will only come under contention when the system is
- * swapping and available memory is low, it makes sense to share one
- * buffer across all the serial ports, since it significantly saves
- * memory if large numbers of serial ports are open.
- */
-static unsigned char *tmp_buf;
-static DECLARE_MUTEX(tmp_buf_sem);
-
-static char *dz_name = "DECstation DZ serial driver version ";
-static char *dz_version = "1.02";
-
-static inline unsigned short dz_in (struct dz_serial *, unsigned);
-static inline void dz_out (struct dz_serial *, unsigned, unsigned short);
-
-static inline void dz_sched_event (struct dz_serial *, int);
-static inline void receive_chars (struct dz_serial *);
-static inline void transmit_chars (struct dz_serial *);
-static inline void check_modem_status (struct dz_serial *);
-
-static void dz_stop (struct tty_struct *);
-static void dz_start (struct tty_struct *);
-static void dz_interrupt (int, void *, struct pt_regs *);
-static void do_serial_bh (void);
-static void do_softint (void *);
-static void do_serial_hangup (void *);
-static void change_speed (struct dz_serial *);
-static void dz_flush_chars (struct tty_struct *);
-static void dz_console_print (struct console *, const char *, unsigned int);
-static void dz_flush_buffer (struct tty_struct *);
-static void dz_throttle (struct tty_struct *);
-static void dz_unthrottle (struct tty_struct *);
-static void dz_send_xchar (struct tty_struct *, char);
-static void shutdown (struct dz_serial *);
-static void send_break (struct dz_serial *, int);
-static void dz_set_termios (struct tty_struct *, struct termios *);
-static void dz_close (struct tty_struct *, struct file *);
-static void dz_hangup (struct tty_struct *);
-static void show_serial_version (void);
-
-static int dz_write (struct tty_struct *, int, const unsigned char *, int);
-static int dz_write_room (struct tty_struct *);
-static int dz_chars_in_buffer (struct tty_struct *);
-static int startup (struct dz_serial *);
-static int get_serial_info (struct dz_serial *, struct serial_struct *);
-static int set_serial_info (struct dz_serial *, struct serial_struct *);
-static int get_lsr_info (struct dz_serial *, unsigned int *);
-static int dz_ioctl (struct tty_struct *, struct file *, unsigned int, unsigned long);
-static int block_til_ready (struct tty_struct *, struct file *, struct dz_serial *);
-static int dz_open (struct tty_struct *, struct file *);
-
-#ifdef MODULE
-int init_module (void)
-void cleanup_module (void)
-#endif
-
-#endif
-
 #endif /* DZ_SERIAL_H */
diff -Nur linux-2.4.30/drivers/char/ibm_workpad_keymap.map linux-2.4.30-mips/drivers/char/ibm_workpad_keymap.map
--- linux-2.4.30/drivers/char/ibm_workpad_keymap.map	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/char/ibm_workpad_keymap.map	2003-12-20 15:20:44.000000000 +0100
@@ -0,0 +1,343 @@
+# Keymap for IBM Workpad z50
+# US Mapping
+#
+# by Michael Klar <wyldfier@iname.com>
+#
+# This is a great big mess on account of how the Caps Lock key is handled as
+# LeftShift-RightShift.  Right shift key had to be broken out, so don't use
+# use this map file as a basis for other keyboards that don't do the same
+# thing with Caps Lock.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+
+keymaps 0-2,4-5,8,12,32-33,36-37
+strings as usual
+
+keycode 0 = F1 F11 Console_13
+	shiftr keycode 0 = F11
+	shift shiftr keycode 0 = F11
+	control keycode 0 = F1
+	alt keycode 0 = Console_1
+	control alt keycode 0 = Console_1
+keycode 1 = F3 F13 Console_15
+	shiftr keycode 1 = F13
+	shift shiftr keycode 1 = F13
+	control keycode 1 = F3
+	alt keycode 1 = Console_3
+	control alt keycode 1 = Console_3
+keycode 2 = F5 F15 Console_17
+	shiftr keycode 2 = F15
+	shift shiftr keycode 2 = F15
+	control keycode 2 = F5
+	alt keycode 2 = Console_5
+	control alt keycode 2 = Console_5
+keycode 3 = F7 F17 Console_19
+	shiftr keycode 3 = F17
+	shift shiftr keycode 3 = F17
+	control keycode 3 = F7
+	alt keycode 3 = Console_7
+	control alt keycode 3 = Console_7
+keycode 4 = F9 F19 Console_21
+	shiftr keycode 4 = F19
+	shift shiftr keycode 4 = F19
+	control keycode 4 = F9
+	alt keycode 4 = Console_9
+	control alt keycode 4 = Console_9
+#keycode 5 is contrast down
+#keycode 6 is contrast up
+keycode 7 = F11 F11 Console_23
+	shiftr keycode 7 = F11
+	shift shiftr keycode 7 = F11
+	control keycode 7 = F11
+	alt keycode 7 = Console_11
+	control alt keycode 7 = Console_11
+keycode 8 = F2 F12 Console_14
+	shiftr keycode 8 = F12
+	shift shiftr keycode 8 = F12
+	control keycode 8 = F2
+	alt keycode 8 = Console_2
+	control alt keycode 8 = Console_2
+keycode 9 = F4 F14 Console_16
+	shiftr keycode 9 = F14
+	shift shiftr keycode 9 = F14
+	control keycode 9 = F4
+	alt keycode 9 = Console_4
+	control alt keycode 9 = Console_4
+keycode 10 = F6 F16 Console_18
+	shiftr keycode 10 = F16
+	shift shiftr keycode 10 = F16
+	control keycode 10 = F6
+	alt keycode 10 = Console_6
+	control alt keycode 10 = Console_6
+keycode 11 = F8 F18 Console_20
+	shiftr keycode 11 = F18
+	shift shiftr keycode 11 = F18
+	control keycode 11 = F8
+	alt keycode 11 = Console_8
+	control alt keycode 11 = Console_8
+keycode 12 = F10 F20 Console_22
+	shiftr keycode 12 = F20
+	shift shiftr keycode 12 = F20
+	control keycode 12 = F10
+	alt keycode 12 = Console_10
+	control alt keycode 12 = Console_10
+#keycode 13 is brightness down
+#keycode 14 is brightness up
+keycode 15 = F12 F12 Console_24
+	shiftr keycode 15 = F12
+	shift shiftr keycode 15 = F12
+	control keycode 15 = F12
+	alt keycode 15 = Console_12
+	control alt keycode 15 = Console_12
+keycode 16 = apostrophe quotedbl
+	shiftr keycode 16 = quotedbl
+	shift shiftr keycode 16 = quotedbl
+	control keycode 16 = Control_g
+	alt keycode 16 = Meta_apostrophe
+keycode 17 = bracketleft braceleft
+	shiftr keycode 17 = braceleft
+	shift shiftr keycode 17 = braceleft
+	control keycode 17 = Escape
+	alt keycode 17 = Meta_bracketleft
+keycode 18 = minus underscore backslash       
+	shiftr keycode 18 = underscore
+	shift shiftr keycode 18 = underscore
+	control keycode 18 = Control_underscore
+	shift control keycode 18 = Control_underscore
+	shiftr control keycode 18 = Control_underscore
+	shift shiftr control keycode 18 = Control_underscore
+	alt keycode 18 = Meta_minus
+keycode 19 = zero parenright braceright
+	shiftr keycode 19 = parenright
+	shift shiftr keycode 19 = parenright
+	alt keycode 19 = Meta_zero
+keycode 20 = p
+	shiftr keycode 20 = +P
+	shift shiftr keycode 20 = +p
+keycode 21 = semicolon colon
+	shiftr keycode 21 = colon
+	shift shiftr keycode 21 = colon
+	alt keycode 21 = Meta_semicolon
+keycode 22 = Up Scroll_Backward
+	shiftr keycode 22 = Scroll_Backward
+	shift shiftr keycode 22 = Scroll_Backward
+	alt keycode 22 = Prior
+keycode 23 = slash question
+	shiftr keycode 23 = question
+	shift shiftr keycode 23 = question
+	control keycode 23 = Delete
+	alt keycode 23 = Meta_slash
+
+keycode 27 = nine parenleft bracketright
+	shiftr keycode 27 = parenleft
+	shift shiftr keycode 27 = parenleft
+	alt keycode 27 = Meta_nine
+keycode 28 = o
+	shiftr keycode 28 = +O
+	shift shiftr keycode 28 = +o
+keycode 29 = l
+	shiftr keycode 29 = +L
+	shift shiftr keycode 29 = +l
+keycode 30 = period greater
+	shiftr keycode 30 = greater
+	shift shiftr keycode 30 = greater
+	control keycode 30 = Compose
+	alt keycode 30 = Meta_period
+
+keycode 32 = Left Decr_Console
+	shiftr keycode 32 = Decr_Console
+	shift shiftr keycode 32 = Decr_Console
+	alt keycode 32 = Home
+keycode 33 = bracketright braceright asciitilde      
+	shiftr keycode 33 = braceright
+	shift shiftr keycode 33 = braceright
+	control keycode 33 = Control_bracketright
+	alt keycode 33 = Meta_bracketright
+keycode 34 = equal plus
+	shiftr keycode 34 = plus
+	shift shiftr keycode 34 = plus
+	alt keycode 34 = Meta_equal
+keycode 35 = eight asterisk bracketleft
+	shiftr keycode 35 = asterisk
+	shift shiftr keycode 35 = asterisk
+	control keycode 35 = Delete
+	alt keycode 35 = Meta_eight
+keycode 36 = i
+	shiftr keycode 36 = +I
+	shift shiftr keycode 36 = +i
+keycode 37 = k
+	shiftr keycode 37 = +K
+	shift shiftr keycode 37 = +k
+keycode 38 = comma less
+	shiftr keycode 38 = less
+	shift shiftr keycode 38 = less
+	alt keycode 38 = Meta_comma
+
+keycode 40 = h
+	shiftr keycode 40 = +H
+	shift shiftr keycode 40 = +h
+keycode 41 = y
+	shiftr keycode 41 = +Y
+	shift shiftr keycode 41 = +y
+keycode 42 = six asciicircum
+	shiftr keycode 42 = asciicircum
+	shift shiftr keycode 42 = asciicircum
+	control keycode 42 = Control_asciicircum
+	alt keycode 42 = Meta_six
+keycode 43 = seven ampersand braceleft
+	shiftr keycode 43 = ampersand
+	shift shiftr keycode 43 = ampersand
+	control keycode 43 = Control_underscore
+	alt keycode 43 = Meta_seven
+keycode 44 = u
+	shiftr keycode 44 = +U
+	shift shiftr keycode 44 = +u
+keycode 45 = j
+	shiftr keycode 45 = +J
+	shift shiftr keycode 45 = +j
+keycode 46 = m
+	shiftr keycode 46 = +M
+	shift shiftr keycode 46 = +m
+keycode 47 = n
+	shiftr keycode 47 = +N
+	shift shiftr keycode 47 = +n
+
+# This is the "Backspace" key:
+keycode 49 = Delete Delete
+	shiftr keycode 49 = Delete
+	shift shiftr keycode 49 = Delete
+	control keycode 49 = BackSpace
+	alt keycode 49 = Meta_Delete
+keycode 50 = Num_Lock
+	shift keycode 50 = Bare_Num_Lock
+	shiftr keycode 50 = Bare_Num_Lock
+	shift shiftr keycode 50 = Bare_Num_Lock
+# This is the "Delete" key:
+keycode 51 = Remove
+	control alt keycode 51 = Boot
+
+keycode 53 = backslash bar
+	shiftr keycode 53 = bar
+	shift shiftr keycode 53 = bar
+	control keycode 53 = Control_backslash
+	alt keycode 53 = Meta_backslash
+keycode 54 = Return
+	alt keycode 54 = Meta_Control_m
+keycode 55 = space space           
+	shiftr keycode 55 = space
+	shift shiftr keycode 55 = space
+	control keycode 55 = nul
+	alt keycode 55 = Meta_space
+keycode 56 = g
+	shiftr keycode 56 = +G
+	shift shiftr keycode 56 = +g
+keycode 57 = t
+	shiftr keycode 57 = +T
+	shift shiftr keycode 57 = +t
+keycode 58 = five percent
+	shiftr keycode 58 = percent
+	shift shiftr keycode 58 = percent
+	control keycode 58 = Control_bracketright
+	alt keycode 58 = Meta_five
+keycode 59 = four dollar dollar
+	shiftr keycode 59 = dollar
+	shift shiftr keycode 59 = dollar
+	control keycode 59 = Control_backslash
+	alt keycode 59 = Meta_four
+keycode 60 = r
+	shiftr keycode 60 = +R
+	shift shiftr keycode 60 = +r
+keycode 61 = f
+	shiftr keycode 61 = +F
+	shift shiftr keycode 61 = +f
+	altgr keycode 61 = Hex_F
+keycode 62 = v
+	shiftr keycode 62 = +V
+	shift shiftr keycode 62 = +v
+keycode 63 = b
+	shiftr keycode 63 = +B
+	shift shiftr keycode 63 = +b
+	altgr keycode 63 = Hex_B
+
+keycode 67 = three numbersign
+	shiftr keycode 67 = numbersign
+	shift shiftr keycode 67 = numbersign
+	control keycode 67 = Escape
+	alt keycode 67 = Meta_three
+keycode 68 = e
+	shiftr keycode 68 = +E
+	shift shiftr keycode 68 = +e
+	altgr keycode 68 = Hex_E
+keycode 69 = d
+	shiftr keycode 69 = +D
+	shift shiftr keycode 69 = +d
+	altgr keycode 69 = Hex_D
+keycode 70 = c
+	shiftr keycode 70 = +C
+	shift shiftr keycode 70 = +c
+	altgr keycode 70 = Hex_C
+keycode 71 = Right Incr_Console
+	shiftr keycode 71 = Incr_Console
+	shift shiftr keycode 71 = Incr_Console
+	alt keycode 71 = End
+
+keycode 75 = two at at
+	shiftr keycode 75 = at
+	shift shiftr keycode 75 = at
+	control keycode 75 = nul
+	shift control keycode 75 = nul
+	shiftr control keycode 75 = nul
+	shift shiftr control keycode 75 = nul
+	alt keycode 75 = Meta_two
+keycode 76 = w
+	shiftr keycode 76 = +W
+	shift shiftr keycode 76 = +w
+keycode 77 = s
+	shiftr keycode 77 = +S
+	shift shiftr keycode 77 = +s
+keycode 78 = x
+	shiftr keycode 78 = +X
+	shift shiftr keycode 78 = +x
+keycode 79 = Down Scroll_Forward
+	shiftr keycode 79 = Scroll_Forward
+	shift shiftr keycode 79 = Scroll_Forward
+	alt keycode 79 = Next
+keycode 80 = Escape Escape
+	shiftr keycode 80 = Escape
+	shift shiftr keycode 80 = Escape
+	alt keycode 80 = Meta_Escape
+keycode 81 = Tab Tab             
+	shiftr keycode 81 = Tab
+	shift shiftr keycode 81 = Tab
+	alt keycode 81 = Meta_Tab
+keycode 82 = grave asciitilde
+	shiftr keycode 82 = asciitilde
+	shift shiftr keycode 82 = asciitilde
+	control keycode 82 = nul
+	alt keycode 82 = Meta_grave
+keycode 83 = one exclam
+	shiftr keycode 83 = exclam
+	shift shiftr keycode 83 = exclam
+	alt keycode 83 = Meta_one
+keycode 84 = q
+	shiftr keycode 84 = +Q
+	shift shiftr keycode 84 = +q
+keycode 85 = a
+	shiftr keycode 85 = +A
+	shift shiftr keycode 85 = +a
+	altgr keycode 85 = Hex_A
+keycode 86 = z
+	shiftr keycode 86 = +Z
+	shift shiftr keycode 86 = +z
+
+# This is the windows key:
+keycode 88 = Decr_Console
+keycode 89 = Shift
+keycode 90 = Control
+keycode 91 = Control
+keycode 92 = Alt
+keycode 93 = AltGr
+keycode 94 = ShiftR
+	shift keycode 94 = Caps_Lock
diff -Nur linux-2.4.30/drivers/char/indydog.c linux-2.4.30-mips/drivers/char/indydog.c
--- linux-2.4.30/drivers/char/indydog.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-2.4.30-mips/drivers/char/indydog.c	2004-06-22 17:32:07.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *	IndyDog	0.2	A Hardware Watchdog Device for SGI IP22
+ *	IndyDog	0.3	A Hardware Watchdog Device for SGI IP22
  *
  *	(c) Copyright 2002 Guido Guenther <agx@sigxcpu.org>, All Rights Reserved.
  *
@@ -7,10 +7,10 @@
  *	modify it under the terms of the GNU General Public License
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
- *	
+ *
  *	based on softdog.c by Alan Cox <alan@redhat.com>
  */
- 
+
 #include <linux/module.h>
 #include <linux/config.h>
 #include <linux/types.h>
@@ -19,13 +19,12 @@
 #include <linux/mm.h>
 #include <linux/miscdevice.h>
 #include <linux/watchdog.h>
-#include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <asm/uaccess.h>
 #include <asm/sgi/mc.h>
 
-static unsigned long indydog_alive;
-static int expect_close = 0;
+#define PFX "indydog: "
+static int indydog_alive;
 
 #ifdef CONFIG_WATCHDOG_NOWAYOUT
 static int nowayout = 1;
@@ -33,10 +32,30 @@
 static int nowayout = 0;
 #endif
 
+#define WATCHDOG_TIMEOUT 30		/* 30 sec default timeout */
+
 MODULE_PARM(nowayout,"i");
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default=CONFIG_WATCHDOG_NOWAYOUT)");
 
-static inline void indydog_ping(void)
+static void indydog_start(void)
+{
+	u32 mc_ctrl0 = sgimc->cpuctrl0;
+
+	mc_ctrl0 = sgimc->cpuctrl0 | SGIMC_CCTRL0_WDOG;
+	sgimc->cpuctrl0 = mc_ctrl0;
+}
+
+static void indydog_stop(void)
+{
+	u32 mc_ctrl0 = sgimc->cpuctrl0;
+
+	mc_ctrl0 &= ~SGIMC_CCTRL0_WDOG;
+	sgimc->cpuctrl0 = mc_ctrl0;
+
+	printk(KERN_INFO PFX "Stopped watchdog timer.\n");
+}
+
+static void indydog_ping(void)
 {
 	sgimc->watchdogt = 0;
 }
@@ -46,18 +65,14 @@
  */
 static int indydog_open(struct inode *inode, struct file *file)
 {
-	u32 mc_ctrl0;
-	
-	if (test_and_set_bit(0,&indydog_alive))
+	if (indydog_alive)
 		return -EBUSY;
 
-	if (nowayout) {
+	if (nowayout)
 		MOD_INC_USE_COUNT;
-	}
 
 	/* Activate timer */
-	mc_ctrl0 = sgimc->cpuctrl0 | SGIMC_CCTRL0_WDOG;
-	sgimc->cpuctrl0 = mc_ctrl0;
+	indydog_start();
 	indydog_ping();
 			
 	indydog_alive = 1;
@@ -69,63 +84,48 @@
 static int indydog_release(struct inode *inode, struct file *file)
 {
 	/* Shut off the timer.
-	 * Lock it in if it's a module and we set nowayout. */
-	lock_kernel();
-	if (expect_close) {
-		u32 mc_ctrl0 = sgimc->cpuctrl0;
+	 * Lock it in if it's a module and we defined ...NOWAYOUT */
+	if (!nowayout) {
+		u32 mc_ctrl0 = sgimc->cpuctrl0; 
 		mc_ctrl0 &= ~SGIMC_CCTRL0_WDOG;
 		sgimc->cpuctrl0 = mc_ctrl0;
 		printk(KERN_INFO "Stopped watchdog timer.\n");
-	} else
-		printk(KERN_CRIT "WDT device closed unexpectedly.  WDT will not stop!\n");
-	clear_bit(0, &indydog_alive);
-	unlock_kernel();
+	}
+	indydog_alive = 0;
 
 	return 0;
 }
 
 static ssize_t indydog_write(struct file *file, const char *data, size_t len, loff_t *ppos)
 {
-	/*  Can't seek (pwrite) on this device  */
+	/* Can't seek (pwrite) on this device */
 	if (ppos != &file->f_pos)
 		return -ESPIPE;
 
-	/*
-	 *	Refresh the timer.
-	 */
+	/* Refresh the timer. */
 	if (len) {
-		if (!nowayout) {
-			size_t i;
-
-			/* In case it was set long ago */
-			expect_close = 0;
- 
-			for (i = 0; i != len; i++) {
-				char c;
-				if (get_user(c, data + i))
-					return -EFAULT;
-				if (c == 'V')
-					expect_close = 1;
-			}
-		}
 		indydog_ping();
-		return 1;
 	}
-	return 0;
+	return len;
 }
 
 static int indydog_ioctl(struct inode *inode, struct file *file,
 	unsigned int cmd, unsigned long arg)
 {
+	int options, retval = -EINVAL;
 	static struct watchdog_info ident = {
-		options: WDIOF_MAGICCLOSE,
-		identity: "Hardware Watchdog for SGI IP22",
+		.options		= WDIOF_KEEPALIVEPING |
+					  WDIOF_MAGICCLOSE,
+		.firmware_version	= 0,
+		.identity		= "Hardware Watchdog for SGI IP22",
 	};
+
 	switch (cmd) {
 		default:
 			return -ENOIOCTLCMD;
 		case WDIOC_GETSUPPORT:
-			if(copy_to_user((struct watchdog_info *)arg, &ident, sizeof(ident)))
+			if (copy_to_user((struct watchdog_info *)arg,
+					 &ident, sizeof(ident)))
 				return -EFAULT;
 			return 0;
 		case WDIOC_GETSTATUS:
@@ -134,31 +134,53 @@
 		case WDIOC_KEEPALIVE:
 			indydog_ping();
 			return 0;
+		case WDIOC_GETTIMEOUT:
+			return put_user(WATCHDOG_TIMEOUT,(int *)arg);
+		case WDIOC_SETOPTIONS:
+		{
+			if (get_user(options, (int *)arg))
+				return -EFAULT;
+
+			if (options & WDIOS_DISABLECARD) {
+				indydog_stop();
+				retval = 0;
+			}
+
+			if (options & WDIOS_ENABLECARD) {
+				indydog_start();
+				retval = 0;
+			}
+
+			return retval;
+		}
 	}
 }
 
 static struct file_operations indydog_fops = {
-	owner:		THIS_MODULE,
-	write:		indydog_write,
-	ioctl:		indydog_ioctl,
-	open:		indydog_open,
-	release:	indydog_release,
+	.owner		= THIS_MODULE,
+	.write		= indydog_write,
+	.ioctl		= indydog_ioctl,
+	.open		= indydog_open,
+	.release	= indydog_release,
 };
 
 static struct miscdevice indydog_miscdev = {
-	minor:		WATCHDOG_MINOR,
-	name:		"watchdog",
-	fops:		&indydog_fops,
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &indydog_fops,
 };
 
-static const char banner[] __initdata = KERN_INFO "Hardware Watchdog Timer for SGI IP22: 0.2\n";
+static char banner[] __initdata =
+	KERN_INFO PFX "Hardware Watchdog Timer for SGI IP22: 0.3\n";
 
 static int __init watchdog_init(void)
 {
 	int ret = misc_register(&indydog_miscdev);
-
-	if (ret)
+	if (ret) {
+		printk(KERN_ERR PFX "cannot register miscdev on minor=%d (err=%d)\n",
+			WATCHDOG_MINOR, ret);
 		return ret;
+	}
 
 	printk(banner);
 
@@ -172,4 +194,7 @@
 
 module_init(watchdog_init);
 module_exit(watchdog_exit);
+
+MODULE_AUTHOR("Guido Guenther <agx@sigxcpu.org>");
+MODULE_DESCRIPTION("Hardware Watchdog Device for SGI IP22");
 MODULE_LICENSE("GPL");
diff -Nur linux-2.4.30/drivers/char/ip27-rtc.c linux-2.4.30-mips/drivers/char/ip27-rtc.c
--- linux-2.4.30/drivers/char/ip27-rtc.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/char/ip27-rtc.c	2004-04-06 03:35:30.000000000 +0200
@@ -44,6 +44,7 @@
 #include <asm/sn/klconfig.h>
 #include <asm/sn/sn0/ip27.h>
 #include <asm/sn/sn0/hub.h>
+#include <asm/sn/sn_private.h>
 
 static int rtc_ioctl(struct inode *inode, struct file *file,
 		     unsigned int cmd, unsigned long arg);
@@ -209,11 +210,8 @@
 
 static int __init rtc_init(void)
 {
-	nasid_t nid;
-
-	nid = get_nasid();
 	rtc = (struct m48t35_rtc *)
-	    (KL_CONFIG_CH_CONS_INFO(nid)->memory_base + IOC3_BYTEBUS_DEV0);
+	(KL_CONFIG_CH_CONS_INFO(master_nasid)->memory_base + IOC3_BYTEBUS_DEV0);
 
 	printk(KERN_INFO "Real Time Clock Driver v%s\n", RTC_VERSION);
 	if (misc_register(&rtc_dev)) {
@@ -325,3 +323,7 @@
 
 	rtc_tm->tm_mon--;
 }
+
+MODULE_AUTHOR("Ralf Baechle <ralf@linux-mips.org>");
+MODULE_DESCRIPTION("SGI IP27 M48T35 RTC driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.4.30/drivers/char/mips_rtc.c linux-2.4.30-mips/drivers/char/mips_rtc.c
--- linux-2.4.30/drivers/char/mips_rtc.c	2004-01-05 14:53:56.000000000 +0100
+++ linux-2.4.30-mips/drivers/char/mips_rtc.c	2004-06-28 14:54:53.000000000 +0200
@@ -53,14 +53,6 @@
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
-
-/*
- * Check machine
- */
-#if !defined(CONFIG_MIPS) || !defined(CONFIG_NEW_TIME_C)
-#error "This driver is for MIPS machines with CONFIG_NEW_TIME_C defined"
-#endif
-
 #include <asm/time.h>
 
 static unsigned long rtc_status = 0;	/* bitmapped status byte.       */
diff -Nur linux-2.4.30/drivers/char/sb1250_duart.c linux-2.4.30-mips/drivers/char/sb1250_duart.c
--- linux-2.4.30/drivers/char/sb1250_duart.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/char/sb1250_duart.c	2004-09-17 01:25:44.000000000 +0200
@@ -328,10 +328,11 @@
 		if (c <= 0) break;
 
 		if (from_user) {
+			spin_unlock_irqrestore(&us->outp_lock, flags);
 			if (copy_from_user(us->outp_buf + us->outp_tail, buf, c)) {
-				spin_unlock_irqrestore(&us->outp_lock, flags);
 				return -EFAULT;
 			}
+			spin_lock_irqsave(&us->outp_lock, flags);
 		} else {
 			memcpy(us->outp_buf + us->outp_tail, buf, c);
 		}
@@ -498,9 +499,31 @@
 	duart_set_cflag(us->line, tty->termios->c_cflag);
 }
 
+static int get_serial_info(uart_state_t *us, struct serial_struct * retinfo) {
+
+	struct serial_struct tmp;
+
+	memset(&tmp, 0, sizeof(tmp));
+
+	tmp.type=PORT_SB1250;
+	tmp.line=us->line;
+	tmp.port=A_DUART_CHANREG(tmp.line,0);
+	tmp.irq=K_INT_UART_0 + tmp.line;
+	tmp.xmit_fifo_size=16; /* fixed by hw */
+	tmp.baud_base=5000000;
+	tmp.io_type=SERIAL_IO_MEM;
+
+	if (copy_to_user(retinfo,&tmp,sizeof(*retinfo)))
+		return -EFAULT;
+
+	return 0;
+}
+
 static int duart_ioctl(struct tty_struct *tty, struct file * file,
 		       unsigned int cmd, unsigned long arg)
 {
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
 /*	if (serial_paranoia_check(info, tty->device, "rs_ioctl"))
 	return -ENODEV;*/
 	switch (cmd) {
@@ -517,7 +540,7 @@
 		printk("Ignoring TIOCMSET\n");
 		break;
 	case TIOCGSERIAL:
-		printk("Ignoring TIOCGSERIAL\n");
+		return get_serial_info(us,(struct serial_struct *) arg);
 		break;
 	case TIOCSSERIAL:
 		printk("Ignoring TIOCSSERIAL\n");
diff -Nur linux-2.4.30/drivers/char/serial.c linux-2.4.30-mips/drivers/char/serial.c
--- linux-2.4.30/drivers/char/serial.c	2005-01-19 15:09:50.000000000 +0100
+++ linux-2.4.30-mips/drivers/char/serial.c	2004-12-27 05:13:43.000000000 +0100
@@ -62,6 +62,12 @@
  *        Robert Schwebel <robert@schwebel.de>,
  *        Juergen Beisert <jbeisert@eurodsn.de>,
  *        Theodore Ts'o <tytso@mit.edu>
+ *
+ * 10/00: Added suport for MIPS Atlas board.
+ * 11/00: Hooks for serial kernel debug port support added.
+ *        Kevin D. Kissell, kevink@mips.com and Carsten Langgaard,
+ *        carstenl@mips.com
+ *        Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
  */
 
 static char *serial_version = "5.05c";
@@ -413,6 +419,22 @@
 	return 0;
 }
 
+#if defined(CONFIG_MIPS_ATLAS) || defined(CONFIG_MIPS_SEAD)
+
+#include <asm/mips-boards/atlas.h>
+
+static _INLINE_ unsigned int serial_in(struct async_struct *info, int offset)
+{
+        return (*(volatile unsigned int *)(mips_io_port_base + ATLAS_UART_REGS_BASE + offset*8) & 0xff);
+}
+
+static _INLINE_ void serial_out(struct async_struct *info, int offset, int value)
+{
+        *(volatile unsigned int *)(mips_io_port_base + ATLAS_UART_REGS_BASE + offset*8) = value;
+}
+
+#else
+
 static _INLINE_ unsigned int serial_in(struct async_struct *info, int offset)
 {
 	switch (info->io_type) {
@@ -447,6 +469,8 @@
 		outb(value, info->port+offset);
 	}
 }
+#endif
+
 
 /*
  * We used to support using pause I/O for certain machines.  We
diff -Nur linux-2.4.30/drivers/char/victor_mpc30x_keymap.map linux-2.4.30-mips/drivers/char/victor_mpc30x_keymap.map
--- linux-2.4.30/drivers/char/victor_mpc30x_keymap.map	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/char/victor_mpc30x_keymap.map	2004-02-05 18:04:42.000000000 +0100
@@ -0,0 +1,102 @@
+# Victor Interlink MP-C303/304 keyboard keymap
+#
+# Copyright (C) 2003  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+keymaps 0-1,4-5,8-9,12
+alt_is_meta
+strings as usual
+compose as usual for "iso-8859-1"
+
+# First line
+keycode 89 = Escape
+keycode  9 = Delete
+
+# 2nd line
+keycode 73 = one              exclam
+keycode 18 = two              quotedbl
+keycode 92 = three            numbersign
+	control	keycode 92 = Escape
+keycode 53 = four             dollar
+	control	keycode 53 = Control_backslash
+keycode 21 = five             percent
+	control	keycode 21 = Control_bracketright
+keycode 50 = six              ampersand
+	control	keycode 50 = Control_underscore
+keycode 48 = seven            apostrophe
+keycode 51 = eight            parenleft
+keycode 16 = nine             parenright
+keycode 80 = zero             asciitilde
+	control	keycode 80 = nul
+keycode 49 = minus            equal
+keycode 30 = asciicircum      asciitilde
+	control	keycode 30 = Control_asciicircum
+keycode  5 = backslash        bar
+	control	keycode  5 = Control_backslash
+keycode 13 = BackSpace
+# 3rd line
+keycode 57 = Tab
+keycode 74 = q
+keycode 26 = w
+keycode 81 = e
+keycode 29 = r
+keycode 37 = t
+keycode 45 = y
+keycode 72 = u
+keycode 24 = i
+keycode 32 = o
+keycode 41 = p
+keycode  1 = at               grave
+	control	keycode  1 = nul
+keycode 54 = bracketleft      braceleft
+keycode 63 = Return
+	alt	keycode 63 = Meta_Control_m
+# 4th line
+keycode 23 = Caps_Lock
+keycode 34 = a
+keycode 66 = s
+keycode 52 = d
+keycode 20 = f
+keycode 84 = g
+keycode 67 = h
+keycode 64 = j
+keycode 17 = k
+keycode 83 = l
+keycode 22 = semicolon        plus
+keycode 61 = colon            asterisk
+	control keycode 61 = Control_g
+keycode 65 = bracketright     braceright
+	control	keycode 65 = Control_bracketright
+# 5th line
+keycode 91 = Shift
+keycode 76 = z
+keycode 68 = x
+keycode 28 = c
+keycode 36 = v
+keycode 44 = b
+keycode 19 = n
+keycode 27 = m
+keycode 35 = comma            less
+keycode  3 = period           greater
+	control	keycode  3 = Compose
+keycode 38 = slash            question
+	control	keycode 38 = Delete
+	shift	control	keycode 38 = Delete
+keycode  6 = backslash        underscore
+	control	keycode  6 = Control_backslash
+keycode 55 = Up
+	alt keycode 55 = PageUp
+keycode 14 = Shift
+# 6th line
+keycode 56 = Control
+keycode 42 = Alt
+keycode 33 = space
+	control	keycode 33 = nul
+keycode  7 = Left
+	alt keycode  7 = Home
+keycode 31 = Down
+	alt keycode 31 = PageDown
+keycode 47 = Right
+	alt keycode 47 = End
diff -Nur linux-2.4.30/drivers/char/vr41xx_keyb.c linux-2.4.30-mips/drivers/char/vr41xx_keyb.c
--- linux-2.4.30/drivers/char/vr41xx_keyb.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/char/vr41xx_keyb.c	2004-02-17 13:08:55.000000000 +0100
@@ -308,7 +308,7 @@
 			if (found != 0) {
 				kiu_base = VRC4173_KIU_OFFSET;
 				mkiuintreg = VRC4173_MKIUINTREG_OFFSET;
-				vrc4173_clock_supply(VRC4173_KIU_CLOCK);
+				vrc4173_supply_clock(VRC4173_KIU_CLOCK);
 			}
 		}
 #endif
@@ -325,7 +325,7 @@
 
 	if (current_cpu_data.cputype == CPU_VR4111 ||
 	    current_cpu_data.cputype == CPU_VR4121)
-		vr41xx_clock_supply(KIU_CLOCK);
+		vr41xx_supply_clock(KIU_CLOCK);
 
 	kiu_writew(KIURST_KIURST, KIURST);
 
diff -Nur linux-2.4.30/drivers/i2c/Config.in linux-2.4.30-mips/drivers/i2c/Config.in
--- linux-2.4.30/drivers/i2c/Config.in	2004-04-14 15:05:29.000000000 +0200
+++ linux-2.4.30-mips/drivers/i2c/Config.in	2005-02-11 20:49:04.000000000 +0100
@@ -57,6 +57,10 @@
    if [ "$CONFIG_SGI_IP22" = "y" ]; then
       dep_tristate 'I2C SGI interfaces' CONFIG_I2C_ALGO_SGI $CONFIG_I2C
    fi
+
+   if [ "$CONFIG_SOC_AU1550" = "y" -o "$CONFIG_SOC_AU1200" ]; then
+      dep_tristate 'Au1550/Au1200 SMBus interface' CONFIG_I2C_ALGO_AU1550 $CONFIG_I2C
+   fi
  
 # This is needed for automatic patch generation: sensors code starts here
 # This is needed for automatic patch generation: sensors code ends here
diff -Nur linux-2.4.30/drivers/i2c/Makefile linux-2.4.30-mips/drivers/i2c/Makefile
--- linux-2.4.30/drivers/i2c/Makefile	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/i2c/Makefile	2005-02-11 20:49:04.000000000 +0100
@@ -6,7 +6,7 @@
 
 export-objs	:= i2c-core.o i2c-algo-bit.o i2c-algo-pcf.o \
 		   i2c-algo-ite.o i2c-algo-sibyte.o i2c-algo-sgi.o \
-		   i2c-proc.o
+		   i2c-algo-au1550.o i2c-proc.o i2c-au1550.o
 
 obj-$(CONFIG_I2C)		+= i2c-core.o
 obj-$(CONFIG_I2C_CHARDEV)	+= i2c-dev.o
@@ -25,6 +25,7 @@
 obj-$(CONFIG_I2C_ALGO_SIBYTE)	+= i2c-algo-sibyte.o i2c-sibyte.o
 obj-$(CONFIG_I2C_MAX1617)	+= i2c-max1617.o
 obj-$(CONFIG_I2C_ALGO_SGI)	+= i2c-algo-sgi.o
+obj-$(CONFIG_I2C_ALGO_AU1550)	+= i2c-algo-au1550.o i2c-au1550.o
 
 # This is needed for automatic patch generation: sensors code starts here
 # This is needed for automatic patch generation: sensors code ends here
diff -Nur linux-2.4.30/drivers/i2c/i2c-algo-au1550.c linux-2.4.30-mips/drivers/i2c/i2c-algo-au1550.c
--- linux-2.4.30/drivers/i2c/i2c-algo-au1550.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/i2c/i2c-algo-au1550.c	2005-02-11 20:49:04.000000000 +0100
@@ -0,0 +1,340 @@
+/*
+ * i2c-algo-au1550.c: SMBus (i2c) driver algorithms for Alchemy PSC interface
+ * Copyright (C) 2004 Embedded Edge, LLC <dan@embeddededge.com>
+ *
+ * The documentation describes this as an SMBus controller, but it doesn't
+ * understand any of the SMBus protocol in hardware.  It's really an I2C
+ * controller that could emulate most of the SMBus in software.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/au1000.h>
+#include <asm/au1xxx_psc.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-au1550.h>
+
+static int
+wait_xfer_done(struct i2c_algo_au1550_data *adap)
+{
+	u32	stat;
+	int	i;
+	volatile psc_smb_t	*sp;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	/* Wait for Tx FIFO Underflow.
+	*/
+	for (i = 0; i < adap->xfer_timeout; i++) {
+		stat = sp->psc_smbevnt;
+		au_sync();
+		if ((stat & PSC_SMBEVNT_TU) != 0) {
+			/* Clear it.  */
+			sp->psc_smbevnt = PSC_SMBEVNT_TU;
+			au_sync();
+			return 0;
+		}
+		udelay(1);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int
+wait_ack(struct i2c_algo_au1550_data *adap)
+{
+	u32	stat;
+	volatile psc_smb_t	*sp;
+
+	if (wait_xfer_done(adap))
+		return -ETIMEDOUT;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	stat = sp->psc_smbevnt;
+	au_sync();
+
+	if ((stat & (PSC_SMBEVNT_DN | PSC_SMBEVNT_AN | PSC_SMBEVNT_AL)) != 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int
+wait_master_done(struct i2c_algo_au1550_data *adap)
+{
+	u32	stat;
+	int	i;
+	volatile psc_smb_t	*sp;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	/* Wait for Master Done.
+	*/
+	for (i = 0; i < adap->xfer_timeout; i++) {
+		stat = sp->psc_smbevnt;
+		au_sync();
+		if ((stat & PSC_SMBEVNT_MD) != 0)
+			return 0;
+		udelay(1);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int
+do_address(struct i2c_algo_au1550_data *adap, unsigned int addr, int rd)
+{
+	volatile psc_smb_t	*sp;
+	u32			stat;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	/* Reset the FIFOs, clear events.
+	*/
+	sp->psc_smbpcr = PSC_SMBPCR_DC;
+	sp->psc_smbevnt = PSC_SMBEVNT_ALLCLR;
+	au_sync();
+	do {
+		stat = sp->psc_smbpcr;
+		au_sync();
+	} while ((stat & PSC_SMBPCR_DC) != 0);
+
+	/* Write out the i2c chip address and specify operation
+	*/
+	addr <<= 1;
+	if (rd)
+		addr |= 1;
+
+	/* Put byte into fifo, start up master.
+	*/
+	sp->psc_smbtxrx = addr;
+	au_sync();
+	sp->psc_smbpcr = PSC_SMBPCR_MS;
+	au_sync();
+	if (wait_ack(adap))
+		return -EIO;
+	return 0;
+}
+
+static u32
+wait_for_rx_byte(struct i2c_algo_au1550_data *adap, u32 *ret_data)
+{
+	int	j;
+	u32	data, stat;
+	volatile psc_smb_t	*sp;
+
+	if (wait_xfer_done(adap))
+		return -EIO;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	j =  adap->xfer_timeout * 100;
+	do {
+		j--;
+		if (j <= 0)
+			return -EIO;
+
+		stat = sp->psc_smbstat;
+		au_sync();
+		if ((stat & PSC_SMBSTAT_RE) == 0)
+			j = 0;
+		else
+			udelay(1);
+	} while (j > 0);
+	data = sp->psc_smbtxrx;
+	au_sync();
+	*ret_data = data;
+
+	return 0;
+}
+
+static int
+i2c_read(struct i2c_algo_au1550_data *adap, unsigned char *buf,
+		    unsigned int len)
+{
+	int	i;
+	u32	data;
+	volatile psc_smb_t	*sp;
+
+	if (len == 0)
+		return 0;
+
+	/* A read is performed by stuffing the transmit fifo with
+	 * zero bytes for timing, waiting for bytes to appear in the
+	 * receive fifo, then reading the bytes.
+	 */
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	i = 0;
+	while (i < (len-1)) {
+		sp->psc_smbtxrx = 0;
+		au_sync();
+		if (wait_for_rx_byte(adap, &data))
+			return -EIO;
+
+		buf[i] = data;
+		i++;
+	}
+
+	/* The last byte has to indicate transfer done.
+	*/
+	sp->psc_smbtxrx = PSC_SMBTXRX_STP;
+	au_sync();
+	if (wait_master_done(adap))
+		return -EIO;
+
+	data = sp->psc_smbtxrx;
+	au_sync();
+	buf[i] = data;
+	return 0;
+}
+
+static int
+i2c_write(struct i2c_algo_au1550_data *adap, unsigned char *buf,
+		     unsigned int len)
+{
+	int	i;
+	u32	data;
+	volatile psc_smb_t	*sp;
+
+	if (len == 0)
+		return 0;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	i = 0;
+	while (i < (len-1)) {
+		data = buf[i];
+		sp->psc_smbtxrx = data;
+		au_sync();
+		if (wait_ack(adap))
+			return -EIO;
+		i++;
+	}
+
+	/* The last byte has to indicate transfer done.
+	*/
+	data = buf[i];
+	data |= PSC_SMBTXRX_STP;
+	sp->psc_smbtxrx = data;
+	au_sync();
+	if (wait_master_done(adap))
+		return -EIO;
+	return 0;
+}
+
+static int
+au1550_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
+{
+	struct i2c_algo_au1550_data *adap = i2c_adap->algo_data;
+	struct i2c_msg *p;
+	int i, err = 0;
+
+	for (i = 0; !err && i < num; i++) {
+		p = &msgs[i];
+		err = do_address(adap, p->addr, p->flags & I2C_M_RD);
+		if (err || !p->len)
+			continue;
+		if (p->flags & I2C_M_RD)
+			err = i2c_read(adap, p->buf, p->len);
+		else
+			err = i2c_write(adap, p->buf, p->len);
+	}
+
+	/* Return the number of messages processed, or the error code.
+	*/
+	if (err == 0)
+		err = num;
+	return err;
+}
+
+static u32
+au1550_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm au1550_algo = {
+	.name		= "Au1550 algorithm",
+	.id		= I2C_ALGO_AU1550,
+	.master_xfer	= au1550_xfer,
+	.functionality	= au1550_func,
+};
+
+/* 
+ * registering functions to load algorithms at runtime 
+ * Prior to calling us, the 50MHz clock frequency and routing
+ * must have been set up for the PSC indicated by the adapter.
+ */
+int
+i2c_au1550_add_bus(struct i2c_adapter *i2c_adap)
+{
+	struct i2c_algo_au1550_data *adap = i2c_adap->algo_data;
+	volatile psc_smb_t	*sp;
+	u32	stat;
+
+	i2c_adap->algo = &au1550_algo;
+
+	/* Now, set up the PSC for SMBus PIO mode.
+	*/
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+	sp->psc_ctrl = PSC_CTRL_DISABLE;
+	au_sync();
+	sp->psc_sel = PSC_SEL_PS_SMBUSMODE;
+	sp->psc_smbcfg = 0;
+	au_sync();
+	sp->psc_ctrl = PSC_CTRL_ENABLE;
+	au_sync();
+	do {
+		stat = sp->psc_smbstat;
+		au_sync();
+	} while ((stat & PSC_SMBSTAT_SR) == 0);
+
+	sp->psc_smbcfg = (PSC_SMBCFG_RT_FIFO8 | PSC_SMBCFG_TT_FIFO8 |
+				PSC_SMBCFG_DD_DISABLE);
+
+	/* Divide by 8 to get a 6.25 MHz clock.  The later protocol
+	 * timings are based on this clock.
+	 */
+	sp->psc_smbcfg |= PSC_SMBCFG_SET_DIV(PSC_SMBCFG_DIV2);
+	sp->psc_smbmsk = PSC_SMBMSK_ALLMASK;
+	au_sync();
+
+	/* Set the protocol timer values.  See Table 71 in the
+	 * Au1550 Data Book for standard timing values.
+	 */
+	sp->psc_smbtmr = PSC_SMBTMR_SET_TH(2) | PSC_SMBTMR_SET_PS(15) | \
+		PSC_SMBTMR_SET_PU(11) | PSC_SMBTMR_SET_SH(11) | \
+		PSC_SMBTMR_SET_SU(11) | PSC_SMBTMR_SET_CL(15) | \
+		PSC_SMBTMR_SET_CH(11);
+	au_sync();
+
+	sp->psc_smbcfg |= PSC_SMBCFG_DE_ENABLE;
+	do {
+		stat = sp->psc_smbstat;
+		au_sync();
+	} while ((stat & PSC_SMBSTAT_DR) == 0);
+
+	return i2c_add_adapter(i2c_adap);
+}
+
+
+int
+i2c_au1550_del_bus(struct i2c_adapter *adap)
+{
+	return i2c_del_adapter(adap);
+}
+
+EXPORT_SYMBOL(i2c_au1550_add_bus);
+EXPORT_SYMBOL(i2c_au1550_del_bus);
+
+MODULE_AUTHOR("Dan Malek <dan@embeddededge.com>");
+MODULE_DESCRIPTION("SMBus Au1550 algorithm");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.4.30/drivers/i2c/i2c-au1550.c linux-2.4.30-mips/drivers/i2c/i2c-au1550.c
--- linux-2.4.30/drivers/i2c/i2c-au1550.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/i2c/i2c-au1550.c	2005-02-11 20:49:04.000000000 +0100
@@ -0,0 +1,154 @@
+/*
+ * i2c-au1550.c: SMBus (i2c) adapter for Alchemy PSC interface
+ * Copyright (C) 2004 Embedded Edge, LLC <dan@embeddededge.com>
+ *
+ * This is just a skeleton adapter to use with the Au1550 PSC
+ * algorithm.  It was developed for the Pb1550, but will work with
+ * any Au1550 board that has a similar PSC configuration.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+
+#include <asm/au1000.h>
+#include <asm/au1xxx_psc.h>
+#if defined( CONFIG_MIPS_PB1550 )
+	#include <asm/pb1550.h>
+#endif
+#if defined( CONFIG_MIPS_PB1200 )
+	#include <asm/pb1200.h>
+#endif
+#if defined( CONFIG_MIPS_DB1200 )
+	#include <asm/db1200.h>
+#endif
+#if defined( CONFIG_MIPS_FICMMP )
+	#include <asm/ficmmp.h>
+#endif
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-au1550.h>
+
+
+
+static int
+pb1550_reg(struct i2c_client *client)
+{
+	return 0;
+}
+
+static int
+pb1550_unreg(struct i2c_client *client)
+{
+	return 0;
+}
+
+static void
+pb1550_inc_use(struct i2c_adapter *adap)
+{
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+}
+
+static void
+pb1550_dec_use(struct i2c_adapter *adap)
+{
+#ifdef MODULE
+	MOD_DEC_USE_COUNT;
+#endif
+}
+
+static struct i2c_algo_au1550_data pb1550_i2c_info = {
+	SMBUS_PSC_BASE, 200, 200
+};
+
+static struct i2c_adapter pb1550_board_adapter = {
+	name:              "pb1550 adapter",
+	id:                I2C_HW_AU1550_PSC,
+	algo:              NULL,
+	algo_data:         &pb1550_i2c_info,
+	inc_use:           pb1550_inc_use,
+	dec_use:           pb1550_dec_use,
+	client_register:   pb1550_reg,
+	client_unregister: pb1550_unreg,
+	client_count:      0,
+};
+
+int __init
+i2c_pb1550_init(void)
+{
+	/* This is where we would set up a 50MHz clock source
+	 * and routing.  On the Pb1550, the SMBus is PSC2, which
+	 * uses a shared clock with USB.  This has been already
+	 * configured by Yamon as a 48MHz clock, close enough
+	 * for our work.
+	 */
+        if (i2c_au1550_add_bus(&pb1550_board_adapter) < 0)
+                return -ENODEV;
+
+	return 0;
+}
+
+/* BIG hack to support the control interface on the Wolfson WM8731
+ * audio codec on the Pb1550 board.  We get an address and two data
+ * bytes to write, create an i2c message, and send it across the
+ * i2c transfer function.  We do this here because we have access to
+ * the i2c adapter structure.
+ */
+static struct i2c_msg wm_i2c_msg;  /* We don't want this stuff on the stack */
+static	u8 i2cbuf[2];
+
+int
+pb1550_wm_codec_write(u8 addr, u8 reg, u8 val)
+{
+	wm_i2c_msg.addr = addr;
+	wm_i2c_msg.flags = 0;
+	wm_i2c_msg.buf = i2cbuf;
+	wm_i2c_msg.len = 2;
+	i2cbuf[0] = reg;
+	i2cbuf[1] = val;
+
+	return pb1550_board_adapter.algo->master_xfer(&pb1550_board_adapter, &wm_i2c_msg, 1);
+}
+
+/* the next function is needed by DVB driver. */
+int pb1550_i2c_xfer(struct i2c_msg msgs[], int num)
+{
+    return pb1550_board_adapter.algo->master_xfer(&pb1550_board_adapter, msgs, num);
+}
+
+EXPORT_SYMBOL(pb1550_wm_codec_write);
+EXPORT_SYMBOL(pb1550_i2c_xfer);
+
+MODULE_AUTHOR("Dan Malek, Embedded Edge, LLC.");
+MODULE_DESCRIPTION("SMBus adapter Alchemy pb1550");
+MODULE_LICENSE("GPL");
+
+int
+init_module(void)
+{
+	return i2c_pb1550_init();
+}
+
+void
+cleanup_module(void)
+{
+	i2c_au1550_del_bus(&pb1550_board_adapter);
+}
diff -Nur linux-2.4.30/drivers/i2c/i2c-core.c linux-2.4.30-mips/drivers/i2c/i2c-core.c
--- linux-2.4.30/drivers/i2c/i2c-core.c	2005-01-19 15:09:54.000000000 +0100
+++ linux-2.4.30-mips/drivers/i2c/i2c-core.c	2004-11-29 18:47:16.000000000 +0100
@@ -1280,6 +1280,9 @@
 #ifdef CONFIG_I2C_MAX1617
 	extern int i2c_max1617_init(void);
 #endif
+#ifdef CONFIG_I2C_ALGO_AU1550
+	extern int i2c_pb1550_init(void);
+#endif
 
 #ifdef CONFIG_I2C_PROC
 	extern int sensors_init(void);
@@ -1335,6 +1338,10 @@
 	i2c_max1617_init();
 #endif
 
+#ifdef CONFIG_I2C_ALGO_AU1550
+	i2c_pb1550_init();
+#endif
+
 	/* -------------- proc interface ---- */
 #ifdef CONFIG_I2C_PROC
 	sensors_init();
diff -Nur linux-2.4.30/drivers/media/video/indycam.c linux-2.4.30-mips/drivers/media/video/indycam.c
--- linux-2.4.30/drivers/media/video/indycam.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/media/video/indycam.c	2004-12-09 21:32:05.000000000 +0100
@@ -50,13 +50,14 @@
 		0x80,			/* INDYCAM_GAMMA */
 	};
 
-	int err = 0;
 	struct indycam *camera;
 	struct i2c_client *client;
+	int err = 0;
 
 	client = kmalloc(sizeof(*client), GFP_KERNEL);
-	if (!client) 
+	if (!client)
 		return -ENOMEM;
+
 	camera = kmalloc(sizeof(*camera), GFP_KERNEL);
 	if (!camera) {
 		err = -ENOMEM;
@@ -67,7 +68,7 @@
 	client->adapter = adap;
 	client->addr = addr;
 	client->driver = &i2c_driver_indycam;
-	strcpy(client->name, "IndyCam client");			
+	strcpy(client->name, "IndyCam client");
 	camera->client = client;
 
 	err = i2c_attach_client(client);
@@ -75,18 +76,18 @@
 		goto out_free_camera;
 
 	camera->version = i2c_smbus_read_byte_data(client, INDYCAM_VERSION);
-	if (camera->version != CAMERA_VERSION_INDY &&
-	    camera->version != CAMERA_VERSION_MOOSE) {
+	if ((camera->version != CAMERA_VERSION_INDY) &&
+	    (camera->version != CAMERA_VERSION_MOOSE)) {
 		err = -ENODEV;
 		goto out_detach_client;
 	}
-	printk(KERN_INFO "Indycam v%d.%d detected.\n",
+	printk(KERN_INFO "IndyCam v%d.%d detected.\n",
 	       INDYCAM_VERSION_MAJOR(camera->version),
 	       INDYCAM_VERSION_MINOR(camera->version));
 
 	err = i2c_master_send(client, initseq, sizeof(initseq));
 	if (err)
-		printk(KERN_INFO "IndyCam initalization failed\n");
+		printk(KERN_ERR "IndyCam initalization failed.\n");
 
 	MOD_INC_USE_COUNT;
 	return 0;
diff -Nur linux-2.4.30/drivers/media/video/vino.c linux-2.4.30-mips/drivers/media/video/vino.c
--- linux-2.4.30/drivers/media/video/vino.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/media/video/vino.c	2004-12-10 05:02:54.000000000 +0100
@@ -5,6 +5,8 @@
  * License version 2 as published by the Free Software Foundation.
  *
  * Copyright (C) 2003 Ladislav Michl <ladis@linux-mips.org>
+ * Copyright (C) 2004 Mikael Nousiainen <tmnousia@cc.hut.fi>
+ * 
  */
 
 #include <linux/module.h>
@@ -37,13 +39,23 @@
 #define DEBUG(x...)
 #endif
 
+/* Channels (who could have guessed) */
+#define VINO_CHAN_NONE		0
+#define VINO_CHAN_A		1
+#define VINO_CHAN_B		2
+
 /* VINO video size */
 #define VINO_PAL_WIDTH		768
 #define VINO_PAL_HEIGHT		576
 #define VINO_NTSC_WIDTH		646
 #define VINO_NTSC_HEIGHT	486
 
-/* set this to some sensible values. note: VINO_MIN_WIDTH has to be 8*x */
+/* Minimum value for Y-clipping (for smaller values the images
+ * will be corrupted) */
+#define VINO_MIN_Y_CLIPPING	2
+ 
+/* Set these to some sensible values.
+ * Note: the picture width has to be divisible by 8 */
 #define VINO_MIN_WIDTH		32
 #define VINO_MIN_HEIGHT		32
 
@@ -64,9 +76,7 @@
 
 struct vino_device {
 	struct video_device vdev;
-#define VINO_CHAN_A	1
-#define VINO_CHAN_B	2
-	int chan;
+	int chan;	/* VINO_CHAN_NONE, VINO_CHAN_A or VINO_CHAN_B */
 	int alpha;
 	/* clipping... */
 	unsigned int left, right, top, bottom;
@@ -106,7 +116,7 @@
 
 struct vino_client {
 	struct i2c_client *driver;
-	int owner;
+	int owner;	/* VINO_CHAN_NONE, VINO_CHAN_A or VINO_CHAN_B */
 };
 
 struct vino_video {
@@ -362,6 +372,7 @@
 static int dma_setup(struct vino_device *v)
 {
 	u32 ctrl, intr;
+	int ofs;
 	struct sgi_vino_channel *ch;
 
 	ch = (v->chan == VINO_CHAN_A) ? &vino->a : &vino->b;
@@ -377,14 +388,24 @@
 	ch->line_size = v->line_size - 8;
 	/* set the alpha register */
 	ch->alpha = v->alpha;
-	/* set cliping registers */
-	ch->clip_start = VINO_CLIP_ODD(v->top) | VINO_CLIP_EVEN(v->top+1) |
+	/* Set the clipping registers, this is the constant source of fun :)
+	 * Y clipping start has to be >= 2 and end has to be start + height/2
+	 * The values of top and bottom are even so dividing is not a problem
+	 *
+	 * The docs say that clipping values for the even field should be
+	 * odd_end + something_to_skip_vertical_blanking + some_lines and
+	 * even_start + height/2, though the image is good this way also
+	 *
+	 * TODO: for analog sources (SAA7191), the clipping values are a bit
+	 * different and that case isn't yet handled
+	 */
+	ofs = VINO_MIN_Y_CLIPPING;	/* Should depend on input source */
+	ch->clip_start = VINO_CLIP_ODD(ofs + v->top / 2) |
+			 VINO_CLIP_EVEN(ofs + v->top / 2 + 1) |
 			 VINO_CLIP_X(v->left);
-	ch->clip_end = VINO_CLIP_ODD(v->bottom) | VINO_CLIP_EVEN(v->bottom+1) |
+	ch->clip_end = VINO_CLIP_ODD(ofs + v->bottom / 2 - 1) |
+		       VINO_CLIP_EVEN(ofs + v->bottom / 2) |
 		       VINO_CLIP_X(v->right);
-	/* FIXME: end-of-field bug workaround
-		       VINO_CLIP_X(VINO_PAL_WIDTH);
-	 */
 	/* init the frame rate and norm (full frame rate only for now...) */
 	ch->frame_rate = VINO_FRAMERT_RT(0x1fff) |
 			 (get_capture_norm(v) == VIDEO_MODE_PAL ?
@@ -510,6 +531,7 @@
 static void vino_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	u32 intr, ctrl;
+	int a_eof, b_eof;
 
 	spin_lock(&Vino->vino_lock);
 	ctrl = vino->control;
@@ -525,12 +547,14 @@
 		vino->control = ctrl;
 		clear_eod(&Vino->chB);
 	}
+	a_eof = intr & VINO_INTSTAT_A_EOF;
+	b_eof = intr & VINO_INTSTAT_B_EOF;
 	vino->intr_status = ~intr;
 	spin_unlock(&Vino->vino_lock);
-	/* FIXME: For now we are assuming that interrupt means that frame is
-	 * done. That's not true, but we can live with such brokeness for
-	 * a while ;-) */
-	field_done(&Vino->chA);
+	if (a_eof)
+		field_done(&Vino->chA);
+	if (b_eof)
+		field_done(&Vino->chB);
 }
 
 static int vino_grab(struct vino_device *v, int frame)
diff -Nur linux-2.4.30/drivers/mtd/devices/docprobe.c linux-2.4.30-mips/drivers/mtd/devices/docprobe.c
--- linux-2.4.30/drivers/mtd/devices/docprobe.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.30-mips/drivers/mtd/devices/docprobe.c	2003-06-16 01:42:21.000000000 +0200
@@ -89,10 +89,10 @@
 	0xe4000000,
 #elif defined(CONFIG_MOMENCO_OCELOT)
 	0x2f000000,
-        0xff000000,
+	0xff000000,
 #elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
-        0xff000000,
-##else
+	0xff000000,
+#else
 #warning Unknown architecture for DiskOnChip. No default probe locations defined
 #endif
 	0 };
diff -Nur linux-2.4.30/drivers/mtd/devices/ms02-nv.c linux-2.4.30-mips/drivers/mtd/devices/ms02-nv.c
--- linux-2.4.30/drivers/mtd/devices/ms02-nv.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.30-mips/drivers/mtd/devices/ms02-nv.c	2004-07-30 12:22:40.000000000 +0200
@@ -1,10 +1,10 @@
 /*
- *      Copyright (c) 2001 Maciej W. Rozycki
+ *	Copyright (c) 2001 Maciej W. Rozycki
  *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
  *
  *	$Id: ms02-nv.c,v 1.2 2003/01/24 14:05:17 dwmw2 Exp $
  */
@@ -29,18 +29,18 @@
 
 
 static char version[] __initdata =
-        "ms02-nv.c: v.1.0.0  13 Aug 2001  Maciej W. Rozycki.\n";
+	"ms02-nv.c: v.1.0.0  13 Aug 2001  Maciej W. Rozycki.\n";
 
-MODULE_AUTHOR("Maciej W. Rozycki <macro@ds2.pg.gda.pl>");
+MODULE_AUTHOR("Maciej W. Rozycki <macro@linux-mips.org>");
 MODULE_DESCRIPTION("DEC MS02-NV NVRAM module driver");
 MODULE_LICENSE("GPL");
 
 
 /*
  * Addresses we probe for an MS02-NV at.  Modules may be located
- * at any 8MB boundary within a 0MB up to 112MB range or at any 32MB
- * boundary within a 0MB up to 448MB range.  We don't support a module
- * at 0MB, though.
+ * at any 8MiB boundary within a 0MiB up to 112MiB range or at any 32MiB
+ * boundary within a 0MiB up to 448MiB range.  We don't support a module
+ * at 0MiB, though.
  */
 static ulong ms02nv_addrs[] __initdata = {
 	0x07000000, 0x06800000, 0x06000000, 0x05800000, 0x05000000,
@@ -130,7 +130,7 @@
 
 	int ret = -ENODEV;
 
-	/* The module decodes 8MB of address space. */
+	/* The module decodes 8MiB of address space. */
 	mod_res = kmalloc(sizeof(*mod_res), GFP_KERNEL);
 	if (!mod_res)
 		return -ENOMEM;
@@ -233,7 +233,7 @@
 		goto err_out_csr_res;
 	}
 
-	printk(KERN_INFO "mtd%d: %s at 0x%08lx, size %uMB.\n",
+	printk(KERN_INFO "mtd%d: %s at 0x%08lx, size %uMiB.\n",
 		mtd->index, ms02nv_name, addr, size >> 20);
 
 	mp->next = root_ms02nv_mtd;
@@ -293,12 +293,12 @@
 
 	switch (mips_machtype) {
 	case MACH_DS5000_200:
-		csr = (volatile u32 *)KN02_CSR_ADDR;
+		csr = (volatile u32 *)KN02_CSR_BASE;
 		if (*csr & KN02_CSR_BNK32M)
 			stride = 2;
 		break;
 	case MACH_DS5000_2X0:
-	case MACH_DS5000:
+	case MACH_DS5900:
 		csr = (volatile u32 *)KN03_MCR_BASE;
 		if (*csr & KN03_MCR_BNK32M)
 			stride = 2;
diff -Nur linux-2.4.30/drivers/mtd/devices/ms02-nv.h linux-2.4.30-mips/drivers/mtd/devices/ms02-nv.h
--- linux-2.4.30/drivers/mtd/devices/ms02-nv.h	2002-11-29 00:53:13.000000000 +0100
+++ linux-2.4.30-mips/drivers/mtd/devices/ms02-nv.h	2004-07-30 12:22:40.000000000 +0200
@@ -1,32 +1,96 @@
 /*
- *      Copyright (c) 2001 Maciej W. Rozycki
+ *	Copyright (c) 2001, 2003  Maciej W. Rozycki
  *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
+ *	DEC MS02-NV (54-20948-01) battery backed-up NVRAM module for
+ *	DECstation/DECsystem 5000/2x0 and DECsystem 5900 and 5900/260
+ *	systems.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	$Id: ms02-nv.h,v 1.3 2003/08/19 09:25:36 dwmw2 Exp $
  */
 
 #include <linux/ioport.h>
 #include <linux/mtd/mtd.h>
 
+/*
+ * Addresses are decoded as follows:
+ *
+ * 0x000000 - 0x3fffff	SRAM
+ * 0x400000 - 0x7fffff	CSR
+ *
+ * Within the SRAM area the following ranges are forced by the system
+ * firmware:
+ *
+ * 0x000000 - 0x0003ff	diagnostic area, destroyed upon a reboot
+ * 0x000400 - ENDofRAM	storage area, available to operating systems
+ *
+ * but we can't really use the available area right from 0x000400 as
+ * the first word is used by the firmware as a status flag passed
+ * from an operating system.  If anything but the valid data magic
+ * ID value is found, the firmware considers the SRAM clean, i.e.
+ * containing no valid data, and disables the battery resulting in
+ * data being erased as soon as power is switched off.  So the choice
+ * for the start address of the user-available is 0x001000 which is
+ * nicely page aligned.  The area between 0x000404 and 0x000fff may
+ * be used by the driver for own needs.
+ *
+ * The diagnostic area defines two status words to be read by an
+ * operating system, a magic ID to distinguish a MS02-NV board from
+ * anything else and a status information providing results of tests
+ * as well as the size of SRAM available, which can be 1MiB or 2MiB
+ * (that's what the firmware handles; no idea if 2MiB modules ever
+ * existed).
+ *
+ * The firmware only handles the MS02-NV board if installed in the
+ * last (15th) slot, so for any other location the status information
+ * stored in the SRAM cannot be relied upon.  But from the hardware
+ * point of view there is no problem using up to 14 such boards in a
+ * system -- only the 1st slot needs to be filled with a DRAM module.
+ * The MS02-NV board is ECC-protected, like other MS02 memory boards.
+ *
+ * The state of the battery as provided by the CSR is reflected on
+ * the two onboard LEDs.  When facing the battery side of the board,
+ * with the LEDs at the top left and the battery at the bottom right
+ * (i.e. looking from the back side of the system box), their meaning
+ * is as follows (the system has to be powered on):
+ *
+ * left LED		battery disable status: lit = enabled
+ * right LED		battery condition status: lit = OK
+ */
+
 /* MS02-NV iomem register offsets. */
 #define MS02NV_CSR		0x400000	/* control & status register */
 
+/* MS02-NV CSR status bits. */
+#define MS02NV_CSR_BATT_OK	0x01		/* battery OK */
+#define MS02NV_CSR_BATT_OFF	0x02		/* battery disabled */
+
+
 /* MS02-NV memory offsets. */
 #define MS02NV_DIAG		0x0003f8	/* diagnostic status */
 #define MS02NV_MAGIC		0x0003fc	/* MS02-NV magic ID */
-#define MS02NV_RAM		0x000400	/* general-purpose RAM start */
+#define MS02NV_VALID		0x000400	/* valid data magic ID */
+#define MS02NV_RAM		0x001000	/* user-exposed RAM start */
 
-/* MS02-NV diagnostic status constants. */
-#define MS02NV_DIAG_SIZE_MASK	0xf0		/* RAM size mask */
-#define MS02NV_DIAG_SIZE_SHIFT	0x10		/* RAM size shift (left) */
+/* MS02-NV diagnostic status bits. */
+#define MS02NV_DIAG_TEST	0x01		/* SRAM test done (?) */
+#define MS02NV_DIAG_RO		0x02		/* SRAM r/o test done */
+#define MS02NV_DIAG_RW		0x04		/* SRAM r/w test done */
+#define MS02NV_DIAG_FAIL	0x08		/* SRAM test failed */
+#define MS02NV_DIAG_SIZE_MASK	0xf0		/* SRAM size mask */
+#define MS02NV_DIAG_SIZE_SHIFT	0x10		/* SRAM size shift (left) */
 
 /* MS02-NV general constants. */
 #define MS02NV_ID		0x03021966	/* MS02-NV magic ID value */
+#define MS02NV_VALID_ID		0xbd100248	/* valid data magic ID value */
 #define MS02NV_SLOT_SIZE	0x800000	/* size of the address space
 						   decoded by the module */
 
+
 typedef volatile u32 ms02nv_uint;
 
 struct ms02nv_private {
diff -Nur linux-2.4.30/drivers/mtd/maps/Config.in linux-2.4.30-mips/drivers/mtd/maps/Config.in
--- linux-2.4.30/drivers/mtd/maps/Config.in	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.30-mips/drivers/mtd/maps/Config.in	2004-02-26 01:46:35.000000000 +0100
@@ -51,11 +51,26 @@
    dep_tristate '  Pb1000 MTD support' CONFIG_MTD_PB1000 $CONFIG_MIPS_PB1000
    dep_tristate '  Pb1500 MTD support' CONFIG_MTD_PB1500 $CONFIG_MIPS_PB1500
    dep_tristate '  Pb1100 MTD support' CONFIG_MTD_PB1100 $CONFIG_MIPS_PB1100
+   dep_tristate '  Bosporus MTD support' CONFIG_MTD_BOSPORUS $CONFIG_MIPS_BOSPORUS
+   dep_tristate '  XXS1500 boot flash device' CONFIG_MTD_XXS1500 $CONFIG_MIPS_XXS1500
+   dep_tristate '  MTX-1 flash device' CONFIG_MTD_MTX1 $CONFIG_MIPS_MTX1
    if [ "$CONFIG_MTD_PB1500" = "y" -o "$CONFIG_MTD_PB1500" = "m" \
 	-o "$CONFIG_MTD_PB1100" = "y" -o "$CONFIG_MTD_PB1100" = "m" ]; then
       bool '  Pb[15]00 boot flash device' CONFIG_MTD_PB1500_BOOT 
       bool '  Pb[15]00 user flash device (2nd 32MiB bank)' CONFIG_MTD_PB1500_USER
    fi
+   tristate '  Db1x00 MTD support' CONFIG_MTD_DB1X00
+   if [ "$CONFIG_MTD_DB1X00" = "y" -o "$CONFIG_MTD_DB1X00" = "m" ]; then
+      bool '  Db1x00 boot flash device' CONFIG_MTD_DB1X00_BOOT 
+      bool '  Db1x00 user flash device (2nd bank)' CONFIG_MTD_DB1X00_USER
+   fi
+   tristate '  Pb1550 MTD support' CONFIG_MTD_PB1550
+   if [ "$CONFIG_MTD_PB1550" = "y" -o "$CONFIG_MTD_PB1550" = "m" ]; then
+      bool '  Pb1550 Boot Flash' CONFIG_MTD_PB1550_BOOT
+      bool '  Pb1550 User Parameter Flash' CONFIG_MTD_PB1550_USER
+   fi
+   dep_tristate '  Hydrogen 3 MTD support' CONFIG_MTD_HYDROGEN3 $CONFIG_MIPS_HYDROGEN3
+   dep_tristate '  Mirage MTD support' CONFIG_MTD_MIRAGE $CONFIG_MIPS_MIRAGE
    dep_tristate '  Flash chip mapping on ITE QED-4N-S01B, Globespan IVR or custom board' CONFIG_MTD_CSTM_MIPS_IXX $CONFIG_MTD_CFI $CONFIG_MTD_JEDEC $CONFIG_MTD_PARTITIONS 
    if [ "$CONFIG_MTD_CSTM_MIPS_IXX" = "y" -o "$CONFIG_MTD_CSTM_MIPS_IXX" = "m" ]; then
       hex '    Physical start address of flash mapping' CONFIG_MTD_CSTM_MIPS_IXX_START 0x8000000
diff -Nur linux-2.4.30/drivers/mtd/maps/Makefile linux-2.4.30-mips/drivers/mtd/maps/Makefile
--- linux-2.4.30/drivers/mtd/maps/Makefile	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.30-mips/drivers/mtd/maps/Makefile	2004-02-26 01:46:35.000000000 +0100
@@ -52,7 +52,13 @@
 obj-$(CONFIG_MTD_PB1000)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_PB1100)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_PB1500)	+= pb1xxx-flash.o
+obj-$(CONFIG_MTD_XXS1500)       += xxs1500.o
+obj-$(CONFIG_MTD_MTX1)		+= mtx-1.o
 obj-$(CONFIG_MTD_LASAT)		+= lasat.o
+obj-$(CONFIG_MTD_DB1X00)        += db1x00-flash.o
+obj-$(CONFIG_MTD_PB1550)        += pb1550-flash.o
+obj-$(CONFIG_MTD_HYDROGEN3)     += hydrogen3-flash.o
+obj-$(CONFIG_MTD_BOSPORUS)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_EDB7312)	+= edb7312.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
@@ -61,5 +67,6 @@
 obj-$(CONFIG_MTD_UCLINUX)	+= uclinux.o
 obj-$(CONFIG_MTD_NETtel)	+= nettel.o
 obj-$(CONFIG_MTD_SCB2_FLASH)	+= scb2_flash.o
+obj-$(CONFIG_MTD_MIRAGE)        += mirage-flash.o
 
 include $(TOPDIR)/Rules.make
diff -Nur linux-2.4.30/drivers/mtd/maps/db1x00-flash.c linux-2.4.30-mips/drivers/mtd/maps/db1x00-flash.c
--- linux-2.4.30/drivers/mtd/maps/db1x00-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/mtd/maps/db1x00-flash.c	2005-02-03 07:35:29.000000000 +0100
@@ -0,0 +1,283 @@
+/*
+ * Flash memory access on Alchemy Db1xxx boards
+ * 
+ * (C) 2003 Pete Popov <ppopov@pacbell.net>
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+#include <asm/db1x00.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+static unsigned long window_addr;
+static unsigned long window_size;
+static unsigned long flash_size;
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+static struct map_info db1x00_map = {
+	name:		"Db1x00 flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+static unsigned char flash_buswidth = 4;
+
+/* 
+ * The Db1x boards support different flash densities. We setup
+ * the mtd_partition structures below for default of 64Mbit 
+ * flash densities, and override the partitions sizes, if
+ * necessary, after we check the board status register.
+ */
+
+#ifdef DB1X00_BOTH_BANKS
+/* both banks will be used. Combine the first bank and the first 
+ * part of the second bank together into a single jffs/jffs2
+ * partition.
+ */
+static struct mtd_partition db1x00_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x1c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000-0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#elif defined(DB1X00_BOOT_ONLY)
+static struct mtd_partition db1x00_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x00c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000-0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#elif defined(DB1X00_USER_ONLY)
+static struct mtd_partition db1x00_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x0e00000,
+                offset: 0x0000000
+        },{
+                name: "raw kernel",
+		size: MTDPART_SIZ_FULL,
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#else
+#error MTD_DB1X00 define combo error /* should never happen */
+#endif
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+/*
+ * Probe the flash density and setup window address and size
+ * based on user CONFIG options. There are times when we don't
+ * want the MTD driver to be probing the boot or user flash,
+ * so having the option to enable only one bank is important.
+ */
+int setup_flash_params()
+{
+	switch ((bcsr->status >> 14) & 0x3) {
+		case 0: /* 64Mbit devices */
+			flash_size = 0x800000; /* 8MB per part */
+#if defined(DB1X00_BOTH_BANKS)
+			window_addr = 0x1E000000;
+			window_size = 0x2000000; 
+#elif defined(DB1X00_BOOT_ONLY)
+			window_addr = 0x1F000000;
+			window_size = 0x1000000; 
+#else /* USER ONLY */
+			window_addr = 0x1E000000;
+			window_size = 0x1000000; 
+#endif
+			break;
+		case 1:
+			/* 128 Mbit devices */
+			flash_size = 0x1000000; /* 16MB per part */
+#if defined(DB1X00_BOTH_BANKS)
+			window_addr = 0x1C000000;
+			window_size = 0x4000000;
+			/* USERFS from 0x1C00 0000 to 0x1FC0 0000 */
+			db1x00_partitions[0].size = 0x3C00000;
+#elif defined(DB1X00_BOOT_ONLY)
+			window_addr = 0x1E000000;
+			window_size = 0x2000000;
+			/* USERFS from 0x1E00 0000 to 0x1FC0 0000 */
+			db1x00_partitions[0].size = 0x1C00000;
+#else /* USER ONLY */
+			window_addr = 0x1C000000;
+			window_size = 0x2000000;
+			/* USERFS from 0x1C00 0000 to 0x1DE00000 */
+			db1x00_partitions[0].size = 0x1DE0000;
+#endif
+			break;
+		case 2:
+			/* 256 Mbit devices */
+			flash_size = 0x4000000; /* 64MB per part */
+#if defined(DB1X00_BOTH_BANKS)
+			return 1;
+#elif defined(DB1X00_BOOT_ONLY)
+			/* Boot ROM flash bank only; no user bank */
+			window_addr = 0x1C000000;
+			window_size = 0x4000000;
+			/* USERFS from 0x1C00 0000 to 0x1FC00000 */
+			db1x00_partitions[0].size = 0x3C00000;
+#else /* USER ONLY */
+			return 1;
+#endif
+			break;
+		default:
+			return 1;
+	}
+	return 0;
+}
+
+int __init db1x00_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	db1x00_map.buswidth = flash_buswidth;
+
+	if (setup_flash_params()) 
+		return -ENXIO;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = db1x00_partitions;
+	nb_parts = NB_OF(db1x00_partitions);
+	db1x00_map.size = window_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "Db1xxx flash: probing %d-bit flash bus\n", 
+			db1x00_map.buswidth*8);
+	db1x00_map.map_priv_1 = 
+		(unsigned long)ioremap(window_addr, window_size);
+	mymtd = do_map_probe("cfi_probe", &db1x00_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit db1x00_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(db1x00_mtd_init);
+module_exit(db1x00_mtd_cleanup);
+
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("Db1x00 mtd map driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.4.30/drivers/mtd/maps/hydrogen3-flash.c linux-2.4.30-mips/drivers/mtd/maps/hydrogen3-flash.c
--- linux-2.4.30/drivers/mtd/maps/hydrogen3-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/mtd/maps/hydrogen3-flash.c	2004-01-10 23:40:18.000000000 +0100
@@ -0,0 +1,189 @@
+/*
+ * Flash memory access on Alchemy HydrogenIII boards
+ * 
+ * (C) 2003 Pete Popov <ppopov@pacbell.net>
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+#define WINDOW_ADDR 0x1E000000
+#define WINDOW_SIZE 0x02000000
+
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+static struct map_info hydrogen3_map = {
+	name:		"HydrogenIII flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+static unsigned char flash_buswidth = 4;
+
+/* MTDPART_OFS_APPEND is vastly preferred to any attempt at statically lining
+ * up the offsets. */
+static struct mtd_partition hydrogen3_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x1c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+                size: 0x02c0000,
+                offset: MTDPART_OFS_APPEND
+        }
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init hydrogen3_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	hydrogen3_map.buswidth = flash_buswidth;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = hydrogen3_partitions;
+	nb_parts = NB_OF(hydrogen3_partitions);
+	hydrogen3_map.size = WINDOW_SIZE;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "HydrogenIII flash: probing %d-bit flash bus\n", 
+			hydrogen3_map.buswidth*8);
+	hydrogen3_map.map_priv_1 = 
+		(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	mymtd = do_map_probe("cfi_probe", &hydrogen3_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit hydrogen3_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+/*#ifndef MODULE
+
+static int __init _bootflashonly(char *str)
+{
+  bootflashonly = simple_strtol(str, NULL, 0);
+  return 1;
+}
+
+
+__setup("bootflashonly=", _bootflashonly);
+
+#endif*/
+
+
+module_init(hydrogen3_mtd_init);
+module_exit(hydrogen3_mtd_cleanup);
+
+MODULE_PARM(bootflashonly, "i");
+MODULE_PARM_DESC(bootflashonly, "1=use \"boot flash only\"");
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("HydrogenIII mtd map driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.4.30/drivers/mtd/maps/lasat.c linux-2.4.30-mips/drivers/mtd/maps/lasat.c
--- linux-2.4.30/drivers/mtd/maps/lasat.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.30-mips/drivers/mtd/maps/lasat.c	2003-08-18 04:59:02.000000000 +0200
@@ -1,15 +1,6 @@
 /*
  * Flash device on lasat 100 and 200 boards
  *
- * Presumably (C) 2002 Brian Murphy <brian@murphy.dk> or whoever he
- * works for.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * $Id: lasat.c,v 1.1 2003/01/24 14:26:38 dwmw2 Exp $
- *
  */
 
 #include <linux/module.h>
@@ -21,7 +12,6 @@
 #include <linux/mtd/partitions.h>
 #include <linux/config.h>
 #include <asm/lasat/lasat.h>
-#include <asm/lasat/lasat_mtd.h>
 
 static struct mtd_info *mymtd;
 
@@ -69,30 +59,33 @@
 }
 
 static struct map_info sp_map = {
-	.name = "SP flash",
-	.buswidth = 4,
-	.read8 = sp_read8,
-	.read16 = sp_read16,
-	.read32 = sp_read32,
-	.copy_from = sp_copy_from,
-	.write8 = sp_write8,
-	.write16 = sp_write16,
-	.write32 = sp_write32,
-	.copy_to = sp_copy_to
+	name: "SP flash",
+	buswidth: 4,
+	read8: sp_read8,
+	read16: sp_read16,
+	read32: sp_read32,
+	copy_from: sp_copy_from,
+	write8: sp_write8,
+	write16: sp_write16,
+	write32: sp_write32,
+	copy_to: sp_copy_to
 };
 
 static struct mtd_partition partition_info[LASAT_MTD_LAST];
-static char *lasat_mtd_partnames[] = {"Bootloader", "Service", "Normal", "Filesystem", "Config"};
+static char *lasat_mtd_partnames[] = {"Bootloader", "Service", "Normal", "Config", "Filesystem"};
 
 static int __init init_sp(void)
 {
 	int i;
+	int nparts = 0;
 	/* this does not play well with the old flash code which 
 	 * protects and uprotects the flash when necessary */
        	printk(KERN_NOTICE "Unprotecting flash\n");
 	*lasat_misc->flash_wp_reg |= 1 << lasat_misc->flash_wp_bit;
 
-	sp_map.map_priv_1 = lasat_flash_partition_start(LASAT_MTD_BOOTLOADER);
+	sp_map.map_priv_1 = ioremap_nocache(
+		lasat_flash_partition_start(LASAT_MTD_BOOTLOADER),
+		lasat_board_info.li_flash_size);
 	sp_map.size = lasat_board_info.li_flash_size;
 
        	printk(KERN_NOTICE "sp flash device: %lx at %lx\n", 
@@ -109,12 +102,15 @@
 
 		for (i=0; i < LASAT_MTD_LAST; i++) {
 			size = lasat_flash_partition_size(i);
-			partition_info[i].size = size;
-			partition_info[i].offset = offset;
-			offset += size;
+			if (size != 0) {
+				nparts++;
+				partition_info[i].size = size;
+				partition_info[i].offset = offset;
+				offset += size;
+			}
 		}
 
-		add_mtd_partitions( mymtd, partition_info, LASAT_MTD_LAST );
+		add_mtd_partitions( mymtd, partition_info, nparts );
 		return 0;
 	}
 
@@ -124,11 +120,11 @@
 static void __exit cleanup_sp(void)
 {
 	if (mymtd) {
-		del_mtd_partitions(mymtd);
-		map_destroy(mymtd);
+	  del_mtd_partitions(mymtd);
+	  map_destroy(mymtd);
 	}
 	if (sp_map.map_priv_1) {
-		sp_map.map_priv_1 = 0;
+	  sp_map.map_priv_1 = 0;
 	}
 }
 
diff -Nur linux-2.4.30/drivers/mtd/maps/mirage-flash.c linux-2.4.30-mips/drivers/mtd/maps/mirage-flash.c
--- linux-2.4.30/drivers/mtd/maps/mirage-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/mtd/maps/mirage-flash.c	2003-12-22 04:37:22.000000000 +0100
@@ -0,0 +1,194 @@
+/*
+ * Flash memory access on AMD Mirage board.
+ * 
+ * (C) 2003 Embedded Edge
+ * based on mirage-flash.c:
+ * (C) 2003 Pete Popov <ppopov@pacbell.net>
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+//#include <asm/mirage.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+static unsigned long window_addr;
+static unsigned long window_size;
+static unsigned long flash_size;
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+static struct map_info mirage_map = {
+	name:		"Mirage flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+static unsigned char flash_buswidth = 4;
+
+static struct mtd_partition mirage_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x1c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000-0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+/*
+ * Probe the flash density and setup window address and size
+ * based on user CONFIG options. There are times when we don't
+ * want the MTD driver to be probing the boot or user flash,
+ * so having the option to enable only one bank is important.
+ */
+int setup_flash_params()
+{
+	flash_size = 0x4000000; /* 64MB per part */
+	/* Boot ROM flash bank only; no user bank */
+	window_addr = 0x1C000000;
+	window_size = 0x4000000;
+	/* USERFS from 0x1C00 0000 to 0x1FC00000 */
+	mirage_partitions[0].size = 0x3C00000;
+	return 0;
+}
+
+int __init mirage_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	mirage_map.buswidth = flash_buswidth;
+
+	if (setup_flash_params()) 
+		return -ENXIO;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = mirage_partitions;
+	nb_parts = NB_OF(mirage_partitions);
+	mirage_map.size = window_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "Mirage flash: probing %d-bit flash bus\n", 
+			mirage_map.buswidth*8);
+	mirage_map.map_priv_1 = 
+		(unsigned long)ioremap(window_addr, window_size);
+	mymtd = do_map_probe("cfi_probe", &mirage_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit mirage_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(mirage_mtd_init);
+module_exit(mirage_mtd_cleanup);
+
+MODULE_AUTHOR("Embedded Edge");
+MODULE_DESCRIPTION("Mirage mtd map driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.4.30/drivers/mtd/maps/mtx-1.c linux-2.4.30-mips/drivers/mtd/maps/mtx-1.c
--- linux-2.4.30/drivers/mtd/maps/mtx-1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/mtd/maps/mtx-1.c	2003-06-27 02:04:35.000000000 +0200
@@ -0,0 +1,181 @@
+/*
+ * Flash memory access on 4G Systems MTX-1 board
+ * 
+ * (C) 2003 Pete Popov <ppopov@mvista.com>
+ *	    Bruno Randolf <bruno.randolf@4g-systems.de>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+#ifdef CONFIG_MIPS_MTX1
+#define WINDOW_ADDR 0x1E000000
+#define WINDOW_SIZE 0x2000000
+#endif
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+
+
+static struct map_info mtx1_map = {
+	name:		"MTX-1 flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+
+static unsigned long flash_size = 0x01000000;
+static unsigned char flash_buswidth = 4;
+static struct mtd_partition mtx1_partitions[] = {
+        {
+                name: "user fs",
+                size: 0x1c00000,
+                offset: 0,
+        },{
+                name: "yamon",
+                size: 0x0100000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+                size: 0x02c0000,
+                offset: MTDPART_OFS_APPEND,
+        },{
+                name: "yamon env vars",
+                size: 0x0040000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        }
+};
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init mtx1_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	mtx1_map.buswidth = flash_buswidth;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = mtx1_partitions;
+	nb_parts = NB_OF(mtx1_partitions);
+	mtx1_map.size = flash_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "MTX-1 flash: probing %d-bit flash bus\n",
+			mtx1_map.buswidth*8);
+	mtx1_map.map_priv_1 =
+		(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	mymtd = do_map_probe("cfi_probe", &mtx1_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit mtx1_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(mtx1_mtd_init);
+module_exit(mtx1_mtd_cleanup);
+
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("MTX-1 CFI map driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.4.30/drivers/mtd/maps/pb1550-flash.c linux-2.4.30-mips/drivers/mtd/maps/pb1550-flash.c
--- linux-2.4.30/drivers/mtd/maps/pb1550-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/mtd/maps/pb1550-flash.c	2004-02-26 01:48:48.000000000 +0100
@@ -0,0 +1,270 @@
+/*
+ * Flash memory access on Alchemy Pb1550 board
+ * 
+ * (C) 2004 Embedded Edge, LLC, based on pb1550-flash.c:
+ * (C) 2003 Pete Popov <ppopov@pacbell.net>
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+#include <asm/pb1550.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+static unsigned long window_addr;
+static unsigned long window_size;
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+static struct map_info pb1550_map = {
+	name:		"Pb1550 flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+static unsigned char flash_buswidth = 4;
+
+/* 
+ * Support only 64MB NOR Flash parts
+ */
+
+#ifdef PB1550_BOTH_BANKS
+/* both banks will be used. Combine the first bank and the first 
+ * part of the second bank together into a single jffs/jffs2
+ * partition.
+ */
+static struct mtd_partition pb1550_partitions[] = {
+	/* assume boot[2:0]:swap is '0000' or '1000', which translates to:
+	 * 1C00 0000 1FFF FFFF CE0 64MB Boot NOR Flash
+	 * 1800 0000 1BFF FFFF CE0 64MB Param NOR Flash
+	 */
+        {
+                name: "User FS",
+                size:   (0x1FC00000 - 0x18000000),
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000 - 0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#elif defined(PB1550_BOOT_ONLY)
+static struct mtd_partition pb1550_partitions[] = {
+	/* assume boot[2:0]:swap is '0000' or '1000', which translates to:
+	 * 1C00 0000 1FFF FFFF CE0 64MB Boot NOR Flash
+	 */
+        {
+                name: "User FS",
+                size:   0x03c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000-0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#elif defined(PB1550_USER_ONLY)
+static struct mtd_partition pb1550_partitions[] = {
+	/* assume boot[2:0]:swap is '0000' or '1000', which translates to:
+	 * 1800 0000 1BFF FFFF CE0 64MB Param NOR Flash
+	 */
+        {
+                name: "User FS",
+                size:  (0x4000000 - 0x200000), /* reserve 2MB for raw kernel */
+                offset: 0x0000000
+        },{
+                name: "raw kernel",
+		size: MTDPART_SIZ_FULL,
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#else
+#error MTD_PB1550 define combo error /* should never happen */
+#endif
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+/*
+ * Probe the flash density and setup window address and size
+ * based on user CONFIG options. There are times when we don't
+ * want the MTD driver to be probing the boot or user flash,
+ * so having the option to enable only one bank is important.
+ */
+int setup_flash_params()
+{
+	u16 boot_swapboot;
+	boot_swapboot = (au_readl(MEM_STSTAT) & (0x7<<1)) | 
+		((bcsr->status >> 6)  & 0x1);
+	printk("Pb1550 MTD: boot:swap %d\n", boot_swapboot);
+
+	switch (boot_swapboot) {
+		case 0: /* 512Mbit devices, both enabled */
+		case 1: 
+		case 8:
+		case 9: 
+#if defined(PB1550_BOTH_BANKS)
+			window_addr = 0x18000000;
+			window_size = 0x8000000; 
+#elif defined(PB1550_BOOT_ONLY)
+			window_addr = 0x1C000000;
+			window_size = 0x4000000; 
+#else /* USER ONLY */
+			window_addr = 0x1E000000;
+			window_size = 0x1000000; 
+#endif
+			break;
+		case 0xC:
+		case 0xD:
+		case 0xE:
+		case 0xF: 
+			/* 64 MB Boot NOR Flash is disabled */
+			/* and the start address is moved to 0x0C00000 */
+			window_addr = 0x0C000000;
+			window_size = 0x4000000; 
+		default:
+			printk("Pb1550 MTD: unsupported boot:swap setting\n");
+			return 1;
+	}
+	return 0;
+}
+
+int __init pb1550_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	pb1550_map.buswidth = flash_buswidth;
+
+	if (setup_flash_params()) 
+		return -ENXIO;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = pb1550_partitions;
+	nb_parts = NB_OF(pb1550_partitions);
+	pb1550_map.size = window_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "Pb1550 flash: probing %d-bit flash bus\n", 
+			pb1550_map.buswidth*8);
+	pb1550_map.map_priv_1 = 
+		(unsigned long)ioremap(window_addr, window_size);
+	mymtd = do_map_probe("cfi_probe", &pb1550_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit pb1550_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(pb1550_mtd_init);
+module_exit(pb1550_mtd_cleanup);
+
+MODULE_AUTHOR("Embedded Edge, LLC");
+MODULE_DESCRIPTION("Pb1550 mtd map driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.4.30/drivers/mtd/maps/pb1xxx-flash.c linux-2.4.30-mips/drivers/mtd/maps/pb1xxx-flash.c
--- linux-2.4.30/drivers/mtd/maps/pb1xxx-flash.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.30-mips/drivers/mtd/maps/pb1xxx-flash.c	2003-05-19 08:27:22.000000000 +0200
@@ -192,6 +192,34 @@
 #else
 #error MTD_PB1500 define combo error /* should never happen */
 #endif
+#elif defined(CONFIG_MTD_BOSPORUS)
+static unsigned char flash_buswidth = 2;
+static unsigned long flash_size 	= 0x02000000;
+#define WINDOW_ADDR 0x1F000000
+#define WINDOW_SIZE 0x2000000
+static struct mtd_partition pb1xxx_partitions[] = {
+        {
+                name:   "User FS",
+                size:   0x00400000,
+                offset: 0x00000000,
+        },{
+                name:   "Yamon-2",
+                size:   0x00100000,
+                offset: 0x00400000,
+        },{
+                name:   "Root FS",
+                size:   0x00700000,
+                offset: 0x00500000,
+        },{
+                name:   "Yamon-1",
+                size:   0x00100000,
+                offset: 0x00C00000,
+        },{
+                name:   "Kernel",
+                size:   0x00300000,
+                offset: 0x00D00000,
+        }
+};
 #else
 #error Unsupported board
 #endif
diff -Nur linux-2.4.30/drivers/mtd/maps/xxs1500.c linux-2.4.30-mips/drivers/mtd/maps/xxs1500.c
--- linux-2.4.30/drivers/mtd/maps/xxs1500.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/mtd/maps/xxs1500.c	2003-08-02 04:06:01.000000000 +0200
@@ -0,0 +1,186 @@
+/*
+ * Flash memory access on MyCable XXS1500 board
+ * 
+ * (C) 2003 Pete Popov <ppopov@mvista.com>
+ * 
+ * $Id: xxs1500.c,v 1.1.2.2 2003/08/02 02:06:01 ppopov Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+#ifdef CONFIG_MIPS_XXS1500
+#define WINDOW_ADDR 0x1F000000
+#define WINDOW_SIZE 0x1000000
+#endif
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+
+
+static struct map_info xxs1500_map = {
+	name:		"XXS1500 flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+
+static unsigned long flash_size = 0x00800000;
+static unsigned char flash_buswidth = 4;
+static struct mtd_partition xxs1500_partitions[] = {
+        {
+                name: "kernel image",
+                size: 0x00200000,
+                offset: 0,
+        },{
+                name: "user fs 0",
+                size: (0x00C00000-0x200000),
+                offset: MTDPART_OFS_APPEND,
+        },{
+                name: "yamon",
+                size: 0x00100000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "user fs 1",
+                size: 0x2c0000,
+                offset: MTDPART_OFS_APPEND,
+        },{
+                name: "yamon env vars",
+                size: 0x040000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        }
+};
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init xxs1500_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	xxs1500_map.buswidth = flash_buswidth;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = xxs1500_partitions;
+	nb_parts = NB_OF(xxs1500_partitions);
+	xxs1500_map.size = flash_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "XXS1500 flash: probing %d-bit flash bus\n", 
+			xxs1500_map.buswidth*8);
+	xxs1500_map.map_priv_1 = 
+		(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	mymtd = do_map_probe("cfi_probe", &xxs1500_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit xxs1500_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(xxs1500_mtd_init);
+module_exit(xxs1500_mtd_cleanup);
+
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("XXS1500 CFI map driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.4.30/drivers/net/defxx.c linux-2.4.30-mips/drivers/net/defxx.c
--- linux-2.4.30/drivers/net/defxx.c	2004-11-17 12:54:21.000000000 +0100
+++ linux-2.4.30-mips/drivers/net/defxx.c	2004-11-19 01:28:39.000000000 +0100
@@ -10,24 +10,18 @@
  *
  * Abstract:
  *   A Linux device driver supporting the Digital Equipment Corporation
- *   FDDI EISA and PCI controller families.  Supported adapters include:
+ *   FDDI TURBOchannel, EISA and PCI controller families.  Supported
+ *   adapters include:
  *
- *		DEC FDDIcontroller/EISA (DEFEA)
- *		DEC FDDIcontroller/PCI  (DEFPA)
+ *		DEC FDDIcontroller/TURBOchannel (DEFTA)
+ *		DEC FDDIcontroller/EISA         (DEFEA)
+ *		DEC FDDIcontroller/PCI          (DEFPA)
  *
- * Maintainers:
- *   LVS	Lawrence V. Stefani
- *
- * Contact:
- *	 The author may be reached at:
+ * The original author:
+ *   LVS	Lawrence V. Stefani <lstefani@yahoo.com>
  *
- *		Inet: stefani@lkg.dec.com
- *		(NOTE! this address no longer works -jgarzik)
- *
- *		Mail: Digital Equipment Corporation
- *			  550 King Street
- *			  M/S: LKG1-3/M07
- *			  Littleton, MA  01460
+ * Maintainers:
+ *   macro	Maciej W. Rozycki <macro@linux-mips.org>
  *
  * Credits:
  *   I'd like to thank Patricia Cross for helping me get started with
@@ -197,16 +191,16 @@
  *		Sep 2000	tjeerd		Fix leak on unload, cosmetic code cleanup
  *		Feb 2001			Skb allocation fixes
  *		Feb 2001	davej		PCI enable cleanups.
+ *		04 Aug 2003	macro		Converted to the DMA API.
+ *		14 Aug 2004	macro		Fix device names reported.
+ *		26 Sep 2004	macro		TURBOchannel support.
  */
 
 /* Include files */
 
 #include <linux/module.h>
-
 #include <linux/kernel.h>
-#include <linux/sched.h>
 #include <linux/string.h>
-#include <linux/ptrace.h>
 #include <linux/errno.h>
 #include <linux/ioport.h>
 #include <linux/slab.h>
@@ -215,19 +209,33 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/netdevice.h>
+#include <linux/fddidevice.h>
+#include <linux/skbuff.h>
+
 #include <asm/byteorder.h>
 #include <asm/bitops.h>
 #include <asm/io.h>
 
-#include <linux/fddidevice.h>
-#include <linux/skbuff.h>
+#ifdef CONFIG_TC
+#include <asm/dec/tc.h>
+#else
+static int search_tc_card(const char *name) { return -ENODEV; }
+static void claim_tc_card(int slot) { }
+static void release_tc_card(int slot) { }
+static unsigned long get_tc_base_addr(int slot) { return 0; }
+static unsigned long get_tc_irq_nr(int slot) { return -1; }
+#endif
 
 #include "defxx.h"
 
-/* Version information string - should be updated prior to each new release!!! */
+/* Version information string should be updated prior to each new release!  */
+#define DRV_NAME "defxx"
+#define DRV_VERSION "v1.07T"
+#define DRV_RELDATE "2004/09/26"
 
 static char version[] __devinitdata =
-	"defxx.c:v1.05e 2001/02/03  Lawrence V. Stefani and others\n";
+	DRV_NAME ": " DRV_VERSION " " DRV_RELDATE
+	"  Lawrence V. Stefani and others\n";
 
 #define DYNAMIC_BUFFERS 1
 
@@ -243,7 +251,7 @@
 static void		dfx_bus_init(struct net_device *dev);
 static void		dfx_bus_config_check(DFX_board_t *bp);
 
-static int		dfx_driver_init(struct net_device *dev);
+static int		dfx_driver_init(struct net_device *dev, const char *print_name);
 static int		dfx_adap_init(DFX_board_t *bp, int get_buffers);
 
 static int		dfx_open(struct net_device *dev);
@@ -337,48 +345,84 @@
 	int			offset,
 	u8			data
 	)
+{
+	if (bp->bus_type == DFX_BUS_TYPE_TC)
+	{
+	volatile u8 *addr = (void *)(bp->base_addr + offset);
 
+	*addr = data;
+	mb();
+	}
+	else
 	{
 	u16 port = bp->base_addr + offset;
 
 	outb(data, port);
 	}
+}
 
 static inline void dfx_port_read_byte(
 	DFX_board_t	*bp,
 	int			offset,
 	u8			*data
 	)
+{
+	if (bp->bus_type == DFX_BUS_TYPE_TC)
+	{
+	volatile u8 *addr = (void *)(bp->base_addr + offset);
 
+	mb();
+	*data = *addr;
+	}
+	else
 	{
 	u16 port = bp->base_addr + offset;
 
 	*data = inb(port);
 	}
+}
 
 static inline void dfx_port_write_long(
 	DFX_board_t	*bp,
 	int			offset,
 	u32			data
 	)
+{
+	if (bp->bus_type == DFX_BUS_TYPE_TC)
+	{
+	volatile u32 *addr = (void *)(bp->base_addr + offset);
 
+	*addr = data;
+	mb();
+	}
+	else
 	{
 	u16 port = bp->base_addr + offset;
 
 	outl(data, port);
 	}
+}
 
 static inline void dfx_port_read_long(
 	DFX_board_t	*bp,
 	int			offset,
 	u32			*data
 	)
+{
+	if (bp->bus_type == DFX_BUS_TYPE_TC)
+	{
+	volatile u32 *addr = (void *)(bp->base_addr + offset);
 
+	mb();
+	*data = *addr;
+	}
+	else
 	{
 	u16 port = bp->base_addr + offset;
 
 	*data = inl(port);
 	}
+}
 
 
 /*
@@ -393,8 +437,9 @@
  *   Condition code
  *       
  * Arguments:
- *   pdev - pointer to pci device information (NULL for EISA)
- *   ioaddr - pointer to port (NULL for PCI)
+ *   pdev - pointer to pci device information (NULL for EISA or TURBOchannel)
+ *   bus_type - bus type (one of DFX_BUS_TYPE_*)
+ *   handle - bus-specific data: slot (TC), pointer to port (EISA), NULL (PCI)
  *
  * Functional Description:
  *
@@ -410,54 +455,68 @@
  *   initialized and the board resources are read and stored in
  *   the device structure.
  */
-static int __devinit dfx_init_one_pci_or_eisa(struct pci_dev *pdev, long ioaddr)
+static int __devinit dfx_init_one_pci_or_eisa(struct pci_dev *pdev, u32 bus_type, long handle)
 {
+	static int version_disp;
+	char *print_name = DRV_NAME;
 	struct net_device *dev;
 	DFX_board_t	  *bp;			/* board pointer */
+	long ioaddr;				/* pointer to port */
+	unsigned long len;			/* resource length */
+	int alloc_size;				/* total buffer size used */
 	int err;
 
-#ifndef MODULE
-	static int version_disp;
-
-	if (!version_disp)	/* display version info if adapter is found */
-	{
+	if (!version_disp) {	/* display version info if adapter is found */
 		version_disp = 1;	/* set display flag to TRUE so that */
 		printk(version);	/* we only display this string ONCE */
 	}
-#endif
 
-	/*
-	 * init_fddidev() allocates a device structure with private data, clears the device structure and private data,
-	 * and  calls fddi_setup() and register_netdev(). Not much left to do for us here.
-	 */
-	dev = init_fddidev(NULL, sizeof(*bp));
+	if (pdev != NULL)
+		print_name = pdev->slot_name;
+
+	dev = alloc_fddidev(sizeof(*bp));
 	if (!dev) {
-		printk (KERN_ERR "defxx: unable to allocate fddidev, aborting\n");
+		printk(KERN_ERR "%s: unable to allocate fddidev, aborting\n",
+		       print_name);
 		return -ENOMEM;
 	}
 
 	/* Enable PCI device. */
-	if (pdev != NULL) {
+	if (bus_type == DFX_BUS_TYPE_PCI) {
 		err = pci_enable_device (pdev);
 		if (err) goto err_out;
 		ioaddr = pci_resource_start (pdev, 1);
 	}
 
 	SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, &pdev->dev);
 
 	bp = dev->priv;
 
-	if (!request_region (ioaddr, pdev ? PFI_K_CSR_IO_LEN : PI_ESIC_K_CSR_IO_LEN, dev->name)) {
-		printk (KERN_ERR "%s: Cannot reserve I/O resource 0x%x @ 0x%lx, aborting\n",
-			dev->name, PFI_K_CSR_IO_LEN, ioaddr);
+	if (bus_type == DFX_BUS_TYPE_TC) {
+		/* TURBOchannel board */
+		bp->slot = handle;
+		claim_tc_card(bp->slot);
+		ioaddr = get_tc_base_addr(handle) + PI_TC_K_CSR_OFFSET;
+		len = PI_TC_K_CSR_LEN;
+	} else if (bus_type == DFX_BUS_TYPE_EISA) {
+		/* EISA board */
+		ioaddr = handle;
+		len = PI_ESIC_K_CSR_IO_LEN;
+	} else
+		/* PCI board */
+		len = PFI_K_CSR_IO_LEN;
+	dev->base_addr			= ioaddr; /* save port (I/O) base address */
+
+	if (!request_region(ioaddr, len, print_name)) {
+		printk(KERN_ERR "%s: Cannot reserve I/O resource "
+		       "0x%lx @ 0x%lx, aborting\n", print_name, len, ioaddr);
 		err = -EBUSY;
 		goto err_out;
 	}
 
 	/* Initialize new device structure */
 
-	dev->base_addr			= ioaddr; /* save port (I/O) base address */
-
 	dev->get_stats			= dfx_ctl_get_stats;
 	dev->open			= dfx_open;
 	dev->stop			= dfx_close;
@@ -465,37 +524,54 @@
 	dev->set_multicast_list		= dfx_ctl_set_multicast_list;
 	dev->set_mac_address		= dfx_ctl_set_mac_address;
 
-	if (pdev == NULL) {
-		/* EISA board */
-		bp->bus_type = DFX_BUS_TYPE_EISA;
+	bp->bus_type = bus_type;
+	if (bus_type == DFX_BUS_TYPE_TC || bus_type == DFX_BUS_TYPE_EISA) {
+		/* TURBOchannel or EISA board */
 		bp->next = root_dfx_eisa_dev;
 		root_dfx_eisa_dev = dev;
 	} else {
 		/* PCI board */
-		bp->bus_type = DFX_BUS_TYPE_PCI;
 		bp->pci_dev = pdev;
 		pci_set_drvdata (pdev, dev);
 		pci_set_master (pdev);
 	}
 
-	if (dfx_driver_init(dev) != DFX_K_SUCCESS) {
+
+	if (dfx_driver_init(dev, print_name) != DFX_K_SUCCESS) {
 		err = -ENODEV;
 		goto err_out_region;
 	}
 
+	err = register_netdev(dev);
+	if (err)
+		goto err_out_kfree;
+
+	printk("%s: registered as %s\n", print_name, dev->name);
 	return 0;
 
+err_out_kfree:
+	alloc_size = sizeof(PI_DESCR_BLOCK) +
+		     PI_CMD_REQ_K_SIZE_MAX + PI_CMD_RSP_K_SIZE_MAX +
+#ifndef DYNAMIC_BUFFERS
+		     (bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX) +
+#endif
+		     sizeof(PI_CONSUMER_BLOCK) +
+		     (PI_ALIGN_K_DESC_BLK - 1);
+	if (bp->kmalloced)
+		pci_free_consistent(pdev, alloc_size,
+				    bp->kmalloced, bp->kmalloced_dma);
 err_out_region:
-	release_region(ioaddr, pdev ? PFI_K_CSR_IO_LEN : PI_ESIC_K_CSR_IO_LEN);
+	release_region(ioaddr, len);
 err_out:
-	unregister_netdev(dev);
-	kfree(dev);
+	if (bp->bus_type == DFX_BUS_TYPE_TC)
+		release_tc_card(bp->slot);
+	free_netdev(dev);
 	return err;
 }
 
 static int __devinit dfx_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	return dfx_init_one_pci_or_eisa(pdev, 0);
+	return dfx_init_one_pci_or_eisa(pdev, DFX_BUS_TYPE_PCI, 0);
 }
 
 static int __init dfx_eisa_init(void)
@@ -507,6 +583,7 @@
 
 	DBG_printk("In dfx_eisa_init...\n");
 
+#ifdef CONFIG_EISA
 	/* Scan for FDDI EISA controllers */
 
 	for (i=0; i < DFX_MAX_EISA_SLOTS; i++)		/* only scan for up to 16 EISA slots */
@@ -517,9 +594,27 @@
 		{
 			port = (i << 12);					/* recalc base addr */
 
-			if (dfx_init_one_pci_or_eisa(NULL, port) == 0) rc = 0;
+			if (dfx_init_one_pci_or_eisa(NULL, DFX_BUS_TYPE_EISA, port) == 0) rc = 0;
 		}
 	}
+#endif
+	return rc;
+}
+
+static int __init dfx_tc_init(void)
+{
+	int rc = -ENODEV;
+	int slot;		/* TC slot number */
+
+	DBG_printk("In dfx_tc_init...\n");
+
+	/* Scan for FDDI TC controllers */
+	while ((slot = search_tc_card("PMAF-F")) >= 0) {
+		if (dfx_init_one_pci_or_eisa(NULL, DFX_BUS_TYPE_TC, slot) == 0)
+			rc = 0;
+		else
+			break;
+	}
 	return rc;
 }
 
@@ -583,8 +678,9 @@
 
 	/* Initialize adapter based on bus type */
 
-	if (bp->bus_type == DFX_BUS_TYPE_EISA)
-		{
+	if (bp->bus_type == DFX_BUS_TYPE_TC) {
+		dev->irq = get_tc_irq_nr(bp->slot);
+	} else if (bp->bus_type == DFX_BUS_TYPE_EISA) {
 		/* Get the interrupt level from the ESIC chip */
 
 		dfx_port_read_byte(bp, PI_ESIC_K_IO_CONFIG_STAT_0, &val);
@@ -766,6 +862,7 @@
  *       
  * Arguments:
  *   dev - pointer to device information
+ *   print_name - printable device name
  *
  * Functional Description:
  *   This function allocates additional resources such as the host memory
@@ -780,20 +877,21 @@
  *						or read adapter MAC address
  *
  * Assumptions:
- *   Memory allocated from kmalloc() call is physically contiguous, locked
- *   memory whose physical address equals its virtual address.
+ *   Memory allocated from pci_alloc_consistent() call is physically
+ *   contiguous, locked memory.
  *
  * Side Effects:
  *   Adapter is reset and should be in DMA_UNAVAILABLE state before
  *   returning from this routine.
  */
 
-static int __devinit dfx_driver_init(struct net_device *dev)
+static int __devinit dfx_driver_init(struct net_device *dev,
+				     const char *print_name)
 {
 	DFX_board_t *bp = dev->priv;
 	int			alloc_size;			/* total buffer size needed */
 	char		*top_v, *curr_v;	/* virtual addrs into memory block */
-	u32			top_p, curr_p;		/* physical addrs into memory block */
+	dma_addr_t		top_p, curr_p;		/* physical addrs into memory block */
 	u32			data;				/* host data register value */
 
 	DBG_printk("In dfx_driver_init...\n");
@@ -837,26 +935,20 @@
 
 	/*  Read the factory MAC address from the adapter then save it */
 
-	if (dfx_hw_port_ctrl_req(bp,
-							PI_PCTRL_M_MLA,
-							PI_PDATA_A_MLA_K_LO,
-							0,
-							&data) != DFX_K_SUCCESS)
-		{
-		printk("%s: Could not read adapter factory MAC address!\n", dev->name);
+	if (dfx_hw_port_ctrl_req(bp, PI_PCTRL_M_MLA, PI_PDATA_A_MLA_K_LO, 0,
+				 &data) != DFX_K_SUCCESS) {
+		printk("%s: Could not read adapter factory MAC address!\n",
+		       print_name);
 		return(DFX_K_FAILURE);
-		}
+	}
 	memcpy(&bp->factory_mac_addr[0], &data, sizeof(u32));
 
-	if (dfx_hw_port_ctrl_req(bp,
-							PI_PCTRL_M_MLA,
-							PI_PDATA_A_MLA_K_HI,
-							0,
-							&data) != DFX_K_SUCCESS)
-		{
-		printk("%s: Could not read adapter factory MAC address!\n", dev->name);
+	if (dfx_hw_port_ctrl_req(bp, PI_PCTRL_M_MLA, PI_PDATA_A_MLA_K_HI, 0,
+				 &data) != DFX_K_SUCCESS) {
+		printk("%s: Could not read adapter factory MAC address!\n",
+		       print_name);
 		return(DFX_K_FAILURE);
-		}
+	}
 	memcpy(&bp->factory_mac_addr[4], &data, sizeof(u16));
 
 	/*
@@ -867,28 +959,27 @@
 	 */
 
 	memcpy(dev->dev_addr, bp->factory_mac_addr, FDDI_K_ALEN);
-	if (bp->bus_type == DFX_BUS_TYPE_EISA)
-		printk("%s: DEFEA at I/O addr = 0x%lX, IRQ = %d, Hardware addr = %02X-%02X-%02X-%02X-%02X-%02X\n",
-				dev->name,
-				dev->base_addr,
-				dev->irq,
-				dev->dev_addr[0],
-				dev->dev_addr[1],
-				dev->dev_addr[2],
-				dev->dev_addr[3],
-				dev->dev_addr[4],
-				dev->dev_addr[5]);
+	if (bp->bus_type == DFX_BUS_TYPE_TC)
+		printk("%s: DEFTA at addr = 0x%lX, IRQ = %d, "
+		       "Hardware addr = %02X-%02X-%02X-%02X-%02X-%02X\n",
+		       print_name, dev->base_addr, dev->irq,
+		       dev->dev_addr[0], dev->dev_addr[1],
+		       dev->dev_addr[2], dev->dev_addr[3],
+		       dev->dev_addr[4], dev->dev_addr[5]);
+	else if (bp->bus_type == DFX_BUS_TYPE_EISA)
+		printk("%s: DEFEA at I/O addr = 0x%lX, IRQ = %d, "
+		       "Hardware addr = %02X-%02X-%02X-%02X-%02X-%02X\n",
+		       print_name, dev->base_addr, dev->irq,
+		       dev->dev_addr[0], dev->dev_addr[1],
+		       dev->dev_addr[2], dev->dev_addr[3],
+		       dev->dev_addr[4], dev->dev_addr[5]);
 	else
-		printk("%s: DEFPA at I/O addr = 0x%lX, IRQ = %d, Hardware addr = %02X-%02X-%02X-%02X-%02X-%02X\n",
-				dev->name,
-				dev->base_addr,
-				dev->irq,
-				dev->dev_addr[0],
-				dev->dev_addr[1],
-				dev->dev_addr[2],
-				dev->dev_addr[3],
-				dev->dev_addr[4],
-				dev->dev_addr[5]);
+		printk("%s: DEFPA at I/O addr = 0x%lX, IRQ = %d, "
+		       "Hardware addr = %02X-%02X-%02X-%02X-%02X-%02X\n",
+		       print_name, dev->base_addr, dev->irq,
+		       dev->dev_addr[0], dev->dev_addr[1],
+		       dev->dev_addr[2], dev->dev_addr[3],
+		       dev->dev_addr[4], dev->dev_addr[5]);
 
 	/*
 	 * Get memory for descriptor block, consumer block, and other buffers
@@ -903,14 +994,15 @@
 #endif
 					sizeof(PI_CONSUMER_BLOCK) +
 					(PI_ALIGN_K_DESC_BLK - 1);
-	bp->kmalloced = top_v = (char *) kmalloc(alloc_size, GFP_KERNEL);
-	if (top_v == NULL)
-		{
-		printk("%s: Could not allocate memory for host buffers and structures!\n", dev->name);
+	bp->kmalloced = top_v = pci_alloc_consistent(bp->pci_dev, alloc_size,
+						     &bp->kmalloced_dma);
+	if (top_v == NULL) {
+		printk("%s: Could not allocate memory for host buffers "
+		       "and structures!\n", print_name);
 		return(DFX_K_FAILURE);
-		}
+	}
 	memset(top_v, 0, alloc_size);	/* zero out memory before continuing */
-	top_p = virt_to_bus(top_v);		/* get physical address of buffer */
+	top_p = bp->kmalloced_dma;	/* get physical address of buffer */
 
 	/*
 	 *  To guarantee the 8K alignment required for the descriptor block, 8K - 1
@@ -924,7 +1016,7 @@
 	 *		  for allocating the needed memory.
 	 */
 
-	curr_p = (u32) (ALIGN(top_p, PI_ALIGN_K_DESC_BLK));
+	curr_p = ALIGN(top_p, PI_ALIGN_K_DESC_BLK);
 	curr_v = top_v + (curr_p - top_p);
 
 	/* Reserve space for descriptor block */
@@ -965,14 +1057,20 @@
 
 	/* Display virtual and physical addresses if debug driver */
 
-	DBG_printk("%s: Descriptor block virt = %0lX, phys = %0X\n",				dev->name, (long)bp->descr_block_virt,	bp->descr_block_phys);
-	DBG_printk("%s: Command Request buffer virt = %0lX, phys = %0X\n",			dev->name, (long)bp->cmd_req_virt,		bp->cmd_req_phys);
-	DBG_printk("%s: Command Response buffer virt = %0lX, phys = %0X\n",			dev->name, (long)bp->cmd_rsp_virt,		bp->cmd_rsp_phys);
-	DBG_printk("%s: Receive buffer block virt = %0lX, phys = %0X\n",			dev->name, (long)bp->rcv_block_virt,	bp->rcv_block_phys);
-	DBG_printk("%s: Consumer block virt = %0lX, phys = %0X\n",				dev->name, (long)bp->cons_block_virt,	bp->cons_block_phys);
+	DBG_printk("%s: Descriptor block virt = %0lX, phys = %0X\n",
+		   print_name,
+		   (long)bp->descr_block_virt, bp->descr_block_phys);
+	DBG_printk("%s: Command Request buffer virt = %0lX, phys = %0X\n",
+		   print_name, (long)bp->cmd_req_virt, bp->cmd_req_phys);
+	DBG_printk("%s: Command Response buffer virt = %0lX, phys = %0X\n",
+		   print_name, (long)bp->cmd_rsp_virt, bp->cmd_rsp_phys);
+	DBG_printk("%s: Receive buffer block virt = %0lX, phys = %0X\n",
+		   print_name, (long)bp->rcv_block_virt, bp->rcv_block_phys);
+	DBG_printk("%s: Consumer block virt = %0lX, phys = %0X\n",
+		   print_name, (long)bp->cons_block_virt, bp->cons_block_phys);
 
 	return(DFX_K_SUCCESS);
-	}
+}
 
 
 /*
@@ -1218,7 +1316,9 @@
 	
 	/* Register IRQ - support shared interrupts by passing device ptr */
 
-	ret = request_irq(dev->irq, (void *)dfx_interrupt, SA_SHIRQ, dev->name, dev);
+	ret = request_irq(dev->irq, (void *)dfx_interrupt,
+			  (bp->bus_type == DFX_BUS_TYPE_TC) ? 0 : SA_SHIRQ,
+			  dev->name, dev);
 	if (ret) {
 		printk(KERN_ERR "%s: Requested IRQ %d is busy\n", dev->name, dev->irq);
 		return ret;
@@ -1737,7 +1837,7 @@
 		dfx_port_write_long(bp, PFI_K_REG_MODE_CTRL,
 					(PFI_MODE_M_PDQ_INT_ENB + PFI_MODE_M_DMA_ENB));
 		}
-	else
+	else if (bp->bus_type == DFX_BUS_TYPE_EISA)
 		{
 		/* Disable interrupts at the ESIC */
 
@@ -1755,6 +1855,13 @@
 		tmp |= PI_CONFIG_STAT_0_M_INT_ENB;
 		dfx_port_write_byte(bp, PI_ESIC_K_IO_CONFIG_STAT_0, tmp);
 		}
+	else {
+		/* TC doesn't share interrupts so no need to disable them */
+
+		/* Call interrupt service routine for this adapter */
+
+		dfx_int_common(dev);
+	}
 
 	spin_unlock(&bp->lock);
 	}
@@ -2663,12 +2770,12 @@
  
 static void my_skb_align(struct sk_buff *skb, int n)
 {
-	u32 x=(u32)skb->data;	/* We only want the low bits .. */
-	u32 v;
+	unsigned long x = (unsigned long)skb->data;
+	unsigned long v;
 	
-	v=(x+n-1)&~(n-1);	/* Where we want to be */
+	v = ALIGN(x, n);	/* Where we want to be */
 	
-	skb_reserve(skb, v-x);
+	skb_reserve(skb, v - x);
 }
 
 
@@ -2745,7 +2852,10 @@
 			 */
 			 
 			my_skb_align(newskb, 128);
-			bp->descr_block_virt->rcv_data[i+j].long_1 = virt_to_bus(newskb->data);
+			bp->descr_block_virt->rcv_data[i + j].long_1 =
+				(u32)pci_map_single(bp->pci_dev, newskb->data,
+						    NEW_SKB_SIZE,
+						    PCI_DMA_FROMDEVICE);
 			/*
 			 * p_rcv_buff_va is only used inside the
 			 * kernel so we put the skb pointer here.
@@ -2859,9 +2969,17 @@
 						
 						my_skb_align(newskb, 128);
 						skb = (struct sk_buff *)bp->p_rcv_buff_va[entry];
+						pci_unmap_single(bp->pci_dev,
+							bp->descr_block_virt->rcv_data[entry].long_1,
+							NEW_SKB_SIZE,
+							PCI_DMA_FROMDEVICE);
 						skb_reserve(skb, RCV_BUFF_K_PADDING);
 						bp->p_rcv_buff_va[entry] = (char *)newskb;
-						bp->descr_block_virt->rcv_data[entry].long_1 = virt_to_bus(newskb->data);
+						bp->descr_block_virt->rcv_data[entry].long_1 =
+							(u32)pci_map_single(bp->pci_dev,
+								newskb->data,
+								NEW_SKB_SIZE,
+								PCI_DMA_FROMDEVICE);
 					} else
 						skb = NULL;
 				} else
@@ -2934,7 +3052,7 @@
  *   is contained in a single physically contiguous buffer
  *   in which the virtual address of the start of packet
  *   (skb->data) can be converted to a physical address
- *   by using virt_to_bus().
+ *   by using pci_map_single().
  *
  *   Since the adapter architecture requires a three byte
  *   packet request header to prepend the start of packet,
@@ -3082,12 +3200,13 @@
 	 *			skb->data.
 	 *		 6. The physical address of the start of packet
 	 *			can be determined from the virtual address
-	 *			by using virt_to_bus() and is only 32-bits
+	 *			by using pci_map_single() and is only 32-bits
 	 *			wide.
 	 */
 
 	p_xmt_descr->long_0	= (u32) (PI_XMT_DESCR_M_SOP | PI_XMT_DESCR_M_EOP | ((skb->len) << PI_XMT_DESCR_V_SEG_LEN));
-	p_xmt_descr->long_1 = (u32) virt_to_bus(skb->data);
+	p_xmt_descr->long_1 = (u32)pci_map_single(bp->pci_dev, skb->data,
+						  skb->len, PCI_DMA_TODEVICE);
 
 	/*
 	 * Verify that descriptor is actually available
@@ -3171,6 +3290,7 @@
 	{
 	XMT_DRIVER_DESCR	*p_xmt_drv_descr;	/* ptr to transmit driver descriptor */
 	PI_TYPE_2_CONSUMER	*p_type_2_cons;		/* ptr to rcv/xmt consumer block register */
+	u8			comp;			/* local transmit completion index */
 	int 			freed = 0;		/* buffers freed */
 
 	/* Service all consumed transmit frames */
@@ -3188,7 +3308,11 @@
 		bp->xmt_total_bytes += p_xmt_drv_descr->p_skb->len;
 
 		/* Return skb to operating system */
-
+		comp = bp->rcv_xmt_reg.index.xmt_comp;
+		pci_unmap_single(bp->pci_dev,
+				 bp->descr_block_virt->xmt_data[comp].long_1,
+				 p_xmt_drv_descr->p_skb->len,
+				 PCI_DMA_TODEVICE);
 		dev_kfree_skb_irq(p_xmt_drv_descr->p_skb);
 
 		/*
@@ -3297,6 +3421,7 @@
 	{
 	u32			prod_cons;		/* rcv/xmt consumer block longword */
 	XMT_DRIVER_DESCR	*p_xmt_drv_descr;	/* ptr to transmit driver descriptor */
+	u8			comp;			/* local transmit completion index */
 
 	/* Flush all outstanding transmit frames */
 
@@ -3307,7 +3432,11 @@
 		p_xmt_drv_descr = &(bp->xmt_drv_descr_blk[bp->rcv_xmt_reg.index.xmt_comp]);
 
 		/* Return skb to operating system */
-
+		comp = bp->rcv_xmt_reg.index.xmt_comp;
+		pci_unmap_single(bp->pci_dev,
+				 bp->descr_block_virt->xmt_data[comp].long_1,
+				 p_xmt_drv_descr->p_skb->len,
+				 PCI_DMA_TODEVICE);
 		dev_kfree_skb(p_xmt_drv_descr->p_skb);
 
 		/* Increment transmit error counter */
@@ -3337,12 +3466,36 @@
 
 static void __devexit dfx_remove_one_pci_or_eisa(struct pci_dev *pdev, struct net_device *dev)
 {
-	DFX_board_t	  *bp = dev->priv;
+	DFX_board_t	*bp = dev->priv;
+	unsigned long	len;			/* resource length */
+	int		alloc_size;		/* total buffer size used */
 
+	if (bp->bus_type == DFX_BUS_TYPE_TC) {
+		/* TURBOchannel board */
+		len = PI_TC_K_CSR_LEN;
+	} else if (bp->bus_type == DFX_BUS_TYPE_EISA) {
+		/* EISA board */
+		len = PI_ESIC_K_CSR_IO_LEN;
+	} else {
+		len = PFI_K_CSR_IO_LEN;
+	}
 	unregister_netdev(dev);
-	release_region(dev->base_addr,  pdev ? PFI_K_CSR_IO_LEN : PI_ESIC_K_CSR_IO_LEN );
-	if (bp->kmalloced) kfree(bp->kmalloced);
-	kfree(dev);
+	release_region(dev->base_addr, len);
+
+	if (bp->bus_type == DFX_BUS_TYPE_TC)
+		release_tc_card(bp->slot);
+
+	alloc_size = sizeof(PI_DESCR_BLOCK) +
+		     PI_CMD_REQ_K_SIZE_MAX + PI_CMD_RSP_K_SIZE_MAX +
+#ifndef DYNAMIC_BUFFERS
+		     (bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX) +
+#endif
+		     sizeof(PI_CONSUMER_BLOCK) +
+		     (PI_ALIGN_K_DESC_BLK - 1);
+	if (bp->kmalloced)
+		pci_free_consistent(pdev, alloc_size, bp->kmalloced,
+				    bp->kmalloced_dma);
+	free_netdev(dev);
 }
 
 static void __devexit dfx_remove_one (struct pci_dev *pdev)
@@ -3353,21 +3506,22 @@
 	pci_set_drvdata(pdev, NULL);
 }
 
-static struct pci_device_id dfx_pci_tbl[] __devinitdata = {
+static struct pci_device_id dfx_pci_tbl[] = {
 	{ PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_DEC_FDDI, PCI_ANY_ID, PCI_ANY_ID, },
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, dfx_pci_tbl);
 
 static struct pci_driver dfx_driver = {
-	name:		"defxx",
-	probe:		dfx_init_one,
-	remove:		__devexit_p(dfx_remove_one),
-	id_table:	dfx_pci_tbl,
+	.name		= "defxx",
+	.probe		= dfx_init_one,
+	.remove		= __devexit_p(dfx_remove_one),
+	.id_table	= dfx_pci_tbl,
 };
 
 static int dfx_have_pci;
 static int dfx_have_eisa;
+static int dfx_have_tc;
 
 
 static void __exit dfx_eisa_cleanup(void)
@@ -3388,12 +3542,7 @@
 
 static int __init dfx_init(void)
 {
-	int rc_pci, rc_eisa;
-
-/* when a module, this is printed whether or not devices are found in probe */
-#ifdef MODULE
-	printk(version);
-#endif
+	int rc_pci, rc_eisa, rc_tc;
 
 	rc_pci = pci_module_init(&dfx_driver);
 	if (rc_pci >= 0) dfx_have_pci = 1;
@@ -3401,20 +3550,27 @@
 	rc_eisa = dfx_eisa_init();
 	if (rc_eisa >= 0) dfx_have_eisa = 1;
 
-	return ((rc_eisa < 0) ? 0 : rc_eisa)  + ((rc_pci < 0) ? 0 : rc_pci); 
+	rc_tc = dfx_tc_init();
+	if (rc_tc >= 0) dfx_have_tc = 1;
+
+	return ((rc_tc < 0) ? 0 : rc_tc) +
+	       ((rc_eisa < 0) ? 0 : rc_eisa) +
+	       ((rc_pci < 0) ? 0 : rc_pci); 
 }
 
 static void __exit dfx_cleanup(void)
 {
 	if (dfx_have_pci)
 		pci_unregister_driver(&dfx_driver);
-	if (dfx_have_eisa)
+	if (dfx_have_eisa || dfx_have_tc)
 		dfx_eisa_cleanup();
-		
 }	
 
 module_init(dfx_init);
 module_exit(dfx_cleanup);
+MODULE_AUTHOR("Lawrence V. Stefani");
+MODULE_DESCRIPTION("DEC FDDIcontroller EISA/PCI (DEFEA/DEFPA) driver "
+		   DRV_VERSION " " DRV_RELDATE);
 MODULE_LICENSE("GPL");
 
 
diff -Nur linux-2.4.30/drivers/net/defxx.h linux-2.4.30-mips/drivers/net/defxx.h
--- linux-2.4.30/drivers/net/defxx.h	2001-02-13 22:15:05.000000000 +0100
+++ linux-2.4.30-mips/drivers/net/defxx.h	2004-10-03 20:06:48.000000000 +0200
@@ -12,17 +12,11 @@
  *   Contains all definitions specified by port specification and required
  *   by the defxx.c driver.
  *
- * Maintainers:
- *   LVS	Lawrence V. Stefani
- *
- * Contact:
- *	 The author may be reached at:
+ * The original author:
+ *   LVS	Lawrence V. Stefani <lstefani@yahoo.com>
  *
- *		Inet: stefani@lkg.dec.com
- *		Mail: Digital Equipment Corporation
- *			  550 King Street
- *			  M/S: LKG1-3/M07
- *			  Littleton, MA  01460
+ * Maintainers:
+ *   macro	Maciej W. Rozycki <macro@linux-mips.org>
  *
  * Modification History:
  *		Date		Name	Description
@@ -30,6 +24,7 @@
  *		09-Sep-96	LVS		Added group_prom field.  Moved read/write I/O
  *							macros to DEFXX.C.
  *		12-Sep-96	LVS		Removed packet request header pointers.
+ *		04 Aug 2003	macro		Converted to the DMA API.
  */
 
 #ifndef _DEFXX_H_
@@ -1467,6 +1462,11 @@
 
 #endif	/* #ifndef BIG_ENDIAN */
 
+/* Define TC PDQ CSR offset and length */
+
+#define PI_TC_K_CSR_OFFSET		0x100000
+#define PI_TC_K_CSR_LEN			0x80		/* 128 bytes */
+
 /* Define EISA controller register offsets */
 
 #define PI_ESIC_K_BURST_HOLDOFF		0x040
@@ -1634,6 +1634,7 @@
 
 #define DFX_BUS_TYPE_PCI		0			/* type code for DEC FDDIcontroller/PCI */
 #define DFX_BUS_TYPE_EISA		1			/* type code for DEC FDDIcontroller/EISA */
+#define DFX_BUS_TYPE_TC			2			/* type code for DEC FDDIcontroller/TURBOchannel */
 
 #define DFX_FC_PRH2_PRH1_PRH0		0x54003820	/* Packet Request Header bytes + FC */
 #define DFX_PRH0_BYTE			0x20		/* Packet Request Header byte 0 */
@@ -1704,17 +1705,19 @@
 	{
 	/* Keep virtual and physical pointers to locked, physically contiguous memory */
 
-	char				*kmalloced;					/* kfree this on unload */ 
+	char				*kmalloced;					/* pci_free_consistent this on unload */ 
+	dma_addr_t			kmalloced_dma;
+	/* DMA handle for the above */
 	PI_DESCR_BLOCK			*descr_block_virt;				/* PDQ descriptor block virt address */
-	u32				descr_block_phys;				/* PDQ descriptor block phys address */
+	dma_addr_t			descr_block_phys;				/* PDQ descriptor block phys address */
 	PI_DMA_CMD_REQ			*cmd_req_virt;					/* Command request buffer virt address */
-	u32				cmd_req_phys;					/* Command request buffer phys address */
+	dma_addr_t			cmd_req_phys;					/* Command request buffer phys address */
 	PI_DMA_CMD_RSP			*cmd_rsp_virt;					/* Command response buffer virt address */
-	u32				cmd_rsp_phys;					/* Command response buffer phys address */
+	dma_addr_t			cmd_rsp_phys;					/* Command response buffer phys address */
 	char				*rcv_block_virt;				/* LLC host receive queue buf blk virt */
-	u32				rcv_block_phys;					/* LLC host receive queue buf blk phys */
+	dma_addr_t			rcv_block_phys;					/* LLC host receive queue buf blk phys */
 	PI_CONSUMER_BLOCK		*cons_block_virt;				/* PDQ consumer block virt address */
-	u32				cons_block_phys;				/* PDQ consumer block phys address */
+	dma_addr_t			cons_block_phys;				/* PDQ consumer block phys address */
 
 	/* Keep local copies of Type 1 and Type 2 register data */
 
@@ -1758,8 +1761,9 @@
 
 	struct net_device		*dev;						/* pointer to device structure */
 	struct net_device		*next;
-	u32				bus_type;					/* bus type (0 == PCI, 1 == EISA) */
-	u16				base_addr;					/* base I/O address (same as dev->base_addr) */
+	u32				bus_type;					/* bus type (0 == PCI, 1 == EISA, 2 == TC) */
+	long				base_addr;					/* base I/O address (same as dev->base_addr) */
+	int				slot;						/* TC slot number */
 	struct pci_dev *		pci_dev;
 	u32				full_duplex_enb;				/* FDDI Full Duplex enable (1 == on, 2 == off) */
 	u32				req_ttrt;					/* requested TTRT value (in 80ns units) */
diff -Nur linux-2.4.30/drivers/net/hamradio/hdlcdrv.c linux-2.4.30-mips/drivers/net/hamradio/hdlcdrv.c
--- linux-2.4.30/drivers/net/hamradio/hdlcdrv.c	2002-02-25 20:37:59.000000000 +0100
+++ linux-2.4.30-mips/drivers/net/hamradio/hdlcdrv.c	2004-05-04 14:04:27.000000000 +0200
@@ -587,6 +587,8 @@
 		return -EINVAL;
 	s = (struct hdlcdrv_state *)dev->priv;
 
+	netif_stop_queue(dev);
+
 	if (s->ops && s->ops->close)
 		i = s->ops->close(dev);
 	if (s->skb)
diff -Nur linux-2.4.30/drivers/net/irda/au1k_ir.c linux-2.4.30-mips/drivers/net/irda/au1k_ir.c
--- linux-2.4.30/drivers/net/irda/au1k_ir.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/net/irda/au1k_ir.c	2005-02-03 07:35:29.000000000 +0100
@@ -81,10 +81,6 @@
 
 #define RUN_AT(x) (jiffies + (x))
 
-#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100)
-static BCSR * const bcsr = (BCSR *)0xAE000000;
-#endif
-
 static spinlock_t ir_lock = SPIN_LOCK_UNLOCKED;
 
 /*
diff -Nur linux-2.4.30/drivers/pci/pci.c linux-2.4.30-mips/drivers/pci/pci.c
--- linux-2.4.30/drivers/pci/pci.c	2004-11-17 12:54:21.000000000 +0100
+++ linux-2.4.30-mips/drivers/pci/pci.c	2004-11-19 01:28:41.000000000 +0100
@@ -1281,11 +1281,17 @@
 {
 	unsigned int buses;
 	unsigned short cr;
+	unsigned short bctl;
 	struct pci_bus *child;
 	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
 
 	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
 	DBG("Scanning behind PCI bridge %s, config %06x, pass %d\n", dev->slot_name, buses & 0xffffff, pass);
+	/* Disable MasterAbortMode during probing to avoid reporting
+           of bus errors (in some architectures) */
+	pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &bctl);
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, 
+			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
 	if ((buses & 0xffff00) && !pcibios_assign_all_busses()) {
 		/*
 		 * Bus already configured by firmware, process it in the first
@@ -1351,6 +1357,7 @@
 		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
 		pci_write_config_word(dev, PCI_COMMAND, cr);
 	}
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, bctl);
 	sprintf(child->name, (is_cardbus ? "PCI CardBus #%02x" : "PCI Bus #%02x"), child->number);
 	return max;
 }
diff -Nur linux-2.4.30/drivers/pcmcia/Config.in linux-2.4.30-mips/drivers/pcmcia/Config.in
--- linux-2.4.30/drivers/pcmcia/Config.in	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/pcmcia/Config.in	2004-02-22 06:21:34.000000000 +0100
@@ -30,16 +30,14 @@
       dep_tristate '  M8xx support' CONFIG_PCMCIA_M8XX $CONFIG_PCMCIA
    fi
    if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
-      dep_tristate '  Au1x00 PCMCIA support' CONFIG_PCMCIA_AU1X00 $CONFIG_PCMCIA 
-      if [ "$CONFIG_PCMCIA_AU1X00" != "n" ]; then
-        bool '  Pb1x00 board support' CONFIG_PCMCIA_PB1X00
-        bool '  Db1x00 board support' CONFIG_PCMCIA_DB1X00
-        bool '  XXS1500 board support' CONFIG_PCMCIA_XXS1500
-      fi
+      dep_tristate '  Au1x00 PCMCIA support' CONFIG_PCMCIA_AU1X00 $CONFIG_PCMCIA
    fi
    if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
       dep_bool '  SiByte PCMCIA support' CONFIG_PCMCIA_SIBYTE $CONFIG_PCMCIA $CONFIG_BLK_DEV_IDE_SIBYTE
    fi
+   if [ "$CONFIG_VRC4171" = "y" -o "$CONFIG_VRC4171" = "m" ]; then
+      dep_tristate '  NEC VRC4171 Card Controllers support' CONFIG_PCMCIA_VRC4171 $CONFIG_PCMCIA
+   fi
    if [ "$CONFIG_VRC4173" = "y" -o "$CONFIG_VRC4173" = "m" ]; then
       dep_tristate '  NEC VRC4173 CARDU support' CONFIG_PCMCIA_VRC4173 $CONFIG_PCMCIA
    fi
diff -Nur linux-2.4.30/drivers/pcmcia/Makefile linux-2.4.30-mips/drivers/pcmcia/Makefile
--- linux-2.4.30/drivers/pcmcia/Makefile	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/pcmcia/Makefile	2005-02-03 07:35:30.000000000 +0100
@@ -61,9 +61,18 @@
 
 obj-$(CONFIG_PCMCIA_AU1X00)			+= au1x00_ss.o
 au1000_ss-objs-y				:= au1000_generic.o
-au1000_ss-objs-$(CONFIG_PCMCIA_PB1X00)		+= au1000_pb1x00.o
-au1000_ss-objs-$(CONFIG_PCMCIA_DB1X00)		+= au1000_db1x00.o
-au1000_ss-objs-$(CONFIG_PCMCIA_XXS1500) 	+= au1000_xxs1500.o
+au1000_ss-objs-$(CONFIG_MIPS_PB1000)		+= au1000_pb1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_PB1100)		+= au1000_pb1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_PB1500)		+= au1000_pb1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_PB1550)		+= au1000_pb1550.o
+au1000_ss-objs-$(CONFIG_MIPS_PB1200)		+= au1000_db1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_DB1000)		+= au1000_db1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_DB1100)		+= au1000_db1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_DB1500)		+= au1000_db1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_DB1550)		+= au1000_db1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_DB1200)		+= au1000_db1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_HYDROGEN3)		+= au1000_hydrogen3.o
+au1000_ss-objs-$(CONFIG_MIPS_XXS1500) 		+= au1000_xxs1500.o
 
 obj-$(CONFIG_PCMCIA_SA1100)	+= sa1100_cs.o
 obj-$(CONFIG_PCMCIA_M8XX)	+= m8xx_pcmcia.o
@@ -89,6 +98,7 @@
 sa1100_cs-objs-$(CONFIG_SA1100_XP860)		+= sa1100_xp860.o sa1111_generic.o
 sa1100_cs-objs-$(CONFIG_SA1100_YOPY)		+= sa1100_yopy.o
 
+obj-$(CONFIG_PCMCIA_VRC4171)	+= vrc4171_card.o
 obj-$(CONFIG_PCMCIA_VRC4173)	+= vrc4173_cardu.o
 
 include $(TOPDIR)/Rules.make
diff -Nur linux-2.4.30/drivers/pcmcia/au1000_db1x00.c linux-2.4.30-mips/drivers/pcmcia/au1000_db1x00.c
--- linux-2.4.30/drivers/pcmcia/au1000_db1x00.c	2005-01-19 15:09:57.000000000 +0100
+++ linux-2.4.30-mips/drivers/pcmcia/au1000_db1x00.c	2005-02-03 07:35:30.000000000 +0100
@@ -1,6 +1,6 @@
 /*
  *
- * Alchemy Semi Db1x00 boards specific pcmcia routines.
+ * AMD Alchemy DUAL-SLOT Db1x00 boards' specific pcmcia routines.
  *
  * Copyright 2002 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
@@ -54,9 +54,20 @@
 #include <asm/au1000.h>
 #include <asm/au1000_pcmcia.h>
 
+#if defined(CONFIG_MIPS_PB1200)
+#include <asm/pb1200.h>
+#elif defined(CONFIG_MIPS_DB1200)
+#include <asm/db1200.h>
+#else
 #include <asm/db1x00.h>
+#endif
 
-static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+#define PCMCIA_MAX_SOCK 1
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
+
+/* VPP/VCC */
+#define SET_VCC_VPP(VCC, VPP, SLOT)\
+    ((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
 
 static int db1x00_pcmcia_init(struct pcmcia_init *init)
 {
@@ -76,7 +87,7 @@
 db1x00_pcmcia_socket_state(unsigned sock, struct pcmcia_state *state)
 {
 	u32 inserted;
-	unsigned char vs;
+	u16 vs;
 
 	if(sock > PCMCIA_MAX_SOCK) return -1;
 
@@ -87,11 +98,11 @@
 
 	if (sock == 0) {
 		vs = bcsr->status & 0x3;
-		inserted = !(bcsr->status & (1<<4));
+		inserted = BOARD_CARD_INSERTED(0);
 	}
 	else {
 		vs = (bcsr->status & 0xC)>>2;
-		inserted = !(bcsr->status & (1<<5));
+		inserted = BOARD_CARD_INSERTED(1);
 	}
 
 	DEBUG(KERN_DEBUG "db1x00 socket %d: inserted %d, vs %d\n", 
@@ -144,16 +155,9 @@
 	if(info->sock > PCMCIA_MAX_SOCK) return -1;
 
 	if(info->sock == 0)
-#ifdef CONFIG_MIPS_DB1550
-		info->irq = AU1000_GPIO_3;
+		info->irq = BOARD_PC0_INT;
 	else 
-		info->irq = AU1000_GPIO_5;
-#else
-		info->irq = AU1000_GPIO_2;
-	else 
-		info->irq = AU1000_GPIO_5;
-#endif
-
+		info->irq = BOARD_PC1_INT;
 	return 0;
 }
 
diff -Nur linux-2.4.30/drivers/pcmcia/vrc4171_card.c linux-2.4.30-mips/drivers/pcmcia/vrc4171_card.c
--- linux-2.4.30/drivers/pcmcia/vrc4171_card.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/pcmcia/vrc4171_card.c	2004-01-19 16:54:58.000000000 +0100
@@ -0,0 +1,886 @@
+/*
+ * vrc4171_card.c, NEC VRC4171 Card Controller driver for Socket Services.
+ *
+ * Copyright (C) 2003  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+#include <asm/io.h>
+#include <asm/vr41xx/vrc4171.h>
+
+#include <pcmcia/ss.h>
+
+#include "i82365.h"
+
+MODULE_DESCRIPTION("NEC VRC4171 Card Controllers driver for Socket Services");
+MODULE_AUTHOR("Yoichi Yuasa <yuasa@hh.iij4u.or.jp>");
+MODULE_LICENSE("GPL");
+
+#define CARD_MAX_SLOTS		2
+#define CARD_SLOTA		0
+#define CARD_SLOTB		1
+#define CARD_SLOTB_OFFSET	0x40
+
+#define CARD_MEM_START		0x10000000
+#define CARD_MEM_END		0x13ffffff
+#define CARD_MAX_MEM_OFFSET	0x3ffffff
+#define CARD_MAX_MEM_SPEED	1000
+
+#define CARD_CONTROLLER_INDEX	0x03e0
+#define CARD_CONTROLLER_DATA	0x03e1
+#define CARD_CONTROLLER_SIZE	2
+ /* Power register */
+  #define VPP_GET_VCC		0x01
+  #define POWER_ENABLE		0x10
+ #define CARD_VOLTAGE_SENSE	0x1f
+  #define VCC_3VORXV_CAPABLE	0x00
+  #define VCC_XV_ONLY		0x01
+  #define VCC_3V_CAPABLE	0x02
+  #define VCC_5V_ONLY		0x03
+ #define CARD_VOLTAGE_SELECT	0x2f
+  #define VCC_3V		0x01
+  #define VCC_5V		0x00
+  #define VCC_XV		0x02
+  #define VCC_STATUS_3V		0x02
+  #define VCC_STATUS_5V		0x01
+  #define VCC_STATUS_XV		0x03
+ #define GLOBAL_CONTROL		0x1e
+  #define EXWRBK		0x04
+  #define IRQPM_EN		0x08
+  #define CLRPMIRQ		0x10
+
+#define IO_MAX_MAPS	2
+#define MEM_MAX_MAPS	5
+
+enum {
+	SLOTB_PROBE = 0,
+	SLOTB_NOPROBE_IO,
+	SLOTB_NOPROBE_MEM,
+	SLOTB_NOPROBE_ALL
+};
+
+typedef struct vrc4171_socket {
+	int noprobe;
+	void (*handler)(void *, unsigned int);
+	void *info;
+	socket_cap_t cap;
+	spinlock_t event_lock;
+	uint16_t events;
+	struct socket_info_t *pcmcia_socket;
+	struct tq_struct tq_task;
+	char name[24];
+	int csc_irq;
+	int io_irq;
+} vrc4171_socket_t;
+
+static vrc4171_socket_t vrc4171_sockets[CARD_MAX_SLOTS];
+static int vrc4171_slotb = SLOTB_IS_NONE;
+static unsigned int vrc4171_irq;
+static uint16_t vrc4171_irq_mask = 0xdeb8;
+
+extern struct socket_info_t *pcmcia_register_socket(int slot,
+                                                    struct pccard_operations *vtable,
+                                                    int use_bus_pm);
+extern void pcmcia_unregister_socket(struct socket_info_t *s);
+
+static inline uint8_t exca_read_byte(int slot, uint8_t index)
+{
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	return inb(CARD_CONTROLLER_DATA);
+}
+
+static inline uint16_t exca_read_word(int slot, uint8_t index)
+{
+	uint16_t data;
+
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index++, CARD_CONTROLLER_INDEX);
+	data = inb(CARD_CONTROLLER_DATA);
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	data |= ((uint16_t)inb(CARD_CONTROLLER_DATA)) << 8;
+
+	return data;
+}
+
+static inline uint8_t exca_write_byte(int slot, uint8_t index, uint8_t data)
+{
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	outb(data, CARD_CONTROLLER_DATA);
+
+	return data;
+}
+
+static inline uint16_t exca_write_word(int slot, uint8_t index, uint16_t data)
+{
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index++, CARD_CONTROLLER_INDEX);
+	outb(data, CARD_CONTROLLER_DATA);
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	outb((uint8_t)(data >> 8), CARD_CONTROLLER_DATA);
+
+	return data;
+}
+
+static inline int search_nonuse_irq(void)
+{
+	int i;
+
+	for (i = 0; i < 16; i++) {
+		if (vrc4171_irq_mask & (1 << i)) {
+			vrc4171_irq_mask &= ~(1 << i);
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+static int pccard_init(unsigned int slot)
+{
+	vrc4171_socket_t *socket = &vrc4171_sockets[slot];
+
+	socket->cap.features |= SS_CAP_PCCARD | SS_CAP_PAGE_REGS;
+	socket->cap.irq_mask = 0;
+	socket->cap.pci_irq = vrc4171_irq;
+	socket->cap.map_size = 0x1000;
+	socket->events = 0;
+	spin_lock_init(socket->event_lock);
+	socket->csc_irq = search_nonuse_irq();
+	socket->io_irq = search_nonuse_irq();
+
+	return 0;
+}
+
+static int pccard_suspend(unsigned int slot)
+{
+	return -EINVAL;
+}
+
+static int pccard_register_callback(unsigned int slot,
+                                    void (*handler)(void *, unsigned int),
+                                    void *info)
+{
+	vrc4171_socket_t *socket;
+
+	if (slot >= CARD_MAX_SLOTS)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+
+	socket->handler = handler;
+	socket->info = info;
+
+	if (handler)
+		MOD_INC_USE_COUNT;
+	else
+		MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+static int pccard_inquire_socket(unsigned int slot, socket_cap_t *cap)
+{
+	vrc4171_socket_t *socket;
+
+	if (slot >= CARD_MAX_SLOTS || cap == NULL)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+
+	*cap = socket->cap;
+
+	return 0;
+}
+
+static int pccard_get_status(unsigned int slot, u_int *value)
+{
+	uint8_t status, sense;
+	u_int val = 0;
+
+	if (slot >= CARD_MAX_SLOTS || value == NULL)
+		return -EINVAL;
+
+	status = exca_read_byte(slot, I365_STATUS);
+	if (exca_read_byte(slot, I365_INTCTL) & I365_PC_IOCARD) {
+		if (status & I365_CS_STSCHG)
+			val |= SS_STSCHG;
+	} else {
+		if (!(status & I365_CS_BVD1))
+			val |= SS_BATDEAD;
+		else if ((status & (I365_CS_BVD1 | I365_CS_BVD2)) == I365_CS_BVD1)
+			val |= SS_BATWARN;
+	}
+	if ((status & I365_CS_DETECT) == I365_CS_DETECT)
+		val |= SS_DETECT;
+	if (status & I365_CS_WRPROT)
+		val |= SS_WRPROT;
+	if (status & I365_CS_READY)
+		val |= SS_READY;
+	if (status & I365_CS_POWERON)
+		val |= SS_POWERON;
+
+	sense = exca_read_byte(slot, CARD_VOLTAGE_SENSE);
+	switch (sense) {
+	case VCC_3VORXV_CAPABLE:
+		val |= SS_3VCARD | SS_XVCARD;
+		break;
+	case VCC_XV_ONLY:
+		val |= SS_XVCARD;
+		break;
+	case VCC_3V_CAPABLE:
+		val |= SS_3VCARD;
+		break;
+	default:
+		/* 5V only */
+		break;
+	}
+
+	*value = val;
+
+	return 0;
+}
+
+static inline u_char get_Vcc_value(uint8_t voltage)
+{
+	switch (voltage) {
+	case VCC_STATUS_3V:
+		return 33;
+	case VCC_STATUS_5V:
+		return 50;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static inline u_char get_Vpp_value(uint8_t power, u_char Vcc)
+{
+	if ((power & 0x03) == 0x01 || (power & 0x03) == 0x02)
+		return Vcc;
+
+	return 0;
+}
+
+static int pccard_get_socket(unsigned int slot, socket_state_t *state)
+{
+	vrc4171_socket_t *socket;
+	uint8_t power, voltage, control, cscint;
+
+	if (slot >= CARD_MAX_SLOTS || state == NULL)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+
+	power = exca_read_byte(slot, I365_POWER);
+	voltage = exca_read_byte(slot, CARD_VOLTAGE_SELECT);
+
+	state->Vcc = get_Vcc_value(voltage);
+	state->Vpp = get_Vpp_value(power, state->Vcc);
+
+	state->flags = 0;
+	if (power & POWER_ENABLE)
+		state->flags |= SS_PWR_AUTO;
+	if (power & I365_PWR_OUT)
+		state->flags |= SS_OUTPUT_ENA;
+
+	control = exca_read_byte(slot, I365_INTCTL);
+	if (control & I365_PC_IOCARD)
+		state->flags |= SS_IOCARD;
+	if (!(control & I365_PC_RESET))
+		state->flags |= SS_RESET;
+
+        cscint = exca_read_byte(slot, I365_CSCINT);
+	state->csc_mask = 0;
+	if (state->flags & SS_IOCARD) {
+		if (cscint & I365_CSC_STSCHG)
+			state->flags |= SS_STSCHG;
+	} else {
+		if (cscint & I365_CSC_BVD1)  
+			state->csc_mask |= SS_BATDEAD;
+		if (cscint & I365_CSC_BVD2)  
+			state->csc_mask |= SS_BATWARN;
+	}
+	if (cscint & I365_CSC_READY)
+		state->csc_mask |= SS_READY;
+	if (cscint & I365_CSC_DETECT)
+		state->csc_mask |= SS_DETECT;
+
+	return 0;
+}
+
+static inline uint8_t set_Vcc_value(u_char Vcc)
+{
+	switch (Vcc) {
+	case 33:
+		return VCC_3V;
+	case 50:
+		return VCC_5V;
+	}
+
+	/* Small voltage is chosen for safety. */
+	return VCC_3V;
+}
+
+static int pccard_set_socket(unsigned int slot, socket_state_t *state)
+{
+	vrc4171_socket_t *socket;
+	uint8_t voltage, power, control, cscint;
+
+	if (slot >= CARD_MAX_SLOTS ||
+	    (state->Vpp != state->Vcc && state->Vpp != 0) ||
+	    (state->Vcc != 50 && state->Vcc != 33 && state->Vcc != 0))
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+
+	spin_lock_irq(&socket->event_lock);
+
+	voltage = set_Vcc_value(state->Vcc);
+	exca_write_byte(slot, CARD_VOLTAGE_SELECT, voltage);
+
+	power = POWER_ENABLE;
+	if (state->Vpp == state->Vcc)
+		power |= VPP_GET_VCC;
+	if (state->flags & SS_OUTPUT_ENA)
+		power |= I365_PWR_OUT;
+	exca_write_byte(slot, I365_POWER, power);
+
+	control = 0;
+	if (state->io_irq != 0)
+		control |= socket->io_irq;
+	if (state->flags & SS_IOCARD)
+		control |= I365_PC_IOCARD;
+	if (state->flags & SS_RESET)
+		control	&= ~I365_PC_RESET;
+	else
+		control |= I365_PC_RESET;
+	exca_write_byte(slot, I365_INTCTL, control);
+
+        cscint = 0;
+        exca_write_byte(slot, I365_CSCINT, cscint);
+	exca_read_byte(slot, I365_CSC);	/* clear CardStatus change */
+	if (state->csc_mask != 0)
+		cscint |= socket->csc_irq << 8;
+	if (state->flags & SS_IOCARD) {
+		if (state->csc_mask & SS_STSCHG)
+			cscint |= I365_CSC_STSCHG;
+	} else {
+		if (state->csc_mask & SS_BATDEAD)
+			cscint |= I365_CSC_BVD1;
+		if (state->csc_mask & SS_BATWARN)
+			cscint |= I365_CSC_BVD2;
+	}
+	if (state->csc_mask & SS_READY)
+		cscint |= I365_CSC_READY;
+	if (state->csc_mask & SS_DETECT)
+		cscint |= I365_CSC_DETECT;
+        exca_write_byte(slot, I365_CSCINT, cscint);
+
+	spin_unlock_irq(&socket->event_lock);
+
+	return 0;
+}
+
+static int pccard_get_io_map(unsigned int slot, struct pccard_io_map *io)
+{
+	vrc4171_socket_t *socket;
+	uint8_t ioctl, addrwin;
+	u_char map;
+
+	if (slot >= CARD_MAX_SLOTS || io == NULL ||
+	    io->map >= IO_MAX_MAPS)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+	map = io->map;
+
+	io->start = exca_read_word(slot, I365_IO(map)+I365_W_START);
+	io->stop = exca_read_word(slot, I365_IO(map)+I365_W_STOP);
+
+	ioctl = exca_read_byte(slot, I365_IOCTL);
+	if (io->flags & I365_IOCTL_WAIT(map))
+		io->speed = 1;
+	else
+		io->speed = 0;
+
+	io->flags = 0;
+	if (ioctl & I365_IOCTL_16BIT(map))
+		io->flags |= MAP_16BIT;
+	if (ioctl & I365_IOCTL_IOCS16(map))
+		io->flags |= MAP_AUTOSZ;
+	if (ioctl & I365_IOCTL_0WS(map))
+		io->flags |= MAP_0WS;
+
+	addrwin = exca_read_byte(slot, I365_ADDRWIN);
+	if (addrwin & I365_ENA_IO(map))
+		io->flags |= MAP_ACTIVE;
+
+	return 0;
+}
+
+static int pccard_set_io_map(unsigned int slot, struct pccard_io_map *io)
+{
+	vrc4171_socket_t *socket;
+	uint8_t ioctl, addrwin;
+	u_char map;
+
+	if (slot >= CARD_MAX_SLOTS ||
+	    io == NULL || io->map >= IO_MAX_MAPS ||
+	    io->start > 0xffff || io->stop > 0xffff || io->start > io->stop)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+	map = io->map;
+
+	addrwin = exca_read_byte(slot, I365_ADDRWIN);
+	if (addrwin & I365_ENA_IO(map)) {
+		addrwin &= ~I365_ENA_IO(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	exca_write_word(slot, I365_IO(map)+I365_W_START, io->start);
+	exca_write_word(slot, I365_IO(map)+I365_W_STOP, io->stop);
+
+	ioctl = 0;
+	if (io->speed > 0)
+		ioctl |= I365_IOCTL_WAIT(map);
+	if (io->flags & MAP_16BIT)
+		ioctl |= I365_IOCTL_16BIT(map);
+	if (io->flags & MAP_AUTOSZ)
+		ioctl |= I365_IOCTL_IOCS16(map);
+	if (io->flags & MAP_0WS)
+		ioctl |= I365_IOCTL_0WS(map);
+	exca_write_byte(slot, I365_IOCTL, ioctl);
+
+	if (io->flags & MAP_ACTIVE) {
+		addrwin |= I365_ENA_IO(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	return 0;
+}
+
+static int pccard_get_mem_map(unsigned int slot, struct pccard_mem_map *mem)
+{
+	vrc4171_socket_t *socket;
+	uint8_t addrwin;
+	u_long start, stop;
+	u_int offset;
+	u_char map;
+
+	if (slot >= CARD_MAX_SLOTS || mem == NULL || mem->map >= MEM_MAX_MAPS)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+	map = mem->map;
+
+	mem->flags = 0;
+	mem->speed = 0;
+
+	addrwin = exca_read_byte(slot, I365_ADDRWIN);
+	if (addrwin & I365_ENA_MEM(map))
+		mem->flags |= MAP_ACTIVE;
+
+	start = exca_read_word(slot, I365_MEM(map)+I365_W_START);
+	if (start & I365_MEM_16BIT)
+		mem->flags |= MAP_16BIT;
+	mem->sys_start = (start & 0x3fffUL) << 12;
+
+	stop = exca_read_word(slot, I365_MEM(map)+I365_W_STOP);
+	if (start & I365_MEM_WS0)
+		mem->speed += 1;
+	if (start & I365_MEM_WS1)
+		mem->speed += 2;
+	mem->sys_stop = ((stop & 0x3fffUL) << 12) + 0xfffUL;
+
+	offset = exca_read_word(slot, I365_MEM(map)+I365_W_OFF);
+	if (offset & I365_MEM_REG)
+		mem->flags |= MAP_ATTRIB;
+	if (offset & I365_MEM_WRPROT)
+		mem->flags |= MAP_WRPROT;
+	mem->card_start = (offset & 0x3fffUL) << 12;
+
+	mem->sys_start += CARD_MEM_START;
+	mem->sys_stop += CARD_MEM_START;
+
+	return 0;
+}
+
+static int pccard_set_mem_map(unsigned int slot, struct pccard_mem_map *mem)
+{
+	vrc4171_socket_t *socket;
+	uint16_t start, stop, offset;
+	uint8_t addrwin;
+	u_char map;
+
+	if (slot >= CARD_MAX_SLOTS ||
+	    mem == NULL || mem->map >= MEM_MAX_MAPS ||
+	    mem->sys_start < CARD_MEM_START || mem->sys_start > CARD_MEM_END ||
+	    mem->sys_stop < CARD_MEM_START || mem->sys_stop > CARD_MEM_END ||
+	    mem->sys_start > mem->sys_stop ||
+	    mem->card_start > CARD_MAX_MEM_OFFSET ||
+	    mem->speed > CARD_MAX_MEM_SPEED)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+	map = mem->map;
+
+	addrwin = exca_read_byte(slot, I365_ADDRWIN);
+	if (addrwin & I365_ENA_MEM(map)) {
+		addrwin &= ~I365_ENA_MEM(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	start = (mem->sys_start >> 12) & 0x3fff;
+	if (mem->flags & MAP_16BIT)
+		start |= I365_MEM_16BIT;
+	exca_write_word(slot, I365_MEM(map)+I365_W_START, start);
+
+	stop = (mem->sys_stop >> 12) & 0x3fff;
+	switch (mem->speed) {
+	case 0:
+		break;
+	case 1:
+		stop |= I365_MEM_WS0;
+		break;
+	case 2:
+		stop |= I365_MEM_WS1;
+		break;
+	default:
+		stop |= I365_MEM_WS0 | I365_MEM_WS1;
+		break;
+	}
+	exca_write_word(slot, I365_MEM(map)+I365_W_STOP, stop);
+
+	offset = (mem->card_start >> 12) & 0x3fff;
+	if (mem->flags & MAP_ATTRIB)
+		offset |= I365_MEM_REG;
+	if (mem->flags & MAP_WRPROT)
+		offset |= I365_MEM_WRPROT;
+	exca_write_word(slot, I365_MEM(map)+I365_W_OFF, offset);
+
+	if (mem->flags & MAP_ACTIVE) {
+		addrwin |= I365_ENA_MEM(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	return 0;
+}
+
+static void pccard_proc_setup(unsigned int slot, struct proc_dir_entry *base)
+{          
+}
+
+static struct pccard_operations vrc4171_pccard_operations = {
+	.init			= pccard_init,
+	.suspend		= pccard_suspend,
+	.register_callback	= pccard_register_callback,
+	.inquire_socket		= pccard_inquire_socket,
+	.get_status		= pccard_get_status,
+	.get_socket		= pccard_get_socket,
+	.set_socket		= pccard_set_socket,
+	.get_io_map		= pccard_get_io_map,
+	.set_io_map		= pccard_set_io_map,
+	.get_mem_map		= pccard_get_mem_map,
+	.set_mem_map		= pccard_set_mem_map,
+	.proc_setup		= pccard_proc_setup,
+};
+
+static void pccard_bh(void *data)
+{
+	vrc4171_socket_t *socket = (vrc4171_socket_t *)data;
+	uint16_t events;
+
+	spin_lock_irq(&socket->event_lock);
+	events = socket->events;
+	socket->events = 0;
+	spin_unlock_irq(&socket->event_lock);
+ 
+	if (socket->handler)
+		socket->handler(socket->info, events);
+}
+
+static inline uint16_t get_events(int slot)
+{
+	uint16_t events = 0;
+	uint8_t status, csc;
+
+	status = exca_read_byte(slot, I365_STATUS);
+	csc = exca_read_byte(slot, I365_CSC);
+
+	if (exca_read_byte(slot, I365_INTCTL) & I365_PC_IOCARD) {
+		if ((csc & I365_CSC_STSCHG) && (status & I365_CS_STSCHG))
+			events |= SS_STSCHG;
+	} else {
+		if (csc & (I365_CSC_BVD1 | I365_CSC_BVD2)) {
+			if (!(status & I365_CS_BVD1))
+				events |= SS_BATDEAD;
+			else if ((status & (I365_CS_BVD1 | I365_CS_BVD2)) == I365_CS_BVD1)
+				events |= SS_BATWARN;
+		}
+	}
+	if ((csc & I365_CSC_READY) && (status & I365_CS_READY))
+		events |= SS_READY;
+	if ((csc & I365_CSC_DETECT) && ((status & I365_CS_DETECT) == I365_CS_DETECT))
+		events |= SS_DETECT;
+
+	return events;
+}
+
+static void pccard_status_change(int slot, vrc4171_socket_t *socket)
+{
+	uint16_t events;
+
+	socket->tq_task.routine = pccard_bh;
+	socket->tq_task.data = socket;
+
+	events = get_events(slot);
+	if (events) {
+		spin_lock(&socket->event_lock);
+		socket->events |= events;
+		spin_unlock(&socket->event_lock);
+		schedule_task(&socket->tq_task);
+	}
+}
+
+static void pccard_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	vrc4171_socket_t *socket;
+	uint16_t status;
+
+	status = vrc4171_get_irq_status();
+	if (status & IRQ_A) {
+		socket = &vrc4171_sockets[CARD_SLOTA];
+		if (socket->noprobe == SLOTB_PROBE) {
+			if (status & (1 << socket->csc_irq))
+				pccard_status_change(CARD_SLOTA, socket);
+		}
+	}
+
+	if (status & IRQ_B) {
+		socket = &vrc4171_sockets[CARD_SLOTB];
+		if (socket->noprobe == SLOTB_PROBE) {
+			if (status & (1 << socket->csc_irq))
+				pccard_status_change(CARD_SLOTB, socket);
+		}
+	}
+}
+
+static inline void reserve_using_irq(int slot)
+{
+	unsigned int irq;
+
+	irq = exca_read_byte(slot, I365_INTCTL);
+	irq &= 0x0f;
+	vrc4171_irq_mask &= ~(1 << irq);
+
+	irq = exca_read_byte(slot, I365_CSCINT);
+	irq = (irq & 0xf0) >> 4;
+	vrc4171_irq_mask &= ~(1 << irq);
+}
+
+static int __devinit vrc4171_add_socket(int slot)
+{
+	vrc4171_socket_t *socket;
+
+	if (slot >= CARD_MAX_SLOTS)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+	if (socket->noprobe != SLOTB_PROBE) {
+		uint8_t addrwin;
+
+		switch (socket->noprobe) {
+		case SLOTB_NOPROBE_MEM:
+			addrwin = exca_read_byte(slot, I365_ADDRWIN);
+			addrwin &= 0x1f;
+			exca_write_byte(slot, I365_ADDRWIN, addrwin);
+			break;
+		case SLOTB_NOPROBE_IO:
+			addrwin = exca_read_byte(slot, I365_ADDRWIN);
+			addrwin &= 0xc0;
+			exca_write_byte(slot, I365_ADDRWIN, addrwin);
+			break;
+		default:
+			break;
+		}
+
+		reserve_using_irq(slot);
+
+		return 0;
+	}
+
+	sprintf(socket->name, "NEC VRC4171 Card Slot %1c", 'A' + slot);
+
+	socket->pcmcia_socket = pcmcia_register_socket(slot, &vrc4171_pccard_operations, 1);
+	if (socket->pcmcia_socket == NULL)
+		return -ENOMEM;
+
+	exca_write_byte(slot, I365_ADDRWIN, 0);
+
+	exca_write_byte(slot, GLOBAL_CONTROL, 0);
+
+	return 0;
+}
+
+static void vrc4171_remove_socket(int slot)
+{
+	vrc4171_socket_t *socket;
+
+	if (slot >= CARD_MAX_SLOTS)
+		return;
+
+	socket = &vrc4171_sockets[slot];
+
+	if (socket->pcmcia_socket != NULL) {
+		pcmcia_unregister_socket(socket->pcmcia_socket);
+		socket->pcmcia_socket = NULL;
+	}
+}
+
+static int __devinit vrc4171_card_setup(char *options)
+{
+	if (options == NULL || *options == '\0')
+		return 0;
+
+	if (strncmp(options, "irq:", 4) == 0) {
+		int irq;
+		options += 4;
+		irq = simple_strtoul(options, &options, 0);
+		if (irq >= 0 && irq < NR_IRQS)
+			vrc4171_irq = irq;
+
+		if (*options != ',')
+			return 0;
+		options++;
+	}
+
+	if (strncmp(options, "slota:", 6) == 0) {
+		options += 6;
+		if (*options != '\0') {
+			if (strncmp(options, "noprobe", 7) == 0) {
+				vrc4171_sockets[CARD_SLOTA].noprobe = 1;
+				options += 7;
+			}
+
+			if (*options != ',')
+				return 0;
+			options++;
+		} else
+			return 0;
+
+	}
+
+	if (strncmp(options, "slotb:", 6) == 0) {
+		options += 6;
+		if (*options != '\0') {
+			if (strncmp(options, "pccard", 6) == 0) {
+				vrc4171_slotb = SLOTB_IS_PCCARD;
+				options += 6;
+			} else if (strncmp(options, "cf", 2) == 0) {
+				vrc4171_slotb = SLOTB_IS_CF;
+				options += 2;
+			} else if (strncmp(options, "flashrom", 8) == 0) {
+				vrc4171_slotb = SLOTB_IS_FLASHROM;
+				options += 8;
+			} else if (strncmp(options, "none", 4) == 0) {
+				vrc4171_slotb = SLOTB_IS_NONE;
+				options += 4;
+			}
+
+			if (*options != ',')
+				return 0;
+			options++;
+
+			if ( strncmp(options, "memnoprobe", 10) == 0)
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOTB_NOPROBE_MEM;
+			if ( strncmp(options, "ionoprobe", 9) == 0)
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOTB_NOPROBE_IO;
+			if ( strncmp(options, "noprobe", 7) == 0)
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOTB_NOPROBE_ALL;
+		}
+	}
+
+	return 0;
+}
+
+__setup("vrc4171_card=", vrc4171_card_setup);
+
+static int __devinit vrc4171_card_init(void)
+{
+	int retval, slot;
+
+	vrc4171_set_multifunction_pin(vrc4171_slotb);
+
+	if (request_region(CARD_CONTROLLER_INDEX, CARD_CONTROLLER_SIZE,
+	                       "NEC VRC4171 Card Controller") == NULL)
+		return -EBUSY;
+
+	for (slot = 0; slot < CARD_MAX_SLOTS; slot++) {
+		if (slot == CARD_SLOTB && vrc4171_slotb == SLOTB_IS_NONE)
+			break;
+
+		retval = vrc4171_add_socket(slot);
+		if (retval != 0)
+			return retval;
+	}
+
+	retval = request_irq(vrc4171_irq, pccard_interrupt, SA_SHIRQ,
+	                     "NEC VRC4171 Card Controller", vrc4171_sockets);
+	if (retval < 0) {
+		for (slot = 0; slot < CARD_MAX_SLOTS; slot++)
+			vrc4171_remove_socket(slot);
+
+		return retval;
+	}
+
+	printk(KERN_INFO "NEC VRC4171 Card Controller, connected to IRQ %d\n", vrc4171_irq);
+
+	return 0;
+}
+
+static void __devexit vrc4171_card_exit(void)
+{
+	int slot;
+
+	for (slot = 0; slot < CARD_MAX_SLOTS; slot++)
+		vrc4171_remove_socket(slot);
+
+	release_region(CARD_CONTROLLER_INDEX, CARD_CONTROLLER_SIZE);
+}
+
+module_init(vrc4171_card_init);
+module_exit(vrc4171_card_exit);
diff -Nur linux-2.4.30/drivers/scsi/NCR53C9x.h linux-2.4.30-mips/drivers/scsi/NCR53C9x.h
--- linux-2.4.30/drivers/scsi/NCR53C9x.h	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/scsi/NCR53C9x.h	2003-12-15 19:19:51.000000000 +0100
@@ -144,12 +144,7 @@
 
 #ifndef MULTIPLE_PAD_SIZES
 
-#ifdef CONFIG_CPU_HAS_WB
-#include <asm/wbflush.h>
-#define esp_write(__reg, __val) do{(__reg) = (__val); wbflush();} while(0)
-#else
-#define esp_write(__reg, __val) ((__reg) = (__val))
-#endif
+#define esp_write(__reg, __val) do{(__reg) = (__val); iob();} while(0)
 #define esp_read(__reg) (__reg)
 
 struct ESP_regs {
diff -Nur linux-2.4.30/drivers/sound/au1550_i2s.c linux-2.4.30-mips/drivers/sound/au1550_i2s.c
--- linux-2.4.30/drivers/sound/au1550_i2s.c	2005-01-19 15:10:04.000000000 +0100
+++ linux-2.4.30-mips/drivers/sound/au1550_i2s.c	2005-02-08 08:07:50.000000000 +0100
@@ -41,6 +41,7 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  *
  */
+
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/string.h>
@@ -62,7 +63,45 @@
 #include <asm/uaccess.h>
 #include <asm/hardirq.h>
 #include <asm/au1000.h>
+
+#if defined(CONFIG_SOC_AU1550)
 #include <asm/pb1550.h>
+#endif
+
+#if defined(CONFIG_MIPS_PB1200)
+#define WM8731
+#define WM_MODE_USB
+#include <asm/pb1200.h>
+#endif
+
+#if defined(CONFIG_MIPS_FICMMP)
+#define WM8721
+#define WM_MODE_NORMAL
+#include <asm/ficmmp.h>
+#endif
+
+
+#define WM_VOLUME_MIN	47
+#define WM_VOLUME_SCALE	80
+
+#if defined(WM8731)
+	/* OSS interface to the wm i2s.. */
+	#define CODEC_NAME "Wolfson WM8731 I2S"
+	#define WM_I2S_STEREO_MASK (SOUND_MASK_PCM | SOUND_MASK_LINE)
+	#define WM_I2S_SUPPORTED_MASK (WM_I2S_STEREO_MASK | SOUND_MASK_MIC)
+	#define WM_I2S_RECORD_MASK (SOUND_MASK_MIC | SOUND_MASK_LINE1 | SOUND_MASK_LINE)
+#elif defined(WM8721)
+	#define CODEC_NAME "Wolfson WM8721 I2S"
+	#define WM_I2S_STEREO_MASK (SOUND_MASK_PCM)
+	#define WM_I2S_SUPPORTED_MASK (WM_I2S_STEREO_MASK)
+	#define WM_I2S_RECORD_MASK (0)
+#endif
+
+
+#define supported_mixer(FOO) ((FOO >= 0) && \
+                                    (FOO < SOUND_MIXER_NRDEVICES) && \
+                                    WM_I2S_SUPPORTED_MASK & (1<<FOO) )
+
 #include <asm/au1xxx_psc.h>
 #include <asm/au1xxx_dbdma.h>
 
@@ -98,13 +137,51 @@
  * 0 = no VRA, 1 = use VRA if codec supports it
  * The framework is here, but we currently force no VRA.
  */
+#if defined(CONFIG_MIPS_PB1200) | defined(CONFIG_MIPS_PB1550)
 static int      vra = 0;
+#elif defined(CONFIG_MIPS_FICMMP)
+static int vra = 1;
+#endif
+
+#define WM_REG_L_HEADPHONE_OUT			0x02
+#define WM_REG_R_HEADPHONE_OUT			0x03
+#define WM_REG_ANALOGUE_AUDIO_PATH_CTRL		0x04
+#define WM_REG_DIGITAL_AUDIO_PATH_CTRL		0x05
+#define WM_REG_POWER_DOWN_CTRL			0x06
+#define WM_REG_DIGITAL_AUDIO_IF			0x07
+#define WM_REG_SAMPLING_CONTROL 		0x08
+#define WM_REG_ACTIVE_CTRL			0x09
+#define WM_REG_RESET				0x0F
+#define WM_SC_SR_96000		(0x7<<2)
+#define WM_SC_SR_88200		(0xF<<2)
+#define WM_SC_SR_48000		(0x0<<2)
+#define WM_SC_SR_44100		(0x8<<2)
+#define WM_SC_SR_32000		(0x6<<2)
+#define WM_SC_SR_8018		(0x9<<2)
+#define WM_SC_SR_8000		(0x1<<2)
+#define WM_SC_MODE_USB		1
+#define WM_SC_MODE_NORMAL	0
+#define WM_SC_BOSR_250FS	(0<<1)
+#define WM_SC_BOSR_272FS	(1<<1)
+#define WM_SC_BOSR_256FS	(0<<1)
+#define WM_SC_BOSR_128FS	(0<<1)
+#define WM_SC_BOSR_384FS	(1<<1)
+#define WM_SC_BOSR_192FS	(1<<1)
+
+#define WS_64FS			31
+#define WS_96FS			47
+#define WS_128FS		63
+#define WS_192FS		95
+
+#define MIN_Q_COUNT		2
+
 MODULE_PARM(vra, "i");
 MODULE_PARM_DESC(vra, "if 1 use VRA if codec supports it");
 
 static struct au1550_state {
 	/* soundcore stuff */
 	int             dev_audio;
+	int				dev_mixer;
 
 	spinlock_t		lock;
 	struct semaphore	open_sem;
@@ -114,6 +191,11 @@
 	int			no_vra;
 	volatile psc_i2s_t	*psc_addr;
 
+	int level_line;
+	int level_mic;
+	int level_left;
+	int level_right;
+
 	struct dmabuf {
 		u32		dmanr;
 		unsigned        sample_rate;
@@ -195,60 +277,224 @@
 	}
 }
 
-/* Just a place holder.  The Wolfson codec is a write only device,
- * so we would have to keep a local copy of the data.
- */
-#if 0
-static u8
-rdcodec(u8 addr)
-{
-	return 0  /* data */;
-}
-#endif
-
-
 static void
-wrcodec(u8 ctlreg, u8 val)
+wrcodec(u8 ctlreg, u16 val)
 {
 	int	rcnt;
 	extern int pb1550_wm_codec_write(u8 addr, u8 reg, u8 val);
-
 	/* The codec is a write only device, with a 16-bit control/data
 	 * word.  Although it is written as two bytes on the I2C, the
 	 * format is actually 7 bits of register and 9 bits of data.
 	 * The ls bit of the first byte is the ms bit of the data.
 	 */
 	rcnt = 0;
-	while ((pb1550_wm_codec_write((0x36 >> 1), ctlreg, val) != 1) 
-							&& (rcnt < 50)) {
+	while ((pb1550_wm_codec_write((0x36 >> 1), 
+					(ctlreg << 1) | ((val >> 8) & 0x01), 
+					(u8) (val & 0x00FF)) != 1) && 
+			(rcnt < 50)) {
 		rcnt++;
-#if 0
-		printk("Codec write retry %02x %02x\n", ctlreg, val);
-#endif
 	}
+
+	au1550_delay(10);
+}
+
+static int
+au1550_open_mixdev(struct inode *inode, struct file *file)
+{
+	file->private_data = &au1550_state;
+	return 0;
+}
+
+static int
+au1550_release_mixdev(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int wm_i2s_read_mixer(struct au1550_state *s, int oss_channel)
+{
+	int ret = 0;
+
+	if (WM_I2S_STEREO_MASK & (1 << oss_channel)) {
+		/* nice stereo mixers .. */
+
+		ret = s->level_left | (s->level_right << 8);
+	} else if (oss_channel == SOUND_MIXER_MIC) {
+		ret = 0;
+		/* TODO: Implement read mixer for input/output codecs */
+	}
+
+	return ret;
 }
 
+static void wm_i2s_write_mixer(struct au1550_state *s, int oss_channel, unsigned int left, unsigned int right)
+{
+	if (WM_I2S_STEREO_MASK & (1 << oss_channel)) {
+		/* stereo mixers */
+		s->level_left = left;
+		s->level_right = right;
+
+		right = (right * WM_VOLUME_SCALE) / 100;
+		left  = (left  * WM_VOLUME_SCALE) / 100;
+		if (right > WM_VOLUME_SCALE)
+			right = WM_VOLUME_SCALE;
+		if (left > WM_VOLUME_SCALE)
+			left = WM_VOLUME_SCALE;
+
+		right += WM_VOLUME_MIN;
+		left  += WM_VOLUME_MIN;
+
+		wrcodec(WM_REG_L_HEADPHONE_OUT, left);
+		wrcodec(WM_REG_R_HEADPHONE_OUT, right);
+
+	}else if (oss_channel == SOUND_MIXER_MIC) {
+		/* TODO: implement write mixer for input/output codecs */
+	}
+}
+
+/* a thin wrapper for write_mixer */
+static void wm_i2s_set_mixer(struct au1550_state *s, unsigned int oss_mixer, unsigned int val )
+{
+	unsigned int left,right;
+
+	/* cleanse input a little */
+	right = ((val >> 8)  & 0xff) ;
+	left = (val  & 0xff) ;
+
+	if (right > 100) right = 100;
+	if (left > 100) left = 100;
+
+	wm_i2s_write_mixer(s, oss_mixer, left, right);
+}
+
+static int
+au1550_ioctl_mixdev(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+
+	int i, val = 0;
+
+	if (cmd == SOUND_MIXER_INFO) {
+		mixer_info info;
+		strncpy(info.id, CODEC_NAME, sizeof(info.id));
+		strncpy(info.name, CODEC_NAME, sizeof(info.name));
+		info.modify_counter = 0;
+		if (copy_to_user((void *)arg, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+	if (cmd == SOUND_OLD_MIXER_INFO) {
+		_old_mixer_info info;
+		strncpy(info.id, CODEC_NAME, sizeof(info.id));
+		strncpy(info.name, CODEC_NAME, sizeof(info.name));
+		if (copy_to_user((void *)arg, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+
+	if (_IOC_TYPE(cmd) != 'M' || _SIOC_SIZE(cmd) != sizeof(int))
+		return -EINVAL;
+
+	if (cmd == OSS_GETVERSION)
+		return put_user(SOUND_VERSION, (int *)arg);
+
+	if (_SIOC_DIR(cmd) == _SIOC_READ) {
+		switch (_IOC_NR(cmd)) {
+		case SOUND_MIXER_RECSRC: /* give them the current record src */
+			val = 0;
+			/*
+			if (!codec->recmask_io) {
+				val = 0;
+			} else {
+				val = codec->recmask_io(codec, 1, 0);
+			}*/
+			break;
+
+		case SOUND_MIXER_DEVMASK: /* give them the supported mixers */
+			val = WM_I2S_SUPPORTED_MASK;
+			break;
+
+		case SOUND_MIXER_RECMASK: 
+			/* Arg contains a bit for each supported recording 
+			 * source */
+			val = WM_I2S_RECORD_MASK;
+			break;
+
+		case SOUND_MIXER_STEREODEVS: 
+			/* Mixer channels supporting stereo */
+			val = WM_I2S_STEREO_MASK;
+			break;
+
+		case SOUND_MIXER_CAPS:
+			val = SOUND_CAP_EXCL_INPUT;
+			break;
+
+		default: /* read a specific mixer */
+			i = _IOC_NR(cmd);
+
+			if (!supported_mixer(i))
+				return -EINVAL;
+
+			val = wm_i2s_read_mixer(s, i);
+ 			break;
+		}
+		return put_user(val, (int *)arg);
+	}
+
+	if (_SIOC_DIR(cmd) == (_SIOC_WRITE|_SIOC_READ)) {
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+
+		switch (_IOC_NR(cmd)) {
+		case SOUND_MIXER_RECSRC: 
+			/* Arg contains a bit for each recording source */
+			if (!WM_I2S_RECORD_MASK)
+				return -EINVAL;
+			if (!val)
+				return 0;
+			if (!(val &= WM_I2S_RECORD_MASK))
+				return -EINVAL;
+
+			return 0;
+		default: /* write a specific mixer */
+			i = _IOC_NR(cmd);
+
+			if (!supported_mixer(i))
+				return -EINVAL;
+
+			wm_i2s_set_mixer(s, i, val);
+
+			return 0;
+	}
+}
+	return -EINVAL;
+}
+
+static loff_t
+au1550_llseek(struct file *file, loff_t offset, int origin)
+{
+	return -ESPIPE;
+}
+
+static /*const */ struct file_operations au1550_mixer_fops = {
+	owner:THIS_MODULE,
+	llseek:au1550_llseek,
+	ioctl:au1550_ioctl_mixdev,
+	open:au1550_open_mixdev,
+	release:au1550_release_mixdev,
+};
+
 void
-codec_init(void)
+codec_init(struct au1550_state *s)
 {
-	wrcodec(0x1e, 0x00);	/* Reset */
-	au1550_delay(200);
-	wrcodec(0x0c, 0x00);	/* Power up everything */
-	au1550_delay(10);
-	wrcodec(0x12, 0x00);	/* Deactivate codec */
-	au1550_delay(10);
-	wrcodec(0x08, 0x10);	/* Select DAC outputs to line out */
-	au1550_delay(10);
-	wrcodec(0x0a, 0x00);	/* Disable output mute */
-	au1550_delay(10);
-	wrcodec(0x05, 0x70);	/* lower output volume on headphone */
-	au1550_delay(10);
-	wrcodec(0x0e, 0x02);	/* Set slave, 16-bit, I2S modes */
-	au1550_delay(10);
-	wrcodec(0x10, 0x01);	/* 12MHz (USB), 250fs */
-	au1550_delay(10);
-	wrcodec(0x12, 0x01);	/* Activate codec */
-	au1550_delay(10);
+	wrcodec(WM_REG_RESET, 0x00);	/* Reset */
+	wrcodec(WM_REG_POWER_DOWN_CTRL, 0x00);	/* Power up everything */
+	wrcodec(WM_REG_ACTIVE_CTRL, 0x00);	/* Deactivate codec */
+	wrcodec(WM_REG_ANALOGUE_AUDIO_PATH_CTRL, 0x10);	/* Select DAC outputs to line out */
+	wrcodec(WM_REG_DIGITAL_AUDIO_PATH_CTRL, 0x00);	/* Disable output mute */
+	wm_i2s_write_mixer(s, SOUND_MIXER_PCM, 74, 74);
+	wrcodec(WM_REG_DIGITAL_AUDIO_IF, 0x02);	/* Set slave, 16-bit, I2S modes */
+	wrcodec(WM_REG_ACTIVE_CTRL, 0x01);	/* Activate codec */
 }
 
 /* stop the ADC before calling */
@@ -256,27 +502,16 @@
 set_adc_rate(struct au1550_state *s, unsigned rate)
 {
 	struct dmabuf  *adc = &s->dma_adc;
-	struct dmabuf  *dac = &s->dma_dac;
 
-	if (s->no_vra) {
-		/* calc SRC factor
-		*/
+	#if defined(WM_MODE_USB)
 		adc->src_factor = (((SAMP_RATE*2) / rate) + 1) >> 1;
 		adc->sample_rate = SAMP_RATE / adc->src_factor;
 		return;
-	}
+	#else
+	//TODO: Need code for normal mode
+	#endif
 
 	adc->src_factor = 1;
-
-
-#if 0
-	rate = rate > SAMP_RATE ? SAMP_RATE : rate;
-
-	wrcodec(0, 0);	/* I don't yet know what to write here if we vra */
-
-	adc->sample_rate = rate;
-	dac->sample_rate = rate;
-#endif
 }
 
 /* stop the DAC before calling */
@@ -284,26 +519,89 @@
 set_dac_rate(struct au1550_state *s, unsigned rate)
 {
 	struct dmabuf  *dac = &s->dma_dac;
-	struct dmabuf  *adc = &s->dma_adc;
 
-	if (s->no_vra) {
-		/* calc SRC factor
-		*/
-		dac->src_factor = (((SAMP_RATE*2) / rate) + 1) >> 1;
-		dac->sample_rate = SAMP_RATE / dac->src_factor;
-		return;
+	u16 sr, ws, div, bosr, mode;
+	volatile psc_i2s_t* ip = (volatile psc_i2s_t *)I2S_PSC_BASE;
+	u32 cfg;
+
+	#if defined(CONFIG_MIPS_FICMMP)
+		rate = ficmmp_set_i2s_sample_rate(rate);
+	#endif
+
+	switch(rate)
+	{
+		case 96000: 
+			sr = WM_SC_SR_96000; 
+			ws = WS_64FS;  
+			div = PSC_I2SCFG_DIV2;  
+			break;
+		case 88200: 
+			sr = WM_SC_SR_88200; 
+			ws = WS_64FS;  
+			div = PSC_I2SCFG_DIV2;  
+			break;
+		case 44100: 
+			sr = WM_SC_SR_44100; 
+			ws = WS_128FS; 
+			div = PSC_I2SCFG_DIV2;  
+			break;
+		case 48000: 
+			sr = WM_SC_SR_48000; 
+			ws = WS_128FS; 
+			div = PSC_I2SCFG_DIV2;  
+			break;
+		case 32000: 
+			sr = WM_SC_SR_32000; 
+			ws = WS_96FS;  
+			div = PSC_I2SCFG_DIV4;  
+			break;
+		case  8018: 
+			sr = WM_SC_SR_8018;  
+			ws = WS_128FS; 
+			div = PSC_I2SCFG_DIV2;  
+			break;
+		case  8000:
+		default:    
+			sr = WM_SC_SR_8000;  
+			ws = WS_96FS;  
+			div = PSC_I2SCFG_DIV16; 
+			break;
 	}
 
+	#if defined(WM_MODE_USB)
+		mode = WM_SC_MODE_USB;
+	#else
+		mode = WM_SC_MODE_NORMAL;
+	#endif
+
+	bosr = 0;
+
 	dac->src_factor = 1;
+	dac->sample_rate = rate;
 
-#if 0
-	rate = rate > SAMP_RATE ? SAMP_RATE : rate;
+	/* Deactivate codec */
+	wrcodec(WM_REG_ACTIVE_CTRL, 0x00);
 
-	wrcodec(0, 0);	/* I don't yet know what to write here if we vra */
+	/* Disable I2S controller */
+	ip->psc_i2scfg &= ~PSC_I2SCFG_DE_ENABLE;
+	/* Wait for device disabled */
+	while ((ip->psc_i2sstat & PSC_I2SSTAT_DR) == 1);
+
+	cfg = ip->psc_i2scfg;
+	/* Clear WS and DIVIDER values */
+	cfg &= ~(PSC_I2SCFG_WS_MASK | PSC_I2SCFG_DIV_MASK);	
+	cfg |= PSC_I2SCFG_WS(ws) | div;
+	/* Reconfigure and enable */
+	ip->psc_i2scfg = cfg | PSC_I2SCFG_DE_ENABLE;	
 
-	adc->sample_rate = rate;
-	dac->sample_rate = rate;
-#endif
+	/* Wait for device enabled */
+	while ((ip->psc_i2sstat & PSC_I2SSTAT_DR) == 0);
+
+	/* Set appropriate sampling rate */
+	wrcodec(WM_REG_SAMPLING_CONTROL, bosr | mode | sr);
+
+	/* Activate codec */
+	wrcodec(WM_REG_ACTIVE_CTRL, 0x01);
 }
 
 static void
@@ -354,8 +652,7 @@
 	ip->psc_i2spcr = PSC_I2SPCR_RP;
 	au_sync();
 
-	/* Wait for Receive Busy to show disabled.
-	*/
+	/* Wait for Receive Busy to show disabled.  */
 	do {
 		stat = ip->psc_i2sstat;
 		au_sync();
@@ -463,7 +760,6 @@
 	if (db->num_channels == 1)
 		db->cnt_factor *= 2;
 	db->cnt_factor *= db->src_factor;
-
 	db->count = 0;
 	db->dma_qcount = 0;
 	db->nextIn = db->nextOut = db->rawbuf;
@@ -546,12 +842,13 @@
 	if (i2s_stat & (PSC_I2SSTAT_TF | PSC_I2SSTAT_TR | PSC_I2SSTAT_TF))
 		dbg("I2S status = 0x%08x", i2s_stat);
 #endif
+
 	db->dma_qcount--;
 
 	if (db->count >= db->fragsize) {
-		if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
-							db->fragsize) == 0) {
-			err("qcount < 2 and no ring room!");
+		if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut, db->fragsize) == 0)
+		{
+			err("qcount < MIN_Q_COUNT and no ring room!");
 		}
 		db->nextOut += db->fragsize;
 		if (db->nextOut >= db->rawbuf + db->dmasize)
@@ -606,65 +903,43 @@
 
 }
 
-static loff_t
-au1550_llseek(struct file *file, loff_t offset, int origin)
-{
-	return -ESPIPE;
-}
-
-
-#if 0
-static int
-au1550_open_mixdev(struct inode *inode, struct file *file)
-{
-	file->private_data = &au1550_state;
-	return 0;
-}
-
-static int
-au1550_release_mixdev(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static int
-mixdev_ioctl(struct ac97_codec *codec, unsigned int cmd,
-                        unsigned long arg)
-{
-	return codec->mixer_ioctl(codec, cmd, arg);
-}
-
-static int
-au1550_ioctl_mixdev(struct inode *inode, struct file *file,
-			       unsigned int cmd, unsigned long arg)
-{
-	struct au1550_state *s = (struct au1550_state *)file->private_data;
-	struct ac97_codec *codec = s->codec;
-
-	return mixdev_ioctl(codec, cmd, arg);
-}
-
-static /*const */ struct file_operations au1550_mixer_fops = {
-	owner:THIS_MODULE,
-	llseek:au1550_llseek,
-	ioctl:au1550_ioctl_mixdev,
-	open:au1550_open_mixdev,
-	release:au1550_release_mixdev,
-};
-#endif
-
 static int
 drain_dac(struct au1550_state *s, int nonblock)
 {
 	unsigned long   flags;
 	int             count, tmo;
 
+	struct dmabuf  *db = &s->dma_dac;
+
+	//DPRINTF();
 	if (s->dma_dac.mapped || !s->dma_dac.ready || s->dma_dac.stopped)
 		return 0;
 
 	for (;;) {
 		spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
+		count = db->count;
+
+		/* Pad the ddma buffer with zeros if the amount remaining 
+		 * is not a multiple of fragsize */
+		if(count % db->fragsize != 0)
+		{
+			int pad = db->fragsize - (count % db->fragsize);
+			char* bufptr = db->nextIn;
+			char* bufend = db->rawbuf + db->dmasize;
+
+			if((bufend - bufptr) < pad)
+				printk("Error!  ddma padding is bigger than available ring space!\n");
+			else
+			{
+				memset((void*)bufptr, 0, pad);
+				count += pad;
+				db->nextIn += pad;
+				db->count += pad;
+				if (db->dma_qcount == 0)
+						start_dac(s);
+				db->dma_qcount++;
+			}
+		}
 		spin_unlock_irqrestore(&s->lock, flags);
 		if (count <= 0)
 			break;
@@ -672,9 +947,9 @@
 			break;
 		if (nonblock)
 			return -EBUSY;
-		tmo = 1000 * count / (s->no_vra ?
-				      SAMP_RATE : s->dma_dac.sample_rate);
+		tmo = 1000 * count / s->dma_dac.sample_rate;
 		tmo /= s->dma_dac.dma_bytes_per_sample;
+
 		au1550_delay(tmo);
 	}
 	if (signal_pending(current))
@@ -698,8 +973,7 @@
  *     If interpolating (no VRA), duplicate every audio frame src_factor times.
  */
 static int
-translate_from_user(struct dmabuf *db, char* dmabuf, char* userbuf,
-							       int dmacount)
+translate_from_user(struct dmabuf *db, char* dmabuf, char* userbuf, int dmacount)
 {
 	int             sample, i;
 	int             interp_bytes_per_sample;
@@ -737,11 +1011,12 @@
 
 		/* duplicate every audio frame src_factor times
 		*/
-		for (i = 0; i < db->src_factor; i++)
+		for (i = 0; i < db->src_factor; i++) {
 			memcpy(dmabuf, dmasample, db->dma_bytes_per_sample);
+			dmabuf += interp_bytes_per_sample;
+		}
 
 		userbuf += db->user_bytes_per_sample;
-		dmabuf += interp_bytes_per_sample;
 	}
 
 	return num_samples * interp_bytes_per_sample;
@@ -996,15 +1271,14 @@
 		 * on the dma queue.  If the queue count reaches zero,
 		 * we know the dma has stopped.
 		 */
-		while ((db->dma_qcount < 2) && (db->count >= db->fragsize)) {
+		while ((db->dma_qcount < MIN_Q_COUNT) && (db->count >= db->fragsize)) {
 			if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
 							db->fragsize) == 0) {
-				err("qcount < 2 and no ring room!");
+				err("qcount < MIN_Q_COUNT and no ring room!");
 			}
 			db->nextOut += db->fragsize;
 			if (db->nextOut >= db->rawbuf + db->dmasize)
 				db->nextOut -= db->dmasize;
-			db->count -= db->fragsize;
 			db->total_bytes += db->dma_fragsize;
 			if (db->dma_qcount == 0)
 				start_dac(s);
@@ -1017,7 +1291,6 @@
 		buffer += usercnt;
 		ret += usercnt;
 	}			/* while (count > 0) */
-
 out:
 	up(&s->sem);
 out2:
@@ -1371,9 +1644,6 @@
 			s->dma_dac.cnt_factor;
 		abinfo.fragstotal = s->dma_dac.numfrag;
 		abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;
-#ifdef AU1000_VERBOSE_DEBUG
-		dbg("bytes=%d, fragments=%d", abinfo.bytes, abinfo.fragments);
-#endif
 		return copy_to_user((void *) arg, &abinfo,
 				    sizeof(abinfo)) ? -EFAULT : 0;
 
@@ -1536,13 +1806,9 @@
 	case SNDCTL_DSP_SETSYNCRO:
 	case SOUND_PCM_READ_FILTER:
 		return -EINVAL;
+	default: break;
 	}
-
-#if 0
-	return mixdev_ioctl(s->codec, cmd, arg);
-#else
 	return 0;
-#endif
 }
 
 
@@ -1664,15 +1930,15 @@
 MODULE_AUTHOR("Advanced Micro Devices (AMD), dan@embeddededge.com");
 MODULE_DESCRIPTION("Au1550 Audio Driver");
 
+#if defined(WM_MODE_USB)
 /* Set up an internal clock for the PSC3.  This will then get
  * driven out of the Au1550 as the master.
  */
 static void
 intclk_setup(void)
 {
-	uint	clk, rate, stat;
-
-	/* Wire up Freq4 as a clock for the PSC3.
+	uint	clk, rate;
+	/* Wire up Freq4 as a clock for the PSC.
 	 * We know SMBus uses Freq3.
 	 * By making changes to this rate, plus the word strobe
 	 * size, we can make fine adjustments to the actual data rate.
@@ -1700,11 +1966,17 @@
 	*/
 	clk = au_readl(SYS_CLKSRC);
 	au_sync();
+#if defined(CONFIG_SOC_AU1550)
 	clk &= ~0x01f00000;
 	clk |= (6 << 22);
+#elif defined(CONFIG_SOC_AU1200)
+	clk &= ~0x3e000000;
+	clk |= (6 << 27);
+#endif
 	au_writel(clk, SYS_CLKSRC);
 	au_sync();
 }
+#endif
 
 static int __devinit
 au1550_probe(void)
@@ -1724,6 +1996,11 @@
 	init_MUTEX(&s->open_sem);
 	spin_lock_init(&s->lock);
 
+	/* CPLD Mux for I2s */
+
+#if defined(CONFIG_MIPS_PB1200)
+	bcsr->resets |= BCSR_RESETS_PCS1MUX;
+#endif
 
 	s->psc_addr = (volatile psc_i2s_t *)I2S_PSC_BASE;
 	ip = s->psc_addr;
@@ -1765,9 +2042,8 @@
 
 	if ((s->dev_audio = register_sound_dsp(&au1550_audio_fops, -1)) < 0)
 		goto err_dev1;
-#if 0
-	if ((s->codec->dev_mixer =
-	     register_sound_mixer(&au1550_mixer_fops, -1)) < 0)
+#if 1
+	if ((s->dev_mixer = register_sound_mixer(&au1550_mixer_fops, -1)) < 0)
 		goto err_dev2;
 #endif
 
@@ -1777,7 +2053,6 @@
 				       proc_au1550_dump, NULL);
 #endif /* AU1550_DEBUG */
 
-	intclk_setup();
 
 	/* The GPIO for the appropriate PSC was configured by the
 	 * board specific start up.
@@ -1786,7 +2061,12 @@
 	 */
 	ip->psc_ctrl = PSC_CTRL_DISABLE;	/* Disable PSC */
 	au_sync();
+#if defined(WM_MODE_USB)
+	intclk_setup();
 	ip->psc_sel = (PSC_SEL_CLK_INTCLK | PSC_SEL_PS_I2SMODE);
+#else
+	ip->psc_sel = (PSC_SEL_CLK_EXTCLK | PSC_SEL_PS_I2SMODE);
+#endif
 	au_sync();
 
 	/* Enable PSC
@@ -1806,42 +2086,18 @@
 	 * Actual I2S mode (first bit delayed by one clock).
 	 * Master mode (We provide the clock from the PSC).
 	 */
-	val = PSC_I2SCFG_SET_LEN(16);
-#ifdef TRY_441KHz
-	/* This really should be 250, but it appears that all of the
-	 * PLLs, dividers and so on in the chain shift it.  That's the
-	 * problem with sourceing the clock instead of letting the very
-	 * stable codec provide it.  But, the PSC doesn't appear to want
-	 * to work in slave mode, so this is what we get.  It's  not
-	 * studio quality timing, but it's good enough for listening
-	 * to mp3s.
-	 */
-	val |= PSC_I2SCFG_SET_WS(252);
-#else
-	val |= PSC_I2SCFG_SET_WS(250);
-#endif
-	val |= PSC_I2SCFG_RT_FIFO8 | PSC_I2SCFG_TT_FIFO8 | \
+
+	val = PSC_I2SCFG_SET_LEN(16) | PSC_I2SCFG_WS(WS_128FS) | PSC_I2SCFG_RT_FIFO8 | PSC_I2SCFG_TT_FIFO8 | \
 					PSC_I2SCFG_BI | PSC_I2SCFG_XM;
 
-	ip->psc_i2scfg = val;
-	au_sync();
-	val |= PSC_I2SCFG_DE_ENABLE;
-	ip->psc_i2scfg = val;
-	au_sync();
+	ip->psc_i2scfg = val | PSC_I2SCFG_DE_ENABLE;
 
-	/* Wait for Device ready.
-	*/
-	do {
-		val = ip->psc_i2sstat;
-		au_sync();
-	} while ((val & PSC_I2SSTAT_DR) == 0);
+	set_dac_rate(s, 8000);  //Set default rate
 
-	val = ip->psc_i2scfg;
-	au_sync();
+	codec_init(s);
 
-	codec_init();
+	s->no_vra = vra ? 0 : 1;
 
-	s->no_vra = 1;
 	if (s->no_vra)
 		info("no VRA, interpolating and decimating");
 
@@ -1866,6 +2122,8 @@
  err_dev2:
 	unregister_sound_dsp(s->dev_audio);
 #endif
+ err_dev2:
+	unregister_sound_dsp(s->dev_audio);
  err_dev1:
 	au1xxx_dbdma_chan_free(s->dma_adc.dmanr);
  err_dma2:
diff -Nur linux-2.4.30/drivers/sound/au1550_psc.c linux-2.4.30-mips/drivers/sound/au1550_psc.c
--- linux-2.4.30/drivers/sound/au1550_psc.c	2005-01-19 15:10:04.000000000 +0100
+++ linux-2.4.30-mips/drivers/sound/au1550_psc.c	2005-01-30 09:01:28.000000000 +0100
@@ -30,6 +30,7 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  *
  */
+
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/string.h>
@@ -63,6 +64,14 @@
 #include <asm/db1x00.h>
 #endif
 
+#ifdef CONFIG_MIPS_PB1200
+#include <asm/pb1200.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+#include <asm/db1200.h>
+#endif
+
 #undef OSS_DOCUMENTED_MIXER_SEMANTICS
 
 #define AU1550_MODULE_NAME "Au1550 psc audio"
@@ -521,7 +530,14 @@
 	spin_unlock_irqrestore(&s->lock, flags);
 }
 
-
+/* 
+   NOTE: The xmit slots cannot be changed on the fly when in full-duplex 
+   because the AC'97 block must be stopped/started.  When using this driver 
+   in full-duplex (in & out at the same time), the DMA engine will stop if 
+   you disable the block.
+   TODO: change implementation to properly restart adc/dac after setting 
+   xmit slots.
+*/
 static void
 set_xmit_slots(int num_channels)
 {
@@ -565,6 +581,14 @@
 	} while ((stat & PSC_AC97STAT_DR) == 0);
 }
 
+/* 
+   NOTE: The recv slots cannot be changed on the fly when in full-duplex 
+   because the AC'97 block must be stopped/started.  When using this driver 
+   in full-duplex (in & out at the same time), the DMA engine will stop if 
+   you disable the block.
+   TODO: change implementation to properly restart adc/dac after setting 
+   recv slots.
+*/
 static void
 set_recv_slots(int num_channels)
 {
@@ -608,7 +632,6 @@
 
 	spin_lock_irqsave(&s->lock, flags);
 
-	set_xmit_slots(db->num_channels);
 	au_writel(PSC_AC97PCR_TC, PSC_AC97PCR);
 	au_sync();
 	au_writel(PSC_AC97PCR_TS, PSC_AC97PCR);
@@ -640,7 +663,6 @@
 			db->nextIn -= db->dmasize;
 	}
 
-	set_recv_slots(db->num_channels);
 	au1xxx_dbdma_start(db->dmanr);
 	au_writel(PSC_AC97PCR_RC, PSC_AC97PCR);
 	au_sync();
@@ -752,12 +774,16 @@
 	if (ac97c_stat & (AC97C_XU | AC97C_XO | AC97C_TE))
 		dbg("AC97C status = 0x%08x", ac97c_stat);
 #endif
+	/* There is a possiblity that we are getting 1 interrupt for
+	   multiple descriptors. Use ddma api to find out how many
+	   completed.
+	*/
 	db->dma_qcount--;
 
 	if (db->count >= db->fragsize) {
 		if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
 							db->fragsize) == 0) {
-			err("qcount < 2 and no ring room!");
+			err("qcount < 2 and no ring room1!");
 		}
 		db->nextOut += db->fragsize;
 		if (db->nextOut >= db->rawbuf + db->dmasize)
@@ -941,11 +967,12 @@
 
 		/* duplicate every audio frame src_factor times
 		*/
-		for (i = 0; i < db->src_factor; i++)
+		for (i = 0; i < db->src_factor; i++) {
 			memcpy(dmabuf, dmasample, db->dma_bytes_per_sample);
+			dmabuf += interp_bytes_per_sample;
+		}
 
 		userbuf += db->user_bytes_per_sample;
-		dmabuf += interp_bytes_per_sample;
 	}
 
 	return num_samples * interp_bytes_per_sample;
@@ -1203,7 +1230,7 @@
 		while ((db->dma_qcount < 2) && (db->count >= db->fragsize)) {
 			if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
 							db->fragsize) == 0) {
-				err("qcount < 2 and no ring room!");
+				err("qcount < 2 and no ring room!0");
 			}
 			db->nextOut += db->fragsize;
 			if (db->nextOut >= db->rawbuf + db->dmasize)
@@ -1481,6 +1508,7 @@
 					return -EINVAL;
 				stop_adc(s);
 				s->dma_adc.num_channels = val;
+				set_recv_slots(val);
 				if ((ret = prog_dmabuf_adc(s)))
 					return ret;
 			}
@@ -1538,6 +1566,7 @@
 				}
 
 				s->dma_dac.num_channels = val;
+				set_xmit_slots(val);
 				if ((ret = prog_dmabuf_dac(s)))
 					return ret;
 			}
@@ -1832,10 +1861,8 @@
 		down(&s->open_sem);
 	}
 
-	stop_dac(s);
-	stop_adc(s);
-
 	if (file->f_mode & FMODE_READ) {
+		stop_adc(s);
 		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags =
 			s->dma_adc.subdivision = s->dma_adc.total_bytes = 0;
 		s->dma_adc.num_channels = 1;
@@ -1846,6 +1873,7 @@
 	}
 
 	if (file->f_mode & FMODE_WRITE) {
+		stop_dac(s);
 		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags =
 			s->dma_dac.subdivision = s->dma_dac.total_bytes = 0;
 		s->dma_dac.num_channels = 1;
@@ -2091,6 +2119,9 @@
 					     ac97_read_proc, &s->codec);
 #endif
 
+	set_xmit_slots(1);
+	set_recv_slots(1);
+
 	return 0;
 
  err_dev3:
diff -Nur linux-2.4.30/drivers/tc/lk201.c linux-2.4.30-mips/drivers/tc/lk201.c
--- linux-2.4.30/drivers/tc/lk201.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/tc/lk201.c	2004-09-28 02:53:04.000000000 +0200
@@ -5,7 +5,7 @@
  * for more details.
  *
  * Copyright (C) 1999-2002 Harald Koerfgen <hkoerfg@web.de>
- * Copyright (C) 2001, 2002, 2003  Maciej W. Rozycki <macro@ds2.pg.gda.pl>
+ * Copyright (C) 2001, 2002, 2003, 2004  Maciej W. Rozycki
  */
 
 #include <linux/config.h>
@@ -23,8 +23,8 @@
 #include <asm/keyboard.h>
 #include <asm/dec/tc.h>
 #include <asm/dec/machtype.h>
+#include <asm/dec/serial.h>
 
-#include "zs.h"
 #include "lk201.h"
 
 /*
@@ -55,19 +55,20 @@
 unsigned char kbd_sysrq_key = -1;
 #endif
 
-#define KEYB_LINE	3
+#define KEYB_LINE_ZS	3
+#define KEYB_LINE_DZ	0
 
-static int __init lk201_init(struct dec_serial *);
-static void __init lk201_info(struct dec_serial *);
-static void lk201_kbd_rx_char(unsigned char, unsigned char);
+static int __init lk201_init(void *);
+static void __init lk201_info(void *);
+static void lk201_rx_char(unsigned char, unsigned char);
 
-struct zs_hook lk201_kbdhook = {
+static struct dec_serial_hook lk201_hook = {
 	.init_channel	= lk201_init,
 	.init_info	= lk201_info,
 	.rx_char	= NULL,
 	.poll_rx_char	= NULL,
 	.poll_tx_char	= NULL,
-	.cflags		= B4800 | CS8 | CSTOPB | CLOCAL
+	.cflags		= B4800 | CS8 | CSTOPB | CLOCAL,
 };
 
 /*
@@ -93,28 +94,28 @@
 	LK_CMD_ENB_BELL, LK_PARAM_VOLUME(4),
 };
 
-static struct dec_serial* lk201kbd_info;
+static void *lk201_handle;
 
-static int lk201_send(struct dec_serial *info, unsigned char ch)
+static int lk201_send(unsigned char ch)
 {
-	if (info->hook->poll_tx_char(info, ch)) {
+	if (lk201_hook.poll_tx_char(lk201_handle, ch)) {
 		printk(KERN_ERR "lk201: transmit timeout\n");
 		return -EIO;
 	}
 	return 0;
 }
 
-static inline int lk201_get_id(struct dec_serial *info)
+static inline int lk201_get_id(void)
 {
-	return lk201_send(info, LK_CMD_REQ_ID);
+	return lk201_send(LK_CMD_REQ_ID);
 }
 
-static int lk201_reset(struct dec_serial *info)
+static int lk201_reset(void)
 {
 	int i, r;
 
 	for (i = 0; i < sizeof(lk201_reset_string); i++) {
-		r = lk201_send(info, lk201_reset_string[i]);
+		r = lk201_send(lk201_reset_string[i]);
 		if (r < 0)
 			return r;
 	}
@@ -203,24 +204,26 @@
 
 static int write_kbd_rate(struct kbd_repeat *rep)
 {
-	struct dec_serial* info = lk201kbd_info;
 	int delay, rate;
 	int i;
 
 	delay = rep->delay / 5;
 	rate = rep->rate;
 	for (i = 0; i < 4; i++) {
-		if (info->hook->poll_tx_char(info, LK_CMD_RPT_RATE(i)))
+		if (lk201_hook.poll_tx_char(lk201_handle,
+					    LK_CMD_RPT_RATE(i)))
 			return 1;
-		if (info->hook->poll_tx_char(info, LK_PARAM_DELAY(delay)))
+		if (lk201_hook.poll_tx_char(lk201_handle,
+					    LK_PARAM_DELAY(delay)))
 			return 1;
-		if (info->hook->poll_tx_char(info, LK_PARAM_RATE(rate)))
+		if (lk201_hook.poll_tx_char(lk201_handle,
+					    LK_PARAM_RATE(rate)))
 			return 1;
 	}
 	return 0;
 }
 
-static int lk201kbd_rate(struct kbd_repeat *rep)
+static int lk201_kbd_rate(struct kbd_repeat *rep)
 {
 	if (rep == NULL)
 		return -EINVAL;
@@ -237,10 +240,8 @@
 	return 0;
 }
 
-static void lk201kd_mksound(unsigned int hz, unsigned int ticks)
+static void lk201_kd_mksound(unsigned int hz, unsigned int ticks)
 {
-	struct dec_serial* info = lk201kbd_info;
-
 	if (!ticks)
 		return;
 
@@ -253,20 +254,19 @@
 		ticks = 7;
 	ticks = 7 - ticks;
 
-	if (info->hook->poll_tx_char(info, LK_CMD_ENB_BELL))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_ENB_BELL))
 		return;
-	if (info->hook->poll_tx_char(info, LK_PARAM_VOLUME(ticks)))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_PARAM_VOLUME(ticks)))
 		return;
-	if (info->hook->poll_tx_char(info, LK_CMD_BELL))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_BELL))
 		return;
 }
 
 void kbd_leds(unsigned char leds)
 {
-	struct dec_serial* info = lk201kbd_info;
 	unsigned char l = 0;
 
-	if (!info)		/* FIXME */
+	if (!lk201_handle)		/* FIXME */
 		return;
 
 	/* FIXME -- Only Hold and Lock LEDs for now. --macro */
@@ -275,13 +275,13 @@
 	if (leds & LED_CAP)
 		l |= LK_LED_LOCK;
 
-	if (info->hook->poll_tx_char(info, LK_CMD_LEDS_ON))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_LEDS_ON))
 		return;
-	if (info->hook->poll_tx_char(info, LK_PARAM_LED_MASK(l)))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_PARAM_LED_MASK(l)))
 		return;
-	if (info->hook->poll_tx_char(info, LK_CMD_LEDS_OFF))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_LEDS_OFF))
 		return;
-	if (info->hook->poll_tx_char(info, LK_PARAM_LED_MASK(~l)))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_PARAM_LED_MASK(~l)))
 		return;
 }
 
@@ -307,7 +307,7 @@
 	return 0x80;
 }
 
-static void lk201_kbd_rx_char(unsigned char ch, unsigned char stat)
+static void lk201_rx_char(unsigned char ch, unsigned char fl)
 {
 	static unsigned char id[6];
 	static int id_i;
@@ -316,9 +316,8 @@
 	static int prev_scancode;
 	unsigned char c = scancodeRemap[ch];
 
-	if (stat && stat != TTY_OVERRUN) {
-		printk(KERN_ERR "lk201: keyboard receive error: 0x%02x\n",
-		       stat);
+	if (fl != TTY_NORMAL && fl != TTY_OVERRUN) {
+		printk(KERN_ERR "lk201: keyboard receive error: 0x%02x\n", fl);
 		return;
 	}
 
@@ -335,7 +334,7 @@
 			/* OK, the power-up concluded. */
 			lk201_report(id);
 			if (id[2] == LK_STAT_PWRUP_OK)
-				lk201_get_id(lk201kbd_info);
+				lk201_get_id();
 			else {
 				id_i = 0;
 				printk(KERN_ERR "lk201: keyboard power-up "
@@ -345,7 +344,7 @@
 			/* We got the ID; report it and start operation. */
 			id_i = 0;
 			lk201_id(id);
-			lk201_reset(lk201kbd_info);
+			lk201_reset();
 		}
 		return;
 	}
@@ -398,29 +397,28 @@
 	tasklet_schedule(&keyboard_tasklet);
 }
 
-static void __init lk201_info(struct dec_serial *info)
+static void __init lk201_info(void *handle)
 {
 }
 
-static int __init lk201_init(struct dec_serial *info)
+static int __init lk201_init(void *handle)
 {
 	/* First install handlers. */
-	lk201kbd_info = info;
-	kbd_rate = lk201kbd_rate;
-	kd_mksound = lk201kd_mksound;
+	lk201_handle = handle;
+	kbd_rate = lk201_kbd_rate;
+	kd_mksound = lk201_kd_mksound;
 
-	info->hook->rx_char = lk201_kbd_rx_char;
+	lk201_hook.rx_char = lk201_rx_char;
 
 	/* Then just issue a reset -- the handlers will do the rest. */
-	lk201_send(info, LK_CMD_POWER_UP);
+	lk201_send(LK_CMD_POWER_UP);
 
 	return 0;
 }
 
 void __init kbd_init_hw(void)
 {
-	extern int register_zs_hook(unsigned int, struct zs_hook *);
-	extern int unregister_zs_hook(unsigned int);
+	int keyb_line;
 
 	/* Maxine uses LK501 at the Access.Bus. */
 	if (!LK_IFACE)
@@ -428,19 +426,15 @@
 
 	printk(KERN_INFO "lk201: DECstation LK keyboard driver v0.05.\n");
 
-	if (LK_IFACE_ZS) {
-		/*
-		 * kbd_init_hw() is being called before
-		 * rs_init() so just register the kbd hook
-		 * and let zs_init do the rest :-)
-		 */
-		if(!register_zs_hook(KEYB_LINE, &lk201_kbdhook))
-			unregister_zs_hook(KEYB_LINE);
-	} else {
-		/*
-		 * TODO: modify dz.c to allow similar hooks
-		 * for LK201 handling on DS2100, DS3100, and DS5000/200
-		 */
-		printk(KERN_ERR "lk201: support for DZ11 not yet ready.\n");
-	}
+	/*
+	 * kbd_init_hw() is being called before
+	 * rs_init() so just register the kbd hook
+	 * and let zs_init do the rest :-)
+	 */
+	if (LK_IFACE_ZS)
+		keyb_line = KEYB_LINE_ZS;
+	else
+		keyb_line = KEYB_LINE_DZ;
+	if (!register_dec_serial_hook(keyb_line, &lk201_hook))
+		unregister_dec_serial_hook(keyb_line);
 }
diff -Nur linux-2.4.30/drivers/tc/zs.c linux-2.4.30-mips/drivers/tc/zs.c
--- linux-2.4.30/drivers/tc/zs.c	2005-01-19 15:10:05.000000000 +0100
+++ linux-2.4.30-mips/drivers/tc/zs.c	2004-12-27 05:13:50.000000000 +0100
@@ -68,6 +68,8 @@
 #include <asm/bitops.h>
 #include <asm/uaccess.h>
 #include <asm/bootinfo.h>
+#include <asm/dec/serial.h>
+
 #ifdef CONFIG_DECSTATION
 #include <asm/dec/interrupts.h>
 #include <asm/dec/machtype.h>
@@ -160,8 +162,8 @@
 #ifdef CONFIG_SERIAL_DEC_CONSOLE
 static struct console sercons;
 #endif
-#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) \
-    && !defined(MODULE)
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
 static unsigned long break_pressed; /* break, really ... */
 #endif
 
@@ -196,7 +198,6 @@
 /*
  * Debugging.
  */
-#undef SERIAL_DEBUG_INTR
 #undef SERIAL_DEBUG_OPEN
 #undef SERIAL_DEBUG_FLOW
 #undef SERIAL_DEBUG_THROTTLE
@@ -221,10 +222,6 @@
 static struct termios *serial_termios[NUM_CHANNELS];
 static struct termios *serial_termios_locked[NUM_CHANNELS];
 
-#ifndef MIN
-#define MIN(a,b)	((a) < (b) ? (a) : (b))
-#endif
-
 /*
  * tmp_buf is used as a temporary buffer by serial_write.  We need to
  * lock it in case the copy_from_user blocks while swapping in a page,
@@ -386,8 +383,6 @@
  * -----------------------------------------------------------------------
  */
 
-static int tty_break;	/* Set whenever BREAK condition is detected.  */
-
 /*
  * This routine is used by the interrupt handler to schedule
  * processing in the software interrupt portion of the driver.
@@ -414,20 +409,15 @@
 		if (!tty && (!info->hook || !info->hook->rx_char))
 			continue;
 
-		if (tty_break) {
-			tty_break = 0;
-#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && !defined(MODULE)
-			if (info->line == sercons.index) {
-				if (!break_pressed) {
-					break_pressed = jiffies;
-					goto ignore_char;
-				}
-				break_pressed = 0;
-			}
-#endif
+		flag = TTY_NORMAL;
+		if (info->tty_break) {
+			info->tty_break = 0;
 			flag = TTY_BREAK;
 			if (info->flags & ZILOG_SAK)
 				do_SAK(tty);
+			/* Ignore the null char got when BREAK is removed.  */
+			if (ch == 0)
+				continue;
 		} else {
 			if (stat & Rx_OVR) {
 				flag = TTY_OVERRUN;
@@ -435,20 +425,22 @@
 				flag = TTY_FRAME;
 			} else if (stat & PAR_ERR) {
 				flag = TTY_PARITY;
-			} else
-				flag = 0;
-			if (flag)
+			}
+			if (flag != TTY_NORMAL)
 				/* reset the error indication */
 				write_zsreg(info->zs_channel, R0, ERR_RES);
 		}
 
-#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && !defined(MODULE)
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
 		if (break_pressed && info->line == sercons.index) {
-			if (ch != 0 &&
-			    time_before(jiffies, break_pressed + HZ*5)) {
+			/* Ignore the null char got when BREAK is removed.  */
+			if (ch == 0)
+				continue;
+			if (time_before(jiffies, break_pressed + HZ * 5)) {
 				handle_sysrq(ch, regs, NULL, NULL);
 				break_pressed = 0;
-				goto ignore_char;
+				continue;
 			}
 			break_pressed = 0;
 		}
@@ -459,23 +451,7 @@
 			return;
   		}
 
-		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
-			static int flip_buf_ovf;
-			++flip_buf_ovf;
-			continue;
-		}
-		tty->flip.count++;
-		{
-			static int flip_max_cnt;
-			if (flip_max_cnt < tty->flip.count)
-				flip_max_cnt = tty->flip.count;
-		}
-
-		*tty->flip.flag_buf_ptr++ = flag;
-		*tty->flip.char_buf_ptr++ = ch;
-#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && !defined(MODULE)
-	ignore_char:
-#endif
+		tty_insert_flip_char(tty, ch, flag);
 	}
 	if (tty)
 		tty_flip_buffer_push(tty);
@@ -517,11 +493,15 @@
 	/* Get status from Read Register 0 */
 	stat = read_zsreg(info->zs_channel, R0);
 
-	if (stat & BRK_ABRT) {
-#ifdef SERIAL_DEBUG_INTR
-		printk("handling break....");
+	if ((stat & BRK_ABRT) && !(info->read_reg_zero & BRK_ABRT)) {
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
+		if (info->line == sercons.index) {
+			if (!break_pressed)
+				break_pressed = jiffies;
+		} else
 #endif
-		tty_break = 1;
+			info->tty_break = 1;
 	}
 
 	if (info->zs_channel != info->zs_chan_a) {
@@ -957,7 +937,7 @@
 	save_flags(flags);
 	while (1) {
 		cli();
-		c = MIN(count, MIN(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+		c = min(count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
 				   SERIAL_XMIT_SIZE - info->xmit_head));
 		if (c <= 0)
 			break;
@@ -965,7 +945,7 @@
 		if (from_user) {
 			down(&tmp_buf_sem);
 			copy_from_user(tmp_buf, buf, c);
-			c = MIN(c, MIN(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+			c = min(c, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
 				       SERIAL_XMIT_SIZE - info->xmit_head));
 			memcpy(info->xmit_buf + info->xmit_head, tmp_buf, c);
 			up(&tmp_buf_sem);
@@ -1282,46 +1262,48 @@
 	}
 
 	switch (cmd) {
-		case TIOCMGET:
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-				sizeof(unsigned int));
-			if (error)
-				return error;
-			return get_modem_info(info, (unsigned int *) arg);
-		case TIOCMBIS:
-		case TIOCMBIC:
-		case TIOCMSET:
-			return set_modem_info(info, cmd, (unsigned int *) arg);
-		case TIOCGSERIAL:
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-						sizeof(struct serial_struct));
-			if (error)
-				return error;
-			return get_serial_info(info,
-					       (struct serial_struct *) arg);
-		case TIOCSSERIAL:
-			return set_serial_info(info,
-					       (struct serial_struct *) arg);
-		case TIOCSERGETLSR: /* Get line status register */
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-				sizeof(unsigned int));
-			if (error)
-				return error;
-			else
-			    return get_lsr_info(info, (unsigned int *) arg);
+	case TIOCMGET:
+		error = verify_area(VERIFY_WRITE, (void *)arg,
+				    sizeof(unsigned int));
+		if (error)
+			return error;
+		return get_modem_info(info, (unsigned int *)arg);
 
-		case TIOCSERGSTRUCT:
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-						sizeof(struct dec_serial));
-			if (error)
-				return error;
-			copy_from_user((struct dec_serial *) arg,
-				       info, sizeof(struct dec_serial));
-			return 0;
+	case TIOCMBIS:
+	case TIOCMBIC:
+	case TIOCMSET:
+		return set_modem_info(info, cmd, (unsigned int *)arg);
 
-		default:
-			return -ENOIOCTLCMD;
-		}
+	case TIOCGSERIAL:
+		error = verify_area(VERIFY_WRITE, (void *)arg,
+				    sizeof(struct serial_struct));
+		if (error)
+			return error;
+		return get_serial_info(info, (struct serial_struct *)arg);
+
+	case TIOCSSERIAL:
+		return set_serial_info(info, (struct serial_struct *)arg);
+
+	case TIOCSERGETLSR:			/* Get line status register */
+		error = verify_area(VERIFY_WRITE, (void *)arg,
+				    sizeof(unsigned int));
+		if (error)
+			return error;
+		else
+			return get_lsr_info(info, (unsigned int *)arg);
+
+	case TIOCSERGSTRUCT:
+		error = verify_area(VERIFY_WRITE, (void *)arg,
+				    sizeof(struct dec_serial));
+		if (error)
+			return error;
+		copy_from_user((struct dec_serial *)arg, info,
+			       sizeof(struct dec_serial));
+		return 0;
+
+	default:
+		return -ENOIOCTLCMD;
+	}
 	return 0;
 }
 
@@ -1446,7 +1428,8 @@
 static void rs_wait_until_sent(struct tty_struct *tty, int timeout)
 {
 	struct dec_serial *info = (struct dec_serial *) tty->driver_data;
-	unsigned long orig_jiffies, char_time;
+	unsigned long orig_jiffies;
+	int char_time;
 
 	if (serial_paranoia_check(info, tty->device, "rs_wait_until_sent"))
 		return;
@@ -1462,7 +1445,7 @@
 	if (char_time == 0)
 		char_time = 1;
 	if (timeout)
-		char_time = MIN(char_time, timeout);
+		char_time = min(char_time, timeout);
 	while ((read_zsreg(info->zs_channel, 1) & Tx_BUF_EMP) == 0) {
 		current->state = TASK_INTERRUPTIBLE;
 		schedule_timeout(char_time);
@@ -1714,7 +1697,7 @@
 
 static void __init show_serial_version(void)
 {
-	printk("DECstation Z8530 serial driver version 0.08\n");
+	printk("DECstation Z8530 serial driver version 0.09\n");
 }
 
 /*  Initialize Z8530s zs_channels
@@ -1994,8 +1977,9 @@
  * polling I/O routines
  */
 static int
-zs_poll_tx_char(struct dec_serial *info, unsigned char ch)
+zs_poll_tx_char(void *handle, unsigned char ch)
 {
+	struct dec_serial *info = handle;
 	struct dec_zschannel *chan = info->zs_channel;
 	int    ret;
 
@@ -2017,8 +2001,9 @@
 }
 
 static int
-zs_poll_rx_char(struct dec_serial *info)
+zs_poll_rx_char(void *handle)
 {
+	struct dec_serial *info = handle;
         struct dec_zschannel *chan = info->zs_channel;
         int    ret;
 
@@ -2038,12 +2023,13 @@
 		return -ENODEV;
 }
 
-unsigned int register_zs_hook(unsigned int channel, struct zs_hook *hook)
+int register_zs_hook(unsigned int channel, struct dec_serial_hook *hook)
 {
 	struct dec_serial *info = &zs_soft[channel];
 
 	if (info->hook) {
-		printk(__FUNCTION__": line %d has already a hook registered\n", channel);
+		printk("%s: line %d has already a hook registered\n",
+		       __FUNCTION__, channel);
 
 		return 0;
 	} else {
@@ -2055,7 +2041,7 @@
 	}
 }
 
-unsigned int unregister_zs_hook(unsigned int channel)
+int unregister_zs_hook(unsigned int channel)
 {
 	struct dec_serial *info = &zs_soft[channel];
 
@@ -2063,8 +2049,8 @@
                 info->hook = NULL;
                 return 1;
         } else {
-                printk(__FUNCTION__": trying to unregister hook on line %d,"
-                       " but none is registered\n", channel);
+                printk("%s: trying to unregister hook on line %d,"
+                       " but none is registered\n", __FUNCTION__, channel);
                 return 0;
         }
 }
@@ -2319,22 +2305,23 @@
 	write_zsreg(chan, 9, nine);
 }
 
-static int kgdbhook_init_channel(struct dec_serial* info)
+static int kgdbhook_init_channel(void *handle)
 {
 	return 0;
 }
 
-static void kgdbhook_init_info(struct dec_serial* info)
+static void kgdbhook_init_info(void *handle)
 {
 }
 
-static void kgdbhook_rx_char(struct dec_serial* info,
-			     unsigned char ch, unsigned char stat)
+static void kgdbhook_rx_char(void *handle, unsigned char ch, unsigned char fl)
 {
+	struct dec_serial *info = handle;
+
+	if (fl != TTY_NORMAL)
+		return;
 	if (ch == 0x03 || ch == '$')
 		breakpoint();
-	if (stat & (Rx_OVR|FRM_ERR|PAR_ERR))
-		write_zsreg(info->zs_channel, 0, ERR_RES);
 }
 
 /* This sets up the serial port we're using, and turns on
@@ -2360,11 +2347,11 @@
  * for /dev/ttyb which is determined in setup_arch() from the
  * boot command line flags.
  */
-struct zs_hook zs_kgdbhook = {
-	init_channel : kgdbhook_init_channel,
-	init_info    : kgdbhook_init_info,
-	cflags       : B38400|CS8|CLOCAL,
-	rx_char      : kgdbhook_rx_char,
+struct dec_serial_hook zs_kgdbhook = {
+	.init_channel	= kgdbhook_init_channel,
+	.init_info	= kgdbhook_init_info,
+	.rx_char	= kgdbhook_rx_char,
+	.cflags		= B38400 | CS8 | CLOCAL,
 }
 
 void __init zs_kgdb_hook(int tty_num)
diff -Nur linux-2.4.30/drivers/tc/zs.h linux-2.4.30-mips/drivers/tc/zs.h
--- linux-2.4.30/drivers/tc/zs.h	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/tc/zs.h	2004-07-01 15:28:54.000000000 +0200
@@ -1,14 +1,18 @@
 /*
- * macserial.h: Definitions for the Macintosh Z8530 serial driver.
+ * drivers/tc/zs.h: Definitions for the DECstation Z85C30 serial driver.
  *
  * Adapted from drivers/sbus/char/sunserial.h by Paul Mackerras.
+ * Adapted from drivers/macintosh/macserial.h by Harald Koerfgen.
  *
  * Copyright (C) 1996 Paul Mackerras (Paul.Mackerras@cs.anu.edu.au)
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
+ * Copyright (C) 2004  Maciej W. Rozycki
  */
 #ifndef _DECSERIAL_H
 #define _DECSERIAL_H
 
+#include <asm/dec/serial.h>
+
 #define NUM_ZSREGS    16
 
 struct serial_struct {
@@ -89,63 +93,50 @@
 	unsigned char curregs[NUM_ZSREGS];
 };
 
-struct dec_serial;
-
-struct zs_hook {
-	int (*init_channel)(struct dec_serial* info);
-	void (*init_info)(struct dec_serial* info);
-	void (*rx_char)(unsigned char ch, unsigned char stat);
-	int  (*poll_rx_char)(struct dec_serial* info);
-	int  (*poll_tx_char)(struct dec_serial* info,
-			     unsigned char ch);
-	unsigned cflags;
-};
-
 struct dec_serial {
-	struct dec_serial *zs_next;	/* For IRQ servicing chain */
-	struct dec_zschannel *zs_channel; /* Channel registers */
-	struct dec_zschannel *zs_chan_a;	/* A side registers */
-	unsigned char read_reg_zero;
-
-	char soft_carrier;  /* Use soft carrier on this channel */
-	char break_abort;   /* Is serial console in, so process brk/abrt */
-	struct zs_hook *hook;  /* Hook on this channel */
-	char is_cons;       /* Is this our console. */
-	unsigned char tx_active; /* character is being xmitted */
-	unsigned char tx_stopped; /* output is suspended */
-
-	/* We need to know the current clock divisor
-	 * to read the bps rate the chip has currently
-	 * loaded.
+	struct dec_serial	*zs_next;	/* For IRQ servicing chain.  */
+	struct dec_zschannel	*zs_channel;	/* Channel registers.  */
+	struct dec_zschannel	*zs_chan_a;	/* A side registers.  */
+	unsigned char		read_reg_zero;
+
+	struct dec_serial_hook	*hook;		/* Hook on this channel.  */
+	int			tty_break;	/* Set on BREAK condition.  */
+	int			is_cons;	/* Is this our console.  */
+	int			tx_active;	/* Char is being xmitted.  */
+	int			tx_stopped;	/* Output is suspended.  */
+
+	/*
+	 * We need to know the current clock divisor
+	 * to read the bps rate the chip has currently loaded.
 	 */
-	unsigned char clk_divisor;  /* May be 1, 16, 32, or 64 */
-	int zs_baud;
+	int			clk_divisor;	/* May be 1, 16, 32, or 64.  */
+	int			zs_baud;
 
-	char change_needed;
+	char			change_needed;
 
 	int			magic;
 	int			baud_base;
 	int			port;
 	int			irq;
-	int			flags; 		/* defined in tty.h */
-	int			type; 		/* UART type */
+	int			flags; 		/* Defined in tty.h.  */
+	int			type; 		/* UART type.  */
 	struct tty_struct 	*tty;
 	int			read_status_mask;
 	int			ignore_status_mask;
 	int			timeout;
 	int			xmit_fifo_size;
 	int			custom_divisor;
-	int			x_char;	/* xon/xoff character */
+	int			x_char;		/* XON/XOFF character.  */
 	int			close_delay;
 	unsigned short		closing_wait;
 	unsigned short		closing_wait2;
 	unsigned long		event;
 	unsigned long		last_active;
 	int			line;
-	int			count;	    /* # of fd on device */
-	int			blocked_open; /* # of blocked opens */
-	long			session; /* Session of opening process */
-	long			pgrp; /* pgrp of opening process */
+	int			count;		/* # of fds on device.  */
+	int			blocked_open;	/* # of blocked opens.  */
+	long			session;	/* Sess of opening process.  */
+	long			pgrp;		/* Pgrp of opening process.  */
 	unsigned char 		*xmit_buf;
 	int			xmit_head;
 	int			xmit_tail;
diff -Nur linux-2.4.30/drivers/video/Config.in linux-2.4.30-mips/drivers/video/Config.in
--- linux-2.4.30/drivers/video/Config.in	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/video/Config.in	2005-02-11 22:16:44.000000000 +0100
@@ -87,8 +87,8 @@
    if [ "$CONFIG_HP300" = "y" ]; then
       define_bool CONFIG_FB_HP300 y
    fi
-   if [ "$ARCH" = "alpha" ]; then
-      tristate '  TGA framebuffer support' CONFIG_FB_TGA
+   if [ "$ARCH" = "alpha" -o "$CONFIG_TC" = "y" ]; then
+      tristate '  TGA/SFB+ framebuffer support' CONFIG_FB_TGA
    fi
    if [ "$CONFIG_X86" = "y" ]; then
       bool '  VESA VGA graphics console' CONFIG_FB_VESA
@@ -121,6 +121,17 @@
          hex '    Framebuffer Base Address' CONFIG_E1355_FB_BASE a8200000
       fi
    fi
+   if [ "$CONFIG_SOC_AU1100" = "y" ]; then
+      bool '  Au1100 LCD Driver' CONFIG_FB_AU1100
+   fi
+   
+   if [ "$CONFIG_SOC_AU1200" = "y" ]; then
+      bool '  Au1200 LCD Driver' CONFIG_FB_AU1200
+      if [ "$CONFIG_FB_AU1200" = "y" ]; then
+      int  '    Number of planes (1 to 4)' CONFIG_FB_AU1200_DEVS 1
+      fi
+   fi
+   
    if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
       if [ "$CONFIG_PCI" != "n" ]; then
 	 tristate '  Matrox acceleration (EXPERIMENTAL)' CONFIG_FB_MATROX
@@ -178,9 +189,6 @@
 	     bool '    Use CRT on Pb1100 ' CONFIG_PB1500_CRT
 	     bool '    Use TFT Panel on Pb1100 ' CONFIG_PB1500_TFT
            fi
-           if [ "$CONFIG_SOC_AU1100" = "y" ]; then
-	     bool '    Au1100 LCD Driver' CONFIG_FB_AU1100
-           fi
 	 fi
       fi
    fi
diff -Nur linux-2.4.30/drivers/video/Makefile linux-2.4.30-mips/drivers/video/Makefile
--- linux-2.4.30/drivers/video/Makefile	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.30-mips/drivers/video/Makefile	2005-02-11 22:16:44.000000000 +0100
@@ -87,6 +87,7 @@
 obj-$(CONFIG_FB_MAXINE)           += maxinefb.o
 obj-$(CONFIG_FB_TX3912)           += tx3912fb.o
 obj-$(CONFIG_FB_AU1100)		  += au1100fb.o fbgen.o
+obj-$(CONFIG_FB_AU1200)		  += au1200fb.o fbgen.o
 obj-$(CONFIG_FB_IT8181)		  += it8181fb.o fbgen.o
 
 subdir-$(CONFIG_STI_CONSOLE)      += sti
diff -Nur linux-2.4.30/drivers/video/au1200fb.c linux-2.4.30-mips/drivers/video/au1200fb.c
--- linux-2.4.30/drivers/video/au1200fb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/video/au1200fb.c	2005-03-13 09:04:16.000000000 +0100
@@ -0,0 +1,1564 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1200 LCD Driver.
+ *
+ * Copyright 2004 AMD
+ * Author: AMD
+ *
+ * Based on:
+ * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device
+ *  Created 28 Dec 1997 by Geert Uytterhoeven
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+
+#include <asm/au1000.h>
+#include <asm/au1xxx_gpio.h>
+#include "au1200fb.h"
+
+#include <video/fbcon.h>
+#include <video/fbcon-cfb16.h>
+#include <video/fbcon-cfb32.h>
+#define CMAPSIZE 16
+
+#define AU1200_LCD_GET_WINENABLE	1
+#define AU1200_LCD_SET_WINENABLE	2
+#define AU1200_LCD_GET_WINLOCATION	3
+#define AU1200_LCD_SET_WINLOCATION	4
+#define AU1200_LCD_GET_WINSIZE		5
+#define AU1200_LCD_SET_WINSIZE		6
+#define AU1200_LCD_GET_BACKCOLOR	7
+#define AU1200_LCD_SET_BACKCOLOR	8
+#define AU1200_LCD_GET_COLORKEY	9
+#define AU1200_LCD_SET_COLORKEY	10
+#define AU1200_LCD_GET_PANEL		11
+#define AU1200_LCD_SET_PANEL		12
+
+typedef struct au1200_lcd_getset_t
+{
+	unsigned int subcmd;
+	union {
+		struct {
+			int enable;
+		} winenable;
+		struct {
+			int x, y;
+		} winlocation;
+		struct {
+			int hsz, vsz;
+		} winsize;
+		struct {
+			unsigned int color;
+		} backcolor;
+		struct {
+			unsigned int key;
+			unsigned int mask;
+		} colorkey;
+		struct {
+			int panel;
+			char desc[80];
+		} panel;
+	};
+} au1200_lcd_getset_t;
+
+AU1200_LCD *lcd = (AU1200_LCD *)AU1200_LCD_ADDR;
+static int window_index = 0; /* default is zero */
+static int panel_index = -1; /* default is call board_au1200fb_panel */
+
+struct window_settings
+{
+	unsigned char name[64];
+	uint32 mode_backcolor;
+	uint32 mode_colorkey;
+	uint32 mode_colorkeymsk;
+	struct
+	{
+		int xres;
+		int yres;
+		int xpos;
+		int ypos;
+		uint32 mode_winctrl1; /* winctrl1[FRM,CCO,PO,PIPE] */
+		uint32 mode_winenable;
+	} w[4];
+};
+
+struct panel_settings
+{
+	unsigned char name[64];
+	/* panel physical dimensions */
+	uint32 Xres;
+	uint32 Yres;
+	/* panel timings */
+	uint32 mode_screen;
+	uint32 mode_horztiming;
+	uint32 mode_verttiming;
+	uint32 mode_clkcontrol;
+	uint32 mode_pwmdiv;
+	uint32 mode_pwmhi;
+	uint32 mode_outmask;
+	uint32 mode_fifoctrl;
+	uint32 mode_toyclksrc;
+	uint32 mode_backlight;
+	uint32 mode_auxpll;
+	int (*device_init)(void);
+	int (*device_shutdown)(void);
+};
+
+#if defined(__BIG_ENDIAN)
+#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_00
+#else
+#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_01
+#endif
+
+extern int board_au1200fb_panel (void);
+extern int board_au1200fb_panel_init (void);
+extern int board_au1200fb_panel_shutdown (void);
+
+#if defined(CONFIG_FOCUS_ENHANCEMENTS)
+extern int board_au1200fb_focus_init_hdtv(void);
+extern int board_au1200fb_focus_init_component(void);
+extern int board_au1200fb_focus_init_cvsv(void);
+extern int board_au1200fb_focus_shutdown(void);
+#endif
+
+/*
+ * Default window configurations
+ */
+static struct window_settings windows[] =
+{
+	{ /* Index 0 */
+		"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx",
+		/* mode_backcolor	*/ 0x006600ff,
+		/* mode_colorkey,msk*/ 0, 0,
+		{
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565|LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ LCD_WINENABLE_WEN0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565|LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ 0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565|LCD_WINCTRL1_PO_16BPP|LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565|LCD_WINCTRL1_PO_16BPP|LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0,
+			},
+		},
+	},
+
+	{ /* Index 1 */
+		"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx",
+		/* mode_backcolor	*/ 0x006600ff,
+		/* mode_colorkey,msk*/ 0, 0,
+		{
+			{
+			/* xres, yres, xpos, ypos */ 320, 240, 5, 5,
+#if 0
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565|LCD_WINCTRL1_PO_16BPP,
+#endif
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_24BPP|LCD_WINCTRL1_PO_00,
+			/* mode_winenable*/ LCD_WINENABLE_WEN0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565|LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ 0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 100, 100, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565|LCD_WINCTRL1_PO_16BPP|LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0/*LCD_WINENABLE_WEN2*/,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 200, 25, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565|LCD_WINCTRL1_PO_16BPP|LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0,
+			},
+		},
+	},
+	/* Need VGA 640 @ 24bpp, @ 32bpp */
+	/* Need VGA 800 @ 24bpp, @ 32bpp */
+	/* Need VGA 1024 @ 24bpp, @ 32bpp */
+} ;
+
+/*
+ * Controller configurations for various panels.
+ */
+static struct panel_settings panels[] =
+{
+	{ /* Index 0: QVGA 320x240 H:33.3kHz V:110Hz */
+		"VGA_320x240",
+		320, 240,
+		/* mode_screen 		*/ LCD_SCREEN_SX_N(320) | LCD_SCREEN_SY_N(240),
+		/* mode_horztiming	*/ 0x00c4623b,
+		/* mode_verttiming	*/ 0x00502814,
+		/* mode_clkcontrol	*/ 0x00020002, /* /4=24Mhz */
+		/* mode_pwmdiv		*/ 0x00000000,
+		/* mode_pwmhi		*/ 0x00000000,
+		/* mode_outmask		*/ 0x00FFFFFF,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000004, /* 96MHz AUXPLL directly */
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 8, /* 96MHz AUXPLL */
+		/* device_init		*/ NULL,
+		/* device_shutdown	*/ NULL,
+	},
+
+	{ /* Index 1: VGA 640x480 H:30.3kHz V:58Hz */
+		"VGA_640x480",
+		640, 480,
+		/* mode_screen 		*/ 0x13f9df80,
+		/* mode_horztiming	*/ 0x003c5859,
+		/* mode_verttiming	*/ 0x00741201,
+		/* mode_clkcontrol	*/ 0x00020001, /* /4=24Mhz */
+		/* mode_pwmdiv		*/ 0x00000000,
+		/* mode_pwmhi		*/ 0x00000000,
+		/* mode_outmask		*/ 0x00FFFFFF,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000004, /* AUXPLL directly */
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 8, /* 96MHz AUXPLL */
+		/* device_init		*/ NULL,
+		/* device_shutdown	*/ NULL,
+	},
+
+	{ /* Index 2: SVGA 800x600 H:46.1kHz V:69Hz */
+		"SVGA_800x600",
+		800, 600,
+		/* mode_screen 		*/ 0x18fa5780,
+		/* mode_horztiming	*/ 0x00dc7e77,
+		/* mode_verttiming	*/ 0x00584805,
+		/* mode_clkcontrol	*/ 0x00020000, /* /2=48Mhz */
+		/* mode_pwmdiv		*/ 0x00000000,
+		/* mode_pwmhi		*/ 0x00000000,
+		/* mode_outmask		*/ 0x00FFFFFF,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000004, /* AUXPLL directly */
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 8, /* 96MHz AUXPLL */
+		/* device_init		*/ NULL,
+		/* device_shutdown	*/ NULL,
+	},
+
+	{ /* Index 3: XVGA 1024x768 H:56.2kHz V:70Hz */
+		"XVGA_1024x768",
+		1024, 768,
+		/* mode_screen 		*/ 0x1ffaff80,
+		/* mode_horztiming	*/ 0x007d0e57,
+		/* mode_verttiming	*/ 0x00740a01,
+		/* mode_clkcontrol	*/ 0x000A0000, /* /1 */
+		/* mode_pwmdiv		*/ 0x00000000,
+		/* mode_pwmhi		*/ 0x00000000,
+		/* mode_outmask		*/ 0x00FFFFFF,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000004, /* AUXPLL directly */
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 6, /* 72MHz AUXPLL */
+		/* device_init		*/ NULL,
+		/* device_shutdown	*/ NULL,
+	},
+
+	{ /* Index 4: XVGA 1280x1024 H:68.5kHz V:65Hz */
+		"XVGA_1280x1024",
+		1280, 1024,
+		/* mode_screen 		*/ 0x27fbff80,
+		/* mode_horztiming	*/ 0x00cdb2c7,
+		/* mode_verttiming	*/ 0x00600002,
+		/* mode_clkcontrol	*/ 0x000A0000, /* /1 */
+		/* mode_pwmdiv		*/ 0x00000000,
+		/* mode_pwmhi		*/ 0x00000000,
+		/* mode_outmask		*/ 0x00FFFFFF,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000004, /* AUXPLL directly */
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 10, /* 120MHz AUXPLL */
+		/* device_init		*/ NULL,
+		/* device_shutdown	*/ NULL,
+	},
+
+	{ /* Index 5: Samsung 1024x768 TFT */
+		"Samsung_1024x768_TFT",
+		1024, 768,
+		/* mode_screen 		*/ 0x1ffaff80,
+		/* mode_horztiming	*/ 0x018cc677,
+		/* mode_verttiming	*/ 0x00241217,
+		/* mode_clkcontrol	*/ 0x00000000, /* SCB 0x1 /4=24Mhz */
+		/* mode_pwmdiv		*/ 0x8000063f, /* SCB 0x0 */
+		/* mode_pwmhi		*/ 0x03400000, /* SCB 0x0 */
+		/* mode_outmask		*/ 0x00fcfcfc,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000004, /* 96MHz AUXPLL directly */
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 8, /* 96MHz AUXPLL */
+		/* device_init		*/ board_au1200fb_panel_init,
+		/* device_shutdown	*/ board_au1200fb_panel_shutdown,
+	},
+
+	{ /* Index 6: Toshiba 640x480 TFT */
+		"Toshiba_640x480_TFT",
+		640, 480,
+		/* mode_screen 		*/ LCD_SCREEN_SX_N(640) | LCD_SCREEN_SY_N(480),
+		/* mode_horztiming	*/ LCD_HORZTIMING_HPW_N(96) | LCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(51),
+		/* mode_verttiming	*/ LCD_VERTTIMING_VPW_N(2) | LCD_VERTTIMING_VND1_N(11) | LCD_VERTTIMING_VND2_N(32) ,
+		/* mode_clkcontrol	*/ 0x00000000, /* /4=24Mhz */
+		/* mode_pwmdiv		*/ 0x8000063f,
+		/* mode_pwmhi		*/ 0x03400000,
+		/* mode_outmask		*/ 0x00fcfcfc,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000004, /* 96MHz AUXPLL directly */
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 8, /* 96MHz AUXPLL */
+		/* device_init		*/ board_au1200fb_panel_init,
+		/* device_shutdown	*/ board_au1200fb_panel_shutdown,
+	},
+
+	{ /* Index 7: Sharp 320x240 TFT */
+		"Sharp_320x240_TFT",
+		320, 240,
+		/* mode_screen 		*/ LCD_SCREEN_SX_N(320) | LCD_SCREEN_SY_N(240),
+		/* mode_horztiming	*/ LCD_HORZTIMING_HPW_N(60) | LCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(2),
+		/* mode_verttiming	*/ LCD_VERTTIMING_VPW_N(2) | LCD_VERTTIMING_VND1_N(2) | LCD_VERTTIMING_VND2_N(5) ,
+		/* mode_clkcontrol	*/ LCD_CLKCONTROL_PCD_N(7), /* /16=6Mhz */
+		/* mode_pwmdiv		*/ 0x8000063f,
+		/* mode_pwmhi		*/ 0x03400000,
+		/* mode_outmask		*/ 0x00fcfcfc,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000004, /* 96MHz AUXPLL directly */
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 8, /* 96MHz AUXPLL */
+		/* device_init		*/ board_au1200fb_panel_init,
+		/* device_shutdown	*/ board_au1200fb_panel_shutdown,
+	},
+	{ /* Index 8: Toppoly TD070WGCB2 7" 854x480 TFT */
+		"Toppoly_TD070WGCB2",
+		854, 480,
+		/* mode_screen 		*/ LCD_SCREEN_SX_N(854) | LCD_SCREEN_SY_N(480),
+		/* mode_horztiming	*/ LCD_HORZTIMING_HND2_N(44) | LCD_HORZTIMING_HND1_N(44) | LCD_HORZTIMING_HPW_N(114),
+		/* mode_verttiming	*/ LCD_VERTTIMING_VND2_N(20) | LCD_VERTTIMING_VND1_N(21) | LCD_VERTTIMING_VPW_N(4),
+		/* mode_clkcontrol	*/ 0x00020001, /* /4=24Mhz */
+		/* mode_pwmdiv		*/ 0x8000063f,
+		/* mode_pwmhi		*/ 0x03400000,
+		/* mode_outmask		*/ 0x00FCFCFC,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000004, /* AUXPLL directly */
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 8, /* 96MHz AUXPLL */
+		/* device_init		*/ board_au1200fb_panel_init,
+		/* device_shutdown	*/ board_au1200fb_panel_shutdown,
+	},
+#if defined(CONFIG_FOCUS_ENHANCEMENTS)
+	{ /* Index 9: Focus FS453 TV-Out 640x480 */
+		"FS453_640x480 (Composite/S-Video)",
+		640, 480,
+		/* mode_screen 		*/ LCD_SCREEN_SX_N(640) | LCD_SCREEN_SY_N(480),
+		/* mode_horztiming	*/ LCD_HORZTIMING_HND2_N(143) | LCD_HORZTIMING_HND1_N(143) | LCD_HORZTIMING_HPW_N(10),
+		/* mode_verttiming	*/ LCD_VERTTIMING_VND2_N(30) | LCD_VERTTIMING_VND1_N(30) | LCD_VERTTIMING_VPW_N(5),
+		/* mode_clkcontrol	*/ 0x00480000 | (1<<17) | (1<<18), /* External Clock, 1:1 clock ratio */
+		/* mode_pwmdiv		*/ 0x00000000,
+		/* mode_pwmhi		*/ 0x00000000,
+		/* mode_outmask		*/ 0x00FFFFFF,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000000,
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 8, /* 96MHz AUXPLL */
+		/* device_init		*/ board_au1200fb_focus_init_cvsv,
+		/* device_shutdown	*/ board_au1200fb_focus_shutdown,
+	},
+	
+	{ /* Index 10: Focus FS453 TV-Out 640x480 */
+		"FS453_640x480 (Component Video)",
+		640, 480,
+		/* mode_screen 		*/ LCD_SCREEN_SX_N(640) | LCD_SCREEN_SY_N(480),
+		/* mode_horztiming	*/ LCD_HORZTIMING_HND2_N(143) | LCD_HORZTIMING_HND1_N(143) | LCD_HORZTIMING_HPW_N(10),
+		/* mode_verttiming	*/ LCD_VERTTIMING_VND2_N(30) | LCD_VERTTIMING_VND1_N(30) | LCD_VERTTIMING_VPW_N(5),
+		/* mode_clkcontrol	*/ 0x00480000 | (1<<17) | (1<<18), /* External Clock, 1:1 clock ratio */
+		/* mode_pwmdiv		*/ 0x00000000,
+		/* mode_pwmhi		*/ 0x00000000,
+		/* mode_outmask		*/ 0x00FFFFFF,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000000,
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 8, /* 96MHz AUXPLL */
+		/* device_init		*/ board_au1200fb_focus_init_component,
+		/* device_shutdown	*/ board_au1200fb_focus_shutdown,
+	},
+	
+	{ /* Index 11: Focus FS453 TV-Out 640x480 */
+		"FS453_640x480 (HDTV)",
+		720, 480,
+		/* mode_screen 		*/ LCD_SCREEN_SX_N(720) | LCD_SCREEN_SY_N(480),
+		/* mode_horztiming	*/ LCD_HORZTIMING_HND2_N(28) | LCD_HORZTIMING_HND1_N(46) | LCD_HORZTIMING_HPW_N(64),
+		/* mode_verttiming	*/ LCD_VERTTIMING_VND2_N(7) | LCD_VERTTIMING_VND1_N(31) | LCD_VERTTIMING_VPW_N(7),
+		/* mode_clkcontrol	*/ 0x00480000 | (1<<17) | (1<<18), /* External Clock, 1:1 clock ratio */
+		/* mode_pwmdiv		*/ 0x00000000,
+		/* mode_pwmhi		*/ 0x00000000,
+		/* mode_outmask		*/ 0x00FFFFFF,
+		/* mode_fifoctrl	*/ 0x2f2f2f2f,
+		/* mode_toyclksrc   */ 0x00000000,
+		/* mode_backlight   */ 0x00000000,
+		/* mode_auxpll		*/ 8, /* 96MHz AUXPLL */
+		/* device_init		*/ board_au1200fb_focus_init_hdtv,
+		/* device_shutdown	*/ board_au1200fb_focus_shutdown,
+	},
+#endif
+};
+
+#define NUM_PANELS (sizeof(panels) / sizeof(struct panel_settings))
+
+static struct window_settings *win;
+static struct panel_settings *panel;
+
+struct au1200fb_info {
+	struct fb_info_gen gen;
+	unsigned long fb_virt_start;
+	unsigned long fb_size;
+	unsigned long fb_phys;
+	int mmaped;
+	int nohwcursor;
+	int noblanking;
+
+	struct { unsigned red, green, blue, pad; } palette[256];
+
+#if defined(FBCON_HAS_CFB16)
+	u16 fbcon_cmap16[16];
+#endif
+#if defined(FBCON_HAS_CFB32)
+	u32 fbcon_cmap32[16];
+#endif
+};
+
+
+struct au1200fb_par {
+    struct fb_var_screeninfo var;
+	
+	int line_length;  /* in bytes */
+	int cmap_len;     /* color-map length */
+};
+
+#ifndef CONFIG_FB_AU1200_DEVS
+#define CONFIG_FB_AU1200_DEVS 1
+#endif
+
+static struct au1200fb_info fb_infos[CONFIG_FB_AU1200_DEVS];
+static struct au1200fb_par fb_pars[CONFIG_FB_AU1200_DEVS];
+static struct display disps[CONFIG_FB_AU1200_DEVS];
+
+int au1200fb_init(void);
+void au1200fb_setup(char *options, int *ints);
+static int au1200fb_mmap(struct fb_info *fb, struct file *file, 
+		struct vm_area_struct *vma);
+static int au1200_blank(int blank_mode, struct fb_info_gen *info);
+static int au1200fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
+			  u_long arg, int con, struct fb_info *info);
+
+void au1200_nocursor(struct display *p, int mode, int xx, int yy){};
+
+static int au1200_setlocation (int plane, int xpos, int ypos);
+static int au1200_setsize (int plane, int xres, int yres);
+static void au1200_setmode(int plane);
+static void au1200_setpanel (struct panel_settings *newpanel);
+
+static struct fb_ops au1200fb_ops = {
+	owner:		THIS_MODULE,
+	fb_get_fix:	fbgen_get_fix,
+	fb_get_var:	fbgen_get_var,
+	fb_set_var:	fbgen_set_var,
+	fb_get_cmap:	fbgen_get_cmap,
+	fb_set_cmap:	fbgen_set_cmap,
+	fb_pan_display: fbgen_pan_display,
+        fb_ioctl:       au1200fb_ioctl,
+	fb_mmap:        au1200fb_mmap,
+};
+
+
+static int
+winbpp (unsigned int winctrl1)
+{
+	/* how many bytes of memory are needed for each pixel format */
+	switch (winctrl1 & LCD_WINCTRL1_FRM)
+	{
+		case LCD_WINCTRL1_FRM_1BPP: return 1; break;
+		case LCD_WINCTRL1_FRM_2BPP: return 2; break;
+		case LCD_WINCTRL1_FRM_4BPP: return 4; break;
+		case LCD_WINCTRL1_FRM_8BPP: return 8; break;
+		case LCD_WINCTRL1_FRM_12BPP: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPP655: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPP565: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPP556: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPI1555: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPI5551: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPA1555: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPA5551: return 16; break;
+		case LCD_WINCTRL1_FRM_24BPP: return 32; break;
+		case LCD_WINCTRL1_FRM_32BPP: return 32; break;
+		default: return 0; break;
+	}
+}
+
+static int
+fbinfo2index (struct fb_info *fb_info)
+{
+	int i;
+	for (i = 0; i < CONFIG_FB_AU1200_DEVS; ++i)
+	{
+		if (fb_info == (struct fb_info *)(&fb_infos[i]))
+			return i;
+	}
+	printk("au1200fb: ERROR: fbinfo2index failed!\n");
+	return -1;
+}
+
+static void au1200_detect(void)
+{
+	/*
+	 *  This function should detect the current video mode settings 
+	 *  and store it as the default video mode
+	 * Yeh, well, we're not going to change any settings so we're
+	 * always stuck with the default ...
+	 */
+}
+
+static int au1200_encode_fix(struct fb_fix_screeninfo *fix, 
+		const void *_par, struct fb_info_gen *_info)
+{
+    struct au1200fb_info *info = (struct au1200fb_info *) _info;
+    struct au1200fb_par *par = (struct au1200fb_par *) _par;
+	int plane;
+
+	plane = fbinfo2index(info);
+
+	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
+
+	fix->smem_start = info->fb_phys;
+	fix->smem_len = info->fb_size;
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->type_aux = 0;
+        fix->visual = (par->var.bits_per_pixel == 8) ?
+	       	FB_VISUAL_PSEUDOCOLOR	: FB_VISUAL_TRUECOLOR;
+	fix->ywrapstep = 0;
+	fix->xpanstep = 1;
+	fix->ypanstep = 1;
+	/* FIX!!!! why doesn't par->line_length work???? it does for au1100 */
+	fix->line_length = fb_pars[plane].line_length; /*par->line_length;*/
+	return 0;
+}
+
+static void set_color_bitfields(struct fb_var_screeninfo *var, int plane)
+{
+	if (var->bits_per_pixel == 8)
+	{
+		var->red.offset = 0;
+		var->red.length = 8;
+		var->green.offset = 0;
+		var->green.length = 8;
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+	}
+	else
+	
+	if (var->bits_per_pixel == 16)
+	{
+		/* FIX!!! How does CCO affect this ? */
+		/* FIX!!! Not exactly sure how many of these work with FB */
+		switch (win->w[plane].mode_winctrl1 & LCD_WINCTRL1_FRM)
+		{
+			case LCD_WINCTRL1_FRM_16BPP655:
+				var->red.offset = 10;
+				var->red.length = 6;
+				var->green.offset = 5;
+				var->green.length = 5;
+				var->blue.offset = 0;
+				var->blue.length = 5;
+				var->transp.offset = 0;
+				var->transp.length = 0;
+				break;
+
+			case LCD_WINCTRL1_FRM_16BPP565:
+				var->red.offset = 11;
+				var->red.length = 5;
+				var->green.offset = 5;
+				var->green.length = 6;
+				var->blue.offset = 0;
+				var->blue.length = 5;
+				var->transp.offset = 0;
+				var->transp.length = 0;
+				break;
+
+			case LCD_WINCTRL1_FRM_16BPP556:
+				var->red.offset = 11;
+				var->red.length = 5;
+				var->green.offset = 6;
+				var->green.length = 5;
+				var->blue.offset = 0;
+				var->blue.length = 6;
+				var->transp.offset = 0;
+				var->transp.length = 0;
+				break;
+
+			case LCD_WINCTRL1_FRM_16BPPI1555:
+				var->red.offset = 10;
+				var->red.length = 5;
+				var->green.offset = 5;
+				var->green.length = 5;
+				var->blue.offset = 0;
+				var->blue.length = 5;
+				var->transp.offset = 0;
+				var->transp.length = 0;
+				break;
+
+			case LCD_WINCTRL1_FRM_16BPPI5551:
+				var->red.offset = 11;
+				var->red.length = 5;
+				var->green.offset = 6;
+				var->green.length = 5;
+				var->blue.offset = 1;
+				var->blue.length = 5;
+				var->transp.offset = 0;
+				var->transp.length = 0;
+				break;
+
+			case LCD_WINCTRL1_FRM_16BPPA1555:
+				var->red.offset = 10;
+				var->red.length = 5;
+				var->green.offset = 5;
+				var->green.length = 5;
+				var->blue.offset = 0;
+				var->blue.length = 5;
+				var->transp.offset = 15;
+				var->transp.length = 1;
+				break;
+
+			case LCD_WINCTRL1_FRM_16BPPA5551:
+				var->red.offset = 11;
+				var->red.length = 5;
+				var->green.offset = 6;
+				var->green.length = 5;
+				var->blue.offset = 1;
+				var->blue.length = 5;
+				var->transp.offset = 0;
+				var->transp.length = 1;
+				break;
+
+			default:
+				printk("ERROR: Invalid PIXEL FORMAT!!!\n"); break;
+		}
+	}
+	else
+
+	if (var->bits_per_pixel == 32)
+	{
+		switch (win->w[plane].mode_winctrl1 & LCD_WINCTRL1_FRM)
+		{
+		case LCD_WINCTRL1_FRM_24BPP:
+			var->red.offset = 16;
+			var->red.length = 8;
+			var->green.offset = 8;
+			var->green.length = 8;
+			var->blue.offset = 0;
+			var->blue.length = 8;
+			var->transp.offset = 0;
+			var->transp.length = 0;
+			break;
+
+		case LCD_WINCTRL1_FRM_32BPP:
+			var->red.offset = 16;
+			var->red.length = 8;
+			var->green.offset = 8;
+			var->green.length = 8;
+			var->blue.offset = 0;
+			var->blue.length = 8;
+			var->transp.offset = 24;
+			var->transp.length = 8;
+			break;
+		}
+	}
+	var->red.msb_right = 0;
+	var->green.msb_right = 0;
+	var->blue.msb_right = 0;
+	var->transp.msb_right = 0;
+#if 0
+printk("set_color_bitfields(a=%d, r=%d..%d, g=%d..%d, b=%d..%d)\n",
+	var->transp.offset,
+	var->red.offset+var->red.length-1, var->red.offset,
+	var->green.offset+var->green.length-1, var->green.offset,
+	var->blue.offset+var->blue.length-1, var->blue.offset);
+#endif
+}
+
+static int au1200_decode_var(const struct fb_var_screeninfo *var, 
+		void *_par, struct fb_info_gen *_info)
+{
+	struct au1200fb_par *par = (struct au1200fb_par *)_par;
+	int plane, bpp;
+
+	plane = fbinfo2index((struct fb_info *)_info);
+
+	/*
+	 * Don't allow setting any of these yet: xres and yres don't
+	 * make sense for LCD panels.
+	 */
+	if (var->xres != win->w[plane].xres ||
+	    var->yres != win->w[plane].yres ||
+	    var->xres != win->w[plane].xres ||
+	    var->yres != win->w[plane].yres) {
+		return -EINVAL;
+	}
+
+	bpp = winbpp(win->w[plane].mode_winctrl1);
+	if(var->bits_per_pixel != bpp) {
+		/* on au1200, window pixel format is independent of panel pixel */
+		printk("WARNING: bits_per_pizel != panel->bpp\n");
+	}
+
+	memset(par, 0, sizeof(struct au1200fb_par));
+	par->var = *var;
+	
+	/* FIX!!! */
+	switch (var->bits_per_pixel) {
+		case 8:
+			par->var.bits_per_pixel = 8;
+			break;
+		case 16:
+			par->var.bits_per_pixel = 16;
+			break;
+		case 24:
+		case 32:
+			par->var.bits_per_pixel = 32;
+			break;
+		default:
+			printk("color depth %d bpp not supported\n",
+					var->bits_per_pixel);
+			return -EINVAL;
+
+	}
+	set_color_bitfields(&par->var, plane);
+	/* FIX!!! what is this for 24/32bpp? */
+	par->cmap_len = (par->var.bits_per_pixel == 8) ? 256 : 16;
+	return 0;
+}
+
+static int au1200_encode_var(struct fb_var_screeninfo *var, 
+		const void *par, struct fb_info_gen *_info)
+{
+	*var = ((struct au1200fb_par *)par)->var;
+	return 0;
+}
+
+static void 
+au1200_get_par(void *_par, struct fb_info_gen *_info)
+{
+	int index;
+
+	index = fbinfo2index((struct fb_info *)_info);
+	*(struct au1200fb_par *)_par = fb_pars[index];
+}
+
+static void au1200_set_par(const void *par, struct fb_info_gen *info)
+{
+	/* nothing to do: we don't change any settings */
+}
+
+static int au1200_getcolreg(unsigned regno, unsigned *red, unsigned *green,
+			 unsigned *blue, unsigned *transp,
+			 struct fb_info *info)
+{
+	struct au1200fb_info* i = (struct au1200fb_info*)info;
+
+	if (regno > 255)
+		return 1;
+   
+	*red    = i->palette[regno].red; 
+	*green  = i->palette[regno].green; 
+	*blue   = i->palette[regno].blue; 
+	*transp = 0;
+
+	return 0;
+}
+
+static int au1200_setcolreg(unsigned regno, unsigned red, unsigned green,
+			 unsigned blue, unsigned transp,
+			 struct fb_info *info)
+{
+	struct au1200fb_info* i = (struct au1200fb_info *)info;
+	u32 rgbcol;
+	int plane, bpp;
+
+	plane = fbinfo2index((struct fb_info *)info);
+	bpp = winbpp(win->w[plane].mode_winctrl1);
+
+	if (regno > 255)
+		return 1;
+
+	i->palette[regno].red    = red;
+	i->palette[regno].green  = green;
+	i->palette[regno].blue   = blue;
+   
+	switch(bpp) {
+#ifdef FBCON_HAS_CFB8
+	case 8:
+		red >>= 10;
+		green >>= 10;
+		blue >>= 10;
+		panel_reg->lcd_pallettebase[regno] = (blue&0x1f) | 
+			((green&0x3f)<<5) | ((red&0x1f)<<11);
+		break;
+#endif
+#ifdef FBCON_HAS_CFB16
+/* FIX!!!! depends upon pixel format */
+	case 16:
+		i->fbcon_cmap16[regno] =
+			((red & 0xf800) >> 0) |
+			((green & 0xfc00) >> 5) |
+			((blue & 0xf800) >> 11);
+		break;
+#endif
+#ifdef FBCON_HAS_CFB32
+	case 32:
+		i->fbcon_cmap32[regno] =
+            (((u32 )transp & 0xff00) << 16) |
+            (((u32 )red & 0xff00) << 8) |
+            (((u32 )green & 0xff00)) |
+            (((u32 )blue & 0xff00) >> 8);
+		break;
+#endif
+	default:
+	printk("unsupported au1200_setcolreg(%d)\n", bpp);
+		break;
+	}
+
+	return 0;
+}
+
+
+static int  au1200_blank(int blank_mode, struct fb_info_gen *_info)
+{
+	struct au1200fb_info *fb_info = (struct au1200fb_info *)_info;
+	int plane;
+
+	/* Short-circuit screen blanking */
+	if (fb_info->noblanking)
+		return 0;
+
+	plane = fbinfo2index((struct fb_info *)_info);
+
+	switch (blank_mode) {
+	case VESA_NO_BLANKING:
+		/* printk("turn on panel\n"); */
+		au1200_setpanel(panel);
+		break;
+
+	case VESA_VSYNC_SUSPEND:
+	case VESA_HSYNC_SUSPEND:
+	case VESA_POWERDOWN:
+		/* printk("turn off panel\n"); */
+		au1200_setpanel(NULL);
+        break;
+	default: 
+		break;
+
+	}
+	return 0;
+}
+
+static void au1200_set_disp(const void *unused, struct display *disp,
+			 struct fb_info_gen *info)
+{
+	struct au1200fb_info *fb_info;
+	int plane;
+
+	fb_info = (struct au1200fb_info *)info;
+
+	disp->screen_base = (char *)fb_info->fb_virt_start;
+
+	switch (disp->var.bits_per_pixel) {
+#ifdef FBCON_HAS_CFB8
+	case 8:
+		disp->dispsw = &fbcon_cfb8;
+		if (fb_info->nohwcursor)
+			fbcon_cfb8.cursor = au1200_nocursor;
+		break;
+#endif
+#ifdef FBCON_HAS_CFB16
+	case 16:
+		disp->dispsw = &fbcon_cfb16;
+		disp->dispsw_data = fb_info->fbcon_cmap16;
+		if (fb_info->nohwcursor)
+			fbcon_cfb16.cursor = au1200_nocursor;
+		break;
+#endif
+#ifdef FBCON_HAS_CFB32
+	case 32:
+		disp->dispsw = &fbcon_cfb32;
+		disp->dispsw_data = fb_info->fbcon_cmap32;
+		if (fb_info->nohwcursor)
+			fbcon_cfb32.cursor = au1200_nocursor;
+		break;
+#endif
+	default:
+		disp->dispsw = &fbcon_dummy;
+		disp->dispsw_data = NULL;
+		break;
+	}
+}
+
+static int
+au1200fb_mmap(struct fb_info *_fb,
+	     struct file *file,
+	     struct vm_area_struct *vma)
+{
+	unsigned int len;
+	unsigned long start=0, off;
+
+	struct au1200fb_info *fb_info = (struct au1200fb_info *)_fb;
+
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
+		return -EINVAL;
+	}
+    
+	start = fb_info->fb_phys & PAGE_MASK;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + fb_info->fb_size);
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+
+	if ((vma->vm_end - vma->vm_start + off) > len) {
+		return -EINVAL;
+	}
+
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+
+	pgprot_val(vma->vm_page_prot) &= ~_CACHE_MASK;
+	pgprot_val(vma->vm_page_prot) |= _CACHE_UNCACHED;
+
+	/* This is an IO map - tell maydump to skip this VMA */
+	vma->vm_flags |= VM_IO;
+    
+	if (io_remap_page_range(vma->vm_start, off,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+
+	fb_info->mmaped = 1;
+	return 0;
+}
+
+int au1200_pan_display(const struct fb_var_screeninfo *var,
+		       struct fb_info_gen *info)
+{
+	return 0;
+}
+
+
+static int au1200fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
+			  u_long arg, int con, struct fb_info *info)
+{
+	int plane;
+
+	plane = fbinfo2index(info);
+
+	/* printk("au1200fb: ioctl %d on plane %d\n", cmd, plane); */
+
+	if (cmd == 0x46FF)
+	{
+		au1200_lcd_getset_t iodata;
+
+		if (copy_from_user(&iodata, (void *) arg, sizeof(au1200_lcd_getset_t)))
+			return -EFAULT;
+
+		switch (iodata.subcmd)
+		{
+			case AU1200_LCD_GET_WINENABLE:
+				iodata.winenable.enable = (lcd->winenable & (1<<plane)) ? 1 : 0;
+				break;
+			case AU1200_LCD_SET_WINENABLE:
+				{
+				u32 winenable;
+				winenable = lcd->winenable;
+				winenable &= ~(1<<plane);
+				winenable |= (iodata.winenable.enable) ? (1<<plane) : 0;
+				lcd->winenable = winenable;
+				}
+				break;
+			case AU1200_LCD_GET_WINLOCATION:
+				iodata.winlocation.x =
+					(lcd->window[plane].winctrl0 & LCD_WINCTRL0_OX) >> 21;
+				iodata.winlocation.y =
+					(lcd->window[plane].winctrl0 & LCD_WINCTRL0_OY) >> 10;
+				break;
+			case AU1200_LCD_SET_WINLOCATION:
+				au1200_setlocation(plane, iodata.winlocation.x, iodata.winlocation.y);
+				break;
+			case AU1200_LCD_GET_WINSIZE:
+				iodata.winsize.hsz =
+					(lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZX) >> 11;
+				iodata.winsize.vsz =
+					(lcd->window[plane].winctrl0 & LCD_WINCTRL1_SZY) >> 0;
+				break;
+			case AU1200_LCD_SET_WINSIZE:
+				au1200_setsize(plane, iodata.winsize.hsz, iodata.winsize.vsz);
+				break;
+			case AU1200_LCD_GET_BACKCOLOR:
+				iodata.backcolor.color = lcd->backcolor;
+				break;
+			case AU1200_LCD_SET_BACKCOLOR:
+				 lcd->backcolor = iodata.backcolor.color;
+				break;
+			case AU1200_LCD_GET_COLORKEY:
+				iodata.colorkey.key = lcd->colorkey;
+				iodata.colorkey.mask = lcd->colorkeymsk;
+				break;
+			case AU1200_LCD_SET_COLORKEY:
+				lcd->colorkey = iodata.colorkey.key;
+				lcd->colorkeymsk = iodata.colorkey.mask;
+				break;
+			case AU1200_LCD_GET_PANEL:
+				iodata.panel.panel = panel_index;
+				break;
+			case AU1200_LCD_SET_PANEL:
+				if ((iodata.panel.panel >= 0) && (iodata.panel.panel < NUM_PANELS))
+				{
+					struct panel_settings *newpanel;
+					panel_index = iodata.panel.panel;
+					newpanel = &panels[panel_index];
+					au1200_setpanel(newpanel);
+				}
+				break;
+		}
+
+		return copy_to_user((void *) arg, &iodata, sizeof(au1200_lcd_getset_t)) ? -EFAULT : 0;
+	}
+
+	return -EINVAL;
+}
+
+static struct fbgen_hwswitch au1200_switch = {
+	au1200_detect, 
+	au1200_encode_fix, 
+	au1200_decode_var, 
+	au1200_encode_var, 
+	au1200_get_par, 
+	au1200_set_par, 
+	au1200_getcolreg, 
+	au1200_setcolreg, 
+	au1200_pan_display, 
+	au1200_blank, 
+	au1200_set_disp
+};
+
+static void au1200_setpanel (struct panel_settings *newpanel)
+{
+	/*
+	 * Perform global setup/init of LCD controller
+	 */
+	uint32 winenable;
+
+	/* Make sure all windows disabled */
+	winenable = lcd->winenable;
+	lcd->winenable = 0;
+
+	/*
+	 * Ensure everything is disabled before reconfiguring
+	 */
+	if (lcd->screen & LCD_SCREEN_SEN)
+	{
+		/* Wait for vertical sync period */
+		lcd->intstatus = LCD_INT_SS;
+		while ((lcd->intstatus & LCD_INT_SS) == 0)
+			;		
+		
+		lcd->screen &= ~LCD_SCREEN_SEN;	/*disable the controller*/
+		
+		do
+		{
+			lcd->intstatus = lcd->intstatus; /*clear interrupts*/
+		}
+		/*wait for controller to shut down*/
+		while ((lcd->intstatus & LCD_INT_SD) == 0);
+		
+		/* Call shutdown of current panel (if up) */
+		/* this must occur last, because if an external clock is driving
+		    the controller, the clock cannot be turned off before first
+			shutting down the controller.
+		 */
+		if (panel->device_shutdown != NULL) panel->device_shutdown();
+	}
+
+	/* Check if only needing to turn off panel */
+	if (panel == NULL) return;
+
+	panel = newpanel;
+	
+	printk("Panel(%s), %dx%d\n", panel->name, panel->Xres, panel->Yres);
+
+	/*
+	 * Setup clocking if internal LCD clock source (assumes sys_auxpll valid)
+	 */
+	if (!(panel->mode_clkcontrol & LCD_CLKCONTROL_EXT))
+	{
+		uint32 sys_clksrc;
+		/* WARNING! This should really be a check since other peripherals can 
+		   be affected by changins sys_auxpll  */
+		au_writel(panel->mode_auxpll, SYS_AUXPLL);
+		sys_clksrc = au_readl(SYS_CLKSRC) & ~0x0000001f; 
+		sys_clksrc |= panel->mode_toyclksrc;
+		au_writel(sys_clksrc, SYS_CLKSRC);
+	}
+
+	/*
+	 * Configure panel timings
+	 */
+	lcd->screen = panel->mode_screen;
+	lcd->horztiming = panel->mode_horztiming;
+	lcd->verttiming = panel->mode_verttiming;
+	lcd->clkcontrol = panel->mode_clkcontrol;
+	lcd->pwmdiv = panel->mode_pwmdiv;
+	lcd->pwmhi = panel->mode_pwmhi;
+	lcd->outmask = panel->mode_outmask;
+	lcd->fifoctrl = panel->mode_fifoctrl;
+	au_sync();
+
+	/* FIX!!! Check window settings to make sure still valid for new geometry */
+	au1200_setlocation(0, win->w[0].xpos, win->w[0].ypos);
+	au1200_setlocation(1, win->w[1].xpos, win->w[1].ypos);
+	au1200_setlocation(2, win->w[2].xpos, win->w[2].ypos);
+	au1200_setlocation(3, win->w[3].xpos, win->w[3].ypos);
+	lcd->winenable = winenable;
+
+	/*
+	 * Re-enable screen now that it is configured
+	 */
+	lcd->screen |= LCD_SCREEN_SEN;
+	au_sync();
+
+	/* Call init of panel */
+	if (panel->device_init != NULL) panel->device_init();
+
+#if 0
+#define D(X) printk("%25s: %08X\n", #X, X)
+	D(lcd->screen);
+	D(lcd->horztiming);
+	D(lcd->verttiming);
+	D(lcd->clkcontrol);
+	D(lcd->pwmdiv);
+	D(lcd->pwmhi);
+	D(lcd->outmask);
+	D(lcd->fifoctrl);
+	D(lcd->window[0].winctrl0);
+	D(lcd->window[0].winctrl1);
+	D(lcd->window[0].winctrl2);
+	D(lcd->window[0].winbuf0);
+	D(lcd->window[0].winbuf1);
+	D(lcd->window[0].winbufctrl);
+	D(lcd->window[1].winctrl0);
+	D(lcd->window[1].winctrl1);
+	D(lcd->window[1].winctrl2);
+	D(lcd->window[1].winbuf0);
+	D(lcd->window[1].winbuf1);
+	D(lcd->window[1].winbufctrl);
+	D(lcd->window[2].winctrl0);
+	D(lcd->window[2].winctrl1);
+	D(lcd->window[2].winctrl2);
+	D(lcd->window[2].winbuf0);
+	D(lcd->window[2].winbuf1);
+	D(lcd->window[2].winbufctrl);
+	D(lcd->window[3].winctrl0);
+	D(lcd->window[3].winctrl1);
+	D(lcd->window[3].winctrl2);
+	D(lcd->window[3].winbuf0);
+	D(lcd->window[3].winbuf1);
+	D(lcd->window[3].winbufctrl);
+	D(lcd->winenable);
+	D(lcd->intenable);
+	D(lcd->intstatus);
+	D(lcd->backcolor);
+	D(lcd->winenable);
+	D(lcd->colorkey);
+    D(lcd->colorkeymsk);
+	D(lcd->hwc.cursorctrl);
+	D(lcd->hwc.cursorpos);
+	D(lcd->hwc.cursorcolor0);
+	D(lcd->hwc.cursorcolor1);
+	D(lcd->hwc.cursorcolor2);
+	D(lcd->hwc.cursorcolor3);
+#endif
+}
+
+static int au1200_setsize (int plane, int xres, int yres)
+{
+#if 0
+	uint32 winctrl0, winctrl1, winenable;
+	int xsz, ysz;
+
+	/* FIX!!! X*Y can not surpass allocated memory */
+
+	printk("setsize: x %d y %d\n", xres, yres);
+	winctrl1 = lcd->window[plane].winctrl1;
+	printk("org winctrl1 %08X\n", winctrl1);
+	winctrl1 &= ~(LCD_WINCTRL1_SZX | LCD_WINCTRL1_SZY);
+
+	xres -= 1;
+	yres -= 1;
+	winctrl1 |= (xres << 11);
+	winctrl1 |= (yres << 0);
+
+	printk("new winctrl1 %08X\n", winctrl1);
+
+	/*winenable = lcd->winenable & (1 << plane); */
+	/*lcd->winenable &= ~(1 << plane); */
+	lcd->window[plane].winctrl1 = winctrl1;
+	/*lcd->winenable |= winenable; */
+#endif
+	return 0;
+}
+
+static int au1200_setlocation (int plane, int xpos, int ypos)
+{
+	uint32 winctrl0, winctrl1, winenable, fb_offset = 0;
+	int xsz, ysz;
+
+	/* FIX!!! NOT CHECKING FOR COMPLETE OFFSCREEN YET */
+
+	winctrl0 = lcd->window[plane].winctrl0;
+	winctrl1 = lcd->window[plane].winctrl1;
+	winctrl0 &= (LCD_WINCTRL0_A | LCD_WINCTRL0_AEN);
+	winctrl1 &= ~(LCD_WINCTRL1_SZX | LCD_WINCTRL1_SZY);
+
+	/* Check for off-screen adjustments */
+	xsz = win->w[plane].xres;
+	ysz = win->w[plane].yres;
+	if ((xpos + win->w[plane].xres) > panel->Xres)
+	{
+		/* Off-screen to the right */
+		xsz = panel->Xres - xpos; /* off by 1 ??? */
+		/*printk("off screen right\n");*/
+	}
+
+	if ((ypos + win->w[plane].yres) > panel->Yres)
+	{
+		/* Off-screen to the bottom */
+		ysz = panel->Yres - ypos; /* off by 1 ??? */
+		/*printk("off screen bottom\n");*/
+	}
+
+	if (xpos < 0)
+	{
+		/* Off-screen to the left */
+		xsz = win->w[plane].xres + xpos;
+		fb_offset += (((0 - xpos) * winbpp(lcd->window[plane].winctrl1))/8);
+		xpos = 0;
+		/*printk("off screen left\n");*/
+	}
+
+	if (ypos < 0)
+	{
+		/* Off-screen to the top */
+		ysz = win->w[plane].yres + ypos;
+		fb_offset += ((0 - ypos) *	fb_pars[plane].line_length);
+		ypos = 0;
+		/*printk("off screen top\n");*/
+	}
+
+	/* record settings */
+	win->w[plane].xpos = xpos;
+	win->w[plane].ypos = ypos;
+
+	xsz -= 1;
+	ysz -= 1;
+	winctrl0 |= (xpos << 21);
+	winctrl0 |= (ypos << 10);
+	winctrl1 |= (xsz << 11);
+	winctrl1 |= (ysz << 0);
+
+	/* Disable the window while making changes, then restore WINEN */
+	winenable = lcd->winenable & (1 << plane);
+	lcd->winenable &= ~(1 << plane);
+	lcd->window[plane].winctrl0 = winctrl0;
+	lcd->window[plane].winctrl1 = winctrl1;
+	lcd->window[plane].winbuf0 =
+	lcd->window[plane].winbuf1 = fb_infos[plane].fb_phys + fb_offset;
+	lcd->window[plane].winbufctrl = 0; /* select winbuf0 */
+	lcd->winenable |= winenable;
+
+	return 0;
+}
+
+static void au1200_setmode(int plane)
+{
+	/* Window/plane setup */
+	lcd->window[plane].winctrl1 = ( 0
+		| LCD_WINCTRL1_PRI_N(plane)
+		| win->w[plane].mode_winctrl1 /* FRM,CCO,PO,PIPE */
+		) ;
+
+	au1200_setlocation(plane, win->w[plane].xpos, win->w[plane].ypos);
+
+	lcd->window[plane].winctrl2 = ( 0
+		| LCD_WINCTRL2_CKMODE_00
+		| LCD_WINCTRL2_DBM
+/*			| LCD_WINCTRL2_RAM */
+		| LCD_WINCTRL2_BX_N(fb_pars[plane].line_length)
+		| LCD_WINCTRL2_SCX_1
+		| LCD_WINCTRL2_SCY_1
+		) ;
+	lcd->winenable |= win->w[plane].mode_winenable;
+	au_sync();
+
+}
+
+static unsigned long
+au1200fb_alloc_fbmem (unsigned long size)
+{
+	/* __get_free_pages() fulfills a max request of 2MB */
+	/* do multiple requests to obtain large contigous mem */
+#define MAX_GFP 0x00200000
+
+	unsigned long mem, amem, alloced = 0, allocsize;
+
+	size += 0x1000;
+	allocsize = (size < MAX_GFP) ? size : MAX_GFP;
+
+	/* Get first chunk */
+	mem = (unsigned long )
+		__get_free_pages(GFP_ATOMIC | GFP_DMA, get_order(allocsize));
+	if (mem != 0) alloced = allocsize;
+
+	/* Get remaining, contiguous chunks */
+	while (alloced < size)
+	{
+		amem = (unsigned long )
+			__get_free_pages(GFP_ATOMIC | GFP_DMA, get_order(allocsize));
+		if (amem != 0)
+			alloced += allocsize;
+
+		/* check for contiguous mem alloced */
+		if ((amem == 0) || (amem + allocsize) != mem)
+			break;
+		else
+			mem = amem;
+	}
+	return mem;
+}
+
+int __init au1200fb_init(void)
+{
+	int num_panels = sizeof(panels)/sizeof(struct panel_settings);
+	struct au1200fb_info *fb_info;
+	struct display *disp;
+	struct au1200fb_par *par;
+	unsigned long page;
+	int plane, bpp;
+
+    /*
+	* Get the panel information/display mode
+	*/
+	if (panel_index < 0)
+		panel_index = board_au1200fb_panel();
+	if ((panel_index < 0) || (panel_index >= num_panels)) {
+		printk("ERROR: INVALID PANEL %d\n", panel_index);
+		return -EINVAL;
+	}
+	panel = &panels[panel_index];
+	win = &windows[window_index];
+
+	printk("au1200fb: Panel %d %s\n", panel_index, panel->name);
+	printk("au1200fb: Win %d %s\n", window_index, win->name);
+
+	/* Global setup/init */
+	au1200_setpanel(panel);
+	lcd->intenable = 0;
+	lcd->intstatus = ~0;
+	lcd->backcolor = win->mode_backcolor;
+	lcd->winenable = 0;
+
+	/* Setup Color Key - FIX!!! */
+	lcd->colorkey = win->mode_colorkey;
+	lcd->colorkeymsk = win->mode_colorkeymsk;
+
+	/* Setup HWCursor - FIX!!! Need to support this eventually */
+	lcd->hwc.cursorctrl = 0;
+	lcd->hwc.cursorpos = 0;
+	lcd->hwc.cursorcolor0 = 0;
+	lcd->hwc.cursorcolor1 = 0;
+	lcd->hwc.cursorcolor2 = 0;
+	lcd->hwc.cursorcolor3 = 0;
+
+	/* Register each plane as a frame buffer device */
+	for (plane = 0; plane < CONFIG_FB_AU1200_DEVS; ++plane)
+	{
+		fb_info = &fb_infos[plane];
+		disp = &disps[plane];
+		par = &fb_pars[plane];
+
+		bpp = winbpp(win->w[plane].mode_winctrl1);
+		if (win->w[plane].xres == 0)
+			win->w[plane].xres = panel->Xres;
+		if (win->w[plane].yres == 0)
+			win->w[plane].yres = panel->Yres;
+
+		par->var.xres =
+		par->var.xres_virtual = win->w[plane].xres;
+		par->var.yres =
+		par->var.yres_virtual = win->w[plane].yres;
+		par->var.bits_per_pixel = bpp;
+		par->line_length = win->w[plane].xres * bpp / 8; /* in bytes */
+		/*
+		 * Allocate LCD framebuffer from system memory
+		 * Set page reserved so that mmap will work. This is necessary
+		 * since we'll be remapping normal memory.
+		 */
+		fb_info->fb_size = (win->w[plane].xres * win->w[plane].yres * bpp) / 8;
+		fb_info->fb_virt_start = au1200fb_alloc_fbmem(fb_info->fb_size);
+		if (!fb_info->fb_virt_start) {
+			printk("Unable to allocate fb memory\n");
+			return -ENOMEM;
+		}
+		fb_info->fb_phys = virt_to_bus((void *)fb_info->fb_virt_start);
+		for (page = fb_info->fb_virt_start;
+		     page < PAGE_ALIGN(fb_info->fb_virt_start + fb_info->fb_size); 
+		     page += PAGE_SIZE) {
+			SetPageReserved(virt_to_page(page));
+		}
+		/* Convert to kseg1 */
+		fb_info->fb_virt_start =
+			(void *)((u32)fb_info->fb_virt_start | 0xA0000000);
+		/* FIX!!! may wish to avoid this to save startup time??? */
+		memset((void *)fb_info->fb_virt_start, 0, fb_info->fb_size);
+
+		fb_info->gen.parsize = sizeof(struct au1200fb_par);
+		fb_info->gen.fbhw = &au1200_switch;
+		strcpy(fb_info->gen.info.modename, "Au1200 LCD");
+		fb_info->gen.info.changevar = NULL;
+		fb_info->gen.info.node = -1;
+
+		fb_info->gen.info.fbops = &au1200fb_ops;
+		fb_info->gen.info.disp = disp;
+		fb_info->gen.info.switch_con = &fbgen_switch;
+		fb_info->gen.info.updatevar = &fbgen_update_var;
+		fb_info->gen.info.blank = &fbgen_blank;
+		fb_info->gen.info.flags = FBINFO_FLAG_DEFAULT;
+
+		fb_info->nohwcursor = 1;
+		fb_info->noblanking = 1;
+
+		/* This should give a reasonable default video mode */
+		fbgen_get_var(&disp->var, -1, &fb_info->gen.info);
+		fbgen_do_set_var(&disp->var, 1, &fb_info->gen);
+		fbgen_set_disp(-1, &fb_info->gen);
+		fbgen_install_cmap(0, &fb_info->gen);
+
+		/* Turn on plane */
+		au1200_setmode(plane);
+
+		if (register_framebuffer(&fb_info->gen.info) < 0)
+			return -EINVAL;
+
+		printk(KERN_INFO "fb%d: %s plane %d @ %08X (%d x %d x %d)\n", 
+				GET_FB_IDX(fb_info->gen.info.node), 
+				fb_info->gen.info.modename, plane, fb_info->fb_phys,
+				win->w[plane].xres, win->w[plane].yres, bpp);
+	}
+	/* uncomment this if your driver cannot be unloaded */
+	/* MOD_INC_USE_COUNT; */
+	return 0;
+}
+
+void au1200fb_setup(char *options, int *ints)
+{
+	char* this_opt;
+	int i;
+	int num_panels = sizeof(panels)/sizeof(struct panel_settings);
+
+	if (!options || !*options)
+		return;
+
+	for(this_opt=strtok(options, ","); this_opt;
+	    this_opt=strtok(NULL, ",")) {
+		if (!strncmp(this_opt, "panel:", 6)) {
+			int i;
+			long int li;
+			char *endptr;
+			this_opt += 6;
+
+			/* Panel name can be name, "bs" for board-switch, or number/index */
+			li = simple_strtol(this_opt, &endptr, 0);
+			if (*endptr == '\0') {
+				panel_index = (int)li;
+			}
+			else if (strcmp(this_opt, "bs") == 0) {
+				panel_index = board_au1200fb_panel();
+			}
+			else
+			for (i=0; i<num_panels; i++) {
+				if (!strcmp(this_opt, panels[i].name)) {
+					panel_index = i;
+					break;
+				}
+			}
+		}
+		else if (!strncmp(this_opt, "nohwcursor", 10)) {
+			printk("nohwcursor\n");
+			fb_infos[0].nohwcursor = 1;
+		}
+	}
+
+	printk("au1200fb: Panel %d %s\n", panel_index,
+		panels[panel_index].name);
+}
+
+
+
+#ifdef MODULE
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Au1200 LCD framebuffer driver");
+
+void au1200fb_cleanup(struct fb_info *info)
+{
+	unregister_framebuffer(info);
+}
+
+module_init(au1200fb_init);
+module_exit(au1200fb_cleanup);
+#endif /* MODULE */
+
+
diff -Nur linux-2.4.30/drivers/video/au1200fb.h linux-2.4.30-mips/drivers/video/au1200fb.h
--- linux-2.4.30/drivers/video/au1200fb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/video/au1200fb.h	2005-02-11 22:16:44.000000000 +0100
@@ -0,0 +1,288 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Hardware definitions for the Au1200 LCD controller
+ *
+ * Copyright 2004 AMD
+ * Author:	AMD
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _AU1200LCD_H
+#define _AU1200LCD_H
+
+/********************************************************************/
+#define AU1200_LCD_ADDR		0xB5000000
+
+#define uint8 unsigned char
+#define uint32 unsigned int
+
+typedef volatile struct
+{
+	uint32	reserved0;
+	uint32	screen;
+	uint32	backcolor;
+	uint32	horztiming;
+	uint32	verttiming;
+	uint32	clkcontrol;
+	uint32	pwmdiv;
+	uint32	pwmhi;
+	uint32	reserved1;
+	uint32	winenable;
+	uint32	colorkey;
+	uint32	colorkeymsk;
+	struct
+	{
+		uint32	cursorctrl;
+		uint32	cursorpos;
+		uint32	cursorcolor0;
+		uint32	cursorcolor1;
+		uint32	cursorcolor2;
+		uint32	cursorcolor3;
+	} hwc;
+	uint32	intstatus;
+	uint32	intenable;
+	uint32	outmask;
+	uint32	fifoctrl;
+	uint32	reserved2[(0x0100-0x0058)/4];
+	struct
+	{
+		uint32	winctrl0;
+		uint32	winctrl1;
+		uint32	winctrl2;
+		uint32	winbuf0;
+		uint32	winbuf1;
+		uint32	winbufctrl;
+		uint32	winreserved0;
+		uint32	winreserved1;
+	} window[4];
+
+	uint32	reserved3[(0x0400-0x0180)/4];
+
+	uint32	palette[(0x0800-0x0400)/4];
+
+	uint8	cursorpattern[256];
+
+} AU1200_LCD;
+
+/* lcd_screen */
+#define LCD_SCREEN_SEN		(1<<31)
+#define LCD_SCREEN_SX		(0x07FF<<19)
+#define LCD_SCREEN_SY		(0x07FF<< 8)
+#define LCD_SCREEN_SWP		(1<<7)
+#define LCD_SCREEN_SWD		(1<<6)
+#define LCD_SCREEN_ST		(7<<0)
+#define LCD_SCREEN_ST_TFT	(0<<0)
+#define LCD_SCREEN_SX_N(WIDTH)	((WIDTH-1)<<19)
+#define LCD_SCREEN_SY_N(HEIGHT)	((HEIGHT-1)<<8)
+#define LCD_SCREEN_ST_CSTN	(1<<0)
+#define LCD_SCREEN_ST_CDSTN	(2<<0)
+#define LCD_SCREEN_ST_M8STN	(3<<0)
+#define LCD_SCREEN_ST_M4STN	(4<<0)
+
+/* lcd_backcolor */
+#define LCD_BACKCOLOR_SBGR		(0xFF<<16)
+#define LCD_BACKCOLOR_SBGG		(0xFF<<8)
+#define LCD_BACKCOLOR_SBGB		(0xFF<<0)
+#define LCD_BACKCOLOR_SBGR_N(N)	((N)<<16)
+#define LCD_BACKCOLOR_SBGG_N(N)	((N)<<8)
+#define LCD_BACKCOLOR_SBGB_N(N)	((N)<<0)
+
+/* lcd_winenable */
+#define LCD_WINENABLE_WEN3		(1<<3)
+#define LCD_WINENABLE_WEN2		(1<<2)
+#define LCD_WINENABLE_WEN1		(1<<1)
+#define LCD_WINENABLE_WEN0		(1<<0)
+
+/* lcd_colorkey */
+#define LCD_COLORKEY_CKR		(0xFF<<16)
+#define LCD_COLORKEY_CKG		(0xFF<<8)
+#define LCD_COLORKEY_CKB		(0xFF<<0)
+#define LCD_COLORKEY_CKR_N(N)	((N)<<16)
+#define LCD_COLORKEY_CKG_N(N)	((N)<<8)
+#define LCD_COLORKEY_CKB_N(N)	((N)<<0)
+
+/* lcd_colorkeymsk */
+#define LCD_COLORKEYMSK_CKMR		(0xFF<<16)
+#define LCD_COLORKEYMSK_CKMG		(0xFF<<8)
+#define LCD_COLORKEYMSK_CKMB		(0xFF<<0)
+#define LCD_COLORKEYMSK_CKMR_N(N)	((N)<<16)
+#define LCD_COLORKEYMSK_CKMG_N(N)	((N)<<8)
+#define LCD_COLORKEYMSK_CKMB_N(N)	((N)<<0)
+
+/* lcd windows control 0 */
+#define LCD_WINCTRL0_OX		(0x07FF<<21)
+#define LCD_WINCTRL0_OY		(0x07FF<<10)
+#define LCD_WINCTRL0_A		(0x00FF<<2)
+#define LCD_WINCTRL0_AEN	(1<<1)
+#define LCD_WINCTRL0_OX_N(N) ((N)<<21)
+#define LCD_WINCTRL0_OY_N(N) ((N)<<10)
+#define LCD_WINCTRL0_A_N(N) ((N)<<2)
+
+/* lcd windows control 1 */
+#define LCD_WINCTRL1_PRI	(3<<30)
+#define LCD_WINCTRL1_PIPE	(1<<29)
+#define LCD_WINCTRL1_FRM	(0xF<<25)
+#define LCD_WINCTRL1_CCO	(1<<24)
+#define LCD_WINCTRL1_PO		(3<<22)
+#define LCD_WINCTRL1_SZX	(0x07FF<<11)
+#define LCD_WINCTRL1_SZY	(0x07FF<<0)
+#define LCD_WINCTRL1_FRM_1BPP	(0<<25)
+#define LCD_WINCTRL1_FRM_2BPP	(1<<25)
+#define LCD_WINCTRL1_FRM_4BPP	(2<<25)
+#define LCD_WINCTRL1_FRM_8BPP	(3<<25)
+#define LCD_WINCTRL1_FRM_12BPP	(4<<25)
+#define LCD_WINCTRL1_FRM_16BPP655	(5<<25)
+#define LCD_WINCTRL1_FRM_16BPP565	(6<<25)
+#define LCD_WINCTRL1_FRM_16BPP556	(7<<25)
+#define LCD_WINCTRL1_FRM_16BPPI1555	(8<<25)
+#define LCD_WINCTRL1_FRM_16BPPI5551	(9<<25)
+#define LCD_WINCTRL1_FRM_16BPPA1555	(10<<25)
+#define LCD_WINCTRL1_FRM_16BPPA5551	(11<<25)
+#define LCD_WINCTRL1_FRM_24BPP		(12<<25)
+#define LCD_WINCTRL1_FRM_32BPP		(13<<25)
+#define LCD_WINCTRL1_PRI_N(N)	((N)<<30)
+#define LCD_WINCTRL1_PO_00		(0<<22)
+#define LCD_WINCTRL1_PO_01		(1<<22)
+#define LCD_WINCTRL1_PO_10		(2<<22)
+#define LCD_WINCTRL1_PO_11		(3<<22)
+#define LCD_WINCTRL1_SZX_N(N)	((N-1)<<11)
+#define LCD_WINCTRL1_SZY_N(N)	((N-1)<<0)
+
+/* lcd windows control 2 */
+#define LCD_WINCTRL2_CKMODE		(3<<24)
+#define LCD_WINCTRL2_DBM		(1<<23)
+#define LCD_WINCTRL2_RAM		(3<<21)
+#define LCD_WINCTRL2_BX			(0x1FFF<<8)
+#define LCD_WINCTRL2_SCX		(0xF<<4)
+#define LCD_WINCTRL2_SCY		(0xF<<0)
+#define LCD_WINCTRL2_CKMODE_00		(0<<24)
+#define LCD_WINCTRL2_CKMODE_01		(1<<24)
+#define LCD_WINCTRL2_CKMODE_10		(2<<24)
+#define LCD_WINCTRL2_CKMODE_11		(3<<24)
+#define LCD_WINCTRL2_RAM_NONE		(0<<21)
+#define LCD_WINCTRL2_RAM_PALETTE	(1<<21)
+#define LCD_WINCTRL2_RAM_GAMMA		(2<<21)
+#define LCD_WINCTRL2_RAM_BUFFER		(3<<21)
+#define LCD_WINCTRL2_BX_N(N)	((N)<<8)
+#define LCD_WINCTRL2_SCX_1		(0<<4)
+#define LCD_WINCTRL2_SCX_2		(1<<4)
+#define LCD_WINCTRL2_SCX_4		(2<<4)
+#define LCD_WINCTRL2_SCY_1		(0<<0)
+#define LCD_WINCTRL2_SCY_2		(1<<0)
+#define LCD_WINCTRL2_SCY_4		(2<<0)
+
+/* lcd windows buffer control */
+#define LCD_WINBUFCTRL_DB		(1<<1)
+#define LCD_WINBUFCTRL_DBN		(1<<0)
+
+/* lcd_intstatus, lcd_intenable */
+#define LCD_INT_IFO				(0xF<<14)
+#define LCD_INT_IFU				(0xF<<10)
+#define LCD_INT_OFO				(1<<9)
+#define LCD_INT_OFU				(1<<8)
+#define LCD_INT_WAIT			(1<<3)
+#define LCD_INT_SD				(1<<2)
+#define LCD_INT_SA				(1<<1)
+#define LCD_INT_SS				(1<<0)
+
+/* lcd_horztiming */
+#define LCD_HORZTIMING_HND2		(0x1FF<<18)
+#define LCD_HORZTIMING_HND1		(0x1FF<<9)
+#define LCD_HORZTIMING_HPW		(0x1FF<<0)
+#define LCD_HORZTIMING_HND2_N(N)(((N)-1)<<18)
+#define LCD_HORZTIMING_HND1_N(N)(((N)-1)<<9)
+#define LCD_HORZTIMING_HPW_N(N)	(((N)-1)<<0)
+
+/* lcd_verttiming */
+#define LCD_VERTTIMING_VND2		(0x1FF<<18)
+#define LCD_VERTTIMING_VND1		(0x1FF<<9)
+#define LCD_VERTTIMING_VPW		(0x1FF<<0)
+#define LCD_VERTTIMING_VND2_N(N)(((N)-1)<<18)
+#define LCD_VERTTIMING_VND1_N(N)(((N)-1)<<9)
+#define LCD_VERTTIMING_VPW_N(N)	(((N)-1)<<0)
+
+/* lcd_clkcontrol */
+#define LCD_CLKCONTROL_EXT		(1<<22)
+#define LCD_CLKCONTROL_DELAY	(3<<20)
+#define LCD_CLKCONTROL_CDD		(1<<19)
+#define LCD_CLKCONTROL_IB		(1<<18)
+#define LCD_CLKCONTROL_IC		(1<<17)
+#define LCD_CLKCONTROL_IH		(1<<16)
+#define LCD_CLKCONTROL_IV		(1<<15)
+#define LCD_CLKCONTROL_BF		(0x1F<<10)
+#define LCD_CLKCONTROL_PCD		(0x3FF<<0)
+#define LCD_CLKCONTROL_BF_N(N)	(((N)-1)<<10)
+#define LCD_CLKCONTROL_PCD_N(N)	((N)<<0)
+
+/* lcd_pwmdiv */
+#define LCD_PWMDIV_EN			(1<<31)
+#define LCD_PWMDIV_PWMDIV		(0x1FFFF<<0)
+#define LCD_PWMDIV_PWMDIV_N(N)	((N)<<0)
+
+/* lcd_pwmhi */
+#define LCD_PWMHI_PWMHI1		(0xFFFF<<16)
+#define LCD_PWMHI_PWMHI0		(0xFFFF<<0)
+#define LCD_PWMHI_PWMHI1_N(N)	((N)<<16)
+#define LCD_PWMHI_PWMHI0_N(N)	((N)<<0)
+
+/* lcd_hwccon */
+#define LCD_HWCCON_EN			(1<<0)
+
+/* lcd_cursorpos */
+#define LCD_CURSORPOS_HWCXOFF		(0x1F<<27)
+#define LCD_CURSORPOS_HWCXPOS		(0x07FF<<16)
+#define LCD_CURSORPOS_HWCYOFF		(0x1F<<11)
+#define LCD_CURSORPOS_HWCYPOS		(0x07FF<<0)
+#define LCD_CURSORPOS_HWCXOFF_N(N)	((N)<<27)
+#define LCD_CURSORPOS_HWCXPOS_N(N)	((N)<<16)
+#define LCD_CURSORPOS_HWCYOFF_N(N)	((N)<<11)
+#define LCD_CURSORPOS_HWCYPOS_N(N)	((N)<<0)
+
+/* lcd_cursorcolor */
+#define LCD_CURSORCOLOR_HWCA		(0xFF<<24)
+#define LCD_CURSORCOLOR_HWCR		(0xFF<<16)
+#define LCD_CURSORCOLOR_HWCG		(0xFF<<8)
+#define LCD_CURSORCOLOR_HWCB		(0xFF<<0)
+#define LCD_CURSORCOLOR_HWCA_N(N)	((N)<<24)
+#define LCD_CURSORCOLOR_HWCR_N(N)	((N)<<16)
+#define LCD_CURSORCOLOR_HWCG_N(N)	((N)<<8)
+#define LCD_CURSORCOLOR_HWCB_N(N)	((N)<<0)
+
+/* lcd_fifoctrl */
+#define LCD_FIFOCTRL_F3IF		(1<<29)
+#define LCD_FIFOCTRL_F3REQ		(0x1F<<24)
+#define LCD_FIFOCTRL_F2IF		(1<<29)
+#define LCD_FIFOCTRL_F2REQ		(0x1F<<16)
+#define LCD_FIFOCTRL_F1IF		(1<<29)
+#define LCD_FIFOCTRL_F1REQ		(0x1F<<8)
+#define LCD_FIFOCTRL_F0IF		(1<<29)
+#define LCD_FIFOCTRL_F0REQ		(0x1F<<0)
+#define LCD_FIFOCTRL_F3REQ_N(N)	((N-1)<<24)
+#define LCD_FIFOCTRL_F2REQ_N(N)	((N-1)<<16)
+#define LCD_FIFOCTRL_F1REQ_N(N)	((N-1)<<8)
+#define LCD_FIFOCTRL_F0REQ_N(N)	((N-1)<<0)
+
+/* lcd_outmask */
+#define LCD_OUTMASK_MASK		(0x00FFFFFF)
+
+/********************************************************************/
+#endif /* _AU1200LCD_H */
diff -Nur linux-2.4.30/drivers/video/fbmem.c linux-2.4.30-mips/drivers/video/fbmem.c
--- linux-2.4.30/drivers/video/fbmem.c	2005-01-19 15:10:09.000000000 +0100
+++ linux-2.4.30-mips/drivers/video/fbmem.c	2005-02-11 22:16:44.000000000 +0100
@@ -139,6 +139,8 @@
 extern int e1356fb_setup(char*);
 extern int au1100fb_init(void);
 extern int au1100fb_setup(char*);
+extern int au1200fb_init(void);
+extern int au1200fb_setup(char*);
 extern int pvr2fb_init(void);
 extern int pvr2fb_setup(char*);
 extern int sstfb_init(void);
@@ -331,6 +333,9 @@
 #ifdef CONFIG_FB_AU1100
 	{ "au1100fb", au1100fb_init, au1100fb_setup },
 #endif 
+#ifdef CONFIG_FB_AU1200
+	{ "au1200fb", au1200fb_init, au1200fb_setup },
+#endif 
 #ifdef CONFIG_FB_IT8181
 	{ "it8181fb", it8181fb_init, it8181fb_setup },
 #endif
diff -Nur linux-2.4.30/drivers/video/ims332.h linux-2.4.30-mips/drivers/video/ims332.h
--- linux-2.4.30/drivers/video/ims332.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/drivers/video/ims332.h	2003-12-22 17:02:20.000000000 +0100
@@ -0,0 +1,275 @@
+/*
+ *	linux/drivers/video/ims332.h
+ *
+ *	Copyright 2003  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+ *
+ *	This file is subject to the terms and conditions of the GNU General
+ *	Public License. See the file COPYING in the main directory of this
+ *	archive for more details.
+ */
+#include <linux/types.h>
+
+/*
+ * IMS332 16-bit wide, 128-bit aligned registers.
+ */
+struct _ims332_reg {
+	volatile u16 r;
+	u16 pad[7];
+};
+
+struct _ims332_regs {
+#define IMS332_BOOT_PLL_MUTLIPLIER	0x00001f
+#define IMS332_BOOT_CLOCK_SOURCE_SEL	0x000020
+#define IMS332_BOOT_ADDRESS_ALIGNMENT	0x000040
+#define IMS332_BOOT_WRITE_ZERO		0xffff80
+	struct _ims332_reg boot;
+	struct _ims332_reg pad0[0x020 - 0x000];
+	struct _ims332_reg half_sync;
+	struct _ims332_reg back_porch;
+	struct _ims332_reg display;
+	struct _ims332_reg short_display;
+	struct _ims332_reg broad_pulse;
+	struct _ims332_reg vsync;
+	struct _ims332_reg vpre_equalise;
+	struct _ims332_reg vpost_equalise;
+	struct _ims332_reg vblank;
+	struct _ims332_reg vdisplay;
+	struct _ims332_reg line_time;
+	struct _ims332_reg line_start;
+	struct _ims332_reg mem_init;
+	struct _ims332_reg transfer_delay;
+	struct _ims332_reg pad1[0x03f - 0x02e];
+	struct _ims332_reg pixel_address_mask;
+	struct _ims332_reg pad2[0x05f - 0x040];
+
+#define IMS332_CTRL_A_BOOT_ENABLE_VTG		0x000001
+#define IMS332_CTRL_A_SCREEN_FORMAT		0x000002
+#define IMS332_CTRL_A_INTERLACED_STANDARD	0x000004
+#define IMS332_CTRL_A_OPERATING_MODE		0x000008
+#define IMS332_CTRL_A_FRAME_FLYBACK_PATTERN	0x000010
+#define IMS332_CTRL_A_DIGITAL_SYNC_FORMAT	0x000020
+#define IMS332_CTRL_A_ANALOGUE_VIDEO_FORMAT	0x000040
+#define IMS332_CTRL_A_BLANK_LEVEL		0x000080
+#define IMS332_CTRL_A_BLANK_IO			0x000100
+#define IMS332_CTRL_A_BLANK_FUNCTION_SWITCH	0x000200
+#define IMS332_CTRL_A_FORCE_BLANKING		0x000400
+#define IMS332_CTRL_A_TURN_OFF_BLANKING		0x000800
+#define IMS332_CTRL_A_VRAM_ADDRESS_INCREMENT	0x003000
+#define IMS332_CTRL_A_TURN_OFF_DMA		0x004000
+#define IMS332_CTRL_A_SYNC_DELAY		0x038000
+#define IMS332_CTRL_A_PIXEL_PORT_INTERLEAVING	0x040000
+#define IMS332_CTRL_A_DELAYED_SAMPLING		0x080000
+#define IMS332_CTRL_A_BITS_PER_PIXEL		0x700000
+#define IMS332_CTRL_A_CURSOR_DISABLE		0x800000
+	struct _ims332_reg config_control_a;
+	struct _ims332_reg pad3[0x06f - 0x060];
+
+#define IMS332_CTRL_B_WRITE_ZERO	0xffffff
+	struct _ims332_reg config_control_b;
+	struct _ims332_reg pad4[0x07f - 0x070];
+	struct _ims332_reg screen_top;
+	struct _ims332_reg pad5[0x0a0 - 0x080];
+	/* cursor color palette, 3 entries, reg no. 0xa1 - 0xa3 */
+	struct _ims332_reg cursor_color_palette0;
+	struct _ims332_reg cursor_color_palette1;
+	struct _ims332_reg cursor_color_palette2;
+	struct _ims332_reg pad6[0x0bf - 0x0a3];
+	struct _ims332_reg rgb_frame_checksum0;
+	struct _ims332_reg rgb_frame_checksum1;
+	struct _ims332_reg rgb_frame_checksum2;
+	struct _ims332_reg pad7[0x0c6 - 0x0c2];
+	struct _ims332_reg cursor_start;
+	struct _ims332_reg pad8[0x0ff - 0x0c7];
+	/* color palette, 256 entries of form 0x00BBGGRR, reg no. 0x100 - 0x1ff */
+	struct _ims332_reg color_palette[0x1ff - 0x0ff];
+	/* hardware cursor bitmap, reg no. 0x200 - 0x3ff */
+	struct _ims332_reg cursor_ram[0x3ff - 0x1ff];
+};
+
+/*
+ * In the functions below we use some weird looking helper variables to
+ * access most members of this struct, otherwise the compiler splits
+ * the read/write in two byte accesses.
+ */
+struct ims332_regs {
+	struct _ims332_regs rw;
+	char pad0[0x80000 - sizeof (struct _ims332_regs)];
+	struct _ims332_regs r;
+	char pad1[0xa0000 - (sizeof (struct _ims332_regs) + 0x80000)];
+	struct _ims332_regs w;
+} __attribute__((packed));
+
+static inline void ims332_control_reg_bits(struct ims332_regs *regs, u32 mask,
+					   u32 val)
+{
+	volatile u16 *ctr = &(regs->r.config_control_a.r);
+	volatile u16 *ctw = &(regs->w.config_control_a.r);
+	u32 ctrl;
+
+	mb();
+	ctrl = *ctr;
+	rmb();
+	ctrl |= ((regs->rw.boot.r << 8) & 0x00ff0000);
+	ctrl |= val & mask;
+	ctrl &= ~(~val & mask);
+	wmb();
+	regs->rw.boot.r = (ctrl >> 8) & 0xff00;
+	wmb();
+	*ctw = ctrl & 0xffff;
+}
+
+/* FIXME: This is maxinefb specific. */
+static inline void ims332_bootstrap(struct ims332_regs *regs)
+{
+	volatile u16 *ctw = &(regs->w.config_control_a.r);
+	u32 ctrl = IMS332_CTRL_A_BOOT_ENABLE_VTG | IMS332_CTRL_A_TURN_OFF_DMA;
+
+	/* bootstrap sequence */
+	mb();
+	regs->rw.boot.r = 0;
+	wmb();
+	*ctw = 0;
+
+	/* init control A register */
+	wmb();
+	regs->rw.boot.r = (ctrl >> 8) & 0xff00;
+	wmb();
+	*ctw = ctrl & 0xffff;
+}
+
+static inline void ims332_blank_screen(struct ims332_regs *regs, int blank)
+{
+	ims332_control_reg_bits(regs, IMS332_CTRL_A_FORCE_BLANKING,
+				blank ? IMS332_CTRL_A_FORCE_BLANKING : 0);
+}
+
+static inline void ims332_set_color_depth(struct ims332_regs *regs, u32 depth)
+{
+	u32 dp;
+	u32 mask = (IMS332_CTRL_A_PIXEL_PORT_INTERLEAVING
+		    | IMS332_CTRL_A_DELAYED_SAMPLING
+		    | IMS332_CTRL_A_BITS_PER_PIXEL);
+
+	switch (depth) {
+	case 1: dp = 0 << 20; break;
+	case 2: dp = 1 << 20; break;
+	case 4: dp = 2 << 20; break;
+	case 8: dp = 3 << 20; break;
+	case 15: dp = (4 << 20) | IMS332_CTRL_A_PIXEL_PORT_INTERLEAVING; break;
+	case 16: dp = (5 << 20) | IMS332_CTRL_A_PIXEL_PORT_INTERLEAVING; break;
+	default: return;
+	}
+	ims332_control_reg_bits(regs, mask, dp);
+
+	if (depth <= 8) {
+		volatile u16 *pmask = &(regs->w.pixel_address_mask.r);
+		u32 dm = (1 << depth) - 1;
+
+		wmb();
+		regs->rw.boot.r = dm << 8;
+		wmb();
+		*pmask = dm << 8 | dm;
+	}
+}
+
+static inline void ims332_set_screen_top(struct ims332_regs *regs, u16 top)
+{
+	volatile u16 *st = &(regs->w.screen_top.r);
+
+	mb();
+	*st = top & 0xffff;
+}
+
+static inline void ims332_enable_cursor(struct ims332_regs *regs, int on)
+{
+	ims332_control_reg_bits(regs, IMS332_CTRL_A_CURSOR_DISABLE,
+				on ? 0 : IMS332_CTRL_A_CURSOR_DISABLE);
+}
+
+static inline void ims332_position_cursor(struct ims332_regs *regs,
+					  u16 x, u16 y)
+{
+	volatile u16 *cp = &(regs->w.cursor_start.r);
+	u32 val = ((x & 0xfff) << 12) | (y & 0xfff);
+
+	if (x > 2303 || y > 2303)
+		return;
+
+	mb();
+	regs->rw.boot.r = (val >> 8) & 0xff00;
+	wmb();
+	*cp = val & 0xffff;
+}
+
+static inline void ims332_set_font(struct ims332_regs *regs, u8 fgc,
+				   u16 width, u16 height)
+{
+	volatile u16 *cp0 = &(regs->w.cursor_color_palette0.r);
+	int i;
+
+	mb();
+	for (i = 0; i < 0x200; i++) {
+		volatile u16 *cram = &(regs->w.cursor_ram[i].r);
+
+		if (height << 6 <= i << 3)
+			*cram = 0x0000;
+		else if (width <= i % 8 << 3)
+			*cram = 0x0000;
+		else if (((width >> 3) & 0xffff) > i % 8)
+			*cram = 0x5555;
+		else
+			*cram = 0x5555 & ~(0xffff << (width % 8 << 1));
+		wmb();
+	}
+	regs->rw.boot.r = fgc << 8;
+	wmb();
+	*cp0 = fgc << 8 | fgc;
+}
+
+static inline void ims332_read_cmap(struct ims332_regs *regs, u8 reg,
+				    u8* red, u8* green, u8* blue)
+{
+	volatile u16 *rptr = &(regs->r.color_palette[reg].r);
+	u16 val;
+
+	mb();
+	val = *rptr;
+	*red = val & 0xff;
+	*green = (val >> 8) & 0xff;
+	rmb();
+	*blue = (regs->rw.boot.r >> 8) & 0xff;
+}
+
+static inline void ims332_write_cmap(struct ims332_regs *regs, u8 reg,
+				     u8 red, u8 green, u8 blue)
+{
+	volatile u16 *wptr = &(regs->w.color_palette[reg].r);
+
+	mb();
+	regs->rw.boot.r = blue << 8;
+	wmb();
+	*wptr = (green << 8) + red;
+}
+
+static inline void ims332_dump_regs(struct ims332_regs *regs)
+{
+	int i;
+
+	printk(__FUNCTION__);
+	ims332_control_reg_bits(regs, IMS332_CTRL_A_BOOT_ENABLE_VTG, 0);
+	for (i = 0; i < 0x100; i++) {
+		volatile u16 *cpad = (u16 *)((char *)(&regs->r) + sizeof(struct _ims332_reg) * i);
+		u32 val;
+
+		val = *cpad;
+		rmb();
+		val |= regs->rw.boot.r << 8;
+		rmb();
+		if (! (i % 8))
+			printk("\n%02x:", i);
+		printk(" %06x", val);
+	}
+	ims332_control_reg_bits(regs, IMS332_CTRL_A_BOOT_ENABLE_VTG,
+				IMS332_CTRL_A_BOOT_ENABLE_VTG);
+	printk("\n");
+}
diff -Nur linux-2.4.30/drivers/video/maxinefb.h linux-2.4.30-mips/drivers/video/maxinefb.h
--- linux-2.4.30/drivers/video/maxinefb.h	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.30-mips/drivers/video/maxinefb.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,38 +0,0 @@
-/*
- *      linux/drivers/video/maxinefb.h
- *
- *      DECstation 5000/xx onboard framebuffer support, Copyright (C) 1999 by
- *      Michael Engel <engel@unix-ag.org> and Karsten Merker <merker@guug.de>
- *      This file is subject to the terms and conditions of the GNU General
- *      Public License.  See the file COPYING in the main directory of this
- *      archive for more details.
- */
-
-#include <asm/addrspace.h>
-
-/*
- * IMS332 video controller register base address
- */
-#define MAXINEFB_IMS332_ADDRESS		KSEG1ADDR(0x1c140000)
-
-/*
- * Begin of DECstation 5000/xx onboard framebuffer memory, default resolution
- * is 1024x768x8
- */
-#define DS5000_xx_ONBOARD_FBMEM_START	KSEG1ADDR(0x0a000000)
-
-/*
- *      The IMS 332 video controller used in the DECstation 5000/xx series
- *      uses 32 bits wide registers; the following defines declare the
- *      register numbers, to get the real offset, these have to be multiplied
- *      by four.
- */
-
-#define IMS332_REG_CURSOR_RAM           0x200	/* hardware cursor bitmap */
-
-/*
- * The color palette entries have the form 0x00BBGGRR
- */
-#define IMS332_REG_COLOR_PALETTE        0x100	/* color palette, 256 entries */
-#define IMS332_REG_CURSOR_COLOR_PALETTE	0x0a1	/* cursor color palette, */
-						/* 3 entries             */
diff -Nur linux-2.4.30/drivers/video/newport_con.c linux-2.4.30-mips/drivers/video/newport_con.c
--- linux-2.4.30/drivers/video/newport_con.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.30-mips/drivers/video/newport_con.c	2004-09-23 15:32:29.000000000 +0200
@@ -22,6 +22,7 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 
+#include <asm/io.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <asm/page.h>
@@ -77,7 +78,7 @@
 static inline void newport_render_background(int xstart, int ystart,
 					     int xend, int yend, int ci)
 {
-	newport_wait();
+	newport_wait(npregs);
 	npregs->set.wrmask = 0xffffffff;
 	npregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |
 				 NPORT_DMODE0_DOSETUP | NPORT_DMODE0_STOPX
@@ -94,7 +95,7 @@
 	unsigned short i;
 
 	for (i = 0; i < 16; i++) {
-		newport_bfwait();
+		newport_bfwait(npregs);
 		newport_cmap_setaddr(npregs, color_table[i]);
 		newport_cmap_setrgb(npregs,
 				    default_red[i],
@@ -107,7 +108,7 @@
 	unsigned long i;
 
 	for (i = 0; i < LINUX_LOGO_COLORS; i++) {
-		newport_bfwait();
+		newport_bfwait(npregs);
 		newport_cmap_setaddr(npregs, i + 0x20);
 		newport_cmap_setrgb(npregs,
 				    linux_logo_red[i],
@@ -115,13 +116,13 @@
 				    linux_logo_blue[i]);
 	}
 
-	newport_wait();
+	newport_wait(npregs);
 	npregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |
 				 NPORT_DMODE0_CHOST);
 
 	npregs->set.xystarti = ((newport_xsize - LOGO_W) << 16) | (0);
 	npregs->set.xyendi = ((newport_xsize - 1) << 16);
-	newport_wait();
+	newport_wait(npregs);
 
 	for (i = 0; i < LOGO_W * LOGO_H; i++)
 		npregs->go.hostrw0 = linux_logo[i] << 24;
@@ -133,7 +134,7 @@
 	if (logo_active)
 		return;
 
-	newport_wait();
+	newport_wait(npregs);
 	npregs->set.wrmask = 0xffffffff;
 	npregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |
 				 NPORT_DMODE0_DOSETUP | NPORT_DMODE0_STOPX
@@ -155,7 +156,7 @@
 	unsigned short treg;
 	int i;
 
-	newport_wait();
+	newport_wait(npregs);
 	treg = newport_vc2_get(npregs, VC2_IREG_CONTROL);
 	newport_vc2_set(npregs, VC2_IREG_CONTROL,
 			(treg | VC2_CTRL_EVIDEO));
@@ -165,7 +166,7 @@
 	npregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |
 			       NPORT_DMODE_W2 | VC2_PROTOCOL);
 	for (i = 0; i < 128; i++) {
-		newport_bfwait();
+		newport_bfwait(npregs);
 		if (i == 92 || i == 94)
 			npregs->set.dcbdata0.byshort.s1 = 0xff00;
 		else
@@ -205,7 +206,7 @@
 	npregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |
 			       NPORT_DMODE_W2 | VC2_PROTOCOL);
 	for (i = 0; i < 128; i++) {
-		newport_bfwait();
+		newport_bfwait(npregs);
 		linetable[i] = npregs->set.dcbdata0.byshort.s1;
 	}
 
@@ -216,12 +217,12 @@
 		npregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |
 				       NPORT_DMODE_W2 | VC2_PROTOCOL);
 		do {
-			newport_bfwait();
+			newport_bfwait(npregs);
 			treg = npregs->set.dcbdata0.byshort.s1;
 			if ((treg & 1) == 0)
 				cols += (treg >> 7) & 0xfe;
 			if ((treg & 0x80) == 0) {
-				newport_bfwait();
+				newport_bfwait(npregs);
 				treg = npregs->set.dcbdata0.byshort.s1;
 			}
 		} while ((treg & 0x8000) == 0);
@@ -291,16 +292,16 @@
 
 	if (!sgi_gfxaddr)
 		return NULL;
-	npregs = (struct newport_regs *) (KSEG1 + sgi_gfxaddr);
+	npregs = (struct newport_regs *)	/* ioremap cannot fail */
+		 ioremap(sgi_gfxaddr, sizeof(struct newport_regs));
 	npregs->cset.config = NPORT_CFG_GD0;
 
-	if (newport_wait()) {
-		return NULL;
-	}
+	if (newport_wait(npregs))
+		goto out_unmap;
 
 	npregs->set.xstarti = TESTVAL;
 	if (npregs->set._xstart.word != XSTI_TO_FXSTART(TESTVAL))
-		return NULL;
+		goto out_unmap;
 
 	for (i = 0; i < MAX_NR_CONSOLES; i++)
 		font_data[i] = FONT_DATA;
@@ -310,6 +311,10 @@
 	newport_get_screensize();
 
 	return "SGI Newport";
+
+out_unmap:
+	iounmap((void *)npregs);
+	return NULL;
 }
 
 static void newport_init(struct vc_data *vc, int init)
@@ -363,7 +368,7 @@
 				  (charattr & 0xf0) >> 4);
 
 	/* Set the color and drawing mode. */
-	newport_wait();
+	newport_wait(npregs);
 	npregs->set.colori = charattr & 0xf;
 	npregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |
 				 NPORT_DMODE0_STOPX | NPORT_DMODE0_ZPENAB |
@@ -372,7 +377,7 @@
 	/* Set coordinates for bitmap operation. */
 	npregs->set.xystarti = (xpos << 16) | ((ypos + topscan) & 0x3ff);
 	npregs->set.xyendi = ((xpos + 7) << 16);
-	newport_wait();
+	newport_wait(npregs);
 
 	/* Go, baby, go... */
 	RENDER(npregs, p);
@@ -396,7 +401,7 @@
 					  xpos + ((count - 1) << 3), ypos,
 					  (charattr & 0xf0) >> 4);
 
-	newport_wait();
+	newport_wait(npregs);
 
 	/* Set the color and drawing mode. */
 	npregs->set.colori = charattr & 0xf;
@@ -407,7 +412,7 @@
 	for (i = 0; i < count; i++, xpos += 8) {
 		p = &font_data[vc->vc_num][(scr_readw(s++) & 0xff) << 4];
 
-		newport_wait();
+		newport_wait(npregs);
 
 		/* Set coordinates for bitmap operation. */
 		npregs->set.xystarti =
@@ -689,7 +694,7 @@
 		xe = xs;
 		xs = tmp;
 	}
-	newport_wait();
+	newport_wait(npregs);
 	npregs->set.drawmode0 = (NPORT_DMODE0_S2S | NPORT_DMODE0_BLOCK |
 				 NPORT_DMODE0_DOSETUP | NPORT_DMODE0_STOPX
 				 | NPORT_DMODE0_STOPY);
@@ -706,35 +711,35 @@
 #define DUMMY (void *) newport_dummy
 
 const struct consw newport_con = {
-    con_startup:	newport_startup,
-    con_init:		newport_init,
-    con_deinit:		newport_deinit,
-    con_clear:		newport_clear,
-    con_putc:		newport_putc,
-    con_putcs:		newport_putcs,
-    con_cursor:		newport_cursor,
-    con_scroll:		newport_scroll,
-    con_bmove:		newport_bmove,
-    con_switch:		newport_switch,
-    con_blank:		newport_blank,
-    con_font_op:	newport_font_op,
-    con_set_palette:	newport_set_palette,
-    con_scrolldelta:	newport_scrolldelta,
-    con_set_origin:	DUMMY,
-    con_save_screen:	DUMMY
+	.con_startup	  = newport_startup,
+	.con_init	  = newport_init,
+	.con_deinit	  = newport_deinit,
+	.con_clear	  = newport_clear,
+	.con_putc	  = newport_putc,
+	.con_putcs	  = newport_putcs,
+	.con_cursor	  = newport_cursor,
+	.con_scroll	  = newport_scroll,
+	.con_bmove 	  = newport_bmove,
+	.con_switch	  = newport_switch,
+	.con_blank	  = newport_blank,
+	.con_font_op	  = newport_font_op,
+	.con_set_palette  = newport_set_palette,
+	.con_scrolldelta  = newport_scrolldelta,
+	.con_set_origin	  = DUMMY,
+	.con_save_screen  = DUMMY
 };
 
 #ifdef MODULE
 static int __init newport_console_init(void)
 {
 	take_over_console(&newport_con, 0, MAX_NR_CONSOLES - 1, 1);
-
 	return 0;
 }
 
 static void __exit newport_console_exit(void)
 {
 	give_up_console(&newport_con);
+	iounmap((void *)npregs);
 }
 
 module_init(newport_console_init);
diff -Nur linux-2.4.30/drivers/video/tgafb.c linux-2.4.30-mips/drivers/video/tgafb.c
--- linux-2.4.30/drivers/video/tgafb.c	2001-11-14 23:52:20.000000000 +0100
+++ linux-2.4.30-mips/drivers/video/tgafb.c	2004-10-30 01:15:02.000000000 +0200
@@ -45,6 +45,15 @@
 #include <linux/console.h>
 #include <asm/io.h>
 
+#ifdef CONFIG_TC
+#include <asm/dec/tc.h>
+#else
+static int search_tc_card(const char *) { return -1; }
+static void claim_tc_card(int) { }
+static void release_tc_card(int) { }
+static unsigned long get_tc_base_addr(int) { return 0; }
+#endif
+
 #include <video/fbcon.h>
 #include <video/fbcon-cfb8.h>
 #include <video/fbcon-cfb32.h>
@@ -84,10 +93,10 @@
 };
 
 static unsigned int deep_presets[4] = {
-  0x00014000,
-  0x0001440d,
+  0x00004000,
+  0x0000440d,
   0xffffffff,
-  0x0001441d
+  0x0000441d
 };
 
 static unsigned int rasterop_presets[4] = {
@@ -131,6 +140,13 @@
 	0,
 	FB_VMODE_NONINTERLACED
     }},
+    { "1280x1024-72", {			/* mode #0 of PMAGD boards */
+	1280, 1024, 1280, 1024, 0, 0, 0, 0,
+	{0, 8, 0}, {0, 8, 0}, {0, 8, 0}, {0, 0, 0},
+	0, 0, -1, -1, FB_ACCELF_TEXT, 7692, 232, 32, 34, 3, 160, 3,
+	FB_SYNC_ON_GREEN,
+	FB_VMODE_NONINTERLACED
+    }},
     { "800x600-56", {
 	800, 600, 800, 600, 0, 0, 0, 0,
 	{0, 8, 0}, {0, 8, 0}, {0, 8, 0}, {0, 0, 0},
@@ -488,7 +504,8 @@
       continue;
 
     mb();
-    TGA_WRITE_REG(deep_presets[fb_info.tga_type], TGA_DEEP_REG);
+    TGA_WRITE_REG(deep_presets[fb_info.tga_type] |
+		  (par->sync_on_green ? 0x0 : 0x00010000), TGA_DEEP_REG);
     while (TGA_READ_REG(TGA_CMD_STAT_REG) & 1) /* wait for not busy */
 	continue;
     mb();
@@ -548,7 +565,7 @@
 	BT463_WRITE(BT463_REG_ACC, BT463_CMD_REG_0, 0x40);
 	BT463_WRITE(BT463_REG_ACC, BT463_CMD_REG_1, 0x08);
 	BT463_WRITE(BT463_REG_ACC, BT463_CMD_REG_2, 
-		(par->sync_on_green ? 0x80 : 0x40));
+		(par->sync_on_green ? 0xc0 : 0x40));
 
 	BT463_WRITE(BT463_REG_ACC, BT463_READ_MASK_0, 0xff);
 	BT463_WRITE(BT463_REG_ACC, BT463_READ_MASK_1, 0xff);
@@ -921,19 +938,34 @@
 int __init tgafb_init(void)
 {
     struct pci_dev *pdev;
+    int slot;
 
     pdev = pci_find_device(PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_DEC_TGA, NULL);
     if (!pdev)
+	slot = search_tc_card("PMAGD");
+    if (!pdev && slot < 0)
 	return -ENXIO;
 
     /* divine board type */
 
-    fb_info.tga_mem_base = (unsigned long)ioremap(pdev->resource[0].start, 0);
-    fb_info.tga_type = (readl(fb_info.tga_mem_base) >> 12) & 0x0f;
-    fb_info.tga_regs_base = fb_info.tga_mem_base + TGA_REGS_OFFSET;
-    fb_info.tga_fb_base = (fb_info.tga_mem_base
+    if (pdev) {
+	fb_info.tga_mem_base = (unsigned long)ioremap(pdev->resource[0].start,
+						      0);
+	fb_info.tga_type = (readl(fb_info.tga_mem_base) >> 12) & 0x0f;
+	fb_info.tga_regs_base = fb_info.tga_mem_base + TGA_REGS_OFFSET;
+	fb_info.tga_fb_base = (fb_info.tga_mem_base
 			   + fb_offset_presets[fb_info.tga_type]);
-    pci_read_config_byte(pdev, PCI_REVISION_ID, &fb_info.tga_chip_rev);
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &fb_info.tga_chip_rev);
+
+    } else {
+	claim_tc_card(slot);
+	fb_info.tga_mem_base = get_tc_base_addr(slot);
+	fb_info.tga_type = (readl(fb_info.tga_mem_base) >> 12) & 0x0f;	/* ? */
+	fb_info.tga_regs_base = fb_info.tga_mem_base + TGA_REGS_OFFSET;
+	fb_info.tga_fb_base = (fb_info.tga_mem_base
+			   + fb_offset_presets[fb_info.tga_type]);
+	fb_info.tga_chip_rev = TGA_READ_REG(TGA_START_REG) & 0xff;
+    }
 
     /* setup framebuffer */
 
@@ -950,40 +982,62 @@
     fb_info.gen.fbhw = &tgafb_hwswitch;
     fb_info.gen.fbhw->detect();
 
-    printk (KERN_INFO "tgafb: DC21030 [TGA] detected, rev=0x%02x\n", fb_info.tga_chip_rev);
-    printk (KERN_INFO "tgafb: at PCI bus %d, device %d, function %d\n", 
-	    pdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+    if (pdev) {
+	printk (KERN_INFO "tgafb: DC21030 [TGA] detected, rev=0x%02x\n",
+		fb_info.tga_chip_rev);
+	printk (KERN_INFO "tgafb: at PCI bus %d, device %d, function %d\n", 
+		pdev->bus->number,
+		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+    } else {
+	printk (KERN_INFO "tgafb: SFB+ detected, rev=0x%02x\n",
+		fb_info.tga_chip_rev);
+    }
 	    
     switch (fb_info.tga_type) 
     { 
 	case TGA_TYPE_8PLANE:
-	    strcpy (fb_info.gen.info.modename,"Digital ZLXp-E1"); 
+	    if (pdev)
+		strcpy (fb_info.gen.info.modename,"Digital ZLXp-E1"); 
+	    else
+		strcpy (fb_info.gen.info.modename,"Digital ZLX-E1"); 
 	    break;
 
 	case TGA_TYPE_24PLANE:
-	    strcpy (fb_info.gen.info.modename,"Digital ZLXp-E2"); 
+	    if (pdev)
+		strcpy (fb_info.gen.info.modename,"Digital ZLXp-E2"); 
+	    else
+		strcpy (fb_info.gen.info.modename,"Digital ZLX-E2"); 
 	    break;
 
 	case TGA_TYPE_24PLUSZ:
-	    strcpy (fb_info.gen.info.modename,"Digital ZLXp-E3"); 
+	    if (pdev)
+		strcpy (fb_info.gen.info.modename,"Digital ZLXp-E3"); 
+	    else
+		strcpy (fb_info.gen.info.modename,"Digital ZLX-E3"); 
 	    break;
     }
 
     /* This should give a reasonable default video mode */
 
     if (!default_var_valid) {
-	default_var = tgafb_predefined[0].var;
+	if (pdev)
+	    default_var = tgafb_predefined[0].var;
+	else
+	    default_var = tgafb_predefined[1].var;
     }
     fbgen_get_var(&disp.var, -1, &fb_info.gen.info);
     disp.var.activate = FB_ACTIVATE_NOW;
     fbgen_do_set_var(&disp.var, 1, &fb_info.gen);
     fbgen_set_disp(-1, &fb_info.gen);
     fbgen_install_cmap(0, &fb_info.gen);
-    if (register_framebuffer(&fb_info.gen.info) < 0)
+    if (register_framebuffer(&fb_info.gen.info) < 0) {
+	if (slot >= 0)
+	    release_tc_card(slot);
 	return -EINVAL;
-    printk(KERN_INFO "fb%d: %s frame buffer device at 0x%lx\n", 
+    }
+    printk(KERN_INFO "fb%d: %s frame buffer device at 0x%llx\n", 
 	    GET_FB_IDX(fb_info.gen.info.node), fb_info.gen.info.modename, 
-	    pdev->resource[0].start);
+	    fb_info.tga_mem_base);
     return 0;
 }
 
diff -Nur linux-2.4.30/drivers/video/tgafb.h linux-2.4.30-mips/drivers/video/tgafb.h
--- linux-2.4.30/drivers/video/tgafb.h	2000-04-12 18:47:28.000000000 +0200
+++ linux-2.4.30-mips/drivers/video/tgafb.h	2004-10-30 01:15:02.000000000 +0200
@@ -36,6 +36,7 @@
 #define	TGA_RASTEROP_REG		0x0034
 #define	TGA_PIXELSHIFT_REG		0x0038
 #define	TGA_DEEP_REG			0x0050
+#define	TGA_START_REG			0x0054
 #define	TGA_PIXELMASK_REG		0x005c
 #define	TGA_CURSOR_BASE_REG		0x0060
 #define	TGA_HORIZ_REG			0x0064
diff -Nur linux-2.4.30/fs/binfmt_elf.c linux-2.4.30-mips/fs/binfmt_elf.c
--- linux-2.4.30/fs/binfmt_elf.c	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.30-mips/fs/binfmt_elf.c	2005-04-05 21:09:57.000000000 +0200
@@ -660,6 +660,9 @@
 		    bprm->argc++;
 		  }
 		}
+	} else {
+		/* Executables without an interpreter also need a personality  */
+		SET_PERSONALITY(elf_ex, ibcs2_interpreter);
 	}
 
 	/* Flush all traces of the currently running executable */
@@ -1211,7 +1214,11 @@
 	elf.e_entry = 0;
 	elf.e_phoff = sizeof(elf);
 	elf.e_shoff = 0;
+#ifdef ELF_CORE_EFLAGS
+	elf.e_flags = ELF_CORE_EFLAGS;
+#else
 	elf.e_flags = 0;
+#endif
 	elf.e_ehsize = sizeof(elf);
 	elf.e_phentsize = sizeof(struct elf_phdr);
 	elf.e_phnum = segs+1;		/* Include notes */
diff -Nur linux-2.4.30/fs/partitions/sgi.c linux-2.4.30-mips/fs/partitions/sgi.c
--- linux-2.4.30/fs/partitions/sgi.c	2001-10-02 05:03:26.000000000 +0200
+++ linux-2.4.30-mips/fs/partitions/sgi.c	2004-08-11 22:30:07.000000000 +0200
@@ -17,6 +17,11 @@
 #include "check.h"
 #include "sgi.h"
 
+#if CONFIG_BLK_DEV_MD
+extern void md_autodetect_dev(kdev_t dev);
+#endif
+
+
 int sgi_partition(struct gendisk *hd, struct block_device *bdev, unsigned long first_sector, int current_minor)
 {
 	int i, csum, magic;
@@ -77,6 +82,10 @@
 		if(!blocks)
 			continue;
 		add_gd_partition(hd, current_minor, start, blocks);
+#ifdef CONFIG_BLK_DEV_MD
+		if (be32_to_cpu(p->type) == LINUX_RAID_PARTITION)
+			md_autodetect_dev(MKDEV(hd->major, current_minor));
+#endif
 		current_minor++;
 	}
 	printk("\n");
diff -Nur linux-2.4.30/fs/proc/array.c linux-2.4.30-mips/fs/proc/array.c
--- linux-2.4.30/fs/proc/array.c	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30-mips/fs/proc/array.c	2004-11-29 18:47:18.000000000 +0100
@@ -368,15 +368,15 @@
 		task->cmin_flt,
 		task->maj_flt,
 		task->cmaj_flt,
-		task->times.tms_utime,
-		task->times.tms_stime,
-		task->times.tms_cutime,
-		task->times.tms_cstime,
+		hz_to_std(task->times.tms_utime),
+		hz_to_std(task->times.tms_stime),
+		hz_to_std(task->times.tms_cutime),
+		hz_to_std(task->times.tms_cstime),
 		priority,
 		nice,
 		0UL /* removed */,
 		task->it_real_value,
-		task->start_time,
+		hz_to_std(task->start_time),
 		vsize,
 		mm ? mm->rss : 0, /* you might want to shift this left 3 */
 		task->rlim[RLIMIT_RSS].rlim_cur,
@@ -615,14 +615,14 @@
 
 	len = sprintf(buffer,
 		"cpu  %lu %lu\n",
-		task->times.tms_utime,
-		task->times.tms_stime);
+		hz_to_std(task->times.tms_utime),
+		hz_to_std(task->times.tms_stime));
 		
 	for (i = 0 ; i < smp_num_cpus; i++)
 		len += sprintf(buffer + len, "cpu%d %lu %lu\n",
 			i,
-			task->per_cpu_utime[cpu_logical_map(i)],
-			task->per_cpu_stime[cpu_logical_map(i)]);
+			hz_to_std(task->per_cpu_utime[cpu_logical_map(i)]),
+			hz_to_std(task->per_cpu_stime[cpu_logical_map(i)]));
 
 	return len;
 }
diff -Nur linux-2.4.30/fs/proc/proc_misc.c linux-2.4.30-mips/fs/proc/proc_misc.c
--- linux-2.4.30/fs/proc/proc_misc.c	2004-08-08 01:26:06.000000000 +0200
+++ linux-2.4.30-mips/fs/proc/proc_misc.c	2004-08-14 20:39:01.000000000 +0200
@@ -308,16 +308,16 @@
 {
 	int i, len = 0;
 	extern unsigned long total_forks;
-	unsigned long jif = jiffies;
+	unsigned long jif = hz_to_std(jiffies);
 	unsigned int sum = 0, user = 0, nice = 0, system = 0;
 	int major, disk;
 
 	for (i = 0 ; i < smp_num_cpus; i++) {
 		int cpu = cpu_logical_map(i), j;
 
-		user += kstat.per_cpu_user[cpu];
-		nice += kstat.per_cpu_nice[cpu];
-		system += kstat.per_cpu_system[cpu];
+		user += hz_to_std(kstat.per_cpu_user[cpu]);
+		nice += hz_to_std(kstat.per_cpu_nice[cpu]);
+		system += hz_to_std(kstat.per_cpu_system[cpu]);
 #if !defined(CONFIG_ARCH_S390)
 		for (j = 0 ; j < NR_IRQS ; j++)
 			sum += kstat.irqs[cpu][j];
@@ -331,10 +331,10 @@
 		proc_sprintf(page, &off, &len,
 			"cpu%d %u %u %u %lu\n",
 			i,
-			kstat.per_cpu_user[cpu_logical_map(i)],
-			kstat.per_cpu_nice[cpu_logical_map(i)],
-			kstat.per_cpu_system[cpu_logical_map(i)],
-			jif - (  kstat.per_cpu_user[cpu_logical_map(i)] \
+			hz_to_std(kstat.per_cpu_user[cpu_logical_map(i)]),
+			hz_to_std(kstat.per_cpu_nice[cpu_logical_map(i)]),
+			hz_to_std(kstat.per_cpu_system[cpu_logical_map(i)]),
+			jif - hz_to_std(  kstat.per_cpu_user[cpu_logical_map(i)] \
 				   + kstat.per_cpu_nice[cpu_logical_map(i)] \
 				   + kstat.per_cpu_system[cpu_logical_map(i)]));
 	proc_sprintf(page, &off, &len,
diff -Nur linux-2.4.30/include/asm-alpha/param.h linux-2.4.30-mips/include/asm-alpha/param.h
--- linux-2.4.30/include/asm-alpha/param.h	2000-11-08 08:37:31.000000000 +0100
+++ linux-2.4.30-mips/include/asm-alpha/param.h	2000-11-28 04:59:03.000000000 +0100
@@ -13,6 +13,9 @@
 # else
 #  define HZ	1200
 # endif
+#ifdef __KERNEL__
+# define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192
diff -Nur linux-2.4.30/include/asm-i386/param.h linux-2.4.30-mips/include/asm-i386/param.h
--- linux-2.4.30/include/asm-i386/param.h	2000-10-27 20:04:43.000000000 +0200
+++ linux-2.4.30-mips/include/asm-i386/param.h	2000-11-23 03:00:55.000000000 +0100
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -Nur linux-2.4.30/include/asm-ia64/param.h linux-2.4.30-mips/include/asm-ia64/param.h
--- linux-2.4.30/include/asm-ia64/param.h	2004-04-14 15:05:40.000000000 +0200
+++ linux-2.4.30-mips/include/asm-ia64/param.h	2004-04-16 05:14:20.000000000 +0200
@@ -7,9 +7,15 @@
  * Based on <asm-i386/param.h>.
  *
  * Modified 1998, 1999, 2002-2003
- *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
+ *    David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
  */
 
+#include <linux/config.h>
+
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
+
 #define EXEC_PAGESIZE	65536
 
 #ifndef NGROUPS
diff -Nur linux-2.4.30/include/asm-m68k/param.h linux-2.4.30-mips/include/asm-m68k/param.h
--- linux-2.4.30/include/asm-m68k/param.h	2001-01-04 22:00:55.000000000 +0100
+++ linux-2.4.30-mips/include/asm-m68k/param.h	2001-01-11 05:02:45.000000000 +0100
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192
diff -Nur linux-2.4.30/include/asm-mips/au1000.h linux-2.4.30-mips/include/asm-mips/au1000.h
--- linux-2.4.30/include/asm-mips/au1000.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/au1000.h	2005-01-30 09:01:28.000000000 +0100
@@ -160,28 +160,356 @@
 #define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4 | IE_IRQ5)
 #endif
 
-/* SDRAM Controller */
+/*
+ * SDRAM Register Offsets
+ */
 #if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1100)
-#define MEM_SDMODE0                0xB4000000
-#define MEM_SDMODE1                0xB4000004
-#define MEM_SDMODE2                0xB4000008
-
-#define MEM_SDADDR0                0xB400000C
-#define MEM_SDADDR1                0xB4000010
-#define MEM_SDADDR2                0xB4000014
-
-#define MEM_SDREFCFG               0xB4000018
-#define MEM_SDPRECMD               0xB400001C
-#define MEM_SDAUTOREF              0xB4000020
-
-#define MEM_SDWRMD0                0xB4000024
-#define MEM_SDWRMD1                0xB4000028
-#define MEM_SDWRMD2                0xB400002C
+#define MEM_SDMODE0		(0x0000)
+#define MEM_SDMODE1		(0x0004)
+#define MEM_SDMODE2		(0x0008)
+#define MEM_SDADDR0		(0x000C)
+#define MEM_SDADDR1		(0x0010)
+#define MEM_SDADDR2		(0x0014)
+#define MEM_SDREFCFG	(0x0018)
+#define MEM_SDPRECMD	(0x001C)
+#define MEM_SDAUTOREF	(0x0020)
+#define MEM_SDWRMD0		(0x0024)
+#define MEM_SDWRMD1		(0x0028)
+#define MEM_SDWRMD2		(0x002C)
+#define MEM_SDSLEEP		(0x0030)
+#define MEM_SDSMCKE		(0x0034)
+
+#ifndef ASSEMBLER
+/*typedef volatile struct
+{
+	uint32 sdmode0;
+	uint32 sdmode1;
+	uint32 sdmode2;
+	uint32 sdaddr0;
+	uint32 sdaddr1;
+	uint32 sdaddr2;
+	uint32 sdrefcfg;
+	uint32 sdautoref;
+	uint32 sdwrmd0;
+	uint32 sdwrmd1;
+	uint32 sdwrmd2;
+	uint32 sdsleep;
+	uint32 sdsmcke;
+
+} AU1X00_SDRAM;*/
+#endif
+
+/*
+ * MEM_SDMODE register content definitions
+ */
+#define MEM_SDMODE_F		(1<<22)
+#define MEM_SDMODE_SR		(1<<21)
+#define MEM_SDMODE_BS		(1<<20)
+#define MEM_SDMODE_RS		(3<<18)
+#define MEM_SDMODE_CS		(7<<15)
+#define MEM_SDMODE_TRAS		(15<<11)
+#define MEM_SDMODE_TMRD		(3<<9)
+#define MEM_SDMODE_TWR		(3<<7)
+#define MEM_SDMODE_TRP		(3<<5)
+#define MEM_SDMODE_TRCD		(3<<3)
+#define MEM_SDMODE_TCL		(7<<0)
+
+#define MEM_SDMODE_BS_2Bank	(0<<20)
+#define MEM_SDMODE_BS_4Bank	(1<<20)
+#define MEM_SDMODE_RS_11Row	(0<<18)
+#define MEM_SDMODE_RS_12Row	(1<<18)
+#define MEM_SDMODE_RS_13Row	(2<<18)
+#define MEM_SDMODE_RS_N(N)	((N)<<18)
+#define MEM_SDMODE_CS_7Col	(0<<15)
+#define MEM_SDMODE_CS_8Col	(1<<15)
+#define MEM_SDMODE_CS_9Col	(2<<15)
+#define MEM_SDMODE_CS_10Col	(3<<15)
+#define MEM_SDMODE_CS_11Col	(4<<15)
+#define MEM_SDMODE_CS_N(N)		((N)<<15)
+#define MEM_SDMODE_TRAS_N(N)	((N)<<11)
+#define MEM_SDMODE_TMRD_N(N)	((N)<<9)
+#define MEM_SDMODE_TWR_N(N)		((N)<<7)
+#define MEM_SDMODE_TRP_N(N)		((N)<<5)
+#define MEM_SDMODE_TRCD_N(N)	((N)<<3)
+#define MEM_SDMODE_TCL_N(N)		((N)<<0)
+
+/*
+ * MEM_SDADDR register contents definitions
+ */
+#define MEM_SDADDR_E			(1<<20)
+#define MEM_SDADDR_CSBA			(0x03FF<<10)
+#define MEM_SDADDR_CSMASK		(0x03FF<<0)
+#define MEM_SDADDR_CSBA_N(N)	((N)&(0x03FF<<22)>>12)
+#define MEM_SDADDR_CSMASK_N(N)	((N)&(0x03FF<<22)>>22)
+
+/*
+ * MEM_SDREFCFG register content definitions
+ */
+#define MEM_SDREFCFG_TRC		(15<<28)
+#define MEM_SDREFCFG_TRPM		(3<<26)
+#define MEM_SDREFCFG_E			(1<<25)
+#define MEM_SDREFCFG_RE			(0x1ffffff<<0)
+#define MEM_SDREFCFG_TRC_N(N)	((N)<<MEM_SDREFCFG_TRC)
+#define MEM_SDREFCFG_TRPM_N(N)	((N)<<MEM_SDREFCFG_TRPM)
+#define MEM_SDREFCFG_REF_N(N)	(N)
+#endif
+
+/***********************************************************************/
+
+/*
+ * Au1550 SDRAM Register Offsets
+ */
+
+/***********************************************************************/
+
+#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
+#define MEM_SDMODE0		(0x0800)
+#define MEM_SDMODE1		(0x0808)
+#define MEM_SDMODE2		(0x0810)
+#define MEM_SDADDR0		(0x0820)
+#define MEM_SDADDR1		(0x0828)
+#define MEM_SDADDR2		(0x0830)
+#define MEM_SDCONFIGA	(0x0840)
+#define MEM_SDCONFIGB	(0x0848)
+#define MEM_SDSTAT		(0x0850)
+#define MEM_SDERRADDR	(0x0858)
+#define MEM_SDSTRIDE0	(0x0860)
+#define MEM_SDSTRIDE1	(0x0868)
+#define MEM_SDSTRIDE2	(0x0870)
+#define MEM_SDWRMD0		(0x0880)
+#define MEM_SDWRMD1		(0x0888)
+#define MEM_SDWRMD2		(0x0890)
+#define MEM_SDPRECMD	(0x08C0)
+#define MEM_SDAUTOREF	(0x08C8)
+#define MEM_SDSREF		(0x08D0)
+#define MEM_SDSLEEP		MEM_SDSREF
+
+#ifndef ASSEMBLER
+/*typedef volatile struct
+{
+	uint32 sdmode0;
+	uint32 reserved0;
+	uint32 sdmode1;
+	uint32 reserved1;
+	uint32 sdmode2;
+	uint32 reserved2[3];
+	uint32 sdaddr0;
+	uint32 reserved3;
+	uint32 sdaddr1;
+	uint32 reserved4;
+	uint32 sdaddr2;
+	uint32 reserved5[3];
+	uint32 sdconfiga;
+	uint32 reserved6;
+	uint32 sdconfigb;
+	uint32 reserved7;
+	uint32 sdstat;
+	uint32 reserved8;
+	uint32 sderraddr;
+	uint32 reserved9;
+	uint32 sdstride0;
+	uint32 reserved10;
+	uint32 sdstride1;
+	uint32 reserved11;
+	uint32 sdstride2;
+	uint32 reserved12[3];
+	uint32 sdwrmd0;
+	uint32 reserved13;
+	uint32 sdwrmd1;
+	uint32 reserved14;
+	uint32 sdwrmd2;
+	uint32 reserved15[11];
+	uint32 sdprecmd;
+	uint32 reserved16;
+	uint32 sdautoref;
+	uint32 reserved17;
+	uint32 sdsref;
+
+} AU1550_SDRAM;*/
+#endif
+#endif
+
+/*
+ * Physical base addresses for integrated peripherals
+ */
+
+#ifdef CONFIG_SOC_AU1000
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define	IRDA_PHYS_ADDR		0x10300000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MAC1_PHYS_ADDR		0x10510000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART2_PHYS_ADDR		0x11300000
+#define	UART3_PHYS_ADDR		0x11400000
+#define	SSI0_PHYS_ADDR		0x11600000
+#define	SSI1_PHYS_ADDR		0x11680000
+#define	SYS_PHYS_ADDR		0x11900000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#endif
+
+/********************************************************************/
 
-#define MEM_SDSLEEP                0xB4000030
-#define MEM_SDSMCKE                0xB4000034
+#ifdef CONFIG_SOC_AU1500
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define PCI_PHYS_ADDR		0x14005000
+#define	MAC0_PHYS_ADDR		0x11500000
+#define	MAC1_PHYS_ADDR		0x11510000
+#define	MACEN_PHYS_ADDR		0x11520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART3_PHYS_ADDR		0x11400000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define PCI_MEM_PHYS_ADDR     0x400000000
+#define PCI_IO_PHYS_ADDR      0x500000000
+#define PCI_CONFIG0_PHYS_ADDR 0x600000000
+#define PCI_CONFIG1_PHYS_ADDR 0x680000000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
 #endif
 
+/********************************************************************/
+
+#ifdef CONFIG_SOC_AU1100
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define SD0_PHYS_ADDR		0x10600000
+#define SD1_PHYS_ADDR		0x10680000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define	IRDA_PHYS_ADDR		0x10300000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART3_PHYS_ADDR		0x11400000
+#define	SSI0_PHYS_ADDR		0x11600000
+#define	SSI1_PHYS_ADDR		0x11680000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define LCD_PHYS_ADDR		0x15000000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#endif
+
+/***********************************************************************/
+
+#ifdef CONFIG_SOC_AU1550
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	USBH_PHYS_ADDR		0x14020000
+#define	USBD_PHYS_ADDR		0x10200000
+#define PCI_PHYS_ADDR		0x14005000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MAC1_PHYS_ADDR		0x10510000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART3_PHYS_ADDR		0x11400000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define	DDMA_PHYS_ADDR		0x14002000
+#define PE_PHYS_ADDR		0x14008000
+#define PSC0_PHYS_ADDR	 	0x11A00000
+#define PSC1_PHYS_ADDR	 	0x11B00000
+#define PSC2_PHYS_ADDR	 	0x10A00000
+#define PSC3_PHYS_ADDR	 	0x10B00000
+#define PCI_MEM_PHYS_ADDR     0x400000000
+#define PCI_IO_PHYS_ADDR      0x500000000
+#define PCI_CONFIG0_PHYS_ADDR 0x600000000
+#define PCI_CONFIG1_PHYS_ADDR 0x680000000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#endif
+
+/***********************************************************************/
+
+#ifdef CONFIG_SOC_AU1200
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define AES_PHYS_ADDR		0x10300000
+#define CIM_PHYS_ADDR		0x14004000
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define USBM_PHYS_ADDR		0x14020000
+#define	USBH_PHYS_ADDR		0x14020100
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define	DDMA_PHYS_ADDR		0x14002000
+#define PSC0_PHYS_ADDR	 	0x11A00000
+#define PSC1_PHYS_ADDR	 	0x11B00000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#define SD0_PHYS_ADDR		0x10600000
+#define SD1_PHYS_ADDR		0x10680000
+#define LCD_PHYS_ADDR		0x15000000
+#define SWCNT_PHYS_ADDR		0x1110010C
+#define MAEFE_PHYS_ADDR		0x14012000
+#define MAEBE_PHYS_ADDR		0x14010000
+#endif
+
+
 /* Static Bus Controller */
 #define MEM_STCFG0                 0xB4001000
 #define MEM_STTIME0                0xB4001004
@@ -367,7 +695,7 @@
 #define AU1000_MAC0_ENABLE       0xB0520000
 #define AU1000_MAC1_ENABLE       0xB0520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1000
+#endif /* CONFIG_SOC_AU1000 */
 
 /* Au1500 */
 #ifdef CONFIG_SOC_AU1500
@@ -438,7 +766,7 @@
 #define AU1500_MAC0_ENABLE       0xB1520000
 #define AU1500_MAC1_ENABLE       0xB1520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1500
+#endif /* CONFIG_SOC_AU1500 */
 
 /* Au1100 */
 #ifdef CONFIG_SOC_AU1100
@@ -483,6 +811,22 @@
 #define AU1000_GPIO_13            45
 #define AU1000_GPIO_14            46
 #define AU1000_GPIO_15            47
+#define AU1000_GPIO_16            48
+#define AU1000_GPIO_17            49
+#define AU1000_GPIO_18            50
+#define AU1000_GPIO_19            51
+#define AU1000_GPIO_20            52
+#define AU1000_GPIO_21            53
+#define AU1000_GPIO_22            54
+#define AU1000_GPIO_23            55
+#define AU1000_GPIO_24            56
+#define AU1000_GPIO_25            57
+#define AU1000_GPIO_26            58
+#define AU1000_GPIO_27            59
+#define AU1000_GPIO_28            60
+#define AU1000_GPIO_29            61
+#define AU1000_GPIO_30            62
+#define AU1000_GPIO_31            63
 
 #define UART0_ADDR                0xB1100000
 #define UART1_ADDR                0xB1200000
@@ -494,7 +838,7 @@
 #define AU1100_ETH0_BASE	  0xB0500000
 #define AU1100_MAC0_ENABLE       0xB0520000
 #define NUM_ETH_INTERFACES 1
-#endif // CONFIG_SOC_AU1100
+#endif /* CONFIG_SOC_AU1100 */
 
 #ifdef CONFIG_SOC_AU1550
 #define AU1550_UART0_INT          0
@@ -511,14 +855,14 @@
 #define AU1550_PSC1_INT           11
 #define AU1550_PSC2_INT           12
 #define AU1550_PSC3_INT           13
-#define AU1550_TOY_INT			  14
-#define AU1550_TOY_MATCH0_INT     15
-#define AU1550_TOY_MATCH1_INT     16
-#define AU1550_TOY_MATCH2_INT     17
-#define AU1550_RTC_INT            18
-#define AU1550_RTC_MATCH0_INT     19
-#define AU1550_RTC_MATCH1_INT     20
-#define AU1550_RTC_MATCH2_INT     21
+#define AU1000_TOY_INT			  14
+#define AU1000_TOY_MATCH0_INT     15
+#define AU1000_TOY_MATCH1_INT     16
+#define AU1000_TOY_MATCH2_INT     17
+#define AU1000_RTC_INT            18
+#define AU1000_RTC_MATCH0_INT     19
+#define AU1000_RTC_MATCH1_INT     20
+#define AU1000_RTC_MATCH2_INT     21
 #define AU1550_NAND_INT           23
 #define AU1550_USB_DEV_REQ_INT    24
 #define AU1550_USB_DEV_SUS_INT    25
@@ -573,7 +917,7 @@
 #define AU1550_MAC0_ENABLE       0xB0520000
 #define AU1550_MAC1_ENABLE       0xB0520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1550
+#endif /* CONFIG_SOC_AU1550 */
 
 #ifdef CONFIG_SOC_AU1200
 #define AU1200_UART0_INT          0
@@ -590,14 +934,14 @@
 #define AU1200_PSC1_INT           11
 #define AU1200_AES_INT            12
 #define AU1200_CAMERA_INT         13
-#define AU1200_TOY_INT			  14
-#define AU1200_TOY_MATCH0_INT     15
-#define AU1200_TOY_MATCH1_INT     16
-#define AU1200_TOY_MATCH2_INT     17
-#define AU1200_RTC_INT            18
-#define AU1200_RTC_MATCH0_INT     19
-#define AU1200_RTC_MATCH1_INT     20
-#define AU1200_RTC_MATCH2_INT     21
+#define AU1000_TOY_INT			  14
+#define AU1000_TOY_MATCH0_INT     15
+#define AU1000_TOY_MATCH1_INT     16
+#define AU1000_TOY_MATCH2_INT     17
+#define AU1000_RTC_INT            18
+#define AU1000_RTC_MATCH0_INT     19
+#define AU1000_RTC_MATCH1_INT     20
+#define AU1000_RTC_MATCH2_INT     21
 #define AU1200_NAND_INT           23
 #define AU1200_GPIO_204           24
 #define AU1200_GPIO_205           25
@@ -605,6 +949,7 @@
 #define AU1200_GPIO_207           27
 #define AU1200_GPIO_208_215       28 // Logical OR of 208:215
 #define AU1200_USB_INT            29
+#define AU1000_USB_HOST_INT		  AU1200_USB_INT
 #define AU1200_LCD_INT            30
 #define AU1200_MAE_BOTH_INT       31
 #define AU1000_GPIO_0             32
@@ -643,21 +988,36 @@
 #define UART0_ADDR                0xB1100000
 #define UART1_ADDR                0xB1200000
 
-#define USB_OHCI_BASE             0x14020000 // phys addr for ioremap
-#define USB_HOST_CONFIG           0xB4027ffc
+#define USB_UOC_BASE              0x14020020
+#define USB_UOC_LEN               0x20
+#define USB_OHCI_BASE             0x14020100
+#define USB_OHCI_LEN              0x100
+#define USB_EHCI_BASE             0x14020200
+#define USB_EHCI_LEN              0x100
+#define USB_UDC_BASE              0x14022000
+#define USB_UDC_LEN               0x2000
+#define USB_MSR_BASE			  0xB4020000
+#define USB_MSR_MCFG              4
+#define USBMSRMCFG_OMEMEN         0
+#define USBMSRMCFG_OBMEN          1
+#define USBMSRMCFG_EMEMEN         2
+#define USBMSRMCFG_EBMEN          3
+#define USBMSRMCFG_DMEMEN         4
+#define USBMSRMCFG_DBMEN          5
+#define USBMSRMCFG_GMEMEN         6
+#define USBMSRMCFG_OHCCLKEN       16
+#define USBMSRMCFG_EHCCLKEN       17
+#define USBMSRMCFG_UDCCLKEN       18
+#define USBMSRMCFG_PHYPLLEN       19
+#define USBMSRMCFG_RDCOMB         30
+#define USBMSRMCFG_PFEN           31
 
-// these are here for prototyping on au1550 (do not exist on au1200)
-#define AU1200_ETH0_BASE      0xB0500000
-#define AU1200_ETH1_BASE      0xB0510000
-#define AU1200_MAC0_ENABLE       0xB0520000
-#define AU1200_MAC1_ENABLE       0xB0520004
-#define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1200
+#endif /* CONFIG_SOC_AU1200 */
 
 #define AU1000_LAST_INTC0_INT     31
+#define AU1000_LAST_INTC1_INT     63
 #define AU1000_MAX_INTR           63
 
-
 /* Programmable Counters 0 and 1 */
 #define SYS_BASE                   0xB1900000
 #define SYS_COUNTER_CNTRL          (SYS_BASE + 0x14)
@@ -728,6 +1088,8 @@
   #define I2S_CONTROL_D         (1<<1)
   #define I2S_CONTROL_CE        (1<<0)
 
+#ifndef CONFIG_SOC_AU1200
+
 /* USB Host Controller */
 #define USB_OHCI_LEN              0x00100000
 
@@ -773,6 +1135,8 @@
   #define USBDEV_ENABLE (1<<1)
   #define USBDEV_CE     (1<<0)
 
+#endif /* !CONFIG_SOC_AU1200 */
+
 /* Ethernet Controllers  */
 
 /* 4 byte offsets from AU1000_ETH_BASE */
@@ -1171,6 +1535,37 @@
   #define SYS_PF_PSC1_S1		(1 << 1)
   #define SYS_PF_MUST_BE_SET		((1 << 5) | (1 << 2))
 
+/* Au1200 Only */
+#ifdef CONFIG_SOC_AU1200
+#define SYS_PINFUNC_DMA		(1<<31)
+#define SYS_PINFUNC_S0A		(1<<30)
+#define SYS_PINFUNC_S1A		(1<<29)
+#define SYS_PINFUNC_LP0		(1<<28)
+#define SYS_PINFUNC_LP1		(1<<27)
+#define SYS_PINFUNC_LD16	(1<<26)
+#define SYS_PINFUNC_LD8		(1<<25)
+#define SYS_PINFUNC_LD1		(1<<24)
+#define SYS_PINFUNC_LD0		(1<<23)
+#define SYS_PINFUNC_P1A		(3<<21)
+#define SYS_PINFUNC_P1B		(1<<20)
+#define SYS_PINFUNC_FS3		(1<<19)
+#define SYS_PINFUNC_P0A		(3<<17)
+#define SYS_PINFUNC_CS		(1<<16)
+#define SYS_PINFUNC_CIM		(1<<15)
+#define SYS_PINFUNC_P1C		(1<<14)
+#define SYS_PINFUNC_U1T		(1<<12)
+#define SYS_PINFUNC_U1R		(1<<11)
+#define SYS_PINFUNC_EX1		(1<<10)
+#define SYS_PINFUNC_EX0		(1<<9)
+#define SYS_PINFUNC_U0R		(1<<8)
+#define SYS_PINFUNC_MC		(1<<7)
+#define SYS_PINFUNC_S0B		(1<<6)
+#define SYS_PINFUNC_S0C		(1<<5)
+#define SYS_PINFUNC_P0B		(1<<4)
+#define SYS_PINFUNC_U0T		(1<<3)
+#define SYS_PINFUNC_S1B		(1<<2)
+#endif
+
 #define SYS_TRIOUTRD              0xB1900100
 #define SYS_TRIOUTCLR             0xB1900100
 #define SYS_OUTPUTRD              0xB1900108
@@ -1298,7 +1693,6 @@
 #define SD1_XMIT_FIFO	0xB0680000
 #define SD1_RECV_FIFO	0xB0680004
 
-
 #if defined (CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)
 /* Au1500 PCI Controller */
 #define Au1500_CFG_BASE           0xB4005000 // virtual, kseg0 addr
@@ -1388,9 +1782,60 @@
 
 #endif
 
+#ifndef _LANGUAGE_ASSEMBLY
+typedef volatile struct
+{
+	/* 0x0000 */ u32 toytrim;
+	/* 0x0004 */ u32 toywrite;
+	/* 0x0008 */ u32 toymatch0;
+	/* 0x000C */ u32 toymatch1;
+	/* 0x0010 */ u32 toymatch2;
+	/* 0x0014 */ u32 cntrctrl;
+	/* 0x0018 */ u32 scratch0;
+	/* 0x001C */ u32 scratch1;
+	/* 0x0020 */ u32 freqctrl0;
+	/* 0x0024 */ u32 freqctrl1;
+	/* 0x0028 */ u32 clksrc;
+	/* 0x002C */ u32 pinfunc;
+	/* 0x0030 */ u32 reserved0;
+	/* 0x0034 */ u32 wakemsk;
+	/* 0x0038 */ u32 endian;
+	/* 0x003C */ u32 powerctrl;
+	/* 0x0040 */ u32 toyread;
+	/* 0x0044 */ u32 rtctrim;
+	/* 0x0048 */ u32 rtcwrite;
+	/* 0x004C */ u32 rtcmatch0;
+	/* 0x0050 */ u32 rtcmatch1;
+	/* 0x0054 */ u32 rtcmatch2;
+	/* 0x0058 */ u32 rtcread;
+	/* 0x005C */ u32 wakesrc;
+	/* 0x0060 */ u32 cpupll;
+	/* 0x0064 */ u32 auxpll;
+	/* 0x0068 */ u32 reserved1;
+	/* 0x006C */ u32 reserved2;
+	/* 0x0070 */ u32 reserved3;
+	/* 0x0074 */ u32 reserved4;
+	/* 0x0078 */ u32 slppwr;
+	/* 0x007C */ u32 sleep;
+	/* 0x0080 */ u32 reserved5[32];
+	/* 0x0100 */ u32 trioutrd;
+#define trioutclr trioutrd
+	/* 0x0104 */ u32 reserved6;
+	/* 0x0108 */ u32 outputrd;
+#define outputset outputrd
+	/* 0x010C */ u32 outputclr;
+	/* 0x0110 */ u32 pinstaterd;
+#define pininputen pinstaterd
+
+} AU1X00_SYS;
+
+static AU1X00_SYS* const sys  = (AU1X00_SYS *)SYS_BASE;
+
+#endif
 /* Processor information base on prid.
  * Copied from PowerPC.
  */
+#ifndef _LANGUAGE_ASSEMBLY
 struct cpu_spec {
 	/* CPU is matched via (PRID & prid_mask) == prid_value */
 	unsigned int	prid_mask;
@@ -1404,3 +1849,6 @@
 extern struct cpu_spec		cpu_specs[];
 extern struct cpu_spec		*cur_cpu_spec[];
 #endif
+
+#endif
+
diff -Nur linux-2.4.30/include/asm-mips/au1000_gpio.h linux-2.4.30-mips/include/asm-mips/au1000_gpio.h
--- linux-2.4.30/include/asm-mips/au1000_gpio.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/au1000_gpio.h	2005-01-30 09:01:28.000000000 +0100
@@ -30,6 +30,13 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+/*
+ *  Revision history
+ *    01/31/02  0.01   Initial release. Steve Longerbeam, MontaVista
+ *    10/12/03  0.1    Added Au1100/Au1500, GPIO2, and bit operations. K.C. Nishio, AMD
+ *    08/05/04  0.11   Added Au1550 and Au1200. K.C. Nishio
+ */
+
 #ifndef __AU1000_GPIO_H
 #define __AU1000_GPIO_H
 
@@ -44,13 +51,94 @@
 #define AU1000GPIO_TRISTATE	_IOW (AU1000GPIO_IOC_MAGIC, 4, int)
 #define AU1000GPIO_AVAIL_MASK	_IOR (AU1000GPIO_IOC_MAGIC, 5, int)
 
+// bit operations
+#define AU1000GPIO_BIT_READ	_IOW (AU1000GPIO_IOC_MAGIC, 6, int)
+#define AU1000GPIO_BIT_SET	_IOW (AU1000GPIO_IOC_MAGIC, 7, int)
+#define AU1000GPIO_BIT_CLEAR	_IOW (AU1000GPIO_IOC_MAGIC, 8, int)
+#define AU1000GPIO_BIT_TRISTATE	_IOW (AU1000GPIO_IOC_MAGIC, 9, int)
+#define AU1000GPIO_BIT_INIT	_IOW (AU1000GPIO_IOC_MAGIC, 10, int)
+#define AU1000GPIO_BIT_TERM	_IOW (AU1000GPIO_IOC_MAGIC, 11, int)
+
+/* set this major numer same as the CRIS GPIO driver */
+#define AU1X00_GPIO_MAJOR	(120)
+
+#define ENABLED_ZERO		(0)
+#define ENABLED_ONE		(1)
+#define ENABLED_10		(0x2)
+#define ENABLED_11		(0x3)
+#define ENABLED_111		(0x7)
+#define NOT_AVAIL		(-1)
+#define AU1X00_MAX_PRIMARY_GPIO	(32) 
+
+#define AU1000_GPIO_MINOR_MAX	AU1X00_MAX_PRIMARY_GPIO
+/* Au1100, 1500, 1550 and 1200 have the secondary GPIO block */
+#define AU1XX0_GPIO_MINOR_MAX	(48)
+
+#define AU1X00_GPIO_NAME	"gpio"
+
+/* GPIO pins which are not multiplexed */
+#if defined(CONFIG_SOC_AU1000)
+  #define NATIVE_GPIOPIN	((1 << 15) | (1 << 8) | (1 << 7) | (1 << 1) | (1 << 0))
+  #define NATIVE_GPIO2PIN	(0)
+#elif defined(CONFIG_SOC_AU1100)
+  #define NATIVE_GPIOPIN	((1 << 23) | (1 << 22) | (1 << 21) | (1 << 20) | (1 << 19) | (1 << 18) | \
+				 (1 << 17) | (1 << 16) | (1 << 7) | (1 << 1) | (1 << 0))
+  #define NATIVE_GPIO2PIN	(0)
+#elif defined(CONFIG_SOC_AU1500)
+  #define NATIVE_GPIOPIN	((1 << 15) | (1 << 8) | (1 << 7) | (1 << 1) | (1 << 0))
+  /* exclude the PCI reset output signal: GPIO[200], DMA_REQ2 and DMA_REQ3 */
+  #define NATIVE_GPIO2PIN	(0xfffe & ~((1 << 9) | (1 << 8))) 
+#elif defined(CONFIG_SOC_AU1550)
+  #define NATIVE_GPIOPIN	((1 << 15) | (1 << 8) | (1 << 7) | (1 << 6) | (1 << 1) | (1 << 0))
+  /* please refere Au1550 Data Book, chapter 15 */
+  #define NATIVE_GPIO2PIN	(1 << 5) 
+#elif defined(CONFIG_SOC_AU1200)
+  #define NATIVE_GPIOPIN	((1 << 7) | (1 << 5))
+  #define NATIVE_GPIO2PIN	(0) 
+#endif
+
+/* minor as u32 */
+#define MINOR_TO_GPIOPIN(minor)		((minor < AU1X00_MAX_PRIMARY_GPIO) ? minor : (minor - AU1X00_MAX_PRIMARY_GPIO))
+#define IS_PRIMARY_GPIOPIN(minor)	((minor < AU1X00_MAX_PRIMARY_GPIO) ? 1 : 0)
+
+/*
+ * pin to minor mapping.
+ * GPIO0-GPIO31, minor=0-31.
+ * GPIO200-GPIO215, minor=32-47.
+ */
+typedef struct _au1x00_gpio_bit_ctl {
+	int direction;	// The direction of this GPIO pin. 0: IN, 1: OUT.
+	int data;	// Pin output when itized (0/1), or at the term. 0/1/-1 (tristate).
+} au1x00_gpio_bit_ctl;
+
+typedef struct _au1x00_gpio_driver {
+	const char	*driver_name;
+	const char	*name;
+	int		name_base;	/* offset of printed name */
+	short		major;		/* major device number */
+	short		minor_start;	/* start of minor device number*/
+	short		num;		/* number of devices */
+} au1x00_gpio_driver;
+
 #ifdef __KERNEL__
-extern u32 get_au1000_avail_gpio_mask(void);
-extern int au1000gpio_tristate(u32 data);
-extern int au1000gpio_in(u32 *data);
-extern int au1000gpio_set(u32 data);
-extern int au1000gpio_clear(u32 data);
-extern int au1000gpio_out(u32 data);
+extern u32 get_au1000_avail_gpio_mask(u32 *avail_gpio2);
+extern int au1000gpio_tristate(u32 minor, u32 data);
+extern int au1000gpio_in(u32 minor, u32 *data);
+extern int au1000gpio_set(u32 minor, u32 data);
+extern int au1000gpio_clear(u32 minor, u32 data);
+extern int au1000gpio_out(u32 minor, u32 data);
+extern int au1000gpio_bit_read(u32 minor, u32 *read_data);
+extern int au1000gpio_bit_set(u32 minor);
+extern int au1000gpio_bit_clear(u32 minor);
+extern int au1000gpio_bit_tristate(u32 minor);
+extern int check_minor_to_gpio(u32 minor);
+extern int au1000gpio_bit_init(u32 minor, au1x00_gpio_bit_ctl *bit_opt);
+extern int au1000gpio_bit_term(u32 minor, au1x00_gpio_bit_ctl *bit_opt);
+
+extern void gpio_register_devfs (au1x00_gpio_driver *driver, unsigned int flags, unsigned minor);
+extern void gpio_unregister_devfs (au1x00_gpio_driver *driver, unsigned minor);
+extern int gpio_register_driver(au1x00_gpio_driver *driver);
+extern int gpio_unregister_driver(au1x00_gpio_driver *driver);
 #endif
 
 #endif
diff -Nur linux-2.4.30/include/asm-mips/au1000_pcmcia.h linux-2.4.30-mips/include/asm-mips/au1000_pcmcia.h
--- linux-2.4.30/include/asm-mips/au1000_pcmcia.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/au1000_pcmcia.h	2005-01-30 09:01:28.000000000 +0100
@@ -38,16 +38,41 @@
 #define AU1X_SOCK0_PHYS_MEM  0xF80000000
 
 /* pcmcia socket 1 needs external glue logic so the memory map
- * differs from board to board.
+ * differs from board to board. the general rule is that
+ * static bus address bit 26 should be used to decode socket 0
+ * from socket 1. alas, some boards dont follow this...
+ * These really belong in a board-specific header file...
  */
-#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_PB1500)
-#define AU1X_SOCK1_IO        0xF08000000
-#define AU1X_SOCK1_PHYS_ATTR 0xF48000000
-#define AU1X_SOCK1_PHYS_MEM  0xF88000000
-#elif defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500) || defined(CONFIG_MIPS_PB1550) || defined(CONFIG_MIPS_DB1550)
-#define AU1X_SOCK1_IO        0xF04000000
-#define AU1X_SOCK1_PHYS_ATTR 0xF44000000
-#define AU1X_SOCK1_PHYS_MEM  0xF84000000
+#ifdef CONFIG_MIPS_PB1000
+#define SOCK1_DECODE (1<<27)
+#endif
+#ifdef CONFIG_MIPS_DB1000
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_DB1500
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_DB1100
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_DB1550
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_DB1200
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_PB1550
+#define SOCK1_DECODE (1<<26)
+#endif
+#ifdef CONFIG_MIPS_PB1200
+#define SOCK1_DECODE (1<<26)
+#endif
+
+/* The board has a second PCMCIA socket */
+#ifdef SOCK1_DECODE
+#define AU1X_SOCK1_IO        (0xF00000000|SOCK1_DECODE)
+#define AU1X_SOCK1_PHYS_ATTR (0xF40000000|SOCK1_DECODE)
+#define AU1X_SOCK1_PHYS_MEM  (0xF80000000|SOCK1_DECODE)
 #endif
 
 struct pcmcia_state {
diff -Nur linux-2.4.30/include/asm-mips/au1100_mmc.h linux-2.4.30-mips/include/asm-mips/au1100_mmc.h
--- linux-2.4.30/include/asm-mips/au1100_mmc.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/au1100_mmc.h	2005-01-30 09:01:28.000000000 +0100
@@ -39,16 +39,22 @@
 #define __ASM_AU1100_MMC_H
 
 
-#define NUM_AU1100_MMC_CONTROLLERS	2
-
-
-#define AU1100_SD_IRQ	2
-
+#if defined(CONFIG_SOC_AU1100)
+#define NUM_MMC_CONTROLLERS	2
+#define AU1X_MMC_INT AU1100_SD_INT
+#endif
+
+#if defined(CONFIG_SOC_AU1200)
+#define NUM_MMC_CONTROLLERS	2
+#define AU1X_MMC_INT AU1200_SD_INT
+#endif
 
 #define SD0_BASE	0xB0600000
 #define SD1_BASE	0xB0680000
 
 
+
+
 /*
  *  Register offsets.
  */
@@ -201,5 +207,12 @@
 #define SD_CMD_RT_1B	(0x00810000)
 
 
+/* support routines required on a platform-specific basis */
+extern void mmc_card_inserted(int _n_, int *_res_);
+extern void mmc_card_writable(int _n_, int *_res_);
+extern void mmc_power_on(int _n_);
+extern void mmc_power_off(int _n_);
+
+
 #endif /* __ASM_AU1100_MMC_H */
 
diff -Nur linux-2.4.30/include/asm-mips/au1xxx_dbdma.h linux-2.4.30-mips/include/asm-mips/au1xxx_dbdma.h
--- linux-2.4.30/include/asm-mips/au1xxx_dbdma.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/au1xxx_dbdma.h	2005-01-30 09:01:28.000000000 +0100
@@ -43,7 +43,7 @@
 #define DDMA_GLOBAL_BASE	0xb4003000
 #define DDMA_CHANNEL_BASE	0xb4002000
 
-typedef struct dbdma_global {
+typedef volatile struct dbdma_global {
 	u32	ddma_config;
 	u32	ddma_intstat;
 	u32	ddma_throttle;
@@ -60,7 +60,7 @@
 
 /* The structure of a DMA Channel.
 */
-typedef struct au1xxx_dma_channel {
+typedef volatile struct au1xxx_dma_channel {
 	u32	ddma_cfg;	/* See below */
 	u32	ddma_desptr;	/* 32-byte aligned pointer to descriptor */
 	u32	ddma_statptr;	/* word aligned pointer to status word */
@@ -96,7 +96,7 @@
 /* "Standard" DDMA Descriptor.
  * Must be 32-byte aligned.
  */
-typedef struct au1xxx_ddma_desc {
+typedef volatile struct au1xxx_ddma_desc {
 	u32	dscr_cmd0;		/* See below */
 	u32	dscr_cmd1;		/* See below */
 	u32	dscr_source0;		/* source phys address */
@@ -105,6 +105,12 @@
 	u32	dscr_dest1;		/* See below */
 	u32	dscr_stat;		/* completion status */
 	u32	dscr_nxtptr;		/* Next descriptor pointer (mostly) */
+	/* First 32bytes are HW specific!!!
+	   Lets have some SW data following.. make sure its 32bytes
+	 */
+	u32	sw_status;
+	u32 	sw_context;
+	u32	sw_reserved[6];
 } au1x_ddma_desc_t;
 
 #define DSCR_CMD0_V		(1 << 31)	/* Descriptor valid */
@@ -123,6 +129,8 @@
 #define DSCR_CMD0_CV		(0x1 << 2)	/* Clear Valid when done */
 #define DSCR_CMD0_ST_MASK	(0x3 << 0)	/* Status instruction */
 
+#define SW_STATUS_INUSE		(1<<0)
+
 /* Command 0 device IDs.
 */
 #ifdef CONFIG_SOC_AU1550
@@ -169,8 +177,8 @@
 #define DSCR_CMD0_SDMS_RX0	9
 #define DSCR_CMD0_SDMS_TX1	10
 #define DSCR_CMD0_SDMS_RX1	11
-#define DSCR_CMD0_AES_TX	12
-#define DSCR_CMD0_AES_RX	13
+#define DSCR_CMD0_AES_TX	13
+#define DSCR_CMD0_AES_RX	12
 #define DSCR_CMD0_PSC0_TX	14
 #define DSCR_CMD0_PSC0_RX	15
 #define DSCR_CMD0_PSC1_TX	16
@@ -189,6 +197,10 @@
 #define DSCR_CMD0_THROTTLE	30
 #define DSCR_CMD0_ALWAYS	31
 #define DSCR_NDEV_IDS		32
+/* THis macro is used to find/create custom device types */
+#define DSCR_DEV2CUSTOM_ID(x,d)	(((((x)&0xFFFF)<<8)|0x32000000)|((d)&0xFF))
+#define DSCR_CUSTOM2DEV_ID(x)	((x)&0xFF)
+
 
 #define DSCR_CMD0_SID(x)	(((x) & 0x1f) << 25)
 #define DSCR_CMD0_DID(x)	(((x) & 0x1f) << 20)
@@ -277,6 +289,43 @@
 */
 #define NUM_DBDMA_CHANS	16
 
+/*
+ * Ddma API definitions
+ * FIXME: may not fit to this header file
+ */
+typedef struct dbdma_device_table {
+	u32		dev_id;
+	u32		dev_flags;
+	u32		dev_tsize;
+	u32		dev_devwidth;
+	u32		dev_physaddr;		/* If FIFO */
+	u32		dev_intlevel;
+	u32		dev_intpolarity;
+} dbdev_tab_t;
+
+
+typedef struct dbdma_chan_config {
+	spinlock_t      lock;
+
+	u32			chan_flags;
+	u32			chan_index;
+	dbdev_tab_t		*chan_src;
+	dbdev_tab_t		*chan_dest;
+	au1x_dma_chan_t		*chan_ptr;
+	au1x_ddma_desc_t	*chan_desc_base;
+	au1x_ddma_desc_t	*get_ptr, *put_ptr, *cur_ptr;
+	void			*chan_callparam;
+	void (*chan_callback)(int, void *, struct pt_regs *);
+} chan_tab_t;
+
+#define DEV_FLAGS_INUSE		(1 << 0)
+#define DEV_FLAGS_ANYUSE	(1 << 1)
+#define DEV_FLAGS_OUT		(1 << 2)
+#define DEV_FLAGS_IN		(1 << 3)
+#define DEV_FLAGS_BURSTABLE (1 << 4)
+#define DEV_FLAGS_SYNC		(1 << 5)
+/* end Ddma API definitions */
+
 /* External functions for drivers to use.
 */
 /* Use this to allocate a dbdma channel.  The device ids are one of the
@@ -299,8 +348,8 @@
 
 /* Put buffers on source/destination descriptors.
 */
-u32 au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes);
-u32 au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes);
+u32 _au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags);
+u32 _au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags);
 
 /* Get a buffer from the destination descriptor.
 */
@@ -314,5 +363,25 @@
 void au1xxx_dbdma_chan_free(u32 chanid);
 void au1xxx_dbdma_dump(u32 chanid);
 
+u32 au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr );
+
+u32 au1xxx_ddma_add_device( dbdev_tab_t *dev );
+
+/*
+ 	Some compatibilty macros --
+		Needed to make changes to API without breaking existing drivers
+*/
+#define	au1xxx_dbdma_put_source(chanid,buf,nbytes)_au1xxx_dbdma_put_source(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define	au1xxx_dbdma_put_source_flags(chanid,buf,nbytes,flags) _au1xxx_dbdma_put_source(chanid, buf, nbytes, flags)
+
+#define au1xxx_dbdma_put_dest(chanid,buf,nbytes) _au1xxx_dbdma_put_dest(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define	au1xxx_dbdma_put_dest_flags(chanid,buf,nbytes,flags) _au1xxx_dbdma_put_dest(chanid, buf, nbytes, flags)
+
+/*
+ *	Flags for the put_source/put_dest functions.
+ */
+#define DDMA_FLAGS_IE	(1<<0)
+#define DDMA_FLAGS_NOIE (1<<1)
+
 #endif /* _LANGUAGE_ASSEMBLY */
 #endif /* _AU1000_DBDMA_H_ */
diff -Nur linux-2.4.30/include/asm-mips/au1xxx_gpio.h linux-2.4.30-mips/include/asm-mips/au1xxx_gpio.h
--- linux-2.4.30/include/asm-mips/au1xxx_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/au1xxx_gpio.h	2005-01-30 09:01:28.000000000 +0100
@@ -0,0 +1,22 @@
+
+
+#ifndef __AU1XXX_GPIO_H
+#define __AU1XXX_GPIO_H
+
+void au1xxx_gpio1_set_inputs(void);
+void au1xxx_gpio_tristate(int signal);
+void au1xxx_gpio_write(int signal, int value);
+int  au1xxx_gpio_read(int signal);
+
+typedef volatile struct
+{
+	u32 dir;
+	u32 reserved;
+	u32 output;
+	u32 pinstate;
+	u32 inten;
+	u32 enable;
+
+} AU1X00_GPIO2;
+
+#endif //__AU1XXX_GPIO_H
diff -Nur linux-2.4.30/include/asm-mips/au1xxx_psc.h linux-2.4.30-mips/include/asm-mips/au1xxx_psc.h
--- linux-2.4.30/include/asm-mips/au1xxx_psc.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/au1xxx_psc.h	2005-01-30 09:01:28.000000000 +0100
@@ -41,6 +41,11 @@
 #define PSC3_BASE_ADDR		0xb0d00000
 #endif
 
+#ifdef CONFIG_SOC_AU1200
+#define PSC0_BASE_ADDR		0xb1a00000
+#define PSC1_BASE_ADDR		0xb1b00000
+#endif
+
 /* The PSC select and control registers are common to
  * all protocols.
  */
@@ -226,6 +231,8 @@
 #define PSC_I2SCFG_DD_DISABLE	(1 << 27)
 #define PSC_I2SCFG_DE_ENABLE	(1 << 26)
 #define PSC_I2SCFG_SET_WS(x)	(((((x) / 2) - 1) & 0x7f) << 16)
+#define PSC_I2SCFG_WS(n)		((n&0xFF)<<16)
+#define PSC_I2SCFG_WS_MASK	(PSC_I2SCFG_WS(0x3F))
 #define PSC_I2SCFG_WI		(1 << 15)
 
 #define PSC_I2SCFG_DIV_MASK	(3 << 13)
diff -Nur linux-2.4.30/include/asm-mips/bootinfo.h linux-2.4.30-mips/include/asm-mips/bootinfo.h
--- linux-2.4.30/include/asm-mips/bootinfo.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/bootinfo.h	2005-01-30 09:01:28.000000000 +0100
@@ -180,6 +180,9 @@
 #define MACH_MTX1		7	/* 4G MTX-1 Au1500-based board */
 #define MACH_CSB250		8	/* Cogent Au1500 */
 #define MACH_PB1550     	9       /* Au1550-based eval board */
+#define MACH_PB1200     	10      /* Au1200-based eval board */
+#define MACH_DB1550     	11      /* Au1550-based eval board */
+#define MACH_DB1200     	12      /* Au1200-based eval board */
 
 /*
  * Valid machtype for group NEC_VR41XX
diff -Nur linux-2.4.30/include/asm-mips/db1200.h linux-2.4.30-mips/include/asm-mips/db1200.h
--- linux-2.4.30/include/asm-mips/db1200.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/db1200.h	2005-01-30 09:02:45.000000000 +0100
@@ -0,0 +1,214 @@
+/*
+ * AMD Alchemy DB1200 Referrence Board
+ * Board Registers defines.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_DB1200_H
+#define __ASM_DB1200_H
+
+#include <linux/types.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+#define BCSR_KSEG1_ADDR 0xB9800000
+
+typedef volatile struct
+{
+	/*00*/	u16 whoami;
+		u16 reserved0;
+	/*04*/	u16 status;
+		u16 reserved1;
+	/*08*/	u16 switches;
+		u16 reserved2;
+	/*0C*/	u16 resets;
+		u16 reserved3;
+
+	/*10*/	u16 pcmcia;
+		u16 reserved4;
+	/*14*/	u16 board;
+		u16 reserved5;
+	/*18*/	u16 disk_leds;
+		u16 reserved6;
+	/*1C*/	u16 system;
+		u16 reserved7;
+
+	/*20*/	u16 intclr;
+		u16 reserved8;
+	/*24*/	u16 intset;
+		u16 reserved9;
+	/*28*/	u16 intclr_mask;
+		u16 reserved10;
+	/*2C*/	u16 intset_mask;
+		u16 reserved11;
+
+	/*30*/	u16 sig_status;
+		u16 reserved12;
+	/*34*/	u16 int_status;
+		u16 reserved13;
+	/*38*/	u16 reserved14;
+		u16 reserved15;
+	/*3C*/	u16 reserved16;
+		u16 reserved17;
+
+} BCSR;
+
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+/*
+ * Register bit definitions for the BCSRs
+ */
+#define BCSR_WHOAMI_DCID	0x000F
+#define BCSR_WHOAMI_CPLD	0x00F0
+#define BCSR_WHOAMI_BOARD	0x0F00
+
+#define BCSR_STATUS_PCMCIA0VS	0x0003
+#define BCSR_STATUS_PCMCIA1VS	0x000C
+#define BCSR_STATUS_SWAPBOOT	0x0040
+#define BCSR_STATUS_FLASHBUSY	0x0100
+#define BCSR_STATUS_IDECBLID	0x0200
+#define BCSR_STATUS_SD0WP		0x0400
+#define BCSR_STATUS_U0RXD		0x1000
+#define BCSR_STATUS_U1RXD		0x2000
+
+#define BCSR_SWITCHES_OCTAL	0x00FF
+#define BCSR_SWITCHES_DIP_1	0x0080
+#define BCSR_SWITCHES_DIP_2	0x0040
+#define BCSR_SWITCHES_DIP_3	0x0020
+#define BCSR_SWITCHES_DIP_4	0x0010
+#define BCSR_SWITCHES_DIP_5	0x0008
+#define BCSR_SWITCHES_DIP_6	0x0004
+#define BCSR_SWITCHES_DIP_7	0x0002
+#define BCSR_SWITCHES_DIP_8	0x0001
+#define BCSR_SWITCHES_ROTARY	0x0F00
+
+#define BCSR_RESETS_ETH		0x0001
+#define BCSR_RESETS_CAMERA	0x0002
+#define BCSR_RESETS_DC		0x0004
+#define BCSR_RESETS_IDE		0x0008
+#define BCSR_RESETS_TV		0x0010
+/* not resets but in the same register */
+#define BCSR_RESETS_PWMR1mUX 0x0800
+#define BCSR_RESETS_PCS0MUX	0x1000
+#define BCSR_RESETS_PCS1MUX	0x2000
+#define BCSR_RESETS_SPISEL	0x4000
+
+#define BCSR_PCMCIA_PC0VPP	0x0003
+#define BCSR_PCMCIA_PC0VCC	0x000C
+#define BCSR_PCMCIA_PC0DRVEN	0x0010
+#define BCSR_PCMCIA_PC0RST	0x0080
+#define BCSR_PCMCIA_PC1VPP	0x0300
+#define BCSR_PCMCIA_PC1VCC	0x0C00
+#define BCSR_PCMCIA_PC1DRVEN	0x1000
+#define BCSR_PCMCIA_PC1RST	0x8000
+
+#define BCSR_BOARD_LCDVEE	0x0001
+#define BCSR_BOARD_LCDVDD	0x0002
+#define BCSR_BOARD_LCDBL	0x0004
+#define BCSR_BOARD_CAMSNAP	0x0010
+#define BCSR_BOARD_CAMPWR	0x0020
+#define BCSR_BOARD_SD0PWR	0x0040
+
+#define BCSR_LEDS_DECIMALS	0x0003
+#define BCSR_LEDS_LED0		0x0100
+#define BCSR_LEDS_LED1		0x0200
+#define BCSR_LEDS_LED2		0x0400
+#define BCSR_LEDS_LED3		0x0800
+
+#define BCSR_SYSTEM_POWEROFF	0x4000
+#define BCSR_SYSTEM_RESET	0x8000
+
+/* Bit positions for the different interrupt sources */
+#define BCSR_INT_IDE		0x0001
+#define BCSR_INT_ETH		0x0002
+#define BCSR_INT_PC0		0x0004
+#define BCSR_INT_PC0STSCHG	0x0008
+#define BCSR_INT_PC1		0x0010
+#define BCSR_INT_PC1STSCHG	0x0020
+#define BCSR_INT_DC			0x0040
+#define BCSR_INT_FLASHBUSY	0x0080
+#define BCSR_INT_PC0INSERT	0x0100
+#define BCSR_INT_PC0EJECT	0x0200
+#define BCSR_INT_PC1INSERT	0x0400
+#define BCSR_INT_PC1EJECT	0x0800
+#define BCSR_INT_SD0INSERT	0x1000
+#define BCSR_INT_SD0EJECT	0x2000
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x19000300)
+#define AU1XXX_SMC91111_IRQ			DB1200_ETH_INT
+
+#define AU1XXX_ATA_PHYS_ADDR		(0x18800000)
+#define AU1XXX_ATA_PHYS_LEN			(0x100)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+#define AU1XXX_ATA_INT			DB1200_IDE_INT
+#define AU1XXX_ATA_DDMA_REQ		DSCR_CMD0_DMA_REQ1;
+#define AU1XXX_ATA_RQSIZE		128
+
+#define NAND_PHYS_ADDR   0x20000000
+
+/*
+ *	External Interrupts for Pb1200 as of 8/6/2004.
+ *   Bit positions in the CPLD registers can be calculated by taking
+ *   the interrupt define and subtracting the DB1200_INT_BEGIN value.
+ *    *example: IDE bis pos is  = 64 - 64
+                ETH bit pos is  = 65 - 64
+ */
+#define DB1200_INT_BEGIN		(AU1000_LAST_INTC1_INT + 1)
+#define DB1200_IDE_INT			(DB1200_INT_BEGIN + 0)
+#define DB1200_ETH_INT			(DB1200_INT_BEGIN + 1)
+#define DB1200_PC0_INT			(DB1200_INT_BEGIN + 2)
+#define DB1200_PC0_STSCHG_INT	(DB1200_INT_BEGIN + 3)
+#define DB1200_PC1_INT			(DB1200_INT_BEGIN + 4)
+#define DB1200_PC1_STSCHG_INT	(DB1200_INT_BEGIN + 5)
+#define DB1200_DC_INT			(DB1200_INT_BEGIN + 6)
+#define DB1200_FLASHBUSY_INT	(DB1200_INT_BEGIN + 7)
+#define DB1200_PC0_INSERT_INT	(DB1200_INT_BEGIN + 8)
+#define DB1200_PC0_EJECT_INT	(DB1200_INT_BEGIN + 9)
+#define DB1200_PC1_INSERT_INT	(DB1200_INT_BEGIN + 10)
+#define DB1200_PC1_EJECT_INT	(DB1200_INT_BEGIN + 11)
+#define DB1200_SD0_INSERT_INT	(DB1200_INT_BEGIN + 12)
+#define DB1200_SD0_EJECT_INT	(DB1200_INT_BEGIN + 13)
+
+#define DB1200_INT_END			(DB1200_INT_BEGIN + 15)
+
+/* For drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT DB1200_PC0_INT
+#define BOARD_PC1_INT DB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+
+#endif /* __ASM_DB1200_H */
+
diff -Nur linux-2.4.30/include/asm-mips/db1x00.h linux-2.4.30-mips/include/asm-mips/db1x00.h
--- linux-2.4.30/include/asm-mips/db1x00.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/db1x00.h	2005-01-30 09:06:19.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * AMD Alchemy DB1x00 Reference Boards
+ * AMD Alchemy DB1x00 Reference Boards (BUT NOT DB1200)
  *
  * Copyright 2001 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
@@ -36,9 +36,18 @@
 #define AC97_PSC_BASE       PSC1_BASE_ADDR
 #define SMBUS_PSC_BASE      PSC2_BASE_ADDR
 #define I2S_PSC_BASE        PSC3_BASE_ADDR
+#define NAND_CS 1
+/* for drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT AU1000_GPIO_3
+#define BOARD_PC1_INT AU1000_GPIO_5
+#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
 
 #else
 #define BCSR_KSEG1_ADDR 0xAE000000
+/* for drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT AU1000_GPIO_2
+#define BOARD_PC1_INT AU1000_GPIO_5
+#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
 #endif
 
 /*
@@ -66,6 +75,7 @@
 
 } BCSR;
 
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 
 /*
  * Register/mask bit definitions for the BCSRs
@@ -130,14 +140,6 @@
 
 #define BCSR_SWRESET_RESET		0x0080
 
-/* PCMCIA Db1x00 specific defines */
-#define PCMCIA_MAX_SOCK 1
-#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
-
-/* VPP/VCC */
-#define SET_VCC_VPP(VCC, VPP, SLOT)\
-	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
-
 /* MTD CONFIG OPTIONS */
 #if defined(CONFIG_MTD_DB1X00_BOOT) && defined(CONFIG_MTD_DB1X00_USER)
 #define DB1X00_BOTH_BANKS
@@ -147,48 +149,15 @@
 #define DB1X00_USER_ONLY
 #endif
 
-/* SD controller macros */
-/*
- * Detect card.
- */
-#define mmc_card_inserted(_n_, _res_) \
-	do { \
-		BCSR * const bcsr = (BCSR *)0xAE000000; \
-		unsigned long mmc_wp, board_specific; \
-		if ((_n_)) { \
-			mmc_wp = BCSR_BOARD_SD1_WP; \
-		} else { \
-			mmc_wp = BCSR_BOARD_SD0_WP; \
-		} \
-		board_specific = au_readl((unsigned long)(&bcsr->specific)); \
-		if (!(board_specific & mmc_wp)) {/* low means card present */ \
-			*(int *)(_res_) = 1; \
-		} else { \
-			*(int *)(_res_) = 0; \
-		} \
-	} while (0)
-
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX) && defined(CONFIG_MIPS_DB1550)
 /*
- * Apply power to card slot(s).
+ * Daughter card information.
  */
-#define mmc_power_on(_n_) \
-	do { \
-		BCSR * const bcsr = (BCSR *)0xAE000000; \
-		unsigned long mmc_pwr, mmc_wp, board_specific; \
-		if ((_n_)) { \
-			mmc_pwr = BCSR_BOARD_SD1_PWR; \
-			mmc_wp = BCSR_BOARD_SD1_WP; \
-		} else { \
-			mmc_pwr = BCSR_BOARD_SD0_PWR; \
-			mmc_wp = BCSR_BOARD_SD0_WP; \
-		} \
-		board_specific = au_readl((unsigned long)(&bcsr->specific)); \
-		if (!(board_specific & mmc_wp)) {/* low means card present */ \
-			board_specific |= mmc_pwr; \
-			au_writel(board_specific, (int)(&bcsr->specific)); \
-			au_sync(); \
-		} \
-	} while (0)
+#define DAUGHTER_CARD_IRQ		(AU1000_GPIO_8)
+/* DC_IDE */
+#define AU1XXX_ATA_PHYS_ADDR		(0x0C000000)
+#define AU1XXX_ATA_REG_OFFSET		(5)	
+#endif /* CONFIG_MIPS_DB1550 */
 
 #endif /* __ASM_DB1X00_H */
 
diff -Nur linux-2.4.30/include/asm-mips/ficmmp.h linux-2.4.30-mips/include/asm-mips/ficmmp.h
--- linux-2.4.30/include/asm-mips/ficmmp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/ficmmp.h	2005-01-30 09:01:28.000000000 +0100
@@ -0,0 +1,156 @@
+/*
+ * FIC MMP
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_FICMMP_H
+#define __ASM_FICMMP_H
+
+#include <linux/types.h>
+#include <asm/au1000.h>
+#include <asm/au1xxx_gpio.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+
+/*
+ * SMSC LAN91C111
+ */
+#define AU1XXX_SMC91111_PHYS_ADDR	(0xAC000300)
+#define AU1XXX_SMC91111_IRQ			AU1000_GPIO_5
+
+/* DC_IDE and DC_ETHERNET */
+#define FICMMP_IDE_INT	AU1000_GPIO_4
+
+#define AU1XXX_ATA_PHYS_ADDR	(0x0C800000)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+/*
+#define AU1XXX_ATA_BASE		(0x0C800000)
+#define AU1XXX_ATA_END			(0x0CFFFFFF)
+#define AU1XXX_ATA_MEM_SIZE		(AU1XXX_ATA_END - AU1XXX_ATA_BASE +1)
+
+#define AU1XXX_ATA_REG_OFFSET		(5)
+*/
+/* VPP/VCC */
+#define SET_VCC_VPP(VCC, VPP, SLOT)\
+	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
+
+	
+#define FICMMP_CONFIG_BASE		0xAD000000
+#define FICMMP_CONFIG_ENABLE	13
+
+#define FICMMP_CONFIG_I2SFREQ(N)	(N<<0)
+#define FICMMP_CONFIG_I2SXTAL0		(1<<0)
+#define FICMMP_CONFIG_I2SXTAL1		(1<<1)
+#define FICMMP_CONFIG_I2SXTAL2		(1<<2)
+#define FICMMP_CONFIG_I2SXTAL3		(1<<3)
+#define FICMMP_CONFIG_ADV1			(1<<4)
+#define FICMMP_CONFIG_IDERST		(1<<5)
+#define FICMMP_CONFIG_LCMEN			(1<<6)
+#define FICMMP_CONFIG_CAMPWDN		(1<<7)
+#define FICMMP_CONFIG_USBPWREN		(1<<8)
+#define FICMMP_CONFIG_LCMPWREN		(1<<9)
+#define FICMMP_CONFIG_TVOUTPWREN	(1<<10)
+#define FICMMP_CONFIG_RS232PWREN	(1<<11)
+#define FICMMP_CONFIG_LCMDATAOUT	(1<<12)
+#define FICMMP_CONFIG_TVODATAOUT	(1<<13)
+#define FICMMP_CONFIG_ADV3			(1<<14)
+#define FICMMP_CONFIG_ADV4			(1<<15)
+
+#define I2S_FREQ_8_192				(0x0)
+#define I2S_FREQ_11_2896			(0x1)
+#define I2S_FREQ_12_288				(0x2)
+#define I2S_FREQ_24_576				(0x3)
+//#define I2S_FREQ_12_288			(0x4)
+#define I2S_FREQ_16_9344			(0x5)
+#define I2S_FREQ_18_432				(0x6)
+#define I2S_FREQ_36_864				(0x7)
+#define I2S_FREQ_16_384				(0x8)
+#define I2S_FREQ_22_5792			(0x9)
+//#define I2S_FREQ_24_576			(0x10)
+#define I2S_FREQ_49_152				(0x11)
+//#define I2S_FREQ_24_576			(0x12)
+#define I2S_FREQ_33_8688			(0x13)
+//#define I2S_FREQ_36_864			(0x14)
+#define I2S_FREQ_73_728				(0x15)
+
+#define FICMMP_IDE_PWR				9
+#define FICMMP_FOCUS_RST			2
+
+static __inline void ficmmp_config_set(u16 bits)
+{
+	extern u16 ficmmp_config;
+	//printk("set_config: %X, Old: %X, New: %X\n", bits, ficmmp_config, ficmmp_config | bits);
+	ficmmp_config |= bits;
+	*((u16*)FICMMP_CONFIG_BASE) = ficmmp_config;
+}
+
+static __inline void ficmmp_config_clear(u16 bits)
+{
+	extern u16 ficmmp_config;
+//	printk("clear_config: %X, Old: %X, New: %X\n", bits, ficmmp_config, ficmmp_config & ~bits);
+	ficmmp_config &= ~bits;
+	*((u16*)FICMMP_CONFIG_BASE) = ficmmp_config;
+}
+
+static __inline void ficmmp_config_init(void)
+{
+	au1xxx_gpio_write(FICMMP_CONFIG_ENABLE, 0);	//Enable configuration latch
+	ficmmp_config_set(FICMMP_CONFIG_LCMDATAOUT | FICMMP_CONFIG_TVODATAOUT | FICMMP_CONFIG_IDERST);  //Disable display data buffers
+	ficmmp_config_set(FICMMP_CONFIG_I2SFREQ(I2S_FREQ_36_864));
+}
+
+static __inline u32 ficmmp_set_i2s_sample_rate(u32 rate)
+{
+	u32 freq;
+	
+	switch(rate)
+	{
+	case 88200: 
+	case 44100:
+	case  8018: freq = I2S_FREQ_11_2896; break;
+	case 48000:
+	case 32000: //freq = I2S_FREQ_18_432; break;
+	case  8000: freq = I2S_FREQ_12_288; break;
+	default:    freq = I2S_FREQ_12_288; rate = 8000; 
+	}
+	ficmmp_config_clear(FICMMP_CONFIG_I2SFREQ(0xF));
+	ficmmp_config_set(FICMMP_CONFIG_I2SFREQ(freq));
+	return rate;
+}
+
+#endif /* __ASM_FICMMP_H */
+
diff -Nur linux-2.4.30/include/asm-mips/hazards.h linux-2.4.30-mips/include/asm-mips/hazards.h
--- linux-2.4.30/include/asm-mips/hazards.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/hazards.h	2004-11-25 23:18:38.000000000 +0100
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2003 Ralf Baechle
+ * Copyright (C) 2003, 2004 Ralf Baechle
  */
 #ifndef _ASM_HAZARDS_H
 #define _ASM_HAZARDS_H
@@ -12,38 +12,185 @@
 
 #ifdef __ASSEMBLY__
 
+	.macro	_ssnop
+	sll	$0, $0, 1
+	.endm
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
  * for data translations should not occur for 3 cpu cycles.
  */
 #ifdef CONFIG_CPU_RM9000
-#define rm9000_tlb_hazard						\
+
+#define mtc0_tlbw_hazard						\
+	.set	push;							\
+	.set	mips32;							\
+	_ssnop; _ssnop; _ssnop; _ssnop;					\
+	.set	pop
+
+#define tlbw_eret_hazard						\
 	.set	push;							\
 	.set	mips32;							\
-	ssnop; ssnop; ssnop; ssnop;					\
+	_ssnop; _ssnop; _ssnop; _ssnop;					\
 	.set	pop
+
 #else
-#define rm9000_tlb_hazard
+
+/*
+ * The taken branch will result in a two cycle penalty for the two killed
+ * instructions on R4000 / R4400.  Other processors only have a single cycle
+ * hazard so this is nice trick to have an optimal code for a range of
+ * processors.
+ */
+#define mtc0_tlbw_hazard						\
+	b	. + 8
+#define tlbw_eret_hazard
 #endif
 
+/*
+ * mtc0->mfc0 hazard
+ * The 24K has a 2 cycle mtc0/mfc0 execution hazard.
+ * It is a MIPS32R2 processor so ehb will clear the hazard.
+ */
+
+#ifdef CONFIG_CPU_MIPSR2
+/*
+ * Use a macro for ehb unless explicit support for MIPSR2 is enabled
+ */
+	.macro	ehb
+	sll	$0, $0, 3
+	.endm
+
+#define irq_enable_hazard						\
+	ehb		# irq_enable_hazard
+
+#define irq_disable_hazard						\
+	ehb		# irq_disable_hazard
+
 #else
 
+#define irq_enable_hazard
+#define irq_disable_hazard
+
+#endif
+
+#else /* __ASSEMBLY__ */
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
  * for data translations should not occur for 3 cpu cycles.
  */
 #ifdef CONFIG_CPU_RM9000
-#define rm9000_tlb_hazard()						\
+
+#define mtc0_tlbw_hazard()						\
 	__asm__ __volatile__(						\
 		".set\tmips32\n\t"					\
-		"ssnop; ssnop; ssnop; ssnop\n\t"			\
+		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
+		".set\tmips0")
+
+#define tlbw_use_hazard()						\
+	__asm__ __volatile__(						\
+		".set\tmips32\n\t"					\
+		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
 		".set\tmips0")
 #else
-#define rm9000_tlb_hazard() do { } while (0)
+
+/*
+ * Overkill warning ...
+ */
+#define mtc0_tlbw_hazard()						\
+	__asm__ __volatile__(						\
+		".set noreorder\n\t"					\
+		"nop; nop; nop; nop; nop; nop;\n\t"			\
+		".set reorder\n\t")
+
+#define tlbw_use_hazard()						\
+	__asm__ __volatile__(						\
+		".set noreorder\n\t"					\
+		"nop; nop; nop; nop; nop; nop;\n\t"			\
+		".set reorder\n\t")
+
 #endif
 
+/*
+ * mtc0->mfc0 hazard
+ * The 24K has a 2 cycle mtc0/mfc0 execution hazard.
+ * It is a MIPS32R2 processor so ehb will clear the hazard.
+ */
+
+#ifdef CONFIG_CPU_MIPSR2
+/*
+ * Use a macro for ehb unless explicit support for MIPSR2 is enabled
+ */
+__asm__(
+	"	.macro	ehb					\n\t"
+	"	sll	$0, $0, 3				\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	ehb						\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	ehb						\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()						\
+	__asm__ __volatile__(						\
+	"ehb\t\t\t\t# irq_enable_hazard")
+
+#define irq_disable_hazard()						\
+	__asm__ __volatile__(						\
+	"ehb\t\t\t\t# irq_disable_hazard")
+
+#elif defined(CONFIG_CPU_R10000)
+
+/*
+ * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
+ */
+
+__asm__(
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()	do { } while (0)
+#define irq_disable_hazard()	do { } while (0)
+
+#else
+
+/*
+ * Default for classic MIPS processors.  Assume worst case hazards but don't
+ * care about the irq_enable_hazard - sooner or later the hardware will
+ * enable it and we don't care when exactly.
+ */
+
+__asm__(
+	"	.macro	_ssnop					\n\t"
+	"	sll	$0, $2, 1				\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	#						\n\t"
+	"	# There is a hazard but we do not care		\n\t"
+	"	#						\n\t"
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	_ssnop; _ssnop; _ssnop				\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()	do { } while (0)
+#define irq_disable_hazard()						\
+	__asm__ __volatile__(						\
+	"_ssnop; _ssnop; _ssnop;\t\t# irq_disable_hazard")
+
 #endif
 
+#endif /* __ASSEMBLY__ */
+
 #endif /* _ASM_HAZARDS_H */
diff -Nur linux-2.4.30/include/asm-mips/mipsregs.h linux-2.4.30-mips/include/asm-mips/mipsregs.h
--- linux-2.4.30/include/asm-mips/mipsregs.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/mipsregs.h	2005-02-06 22:24:22.000000000 +0100
@@ -757,10 +757,18 @@
 #define read_c0_config1()	__read_32bit_c0_register($16, 1)
 #define read_c0_config2()	__read_32bit_c0_register($16, 2)
 #define read_c0_config3()	__read_32bit_c0_register($16, 3)
+#define read_c0_config4()	__read_32bit_c0_register($16, 4)
+#define read_c0_config5()	__read_32bit_c0_register($16, 5)
+#define read_c0_config6()	__read_32bit_c0_register($16, 6)
+#define read_c0_config7()	__read_32bit_c0_register($16, 7)
 #define write_c0_config(val)	__write_32bit_c0_register($16, 0, val)
 #define write_c0_config1(val)	__write_32bit_c0_register($16, 1, val)
 #define write_c0_config2(val)	__write_32bit_c0_register($16, 2, val)
 #define write_c0_config3(val)	__write_32bit_c0_register($16, 3, val)
+#define write_c0_config4(val)	__write_32bit_c0_register($16, 4, val)
+#define write_c0_config5(val)	__write_32bit_c0_register($16, 5, val)
+#define write_c0_config6(val)	__write_32bit_c0_register($16, 6, val)
+#define write_c0_config7(val)	__write_32bit_c0_register($16, 7, val)
 
 /*
  * The WatchLo register.  There may be upto 8 of them.
@@ -874,42 +882,34 @@
  */
 static inline void tlb_probe(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbp\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_read(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbr\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_write_indexed(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbwi\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_write_random(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbwr\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 /*
diff -Nur linux-2.4.30/include/asm-mips/mmu_context.h linux-2.4.30-mips/include/asm-mips/mmu_context.h
--- linux-2.4.30/include/asm-mips/mmu_context.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/mmu_context.h	2004-11-22 14:38:29.000000000 +0100
@@ -27,7 +27,7 @@
 #define TLBMISS_HANDLER_SETUP_PGD(pgd) \
 	pgd_current[smp_processor_id()] = (unsigned long)(pgd)
 #define TLBMISS_HANDLER_SETUP() \
-	write_c0_context((unsigned long) smp_processor_id() << (23 + 3)); \
+	write_c0_context((unsigned long) smp_processor_id() << 23); \
 	TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
 extern unsigned long pgd_current[];
 
diff -Nur linux-2.4.30/include/asm-mips/pb1100.h linux-2.4.30-mips/include/asm-mips/pb1100.h
--- linux-2.4.30/include/asm-mips/pb1100.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30-mips/include/asm-mips/pb1100.h	2005-01-30 09:10:29.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Alchemy Semi PB1100 Referrence Board
+ * AMD Alchemy PB1100 Reference Boards
  *
  * Copyright 2001 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
@@ -27,55 +27,108 @@
 #ifndef __ASM_PB1100_H
 #define __ASM_PB1100_H
 
-#define PB1100_IDENT          0xAE000000
-#define BOARD_STATUS_REG      0xAE000004
-  #define PB1100_ROM_SEL         (1<<15)
-  #define PB1100_ROM_SIZ         (1<<14)
-  #define PB1100_SWAP_BOOT       (1<<13)
-  #define PB1100_FLASH_WP        (1<<12)
-  #define PB1100_ROM_H_STS       (1<<11)
-  #define PB1100_ROM_L_STS       (1<<10)
-  #define PB1100_FLASH_H_STS      (1<<9)
-  #define PB1100_FLASH_L_STS      (1<<8)
-  #define PB1100_SRAM_SIZ         (1<<7)
-  #define PB1100_TSC_BUSY         (1<<6)
-  #define PB1100_PCMCIA_VS_MASK   (3<<4)
-  #define PB1100_RS232_CD         (1<<3)
-  #define PB1100_RS232_CTS        (1<<2)
-  #define PB1100_RS232_DSR        (1<<1)
-  #define PB1100_RS232_RI         (1<<0)
-
-#define PB1100_IRDA_RS232     0xAE00000C
-  #define PB1100_IRDA_FULL       (0<<14) /* full power */
-  #define PB1100_IRDA_SHUTDOWN   (1<<14)
-  #define PB1100_IRDA_TT         (2<<14) /* 2/3 power */
-  #define PB1100_IRDA_OT         (3<<14) /* 1/3 power */
-  #define PB1100_IRDA_FIR        (1<<13)
-
-#define PCMCIA_BOARD_REG     0xAE000010
-  #define PB1100_SD_WP1_RO       (1<<15) /* read only */
-  #define PB1100_SD_WP0_RO       (1<<14) /* read only */
-  #define PB1100_SD_PWR1         (1<<11) /* applies power to SD1 */
-  #define PB1100_SD_PWR0         (1<<10) /* applies power to SD0 */
-  #define PB1100_SEL_SD_CONN1     (1<<9)
-  #define PB1100_SEL_SD_CONN0     (1<<8)
-  #define PC_DEASSERT_RST         (1<<7)
-  #define PC_DRV_EN               (1<<4)
-
-#define PB1100_G_CONTROL      0xAE000014 /* graphics control */
-
-#define PB1100_RST_VDDI       0xAE00001C
-  #define PB1100_SOFT_RESET      (1<<15) /* clear to reset the board */
-  #define PB1100_VDDI_MASK        (0x1F)
+#define BCSR_KSEG1_ADDR 0xAE000000
+
+/*
+ * Overlay data structure of the Pb1100 board registers.
+ * Registers located at physical 0E0000xx, KSEG1 0xAE0000xx
+ */
+typedef volatile struct
+{
+	/*00*/	unsigned short whoami;
+			unsigned short reserved0;
+	/*04*/	unsigned short status;
+			unsigned short reserved1;
+	/*08*/	unsigned short switches;
+			unsigned short reserved2;
+	/*0C*/	unsigned short resets;
+			unsigned short reserved3;
+	/*10*/	unsigned short pcmcia;
+			unsigned short reserved4;
+	/*14*/	unsigned short graphics; 
+			unsigned short reserved5;
+	/*18*/	unsigned short leds;
+			unsigned short reserved6;
+	/*1C*/	unsigned short swreset;
+			unsigned short reserved7;
+
+} BCSR;
 
-#define PB1100_LEDS           0xAE000018
 
-/* 11:8 is 4 discreet LEDs. Clearing a bit illuminates the LED.
- * 7:0 is the LED Display's decimal points.
+/*
+ * Register/mask bit definitions for the BCSRs
  */
-#define PB1100_HEX_LED        0xAE000018
+#define BCSR_WHOAMI_DCID		0x000F	
+#define BCSR_WHOAMI_CPLD		0x00F0
+#define BCSR_WHOAMI_BOARD		0x0F00 
+
+#define BCSR_STATUS_RS232_RI	    	0x0001 
+#define BCSR_STATUS_RS232_DSR	 	0x0002 
+#define BCSR_STATUS_RS232_CTS    	0x0004	
+#define BCSR_STATUS_RS232_CD	   	0x0008	 
+#define BCSR_STATUS_PCMCIA_VS_MASK  	0x0030 
+#define BCSR_STATUS_TSC_BUSY        	0x0040 
+#define BCSR_STATUS_SRAM_SIZ		0x0080 
+#define BCSR_STATUS_FLASH_L_STS 	0x0100 
+#define BCSR_STATUS_FLASH_H_STS 	0x0200	
+#define BCSR_STATUS_ROM_H_STS   	0x0400 
+#define BCSR_STATUS_ROM_L_STS   	0x0800	
+#define BCSR_STATUS_FLASH_WP	    	0x1000 
+#define BCSR_STATUS_SWAP_BOOT		0x2000
+#define BCSR_STATUS_ROM_SIZ    		0x4000 
+#define BCSR_STATUS_ROM_SEL      	0x8000	
+
+#define BCSR_SWITCHES_DIP		0x00FF
+#define BCSR_SWITCHES_DIP_1		0x0080
+#define BCSR_SWITCHES_DIP_2		0x0040
+#define BCSR_SWITCHES_DIP_3		0x0020
+#define BCSR_SWITCHES_DIP_4		0x0010
+#define BCSR_SWITCHES_DIP_5		0x0008
+#define BCSR_SWITCHES_DIP_6		0x0004
+#define BCSR_SWITCHES_DIP_7		0x0002
+#define BCSR_SWITCHES_DIP_8		0x0001
+#define BCSR_SWITCHES_ROTARY    	0x0F00
+#define BCSR_SWITCHES_SDO_CL     	0x8000
+
+#define BCSR_RESETS_PHY0		0x0001
+#define BCSR_RESETS_PHY1		0x0002
+#define BCSR_RESETS_DC			0x0004
+#define BCSR_RESETS_RS232_RTS		0x0100
+#define BCSR_RESETS_RS232_DTR   	0x0200
+#define BCSR_RESETS_FIR_SEL		0x2000
+#define BCSR_RESETS_IRDA_MODE_MASK	0xC000
+#define BCSR_RESETS_IRDA_MODE_FULL	0x0000
+#define BCSR_RESETS_IRDA_MODE_OFF	0x4000
+#define BCSR_RESETS_IRDA_MODE_2_3	0x8000
+#define BCSR_RESETS_IRDA_MODE_1_3	0xC000
+
+#define BCSR_PCMCIA_PC0VPP		0x0003
+#define BCSR_PCMCIA_PC0VCC		0x000C
+#define BCSR_PCMCIA_PC0_DR_VEN		0x0010
+#define BCSR_PCMCIA_PC0RST		0x0080
+#define BCSR_PCMCIA_SEL_SD_CON0   	0x0100
+#define BCSR_PCMCIA_SEL_SD_CON1   	0x0200
+#define BCSR_PCMCIA_SD0_PWR		0x0400
+#define BCSR_PCMCIA_SD1_PWR		0x0800
+#define BCSR_PCMCIA_SD0_WP		0x4000
+#define BCSR_PCMCIA_SD1_WP		0x8000
+
+#define PB1100_G_CONTROL		0xAE000014
+#define BCSR_GRAPHICS_GPX_SMPASS    	0x0010
+#define BCSR_GRAPHICS_GPX_BIG_ENDIAN	0x0020
+#define BCSR_GRAPHICS_GPX_RST		0x0040
+
+#define BCSR_LEDS_DECIMALS		0x00FF
+#define BCSR_LEDS_LED0			0x0100
+#define BCSR_LEDS_LED1			0x0200
+#define BCSR_LEDS_LED2			0x0400
+#define BCSR_LEDS_LED3			0x0800
+
+#define BCSR_SWRESET_RESET		0x0080
+#define BCSR_VDDI_VDI			0x001F
 
-/* PCMCIA PB1100 specific defines */
+
+ /* PCMCIA Pb1x00 specific defines */
 #define PCMCIA_MAX_SOCK 0
 #define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
 
@@ -83,3 +136,4 @@
 #define SET_VCC_VPP(VCC, VPP) (((VCC)<<2) | ((VPP)<<0))
 
 #endif /* __ASM_PB1100_H */
+
diff -Nur linux-2.4.30/include/asm-mips/pb1200.h linux-2.4.30-mips/include/asm-mips/pb1200.h
--- linux-2.4.30/include/asm-mips/pb1200.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/pb1200.h	2005-01-30 09:01:28.000000000 +0100
@@ -0,0 +1,244 @@
+/*
+ * AMD Alchemy PB1200 Referrence Board
+ * Board Registers defines.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_PB1200_H
+#define __ASM_PB1200_H
+
+#include <linux/types.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+#define BCSR_KSEG1_ADDR 0xAD800000
+
+typedef volatile struct
+{
+	/*00*/	u16 whoami;
+		u16 reserved0;
+	/*04*/	u16 status;
+		u16 reserved1;
+	/*08*/	u16 switches;
+		u16 reserved2;
+	/*0C*/	u16 resets;
+		u16 reserved3;
+
+	/*10*/	u16 pcmcia;
+		u16 reserved4;
+	/*14*/	u16 board;
+		u16 reserved5;
+	/*18*/	u16 disk_leds;
+		u16 reserved6;
+	/*1C*/	u16 system;
+		u16 reserved7;
+
+	/*20*/	u16 intclr;
+		u16 reserved8;
+	/*24*/	u16 intset;
+		u16 reserved9;
+	/*28*/	u16 intclr_mask;
+		u16 reserved10;
+	/*2C*/	u16 intset_mask;
+		u16 reserved11;
+
+	/*30*/	u16 sig_status;
+		u16 reserved12;
+	/*34*/	u16 int_status;
+		u16 reserved13;
+	/*38*/	u16 reserved14;
+		u16 reserved15;
+	/*3C*/	u16 reserved16;
+		u16 reserved17;
+
+} BCSR;
+
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+/*
+ * Register bit definitions for the BCSRs
+ */
+#define BCSR_WHOAMI_DCID	0x000F
+#define BCSR_WHOAMI_CPLD	0x00F0
+#define BCSR_WHOAMI_BOARD	0x0F00
+
+#define BCSR_STATUS_PCMCIA0VS	0x0003
+#define BCSR_STATUS_PCMCIA1VS	0x000C
+#define BCSR_STATUS_SWAPBOOT	0x0040
+#define BCSR_STATUS_FLASHBUSY	0x0100
+#define BCSR_STATUS_IDECBLID	0x0200
+#define BCSR_STATUS_SD0WP		0x0400
+#define BCSR_STATUS_SD1WP		0x0800
+#define BCSR_STATUS_U0RXD		0x1000
+#define BCSR_STATUS_U1RXD		0x2000
+
+#define BCSR_SWITCHES_OCTAL	0x00FF
+#define BCSR_SWITCHES_DIP_1	0x0080
+#define BCSR_SWITCHES_DIP_2	0x0040
+#define BCSR_SWITCHES_DIP_3	0x0020
+#define BCSR_SWITCHES_DIP_4	0x0010
+#define BCSR_SWITCHES_DIP_5	0x0008
+#define BCSR_SWITCHES_DIP_6	0x0004
+#define BCSR_SWITCHES_DIP_7	0x0002
+#define BCSR_SWITCHES_DIP_8	0x0001
+#define BCSR_SWITCHES_ROTARY	0x0F00
+
+#define BCSR_RESETS_ETH		0x0001
+#define BCSR_RESETS_CAMERA	0x0002
+#define BCSR_RESETS_DC		0x0004
+#define BCSR_RESETS_IDE		0x0008
+/* not resets but in the same register */
+#define BCSR_RESETS_WSCFSM  0x0800
+#define BCSR_RESETS_PCS0MUX	0x1000
+#define BCSR_RESETS_PCS1MUX	0x2000
+#define BCSR_RESETS_SPISEL	0x4000
+#define BCSR_RESETS_SD1MUX  0x8000
+
+#define BCSR_PCMCIA_PC0VPP	0x0003
+#define BCSR_PCMCIA_PC0VCC	0x000C
+#define BCSR_PCMCIA_PC0DRVEN	0x0010
+#define BCSR_PCMCIA_PC0RST	0x0080
+#define BCSR_PCMCIA_PC1VPP	0x0300
+#define BCSR_PCMCIA_PC1VCC	0x0C00
+#define BCSR_PCMCIA_PC1DRVEN	0x1000
+#define BCSR_PCMCIA_PC1RST	0x8000
+
+#define BCSR_BOARD_LCDVEE	0x0001
+#define BCSR_BOARD_LCDVDD	0x0002
+#define BCSR_BOARD_LCDBL	0x0004
+#define BCSR_BOARD_CAMSNAP	0x0010
+#define BCSR_BOARD_CAMPWR	0x0020
+#define BCSR_BOARD_SD0PWR	0x0040
+#define BCSR_BOARD_SD1PWR	0x0080
+
+#define BCSR_LEDS_DECIMALS	0x00FF
+#define BCSR_LEDS_LED0		0x0100
+#define BCSR_LEDS_LED1		0x0200
+#define BCSR_LEDS_LED2		0x0400
+#define BCSR_LEDS_LED3		0x0800
+
+#define BCSR_SYSTEM_VDDI	0x001F
+#define BCSR_SYSTEM_POWEROFF	0x4000
+#define BCSR_SYSTEM_RESET	0x8000
+
+/* Bit positions for the different interrupt sources */
+#define BCSR_INT_IDE		0x0001
+#define BCSR_INT_ETH		0x0002
+#define BCSR_INT_PC0		0x0004
+#define BCSR_INT_PC0STSCHG	0x0008
+#define BCSR_INT_PC1		0x0010
+#define BCSR_INT_PC1STSCHG	0x0020
+#define BCSR_INT_DC			0x0040
+#define BCSR_INT_FLASHBUSY	0x0080
+#define BCSR_INT_PC0INSERT	0x0100
+#define BCSR_INT_PC0EJECT	0x0200
+#define BCSR_INT_PC1INSERT	0x0400
+#define BCSR_INT_PC1EJECT	0x0800
+#define BCSR_INT_SD0INSERT	0x1000
+#define BCSR_INT_SD0EJECT	0x2000
+#define BCSR_INT_SD1INSERT	0x4000
+#define BCSR_INT_SD1EJECT	0x8000
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x0D000300)
+#define AU1XXX_SMC91111_IRQ			PB1200_ETH_INT
+
+#define AU1XXX_ATA_PHYS_ADDR		(0x0C800000)
+#define AU1XXX_ATA_PHYS_LEN			(0x100)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+#define AU1XXX_ATA_INT			PB1200_IDE_INT
+#define AU1XXX_ATA_DDMA_REQ		DSCR_CMD0_DMA_REQ1;
+#define AU1XXX_ATA_RQSIZE		128
+
+#define NAND_PHYS_ADDR   0x1C000000
+
+/* Timing values as described in databook, * ns value stripped of
+ * lower 2 bits.
+ * These defines are here rather than an SOC1200 generic file because
+ * the parts chosen on another board may be different and may require
+ * different timings.
+ */
+#define NAND_T_H			(18 >> 2)
+#define NAND_T_PUL			(30 >> 2)
+#define NAND_T_SU			(30 >> 2)
+#define NAND_T_WH			(30 >> 2)
+
+/* Bitfield shift amounts */
+#define NAND_T_H_SHIFT		0
+#define NAND_T_PUL_SHIFT	4
+#define NAND_T_SU_SHIFT		8
+#define NAND_T_WH_SHIFT		12
+
+#define NAND_TIMING	((NAND_T_H   & 0xF)	<< NAND_T_H_SHIFT)   | \
+			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
+			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
+			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
+
+
+/*
+ *	External Interrupts for Pb1200 as of 8/6/2004.
+ *   Bit positions in the CPLD registers can be calculated by taking
+ *   the interrupt define and subtracting the PB1200_INT_BEGIN value.
+ *    *example: IDE bis pos is  = 64 - 64
+                ETH bit pos is  = 65 - 64
+ */
+#define PB1200_INT_BEGIN		(AU1000_LAST_INTC1_INT + 1)
+#define PB1200_IDE_INT			(PB1200_INT_BEGIN + 0)
+#define PB1200_ETH_INT			(PB1200_INT_BEGIN + 1)
+#define PB1200_PC0_INT			(PB1200_INT_BEGIN + 2)
+#define PB1200_PC0_STSCHG_INT	(PB1200_INT_BEGIN + 3)
+#define PB1200_PC1_INT			(PB1200_INT_BEGIN + 4)
+#define PB1200_PC1_STSCHG_INT	(PB1200_INT_BEGIN + 5)
+#define PB1200_DC_INT			(PB1200_INT_BEGIN + 6)
+#define PB1200_FLASHBUSY_INT	(PB1200_INT_BEGIN + 7)
+#define PB1200_PC0_INSERT_INT	(PB1200_INT_BEGIN + 8)
+#define PB1200_PC0_EJECT_INT	(PB1200_INT_BEGIN + 9)
+#define PB1200_PC1_INSERT_INT	(PB1200_INT_BEGIN + 10)
+#define PB1200_PC1_EJECT_INT	(PB1200_INT_BEGIN + 11)
+#define PB1200_SD0_INSERT_INT	(PB1200_INT_BEGIN + 12)
+#define PB1200_SD0_EJECT_INT	(PB1200_INT_BEGIN + 13)
+#define PB1200_SD1_INSERT_INT	(PB1200_INT_BEGIN + 14)
+#define PB1200_SD1_EJECT_INT	(PB1200_INT_BEGIN + 15)
+
+#define PB1200_INT_END			(PB1200_INT_BEGIN + 15)
+
+/* For drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT PB1200_PC0_INT
+#define BOARD_PC1_INT PB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+
+#endif /* __ASM_PB1200_H */
+
diff -Nur linux-2.4.30/include/asm-mips/pb1550.h linux-2.4.30-mips/include/asm-mips/pb1550.h
--- linux-2.4.30/include/asm-mips/pb1550.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/pb1550.h	2005-01-30 09:01:28.000000000 +0100
@@ -30,13 +30,11 @@
 
 #define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
 #define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
-#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC3_TX
-#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC3_RX
-
 #define SPI_PSC_BASE        PSC0_BASE_ADDR
 #define AC97_PSC_BASE       PSC1_BASE_ADDR
 #define SMBUS_PSC_BASE      PSC2_BASE_ADDR
 #define I2S_PSC_BASE        PSC3_BASE_ADDR
+#define NAND_CS 1
 
 #define BCSR_PHYS_ADDR 0xAF000000
 
@@ -160,9 +158,23 @@
 #define NAND_T_SU_SHIFT		8
 #define NAND_T_WH_SHIFT		12
 
-#define NAND_TIMING	((NAND_T_H   & 0xF)	<< NAND_T_H_SHIFT)   | \
-			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
-			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
-			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
+#define NAND_TIMING	((NAND_T_H   & 0xF) << NAND_T_H_SHIFT)   | \
+			((NAND_T_PUL & 0xF) << NAND_T_PUL_SHIFT) | \
+			((NAND_T_SU  & 0xF) << NAND_T_SU_SHIFT)  | \
+			((NAND_T_WH  & 0xF) << NAND_T_WH_SHIFT)
+
+/*
+ * Daughter card information.
+ */
+#define DAUGHTER_CARD_BASE		(0xAC000000)
+#define DAUGHTER_CARD_MEM_SIZE		(0xADFFFFFF - DAUGHTER_CARD_BASE + 1)
+#define DAUGHTER_CARD_IRQ		(AU1000_GPIO_3)
+
+/* DC_IDE and DC_ETHERNET */
+#define AU1XXX_ATA_PHYS_ADDR		(0x0C000000)
+#define AU1XXX_ATA_REG_OFFSET		(5)	
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x0C000300)
+#define AU1XXX_SMC91111_IRQ		AU1000_GPIO_3
 
 #endif /* __ASM_PB1550_H */
diff -Nur linux-2.4.30/include/asm-mips/tx4927/tx4927.h linux-2.4.30-mips/include/asm-mips/tx4927/tx4927.h
--- linux-2.4.30/include/asm-mips/tx4927/tx4927.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.30-mips/include/asm-mips/tx4927/tx4927.h	2004-11-22 19:02:10.000000000 +0100
@@ -88,8 +88,8 @@
 
 
 /* TX4927 Configuration registers (64-bit registers) */
-#define TX4927_CONFIG_BASE                       0xe300
-#define TX4927_CONFIG_CCFG                       0xe300
+#define TX4927_CONFIG_BASE                       0xe000
+#define TX4927_CONFIG_CCFG                       0xe000
 #define TX4927_CONFIG_CCFG_RESERVED_42_63                BM_63_42
 #define TX4927_CONFIG_CCFG_WDRST                         BM_41_41
 #define TX4927_CONFIG_CCFG_WDREXEN                       BM_40_40
@@ -124,14 +124,14 @@
 #define TX4927_CONFIG_CCFG_ENDIAN                        BM_02_02
 #define TX4927_CONFIG_CCFG_ARMODE                        BM_01_01
 #define TX4927_CONFIG_CCFG_ACEHOLD                       BM_00_00
-#define TX4927_CONFIG_REVID                      0xe308 
+#define TX4927_CONFIG_REVID                      0xe008 
 #define TX4927_CONFIG_REVID_RESERVED_32_63               BM_32_63
 #define TX4927_CONFIG_REVID_PCODE                        BM_16_31
 #define TX4927_CONFIG_REVID_MJERREV                      BM_12_15
 #define TX4927_CONFIG_REVID_MINEREV                      BM_08_11
 #define TX4927_CONFIG_REVID_MJREV                        BM_04_07
 #define TX4927_CONFIG_REVID_MINREV                       BM_00_03
-#define TX4927_CONFIG_PCFG                       0xe310 
+#define TX4927_CONFIG_PCFG                       0xe010 
 #define TX4927_CONFIG_PCFG_RESERVED_57_63                BM_57_63
 #define TX4927_CONFIG_PCFG_DRVDATA                       BM_56_56
 #define TX4927_CONFIG_PCFG_DRVCB                         BM_55_55
@@ -197,10 +197,10 @@
 #define TX4927_CONFIG_PCFG_DMASEL0_SIO1                  BM_00_00
 #define TX4927_CONFIG_PCFG_DMASEL0_ACLC0                 BM_01_01
 #define TX4927_CONFIG_PCFG_DMASEL0_ACLC2                 BM_00_01
-#define TX4927_CONFIG_TOEA                       0xe318 
+#define TX4927_CONFIG_TOEA                       0xe018 
 #define TX4927_CONFIG_TOEA_RESERVED_36_63                BM_36_63
 #define TX4927_CONFIG_TOEA_TOEA                          BM_00_35
-#define TX4927_CONFIG_CLKCTR                     0xe320 
+#define TX4927_CONFIG_CLKCTR                     0xe020 
 #define TX4927_CONFIG_CLKCTR_RESERVED_26_63              BM_26_63
 #define TX4927_CONFIG_CLKCTR_ACLCKD                      BM_25_25
 #define TX4927_CONFIG_CLKCTR_PIOCKD                      BM_24_24
@@ -223,7 +223,7 @@
 #define TX4927_CONFIG_CLKCTR_TM2RST                      BM_02_02
 #define TX4927_CONFIG_CLKCTR_SIO0RST                     BM_01_01
 #define TX4927_CONFIG_CLKCTR_SIO1RST                     BM_00_00
-#define TX4927_CONFIG_GARBC                      0xe330 
+#define TX4927_CONFIG_GARBC                      0xe030 
 #define TX4927_CONFIG_GARBC_RESERVED_10_63               BM_10_63
 #define TX4927_CONFIG_GARBC_SET_09                       BM_09_09
 #define TX4927_CONFIG_GARBC_ARBMD                        BM_08_08
@@ -243,7 +243,7 @@
 #define TX4927_CONFIG_GARBC_PRIORITY_H3_PDMAC            BM_00_00
 #define TX4927_CONFIG_GARBC_PRIORITY_H3_DMAC             BM_01_01
 #define TX4927_CONFIG_GARBC_PRIORITY_H3_BAD_VALUE        BM_00_01
-#define TX4927_CONFIG_RAMP                       0xe348 
+#define TX4927_CONFIG_RAMP                       0xe048 
 #define TX4927_CONFIG_RAMP_RESERVED_20_63                BM_20_63
 #define TX4927_CONFIG_RAMP_RAMP                          BM_00_19
 #define TX4927_CONFIG_LIMIT                      0xefff
@@ -456,7 +456,7 @@
 #define TX4927_ACLC_ACINTSTS            0xf710
 #define TX4927_ACLC_ACINTMSTS           0xf714
 #define TX4927_ACLC_ACINTEN             0xf718
-#define TX4927_ACLC_ACINTDIS            0xfR71c
+#define TX4927_ACLC_ACINTDIS            0xf71c
 #define TX4927_ACLC_ACSEMAPH            0xf720
 #define TX4927_ACLC_ACGPIDAT            0xf740
 #define TX4927_ACLC_ACGPODAT            0xf744
diff -Nur linux-2.4.30/include/asm-mips/unistd.h linux-2.4.30-mips/include/asm-mips/unistd.h
--- linux-2.4.30/include/asm-mips/unistd.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips/unistd.h	2004-11-24 21:30:06.000000000 +0100
@@ -760,7 +760,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 /*
@@ -788,7 +788,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall2(type,name,atype,a,btype,b) \
@@ -813,7 +813,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall3(type,name,atype,a,btype,b,ctype,c) \
@@ -839,7 +839,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall4(type,name,atype,a,btype,b,ctype,c,dtype,d) \
@@ -865,7 +865,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #if (_MIPS_SIM == _MIPS_SIM_ABI32)
@@ -902,7 +902,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall6(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e,ftype,f) \
@@ -935,7 +935,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #endif /* (_MIPS_SIM == _MIPS_SIM_ABI32) */
@@ -966,7 +966,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall6(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e,ftype,f) \
@@ -995,7 +995,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #endif /* (_MIPS_SIM == _MIPS_SIM_NABI32) || (_MIPS_SIM == _MIPS_SIM_ABI64) */
diff -Nur linux-2.4.30/include/asm-mips64/hazards.h linux-2.4.30-mips/include/asm-mips64/hazards.h
--- linux-2.4.30/include/asm-mips64/hazards.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips64/hazards.h	2004-11-25 23:18:38.000000000 +0100
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2003 Ralf Baechle
+ * Copyright (C) 2003, 2004 Ralf Baechle
  */
 #ifndef _ASM_HAZARDS_H
 #define _ASM_HAZARDS_H
@@ -12,37 +12,185 @@
 
 #ifdef __ASSEMBLY__
 
+	.macro	_ssnop
+	sll	$0, $0, 1
+	.endm
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
  * for data translations should not occur for 3 cpu cycles.
  */
 #ifdef CONFIG_CPU_RM9000
-#define rm9000_tlb_hazard						\
+
+#define mtc0_tlbw_hazard						\
+	.set	push;							\
+	.set	mips32;							\
+	_ssnop; _ssnop; _ssnop; _ssnop;					\
+	.set	pop
+
+#define tlbw_eret_hazard						\
+	.set	push;							\
 	.set	mips32;							\
-	ssnop; ssnop; ssnop; ssnop;					\
-	.set	mips0
+	_ssnop; _ssnop; _ssnop; _ssnop;					\
+	.set	pop
+
 #else
-#define rm9000_tlb_hazard
+
+/*
+ * The taken branch will result in a two cycle penalty for the two killed
+ * instructions on R4000 / R4400.  Other processors only have a single cycle
+ * hazard so this is nice trick to have an optimal code for a range of
+ * processors.
+ */
+#define mtc0_tlbw_hazard						\
+	b	. + 8
+#define tlbw_eret_hazard
 #endif
 
+/*
+ * mtc0->mfc0 hazard
+ * The 24K has a 2 cycle mtc0/mfc0 execution hazard.
+ * It is a MIPS32R2 processor so ehb will clear the hazard.
+ */
+
+#ifdef CONFIG_CPU_MIPSR2
+/*
+ * Use a macro for ehb unless explicit support for MIPSR2 is enabled
+ */
+	.macro	ehb
+	sll	$0, $0, 3
+	.endm
+
+#define irq_enable_hazard						\
+	ehb		# irq_enable_hazard
+
+#define irq_disable_hazard						\
+	ehb		# irq_disable_hazard
+
 #else
 
+#define irq_enable_hazard
+#define irq_disable_hazard
+
+#endif
+
+#else /* __ASSEMBLY__ */
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
  * for data translations should not occur for 3 cpu cycles.
  */
 #ifdef CONFIG_CPU_RM9000
-#define rm9000_tlb_hazard()						\
+
+#define mtc0_tlbw_hazard()						\
+	__asm__ __volatile__(						\
+		".set\tmips32\n\t"					\
+		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
+		".set\tmips0")
+
+#define tlbw_use_hazard()						\
 	__asm__ __volatile__(						\
 		".set\tmips32\n\t"					\
-		"ssnop; ssnop; ssnop; ssnop\n\t"			\
+		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
 		".set\tmips0")
 #else
-#define rm9000_tlb_hazard() do { } while (0)
+
+/*
+ * Overkill warning ...
+ */
+#define mtc0_tlbw_hazard()						\
+	__asm__ __volatile__(						\
+		".set noreorder\n\t"					\
+		"nop; nop; nop; nop; nop; nop;\n\t"			\
+		".set reorder\n\t")
+
+#define tlbw_use_hazard()						\
+	__asm__ __volatile__(						\
+		".set noreorder\n\t"					\
+		"nop; nop; nop; nop; nop; nop;\n\t"			\
+		".set reorder\n\t")
+
 #endif
 
+/*
+ * mtc0->mfc0 hazard
+ * The 24K has a 2 cycle mtc0/mfc0 execution hazard.
+ * It is a MIPS32R2 processor so ehb will clear the hazard.
+ */
+
+#ifdef CONFIG_CPU_MIPSR2
+/*
+ * Use a macro for ehb unless explicit support for MIPSR2 is enabled
+ */
+__asm__(
+	"	.macro	ehb					\n\t"
+	"	sll	$0, $0, 3				\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	ehb						\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	ehb						\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()						\
+	__asm__ __volatile__(						\
+	"ehb\t\t\t\t# irq_enable_hazard")
+
+#define irq_disable_hazard()						\
+	__asm__ __volatile__(						\
+	"ehb\t\t\t\t# irq_disable_hazard")
+
+#elif defined(CONFIG_CPU_R10000)
+
+/*
+ * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
+ */
+
+__asm__(
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()	do { } while (0)
+#define irq_disable_hazard()	do { } while (0)
+
+#else
+
+/*
+ * Default for classic MIPS processors.  Assume worst case hazards but don't
+ * care about the irq_enable_hazard - sooner or later the hardware will
+ * enable it and we don't care when exactly.
+ */
+
+__asm__(
+	"	.macro	_ssnop					\n\t"
+	"	sll	$0, $2, 1				\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	#						\n\t"
+	"	# There is a hazard but we do not care		\n\t"
+	"	#						\n\t"
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	_ssnop; _ssnop; _ssnop				\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()	do { } while (0)
+#define irq_disable_hazard()						\
+	__asm__ __volatile__(						\
+	"_ssnop; _ssnop; _ssnop;\t\t# irq_disable_hazard")
+
 #endif
 
+#endif /* __ASSEMBLY__ */
+
 #endif /* _ASM_HAZARDS_H */
diff -Nur linux-2.4.30/include/asm-mips64/mipsregs.h linux-2.4.30-mips/include/asm-mips64/mipsregs.h
--- linux-2.4.30/include/asm-mips64/mipsregs.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips64/mipsregs.h	2005-02-06 22:24:22.000000000 +0100
@@ -757,10 +757,18 @@
 #define read_c0_config1()	__read_32bit_c0_register($16, 1)
 #define read_c0_config2()	__read_32bit_c0_register($16, 2)
 #define read_c0_config3()	__read_32bit_c0_register($16, 3)
+#define read_c0_config4()	__read_32bit_c0_register($16, 4)
+#define read_c0_config5()	__read_32bit_c0_register($16, 5)
+#define read_c0_config6()	__read_32bit_c0_register($16, 6)
+#define read_c0_config7()	__read_32bit_c0_register($16, 7)
 #define write_c0_config(val)	__write_32bit_c0_register($16, 0, val)
 #define write_c0_config1(val)	__write_32bit_c0_register($16, 1, val)
 #define write_c0_config2(val)	__write_32bit_c0_register($16, 2, val)
 #define write_c0_config3(val)	__write_32bit_c0_register($16, 3, val)
+#define write_c0_config4(val)	__write_32bit_c0_register($16, 4, val)
+#define write_c0_config5(val)	__write_32bit_c0_register($16, 5, val)
+#define write_c0_config6(val)	__write_32bit_c0_register($16, 6, val)
+#define write_c0_config7(val)	__write_32bit_c0_register($16, 7, val)
 
 /*
  * The WatchLo register.  There may be upto 8 of them.
@@ -856,42 +864,34 @@
  */
 static inline void tlb_probe(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbp\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_read(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbr\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_write_indexed(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbwi\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 static inline void tlb_write_random(void)
 {
-	rm9000_tlb_hazard();
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbwr\n\t"
 		".set reorder");
-	rm9000_tlb_hazard();
 }
 
 /*
diff -Nur linux-2.4.30/include/asm-mips64/unistd.h linux-2.4.30-mips/include/asm-mips64/unistd.h
--- linux-2.4.30/include/asm-mips64/unistd.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30-mips/include/asm-mips64/unistd.h	2004-11-24 21:30:06.000000000 +0100
@@ -760,7 +760,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 /*
@@ -788,7 +788,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall2(type,name,atype,a,btype,b) \
@@ -813,7 +813,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall3(type,name,atype,a,btype,b,ctype,c) \
@@ -839,7 +839,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall4(type,name,atype,a,btype,b,ctype,c,dtype,d) \
@@ -865,7 +865,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #if (_MIPS_SIM == _MIPS_SIM_ABI32)
@@ -902,7 +902,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall6(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e,ftype,f) \
@@ -935,7 +935,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #endif /* (_MIPS_SIM == _MIPS_SIM_ABI32) */
@@ -966,7 +966,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #define _syscall6(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e,ftype,f) \
@@ -995,7 +995,7 @@
 	if (__a3 == 0) \
 		return (type) __v0; \
 	errno = __v0; \
-	return -1; \
+	return (type)-1; \
 }
 
 #endif /* (_MIPS_SIM == _MIPS_SIM_NABI32) || (_MIPS_SIM == _MIPS_SIM_ABI64) */
diff -Nur linux-2.4.30/include/asm-ppc/param.h linux-2.4.30-mips/include/asm-ppc/param.h
--- linux-2.4.30/include/asm-ppc/param.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.30-mips/include/asm-ppc/param.h	2003-07-05 05:23:46.000000000 +0200
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -Nur linux-2.4.30/include/asm-s390/param.h linux-2.4.30-mips/include/asm-s390/param.h
--- linux-2.4.30/include/asm-s390/param.h	2001-02-13 23:13:44.000000000 +0100
+++ linux-2.4.30-mips/include/asm-s390/param.h	2001-03-09 21:34:48.000000000 +0100
@@ -11,6 +11,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -Nur linux-2.4.30/include/asm-sh/param.h linux-2.4.30-mips/include/asm-sh/param.h
--- linux-2.4.30/include/asm-sh/param.h	2001-01-04 22:19:13.000000000 +0100
+++ linux-2.4.30-mips/include/asm-sh/param.h	2001-01-11 05:02:45.000000000 +0100
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -Nur linux-2.4.30/include/asm-sparc/param.h linux-2.4.30-mips/include/asm-sparc/param.h
--- linux-2.4.30/include/asm-sparc/param.h	2000-10-30 23:34:12.000000000 +0100
+++ linux-2.4.30-mips/include/asm-sparc/param.h	2000-11-23 03:00:56.000000000 +0100
@@ -4,6 +4,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192    /* Thanks for sun4's we carry baggage... */
diff -Nur linux-2.4.30/include/asm-sparc64/param.h linux-2.4.30-mips/include/asm-sparc64/param.h
--- linux-2.4.30/include/asm-sparc64/param.h	2000-10-30 23:34:12.000000000 +0100
+++ linux-2.4.30-mips/include/asm-sparc64/param.h	2000-11-23 03:00:56.000000000 +0100
@@ -4,6 +4,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192    /* Thanks for sun4's we carry baggage... */
diff -Nur linux-2.4.30/include/linux/i2c-algo-au1550.h linux-2.4.30-mips/include/linux/i2c-algo-au1550.h
--- linux-2.4.30/include/linux/i2c-algo-au1550.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.30-mips/include/linux/i2c-algo-au1550.h	2004-07-07 02:38:02.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2004 Embedded Edge, LLC <dan@embeddededge.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef I2C_ALGO_AU1550_H
+#define I2C_ALGO_AU1550_H 1
+
+struct i2c_algo_au1550_data {
+	u32	psc_base;
+	int	xfer_timeout;
+	int	ack_timeout;
+};
+
+int i2c_au1550_add_bus(struct i2c_adapter *);
+int i2c_au1550_del_bus(struct i2c_adapter *);
+
+#endif /* I2C_ALGO_AU1550_H */
diff -Nur linux-2.4.30/include/linux/i2c-id.h linux-2.4.30-mips/include/linux/i2c-id.h
--- linux-2.4.30/include/linux/i2c-id.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30-mips/include/linux/i2c-id.h	2004-07-07 02:38:02.000000000 +0200
@@ -156,6 +156,8 @@
 
 #define I2C_ALGO_SGI	0x130000	/* SGI algorithm		*/
 
+#define I2C_ALGO_AU1550	0x140000	/* Alchemy Au1550 PSC		*/
+
 #define I2C_ALGO_EXP	0x800000	/* experimental			*/
 
 #define I2C_ALGO_MASK	0xff0000	/* Mask for algorithms		*/
@@ -204,6 +206,9 @@
 #define I2C_HW_SGI_VINO	0x00
 #define I2C_HW_SGI_MACE	0x01
 
+/* --- Au1550 PSC adapters						*/
+#define I2C_HW_AU1550_PSC	0x00
+
 /* --- SMBus only adapters						*/
 #define I2C_HW_SMBUS_PIIX4	0x00
 #define I2C_HW_SMBUS_ALI15X3	0x01
diff -Nur linux-2.4.30/include/linux/sched.h linux-2.4.30-mips/include/linux/sched.h
--- linux-2.4.30/include/linux/sched.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30-mips/include/linux/sched.h	2004-11-29 18:47:18.000000000 +0100
@@ -617,6 +617,10 @@
 extern int in_group_p(gid_t);
 extern int in_egroup_p(gid_t);
 
+extern ATTRIB_NORET void cpu_idle(void);
+
+extern void release_task(struct task_struct * p);
+
 extern void proc_caches_init(void);
 extern void flush_signals(struct task_struct *);
 extern void flush_signal_handlers(struct task_struct *);
diff -Nur linux-2.4.30/include/linux/serial.h linux-2.4.30-mips/include/linux/serial.h
--- linux-2.4.30/include/linux/serial.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.30-mips/include/linux/serial.h	2004-07-31 02:17:57.000000000 +0200
@@ -75,7 +75,8 @@
 #define PORT_16654	11
 #define PORT_16850	12
 #define PORT_RSA	13	/* RSA-DV II/S card */
-#define PORT_MAX	13
+#define PORT_SB1250	14
+#define PORT_MAX	14
 
 #define SERIAL_IO_PORT	0
 #define SERIAL_IO_HUB6	1
diff -Nur linux-2.4.30/include/linux/swap.h linux-2.4.30-mips/include/linux/swap.h
--- linux-2.4.30/include/linux/swap.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.30-mips/include/linux/swap.h	2004-11-29 18:47:18.000000000 +0100
@@ -1,6 +1,12 @@
 #ifndef _LINUX_SWAP_H
 #define _LINUX_SWAP_H
 
+#include <linux/config.h>
+
+#define MAX_SWAPFILES 32
+
+#ifdef __KERNEL__
+
 #include <linux/spinlock.h>
 #include <asm/page.h>
 
@@ -8,8 +14,6 @@
 #define SWAP_FLAG_PRIO_MASK	0x7fff
 #define SWAP_FLAG_PRIO_SHIFT	0
 
-#define MAX_SWAPFILES 32
-
 /*
  * Magic header for a swap area. The first part of the union is
  * what the swap magic looks like for the old (limited to 128MB)
@@ -39,8 +43,6 @@
 	} info;
 };
 
-#ifdef __KERNEL__
-
 /*
  * Max bad pages in the new format..
  */
diff -Nur linux-2.4.30/include/video/newport.h linux-2.4.30-mips/include/video/newport.h
--- linux-2.4.30/include/video/newport.h	2001-04-12 21:20:31.000000000 +0200
+++ linux-2.4.30-mips/include/video/newport.h	2004-09-23 15:32:29.000000000 +0200
@@ -291,8 +291,6 @@
 	unsigned int _unused2[0x1ef];
 	struct newport_cregs cgo;
 };
-extern struct newport_regs *npregs;
-
 
 typedef struct {
 	unsigned int drawmode1;
@@ -450,38 +448,26 @@
 
 /* Miscellaneous NEWPORT routines. */
 #define BUSY_TIMEOUT 100000
-static __inline__ int newport_wait(void)
+static __inline__ int newport_wait(struct newport_regs *regs)
 {
-	int i = 0;
+	int t = BUSY_TIMEOUT;
 
-	while(i < BUSY_TIMEOUT)
-		if(!(npregs->cset.status & NPORT_STAT_GBUSY))
+	while (t--)
+		if (!(regs->cset.status & NPORT_STAT_GBUSY))
 			break;
-	if(i == BUSY_TIMEOUT)
-		return 1;
-	return 0;
+	return !t;
 }
 
-static __inline__ int newport_bfwait(void)
+static __inline__ int newport_bfwait(struct newport_regs *regs)
 {
-	int i = 0;
+	int t = BUSY_TIMEOUT;
 
-	while(i < BUSY_TIMEOUT)
-		if(!(npregs->cset.status & NPORT_STAT_BBUSY))
+	while (t--)
+		if(!(regs->cset.status & NPORT_STAT_BBUSY))
 			break;
-	if(i == BUSY_TIMEOUT)
-		return 1;
-	return 0;
+	return !t;
 }
 
-/* newport.c and cons_newport.c routines */
-extern struct graphics_ops *newport_probe (int, const char **);
-
-void newport_save    (void *);
-void newport_restore (void *);
-void newport_reset   (void);
-int  newport_ioctl   (int card, int cmd, unsigned long arg);
-
 /*
  * DCBMODE register defines:
  */
@@ -564,7 +550,7 @@
 {
         rex->set.dcbmode = DCB_XMAP0 | XM9_CRS_FIFO_AVAIL |
 		DCB_DATAWIDTH_1 | R_DCB_XMAP9_PROTOCOL;
-        newport_bfwait ();
+        newport_bfwait (rex);
 	
         while ((rex->set.dcbdata0.bybytes.b3 & 3) != XM9_FIFO_EMPTY)
 		;
diff -Nur linux-2.4.30/init/main.c linux-2.4.30-mips/init/main.c
--- linux-2.4.30/init/main.c	2004-11-17 12:54:22.000000000 +0100
+++ linux-2.4.30-mips/init/main.c	2004-11-19 01:28:52.000000000 +0100
@@ -296,7 +296,6 @@
 
 
 extern void setup_arch(char **);
-extern void cpu_idle(void);
 
 unsigned long wait_init_idle;
 
diff -Nur linux-2.4.30/kernel/exit.c linux-2.4.30-mips/kernel/exit.c
--- linux-2.4.30/kernel/exit.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.30-mips/kernel/exit.c	2003-01-11 18:53:18.000000000 +0100
@@ -26,7 +26,7 @@
 
 int getrusage(struct task_struct *, int, struct rusage *);
 
-static void release_task(struct task_struct * p)
+void release_task(struct task_struct * p)
 {
 	if (p != current) {
 #ifdef CONFIG_SMP
diff -Nur linux-2.4.30/kernel/signal.c linux-2.4.30-mips/kernel/signal.c
--- linux-2.4.30/kernel/signal.c	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.30-mips/kernel/signal.c	2004-01-20 16:10:34.000000000 +0100
@@ -14,6 +14,7 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 
+#include <asm/param.h>
 #include <asm/uaccess.h>
 
 /*
@@ -28,6 +29,14 @@
 #define SIG_SLAB_DEBUG	0
 #endif
 
+#define DEBUG_SIG 0
+
+#if DEBUG_SIG
+#define SIG_SLAB_DEBUG	(SLAB_DEBUG_FREE | SLAB_RED_ZONE /* | SLAB_POISON */)
+#else
+#define SIG_SLAB_DEBUG	0
+#endif
+
 static kmem_cache_t *sigqueue_cachep;
 
 atomic_t nr_queued_signals;
@@ -270,6 +279,11 @@
 	signal_pending(current));
 #endif
 
+#if DEBUG_SIG
+printk("SIG dequeue (%s:%d): %d ", current->comm, current->pid,
+	signal_pending(current));
+#endif
+
 	sig = next_signal(current, mask);
 	if (sig) {
 		if (current->notifier) {
@@ -293,6 +307,10 @@
 printk(" %d -> %d\n", signal_pending(current), sig);
 #endif
 
+#if DEBUG_SIG
+printk(" %d -> %d\n", signal_pending(current), sig);
+#endif
+
 	return sig;
 }
 
@@ -540,6 +558,11 @@
 printk("SIG queue (%s:%d): %d ", t->comm, t->pid, sig);
 #endif
 
+
+#if DEBUG_SIG
+printk("SIG queue (%s:%d): %d ", t->comm, t->pid, sig);
+#endif
+
 	ret = -EINVAL;
 	if (sig < 0 || sig > _NSIG)
 		goto out_nolock;
@@ -778,8 +801,8 @@
 	info.si_uid = tsk->uid;
 
 	/* FIXME: find out whether or not this is supposed to be c*time. */
-	info.si_utime = tsk->times.tms_utime;
-	info.si_stime = tsk->times.tms_stime;
+	info.si_utime = hz_to_std(tsk->times.tms_utime);
+	info.si_stime = hz_to_std(tsk->times.tms_stime);
 
 	status = tsk->exit_code & 0x7f;
 	why = SI_KERNEL;	/* shouldn't happen */
diff -Nur linux-2.4.30/kernel/sys.c linux-2.4.30-mips/kernel/sys.c
--- linux-2.4.30/kernel/sys.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.30-mips/kernel/sys.c	2003-11-17 02:07:47.000000000 +0100
@@ -801,16 +801,23 @@
 
 asmlinkage long sys_times(struct tms * tbuf)
 {
+	struct tms temp;
+
 	/*
 	 *	In the SMP world we might just be unlucky and have one of
 	 *	the times increment as we use it. Since the value is an
 	 *	atomically safe type this is just fine. Conceptually its
 	 *	as if the syscall took an instant longer to occur.
 	 */
-	if (tbuf)
-		if (copy_to_user(tbuf, &current->times, sizeof(struct tms)))
+	if (tbuf) {
+		temp.tms_utime = hz_to_std(current->times.tms_utime);
+		temp.tms_stime = hz_to_std(current->times.tms_stime);
+		temp.tms_cutime = hz_to_std(current->times.tms_cutime);
+		temp.tms_cstime = hz_to_std(current->times.tms_cstime);
+		if (copy_to_user(tbuf, &temp, sizeof(struct tms)))
 			return -EFAULT;
-	return jiffies;
+	}
+	return hz_to_std(jiffies);
 }
 
 /*
diff -Nur linux-2.4.30/lib/Makefile linux-2.4.30-mips/lib/Makefile
--- linux-2.4.30/lib/Makefile	2004-04-14 15:05:40.000000000 +0200
+++ linux-2.4.30-mips/lib/Makefile	2004-04-16 05:14:21.000000000 +0200
@@ -27,6 +27,7 @@
 subdir-$(CONFIG_ZLIB_INFLATE) += zlib_inflate
 subdir-$(CONFIG_ZLIB_DEFLATE) += zlib_deflate
 
+-include $(TOPDIR)/arch/$(ARCH)/Makefile.lib
 include $(TOPDIR)/drivers/net/Makefile.lib
 include $(TOPDIR)/drivers/usb/Makefile.lib
 include $(TOPDIR)/drivers/bluetooth/Makefile.lib
