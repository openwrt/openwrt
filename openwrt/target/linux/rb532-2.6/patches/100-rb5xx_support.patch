diff -urN linux.old/arch/mips/Kconfig linux.dev/arch/mips/Kconfig
--- linux.old/arch/mips/Kconfig	2006-07-29 19:53:20.000000000 +0200
+++ linux.dev/arch/mips/Kconfig	2006-07-29 19:31:51.000000000 +0200
@@ -742,6 +742,19 @@
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select TOSHIBA_BOARDS
 
+config MIKROTIK_RB500
+	bool "Support for RB5xx boards"
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SWAP_IO_SPACE
+	select DMA_NONCOHERENT
+	help
+	  Support the Mikrotik(tm) Routerboard 500 series,
+	  such as the RB532.
+
 config TOSHIBA_RBTX4927
 	bool "Toshiba TBTX49[23]7 board"
 	select DMA_NONCOHERENT
@@ -1028,7 +1041,7 @@
 
 config MIPS_L1_CACHE_SHIFT
 	int
-	default "4" if MACH_DECSTATION
+	default "4" if MACH_DECSTATION || MIKROTIK_RB500
 	default "7" if SGI_IP27
 	default "5"
 
diff -urN linux.old/arch/mips/Makefile linux.dev/arch/mips/Makefile
--- linux.old/arch/mips/Makefile	2006-07-29 19:53:20.000000000 +0200
+++ linux.dev/arch/mips/Makefile	2006-07-29 19:31:51.000000000 +0200
@@ -580,6 +580,13 @@
 load-$(CONFIG_TOSHIBA_JMR3927)	+= 0xffffffff80050000
 
 #
+# Routerboard 532 board
+#
+core-$(CONFIG_MIKROTIK_RB500)	+= arch/mips/rb500/
+cflags-$(CONFIG_MIKROTIK_RB500) += -Iinclude/asm-mips/rc32434
+load-$(CONFIG_MIKROTIK_RB500)	+= 0xffffffff80101000
+
+#
 # Toshiba RBTX4927 board or
 # Toshiba RBTX4937 board
 #
diff -urN linux.old/arch/mips/mm/tlbex.c linux.dev/arch/mips/mm/tlbex.c
--- linux.old/arch/mips/mm/tlbex.c	2006-07-29 19:53:20.000000000 +0200
+++ linux.dev/arch/mips/mm/tlbex.c	2006-07-29 19:31:51.000000000 +0200
@@ -876,7 +876,6 @@
 	case CPU_R10000:
 	case CPU_R12000:
 	case CPU_R14000:
-	case CPU_4KC:
 	case CPU_SB1:
 	case CPU_SB1A:
 	case CPU_4KSC:
@@ -904,6 +903,7 @@
 		tlbw(p);
 		break;
 
+	case CPU_4KC:
 	case CPU_4KEC:
 	case CPU_24K:
 	case CPU_34K:
diff -urN linux.old/arch/mips/pci/fixup-rb500.c linux.dev/arch/mips/pci/fixup-rb500.c
--- linux.old/arch/mips/pci/fixup-rb500.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/pci/fixup-rb500.c	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/rc32434/rc32434.h>
+
+static int __devinitdata irq_map[2][12] = {
+	{ 0, 0, 2, 3, 2, 3, 0, 0, 0, 0, 0, 1 },
+	{ 0, 0, 1, 3, 0, 2, 1, 3, 0, 2, 1, 3 }
+};
+
+int __devinit pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq = 0;
+
+	if (dev->bus->number < 2 && PCI_SLOT(dev->devfn) < 12) {
+		irq = irq_map[dev->bus->number][PCI_SLOT(dev->devfn)];
+	}
+	return irq + GROUP4_IRQ_BASE + 4;
+}
+
diff -urN linux.old/arch/mips/pci/Makefile linux.dev/arch/mips/pci/Makefile
--- linux.old/arch/mips/pci/Makefile	2006-07-29 19:53:20.000000000 +0200
+++ linux.dev/arch/mips/pci/Makefile	2006-07-29 19:31:51.000000000 +0200
@@ -57,3 +57,4 @@
 obj-$(CONFIG_TOSHIBA_RBTX4938)	+= fixup-tx4938.o ops-tx4938.o
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
+obj-$(CONFIG_MIKROTIK_RB500)	+= pci-rc32434.o ops-rc32434.o fixup-rb500.o
diff -urN linux.old/arch/mips/pci/ops-rc32434.c linux.dev/arch/mips/pci/ops-rc32434.c
--- linux.old/arch/mips/pci/ops-rc32434.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/pci/ops-rc32434.c	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,195 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     pci_ops for IDT EB434 board
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/io.h>
+
+#include <asm/rc32434/rc32434.h>
+#include <asm/rc32434/pci.h> 
+
+#define PCI_ACCESS_READ  0
+#define PCI_ACCESS_WRITE 1
+
+
+#define PCI_CFG_SET(bus,slot,func,off) \
+	(rc32434_pci->pcicfga = (0x80000000 | \
+				((bus) << 16) | ((slot)<<11) | \
+				((func)<<8) | (off)))
+
+static inline int config_access(unsigned char access_type, struct pci_bus *bus,
+                         unsigned int devfn, unsigned char where,
+                         u32 * data)
+{ 
+	unsigned int slot = PCI_SLOT(devfn);
+	u8 func = PCI_FUNC(devfn);
+	
+	/* Setup address */
+	PCI_CFG_SET(bus->number, slot, func, where);
+	rc32434_sync();
+	
+	if (access_type == PCI_ACCESS_WRITE)
+		rc32434_pci->pcicfgd = *data;
+	else
+		*data = rc32434_pci->pcicfgd;
+	
+	rc32434_sync();
+	
+	return 0;
+}
+
+
+/*
+ * We can't address 8 and 16 bit words directly.  Instead we have to
+ * read/write a 32bit word and mask/modify the data we actually want.
+ */
+static int read_config_byte(struct pci_bus *bus, unsigned int devfn,
+                            int where, u8 * val)
+{
+	u32 data;
+	int ret;
+	
+	ret = config_access(PCI_ACCESS_READ, bus, devfn, where, &data);
+	*val = (data >> ((where & 3) << 3)) & 0xff;
+	return ret;
+}
+
+static int read_config_word(struct pci_bus *bus, unsigned int devfn,
+                            int where, u16 * val)
+{
+	u32 data;
+	int ret;
+	
+	ret = config_access(PCI_ACCESS_READ, bus, devfn, where, &data);
+	*val = (data >> ((where & 3) << 3)) & 0xffff;
+	return ret;
+}
+
+static int read_config_dword(struct pci_bus *bus, unsigned int devfn,
+                             int where, u32 * val)
+{
+	int ret;
+	
+	ret = config_access(PCI_ACCESS_READ, bus, devfn, where, val);
+	return ret;
+}
+
+static int
+write_config_byte(struct pci_bus *bus, unsigned int devfn, int where,
+                  u8 val)
+{
+	u32 data = 0;
+	
+	if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))
+		return -1;
+	
+	data = (data & ~(0xff << ((where & 3) << 3))) |
+		(val << ((where & 3) << 3));
+	
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))
+		return -1;
+	
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static int
+write_config_word(struct pci_bus *bus, unsigned int devfn, int where,
+                  u16 val)
+{
+	u32 data = 0;
+	
+	if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))
+		return -1;
+	
+	data = (data & ~(0xffff << ((where & 3) << 3))) |
+		(val << ((where & 3) << 3));
+	
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))
+		return -1;
+	
+	
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static int 
+write_config_dword(struct pci_bus *bus, unsigned int devfn, int where,
+                   u32 val)
+{
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &val))
+		return -1;
+	
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pci_config_read(struct pci_bus *bus, unsigned int devfn,
+			   int where, int size, u32 * val)
+{
+	switch (size) {
+	case 1: 
+		return read_config_byte(bus, devfn, where, (u8 *) val);
+	case 2: 
+		return read_config_word(bus, devfn, where, (u16 *) val);
+	default:
+		return read_config_dword(bus, devfn, where, val);
+	}
+}
+
+static int pci_config_write(struct pci_bus *bus, unsigned int devfn,
+			    int where, int size, u32 val)
+{
+	switch (size) {
+	case 1: 
+		return write_config_byte(bus, devfn, where, (u8) val);
+	case 2: 
+		return write_config_word(bus, devfn, where, (u16) val);
+	default:
+		return write_config_dword(bus, devfn, where, val);
+	}
+}
+
+struct pci_ops rc32434_pci_ops = {
+	.read =  pci_config_read,
+	.write = pci_config_write,
+};
diff -urN linux.old/arch/mips/pci/pci-rc32434.c linux.dev/arch/mips/pci/pci-rc32434.c
--- linux.old/arch/mips/pci/pci-rc32434.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/pci/pci-rc32434.c	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,234 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     PCI initialization for IDT EB434 board
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/rc32434/rc32434.h>
+#include <asm/rc32434/pci.h>
+
+#define PCI_ACCESS_READ  0
+#define PCI_ACCESS_WRITE 1
+
+/* define an unsigned array for the PCI registers */
+unsigned int korinaCnfgRegs[25] = {
+	KORINA_CNFG1,	 KORINA_CNFG2,  KORINA_CNFG3,  KORINA_CNFG4,
+	KORINA_CNFG5,	 KORINA_CNFG6,  KORINA_CNFG7,  KORINA_CNFG8,
+	KORINA_CNFG9,	 KORINA_CNFG10, KORINA_CNFG11, KORINA_CNFG12,
+	KORINA_CNFG13, KORINA_CNFG14, KORINA_CNFG15, KORINA_CNFG16,
+	KORINA_CNFG17, KORINA_CNFG18, KORINA_CNFG19, KORINA_CNFG20,
+	KORINA_CNFG21, KORINA_CNFG22, KORINA_CNFG23, KORINA_CNFG24
+};
+static struct resource rc32434_res_pci_mem1;
+static struct resource rc32434_res_pci_mem2;
+
+static struct resource rc32434_res_pci_mem1 = {
+	.name = "PCI MEM1",
+	.start = 0x50000000,
+	.end = 0x5FFFFFFF,
+	.flags = IORESOURCE_MEM,
+	.parent = &rc32434_res_pci_mem1,
+	.sibling = NULL,
+	.child = &rc32434_res_pci_mem2
+};
+
+static struct resource rc32434_res_pci_mem2 = {
+	.name = "PCI Mem2",
+	.start = 0x60000000,
+	.end = 0x6FFFFFFF,
+	.flags = IORESOURCE_MEM,
+	.parent = &rc32434_res_pci_mem1,
+	.sibling = NULL,
+	.child = NULL
+};
+
+static struct resource rc32434_res_pci_io1 = {
+	.name = "PCI I/O1",
+	.start = 0x18800000,
+	.end = 0x188FFFFF,
+	.flags = IORESOURCE_IO,
+};
+
+extern struct pci_ops rc32434_pci_ops;
+
+#define PCI_MEM1_START	PCI_ADDR_START
+#define PCI_MEM1_END	PCI_ADDR_START + CPUTOPCI_MEM_WIN - 1
+#define PCI_MEM2_START	PCI_ADDR_START + CPUTOPCI_MEM_WIN
+#define PCI_MEM2_END	PCI_ADDR_START + ( 2* CPUTOPCI_MEM_WIN)  - 1
+#define PCI_IO1_START	PCI_ADDR_START + (2 * CPUTOPCI_MEM_WIN)
+#define PCI_IO1_END 	PCI_ADDR_START + (2* CPUTOPCI_MEM_WIN) + CPUTOPCI_IO_WIN -1
+#define PCI_IO2_START	PCI_ADDR_START + (2 * CPUTOPCI_MEM_WIN) + CPUTOPCI_IO_WIN
+#define PCI_IO2_END 	PCI_ADDR_START + (2* CPUTOPCI_MEM_WIN) + (2 * CPUTOPCI_IO_WIN) -1
+
+
+struct pci_controller rc32434_controller2;
+
+struct pci_controller rc32434_controller = {
+	.pci_ops 	= &rc32434_pci_ops,
+	.mem_resource 	= &rc32434_res_pci_mem1,
+	.io_resource 	= &rc32434_res_pci_io1,
+	.mem_offset     = 0,
+	.io_offset      = 0,
+
+};
+
+#ifdef __MIPSEB__
+#define PCI_ENDIAN_FLAG PCILBAC_sb_m
+#else
+#define PCI_ENDIAN_FLAG 0
+#endif
+
+static int __init rc32434_pcibridge_init(void)
+{
+	unsigned int pcicValue, pcicData = 0;
+	unsigned int dummyRead, pciCntlVal;
+	int loopCount;
+	unsigned int pciConfigAddr;
+
+	pcicValue = rc32434_pci->pcic;
+	pcicValue = (pcicValue >> PCIM_SHFT) & PCIM_BIT_LEN;
+	if (!((pcicValue == PCIM_H_EA) ||
+		 (pcicValue == PCIM_H_IA_FIX) ||
+		(pcicValue == PCIM_H_IA_RR))) {
+		printk("PCI init error!!!\n");
+		/* Not in Host Mode, return ERROR */
+		return -1;
+	}
+	/* Enables the Idle Grant mode, Arbiter Parking */
+	pcicData |=(PCIC_igm_m|PCIC_eap_m|PCIC_en_m);
+	rc32434_pci->pcic = pcicData; /* Enable the PCI bus Interface */
+	/* Zero out the PCI status & PCI Status Mask */
+	for(;;)
+	{
+	   pcicData = rc32434_pci->pcis;
+	   if (!(pcicData & PCIS_rip_m))
+		    break;
+	}
+
+	rc32434_pci->pcis = 0;
+	rc32434_pci->pcism = 0xFFFFFFFF;
+	/* Zero out the PCI decoupled registers */
+	rc32434_pci->pcidac=0; /* disable PCI decoupled accesses at initialization */
+	rc32434_pci->pcidas=0; /* clear the status */
+	rc32434_pci->pcidasm=0x0000007F; /* Mask all the interrupts */
+	/* Mask PCI Messaging Interrupts */
+	rc32434_pci_msg->pciiic = 0;
+	rc32434_pci_msg->pciiim = 0xFFFFFFFF;
+	rc32434_pci_msg->pciioic = 0;
+	rc32434_pci_msg->pciioim = 0;
+
+
+	/* Setup PCILB0 as Memory Window */
+	rc32434_pci->pcilba[0].a = (unsigned int) (PCI_ADDR_START);
+
+	/* setup the PCI map address as same as the local address */
+
+	rc32434_pci->pcilba[0].m = (unsigned int) (PCI_ADDR_START);
+
+
+	/* Setup PCILBA1 as MEM */
+	rc32434_pci->pcilba[0].c = ( ((SIZE_256MB & 0x1f) << PCILBAC_size_b) | PCI_ENDIAN_FLAG);
+	dummyRead = rc32434_pci->pcilba[0].c; /* flush the CPU write Buffers */
+	rc32434_pci->pcilba[1].a = 0x60000000;
+	rc32434_pci->pcilba[1].m = 0x60000000;
+
+	/* setup PCILBA2 as IO Window*/
+	rc32434_pci->pcilba[1].c = (((SIZE_256MB & 0x1f) << PCILBAC_size_b )| PCI_ENDIAN_FLAG);
+	dummyRead = rc32434_pci->pcilba[1].c; /* flush the CPU write Buffers */
+	rc32434_pci->pcilba[2].a = 0x18C00000;
+	rc32434_pci->pcilba[2].m = 0x18FFFFFF;
+
+	/* setup PCILBA2 as IO Window*/
+	rc32434_pci->pcilba[2].c = (((SIZE_4MB & 0x1f) << PCILBAC_size_b) | PCI_ENDIAN_FLAG );
+	dummyRead = rc32434_pci->pcilba[2].c; /* flush the CPU write Buffers */
+
+	/* Setup PCILBA3 as IO Window */
+	rc32434_pci->pcilba[3].a = 0x18800000;
+	rc32434_pci->pcilba[3].m = 0x18800000;
+	rc32434_pci->pcilba[3].c = ( (((SIZE_1MB & 0x1ff) << PCILBAC_size_b) | PCILBAC_msi_m) | PCI_ENDIAN_FLAG);
+	dummyRead = rc32434_pci->pcilba[3].c; /* flush the CPU write Buffers */
+
+	pciConfigAddr=(unsigned int)(0x80000004);
+	for(loopCount=0;loopCount<24;loopCount++){
+		rc32434_pci->pcicfga=pciConfigAddr;
+		dummyRead=rc32434_pci->pcicfga;
+		rc32434_pci->pcicfgd = korinaCnfgRegs[loopCount];
+		dummyRead=rc32434_pci->pcicfgd;
+		pciConfigAddr += 4;
+	}
+	rc32434_pci->pcitc = (unsigned int)((PCITC_RTIMER_VAL&0xff) << PCITC_rtimer_b)
+		| ((PCITC_DTIMER_VAL&0xff) << PCITC_dtimer_b);
+
+	pciCntlVal=rc32434_pci->pcic;
+	pciCntlVal &=~(PCIC_tnr_m);
+	rc32434_pci->pcic = pciCntlVal;
+	pciCntlVal=rc32434_pci->pcic;
+	return 0;
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	if (PCI_SLOT(dev->devfn) == 6 && dev->bus->number == 0) {
+		/* disable prefetched memory range */
+		pci_write_config_word(dev, PCI_PREF_MEMORY_LIMIT, 0);
+		pci_write_config_word(dev, PCI_PREF_MEMORY_BASE, 0x10);
+
+		pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 4);
+	}
+	return 0;
+}
+
+static int __init rc32434_pci_init(void)
+{
+	printk("PCI: Initializing PCI\n");
+
+	ioport_resource.start = rc32434_res_pci_io1.start;
+	ioport_resource.end = rc32434_res_pci_io1.end;
+
+	rc32434_pcibridge_init();
+
+	register_pci_controller(&rc32434_controller);
+	rc32434_sync();
+}
+
+arch_initcall(rc32434_pci_init);
+
diff -urN linux.old/arch/mips/rb500/devices.c linux.dev/arch/mips/rb500/devices.c
--- linux.old/arch/mips/rb500/devices.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/devices.c	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,211 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+#include <asm/unaligned.h>
+#include <asm/io.h>
+
+#include <asm/rc32434/rc32434.h>
+#include <asm/rc32434/dma.h>
+#include <asm/rc32434/dma_v.h>
+#include <asm/rc32434/eth.h>
+#include <asm/rc32434/rb.h>
+
+#define ETH0_DMA_RX_IRQ   	GROUP1_IRQ_BASE + 0
+#define ETH0_DMA_TX_IRQ   	GROUP1_IRQ_BASE + 1 
+#define ETH0_RX_OVR_IRQ   	GROUP3_IRQ_BASE + 9
+#define ETH0_TX_UND_IRQ   	GROUP3_IRQ_BASE + 10
+
+#define ETH0_RX_DMA_ADDR  (DMA0_PhysicalAddress + 0*DMA_CHAN_OFFSET)
+#define ETH0_TX_DMA_ADDR  (DMA0_PhysicalAddress + 1*DMA_CHAN_OFFSET)
+
+static struct resource korina_dev0_res[] = {
+	{
+		.name  = "korina_regs",
+		.start = ETH0_PhysicalAddress,
+		.end   = ETH0_PhysicalAddress + sizeof(ETH_t),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name  = "korina_rx",
+		.start = ETH0_DMA_RX_IRQ,
+		.end   = ETH0_DMA_RX_IRQ,
+		.flags = IORESOURCE_IRQ
+	},
+	{
+		.name  = "korina_tx",
+		.start = ETH0_DMA_TX_IRQ,
+		.end   = ETH0_DMA_TX_IRQ,
+		.flags = IORESOURCE_IRQ
+	},
+	{
+		.name  = "korina_ovr",
+		.start = ETH0_RX_OVR_IRQ,
+		.end   = ETH0_RX_OVR_IRQ,
+		.flags = IORESOURCE_IRQ
+	},
+	{
+		.name  = "korina_und",
+		.start = ETH0_TX_UND_IRQ,
+		.end   = ETH0_TX_UND_IRQ,
+		.flags = IORESOURCE_IRQ
+	},
+	{
+		.name  = "korina_dma_rx",
+		.start = ETH0_RX_DMA_ADDR,
+		.end   = ETH0_RX_DMA_ADDR + DMA_CHAN_OFFSET - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name  = "korina_dma_tx",
+		.start = ETH0_TX_DMA_ADDR,
+		.end   = ETH0_TX_DMA_ADDR + DMA_CHAN_OFFSET - 1,
+		.flags = IORESOURCE_MEM,
+	}
+};
+
+static struct korina_device korina_dev0_data = {
+	.name = "korina0",
+	.mac = { 0xde, 0xca, 0xff, 0xc0, 0xff, 0xee }
+};
+
+static struct platform_device korina_dev0 = {
+	.id = 0,
+	.name = "korina",
+	.dev.platform_data = &korina_dev0_data,
+	.resource = korina_dev0_res,
+	.num_resources = ARRAY_SIZE(korina_dev0_res),
+};
+
+
+#define CF_GPIO_NUM 13
+
+static struct resource cf_slot0_res[] = {
+	{
+		.name  = "cf_membase",
+		.flags = IORESOURCE_MEM
+	},
+	{
+		.name  = "cf_irq",
+		.start = (8 + 4 * 32 + CF_GPIO_NUM),  /* 149 */
+		.end   = (8 + 4 * 32 + CF_GPIO_NUM),
+		.flags = IORESOURCE_IRQ
+	}
+};
+
+static struct cf_device cf_slot0_data = {
+	.gpio_pin = 13
+};
+
+static struct platform_device cf_slot0 = {
+	.id = 0,
+	.name = "rb500-cf",
+	.dev.platform_data = &cf_slot0_data,
+	.resource = cf_slot0_res,
+	.num_resources = ARRAY_SIZE(cf_slot0_res),
+};
+
+
+
+static struct platform_device *rb500_devs[] = {
+	&korina_dev0,
+	&cf_slot0
+};
+
+static void __init parse_mac_addr(char* macstr)
+{
+	int i, j;
+	unsigned char result, value;
+	
+	for (i=0; i<6; i++) {
+		result = 0;
+		if (i != 5 && *(macstr+2) != ':') {
+			return;
+		}				
+		for (j=0; j<2; j++) {
+			if (isxdigit(*macstr) && (value = isdigit(*macstr) ? *macstr-'0' : 
+						  toupper(*macstr)-'A'+10) < 16) {
+				result = result*16 + value;
+				macstr++;
+			} 
+			else return;
+		}
+		
+		macstr++; 
+		korina_dev0_data.mac[i] = result;
+	}
+}
+
+
+/* DEVICE CONTROLLER 1 */
+#define CFG_DC_DEV1 (void*)0xb8010010
+#define CFG_DC_DEVBASE    0x0
+#define CFG_DC_DEVMASK    0x4
+#define CFG_DC_DEVC       0x8
+#define CFG_DC_DEVTC      0xC
+
+
+static int __init plat_setup_devices(void)
+{
+	/* Look for the CF card reader */
+	if (!readl(CFG_DC_DEV1 + CFG_DC_DEVMASK))
+		rb500_devs[1] = NULL;
+	else {
+		cf_slot0_res[0].start = readl(CFG_DC_DEV1 + CFG_DC_DEVBASE);
+		cf_slot0_res[0].end = cf_slot0_res[0].start + 0x1000;
+	}
+		
+	return platform_add_devices(rb500_devs, ARRAY_SIZE(rb500_devs));
+}
+
+static int __init setup_kmac(char *s)
+{
+    printk("korina mac = %s\n",s);
+	parse_mac_addr(s);
+    return 0;
+}
+
+__setup("kmac=", setup_kmac);
+arch_initcall(plat_setup_devices);
+
+
+#if defined(CONFIG_MTD_BLOCK2MTD) && defined(CONFIG_BLK_DEV_CF_MIPS)
+extern void block2mtd_setup(char *initstr);
+extern void mount_devfs_fs(void);
+
+static int __init setup_mtd(void)
+{
+	struct hd_struct **part;
+	int num = 0, i;
+	char initstr[64];
+	
+	if (cf_slot0_data.gd == NULL)
+		return 0;
+	
+	/* count partitions */
+	part = cf_slot0_data.gd->part;
+	while (part[num] != NULL) {
+		num++;
+	}
+
+	if (num < 2)
+		return 0;
+
+	mount_devfs_fs();
+	printk("Setting up block2mtd devices\n");
+
+	block2mtd_setup("/dev/cf/card0/part1,131072,kernel");
+	block2mtd_setup("/dev/cf/card0/part2,131072,rootfs");
+	
+	for (i = 2; part[i]; i++) {
+		sprintf(initstr, "/dev/cf/card0/part%d,131072,part%d", i + 1, i + 1);
+		block2mtd_setup(initstr);
+	}
+	
+	return 0;
+}
+
+late_initcall(setup_mtd);
+#endif
diff -urN linux.old/arch/mips/rb500/early_serial.c linux.dev/arch/mips/rb500/early_serial.c
--- linux.old/arch/mips/rb500/early_serial.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/early_serial.c	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,199 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *      EB434 specific polling driver for 16550 UART.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * Copyright (C) 2000 by Lineo, Inc.
+ * Written by Quinn Jensen (jensenq@lineo.com)
+ **************************************************************************
+ * P. Sadik  Oct 20, 2003
+ *
+ * DIVISOR is made a function of idt_cpu_freq
+ **************************************************************************
+ * P. Sadik  Oct 30, 2003
+ *
+ * added reset_cons_port
+ **************************************************************************
+ */
+
+#include <linux/serial_reg.h>
+
+/* turn this on to watch the debug protocol echoed on the console port */
+#define DEBUG_REMOTE_DEBUG
+
+#define CONS_BAUD 115200
+
+extern unsigned int idt_cpu_freq;
+
+#define EXT_FREQ    24000000
+#define INT_FREQ    idt_cpu_freq
+
+#define EXT_PORT    0xb9800000u
+#define EXT_SHIFT   0
+
+#ifdef __MIPSEB__
+#define INT_PORT    0xb8058003u
+#else
+#define INT_PORT    0xb8058000u
+#endif
+#define INT_SHIFT   2
+
+#define INT_FCR     UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT | UART_FCR_TRIGGER_14
+#define EXT_FCR     UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT
+
+typedef struct
+{
+  volatile unsigned char *base;
+  unsigned int shift;
+  unsigned int freq;
+  unsigned int fcr;
+} ser_port;
+           
+ser_port ports[2] = 
+{
+  { (volatile unsigned char *)INT_PORT, INT_SHIFT, 0, INT_FCR},
+  { (volatile unsigned char *)EXT_PORT, EXT_SHIFT, EXT_FREQ, EXT_FCR}
+};
+
+#define CONS_PORT   0
+
+void cons_putc(char c);
+int port_getc(int port);
+void port_putc(int port, char c);
+
+int cons_getc(void)
+{
+	return port_getc(CONS_PORT);
+}
+
+void cons_putc(char c)
+{
+	port_putc(CONS_PORT, c);
+}
+
+void cons_puts(char *s)
+{
+	while(*s) {
+		if(*s == '\n') cons_putc('\r');
+		cons_putc(*s);
+		s++;
+	}
+}
+
+void cons_do_putn(int n)
+{
+	if(n) {
+		cons_do_putn(n / 10);
+		cons_putc(n % 10 + '0');
+	}
+}
+
+void cons_putn(int n)
+{
+	if(n < 0) {
+		cons_putc('-');
+		n = -n;
+	}
+
+	if (n == 0) {
+		cons_putc('0');
+	} else {
+		cons_do_putn(n);
+	}
+}
+
+int port_getc(int p)
+{
+	volatile unsigned char *port = ports[p].base;
+	int s = ports[p].shift;
+	int c;
+
+	while((*(port + (UART_LSR << s)) & UART_LSR_DR) == 0) {
+		continue;
+	}       	
+
+	c = *(port + (UART_RX << s));
+
+	return c;
+}
+
+int port_getc_ready(int p)
+{
+	volatile unsigned char *port = ports[p].base;
+	int s = ports[p].shift;
+
+	return *(port + (UART_LSR << s)) & UART_LSR_DR;
+}
+
+#define OK_TO_XMT (UART_LSR_TEMT | UART_LSR_THRE)
+
+void port_putc(int p, char c)
+{
+	volatile unsigned char *port = ports[p].base;
+	int s = ports[p].shift;
+	volatile unsigned char *lsr = port + (UART_LSR << s);
+
+	while((*lsr & OK_TO_XMT) != OK_TO_XMT) {
+		continue;
+	}
+
+	*(port + (UART_TX << s)) = c;
+}
+
+void reset_cons_port(void)
+{
+  volatile unsigned char *port = ports[CONS_PORT].base;
+  unsigned int s = ports[CONS_PORT].shift;
+  unsigned int DIVISOR;
+
+  if (ports[CONS_PORT].freq) 
+    DIVISOR = (ports[CONS_PORT].freq / 16 / CONS_BAUD);
+  else
+    DIVISOR = (idt_cpu_freq / 16 / CONS_BAUD);
+
+  /* reset the port */
+  *(port + (UART_CSR << s)) = 0;
+
+  /* clear and enable the FIFOs */
+  *(port + (UART_FCR << s)) = ports[CONS_PORT].fcr;
+
+  /* set the baud rate */
+  *(port + (UART_LCR << s)) = UART_LCR_DLAB;         /* enable DLL, DLM registers */
+
+  *(port + (UART_DLL << s)) = DIVISOR;
+  *(port + (UART_DLM << s)) = DIVISOR >> 8;
+  /* set the line control stuff and disable DLL, DLM regs */
+
+  *(port + (UART_LCR << s)) = UART_LCR_STOP |        /* 2 stop bits */
+    UART_LCR_WLEN8;                         /* 8 bit word length */
+        
+  /* leave interrupts off */
+  *(port + (UART_IER << s)) = 0;
+
+  /* the modem controls don't leave the chip on this port, so leave them alone */
+  *(port + (UART_MCR << s)) = 0;
+}
diff -urN linux.old/arch/mips/rb500/irq.c linux.dev/arch/mips/rb500/irq.c
--- linux.old/arch/mips/rb500/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/irq.c	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,264 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	RC32434 interrupt routines.
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *		stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/time.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/rc32434/rc32434.h>
+#include <asm/rc32434/gpio.h>
+
+extern void set_debug_traps(void);
+extern irq_cpustat_t irq_stat [NR_CPUS];
+unsigned int local_bh_count[NR_CPUS];
+unsigned int local_irq_count[NR_CPUS];
+
+static unsigned int startup_irq(unsigned int irq);
+static void rb500_end_irq(unsigned int irq_nr);
+static void mask_and_ack_irq(unsigned int irq_nr);
+static void rb500_enable_irq(unsigned int irq_nr);
+static void rb500_disable_irq(unsigned int irq_nr);
+
+extern void __init init_generic_irq(void);
+
+typedef struct {
+  u32 mask;       /* mask of valid bits in pending/mask registers */
+  volatile u32 *base_addr;
+} intr_group_t;
+
+#define RC32434_NR_IRQS  (GROUP4_IRQ_BASE + 32)
+
+#if (NR_IRQS < RC32434_NR_IRQS)
+#error Too little irqs defined. Did you override <asm/irq.h> ?
+#endif
+
+static const intr_group_t intr_group[NUM_INTR_GROUPS] = {
+  { 0x0000efff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 0 * IC_GROUP_OFFSET) },
+  { 0x00001fff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 1 * IC_GROUP_OFFSET) },
+  { 0x00000007, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 2 * IC_GROUP_OFFSET) },
+  { 0x0003ffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 3 * IC_GROUP_OFFSET) },
+  { 0xffffffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 4 * IC_GROUP_OFFSET) }
+};
+
+#define READ_PEND(base) (*(base))
+#define READ_MASK(base) (*(base + 2))
+#define WRITE_MASK(base, val) (*(base + 2) = (val))
+
+static inline int irq_to_group(unsigned int irq_nr)
+{
+  return ((irq_nr - GROUP0_IRQ_BASE) >> 5);
+}
+
+static inline int group_to_ip(unsigned int group)
+{
+  return group + 2;
+}
+
+static inline void enable_local_irq(unsigned int ip)
+{
+  int ipnum = 0x100 << ip;
+  clear_c0_cause(ipnum);
+  set_c0_status(ipnum);
+}
+
+static inline void disable_local_irq(unsigned int ip)
+{
+  int ipnum = 0x100 << ip;
+  clear_c0_status(ipnum);
+}
+
+static inline void ack_local_irq(unsigned int ip)
+{
+  int ipnum = 0x100 << ip;
+  clear_c0_cause(ipnum);
+}
+
+static void rb500_enable_irq(unsigned int irq_nr)
+{
+  int           ip = irq_nr - GROUP0_IRQ_BASE;
+  unsigned int  group, intr_bit;
+  volatile unsigned int  *addr;
+  
+  
+  if (ip < 0)
+    enable_local_irq(irq_nr);
+  else {
+    group = ip >> 5;
+ 
+    ip &= (1<<5)-1;
+    intr_bit = 1 << ip;
+ 
+    enable_local_irq(group_to_ip(group));
+    
+    addr = intr_group[group].base_addr;
+    WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);
+  }
+}
+
+static void rb500_disable_irq(unsigned int irq_nr)
+{
+  int           ip = irq_nr - GROUP0_IRQ_BASE;
+  unsigned int  group, intr_bit, mask;
+  volatile unsigned int  *addr;
+  
+  if (ip < 0) {
+	disable_local_irq(irq_nr);
+    }else{
+    group = ip >> 5;
+    
+    ip &= (1<<5) -1;
+    intr_bit = 1 << ip;
+    addr = intr_group[group].base_addr;
+    mask = READ_MASK(addr);
+    mask |= intr_bit;
+    WRITE_MASK(addr,mask);
+   
+    /*
+     * if there are no more interrupts enabled in this
+     * group, disable corresponding IP
+     */
+    if (mask == intr_group[group].mask)
+      disable_local_irq(group_to_ip(group));
+  }
+}
+
+static unsigned int startup_irq(unsigned int irq_nr)
+{
+  rb500_enable_irq(irq_nr);
+  return 0; 
+}
+
+static void shutdown_irq(unsigned int irq_nr)
+{
+  rb500_disable_irq(irq_nr);
+  return;
+}
+
+static void mask_and_ack_irq(unsigned int irq_nr)
+{
+  rb500_disable_irq(irq_nr);
+  ack_local_irq(group_to_ip(irq_to_group(irq_nr)));
+}
+
+static void rb500_end_irq(unsigned int irq_nr)
+{
+
+  int ip = irq_nr - GROUP0_IRQ_BASE;
+  unsigned int intr_bit, group;
+  volatile unsigned int *addr;
+
+	if ((irq_desc[irq_nr].status & (IRQ_DISABLED | IRQ_INPROGRESS))) {
+		printk("warning: end_irq %d did not enable (%x)\n", 
+			irq_nr, irq_desc[irq_nr].status);
+		return;
+	}
+	
+	if (ip < 0) {
+		enable_local_irq(irq_nr);
+	} else {
+		group = ip >> 5;
+	
+		ip &= (1 << 5) - 1;
+		intr_bit = 1 << ip;
+	
+		if (irq_nr >= GROUP4_IRQ_BASE && irq_nr <= (GROUP4_IRQ_BASE + 13)) {
+			gpio->gpioistat = gpio->gpioistat & ~intr_bit;
+		}
+	
+		enable_local_irq(group_to_ip(group));
+	
+		addr = intr_group[group].base_addr;
+		WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);
+	}
+}
+
+static struct hw_interrupt_type rc32434_irq_type = {
+  .typename = "RB500",
+  .startup = startup_irq,
+  .shutdown = shutdown_irq,
+  .enable = rb500_enable_irq,
+  .disable = rb500_disable_irq,
+  .ack = mask_and_ack_irq,
+  .end = rb500_end_irq,
+};
+
+
+void __init arch_init_irq(void)
+{
+	int i;
+
+	printk("Initializing IRQ's: %d out of %d\n", RC32434_NR_IRQS, NR_IRQS);
+	memset(irq_desc, 0, sizeof(irq_desc));
+  
+	for (i = 0; i < RC32434_NR_IRQS; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &rc32434_irq_type;
+		spin_lock_init(&irq_desc[i].lock);
+	}
+}
+
+/* Main Interrupt dispatcher */
+asmlinkage void plat_irq_dispatch(struct pt_regs *regs)
+{
+	unsigned int ip, pend, group;
+	volatile unsigned int *addr;
+	unsigned int cp0_cause = read_c0_cause() & read_c0_status();
+
+	if (cp0_cause & CAUSEF_IP7) {
+		ll_timer_interrupt(7, regs);
+	} else if ((ip = (cp0_cause & 0x7c00))) {
+		group = 21 - rc32434_clz(ip);
+
+		addr = intr_group[group].base_addr;
+
+		pend = READ_PEND(addr);
+		pend &= ~READ_MASK(addr); // only unmasked interrupts
+		pend = 39 - rc32434_clz(pend);
+		do_IRQ((group << 5) + pend, regs);
+	}
+}
diff -urN linux.old/arch/mips/rb500/Makefile linux.dev/arch/mips/rb500/Makefile
--- linux.old/arch/mips/rb500/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/Makefile	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,5 @@
+#
+# Makefile for the RB500 board specific parts of the kernel
+#
+
+obj-y	 += irq.o time.o setup.o serial.o early_serial.o prom.o misc.o devices.o
diff -urN linux.old/arch/mips/rb500/misc.c linux.dev/arch/mips/rb500/misc.c
--- linux.old/arch/mips/rb500/misc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/misc.c	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,54 @@
+#include <linux/module.h>
+#include <linux/kernel.h>   /* printk() */
+#include <linux/types.h>    /* size_t */
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <asm/rc32434/rb.h>
+
+#define GPIO_BADDR  0xb8050000
+
+
+static unsigned char *devCtl3Base = (unsigned char *) KSEG1ADDR(0x18010030);
+static unsigned char latchU5State = 0;
+static spinlock_t clu5Lock = SPIN_LOCK_UNLOCKED;
+
+void set434Reg(unsigned regOffs, unsigned bit, unsigned len, unsigned val) {
+    unsigned flags, data;
+    unsigned i = 0;
+    spin_lock_irqsave(&clu5Lock, flags);
+    data = *(volatile unsigned *) (IDT434_REG_BASE + regOffs);
+    for (i = 0; i != len; ++i) {
+	if (val & (1 << i)) data |= (1 << (i + bit));
+	else data &= ~(1 << (i + bit));
+    }
+    *(volatile unsigned *) (IDT434_REG_BASE + regOffs) = data;
+    spin_unlock_irqrestore(&clu5Lock, flags);
+}
+
+void changeLatchU5(unsigned char orMask, unsigned char nandMask) {
+    unsigned flags;
+    spin_lock_irqsave(&clu5Lock, flags);
+    latchU5State = (latchU5State | orMask) & ~nandMask;
+    *devCtl3Base = latchU5State;
+    spin_unlock_irqrestore(&clu5Lock, flags);
+}
+
+u32 gpio_get(gpio_func func)
+{
+	return readl((void *) GPIO_BADDR + func);
+}
+
+void gpio_set(gpio_func func, u32 mask, u32 value)
+{
+	u32 val = readl((void *) GPIO_BADDR + func);
+	
+	val &= ~mask;
+	val |= value & mask;
+	
+	writel(val, (void *) GPIO_BADDR + func);
+}
+
+EXPORT_SYMBOL(gpio_set);
+EXPORT_SYMBOL(gpio_get);
+EXPORT_SYMBOL(set434Reg);
+EXPORT_SYMBOL(changeLatchU5);
diff -urN linux.old/arch/mips/rb500/prom.c linux.dev/arch/mips/rb500/prom.c
--- linux.old/arch/mips/rb500/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/prom.c	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,181 @@
+/*
+* prom.c 
+**********************************************************************
+* P . Sadik Oct 10, 2003
+*
+* Started change log
+* idt_cpu_freq is make a kernel configuration parameter
+* idt_cpu_freq is exported so that other modules can use it.
+* Code cleanup
+**********************************************************************
+* P. Sadik Oct 20, 2003
+*
+* Removed NVRAM code from here, since they are already available under
+* nvram directory.
+* Added serial port initialisation.
+**********************************************************************
+**********************************************************************
+* P. Sadik Oct 30, 2003
+*
+* Added reset_cons_port
+**********************************************************************
+
+  P.Christeas, 2005-2006
+  Port to 2.6, add 2.6 cmdline parsing
+
+*/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/console.h>
+#include <asm/bootinfo.h>
+#include <linux/bootmem.h>
+#include <linux/ioport.h>
+#include <linux/blkdev.h>
+#include <asm/rc32434/ddr.h>
+
+#define PROM_ENTRY(x)   (0xbfc00000+((x)*8))
+extern void __init setup_serial_port(void);
+extern void cons_putc(char c);
+extern void cons_puts(char *s);
+
+unsigned int idt_cpu_freq = 132000000;
+EXPORT_SYMBOL(idt_cpu_freq);
+unsigned int board_type = 500;
+EXPORT_SYMBOL(board_type);
+unsigned int gpio_bootup_state = 0;
+EXPORT_SYMBOL(gpio_bootup_state);
+
+
+char mips_mac_address[18] = "08:00:06:05:40:01";
+EXPORT_SYMBOL(mips_mac_address);
+
+/* what to append to cmdline when button is [not] pressed */
+#define GPIO_INIT_NOBUTTON ""
+#define GPIO_INIT_BUTTON   " 2"
+
+#ifdef CONFIG_MIKROTIK_RB500
+unsigned soft_reboot = 0;
+EXPORT_SYMBOL(soft_reboot);
+#endif
+
+#define SR_NMI			0x00180000      /* NMI */
+#define SERIAL_SPEED_ENTRY	0x00000001
+
+#ifdef CONFIG_REMOTE_DEBUG
+extern int remote_debug;
+#endif
+
+extern unsigned long mips_machgroup;
+extern unsigned long mips_machtype;
+
+#define FREQ_TAG   "HZ="
+#define GPIO_TAG   "gpio="
+#define KMAC_TAG   "kmac="
+#define MEM_TAG	   "mem="
+#define BOARD_TAG  "board="
+#define IGNORE_CMDLINE_MEM 1
+#define DEBUG_DDR
+
+void parse_soft_settings(unsigned *ptr, unsigned size);
+void parse_hard_settings(unsigned *ptr, unsigned size);
+
+void __init prom_setup_cmdline(void);
+
+#ifdef DEBUG_DDR
+void cons_puthex4(u32 h){
+	h&=0x0f;
+	if (h>=10)
+		cons_putc((h-10)+'a');
+	else
+		cons_putc(h+'0');
+}
+
+void cons_putreg32(u32 reg){
+	char c;
+	cons_putc('0');
+	cons_putc('x');
+	for (c=28;c>=0;c-=4)
+		cons_puthex4(reg>>c);
+}
+#endif
+
+void __init prom_init(void)
+{
+	DDR_t ddr = (DDR_t) DDR_VirtualAddress; /* define the pointer to the DDR registers */
+	phys_t memsize = 0-ddr->ddrmask;
+	
+	/* this should be the very first message, even before serial is properly initialized */
+	prom_setup_cmdline();
+	setup_serial_port();
+
+	mips_machgroup = MACH_GROUP_MIKROTIK;
+	soft_reboot = read_c0_status() & SR_NMI;
+	pm_power_off = NULL;
+
+	/*
+	 * give all RAM to boot allocator,
+	 * except for the first 0x400 and the last 0x200 bytes
+	 */
+	add_memory_region(ddr->ddrbase + 0x400, memsize - 0x600, BOOT_MEM_RAM);
+}
+
+void prom_free_prom_memory(void)
+{
+	/* FIXME: STUB */
+}
+
+void __init prom_setup_cmdline(void){
+	char cmd_line[CL_SIZE];
+	char *cp;
+	int prom_argc;
+	char **prom_argv, **prom_envp;
+	int i;
+	
+	prom_argc = fw_arg0;
+	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
+	
+	cp=cmd_line;
+		/* Note: it is common that parameters start at argv[1] and not argv[0],
+		however, our elf loader starts at [0] */
+	for(i=0;i<prom_argc;i++){
+		if (strncmp(prom_argv[i], FREQ_TAG, sizeof(FREQ_TAG) - 1) == 0) {
+			idt_cpu_freq = simple_strtoul(prom_argv[i] + sizeof(FREQ_TAG) - 1, 0, 10);
+			continue;
+		}
+#ifdef IGNORE_CMDLINE_MEM
+		/* parses out the "mem=xx" arg */
+		if (strncmp(prom_argv[i], MEM_TAG, sizeof(MEM_TAG) - 1) == 0) {
+			continue;
+		}
+#endif
+		if (i>0) *(cp++) = ' ';
+		if (strncmp(prom_argv[i], BOARD_TAG, sizeof(BOARD_TAG) - 1) == 0) {
+			board_type =  simple_strtoul(prom_argv[i] + sizeof(BOARD_TAG) - 1, 0, 10);
+		}
+		if (strncmp(prom_argv[i], GPIO_TAG, sizeof(GPIO_TAG) - 1) == 0) {
+			gpio_bootup_state =  simple_strtoul(prom_argv[i] + sizeof(GPIO_TAG) - 1, 0, 10);
+		}
+		strcpy(cp,prom_argv[i]);
+		cp+=strlen(prom_argv[i]);
+	}
+	
+	i=strlen(arcs_cmdline);
+	if (i>0){
+		*(cp++) = ' ';
+		strcpy(cp,arcs_cmdline);
+		cp+=strlen(arcs_cmdline);
+	}
+	if (gpio_bootup_state&0x02)
+		strcpy(cp,GPIO_INIT_NOBUTTON);
+	else
+		strcpy(cp,GPIO_INIT_BUTTON);
+	cmd_line[CL_SIZE-1] = '\0';
+	
+	strcpy(arcs_cmdline,cmd_line);
+}
+
diff -urN linux.old/arch/mips/rb500/serial.c linux.dev/arch/mips/rb500/serial.c
--- linux.old/arch/mips/rb500/serial.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/serial.c	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,79 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     Serial port initialisation.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+
+#include <asm/time.h>
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/serial.h>
+#include <asm/rc32434/rc32434.h>
+
+extern unsigned int idt_cpu_freq;
+
+static struct uart_port serial_req = {
+	.type = PORT_16550A,
+	.line = 0,
+	.irq = RC32434_UART0_IRQ,
+	.flags = STD_COM_FLAGS,
+	.iotype = UPIO_MEM,
+	.membase = (char *) KSEG1ADDR(RC32434_UART0_BASE),
+//	.fifosize = 14
+	.regshift = 2
+};
+
+int __init setup_serial_port(void)
+{
+	serial_req.uartclk = idt_cpu_freq;
+
+	if (early_serial_setup(&serial_req)){
+		cons_puts("Serial setup failed!\n");
+		return -ENODEV;
+	}
+	
+	return(0);
+}
diff -urN linux.old/arch/mips/rb500/setup.c linux.dev/arch/mips/rb500/setup.c
--- linux.old/arch/mips/rb500/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/setup.c	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,84 @@
+/*
+ * setup.c - boot time setup code
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/irq.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <linux/ioport.h>
+#include <asm/mipsregs.h>
+#include <asm/pgtable.h>
+#include <asm/reboot.h>
+#include <asm/addrspace.h>     /* for KSEG1ADDR() */
+#include <asm/rc32434/rc32434.h>
+#include <linux/pm.h>
+#include <asm/rc32434/pci.h>
+
+extern void (*board_time_init)(void);
+extern void (*board_timer_setup)(struct irqaction *irq);
+extern void rc32434_time_init(void);
+extern void rc32434_timer_setup(struct irqaction *irq);
+#ifdef CONFIG_PCI
+extern int __init rc32434_pcibridge_init(void);
+#endif
+
+#define epldMask ((volatile unsigned char *)0xB900000d)
+
+static void rb_machine_restart(char *command)
+{
+	/* just jump to the reset vector */
+	* (volatile unsigned *) KSEG1ADDR(0x18008000) = 0x80000001;
+	((void (*)(void))KSEG1ADDR(0x1FC00000u))();
+}
+
+static void rb_machine_halt(void)
+{
+	for(;;) continue;
+}
+
+#ifdef CONFIG_CPU_HAS_WB
+void (*__wbflush) (void);
+
+static void rb_write_buffer_flush(void)
+{
+	__asm__ __volatile__
+	    ("sync\n\t" "nop\n\t" "loop: bc0f loop\n\t" "nop\n\t");
+}
+#endif
+
+void __init plat_setup(void)
+{
+	unsigned int pciCntlVal;
+
+	board_time_init = rc32434_time_init;
+	board_timer_setup = rc32434_timer_setup;
+
+#ifdef CONFIG_CPU_HAS_WB
+	__wbflush = rb_write_buffer_flush;
+#endif
+	_machine_restart = rb_machine_restart;
+	_machine_halt = rb_machine_halt;
+	/*_machine_power_off = rb_machine_power_halt;*/
+	pm_power_off = rb_machine_halt;
+
+	set_io_port_base(KSEG1);
+
+	pciCntlVal=rc32434_pci->pcic;
+	pciCntlVal &= 0xFFFFFF7;
+	rc32434_pci->pcic = pciCntlVal;
+
+#ifdef CONFIG_PCI
+	/* Enable PCI interrupts in EPLD Mask register */
+	*epldMask = 0x0;
+	*(epldMask + 1) = 0x0;
+#endif
+	write_c0_wired(0);
+}
+
+const char *get_system_type(void)
+{
+	return "MIPS RB500";
+}
diff -urN linux.old/arch/mips/rb500/time.c linux.dev/arch/mips/rb500/time.c
--- linux.old/arch/mips/rb500/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/rb500/time.c	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,94 @@
+/*
+****************************************************************************
+* Carsten Langgaard, carstenl@mips.com
+* Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+*
+***************************************************************************
+*
+*  This program is free software; you can distribute it and/or modify it
+*  under the terms of the GNU General Public License (Version 2) as
+*  published by the Free Software Foundation.
+*
+*  This program is distributed in the hope it will be useful, but WITHOUT
+*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+*  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+*  for more details.
+*
+*  You should have received a copy of the GNU General Public License along
+*  with this program; if not, write to the Free Software Foundation, Inc.,
+*  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+*
+****************************************************************************
+*
+* Setting up the clock on the MIPS boards.
+*
+****************************************************************************
+* P. Sadik Oct 10, 2003
+*
+* Started change log.
+* mips_counter_frequency is now calculated at run time, based on idt_cpu_freq.
+* Code cleanup
+****************************************************************************
+*/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/mc146818rtc.h>
+#include <linux/irq.h>
+#include <linux/timex.h>
+
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/debug.h>
+#include <asm/rc32434/rc32434.h>
+
+static unsigned long r4k_offset; /* Amount to incr compare reg each time */
+static unsigned long r4k_cur;    /* What counter should be at next timer irq */
+extern void ll_timer_interrupt(int irq, struct pt_regs *regs);
+extern unsigned int mips_hpt_frequency;
+extern unsigned int idt_cpu_freq;
+
+/* 
+ * Figure out the r4k offset, the amount to increment the compare
+ * register for each time tick. There is no RTC available.
+ *
+ * The RC32434 counts at half the CPU *core* speed.
+ */
+static unsigned long __init cal_r4koff(void)
+{
+	mips_hpt_frequency = idt_cpu_freq * IDT_CLOCK_MULT / 2;
+	return (mips_hpt_frequency / HZ);
+}
+
+
+void __init rc32434_time_init(void)
+{
+	unsigned int est_freq, flags;
+
+	local_irq_save(flags);
+
+	printk("calculating r4koff... ");
+	r4k_offset = cal_r4koff();
+	printk("%08lx(%d)\n", r4k_offset, (int) r4k_offset);
+
+	est_freq = 2*r4k_offset*HZ;	
+	est_freq += 5000;	/* round */
+	est_freq -= est_freq%10000;
+	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000, 
+	       (est_freq%1000000)*100/1000000);
+	local_irq_restore(flags);
+}
+
+void __init rc32434_timer_setup(struct irqaction *irq)
+{
+	/* we are using the cpu counter for timer interrupts */
+	setup_irq(MIPS_CPU_TIMER_IRQ, irq);
+
+	/* to generate the first timer interrupt */
+	r4k_cur = (read_c0_count() + r4k_offset);
+	write_c0_compare(r4k_cur);
+}
+
diff -urN linux.old/drivers/mtd/devices/block2mtd.c linux.dev/drivers/mtd/devices/block2mtd.c
--- linux.old/drivers/mtd/devices/block2mtd.c	2006-07-29 19:53:54.000000000 +0200
+++ linux.dev/drivers/mtd/devices/block2mtd.c	2006-07-29 19:47:03.000000000 +0200
@@ -26,7 +26,6 @@
 #define ERROR(fmt, args...) printk(KERN_ERR "block2mtd: " fmt "\n" , ## args)
 #define INFO(fmt, args...) printk(KERN_INFO "block2mtd: " fmt "\n" , ## args)
 
-
 /* Info for the block device */
 struct block2mtd_dev {
 	struct list_head list;
@@ -62,10 +61,8 @@
 	read_lock_irq(&mapping->tree_lock);
 	for (i = 0; i < PAGE_READAHEAD; i++) {
 		pagei = index + i;
-		if (pagei > end_index) {
-			INFO("Overrun end of disk in cache readahead\n");
+		if (pagei > end_index)
 			break;
-		}
 		page = radix_tree_lookup(&mapping->page_tree, pagei);
 		if (page && (!i))
 			break;
@@ -106,7 +103,7 @@
 
 	while (pages) {
 		page = page_readahead(mapping, index);
-		if (!page)
+		if (!page || !page_address(page))
 			return -ENOMEM;
 		if (IS_ERR(page))
 			return PTR_ERR(page);
@@ -285,7 +282,7 @@
 
 
 /* FIXME: ensure that mtd->size % erase_size == 0 */
-static struct block2mtd_dev *add_device(char *devname, int erase_size)
+static struct block2mtd_dev *add_device(char *devname, int erase_size, char *alias)
 {
 	struct block_device *bdev;
 	struct block2mtd_dev *dev;
@@ -315,14 +312,15 @@
 
 	/* Setup the MTD structure */
 	/* make the name contain the block device in */
-	dev->mtd.name = kmalloc(sizeof("block2mtd: ") + strlen(devname),
+	dev->mtd.name = kmalloc(strlen((alias ?: devname)),
 			GFP_KERNEL);
 	if (!dev->mtd.name)
 		goto devinit_err;
 
-	sprintf(dev->mtd.name, "block2mtd: %s", devname);
+	strcpy(dev->mtd.name, (alias ?: devname));
 
 	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;
+	dev->mtd.size -= dev->mtd.size % erase_size;
 	dev->mtd.erasesize = erase_size;
 	dev->mtd.type = MTD_RAM;
 	dev->mtd.flags = MTD_CAP_RAM;
@@ -341,7 +339,7 @@
 	}
 	list_add(&dev->list, &blkmtd_device_list);
 	INFO("mtd%d: [%s] erase_size = %dKiB [%d]", dev->mtd.index,
-			dev->mtd.name + strlen("blkmtd: "),
+			dev->mtd.name,
 			dev->mtd.erasesize >> 10, dev->mtd.erasesize);
 	return dev;
 
@@ -416,10 +414,10 @@
 	return 0;				\
 } while (0)
 
-static int block2mtd_setup(const char *val, struct kernel_param *kp)
+int block2mtd_setup(const char *val, struct kernel_param *kp)
 {
 	char buf[80+12], *str=buf; /* 80 for device, 12 for erase size */
-	char *token[2];
+	char *token[3];
 	char *name;
 	size_t erase_size = PAGE_SIZE;
 	int i, ret;
@@ -430,7 +428,7 @@
 	strcpy(str, val);
 	kill_final_newline(str);
 
-	for (i=0; i<2; i++)
+	for (i=0; i<3; i++)
 		token[i] = strsep(&str, ",");
 
 	if (str)
@@ -453,7 +451,7 @@
 			parse_err("illegal erase size");
 	}
 
-	add_device(name, erase_size);
+	add_device(name, erase_size, token[2]);
 
 	return 0;
 }
@@ -461,6 +459,7 @@
 
 module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
 MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>]\"");
+EXPORT_SYMBOL(block2mtd_setup);
 
 static int __init block2mtd_init(void)
 {
diff -urN linux.old/drivers/pci/Makefile linux.dev/drivers/pci/Makefile
--- linux.old/drivers/pci/Makefile	2006-07-29 19:53:20.000000000 +0200
+++ linux.dev/drivers/pci/Makefile	2006-07-29 19:31:51.000000000 +0200
@@ -27,6 +27,7 @@
 obj-$(CONFIG_MIPS) += setup-bus.o setup-irq.o
 obj-$(CONFIG_X86_VISWS) += setup-irq.o
 obj-$(CONFIG_PCI_MSI) += msi.o
+obj-$(CONFIG_MIKROTIK_RB500) += setup-irq.o
 
 #
 # ACPI Related PCI FW Functions
diff -urN linux.old/include/asm-mips/bootinfo.h linux.dev/include/asm-mips/bootinfo.h
--- linux.old/include/asm-mips/bootinfo.h	2006-07-29 19:53:20.000000000 +0200
+++ linux.dev/include/asm-mips/bootinfo.h	2006-07-29 19:31:51.000000000 +0200
@@ -218,6 +218,8 @@
 #define MACH_GROUP_TITAN       22	/* PMC-Sierra Titan		*/
 #define  MACH_TITAN_YOSEMITE	1	/* PMC-Sierra Yosemite		*/
 
+#define MACH_GROUP_MIKROTIK    24 /* Mikrotik Boards			    */
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
diff -urN linux.old/include/asm-mips/cpu.h linux.dev/include/asm-mips/cpu.h
--- linux.old/include/asm-mips/cpu.h	2006-07-29 19:53:20.000000000 +0200
+++ linux.dev/include/asm-mips/cpu.h	2006-07-29 19:31:51.000000000 +0200
@@ -200,7 +200,8 @@
 #define CPU_SB1A		62
 #define CPU_74K			63
 #define CPU_R14000		64
-#define CPU_LAST		64
+#define CPU_RC32300		65
+#define CPU_LAST		65
 
 /*
  * ISA Level encodings
diff -urN linux.old/include/asm-mips/rc32434/crom.h linux.dev/include/asm-mips/rc32434/crom.h
--- linux.old/include/asm-mips/rc32434/crom.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/crom.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,98 @@
+#ifndef __IDT_CROM_H__
+#define __IDT_CROM_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Configuration ROM register definitions.
+ *
+ * File   : $Id: crom.h,v 1.2 2002/06/06 18:34:03 astichte Exp $
+ *
+ * Author : Allen.Stichter@idt.com
+ * Date   : 20020118
+ * Update :
+ *	    $Log: crom.h,v $
+ *	    Revision 1.2  2002/06/06 18:34:03  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:21  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h>
+
+enum
+{
+	CROM0_PhysicalAddress	= 0x100b8000,
+	CROM_PhysicalAddress	= CROM0_PhysicalAddress,
+
+	CROM0_VirtualAddress	= 0xb00b8000,
+	CROM_VirtualAddress	= CROM0_VirtualAddress,
+} ;
+
+typedef struct CROM_s
+{
+	U32	cromw0 ;		// use CROMW0_
+	U32	cromw1 ;		// use CROMW1_
+	U32	cromw2 ;		// use CROMW2_
+} volatile * CROM_t ;
+
+enum
+{
+	CROMW0_xloc_b	= 0,
+	CROMW0_xloc_m	= 0x0000003f,
+	CROMW0_yloc_b	= 8,
+	CROMW0_yloc_m	= 0x00003f00,
+	CROMW0_speed_b	= 16,
+	CROMW0_speed_m	= 0x01ff0000,
+	CROMW1_wafer_b	= 0,
+	CROMW1_wafer_m	= 0x0000001f,
+	CROMW1_lot_b	= 8,
+	CROMW1_lot_m	= 0x0fffff00,
+	CROMW1_fab_b	= 28,
+	CROMW1_fab_m	= 0xf0000000,
+	CROMW2_pci_b	= 0,
+	CROMW2_pci_m	= 0x00000001,
+	CROMW2_eth0_b	= 1,
+	CROMW2_eth0_m	= 0x00000002,
+	CROMW2_eth1_b	= 2,
+	CROMW2_eth1_m	= 0x00000004
+	CROMW2_i2c_b	= 3,
+	CROMW2_i2c_m	= 0x00000008,
+	CROMW2_rng_b	= 4,
+	CROMW2_rng_m	= 0x00000010,
+	CROMW2_se_b	= 5,
+	CROMW2_se_m	= 0x00000020,
+	CROMW2_des_b	= 6,
+	CROMW2_des_m	= 0x00000040,
+	CROMW2_tdes_b	= 7,
+	CROMW2_tdes_m	= 0x00000080,
+	CROMW2_a128_b	= 8,
+	CROMW2_a128_m	= 0x00000100,
+	CROMW2_a192_b	= 9,
+	CROMW2_a192_m	= 0x00000200,
+	CROMW2_a256_b	= 10,
+	CROMW2_a256_m	= 0x00000400,
+	CROMW2_md5_b	= 11,
+	CROMW2_md5_m	= 0x00000800,
+	CROMW2_s1_b	= 12,
+	CROMW2_s1_m	= 0x00001000,
+	CROMW2_s256_b	= 13,
+	CROMW2_s256_m	= 0x00002000,
+	CROMW2_pka_b	= 14,
+	CROMW2_pka_m	= 0x00004000,
+	CROMW2_exp_b	= 15,
+	CROMW2_exp_m	= 0x00018000,
+		CROMW2_exp_8192_v	= 0,
+		CROMW2_exp_1536_v	= 1,
+		CROMW2_exp_1024_v	= 2,
+		CROMW2_exp_512_v	= 3,
+	CROMW2_rocfg_b	= 17,
+	CROMW2_rocfg_m	= 0x000e0000,
+} ;
+
+#endif	// __IDT_CROM_H__
diff -urN linux.old/include/asm-mips/rc32434/ddr.h linux.dev/include/asm-mips/rc32434/ddr.h
--- linux.old/include/asm-mips/rc32434/ddr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/ddr.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,175 @@
+#ifndef __IDT_DDR_H__
+#define __IDT_DDR_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * DDR register definition.
+ *
+ * File   : $Id: ddr.h,v 1.2 2002/06/06 18:34:03 astichte Exp $
+ *
+ * Author : ryan.holmQVist@idt.com
+ * Date   : 20011005
+ * Update :
+ *          $Log: ddr.h,v $
+ *          Revision 1.2  2002/06/06 18:34:03  astichte
+ *          Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *
+ *          Revision 1.1  2002/05/29 17:33:21  sysarch
+ *          jba File moved from vcode/include/idt/acacia
+ *
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h>
+
+enum
+{
+	DDR0_PhysicalAddress	= 0x18018000,
+	DDR_PhysicalAddress	= DDR0_PhysicalAddress,		// Default
+
+	DDR0_VirtualAddress	= 0xb8018000,
+	DDR_VirtualAddress	= DDR0_VirtualAddress,		// Default
+} ;
+
+typedef struct DDR_s
+{
+	U32	ddrbase ;
+	U32	ddrmask ;
+	U32	res1;
+	U32	res2;
+	U32	ddrc ;
+	U32	ddrabase ;
+	U32	ddramask ;
+	U32	ddramap ;
+	U32	ddrcust;
+	U32	ddrrdc;
+	U32	ddrspare;
+} volatile *DDR_t ;
+
+enum
+{
+	DDR0BASE_baseaddr_b	= 16,
+	DDR0BASE_baseaddr_m	= 0xffff0000,
+
+	DDR0MASK_mask_b		= 16,
+	DDR0MASK_mask_m		= 0xffff0000,
+
+	DDR1BASE_baseaddr_b	= 16,
+	DDR1BASE_baseaddr_m	= 0xffff0000,
+
+	DDR1MASK_mask_b		= 16,
+	DDR1MASK_mask_m		= 0xffff0000,
+
+	DDRC_ata_b		= 5,
+	DDRC_ata_m		= 0x000000E0,
+	DDRC_dbw_b		= 8,
+	DDRC_dbw_m		= 0x00000100,
+	DDRC_wr_b		= 9,
+	DDRC_wr_m		= 0x00000600,
+	DDRC_ps_b		= 11,
+	DDRC_ps_m		= 0x00001800,
+	DDRC_dtype_b		= 13,
+	DDRC_dtype_m		= 0x0000e000,
+	DDRC_rfc_b		= 16,
+	DDRC_rfc_m		= 0x000f0000,
+	DDRC_rp_b		= 20,
+	DDRC_rp_m		= 0x00300000,
+	DDRC_ap_b		= 22,
+	DDRC_ap_m		= 0x00400000,
+	DDRC_rcd_b		= 23,
+	DDRC_rcd_m		= 0x01800000,
+	DDRC_cl_b		= 25,
+	DDRC_cl_m		= 0x06000000,
+	DDRC_dbm_b		= 27,
+	DDRC_dbm_m		= 0x08000000,
+	DDRC_sds_b		= 28,
+	DDRC_sds_m		= 0x10000000,
+	DDRC_atp_b		= 29,
+	DDRC_atp_m		= 0x60000000,
+	DDRC_re_b		= 31,
+	DDRC_re_m		= 0x80000000,
+
+	DDRRDC_ces_b		= 0,
+	DDRRDC_ces_m		= 0x00000001,
+	DDRRDC_ace_b		= 1,
+	DDRRDC_ace_m		= 0x00000002,
+
+	DDRABASE_baseaddr_b	= 16,
+	DDRABASE_baseaddr_m	= 0xffff0000,
+
+	DDRAMASK_mask_b		= 16,
+	DDRAMASK_mask_m		= 0xffff0000,
+
+	DDRAMAP_map_b		= 16,
+	DDRAMAP_map_m		= 0xffff0000,
+
+	DDRCUST_cs_b		= 0,
+	DDRCUST_cs_m		= 0x00000003,
+	DDRCUST_we_b		= 2,
+	DDRCUST_we_m		= 0x00000004,
+	DDRCUST_ras_b		= 3,
+	DDRCUST_ras_m		= 0x00000008,
+	DDRCUST_cas_b		= 4,
+	DDRCUST_cas_m		= 0x00000010,
+	DDRCUST_cke_b		= 5,
+	DDRCUST_cke_m		= 0x00000020,
+	DDRCUST_ba_b		= 6,
+	DDRCUST_ba_m		= 0x000000c0,
+
+	RCOUNT_rcount_b		= 0,
+	RCOUNT_rcount_m		= 0x0000ffff,
+
+	RCOMPARE_rcompare_b	= 0,
+	RCOMPARE_rcompare_m	= 0x0000ffff,
+
+	RTC_ce_b		= 0,
+	RTC_ce_m		= 0x00000001,
+	RTC_to_b		= 1,
+	RTC_to_m		= 0x00000002,
+	RTC_rqe_b		= 2,
+	RTC_rqe_m		= 0x00000004,
+
+	DDRDQSC_dm_b		= 0,
+	DDRDQSC_dm_m		= 0x00000003,
+	DDRDQSC_dqsbs_b		= 2,
+	DDRDQSC_dqsbs_m		= 0x000000fc,
+	DDRDQSC_db_b		= 8,
+	DDRDQSC_db_m		= 0x00000100,
+	DDRDQSC_dbsp_b		= 9,
+	DDRDQSC_dbsp_m		= 0x01fffe00,
+	DDRDQSC_bdp_b		= 25,
+	DDRDQSC_bdp_m		= 0x7e000000,
+
+	DDRDLLC_eao_b		= 0,
+	DDRDLLC_eao_m		= 0x00000001,
+	DDRDLLC_eo_b		= 1,
+	DDRDLLC_eo_m		= 0x0000003e,
+	DDRDLLC_fs_b		= 6,
+	DDRDLLC_fs_m		= 0x000000c0,
+	DDRDLLC_as_b		= 8,
+	DDRDLLC_as_m		= 0x00000700,
+	DDRDLLC_sp_b		= 11,
+	DDRDLLC_sp_m		= 0x001ff800,
+
+	DDRDLLFC_men_b		= 0,
+	DDRDLLFC_men_m		= 0x00000001,
+	DDRDLLFC_aen_b		= 1,
+	DDRDLLFC_aen_m		= 0x00000002,
+	DDRDLLFC_ff_b		= 2,
+	DDRDLLFC_ff_m		= 0x00000004,
+
+	DDRDLLTA_addr_b		= 2,
+	DDRDLLTA_addr_m		= 0xfffffffc,
+
+	DDRDLLED_dbe_b		= 0,
+	DDRDLLED_dbe_m		= 0x00000001,
+	DDRDLLED_dte_b		= 1,
+	DDRDLLED_dte_m		= 0x00000002,
+	
+		
+} ;
+
+#endif	// __IDT_DDR_H__
diff -urN linux.old/include/asm-mips/rc32434/dev.h linux.dev/include/asm-mips/rc32434/dev.h
--- linux.old/include/asm-mips/rc32434/dev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/dev.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,134 @@
+#ifndef __IDT_DEV_H__
+#define __IDT_DEV_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Device Controller register definition.
+ *
+ * File   : $Id: dev.h,v 1.2 2002/06/06 18:34:03 astichte Exp $
+ *
+ * Author : John.Ahrens@idt.com
+ * Date   : 200112013
+ * Update :
+ *	    $Log: dev.h,v $
+ *	    Revision 1.2  2002/06/06 18:34:03  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:21  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h> 
+
+enum
+{
+	DEV0_PhysicalAddress	= 0x18010000,
+	DEV_PhysicalAddress	= DEV0_PhysicalAddress,		// Default
+
+	DEV0_VirtualAddress	= 0xb8010000,
+	DEV_VirtualAddress	= DEV0_VirtualAddress,		// Default
+} ;
+
+typedef struct DEVICE_s
+{
+	U32	devbase ;			// Device Base
+	U32	devmask ;			// Device Mask
+	U32	devc ;				// Device Control
+	U32	devtc ;				// Device Timing Control
+} volatile *DEVICE_t ;
+
+enum
+{
+	DEV_Count = 3,
+} ;
+
+typedef struct DEV_s
+{
+	struct DEVICE_s	dev [DEV_Count] ;
+	U32		btcs ;			// Bus timeout control / status 
+	U32		btcompare ;		// Compare
+	U32		btaddr ;		// Timeout address.
+	U32		devdacs ;		// Decoupled access control.
+	U32		devdaa ;		// Decoupled access address.
+	U32		devdad ;		// Decoupled access address.
+	U32		devspare ;		// spare.
+} volatile *DEV_t ;
+
+enum
+{
+	DEVBASE_baseaddr_b	= 16,
+	DEVBASE_baseaddr_m	= 0xffff0000,
+	DEVMASK_mask_b		= 16,
+	DEVMASK_mask_m		= 0xffff0000,
+
+	DEVC_ds_b		= 0,
+	DEVC_ds_m		= 0x00000003,
+		DEVC_ds_8_v	= 0,		// 8-bit device.
+		DEVC_ds_16_v	= 1,		// reserved
+		DEVC_ds_res_v	= 2,		// reserved.
+		DEVC_ds_res2_v	= 3,		// reserved.
+	DEVC_be_b		= 2,
+	DEVC_be_m		= 0x00000004,
+	DEVC_wp_b		= 3,
+	DEVC_wp_m		= 0x00000008,
+	DEVC_csd_b		= 4,
+	DEVC_csd_m		= 0x000000f0,
+	DEVC_oed_b		= 8,
+	DEVC_oed_m		= 0x00000f00,
+	DEVC_bwd_b		= 12,
+	DEVC_bwd_m		= 0x0000f000,
+	DEVC_rws_b		= 16,
+	DEVC_rws_m		= 0x003f0000,
+	DEVC_wws_b		= 22,
+	DEVC_wws_m		= 0x0fc00000,
+	DEVC_bre_b		= 28,
+	DEVC_bre_m		= 0x10000000,
+	DEVC_bwe_b		= 29,
+	DEVC_bwe_m		= 0x20000000,
+	DEVC_wam_b		= 30,
+	DEVC_wam_m		= 0x40000000,
+
+	DEVTC_prd_b		= 0,
+	DEVTC_prd_m		= 0x0000000f,
+	DEVTC_pwd_b		= 4,
+	DEVTC_pwd_m		= 0x000000f0,
+	DEVTC_wdh_b		= 8,
+	DEVTC_wdh_m		= 0x00000700,
+	DEVTC_csh_b		= 11,
+	DEVTC_csh_m		= 0x00001800,
+
+	BTCS_tt_b		= 0,
+	BTCS_tt_m		= 0x00000001,
+		BTCS_tt_write		= 0,	
+		BTCS_tt_read		= 1,	
+	BTCS_bto_b		= 1,		// In btcs
+	BTCS_bto_m		= 0x00000002,	// In btcs
+	BTCS_bte_b		= 2,		// In btcs
+	BTCS_bte_m		= 0x00000004,	// In btcs
+
+	BTCOMPARE_compare_b	= 0,		// In btcompare
+	BTCOMPARE_compare_m	= 0x0000ffff,	// In btcompare
+
+	DEVDACS_op_b		= 0,		// In devdacs
+	DEVDACS_op_m		= 0x00000001,	// In devdacs
+		DEVDACS_op_write_v		= 0,
+		DEVDACS_op_read_v		= 1,
+	DEVDACS_size_b		= 1,		// In devdacs
+	DEVDACS_size_m		= 0x00000006,	// In devdacs
+		DEVDACS_size_byte_v		= 0,
+		DEVDACS_size_halfword	= 1,
+		DEVDACS_size_triplebyte	= 2,
+		DEVDACS_size_word		= 3,
+	DEVDACS_err_b		= 3,		// In devdacs
+	DEVDACS_err_m		= 0x00000008,	// In devdacs
+	DEVDACS_f_b		= 4,		// In devdacs
+	DEVDACS_f_m		= 0x00000010,	// In devdacs
+} ;
+
+#endif	//__IDT_DEV_H__
+
diff -urN linux.old/include/asm-mips/rc32434/dma.h linux.dev/include/asm-mips/rc32434/dma.h
--- linux.old/include/asm-mips/rc32434/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/dma.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,202 @@
+#ifndef __IDT_DMA_H__
+#define __IDT_DMA_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * DMA register definition.
+ *
+ * File   : $Id: dma.h,v 1.3 2002/06/06 18:34:03 astichte Exp $
+ *
+ * Author : ryan.holmQVist@idt.com
+ * Date   : 20011005
+ * Update :
+ *	    $Log: dma.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:03  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/05 18:30:46  astichte
+ *	    Removed IDTField
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:21  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h> 
+enum
+{
+	DMA0_PhysicalAddress	= 0x18040000,
+	DMA_PhysicalAddress	= DMA0_PhysicalAddress,		// Default
+
+	DMA0_VirtualAddress	= 0xb8040000,
+	DMA_VirtualAddress	= DMA0_VirtualAddress,		// Default
+} ;
+
+/*
+ * DMA descriptor (in physical memory).
+ */
+
+typedef struct DMAD_s
+{
+	U32			control ;	// Control. use DMAD_*
+	U32			ca ;		// Current Address.
+	U32			devcs ; 	// Device control and status.
+	U32			link ;		// Next descriptor in chain.
+} volatile *DMAD_t ;
+
+enum
+{
+	DMAD_size		= sizeof (struct DMAD_s),
+	DMAD_count_b		= 0,		// in DMAD_t -> control
+	DMAD_count_m		= 0x0003ffff,	// in DMAD_t -> control
+	DMAD_ds_b		= 20,		// in DMAD_t -> control
+	DMAD_ds_m		= 0x00300000,	// in DMAD_t -> control
+		DMAD_ds_ethRcv_v	= 0,
+		DMAD_ds_ethXmt_v	= 0,
+		DMAD_ds_memToFifo_v	= 0,
+		DMAD_ds_fifoToMem_v	= 0,
+		DMAD_ds_pciToMem_v	= 0,
+		DMAD_ds_memToPci_v	= 0,
+	
+	DMAD_devcmd_b		= 22,		// in DMAD_t -> control
+	DMAD_devcmd_m		= 0x01c00000,	// in DMAD_t -> control
+		DMAD_devcmd_byte_v	= 0,	//memory-to-memory
+		DMAD_devcmd_halfword_v	= 1,	//memory-to-memory
+		DMAD_devcmd_word_v	= 2,	//memory-to-memory
+		DMAD_devcmd_2words_v	= 3,	//memory-to-memory
+		DMAD_devcmd_4words_v	= 4,	//memory-to-memory
+		DMAD_devcmd_6words_v	= 5,	//memory-to-memory
+		DMAD_devcmd_8words_v	= 6,	//memory-to-memory
+		DMAD_devcmd_16words_v	= 7,	//memory-to-memory
+	DMAD_cof_b		= 25,		// chain on finished
+	DMAD_cof_m		= 0x02000000,	// 
+	DMAD_cod_b		= 26,		// chain on done
+	DMAD_cod_m		= 0x04000000,	// 
+	DMAD_iof_b		= 27,		// interrupt on finished
+	DMAD_iof_m		= 0x08000000,	// 
+	DMAD_iod_b		= 28,		// interrupt on done
+	DMAD_iod_m		= 0x10000000,	// 
+	DMAD_t_b		= 29,		// terminated
+	DMAD_t_m		= 0x20000000,	// 
+	DMAD_d_b		= 30,		// done
+	DMAD_d_m		= 0x40000000,	// 
+	DMAD_f_b		= 31,		// finished
+	DMAD_f_m		= 0x80000000,	// 
+} ;
+
+/*
+ * DMA register (within Internal Register Map).
+ */
+
+struct DMA_Chan_s
+{
+	U32		dmac ;		// Control.
+	U32		dmas ;		// Status.	
+	U32		dmasm ; 	// Mask.
+	U32		dmadptr ;	// Descriptor pointer.
+	U32		dmandptr ;	// Next descriptor pointer.
+};
+
+typedef struct DMA_Chan_s volatile *DMA_Chan_t ;
+
+//DMA_Channels	  use DMACH_count instead
+
+enum
+{
+	DMAC_run_b	= 0,		// 
+	DMAC_run_m	= 0x00000001,	// 
+	DMAC_dm_b	= 1,		// done mask
+	DMAC_dm_m	= 0x00000002,	// 
+	DMAC_mode_b	= 2,		// 
+	DMAC_mode_m	= 0x0000000c,	// 
+		DMAC_mode_auto_v	= 0,
+		DMAC_mode_burst_v	= 1,
+		DMAC_mode_transfer_v	= 2, //usually used
+		DMAC_mode_reserved_v	= 3,
+	DMAC_a_b	= 4,		// 
+	DMAC_a_m	= 0x00000010,	// 
+
+	DMAS_f_b	= 0,		// finished (sticky) 
+	DMAS_f_m	= 0x00000001,	//		     
+	DMAS_d_b	= 1,		// done (sticky)     
+	DMAS_d_m	= 0x00000002,	//		     
+	DMAS_c_b	= 2,		// chain (sticky)    
+	DMAS_c_m	= 0x00000004,	//		     
+	DMAS_e_b	= 3,		// error (sticky)    
+	DMAS_e_m	= 0x00000008,	//		     
+	DMAS_h_b	= 4,		// halt (sticky)     
+	DMAS_h_m	= 0x00000010,	//		     
+
+	DMASM_f_b	= 0,		// finished (1=mask)
+	DMASM_f_m	= 0x00000001,	// 
+	DMASM_d_b	= 1,		// done (1=mask)
+	DMASM_d_m	= 0x00000002,	// 
+	DMASM_c_b	= 2,		// chain (1=mask)
+	DMASM_c_m	= 0x00000004,	// 
+	DMASM_e_b	= 3,		// error (1=mask)
+	DMASM_e_m	= 0x00000008,	// 
+	DMASM_h_b	= 4,		// halt (1=mask)
+	DMASM_h_m	= 0x00000010,	// 
+} ;
+
+/*
+ * DMA channel definitions
+ */
+
+enum
+{
+	DMACH_ethRcv = 0,
+	DMACH_ethXmt = 1,
+	DMACH_memToFifo = 2,
+	DMACH_fifoToMem = 3,
+	DMACH_pciToMem = 4,
+	DMACH_memToPci = 5,
+	
+	DMACH_count //must be last
+};
+
+
+typedef struct DMAC_s
+{
+	struct DMA_Chan_s ch [DMACH_count] ; //use ch[DMACH_]
+} volatile *DMA_t ;
+
+
+/*
+ * External DMA parameters
+*/
+#if 0
+enum
+{
+	DMADEVCMD_ts_b	= 0,		// ts field in devcmd
+	DMADEVCMD_ts_m	= 0x00000007,	// ts field in devcmd
+		DMADEVCMD_ts_byte_v	= 0,
+		DMADEVCMD_ts_halfword_v	= 1,
+		DMADEVCMD_ts_word_v	= 2,
+		DMADEVCMD_ts_2word_v	= 3,
+		DMADEVCMD_ts_4word_v	= 4,
+		DMADEVCMD_ts_6word_v	= 5,
+		DMADEVCMD_ts_8word_v	= 6,
+		DMADEVCMD_ts_16word_v	= 7
+};
+#endif
+
+#if 1	// aws - Compatibility.
+#	define	EXTDMA_ts_b		DMADEVCMD_ts_b
+#	define	EXTDMA_ts_m		DMADEVCMD_ts_m
+#	define	EXTDMA_ts_byte_v	DMADEVCMD_ts_byte_v
+#	define	EXTDMA_ts_halfword_v	DMADEVCMD_ts_halfword_v
+#	define	EXTDMA_ts_word_v	DMADEVCMD_ts_word_v
+#	define	EXTDMA_ts_2word_v	DMADEVCMD_ts_2word_v
+#	define	EXTDMA_ts_4word_v	DMADEVCMD_ts_4word_v
+#	define	EXTDMA_ts_6word_v	DMADEVCMD_ts_6word_v
+#	define	EXTDMA_ts_8word_v	DMADEVCMD_ts_8word_v
+#	define	EXTDMA_ts_16word_v	DMADEVCMD_ts_16word_v
+#endif	// aws - Compatibility.
+
+#endif	// __IDT_DMA_H__
+
diff -urN linux.old/include/asm-mips/rc32434/dma_v.h linux.dev/include/asm-mips/rc32434/dma_v.h
--- linux.old/include/asm-mips/rc32434/dma_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/dma_v.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,73 @@
+#ifndef __IDT_DMA_V_H__
+#define __IDT_DMA_V_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * DMA register definition.
+ *
+ * File   : $Id: dma.h,v 1.3 2002/06/06 18:34:03 astichte Exp $
+ *
+ * Author : ryan.holmQVist@idt.com
+ * Date   : 20011005
+ * Update :
+ *	    $Log: dma.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:03  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/05 18:30:46  astichte
+ *	    Removed IDTField
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:21  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+#include  <asm/rc32434/types.h> 
+#include  <asm/rc32434/dma.h> 
+#include  <asm/rc32434/rc32434.h>
+#define DMA_CHAN_OFFSET  0x14
+#define IS_DMA_USED(X) (((X) & (DMAD_f_m | DMAD_d_m | DMAD_t_m)) != 0)
+#define DMA_COUNT(count)   \
+  ((count) & DMAD_count_m)
+
+#define DMA_HALT_TIMEOUT 500
+
+
+static inline int rc32434_halt_dma(DMA_Chan_t ch)
+{
+	int timeout=1;
+	if (local_readl(&ch->dmac) & DMAC_run_m) {
+		local_writel(0, &ch->dmac); 
+		for (timeout = DMA_HALT_TIMEOUT; timeout > 0; timeout--) {
+			if (local_readl(&ch->dmas) & DMAS_h_m) {
+				local_writel(0, &ch->dmas);  
+				break;
+			}
+		}
+	}
+
+	return timeout ? 0 : 1;
+}
+
+static inline void rc32434_start_dma(DMA_Chan_t ch, u32 dma_addr)
+{
+	local_writel(0, &ch->dmandptr); 
+	local_writel(dma_addr, &ch->dmadptr);
+}
+
+static inline void rc32434_chain_dma(DMA_Chan_t ch, u32 dma_addr)
+{
+	local_writel(dma_addr, &ch->dmandptr);
+}
+
+#endif	// __IDT_DMA_V_H__
+
+
+
+
+
+
+
diff -urN linux.old/include/asm-mips/rc32434/eth.h linux.dev/include/asm-mips/rc32434/eth.h
--- linux.old/include/asm-mips/rc32434/eth.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/eth.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,322 @@
+#ifndef	__IDT_ETH_H__
+#define	__IDT_ETH_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Ethernet register definition.
+ *
+ * File   : $Id: eth.h,v 1.3 2002/06/06 18:34:04 astichte Exp $
+ *
+ * Author : Allen.Stichter@idt.com
+ * Date   : 20020605
+ * Update :
+ *	    $Log: eth.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:04  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/05 18:19:46  astichte
+ *	    Added
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:22  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h> 
+
+enum
+{
+	ETH0_PhysicalAddress	= 0x18060000,
+	ETH_PhysicalAddress	= ETH0_PhysicalAddress,		// Default
+
+	ETH0_VirtualAddress	= 0xb8060000,
+	ETH_VirtualAddress	= ETH0_VirtualAddress,		// Default
+} ;
+
+typedef struct
+{
+	U32 ethintfc		;
+	U32 ethfifott		;
+	U32 etharc		;
+	U32 ethhash0		;
+	U32 ethhash1		;
+	U32 ethu0 [4]		;	// Reserved.	
+	U32 ethpfs		;
+	U32 ethmcp		;
+	U32 eth_u1 [10]		;	// Reserved.
+	U32 ethspare		;
+	U32 eth_u2 [42]		;	// Reserved. 
+	U32 ethsal0		;
+	U32 ethsah0		;
+	U32 ethsal1		;
+	U32 ethsah1		;
+	U32 ethsal2		;
+	U32 ethsah2		;
+	U32 ethsal3		;
+	U32 ethsah3		;
+	U32 ethrbc		;
+	U32 ethrpc		;
+	U32 ethrupc		;
+	U32 ethrfc		;
+	U32 ethtbc		;
+	U32 ethgpf		;
+	U32 eth_u9 [50]		;	// Reserved.	
+	U32 ethmac1		;
+	U32 ethmac2		;
+	U32 ethipgt		;
+	U32 ethipgr		;
+	U32 ethclrt		;
+	U32 ethmaxf		;
+	U32 eth_u10		;	// Reserved.	
+	U32 ethmtest		;
+	U32 miimcfg		;
+	U32 miimcmd		;
+	U32 miimaddr		;
+	U32 miimwtd		;
+	U32 miimrdd		;
+	U32 miimind		;
+	U32 eth_u11		;	// Reserved.
+	U32 eth_u12		;	// Reserved.
+	U32 ethcfsa0		;
+	U32 ethcfsa1		;
+	U32 ethcfsa2		;
+} volatile *ETH_t;
+
+enum
+{
+	ETHINTFC_en_b		= 0,
+	ETHINTFC_en_m		= 0x00000001,
+	ETHINTFC_its_b		= 1,
+	ETHINTFC_its_m		= 0x00000002,
+	ETHINTFC_rip_b		= 2,
+	ETHINTFC_rip_m		= 0x00000004,
+	ETHINTFC_jam_b		= 3,
+	ETHINTFC_jam_m		= 0x00000008,
+	ETHINTFC_ovr_b		= 4,
+	ETHINTFC_ovr_m		= 0x00000010,
+	ETHINTFC_und_b		= 5,
+	ETHINTFC_und_m		= 0x00000020,
+	ETHINTFC_iom_b 		= 6,
+	ETHINTFC_iom_m		= 0x000000c0,
+
+	ETHFIFOTT_tth_b		= 0,
+	ETHFIFOTT_tth_m		= 0x0000007f,
+
+	ETHARC_pro_b		= 0,
+	ETHARC_pro_m		= 0x00000001,
+	ETHARC_am_b		= 1,
+	ETHARC_am_m		= 0x00000002,
+	ETHARC_afm_b		= 2,
+	ETHARC_afm_m		= 0x00000004,
+	ETHARC_ab_b		= 3,
+	ETHARC_ab_m		= 0x00000008,
+
+	ETHSAL_byte5_b		= 0,
+	ETHSAL_byte5_m		= 0x000000ff,
+	ETHSAL_byte4_b		= 8,
+	ETHSAL_byte4_m		= 0x0000ff00,
+	ETHSAL_byte3_b		= 16,
+	ETHSAL_byte3_m		= 0x00ff0000,
+	ETHSAL_byte2_b		= 24,
+	ETHSAL_byte2_m		= 0xff000000,
+
+	ETHSAH_byte1_b		= 0,
+	ETHSAH_byte1_m		= 0x000000ff,
+	ETHSAH_byte0_b		= 8,
+	ETHSAH_byte0_m		= 0x0000ff00,
+	
+	ETHGPF_ptv_b		= 0,
+	ETHGPF_ptv_m		= 0x0000ffff,
+
+	ETHPFS_pfd_b		= 0,
+	ETHPFS_pfd_m		= 0x00000001,
+
+	ETHCFSA0_cfsa4_b	= 0,
+	ETHCFSA0_cfsa4_m	= 0x000000ff,
+	ETHCFSA0_cfsa5_b	= 8,
+	ETHCFSA0_cfsa5_m	= 0x0000ff00,
+
+	ETHCFSA1_cfsa2_b	= 0,
+	ETHCFSA1_cfsa2_m	= 0x000000ff,
+	ETHCFSA1_cfsa3_b	= 8,
+	ETHCFSA1_cfsa3_m	= 0x0000ff00,
+
+	ETHCFSA2_cfsa0_b	= 0,
+	ETHCFSA2_cfsa0_m	= 0x000000ff,
+	ETHCFSA2_cfsa1_b	= 8,
+	ETHCFSA2_cfsa1_m	= 0x0000ff00,
+
+	ETHMAC1_re_b		= 0,
+	ETHMAC1_re_m		= 0x00000001,
+	ETHMAC1_paf_b		= 1,
+	ETHMAC1_paf_m		= 0x00000002,
+	ETHMAC1_rfc_b		= 2,
+	ETHMAC1_rfc_m		= 0x00000004,
+	ETHMAC1_tfc_b		= 3,
+	ETHMAC1_tfc_m		= 0x00000008,
+	ETHMAC1_lb_b		= 4,
+	ETHMAC1_lb_m		= 0x00000010,
+	ETHMAC1_mr_b		= 31,
+	ETHMAC1_mr_m		= 0x80000000,
+
+	ETHMAC2_fd_b		= 0,
+	ETHMAC2_fd_m		= 0x00000001,
+	ETHMAC2_flc_b		= 1,
+	ETHMAC2_flc_m		= 0x00000002,
+	ETHMAC2_hfe_b		= 2,
+	ETHMAC2_hfe_m		= 0x00000004,
+	ETHMAC2_dc_b		= 3,
+	ETHMAC2_dc_m		= 0x00000008,
+	ETHMAC2_cen_b		= 4,
+	ETHMAC2_cen_m		= 0x00000010,
+	ETHMAC2_pe_b		= 5,
+	ETHMAC2_pe_m		= 0x00000020,
+	ETHMAC2_vpe_b		= 6,
+	ETHMAC2_vpe_m		= 0x00000040,
+	ETHMAC2_ape_b		= 7,
+	ETHMAC2_ape_m		= 0x00000080,
+	ETHMAC2_ppe_b		= 8,
+	ETHMAC2_ppe_m		= 0x00000100,
+	ETHMAC2_lpe_b		= 9,
+	ETHMAC2_lpe_m		= 0x00000200,
+	ETHMAC2_nb_b		= 12,
+	ETHMAC2_nb_m		= 0x00001000,
+	ETHMAC2_bp_b		= 13,
+	ETHMAC2_bp_m		= 0x00002000,
+	ETHMAC2_ed_b		= 14,
+	ETHMAC2_ed_m		= 0x00004000,
+
+	ETHIPGT_ipgt_b		= 0,
+	ETHIPGT_ipgt_m		= 0x0000007f,
+
+	ETHIPGR_ipgr2_b		= 0,
+	ETHIPGR_ipgr2_m		= 0x0000007f,
+	ETHIPGR_ipgr1_b		= 8,
+	ETHIPGR_ipgr1_m		= 0x00007f00,
+
+	ETHCLRT_maxret_b	= 0,
+	ETHCLRT_maxret_m	= 0x0000000f,
+	ETHCLRT_colwin_b	= 8,
+	ETHCLRT_colwin_m	= 0x00003f00,
+
+	ETHMAXF_maxf_b		= 0,
+	ETHMAXF_maxf_m		= 0x0000ffff,
+
+	ETHMTEST_tb_b		= 2,
+	ETHMTEST_tb_m		= 0x00000004,
+
+	ETHMCP_div_b		= 0,
+	ETHMCP_div_m		= 0x000000ff,
+	
+	MIIMCFG_rsv_b		= 0,
+	MIIMCFG_rsv_m		= 0x0000000c,
+
+	MIIMCMD_rd_b		= 0,
+	MIIMCMD_rd_m		= 0x00000001,
+	MIIMCMD_scn_b		= 1,
+	MIIMCMD_scn_m		= 0x00000002,
+
+	MIIMADDR_regaddr_b	= 0,
+	MIIMADDR_regaddr_m	= 0x0000001f,
+	MIIMADDR_phyaddr_b	= 8,
+	MIIMADDR_phyaddr_m	= 0x00001f00,
+
+	MIIMWTD_wdata_b		= 0,
+	MIIMWTD_wdata_m		= 0x0000ffff,
+
+	MIIMRDD_rdata_b		= 0,
+	MIIMRDD_rdata_m		= 0x0000ffff,
+
+	MIIMIND_bsy_b		= 0,
+	MIIMIND_bsy_m		= 0x00000001,
+	MIIMIND_scn_b		= 1,
+	MIIMIND_scn_m		= 0x00000002,
+	MIIMIND_nv_b		= 2,
+	MIIMIND_nv_m		= 0x00000004,
+
+} ;
+
+/*
+ * Values for the DEVCS field of the Ethernet DMA Rx and Tx descriptors.
+ */
+enum
+{
+	ETHRX_fd_b		= 0,
+	ETHRX_fd_m		= 0x00000001,
+	ETHRX_ld_b		= 1,
+	ETHRX_ld_m		= 0x00000002,
+	ETHRX_rok_b		= 2,
+	ETHRX_rok_m		= 0x00000004,
+	ETHRX_fm_b		= 3,
+	ETHRX_fm_m		= 0x00000008,
+	ETHRX_mp_b		= 4,
+	ETHRX_mp_m		= 0x00000010,
+	ETHRX_bp_b		= 5,
+	ETHRX_bp_m		= 0x00000020,
+	ETHRX_vlt_b		= 6,
+	ETHRX_vlt_m		= 0x00000040,
+	ETHRX_cf_b		= 7,
+	ETHRX_cf_m		= 0x00000080,
+	ETHRX_ovr_b		= 8,
+	ETHRX_ovr_m		= 0x00000100,
+	ETHRX_crc_b		= 9,
+	ETHRX_crc_m		= 0x00000200,
+	ETHRX_cv_b		= 10,
+	ETHRX_cv_m		= 0x00000400,
+	ETHRX_db_b		= 11,
+	ETHRX_db_m		= 0x00000800,
+	ETHRX_le_b		= 12,
+	ETHRX_le_m		= 0x00001000,
+	ETHRX_lor_b		= 13,
+	ETHRX_lor_m		= 0x00002000,
+	ETHRX_ces_b		= 14,
+	ETHRX_ces_m		= 0x00004000,
+	ETHRX_length_b		= 16,
+	ETHRX_length_m		= 0xffff0000,
+
+	ETHTX_fd_b		= 0,
+	ETHTX_fd_m		= 0x00000001,
+	ETHTX_ld_b		= 1,
+	ETHTX_ld_m		= 0x00000002,
+	ETHTX_oen_b		= 2,
+	ETHTX_oen_m		= 0x00000004,
+	ETHTX_pen_b		= 3,
+	ETHTX_pen_m		= 0x00000008,
+	ETHTX_cen_b		= 4,
+	ETHTX_cen_m		= 0x00000010,
+	ETHTX_hen_b		= 5,
+	ETHTX_hen_m		= 0x00000020,
+	ETHTX_tok_b		= 6,
+	ETHTX_tok_m		= 0x00000040,
+	ETHTX_mp_b		= 7,
+	ETHTX_mp_m		= 0x00000080,
+	ETHTX_bp_b		= 8,
+	ETHTX_bp_m		= 0x00000100,
+	ETHTX_und_b		= 9,
+	ETHTX_und_m		= 0x00000200,
+	ETHTX_of_b		= 10,
+	ETHTX_of_m		= 0x00000400,
+	ETHTX_ed_b		= 11,
+	ETHTX_ed_m		= 0x00000800,
+	ETHTX_ec_b		= 12,
+	ETHTX_ec_m		= 0x00001000,
+	ETHTX_lc_b		= 13,
+	ETHTX_lc_m		= 0x00002000,
+	ETHTX_td_b		= 14,
+	ETHTX_td_m		= 0x00004000,
+	ETHTX_crc_b		= 15,
+	ETHTX_crc_m		= 0x00008000,
+	ETHTX_le_b		= 16,
+	ETHTX_le_m		= 0x00010000,
+	ETHTX_cc_b		= 17,
+	ETHTX_cc_m		= 0x001E0000,
+} ;
+
+#endif	// __IDT_ETH_H__
+
+
+
+
diff -urN linux.old/include/asm-mips/rc32434/eth_v.h linux.dev/include/asm-mips/rc32434/eth_v.h
--- linux.old/include/asm-mips/rc32434/eth_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/eth_v.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,64 @@
+#ifndef	__IDT_ETH_V_H__
+#define	__IDT_ETH_V_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Ethernet register definition.
+ *
+ * File   : $Id: eth.h,v 1.3 2002/06/06 18:34:04 astichte Exp $
+ *
+ * Author : Allen.Stichter@idt.com
+ * Date   : 20020605
+ * Update :
+ *	    $Log: eth.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:04  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/05 18:19:46  astichte
+ *	    Added
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:22  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h> 
+#include  <asm/rc32434/eth.h> 
+
+#define IS_TX_TOK(X)         (((X) & (1<<ETHTX_tok_b)) >> ETHTX_tok_b )   /* Transmit Okay    */
+#define IS_TX_MP(X)          (((X) & (1<<ETHTX_mp_b))  >> ETHTX_mp_b )    /* Multicast        */
+#define IS_TX_BP(X)          (((X) & (1<<ETHTX_bp_b))  >> ETHTX_bp_b )    /* Broadcast        */
+#define IS_TX_UND_ERR(X)     (((X) & (1<<ETHTX_und_b)) >> ETHTX_und_b )   /* Transmit FIFO Underflow */
+#define IS_TX_OF_ERR(X)      (((X) & (1<<ETHTX_of_b))  >> ETHTX_of_b )    /* Oversized frame  */
+#define IS_TX_ED_ERR(X)      (((X) & (1<<ETHTX_ed_b))  >> ETHTX_ed_b )    /* Excessive deferral  */
+#define IS_TX_EC_ERR(X)      (((X) & (1<<ETHTX_ec_b))  >> ETHTX_ec_b)     /* Excessive collisions  */
+#define IS_TX_LC_ERR(X)      (((X) & (1<<ETHTX_lc_b))  >> ETHTX_lc_b )    /* Late Collision   */
+#define IS_TX_TD_ERR(X)      (((X) & (1<<ETHTX_td_b))  >> ETHTX_td_b )    /* Transmit deferred*/
+#define IS_TX_CRC_ERR(X)     (((X) & (1<<ETHTX_crc_b)) >> ETHTX_crc_b )   /* CRC Error        */
+#define IS_TX_LE_ERR(X)      (((X) & (1<<ETHTX_le_b))  >>  ETHTX_le_b )    /* Length Error     */
+
+#define TX_COLLISION_COUNT(X) (((X) & ETHTX_cc_m)>>ETHTX_cc_b)  /* Collision Count  */
+
+#define IS_RCV_ROK(X)        (((X) & (1<<ETHRX_rok_b)) >> ETHRX_rok_b)    /* Receive Okay     */
+#define IS_RCV_FM(X)         (((X) & (1<<ETHRX_fm_b))  >> ETHRX_fm_b)     /* Is Filter Match  */
+#define IS_RCV_MP(X)         (((X) & (1<<ETHRX_mp_b))  >> ETHRX_mp_b)     /* Is it MP         */
+#define IS_RCV_BP(X)         (((X) & (1<<ETHRX_bp_b))  >> ETHRX_bp_b)     /* Is it BP         */
+#define IS_RCV_VLT(X)        (((X) & (1<<ETHRX_vlt_b)) >> ETHRX_vlt_b)    /* VLAN Tag Detect  */
+#define IS_RCV_CF(X)         (((X) & (1<<ETHRX_cf_b))  >> ETHRX_cf_b)     /* Control Frame    */
+#define IS_RCV_OVR_ERR(X)    (((X) & (1<<ETHRX_ovr_b)) >> ETHRX_ovr_b)    /* Receive Overflow */
+#define IS_RCV_CRC_ERR(X)    (((X) & (1<<ETHRX_crc_b)) >> ETHRX_crc_b)    /* CRC Error        */
+#define IS_RCV_CV_ERR(X)     (((X) & (1<<ETHRX_cv_b))  >> ETHRX_cv_b)     /* Code Violation   */
+#define IS_RCV_DB_ERR(X)     (((X) & (1<<ETHRX_db_b))  >> ETHRX_db_b)     /* Dribble Bits     */
+#define IS_RCV_LE_ERR(X)     (((X) & (1<<ETHRX_le_b))  >> ETHRX_le_b)     /* Length error     */
+#define IS_RCV_LOR_ERR(X)    (((X) & (1<<ETHRX_lor_b)) >> ETHRX_lor_b)    /* Length Out of Range */
+#define IS_RCV_CES_ERR(X)    (((X) & (1<<ETHRX_ces_b)) >> ETHRX_ces_b)  /* Preamble error   */
+#define RCVPKT_LENGTH(X)     (((X) & ETHRX_length_m) >> ETHRX_length_b)   /* Length of the received packet */
+#endif	// __IDT_ETH_V_H__
+
+
+
+
+
diff -urN linux.old/include/asm-mips/rc32434/gpio.h linux.dev/include/asm-mips/rc32434/gpio.h
--- linux.old/include/asm-mips/rc32434/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/gpio.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,182 @@
+#ifndef __IDT_GPIO_H__
+#define __IDT_GPIO_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * GPIO register definition.
+ *
+ * File   : $Id: gpio.h,v 1.2 2002/06/06 18:34:04 astichte Exp $
+ *
+ * Author : ryan.holmQVist@idt.com
+ * Date   : 20011005
+ * Update :
+ *	    $Log: gpio.h,v $
+ *	    Revision 1.2  2002/06/06 18:34:04  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:22  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h> 
+enum
+{
+	GPIO0_PhysicalAddress	= 0x18050000,
+	GPIO_PhysicalAddress	= GPIO0_PhysicalAddress,	// Default
+
+	GPIO0_VirtualAddress	= 0xb8050000,
+	GPIO_VirtualAddress	= GPIO0_VirtualAddress,		// Default
+} ;
+
+typedef struct
+{
+	U32   gpiofunc;   /* GPIO Function Register
+			   * gpiofunc[x]==0 bit = gpio
+			   * func[x]==1  bit = altfunc
+			   */
+	U32   gpiocfg;	  /* GPIO Configuration Register
+			   * gpiocfg[x]==0 bit = input
+			   * gpiocfg[x]==1 bit = output
+			   */
+	U32   gpiod;	  /* GPIO Data Register
+			   * gpiod[x] read/write gpio pinX status
+			   */
+	U32   gpioilevel; /* GPIO Interrupt Status Register
+			   * interrupt level (see gpioistat)
+			   */
+	U32   gpioistat;  /* Gpio Interrupt Status Register
+			   * istat[x] = (gpiod[x] == level[x])
+			   * cleared in ISR (STICKY bits)
+			   */
+	U32   gpionmien;  /* GPIO Non-maskable Interrupt Enable Register */
+} volatile * GPIO_t ;
+
+typedef enum
+{
+	GPIO_gpio_v		= 0,		// gpiofunc use pin as GPIO.
+	GPIO_alt_v		= 1,		// gpiofunc use pin as alt.
+	GPIO_input_v		= 0,		// gpiocfg use pin as input.
+	GPIO_output_v		= 1,		// gpiocfg use pin as output.
+	GPIO_pin0_b		= 0,
+	GPIO_pin0_m		= 0x00000001,
+	GPIO_pin1_b		= 1,
+	GPIO_pin1_m		= 0x00000002,
+	GPIO_pin2_b		= 2,
+	GPIO_pin2_m		= 0x00000004,
+	GPIO_pin3_b		= 3,
+	GPIO_pin3_m		= 0x00000008,
+	GPIO_pin4_b		= 4,
+	GPIO_pin4_m		= 0x00000010,
+	GPIO_pin5_b		= 5,
+	GPIO_pin5_m		= 0x00000020,
+	GPIO_pin6_b		= 6,
+	GPIO_pin6_m		= 0x00000040,
+	GPIO_pin7_b		= 7,
+	GPIO_pin7_m		= 0x00000080,
+	GPIO_pin8_b		= 8,
+	GPIO_pin8_m		= 0x00000100,
+	GPIO_pin9_b		= 9,
+	GPIO_pin9_m		= 0x00000200,
+	GPIO_pin10_b		= 10,
+	GPIO_pin10_m		= 0x00000400,
+	GPIO_pin11_b		= 11,
+	GPIO_pin11_m		= 0x00000800,
+	GPIO_pin12_b		= 12,
+	GPIO_pin12_m		= 0x00001000,
+	GPIO_pin13_b		= 13,
+	GPIO_pin13_m		= 0x00002000,
+	GPIO_pin14_b		= 14,
+	GPIO_pin14_m		= 0x00004000,
+	GPIO_pin15_b		= 15,
+	GPIO_pin15_m		= 0x00008000,
+	GPIO_pin16_b		= 16,
+	GPIO_pin16_m		= 0x00010000,
+	GPIO_pin17_b		= 17,
+	GPIO_pin17_m		= 0x00020000,
+	GPIO_pin18_b		= 18,
+	GPIO_pin18_m		= 0x00040000,
+	GPIO_pin19_b		= 19,
+	GPIO_pin19_m		= 0x00080000,
+	GPIO_pin20_b		= 20,
+	GPIO_pin20_m		= 0x00100000,
+	GPIO_pin21_b		= 21,
+	GPIO_pin21_m		= 0x00200000,
+	GPIO_pin22_b		= 22,
+	GPIO_pin22_m		= 0x00400000,
+	GPIO_pin23_b		= 23,
+	GPIO_pin23_m		= 0x00800000,
+	GPIO_pin24_b		= 24,
+	GPIO_pin24_m		= 0x01000000,
+	GPIO_pin25_b		= 25,
+	GPIO_pin25_m		= 0x02000000,
+	GPIO_pin26_b		= 26,
+	GPIO_pin26_m		= 0x04000000,
+	GPIO_pin27_b		= 27,
+	GPIO_pin27_m		= 0x08000000,
+	GPIO_pin28_b		= 28,
+	GPIO_pin28_m		= 0x10000000,
+	GPIO_pin29_b		= 29,
+	GPIO_pin29_m		= 0x20000000,
+	GPIO_pin30_b		= 30,
+	GPIO_pin30_m		= 0x40000000,
+	GPIO_pin31_b		= 31,
+	GPIO_pin31_m		= 0x80000000,
+
+// Alternate function pins.  Corrsponding gpiofunc bit set to GPIO_alt_v.
+
+	GPIO_u0sout_b		= GPIO_pin0_b,		// UART 0 serial out.
+	GPIO_u0sout_m		= GPIO_pin0_m,
+		GPIO_u0sout_cfg_v	= GPIO_output_v,
+	GPIO_u0sinp_b	= GPIO_pin1_b,			// UART 0 serial in.
+	GPIO_u0sinp_m	= GPIO_pin1_m,
+		GPIO_u0sinp_cfg_v	= GPIO_input_v,
+	GPIO_u0rtsn_b	= GPIO_pin2_b,			// UART 0 req. to send.
+	GPIO_u0rtsn_m	= GPIO_pin2_m,
+		GPIO_u0rtsn_cfg_v	= GPIO_output_v,
+	GPIO_u0ctsn_b	= GPIO_pin3_b,			// UART 0 clear to send.
+	GPIO_u0ctsn_m	= GPIO_pin3_m,
+		GPIO_u0ctsn_cfg_v	= GPIO_input_v,
+	GPIO_maddr22_b		= GPIO_pin4_b, 	// M&P bus bit 22.
+	GPIO_maddr22_m		= GPIO_pin4_m,
+		GPIO_maddr22_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr23_b		= GPIO_pin5_b, 	// M&P bus bit 23.
+	GPIO_maddr23_m		= GPIO_pin5_m,
+		GPIO_maddr23_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr24_b		= GPIO_pin6_b, 	// M&P bus bit 24.
+	GPIO_maddr24_m		= GPIO_pin6_m,
+		GPIO_maddr24_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr25_b		= GPIO_pin7_b, 	// M&P bus bit 25.
+	GPIO_maddr25_m		= GPIO_pin7_m,
+		GPIO_maddr25_cfg_v	= GPIO_output_v,
+
+	GPIO_cpu_b		= GPIO_pin8_b, 	// M&P bus bit 25.
+	GPIO_cpu_m		= GPIO_pin8_m,
+		GPIO_cpu_cfg_v	= GPIO_output_v,
+	GPIO_afspare6_b 	= GPIO_pin9_b, 	// reserved.
+	GPIO_afspare6_m 	= GPIO_pin9_m,
+		GPIO_afspare6_cfg_v	= GPIO_input_v,
+	GPIO_afspare4_b 	= GPIO_pin10_b, 	// reserved.
+	GPIO_afspare4_m 	= GPIO_pin10_m,
+		GPIO_afspare4_cfg_v	= GPIO_input_v,
+	GPIO_afspare3_b 	= GPIO_pin11_b, 	// reserved.
+	GPIO_afspare3_m 	= GPIO_pin11_m,
+		GPIO_afspare3_cfg_v	= GPIO_input_v,
+	GPIO_afspare2_b 	= GPIO_pin12_b, 	// reserved.
+	GPIO_afspare2_m 	= GPIO_pin12_m,
+		GPIO_afspare2_cfg_v	= GPIO_input_v,
+	GPIO_pcimuintn_b	= GPIO_pin13_b, 	// PCI messaging int.
+	GPIO_pcimuintn_m	= GPIO_pin13_m,
+		GPIO_pcimuintn_cfg_v	= GPIO_output_v,
+
+} GPIO_DEFS_t;
+
+#endif	// __IDT_GPIO_H__
+
diff -urN linux.old/include/asm-mips/rc32434/i2c.h linux.dev/include/asm-mips/rc32434/i2c.h
--- linux.old/include/asm-mips/rc32434/i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/i2c.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,147 @@
+#ifndef __IDT_I2C_H__
+#define __IDT_I2C_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * I2C register definitions.
+ *
+ * File   : $Id: i2c.h,v 1.2 2002/06/06 18:34:04 astichte Exp $
+ *
+ * Author : Allen.Stichter@idt.com
+ * Date   : 20020120
+ * Update :
+ *	    $Log: i2c.h,v $
+ *	    Revision 1.2  2002/06/06 18:34:04  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:22  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h>
+
+enum
+{
+	I2C0_PhysicalAddress	= 0x18068000,
+	I2C_PhysicalAddress	= I2C0_PhysicalAddress,
+
+	I2C0_VirtualAddress	= 0xb8068000,
+	I2C_VirtualAddress	= I2C0_VirtualAddress,
+} ;
+
+typedef struct 
+{
+	U32	i2cc ;
+	U32	i2cdi ;
+	U32	i2cdo ;
+	U32	i2ccp ;		// I2C clk = ICLK / div / 8
+	U32	i2cmcmd ;
+	U32	i2cms ;
+	U32	i2cmsm ;
+	U32	i2css ;
+	U32	i2cssm ;
+	U32	i2csaddr ;
+	U32	i2csack ;
+} volatile * I2C_t ;
+enum
+{
+	I2CC_men_b	= 0,		// In I2C-> i2cc
+	I2CC_men_m	= 0x00000001,
+	I2CC_sen_b	= 1,		// In I2C-> i2cc
+	I2CC_sen_m	= 0x00000002,
+	I2CC_iom_b	= 2,		// In I2C-> i2cc
+	I2CC_iom_m	= 0x00000004,
+
+	I2CDI_data_b	= 0,		// In I2C-> i2cdi
+	I2CDI_data_m	= 0x000000ff,
+
+	I2CDO_data_b	= 0,		// In I2C-> i2cdo
+	I2CDO_data_m	= 0x000000ff,
+
+	I2CCP_div_b	= 0,		// In I2C-> i2ccp
+	I2CCP_div_m	= 0x0000ffff,
+
+	I2CMCMD_cmd_b	= 0,		// In I2C-> i2cmcmd
+	I2CMCMD_cmd_m	= 0x0000000f,
+		I2CMCMD_cmd_nop_v	= 0,
+		I2CMCMD_cmd_start_v	= 1,
+		I2CMCMD_cmd_stop_v	= 2,
+		I2CMCMD_cmd_res3_v	= 3,
+		I2CMCMD_cmd_rd_v	= 4,
+		I2CMCMD_cmd_rdack_v	= 5,
+		I2CMCMD_cmd_wd_v	= 6,
+		I2CMCMD_cmd_wdack_v	= 7,
+		I2CMCMD_cmd_res8_v	= 8,
+		I2CMCMD_cmd_res9_v	= 9,
+		I2CMCMD_cmd_res10_v	= 10,
+		I2CMCMD_cmd_res11_v	= 11,
+		I2CMCMD_cmd_res12_v	= 12,
+		I2CMCMD_cmd_res13_v	= 13,
+		I2CMCMD_cmd_res14_v	= 14,
+		I2CMCMD_cmd_res15_v	= 15,
+
+	I2CMS_d_b	= 0,		// In I2C-> i2cms
+	I2CMS_d_m	= 0x00000001,
+	I2CMS_na_b	= 1,		// In I2C-> i2cms
+	I2CMS_na_m	= 0x00000002,
+	I2CMS_la_b	= 2,		// In I2C-> i2cms
+	I2CMS_la_m	= 0x00000004,
+	I2CMS_err_b	= 3,		// In I2C-> i2cms
+	I2CMS_err_m	= 0x00000008,
+
+	I2CMSM_d_b	= 0,		// In I2C-> i2cmsm
+	I2CMSM_d_m	= 0x00000001,
+	I2CMSM_na_b	= 1,		// In I2C-> i2cmsm
+	I2CMSM_na_m	= 0x00000002,
+	I2CMSM_la_b	= 2,		// In I2C-> i2cmsm
+	I2CMSM_la_m	= 0x00000004,
+	I2CMSM_err_b	= 3,		// In I2C-> i2cmsm
+	I2CMSM_err_m	= 0x00000008,
+
+	I2CSS_rr_b	= 0,		// In I2C-> i2css
+	I2CSS_rr_m	= 0x00000001,
+	I2CSS_wr_b	= 1,		// In I2C-> i2css
+	I2CSS_wr_m	= 0x00000002,
+	I2CSS_sa_b	= 2,		// In I2C-> i2css
+	I2CSS_sa_m	= 0x00000004,
+	I2CSS_tf_b	= 3,		// In I2C-> i2css
+	I2CSS_tf_m	= 0x00000008,
+	I2CSS_gc_b	= 4,		// In I2C-> i2css
+	I2CSS_gc_m	= 0x00000010,
+	I2CSS_na_b	= 5,		// In I2C-> i2css
+	I2CSS_na_m	= 0x00000020,
+	I2CSS_err_b	= 6,		// In I2C-> i2css
+	I2CSS_err_m	= 0x00000040,
+
+	I2CSSM_rr_b	= 0,		// In I2C-> i2cssm
+	I2CSSM_rr_m	= 0x00000001,
+	I2CSSM_wr_b	= 1,		// In I2C-> i2cssm
+	I2CSSM_wr_m	= 0x00000002,
+	I2CSSM_sa_b	= 2,		// In I2C-> i2cssm
+	I2CSSM_sa_m	= 0x00000004,
+	I2CSSM_tf_b	= 3,		// In I2C-> i2cssm
+	I2CSSM_tf_m	= 0x00000008,
+	I2CSSM_gc_b	= 4,		// In I2C-> i2cssm
+	I2CSSM_gc_m	= 0x00000010,
+	I2CSSM_na_b	= 5,		// In I2C-> i2cssm
+	I2CSSM_na_m	= 0x00000020,
+	I2CSSM_err_b	= 6,		// In I2C-> i2cssm
+	I2CSSM_err_m	= 0x00000040,
+
+	I2CSADDR_addr_b	= 0,		// In I2C-> i2csaddr
+	I2CSADDR_addr_m	= 0x000003ff,
+	I2CSADDR_a_gc_b	= 10,		// In I2C-> i2csaddr
+	I2CSADDR_a_gc_m	= 0x00000400,
+	I2CSADDR_a10_b	= 11,		// In I2C-> i2csaddr
+	I2CSADDR_a10_m	= 0x00000800,
+
+	I2CSACK_ack_b	= 0,		// In I2C-> i2csack
+	I2CSACK_ack_m	= 0x00000001,
+
+} ;
+#endif	// __IDT_I2C_H__
diff -urN linux.old/include/asm-mips/rc32434/integ.h linux.dev/include/asm-mips/rc32434/integ.h
--- linux.old/include/asm-mips/rc32434/integ.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/integ.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,78 @@
+#ifndef __IDT_INTEG_H__
+#define __IDT_INTEG_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * System Integrity register definition.
+ *
+ * File   : $Id: integ.h,v 1.3 2002/06/06 18:34:04 astichte Exp $
+ *
+ * Author : ryan.holmQVist@idt.com
+ * Date   : 20011005
+ * Update :
+ *	    $Log: integ.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:04  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/05 18:32:33  astichte
+ *	    Removed IDTField
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:22  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h>
+
+enum
+{
+	INTEG0_PhysicalAddress	= 0x18030000,
+	INTEG_PhysicalAddress	= INTEG0_PhysicalAddress,	// Default
+
+	INTEG0_VirtualAddress	= 0xb8030000,
+	INTEG_VirtualAddress	= INTEG0_VirtualAddress,	// Default
+} ;
+
+// if you are looing for CEA, try rst.h
+typedef struct
+{
+	U32 filler [0xc] ;		// 0x30 bytes unused.
+	U32 errcs ;			// sticky use ERRCS_
+	U32 wtcount ;			// Watchdog timer count reg.
+	U32 wtcompare ;			// Watchdog timer timeout value.
+	U32 wtc ;			// Watchdog timer control. use WTC_
+} volatile *INTEG_t ;
+
+enum
+{
+	ERRCS_wto_b		= 0,		// In INTEG_t -> errcs
+	ERRCS_wto_m		= 0x00000001,
+	ERRCS_wne_b		= 1,		// In INTEG_t -> errcs
+	ERRCS_wne_m		= 0x00000002,
+	ERRCS_ucw_b		= 2,		// In INTEG_t -> errcs
+	ERRCS_ucw_m		= 0x00000004,
+	ERRCS_ucr_b		= 3,		// In INTEG_t -> errcs
+	ERRCS_ucr_m		= 0x00000008,
+	ERRCS_upw_b		= 4,		// In INTEG_t -> errcs
+	ERRCS_upw_m		= 0x00000010,
+	ERRCS_upr_b		= 5,		// In INTEG_t -> errcs
+	ERRCS_upr_m		= 0x00000020,
+	ERRCS_udw_b		= 6,		// In INTEG_t -> errcs
+	ERRCS_udw_m		= 0x00000040,
+	ERRCS_udr_b		= 7,		// In INTEG_t -> errcs
+	ERRCS_udr_m		= 0x00000080,
+	ERRCS_sae_b		= 8,		// In INTEG_t -> errcs
+	ERRCS_sae_m		= 0x00000100,
+	ERRCS_wre_b		= 9,		// In INTEG_t -> errcs
+	ERRCS_wre_m		= 0x00000200,
+
+	WTC_en_b		= 0,		// In INTEG_t -> wtc
+	WTC_en_m		= 0x00000001,
+	WTC_to_b		= 1,		// In INTEG_t -> wtc
+	WTC_to_m		= 0x00000002,
+} ;
+
+#endif	// __IDT_INTEG_H__
diff -urN linux.old/include/asm-mips/rc32434/int.h linux.dev/include/asm-mips/rc32434/int.h
--- linux.old/include/asm-mips/rc32434/int.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/int.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,167 @@
+#ifndef __IDT_INT_H__
+#define __IDT_INT_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Interrupt Controller register definition.
+ *
+ * File   : $Id: int.h,v 1.3 2002/06/06 18:34:04 astichte Exp $
+ *
+ * Author : ryan.holmqvist@idt.com
+ * Date   : 20011005
+ * Update :
+ *	    $Log: int.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:04  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/05 18:47:33  astichte
+ *	    Removed IDTField
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:22  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h> 
+
+enum
+{
+	INT0_PhysicalAddress	= 0x18038000,
+	INT_PhysicalAddress	= INT0_PhysicalAddress,		// Default
+
+	INT0_VirtualAddress	= 0xb8038000,
+	INT_VirtualAddress	= INT0_VirtualAddress,		// Default
+} ;
+
+struct INT_s
+{
+	U32		ipend ;		//Pending interrupts. use INT?_
+	U32		itest ;		//Test bits.		use INT?_
+	U32		imask ;		//Interrupt disabled when set. use INT?_
+} ;
+
+enum
+{
+	IPEND2	= 0,			// HW 2 interrupt to core. use INT2_
+	IPEND3	= 1,			// HW 3 interrupt to core. use INT3_
+	IPEND4	= 2,			// HW 4 interrupt to core. use INT4_
+	IPEND5	= 3,			// HW 5 interrupt to core. use INT5_
+	IPEND6	= 4,			// HW 6 interrupt to core. use INT6_
+
+	IPEND_count,			// must be last (used in loops)
+	IPEND_min	= IPEND2	// min IPEND (used in loops)
+};
+
+typedef struct INTC_s
+{
+	struct INT_s	i [IPEND_count] ;// use i[IPEND?] = INT?_
+	U32		nmips ;		// use NMIPS_
+} volatile *INT_t ;
+
+enum
+{
+	INT2_timer0_b			= 0,
+	INT2_timer0_m			= 0x00000001,
+	INT2_timer1_b			= 1,
+	INT2_timer1_m			= 0x00000002,
+	INT2_timer2_b			= 2,
+	INT2_timer2_m			= 0x00000004,
+	INT2_refresh_b			= 3,
+	INT2_refresh_m			= 0x00000008,
+	INT2_watchdogTimeout_b		= 4,
+	INT2_watchdogTimeout_m		= 0x00000010,
+	INT2_undecodedCpuWrite_b	= 5,
+	INT2_undecodedCpuWrite_m	= 0x00000020,
+	INT2_undecodedCpuRead_b		= 6,
+	INT2_undecodedCpuRead_m		= 0x00000040,
+	INT2_undecodedPciWrite_b	= 7,
+	INT2_undecodedPciWrite_m	= 0x00000080,
+	INT2_undecodedPciRead_b		= 8,
+	INT2_undecodedPciRead_m		= 0x00000100,
+	INT2_undecodedDmaWrite_b	= 9,
+	INT2_undecodedDmaWrite_m	= 0x00000200,
+	INT2_undecodedDmaRead_b		= 10,
+	INT2_undecodedDmaRead_m		= 0x00000400,
+	INT2_ipBusSlaveAckError_b	= 11,
+	INT2_ipBusSlaveAckError_m	= 0x00000800,
+
+	INT3_dmaChannel0_b		= 0,
+	INT3_dmaChannel0_m		= 0x00000001,
+	INT3_dmaChannel1_b		= 1,
+	INT3_dmaChannel1_m		= 0x00000002,
+	INT3_dmaChannel2_b		= 2,
+	INT3_dmaChannel2_m		= 0x00000004,
+	INT3_dmaChannel3_b		= 3,
+	INT3_dmaChannel3_m		= 0x00000008,
+	INT3_dmaChannel4_b		= 4,
+	INT3_dmaChannel4_m		= 0x00000010,
+	INT3_dmaChannel5_b		= 5,
+	INT3_dmaChannel5_m		= 0x00000020,
+
+	INT5_uartGeneral0_b		= 0,
+	INT5_uartGeneral0_m		= 0x00000001,
+	INT5_uartTxrdy0_b		= 1,
+	INT5_uartTxrdy0_m		= 0x00000002,
+	INT5_uartRxrdy0_b		= 2,
+	INT5_uartRxrdy0_m		= 0x00000004,
+	INT5_pci_b			= 3,
+	INT5_pci_m			= 0x00000008,
+	INT5_pciDecoupled_b		= 4,
+	INT5_pciDecoupled_m		= 0x00000010,
+	INT5_spi_b			= 5,
+	INT5_spi_m			= 0x00000020,
+	INT5_deviceDecoupled_b		= 6,
+	INT5_deviceDecoupled_m		= 0x00000040,
+	INT5_i2cMaster_b		= 7,
+	INT5_i2cMaster_m		= 0x00000080,
+	INT5_i2cSlave_b			= 8,
+	INT5_i2cSlave_m			= 0x00000100,
+	INT5_ethOvr_b			= 9,
+	INT5_ethOvr_m			= 0x00000200,
+	INT5_ethUnd_b			= 10,
+	INT5_ethUnd_m			= 0x00000400,
+	INT5_ethPfd_b			= 11,
+	INT5_ethPfd_m			= 0x00000800,
+	INT5_nvram_b			= 12,
+	INT5_nvram_m			= 0x00001000,
+	
+	INT6_gpio0_b			= 0,
+	INT6_gpio0_m			= 0x00000001,
+	INT6_gpio1_b			= 1,
+	INT6_gpio1_m			= 0x00000002,
+	INT6_gpio2_b			= 2,
+	INT6_gpio2_m			= 0x00000004,
+	INT6_gpio3_b			= 3,
+	INT6_gpio3_m			= 0x00000008,
+	INT6_gpio4_b			= 4,
+	INT6_gpio4_m			= 0x00000010,
+	INT6_gpio5_b			= 5,
+	INT6_gpio5_m			= 0x00000020,
+	INT6_gpio6_b			= 6,
+	INT6_gpio6_m			= 0x00000040,
+	INT6_gpio7_b			= 7,
+	INT6_gpio7_m			= 0x00000080,
+	INT6_gpio8_b			= 8,
+	INT6_gpio8_m			= 0x00000100,
+	INT6_gpio9_b			= 9,
+	INT6_gpio9_m			= 0x00000200,
+	INT6_gpio10_b			= 10,
+	INT6_gpio10_m			= 0x00000400,
+	INT6_gpio11_b			= 11,
+	INT6_gpio11_m			= 0x00000800,
+	INT6_gpio12_b			= 12,
+	INT6_gpio12_m			= 0x00001000,
+	INT6_gpio13_b			= 13,
+	INT6_gpio13_m			= 0x00002000,
+
+	NMIPS_gpio_b			= 0,
+	NMIPS_gpio_m			= 0x00000001,
+} ;
+
+#endif	// __IDT_INT_H__
+
+
diff -urN linux.old/include/asm-mips/rc32434/iparb.h linux.dev/include/asm-mips/rc32434/iparb.h
--- linux.old/include/asm-mips/rc32434/iparb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/iparb.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,95 @@
+#ifndef __IDT_IPARB_H__
+#define __IDT_IPARB_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * IP Arbiter register definitions.
+ *
+ * File   : $Id: iparb.h,v 1.3 2002/06/06 18:34:04 astichte Exp $
+ *
+ * Author : Allen.Stichter@idt.com
+ * Date   : 20020120
+ * Update :
+ *	    $Log: iparb.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:04  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/05 19:01:42  astichte
+ *	    Removed IDTField
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:23  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h>
+
+enum
+{
+	IPARB0_PhysicalAddress	= 0x18048000,
+	IPARB_PhysicalAddress	= IPARB0_PhysicalAddress,	// Default
+
+	IPARB0_VirtualAddress	= 0xb8048000,
+	IPARB_VirtualAddress	= IPARB0_VirtualAddress,	// Default
+} ;
+
+enum
+{
+	IPABMXC_ethernetReceive		= 0,
+	IPABMXC_ethernetTransmit	= 1,
+	IPABMXC_memoryToHoldFifo	= 2,
+	IPABMXC_holdFifoToMemory	= 3,
+	IPABMXC_pciToMemory		= 4,
+	IPABMXC_memoryToPci		= 5,
+	IPABMXC_pciTarget		= 6,
+	IPABMXC_pciTargetStart		= 7,
+	IPABMXC_cpuToIpBus		= 8,
+
+	IPABMXC_Count,				// Must be last in list !
+	IPABMXC_Min			= IPABMXC_ethernetReceive,
+
+	IPAPXC_PriorityCount	= 4,		// 3-highest, 0-lowest.
+} ;
+
+typedef struct
+{
+	U32	ipapc [IPAPXC_PriorityCount] ;	// ipapc[IPAPXC_] = IPAPC_
+	U32	ipabmc [IPABMXC_Count] ;	// ipabmc[IPABMXC_] = IPABMC_
+	U32	ipac ;				// use IPAC_
+	U32	ipaitcc;			// use IPAITCC_
+	U32	ipaspare ;
+} volatile * IPARB_t ;
+
+enum
+{
+	IPAC_dwm_b			= 2,
+	IPAC_dwm_m			= 0x00000004,
+	IPAC_drm_b			= 3,
+	IPAC_drm_m			= 0x00000008,
+	IPAC_msk_b			= 4,
+	IPAC_msk_m			= 0x00000010,
+
+	IPAPC_ptc_b			= 0,
+	IPAPC_ptc_m			= 0x00003fff,
+	IPAPC_mf_b			= 14,
+	IPAPC_mf_m			= 0x00004000,
+	IPAPC_cptc_b			= 16,
+	IPAPC_cptc_m			= 0x3fff0000,
+
+	IPAITCC_itcc			= 0,
+	IPAITCC_itcc,			= 0x000001ff,
+
+	IPABMC_mtc_b			= 0,
+	IPABMC_mtc_m			= 0x00000fff,
+	IPABMC_p_b			= 12,
+	IPABMC_p_m			= 0x00003000,
+	IPABMC_msk_b			= 14,
+	IPABMC_msk_m			= 0x00004000,
+	IPABMC_cmtc_b			= 16,
+	IPABMC_cmtc_m			= 0x0fff0000,
+};
+
+#endif	// __IDT_IPARB_H__
diff -urN linux.old/include/asm-mips/rc32434/irm.h linux.dev/include/asm-mips/rc32434/irm.h
--- linux.old/include/asm-mips/rc32434/irm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/irm.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,55 @@
+#ifndef __IDT_IRM_H__
+#define __IDT_IRM_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Internal Register Map
+ *
+ * File   : $Id: irm.h,v 1.2 2002/06/05 14:51:06 astichte Exp $
+ *
+ * Author : Allen.Stichter@idt.com
+ * Date   : 20020605
+ * Update :
+ *          $Log: irm.h,v $
+ *          Revision 1.2  2002/06/05 14:51:06  astichte
+ *          *** empty log message ***
+ *
+ *          Revision 1.1  2002/05/29 17:33:23  sysarch
+ *          jba File moved from vcode/include/idt/acacia
+ *
+ ******************************************************************************/
+
+/*
+ * NOTE --
+ *	This file is here for backwards compatibility.
+ *	DO NOT USE !!!!
+ */
+
+typedef enum
+{
+	IRM_Physical	= 0x18000000,	// Internal Reg. map physical.
+	RST_Offset	= 0x00000000,	// Includes sysid and RST.
+	DEV_Offset	= 0x00010000,	// Device Controller 0.
+	DDR_Offset	= 0x00018000,	// Double-Data-Rate mem. controller.
+	PMARB_Offset	= 0x00020000,	// PM bus arbiter.
+	TIM_Offset	= 0x00028000,	// Counter / timer.
+	INTEG_Offset	= 0x00030000,	// System Integrity.
+	INT_Offset	= 0x00038000,	// Interrupt controller.
+	DMA_Offset	= 0x00040000,	// DMA.
+	IPARB_Offset	= 0x00044000,	// IP bus arbiter.
+	GPIO_Offset	= 0x00050000,	// GPIO.
+	UART_Offset	= 0x00058000,	// UART
+	ETH_Offset	= 0x00060000,	// Ethernet 1. 
+	I2C_Offset	= 0x00068000,	// I2C interface.
+	SPI_Offset	= 0x00070000,	// Serial Peripheral Interface.
+	NVRAM_Offset  	= 0x00078000,	// NVRAM interface
+	AUTH_Offset	= 0x0007c000,	// Authorization unit 
+	PCI_Offset	= 0x00080000,
+	CROM_Offset	= 0x000b8000,	// Configuration ROM.
+	IRM_Size	= 0x00200000,	// Internal Reg. map size.
+} IRM_Offset_t ;
+ 
+#endif	// __IDT_IRM_H__
diff -urN linux.old/include/asm-mips/rc32434/irq.h linux.dev/include/asm-mips/rc32434/irq.h
--- linux.old/include/asm-mips/rc32434/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/irq.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef __ASM_MACH_MIPS_IRQ_H
+#define __ASM_MACH_MIPS_IRQ_H
+
+#include <linux/config.h>
+
+#define NR_IRQS	256
+
+#endif /* __ASM_MACH_MIPS_IRQ_H */
diff -urN linux.old/include/asm-mips/rc32434/nvram.h linux.dev/include/asm-mips/rc32434/nvram.h
--- linux.old/include/asm-mips/rc32434/nvram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/nvram.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,97 @@
+#ifndef __IDT_NVRAM_H
+#define __IDT_NVRAM_H
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *              All rights reserved.
+ *
+ * IP Arbiter register definitions.
+ *
+ * File   : $Id: nvram.h,v 1.3 2003/07/24 18:34:04 astichte Exp $
+ *
+ * Author : kiran.rao@idt.com
+ * Date   : 20030724
+ * Update :
+ *          $Log: nvram.h,v $
+ *      
+ *
+ ******************************************************************************/
+#include <asm/rc32434/tpes.h>
+
+
+enum
+{
+        NVRAM0_PhysicalAddress    = 0xba000000,
+        NVRAM_PhysicalAddress     = NVRAM0_PhysicalAddress,         // Default
+
+        NVRAM0_VirtualAddress     = 0xba000000,
+        NVRAM_VirtualAddress      = NVRAM0_VirtualAddress,          // Default
+} ;
+
+enum
+{
+	NVRCMD_cmd_b		= 0,
+	NVRCMD_cmd_m		= 0x0000007f,
+	
+	NVRS_r_b		= 0,
+	NVRS_r_m		= 0x00000001,
+	NVRS_e_b		= 1,
+	NVRS_e_m		= 0x00000002,
+	NVRS_k_b		= 2,
+	NVRS_k_m		= 0x00000004, 
+	
+	NVRSM_r_b		= 0,
+	NVRSM_r_m		= 0x00000001,
+	NVRSM_e_b		= 1,
+	NVRSM_e_m		= 0x00000002,
+	NVRSM_k_b		= 2,
+	NVRSM_k_m		= 0x00000004, 
+	
+	NVRCFG0_pwidth_b	= 0,
+	NVRCFG0_pwidth_m	= 0x00000003,
+	NVRCFG0_nmax_b		= 2,
+	NVRCFG0_nmax_m		= 0x0000000C,
+	NVRCFG0_vppl_b		= 4,
+	NVRCFG0_vppl_m		= 0x000000f0,
+	NVRCFG0_vppm_b		= 8,
+	NVRCFG0_vppm_m		= 0x00000300,
+	NVRCFG0_dvpp_b		= 10,
+	NVRCFG0_dvpp_m		= 0x00000c00,
+	NVRCFG0_x_b		= 12,
+	NVRCFG0_x_m		= 0x00007000,
+	
+	NVRCFG1_t1tecc_b	= 0,
+	NVRCFG1_t1tecc_m	= 0x00000003,
+	NVRCFG1_t1mrcl_b	= 2,
+	NVRCFG1_t1mrcl_m	= 0x0000000c,
+	NVRCFG1_t1bias_b	= 4,
+	NVRCFG1_t1bias_m	= 0x00000030,
+	NVRCFG1_t2tecc_b	= 6,
+	NVRCFG1_t2tecc_m	= 0x000000c0,
+	NVRCFG1_t2mrcl_b	= 8,
+	NVRCFG1_t2mrcl_m	= 0x00000300,
+	NVRCFG1_t2bias_b	= 10,
+	NVRCFG1_t2bias_m	= 0x00000c00,
+	NVRCFG1_t3tecc_b	= 12,
+	NVRCFG1_t3tecc_m	= 0x00003000,
+	NVRCFG1_t3mrcl_b	= 14,
+	NVRCFG1_t3mrcl_m	= 0x0000c000,
+	NVRCFG1_t3bias_b	= 16,
+	NVRCFG1_t3bias_m	= 0x00030000,
+	NVRCFG1_t4tecc_b	= 18,
+	NVRCFG1_t4tecc_m	= 0x000c0000,
+	NVRCFG1_t4mrcl_b	= 20,
+	NVRCFG1_t4mrcl_m	= 0x00300000,
+	NVRCFG1_t4bias_b	= 22,
+	NVRCFG1_t4bias_m	= 0x00c00000,
+	NVRCFG1_t5tecc_b	= 24,
+	NVRCFG1_t5tecc_m	= 0x03000000,
+	NVRCFG1_t5mrcl_b	= 26,
+	NVRCFG1_t5mrcl_m	= 0x0c000000,
+	NVRCFG1_t5bias_b	= 28,
+	NVRCFG1_t5bias_m	= 0x30000000,
+}
+
+#endif  // __IDT_NVRAM_H__
+
diff -urN linux.old/include/asm-mips/rc32434/pci.h linux.dev/include/asm-mips/rc32434/pci.h
--- linux.old/include/asm-mips/rc32434/pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/pci.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,695 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   PCI register definitio
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_PCI_H__
+#define __IDT_PCI_H__
+
+enum
+{
+	PCI0_PhysicalAddress	= 0x18080000,
+	PCI_PhysicalAddress	= PCI0_PhysicalAddress,
+
+	PCI0_VirtualAddress	= 0xB8080000,
+	PCI_VirtualAddress	= PCI0_VirtualAddress,
+} ;
+
+enum
+{
+	PCI_LbaCount	= 4,		// Local base addresses.
+} ;
+
+typedef struct
+{
+	u32	a ;		// Address.
+	u32	c ;		// Control.
+	u32	m ;		// mapping.
+} PCI_Map_s ;
+
+typedef struct
+{
+	u32		pcic ;
+	u32		pcis ;
+	u32		pcism ;
+	u32		pcicfga ;
+	u32		pcicfgd ;
+	PCI_Map_s	pcilba [PCI_LbaCount] ;
+	u32		pcidac ;
+	u32		pcidas ;
+	u32		pcidasm ;
+	u32		pcidad ;
+	u32		pcidma8c ;
+	u32		pcidma9c ;
+	u32		pcitc ;
+} volatile *PCI_t ;
+
+// PCI messaging unit.
+enum
+{
+	PCIM_Count	= 2,
+} ;
+typedef struct
+{
+	u32		pciim [PCIM_Count] ;
+	u32		pciom [PCIM_Count] ;
+	u32		pciid ;
+	u32		pciiic ;
+	u32		pciiim ;
+	u32		pciiod ;
+	u32		pciioic ;
+	u32		pciioim ;
+} volatile *PCIM_t ;
+
+/*******************************************************************************
+ *
+ * PCI Control Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIC_en_b	= 0,
+	PCIC_en_m	= 0x00000001,
+	PCIC_tnr_b	= 1,
+	PCIC_tnr_m	= 0x00000002,
+	PCIC_sce_b	= 2,
+	PCIC_sce_m	= 0x00000004,
+	PCIC_ien_b	= 3,
+	PCIC_ien_m	= 0x00000008,
+	PCIC_aaa_b	= 4,
+	PCIC_aaa_m	= 0x00000010,
+	PCIC_eap_b	= 5,
+	PCIC_eap_m	= 0x00000020,
+	PCIC_pcim_b	= 6,
+	PCIC_pcim_m	= 0x000001c0,
+		PCIC_pcim_disabled_v	= 0,
+		PCIC_pcim_tnr_v 	= 1,	// Satellite - target not ready
+		PCIC_pcim_suspend_v	= 2,	// Satellite - suspended CPU.
+		PCIC_pcim_extern_v	= 3,	// Host - external arbiter.
+		PCIC_pcim_fixed_v	= 4,	// Host - fixed priority arb.
+		PCIC_pcim_roundrobin_v	= 5,	// Host - round robin priority.
+		PCIC_pcim_reserved6_v	= 6,
+		PCIC_pcim_reserved7_v	= 7,
+	PCIC_igm_b	= 9,
+	PCIC_igm_m	= 0x00000200,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Status Register
+ *
+ ******************************************************************************/
+enum {
+	PCIS_eed_b	= 0,
+	PCIS_eed_m	= 0x00000001,
+	PCIS_wr_b	= 1,
+	PCIS_wr_m	= 0x00000002,
+	PCIS_nmi_b	= 2,
+	PCIS_nmi_m	= 0x00000004,
+	PCIS_ii_b	= 3,
+	PCIS_ii_m	= 0x00000008,
+	PCIS_cwe_b	= 4,
+	PCIS_cwe_m	= 0x00000010,
+	PCIS_cre_b	= 5,
+	PCIS_cre_m	= 0x00000020,
+	PCIS_mdpe_b	= 6,
+	PCIS_mdpe_m	= 0x00000040,
+	PCIS_sta_b	= 7,
+	PCIS_sta_m	= 0x00000080,
+	PCIS_rta_b	= 8,
+	PCIS_rta_m	= 0x00000100,
+	PCIS_rma_b	= 9,
+	PCIS_rma_m	= 0x00000200,
+	PCIS_sse_b	= 10,
+	PCIS_sse_m	= 0x00000400,
+	PCIS_ose_b	= 11,
+	PCIS_ose_m	= 0x00000800,
+	PCIS_pe_b	= 12,
+	PCIS_pe_m	= 0x00001000,
+	PCIS_tae_b	= 13,
+	PCIS_tae_m	= 0x00002000,
+	PCIS_rle_b	= 14,
+	PCIS_rle_m	= 0x00004000,
+	PCIS_bme_b	= 15,
+	PCIS_bme_m	= 0x00008000,
+	PCIS_prd_b	= 16,
+	PCIS_prd_m	= 0x00010000,
+	PCIS_rip_b	= 17,
+	PCIS_rip_m	= 0x00020000,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Status Mask Register
+ *
+ ******************************************************************************/
+enum {
+	PCISM_eed_b		= 0,
+	PCISM_eed_m		= 0x00000001,
+	PCISM_wr_b		= 1,
+	PCISM_wr_m		= 0x00000002,
+	PCISM_nmi_b		= 2,
+	PCISM_nmi_m		= 0x00000004,
+	PCISM_ii_b		= 3,
+	PCISM_ii_m		= 0x00000008,
+	PCISM_cwe_b		= 4,
+	PCISM_cwe_m		= 0x00000010,
+	PCISM_cre_b		= 5,
+	PCISM_cre_m		= 0x00000020,
+	PCISM_mdpe_b		= 6,
+	PCISM_mdpe_m		= 0x00000040,
+	PCISM_sta_b		= 7,
+	PCISM_sta_m		= 0x00000080,
+	PCISM_rta_b		= 8,
+	PCISM_rta_m		= 0x00000100,
+	PCISM_rma_b		= 9,
+	PCISM_rma_m		= 0x00000200,
+	PCISM_sse_b		= 10,
+	PCISM_sse_m		= 0x00000400,
+	PCISM_ose_b		= 11,
+	PCISM_ose_m		= 0x00000800,
+	PCISM_pe_b		= 12,
+	PCISM_pe_m		= 0x00001000,
+	PCISM_tae_b		= 13,
+	PCISM_tae_m		= 0x00002000,
+	PCISM_rle_b		= 14,
+	PCISM_rle_m		= 0x00004000,
+	PCISM_bme_b		= 15,
+	PCISM_bme_m		= 0x00008000,
+	PCISM_prd_b		= 16,
+	PCISM_prd_m		= 0x00010000,
+	PCISM_rip_b		= 17,
+	PCISM_rip_m		= 0x00020000,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Configuration Address Register
+ *
+ ******************************************************************************/
+enum {
+	PCICFGA_reg_b		= 2,
+	PCICFGA_reg_m		= 0x000000fc,
+		PCICFGA_reg_id_v	= 0x00>>2, //use PCFGID_
+		PCICFGA_reg_04_v	= 0x04>>2, //use PCFG04_
+		PCICFGA_reg_08_v	= 0x08>>2, //use PCFG08_
+		PCICFGA_reg_0C_v	= 0x0C>>2, //use PCFG0C_
+		PCICFGA_reg_pba0_v	= 0x10>>2, //use PCIPBA_
+		PCICFGA_reg_pba1_v	= 0x14>>2, //use PCIPBA_
+		PCICFGA_reg_pba2_v	= 0x18>>2, //use PCIPBA_
+		PCICFGA_reg_pba3_v	= 0x1c>>2, //use PCIPBA_
+		PCICFGA_reg_subsystem_v = 0x2c>>2, //use PCFGSS_
+		PCICFGA_reg_3C_v	= 0x3C>>2, //use PCFG3C_
+		PCICFGA_reg_pba0c_v	= 0x44>>2, //use PCIPBAC_
+		PCICFGA_reg_pba0m_v	= 0x48>>2,
+		PCICFGA_reg_pba1c_v	= 0x4c>>2, //use PCIPBAC_
+		PCICFGA_reg_pba1m_v	= 0x50>>2,
+		PCICFGA_reg_pba2c_v	= 0x54>>2, //use PCIPBAC_
+		PCICFGA_reg_pba2m_v	= 0x58>>2,
+		PCICFGA_reg_pba3c_v	= 0x5c>>2, //use PCIPBAC_
+		PCICFGA_reg_pba3m_v	= 0x60>>2,
+		PCICFGA_reg_pmgt_v	= 0x64>>2,
+	PCICFGA_func_b		= 8,
+	PCICFGA_func_m		= 0x00000700,
+	PCICFGA_dev_b		= 11,
+	PCICFGA_dev_m		= 0x0000f800,
+		PCICFGA_dev_internal_v	= 0,
+	PCICFGA_bus_b		= 16,
+	PCICFGA_bus_m		= 0x00ff0000,
+		PCICFGA_bus_type0_v	= 0,	//local bus
+	PCICFGA_en_b		= 31,		// read only
+	PCICFGA_en_m		= 0x80000000,
+} ;
+
+enum {
+	PCFGID_vendor_b 	= 0,
+	PCFGID_vendor_m 	= 0x0000ffff,
+		PCFGID_vendor_IDT_v		= 0x111d,
+	PCFGID_device_b 	= 16,
+	PCFGID_device_m 	= 0xffff0000,
+		PCFGID_device_Korinade_v	= 0x0214,
+
+	PCFG04_command_ioena_b		= 1,
+	PCFG04_command_ioena_m		= 0x00000001,
+	PCFG04_command_memena_b 	= 2,
+	PCFG04_command_memena_m 	= 0x00000002,
+	PCFG04_command_bmena_b		= 3,
+	PCFG04_command_bmena_m		= 0x00000004,
+	PCFG04_command_mwinv_b		= 5,
+	PCFG04_command_mwinv_m		= 0x00000010,
+	PCFG04_command_parena_b 	= 7,
+	PCFG04_command_parena_m 	= 0x00000040,
+	PCFG04_command_serrena_b	= 9,
+	PCFG04_command_serrena_m	= 0x00000100,
+	PCFG04_command_fastbbena_b	= 10,
+	PCFG04_command_fastbbena_m	= 0x00000200,
+	PCFG04_status_b 		= 16,
+	PCFG04_status_m 		= 0xffff0000,
+	PCFG04_status_66MHz_b		= 21,	// 66 MHz enable
+	PCFG04_status_66MHz_m		= 0x00200000,
+	PCFG04_status_fbb_b		= 23,
+	PCFG04_status_fbb_m		= 0x00800000,
+	PCFG04_status_mdpe_b		= 24,
+	PCFG04_status_mdpe_m		= 0x01000000,
+	PCFG04_status_dst_b		= 25,
+	PCFG04_status_dst_m		= 0x06000000,
+	PCFG04_status_sta_b		= 27,
+	PCFG04_status_sta_m		= 0x08000000,
+	PCFG04_status_rta_b		= 28,
+	PCFG04_status_rta_m		= 0x10000000,
+	PCFG04_status_rma_b		= 29,
+	PCFG04_status_rma_m		= 0x20000000,
+	PCFG04_status_sse_b		= 30,
+	PCFG04_status_sse_m		= 0x40000000,
+	PCFG04_status_pe_b		= 31,
+	PCFG04_status_pe_m		= 0x40000000,
+
+	PCFG08_revId_b			= 0,
+	PCFG08_revId_m			= 0x000000ff,
+	PCFG08_classCode_b		= 0,
+	PCFG08_classCode_m		= 0xffffff00,
+		PCFG08_classCode_bridge_v	= 06,
+		PCFG08_classCode_proc_v 	= 0x0b3000, // processor-MIPS
+	PCFG0C_cacheline_b		= 0,
+	PCFG0C_cacheline_m		= 0x000000ff,
+	PCFG0C_masterLatency_b		= 8,
+	PCFG0C_masterLatency_m		= 0x0000ff00,
+	PCFG0C_headerType_b		= 16,
+	PCFG0C_headerType_m		= 0x00ff0000,
+	PCFG0C_bist_b			= 24,
+	PCFG0C_bist_m			= 0xff000000,
+
+	PCIPBA_msi_b			= 0,
+	PCIPBA_msi_m			= 0x00000001,
+	PCIPBA_p_b			= 3,
+	PCIPBA_p_m			= 0x00000004,
+	PCIPBA_baddr_b			= 8,
+	PCIPBA_baddr_m			= 0xffffff00,
+
+	PCFGSS_vendorId_b		= 0,
+	PCFGSS_vendorId_m		= 0x0000ffff,
+	PCFGSS_id_b			= 16,
+	PCFGSS_id_m			= 0xffff0000,
+
+	PCFG3C_interruptLine_b		= 0,
+	PCFG3C_interruptLine_m		= 0x000000ff,
+	PCFG3C_interruptPin_b		= 8,
+	PCFG3C_interruptPin_m		= 0x0000ff00,
+	PCFG3C_minGrant_b		= 16,
+	PCFG3C_minGrant_m		= 0x00ff0000,
+	PCFG3C_maxLat_b 		= 24,
+	PCFG3C_maxLat_m 		= 0xff000000,
+
+	PCIPBAC_msi_b			= 0,
+	PCIPBAC_msi_m			= 0x00000001,
+	PCIPBAC_p_b			= 1,
+	PCIPBAC_p_m			= 0x00000002,
+	PCIPBAC_size_b			= 2,
+	PCIPBAC_size_m			= 0x0000007c,
+	PCIPBAC_sb_b			= 7,
+	PCIPBAC_sb_m			= 0x00000080,
+	PCIPBAC_pp_b			= 8,
+	PCIPBAC_pp_m			= 0x00000100,
+	PCIPBAC_mr_b			= 9,
+	PCIPBAC_mr_m			= 0x00000600,
+		PCIPBAC_mr_read_v	=0,	//no prefetching
+		PCIPBAC_mr_readLine_v	=1,
+		PCIPBAC_mr_readMult_v	=2,
+	PCIPBAC_mrl_b			= 11,
+	PCIPBAC_mrl_m			= 0x00000800,
+	PCIPBAC_mrm_b			= 12,
+	PCIPBAC_mrm_m			= 0x00001000,
+	PCIPBAC_trp_b			= 13,
+	PCIPBAC_trp_m			= 0x00002000,
+
+	PCFG40_trdyTimeout_b		= 0,
+	PCFG40_trdyTimeout_m		= 0x000000ff,
+	PCFG40_retryLim_b		= 8,
+	PCFG40_retryLim_m		= 0x0000ff00,
+};
+
+/*******************************************************************************
+ *
+ * PCI Local Base Address [0|1|2|3] Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBA_baddr_b		= 0,		// In PCI_t -> pcilba [] .a
+	PCILBA_baddr_m		= 0xffffff00,
+} ;
+/*******************************************************************************
+ *
+ * PCI Local Base Address Control Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBAC_msi_b		= 0,		// In pPci->pcilba[i].c
+	PCILBAC_msi_m		= 0x00000001,
+		PCILBAC_msi_mem_v	= 0,
+		PCILBAC_msi_io_v	= 1,
+	PCILBAC_size_b		= 2,	// In pPci->pcilba[i].c
+	PCILBAC_size_m		= 0x0000007c,
+	PCILBAC_sb_b		= 7,	// In pPci->pcilba[i].c
+	PCILBAC_sb_m		= 0x00000080,
+	PCILBAC_rt_b		= 8,	// In pPci->pcilba[i].c
+	PCILBAC_rt_m		= 0x00000100,
+		PCILBAC_rt_noprefetch_v = 0, // mem read
+		PCILBAC_rt_prefetch_v	= 1, // mem readline
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Local Base Address [0|1|2|3] Mapping Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBAM_maddr_b 	= 8,
+	PCILBAM_maddr_m 	= 0xffffff00,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Decoupled Access Control Register
+ *
+ ******************************************************************************/
+enum {
+	PCIDAC_den_b		= 0,
+	PCIDAC_den_m		= 0x00000001,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Decoupled Access Status Register
+ *
+ ******************************************************************************/
+enum {
+	PCIDAS_d_b	= 0,
+	PCIDAS_d_m	= 0x00000001,
+	PCIDAS_b_b	= 1,
+	PCIDAS_b_m	= 0x00000002,
+	PCIDAS_e_b	= 2,
+	PCIDAS_e_m	= 0x00000004,
+	PCIDAS_ofe_b	= 3,
+	PCIDAS_ofe_m	= 0x00000008,
+	PCIDAS_off_b	= 4,
+	PCIDAS_off_m	= 0x00000010,
+	PCIDAS_ife_b	= 5,
+	PCIDAS_ife_m	= 0x00000020,
+	PCIDAS_iff_b	= 6,
+	PCIDAS_iff_m	= 0x00000040,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI DMA Channel 8 Configuration Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIDMA8C_mbs_b	= 0,		// Maximum Burst Size.
+	PCIDMA8C_mbs_m	= 0x00000fff,	// { pcidma8c }
+	PCIDMA8C_our_b	= 12,		// Optimize Unaligned Burst Reads.
+	PCIDMA8C_our_m	= 0x00001000,	// { pcidma8c }
+} ;
+
+/*******************************************************************************
+ *
+ * PCI DMA Channel 9 Configuration Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIDMA9C_mbs_b	= 0,		// Maximum Burst Size.
+	PCIDMA9C_mbs_m	= 0x00000fff, // { pcidma9c }
+} ;
+
+/*******************************************************************************
+ *
+ * PCI to Memory(DMA Channel 8) AND Memory to PCI DMA(DMA Channel 9)Descriptors
+ *
+ ******************************************************************************/
+enum {
+	PCIDMAD_pt_b		= 22,		// in DEVCMD field (descriptor)
+	PCIDMAD_pt_m		= 0x00c00000,	// preferred transaction field
+		// These are for reads (DMA channel 8)
+		PCIDMAD_devcmd_mr_v	= 0,	//memory read
+		PCIDMAD_devcmd_mrl_v	= 1,	//memory read line
+		PCIDMAD_devcmd_mrm_v	= 2,	//memory read multiple
+		PCIDMAD_devcmd_ior_v	= 3,	//I/O read
+		// These are for writes (DMA channel 9)
+		PCIDMAD_devcmd_mw_v	= 0,	//memory write
+		PCIDMAD_devcmd_mwi_v	= 1,	//memory write invalidate
+		PCIDMAD_devcmd_iow_v	= 3,	//I/O write
+
+	// Swap byte field applies to both DMA channel 8 and 9
+	PCIDMAD_sb_b		= 24,		// in DEVCMD field (descriptor)
+	PCIDMAD_sb_m		= 0x01000000,	// swap byte field
+} ;
+
+
+/*******************************************************************************
+ *
+ * PCI Target Control Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCITC_rtimer_b		= 0,		// In PCITC_t -> pcitc
+	PCITC_rtimer_m		= 0x000000ff,
+	PCITC_dtimer_b		= 8,		// In PCITC_t -> pcitc
+	PCITC_dtimer_m		= 0x0000ff00,
+	PCITC_rdr_b		= 18,		// In PCITC_t -> pcitc
+	PCITC_rdr_m		= 0x00040000,
+	PCITC_ddt_b		= 19,		// In PCITC_t -> pcitc
+	PCITC_ddt_m		= 0x00080000,
+} ;
+/*******************************************************************************
+ *
+ * PCI messaging unit [applies to both inbound and outbound registers ]
+ *
+ ******************************************************************************/
+enum
+{
+	PCIM_m0_b	= 0,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_m0_m	= 0x00000001,	// inbound or outbound message 0
+	PCIM_m1_b	= 1,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_m1_m	= 0x00000002,	// inbound or outbound message 1
+	PCIM_db_b	= 2,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_db_m	= 0x00000004,	// inbound or outbound doorbell
+};
+
+
+
+
+
+
+#define PCI_MSG_VirtualAddress	     0xB8088010
+#define rc32434_pci ((volatile PCI_t) PCI0_VirtualAddress)
+#define rc32434_pci_msg ((volatile PCIM_t) PCI_MSG_VirtualAddress)
+
+#define PCIM_SHFT		0x6
+#define PCIM_BIT_LEN		0x7
+#define PCIM_H_EA		0x3
+#define PCIM_H_IA_FIX		0x4
+#define PCIM_H_IA_RR		0x5
+#if 0
+#define PCI_ADDR_START		0x13000000
+#endif
+
+#define PCI_ADDR_START		0x50000000
+
+#define CPUTOPCI_MEM_WIN	0x02000000
+#define CPUTOPCI_IO_WIN		0x00100000
+#define PCILBA_SIZE_SHFT	2
+#define PCILBA_SIZE_MASK	0x1F
+#define SIZE_256MB		0x1C
+#define SIZE_128MB		0x1B
+#define SIZE_64MB               0x1A
+#define SIZE_32MB		0x19
+#define SIZE_16MB               0x18
+#define SIZE_4MB		0x16
+#define SIZE_2MB		0x15
+#define SIZE_1MB		0x14
+#define KORINA_CONFIG0_ADDR	0x80000000
+#define KORINA_CONFIG1_ADDR	0x80000004
+#define KORINA_CONFIG2_ADDR	0x80000008
+#define KORINA_CONFIG3_ADDR	0x8000000C
+#define KORINA_CONFIG4_ADDR	0x80000010
+#define KORINA_CONFIG5_ADDR	0x80000014
+#define KORINA_CONFIG6_ADDR	0x80000018
+#define KORINA_CONFIG7_ADDR	0x8000001C
+#define KORINA_CONFIG8_ADDR	0x80000020
+#define KORINA_CONFIG9_ADDR	0x80000024
+#define KORINA_CONFIG10_ADDR	0x80000028
+#define KORINA_CONFIG11_ADDR	0x8000002C
+#define KORINA_CONFIG12_ADDR	0x80000030
+#define KORINA_CONFIG13_ADDR	0x80000034
+#define KORINA_CONFIG14_ADDR	0x80000038
+#define KORINA_CONFIG15_ADDR	0x8000003C
+#define KORINA_CONFIG16_ADDR	0x80000040
+#define KORINA_CONFIG17_ADDR	0x80000044
+#define KORINA_CONFIG18_ADDR	0x80000048
+#define KORINA_CONFIG19_ADDR	0x8000004C
+#define KORINA_CONFIG20_ADDR	0x80000050
+#define KORINA_CONFIG21_ADDR	0x80000054
+#define KORINA_CONFIG22_ADDR	0x80000058
+#define KORINA_CONFIG23_ADDR	0x8000005C
+#define KORINA_CONFIG24_ADDR	0x80000060
+#define KORINA_CONFIG25_ADDR	0x80000064
+#define KORINA_CMD 		(PCFG04_command_ioena_m | \
+				 PCFG04_command_memena_m | \
+				 PCFG04_command_bmena_m | \
+				 PCFG04_command_mwinv_m | \
+				 PCFG04_command_parena_m | \
+				 PCFG04_command_serrena_m )
+
+#define KORINA_STAT		(PCFG04_status_mdpe_m | \
+				 PCFG04_status_sta_m  | \
+				 PCFG04_status_rta_m  | \
+				 PCFG04_status_rma_m  | \
+				 PCFG04_status_sse_m  | \
+				 PCFG04_status_pe_m)
+
+#define KORINA_CNFG1		((KORINA_STAT<<16)|KORINA_CMD)
+
+#define KORINA_REVID		0
+#define KORINA_CLASS_CODE	0
+#define KORINA_CNFG2		((KORINA_CLASS_CODE<<8) | \
+				  KORINA_REVID)
+
+#define KORINA_CACHE_LINE_SIZE	4
+#define KORINA_MASTER_LAT	0x3c
+#define KORINA_HEADER_TYPE	0
+#define KORINA_BIST		0
+
+#define KORINA_CNFG3 ((KORINA_BIST << 24) | \
+		      (KORINA_HEADER_TYPE<<16) | \
+		      (KORINA_MASTER_LAT<<8) | \
+		      KORINA_CACHE_LINE_SIZE )
+
+#define KORINA_BAR0	0x00000008 /* 128 MB Memory */
+#define KORINA_BAR1	0x18800001 /* 1 MB IO */
+#define KORINA_BAR2	0x18000001 /* 2 MB IO window for Korina
+					internal Registers */
+#define KORINA_BAR3	0x48000008 /* Spare 128 MB Memory */
+
+#define KORINA_CNFG4	KORINA_BAR0
+#define KORINA_CNFG5    KORINA_BAR1
+#define KORINA_CNFG6 	KORINA_BAR2
+#define KORINA_CNFG7	KORINA_BAR3
+
+#define KORINA_SUBSYS_VENDOR_ID 0x011d
+#define KORINA_SUBSYSTEM_ID	0x0214
+#define KORINA_CNFG8		0
+#define KORINA_CNFG9		0
+#define KORINA_CNFG10		0
+#define KORINA_CNFG11 	((KORINA_SUBSYS_VENDOR_ID<<16) | \
+			  KORINA_SUBSYSTEM_ID)
+#define KORINA_INT_LINE		1
+#define KORINA_INT_PIN		1
+#define KORINA_MIN_GNT		8
+#define KORINA_MAX_LAT		0x38
+#define KORINA_CNFG12		0
+#define KORINA_CNFG13 		0
+#define KORINA_CNFG14		0
+#define KORINA_CNFG15	((KORINA_MAX_LAT<<24) | \
+			 (KORINA_MIN_GNT<<16) | \
+			 (KORINA_INT_PIN<<8)  | \
+			  KORINA_INT_LINE)
+#define	KORINA_RETRY_LIMIT	0x80
+#define KORINA_TRDY_LIMIT	0x80
+#define KORINA_CNFG16 ((KORINA_RETRY_LIMIT<<8) | \
+			KORINA_TRDY_LIMIT)
+#define PCI_PBAxC_R		0x0
+#define PCI_PBAxC_RL		0x1
+#define PCI_PBAxC_RM		0x2
+#define SIZE_SHFT		2
+
+#if defined(__MIPSEB__)
+#define KORINA_PBA0C	( PCIPBAC_mrl_m | PCIPBAC_sb_m | \
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \
+			  PCIPBAC_pp_m | \
+			  (SIZE_128MB<<SIZE_SHFT) | \
+			   PCIPBAC_p_m)
+#else
+#define KORINA_PBA0C	( PCIPBAC_mrl_m | \
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \
+			  PCIPBAC_pp_m | \
+			  (SIZE_128MB<<SIZE_SHFT) | \
+			   PCIPBAC_p_m)
+#endif
+#define KORINA_CNFG17	KORINA_PBA0C
+#define KORINA_PBA0M	0x0
+#define KORINA_CNFG18	KORINA_PBA0M
+
+#if defined(__MIPSEB__)
+#define KORINA_PBA1C	((SIZE_1MB<<SIZE_SHFT) | PCIPBAC_sb_m | \
+			  PCIPBAC_msi_m)
+#else
+#define KORINA_PBA1C	((SIZE_1MB<<SIZE_SHFT) | \
+			  PCIPBAC_msi_m)
+#endif
+#define KORINA_CNFG19	KORINA_PBA1C
+#define KORINA_PBA1M	0x0
+#define KORINA_CNFG20	KORINA_PBA1M
+
+#if defined(__MIPSEB__)
+#define KORINA_PBA2C	((SIZE_2MB<<SIZE_SHFT) | PCIPBAC_sb_m | \
+			  PCIPBAC_msi_m)
+#else
+#define KORINA_PBA2C	((SIZE_2MB<<SIZE_SHFT) | \
+			  PCIPBAC_msi_m)
+#endif
+#define KORINA_CNFG21	KORINA_PBA2C
+#define KORINA_PBA2M	0x18000000
+#define KORINA_CNFG22	KORINA_PBA2M
+#define KORINA_PBA3C	0
+#define KORINA_CNFG23	KORINA_PBA3C
+#define KORINA_PBA3M	0
+#define KORINA_CNFG24	KORINA_PBA3M
+
+
+
+#define	PCITC_DTIMER_VAL	8
+#define PCITC_RTIMER_VAL	0x10
+
+
+
+
+#endif	// __IDT_PCI_H__
+
+
+
diff -urN linux.old/include/asm-mips/rc32434/pcikorina.h linux.dev/include/asm-mips/rc32434/pcikorina.h
--- linux.old/include/asm-mips/rc32434/pcikorina.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/pcikorina.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,209 @@
+/* $Id: pciacacia.h,v 1.5 2001/05/01 10:09:17 carstenl Exp $
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#ifndef _PCIKORINA_H
+#define _PCIKORINA_H
+
+
+#define PCI_MSG_VirtualAddress	     0xB8088010
+#define rc32434_pci ((volatile PCI_t) PCI0_VirtualAddress)
+#define rc32434_pci_msg ((volatile PCIM_t) PCI_MSG_VirtualAddress)
+
+#define PCIM_SHFT		0x6
+#define PCIM_BIT_LEN		0x7
+#define PCIM_H_EA		0x3
+#define PCIM_H_IA_FIX		0x4
+#define PCIM_H_IA_RR		0x5
+#if 0
+#define PCI_ADDR_START		0x13000000
+#endif
+
+#define PCI_ADDR_START		0x50000000
+
+#define CPUTOPCI_MEM_WIN	0x02000000
+#define CPUTOPCI_IO_WIN		0x00100000
+#define PCILBA_SIZE_SHFT	2
+#define PCILBA_SIZE_MASK	0x1F
+#define SIZE_256MB		0x1C
+#define SIZE_128MB		0x1B
+#define SIZE_64MB               0x1A
+#define SIZE_32MB		0x19
+#define SIZE_16MB               0x18
+#define SIZE_4MB		0x16
+#define SIZE_2MB		0x15
+#define SIZE_1MB		0x14
+#define KORINA_CONFIG0_ADDR	0x80000000
+#define KORINA_CONFIG1_ADDR	0x80000004
+#define KORINA_CONFIG2_ADDR	0x80000008
+#define KORINA_CONFIG3_ADDR	0x8000000C
+#define KORINA_CONFIG4_ADDR	0x80000010
+#define KORINA_CONFIG5_ADDR	0x80000014
+#define KORINA_CONFIG6_ADDR	0x80000018
+#define KORINA_CONFIG7_ADDR	0x8000001C
+#define KORINA_CONFIG8_ADDR	0x80000020
+#define KORINA_CONFIG9_ADDR	0x80000024
+#define KORINA_CONFIG10_ADDR	0x80000028
+#define KORINA_CONFIG11_ADDR	0x8000002C
+#define KORINA_CONFIG12_ADDR	0x80000030
+#define KORINA_CONFIG13_ADDR	0x80000034
+#define KORINA_CONFIG14_ADDR	0x80000038
+#define KORINA_CONFIG15_ADDR	0x8000003C
+#define KORINA_CONFIG16_ADDR	0x80000040
+#define KORINA_CONFIG17_ADDR	0x80000044
+#define KORINA_CONFIG18_ADDR	0x80000048
+#define KORINA_CONFIG19_ADDR	0x8000004C
+#define KORINA_CONFIG20_ADDR	0x80000050
+#define KORINA_CONFIG21_ADDR	0x80000054
+#define KORINA_CONFIG22_ADDR	0x80000058
+#define KORINA_CONFIG23_ADDR	0x8000005C
+#define KORINA_CONFIG24_ADDR	0x80000060
+#define KORINA_CONFIG25_ADDR	0x80000064
+#define KORINA_CMD 		(PCFG04_command_ioena_m | \
+				 PCFG04_command_memena_m | \
+				 PCFG04_command_bmena_m | \
+				 PCFG04_command_mwinv_m | \
+				 PCFG04_command_parena_m | \
+				 PCFG04_command_serrena_m )
+
+#define KORINA_STAT		(PCFG04_status_mdpe_m | \
+				 PCFG04_status_sta_m  | \
+				 PCFG04_status_rta_m  | \
+				 PCFG04_status_rma_m  | \
+				 PCFG04_status_sse_m  | \
+				 PCFG04_status_pe_m)
+
+#define KORINA_CNFG1		((KORINA_STAT<<16)|KORINA_CMD)
+
+#define KORINA_REVID		0
+#define KORINA_CLASS_CODE	0
+#define KORINA_CNFG2		((KORINA_CLASS_CODE<<8) | \
+				  KORINA_REVID)
+
+#define KORINA_CACHE_LINE_SIZE	4
+#define KORINA_MASTER_LAT	0x3c
+#define KORINA_HEADER_TYPE	0
+#define KORINA_BIST		0
+
+#define KORINA_CNFG3 ((KORINA_BIST << 24) | \
+		      (KORINA_HEADER_TYPE<<16) | \
+		      (KORINA_MASTER_LAT<<8) | \
+		      KORINA_CACHE_LINE_SIZE )
+
+#define KORINA_BAR0	0x00000008 /* 128 MB Memory */
+#define KORINA_BAR1	0x18800001 /* 1 MB IO */
+#define KORINA_BAR2	0x18000001 /* 2 MB IO window for Acacia
+					internal Registers */
+#define KORINA_BAR3	0x48000008 /* Spare 128 MB Memory */
+
+#define KORINA_CNFG4	KORINA_BAR0
+#define KORINA_CNFG5    KORINA_BAR1
+#define KORINA_CNFG6 	KORINA_BAR2
+#define KORINA_CNFG7	KORINA_BAR3
+
+#define KORINA_SUBSYS_VENDOR_ID 0
+#define KORINA_SUBSYSTEM_ID	0
+#define KORINA_CNFG8		0
+#define KORINA_CNFG9		0
+#define KORINA_CNFG10		0
+#define KORINA_CNFG11 	((KORINA_SUBSYS_VENDOR_ID<<16) | \
+			  KORINA_SUBSYSTEM_ID)
+#define KORINA_INT_LINE		1
+#define KORINA_INT_PIN		1
+#define KORINA_MIN_GNT		8
+#define KORINA_MAX_LAT		0x38
+#define KORINA_CNFG12		0
+#define KORINA_CNFG13 		0
+#define KORINA_CNFG14		0
+#define KORINA_CNFG15	((KORINA_MAX_LAT<<24) | \
+			 (KORINA_MIN_GNT<<16) | \
+			 (KORINA_INT_PIN<<8)  | \
+			  KORINA_INT_LINE)
+#define	KORINA_RETRY_LIMIT	0x80
+#define KORINA_TRDY_LIMIT	0x80
+#define KORINA_CNFG16 ((KORINA_RETRY_LIMIT<<8) | \
+			KORINA_TRDY_LIMIT)
+#define PCI_PBAxC_R		0x0
+#define PCI_PBAxC_RL		0x1
+#define PCI_PBAxC_RM		0x2
+#define SIZE_SHFT		2
+
+#ifdef __MIPSEB__
+#define KORINA_PBA0C	( PCIPBAC_mrl_m  | PCIPBAC_sb_m | \
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \
+			  PCIPBAC_pp_m | \
+			  (SIZE_32MB<<SIZE_SHFT) | \
+			   PCIPBAC_p_m)
+#else
+#define KORINA_PBA0C	( PCIPBAC_mrl_m  | \
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \
+			  PCIPBAC_pp_m | \
+			  (SIZE_32MB<<SIZE_SHFT) | \
+			   PCIPBAC_p_m)
+#endif
+
+#if 0
+
+#define KORINA_PBA0C	( PCIPBAC_sb_m | PCIPBAC_pp_m | \
+			  ((PCI_PBAxC_R &0x3) << PCIPBAC_mr_b) | \
+			  (SIZE_128MB<<SIZE_SHFT))
+#endif
+#define KORINA_CNFG17	KORINA_PBA0C
+#define KORINA_PBA0M	0x0
+#define KORINA_CNFG18	KORINA_PBA0M
+
+#ifdef __MIPSEB__
+#define KORINA_PBA1C	((SIZE_1MB<<SIZE_SHFT)  | PCIPBAC_sb_m | \
+			  PCIPBAC_msi_m)
+#else
+#define KORINA_PBA1C	((SIZE_1MB<<SIZE_SHFT)  | \
+			  PCIPBAC_msi_m)
+
+#endif
+
+#define KORINA_CNFG19	KORINA_PBA1C
+#define KORINA_PBA1M	0x0
+#define KORINA_CNFG20	KORINA_PBA1M
+
+#ifdef __MIPSEB__
+#define KORINA_PBA2C	((SIZE_2MB<<SIZE_SHFT)  | PCIPBAC_sb_m | \
+			  PCIPBAC_msi_m)
+#else
+#define KORINA_PBA2C	((SIZE_2MB<<SIZE_SHFT) | \
+			  PCIPBAC_msi_m)
+
+#endif
+#define KORINA_CNFG21	KORINA_PBA2C
+#define KORINA_PBA2M	0x18000000
+#define KORINA_CNFG22	KORINA_PBA2M
+#define KORINA_PBA3C	0
+#define KORINA_CNFG23	KORINA_PBA3C
+#define KORINA_PBA3M	0
+#define KORINA_CNFG24	KORINA_PBA3M
+
+
+
+#define	PCITC_DTIMER_VAL	8
+#define PCITC_RTIMER_VAL	0x10
+
+					  			  
+#endif /* _PCIKORINA_H */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -urN linux.old/include/asm-mips/rc32434/pci_regs.h linux.dev/include/asm-mips/rc32434/pci_regs.h
--- linux.old/include/asm-mips/rc32434/pci_regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/pci_regs.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,8 @@
+/* Override the default address space for this arch
+*/
+
+#include <linux/pci_regs.h>
+
+//#undef PCI_BASE_ADDRESS_SPACE
+//#define PCI_BASE_ADDRESS_SPACE PCI_BASE_ADDRESS_SPACE_MEMORY
+
diff -urN linux.old/include/asm-mips/rc32434/rb.h linux.dev/include/asm-mips/rc32434/rb.h
--- linux.old/include/asm-mips/rc32434/rb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/rb.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,69 @@
+#ifndef __MIPS_RB_H__
+#define __MIPS_RB_H__
+#include <linux/genhd.h>
+
+#define IDT434_REG_BASE ((volatile void *) KSEG1ADDR(0x18000000))
+#define DEV0BASE 0x010000
+#define DEV0MASK 0x010004
+#define DEV0C 0x010008
+#define DEV0TC 0x01000C
+#define DEV1BASE 0x010010
+#define DEV1MASK 0x010014
+#define DEV1C 0x010018
+#define DEV1TC 0x01001C
+#define DEV2BASE 0x010020
+#define DEV2MASK 0x010024
+#define DEV2C 0x010028
+#define DEV2TC 0x01002C
+#define DEV3BASE 0x010030
+#define DEV3MASK 0x010034
+#define DEV3C 0x010038
+#define DEV3TC 0x01003C
+#define BTCS 0x010040
+#define BTCOMPARE 0x010044
+#define GPIOFUNC 0x050000
+#define GPIOCFG 0x050004
+#define GPIOD 0x050008
+#define GPIOILEVEL 0x05000C
+#define GPIOISTAT 0x050010
+#define GPIONMIEN 0x050014
+#define IMASK6 0x038038
+
+#define LO_WPX (1 << 0)
+#define LO_ALE (1 << 1)
+#define LO_CLE (1 << 2)
+#define LO_CEX (1 << 3)
+#define LO_FOFF (1 << 5)
+#define LO_SPICS (1 << 6)
+#define LO_ULED (1 << 7)
+
+typedef enum {
+	FUNC = 0x00,
+	CFG = 0x04,
+	DATA = 0x08,
+	ILEVEL = 0x0c,
+	ISTAT = 0x10,
+	NMIEN = 0x14
+} gpio_func;
+
+extern void changeLatchU5(unsigned char orMask, unsigned char nandMask);
+extern unsigned get434Reg(unsigned regOffs);
+extern void set434Reg(unsigned regOffs, unsigned bit, unsigned len, unsigned val);
+extern void gpio_set(gpio_func func, u32 mask, u32 value);
+extern u32 gpio_get(gpio_func func);
+
+#define get434Reg(x) (*(volatile unsigned *) (IDT434_REG_BASE + (x)))
+
+struct korina_device {
+	char *name;
+	unsigned char mac[6];
+	struct net_device *dev;
+};
+
+struct cf_device {
+	int gpio_pin;
+	void *dev;
+	struct gendisk *gd;
+};
+
+#endif
diff -urN linux.old/include/asm-mips/rc32434/rc32434.h linux.dev/include/asm-mips/rc32434/rc32434.h
--- linux.old/include/asm-mips/rc32434/rc32434.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/rc32434.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,126 @@
+/*
+ ***************************************************************************
+ * Definitions for IDT RC323434 CPU.
+ *
+ ****************************************************************************
+ * Kiran Rao
+ * 
+ * Original form
+ ****************************************************************************
+ * P. Sadik   Oct 08, 2003
+ *
+ * Started revision history
+ * Made IDT_BUS_FREQ a kernel configuration parameter
+ ****************************************************************************
+ * P. Sadik   Oct 10, 2003
+ *
+ * Removed IDT_BUS_FREQ, since this parameter is no longer required. Instead
+ * idt_cpu_freq is used everywhere
+ ****************************************************************************
+ * P. Sadik   Oct 20, 2003
+ *
+ * Removed RC32434_BASE_BAUD
+ ****************************************************************************
+*/
+#ifndef _RC32434_H_
+#define _RC32434_H_
+
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/rc32434/timer.h>
+
+#define RC32434_REG_BASE   0x18000000
+
+#define interrupt ((volatile INT_t ) INT0_VirtualAddress)
+#define timer     ((volatile TIM_t)  TIM0_VirtualAddress)
+#define gpio	  ((volatile GPIO_t) GPIO0_VirtualAddress)
+
+#define IDT_CLOCK_MULT 2
+#define MIPS_CPU_TIMER_IRQ 7
+/* Interrupt Controller */
+#define IC_GROUP0_PEND     (RC32434_REG_BASE + 0x38000)
+#define IC_GROUP0_MASK     (RC32434_REG_BASE + 0x38008)
+#define IC_GROUP_OFFSET    0x0C
+
+#define NUM_INTR_GROUPS    5
+/* 16550 UARTs */
+
+#define GROUP0_IRQ_BASE 8		/* GRP2 IRQ numbers start here */
+#define GROUP1_IRQ_BASE (GROUP0_IRQ_BASE + 32) /* GRP3 IRQ numbers start here */
+#define GROUP2_IRQ_BASE (GROUP1_IRQ_BASE + 32) /* GRP4 IRQ numbers start here */
+#define GROUP3_IRQ_BASE (GROUP2_IRQ_BASE + 32)	/* GRP5 IRQ numbers start here */
+#define GROUP4_IRQ_BASE (GROUP3_IRQ_BASE + 32)
+
+
+#ifdef __MIPSEB__
+#define RC32434_UART0_BASE (RC32434_REG_BASE + 0x58003)
+#else
+#define RC32434_UART0_BASE (RC32434_REG_BASE + 0x58000)
+#endif
+
+#define RC32434_UART0_IRQ  GROUP3_IRQ_BASE + 0
+// #define EB434_UART1_IRQ    GROUP4_IRQ_BASE + 11
+
+#define local_readl(addr) __raw_readl(addr)
+#define local_writel(l,addr) __raw_writel(l,addr)
+
+/* cpu pipeline flush */
+static inline void rc32434_sync(void)
+{
+        __asm__ volatile ("sync");
+}
+
+static inline void rc32434_sync_udelay(int us)
+{
+        __asm__ volatile ("sync");
+        udelay(us);
+}
+
+static inline void rc32434_sync_delay(int ms)
+{
+        __asm__ volatile ("sync");
+        mdelay(ms);
+}
+
+/*
+ * C access to CLZ and CLO instructions
+ * (count leading zeroes/ones).
+ */
+static inline int rc32434_clz(unsigned long val)
+{
+	int ret;
+        __asm__ volatile (
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		".set\tmips32\n\t"
+		"clz\t%0,%1\n\t"
+                ".set\tmips0\n\t"
+                ".set\tat\n\t"
+                ".set\treorder"
+                : "=r" (ret)
+		: "r" (val));
+
+	return ret;
+}
+static inline int rc32434_clo(unsigned long val)
+{
+	int ret;
+        __asm__ volatile (
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		".set\tmips32\n\t"
+		"clo\t%0,%1\n\t"
+                ".set\tmips0\n\t"
+                ".set\tat\n\t"
+                ".set\treorder"
+                : "=r" (ret)
+		: "r" (val));
+
+	return ret;
+}
+
+extern void cons_putc(char c);
+extern void cons_puts(char *s);
+
+#endif /* _RC32434_H_ */
diff -urN linux.old/include/asm-mips/rc32434/rst.h linux.dev/include/asm-mips/rc32434/rst.h
--- linux.old/include/asm-mips/rc32434/rst.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/rst.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,105 @@
+#ifndef __IDT_RST_H__
+#define __IDT_RST_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Reset register definitions.
+ *
+ * File   : $Id: rst.h,v 1.2 2002/06/06 18:34:05 astichte Exp $
+ *
+ * Author : Allen.Stichter@idt.com
+ * Date   : 20020118
+ * Update :
+ *	    $Log: rst.h,v $
+ *	    Revision 1.2  2002/06/06 18:34:05  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:24  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h>
+
+enum
+{
+	RST0_PhysicalAddress	= 0x18000000,
+	RST_PhysicalAddress	= RST0_PhysicalAddress,		// Default
+
+	RST0_VirtualAddress	= 0xb8000000,
+	RST_VirtualAddress	= RST0_VirtualAddress,		// Default
+} ;
+
+typedef struct RST_s
+{
+	U32	filler [0x0006] ;
+	U32	sysid ;
+	U32	filler2 [0x2000-8] ;		// Pad out to offset 0x8000
+	U32	reset ;
+	U32	bcv ;
+	U32	cea ;
+} volatile * RST_t ;
+
+enum
+{
+	SYSID_rev_b		= 0,
+	SYSID_rev_m		= 0x000000ff,
+	SYSID_imp_b		= 8,
+	SYSID_imp_m		= 0x000fff00,
+	SYSID_vendor_b		= 20,
+	SYSID_vendor_m		= 0xfff00000,
+
+	BCV_pll_b		= 0,
+	BCV_pll_m		= 0x0000000f,
+		BCV_pll_PLLBypass_v	= 0x0,	// PCLK=1*CLK.
+		BCV_pll_Mul3_v		= 0x1,	// PCLK=3*CLK.
+		BCV_pll_Mul4_v		= 0x2,	// PCLK=4*CLK.
+		BCV_pll_SlowMul5_v	= 0x3,	// PCLK=4*CLK.
+		BCV_pll_Mul5_v		= 0x4,	// PCLK=6*CLK.
+		BCV_pll_SlowMul6_v	= 0x5,	// PCLK=8*CLK.
+		BCV_pll_Mul6_v		= 0x6,	// PCLK=8*CLK.
+		BCV_pll_Mul8_v		= 0x7,	// PCLK=8*CLK.
+		BCV_pll_Mul10_v		= 0x8,	// PCLK=8*CLK.
+		BCV_pll_Res5_v		= 0x9,
+		BCV_pll_Res6_v		= 0xa,
+		BCV_pll_Res7_v		= 0xb,
+		BCV_pll_Res8_v		= 0xc,
+		BCV_pll_Res13_v		= 0xd,
+		BCV_pll_Res14_v		= 0xe,
+		BCV_pll_Res15_v		= 0xf,
+	BCV_clkDiv_b		= 4,
+	BCV_clkDiv_m		= 0x00000030,
+		BCV_clkDiv_Div1_v	= 0x0,
+		BCV_clkDiv_Div2_v	= 0x1,
+		BCV_clkDiv_Div4_v	= 0x2,
+		BCV_clkDiv_Res3_v	= 0x3,
+	BCV_bigEndian_b		= 6,
+	BCV_bigEndian_m		= 0x00000040,
+	BCV_resetFast_b		= 7,
+	BCV_resetFast_m		= 0x00000080,
+	BCV_pciMode_b		= 8,
+	BCV_pciMode_m		= 0x00000100,
+		BCV_pciMode_disabled_v	= 0,	// PCI is disabled.
+		BCV_pciMode_tnr_v	= 1,	// satellite Target Not Ready.
+		BCV_pciMode_suspended_v	= 2,	// satellite with suspended CPU.
+		BCV_pciMode_external_v	= 3,	// host, external arbiter.
+		BCV_pciMode_fixed_v	= 4,	// host, fixed priority arbiter.
+		BCV_pciMode_roundRobin_v= 5,	// host, round robin arbiter.
+		BCV_pciMode_res6_v	= 6,
+		BCV_pciMode_res7_v	= 7,
+	BCV_watchDisable_b	= 11,
+	BCV_watchDisable_m	= 0x00000800,
+	BCV_pllTest_b		= 12,
+	BCV_pllTest_m		= 0x00001000,
+	BCV_nvramInit_b		= 13,
+	BCV_nvramInit_m		= 0x00002000,
+	BCV_clksyncTstMd_b	= 14,
+	BCV_clksyncTstMd_m	= 0x00004000,
+	BCV_delayBypass_b	= 15,
+	BCV_delayByPass_m	= 0x00008000,
+} ;
+#endif	// __IDT_RST_H__
diff -urN linux.old/include/asm-mips/rc32434/spi.h linux.dev/include/asm-mips/rc32434/spi.h
--- linux.old/include/asm-mips/rc32434/spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/spi.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,100 @@
+#ifndef __IDT_SPI_H__
+#define __IDT_SPI_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Serial Peripheral Interface register definitions. 
+ *
+ * File   : $Id: spi.h,v 1.2 2002/06/06 18:34:05 astichte Exp $
+ *
+ * Author : ryan.holmQVist@idt.com
+ * Date   : 20011005
+ * Update :
+ *	    $Log: spi.h,v $
+ *	    Revision 1.2  2002/06/06 18:34:05  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:25  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h> 
+
+enum
+{
+	SPI0_PhysicalAddress	= 0x18070000,
+	SPI_PhysicalAddress	= SPI0_PhysicalAddress,
+
+	SPI0_VirtualAddress	= 0xb8070000,
+	SPI_VirtualAddress	= SPI0_VirtualAddress,
+} ;
+
+typedef struct
+{
+	U32 spcp ;	// prescalar. 0=off, * spiClk = sysClk/(2*(spcp+1)*SPR)
+	U32 spc ;	// spi control reg use SPC_
+	U32 sps ;	// spi status reg use SPS_
+	U32 spd ;	// spi data reg use SPD_
+	U32 siofunc ;	// serial IO function use SIOFUNC_
+	U32 siocfg ;	// serial IO config use SIOCFG_
+	U32 siod;	// serial IO data use SIOD_
+} volatile *SPI_t ;
+
+enum
+{
+	SPCP_div_b	 = 0,	       
+	SPCP_div_m	 = 0x000000ff,
+	SPC_spr_b	= 0,	       
+	SPC_spr_m	= 0x00000003,
+	     SPC_spr_div2_v  = 0,
+	     SPC_spr_div4_v  = 1,
+	     SPC_spr_div16_v = 2,
+	     SPC_spr_div32_v = 3,
+	SPC_cpha_b	= 2,	       
+	SPC_cpha_m	= 0x00000004,
+	SPC_cpol_b	= 3,	       
+	SPC_cpol_m	= 0x00000008,
+	SPC_mstr_b	= 4,	       
+	SPC_mstr_m	= 0x00000010,
+	SPC_spe_b	= 6,	       
+	SPC_spe_m	= 0x00000040,
+	SPC_spie_b	= 7,	       
+	SPC_spie_m	= 0x00000080,
+
+	SPS_modf_b	= 4,	       
+	SPS_modf_m	= 0x00000010,
+	SPS_wcol_b	= 6,	       
+	SPS_wcol_m	= 0x00000040,
+	SPS_spif_b	= 7,	       
+	SPS_spif_m	= 0x00000070,
+
+	SPD_data_b	= 0,	       
+	SPD_data_m	= 0x000000ff,
+
+	SIOFUNC_sdo_b	    = 0,	   
+	SIOFUNC_sdo_m	    = 0x00000001,
+	SIOFUNC_sdi_b	    = 1,	   
+	SIOFUNC_sdi_m	    = 0x00000002,
+	SIOFUNC_sck_b	    = 2,	   
+	SIOFUNC_sck_m	    = 0x00000004,
+	
+	SIOCFG_sdo_b	   = 0, 	   
+	SIOCFG_sdo_m	   = 0x00000001,
+	SIOCFG_sdi_b	   = 1, 	   
+	SIOCFG_sdi_m	   = 0x00000002,
+	SIOCFG_sck_b	   = 2, 	   
+	SIOCFG_sck_m	   = 0x00000004,
+	
+	SIOD_sdo_b	 = 0,		 
+	SIOD_sdo_m	 = 0x00000001,
+	SIOD_sdi_b	 = 1,		 
+	SIOD_sdi_m	 = 0x00000002,
+	SIOD_sck_b	 = 2,		 
+	SIOD_sck_m	 = 0x00000004,
+} ;
+#endif	// __IDT_SPI_H__
diff -urN linux.old/include/asm-mips/rc32434/timer.h linux.dev/include/asm-mips/rc32434/timer.h
--- linux.old/include/asm-mips/rc32434/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/timer.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,91 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Definitions for timer registers
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt,neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_TIM_H__
+#define __IDT_TIM_H__
+
+enum
+{
+	TIM0_PhysicalAddress	= 0x18028000,
+	TIM_PhysicalAddress	= TIM0_PhysicalAddress,		// Default
+
+	TIM0_VirtualAddress	= 0xb8028000,
+	TIM_VirtualAddress	= TIM0_VirtualAddress,		// Default
+} ;
+
+enum
+{
+	TIM_Count = 3,
+} ;
+
+struct TIM_CNTR_s
+{
+  u32 count ;
+  u32 compare ;
+  u32 ctc ;	//use CTC_
+} ;
+
+typedef struct TIM_s
+{
+  struct TIM_CNTR_s	tim [TIM_Count] ;
+  u32			rcount ;	//use RCOUNT_
+  u32			rcompare ;	//use RCOMPARE_
+  u32			rtc ;		//use RTC_
+} volatile * TIM_t ;
+
+enum
+{
+  CTC_en_b	= 0,		
+  CTC_en_m	= 0x00000001,
+  CTC_to_b	= 1,		 
+  CTC_to_m	= 0x00000002,
+  
+  RCOUNT_count_b		= 0,	     
+  RCOUNT_count_m		= 0x0000ffff,
+  RCOMPARE_compare_b	= 0,	   
+  RCOMPARE_compare_m	= 0x0000ffff,
+  RTC_ce_b		= 0,		
+  RTC_ce_m		= 0x00000001,
+  RTC_to_b		= 1,		
+  RTC_to_m		= 0x00000002,
+  RTC_rqe_b		= 2,		
+  RTC_rqe_m		= 0x00000004,
+  
+} ;
+#endif	// __IDT_TIM_H__
+
diff -urN linux.old/include/asm-mips/rc32434/tim.h linux.dev/include/asm-mips/rc32434/tim.h
--- linux.old/include/asm-mips/rc32434/tim.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/tim.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,78 @@
+#ifndef __IDT_TIM_H__
+#define __IDT_TIM_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Timer register definition.
+ *
+ * File   : $Id: tim.h,v 1.2 2002/06/06 18:34:05 astichte Exp $
+ *
+ * Author : ryan.holmQVist@idt.com
+ * Date   : 20011005
+ * Update :
+ *	    $Log: tim.h,v $
+ *	    Revision 1.2  2002/06/06 18:34:05  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:25  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+
+
+#include  <asm/rc32434/types.h> 
+
+enum
+{
+	TIM0_PhysicalAddress	= 0x18028000,
+	TIM_PhysicalAddress	= TIM0_PhysicalAddress,		// Default
+
+	TIM0_VirtualAddress	= 0xb8028000,
+	TIM_VirtualAddress	= TIM0_VirtualAddress,		// Default
+} ;
+
+enum
+{
+	TIM_Count = 3,
+} ;
+
+struct TIM_CNTR_s
+{
+	U32 count ;
+	U32 compare ;
+	U32 ctc ;	//use CTC_
+} ;
+
+typedef struct TIM_s
+{
+	struct TIM_CNTR_s	tim [TIM_Count] ;
+	U32			rcount ;	//use RCOUNT_
+	U32			rcompare ;	//use RCOMPARE_
+	U32			rtc ;		//use RTC_
+} volatile * TIM_t ;
+
+enum
+{
+	CTC_en_b	= 0,		
+	CTC_en_m	= 0x00000001,
+	CTC_to_b	= 1,		 
+	CTC_to_m	= 0x00000002,
+
+	RCOUNT_count_b		= 0,	     
+	RCOUNT_count_m		= 0x0000ffff,
+	RCOMPARE_compare_b	= 0,	   
+	RCOMPARE_compare_m	= 0x0000ffff,
+	RTC_ce_b		= 0,		
+	RTC_ce_m		= 0x00000001,
+	RTC_to_b		= 1,		
+	RTC_to_m		= 0x00000002,
+	RTC_rqe_b		= 2,		
+	RTC_rqe_m		= 0x00000004,
+				 
+} ;
+#endif	// __IDT_TIM_H__
+
diff -urN linux.old/include/asm-mips/rc32434/types.h linux.dev/include/asm-mips/rc32434/types.h
--- linux.old/include/asm-mips/rc32434/types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/types.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,39 @@
+#ifndef __IDT_TYPES_H__
+#define __IDT_TYPES_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * Common typedefs used in IDT-generated code.
+ *
+ * File   : $Id: types.h,v 1.1 2002/06/06 16:16:56 astichte Exp $
+ *
+ * Author : Allen.Stichter@idt.com
+ * Date   : 20020606
+ * Update :
+ *	    $Log: types.h,v $
+ *	    Revision 1.1  2002/06/06 16:16:56  astichte
+ *	    Added
+ *	
+ *
+ ******************************************************************************/
+
+typedef unsigned char		U8 ;
+typedef signed char		S8 ;
+
+typedef unsigned short		U16 ;
+typedef signed short		S16 ;
+
+typedef unsigned int		U32 ;
+typedef signed int		S32 ;
+
+typedef unsigned long long	U64 ;
+typedef signed long long	S64 ;
+
+#ifndef __cplusplus
+	typedef U32		bool ;	// (false == 0), (true is != false)
+#endif	// __cplusplus
+
+#endif	// __IDT_TYPES_H__
diff -urN linux.old/include/asm-mips/rc32434/uart.h linux.dev/include/asm-mips/rc32434/uart.h
--- linux.old/include/asm-mips/rc32434/uart.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/rc32434/uart.h	2006-07-29 19:31:51.000000000 +0200
@@ -0,0 +1,178 @@
+#ifndef __IDT_UART_H__
+#define __IDT_UART_H__
+
+/*******************************************************************************
+ *
+ * Copyright 2002 Integrated Device Technology, Inc.
+ *		All rights reserved.
+ *
+ * UART register definitions.
+ *
+ * File   : $Id: uart.h,v 1.3 2002/06/06 18:34:05 astichte Exp $
+ *
+ * Author : Allen.Stichter@idt.com
+ * Date   : 20020118
+ * Update :
+ *	    $Log: uart.h,v $
+ *	    Revision 1.3  2002/06/06 18:34:05  astichte
+ *	    Added XXX_PhysicalAddress and XXX_VirtualAddress
+ *	
+ *	    Revision 1.2  2002/06/04 17:37:52  astichte
+ *	    Updated register definitions.
+ *	
+ *	    Revision 1.1  2002/05/29 17:33:25  sysarch
+ *	    jba File moved from vcode/include/idt/acacia
+ *	
+ *
+ ******************************************************************************/
+
+#include  <asm/rc32434/types.h>
+
+enum
+{
+	UART_PhysicalAddress	= 0x18058000,
+	UART_PhysicalAddress	= UART_PhysicalAddress,	// Default
+
+	UART_VirtualAddress	= 0xb8058000,
+	UART_VirtualAddress	= UART_VirtualAddress,		// Default
+} ;
+
+/*
+ * Register definitions are in bytes so we can handle endian problems.
+ */
+
+typedef struct UART_s
+{
+	union
+	{
+		U32 const	uartrb ;	// 0x00 - DLAB=0, read.
+		U32		uartth ;	// 0x00 - DLAB=0, write.
+		U32		uartdll ;	// 0x00 - DLAB=1, read/write.
+	} ;
+
+	union
+	{
+		U32		uartie ;	// 0x04 - DLAB=0, read/write.
+		U32		uartdlh ;	// 0x04 - DLAB=1, read/write.
+	} ;
+	union
+	{
+		U32 const	uartii ;	// 0x08 - DLAB=0, read.
+		U32		uartfc ;	// 0x08 - DLAB=0, write.
+	} ;
+
+	U32		uartlc ;		// 0x0c
+	U32		uartmc ;		// 0x10
+	U32		uartls ;		// 0x14
+	U32		uartms ;		// 0x18
+	U32		uarts ;			// 0x1c
+} volatile *UART_t ;
+
+// Reset registers.
+typedef U32	volatile *UARTRR_t ;
+
+enum
+{
+	UARTIE_rda_b	= 0,
+	UARTIE_rda_m	= 0x00000001,
+	UARTIE_the_b	= 1,
+	UARTIE_the_m	= 0x00000002,
+	UARTIE_rls_b	= 2,
+	UARTIE_rls_m	= 0x00000004,
+	UARTIE_ems_b	= 3,
+	UARTIE_ems_m	= 0x00000008,
+
+	UARTII_pi_b	= 0,
+	UARTII_pi_m	= 0x00000001,
+	UARTII_iid_b	= 1,
+	UARTII_iid_m	= 0x0000000e,
+		UARTII_iid_ms_v		= 0,	// Modem stat-CTS,DSR,RI or DCD.
+		UARTII_iid_thre_v	= 1,	// Trans. Holding Reg. empty.
+		UARTII_iid_rda_v	= 2,	// Receive data available
+		UARTII_iid_rls_v	= 3,	// Overrun, parity, etc, error.
+		UARTII_iid_res4_v	= 4,	// reserved.
+		UARTII_iid_res5_v	= 5,	// reserved.
+		UARTII_iid_cto_v	= 6,	// Character timeout.
+		UARTII_iid_res7_v	= 7,	// reserved.
+
+	UARTFC_en_b	= 0,
+	UARTFC_en_m	= 0x00000001,
+	UARTFC_rr_b	= 1,
+	UARTFC_rr_m	= 0x00000002,
+	UARTFC_tr_b	= 2,
+	UARTFC_tr_m	= 0x00000004,
+	UARTFC_dms_b	= 3,
+	UARTFC_dms_m	= 0x00000008,
+	UARTFC_rt_b	= 6,
+	UARTFC_rt_m	= 0x000000c0,
+		UARTFC_rt_1Byte_v	= 0,
+		UARTFC_rt_4Byte_v	= 1,
+		UARTFC_rt_8Byte_v	= 2,
+		UARTFC_rt_14Byte_v	= 3,
+
+	UARTLC_wls_b	= 0,
+	UARTLC_wls_m	= 0x00000003,
+		UARTLC_wls_5Bits_v	= 0,
+		UARTLC_wls_6Bits_v	= 1,
+		UARTLC_wls_7Bits_v	= 2,
+		UARTLC_wls_8Bits_v	= 3,
+	UARTLC_stb_b	= 2,
+	UARTLC_stb_m	= 0x00000004,
+	UARTLC_pen_b	= 3,
+	UARTLC_pen_m	= 0x00000008,
+	UARTLC_eps_b	= 4,
+	UARTLC_eps_m	= 0x00000010,
+	UARTLC_sp_b	= 5,
+	UARTLC_sp_m	= 0x00000020,
+	UARTLC_sb_b	= 6,
+	UARTLC_sb_m	= 0x00000040,
+	UARTLC_dlab_b	= 7,
+	UARTLC_dlab_m	= 0x00000080,
+
+	UARTMC_dtr_b	= 0,
+	UARTMC_dtr_m	= 0x00000001,
+	UARTMC_rts_b	= 1,
+	UARTMC_rts_m	= 0x00000002,
+	UARTMC_o1_b	= 2,
+	UARTMC_o1_m	= 0x00000004,
+	UARTMC_o2_b	= 3,
+	UARTMC_o2_m	= 0x00000008,
+	UARTMC_lp_b	= 4,
+	UARTMC_lp_m	= 0x00000010,
+
+	UARTLS_dr_b	= 0,
+	UARTLS_dr_m	= 0x00000001,
+	UARTLS_oe_b	= 1,
+	UARTLS_oe_m	= 0x00000002,
+	UARTLS_pe_b	= 2,
+	UARTLS_pe_m	= 0x00000004,
+	UARTLS_fe_b	= 3,
+	UARTLS_fe_m	= 0x00000008,
+	UARTLS_bi_b	= 4,
+	UARTLS_bi_m	= 0x00000010,
+	UARTLS_thr_b	= 5,
+	UARTLS_thr_m	= 0x00000020,
+	UARTLS_te_b	= 6,
+	UARTLS_te_m	= 0x00000040,
+	UARTLS_rfe_b	= 7,
+	UARTLS_rfe_m	= 0x00000080,
+
+	UARTMS_dcts_b	= 0,
+	UARTMS_dcts_m	= 0x00000001,
+	UARTMS_ddsr_b	= 1,
+	UARTMS_ddsr_m	= 0x00000002,
+	UARTMS_teri_b	= 2,
+	UARTMS_teri_m	= 0x00000004,
+	UARTMS_ddcd_b	= 3,
+	UARTMS_ddcd_m	= 0x00000008,
+	UARTMS_cts_b	= 4,
+	UARTMS_cts_m	= 0x00000010,
+	UARTMS_dsr_b	= 5,
+	UARTMS_dsr_m	= 0x00000020,
+	UARTMS_ri_b	= 6,
+	UARTMS_ri_m	= 0x00000040,
+	UARTMS_dcd_b	= 7,
+	UARTMS_dcd_m	= 0x00000080,
+} ;
+
+#endif	// __IDT_UART_H__
