diff -urN linux.old/arch/mips/Makefile linux.dev/arch/mips/Makefile
--- linux.old/arch/mips/Makefile	2005-10-21 16:43:16.316951500 +0200
+++ linux.dev/arch/mips/Makefile	2005-11-10 01:10:45.775570250 +0100
@@ -369,6 +369,16 @@
 endif
 
 #
+# Texas Instruments AR7
+#
+
+ifdef CONFIG_AR7
+LIBS		+= arch/mips/ar7/ar7.o
+SUBDIRS		+= arch/mips/ar7
+LOADADDR	+= 0x94020000
+endif
+
+#
 # DECstation family
 #
 ifdef CONFIG_DECSTATION
diff -urN linux.old/arch/mips/ar7/Makefile linux.dev/arch/mips/ar7/Makefile
--- linux.old/arch/mips/ar7/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/Makefile	2005-11-10 01:13:51.443173750 +0100
@@ -0,0 +1,14 @@
+.S.s:
+	$(CPP) $(AFLAGS) $< -o $*.s
+
+.S.o:
+	$(CC) $(AFLAGS) -c $< -o $*.o
+
+EXTRA_CFLAGS := -I$(TOPDIR)/include/asm/ar7 -DLITTLE_ENDIAN -D_LINK_KSEG0_
+O_TARGET := ar7.o
+
+obj-y := tnetd73xx_misc.o misc.o
+export-objs := misc.o irq.o init.o
+obj-y += setup.o irq.o int-handler.o reset.o init.o psp_env.o memory.o promlib.o cmdline.o
+
+include $(TOPDIR)/Rules.make
diff -urN linux.old/arch/mips/ar7/cmdline.c linux.dev/arch/mips/ar7/cmdline.c
--- linux.old/arch/mips/ar7/cmdline.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/cmdline.c	2005-11-10 01:14:16.372731750 +0100
@@ -0,0 +1,88 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Kernel command line creation using the prom monitor (YAMON) argc/argv.
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+
+extern int prom_argc;
+extern int *_prom_argv;
+
+/*
+ * YAMON (32-bit PROM) pass arguments and environment as 32-bit pointer.
+ * This macro take care of sign extension.
+ */
+#define prom_argv(index) ((char *)(((int *)(int)_prom_argv)[(index)]))
+
+char arcs_cmdline[CL_SIZE];
+#ifdef CONFIG_CMDLINE_BOOL
+char __initdata cfg_cmdline[] = CONFIG_CMDLINE;
+#endif
+
+char * __init prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+
+void  __init prom_init_cmdline(void)
+{
+	char *cp, *end;
+	int actr;
+	char *env_cmdline = prom_getenv("kernel_args");
+	size_t len;
+
+	actr = 1; /* Always ignore argv[0] */
+
+	cp = end = &(arcs_cmdline[0]);
+	end += sizeof(arcs_cmdline);
+
+	if (env_cmdline) {
+		len = strlen(env_cmdline);
+		if (len > end - cp - 1)
+			len = end - cp - 1;
+		strncpy(cp, env_cmdline, len);
+		cp += len;
+		*cp++ = ' ';
+	}
+#ifdef CONFIG_CMDLINE_BOOL
+	else {
+		len = strlen(cfg_cmdline);
+		if (len > end - cp - 1)
+			len = end - cp - 1;
+		strncpy(cp, cfg_cmdline, len);
+		cp += len;
+		*cp++ = ' ';
+	}
+#endif
+
+	while(actr < prom_argc) {
+		len = strlen(prom_argv(actr));
+		if (len > end - cp - 1)
+			break;
+		strncpy(cp, prom_argv(actr), len);
+		cp += len;
+		*cp++ = ' ';
+		actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+		--cp;
+	*cp = '\0';
+}
diff -urN linux.old/arch/mips/ar7/init.c linux.dev/arch/mips/ar7/init.c
--- linux.old/arch/mips/ar7/init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/init.c	2005-11-10 01:10:45.795571500 +0100
@@ -0,0 +1,199 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * PROM library initialisation code.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/mips-boards/prom.h>
+#include <asm/mips-boards/generic.h>
+
+#include <asm/ar7/adam2_env.h>
+
+int prom_argc;
+int *_prom_argv, *_prom_envp;
+
+/* max # of Adam2 environment variables */
+#define MAX_ENV_ENTRY 80
+
+static t_env_var local_envp[MAX_ENV_ENTRY];
+static int env_type = 0;
+int init_debug = 0;
+
+unsigned int max_env_entry;
+
+extern char *prom_psp_getenv(char *envname);
+
+static inline char *prom_adam2_getenv(char *envname)
+{
+	/*
+	 * Return a pointer to the given environment variable.
+	 * In 64-bit mode: we're using 64-bit pointers, but all pointers
+	 * in the PROM structures are only 32-bit, so we need some
+	 * workarounds, if we are running in 64-bit mode.
+	 */
+	int i;
+	t_env_var *env = (t_env_var *) local_envp;
+
+	if (strcmp("bootloader", envname) == 0)
+		return "Adam2";
+
+	i = strlen(envname);
+	while (env->name) {
+		if(strncmp(envname, env->name, i) == 0) {
+			return(env->val);
+		}
+		env++;
+	}
+
+	return NULL;
+}
+
+/* XXX "bootloader" won't be returned.
+ * Better make it an element of local_envp */
+static inline t_env_var *
+prom_adam2_iterenv(t_env_var *env) {
+	if (!env)
+	  env = local_envp;
+	else
+	  env++;
+	if (env - local_envp > MAX_ENV_ENTRY || !env->name)
+	  return 0;
+	return env;
+}
+
+char *prom_getenv(char *envname)
+{
+	if (env_type == 1)
+		return prom_psp_getenv(envname);
+	else
+		return prom_adam2_getenv(envname);
+}
+
+t_env_var *
+prom_iterenv(t_env_var *last)
+{
+	if (env_type == 1)
+	  return 0; /* not yet implemented */
+	return prom_adam2_iterenv(last);
+}
+
+static inline unsigned char str2hexnum(unsigned char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	return 0; /* foo */
+}
+
+static inline void str2eaddr(unsigned char *ea, unsigned char *str)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		unsigned char num;
+
+		if((*str == '.') || (*str == ':'))
+			str++;
+		num = str2hexnum(*str++) << 4;
+		num |= (str2hexnum(*str++));
+		ea[i] = num;
+	}
+}
+
+int get_ethernet_addr(char *ethernet_addr)
+{
+	char *ethaddr_str;
+
+	ethaddr_str = prom_getenv("ethaddr");
+	if (!ethaddr_str) {
+		printk("ethaddr not set in boot prom\n");
+		return -1;
+	}
+	str2eaddr(ethernet_addr, ethaddr_str);
+
+	if (init_debug > 1) {
+		int i;
+		printk("get_ethernet_addr: ");
+		for (i=0; i<5; i++)
+			printk("%02x:", (unsigned char)*(ethernet_addr+i));
+		printk("%02x\n", *(ethernet_addr+i));
+	}
+
+	return 0;
+}
+
+struct psbl_rec {
+    unsigned int psbl_size;
+    unsigned int env_base;
+    unsigned int env_size;
+    unsigned int ffs_base;
+    unsigned int ffs_size;
+};
+
+static const char psp_env_version[] = "TIENV0.8";
+
+int __init prom_init(int argc, char **argv, char **envp)
+{
+	int i;
+
+	t_env_var *env = (t_env_var *) envp;
+	struct psbl_rec *psbl = (struct psbl_rec *)(KSEG1ADDR(0x94000300));
+	void *psp_env = (void *)KSEG1ADDR(psbl->env_base);
+
+	prom_argc = argc;
+	_prom_argv = (int *)argv;
+	_prom_envp = (int *)envp;
+
+	if(strcmp(psp_env, psp_env_version) == 0) {
+ 		/* PSPBOOT */
+
+		env_type = 1;
+		_prom_envp = psp_env;
+		max_env_entry = (psbl->env_size / 16) - 1;
+	} else {
+		/* Copy what we need locally so we are not dependent on
+		 * bootloader RAM.  In Adam2, the environment parameters
+		 * are in flash but the table that references them is in
+		 * RAM
+		 */
+
+		for(i=0; i < MAX_ENV_ENTRY; i++, env++) {
+			if (env->name) {
+				local_envp[i].name = env->name;
+				local_envp[i].val = env->val;
+			} else {
+				local_envp[i].name = NULL;
+				local_envp[i].val = NULL;
+			}
+		}
+	}
+
+	set_io_port_base(0);
+
+	prom_printf("\nLINUX started...\n");
+	prom_init_cmdline();
+	prom_meminit();
+
+	return 0;
+}
diff -urN linux.old/arch/mips/ar7/int-handler.S linux.dev/arch/mips/ar7/int-handler.S
--- linux.old/arch/mips/ar7/int-handler.S	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/int-handler.S	2005-11-10 01:12:43.938955000 +0100
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2004 PMC-Sierra Inc.
+ * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ * Adaption for AR7: Enrik Berkhan <enrik@akk.org>
+ *
+ * First-level interrupt dispatcher for the TI AR7
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#define __ASSEMBLY__
+#include <linux/config.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+/*
+ * First level interrupt dispatcher for TI AR7 based boards
+ */
+
+		.align	5
+		NESTED(ar7IRQ, PT_SIZE, sp)
+		SAVE_ALL
+		CLI
+		.set	at
+
+		mfc0	t0, CP0_CAUSE
+		mfc0	t2, CP0_STATUS
+
+		and	t0, t2
+
+		andi	t1, t0, STATUSF_IP2	/* hw0 hardware interrupt */
+		bnez	t1, ll_hw0_irq
+
+		andi	t1, t0, STATUSF_IP7	/* R4k CPU timer */
+		bnez	t1, ll_timer_irq
+
+		.set	reorder
+
+		/* wrong alarm or masked ... */
+		j	spurious_interrupt
+		nop
+		END(ar7IRQ)
+
+		.align	5
+
+ll_hw0_irq:
+		li	a0, 2
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+
+ll_timer_irq:
+		li	a0, 7
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+
+			
diff -urN linux.old/arch/mips/ar7/irq.c linux.dev/arch/mips/ar7/irq.c
--- linux.old/arch/mips/ar7/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/irq.c	2005-11-10 01:12:43.938955000 +0100
@@ -0,0 +1,427 @@
+/*
+ * Nitin Dhingra, iamnd@ti.com
+ * Copyright (C) 2002 Texas Instruments, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Routines for generic manipulation of the interrupts found on the Texas
+ * Instruments avalanche board
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/ar7/ar7.h>
+#include <asm/ar7/avalanche_intc.h>
+
+#define shutdown_avalanche_irq	disable_avalanche_irq
+#define mask_and_ack_avalanche_irq   disable_avalanche_irq
+
+static unsigned int startup_avalanche_irq(unsigned int irq);
+static void end_avalanche_irq(unsigned int irq);
+void enable_avalanche_irq(unsigned int irq_nr);
+void disable_avalanche_irq(unsigned int irq_nr);
+void ar7_hw0_interrupt(int interrupt, void *dev, struct pt_regs *regs);
+
+static struct hw_interrupt_type avalanche_irq_type = {
+	"AR7",
+	startup_avalanche_irq,
+	shutdown_avalanche_irq,
+	enable_avalanche_irq,
+	disable_avalanche_irq,
+	mask_and_ack_avalanche_irq,
+	end_avalanche_irq,
+	NULL
+};
+
+static int ar7_irq_base;
+
+static struct irqaction ar7_hw0_action = {
+    ar7_hw0_interrupt, 0, 0, "AR7 on hw0", NULL, NULL
+};
+
+struct avalanche_ictrl_regs         *avalanche_hw0_icregs;  /* Interrupt control regs (primary)   */
+struct avalanche_exctrl_regs        *avalanche_hw0_ecregs;  /* Exception control regs (secondary) */
+struct avalanche_ipace_regs         *avalanche_hw0_ipaceregs;
+struct avalanche_channel_int_number *avalanche_hw0_chregs;  /* Channel control registers          */
+
+/*
+   This remaps interrupts to exist on other channels than the default
+   channels.  essentially we can use the line # as the index for this
+   array
+ */
+
+static unsigned long line_to_channel[AVINTNUM(AVALANCHE_INT_END_PRIMARY)];
+unsigned long uni_secondary_interrupt = 0;
+
+static void end_avalanche_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_avalanche_irq(irq);
+}
+
+void disable_avalanche_irq(unsigned int irq_nr)
+{
+	unsigned long flags;
+	unsigned long chan_nr=0;
+
+	save_and_cli(flags);
+
+	/* irq_nr represents the line number for the interrupt.  We must
+	 *  disable the channel number associated with that line number.
+	 */
+
+	if(irq_nr > AVALANCHE_INT_END_PRIMARY_REG2)
+		chan_nr = AVINTNUM(irq_nr);                 /*CHECK THIS ALSO*/
+	else
+		chan_nr = line_to_channel[AVINTNUM(irq_nr)];/* WE NEED A LINE TO CHANNEL MAPPING FUNCTION HERE*/
+
+	/* disable the interrupt channel bit */
+
+	/* primary interrupt #'s 0-31 */
+
+	if(chan_nr <= AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG1))
+		avalanche_hw0_icregs->intecr1 = (1 << chan_nr);
+
+	/* primary interrupt #'s 32-39 */
+
+	else if ((chan_nr <= AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG2)) &&
+			(chan_nr > AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG1)))
+		avalanche_hw0_icregs->intecr2 = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_SECONDARY)));
+
+	else  /* secondary interrupt #'s 0-31 */
+		avalanche_hw0_ecregs->exiecr = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_PRIMARY)));
+
+	restore_flags(flags);
+}
+
+void enable_avalanche_irq(unsigned int irq_nr)
+{
+	unsigned long flags;
+	unsigned long chan_nr=0;
+
+	save_and_cli(flags);
+
+	/* irq_nr represents the line number for the interrupt.  We must
+	 *  disable the channel number associated with that line number.
+	 */
+
+	if(irq_nr > AVALANCHE_INT_END_PRIMARY_REG2)
+		chan_nr = AVINTNUM(irq_nr);
+	else
+		chan_nr = line_to_channel[AVINTNUM(irq_nr)];
+
+	/* enable the interrupt channel  bit */
+
+	/* primary interrupt #'s 0-31 */
+	if(chan_nr <= AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG1))
+		avalanche_hw0_icregs->intesr1 = (1 << chan_nr);
+
+	/* primary interrupt #'s 32 throuth 39 */
+	else if ((chan_nr <= AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG2)) &&
+			(chan_nr > AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG1)))
+		avalanche_hw0_icregs->intesr2 = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_SECONDARY)));
+
+	else    /* secondary interrupt #'s 0-31 */
+		avalanche_hw0_ecregs->exiesr = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_PRIMARY)));
+
+	restore_flags(flags);
+}
+
+static unsigned int startup_avalanche_irq(unsigned int irq)
+{
+	enable_avalanche_irq(irq);
+	return 0; /* never anything pending */
+}
+
+void __init ar7_irq_init(int base)
+{
+	int i;
+
+	avalanche_hw0_icregs = (struct avalanche_ictrl_regs *)AVALANCHE_ICTRL_REGS_BASE;
+	avalanche_hw0_ecregs = (struct avalanche_exctrl_regs *)AVALANCHE_ECTRL_REGS_BASE;
+	avalanche_hw0_ipaceregs = (struct avalanche_ipace_regs *)AVALANCHE_IPACE_REGS_BASE;
+	avalanche_hw0_chregs = (struct avalanche_channel_int_number *)AVALANCHE_CHCTRL_REGS_BASE;
+
+	/*  Disable interrupts and clear pending
+	 */
+
+	avalanche_hw0_icregs->intecr1 = 0xffffffff;    /* disable interrupts 0:31  */
+	avalanche_hw0_icregs->intcr1 = 0xffffffff;     /* clear interrupts 0:31    */
+	avalanche_hw0_icregs->intecr2 = 0xff;          /* disable interrupts 32:39 */
+	avalanche_hw0_icregs->intcr2 = 0xff;           /* clear interrupts 32:39   */
+	avalanche_hw0_ecregs->exiecr = 0xffffffff;     /* disable secondary interrupts 0:31 */
+	avalanche_hw0_ecregs->excr = 0xffffffff;       /* clear secondary interrupts 0:31 */
+
+
+	// avalanche_hw0_ipaceregs->ipacep = (2*get_avalanche_vbus_freq()/1000000)*4;
+	/* hack for speeding up the pacing. */
+	printk("the pacing pre-scalar has been set as 600.\n");
+	avalanche_hw0_ipaceregs->ipacep = 600;
+	/* Channel to line mapping, Line to Channel mapping */
+
+	for(i = 0; i < 40; i++)
+		avalanche_int_set(i,i);
+
+	ar7_irq_base = base;
+	for (i = base; i <= base+40; i++)
+	{
+		irq_desc[i].status	= IRQ_DISABLED;
+		irq_desc[i].action	= 0;
+		irq_desc[i].depth	= 1;
+		irq_desc[i].handler	= &avalanche_irq_type;
+	}
+
+	setup_irq(2, &ar7_hw0_action);
+	set_c0_status(IE_IRQ0);
+
+	return;
+}
+
+void ar7_hw0_interrupt(int interrupt, void *dev, struct pt_regs *regs)
+{
+	int irq;
+	unsigned long int_line_number, status;
+	int i, chan_nr = 0;
+
+	int_line_number = ((avalanche_hw0_icregs->pintir >> 16) & 0x3F);
+	chan_nr = ((avalanche_hw0_icregs->pintir) & 0x3F);
+
+	if(chan_nr < 32) /* primary 0-31 */
+	{
+		if( chan_nr != uni_secondary_interrupt)
+			avalanche_hw0_icregs->intcr1 = (1<<chan_nr);
+
+	}
+
+	if((chan_nr < 40) && (chan_nr > 31)) /* primary 32-39 */
+	{
+		avalanche_hw0_icregs->intcr2 = (1<<(chan_nr-32));
+	}
+
+
+	/* If the Priority Interrupt Index Register returns 40  then no
+	 * interrupts are pending
+	 */
+
+	if(chan_nr == 40)
+		return;
+
+	if(chan_nr == uni_secondary_interrupt) /* secondary 0-31 */
+	{
+		status = avalanche_hw0_ecregs->exsr;
+		for(i=0; i < 32; i++)
+		{
+			if (status & 1<<i)
+			{
+				/* clear secondary interrupt */
+				avalanche_hw0_ecregs->excr = 1 << i;
+				break;
+			}
+		}
+		irq = i+40;
+
+		/* clear the universal secondary interrupt */
+		avalanche_hw0_icregs->intcr1 = 1 << uni_secondary_interrupt;
+
+	}
+	else
+		irq = chan_nr;
+
+	do_IRQ(irq + ar7_irq_base, regs);
+	return;
+}
+
+void avalanche_int_set(int channel, int line)
+{
+	switch(channel)
+	{
+		case(0):
+			avalanche_hw0_chregs->cintnr0 =  line;
+			break;
+		case(1):
+			avalanche_hw0_chregs->cintnr1 =  line;
+			break;
+		case(2):
+			avalanche_hw0_chregs->cintnr2 =  line;
+			break;
+		case(3):
+			avalanche_hw0_chregs->cintnr3 =  line;
+			break;
+		case(4):
+			avalanche_hw0_chregs->cintnr4 =  line;
+			break;
+		case(5):
+			avalanche_hw0_chregs->cintnr5 =  line;
+			break;
+		case(6):
+			avalanche_hw0_chregs->cintnr6 =  line;
+			break;
+		case(7):
+			avalanche_hw0_chregs->cintnr7 =  line;
+			break;
+		case(8):
+			avalanche_hw0_chregs->cintnr8 =  line;
+			break;
+		case(9):
+			avalanche_hw0_chregs->cintnr9 =  line;
+			break;
+		case(10):
+			avalanche_hw0_chregs->cintnr10 = line;
+			break;
+		case(11):
+			avalanche_hw0_chregs->cintnr11 = line;
+			break;
+		case(12):
+			avalanche_hw0_chregs->cintnr12 = line;
+			break;
+		case(13):
+			avalanche_hw0_chregs->cintnr13 = line;
+			break;
+		case(14):
+			avalanche_hw0_chregs->cintnr14 = line;
+			break;
+		case(15):
+			avalanche_hw0_chregs->cintnr15 = line;
+			break;
+		case(16):
+			avalanche_hw0_chregs->cintnr16 = line;
+			break;
+		case(17):
+			avalanche_hw0_chregs->cintnr17 = line;
+			break;
+		case(18):
+			avalanche_hw0_chregs->cintnr18 = line;
+			break;
+		case(19):
+			avalanche_hw0_chregs->cintnr19 = line;
+			break;
+		case(20):
+			avalanche_hw0_chregs->cintnr20 = line;
+			break;
+		case(21):
+			avalanche_hw0_chregs->cintnr21 = line;
+			break;
+		case(22):
+			avalanche_hw0_chregs->cintnr22 = line;
+			break;
+		case(23):
+			avalanche_hw0_chregs->cintnr23 = line;
+			break;
+		case(24):
+			avalanche_hw0_chregs->cintnr24 = line;
+			break;
+		case(25):
+			avalanche_hw0_chregs->cintnr25 = line;
+			break;
+		case(26):
+			avalanche_hw0_chregs->cintnr26 = line;
+			break;
+		case(27):
+			avalanche_hw0_chregs->cintnr27 = line;
+			break;
+		case(28):
+			avalanche_hw0_chregs->cintnr28 = line;
+			break;
+		case(29):
+			avalanche_hw0_chregs->cintnr29 = line;
+			break;
+		case(30):
+			avalanche_hw0_chregs->cintnr30 = line;
+			break;
+		case(31):
+			avalanche_hw0_chregs->cintnr31 = line;
+			break;
+		case(32):
+			avalanche_hw0_chregs->cintnr32 = line;
+			break;
+		case(33):
+			avalanche_hw0_chregs->cintnr33 = line;
+			break;
+		case(34):
+			avalanche_hw0_chregs->cintnr34 = line;
+			break;
+		case(35):
+			avalanche_hw0_chregs->cintnr35 = line;
+			break;
+		case(36):
+			avalanche_hw0_chregs->cintnr36 = line;
+			break;
+		case(37):
+			avalanche_hw0_chregs->cintnr37 = line;
+			break;
+		case(38):
+			avalanche_hw0_chregs->cintnr38 = line;
+			break;
+		case(39):
+			avalanche_hw0_chregs->cintnr39 = line;
+			break;
+		default:
+			printk("Error: Unknown Avalanche interrupt channel\n");
+	}
+
+	line_to_channel[line] = channel; /* Suraj check */
+
+	if (channel == UNIFIED_SECONDARY_INTERRUPT)
+		uni_secondary_interrupt = line;
+
+}
+
+
+#define AVALANCHE_MAX_PACING_BLK   3
+#define AVALANCHE_PACING_LOW_VAL   2
+#define AVALANCHE_PACING_HIGH_VAL 63
+
+int avalanche_request_pacing(int irq_nr, unsigned int blk_num,
+                            unsigned int pace_value)
+{
+    unsigned int  blk_offset;
+    unsigned long flags;
+
+    if(irq_nr < MIPS_EXCEPTION_OFFSET &&
+       irq_nr >= AVALANCHE_INT_END_PRIMARY)
+        return (0);
+
+    if(blk_num > AVALANCHE_MAX_PACING_BLK)
+        return(-1);
+
+    if(pace_value > AVALANCHE_PACING_HIGH_VAL &&
+       pace_value < AVALANCHE_PACING_LOW_VAL)
+       return(-1);
+
+    blk_offset = blk_num*8;
+
+    save_and_cli(flags);
+
+    /* disable the interrupt pacing, if enabled previously */
+    avalanche_hw0_ipaceregs->ipacemax &= ~(0xff << blk_offset);
+
+    /* clear the pacing map */
+    avalanche_hw0_ipaceregs->ipacemap &= ~(0xff << blk_offset);
+
+    /* setup the new values */
+    avalanche_hw0_ipaceregs->ipacemap |= ((AVINTNUM(irq_nr))   << blk_offset);
+    avalanche_hw0_ipaceregs->ipacemax |= ((0x80 | pace_value)  << blk_offset);
+
+    restore_flags(flags);
+
+    return(0);
+}
diff -urN linux.old/arch/mips/ar7/memory.c linux.dev/arch/mips/ar7/memory.c
--- linux.old/arch/mips/ar7/memory.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/memory.c	2005-11-10 01:14:16.372731750 +0100
@@ -0,0 +1,103 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <asm/mips-boards/prom.h>
+
+extern char _ftext;
+extern int preserve_adam2;
+
+void __init prom_meminit(void)
+{
+	char *memsize_str;
+	unsigned long memsize, adam2size;
+
+	/* assume block before kernel is used by bootloader */
+	adam2size = __pa(&_ftext) - PHYS_OFFSET;
+
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x02000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+
+#if 0
+	add_memory_region(0x00000000, PHYS_OFFSET, BOOT_MEM_RESERVED);
+#endif
+	add_memory_region(PHYS_OFFSET, adam2size, BOOT_MEM_ROM_DATA);
+	add_memory_region(PHYS_OFFSET+adam2size, memsize-adam2size,
+			  BOOT_MEM_RAM);
+}
+
+unsigned long __init prom_free_prom_memory (void)
+{
+	int i;
+	unsigned long freed = 0;
+	unsigned long addr;
+
+	if (preserve_adam2) {
+		char *firstfree_str = prom_getenv("firstfreeaddress");
+		unsigned long firstfree = 0;
+
+		if (firstfree_str)
+			firstfree = simple_strtol(firstfree_str, NULL, 0);
+
+		if (firstfree && firstfree < (unsigned long)&_ftext) {
+			printk("Preserving ADAM2 memory.\n");
+		} else if (firstfree) {
+			printk("Can't preserve ADAM2 memory, "
+			       "firstfreeaddress = %08lx.\n", firstfree);
+			preserve_adam2 = 0;
+		} else {
+			printk("Can't preserve ADAM2 memory, "
+			       "firstfreeaddress unknown!\n");
+			preserve_adam2 = 0;
+		}
+	}
+
+	if (!preserve_adam2) {
+		for (i = 0; i < boot_mem_map.nr_map; i++) {
+			if (boot_mem_map.map[i].type != BOOT_MEM_ROM_DATA)
+				continue;
+
+			addr = boot_mem_map.map[i].addr;
+			while (addr < boot_mem_map.map[i].addr
+				+ boot_mem_map.map[i].size) {
+				ClearPageReserved(virt_to_page(__va(addr)));
+				set_page_count(virt_to_page(__va(addr)), 1);
+				free_page((unsigned long)__va(addr));
+				addr += PAGE_SIZE;
+				freed += PAGE_SIZE;
+			}
+		}
+		printk("Freeing prom memory: %ldkb freed\n", freed >> 10);
+	}
+	return freed >> PAGE_SHIFT;
+}
diff -urN linux.old/arch/mips/ar7/misc.c linux.dev/arch/mips/ar7/misc.c
--- linux.old/arch/mips/ar7/misc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/misc.c	2005-11-10 01:12:43.946955500 +0100
@@ -0,0 +1,322 @@
+#include <asm/ar7/sangam.h>
+#include <asm/ar7/avalanche_misc.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+
+#define TRUE 1
+
+static unsigned int avalanche_vbus_freq;
+
+REMOTE_VLYNQ_DEV_RESET_CTRL_FN p_remote_vlynq_dev_reset_ctrl = NULL;
+
+/*****************************************************************************
+ * Reset Control Module.
+ *****************************************************************************/
+void avalanche_reset_ctrl(unsigned int module_reset_bit, 
+                          AVALANCHE_RESET_CTRL_T reset_ctrl)
+{
+    volatile unsigned int *reset_reg = (unsigned int*) AVALANCHE_RST_CTRL_PRCR;
+   
+    if(module_reset_bit >= 32 && module_reset_bit < 64)
+        return;
+
+    if(module_reset_bit >= 64)
+    {
+        if(p_remote_vlynq_dev_reset_ctrl) {
+            p_remote_vlynq_dev_reset_ctrl(module_reset_bit - 64, reset_ctrl);
+	    return;
+	}
+        else
+            return;
+    }
+    
+    if(reset_ctrl == OUT_OF_RESET)
+        *reset_reg |= 1 << module_reset_bit;
+    else
+        *reset_reg &= ~(1 << module_reset_bit);
+    return;
+}
+
+AVALANCHE_RESET_CTRL_T avalanche_get_reset_status(unsigned int module_reset_bit)
+{
+    volatile unsigned int *reset_reg = (unsigned int*) AVALANCHE_RST_CTRL_PRCR;
+
+    return (((*reset_reg) & (1 << module_reset_bit)) ? OUT_OF_RESET : IN_RESET );
+}
+
+void avalanche_sys_reset(AVALANCHE_SYS_RST_MODE_T mode)
+{
+    volatile unsigned int *sw_reset_reg = (unsigned int*) AVALANCHE_RST_CTRL_SWRCR;
+    *sw_reset_reg =  mode;
+}
+
+#define AVALANCHE_RST_CTRL_RSR_MASK 0x3
+
+AVALANCHE_SYS_RESET_STATUS_T avalanche_get_sys_last_reset_status()
+{
+    volatile unsigned int *sys_reset_status = (unsigned int*) AVALANCHE_RST_CTRL_RSR;
+
+    return ( (AVALANCHE_SYS_RESET_STATUS_T) (*sys_reset_status & AVALANCHE_RST_CTRL_RSR_MASK) );
+}
+
+
+/*****************************************************************************
+ * Power Control Module
+ *****************************************************************************/
+#define AVALANCHE_GLOBAL_POWER_DOWN_MASK    0x3FFFFFFF      /* bit 31, 30 masked */
+#define AVALANCHE_GLOBAL_POWER_DOWN_BIT     30              /* shift to bit 30, 31 */
+
+
+void avalanche_power_ctrl(unsigned int module_power_bit, AVALANCHE_POWER_CTRL_T power_ctrl)
+{
+    volatile unsigned int *power_reg = (unsigned int*)AVALANCHE_POWER_CTRL_PDCR;
+
+    if (power_ctrl == POWER_CTRL_POWER_DOWN)
+        /* power down the module */
+        *power_reg |= (1 << module_power_bit);
+    else
+        /* power on the module */
+        *power_reg &= (~(1 << module_power_bit));
+}
+
+AVALANCHE_POWER_CTRL_T avalanche_get_power_status(unsigned int module_power_bit)
+{
+    volatile unsigned int *power_status_reg = (unsigned int*)AVALANCHE_POWER_CTRL_PDCR;
+
+    return (((*power_status_reg) & (1 << module_power_bit)) ? POWER_CTRL_POWER_DOWN : POWER_CTRL_POWER_UP);
+}
+
+void avalanche_set_global_power_mode(AVALANCHE_SYS_POWER_MODE_T power_mode)
+{
+    volatile unsigned int *power_status_reg = (unsigned int*)AVALANCHE_POWER_CTRL_PDCR;
+
+    *power_status_reg &= AVALANCHE_GLOBAL_POWER_DOWN_MASK;
+    *power_status_reg |= ( power_mode << AVALANCHE_GLOBAL_POWER_DOWN_BIT);
+}
+
+AVALANCHE_SYS_POWER_MODE_T avalanche_get_global_power_mode(void)
+{
+    volatile unsigned int *power_status_reg = (unsigned int*)AVALANCHE_POWER_CTRL_PDCR;
+
+    return((AVALANCHE_SYS_POWER_MODE_T) (((*power_status_reg) & (~AVALANCHE_GLOBAL_POWER_DOWN_MASK)) 
+                                           >> AVALANCHE_GLOBAL_POWER_DOWN_BIT));
+}
+
+/*****************************************************************************
+ * GPIO  Control
+ *****************************************************************************/
+
+/****************************************************************************
+ * FUNCTION: avalanche_gpio_init
+ ***************************************************************************/
+void avalanche_gpio_init(void)
+{
+    spinlock_t closeLock;
+    unsigned int closeFlag;
+    volatile unsigned int *reset_reg = (unsigned int*) AVALANCHE_RST_CTRL_PRCR;
+    spin_lock_irqsave(&closeLock, closeFlag);
+    *reset_reg |= (1 << AVALANCHE_GPIO_RESET_BIT);
+    spin_unlock_irqrestore(&closeLock, closeFlag);  
+}
+
+/****************************************************************************
+ * FUNCTION: avalanche_gpio_ctrl
+ ***************************************************************************/
+int avalanche_gpio_ctrl(unsigned int gpio_pin,
+                        AVALANCHE_GPIO_PIN_MODE_T pin_mode,
+                        AVALANCHE_GPIO_PIN_DIRECTION_T pin_direction)
+{
+    spinlock_t closeLock;
+    unsigned int closeFlag;
+    volatile unsigned int *gpio_ctrl = (unsigned int*)AVALANCHE_GPIO_ENBL;
+
+    if(gpio_pin >= 32)
+        return(-1);
+
+    spin_lock_irqsave(&closeLock, closeFlag);
+
+    if(pin_mode == GPIO_PIN)
+    {
+        *gpio_ctrl |= (1 << gpio_pin);
+
+	gpio_ctrl = (unsigned int*)AVALANCHE_GPIO_DIR;
+        
+        if(pin_direction == GPIO_INPUT_PIN)
+            *gpio_ctrl |=  (1 << gpio_pin);
+        else
+            *gpio_ctrl &= ~(1 << gpio_pin);
+    }
+    else /* FUNCTIONAL PIN */
+    {
+        *gpio_ctrl &= ~(1 << gpio_pin);
+    }
+  
+    spin_unlock_irqrestore(&closeLock, closeFlag);  
+
+    return (0);
+}
+
+/****************************************************************************
+ * FUNCTION: avalanche_gpio_out
+ ***************************************************************************/
+int avalanche_gpio_out_bit(unsigned int gpio_pin, int value)
+{
+    spinlock_t closeLock;
+    unsigned int closeFlag;
+    volatile unsigned int *gpio_out = (unsigned int*) AVALANCHE_GPIO_DATA_OUT;
+ 
+    if(gpio_pin >= 32)
+        return(-1);
+    
+    spin_lock_irqsave(&closeLock, closeFlag);
+    if(value == TRUE)
+        *gpio_out |= 1 << gpio_pin;
+    else
+	*gpio_out &= ~(1 << gpio_pin);
+    spin_unlock_irqrestore(&closeLock, closeFlag);
+
+    return(0);
+}
+
+/****************************************************************************
+ * FUNCTION: avalanche_gpio_in
+ ***************************************************************************/
+int avalanche_gpio_in_bit(unsigned int gpio_pin)
+{
+    spinlock_t closeLock;
+    unsigned int closeFlag;
+    volatile unsigned int *gpio_in = (unsigned int*) AVALANCHE_GPIO_DATA_IN;
+    int ret_val = 0;
+    
+    if(gpio_pin >= 32)
+        return(-1);
+
+    spin_lock_irqsave(&closeLock, closeFlag); 
+    ret_val = ((*gpio_in) & (1 << gpio_pin));
+    spin_unlock_irqrestore(&closeLock, closeFlag);
+ 
+    return (ret_val);
+}
+
+/****************************************************************************
+ * FUNCTION: avalanche_gpio_out_val
+ ***************************************************************************/
+int avalanche_gpio_out_value(unsigned int out_val, unsigned int out_mask, 
+                           unsigned int reg_index)
+{
+    spinlock_t closeLock;
+    unsigned int closeFlag;
+    volatile unsigned int *gpio_out = (unsigned int*) AVALANCHE_GPIO_DATA_OUT;
+
+    if(reg_index > 0)
+        return(-1);
+
+    spin_lock_irqsave(&closeLock, closeFlag);
+    *gpio_out &= ~out_mask;
+    *gpio_out |= out_val;
+    spin_unlock_irqrestore(&closeLock, closeFlag);
+
+    return(0);
+}
+
+/****************************************************************************
+ * FUNCTION: avalanche_gpio_in_value
+ ***************************************************************************/
+int avalanche_gpio_in_value(unsigned int* in_val, unsigned int reg_index)
+{
+    spinlock_t closeLock;
+    unsigned int closeFlag;
+    volatile unsigned int *gpio_in = (unsigned int*) AVALANCHE_GPIO_DATA_IN;
+ 
+    if(reg_index > 0)
+        return(-1);
+
+    spin_lock_irqsave(&closeLock, closeFlag);
+    *in_val = *gpio_in;
+    spin_unlock_irqrestore(&closeLock, closeFlag);
+
+    return (0);
+}
+
+/***********************************************************************
+ *
+ *    Wakeup Control Module for TNETV1050 Communication Processor
+ *
+ ***********************************************************************/
+
+#define AVALANCHE_WAKEUP_POLARITY_BIT   16
+
+void avalanche_wakeup_ctrl(AVALANCHE_WAKEUP_INTERRUPT_T wakeup_int,
+                           AVALANCHE_WAKEUP_CTRL_T      wakeup_ctrl,
+                           AVALANCHE_WAKEUP_POLARITY_T  wakeup_polarity)
+{
+    volatile unsigned int *wakeup_status_reg = (unsigned int*) AVALANCHE_WAKEUP_CTRL_WKCR;
+
+    /* enable/disable */
+    if (wakeup_ctrl == WAKEUP_ENABLED)
+        /* enable wakeup */
+        *wakeup_status_reg |= wakeup_int;
+    else
+        /* disable wakeup */
+        *wakeup_status_reg &= (~wakeup_int);
+
+    /* set polarity */
+    if (wakeup_polarity == WAKEUP_ACTIVE_LOW)
+        *wakeup_status_reg |=  (wakeup_int << AVALANCHE_WAKEUP_POLARITY_BIT);
+    else
+        *wakeup_status_reg &= ~(wakeup_int << AVALANCHE_WAKEUP_POLARITY_BIT);
+}
+
+void avalanche_set_vbus_freq(unsigned int new_vbus_freq)
+{
+    avalanche_vbus_freq = new_vbus_freq;
+}
+
+unsigned int avalanche_get_vbus_freq()
+{
+    return(avalanche_vbus_freq);
+}
+
+unsigned int avalanche_get_chip_version_info()
+{
+    return(*(volatile unsigned int*)AVALANCHE_CVR);
+}
+
+SET_MDIX_ON_CHIP_FN_T p_set_mdix_on_chip_fn = NULL;
+
+int avalanche_set_mdix_on_chip(unsigned int base_addr, unsigned int operation)
+{
+    if(p_set_mdix_on_chip_fn)
+        return (p_set_mdix_on_chip_fn(base_addr, operation));
+    else
+        return(-1);
+}
+
+unsigned int avalanche_is_mdix_on_chip(void)
+{
+    return(p_set_mdix_on_chip_fn ? 1:0);
+}
+
+EXPORT_SYMBOL(avalanche_reset_ctrl);
+EXPORT_SYMBOL(avalanche_get_reset_status);
+EXPORT_SYMBOL(avalanche_sys_reset);
+EXPORT_SYMBOL(avalanche_get_sys_last_reset_status);
+EXPORT_SYMBOL(avalanche_power_ctrl);
+EXPORT_SYMBOL(avalanche_get_power_status);
+EXPORT_SYMBOL(avalanche_set_global_power_mode);
+EXPORT_SYMBOL(avalanche_get_global_power_mode);
+EXPORT_SYMBOL(avalanche_set_mdix_on_chip);
+EXPORT_SYMBOL(avalanche_is_mdix_on_chip);
+
+EXPORT_SYMBOL(avalanche_gpio_init);
+EXPORT_SYMBOL(avalanche_gpio_ctrl);
+EXPORT_SYMBOL(avalanche_gpio_out_bit);
+EXPORT_SYMBOL(avalanche_gpio_in_bit);
+EXPORT_SYMBOL(avalanche_gpio_out_value);
+EXPORT_SYMBOL(avalanche_gpio_in_value);
+
+EXPORT_SYMBOL(avalanche_set_vbus_freq);
+EXPORT_SYMBOL(avalanche_get_vbus_freq);
+
+EXPORT_SYMBOL(avalanche_get_chip_version_info);
+
diff -urN linux.old/arch/mips/ar7/platform.h linux.dev/arch/mips/ar7/platform.h
--- linux.old/arch/mips/ar7/platform.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/platform.h	2005-11-10 01:10:45.799571750 +0100
@@ -0,0 +1,65 @@
+#ifndef _PLATFORM_H_
+#define _PLATFORM_H_
+
+#include <linux/config.h>
+
+
+/* Important: The definition of ENV_SPACE_SIZE should match with that in
+ * PSPBoot. (/psp_boot/inc/psbl/env.h)
+ */
+#ifdef CONFIG_MIPS_AVALANCHE_TICFG
+#define ENV_SPACE_SIZE      (10 * 1024)
+#endif
+
+#ifdef CONFIG_MIPS_TNETV1050SDB
+#define TNETV1050SDB
+#define DUAL_FLASH
+#endif
+
+#ifdef CONFIG_MIPS_AR7DB
+#define TNETD73XX_BOARD
+#define AR7DB
+#endif
+
+#ifdef CONFIG_MIPS_AR7RD
+#define TNETD73XX_BOARD
+#define AR7RD
+#endif
+
+#ifdef CONFIG_AR7WRD
+#define TNETD73XX_BOARD
+#define AR7WRD
+#endif
+
+#ifdef CONFIG_MIPS_AR7VWI
+#define TNETD73XX_BOARD
+#define AR7VWi
+#endif
+
+/* Merging from the DEV_DSL-PSPL4.3.2.7_Patch release. */
+#ifdef CONFIG_MIPS_AR7VW
+#define TNETD73XX_BOARD
+#define AR7WRD
+#endif
+
+#ifdef CONFIG_MIPS_AR7WI
+#define TNETD73XX_BOARD
+#define AR7Wi
+#endif
+
+#ifdef CONFIG_MIPS_AR7V
+#define TNETD73XX_BOARD
+#define AR7V
+#endif
+
+#ifdef CONFIG_MIPS_AR7V
+#define TNETD73XX_BOARD
+#define AR7V
+#endif
+
+#ifdef CONFIG_MIPS_WA1130
+#define AVALANCHE
+#define WLAN
+#endif
+
+#endif
diff -urN linux.old/arch/mips/ar7/promlib.c linux.dev/arch/mips/ar7/promlib.c
--- linux.old/arch/mips/ar7/promlib.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/promlib.c	2005-11-10 01:14:16.372731750 +0100
@@ -0,0 +1,48 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Putting things on the screen/serial line using Adam2 facilities.
+ */
+
+#include <linux/types.h>
+#include <asm/addrspace.h>
+
+#define AVALANCHE_YAMON_FUNCTION_BASE (KSEG1ADDR(0x10000500))
+#define AVALANCHE_YAMON_PROM_PRINT_COUNT_ADDR \
+          (AVALANCHE_YAMON_FUNCTION_BASE + 1 * 0x4)
+#define AVALANCHE_YAMON_PROM_EXIT \
+          (AVALANCHE_YAMON_FUNCTION_BASE + 8 * 0x4)
+
+void prom_putchar(char c)
+{
+ 	static char buf[1];
+	void (*prom_print_str)(unsigned int dummy, char *s, int len) =
+	  (void *)(*(uint32_t *)AVALANCHE_YAMON_PROM_PRINT_COUNT_ADDR);
+
+	buf[0] = c;
+	prom_print_str(1, buf, 1);
+	return;
+}
+
+void adam2_exit(int retval)
+{
+	void (*yamon_exit)(int retval) =
+	  (void *)(*(uint32_t *)AVALANCHE_YAMON_PROM_EXIT);
+
+	yamon_exit(retval);
+	return;
+}
diff -urN linux.old/arch/mips/ar7/psp_env.c linux.dev/arch/mips/ar7/psp_env.c
--- linux.old/arch/mips/ar7/psp_env.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/psp_env.c	2005-11-10 01:10:45.799571750 +0100
@@ -0,0 +1,350 @@
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/io.h>
+
+#include "platform.h"
+
+#define ENV_CELL_SIZE           16
+
+/* control field decode */
+#define ENV_GARBAGE_BIT                 0x01    /* Env is garbage if this bit is off */
+#define ENV_DYNAMIC_BIT                 0x02    /* Env is dynamic if this bit is off */
+
+#define ENV_CTRL_MASK                   0x03
+#define ENV_PREFINED                    (ENV_GARBAGE_BIT | ENV_DYNAMIC_BIT)
+#define ENV_DYNAMIC                     (ENV_GARBAGE_BIT)
+
+struct env_variable {
+    unsigned char   varNum;
+    unsigned char   ctrl;
+    unsigned short  chksum;
+    unsigned char   numCells;
+    unsigned char   data[ENV_CELL_SIZE - 5];    /* The data section starts
+                                                 * here, continues for
+                                                 * numCells.
+                                                 */
+};
+
+extern unsigned int max_env_entry;
+
+/* Internal macros */
+#define get_next_block(var)    ((struct env_variable *)( (char*)(var) + (var)->numCells * ENV_CELL_SIZE))
+
+typedef enum ENV_VARS {
+        env_vars_start = 0,
+        CPUFREQ,
+        MEMSZ,
+        FLASHSZ,
+        MODETTY0,
+        MODETTY1,
+        PROMPT,
+        BOOTCFG,
+        HWA_0,
+#if !defined (AVALANCHE) || defined(TNETC401B)
+        HWA_1,
+#endif
+#if !defined(TNETV1020_BOARD)
+        HWA_RNDIS,
+#endif
+#if defined (TNETD73XX_BOARD)
+        HWA_3,
+#endif
+        IPA,
+        IPA_SVR,
+        BLINE_MAC0,
+#if !defined (AVALANCHE) || defined(TNETC401B)
+        BLINE_MAC1,
+#endif
+#if !defined(TNETV1020_BOARD)
+        BLINE_RNDIS,
+#endif
+#if defined (TNETD73XX_BOARD)
+        BLINE_ATM,
+#endif
+#if !defined(TNETV1020_BOARD)
+        USB_PID,
+        USB_VID,
+        USB_EPPOLLI,
+#endif
+        IPA_GATEWAY,
+        SUBNET_MASK,
+#if defined (TNETV1050_BOARD)
+	BLINE_ESWITCH,
+#endif
+#if !defined(TNETV1020_BOARD)
+	USB_SERIAL,
+	HWA_HRNDIS,      /* Host (PC) side RNDIS address */
+#endif
+	REMOTE_USER,
+	REMOTE_PASS,
+	REMOTE_DIR,
+	SYSFREQ,
+	LINK_TIMEOUT,
+#ifndef AVALANCHE     /* Avalanche boards use only one mac port */
+	MAC_PORT,
+#endif
+	PATH,
+	HOSTNAME,
+#ifdef WLAN
+	HW_REV_MAJOR,
+	HW_REV_MINOR,
+	HW_PATCH,
+	SW_PATCH,
+	SERIAL_NUMBER,
+#endif
+	TFTPCFG,
+#if defined (TNETV1050_BOARD)
+	HWA_ESWITCH,
+#endif
+        /*
+         * Add new env variables here.
+         * NOTE: New environment variables should always be placed at the end, ie
+         *       just before env_vars_end.
+         */
+
+        env_vars_end
+} ENV_VARS;
+
+
+struct env_description {
+        ENV_VARS   idx;
+        char      *nm;
+	char      *alias;
+};
+
+#define ENVSTR(x)         #x
+#define _ENV_ENTRY(x)     {.idx = x, .nm = ENVSTR(x), .alias = NULL}
+
+struct env_description env_ns[] = {
+        _ENV_ENTRY(env_vars_start), /* start. */
+        _ENV_ENTRY(CPUFREQ),
+        _ENV_ENTRY(MEMSZ),
+        _ENV_ENTRY(FLASHSZ),
+        _ENV_ENTRY(MODETTY0),
+        _ENV_ENTRY(MODETTY1),
+        _ENV_ENTRY(PROMPT),
+        _ENV_ENTRY(BOOTCFG),
+        _ENV_ENTRY(HWA_0),
+#if !defined (AVALANCHE) || defined(TNETC401B)
+        _ENV_ENTRY(HWA_1),
+#endif
+#if !defined(TNETV1020_BOARD)
+        _ENV_ENTRY(HWA_RNDIS),
+#endif
+#if defined (TNETD73XX_BOARD)
+        _ENV_ENTRY(HWA_3),
+#endif
+        _ENV_ENTRY(IPA),
+        _ENV_ENTRY(IPA_SVR),
+        _ENV_ENTRY(IPA_GATEWAY),
+        _ENV_ENTRY(SUBNET_MASK),
+        _ENV_ENTRY(BLINE_MAC0),
+#if !defined (AVALANCHE) || defined(TNETC401B)
+        _ENV_ENTRY(BLINE_MAC1),
+#endif
+#if !defined(TNETV1020_BOARD)
+        _ENV_ENTRY(BLINE_RNDIS),
+#endif
+#if defined (TNETD73XX_BOARD)
+        _ENV_ENTRY(BLINE_ATM),
+#endif
+#if !defined(TNETV1020_BOARD)
+        _ENV_ENTRY(USB_PID),
+        _ENV_ENTRY(USB_VID),
+        _ENV_ENTRY(USB_EPPOLLI),
+#endif
+#if defined (TNETV1050_BOARD)
+        _ENV_ENTRY(BLINE_ESWITCH),
+#endif
+#if !defined(TNETV1020_BOARD)
+        _ENV_ENTRY(USB_SERIAL),
+        _ENV_ENTRY(HWA_HRNDIS),
+#endif
+	_ENV_ENTRY(REMOTE_USER),
+	_ENV_ENTRY(REMOTE_PASS),
+	_ENV_ENTRY(REMOTE_DIR),
+	_ENV_ENTRY(SYSFREQ),
+	_ENV_ENTRY(LINK_TIMEOUT),
+#ifndef AVALANCHE       /* Avalanche boards use only one mac port */
+	_ENV_ENTRY(MAC_PORT),
+#endif
+	_ENV_ENTRY(PATH),
+	_ENV_ENTRY(HOSTNAME),
+#ifdef WLAN
+	_ENV_ENTRY(HW_REV_MAJOR),
+	_ENV_ENTRY(HW_REV_MINOR),
+	_ENV_ENTRY(HW_PATCH),
+	_ENV_ENTRY(SW_PATCH),
+	_ENV_ENTRY(SERIAL_NUMBER),
+#endif
+	_ENV_ENTRY(TFTPCFG),
+#if defined (TNETV1050_BOARD)
+	_ENV_ENTRY(HWA_ESWITCH),
+#endif
+        /*
+         * Add new entries below this.
+         */
+	/* Adam2 environment name alias. */
+	{ .idx = IPA,      .nm = "my_ipaddress" },
+	{ .idx = CPUFREQ,  .nm = "cpufrequency" },
+	{ .idx = SYSFREQ,  .nm = "sysfrequency" },
+	{ .idx = HWA_0,    .nm = "maca" },
+#ifndef AVALANCHE
+	{ .idx = HWA_1,    .nm = "macb" },
+#endif
+        { .idx = MODETTY0, .nm = "modetty0" },
+        { .idx = MODETTY1, .nm = "modetty1" },
+	{ .idx = MEMSZ,    .nm = "memsize" },
+
+        _ENV_ENTRY(env_vars_end) /* delimiter. */
+};
+
+static inline int var_to_idx(const char* var)
+{
+	int ii;
+
+	/* go over the list of pre-defined environment variables */
+        for (ii = env_vars_start; env_ns[ii].idx != env_vars_end; ii++){
+		/* check if the env variable is listed */
+                if (strcmp(env_ns[ii].nm, var) == 0) {
+				return env_ns[ii].idx;
+		}
+
+		/* if an alias is present, check if the alias matches
+		 * the description
+		 */
+		if (env_ns[ii].alias != NULL) {
+			if (strcmp(env_ns[ii].alias, var) == 0)	{
+				return env_ns[ii].idx;
+			}
+		}
+	}
+	return 0;
+}
+
+extern int *_prom_envp;
+
+/* FIXME: reading from the flash is extremly unstable. Sometime a read returns garbage,
+ *        the next read some seconds later is ok. It looks like something is hidding or
+ *        overlay the flash address at 0xb0000000. Is this possible?
+ *
+ *        The readb() and while() usage below is a attempt of a workarround - with limited success.
+ */
+
+static inline struct env_variable* get_var_by_number(int index)
+{
+	struct env_variable *env_var = (struct env_variable *)_prom_envp;
+	volatile unsigned char nr;
+	int i;
+
+	env_var++;              /* skip signature */
+
+	i = 0;
+	nr = readb(&(env_var->varNum));
+
+	while (i < max_env_entry && nr != 0xFF) {
+		if ((env_var->ctrl & ENV_CTRL_MASK) == ENV_PREFINED) {
+			if (nr == index) {
+				return env_var;
+			}
+		}
+		i++;
+		env_var = get_next_block(env_var);
+		nr = readb(&(env_var->varNum));
+        }
+
+	return NULL;
+}
+
+static inline struct env_variable* get_var_by_name(char *var)
+{
+	struct env_variable *env_var = (struct env_variable *)_prom_envp;
+	volatile unsigned char nr;
+	int i;
+
+	env_var++;              /* skip signature */
+
+	nr = readb(&(env_var->varNum));
+	i = 0;
+
+	while (i < max_env_entry && nr != 0xFF) {
+		if ((env_var->ctrl & ENV_CTRL_MASK) == ENV_DYNAMIC) {
+			if (strcmp(var, env_var->data) == 0)
+				return env_var;
+		}
+		i++;
+		env_var = get_next_block(env_var);
+		nr = readb(&(env_var->varNum));
+        }
+	return NULL;
+}
+
+static inline struct env_variable* get_var(char *var)
+{
+	int index = var_to_idx(var);
+
+	if (index)
+		return get_var_by_number(index);
+	else
+		return get_var_by_name(var);
+
+	return NULL;
+}
+
+static inline char *get_value(struct env_variable* env_var)
+{
+	unsigned char *name;
+	unsigned char *value;
+	unsigned short chksum;
+	int i;
+
+	chksum = env_var->varNum + env_var->ctrl + env_var->numCells;
+
+	if ((env_var->ctrl & ENV_CTRL_MASK) == ENV_DYNAMIC) {
+		name  = env_var->data;
+		value = env_var->data + strlen(name) + 1;
+
+		for(i = 0; i < strlen(name); i++)
+			chksum += name[i];
+	} else
+		value = env_var->data;
+
+	for (i = 0; i < strlen(value); i++)
+		chksum += value[i];
+
+	chksum += env_var->chksum;
+	chksum = ~(chksum);
+
+	if(chksum != 0) {
+		return NULL;
+	}
+
+	return value;
+}
+
+struct psbl_rec {
+    unsigned int psbl_size;
+    unsigned int env_base;
+    unsigned int env_size;
+    unsigned int ffs_base;
+    unsigned int ffs_size;
+};
+
+char *prom_psp_getenv(char *envname)
+{
+    struct env_variable* env_var;
+    char *value;
+
+    if (strcmp("bootloader", envname) == 0)
+	    return "PSPBoot";
+
+    if (!(env_var = get_var(envname)))
+	    return NULL;
+
+    value = get_value(env_var);
+
+    return value;
+}
diff -urN linux.old/arch/mips/ar7/reset.c linux.dev/arch/mips/ar7/reset.c
--- linux.old/arch/mips/ar7/reset.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/reset.c	2005-11-10 01:14:16.372731750 +0100
@@ -0,0 +1,98 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Reset the AR7 boards.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/types.h>
+
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/addrspace.h>
+
+int preserve_adam2 = 1;
+
+extern void adam2_exit(int retval);
+
+static void ar7_machine_restart(char *command);
+static void ar7_machine_halt(void);
+static void ar7_machine_power_off(void);
+
+static void ar7_machine_restart(char *command)
+{
+	volatile uint32_t *softres_reg = (void *)(KSEG1ADDR(0x08611600 + 0x4));
+
+	*softres_reg = 1;
+}
+
+static void ar7_machine_halt(void)
+{
+
+	if (preserve_adam2) {
+		set_c0_status(ST0_BEV);
+		adam2_exit(0);
+	} else {
+		/* I'd like to have Alt-SysRq-b work in this state.
+		 * What's missing here? The timer interrupt is still running.
+		 * Why doesn't the UART work anymore? */
+		while(1) {
+		  __asm__(".set\tmips3\n\t"
+			  "wait\n\t"
+			  ".set\tmips0");
+		}
+	}
+}
+
+static void ar7_machine_power_off(void)
+{
+	volatile uint32_t *power_reg = (void *)(KSEG1ADDR(0x08610A00));
+	uint32_t power_state = *power_reg;
+
+	/* add something to turn LEDs off? */
+
+	power_state &= ~(3 << 30);
+	power_state |=  (3 << 30); /* power down */
+	*power_reg = power_state;
+
+	printk("after power down?\n");
+}
+
+void ar7_reboot_setup(void)
+{
+	_machine_restart = ar7_machine_restart;
+	_machine_halt = ar7_machine_halt;
+	_machine_power_off = ar7_machine_power_off;
+}
+
+static int __init ar7_do_preserve_adam2(char *s)
+{
+	if (!strcmp(s, "no") || !strcmp(s, "0"))
+		preserve_adam2 = 0;
+	else
+	  	preserve_adam2 = 1;
+        return 1;
+}
+
+__setup("adam2=", ar7_do_preserve_adam2);
diff -urN linux.old/arch/mips/ar7/setup.c linux.dev/arch/mips/ar7/setup.c
--- linux.old/arch/mips/ar7/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/setup.c	2005-11-10 01:12:43.946955500 +0100
@@ -0,0 +1,143 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/irq.h>
+
+#include <asm/processor.h>
+#include <asm/irq.h>
+#include <asm/irq_cpu.h>
+#include <asm/time.h>
+#include <asm/mipsregs.h>
+#include <asm/mips-boards/prom.h>
+
+#ifdef CONFIG_KGDB
+extern void rs_kgdb_hook(int);
+extern void breakpoint(void);
+int remote_debug = 0;
+#endif
+
+extern void ar7_reboot_setup(void);
+extern void ar7_irq_init(int);
+extern asmlinkage void ar7IRQ(void);
+
+void ar7_time_init(void)
+{
+  /* XXX runtime */
+  mips_hpt_frequency = CONFIG_AR7_CPU * 500000;
+}
+
+void ar7_timer_setup(struct irqaction *irq)
+{
+  setup_irq(7, irq);
+  set_c0_status(IE_IRQ5);
+}
+
+void __init init_IRQ(void)
+{
+  init_generic_irq();
+  mips_cpu_irq_init(0);
+  ar7_irq_init(8);
+
+  /* Now safe to set the exception vector. */
+  set_except_vector(0, ar7IRQ);
+
+#ifdef CONFIG_KGDB
+  if (remote_debug)
+  {
+    set_debug_traps();
+    breakpoint();
+  }
+#endif
+}
+
+const char *get_system_type(void)
+{
+	return "Texas Instruments AR7";
+}
+
+void __init ar7_setup(void)
+{
+#ifdef CONFIG_KGDB
+	int rs_putDebugChar(char);
+	char rs_getDebugChar(void);
+	extern int (*generic_putDebugChar)(char);
+	extern char (*generic_getDebugChar)(void);
+#endif
+	char *argptr;
+#ifdef CONFIG_SERIAL_CONSOLE
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "console=")) == NULL) {
+		char console[20];
+		char *s;
+		int i = 0;
+		
+		s = prom_getenv("modetty0");
+		strcpy(console, "38400");
+		
+		if (s != NULL) {
+			while (s[i] >= '0' && s[i] <= '9')
+				i++;
+		
+			if (i > 0) {
+				strncpy(console, s, i);
+				console[i] = 0;
+			}
+		}
+		
+		argptr = prom_getcmdline();
+		strcat(argptr, " console=ttyS0,");
+		strcat(argptr, console);
+	}
+#endif
+
+#ifdef CONFIG_KGDB
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "kgdb=ttyS")) != NULL) {
+		int line;
+		argptr += strlen("kgdb=ttyS");
+		if (*argptr != '0' && *argptr != '1')
+			printk("KGDB: Uknown serial line /dev/ttyS%c, "
+					"falling back to /dev/ttyS1\n", *argptr);
+		line = *argptr == '0' ? 0 : 1;
+		printk("KGDB: Using serial line /dev/ttyS%d for session\n",
+				line ? 1 : 0);
+
+		rs_kgdb_hook(line);
+		generic_putDebugChar = rs_putDebugChar;
+		generic_getDebugChar = rs_getDebugChar;
+
+		prom_printf("KGDB: Using serial line /dev/ttyS%d for session, "
+				"please connect your debugger\n", line ? 1 : 0);
+
+		remote_debug = 1;
+		/* Breakpoints are in init_IRQ() */
+	}
+#endif
+
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "nofpu")) != NULL)
+		cpu_data[0].options &= ~MIPS_CPU_FPU;
+
+	ar7_reboot_setup();
+
+	board_time_init = ar7_time_init;
+	board_timer_setup = ar7_timer_setup;
+}
diff -urN linux.old/arch/mips/ar7/tnetd73xx_misc.c linux.dev/arch/mips/ar7/tnetd73xx_misc.c
--- linux.old/arch/mips/ar7/tnetd73xx_misc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar7/tnetd73xx_misc.c	2005-11-10 01:12:43.946955500 +0100
@@ -0,0 +1,921 @@
+/******************************************************************************
+ * FILE PURPOSE:    TNETD73xx Misc modules API Source
+ ******************************************************************************
+ * FILE NAME:       tnetd73xx_misc.c
+ *
+ * DESCRIPTION:     Clock Control, Reset Control, Power Management, GPIO
+ *                  FSER Modules API
+ *                  As per TNETD73xx specifications
+ *
+ * REVISION HISTORY:
+ * 27 Nov 02 - Sharath Kumar     PSP TII  
+ * 14 Feb 03 - Anant Gole        PSP TII
+ *
+ * (C) Copyright 2002, Texas Instruments, Inc
+ *******************************************************************************/
+
+#include <linux/types.h>
+#include <asm/ar7/tnetd73xx.h>
+#include <asm/ar7/tnetd73xx_misc.h>
+
+/* TNETD73XX Revision */
+u32 tnetd73xx_get_revision(void)
+{
+	/* Read Chip revision register - This register is from GPIO module */
+	return ( (u32) REG32_DATA(TNETD73XX_CVR));
+}
+
+/*****************************************************************************
+ * Reset Control Module
+ *****************************************************************************/
+
+
+void tnetd73xx_reset_ctrl(TNETD73XX_RESET_MODULE_T reset_module, TNETD73XX_RESET_CTRL_T reset_ctrl)
+{
+	u32 reset_status;
+
+	/* read current reset register */
+	REG32_READ(TNETD73XX_RST_CTRL_PRCR, reset_status);
+
+	if (reset_ctrl == OUT_OF_RESET)
+	{
+		/* bring module out of reset */
+		reset_status |= (1 << reset_module);
+	}
+	else
+	{
+		/* put module in reset */
+		reset_status &= (~(1 << reset_module));
+	}
+
+	/* write to the reset register */
+	REG32_WRITE(TNETD73XX_RST_CTRL_PRCR, reset_status);
+}
+
+
+TNETD73XX_RESET_CTRL_T tnetd73xx_get_reset_status (TNETD73XX_RESET_MODULE_T reset_module)
+{
+	u32 reset_status;
+
+	REG32_READ(TNETD73XX_RST_CTRL_PRCR, reset_status);
+	return ( (reset_status & (1 << reset_module)) ? OUT_OF_RESET : IN_RESET );
+}
+
+void tnetd73xx_sys_reset(TNETD73XX_SYS_RST_MODE_T mode)
+{
+	REG32_WRITE(TNETD73XX_RST_CTRL_SWRCR, mode);
+}
+
+#define TNETD73XX_RST_CTRL_RSR_MASK 0x3
+
+TNETD73XX_SYS_RESET_STATUS_T tnetd73xx_get_sys_last_reset_status()
+{
+	u32 sys_reset_status;
+
+	REG32_READ(TNETD73XX_RST_CTRL_RSR, sys_reset_status);
+
+	return ( (TNETD73XX_SYS_RESET_STATUS_T) (sys_reset_status & TNETD73XX_RST_CTRL_RSR_MASK) );
+}
+
+
+/*****************************************************************************
+ * Power Control Module
+ *****************************************************************************/
+#define TNETD73XX_GLOBAL_POWER_DOWN_MASK    0x3FFFFFFF      /* bit 31, 30 masked */
+#define TNETD73XX_GLOBAL_POWER_DOWN_BIT     30              /* shift to bit 30, 31 */
+
+
+void tnetd73xx_power_ctrl(TNETD73XX_POWER_MODULE_T power_module, TNETD73XX_POWER_CTRL_T power_ctrl)
+{
+	u32 power_status;
+
+	/* read current power down control register */
+	REG32_READ(TNETD73XX_POWER_CTRL_PDCR, power_status);
+
+	if (power_ctrl == POWER_CTRL_POWER_DOWN)
+	{
+		/* power down the module */
+		power_status |= (1 << power_module);
+	}
+	else
+	{
+		/* power on the module */
+		power_status &= (~(1 << power_module));
+	}
+
+	/* write to the reset register */
+	REG32_WRITE(TNETD73XX_POWER_CTRL_PDCR, power_status);
+}
+
+TNETD73XX_POWER_CTRL_T tnetd73xx_get_pwr_status(TNETD73XX_POWER_MODULE_T power_module)
+{
+	u32 power_status;
+
+	/* read current power down control register */
+	REG32_READ(TNETD73XX_POWER_CTRL_PDCR, power_status);
+
+	return ( (power_status & (1 << power_module)) ? POWER_CTRL_POWER_DOWN : POWER_CTRL_POWER_UP );
+}
+
+void tnetd73xx_set_global_pwr_mode(TNETD73XX_SYS_POWER_MODE_T power_mode)
+{
+	u32 power_status;
+
+	/* read current power down control register */
+	REG32_READ(TNETD73XX_POWER_CTRL_PDCR, power_status);
+
+	power_status &= TNETD73XX_GLOBAL_POWER_DOWN_MASK;
+	power_status |= ( power_mode << TNETD73XX_GLOBAL_POWER_DOWN_BIT);
+
+	/* write to power down control register */
+	REG32_WRITE(TNETD73XX_POWER_CTRL_PDCR, power_status);
+}
+
+TNETD73XX_SYS_POWER_MODE_T tnetd73xx_get_global_pwr_mode()
+{
+	u32 power_status;
+
+	/* read current power down control register */
+	REG32_READ(TNETD73XX_POWER_CTRL_PDCR, power_status);
+
+	power_status &= (~TNETD73XX_GLOBAL_POWER_DOWN_MASK);
+	power_status = ( power_status >> TNETD73XX_GLOBAL_POWER_DOWN_BIT);
+
+	return ( (TNETD73XX_SYS_POWER_MODE_T) power_status );
+}
+
+
+/*****************************************************************************
+ * Wakeup Control
+ *****************************************************************************/
+
+#define TNETD73XX_WAKEUP_POLARITY_BIT   16
+
+void tnetd73xx_wakeup_ctrl(TNETD73XX_WAKEUP_INTERRUPT_T wakeup_int,
+		TNETD73XX_WAKEUP_CTRL_T wakeup_ctrl,
+		TNETD73XX_WAKEUP_POLARITY_T wakeup_polarity)
+{
+	u32 wakeup_status;
+
+	/* read the wakeup control register */
+	REG32_READ(TNETD73XX_POWER_CTRL_WKCR, wakeup_status);
+
+	/* enable/disable */
+	if (wakeup_ctrl == WAKEUP_ENABLED)
+	{
+		/* enable wakeup */
+		wakeup_status |= wakeup_int;
+	}
+	else
+	{
+		/* disable wakeup */
+		wakeup_status &= (~wakeup_int);
+	}
+
+	/* set polarity */
+	if (wakeup_polarity == WAKEUP_ACTIVE_LOW)
+	{
+		wakeup_status |= (wakeup_int << TNETD73XX_WAKEUP_POLARITY_BIT);
+	}
+	else
+	{
+		wakeup_status &= ~(wakeup_int << TNETD73XX_WAKEUP_POLARITY_BIT);
+	}
+
+	/* write  the wakeup control register */
+	REG32_WRITE(TNETD73XX_POWER_CTRL_WKCR, wakeup_status);
+}
+
+
+/*****************************************************************************
+ * FSER  Control
+ *****************************************************************************/
+
+void tnetd73xx_fser_ctrl(TNETD73XX_FSER_MODE_T fser_mode)
+{
+	REG32_WRITE(TNETD73XX_FSER_BASE, fser_mode);
+}
+
+/*****************************************************************************
+ * Clock Control
+ *****************************************************************************/
+
+#define MIN(x,y)               ( ((x) <  (y)) ? (x) : (y) )
+#define MAX(x,y)               ( ((x) >  (y)) ? (x) : (y) )
+#define ABS(x)                 ( ((signed)(x) > 0) ? (x) : (-(x)) )
+#define CEIL(x,y)              ( ((x) + (y) / 2) / (y) )
+
+#define CLKC_CLKCR(x)          (TNETD73XX_CLOCK_CTRL_BASE + 0x20 + (0x20 * (x)))
+#define CLKC_CLKPLLCR(x)       (TNETD73XX_CLOCK_CTRL_BASE + 0x30 + (0x20 * (x)))
+
+#define CLKC_PRE_DIVIDER        0x0000001F
+#define CLKC_POST_DIVIDER       0x001F0000
+
+#define CLKC_PLL_STATUS         0x1
+#define CLKC_PLL_FACTOR         0x0000F000
+
+#define BOOTCR_PLL_BYPASS       (1 << 5)
+#define BOOTCR_MIPS_ASYNC_MODE  (1 << 25)
+
+#define MIPS_PLL_SELECT         0x00030000
+#define SYSTEM_PLL_SELECT       0x0000C000
+#define USB_PLL_SELECT          0x000C0000
+#define ADSLSS_PLL_SELECT       0x00C00000
+
+#define MIPS_AFECLKI_SELECT     0x00000000
+#define MIPS_REFCLKI_SELECT     0x00010000
+#define MIPS_XTAL3IN_SELECT     0x00020000
+
+#define SYSTEM_AFECLKI_SELECT   0x00000000
+#define SYSTEM_REFCLKI_SELECT   0x00004000
+#define SYSTEM_XTAL3IN_SELECT   0x00008000
+#define SYSTEM_MIPSPLL_SELECT   0x0000C000
+
+#define USB_SYSPLL_SELECT       0x00000000
+#define USB_REFCLKI_SELECT      0x00040000
+#define USB_XTAL3IN_SELECT      0x00080000
+#define USB_MIPSPLL_SELECT      0x000C0000
+
+#define ADSLSS_AFECLKI_SELECT   0x00000000
+#define ADSLSS_REFCLKI_SELECT   0x00400000
+#define ADSLSS_XTAL3IN_SELECT   0x00800000
+#define ADSLSS_MIPSPLL_SELECT   0x00C00000
+
+#define  SYS_MAX                CLK_MHZ(150)
+#define  SYS_MIN                CLK_MHZ(1)
+
+#define  MIPS_SYNC_MAX          SYS_MAX
+#define  MIPS_ASYNC_MAX         CLK_MHZ(160)
+#define  MIPS_MIN               CLK_MHZ(1)
+
+#define  USB_MAX                CLK_MHZ(100)
+#define  USB_MIN                CLK_MHZ(1)
+
+#define  ADSL_MAX               CLK_MHZ(180)
+#define  ADSL_MIN               CLK_MHZ(1)
+
+#define  PLL_MUL_MAXFACTOR      15
+#define  MAX_DIV_VALUE          32
+#define  MIN_DIV_VALUE          1
+
+#define  MIN_PLL_INP_FREQ       CLK_MHZ(8)
+#define  MAX_PLL_INP_FREQ       CLK_MHZ(100)
+
+#define  DIVIDER_LOCK_TIME      10100
+#define  PLL_LOCK_TIME          10100 * 75
+
+
+
+							      /****************************************************************************
+							       * DATA PURPOSE:    PRIVATE Variables
+							       **************************************************************************/
+							      static u32 *clk_src[4];
+							      static u32 mips_pll_out;
+							      static u32 sys_pll_out;
+							      static u32 afeclk_inp;
+							      static u32 refclk_inp;
+							      static u32 xtal_inp;
+							      static u32 present_min;
+							      static u32 present_max;
+
+							      /* Forward References */
+							      static u32 find_gcd(u32 min, u32 max);
+							      static u32 compute_prediv( u32 divider, u32 min, u32 max);
+							      static void get_val(u32 base_freq, u32 output_freq,u32 *multiplier, u32 *divider);
+							      static u32 get_base_frequency(TNETD73XX_CLKC_ID_T clk_id);
+							      static void find_approx(u32 *,u32 *,u32);
+
+							      /****************************************************************************
+							       * FUNCTION: tnetd73xx_clkc_init
+							       ****************************************************************************
+							       * Description: The routine initializes the internal variables depending on
+							       *              on the sources selected for different clocks.
+							       ***************************************************************************/
+void tnetd73xx_clkc_init(u32 afeclk, u32 refclk, u32 xtal3in)
+{
+
+	u32 choice;
+
+	afeclk_inp = afeclk;
+	refclk_inp = refclk;
+	xtal_inp = xtal3in;
+
+	choice = REG32_DATA(TNETD73XX_DCL_BOOTCR) & MIPS_PLL_SELECT;
+	switch(choice)
+	{
+		case MIPS_AFECLKI_SELECT:
+			clk_src[CLKC_MIPS] = &afeclk_inp;
+			break;
+
+		case MIPS_REFCLKI_SELECT:
+			clk_src[CLKC_MIPS] = &refclk_inp;
+			break;
+
+		case MIPS_XTAL3IN_SELECT:
+			clk_src[CLKC_MIPS] = &xtal_inp;
+			break;
+
+		default :
+			clk_src[CLKC_MIPS] = 0;
+
+	}
+
+	choice = REG32_DATA(TNETD73XX_DCL_BOOTCR) & SYSTEM_PLL_SELECT;
+	switch(choice)
+	{
+		case SYSTEM_AFECLKI_SELECT:
+			clk_src[CLKC_SYS] = &afeclk_inp;
+			break;
+
+		case SYSTEM_REFCLKI_SELECT:
+			clk_src[CLKC_SYS] = &refclk_inp;
+			break;
+
+		case SYSTEM_XTAL3IN_SELECT:
+			clk_src[CLKC_SYS] = &xtal_inp;
+			break;
+
+		case SYSTEM_MIPSPLL_SELECT:
+			clk_src[CLKC_SYS] = &mips_pll_out;
+			break;
+
+		default :
+			clk_src[CLKC_SYS] = 0;
+
+	}
+
+
+	choice = REG32_DATA(TNETD73XX_DCL_BOOTCR) & ADSLSS_PLL_SELECT;
+	switch(choice)
+	{
+		case ADSLSS_AFECLKI_SELECT:
+			clk_src[CLKC_ADSLSS] = &afeclk_inp;
+			break;
+
+		case ADSLSS_REFCLKI_SELECT:
+			clk_src[CLKC_ADSLSS] = &refclk_inp;
+			break;
+
+		case ADSLSS_XTAL3IN_SELECT:
+			clk_src[CLKC_ADSLSS] = &xtal_inp;
+			break;
+
+		case ADSLSS_MIPSPLL_SELECT:
+			clk_src[CLKC_ADSLSS] = &mips_pll_out;
+			break;
+
+		default :
+			clk_src[CLKC_ADSLSS] = 0;
+
+	}
+
+
+	choice = REG32_DATA(TNETD73XX_DCL_BOOTCR) & USB_PLL_SELECT;
+	switch(choice)
+	{
+		case USB_SYSPLL_SELECT:
+			clk_src[CLKC_USB] = &sys_pll_out ;
+			break;
+
+		case USB_REFCLKI_SELECT:
+			clk_src[CLKC_USB] = &refclk_inp;
+			break;
+
+		case USB_XTAL3IN_SELECT:
+			clk_src[CLKC_USB] = &xtal_inp;
+			break;
+
+		case USB_MIPSPLL_SELECT:
+			clk_src[CLKC_USB] = &mips_pll_out;
+			break;
+
+		default :
+			clk_src[CLKC_USB] = 0;
+
+	}
+}
+
+
+
+/****************************************************************************
+ * FUNCTION: tnetd73xx_clkc_set_freq
+ ****************************************************************************
+ * Description: The above routine is called to set the output_frequency of the
+ *              selected clock(using clk_id) to the  required value given
+ *              by the variable output_freq.
+ ***************************************************************************/
+TNETD73XX_ERR tnetd73xx_clkc_set_freq
+(
+ TNETD73XX_CLKC_ID_T clk_id,
+ u32              output_freq
+ )
+{
+	u32 base_freq;
+	u32 multiplier;
+	u32 divider;
+	u32 min_prediv;
+	u32 max_prediv;
+	u32 prediv;
+	u32 postdiv;
+	u32 temp;
+
+	/* check if PLLs are bypassed*/
+	if(REG32_DATA(TNETD73XX_DCL_BOOTCR) & BOOTCR_PLL_BYPASS)
+	{
+		return TNETD73XX_ERR_ERROR;
+	}
+
+	/*check if the requested output_frequency is in valid range*/
+	switch( clk_id )
+	{
+		case CLKC_SYS:
+			if( output_freq < SYS_MIN || output_freq > SYS_MAX)
+			{
+				return TNETD73XX_ERR_ERROR;
+			}
+			present_min = SYS_MIN;
+			present_max = SYS_MAX;
+			break;
+
+		case CLKC_MIPS:
+			if((output_freq < MIPS_MIN) ||
+					(output_freq > ((REG32_DATA(TNETD73XX_DCL_BOOTCR) & BOOTCR_MIPS_ASYNC_MODE) ? MIPS_ASYNC_MAX: MIPS_SYNC_MAX)))
+			{
+				return TNETD73XX_ERR_ERROR;
+			}
+			present_min = MIPS_MIN;
+			present_max = (REG32_DATA(TNETD73XX_DCL_BOOTCR) & BOOTCR_MIPS_ASYNC_MODE) ? MIPS_ASYNC_MAX: MIPS_SYNC_MAX;
+			break;
+
+		case CLKC_USB:
+			if( output_freq < USB_MIN || output_freq > USB_MAX)
+			{
+				return TNETD73XX_ERR_ERROR;
+			}
+			present_min = USB_MIN;
+			present_max = USB_MAX;
+			break;
+
+		case CLKC_ADSLSS:
+			if( output_freq < ADSL_MIN || output_freq > ADSL_MAX)
+			{
+				return TNETD73XX_ERR_ERROR;
+			}
+			present_min = ADSL_MIN;
+			present_max = ADSL_MAX;
+			break;
+	}
+
+
+	base_freq = get_base_frequency(clk_id);
+
+
+	/* check for minimum base frequency value */
+	if( base_freq < MIN_PLL_INP_FREQ)
+	{
+		return TNETD73XX_ERR_ERROR;
+	}
+
+	get_val(output_freq, base_freq, &multiplier, &divider);
+
+	/* check multiplier range  */
+	if( (multiplier  > PLL_MUL_MAXFACTOR) || (multiplier <= 0) )
+	{
+		return TNETD73XX_ERR_ERROR;
+	}
+
+	/* check divider value */
+	if( divider == 0 )
+	{
+		return TNETD73XX_ERR_ERROR;
+	}
+
+	/*compute minimum and maximum predivider values */
+	min_prediv = MAX(base_freq / MAX_PLL_INP_FREQ + 1, divider / MAX_DIV_VALUE + 1);
+	max_prediv = MIN(base_freq / MIN_PLL_INP_FREQ, MAX_DIV_VALUE);
+
+	/*adjust  the value of divider so that it not less than minimum predivider value*/
+	if (divider < min_prediv)
+	{
+		temp = CEIL(min_prediv, divider);
+		if ((temp * multiplier) > PLL_MUL_MAXFACTOR)
+		{
+			return TNETD73XX_ERR_ERROR  ;
+		}
+		else
+		{
+			multiplier = temp * multiplier;
+			divider = min_prediv;
+		}
+
+	}
+
+	/* compute predivider  and postdivider values */
+	prediv = compute_prediv (divider, min_prediv, max_prediv);
+	postdiv = CEIL(divider,prediv);
+
+	/*return fail if postdivider value falls out of range */
+	if(postdiv > MAX_DIV_VALUE)
+	{
+		return TNETD73XX_ERR_ERROR;
+	}
+
+
+	/*write predivider and postdivider values*/
+	/* pre-Divider and post-divider are 5 bit N+1 dividers */
+	REG32_WRITE(CLKC_CLKCR(clk_id), ((postdiv -1) & 0x1F) << 16 | ((prediv -1) & 0x1F) );
+
+	/*wait for divider output to stabilise*/
+	for(temp =0; temp < DIVIDER_LOCK_TIME; temp++);
+
+	/*write to PLL clock register*/
+
+	if(clk_id == CLKC_SYS)
+	{
+		/* but before writing put DRAM to hold mode */
+		REG32_DATA(TNETD73XX_EMIF_SDRAM_CFG) |= 0x80000000;
+	}
+	/*Bring PLL into div mode */
+	REG32_WRITE(CLKC_CLKPLLCR(clk_id), 0x4);
+
+	/*compute the word to be written to PLLCR
+	 *corresponding to multiplier value
+	 */
+	multiplier = (((multiplier - 1) & 0xf) << 12)| ((255 <<3) | 0x0e);
+
+	/* wait till PLL enters div mode */
+	while(REG32_DATA(CLKC_CLKPLLCR(clk_id)) & CLKC_PLL_STATUS)
+		/*nothing*/;
+
+	REG32_WRITE(CLKC_CLKPLLCR(clk_id), multiplier);
+
+	while(!REG32_DATA(CLKC_CLKPLLCR(clk_id)) & CLKC_PLL_STATUS)
+		/*nothing*/;
+
+
+	/*wait for External pll to lock*/
+	for(temp =0; temp < PLL_LOCK_TIME; temp++);
+
+	if(clk_id == CLKC_SYS)
+	{
+		/* Bring DRAM out of hold */
+		REG32_DATA(TNETD73XX_EMIF_SDRAM_CFG) &= ~0x80000000;
+	}
+
+	return TNETD73XX_ERR_OK ;
+}
+
+/****************************************************************************
+ * FUNCTION: tnetd73xx_clkc_get_freq
+ ****************************************************************************
+ * Description: The above routine is called to get the output_frequency of the
+ *              selected clock( clk_id)
+ ***************************************************************************/
+u32 tnetd73xx_clkc_get_freq
+(
+ TNETD73XX_CLKC_ID_T clk_id
+ )
+{
+
+	u32  clk_ctrl_register;
+	u32  clk_pll_setting;
+	u32  clk_predivider;
+	u32  clk_postdivider;
+	u16  pll_factor;
+	u32  base_freq;
+	u32  divider;
+
+	base_freq = get_base_frequency(clk_id);
+
+	clk_ctrl_register = REG32_DATA(CLKC_CLKCR(clk_id));
+
+	/* pre-Divider and post-divider are 5 bit N+1 dividers */
+	clk_predivider = (CLKC_PRE_DIVIDER & clk_ctrl_register) + 1;
+	clk_postdivider = ((CLKC_POST_DIVIDER & clk_ctrl_register) >> 16) + 1;
+
+	divider =  clk_predivider * clk_postdivider;
+
+
+	if( (REG32_DATA(TNETD73XX_DCL_BOOTCR) & BOOTCR_PLL_BYPASS))
+	{
+		return (CEIL(base_freq, divider));  /* PLLs bypassed.*/
+	}
+
+
+	else
+	{
+		/*  return the current clock speed based upon the PLL setting */
+		clk_pll_setting = REG32_DATA(CLKC_CLKPLLCR(clk_id));
+
+		/* Get the PLL multiplication factor */
+		pll_factor = ((clk_pll_setting & CLKC_PLL_FACTOR) >> 12) + 1;
+
+		/* Check if we're in divide mode or multiply mode */
+		if((clk_pll_setting & 0x1)   == 0)
+		{
+			/* We're in divide mode */
+			if(pll_factor <  0x10)
+				return (CEIL(base_freq >> 1, divider));
+			else
+				return (CEIL(base_freq >> 2, divider));
+		}
+
+		else     /* We're in PLL mode */
+		{
+			/* See if PLLNDIV & PLLDIV are set */
+			if((clk_pll_setting & 0x0800) && (clk_pll_setting & 0x2))
+			{
+				if(clk_pll_setting & 0x1000)
+				{
+					/* clk = base_freq * k/2  */
+					return(CEIL((base_freq * pll_factor) >> 1, divider));
+				}
+				else
+				{
+					/* clk = base_freq * (k-1) / 4)*/
+					return(CEIL((base_freq * (pll_factor - 1)) >>2, divider));
+				}
+			}
+			else
+			{
+				if(pll_factor < 0x10)
+				{
+					/* clk = base_freq * k */
+					return(CEIL(base_freq * pll_factor, divider));
+				}
+
+				else
+				{
+					/* clk = base_freq  */
+					return(CEIL(base_freq, divider));
+				}
+			}
+		}
+		return(0); /* Should never reach here */
+
+	}
+
+}
+
+
+/* local helper functions */
+
+/****************************************************************************
+ * FUNCTION: get_base_frequency
+ ****************************************************************************
+ * Description: The above routine is called to get base frequency of the clocks.
+ ***************************************************************************/
+
+static u32 get_base_frequency(TNETD73XX_CLKC_ID_T clk_id)
+{
+	/* update the current MIPs PLL output value, if the required
+	 * source is MIPS PLL
+	 */
+	if ( clk_src[clk_id] == &mips_pll_out)
+	{
+		*clk_src[clk_id] = tnetd73xx_clkc_get_freq(CLKC_MIPS);
+	}
+
+
+	/* update the current System PLL output value, if the required
+	 * source is system PLL
+	 */
+	if ( clk_src[clk_id] == &sys_pll_out)
+	{
+		*clk_src[clk_id] = tnetd73xx_clkc_get_freq(CLKC_SYS);
+	}
+
+	return (*clk_src[clk_id]);
+
+}
+
+
+
+/****************************************************************************
+ * FUNCTION: find_gcd
+ ****************************************************************************
+ * Description: The above routine is called to find gcd of 2 numbers.
+ ***************************************************************************/
+static u32 find_gcd
+(
+ u32 min,
+ u32 max
+ )
+{
+	if (max % min == 0)
+	{
+		return min;
+	}
+	else
+	{
+		return find_gcd(max % min, min);
+	}
+}
+
+/****************************************************************************
+ * FUNCTION: compute_prediv
+ ****************************************************************************
+ * Description: The above routine is called to compute predivider value
+ ***************************************************************************/
+static u32 compute_prediv(u32 divider, u32 min, u32 max)
+{
+	u16 prediv;
+
+	/* return the divider itself it it falls within the range of predivider*/
+	if (min <= divider && divider <= max)
+	{
+		return divider;
+	}
+
+	/* find a value for prediv such that it is a factor of divider */
+	for (prediv = max; prediv >= min ; prediv--)
+	{
+		if ( (divider % prediv) == 0 )
+		{
+			return prediv;
+		}
+	}
+
+	/* No such factor exists,  return min as prediv */
+	return min;
+}
+
+/****************************************************************************
+ * FUNCTION: get_val
+ ****************************************************************************
+ * Description: This routine is called to get values of divider and multiplier.
+ ***************************************************************************/
+
+static void get_val(u32 output_freq, u32 base_freq,u32 *multiplier, u32 *divider)
+{
+	u32 temp_mul;
+	u32 temp_div;
+	u32 gcd;
+	u32 min_freq;
+	u32 max_freq;
+
+	/* find gcd of base_freq, output_freq */
+	min_freq = (base_freq < output_freq) ? base_freq : output_freq;
+	max_freq = (base_freq > output_freq) ? base_freq : output_freq;
+	gcd = find_gcd(min_freq , max_freq);
+
+	if(gcd == 0)
+		return;  /* ERROR */
+
+	/* compute values of multiplier and divider */
+	temp_mul = output_freq / gcd;
+	temp_div = base_freq / gcd;
+
+
+	/* set multiplier such that 1 <= multiplier <= PLL_MUL_MAXFACTOR */
+	if( temp_mul > PLL_MUL_MAXFACTOR )
+	{
+		if((temp_mul / temp_div) > PLL_MUL_MAXFACTOR)
+			return;
+
+		find_approx(&temp_mul,&temp_div,base_freq);
+	}
+
+	*multiplier = temp_mul;
+	*divider    = temp_div;
+}
+
+/****************************************************************************
+ * FUNCTION: find_approx
+ ****************************************************************************
+ * Description: This function gets the approx value of num/denom.
+ ***************************************************************************/
+
+static void find_approx(u32 *num,u32 *denom,u32 base_freq)
+{
+	u32 num1;
+	u32 denom1;
+	u32 num2;
+	u32 denom2;
+	int32_t closest;
+	int32_t prev_closest;
+	u32 temp_num;
+	u32 temp_denom;
+	u32 normalize;
+	u32 gcd;
+	u32 output_freq;
+
+	num1 = *num;
+	denom1 = *denom;
+
+	prev_closest = 0x7fffffff; /* maximum possible value */
+	num2 = num1;
+	denom2 = denom1;
+
+	/* start with  max */
+	for(temp_num = 15; temp_num >=1; temp_num--)
+	{
+
+		temp_denom = CEIL(temp_num * denom1, num1);
+		output_freq = (temp_num * base_freq) / temp_denom;
+
+		if(temp_denom < 1)
+		{
+			break;
+		}
+		else
+		{
+			normalize = CEIL(num1,temp_num);
+			closest = (ABS((num1 * (temp_denom) ) - (temp_num * denom1)))  * normalize;
+			if(closest < prev_closest && output_freq > present_min && output_freq <present_max)
+			{
+				prev_closest = closest;
+				num2 = temp_num;
+				denom2 = temp_denom;
+			}
+
+		}
+
+	}
+
+	gcd = find_gcd(num2,denom2);
+	num2 = num2 / gcd;
+	denom2 = denom2 /gcd;
+
+	*num      = num2;
+	*denom    = denom2;
+}
+
+
+/*****************************************************************************
+ * GPIO  Control
+ *****************************************************************************/
+
+/****************************************************************************
+ * FUNCTION: tnetd73xx_gpio_init
+ ***************************************************************************/
+void tnetd73xx_gpio_init()
+{
+	/* Bring module out of reset */
+	tnetd73xx_reset_ctrl(RESET_MODULE_GPIO, OUT_OF_RESET);
+	REG32_WRITE(TNETD73XX_GPIOENR, 0xFFFFFFFF);    
+}
+
+/****************************************************************************
+ * FUNCTION: tnetd73xx_gpio_ctrl
+ ***************************************************************************/
+void tnetd73xx_gpio_ctrl(TNETD73XX_GPIO_PIN_T gpio_pin, 
+		TNETD73XX_GPIO_PIN_MODE_T pin_mode,
+		TNETD73XX_GPIO_PIN_DIRECTION_T pin_direction)
+{
+	u32 pin_status;
+	REG32_READ(TNETD73XX_GPIOENR, pin_status);
+	if (pin_mode == GPIO_PIN)
+	{
+		pin_status |= (1 << gpio_pin);
+		REG32_WRITE(TNETD73XX_GPIOENR, pin_status);
+
+		/* Set pin direction */
+		REG32_READ(TNETD73XX_GPIOPDIRR, pin_status);
+		if (pin_direction == GPIO_INPUT_PIN)
+		{
+			pin_status |= (1 << gpio_pin);
+		}
+		else /* GPIO_OUTPUT_PIN */
+		{
+			pin_status &= (~(1 << gpio_pin));
+		}
+		REG32_WRITE(TNETD73XX_GPIOPDIRR, pin_status);
+	}
+	else /* FUNCTIONAL PIN */
+	{
+		pin_status &= (~(1 << gpio_pin));
+		REG32_WRITE(TNETD73XX_GPIOENR, pin_status);
+	}
+
+}
+
+/****************************************************************************
+ * FUNCTION: tnetd73xx_gpio_out
+ ***************************************************************************/
+void tnetd73xx_gpio_out(TNETD73XX_GPIO_PIN_T gpio_pin, int value)
+{
+	u32 pin_value;
+
+	REG32_READ(TNETD73XX_GPIODOUTR, pin_value);
+	if (value == 1)
+	{
+		pin_value |= (1 << gpio_pin);
+	}
+	else
+	{
+		pin_value &= (~(1 << gpio_pin));
+	}
+	REG32_WRITE(TNETD73XX_GPIODOUTR, pin_value);
+}
+
+/****************************************************************************
+ * FUNCTION: tnetd73xx_gpio_in
+ ***************************************************************************/
+int tnetd73xx_gpio_in(TNETD73XX_GPIO_PIN_T gpio_pin)
+{
+	u32 pin_value;
+	REG32_READ(TNETD73XX_GPIODINR, pin_value);
+	return ( (pin_value & (1 << gpio_pin)) ? 1 : 0 );
+}
+
diff -urN linux.old/arch/mips/config-shared.in linux.dev/arch/mips/config-shared.in
--- linux.old/arch/mips/config-shared.in	2005-10-21 16:43:18.917114000 +0200
+++ linux.dev/arch/mips/config-shared.in	2005-11-10 01:12:43.950955750 +0100
@@ -20,6 +20,16 @@
 mainmenu_option next_comment
 comment 'Machine selection'
 dep_bool 'Support for Acer PICA 1 chipset (EXPERIMENTAL)' CONFIG_ACER_PICA_61 $CONFIG_EXPERIMENTAL
+dep_bool 'Support for Texas Instruments AR7 (EXPERIMENTAL)' CONFIG_AR7 $CONFIG_MIPS32 $CONFIG_EXPERIMENTAL
+if [ "$CONFIG_AR7" = "y" ]; then
+   choice 'Texas Instruments Reference Platform' \
+      "AR7DB CONFIG_AR7DB \
+      AR7RD CONFIG_AR7RD \
+      AR7WRD CONFIG_AR7WRD" AR7DB
+   int 'Texas Instruments AR7 CPU Frequency' CONFIG_AR7_CPU 150
+   int 'Texas Instruments AR7 System Frequency' CONFIG_AR7_SYS 125
+   hex 'Texas Instruments AR7 SDRAM Start' CONFIG_AR7_MEMORY 0x14000000
+fi
 dep_bool 'Support for Alchemy Bosporus board' CONFIG_MIPS_BOSPORUS $CONFIG_MIPS32
 dep_bool 'Support for FIC Multimedia Player board' CONFIG_MIPS_FICMMP $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Mirage board' CONFIG_MIPS_MIRAGE $CONFIG_MIPS32
@@ -239,6 +249,11 @@
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
+if [ "$CONFIG_AR7" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_SWAP_IO_SPACE y
+fi
 if [ "$CONFIG_CASIO_E55" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
    define_bool CONFIG_NONCOHERENT_IO y
@@ -736,6 +751,7 @@
 mainmenu_option next_comment
 comment 'General setup'
 if [ "$CONFIG_ACER_PICA_61" = "y" -o \
+     "$CONFIG_AR7" = "y" -o \
      "$CONFIG_CASIO_E55" = "y" -o \
      "$CONFIG_DDB5074" = "y" -o \
      "$CONFIG_DDB5476" = "y" -o \
@@ -797,6 +813,7 @@
 bool 'Networking support' CONFIG_NET
 
 if [ "$CONFIG_ACER_PICA_61" = "y" -o \
+     "$CONFIG_AR7" = "y" -o \
      "$CONFIG_CASIO_E55" = "y" -o \
      "$CONFIG_DECSTATION" = "y" -o \
      "$CONFIG_IBM_WORKPAD" = "y" -o \
diff -urN linux.old/arch/mips/kernel/head.S linux.dev/arch/mips/kernel/head.S
--- linux.old/arch/mips/kernel/head.S	2005-10-21 16:43:16.396956500 +0200
+++ linux.dev/arch/mips/kernel/head.S	2005-11-10 01:10:45.807572250 +0100
@@ -75,11 +75,11 @@
 		 * size!
 		 */
 		NESTED(except_vec4, 0, sp)
-		.set	push
-		.set	noreorder
-1:		j	1b			/* Dummy, will be replaced */
-		 nop
-		.set	pop
+		.set	mips2
+		lui     k0, 0x9400
+		ori     k0, 0x200
+		jr      k0
+		nop
 		END(except_vec4)
 
 		/*
diff -urN linux.old/arch/mips/kernel/mips_ksyms.c linux.dev/arch/mips/kernel/mips_ksyms.c
--- linux.old/arch/mips/kernel/mips_ksyms.c	2004-02-18 14:36:30.000000000 +0100
+++ linux.dev/arch/mips/kernel/mips_ksyms.c	2005-11-10 01:10:45.811572500 +0100
@@ -40,6 +40,12 @@
 extern long __strnlen_user_nocheck_asm(const char *s);
 extern long __strnlen_user_asm(const char *s);
 
+#ifdef CONFIG_AR7
+#include <asm/ar7/adam2_env.h>
+int avalanche_request_pacing(int irq_nr, unsigned int blk_num, unsigned int pace_value);
+#endif
+
+
 EXPORT_SYMBOL(mips_machtype);
 #ifdef CONFIG_EISA
 EXPORT_SYMBOL(EISA_bus);
@@ -103,3 +109,10 @@
 #endif
 
 EXPORT_SYMBOL(get_wchan);
+
+#ifdef CONFIG_AR7
+EXPORT_SYMBOL_NOVERS(avalanche_request_pacing);
+EXPORT_SYMBOL_NOVERS(prom_getenv);
+EXPORT_SYMBOL_NOVERS(prom_iterenv);
+#endif
+
diff -urN linux.old/arch/mips/kernel/setup.c linux.dev/arch/mips/kernel/setup.c
--- linux.old/arch/mips/kernel/setup.c	2005-10-21 16:43:16.396956500 +0200
+++ linux.dev/arch/mips/kernel/setup.c	2005-11-10 01:14:16.376732000 +0100
@@ -38,6 +38,7 @@
 #include <asm/io.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
+#include <asm/addrspace.h>
 
 struct cpuinfo_mips cpu_data[NR_CPUS];
 EXPORT_SYMBOL(cpu_data);
@@ -88,7 +89,7 @@
 struct boot_mem_map boot_mem_map;
 
 unsigned char aux_device_present;
-extern char _ftext, _etext, _fdata, _edata, _end;
+extern char _ftext, _etext, _fdata, _edata, _fbss, _end;
 
 static char command_line[CL_SIZE];
        char saved_command_line[CL_SIZE];
@@ -116,6 +117,7 @@
 
 static struct resource code_resource = { "Kernel code" };
 static struct resource data_resource = { "Kernel data" };
+static struct resource  bss_resource = { "Kernel bss" };
 
 asmlinkage void __init
 init_arch(int argc, char **argv, char **envp, int *prom_vec)
@@ -272,7 +274,7 @@
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long start, end;
 
-		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
+		if (boot_mem_map.map[i].type == BOOT_MEM_RESERVED)
 			continue;
 
 		start = PFN_UP(boot_mem_map.map[i].addr);
@@ -320,7 +322,8 @@
 #endif
 
 	/* Initialize the boot-time allocator with low memory only.  */
-	bootmap_size = init_bootmem(first_usable_pfn, max_low_pfn);
+	bootmap_size = init_bootmem_node(NODE_DATA(0), first_usable_pfn,
+					 PFN_UP(PHYS_OFFSET), max_low_pfn);
 
 	/*
 	 * Register fully available low RAM pages with the bootmem allocator.
@@ -371,11 +374,12 @@
 			continue;
 
 		/* Register lowmem ranges */
-		free_bootmem(PFN_PHYS(curr_pfn), PFN_PHYS(size));
+		free_bootmem_node(NODE_DATA(0), PFN_PHYS(curr_pfn),
+				  size<<PAGE_SHIFT);
 	}
 
 	/* Reserve the bootmap memory.  */
-	reserve_bootmem(PFN_PHYS(first_usable_pfn), bootmap_size);
+	reserve_bootmem_node(NODE_DATA(0), PFN_PHYS(first_usable_pfn), bootmap_size);
 
 #ifdef CONFIG_BLK_DEV_INITRD
 	/* Board specific code should have set up initrd_start and initrd_end */
@@ -409,6 +413,8 @@
 	code_resource.end = virt_to_bus(&_etext) - 1;
 	data_resource.start = virt_to_bus(&_fdata);
 	data_resource.end = virt_to_bus(&_edata) - 1;
+	bss_resource.start = virt_to_bus(&_fbss);
+	bss_resource.end = virt_to_bus(&_end) - 1;
 
 	/*
 	 * Request address space for all standard RAM.
@@ -448,6 +454,7 @@
 		 */
 		request_resource(res, &code_resource);
 		request_resource(res, &data_resource);
+		request_resource(res, &bss_resource);
 	}
 }
 
@@ -494,6 +501,7 @@
 	void hp_setup(void);
 	void au1x00_setup(void);
 	void frame_info_init(void);
+ 	void ar7_setup(void);
 
 	frame_info_init();
 #if defined(CONFIG_BLK_DEV_FD) || defined(CONFIG_BLK_DEV_FD_MODULE)
@@ -691,6 +699,11 @@
                 pmc_yosemite_setup();
                 break;
 #endif
+#ifdef CONFIG_AR7
+	case MACH_GROUP_UNKNOWN:
+		ar7_setup();
+		break;
+#endif
 	default:
 		panic("Unsupported architecture");
 	}
diff -urN linux.old/arch/mips/kernel/time.c linux.dev/arch/mips/kernel/time.c
--- linux.old/arch/mips/kernel/time.c	2005-01-19 15:09:29.000000000 +0100
+++ linux.dev/arch/mips/kernel/time.c	2005-11-10 01:12:43.950955750 +0100
@@ -143,7 +143,6 @@
 	expirelo = (count / cycles_per_jiffy + 1) * cycles_per_jiffy;
 	write_c0_count(expirelo - cycles_per_jiffy);
 	write_c0_compare(expirelo);
-	write_c0_count(count);
 }
 
 int (*mips_timer_state)(void);
diff -urN linux.old/arch/mips/kernel/traps.c linux.dev/arch/mips/kernel/traps.c
--- linux.old/arch/mips/kernel/traps.c	2005-10-21 16:43:16.400956750 +0200
+++ linux.dev/arch/mips/kernel/traps.c	2005-11-10 01:13:28.301727500 +0100
@@ -869,9 +869,24 @@
 
 	exception_handlers[n] = handler;
 	if (n == 0 && cpu_has_divec) {
+	  printk(KERN_DEBUG "%s: using long jump via k0 to reach %08x\n",
+		 __FUNCTION__, handler);
+	  /* where does the 8 byte limit mentioned in head.S come from??? */
+	  if (handler > 0x0fffffff) { /* maximum for single J instruction */
+	    /* lui k0, 0x0000 */
+	    *(volatile u32 *)(KSEG0+0x200) = 0x3c1a0000 | (handler >> 16);
+	    /* ori k0, 0x0000 */
+	    *(volatile u32 *)(KSEG0+0x204) = 0x375a0000 | (handler & 0xffff);
+	    /* jr k0 */
+	    *(volatile u32 *)(KSEG0+0x208) = 0x03400008;
+	    /* nop */
+	    *(volatile u32 *)(KSEG0+0x20C) = 0x00000000;
+    	    flush_icache_range(KSEG0+0x200, KSEG0+0x210);
+	  } else {
 		*(volatile u32 *)(KSEG0+0x200) = 0x08000000 |
 		                                 (0x03ffffff & (handler >> 2));
-		flush_icache_range(KSEG0+0x200, KSEG0 + 0x204);
+		flush_icache_range(KSEG0+0x200, KSEG0+0x204);
+	  }
 	}
 	return (void *)old_handler;
 }
diff -urN linux.old/arch/mips/mm/init.c linux.dev/arch/mips/mm/init.c
--- linux.old/arch/mips/mm/init.c	2004-02-18 14:36:30.000000000 +0100
+++ linux.dev/arch/mips/mm/init.c	2005-11-10 01:14:16.376732000 +0100
@@ -235,10 +235,13 @@
 #endif
 }
 
+#define START_PFN (NODE_DATA(0)->bdata->node_boot_start >> PAGE_SHIFT)
+#define MAX_LOW_PFN (NODE_DATA(0)->bdata->node_low_pfn)
+
 void __init paging_init(void)
 {
 	unsigned long zones_size[MAX_NR_ZONES] = {0, 0, 0};
-	unsigned long max_dma, high, low;
+	unsigned long max_dma, high, low, start;
 
 	pagetable_init();
 
@@ -247,7 +250,8 @@
 #endif
 
 	max_dma = virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT;
-	low = max_low_pfn;
+	start = START_PFN;
+	low = MAX_LOW_PFN - start;
 	high = highend_pfn;
 
 #ifdef CONFIG_ISA
@@ -270,7 +274,8 @@
 		zones_size[ZONE_HIGHMEM] = high - low;
 #endif
 
-	free_area_init(zones_size);
+	free_area_init_node(0, NODE_DATA(0), 0, zones_size,
+			    start << PAGE_SHIFT, 0);
 }
 
 #define PFN_UP(x)	(((x) + PAGE_SIZE - 1) >> PAGE_SHIFT)
@@ -283,7 +288,7 @@
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long addr, end;
 
-		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
+		if (boot_mem_map.map[i].type == BOOT_MEM_RESERVED)
 			/* not usable memory */
 			continue;
 
@@ -313,16 +318,17 @@
 	max_mapnr = num_physpages = highend_pfn;
 	num_mappedpages = max_low_pfn;
 #else
-	max_mapnr = num_mappedpages = num_physpages = max_low_pfn;
+	max_mapnr = num_mappedpages = num_physpages = MAX_LOW_PFN - START_PFN;
 #endif
-	high_memory = (void *) __va(max_low_pfn * PAGE_SIZE);
-
-	totalram_pages += free_all_bootmem();
+	
+	high_memory = (void *) __va(MAX_LOW_PFN * PAGE_SIZE);
+	
+	totalram_pages += free_all_bootmem_node(NODE_DATA(0));
 	totalram_pages -= setup_zero_pages();	/* Setup zeroed pages.  */
 
 	reservedpages = ram = 0;
-	for (tmp = 0; tmp < max_low_pfn; tmp++)
-		if (page_is_ram(tmp)) {
+	for (tmp = 0; tmp < max_mapnr; tmp++)
+		if (page_is_ram(START_PFN + tmp)) {
 			ram++;
 			if (PageReserved(mem_map+tmp))
 				reservedpages++;
@@ -377,13 +383,13 @@
 #endif
 
 extern char __init_begin, __init_end;
-extern void prom_free_prom_memory(void) __init;
+extern unsigned long prom_free_prom_memory(void) __init;
 
 void free_initmem(void)
 {
 	unsigned long addr;
 
-	prom_free_prom_memory ();
+	totalram_pages += prom_free_prom_memory ();
 
 	addr = (unsigned long) &__init_begin;
 	while (addr < (unsigned long) &__init_end) {
diff -urN linux.old/drivers/char/Config.in linux.dev/drivers/char/Config.in
--- linux.old/drivers/char/Config.in	2005-10-21 16:43:16.440959250 +0200
+++ linux.dev/drivers/char/Config.in	2005-11-10 01:10:45.843574500 +0100
@@ -188,6 +188,14 @@
    tristate 'Total Impact briQ front panel driver' CONFIG_BRIQ_PANEL
 fi
 
+if [ "$CONFIG_AR7" = "y" ]; then  
+   bool 'VLYNQ support for the TI SOC' CONFIG_AR7_VLYNQ
+   dep_bool 'VLYNQ clock source Internal' CONFIG_VLYNQ_CLK_LOCAL $CONFIG_AR7_VLYNQ
+                   
+   define_int CONFIG_AR7_VLYNQ_PORTS 2 
+   tristate 'ADAM2 environment support (read-only)' CONFIG_AR7_ADAM2
+fi                                                                                             
+
 source drivers/i2c/Config.in
 
 mainmenu_option next_comment
diff -urN linux.old/drivers/char/Config.in.orig linux.dev/drivers/char/Config.in.orig
--- linux.old/drivers/char/Config.in.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/char/Config.in.orig	2005-11-10 01:10:45.863575750 +0100
@@ -0,0 +1,414 @@
+#
+# Character device configuration
+#
+mainmenu_option next_comment
+comment 'Character devices'
+
+bool 'Virtual terminal' CONFIG_VT
+if [ "$CONFIG_VT" = "y" ]; then
+   bool '  Support for console on virtual terminal' CONFIG_VT_CONSOLE
+   if [ "$CONFIG_GSC_LASI" = "y" ]; then
+      bool '    Support for Lasi/Dino PS2 port' CONFIG_GSC_PS2
+   fi
+fi
+tristate 'Standard/generic (8250/16550 and compatible UARTs) serial support' CONFIG_SERIAL
+if [ "$CONFIG_SERIAL" = "y" ]; then
+   bool '  Support for console on serial port' CONFIG_SERIAL_CONSOLE
+   if [ "$CONFIG_GSC_LASI" = "y" ]; then
+      bool '   serial port on GSC support' CONFIG_SERIAL_GSC
+   fi
+   if [ "$CONFIG_IA64" = "y" ]; then
+      bool '  Support for serial port described by EFI HCDP table' CONFIG_SERIAL_HCDP
+   fi
+   if [ "$CONFIG_ARCH_ACORN" = "y" ]; then
+      tristate '   Atomwide serial port support' CONFIG_ATOMWIDE_SERIAL
+      tristate '   Dual serial port support' CONFIG_DUALSP_SERIAL
+   fi
+fi
+dep_mbool 'Extended dumb serial driver options' CONFIG_SERIAL_EXTENDED $CONFIG_SERIAL
+if [ "$CONFIG_SERIAL_EXTENDED" = "y" ]; then
+   bool '  Support more than 4 serial ports' CONFIG_SERIAL_MANY_PORTS
+   bool '  Support for sharing serial interrupts' CONFIG_SERIAL_SHARE_IRQ
+   bool '  Autodetect IRQ on standard ports (unsafe)' CONFIG_SERIAL_DETECT_IRQ
+   bool '  Support special multiport boards' CONFIG_SERIAL_MULTIPORT
+   bool '  Support the Bell Technologies HUB6 card' CONFIG_HUB6
+fi
+bool 'Non-standard serial port support' CONFIG_SERIAL_NONSTANDARD
+if [ "$CONFIG_SERIAL_NONSTANDARD" = "y" ]; then
+   tristate '  Computone IntelliPort Plus serial support' CONFIG_COMPUTONE
+   tristate '  Comtrol Rocketport support' CONFIG_ROCKETPORT
+   tristate '  Cyclades async mux support' CONFIG_CYCLADES
+   if [ "$CONFIG_EXPERIMENTAL" = "y" -a "$CONFIG_CYCLADES" != "n" ]; then
+      bool '    Cyclades-Z interrupt mode operation (EXPERIMENTAL)' CONFIG_CYZ_INTR
+   fi
+   if [ "$CONFIG_X86_64" != "y" ]; then
+      tristate '  Digiboard Intelligent Async Support' CONFIG_DIGIEPCA
+      if [ "$CONFIG_DIGIEPCA" = "n" ]; then
+         tristate '  Digiboard PC/Xx Support' CONFIG_DIGI
+      fi
+   fi
+   dep_tristate '  Hayes ESP serial port support' CONFIG_ESPSERIAL $CONFIG_ISA
+   tristate '  Moxa Intellio support' CONFIG_MOXA_INTELLIO
+   tristate '  Moxa SmartIO support' CONFIG_MOXA_SMARTIO
+   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+      dep_tristate '  Multi-Tech multiport card support (EXPERIMENTAL)' CONFIG_ISI m
+   fi
+   tristate '  Microgate SyncLink card support' CONFIG_SYNCLINK
+   tristate '  SyncLink Multiport support' CONFIG_SYNCLINKMP
+   tristate '  HDLC line discipline support' CONFIG_N_HDLC
+   tristate '  SDL RISCom/8 card support' CONFIG_RISCOM8
+   if [ "$CONFIG_X86_64" != "y" ]; then
+      tristate '  Specialix IO8+ card support' CONFIG_SPECIALIX
+      if [ "$CONFIG_SPECIALIX" != "n" ]; then
+         bool '  Specialix DTR/RTS pin is RTS' CONFIG_SPECIALIX_RTSCTS
+      fi 
+      tristate '  Specialix SX (and SI) card support' CONFIG_SX
+      tristate '  Specialix RIO system support' CONFIG_RIO
+      if [ "$CONFIG_RIO" != "n" ]; then
+        bool '    Support really old RIO/PCI cards' CONFIG_RIO_OLDPCI
+      fi
+   fi
+   bool '  Stallion multiport serial support' CONFIG_STALDRV
+   if [ "$CONFIG_STALDRV" = "y" ]; then
+     tristate '    Stallion EasyIO or EC8/32 support' CONFIG_STALLION
+     tristate '    Stallion EC8/64, ONboard, Brumby support' CONFIG_ISTALLION
+   fi
+   if [ "$CONFIG_PARISC" = "y" ]; then
+     if [ "$CONFIG_PDC_CONSOLE" != "y" ]; then
+       bool '  Serial MUX support' CONFIG_SERIAL_MUX CONFIG_SERIAL_NONSTANDARD
+     fi
+     if [ "$CONFIG_SERIAL_MUX" != "y" ]; then
+       bool '  PDC software console support' CONFIG_PDC_CONSOLE CONFIG_SERIAL_NONSTANDARD
+     fi
+   fi
+   if [ "$CONFIG_MIPS" = "y" ]; then
+      bool '  TX3912/PR31700 serial port support' CONFIG_SERIAL_TX3912
+      dep_bool '     Console on TX3912/PR31700 serial port' CONFIG_SERIAL_TX3912_CONSOLE $CONFIG_SERIAL_TX3912
+      bool '  TMPTX39XX/49XX serial port support' CONFIG_SERIAL_TXX9
+      dep_bool '     Console on TMPTX39XX/49XX serial port' CONFIG_SERIAL_TXX9_CONSOLE $CONFIG_SERIAL_TXX9
+      if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
+	 bool '  Enable Au1x00 UART Support' CONFIG_AU1X00_UART
+	 if [ "$CONFIG_AU1X00_UART" = "y" ]; then
+	    bool '        Enable Au1x00 serial console' CONFIG_AU1X00_SERIAL_CONSOLE
+         fi
+         dep_tristate '  Au1x00 USB TTY Device support' CONFIG_AU1X00_USB_TTY $CONFIG_SOC_AU1X00
+	    if [ "$CONFIG_AU1000_USB_TTY" != "y" ]; then
+	       dep_tristate '  Au1x00 USB Raw Device support' CONFIG_AU1X00_USB_RAW $CONFIG_SOC_AU1X00
+	    fi
+	    if [ "$CONFIG_AU1X00_USB_TTY" != "n" -o \
+	         "$CONFIG_AU1X00_USB_RAW" != "n" ]; then
+		 define_bool CONFIG_AU1X00_USB_DEVICE y
+	    fi
+      fi
+      bool '  TXx927 SIO support' CONFIG_TXX927_SERIAL 
+      if [ "$CONFIG_TXX927_SERIAL" = "y" ]; then
+         bool '    TXx927 SIO Console support' CONFIG_TXX927_SERIAL_CONSOLE  
+      fi                             
+      if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
+         bool '  Support for BCM1xxx onchip DUART' CONFIG_SIBYTE_SB1250_DUART
+         if [ "$CONFIG_SIBYTE_SB1250_DUART" = "y" ]; then
+            bool '    Console on BCM1xxx DUART' CONFIG_SIBYTE_SB1250_DUART_CONSOLE
+            if [ "$CONFIG_SIBYTE_SB1250_DUART_CONSOLE" = "y" ]; then
+               define_bool CONFIG_SERIAL_CONSOLE y
+            fi
+         fi
+      fi
+   fi
+   if [ "$CONFIG_DECSTATION" = "y" ]; then
+      bool '  DECstation serial support' CONFIG_SERIAL_DEC
+      dep_bool '    Support for console on a DECstation serial port' CONFIG_SERIAL_DEC_CONSOLE $CONFIG_SERIAL_DEC
+      dep_bool '    DZ11 serial support' CONFIG_DZ $CONFIG_SERIAL_DEC $CONFIG_MIPS32
+      dep_bool '    Z85C30 serial support' CONFIG_ZS $CONFIG_SERIAL_DEC $CONFIG_TC
+   fi
+   if [ "$CONFIG_SGI_IP22" = "y" ]; then
+      bool '  SGI Zilog85C30 serial support' CONFIG_IP22_SERIAL
+   fi
+   if [ "$CONFIG_IA64" = "y" ]; then
+      bool '  SGI SN2 l1 serial port support' CONFIG_SGI_L1_SERIAL
+      if [ "$CONFIG_SGI_L1_SERIAL" = "y" ]; then
+	 bool '    SGI SN2 l1 Console support' CONFIG_SGI_L1_SERIAL_CONSOLE
+      fi
+      if [ "$CONFIG_IA64_GENERIC" = "y" -o "$CONFIG_IA64_SGI_SN2" = "y" ]; then
+	 bool '  SGI SN2 IOC4 serial port support' CONFIG_SGI_IOC4_SERIAL
+      fi
+   fi
+fi
+if [ "$CONFIG_EXPERIMENTAL" = "y" -a "$CONFIG_ZORRO" = "y" ]; then
+   tristate 'Commodore A2232 serial support (EXPERIMENTAL)' CONFIG_A2232
+fi
+if [ "$CONFIG_FOOTBRIDGE" = "y" ]; then
+   bool 'DC21285 serial port support' CONFIG_SERIAL_21285
+   if [ "$CONFIG_SERIAL_21285" = "y" ]; then
+      if [ "$CONFIG_OBSOLETE" = "y" ]; then
+         bool '  Use /dev/ttyS0 device (OBSOLETE)' CONFIG_SERIAL_21285_OLD
+      fi
+      bool '  Console on DC21285 serial port' CONFIG_SERIAL_21285_CONSOLE
+   fi
+   if [ "$CONFIG_PARISC" = "y" ]; then
+     bool '  PDC software console support' CONFIG_PDC_CONSOLE
+   fi
+fi
+if [ "$CONFIG_MIPS_ITE8172" = "y" ]; then
+   bool 'Enable Qtronix 990P Keyboard Support' CONFIG_QTRONIX_KEYBOARD
+   if [ "$CONFIG_QTRONIX_KEYBOARD" = "y" ]; then
+     define_bool CONFIG_IT8172_CIR y
+   else
+     bool '    Enable PS2 Keyboard Support' CONFIG_PC_KEYB
+   fi
+   bool 'Enable Smart Card Reader 0 Support ' CONFIG_IT8172_SCR0
+   bool 'Enable Smart Card Reader 1 Support ' CONFIG_IT8172_SCR1
+fi
+if [ "$CONFIG_MIPS_IVR" = "y" ]; then
+   bool 'Enable Qtronix 990P Keyboard Support' CONFIG_QTRONIX_KEYBOARD
+   if [ "$CONFIG_QTRONIX_KEYBOARD" = "y" ]; then
+     define_bool CONFIG_IT8172_CIR y
+   fi
+   bool 'Enable Smart Card Reader 0 Support ' CONFIG_IT8172_SCR0
+fi
+if [ "$CONFIG_CPU_VR41XX" = "y" ]; then
+   bool 'NEC VR4100 series Keyboard Interface Unit Support ' CONFIG_VR41XX_KIU
+fi
+bool 'Unix98 PTY support' CONFIG_UNIX98_PTYS
+if [ "$CONFIG_UNIX98_PTYS" = "y" ]; then
+   int 'Maximum number of Unix98 PTYs in use (0-2048)' CONFIG_UNIX98_PTY_COUNT 256
+fi
+if [ "$CONFIG_PARPORT" != "n" ]; then
+   dep_tristate 'Parallel printer support' CONFIG_PRINTER $CONFIG_PARPORT
+   if [ "$CONFIG_PRINTER" != "n" ]; then
+      bool '  Support for console on line printer' CONFIG_LP_CONSOLE
+   fi
+   dep_tristate 'Support for user-space parallel port device drivers' CONFIG_PPDEV $CONFIG_PARPORT
+   dep_tristate 'Texas Instruments parallel link cable support' CONFIG_TIPAR $CONFIG_PARPORT
+fi
+
+if [ "$CONFIG_PPC64" = "y" ] ; then 
+   bool 'pSeries Hypervisor Virtual Console support' CONFIG_HVC_CONSOLE
+fi
+if [ "$CONFIG_ALL_PPC" = "y" ]; then
+   tristate 'Total Impact briQ front panel driver' CONFIG_BRIQ_PANEL
+fi
+
+if [ "$CONFIG_AR7" = "y" ]; then  
+   bool 'VLYNQ support for the TI SOC' CONFIG_AR7_VLYNQ
+   dep_bool 'VLYNQ clock source Internal' CONFIG_VLYNQ_CLK_LOCAL $CONFIG_AR7_VLYNQ
+                   
+   define_int CONFIG_AR7_VLYNQ_PORTS 2 
+fi                                                                                             
+
+source drivers/i2c/Config.in
+
+mainmenu_option next_comment
+comment 'Mice'
+tristate 'Bus Mouse Support' CONFIG_BUSMOUSE
+if [ "$CONFIG_BUSMOUSE" != "n" ]; then
+   dep_tristate '  ATIXL busmouse support' CONFIG_ATIXL_BUSMOUSE $CONFIG_BUSMOUSE
+   dep_tristate '  Logitech busmouse support' CONFIG_LOGIBUSMOUSE $CONFIG_BUSMOUSE
+   dep_tristate '  Microsoft busmouse support' CONFIG_MS_BUSMOUSE $CONFIG_BUSMOUSE
+   if [ "$CONFIG_ADB" = "y" -a "$CONFIG_ADB_KEYBOARD" = "y" ]; then
+      dep_tristate '  Apple Desktop Bus mouse support (old driver)' CONFIG_ADBMOUSE $CONFIG_BUSMOUSE
+   fi
+#   if [ "$CONFIG_DECSTATION" = "y" ]; then
+#      dep_bool '  MAXINE Access.Bus mouse (VSXXX-BB/GB) support' CONFIG_DTOP_MOUSE $CONFIG_ACCESSBUS
+#   fi
+fi
+
+tristate 'Mouse Support (not serial and bus mice)' CONFIG_MOUSE
+if [ "$CONFIG_MOUSE" != "n" ]; then
+   bool '  PS/2 mouse (aka "auxiliary device") support' CONFIG_PSMOUSE
+   tristate '  C&T 82C710 mouse port support (as on TI Travelmate)' CONFIG_82C710_MOUSE
+   tristate '  PC110 digitizer pad support' CONFIG_PC110_PAD
+   tristate '  MK712 touch screen support' CONFIG_MK712_MOUSE
+fi
+endmenu
+
+source drivers/char/joystick/Config.in
+
+tristate 'QIC-02 tape support' CONFIG_QIC02_TAPE
+if [ "$CONFIG_QIC02_TAPE" != "n" ]; then
+   bool '  Do you want runtime configuration for QIC-02' CONFIG_QIC02_DYNCONF
+   if [ "$CONFIG_QIC02_DYNCONF" != "y" ]; then
+      comment '  Edit configuration parameters in ./include/linux/tpqic02.h!'
+   else
+      comment '  Setting runtime QIC-02 configuration is done with qic02conf'
+      comment '  from the tpqic02-support package.  It is available at'
+      comment '  metalab.unc.edu or ftp://titus.cfw.com/pub/Linux/util/'
+   fi
+fi
+
+tristate 'IPMI top-level message handler' CONFIG_IPMI_HANDLER
+dep_mbool '  Generate a panic event to all BMCs on a panic' CONFIG_IPMI_PANIC_EVENT $CONFIG_IPMI_HANDLER
+dep_tristate '  Device interface for IPMI' CONFIG_IPMI_DEVICE_INTERFACE $CONFIG_IPMI_HANDLER
+dep_tristate '  IPMI KCS handler' CONFIG_IPMI_KCS $CONFIG_IPMI_HANDLER
+dep_tristate '  IPMI Watchdog Timer' CONFIG_IPMI_WATCHDOG $CONFIG_IPMI_HANDLER
+
+mainmenu_option next_comment
+comment 'Watchdog Cards'
+bool 'Watchdog Timer Support'	CONFIG_WATCHDOG
+if [ "$CONFIG_WATCHDOG" != "n" ]; then
+   bool '  Disable watchdog shutdown on close' CONFIG_WATCHDOG_NOWAYOUT
+   tristate '  Acquire SBC Watchdog Timer' CONFIG_ACQUIRE_WDT
+   tristate '  Advantech SBC Watchdog Timer' CONFIG_ADVANTECH_WDT
+   tristate '  ALi M7101 PMU on ALi 1535D+ Watchdog Timer' CONFIG_ALIM1535_WDT
+   tristate '  ALi M7101 PMU Watchdog Timer' CONFIG_ALIM7101_WDT
+   tristate '  AMD "Elan" SC520 Watchdog Timer' CONFIG_SC520_WDT
+   tristate '  Berkshire Products PC Watchdog' CONFIG_PCWATCHDOG
+   if [ "$CONFIG_FOOTBRIDGE" = "y" ]; then
+      tristate '  DC21285 watchdog' CONFIG_21285_WATCHDOG
+      if [ "$CONFIG_ARCH_NETWINDER" = "y" ]; then
+         tristate '  NetWinder WB83C977 watchdog' CONFIG_977_WATCHDOG
+      fi
+   fi
+   tristate '  Eurotech CPU-1220/1410 Watchdog Timer' CONFIG_EUROTECH_WDT
+   tristate '  IB700 SBC Watchdog Timer' CONFIG_IB700_WDT
+   tristate '  ICP ELectronics Wafer 5823 Watchdog' CONFIG_WAFER_WDT
+   tristate '  Intel i810 TCO timer / Watchdog' CONFIG_I810_TCO
+   tristate '  Mixcom Watchdog' CONFIG_MIXCOMWD 
+   tristate '  SBC-60XX Watchdog Timer' CONFIG_60XX_WDT
+   dep_tristate '  SC1200 Watchdog Timer (EXPERIMENTAL)' CONFIG_SC1200_WDT $CONFIG_EXPERIMENTAL
+   tristate '  NatSemi SCx200 Watchdog' CONFIG_SCx200_WDT
+   tristate '  Software Watchdog' CONFIG_SOFT_WATCHDOG
+   tristate '  W83877F (EMACS) Watchdog Timer' CONFIG_W83877F_WDT
+   tristate '  WDT Watchdog timer' CONFIG_WDT
+   tristate '  WDT PCI Watchdog timer' CONFIG_WDTPCI
+   if [ "$CONFIG_WDT" != "n" ]; then
+      bool '    WDT501 features' CONFIG_WDT_501
+      if [ "$CONFIG_WDT_501" = "y" ]; then
+         bool '      Fan Tachometer' CONFIG_WDT_501_FAN
+      fi
+   fi
+   tristate '  ZF MachZ Watchdog' CONFIG_MACHZ_WDT
+   if [ "$CONFIG_SGI_IP22" = "y" ]; then
+      dep_tristate '  Indy/I2 Hardware Watchdog' CONFIG_INDYDOG $CONFIG_SGI_IP22
+   fi
+   if [ "$CONFIG_8xx" = "y" ]; then
+      tristate '  MPC8xx Watchdog Timer' CONFIG_8xx_WDT
+   fi
+fi
+endmenu
+
+if [ "$CONFIG_ARCH_NETWINDER" = "y" ]; then
+   tristate 'NetWinder thermometer support' CONFIG_DS1620
+   tristate 'NetWinder Button' CONFIG_NWBUTTON
+   if [ "$CONFIG_NWBUTTON" != "n" ]; then
+      bool '  Reboot Using Button' CONFIG_NWBUTTON_REBOOT
+   fi
+   tristate 'NetWinder flash support' CONFIG_NWFLASH
+fi
+tristate 'NatSemi SCx200 Support' CONFIG_SCx200
+dep_tristate '  NatSemi SCx200 GPIO Support' CONFIG_SCx200_GPIO $CONFIG_SCx200
+
+if [ "$CONFIG_IA64_GENERIC" = "y" -o "$CONFIG_IA64_SGI_SN2" = "y" ] ; then
+   bool 'SGI SN2 fetchop support' CONFIG_FETCHOP
+fi
+
+if [ "$CONFIG_X86" = "y" -o "$CONFIG_X86_64" = "y" ]; then
+   dep_tristate 'AMD 768/8111 Random Number Generator support' CONFIG_AMD_RNG $CONFIG_PCI
+fi
+if [ "$CONFIG_X86" = "y" -o "$CONFIG_IA64" = "y" ]; then
+   dep_tristate 'Intel i8x0 Random Number Generator support' CONFIG_INTEL_RNG $CONFIG_PCI
+fi
+if [ "$CONFIG_X86" = "y" -o "$CONFIG_IA64" = "y" -o \
+     "$CONFIG_X86_64" = "y" ]; then
+   dep_tristate 'Intel/AMD/VIA HW Random Number Generator support' CONFIG_HW_RANDOM $CONFIG_PCI
+fi
+dep_tristate 'AMD 76x native power management (Experimental)' CONFIG_AMD_PM768 $CONFIG_PCI
+tristate '/dev/nvram support' CONFIG_NVRAM
+tristate 'Enhanced Real Time Clock Support' CONFIG_RTC
+if [ "$CONFIG_IA64" = "y" ]; then
+   bool 'EFI Real Time Clock Services' CONFIG_EFI_RTC
+fi
+if [ "$CONFIG_OBSOLETE" = "y" -a "$CONFIG_ALPHA_BOOK1" = "y" ]; then
+   bool 'Tadpole ANA H8 Support (OBSOLETE)'  CONFIG_H8
+fi
+if [ "$CONFIG_SGI_IP22" = "y" ]; then
+   tristate 'Dallas DS1286 RTC support' CONFIG_DS1286
+fi
+if [ "$CONFIG_SGI_IP27" = "y" ]; then
+   tristate 'SGI M48T35 RTC support' CONFIG_SGI_IP27_RTC
+fi
+if [ "$CONFIG_TOSHIBA_RBTX4927" = "y" -o "$CONFIG_TOSHIBA_JMR3927" = "y" ]; then
+   tristate 'Dallas DS1742 RTC support' CONFIG_DS1742
+fi
+
+tristate 'Double Talk PC internal speech card support' CONFIG_DTLK
+tristate 'Siemens R3964 line discipline' CONFIG_R3964
+tristate 'Applicom intelligent fieldbus card support' CONFIG_APPLICOM
+if [ "$CONFIG_EXPERIMENTAL" = "y" -a "$CONFIG_X86" = "y" -a "$CONFIG_X86_64" != "y" ]; then
+   dep_tristate 'Sony Vaio Programmable I/O Control Device support (EXPERIMENTAL)' CONFIG_SONYPI $CONFIG_PCI
+fi
+
+mainmenu_option next_comment
+comment 'Ftape, the floppy tape device driver'
+tristate 'Ftape (QIC-80/Travan) support' CONFIG_FTAPE
+if [ "$CONFIG_FTAPE" != "n" ]; then
+   source drivers/char/ftape/Config.in
+fi
+
+endmenu
+
+if [ "$CONFIG_GART_IOMMU" = "y" ]; then
+	bool '/dev/agpgart (AGP Support)' CONFIG_AGP
+	define_bool CONFIG_AGP_AMD_K8 y
+else
+	tristate '/dev/agpgart (AGP Support)' CONFIG_AGP
+fi      
+if [ "$CONFIG_AGP" != "n" ]; then
+   bool '  Intel 440LX/BX/GX and I815/I820/I830M/I830MP/I840/I845/I850/I860 support' CONFIG_AGP_INTEL
+   bool '  Intel I810/I815/I830M (on-board) support' CONFIG_AGP_I810
+   bool '  VIA chipset support' CONFIG_AGP_VIA
+   bool '  AMD Irongate, 761, and 762 support' CONFIG_AGP_AMD
+   if [ "$CONFIG_GART_IOMMU" != "y" ]; then
+      bool '  AMD Opteron/Athlon64 on-CPU GART support' CONFIG_AGP_AMD_K8
+   fi   
+   bool '  Generic SiS support' CONFIG_AGP_SIS
+   bool '  ALI chipset support' CONFIG_AGP_ALI
+   bool '  Serverworks LE/HE support' CONFIG_AGP_SWORKS
+   if [ "$CONFIG_X86" = "y" ]; then
+      bool '  NVIDIA chipset support' CONFIG_AGP_NVIDIA
+   fi
+   if [ "$CONFIG_IA64" = "y" ]; then
+      bool '  Intel 460GX support' CONFIG_AGP_I460
+      bool '  HP ZX1 AGP support' CONFIG_AGP_HP_ZX1
+   fi
+   bool '  ATI IGP chipset support' CONFIG_AGP_ATI
+fi
+
+mainmenu_option next_comment
+comment 'Direct Rendering Manager (XFree86 DRI support)'
+bool 'Direct Rendering Manager (XFree86 DRI support)' CONFIG_DRM
+if [ "$CONFIG_DRM" = "y" ]; then
+   bool '  Build drivers for old (XFree 4.0) DRM' CONFIG_DRM_OLD
+   if [ "$CONFIG_DRM_OLD" = "y" ]; then
+      comment 'DRM 4.0 drivers'
+      source drivers/char/drm-4.0/Config.in
+   else
+      comment 'DRM 4.1 drivers'
+      define_bool CONFIG_DRM_NEW y
+      source drivers/char/drm/Config.in
+   fi
+fi
+
+if [ "$CONFIG_X86" = "y" ]; then
+   tristate 'ACP Modem (Mwave) support' CONFIG_MWAVE
+fi
+
+endmenu
+
+if [ "$CONFIG_HOTPLUG" = "y" -a "$CONFIG_PCMCIA" != "n" ]; then
+   source drivers/char/pcmcia/Config.in
+fi
+if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
+   tristate ' Alchemy Au1x00 GPIO device support' CONFIG_AU1X00_GPIO
+   tristate ' Au1000/ADS7846 touchscreen support' CONFIG_TS_AU1X00_ADS7846
+   #tristate ' Alchemy Au1550 PSC SPI support' CONFIG_AU1550_PSC_SPI
+fi
+if [ "$CONFIG_MIPS_ITE8172" = "y" ]; then
+  tristate ' ITE GPIO' CONFIG_ITE_GPIO
+fi
+
+if [ "$CONFIG_X86" = "y" ]; then
+   tristate 'ACP Modem (Mwave) support' CONFIG_MWAVE
+   dep_tristate 'HP OB600 C/CT Pop-up mouse support' CONFIG_OBMOUSE $CONFIG_INPUT_MOUSEDEV
+fi
+
+endmenu
diff -urN linux.old/drivers/char/Makefile linux.dev/drivers/char/Makefile
--- linux.old/drivers/char/Makefile	2005-10-21 16:43:16.460960500 +0200
+++ linux.dev/drivers/char/Makefile	2005-11-10 01:10:45.871576250 +0100
@@ -240,6 +240,13 @@
 obj-y += joystick/js.o
 endif
 
+#
+# Texas Intruments VLYNQ driver
+# 
+
+subdir-$(CONFIG_AR7_VLYNQ) += avalanche_vlynq
+obj-$(CONFIG_AR7_VLYNQ) += avalanche_vlynq/avalanche_vlynq.o                                                        
+
 obj-$(CONFIG_FETCHOP) += fetchop.o
 obj-$(CONFIG_BUSMOUSE) += busmouse.o
 obj-$(CONFIG_DTLK) += dtlk.o
@@ -340,6 +347,11 @@
   obj-y += ipmi/ipmi.o
 endif
 
+subdir-$(CONFIG_AR7_ADAM2) += ticfg
+ifeq ($(CONFIG_AR7_ADAM2),y)
+  obj-y += ticfg/ticfg.o
+endif
+
 include $(TOPDIR)/Rules.make
 
 fastdep:
diff -urN linux.old/drivers/char/Makefile.orig linux.dev/drivers/char/Makefile.orig
--- linux.old/drivers/char/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/char/Makefile.orig	2005-11-10 01:10:45.871576250 +0100
@@ -0,0 +1,374 @@
+#
+# Makefile for the kernel character device drivers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now inherited from the
+# parent makes..
+#
+
+#
+# This file contains the font map for the default (hardware) font
+#
+FONTMAPFILE = cp437.uni
+
+O_TARGET := char.o
+
+obj-y	 += mem.o tty_io.o n_tty.o tty_ioctl.o raw.o pty.o misc.o random.o
+
+# All of the (potential) objects that export symbols.
+# This list comes from 'grep -l EXPORT_SYMBOL *.[hc]'.
+
+export-objs     :=	busmouse.o console.o keyboard.o sysrq.o \
+			misc.o pty.o random.o selection.o serial.o \
+			sonypi.o tty_io.o tty_ioctl.o generic_serial.o \
+			au1000_gpio.o vac-serial.o hp_psaux.o nvram.o \
+			scx200.o fetchop.o
+
+mod-subdirs	:=	joystick ftape drm drm-4.0 pcmcia
+
+list-multi	:=	
+
+KEYMAP   =defkeymap.o
+KEYBD    =pc_keyb.o
+CONSOLE  =console.o
+SERIAL   =serial.o
+
+ifeq ($(ARCH),s390)
+  KEYMAP   =
+  KEYBD    =
+  CONSOLE  =
+  SERIAL   =
+endif
+
+ifeq ($(ARCH),mips)
+  ifneq ($(CONFIG_PC_KEYB),y)
+    KEYBD    =
+  endif
+  ifeq ($(CONFIG_VR41XX_KIU),y)
+    ifeq ($(CONFIG_IBM_WORKPAD),y)
+      KEYMAP = ibm_workpad_keymap.o
+    endif
+    ifeq ($(CONFIG_VICTOR_MPC30X),y)
+      KEYMAP = victor_mpc30x_keymap.o
+    endif
+    KEYBD    = vr41xx_keyb.o
+  endif
+endif
+
+ifeq ($(ARCH),s390x)
+  KEYMAP   =
+  KEYBD    =
+  CONSOLE  =
+  SERIAL   =
+endif
+
+ifeq ($(ARCH),m68k)
+   ifdef CONFIG_AMIGA
+      KEYBD = amikeyb.o
+   else
+      ifndef CONFIG_MAC
+	 KEYBD =
+      endif
+   endif
+   SERIAL   =
+endif
+
+ifeq ($(ARCH),parisc)
+   ifdef CONFIG_GSC_PS2
+      KEYBD   = hp_psaux.o hp_keyb.o
+   else
+      KEYBD   =
+   endif
+   ifdef CONFIG_SERIAL_MUX
+      CONSOLE += mux.o
+   endif
+   ifdef CONFIG_PDC_CONSOLE
+      CONSOLE += pdc_console.o
+   endif
+endif
+
+ifdef CONFIG_Q40
+  KEYBD += q40_keyb.o
+  SERIAL = serial.o
+endif
+
+ifdef CONFIG_APOLLO
+  KEYBD += dn_keyb.o
+endif
+
+ifeq ($(ARCH),parisc)
+   ifdef CONFIG_GSC_PS2
+      KEYBD   = hp_psaux.o hp_keyb.o
+   else
+      KEYBD   =
+   endif
+   ifdef CONFIG_PDC_CONSOLE
+      CONSOLE += pdc_console.o
+   endif
+endif
+
+ifeq ($(ARCH),arm)
+  ifneq ($(CONFIG_PC_KEYMAP),y)
+    KEYMAP   =
+  endif
+  ifneq ($(CONFIG_PC_KEYB),y)
+    KEYBD    =
+  endif
+endif
+
+ifeq ($(ARCH),sh)
+  KEYMAP   =
+  KEYBD    =
+  CONSOLE  =
+  ifeq ($(CONFIG_SH_HP600),y)
+  KEYMAP   = defkeymap.o
+  KEYBD    = scan_keyb.o hp600_keyb.o
+  CONSOLE  = console.o
+  endif
+  ifeq ($(CONFIG_SH_DMIDA),y)
+  # DMIDA does not connect the HD64465 PS/2 keyboard port
+  # but we allow for USB keyboards to be plugged in.
+  KEYMAP   = defkeymap.o
+  KEYBD    = # hd64465_keyb.o pc_keyb.o
+  CONSOLE  = console.o
+  endif
+  ifeq ($(CONFIG_SH_EC3104),y)
+  KEYMAP   = defkeymap.o
+  KEYBD    = ec3104_keyb.o
+  CONSOLE  = console.o
+  endif
+  ifeq ($(CONFIG_SH_DREAMCAST),y)
+  KEYMAP   = defkeymap.o
+  KEYBD    =
+  CONSOLE  = console.o
+  endif
+endif
+
+ifeq ($(CONFIG_DECSTATION),y)
+  KEYMAP   =
+  KEYBD    =
+endif
+
+ifeq ($(CONFIG_BAGET_MIPS),y)
+  KEYBD    =
+  SERIAL   = vac-serial.o
+endif
+
+ifeq ($(CONFIG_NINO),y)
+  SERIAL   =
+endif
+
+ifneq ($(CONFIG_SUN_SERIAL),)
+  SERIAL   =
+endif
+
+ifeq ($(CONFIG_QTRONIX_KEYBOARD),y)
+  KEYBD    = qtronix.o
+  KEYMAP   = qtronixmap.o
+endif
+
+ifeq ($(CONFIG_DUMMY_KEYB),y)
+  KEYBD = dummy_keyb.o
+endif
+
+obj-$(CONFIG_VT) += vt.o vc_screen.o consolemap.o consolemap_deftbl.o $(CONSOLE) selection.o
+obj-$(CONFIG_SERIAL) += $(SERIAL)
+obj-$(CONFIG_PARPORT_SERIAL) += parport_serial.o
+obj-$(CONFIG_SERIAL_HCDP) += hcdp_serial.o
+obj-$(CONFIG_SERIAL_21285) += serial_21285.o
+obj-$(CONFIG_SERIAL_SA1100) += serial_sa1100.o
+obj-$(CONFIG_SERIAL_AMBA) += serial_amba.o
+obj-$(CONFIG_TS_AU1X00_ADS7846) += au1000_ts.o
+obj-$(CONFIG_SERIAL_DEC) += decserial.o
+
+ifndef CONFIG_SUN_KEYBOARD
+  obj-$(CONFIG_VT) += keyboard.o $(KEYMAP) $(KEYBD)
+else
+  obj-$(CONFIG_PCI) += keyboard.o $(KEYMAP)
+endif
+
+obj-$(CONFIG_HIL) += hp_keyb.o
+obj-$(CONFIG_MAGIC_SYSRQ) += sysrq.o
+obj-$(CONFIG_ATARI_DSP56K) += dsp56k.o
+obj-$(CONFIG_ROCKETPORT) += rocket.o
+obj-$(CONFIG_MOXA_SMARTIO) += mxser.o
+obj-$(CONFIG_MOXA_INTELLIO) += moxa.o
+obj-$(CONFIG_DIGI) += pcxx.o
+obj-$(CONFIG_DIGIEPCA) += epca.o
+obj-$(CONFIG_CYCLADES) += cyclades.o
+obj-$(CONFIG_STALLION) += stallion.o
+obj-$(CONFIG_ISTALLION) += istallion.o
+obj-$(CONFIG_SIBYTE_SB1250_DUART) += sb1250_duart.o
+obj-$(CONFIG_COMPUTONE) += ip2.o ip2main.o
+obj-$(CONFIG_RISCOM8) += riscom8.o
+obj-$(CONFIG_ISI) += isicom.o
+obj-$(CONFIG_ESPSERIAL) += esp.o
+obj-$(CONFIG_SYNCLINK) += synclink.o
+obj-$(CONFIG_SYNCLINKMP) += synclinkmp.o
+obj-$(CONFIG_N_HDLC) += n_hdlc.o
+obj-$(CONFIG_SPECIALIX) += specialix.o
+obj-$(CONFIG_AMIGA_BUILTIN_SERIAL) += amiserial.o
+obj-$(CONFIG_A2232) += ser_a2232.o generic_serial.o
+obj-$(CONFIG_SX) += sx.o generic_serial.o
+obj-$(CONFIG_RIO) += rio/rio.o generic_serial.o
+obj-$(CONFIG_SH_SCI) += sh-sci.o generic_serial.o
+obj-$(CONFIG_SERIAL167) += serial167.o
+obj-$(CONFIG_MVME147_SCC) += generic_serial.o vme_scc.o
+obj-$(CONFIG_MVME162_SCC) += generic_serial.o vme_scc.o
+obj-$(CONFIG_BVME6000_SCC) += generic_serial.o vme_scc.o
+obj-$(CONFIG_HVC_CONSOLE) += hvc_console.o
+obj-$(CONFIG_SERIAL_TX3912) += generic_serial.o serial_tx3912.o
+obj-$(CONFIG_TXX927_SERIAL) += serial_txx927.o
+obj-$(CONFIG_SERIAL_TXX9) += generic_serial.o serial_txx9.o
+obj-$(CONFIG_IP22_SERIAL) += sgiserial.o
+obj-$(CONFIG_AU1X00_UART) += au1x00-serial.o
+obj-$(CONFIG_SGI_L1_SERIAL) += sn_serial.o
+
+subdir-$(CONFIG_RIO) += rio
+subdir-$(CONFIG_INPUT) += joystick
+
+obj-$(CONFIG_ATIXL_BUSMOUSE) += atixlmouse.o
+obj-$(CONFIG_LOGIBUSMOUSE) += logibusmouse.o
+obj-$(CONFIG_PRINTER) += lp.o
+obj-$(CONFIG_TIPAR) += tipar.o
+obj-$(CONFIG_OBMOUSE) += obmouse.o
+
+ifeq ($(CONFIG_INPUT),y)
+obj-y += joystick/js.o
+endif
+
+#
+# Texas Intruments VLYNQ driver
+# 
+
+subdir-$(CONFIG_AR7_VLYNQ) += avalanche_vlynq
+obj-$(CONFIG_AR7_VLYNQ) += avalanche_vlynq/avalanche_vlynq.o                                                        
+
+obj-$(CONFIG_FETCHOP) += fetchop.o
+obj-$(CONFIG_BUSMOUSE) += busmouse.o
+obj-$(CONFIG_DTLK) += dtlk.o
+obj-$(CONFIG_R3964) += n_r3964.o
+obj-$(CONFIG_APPLICOM) += applicom.o
+obj-$(CONFIG_SONYPI) += sonypi.o
+obj-$(CONFIG_MS_BUSMOUSE) += msbusmouse.o
+obj-$(CONFIG_82C710_MOUSE) += qpmouse.o
+obj-$(CONFIG_AMIGAMOUSE) += amigamouse.o
+obj-$(CONFIG_ATARIMOUSE) += atarimouse.o
+obj-$(CONFIG_ADBMOUSE) += adbmouse.o
+obj-$(CONFIG_PC110_PAD) += pc110pad.o
+obj-$(CONFIG_MK712_MOUSE) += mk712.o
+obj-$(CONFIG_RTC) += rtc.o
+obj-$(CONFIG_GEN_RTC) += genrtc.o
+obj-$(CONFIG_EFI_RTC) += efirtc.o
+obj-$(CONFIG_MIPS_RTC) += mips_rtc.o
+obj-$(CONFIG_SGI_IP27_RTC) += ip27-rtc.o
+ifeq ($(CONFIG_PPC),)
+  obj-$(CONFIG_NVRAM) += nvram.o
+endif
+obj-$(CONFIG_TOSHIBA) += toshiba.o
+obj-$(CONFIG_I8K) += i8k.o
+obj-$(CONFIG_DS1286) += ds1286.o
+obj-$(CONFIG_DS1620) += ds1620.o
+obj-$(CONFIG_DS1742) += ds1742.o
+obj-$(CONFIG_INTEL_RNG) += i810_rng.o
+obj-$(CONFIG_AMD_RNG) += amd768_rng.o
+obj-$(CONFIG_HW_RANDOM) += hw_random.o
+obj-$(CONFIG_AMD_PM768) += amd76x_pm.o
+obj-$(CONFIG_BRIQ_PANEL) += briq_panel.o
+
+obj-$(CONFIG_ITE_GPIO) += ite_gpio.o
+obj-$(CONFIG_AU1X00_GPIO) += au1000_gpio.o
+obj-$(CONFIG_AU1550_PSC_SPI) += au1550_psc_spi.o
+obj-$(CONFIG_AU1X00_USB_TTY) += au1000_usbtty.o
+obj-$(CONFIG_AU1X00_USB_RAW) += au1000_usbraw.o
+obj-$(CONFIG_COBALT_LCD) += lcd.o
+
+obj-$(CONFIG_QIC02_TAPE) += tpqic02.o
+
+subdir-$(CONFIG_FTAPE) += ftape
+subdir-$(CONFIG_DRM_OLD) += drm-4.0
+subdir-$(CONFIG_DRM_NEW) += drm
+subdir-$(CONFIG_PCMCIA) += pcmcia
+subdir-$(CONFIG_AGP) += agp
+
+ifeq ($(CONFIG_FTAPE),y)
+obj-y       += ftape/ftape.o
+endif
+
+obj-$(CONFIG_H8) += h8.o
+obj-$(CONFIG_PPDEV) += ppdev.o
+obj-$(CONFIG_DZ) += dz.o
+obj-$(CONFIG_NWBUTTON) += nwbutton.o
+obj-$(CONFIG_NWFLASH) += nwflash.o
+obj-$(CONFIG_SCx200) += scx200.o
+obj-$(CONFIG_SCx200_GPIO) += scx200_gpio.o
+
+# Only one watchdog can succeed. We probe the hardware watchdog
+# drivers first, then the softdog driver.  This means if your hardware
+# watchdog dies or is 'borrowed' for some reason the software watchdog
+# still gives you some cover.
+
+obj-$(CONFIG_PCWATCHDOG) += pcwd.o
+obj-$(CONFIG_ACQUIRE_WDT) += acquirewdt.o
+obj-$(CONFIG_ADVANTECH_WDT) += advantechwdt.o
+obj-$(CONFIG_IB700_WDT) += ib700wdt.o
+obj-$(CONFIG_MIXCOMWD) += mixcomwd.o
+obj-$(CONFIG_60XX_WDT) += sbc60xxwdt.o
+obj-$(CONFIG_W83877F_WDT) += w83877f_wdt.o
+obj-$(CONFIG_SC520_WDT) += sc520_wdt.o
+obj-$(CONFIG_WDT) += wdt.o
+obj-$(CONFIG_WDTPCI) += wdt_pci.o
+obj-$(CONFIG_21285_WATCHDOG) += wdt285.o
+obj-$(CONFIG_977_WATCHDOG) += wdt977.o
+obj-$(CONFIG_I810_TCO) += i810-tco.o
+obj-$(CONFIG_MACHZ_WDT) += machzwd.o
+obj-$(CONFIG_SH_WDT) += shwdt.o
+obj-$(CONFIG_EUROTECH_WDT) += eurotechwdt.o
+obj-$(CONFIG_ALIM7101_WDT) += alim7101_wdt.o
+obj-$(CONFIG_ALIM1535_WDT) += alim1535d_wdt.o
+obj-$(CONFIG_INDYDOG) += indydog.o
+obj-$(CONFIG_SC1200_WDT) += sc1200wdt.o
+obj-$(CONFIG_SCx200_WDT) += scx200_wdt.o
+obj-$(CONFIG_WAFER_WDT) += wafer5823wdt.o
+obj-$(CONFIG_SOFT_WATCHDOG) += softdog.o
+obj-$(CONFIG_INDYDOG) += indydog.o
+obj-$(CONFIG_8xx_WDT) += mpc8xx_wdt.o
+
+subdir-$(CONFIG_MWAVE) += mwave
+ifeq ($(CONFIG_MWAVE),y)
+  obj-y += mwave/mwave.o
+endif
+
+subdir-$(CONFIG_IPMI_HANDLER) += ipmi
+ifeq ($(CONFIG_IPMI_HANDLER),y)
+  obj-y += ipmi/ipmi.o
+endif
+
+include $(TOPDIR)/Rules.make
+
+fastdep:
+
+conmakehash: conmakehash.c
+	$(HOSTCC) $(HOSTCFLAGS) -o conmakehash conmakehash.c
+
+consolemap_deftbl.c: $(FONTMAPFILE) conmakehash
+	./conmakehash $(FONTMAPFILE) > consolemap_deftbl.c
+
+consolemap_deftbl.o: consolemap_deftbl.c $(TOPDIR)/include/linux/types.h
+
+.DELETE_ON_ERROR:
+
+defkeymap.c: defkeymap.map
+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
+
+qtronixmap.c: qtronixmap.map
+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
+
+ibm_workpad_keymap.c: ibm_workpad_keymap.map
+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
+
+victor_mpc30x_keymap.c: victor_mpc30x_keymap.map
+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
diff -urN linux.old/drivers/char/avalanche_vlynq/Makefile linux.dev/drivers/char/avalanche_vlynq/Makefile
--- linux.old/drivers/char/avalanche_vlynq/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/char/avalanche_vlynq/Makefile	2005-11-10 01:10:45.871576250 +0100
@@ -0,0 +1,16 @@
+#
+# Makefile for the linux kernel.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now in the main makefile...
+
+O_TARGET := avalanche_vlynq.o
+
+export-objs := vlynq_board.o
+
+obj-y    +=  vlynq_drv.o  vlynq_hal.o  vlynq_board.o
+
+include $(TOPDIR)/Rules.make
diff -urN linux.old/drivers/char/avalanche_vlynq/vlynq_board.c linux.dev/drivers/char/avalanche_vlynq/vlynq_board.c
--- linux.old/drivers/char/avalanche_vlynq/vlynq_board.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/char/avalanche_vlynq/vlynq_board.c	2005-11-10 01:10:45.871576250 +0100
@@ -0,0 +1,184 @@
+/*
+ * Jeff Harrell, jharrell@ti.com
+ * Copyright (C) 2001 Texas Instruments, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Texas Instruments Sangam specific setup.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <asm/ar7/sangam.h>  
+#include <asm/ar7/avalanche_misc.h>  
+#include <asm/ar7/vlynq.h>  
+   
+#define SYS_VLYNQ_LOCAL_INTERRUPT_VECTOR	30 	/* MSB - 1 bit */
+#define SYS_VLYNQ_REMOTE_INTERRUPT_VECTOR	31 	/* MSB bit */
+#define SYS_VLYNQ_OPTIONS 		        0x7F; 	/* all options*/
+
+/* These defines are board specific */
+
+
+#define VLYNQ0_REMOTE_WINDOW1_OFFSET           (0x0C000000)
+#define VLYNQ0_REMOTE_WINDOW1_SIZE             (0x500)
+
+
+#define VLYNQ1_REMOTE_WINDOW1_OFFSET           (0x0C000000)
+#define VLYNQ1_REMOTE_WINDOW1_SIZE             (0x500)
+
+
+extern VLYNQ_DEV vlynqDevice0, vlynqDevice1;
+int    vlynq_init_status[2] = {0, 0};
+EXPORT_SYMBOL(vlynq_init_status);
+static int reset_hack = 1;
+
+void vlynq_ar7wrd_dev_init()
+{
+    *(unsigned long*) AVALANCHE_GPIO_ENBL    |= (1<<18);
+    vlynq_delay(20000);
+    *(unsigned long*) AVALANCHE_GPIO_DIR     &= ~(1<<18);
+    vlynq_delay(20000);
+    *(unsigned long*) AVALANCHE_GPIO_DATA_OUT&= ~(1<<18);
+    vlynq_delay(50000);
+    *(unsigned long*) AVALANCHE_GPIO_DATA_OUT|=  (1<<18);
+    vlynq_delay(50000);
+
+    /* Initialize the MIPS host vlynq driver for a given vlynq interface */
+    vlynqDevice0.dev_idx = 0;			/* first vlynq module - this parameter is for reference only */
+    vlynqDevice0.module_base = AVALANCHE_LOW_VLYNQ_CONTROL_BASE; 	/*  vlynq0 module base address */
+
+#if defined(CONFIG_VLYNQ_CLK_LOCAL)
+    vlynqDevice0.clk_source = VLYNQ_CLK_SOURCE_LOCAL;   
+#else
+    vlynqDevice0.clk_source = VLYNQ_CLK_SOURCE_REMOTE;   
+#endif
+    vlynqDevice0.clk_div = 0x01; 			/* board/hardware specific */
+    vlynqDevice0.state =  VLYNQ_DRV_STATE_UNINIT; 	/* uninitialized module */
+
+    /* Populate vlynqDevice0.local_mem & Vlynq0.remote_mem based on system configuration */ 
+    /*Local memory configuration */
+
+                /* Demiurg : not good !*/
+#if 0
+    vlynqDevice0.local_mem.Txmap= AVALANCHE_LOW_VLYNQ_MEM_MAP_BASE & ~(0xc0000000) ; /* physical address */
+    vlynqDevice0.remote_mem.RxOffset[0]= VLYNQ0_REMOTE_WINDOW1_OFFSET; /* This is specific to the board on the other end */
+    vlynqDevice0.remote_mem.RxSize[0]=VLYNQ0_REMOTE_WINDOW1_SIZE;
+#endif
+
+                /* Demiurg : This is how it should be ! */
+                vlynqDevice0.local_mem.Txmap = PHYSADDR(AVALANCHE_LOW_VLYNQ_MEM_MAP_BASE);
+#define VLYNQ_ACX111_MEM_OFFSET     0xC0000000  /* Physical address of ACX111 memory */
+#define VLYNQ_ACX111_MEM_SIZE       0x00040000  /* Total size of the ACX111 memory   */
+#define VLYNQ_ACX111_REG_OFFSET     0xF0000000  /* PHYS_ADDR of ACX111 control registers   */
+#define VLYNQ_ACX111_REG_SIZE       0x00022000  /* Size of ACX111 registers area, MAC+PHY  */
+#define ACX111_VL1_REMOTE_SIZE 0x1000000
+                vlynqDevice0.remote_mem.RxOffset[0]  =  VLYNQ_ACX111_MEM_OFFSET;
+                vlynqDevice0.remote_mem.RxSize[0]    =  VLYNQ_ACX111_MEM_SIZE  ;
+                vlynqDevice0.remote_mem.RxOffset[1]  =  VLYNQ_ACX111_REG_OFFSET;
+                vlynqDevice0.remote_mem.RxSize[1]    =  VLYNQ_ACX111_REG_SIZE  ;
+                vlynqDevice0.remote_mem.Txmap        =  0;
+                vlynqDevice0.local_mem.RxOffset[0]   =  AVALANCHE_SDRAM_BASE;
+                vlynqDevice0.local_mem.RxSize[0]     =  ACX111_VL1_REMOTE_SIZE;
+
+
+    /* Local interrupt configuration */
+    vlynqDevice0.local_irq.intLocal = VLYNQ_INT_LOCAL; 	/* Host handles vlynq interrupts*/
+    vlynqDevice0.local_irq.intRemote = VLYNQ_INT_ROOT_ISR;  	/* vlynq root isr used */
+    vlynqDevice0.local_irq.map_vector = SYS_VLYNQ_LOCAL_INTERRUPT_VECTOR;
+    vlynqDevice0.local_irq.intr_ptr = 0; /* Since remote interrupts part of vlynq root isr this is unused */
+
+    /* Remote interrupt configuration */
+    vlynqDevice0.remote_irq.intLocal = VLYNQ_INT_REMOTE; 	/* MIPS handles interrupts */
+    vlynqDevice0.remote_irq.intRemote = VLYNQ_INT_ROOT_ISR;  	/* Not significant since MIPS handles interrupts */
+    vlynqDevice0.remote_irq.map_vector = SYS_VLYNQ_REMOTE_INTERRUPT_VECTOR;
+    vlynqDevice0. remote_irq.intr_ptr = AVALANCHE_INTC_BASE; /* Not significant since MIPS handles interrupts */
+
+     if(reset_hack != 1)
+       printk("About to re-init the VLYNQ.\n");
+
+    if(vlynq_init(&vlynqDevice0,VLYNQ_INIT_PERFORM_ALL)== 0)
+    {
+        /* Suraj added the following to keep the 1130 going. */
+        vlynq_interrupt_vector_set(&vlynqDevice0, 0 /* intr vector line running into 1130 vlynq */,
+                                   0 /* intr mapped onto the interrupt register on remote vlynq and this vlynq */,
+                                   VLYNQ_REMOTE_DVC, 0 /* polarity active high */, 0 /* interrupt Level triggered */);
+
+        /* System wide interrupt is 80 for 1130, please note. */
+        vlynq_init_status[0] = 1;
+        reset_hack = 2;
+    }
+    else
+    {
+        if(reset_hack == 1)
+            printk("VLYNQ INIT FAILED: Please try cold reboot. \n");
+        else
+            printk("Failed to initialize the VLYNQ interface at insmod.\n");
+
+    }
+}
+
+void  vlynq_dev_init(void)
+{
+    volatile unsigned int *reset_base = (unsigned int *) AVALANCHE_RESET_CONTROL_BASE;
+
+    *reset_base &= ~((1 << AVALANCHE_LOW_VLYNQ_RESET_BIT)); /* | (1 << AVALANCHE_HIGH_VLYNQ_RESET_BIT)); */
+
+    vlynq_delay(20000);
+
+    /* Bring vlynq out of reset if not already done */
+    *reset_base |= (1 << AVALANCHE_LOW_VLYNQ_RESET_BIT); /* | (1 << AVALANCHE_HIGH_VLYNQ_RESET_BIT); */
+    vlynq_delay(20000); /* Allowing sufficient time to VLYNQ to settle down.*/
+
+    vlynq_ar7wrd_dev_init( );
+
+}
+
+/* This function is board specific and should be ported for each board. */
+void remote_vlynq_dev_reset_ctrl(unsigned int module_reset_bit,
+                                 AVALANCHE_RESET_CTRL_T reset_ctrl)
+{
+    if(module_reset_bit >= 32)
+        return;
+
+    switch(module_reset_bit)
+    {
+        case 0:
+            if(OUT_OF_RESET == reset_ctrl)
+            {
+                if(reset_hack) return;
+
+                vlynq_delay(20000);
+                printk("Un-resetting the remote device.\n");
+                vlynq_dev_init();
+                printk("Re-initialized the VLYNQ.\n");
+                reset_hack = 2;
+            }
+            else if(IN_RESET == reset_ctrl)
+            {
+                *(unsigned long*) AVALANCHE_GPIO_DATA_OUT &= ~(1<<18);
+
+                vlynq_delay(20000);
+                printk("Resetting the remote device.\n");
+                reset_hack = 0;
+            }
+            else
+                ;
+        break;
+
+        default:
+        break;
+
+    }
+}
+
diff -urN linux.old/drivers/char/avalanche_vlynq/vlynq_drv.c linux.dev/drivers/char/avalanche_vlynq/vlynq_drv.c
--- linux.old/drivers/char/avalanche_vlynq/vlynq_drv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/char/avalanche_vlynq/vlynq_drv.c	2005-11-10 01:10:45.891577500 +0100
@@ -0,0 +1,243 @@
+/******************************************************************************
+ * FILE PURPOSE:    Vlynq Linux Device Driver Source
+ ******************************************************************************
+ * FILE NAME:       vlynq_drv.c
+ *
+ * DESCRIPTION:     Vlynq Linux Device Driver Source
+ *
+ * REVISION HISTORY:
+ *
+ * Date           Description                       Author
+ *-----------------------------------------------------------------------------
+ * 17 July 2003   Initial Creation                  Anant Gole
+ * 17 Dec  2003   Updates                           Sharath Kumar
+ *
+ * (C) Copyright 2003, Texas Instruments, Inc
+ *******************************************************************************/
+ 
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/miscdevice.h>
+#include <linux/smp_lock.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/capability.h>
+#include <asm/ar7/avalanche_intc.h>
+#include <asm/ar7/sangam.h>
+#include <asm/ar7/vlynq.h>
+
+
+#define    TI_VLYNQ_VERSION                 "0.2"
+
+/* debug on ? */
+#define VLYNQ_DEBUG 
+
+/* Macro for debug and error printf's */
+#ifdef VLYNQ_DEBUG
+#define DBGPRINT  printk
+#else
+#define DBGPRINT(x)  
+#endif
+
+#define ERRPRINT  printk
+
+/* Define the max vlynq ports this driver will support. 
+   Device name strings are statically added here */
+#define MAX_VLYNQ_PORTS 2
+
+
+/* Type define for VLYNQ private structure */
+typedef struct vlynqPriv{
+    int irq;
+    VLYNQ_DEV *vlynqDevice;
+}VLYNQ_PRIV;
+
+extern int vlynq_init_status[2];
+
+/* Extern Global variable for vlynq devices used in initialization of the vlynq device
+ * These variables need to be populated/initialized by the system as part of initialization
+ * process. The vlynq enumerator can run at initialization and populate these globals
+ */
+
+VLYNQ_DEV vlynqDevice0;
+VLYNQ_DEV vlynqDevice1;
+
+/* Defining dummy macro AVALANCHE_HIGH_VLYNQ_INT to take
+ * care of compilation in case of single vlynq device 
+ */
+
+#ifndef AVALANCHE_HIGH_VLYNQ_INT
+#define  AVALANCHE_HIGH_VLYNQ_INT 0
+#endif
+
+
+
+/* vlynq private object */
+VLYNQ_PRIV vlynq_priv[CONFIG_AR7_VLYNQ_PORTS] = {
+    { LNXINTNUM(AVALANCHE_LOW_VLYNQ_INT),&vlynqDevice0},
+    { LNXINTNUM(AVALANCHE_HIGH_VLYNQ_INT),&vlynqDevice1},
+};
+
+extern void vlynq_dev_init(void);
+
+
+/* =================================== all the operations */
+
+static int
+vlynq_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    return 0;
+}
+
+static struct file_operations vlynq_fops = {
+    owner:      THIS_MODULE,
+    ioctl:      vlynq_ioctl,
+};
+
+/* Vlynq device object */
+static struct miscdevice vlynq_dev [MAX_VLYNQ_PORTS] = {
+    { MISC_DYNAMIC_MINOR , "vlynq0", &vlynq_fops },
+    { MISC_DYNAMIC_MINOR , "vlynq1", &vlynq_fops },
+};
+
+
+/* Proc read function */
+static int
+vlynq_read_link_proc(char *buf, char **start, off_t offset, int count, int *eof, void *unused)
+{
+    int instance;
+    int len = 0;
+ 
+    len += sprintf(buf +len,"VLYNQ Devices : %d\n",CONFIG_AR7_VLYNQ_PORTS);
+
+    for(instance =0;instance < CONFIG_AR7_VLYNQ_PORTS;instance++)
+    {
+        int link_state;
+        char *link_msg[] = {" DOWN "," UP "};
+       
+        if(vlynq_init_status[instance] == 0)
+            link_state = 0; 
+
+        else if (vlynq_link_check(vlynq_priv[instance].vlynqDevice))
+            link_state = 1;
+
+        else
+            link_state = 0;    
+
+        len += sprintf(buf + len, "VLYNQ %d: Link state: %s\n",instance,link_msg[link_state]);
+
+    }
+    /* Print info about vlynq device 1 */
+   
+    return len;
+}
+
+
+/* Proc function to display driver version */                                                                       
+static int                                                                                     
+vlynq_read_ver_proc(char *buf, char **start, off_t offset, int count, int *eof, void *data)        
+{                                                                                              
+	int instance;                                                                              
+	int len=0;                                                                                 
+                                                                                               
+	len += sprintf(buf +len,"\nTI Linux VLYNQ Driver Version %s\n",TI_VLYNQ_VERSION);         
+	return len;                                                                                
+}                                                                                              
+
+
+
+
+/* Wrapper for vlynq ISR */
+static void lnx_vlynq_root_isr(int irq, void * arg, struct pt_regs *regs)
+{
+   vlynq_root_isr(arg);
+}
+
+/* =================================== init and cleanup */
+
+int vlynq_init_module(void)
+{
+    int ret;
+    int unit = 0;
+    int instance_count = CONFIG_AR7_VLYNQ_PORTS;
+    volatile int *ptr;
+
+    vlynq_dev_init();
+
+    DBGPRINT("Vlynq CONFIG_AR7_VLYNQ_PORTS=%d\n", CONFIG_AR7_VLYNQ_PORTS);
+    /* If num of configured vlynq ports > supported by driver return error */
+    if (instance_count > MAX_VLYNQ_PORTS)
+    {
+        ERRPRINT("ERROR: vlynq_init_module(): Max %d supported\n", MAX_VLYNQ_PORTS);
+        return (-1);
+    }
+
+    /* register the misc device */
+    for (unit = 0; unit < CONFIG_AR7_VLYNQ_PORTS; unit++)
+    {
+        ret = misc_register(&vlynq_dev[unit]);
+
+        if(ret < 0)
+        {
+            ERRPRINT("ERROR:Could not register vlynq device:%d\n",unit);
+            continue;
+        }
+        else 
+            DBGPRINT("Vlynq Device %s registered with minor no %d as misc device. Result=%d\n", 
+                vlynq_dev[unit].name, vlynq_dev[unit].minor, ret);
+#if 0
+            
+        DBGPRINT("Calling vlynq init\n");
+
+        /* Read the global variable for VLYNQ device structure and initialize vlynq driver */
+        ret = vlynq_init(vlynq_priv[unit].vlynqDevice,VLYNQ_INIT_PERFORM_ALL );
+#endif
+
+        if(vlynq_init_status[unit] == 0)
+        {
+            printk("VLYNQ %d : init failed\n",unit); 
+            continue;
+        }
+         
+        /* Check link before proceeding */
+        if (!vlynq_link_check(vlynq_priv[unit].vlynqDevice))
+        {
+ 	    DBGPRINT("\nError: Vlynq link not available.trying once before  Exiting");
+        }
+        else
+        {
+            DBGPRINT("Vlynq instance:%d Link UP\n",unit);
+        
+            /* Install the vlynq local root ISR */
+           request_irq(vlynq_priv[unit].irq,lnx_vlynq_root_isr,0,vlynq_dev[unit].name,vlynq_priv[unit].vlynqDevice);
+        } 
+    }
+
+    proc_mkdir("avalanche", NULL);
+    /* Creating proc entry for the devices */
+    create_proc_read_entry("avalanche/vlynq_link", 0, NULL, vlynq_read_link_proc, NULL);
+    create_proc_read_entry("avalanche/vlynq_ver", 0, NULL, vlynq_read_ver_proc, NULL);
+  
+    return 0;
+}
+
+void vlynq_cleanup_module(void)
+{
+    int unit = 0;
+    
+    for (unit = 0; unit < CONFIG_AR7_VLYNQ_PORTS; unit++)
+    {
+        DBGPRINT("vlynq_cleanup_module(): Unregistring misc device %s\n",vlynq_dev[unit].name);
+        misc_deregister(&vlynq_dev[unit]);
+    }
+
+    remove_proc_entry("avalanche/vlynq_link", NULL);
+    remove_proc_entry("avalanche/vlynq_ver", NULL);
+}
+
+
+module_init(vlynq_init_module);
+module_exit(vlynq_cleanup_module);
+
diff -urN linux.old/drivers/char/avalanche_vlynq/vlynq_hal.c linux.dev/drivers/char/avalanche_vlynq/vlynq_hal.c
--- linux.old/drivers/char/avalanche_vlynq/vlynq_hal.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/char/avalanche_vlynq/vlynq_hal.c	2005-11-10 01:10:45.975582750 +0100
@@ -0,0 +1,1214 @@
+/***************************************************************************
+**+----------------------------------------------------------------------+**
+**|                                ****                                  |**
+**|                                ****                                  |**
+**|                                ******o***                            |**
+**|                          ********_///_****                           |**
+**|                           ***** /_//_/ ****                          |**
+**|                            ** ** (__/ ****                           |**
+**|                                *********                             |**
+**|                                 ****                                 |**
+**|                                  ***                                 |**
+**|                                                                      |**
+**|     Copyright (c) 2003 Texas Instruments Incorporated                |**
+**|                        ALL RIGHTS RESERVED                           |**
+**|                                                                      |**
+**| Permission is hereby granted to licensees of Texas Instruments       |**
+**| Incorporated (TI) products to use this computer program for the sole |**
+**| purpose of implementing a licensee product based on TI products.     |**
+**| No other rights to reproduce, use, or disseminate this computer      |**
+**| program, whether in part or in whole, are granted.                   |**
+**|                                                                      |**
+**| TI makes no representation or warranties with respect to the         |**
+**| performance of this computer program, and specifically disclaims     |**
+**| any responsibility for any damages, special or consequential,        |**
+**| connected with the use of this program.                              |**
+**|                                                                      |**
+**+----------------------------------------------------------------------+**
+***************************************************************************/
+
+/***************************************************************************
+ *  ------------------------------------------------------------------------------
+ *   Module      : vlynq_hal.c
+ *   Description : This file implements VLYNQ HAL API.
+ *  ------------------------------------------------------------------------------
+ ***************************************************************************/
+
+#include <linux/stddef.h>
+#include <linux/types.h>
+#include <asm/ar7/vlynq.h>
+
+/**** Local Function prototypes *******/
+static int vlynqInterruptInit(VLYNQ_DEV *pdev);
+static void  vlynq_configClock(VLYNQ_DEV  *pdev);
+
+/*** Second argument must be explicitly type casted to 
+ * (VLYNQ_DEV*) inside the following functions */
+static void vlynq_local_module_isr(void *arg1, void *arg2, void *arg3);
+static void vlynq_remote_module_isr(void *arg1, void *arg2, void *arg3);
+
+
+volatile int vlynq_delay_value = 0;
+
+/* Code adopted from original vlynq driver */
+void vlynq_delay(unsigned int clktime)
+{
+    int i = 0;
+    volatile int    *ptr = &vlynq_delay_value;
+    *ptr = 0;
+
+    /* We are assuming that the each cycle takes about 
+     * 23 assembly instructions. */
+    for(i = 0; i < (clktime + 23)/23; i++)
+    {
+        *ptr = *ptr + 1;
+    }
+}
+
+
+/* ----------------------------------------------------------------------------
+ *  Function : vlynq_configClock()
+ *  Description: Configures clock settings based on input parameters
+ *  Adapted from original vlyna driver from Cable
+ */
+static void vlynq_configClock(VLYNQ_DEV * pdev)
+{
+    unsigned int tmp;
+
+    switch( pdev->clk_source)
+    {
+        case VLYNQ_CLK_SOURCE_LOCAL:  /* we output the clock, clk_div in range [1..8]. */
+            tmp = ((pdev->clk_div - 1) << 16) |  VLYNQ_CTL_CLKDIR_MASK ;
+            VLYNQ_CTRL_REG = tmp;
+            VLYNQ_R_CTRL_REG = 0ul;
+            break;
+        case VLYNQ_CLK_SOURCE_REMOTE: /* we need to set the clock pin as input */
+            VLYNQ_CTRL_REG = 0ul;
+            tmp = ((pdev->clk_div - 1) << 16) |  VLYNQ_CTL_CLKDIR_MASK ;
+            VLYNQ_R_CTRL_REG = tmp;
+            break;
+        default:   /* do nothing about the clock, but clear other bits. */
+            tmp = ~(VLYNQ_CTL_CLKDIR_MASK | VLYNQ_CTL_CLKDIV_MASK);
+            VLYNQ_CTRL_REG &= tmp;
+            break;
+   }
+}
+
+ /* ----------------------------------------------------------------------------
+ *  Function : vlynq_link_check()
+ *  Description: This function checks the current VLYNQ for a link.
+ *  An arbitrary amount of time is allowed for the link to come up .
+ *  Returns 0 for "no link / failure " and 1 for "link available".
+ * -----------------------------------------------------------------------------
+ */
+unsigned int vlynq_link_check( VLYNQ_DEV * pdev)
+{
+    /*sleep for 64 cycles, allow link to come up*/
+    vlynq_delay(64);  
+      
+    /* check status register return OK if link is found. */
+    if (VLYNQ_STATUS_REG & VLYNQ_STS_LINK_MASK) 
+    {
+        return 1;   /* Link Available */
+    }
+    else
+    {
+        return 0;   /* Link Failure */
+    }
+}
+
+/* ----------------------------------------------------------------------------
+ *  Function : vlynq_init()
+ *  Description: Initialization function accepting paramaters for VLYNQ module
+ *  initialization. The Options bitmap decides what operations are performed
+ *  as a part of initialization. The Input parameters  are obtained through the
+ *  sub fields of VLYNQ_DEV structure.
+ */
+
+int vlynq_init(VLYNQ_DEV *pdev, VLYNQ_INIT_OPTIONS options)
+{
+    unsigned int map;
+    unsigned int val=0,cnt,tmp;
+    unsigned int counter=0;
+    VLYNQ_INTERRUPT_CNTRL *intSetting=NULL;
+
+    /* validate arguments */
+    if( VLYNQ_OUTRANGE(pdev->clk_source, VLYNQ_CLK_SOURCE_REMOTE, VLYNQ_CLK_SOURCE_NONE) || 
+        VLYNQ_OUTRANGE(pdev->clk_div, 8, 1) )
+    {
+      return VLYNQ_INVALID_ARG;
+    }
+   
+    /** perform all sanity checks first **/
+    if(pdev->state != VLYNQ_DRV_STATE_UNINIT)
+        return VLYNQ_INVALID_DRV_STATE;
+
+    /** Initialize local and remote register set addresses- additional
+     * provision to access the registers directly if need be */
+    pdev->local = (VLYNQ_REG_SET*)pdev->module_base;
+    pdev->remote = (VLYNQ_REG_SET*) (pdev->module_base + VLYNQ_REMOTE_REGS_OFFSET);
+
+    /* Detect faulty int configuration that might induce int pkt looping */
+    if ( (options  & VLYNQ_INIT_LOCAL_INTERRUPTS) && (options & VLYNQ_INIT_REMOTE_INTERRUPTS) )
+    {
+        /* case when both local and remote are configured */
+        if((pdev->local_irq.intLocal== VLYNQ_INT_REMOTE )  /* interrupts transfered to remote from local */
+        && (pdev->remote_irq.intLocal== VLYNQ_INT_REMOTE)  /* interrupts transfered from remote to local */
+        && ((pdev->local_irq.intRemote == VLYNQ_INT_ROOT_ISR) || (pdev->remote_irq.intRemote == VLYNQ_INT_ROOT_ISR)) )
+        {
+            return (VLYNQ_INT_CONFIG_ERR); 
+        }
+    }
+
+    pdev->state = VLYNQ_DRV_STATE_ININIT;
+    pdev->intCount = 0;
+    pdev->isrCount = 0;
+
+    /*** Its assumed that the vlynq module  has been brought out of reset
+     * before invocation of vlynq_init. Since, this operation is board specific
+     * it must be handled outside this generic driver */
+   
+    /* Assert reset the remote device, call reset_cb,
+     * reset CB holds Reset according to the device needs. */
+    VLYNQ_RESETCB(VLYNQ_RESET_ASSERT);
+
+    /* Handle VLYNQ clock, HW default (Sense On Reset) is
+     * usually input for all the devices. */        
+    if (options & VLYNQ_INIT_CONFIG_CLOCK)
+    {
+        vlynq_configClock(pdev);
+    }
+ 
+    /* Call reset_cb again. It will release the remote device 
+     * from reset, and wait for a while. */
+    VLYNQ_RESETCB(VLYNQ_RESET_DEASSERT);
+
+    if(options & VLYNQ_INIT_CHECK_LINK )
+    {
+        /* Check for link up during initialization*/
+	while( counter < 25 )
+	{
+	/* loop around giving a chance for link status to settle down */
+	counter++;
+        if(vlynq_link_check(pdev))
+        {
+           /* Link is up exit loop*/
+	   break;
+        }
+
+	vlynq_delay(4000);
+	}/*end of while counter loop */
+
+        if(!vlynq_link_check(pdev))
+        {
+            /* Handle this case as abort */
+            pdev->state = VLYNQ_DRV_STATE_ERROR;
+            VLYNQ_RESETCB( VLYNQ_RESET_INITFAIL);
+            return VLYNQ_LINK_DOWN;
+        }/* end of if not vlynq_link_check conditional block */
+      
+    }/*end of if options & VLYNQ_INIT_CHECK_LINK conditional block */
+
+
+    if (options & VLYNQ_INIT_LOCAL_MEM_REGIONS)
+    {
+        /* Initialise local memory regions . This initialization lets
+         * the local host access remote device memory regions*/   
+        int i; 
+
+        /* configure the VLYNQ portal window to a PHYSICAL
+         * address of the local CPU */
+        VLYNQ_ALIGN4(pdev->local_mem.Txmap);
+        VLYNQ_TXMAP_REG = (pdev->local_mem.Txmap); 
+        
+        /*This code assumes input parameter is itself a physical address */
+        for(i=0; i < VLYNQ_MAX_MEMORY_REGIONS ; i++)
+        {
+            /* Physical address on the remote */
+            map = i+1;
+            VLYNQ_R_RXMAP_SIZE_REG(map) =  0;
+            if( pdev->remote_mem.RxSize[i])
+            {
+                VLYNQ_ALIGN4(pdev->remote_mem.RxOffset[i]);            
+                VLYNQ_ALIGN4(pdev->remote_mem.RxSize[i]);
+                VLYNQ_R_RXMAP_OFFSET_REG(map) = pdev->remote_mem.RxOffset[i];
+                VLYNQ_R_RXMAP_SIZE_REG(map) = pdev->remote_mem.RxSize[i];
+            }
+        }
+    }
+
+    if(options & VLYNQ_INIT_REMOTE_MEM_REGIONS )
+    {
+        int i;
+
+        /* Initialise remote memory regions. This initialization lets remote
+         * device access local host memory regions. It configures the VLYNQ portal
+         * window to a PHYSICAL address of the remote */
+        VLYNQ_ALIGN4(pdev->remote_mem.Txmap);            
+        VLYNQ_R_TXMAP_REG = pdev->remote_mem.Txmap;
+       
+        for( i=0; i<VLYNQ_MAX_MEMORY_REGIONS; i++)
+        {
+            /* Physical address on the local */
+            map = i+1;
+            VLYNQ_RXMAP_SIZE_REG(map) =  0;
+            if( pdev->local_mem.RxSize[i])
+            {
+                VLYNQ_ALIGN4(pdev->local_mem.RxOffset[i]);            
+                VLYNQ_ALIGN4(pdev->local_mem.RxSize[i]);
+                VLYNQ_RXMAP_OFFSET_REG(map) =  (pdev->local_mem.RxOffset[i]);
+                VLYNQ_RXMAP_SIZE_REG(map) =  (pdev->local_mem.RxSize[i]);
+            }
+        }
+    }
+
+    /* Adapted from original vlynq driver from cable - Calculate VLYNQ bus width */
+    pdev->width = 3 +  VLYNQ_STATUS_FLD_WIDTH(VLYNQ_STATUS_REG) 
+                  + VLYNQ_STATUS_FLD_WIDTH(VLYNQ_R_STATUS_REG);
+   
+    /* chance to initialize the device, e.g. to boost VLYNQ 
+     * clock by modifying pdev->clk_div or and verify the width. */
+    VLYNQ_RESETCB(VLYNQ_RESET_LINKESTABLISH);
+
+    /* Handle VLYNQ clock, HW default (Sense On Reset) is
+     * usually input for all the devices. */
+    if(options & VLYNQ_INIT_CONFIG_CLOCK )
+    {
+        vlynq_configClock(pdev);
+    }
+
+    /* last check for link*/
+    if(options & VLYNQ_INIT_CHECK_LINK )
+    {
+     /* Final Check for link during initialization*/
+	while( counter < 25 )
+	{
+	/* loop around giving a chance for link status to settle down */
+	counter++;
+        if(vlynq_link_check(pdev))
+        {
+           /* Link is up exit loop*/
+	   break;
+        }
+
+	vlynq_delay(4000);
+	}/*end of while counter loop */
+
+        if(!vlynq_link_check(pdev))
+        {
+            /* Handle this case as abort */
+            pdev->state = VLYNQ_DRV_STATE_ERROR;
+            VLYNQ_RESETCB( VLYNQ_RESET_INITFAIL);
+            return VLYNQ_LINK_DOWN;
+        }/* end of if not vlynq_link_check conditional block */
+        
+    } /* end of if options & VLYNQ_INIT_CHECK_LINK */
+
+    if(options & VLYNQ_INIT_LOCAL_INTERRUPTS )
+    {
+        /* Configure local interrupt settings */
+        intSetting = &(pdev->local_irq);
+
+        /* Map local module status interrupts to interrupt vector*/
+        val = intSetting->map_vector << VLYNQ_CTL_INTVEC_SHIFT ;
+      
+        /* enable local module status interrupts */
+        val |= 0x01 << VLYNQ_CTL_INTEN_SHIFT;
+      
+        if ( intSetting->intLocal == VLYNQ_INT_LOCAL )
+        {
+            /*set the intLocal bit*/
+            val |= 0x01 << VLYNQ_CTL_INTLOCAL_SHIFT;
+        }
+      
+        /* Irrespective of whether interrupts are handled locally, program
+         * int2Cfg. Error checking for accidental loop(when intLocal=0 and int2Cfg=1
+         * i.e remote packets are set intPending register->which will result in 
+         * same packet being sent out) has been done already
+         */
+      
+        if (intSetting->intRemote == VLYNQ_INT_ROOT_ISR) 
+        {
+            /* Set the int2Cfg register, so that remote interrupt
+             * packets are written to intPending register */
+            val |= 0x01 << VLYNQ_CTL_INT2CFG_SHIFT;
+    
+            /* Set intPtr register to point to intPending register */
+            VLYNQ_INT_PTR_REG = VLYNQ_INT_PENDING_REG_PTR ;
+        }
+        else
+        {
+            /*set the interrupt pointer register*/
+            VLYNQ_INT_PTR_REG = intSetting->intr_ptr;
+            /* Dont bother to modify int2Cfg as it would be zero */
+        }
+
+        /** Clear bits related to INT settings in control register **/
+        VLYNQ_CTRL_REG = VLYNQ_CTRL_REG & (~VLYNQ_CTL_INTFIELDS_CLEAR_MASK);
+      
+        /** Or the bits to be set with Control register **/
+        VLYNQ_CTRL_REG = VLYNQ_CTRL_REG | val;
+
+        /* initialise local ICB */          
+        if(vlynqInterruptInit(pdev)==VLYNQ_MEMALLOC_FAIL)
+            return VLYNQ_MEMALLOC_FAIL;   
+
+        /* Install handler for local module status interrupts. By default when 
+         * local interrupt setting is initialised, the local module status are 
+         * enabled and handler hooked up */
+        if(vlynq_install_isr(pdev, intSetting->map_vector, vlynq_local_module_isr, 
+                             pdev, NULL, NULL) == VLYNQ_INVALID_ARG)
+            return VLYNQ_INVALID_ARG;
+    } /* end of init local interrupts */
+
+    if(options & VLYNQ_INIT_REMOTE_INTERRUPTS )
+    {
+        /* Configure remote interrupt settings from configuration */          
+        intSetting = &(pdev->remote_irq);
+
+        /* Map remote module status interrupts to remote interrupt vector*/
+        val = intSetting->map_vector << VLYNQ_CTL_INTVEC_SHIFT ;
+        /* enable remote module status interrupts */
+        val |= 0x01 << VLYNQ_CTL_INTEN_SHIFT;
+      
+        if ( intSetting->intLocal == VLYNQ_INT_LOCAL )
+        {
+            /*set the intLocal bit*/
+            val |= 0x01 << VLYNQ_CTL_INTLOCAL_SHIFT;
+        }
+
+        /* Irrespective of whether interrupts are handled locally, program
+         * int2Cfg. Error checking for accidental loop(when intLocal=0 and int2Cfg=1
+         * i.e remote packets are set intPending register->which will result in 
+         * same packet being sent out) has been done already
+        */ 
+
+        if (intSetting->intRemote == VLYNQ_INT_ROOT_ISR) 
+        {
+            /* Set the int2Cfg register, so that remote interrupt
+             * packets are written to intPending register */
+            val |= 0x01 << VLYNQ_CTL_INT2CFG_SHIFT;
+            /* Set intPtr register to point to intPending register */
+            VLYNQ_R_INT_PTR_REG = VLYNQ_R_INT_PENDING_REG_PTR ;
+        }
+        else
+        {
+            /*set the interrupt pointer register*/
+            VLYNQ_R_INT_PTR_REG = intSetting->intr_ptr;
+            /* Dont bother to modify int2Cfg as it would be zero */
+        }
+    
+        if( (intSetting->intLocal == VLYNQ_INT_REMOTE) && 
+            (options & VLYNQ_INIT_LOCAL_INTERRUPTS) &&
+            (pdev->local_irq.intRemote == VLYNQ_INT_ROOT_ISR) )
+        {
+            /* Install handler for remote module status interrupts. By default when 
+             * remote interrupts are forwarded to local root_isr then remote_module_isr is
+             * enabled and handler hooked up */
+            if(vlynq_install_isr(pdev,intSetting->map_vector,vlynq_remote_module_isr,
+                                 pdev, NULL, NULL) == VLYNQ_INVALID_ARG)
+                return VLYNQ_INVALID_ARG;
+        }
+
+         
+        /** Clear bits related to INT settings in control register **/
+        VLYNQ_R_CTRL_REG = VLYNQ_R_CTRL_REG & (~VLYNQ_CTL_INTFIELDS_CLEAR_MASK);
+      
+        /** Or the bits to be set with the remote Control register **/
+        VLYNQ_R_CTRL_REG = VLYNQ_R_CTRL_REG | val;
+         
+    } /* init remote interrupt settings*/
+
+    if(options & VLYNQ_INIT_CLEAR_ERRORS )
+    {
+        /* Clear errors during initialization */
+        tmp = VLYNQ_STATUS_REG  & (VLYNQ_STS_RERROR_MASK | VLYNQ_STS_LERROR_MASK);
+        VLYNQ_STATUS_REG = tmp;
+        tmp = VLYNQ_R_STATUS_REG & (VLYNQ_STS_RERROR_MASK | VLYNQ_STS_LERROR_MASK);
+        VLYNQ_R_STATUS_REG = tmp;
+    } 
+
+    /* clear int status */
+    val = VLYNQ_INT_STAT_REG;
+    VLYNQ_INT_STAT_REG = val;
+    
+    /* finish initialization */
+    pdev->state = VLYNQ_DRV_STATE_RUN;
+    VLYNQ_RESETCB( VLYNQ_RESET_INITOK);
+    return VLYNQ_SUCCESS;
+
+}
+
+
+/* ----------------------------------------------------------------------------
+ *  Function : vlynqInterruptInit()
+ *  Description: This local function is used to set up the ICB table for the 
+ *  VLYNQ_STATUS_REG vlynq module. The input parameter "pdev" points the vlynq
+ *  device instance whose ICB is allocated.
+ *  Return : returns VLYNQ_SUCCESS or vlynq error for failure
+ * -----------------------------------------------------------------------------
+ */
+static int vlynqInterruptInit(VLYNQ_DEV *pdev)
+{
+    int i, numslots;
+
+    /* Memory allocated statically.
+     * Initialise ICB,free list.Indicate primary slot empty.
+     * Intialise intVector <==> map_vector translation table*/
+    for(i=0; i < VLYNQ_NUM_INT_BITS; i++)
+    {
+        pdev->pIntrCB[i].isr = NULL;  
+        pdev->pIntrCB[i].next = NULL; /*nothing chained */
+        pdev->vector_map[i] = -1;   /* indicates unmapped  */
+    }
+
+    /* In the ICB slots, [VLYNQ_NUM_INT_BITS i.e 32 to ICB array size) are expansion slots
+     * required only when interrupt chaining/sharing is supported. In case
+     * of chained interrupts the list starts from primary slot and the
+     * additional slots are obtained from the common free area */
+
+    /* Initialise freelist */
+
+    numslots = VLYNQ_NUM_INT_BITS + VLYNQ_IVR_CHAIN_SLOTS;
+    
+    if (numslots > VLYNQ_NUM_INT_BITS)
+    {
+        pdev->freelist = &(pdev->pIntrCB[VLYNQ_NUM_INT_BITS]);
+        
+        for(i = VLYNQ_NUM_INT_BITS; i < (numslots-1) ; i++)
+        {
+            pdev->pIntrCB[i].next = &(pdev->pIntrCB[i+1]);
+            pdev->pIntrCB[i].isr = NULL;
+        }
+        pdev->pIntrCB[i].next=NULL; /* Indicate end of freelist*/
+        pdev->pIntrCB[i].isr=NULL;
+    }  
+    else
+    {   
+        pdev->freelist = NULL;
+    }
+
+    /** Reset mapping for IV 0-7 **/
+    VLYNQ_IVR_03TO00_REG = 0;
+    VLYNQ_IVR_07TO04_REG = 0;
+
+    return VLYNQ_SUCCESS;
+}
+
+/** remember that hooking up of root ISR handler with the interrupt controller 
+ *  is not done as a part of this driver. Typically, it must be done after
+ *  invoking vlynq_init*/
+
+
+ /* ----------------------------------------------------------------------------
+ *  ISR with the SOC interrupt controller. This ISR typically scans
+ *  the Int PENDING/SET register in the VLYNQ module and calls the
+ *  appropriate ISR associated with the correponding vector number.
+ * -----------------------------------------------------------------------------
+ */
+void vlynq_root_isr(void *arg)
+{
+    int    source;  /* Bit position of pending interrupt, start from 0 */
+    unsigned int interrupts, clrInterrupts;
+    VLYNQ_DEV * pdev;
+    VLYNQ_INTR_CNTRL_ICB *entry;
+
+    pdev=(VLYNQ_DEV*)(arg);          /*obtain the vlynq device pointer*/
+ 
+    interrupts =  VLYNQ_INT_STAT_REG; /* Get the list of pending interrupts */
+    VLYNQ_INT_STAT_REG = interrupts; /* clear the int CR register */
+    clrInterrupts = interrupts;      /* save them for further analysis */
+
+    debugPrint("vlynq_root_isr: dev %u. INTCR = 0x%08lx\n", pdev->dev_idx, clrInterrupts,0,0,0,0);
+
+    /* Scan interrupt bits */
+    source =0;
+    while( clrInterrupts != 0)
+    {
+        /* test if bit is set? */
+        if( 0x1ul & clrInterrupts)
+        {   
+            entry = &(pdev->pIntrCB[source]);   /* Get the ISR entry */
+            pdev->intCount++;                   /* update interrupt count */    
+            if(entry->isr != NULL)
+            {
+                do 
+                {
+                    pdev->isrCount++;   /* update isr invocation count */    
+                    /* Call the user ISR and update the count for ISR */
+		    entry->isrCount++;   
+                    entry->isr(entry->arg1, entry->arg2, entry->arg3);
+                    if (entry->next == NULL) break;
+                    entry = entry->next;
+
+                } while (entry->isr != NULL);
+            }
+            else
+            {   
+                debugPrint(" ISR not installed for vlynq vector:%d\n",source,0,0,0,0,0);
+            }
+        }
+        clrInterrupts >>= 1;    /* Next source bit */
+        ++source;
+    } /* endWhile clrInterrupts != 0 */
+}
+
+
+ /* ----------------------------------------------------------------------------
+ *  Function : vlynq_local__module_isr()
+ *  Description: This ISR is attached to the local VLYNQ interrupt vector
+ *  by the Vlynq Driver when local interrupts are being handled. i.e.
+ *  intLocal=1. This ISR handles local Vlynq module status interrupts only
+ *  AS a part of this ISR, user callback in VLYNQ_DEV structure
+ *  is invoked.
+ *  VLYNQ_DEV is passed as arg1. arg2 and arg3 are unused.
+ * -----------------------------------------------------------------------------
+ */
+static void vlynq_local_module_isr(void *arg1,void *arg2, void *arg3)
+{
+    VLYNQ_REPORT_CB func;
+    unsigned int dwStatRegVal;
+    VLYNQ_DEV * pdev;
+
+    pdev = (VLYNQ_DEV*) arg1;
+    /* Callback function is read from the device pointer that is passed as an argument */
+    func = pdev->report_cb;
+
+    /* read local status register */
+    dwStatRegVal = VLYNQ_STATUS_REG;
+
+    /* clear pending events */
+    VLYNQ_STATUS_REG = dwStatRegVal;
+   
+    /* invoke user callback */
+    if( func != NULL)
+        func( pdev, VLYNQ_LOCAL_DVC, dwStatRegVal);
+
+}
+
+ /* ----------------------------------------------------------------------------
+ *  Function : vlynq_remote_module_isr()
+ *  Description: This ISR is attached to the remote VLYNQ interrupt vector
+ *  by the Vlynq Driver when remote interrupts are being handled locally. i.e.
+ *  intLocal=1. This ISR handles local Vlynq module status interrupts only
+ *  AS a part of this ISR, user callback in VLYNQ_DEV structure
+ *  is invoked.
+ *  The parameters  irq,regs ar unused.
+ * -----------------------------------------------------------------------------
+ */
+static void vlynq_remote_module_isr(void *arg1,void *arg2, void *arg3)
+{
+    VLYNQ_REPORT_CB func;
+    unsigned int dwStatRegVal;
+    VLYNQ_DEV * pdev;
+
+   
+    pdev = (VLYNQ_DEV*) arg1;
+   
+    /* Callback function is read from the device pointer that is passed as an argument */
+   func = pdev->report_cb;
+
+    /* read local status register */
+    dwStatRegVal = VLYNQ_R_STATUS_REG;
+
+    /* clear pending events */
+    VLYNQ_R_STATUS_REG = dwStatRegVal;
+
+    /* invoke user callback */
+    if( func != NULL)
+        func( pdev, VLYNQ_REMOTE_DVC, dwStatRegVal);
+
+}
+
+/* ----------------------------------------------------------------------------
+ *  Function : vlynq_interrupt_get_count()
+ *  Description: This function returns the number of times a particular intr
+ *  has been invoked. 
+ *
+ *  It returns 0, if erroneous map_vector is specified or if the corres isr 
+ *  has not been registered with VLYNQ.
+ */
+unsigned int vlynq_interrupt_get_count(VLYNQ_DEV *pdev,
+					unsigned int map_vector)
+{
+    VLYNQ_INTR_CNTRL_ICB *entry;
+    unsigned int count = 0;
+
+    if (map_vector > (VLYNQ_NUM_INT_BITS-1)) 
+        return count;
+   
+    entry = &(pdev->pIntrCB[map_vector]);
+
+    if (entry)
+        count = entry->isrCount;
+
+    return (count);
+}
+
+
+/* ----------------------------------------------------------------------------
+ *  Function : vlynq_install_isr()
+ *  Description: This function installs ISR for Vlynq interrupt vector
+ *  bits(in IntPending register). This function should be used only when 
+ *  Vlynq interrupts are being handled locally(remote may be programmed to send
+ *  interrupt packets).Also, the int2cfg should be 1 and the least significant
+ *  8 bits of the Interrupt Pointer Register must point to Interrupt 
+ *  Pending/Set Register).
+ *  If host int2cfg=0 and the Interrupt Pointer register contains 
+ *  the address of the interrupt set register in the interrupt controller 
+ *  module of the local device , then the ISR for the remote interrupt must be 
+ *  directly registered with the Interrupt controller and must not use this API
+ *  Note: this function simply installs the ISR in ICB It doesnt modify
+ *  any register settings
+ */
+int 
+vlynq_install_isr(VLYNQ_DEV *pdev,
+                  unsigned int map_vector,
+                  VLYNQ_INTR_CNTRL_ISR isr,
+                  void *arg1, void *arg2, void *arg3)
+{
+    VLYNQ_INTR_CNTRL_ICB *entry;
+
+    if ( (map_vector > (VLYNQ_NUM_INT_BITS-1)) || (isr == NULL) ) 
+        return VLYNQ_INVALID_ARG;
+   
+    entry = &(pdev->pIntrCB[map_vector]);
+
+    if(entry->isr == NULL)
+    {
+        entry->isr = isr;
+        entry->arg1 = arg1;
+        entry->arg2 = arg2;
+        entry->arg3 = arg3;
+        entry->next = NULL;
+    }
+    else
+    {
+        /** No more empty slots,return error */
+        if(pdev->freelist == NULL)
+            return VLYNQ_MEMALLOC_FAIL;
+        
+        while(entry->next != NULL)
+        {
+            entry = entry->next;
+        }
+
+        /* Append new node to the chain */
+        entry->next = pdev->freelist;   
+        /* Remove the appended node from freelist */
+        pdev->freelist = pdev->freelist->next;  
+        entry= entry->next;
+         
+        /*** Set the ICB fields ***/
+        entry->isr = isr;
+        entry->arg1 = arg1;
+        entry->arg2 = arg2;
+        entry->arg3 = arg3;
+        entry->next = NULL;
+    }
+   
+    return VLYNQ_SUCCESS;
+}
+
+
+
+/* ----------------------------------------------------------------------------
+ *  Function : vlynq_uninstall_isr
+ *  Description: This function is used to uninstall a previously
+ *  registered ISR. In case of shared/chained interrupts, the 
+ *  void * arg parameter must uniquely identify the ISR to be
+ *  uninstalled.
+ *  Note: this function simply uninstalls the ISR in ICB
+ *  It doesnt modify any register settings
+ */
+int 
+vlynq_uninstall_isr(VLYNQ_DEV *pdev,
+                    unsigned int map_vector,
+                    void *arg1, void *arg2, void *arg3) 
+{
+    VLYNQ_INTR_CNTRL_ICB *entry,*temp;
+
+    if (map_vector > (VLYNQ_NUM_INT_BITS-1)) 
+        return VLYNQ_INVALID_ARG;
+   
+    entry = &(pdev->pIntrCB[map_vector]);
+
+    if(entry->isr == NULL ) 
+        return VLYNQ_ISR_NON_EXISTENT;
+
+    if ( (entry->arg1 == arg1) && (entry->arg2 == arg2) && (entry->arg3 == arg3) )
+    {
+        if(entry->next == NULL)
+        {
+            entry->isr=NULL;
+            return VLYNQ_SUCCESS;
+        }
+        else
+        {
+            temp =  entry->next;
+            /* Copy next node in the chain to prim.slot */
+            entry->isr = temp->isr;
+            entry->arg1 = temp->arg1;
+            entry->arg2 = temp->arg2;
+            entry->arg3 = temp->arg3;
+            entry->next = temp->next;
+            /* Free the just copied node */
+            temp->isr = NULL;
+            temp->arg1 = NULL;
+            temp->arg2 = NULL;
+            temp->arg3 = NULL;
+            temp->next = pdev->freelist;
+            pdev->freelist = temp;
+            return VLYNQ_SUCCESS;
+        }
+    }
+    else
+    {
+        temp = entry;
+        while ( (entry = temp->next) != NULL)
+        {
+            if ( (entry->arg1 == arg1) && (entry->arg2 == arg2) && (entry->arg3 == arg3) )
+            {
+                /* remove node from chain */
+                temp->next = entry->next; 
+                /* Add the removed node to freelist */
+                entry->isr = NULL;
+                entry->arg1 = NULL;
+                entry->arg2 = NULL;
+                entry->arg3 = NULL;
+                entry->next = pdev->freelist;
+                entry->isrCount = 0;
+                pdev->freelist  = entry;
+                return VLYNQ_SUCCESS;
+            }
+            temp = entry;
+        }
+    
+        return VLYNQ_ISR_NON_EXISTENT;
+    }
+}
+
+
+
+
+/* ----------------------------------------------------------------------------
+ *  function : vlynq_interrupt_vector_set()
+ *  description:configures interrupt vector mapping,interrupt type
+ *  polarity -all in one go.
+ */
+int 
+vlynq_interrupt_vector_set(VLYNQ_DEV *pdev,                 /* vlynq device */
+                           unsigned int int_vector,               /* int vector on vlynq device */
+                           unsigned int map_vector,               /* bit for this interrupt */
+                           VLYNQ_DEV_TYPE dev_type,         /* local or remote device */
+                           VLYNQ_INTR_POLARITY pol,         /* polarity of interrupt */
+                           VLYNQ_INTR_TYPE type)            /* pulsed/level interrupt */
+{
+    volatile unsigned int * vecreg;
+    unsigned int val=0;
+    unsigned int bytemask=0XFF;
+
+    /* use the lower 8 bits of val to set the value , shift it to 
+     * appropriate byte position in the ivr and write it to the 
+     * corresponding register */
+
+    /* validate the number of interrupts supported */
+    if (int_vector >= VLYNQ_IVR_MAXIVR) 
+        return VLYNQ_INVALID_ARG;
+        
+    if(map_vector > (VLYNQ_NUM_INT_BITS - 1) ) 
+        return VLYNQ_INVALID_ARG;
+
+    if (dev_type == VLYNQ_LOCAL_DVC)
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_IVR_OFFSET(int_vector));
+    }
+    else
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_R_IVR_OFFSET(int_vector));  
+    }
+
+    /* Update the intVector<==> bit position translation table */
+    pdev->vector_map[map_vector] = int_vector;
+
+    /* val has been initialised to zero. we only have to turn on appropriate bits*/
+    if(type == VLYNQ_INTR_PULSED)
+        val |= VLYNQ_IVR_INTTYPE_MASK;
+        
+    if(pol == VLYNQ_INTR_ACTIVE_LOW)
+        val |= VLYNQ_IVR_INTPOL_MASK;
+
+    val |= map_vector;
+
+    /** clear the correct byte position and then or val **/
+    *vecreg = (*vecreg) & ( ~(bytemask << ( (int_vector %4)*8) ) );
+
+    /** write to correct byte position in vecreg*/
+    *vecreg = (*vecreg) | (val << ( (int_vector % 4)*8) ) ;
+
+    /* Setting a interrupt vector, leaves the interrupt disabled 
+     * which  must be enabled subsequently */
+
+    return VLYNQ_SUCCESS;
+}
+
+
+/* ----------------------------------------------------------------------------
+ *  Function : vlynq_interrupt_vector_cntl()
+ *  Description:enables/disable interrupt
+ */
+int vlynq_interrupt_vector_cntl( VLYNQ_DEV *pdev,
+                                          unsigned int int_vector,
+                                          VLYNQ_DEV_TYPE dev_type,
+                                          unsigned int enable)
+{
+    volatile unsigned int *vecReg;
+    unsigned int val=0;
+    unsigned int intenMask=0x80;
+
+    /* validate the number of interrupts supported */
+    if (int_vector >= VLYNQ_IVR_MAXIVR) 
+        return VLYNQ_INVALID_ARG;
+
+    if (dev_type == VLYNQ_LOCAL_DVC)
+    {
+        vecReg = (volatile unsigned int *) (VLYNQ_IVR_OFFSET(int_vector));
+    }
+    else
+    {
+        vecReg = (volatile unsigned int *) (VLYNQ_R_IVR_OFFSET(int_vector));  
+    }
+
+    /** Clear the correct byte position and then or val **/
+    *vecReg = (*vecReg) & ( ~(intenMask << ( (int_vector %4)*8) ) );
+
+    if(enable)
+    {
+        val |= VLYNQ_IVR_INTEN_MASK; 
+        /** Write to correct byte position in vecReg*/
+        *vecReg = (*vecReg) | (val << ( (int_vector % 4)*8) ) ;
+    }
+
+    return VLYNQ_SUCCESS;
+
+}/* end of function vlynq_interrupt_vector_cntl */
+
+
+
+/* ----------------------------------------------------------------------------
+ *  Function : vlynq_interrupt_vector_map()
+ *  Description:Configures interrupt vector mapping alone
+ */
+int 
+vlynq_interrupt_vector_map( VLYNQ_DEV *pdev,
+                            VLYNQ_DEV_TYPE dev_type,
+                            unsigned int int_vector,
+                            unsigned int map_vector)
+{
+    volatile unsigned int * vecreg;
+    unsigned int val=0;
+    unsigned int bytemask=0x1f;   /* mask to turn off bits corresponding to int vector */ 
+
+    /* use the lower 8 bits of val to set the value , shift it to 
+     * appropriate byte position in the ivr and write it to the 
+     * corresponding register */
+
+    /* validate the number of interrupts supported */
+    if (int_vector >= VLYNQ_IVR_MAXIVR) 
+        return VLYNQ_INVALID_ARG;
+        
+    if(map_vector > (VLYNQ_NUM_INT_BITS - 1) ) 
+        return VLYNQ_INVALID_ARG;
+
+    if (dev_type == VLYNQ_LOCAL_DVC)
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_IVR_OFFSET(int_vector));
+    }
+    else
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_R_IVR_OFFSET(int_vector));  
+    }
+
+    /* Update the intVector<==> bit position translation table */
+    pdev->vector_map[map_vector] = int_vector;
+
+    /** val has been initialised to zero. we only have to turn on
+     * appropriate bits*/
+    val |= map_vector;
+
+    /** clear the correct byte position and then or val **/
+    *vecreg = (*vecreg) & ( ~(bytemask << ( (int_vector %4)*8) ) );
+
+    /** write to correct byte position in vecreg*/
+    *vecreg = (*vecreg) | (val << ( (int_vector % 4)*8) ) ;
+
+    return VLYNQ_SUCCESS;
+}
+
+
+/* ----------------------------------------------------------------------------
+ *  function : vlynq_interrupt_set_polarity()
+ *  description:configures interrupt polarity .
+ */
+int 
+vlynq_interrupt_set_polarity( VLYNQ_DEV *pdev ,
+                              VLYNQ_DEV_TYPE dev_type,
+                              unsigned int map_vector,
+                              VLYNQ_INTR_POLARITY pol)
+{
+    volatile unsigned int * vecreg;
+    int int_vector;
+    unsigned int val=0;
+    unsigned int bytemask=0x20; /** mask to turn off bits corresponding to int polarity */
+
+    /* get the int_vector from map_vector */
+    int_vector = pdev->vector_map[map_vector];
+
+    if(int_vector == -1) 
+        return VLYNQ_INTVEC_MAP_NOT_FOUND;
+
+    /* use the lower 8 bits of val to set the value , shift it to 
+     * appropriate byte position in the ivr and write it to the 
+     * corresponding register */
+
+    if (dev_type == VLYNQ_LOCAL_DVC)
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_IVR_OFFSET(int_vector));
+    }
+    else
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_R_IVR_OFFSET(int_vector));  
+    }
+
+    /* val has been initialised to zero. we only have to turn on
+     * appropriate bits, if need be*/
+
+    /** clear the correct byte position and then or val **/
+    *vecreg = (*vecreg) & ( ~(bytemask << ( (int_vector %4)*8) ) );
+
+    if( pol == VLYNQ_INTR_ACTIVE_LOW)
+    {
+        val |= VLYNQ_IVR_INTPOL_MASK;
+        /** write to correct byte position in vecreg*/
+        *vecreg = (*vecreg) | (val << ( (int_vector % 4)*8) ) ;
+    }
+
+    return VLYNQ_SUCCESS;
+}
+
+int vlynq_interrupt_get_polarity( VLYNQ_DEV *pdev ,
+                                           VLYNQ_DEV_TYPE dev_type,
+                                           unsigned int map_vector)
+{
+    volatile unsigned int * vecreg;
+    int int_vector;
+    unsigned int val=0;
+
+    /* get the int_vector from map_vector */
+    int_vector = pdev->vector_map[map_vector];
+
+    if (map_vector > (VLYNQ_NUM_INT_BITS-1))
+        return(-1);
+
+    if(int_vector == -1) 
+        return VLYNQ_INTVEC_MAP_NOT_FOUND;
+
+    /* use the lower 8 bits of val to set the value , shift it to 
+     * appropriate byte position in the ivr and write it to the 
+     * corresponding register */
+
+    if (dev_type == VLYNQ_LOCAL_DVC)
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_IVR_OFFSET(int_vector));
+    }
+    else
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_R_IVR_OFFSET(int_vector));  
+    }
+
+    /** read the information into val **/
+    val = (*vecreg) & ((VLYNQ_IVR_INTPOL_MASK << ( (int_vector %4)*8) ) );
+    
+    return (val ? (VLYNQ_INTR_ACTIVE_LOW) : (VLYNQ_INTR_ACTIVE_HIGH));
+}
+
+
+/* ----------------------------------------------------------------------------
+ *  function : vlynq_interrupt_set_type()
+ *  description:configures interrupt type .
+ */
+int vlynq_interrupt_set_type( VLYNQ_DEV *pdev,
+                                       VLYNQ_DEV_TYPE dev_type,
+                                       unsigned int map_vector,
+                                       VLYNQ_INTR_TYPE type)
+{
+    volatile unsigned int * vecreg;
+    unsigned int val=0;
+    int int_vector;
+
+    /** mask to turn off bits corresponding to interrupt type */
+    unsigned int bytemask=0x40;
+
+    /* get the int_vector from map_vector */
+    int_vector = pdev->vector_map[map_vector];
+    if(int_vector == -1) 
+        return VLYNQ_INTVEC_MAP_NOT_FOUND;
+
+    /* use the lower 8 bits of val to set the value , shift it to 
+     * appropriate byte position in the ivr and write it to the 
+     * corresponding register */
+    if (dev_type == VLYNQ_LOCAL_DVC)
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_IVR_OFFSET(int_vector));
+    }
+    else
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_R_IVR_OFFSET(int_vector));  
+    }
+
+    /** val has been initialised to zero. we only have to turn on
+     * appropriate bits if need be*/
+
+     /** clear the correct byte position and then or val **/
+    *vecreg = (*vecreg) & ( ~(bytemask << ( (int_vector %4)*8) ) );
+
+    if( type == VLYNQ_INTR_PULSED)
+    {
+        val |= VLYNQ_IVR_INTTYPE_MASK;
+        /** write to correct byte position in vecreg*/
+        *vecreg = (*vecreg) | (val << ( (int_vector % 4)*8) ) ;
+    }
+
+    return VLYNQ_SUCCESS;
+}
+
+/* ----------------------------------------------------------------------------
+ *  function : vlynq_interrupt_get_type()
+ *  description:returns interrupt type .
+ */
+int vlynq_interrupt_get_type( VLYNQ_DEV *pdev, VLYNQ_DEV_TYPE dev_type,
+                                       unsigned int map_vector)
+{
+    volatile unsigned int * vecreg;
+    unsigned int val=0;
+    int int_vector;
+
+    if (map_vector > (VLYNQ_NUM_INT_BITS-1))
+        return(-1);
+
+    /* get the int_vector from map_vector */
+    int_vector = pdev->vector_map[map_vector];
+    if(int_vector == -1) 
+        return VLYNQ_INTVEC_MAP_NOT_FOUND;
+
+    /* use the lower 8 bits of val to set the value , shift it to 
+     * appropriate byte position in the ivr and write it to the 
+     * corresponding register */
+    if (dev_type == VLYNQ_LOCAL_DVC)
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_IVR_OFFSET(int_vector));
+    }
+    else
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_R_IVR_OFFSET(int_vector));  
+    }
+
+    /** Read the correct bit position into val **/
+    val = (*vecreg) & ((VLYNQ_IVR_INTTYPE_MASK << ( (int_vector %4)*8) ) );
+
+    return (val ? (VLYNQ_INTR_PULSED) : (VLYNQ_INTR_LEVEL));
+}
+
+/* ----------------------------------------------------------------------------
+ *  function : vlynq_interrupt_enable()
+ *  description:Enable interrupt by writing to IVR register.
+ */
+int vlynq_interrupt_enable( VLYNQ_DEV *pdev,
+                                     VLYNQ_DEV_TYPE dev_type,
+                                     unsigned int map_vector)
+{
+    volatile unsigned int * vecreg;
+    unsigned int val=0;
+    int int_vector;
+
+    /** mask to turn off bits corresponding to interrupt enable */
+    unsigned int bytemask=0x80;
+
+    /* get the int_vector from map_vector */
+    int_vector = pdev->vector_map[map_vector];
+    if(int_vector == -1) 
+        return VLYNQ_INTVEC_MAP_NOT_FOUND;
+
+    /* use the lower 8 bits of val to set the value , shift it to 
+     * appropriate byte position in the ivr and write it to the 
+     * corresponding register */
+
+    if (dev_type == VLYNQ_LOCAL_DVC)
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_IVR_OFFSET(int_vector));
+    }
+    else
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_R_IVR_OFFSET(int_vector));  
+    }
+
+    /** val has been initialised to zero. we only have to turn on
+    *  bit corresponding to interrupt enable*/
+    val |= VLYNQ_IVR_INTEN_MASK;
+
+    /** clear the correct byte position and then or val **/
+    *vecreg = (*vecreg) & ( ~(bytemask << ( (int_vector %4)*8) ) );
+
+    /** write to correct byte position in vecreg*/
+    *vecreg = (*vecreg) | (val << ( (int_vector % 4)*8) ) ;
+
+    return VLYNQ_SUCCESS;
+}
+
+
+/* ----------------------------------------------------------------------------
+ *  function : vlynq_interrupt_disable()
+ *  description:Disable interrupt by writing to IVR register.
+ */
+int 
+vlynq_interrupt_disable( VLYNQ_DEV *pdev,
+                         VLYNQ_DEV_TYPE dev_type,
+                         unsigned int map_vector)
+{
+    volatile unsigned int * vecreg;
+    int int_vector;
+
+    /** mask to turn off bits corresponding to interrupt enable */
+    unsigned int bytemask=0x80;
+
+    /* get the int_vector from map_vector */
+    int_vector = pdev->vector_map[map_vector];
+    if(int_vector == -1) 
+        return VLYNQ_INTVEC_MAP_NOT_FOUND;
+
+    /* use the lower 8 bits of val to set the value , shift it to 
+     * appropriate byte position in the ivr and write it to the 
+     * corresponding register */
+    if (dev_type == VLYNQ_LOCAL_DVC)
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_IVR_OFFSET(int_vector));
+    }
+    else
+    {
+        vecreg = (volatile unsigned int *) (VLYNQ_R_IVR_OFFSET(int_vector));  
+    }
+
+    /* We disable the interrupt by simply turning off the bit
+     * corresponding to Interrupt enable. 
+     * Clear the interrupt enable bit in the correct byte position **/
+    *vecreg = (*vecreg) & ( ~(bytemask << ( (int_vector %4)*8) ) );
+
+    /* Dont have to set any bit positions */
+
+    return VLYNQ_SUCCESS;
+
+}
+
+
+
+
diff -urN linux.old/drivers/char/serial.c linux.dev/drivers/char/serial.c
--- linux.old/drivers/char/serial.c	2005-10-21 16:43:20.709226000 +0200
+++ linux.dev/drivers/char/serial.c	2005-11-10 01:10:46.015585250 +0100
@@ -419,7 +419,40 @@
 	return 0;
 }
 
-#if defined(CONFIG_MIPS_ATLAS) || defined(CONFIG_MIPS_SEAD)
+#if defined(CONFIG_AR7)
+
+static _INLINE_ unsigned int serial_in(struct async_struct *info, int offset)
+{
+	return (inb(info->port + (offset * 4)) & 0xff);  
+}
+
+
+static _INLINE_ unsigned int serial_inp(struct async_struct *info, int offset)
+{
+#ifdef CONFIG_SERIAL_NOPAUSE_IO
+	return (inb(info->port + (offset * 4)) & 0xff);
+#else
+	return (inb_p(info->port + (offset * 4)) & 0xff);
+#endif
+}
+
+static _INLINE_ void serial_out(struct async_struct *info, int offset, int value)
+{
+	outb(value, info->port + (offset * 4));      
+}
+
+
+static _INLINE_ void serial_outp(struct async_struct *info, int offset,
+		int value)
+{
+#ifdef CONFIG_SERIAL_NOPAUSE_IO
+	outb(value, info->port + (offset * 4));
+#else
+	outb_p(value, info->port + (offset * 4));
+#endif
+}
+
+#elif defined(CONFIG_MIPS_ATLAS) || defined(CONFIG_MIPS_SEAD)
 
 #include <asm/mips-boards/atlas.h>
 
@@ -478,8 +511,10 @@
  * needed for certain old 386 machines, I've left these #define's
  * in....
  */
+#ifndef CONFIG_AR7
 #define serial_inp(info, offset)		serial_in(info, offset)
 #define serial_outp(info, offset, value)	serial_out(info, offset, value)
+#endif
 
 
 /*
@@ -1728,7 +1763,15 @@
 			/* Special case since 134 is really 134.5 */
 			quot = (2*baud_base / 269);
 		else if (baud)
+#ifdef CONFIG_AR7
+			quot = (CONFIG_AR7_SYS*500000) / baud;
+
+		if ((quot%16)>7)
+			quot += 8;
+		quot /=16;
+#else
 			quot = baud_base / baud;
+#endif
 	}
 	/* If the quotient is zero refuse the change */
 	if (!quot && old_termios) {
@@ -5540,8 +5583,10 @@
 		state->irq = irq_cannonicalize(state->irq);
 		if (state->hub6)
 			state->io_type = SERIAL_IO_HUB6;
+#ifndef CONFIG_AR7
 		if (state->port && check_region(state->port,8))
 			continue;
+#endif
 #ifdef CONFIG_MCA			
 		if ((state->flags & ASYNC_BOOT_ONLYMCA) && !MCA_bus)
 			continue;
@@ -5997,7 +6042,15 @@
 	info->io_type = state->io_type;
 	info->iomem_base = state->iomem_base;
 	info->iomem_reg_shift = state->iomem_reg_shift;
+#ifdef CONFIG_AR7
+	quot = (CONFIG_AR7_SYS*500000) / baud;
+
+	if ((quot%16)>7)
+		quot += 8;
+	quot /=16;
+#else
 	quot = state->baud_base / baud;
+#endif
 	cval = cflag & (CSIZE | CSTOPB);
 #if defined(__powerpc__) || defined(__alpha__)
 	cval >>= 8;
diff -urN linux.old/drivers/char/ticfg/Makefile linux.dev/drivers/char/ticfg/Makefile
--- linux.old/drivers/char/ticfg/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/char/ticfg/Makefile	2005-11-10 01:10:46.051587500 +0100
@@ -0,0 +1,6 @@
+
+O_TARGET := ticfg.o
+
+obj-$(CONFIG_AR7_ADAM2) := adam2_env.o
+
+include $(TOPDIR)/Rules.make
diff -urN linux.old/drivers/char/ticfg/adam2_env.c linux.dev/drivers/char/ticfg/adam2_env.c
--- linux.old/drivers/char/ticfg/adam2_env.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/char/ticfg/adam2_env.c	2005-11-10 01:10:46.051587500 +0100
@@ -0,0 +1,85 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>
+#include <linux/init.h>
+
+#include <asm/ar7/adam2_env.h>
+
+#undef ADAM2_ENV_DEBUG
+
+#ifdef ADAM2_ENV_DEBUG
+#define DPRINTK(args...) do { printk(args); } while(0);
+#else
+#define DPRINTK(args...) do { } while(0);
+#endif
+
+#define ADAM2_ENV_DIR	"ticfg"
+#define ADAM2_ENV_NAME	"env"
+
+static struct proc_dir_entry *adam2_env_proc_dir;
+static struct proc_dir_entry *adam2_env_proc_ent;
+
+static int
+adam2_proc_read_env(char *page, char **start, off_t pos, int count,
+		    int *eof, void *data)
+{
+	int len;
+	t_env_var *env;
+
+	if (pos > 0)
+		return 0;
+
+	len=0;
+	for (env = prom_iterenv(0); env; env = prom_iterenv(env)) {
+		if (env->val) {
+			/* XXX check for page len */
+			len += sprintf(page + len, "%s\t%s\n",
+				       env->name, env->val);
+		}
+	}
+
+	*eof=1;
+	return len;
+}
+
+static int __init
+adam2_env_init(void)
+{
+
+	DPRINTK("%s\n", __FUNCTION__);
+
+	adam2_env_proc_dir = proc_mkdir(ADAM2_ENV_DIR, NULL);
+	if (!adam2_env_proc_dir) {
+		printk(KERN_ERR "%s: Unable to create /proc/%s entry\n",
+		       __FUNCTION__, ADAM2_ENV_DIR);
+		return -ENOMEM;
+	}
+	
+	adam2_env_proc_ent =
+		create_proc_entry(ADAM2_ENV_NAME, 0444, adam2_env_proc_dir);
+	if (!adam2_env_proc_ent) {
+		printk(KERN_ERR "%s: Unable to create /proc/%s/%s entry\n",
+		       __FUNCTION__, ADAM2_ENV_DIR, ADAM2_ENV_NAME);
+		remove_proc_entry(ADAM2_ENV_DIR, NULL);
+		return -ENOMEM;
+	}
+	adam2_env_proc_ent->read_proc = adam2_proc_read_env;
+
+	return 0;
+}
+
+static
+void __exit
+adam2_env_cleanup(void)
+{
+	remove_proc_entry(ADAM2_ENV_NAME, adam2_env_proc_dir);
+	remove_proc_entry(ADAM2_ENV_DIR, NULL);
+}
+
+module_init(adam2_env_init);
+module_exit(adam2_env_cleanup);
+
+MODULE_LICENSE("GPL");
diff -urN linux.old/include/asm-mips/addrspace.h linux.dev/include/asm-mips/addrspace.h
--- linux.old/include/asm-mips/addrspace.h	2002-11-29 00:53:15.000000000 +0100
+++ linux.dev/include/asm-mips/addrspace.h	2005-11-10 01:14:16.400733500 +0100
@@ -11,6 +11,8 @@
 #ifndef __ASM_MIPS_ADDRSPACE_H
 #define __ASM_MIPS_ADDRSPACE_H
 
+#include <linux/config.h>
+
 /*
  *  Configure language
  */
@@ -102,4 +104,11 @@
 #define XKPHYS_TO_PHYS(p)		((p) & TO_PHYS_MASK)
 #define PHYS_TO_XKPHYS(cm,a)		(0x8000000000000000 | ((cm)<<59) | (a))
 
+#ifdef CONFIG_AR7_MEMORY
+#define PHYS_OFFSET	((unsigned long)(CONFIG_AR7_MEMORY))
+#else
+#define PHYS_OFFSET	(0)
+#endif
+#define PHYS_PFN_OFFSET	(PHYS_OFFSET >> PAGE_SHIFT)
+
 #endif /* __ASM_MIPS_ADDRSPACE_H */
diff -urN linux.old/include/asm-mips/ar7/adam2_env.h linux.dev/include/asm-mips/ar7/adam2_env.h
--- linux.old/include/asm-mips/ar7/adam2_env.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/adam2_env.h	2005-11-10 01:10:46.067588500 +0100
@@ -0,0 +1,13 @@
+#ifndef _INCLUDE_ASM_AR7_ADAM2_ENV_H_
+#define	_INCLUDE_ASM_AR7_ADAM2_ENV_H_
+
+/* Environment variable */
+typedef struct {
+	char *name;
+	char *val;
+} t_env_var;
+
+char *prom_getenv(char *);
+t_env_var *prom_iterenv(t_env_var *);
+
+#endif /* _INCLUDE_ASM_AR7_ADAM2_ENV_H_ */
diff -urN linux.old/include/asm-mips/ar7/ar7.h linux.dev/include/asm-mips/ar7/ar7.h
--- linux.old/include/asm-mips/ar7/ar7.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/ar7.h	2005-11-10 01:10:46.067588500 +0100
@@ -0,0 +1,33 @@
+/*
+ * $Id$
+ * Copyright (C) $Date$  $Author$
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef _AR7_H
+#define _AR7_H
+
+#include <asm/addrspace.h>
+#include <linux/config.h>
+
+#define AVALANCHE_VECS_KSEG0 (KSEG0ADDR(CONFIG_AR7_MEMORY))
+
+#define AR7_UART0_REGS_BASE (KSEG1ADDR(0x08610E00))
+#define AR7_UART1_REGS_BASE (KSEG1ADDR(0x08610F00))
+#define AR7_BASE_BAUD ( 3686400 / 16 )
+
+#endif
diff -urN linux.old/include/asm-mips/ar7/avalanche_intc.h linux.dev/include/asm-mips/ar7/avalanche_intc.h
--- linux.old/include/asm-mips/ar7/avalanche_intc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/avalanche_intc.h	2005-11-10 01:10:46.067588500 +0100
@@ -0,0 +1,292 @@
+ /*
+ * Nitin Dhingra, iamnd@ti.com
+ * Copyright (C) 2000 Texas Instruments Inc.
+ *
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Defines of the Sead board specific address-MAP, registers, etc.
+ *
+ */
+#ifndef _AVALANCHE_INTC_H
+#define _AVALANCHE_INTC_H
+
+#include <linux/config.h>
+
+/* ----- */
+
+#define KSEG1_BASE                  0xA0000000
+#define KSEG_INV_MASK               0x1FFFFFFF /* Inverted mask for kseg address */
+#define PHYS_ADDR(addr)             ((addr) & KSEG_INV_MASK)
+#define PHYS_TO_K1(addr)            (PHYS_ADDR(addr)|KSEG1_BASE)
+#define AVALANCHE_INTC_BASE PHYS_TO_K1(0x08612400)
+
+/* ----- */
+
+#define MIPS_EXCEPTION_OFFSET 8
+
+/******************************************************************************
+ Avalanche Interrupt number
+******************************************************************************/
+#define AVINTNUM(x) ((x) - MIPS_EXCEPTION_OFFSET)
+
+/*******************************************************************************
+*Linux Interrupt number
+*******************************************************************************/
+#define LNXINTNUM(x)((x) + MIPS_EXCEPTION_OFFSET)
+
+
+
+#define AVALANCHE_INT_END_PRIMARY      (40 + MIPS_EXCEPTION_OFFSET)
+#define AVALANCHE_INT_END_SECONDARY    (32 + MIPS_EXCEPTION_OFFSET)
+
+#define AVALANCHE_INT_END_PRIMARY_REG1 (31 + MIPS_EXCEPTION_OFFSET)
+#define AVALANCHE_INT_END_PRIMARY_REG2 (39 + MIPS_EXCEPTION_OFFSET)
+
+#define AVALANCHE_INTC_END (AVINTNUM(AVALANCHE_INT_END_PRIMARY) + \
+			    AVINTNUM(AVALANCHE_INT_END_SECONDARY) + \
+			    MIPS_EXCEPTION_OFFSET)
+
+#if defined(CONFIG_AR7_VLYNQ)
+#define AVALANCHE_INT_END_LOW_VLYNQ  (AVALANCHE_INTC_END + 32)
+#define AVALANCHE_INT_END_VLYNQ      (AVALANCHE_INTC_END + 32 * CONFIG_AR7_VLYNQ_PORTS)
+#define AVALANCHE_INT_END             AVALANCHE_INT_END_VLYNQ
+#else
+#define AVALANCHE_INT_END             AVALANCHE_INTC_END
+#endif
+
+
+/*
+ * Avalanche interrupt controller register base (primary)
+ */
+#define AVALANCHE_ICTRL_REGS_BASE  AVALANCHE_INTC_BASE
+
+/******************************************************************************
+ * Avalanche exception controller register base (secondary)
+ ******************************************************************************/
+#define AVALANCHE_ECTRL_REGS_BASE  (AVALANCHE_ICTRL_REGS_BASE + 0x80)
+
+
+/******************************************************************************
+ *  Avalanche Interrupt pacing register base (secondary)
+ ******************************************************************************/
+#define AVALANCHE_IPACE_REGS_BASE  (AVALANCHE_ICTRL_REGS_BASE + 0xA0)
+
+
+
+/******************************************************************************
+ * Avalanche Interrupt Channel Control register base
+ *****************************************************************************/
+#define AVALANCHE_CHCTRL_REGS_BASE (AVALANCHE_ICTRL_REGS_BASE + 0x200)
+
+
+struct avalanche_ictrl_regs /* Avalanche Interrupt control registers */
+{
+  volatile unsigned long intsr1;    /* Interrupt Status/Set Register 1   0x00 */
+  volatile unsigned long intsr2;    /* Interrupt Status/Set Register 2   0x04 */
+  volatile unsigned long unused1;                                      /*0x08 */
+  volatile unsigned long unused2;                                      /*0x0C */
+  volatile unsigned long intcr1;    /* Interrupt Clear Register 1        0x10 */
+  volatile unsigned long intcr2;    /* Interrupt Clear Register 2        0x14 */
+  volatile unsigned long unused3;                                      /*0x18 */
+  volatile unsigned long unused4;                                      /*0x1C */
+  volatile unsigned long intesr1;   /* Interrupt Enable (Set) Register 1 0x20 */
+  volatile unsigned long intesr2;   /* Interrupt Enable (Set) Register 2 0x24 */
+  volatile unsigned long unused5;                                      /*0x28 */
+  volatile unsigned long unused6;                                      /*0x2C */
+  volatile unsigned long intecr1;   /* Interrupt Enable Clear Register 1 0x30 */
+  volatile unsigned long intecr2;   /* Interrupt Enable Clear Register 2 0x34 */
+  volatile unsigned long unused7;                                     /* 0x38 */
+  volatile unsigned long unused8;                                     /* 0x3c */
+  volatile unsigned long pintir;    /* Priority Interrupt Index Register 0x40 */
+  volatile unsigned long intmsr;    /* Priority Interrupt Mask Index Reg 0x44 */
+  volatile unsigned long unused9;                                     /* 0x48 */
+  volatile unsigned long unused10;                                    /* 0x4C */
+  volatile unsigned long intpolr1;  /* Interrupt Polarity Mask register 10x50 */
+  volatile unsigned long intpolr2;  /* Interrupt Polarity Mask register 20x54 */
+  volatile unsigned long unused11;                                    /* 0x58 */
+  volatile unsigned long unused12;                                   /*0x5C */
+  volatile unsigned long inttypr1;  /* Interrupt Type     Mask register 10x60 */
+  volatile unsigned long inttypr2;  /* Interrupt Type     Mask register 20x64 */
+};
+
+struct avalanche_exctrl_regs   /* Avalanche Exception control registers */
+{
+  volatile unsigned long exsr;      /* Exceptions Status/Set register    0x80 */
+  volatile unsigned long reserved;                                     /*0x84 */
+  volatile unsigned long excr;      /* Exceptions Clear Register         0x88 */
+  volatile unsigned long reserved1;                                    /*0x8c */
+  volatile unsigned long exiesr;    /* Exceptions Interrupt Enable (set) 0x90 */
+  volatile unsigned long reserved2;                                    /*0x94 */
+  volatile unsigned long exiecr;    /* Exceptions Interrupt Enable(clear)0x98 */
+};
+struct avalanche_ipace_regs
+{
+
+  volatile unsigned long ipacep;    /* Interrupt pacing register         0xa0 */
+  volatile unsigned long ipacemap;  /*Interrupt Pacing Map Register      0xa4 */
+  volatile unsigned long ipacemax;  /*Interrupt Pacing Max Register      0xa8 */
+};
+struct avalanche_channel_int_number
+{
+  volatile unsigned long cintnr0;   /* Channel Interrupt Number Register0x200 */
+  volatile unsigned long cintnr1;   /* Channel Interrupt Number Register0x204 */
+  volatile unsigned long cintnr2;   /* Channel Interrupt Number Register0x208 */
+  volatile unsigned long cintnr3;   /* Channel Interrupt Number Register0x20C */
+  volatile unsigned long cintnr4;   /* Channel Interrupt Number Register0x210 */
+  volatile unsigned long cintnr5;   /* Channel Interrupt Number Register0x214 */
+  volatile unsigned long cintnr6;   /* Channel Interrupt Number Register0x218 */
+  volatile unsigned long cintnr7;   /* Channel Interrupt Number Register0x21C */
+  volatile unsigned long cintnr8;   /* Channel Interrupt Number Register0x220 */
+  volatile unsigned long cintnr9;   /* Channel Interrupt Number Register0x224 */
+  volatile unsigned long cintnr10;  /* Channel Interrupt Number Register0x228 */
+  volatile unsigned long cintnr11;  /* Channel Interrupt Number Register0x22C */
+  volatile unsigned long cintnr12;  /* Channel Interrupt Number Register0x230 */
+  volatile unsigned long cintnr13;  /* Channel Interrupt Number Register0x234 */
+  volatile unsigned long cintnr14;  /* Channel Interrupt Number Register0x238 */
+  volatile unsigned long cintnr15;  /* Channel Interrupt Number Register0x23C */
+  volatile unsigned long cintnr16;  /* Channel Interrupt Number Register0x240 */
+  volatile unsigned long cintnr17;  /* Channel Interrupt Number Register0x244 */
+  volatile unsigned long cintnr18;  /* Channel Interrupt Number Register0x248 */
+  volatile unsigned long cintnr19;  /* Channel Interrupt Number Register0x24C */
+  volatile unsigned long cintnr20;  /* Channel Interrupt Number Register0x250 */
+  volatile unsigned long cintnr21;  /* Channel Interrupt Number Register0x254 */
+  volatile unsigned long cintnr22;  /* Channel Interrupt Number Register0x358 */
+  volatile unsigned long cintnr23;  /* Channel Interrupt Number Register0x35C */
+  volatile unsigned long cintnr24;  /* Channel Interrupt Number Register0x260 */
+  volatile unsigned long cintnr25;  /* Channel Interrupt Number Register0x264 */
+  volatile unsigned long cintnr26;  /* Channel Interrupt Number Register0x268 */
+  volatile unsigned long cintnr27;  /* Channel Interrupt Number Register0x26C */
+  volatile unsigned long cintnr28;  /* Channel Interrupt Number Register0x270 */
+  volatile unsigned long cintnr29;  /* Channel Interrupt Number Register0x274 */
+  volatile unsigned long cintnr30;  /* Channel Interrupt Number Register0x278 */
+  volatile unsigned long cintnr31;  /* Channel Interrupt Number Register0x27C */
+  volatile unsigned long cintnr32;  /* Channel Interrupt Number Register0x280 */
+  volatile unsigned long cintnr33;  /* Channel Interrupt Number Register0x284 */
+  volatile unsigned long cintnr34;  /* Channel Interrupt Number Register0x288 */
+  volatile unsigned long cintnr35;  /* Channel Interrupt Number Register0x28C */
+  volatile unsigned long cintnr36;  /* Channel Interrupt Number Register0x290 */
+  volatile unsigned long cintnr37;  /* Channel Interrupt Number Register0x294 */
+  volatile unsigned long cintnr38;  /* Channel Interrupt Number Register0x298 */
+  volatile unsigned long cintnr39;  /* Channel Interrupt Number Register0x29C */
+};
+
+struct avalanche_interrupt_line_to_channel
+{
+  unsigned long int_line0;    /* Start of primary interrupts */
+  unsigned long int_line1;
+  unsigned long int_line2;
+  unsigned long int_line3;
+  unsigned long int_line4;
+  unsigned long int_line5;
+  unsigned long int_line6;
+  unsigned long int_line7;
+  unsigned long int_line8;
+  unsigned long int_line9;
+  unsigned long int_line10;
+  unsigned long int_line11;
+  unsigned long int_line12;
+  unsigned long int_line13;
+  unsigned long int_line14;
+  unsigned long int_line15;
+  unsigned long int_line16;
+  unsigned long int_line17;
+  unsigned long int_line18;
+  unsigned long int_line19;
+  unsigned long int_line20;
+  unsigned long int_line21;
+  unsigned long int_line22;
+  unsigned long int_line23;
+  unsigned long int_line24;
+  unsigned long int_line25;
+  unsigned long int_line26;
+  unsigned long int_line27;
+  unsigned long int_line28;
+  unsigned long int_line29;
+  unsigned long int_line30;
+  unsigned long int_line31;
+  unsigned long int_line32;
+  unsigned long int_line33;
+  unsigned long int_line34;
+  unsigned long int_line35;
+  unsigned long int_line36;
+  unsigned long int_line37;
+  unsigned long int_line38;
+  unsigned long int_line39;
+};
+
+
+/* Interrupt Line #'s  (Sangam peripherals) */
+
+/*------------------------------*/
+/* Sangam primary interrupts */
+/*------------------------------*/
+
+#define UNIFIED_SECONDARY_INTERRUPT  0
+#define AVALANCHE_EXT_INT_0          1
+#define AVALANCHE_EXT_INT_1          2
+/*  Line #3  Reserved               */
+/*  Line #4  Reserved               */
+#define AVALANCHE_TIMER_0_INT        5
+#define AVALANCHE_TIMER_1_INT        6
+#define AVALANCHE_UART0_INT          7
+#define AVALANCHE_UART1_INT          8
+#define AVALANCHE_PDMA_INT0          9
+#define AVALANCHE_PDMA_INT1          10
+/*  Line #11  Reserved               */
+/*  Line #12  Reserved               */
+/*  Line #13  Reserved               */
+/*  Line #14  Reserved               */
+#define AVALANCHE_ATM_SAR_INT        15
+/*  Line #16  Reserved               */
+/*  Line #17  Reserved               */
+/*  Line #18  Reserved               */
+#define AVALANCHE_MAC0_INT           19
+/*  Line #20  Reserved               */
+#define AVALANCHE_VLYNQ0_INT         21
+#define AVALANCHE_CODEC_WAKE_INT     22
+/*  Line #23  Reserved               */
+#define AVALANCHE_USB_INT            24
+#define AVALANCHE_VLYNQ1_INT         25
+/*  Line #26  Reserved               */
+/*  Line #27  Reserved               */
+#define AVALANCHE_MAC1_INT           28
+#define AVALANCHE_I2CM_INT           29
+#define AVALANCHE_PDMA_INT2          30
+#define AVALANCHE_PDMA_INT3          31
+/*  Line #32  Reserved               */
+/*  Line #33  Reserved               */
+/*  Line #34  Reserved               */
+/*  Line #35  Reserved               */
+/*  Line #36  Reserved               */
+#define AVALANCHE_VDMA_VT_RX_INT     37
+#define AVALANCHE_VDMA_VT_TX_INT     38
+#define AVALANCHE_ADSLSS_INT         39
+
+/*-----------------------------------*/
+/* Sangam Secondary Interrupts    */
+/*-----------------------------------*/
+#define PRIMARY_INTS                 40
+
+#define EMIF_INT                    (7 + PRIMARY_INTS)
+
+
+extern void avalanche_int_set(int channel, int line);
+
+
+#endif /* _AVALANCHE_INTC_H */
diff -urN linux.old/include/asm-mips/ar7/avalanche_misc.h linux.dev/include/asm-mips/ar7/avalanche_misc.h
--- linux.old/include/asm-mips/ar7/avalanche_misc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/avalanche_misc.h	2005-11-10 01:10:46.067588500 +0100
@@ -0,0 +1,174 @@
+#ifndef _AVALANCHE_MISC_H_
+#define _AVALANCHE_MISC_H_
+
+typedef enum AVALANCHE_ERR_t
+{
+    AVALANCHE_ERR_OK        = 0,    /* OK or SUCCESS */
+    AVALANCHE_ERR_ERROR     = -1,   /* Unspecified/Generic ERROR */
+
+    /* Pointers and args */
+    AVALANCHE_ERR_INVARG        = -2,   /* Invaild argument to the call */
+    AVALANCHE_ERR_NULLPTR       = -3,   /* NULL pointer */
+    AVALANCHE_ERR_BADPTR        = -4,   /* Bad (out of mem) pointer */
+
+    /* Memory issues */
+    AVALANCHE_ERR_ALLOC_FAIL    = -10,  /* allocation failed */
+    AVALANCHE_ERR_FREE_FAIL     = -11,  /* free failed */
+    AVALANCHE_ERR_MEM_CORRUPT   = -12,  /* corrupted memory */
+    AVALANCHE_ERR_BUF_LINK      = -13,  /* buffer linking failed */
+
+    /* Device issues */
+    AVALANCHE_ERR_DEVICE_TIMEOUT    = -20,  /* device timeout on read/write */
+    AVALANCHE_ERR_DEVICE_MALFUNC    = -21,  /* device malfunction */
+
+    AVALANCHE_ERR_INVID     = -30   /* Invalid ID */
+
+} AVALANCHE_ERR;
+
+/*****************************************************************************
+ * Reset Control Module
+ *****************************************************************************/
+
+typedef enum AVALANCHE_RESET_MODULE_tag
+{
+    RESET_MODULE_UART0      = 0,
+    RESET_MODULE_UART1      = 1,
+    RESET_MODULE_I2C        = 2,
+    RESET_MODULE_TIMER0     = 3,
+    RESET_MODULE_TIMER1     = 4,
+    RESET_MODULE_GPIO       = 6,
+    RESET_MODULE_ADSLSS     = 7,
+    RESET_MODULE_USBS       = 8,
+    RESET_MODULE_SAR        = 9,
+    RESET_MODULE_VDMA_VT    = 11,
+    RESET_MODULE_FSER       = 12,
+    RESET_MODULE_VLYNQ1     = 16,
+    RESET_MODULE_EMAC0      = 17,
+    RESET_MODULE_DMA        = 18,
+    RESET_MODULE_BIST       = 19,
+    RESET_MODULE_VLYNQ0     = 20,
+    RESET_MODULE_EMAC1      = 21,
+    RESET_MODULE_MDIO       = 22,
+    RESET_MODULE_ADSLSS_DSP = 23,
+    RESET_MODULE_EPHY       = 26
+} AVALANCHE_RESET_MODULE_T;
+
+typedef enum AVALANCHE_RESET_CTRL_tag
+{
+    IN_RESET        = 0,
+    OUT_OF_RESET
+} AVALANCHE_RESET_CTRL_T;
+
+typedef enum AVALANCHE_SYS_RST_MODE_tag
+{
+    RESET_SOC_WITH_MEMCTRL      = 1,    /* SW0 bit in SWRCR register */
+    RESET_SOC_WITHOUT_MEMCTRL   = 2     /* SW1 bit in SWRCR register */
+} AVALANCHE_SYS_RST_MODE_T;
+
+typedef enum AVALANCHE_SYS_RESET_STATUS_tag
+{
+    HARDWARE_RESET = 0,
+    SOFTWARE_RESET0,            /* Caused by writing 1 to SW0 bit in SWRCR register */
+    WATCHDOG_RESET,
+    SOFTWARE_RESET1             /* Caused by writing 1 to SW1 bit in SWRCR register */
+} AVALANCHE_SYS_RESET_STATUS_T;
+
+AVALANCHE_RESET_CTRL_T avalanche_get_reset_status(AVALANCHE_RESET_MODULE_T reset_module);
+void avalanche_sys_reset(AVALANCHE_SYS_RST_MODE_T mode);
+AVALANCHE_SYS_RESET_STATUS_T avalanche_get_sys_last_reset_status(void);
+
+typedef int (*REMOTE_VLYNQ_DEV_RESET_CTRL_FN)(unsigned int reset_module, AVALANCHE_RESET_CTRL_T reset_ctrl);
+
+/*****************************************************************************
+ * Power Control Module
+ *****************************************************************************/
+
+typedef enum AVALANCHE_POWER_CTRL_tag
+{
+    POWER_CTRL_POWER_UP = 0,
+    POWER_CTRL_POWER_DOWN
+} AVALANCHE_POWER_CTRL_T;
+
+typedef enum AVALANCHE_SYS_POWER_MODE_tag
+{
+    GLOBAL_POWER_MODE_RUN       = 0,    /* All system is up */
+    GLOBAL_POWER_MODE_IDLE,             /* MIPS is power down, all peripherals working */
+    GLOBAL_POWER_MODE_STANDBY,          /* Chip in power down, but clock to ADSKL subsystem is running */
+    GLOBAL_POWER_MODE_POWER_DOWN        /* Total chip is powered down */
+} AVALANCHE_SYS_POWER_MODE_T;
+
+void avalanche_power_ctrl(unsigned int power_module,  AVALANCHE_POWER_CTRL_T power_ctrl);
+AVALANCHE_POWER_CTRL_T avalanche_get_power_status(unsigned int power_module);
+void avalanche_set_global_power_mode(AVALANCHE_SYS_POWER_MODE_T power_mode);
+AVALANCHE_SYS_POWER_MODE_T avalanche_get_global_power_mode(void);
+
+/*****************************************************************************
+ * Wakeup Control
+ *****************************************************************************/
+
+typedef enum AVALANCHE_WAKEUP_INTERRUPT_tag
+{
+    WAKEUP_INT0 = 1,
+    WAKEUP_INT1 = 2,
+    WAKEUP_INT2 = 4,
+    WAKEUP_INT3 = 8
+} AVALANCHE_WAKEUP_INTERRUPT_T;
+
+typedef enum TNETV1050_WAKEUP_CTRL_tag
+{
+    WAKEUP_DISABLED = 0,
+    WAKEUP_ENABLED
+} AVALANCHE_WAKEUP_CTRL_T;
+
+typedef enum TNETV1050_WAKEUP_POLARITY_tag
+{
+    WAKEUP_ACTIVE_HIGH = 0,
+    WAKEUP_ACTIVE_LOW
+} AVALANCHE_WAKEUP_POLARITY_T;
+
+void avalanche_wakeup_ctrl(AVALANCHE_WAKEUP_INTERRUPT_T wakeup_int,
+                           AVALANCHE_WAKEUP_CTRL_T wakeup_ctrl,
+                           AVALANCHE_WAKEUP_POLARITY_T wakeup_polarity);
+
+/*****************************************************************************
+ * GPIO Control
+ *****************************************************************************/
+
+typedef enum AVALANCHE_GPIO_PIN_MODE_tag
+{
+    FUNCTIONAL_PIN = 0,
+    GPIO_PIN = 1
+} AVALANCHE_GPIO_PIN_MODE_T;
+
+typedef enum AVALANCHE_GPIO_PIN_DIRECTION_tag
+{
+    GPIO_OUTPUT_PIN = 0,
+    GPIO_INPUT_PIN = 1
+} AVALANCHE_GPIO_PIN_DIRECTION_T;
+
+typedef enum { GPIO_FALSE, GPIO_TRUE } AVALANCHE_GPIO_BOOL_T;
+
+void avalanche_gpio_init(void);
+int avalanche_gpio_ctrl(unsigned int gpio_pin,
+                         AVALANCHE_GPIO_PIN_MODE_T pin_mode,
+                         AVALANCHE_GPIO_PIN_DIRECTION_T pin_direction);
+int avalanche_gpio_ctrl_with_link_count(unsigned int gpio_pin,
+                         AVALANCHE_GPIO_PIN_MODE_T pin_mode,
+                         AVALANCHE_GPIO_PIN_DIRECTION_T pin_direction);
+int avalanche_gpio_out_bit(unsigned int gpio_pin, int value);
+int avalanche_gpio_in_bit(unsigned int gpio_pin);
+int avalanche_gpio_out_value(unsigned int out_val, unsigned int set_mask, unsigned int reg_index);
+int avalanche_gpio_out_value_with_link_count(unsigned int out_val, unsigned int set_mask, unsigned int reg_index);
+int avalanche_gpio_in_value(unsigned int *in_val, unsigned int reg_index);
+
+unsigned int avalanche_get_chip_version_info(void);
+
+unsigned int avalanche_get_vbus_freq(void);
+void         avalanche_set_vbus_freq(unsigned int);
+
+
+typedef int (*SET_MDIX_ON_CHIP_FN_T)(unsigned int base_addr, unsigned int operation);
+int avalanche_set_mdix_on_chip(unsigned int base_addr, unsigned int operation);
+unsigned int avalanche_is_mdix_on_chip(void);
+
+#endif
diff -urN linux.old/include/asm-mips/ar7/avalanche_regs.h linux.dev/include/asm-mips/ar7/avalanche_regs.h
--- linux.old/include/asm-mips/ar7/avalanche_regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/avalanche_regs.h	2005-11-10 01:10:46.071588750 +0100
@@ -0,0 +1,567 @@
+/* 
+ *  $Id$
+ *  Avalanche Register Descriptions
+ *
+ *  Jeff Harrell, jharrell@ti.com
+ *  2000 (c) Texas Instruments Inc.
+ */
+
+#ifndef __AVALANCHE_REGS_H
+#define __AVALANCHE_REGS_H
+
+#include <asm/addrspace.h>
+#include <linux/config.h>
+
+/*----------------------------------------*/
+/* Base offsets within the Avalanche ASIC */
+/*----------------------------------------*/
+
+#define BBIF_SPACE0     (KSEG1ADDR(0x01000000))
+#define BBIF_SPACE1     (KSEG1ADDR(0x01800000))
+#define BBIF_CONTROL    (KSEG1ADDR(0x02000000))
+#define ATM_SAR_BASE    (KSEG1ADDR(0x03000000))
+#define USB_MCU_BASE    (KSEG1ADDR(0x03400000))
+#define DES_BASE        (KSEG1ADDR(0x08600000))
+#define ETH_MACA_BASE   (KSEG1ADDR(0x08610000))
+#define ETH_MACB_BASE   (KSEG1ADDR(0x08612800))
+#define MEM_CTRLR_BASE  (KSEG1ADDR(0x08610800))
+#define GPIO_BASE       (KSEG1ADDR(0x08610900))
+#define CLK_CTRL_BASE   (KSEG1ADDR(0x08610A00))
+#define WATCH_DOG_BASE  (KSEG1ADDR(0x08610B00))
+#define TMR1_BASE       (KSEG1ADDR(0x08610C00))
+#define TRM2_BASE       (KSEG1ADDR(0x08610D00))
+#define UARTA_BASE      (KSEG1ADDR(0x08610E00))
+#define UARTB_BASE      (KSEG1ADDR(0x08610F00))
+#define I2C_BASE        (KSEG1ADDR(0x08611000))
+#define DEV_ID_BASE     (KSEG1ADDR(0x08611100))
+#define USB_BASE        (KSEG1ADDR(0x08611200))
+#define PCI_CONFIG_BASE (KSEG1ADDR(0x08611300))
+#define DMA_BASE        (KSEG1ADDR(0x08611400))
+#define RESET_CTRL_BASE (KSEG1ADDR(0x08611600))
+#define DSL_IF_BASE     (KSEG1ADDR(0x08611B00))
+#define INT_CTL_BASE    (KSEG1ADDR(0x08612400)) 
+#define PHY_BASE        (KSEG1ADDR(0x1E000000))
+
+/*---------------------------------*/
+/* Device ID, chip version number  */
+/*---------------------------------*/
+
+#define AVALANCHE_CHVN  (*(volatile unsigned int *)(DEV_ID_BASE+0x14))
+#define AVALANCHE_DEVID1 (*(volatile unsigned int *)(DEV_ID_BASE+0x18))
+#define AVALANCHE_DEVID2 (*(volatile unsigned int *)(DEV_ID_BASE+0x1C))
+
+/*----------------------------------*/
+/* Reset Control VW changed to ptrs */
+/*----------------------------------*/
+
+#define AVALANCHE_PRCR  (*(volatile unsigned int *)(RESET_CTRL_BASE + 0x0))  /* Peripheral reset control */
+#define AVALANCHE_SWRCR (*(volatile unsigned int *)(RESET_CTRL_BASE + 0x4))  /* Software reset control   */
+#define AVALANCHE_RSR   (*(volatile unsigned int *)(RESET_CTRL_BASE + 0x8))  /* Reset status register    */
+
+/* reset control bits */
+
+#define AV_RST_UART0    (1<<0)    /* Brings UART0 out of reset              */
+#define AV_RST_UART1    (1<<1)    /* Brings UART1 out of reset              */
+#define AV_RST_IICM     (1<<2)    /* Brings the I2CM out of reset           */
+#define AV_RST_TIMER0   (1<<3)    /* Brings Timer 0 out of reset            */
+#define AV_RST_TIMER1   (1<<4)    /* Brings Timer 1 out of reset            */
+#define AV_RST_DES      (1<<5)    /* Brings the DES module out of reset     */
+#define AV_RST_GPIO     (1<<6)    /* Brings the GPIO module out of reset (see note below) */
+/*
+  JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE
+       If you reset the GPIO interface all of the directions (i/o) of the UART B
+       interface pins are inputs and must be reconfigured so as not to lose the 
+       serial console interface
+  JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE
+*/
+#define AV_RST_BBIF     (1<<7)    /* Brings the Broadband interface out of reset */
+#define AV_RST_USB      (1<<8)    /* Brings the USB module out of reset     */
+#define AV_RST_SAR      (1<<9)    /* Brings the SAR out of reset            */
+#define AV_RST_HDLC     (1<<10)   /* Brings the HDLC module out of reset    */
+#define AV_RST_PCI      (1<<16)   /* Brings the PCI module out of reset     */
+#define AV_RST_ETH_MAC0 (1<<17)   /* Brings the Ethernet MAC0 out of reset  */
+#define AV_RST_PICO_DMA (1<<18)   /* Brings the PICO DMA module out of reset */
+#define AV_RST_BIST     (1<<19)   /* Brings the BIST module out of reset    */
+#define AV_RST_DSP      (1<<20)   /* Brings the DSP sub system out of reset */
+#define AV_RST_ETH_MAC1 (1<<21)   /* Brings the Ethernet MAC1 out of reset  */
+
+/*----------------------*/
+/* Physical interfaces  */
+/*----------------------*/
+
+/* Phy loopback */
+#define PHY_LOOPBACK    1
+
+
+/* Phy 0 */
+#define PHY0BASE        (PHY_BASE)
+#define PHY0RST         (*(volatile unsigned char *) (PHY0BASE))      /* reset   */
+#define PHY0CTRL        (*(volatile unsigned char *) (PHY0BASE+0x5))  /* control */
+#define PHY0RACPCTRL    (*(volatile unsigned char *) (PHY0BASE+0x50)) /* RACP control/status */ 
+#define PHY0TACPCTRL    (*(volatile unsigned char *) (PHY0BASE+0x60)) /* TACP idle/unassigned cell hdr */
+#define PHY0RACPINT     (*(volatile unsigned char *) (PHY0BASE+0x51)) /* RACP interrupt enable/Status */
+
+
+/* Phy 1 */
+
+#define PHY1BASE        (PHY_BASE + 0x100000)
+#define PHY1RST         (*(volatile unsigned char *) (PHY1BASE))      /* reset   */
+#define PHY1CTRL        (*(volatile unsigned char *) (PHY1BASE+0x5))  /* control */
+#define PHY1RACPCTRL    (*(volatile unsigned char *) (PHY1BASE+0x50)) 
+#define PHY1TACPCTRL    (*(volatile unsigned char *) (PHY1BASE+0x60)) 
+#define PHY1RACPINT     (*(volatile unsigned char *) (PHY1BASE+0x51)) 
+
+/* Phy 2 */
+
+#define PHY2BASE        (PHY_BASE + 0x200000)
+#define PHY2RST         (*(volatile unsigned char *) (PHY2BASE))      /* reset   */
+#define PHY2CTRL        (*(volatile unsigned char *) (PHY2BASE+0x5))  /* control */
+#define PHY2RACPCTRL    (*(volatile unsigned char *) (PHY2BASE+0x50)) 
+#define PHY2TACPCTRL    (*(volatile unsigned char *) (PHY2BASE+0x60)) 
+#define PHY2RACPINT     (*(volatile unsigned char *) (PHY2BASE+0x51)) 
+
+/*-------------------*/
+/* Avalanche ATM SAR */
+/*-------------------*/
+
+#define AVSAR_SYSCONFIG    (*(volatile unsigned int*)(ATM_SAR_BASE+0x00000000)) /* SAR system config register    */
+#define AVSAR_SYSSTATUS    (*(volatile unsigned int*)(ATM_SAR_BASE+0x00000004)) /* SAR system status register    */
+#define AVSAR_INT_ENABLE   (*(volatile unsigned int*)(ATM_SAR_BASE+0x00000008)) /* SAR interrupt enable register */
+#define AVSAR_CONN_VPI_VCI (*(volatile unsigned int*)(ATM_SAR_BASE+0x0000000c)) /* VPI/VCI connection config     */
+#define AVSAR_CONN_CONFIG  (*(volatile unsigned int*)(ATM_SAR_BASE+0x00000010)) /* Connection config register    */
+#define AVSAR_OAM_CONFIG   (*(volatile unsigned int*)(ATM_SAR_BASE+0x00000018)) /* OAM configuration register    */
+
+/* Transmit completion ring registers */
+
+#define AVSAR_TCRAPTR       (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000100))
+#define AVSAR_TCRASIZE      (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000104))
+#define AVSAR_TCRAINTTHRESH (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000108))
+#define AVSAR_TCRATOTENT    (*(volatile unsigned int *)(ATM_SAR_BASE+0x0000010c))
+#define AVSAR_TCRAFREEENT   (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000110))
+#define AVSAR_TCRAPENDENT   (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000114))
+#define AVSAR_TCRAENTINC    (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000118))
+#define AVSAR_TCRBPTR       (*(volatile unsigned int *)(ATM_SAR_BASE+0x0000011c))
+#define AVSAR_TCRBSIZE      (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000120))
+#define AVSAR_TCRBINTTHRESH (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000124))
+#define AVSAR_TCRBTOTENT    (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000128))
+#define AVSAR_TCRBFREEENT   (*(volatile unsigned int *)(ATM_SAR_BASE+0x0000012c))
+#define AVSAR_TCRBPENDENT   (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000130))
+#define AVSAR_TCRBENTINC    (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000134))
+
+/* Transmit Queue Packet registers */
+#define AVSAR_TXQUEUE_PKT0  (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000140))
+#define AVSAR_TXQUEUE_PKT1  (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000144))
+#define AVSAR_TXQUEUE_PKT2  (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000148))
+#define AVSAR_TX_FLUSH      (*(volatile unsigned int *)(ATM_SAR_BASE+0x0000014C))
+/* Receive completion ring registers */
+
+#define AVSAR_RCRAPTR       (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000200))
+#define AVSAR_RCRASIZE      (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000204))
+#define AVSAR_RCRAINTTHRESH (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000208))
+#define AVSAR_RCRATOTENT    (*(volatile unsigned int *)(ATM_SAR_BASE+0x0000020c))
+#define AVSAR_RCRAFREEENT   (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000210))
+#define AVSAR_RCRAPENDENT   (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000214))
+#define AVSAR_RCRAENTINC    (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000218))
+#define AVSAR_RCRBPTR       (*(volatile unsigned int *)(ATM_SAR_BASE+0x0000021c))
+#define AVSAR_RCRBSIZE      (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000220))
+#define AVSAR_RCRBINTTHRESH (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000224))
+#define AVSAR_RCRBTOTENT    (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000228))
+#define AVSAR_RCRBFREEENT   (*(volatile unsigned int *)(ATM_SAR_BASE+0x0000022c))
+#define AVSAR_RCRBPENDENT   (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000230))
+#define AVSAR_RCRBENTINC    (*(volatile unsigned int *)(ATM_SAR_BASE+0x00000234))
+
+#define AVSAR_RXFBL_ADD0    (*(volatile unsigned int*)(ATM_SAR_BASE+0x00000240)) /* Rx Free buffer list add 0  */
+#define AVSAR_RXFBL_ADD1    (*(volatile unsigned int*)(ATM_SAR_BASE+0x00000244)) /* Rx Free buffer list add 1  */
+#define AVSAR_RXFBL_ADD2    (*(volatile unsigned int*)(ATM_SAR_BASE+0x00000248)) /* Rx Free buffer list add 2  */
+#define AVSAR_RXFBLSIZE_0   (*(volatile unsigned int*)(ATM_SAR_BASE+0x0000028c)) /* Rx Free buffer list size 0 */
+#define AVSAR_RXFBLSIZE_1   (*(volatile unsigned int*)(ATM_SAR_BASE+0x0000029c)) /* Rx Free buffer list size 1 */
+#define AVSAR_RXFBLSIZE_2   (*(volatile unsigned int*)(ATM_SAR_BASE+0x000002ac)) /* Rx Free buffer list size 2 */
+#define AVSAR_RXFBLSIZE_3   (*(volatile unsigned int*)(ATM_SAR_BASE+0x000002bc)) /* Rx Free buffer list size 3 */
+
+
+#if defined(CONFIG_MIPS_EVM3D) || defined(CONFIG_MIPS_AR5D01) || defined(CONFIG_MIPS_AR5W01)
+
+#define AVSAR_SAR_FREQUENCY (*(volatile unsigned int*)(ATM_SAR_BASE+0x00010480))
+#define AVSAR_OAM_CC_SINK   (*(volatile unsigned int*)(ATM_SAR_BASE+0x00010484))
+#define AVSAR_OAM_AIS_RDI_RX (*(volatile unsigned int*)(ATM_SAR_BASE+0x00010488))
+#define AVSAR_OAM_CPID0      (*(volatile unsigned int*)(ATM_SAR_BASE+0x000104E0))
+#define AVSAR_OAM_LLID0      (*(volatile unsigned int*)(ATM_SAR_BASE+0x000104F0))
+#define AVSAR_OAM_CPID1      (*(volatile unsigned int*)(ATM_SAR_BASE+0x000104E4))
+#define AVSAR_OAM_LLID1      (*(volatile unsigned int*)(ATM_SAR_BASE+0x000104F4))
+#define AVSAR_OAM_CPID2      (*(volatile unsigned int*)(ATM_SAR_BASE+0x000104E8))
+#define AVSAR_OAM_LLID2      (*(volatile unsigned int*)(ATM_SAR_BASE+0x000104F8))
+#define AVSAR_OAM_CPID3      (*(volatile unsigned int*)(ATM_SAR_BASE+0x000104EC))
+#define AVSAR_OAM_LLID3      (*(volatile unsigned int*)(ATM_SAR_BASE+0x000104FC))
+#define AVSAR_OAM_CORR_TAG      (*(volatile unsigned int*)(ATM_SAR_BASE+0x00010500))
+#define AVSAR_OAM_FAR_COUNT      (*(volatile unsigned int*)(ATM_SAR_BASE+0x00010520))
+#define AVSAR_OAM_NEAR_COUNT      (*(volatile unsigned int*)(ATM_SAR_BASE+0x00010540))
+#define AVSAR_OAM_CONFIG_REG      (*(volatile unsigned int*)(ATM_SAR_BASE+0x00000018))
+#define AVSAR_FAIRNESS_REG   (*(volatile unsigned int*)(ATM_SAR_BASE+0x000104B8))
+#define AVSAR_UBR_PCR_REG   (*(volatile unsigned int*)(ATM_SAR_BASE+0x00010490))
+
+
+/*
+
+#define OAM_CPID_ADD  0xa30104e0
+
+#define OAM_LLID_ADD  0xa30104f0
+
+#define OAM_LLID_VAL  0xffffffff
+
+#define OAM_CORR_TAG  0xa3010500
+
+#define OAM_FAR_COUNT_ADD 0xa3010520
+
+#define OAM_NEAR_COUNT_ADD 0xa3010540
+
+#define OAM_CONFIG_REG_ADD 0xa3000018
+*/
+
+
+#else /* CONFIG_MIPS_EVM3 || CONFIG_MIPS_ACPEP */
+
+#define AVSAR_SAR_FREQUENCY (*(volatile unsigned int*)(ATM_SAR_BASE+0x00012000))
+#define AVSAR_OAM_CC_SINK   (*(volatile unsigned int*)(ATM_SAR_BASE+0x00012004))
+#define AVSAR_OAM_AIS_RDI_RX (*(volatile unsigned int*)(ATM_SAR_BASE+0x00012008))
+#define AVSAR_OAM_CPID      (*(volatile unsigned int*)(ATM_SAR_BASE+0x00012300))
+
+#endif /* CONFIG_MIPS_EVM3D || CONFIG_MIPS_AR5D01 || CONFIG_MIPS_AR5W01 */
+
+
+#define AVSAR_STATE_RAM     (ATM_SAR_BASE + 0x010000) /* SAR state RAM */
+#define AVSAR_PDSP_BASE     (ATM_SAR_BASE + 0x020000) /* SAR PDSP base address   */
+#define AVSAR_TXDMA_BASE    (ATM_SAR_BASE + 0x030000) /* Transmit DMA state base */ 
+#define AVSAR_TDMASTATE6    0x18                      /* Transmit DMA state word 6 */
+#define AVSAR_RXDMA_BASE    (ATM_SAR_BASE + 0x040000) /* Receive  DMA state base */
+#define AVSAR_RDMASTATE0    0x0                       /* Receive  DMA state word 0 */
+
+/*------------------------------------------*/
+/* DSL Interface                            */
+/*------------------------------------------*/
+
+#define AVDSL_TX_EN          (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000000))
+#define AVDSL_RX_EN          (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000004))
+#define AVDSL_POLL           (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000008))
+
+/* Fast */
+
+#define AVDSL_TX_FIFO_ADDR0  (*(volatile unsigned int *)(DSL_IF_BASE + 0x0000000C))
+#define AVDSL_TX_FIFO_BASE0  (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000010))
+#define AVDSL_TX_FIFO_LEN0   (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000014))
+#define AVDSL_TX_FIFO_PR0    (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000018))
+#define AVDSL_RX_FIFO_ADDR0  (*(volatile unsigned int *)(DSL_IF_BASE + 0x0000001C))
+#define AVDSL_RX_FIFO_BASE0  (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000020))
+#define AVDSL_RX_FIFO_LEN0   (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000024))
+#define AVDSL_RX_FIFO_PR0    (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000028))
+
+/* Interleaved */
+
+#define AVDSL_TX_FIFO_ADDR1  (*(volatile unsigned int *)(DSL_IF_BASE + 0x0000002C))
+#define AVDSL_TX_FIFO_BASE1  (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000030))
+#define AVDSL_TX_FIFO_LEN1   (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000034))
+#define AVDSL_TX_FIFO_PR1    (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000038))
+#define AVDSL_RX_FIFO_ADDR1  (*(volatile unsigned int *)(DSL_IF_BASE + 0x0000003C))
+#define AVDSL_RX_FIFO_BASE1  (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000040))
+#define AVDSL_RX_FIFO_LEN1   (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000044))
+#define AVDSL_RX_FIFO_PR1    (*(volatile unsigned int *)(DSL_IF_BASE + 0x00000048))
+
+/*------------------------------------------*/
+/* Broadband I/F                            */
+/*------------------------------------------*/
+
+#define AVBBIF_BBIF_CNTRL    (*(volatile unsigned int *)(BBIF_CONTROL + 0x00000000))
+#define AVBBIF_ADDR_TRANS_0  (*(volatile unsigned int *)(BBIF_CONTROL + 0x00000004))
+#define AVBBIF_ADDR_TRANS_1  (*(volatile unsigned int *)(BBIF_CONTROL + 0x00000008))
+#define AVBBIF_ADDR_XB_MX_BL (*(volatile unsigned int *)(BBIF_CONTROL + 0x0000000C))
+#define AVBBIF_INFIFO_LVL    (*(volatile unsigned int *)(BBIF_CONTROL + 0x00000010))
+#define AVBBIF_OUTFIFO_LVL   (*(volatile unsigned int *)(BBIF_CONTROL + 0x00000014))
+
+#define AVBBIF_DISABLED    0x0
+#define AVBBIF_LBT4040_INT 0x1
+#define AVBBIF_XBUS        0x2
+#define AVBBIF_LBT4040_EXT 0x4
+
+#define AVBBIF_ADDR_MASK0   0xff000000 /* handles upper bits of BBIF 0 address */
+#define AVBBIF_ADDR_MASK1   0xff800000 /* handles upper bits of BBIF 1 address */
+#define AVBBIF_TRANS_MASK   0xff000000
+/*------------------------------------------*/
+/* GPIO I/F                                 */
+/*------------------------------------------*/
+
+#define GPIO_DATA_INPUT      (*(volatile unsigned int *)(GPIO_BASE + 0x00000000))
+#define GPIO_DATA_OUTPUT     (*(volatile unsigned int *)(GPIO_BASE + 0x00000004))
+#define GPIO_DATA_DIR        (*(volatile unsigned int *)(GPIO_BASE + 0x00000008)) /* 0=output 1=input  */
+#define GPIO_DATA_ENABLE     (*(volatile unsigned int *)(GPIO_BASE + 0x0000000C)) /* 0=GPIO Mux 1=GPIO */
+
+#define GPIO_0 (1<<21)
+#define GPIO_1 (1<<22)
+#define GPIO_2 (1<<23)
+#define GPIO_3 (1<<24)
+#define EINT_1 (1<<18)
+
+/*
+  JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE
+       If you reset the GPIO interface all of the directions (i/o) of the UART B
+       interface pins are inputs and must be reconfigured so as not to lose the 
+       serial console interface
+  JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE JAH NOTE
+*/
+
+/*------------------------------------------*/
+/* CLK_CTRL                                 */
+/*------------------------------------------*/
+#define PERIPH_CLK_CTL       (*(volatile unsigned int *)(CLK_CTRL_BASE + 0x00000004))
+
+#define PCLK_0_HALF_VBUS     (0<<16)
+#define PCLK_EQ_INPUT        (1<<16)
+#define BBIF_CLK_HALF_VBUS   (0<<17)
+#define BBIF_CLK_EQ_VBUS     (1<<17)
+#define BBIF_CLK_EQ_BBCLK    (3<<17)
+#define DSP_MODCLK_DSPCLKI   (0<<20)
+#define DSP_MODCLK_REFCLKI   (1<<20)
+#define USB_CLK_EQ_USBCLKI   (0<<21)
+#define USB_CLK_EQ_REFCLKI   (1<<21)
+
+/*------------------------------------------*/
+/* PCI Control Registers                    */
+/*------------------------------------------*/
+#define	PCIC_CONTROL		(*(volatile unsigned int *)(PCI_CONFIG_BASE))
+#define		PCIC_CONTROL_CFG_DONE				(1<<0)
+#define		PCIC_CONTROL_DIS_SLAVE_TO			(1<<1)
+#define		PCIC_CONTROL_FORCE_DELAY_READ		(1<<2)
+#define		PCIC_CONTROL_FORCE_DELAY_READ_LINE	(1<<3)
+#define		PCIC_CONTROL_FORCE_DELAY_READ_MULT	(1<<4)
+#define		PCIC_CONTROL_MEM_SPACE_EN			(1<<5)
+#define		PCIC_CONTROL_MEM_MASK				(1<<6)
+#define		PCIC_CONTROL_IO_SPACE_EN			(1<<7)
+#define		PCIC_CONTROL_IO_MASK				(1<<8)
+/*			PCIC_CONTROL_RESERVED				(1<<9)	*/
+#define		PCIC_CONTROL_BASE0_EN				(1<<10)
+#define		PCIC_CONTROL_BASE1_EN				(1<<11)
+#define		PCIC_CONTROL_BASE2_EN				(1<<12)
+#define		PCIC_CONTROL_HOLD_MASTER_WRITE		(1<<13)
+#define		PCIC_CONTROL_ARBITER_EN				(1<<14)
+#define	PCIC_INT_SOURCE		(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000004))
+#define		PCIC_INT_SOURCE_PWR_MGMT			(1<<0)
+#define		PCIC_INT_SOURCE_PCI_TARGET			(1<<1)
+#define		PCIC_INT_SOURCE_PCI_MASTER			(1<<2)
+#define		PCIC_INT_SOURCE_POWER_WAKEUP		(1<<3)
+#define		PCIC_INT_SOURCE_PMEIN				(1<<4)
+/*			PCIC_INT_SOURCE_RESERVED			(1<<5) */
+/*			PCIC_INT_SOURCE_RESERVED			(1<<6) */
+#define		PCIC_INT_SOURCE_PIC_INTA			(1<<7)
+#define		PCIC_INT_SOURCE_PIC_INTB			(1<<8)
+#define		PCIC_INT_SOURCE_PIC_INTC			(1<<9)
+#define		PCIC_INT_SOURCE_PIC_INTD			(1<<10)
+#define		PCIC_INT_SOURCE_SOFT_INT0			(1<<11)
+#define		PCIC_INT_SOURCE_SOFT_INT1			(1<<12)
+#define		PCIC_INT_SOURCE_SOFT_INT2			(1<<13)
+#define		PCIC_INT_SOURCE_SOFT_INT3			(1<<14)
+#define	PCIC_INT_CLEAR		(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000008))
+#define		PCIC_INT_CLEAR_PM					(1<<0)
+#define		PCIC_INT_CLEAR_PCI_TARGET			(1<<1)
+#define		PCIC_INT_CLEAR_PCI_MASTER			(1<<2)
+/*			PCIC_INT_CLEAR_RESERVED				(1<<3)	*/
+#define		PCIC_INT_CLEAR_PMEIN				(1<<4)
+/*			PCIC_INT_CLEAR_RESERVED				(1<<5)	*/
+/*			PCIC_INT_CLEAR_RESERVED				(1<<6)	*/
+#define		PCIC_INT_CLEAR_PCI_INTA				(1<<7)
+#define		PCIC_INT_CLEAR_PCI_INTB				(1<<8)
+#define		PCIC_INT_CLEAR_PCI_INTC				(1<<9)
+#define		PCIC_INT_CLEAR_PCI_INTD				(1<<10)
+#define		PCIC_INT_CLEAR_SOFT_INT0			(1<<11)
+#define		PCIC_INT_CLEAR_SOFT_INT1			(1<<12)
+#define		PCIC_INT_CLEAR_SOFT_INT2			(1<<13)
+#define		PCIC_INT_CLEAR_SOFT_INT3			(1<<14)
+#define	PCIC_INT_EN_AVAL	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x0000000c))
+#define		PCIC_INT_EN_AVAL_PM					(1<<0)
+#define		PCIC_INT_EN_AVAL_PCI_TARGET			(1<<1)
+#define		PCIC_INT_EN_AVAL_PCI_MASTER			(1<<2)
+/*			PCIC_INT_EN_AVAL_RESERVED			(1<<3)	*/
+#define		PCIC_INT_EN_AVAL_PMEIN				(1<<4)
+/*			PCIC_INT_EN_AVAL_RESERVED			(1<<5)	*/
+/*			PCIC_INT_EN_AVAL_RESERVED			(1<<6)	*/
+#define		PCIC_INT_EN_AVAL_PCI_INTA			(1<<7)
+#define		PCIC_INT_EN_AVAL_PCI_INTB			(1<<8)
+#define		PCIC_INT_EN_AVAL_PCI_INTC			(1<<9)
+#define		PCIC_INT_EN_AVAL_PCI_INTD			(1<<10)
+#define		PCIC_INT_EN_AVAL_SOFT_INT0			(1<<11)
+#define		PCIC_INT_EN_AVAL_SOFT_INT1			(1<<12)
+#define		PCIC_INT_EN_AVAL_SOFT_INT2			(1<<13)
+#define		PCIC_INT_EN_AVAL_SOFT_INT3			(1<<14)
+#define	PCIC_INT_EN_PCI			(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000010))
+#define		PCIC_INT_EN_PCI_PM					(1<<0)
+#define		PCIC_INT_EN_PCI_PCI_TARGET			(1<<1)
+#define		PCIC_INT_EN_PCI_PCI_MASTER			(1<<2)
+/*			PCIC_INT_EN_PCI_RESERVED			(1<<3)	*/
+#define		PCIC_INT_EN_PCI_PMEIN				(1<<4)
+/*			PCIC_INT_EN_PCI_RESERVED			(1<<5)	*/
+/*			PCIC_INT_EN_PCI_RESERVED			(1<<6)	*/
+#define		PCIC_INT_EN_PCI_PCI_INTA			(1<<7)
+#define		PCIC_INT_EN_PCI_PCI_INTB			(1<<8)
+#define		PCIC_INT_EN_PCI_PCI_INTC			(1<<9)
+#define		PCIC_INT_EN_PCI_PCI_INTD			(1<<10)
+#define		PCIC_INT_EN_PCI_SOFT_INT0			(1<<11)
+#define		PCIC_INT_EN_PCI_SOFT_INT1			(1<<12)
+#define		PCIC_INT_EN_PCI_SOFT_INT2			(1<<13)
+#define		PCIC_INT_EN_PCI_SOFT_INT3			(1<<14)
+#define	PCIC_INT_SWSET		(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000014))
+#define		PCIC_INT_SWSET_SOFT_INT0			(1<<0)
+#define		PCIC_INT_SWSET_SOFT_INT1			(1<<1)
+#define		PCIC_INT_SWSET_SOFT_INT2			(1<<2)
+#define		PCIC_INT_SWSET_SOFT_INT3			(1<<3)
+#define	PCIC_PM_CTL			(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000018))
+#define		PCIC_PM_CTL_PWR_STATE_MASK			(0x02)
+/*			PCIC_PM_CTL_RESERVED				(1<<2) */
+/*			PCIC_PM_CTL_RESERVED				(1<<3) */
+/*			PCIC_PM_CTL_RESERVED				(1<<4) */
+/*			PCIC_PM_CTL_RESERVED				(1<<5) */
+/*			PCIC_PM_CTL_RESERVED				(1<<6) */
+/*			PCIC_PM_CTL_RESERVED				(1<<7) */
+/*			PCIC_PM_CTL_RESERVED				(1<<8) */
+/*			PCIC_PM_CTL_RESERVED				(1<<9) */
+#define		PCIC_PM_CTL_PWR_SUPPORT				(1<<10)
+#define		PCIC_PM_CTL_PMEIN					(1<<11)
+#define		PCIC_PM_CTL_CAP_MASK	(*(volatile unsigned short int *)(PCI_CONFIG_BASE + 0x0000001a))
+#define	PCIC_PM_CONSUME		(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x0000001c))
+#define		PCIC_PM_CONSUME_D0		(*(volatile unsigned char *)(PCI_CONFIG_BASE + 0x0000001c))
+#define		PCIC_PM_CONSUME_D1		(*(volatile unsigned char *)(PCI_CONFIG_BASE + 0x0000001d))
+#define		PCIC_PM_CONSUME_D2		(*(volatile unsigned char *)(PCI_CONFIG_BASE + 0x0000001e))
+#define		PCIC_PM_CONSUME_D3		(*(volatile unsigned char *)(PCI_CONFIG_BASE + 0x0000001f))
+#define	PCIC_PM_DISSAPATED	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000020))
+#define		PCIC_PM_DISSAPATED_D0	(*(volatile unsigned char *)(PCI_CONFIG_BASE + 0x00000020))
+#define		PCIC_PM_DISSAPATED_D1	(*(volatile unsigned char *)(PCI_CONFIG_BASE + 0x00000021))
+#define		PCIC_PM_DISSAPATED_D2	(*(volatile unsigned char *)(PCI_CONFIG_BASE + 0x00000022))
+#define		PCIC_PM_DISSAPATED_D3	(*(volatile unsigned char *)(PCI_CONFIG_BASE + 0x00000023))
+#define	PCIC_PM_DATA_SCALE	(*(volatile unsigned short int *)(PCI_CONFIG_BASE + 0x00000024))
+#define	PCIC_VEND_DEV_ID	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000028))
+#define	PCIC_SUB_VEND_DEV_ID	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x0000002c))
+#define	PCIC_CLASS_REV_ID	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000030))
+#define	PCIC_MAX_MIN		(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000034))
+#define	PCIC_MAST_MEM_AT0	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x0000003c))
+#define	PCIC_MAST_MEM_AT1	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000040))
+#define	PCIC_MAST_MEM_AT2	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000044))
+#define	PCIC_SLAVE_MASK0	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x0000004c))
+#define	PCIC_SLAVE_MASK1	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000050))
+#define	PCIC_SLAVE_MASK2	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000054))
+#define	PCIC_SLAVE_BASE_AT0	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000058))
+#define	PCIC_SLAVE_BASE_AT1	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x0000005c))
+#define	PCIC_SLAVE_BASE_AT2	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000060))
+#define	PCIC_CONF_COMMAND	(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000090))
+#define	PCIC_CONF_ADDR		(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000094))
+#define	PCIC_CONF_DATA		(*(volatile unsigned int *)(PCI_CONFIG_BASE + 0x00000098))
+
+/*------------------------------------------*/
+/* IIC_INTERFACE                            */
+/*------------------------------------------*/
+#define I2C_DATA_HI          (*(volatile unsigned int *)(I2C_BASE + 0x0))
+#define I2C_DATA_LOW         (*(volatile unsigned int *)(I2C_BASE + 0x4))
+#define I2C_CONFIG           (*(volatile unsigned int *)(I2C_BASE + 0x8))
+#define I2C_DATA_READ        (*(volatile unsigned int *)(I2C_BASE + 0xC))
+#define I2C_CLOCK_DIV        (*(volatile unsigned int *)(I2C_BASE + 0x10))
+
+#define I2CWRITE      0x200
+#define I2CREAD       0x300
+#define I2C_END_BURST 0x400
+
+/* read bits */
+#define I2C_READ_ERROR    0x8000
+#define I2C_READ_COMPLETE 0x4000
+#define I2C_READ_BUSY     0x2000
+
+/* device types */
+#define I2C_IO_EXPANDER      0x2
+#define I2C_RTC              0xd
+
+/* device Addresses on I2C bus (EVM3) */
+#define SEVEN_SEGMENT_DISP    0x23   /* Device type = 0x2, Addr = 3 */
+#define EVM3_RTC              0xd0   /* Device type = 0xd, Addr = 0 */
+#define EVM3_RTC_I2C_ADDR      0x0
+
+/*------------------------------------------*/
+/* Ethernet MAC register offset definitions */
+/*------------------------------------------*/
+#define VMAC_DMACONFIG(X)      (*(volatile unsigned int *)(X + 0x00000000))
+#define VMAC_INTSTS(X)         (*(volatile unsigned int *)(X + 0x00000004))
+#define VMAC_INTMASK(X)        (*(volatile unsigned int *)(X + 0x00000008))
+
+#define VMAC_WRAPCLK(X)        (*(volatile unsigned int *)(X + 0x00000340))
+#define VMAC_STATSBASE(X)      (*(volatile unsigned int *)(X + 0x00000400))
+ 
+#define VMAC_TCRPTR(X)         (*(volatile unsigned int *)(X + 0x00000100))
+#define VMAC_TCRSIZE(X)        (*(volatile unsigned int *)(X + 0x00000104))
+#define VMAC_TCRINTTHRESH(X)   (*(volatile unsigned int *)(X + 0x00000108))
+#define VMAC_TCRTOTENT(X)      (*(volatile unsigned int *)(X + 0x0000010C))
+#define VMAC_TCRFREEENT(X)     (*(volatile unsigned int *)(X + 0x00000110))
+#define VMAC_TCRPENDENT(X)     (*(volatile unsigned int *)(X + 0x00000114))
+#define VMAC_TCRENTINC(X)      (*(volatile unsigned int *)(X + 0x00000118))
+#define VMAC_TXISRPACE(X)      (*(volatile unsigned int *)(X + 0x0000011c))
+
+
+#define VMAC_TDMASTATE0(X)     (*(volatile unsigned int *)(X + 0x00000120))
+#define VMAC_TDMASTATE1(X)     (*(volatile unsigned int *)(X + 0x00000124))
+#define VMAC_TDMASTATE2(X)     (*(volatile unsigned int *)(X + 0x00000128))
+#define VMAC_TDMASTATE3(X)     (*(volatile unsigned int *)(X + 0x0000012C))
+#define VMAC_TDMASTATE4(X)     (*(volatile unsigned int *)(X + 0x00000130))
+#define VMAC_TDMASTATE5(X)     (*(volatile unsigned int *)(X + 0x00000134))
+#define VMAC_TDMASTATE6(X)     (*(volatile unsigned int *)(X + 0x00000138))
+#define VMAC_TDMASTATE7(X)     (*(volatile unsigned int *)(X + 0x0000013C))
+#define VMAC_TXPADDCNT(X)      (*(volatile unsigned int *)(X + 0x00000140))
+#define VMAC_TXPADDSTART(X)    (*(volatile unsigned int *)(X + 0x00000144))
+#define VMAC_TXPADDEND(X)      (*(volatile unsigned int *)(X + 0x00000148))
+#define VMAC_TXQFLUSH(X)       (*(volatile unsigned int *)(X + 0x0000014C))
+ 
+#define VMAC_RCRPTR(X)         (*(volatile unsigned int *)(X + 0x00000200))
+#define VMAC_RCRSIZE(X)        (*(volatile unsigned int *)(X + 0x00000204))
+#define VMAC_RCRINTTHRESH(X)   (*(volatile unsigned int *)(X + 0x00000208))
+#define VMAC_RCRTOTENT(X)      (*(volatile unsigned int *)(X + 0x0000020C))
+#define VMAC_RCRFREEENT(X)     (*(volatile unsigned int *)(X + 0x00000210))
+#define VMAC_RCRPENDENT(X)     (*(volatile unsigned int *)(X + 0x00000214))
+#define VMAC_RCRENTINC(X)      (*(volatile unsigned int *)(X + 0x00000218))
+#define VMAC_RXISRPACE(X)      (*(volatile unsigned int *)(X + 0x0000021c))
+
+#define VMAC_RDMASTATE0(X)     (*(volatile unsigned int *)(X + 0x00000220))
+#define VMAC_RDMASTATE1(X)     (*(volatile unsigned int *)(X + 0x00000224))
+#define VMAC_RDMASTATE2(X)     (*(volatile unsigned int *)(X + 0x00000228))
+#define VMAC_RDMASTATE3(X)     (*(volatile unsigned int *)(X + 0x0000022C))
+#define VMAC_RDMASTATE4(X)     (*(volatile unsigned int *)(X + 0x00000230))
+#define VMAC_RDMASTATE5(X)     (*(volatile unsigned int *)(X + 0x00000234))
+#define VMAC_RDMASTATE6(X)     (*(volatile unsigned int *)(X + 0x00000238))
+#define VMAC_RDMASTATE7(X)     (*(volatile unsigned int *)(X + 0x0000023C))
+#define VMAC_FBLADDCNT(X)      (*(volatile unsigned int *)(X + 0x00000240))
+#define VMAC_FBLADDSTART(X)    (*(volatile unsigned int *)(X + 0x00000244))
+#define VMAC_FBLADDEND(X)      (*(volatile unsigned int *)(X + 0x00000248))
+#define VMAC_RXONOFF(X)        (*(volatile unsigned int *)(X + 0x0000024C))
+ 
+#define VMAC_FBL0NEXTD(X)      (*(volatile unsigned int *)(X + 0x00000280))
+#define VMAC_FBL0LASTD(X)      (*(volatile unsigned int *)(X + 0x00000284))
+#define VMAC_FBL0COUNTD(X)     (*(volatile unsigned int *)(X + 0x00000288))
+#define VMAC_FBL0BUFSIZE(X)    (*(volatile unsigned int *)(X + 0x0000028C))
+ 
+#define VMAC_MACCONTROL(X)     (*(volatile unsigned int *)(X + 0x00000300))
+#define VMAC_MACSTATUS(X)      (*(volatile unsigned int *)(X + 0x00000304))
+#define VMAC_MACADDRHI(X)      (*(volatile unsigned int *)(X + 0x00000308))
+#define VMAC_MACADDRLO(X)      (*(volatile unsigned int *)(X + 0x0000030C))
+#define VMAC_MACHASH1(X)       (*(volatile unsigned int *)(X + 0x00000310))
+#define VMAC_MACHASH2(X)       (*(volatile unsigned int *)(X + 0x00000314))
+ 
+#define VMAC_WRAPCLK(X)        (*(volatile unsigned int *)(X + 0x00000340))
+#define VMAC_BOFTEST(X)        (*(volatile unsigned int *)(X + 0x00000344))
+#define VMAC_PACTEST(X)        (*(volatile unsigned int *)(X + 0x00000348))
+#define VMAC_PAUSEOP(X)        (*(volatile unsigned int *)(X + 0x0000034C))
+ 
+#define VMAC_MDIOCONTROL(X)    (*(volatile unsigned int *)(X + 0x00000380))
+#define VMAC_MDIOUSERACCESS(X) (*(volatile unsigned int *)(X +0x00000384))
+#define VMAC_MDIOACK(X)        (*(volatile unsigned int *)(X + 0x00000388))
+#define VMAC_MDIOLINK(X)       (*(volatile unsigned int *)(X + 0x0000038C))
+#define VMAC_MDIOMACPHY(X)     (*(volatile unsigned int *)(X + 0x00000390))
+
+#define VMAC_STATS_BASE(X)     (X + 0x00000400)
+
+#endif __AVALANCHE_REGS_H
+
+
+
+
+
+
diff -urN linux.old/include/asm-mips/ar7/avalanche_types.h linux.dev/include/asm-mips/ar7/avalanche_types.h
--- linux.old/include/asm-mips/ar7/avalanche_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/avalanche_types.h	2005-11-10 01:10:46.071588750 +0100
@@ -0,0 +1,126 @@
+/*------------------------------------------------------------------------------------------*\
+\*------------------------------------------------------------------------------------------*/
+#ifndef _avalanche_types_h_
+#define _avalanche_types_h_
+
+/*--- #include <asm/avalanche/generic/hal_modules/haltypes.h> ---*/
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+#ifndef NULL
+#define NULL (void *)0
+#endif
+
+/*------------------------------------------------------------------------------------------*\
+ * Typen fr Texas GPL Module
+\*------------------------------------------------------------------------------------------*/
+#ifndef __UINT8_T__
+typedef unsigned char   UINT8;
+#define __UINT8_T__
+#endif
+
+#ifndef __UCHAR_T__
+typedef unsigned char   UCHAR;
+#define __UCHAR_T__
+#endif
+
+#ifndef __INT8_T__
+typedef signed char     INT8;
+#define __INT8_T__
+#endif
+
+#ifndef __UINT16_T__
+typedef unsigned short  UINT16;
+#define __UINT16_T__
+#endif
+
+#ifndef __USHORT_T__
+typedef unsigned short  USHORT;
+#define __USHORT_T__
+#endif
+
+#ifndef __INT16_T__
+typedef signed short    INT16;
+#define __INT16_T__
+#endif
+
+#ifndef __UINT32_T__
+typedef unsigned int    UINT32;
+#define __UINT32_T__
+#endif
+
+#ifndef __UINT_T__
+typedef unsigned int    UINT;
+#define __UINT_T__
+#endif
+
+#ifndef __INT32_T__
+typedef signed int      INT32;
+#define __INT32_T__
+#endif
+
+#ifndef __ULONG_T__
+typedef unsigned long   ULONG;
+#define __ULONG_T__
+#endif
+
+#ifndef __BOOL_T__
+typedef int             BOOL;
+#define __BOOL_T__
+#endif
+
+#ifndef __STATUS_T__
+typedef int             STATUS;
+#define __STATUS_T__
+#endif
+
+/*------------------------------------------------------------------------------------------*\
+\*------------------------------------------------------------------------------------------*/
+typedef void (*p_vlynq_intr_cntrl_isr_t)(void *,void *,void *);
+typedef INT32 (*p_vlynq_interrupt_vector_set_t)(void *, UINT32, UINT32, INT32, INT32, INT32);
+typedef INT32 (*p_vlynq_interrupt_vector_cntl_t)(void *, UINT32, INT32, UINT32);
+typedef UINT32 (*p_vlynq_interrupt_get_count_t)(void *, UINT32);
+typedef INT32 (*p_vlynq_install_isr_t)(void *, UINT32, p_vlynq_intr_cntrl_isr_t, void *, void *, void *);
+typedef INT32 (*p_vlynq_uninstall_isr_t)(void *, UINT32, void *, void *, void *);
+typedef void (*p_vlynq_root_isr_t)(void *);
+typedef void (*p_vlynq_delay_t)(UINT32);
+typedef INT32 (*p_vlynq_interrupt_vector_map_t)(void *, INT32, UINT32, UINT32);
+typedef INT32 (*p_vlynq_interrupt_set_polarity_t)(void *, INT32, UINT32, INT32); 
+typedef INT32 (*p_vlynq_interrupt_get_polarity_t)(void *, INT32, UINT32);
+typedef INT32 (*p_vlynq_interrupt_set_type_t)(void *, INT32, UINT32, INT32);
+typedef INT32 (*p_vlynq_interrupt_get_type_t)(void *, INT32, UINT32);
+typedef INT32 (*p_vlynq_interrupt_enable_t)(void *, INT32, UINT32);
+typedef INT32 (*p_vlynq_interrupt_disable_t)(void *, INT32, UINT32);
+                 
+/*------------------------------------------------------------------------------------------*\
+\*------------------------------------------------------------------------------------------*/
+extern p_vlynq_interrupt_vector_set_t p_vlynq_interrupt_vector_set;
+extern p_vlynq_interrupt_vector_cntl_t p_vlynq_interrupt_vector_cntl;
+extern p_vlynq_interrupt_get_count_t p_vlynq_interrupt_get_count;
+extern p_vlynq_install_isr_t p_vlynq_install_isr;
+extern p_vlynq_uninstall_isr_t p_vlynq_uninstall_isr;
+extern p_vlynq_root_isr_t p_vlynq_root_isr;
+extern p_vlynq_delay_t p_vlynq_delay;
+extern p_vlynq_interrupt_vector_map_t p_vlynq_interrupt_vector_map;
+extern p_vlynq_interrupt_set_polarity_t p_vlynq_interrupt_set_polarity;
+extern p_vlynq_interrupt_get_polarity_t p_vlynq_interrupt_get_polarity;
+extern p_vlynq_interrupt_set_type_t p_vlynq_interrupt_set_type;
+extern p_vlynq_interrupt_get_type_t p_vlynq_interrupt_get_type;
+extern p_vlynq_interrupt_enable_t p_vlynq_interrupt_enable;
+extern p_vlynq_interrupt_disable_t p_vlynq_interrupt_disable;
+extern void *p_vlynqDevice0;
+extern void *p_vlynqDevice1;
+
+/*------------------------------------------------------------------------------------------*\
+\*------------------------------------------------------------------------------------------*/
+enum _avalanche_need_ {
+    avalanche_need_vlynq,
+    avalanche_need_auto_mdix
+};
+
+int avalanche_need(enum _avalanche_need_);
+
+#endif /*--- #ifndef _avalanche_types_h_ ---*/
diff -urN linux.old/include/asm-mips/ar7/if_port.h linux.dev/include/asm-mips/ar7/if_port.h
--- linux.old/include/asm-mips/ar7/if_port.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/if_port.h	2005-11-10 01:10:46.071588750 +0100
@@ -0,0 +1,26 @@
+/*******************************************************************************   
+ * FILE PURPOSE:    Interface port id Header file                                      
+ *******************************************************************************   
+ * FILE NAME:       if_port.h                                                   
+ *                                                                                 
+ * DESCRIPTION:     Header file carrying information about port ids of interfaces                             
+ *                                                                                 
+ *                                                                                 
+ * (C) Copyright 2003, Texas Instruments, Inc                                      
+ ******************************************************************************/   
+#ifndef _IF_PORT_H_
+#define _IF_PORT_H_
+
+#define AVALANCHE_CPMAC_LOW_PORT_ID         0
+#define AVALANCHE_CPMAC_HIGH_PORT_ID        1    
+#define AVALANCHE_USB_PORT_ID               2
+#define AVALANCHE_WLAN_PORT_ID              3
+
+
+#define AVALANCHE_MARVELL_BASE_PORT_ID      4
+
+/* The marvell ports occupy port ids from  4 to 8 */
+/* so the next port id number should start at 9   */
+
+
+#endif /* _IF_PORT_H_ */
diff -urN linux.old/include/asm-mips/ar7/sangam.h linux.dev/include/asm-mips/ar7/sangam.h
--- linux.old/include/asm-mips/ar7/sangam.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/sangam.h	2005-11-10 01:10:46.071588750 +0100
@@ -0,0 +1,180 @@
+#ifndef _SANGAM_H_
+#define _SANGAM_H_
+
+#include <linux/config.h>
+#include <asm/addrspace.h>
+
+/*----------------------------------------------------
+ * Sangam's Module Base Addresses
+ *--------------------------------------------------*/
+#define AVALANCHE_ADSL_SUB_SYS_MEM_BASE       (KSEG1ADDR(0x01000000)) /* AVALANCHE ADSL Mem Base */
+#define AVALANCHE_BROADBAND_INTERFACE__BASE   (KSEG1ADDR(0x02000000)) /* AVALANCHE BBIF */        
+#define AVALANCHE_ATM_SAR_BASE                (KSEG1ADDR(0x03000000)) /* AVALANCHE ATM SAR */
+#define AVALANCHE_USB_SLAVE_BASE              (KSEG1ADDR(0x03400000)) /* AVALANCHE USB SLAVE */
+#define AVALANCHE_LOW_VLYNQ_MEM_MAP_BASE      (KSEG1ADDR(0x04000000)) /* AVALANCHE VLYNQ 0 Mem map */
+#define AVALANCHE_LOW_CPMAC_BASE              (KSEG1ADDR(0x08610000)) /* AVALANCHE CPMAC 0 */
+#define AVALANCHE_EMIF_CONTROL_BASE           (KSEG1ADDR(0x08610800)) /* AVALANCHE EMIF */
+#define AVALANCHE_GPIO_BASE                   (KSEG1ADDR(0x08610900)) /* AVALANCHE GPIO */
+#define AVALANCHE_CLOCK_CONTROL_BASE          (KSEG1ADDR(0x08610A00)) /* AVALANCHE Clock Control */
+#define AVALANCHE_WATCHDOG_TIMER_BASE         (KSEG1ADDR(0x08610B00)) /* AVALANCHE Watch Dog Timer */  
+#define AVALANCHE_TIMER0_BASE                 (KSEG1ADDR(0x08610C00)) /* AVALANCHE Timer 1 */  
+#define AVALANCHE_TIMER1_BASE                 (KSEG1ADDR(0x08610D00)) /* AVALANCHE Timer 2 */  
+#define AVALANCHE_UART0_REGS_BASE             (KSEG1ADDR(0x08610E00)) /* AVALANCHE UART 0 */
+#define AVALANCHE_UART1_REGS_BASE             (KSEG1ADDR(0x08610F00)) /* AVALANCHE UART 0 */
+#define AVALANCHE_I2C_BASE                    (KSEG1ADDR(0x08611000)) /* AVALANCHE I2C */
+#define AVALANCHE_USB_SLAVE_CONTROL_BASE      (KSEG1ADDR(0x08611200)) /* AVALANCHE USB DMA */
+#define AVALANCHE_MCDMA0_CTRL_BASE            (KSEG1ADDR(0x08611400)) /* AVALANCHE MC DMA 0 (channels 0-3) */
+#define AVALANCHE_RESET_CONTROL_BASE          (KSEG1ADDR(0x08611600)) /* AVALANCHE Reset Control */
+#define AVALANCHE_BIST_CONTROL_BASE           (KSEG1ADDR(0x08611700)) /* AVALANCHE BIST Control */
+#define AVALANCHE_LOW_VLYNQ_CONTROL_BASE      (KSEG1ADDR(0x08611800)) /* AVALANCHE VLYNQ0 Control */
+#define AVALANCHE_DEVICE_CONFIG_LATCH_BASE    (KSEG1ADDR(0x08611A00)) /* AVALANCHE Device Config Latch */
+#define AVALANCHE_HIGH_VLYNQ_CONTROL_BASE     (KSEG1ADDR(0x08611C00)) /* AVALANCHE VLYNQ1 Control */
+#define AVALANCHE_MDIO_BASE                   (KSEG1ADDR(0x08611E00)) /* AVALANCHE MDIO    */
+#define AVALANCHE_FSER_BASE                   (KSEG1ADDR(0x08612000)) /* AVALANCHE FSER base */
+#define AVALANCHE_INTC_BASE                   (KSEG1ADDR(0x08612400)) /* AVALANCHE INTC  */
+#define AVALANCHE_HIGH_CPMAC_BASE             (KSEG1ADDR(0x08612800)) /* AVALANCHE CPMAC 1 */
+#define AVALANCHE_HIGH_VLYNQ_MEM_MAP_BASE     (KSEG1ADDR(0x0C000000)) /* AVALANCHE VLYNQ 1 Mem map */
+
+#define AVALANCHE_SDRAM_BASE                  0x14000000UL
+
+
+/*----------------------------------------------------
+ * Sangam Interrupt Map (Primary Interrupts)
+ *--------------------------------------------------*/
+
+#define AVALANCHE_UNIFIED_SECONDARY_INT            0
+#define AVALANCHE_EXT_INT_0                        1
+#define AVALANCHE_EXT_INT_1                        2
+/* Line#  3 to 4 are reserved                            */
+#define AVALANCHE_TIMER_0_INT                      5
+#define AVALANCHE_TIMER_1_INT                      6
+#define AVALANCHE_UART0_INT                        7
+#define AVALANCHE_UART1_INT                        8
+#define AVALANCHE_DMA_INT0                         9
+#define AVALANCHE_DMA_INT1                        10
+/* Line# 11 to 14 are reserved                    */
+#define AVALANCHE_ATM_SAR_INT                     15
+/* Line# 16 to 18 are reserved                    */
+#define AVALANCHE_LOW_CPMAC_INT                   19
+/* Line# 20 is reserved                           */
+#define AVALANCHE_LOW_VLYNQ_INT                   21
+#define AVALANCHE_CODEC_WAKEUP_INT                22
+/* Line# 23 is reserved                           */
+#define AVALANCHE_USB_SLAVE_INT                   24
+#define AVALANCHE_HIGH_VLYNQ_INT                  25
+/* Line# 26 to 27 are reserved                    */
+#define AVALANCHE_UNIFIED_PHY_INT                 28
+#define AVALANCHE_I2C_INT                         29
+#define AVALANCHE_DMA_INT2                        30
+#define AVALANCHE_DMA_INT3                        31
+/* Line# 32 is reserved                           */
+#define AVALANCHE_HIGH_CPMAC_INT                  33
+/* Line# 34 to 36 is reserved                     */
+#define AVALANCHE_VDMA_VT_RX_INT                  37
+#define AVALANCHE_VDMA_VT_TX_INT                  38
+#define AVALANCHE_ADSL_SUB_SYSTEM_INT             39
+
+
+#define AVALANCHE_EMIF_INT                        47
+
+
+
+/*-----------------------------------------------------------
+ * Sangam's Reset Bits
+ *---------------------------------------------------------*/
+
+#define AVALANCHE_UART0_RESET_BIT                  0
+#define AVALANCHE_UART1_RESET_BIT                  1
+#define AVALANCHE_I2C_RESET_BIT                    2
+#define AVALANCHE_TIMER0_RESET_BIT                 3
+#define AVALANCHE_TIMER1_RESET_BIT                 4
+/* Reset bit  5 is reserved.                       */
+#define AVALANCHE_GPIO_RESET_BIT                   6
+#define AVALANCHE_ADSL_SUB_SYS_RESET_BIT           7
+#define AVALANCHE_USB_SLAVE_RESET_BIT              8
+#define AVALANCHE_ATM_SAR_RESET_BIT                9
+/* Reset bit 10 is reserved.                      */
+#define AVALANCHE_VDMA_VT_RESET_BIT               11
+#define AVALANCHE_FSER_RESET_BIT                  12
+/* Reset bit 13 to 15 are reserved                */
+#define AVALANCHE_HIGH_VLYNQ_RESET_BIT            16
+#define AVALANCHE_LOW_CPMAC_RESET_BIT             17
+#define AVALANCHE_MCDMA_RESET_BIT                 18
+#define AVALANCHE_BIST_RESET_BIT                  19
+#define AVALANCHE_LOW_VLYNQ_RESET_BIT             20
+#define AVALANCHE_HIGH_CPMAC_RESET_BIT            21
+#define AVALANCHE_MDIO_RESET_BIT                  22
+#define AVALANCHE_ADSL_SUB_SYS_DSP_RESET_BIT      23
+/* Reset bit 24 to 25 are reserved                */
+#define AVALANCHE_LOW_EPHY_RESET_BIT              26
+/* Reset bit 27 to 31 are reserved                */
+
+
+#define AVALANCHE_POWER_MODULE_USBSP               0
+#define AVALANCHE_POWER_MODULE_WDTP                1
+#define AVALANCHE_POWER_MODULE_UT0P                2
+#define AVALANCHE_POWER_MODULE_UT1P                3
+#define AVALANCHE_POWER_MODULE_IICP                4
+#define AVALANCHE_POWER_MODULE_VDMAP               5
+#define AVALANCHE_POWER_MODULE_GPIOP               6
+#define AVALANCHE_POWER_MODULE_VLYNQ1P             7
+#define AVALANCHE_POWER_MODULE_SARP                8
+#define AVALANCHE_POWER_MODULE_ADSLP               9
+#define AVALANCHE_POWER_MODULE_EMIFP              10
+#define AVALANCHE_POWER_MODULE_ADSPP              12
+#define AVALANCHE_POWER_MODULE_RAMP               13
+#define AVALANCHE_POWER_MODULE_ROMP               14
+#define AVALANCHE_POWER_MODULE_DMAP               15
+#define AVALANCHE_POWER_MODULE_BISTP              16
+#define AVALANCHE_POWER_MODULE_TIMER0P            18
+#define AVALANCHE_POWER_MODULE_TIMER1P            19
+#define AVALANCHE_POWER_MODULE_EMAC0P             20
+#define AVALANCHE_POWER_MODULE_EMAC1P             22
+#define AVALANCHE_POWER_MODULE_EPHYP              24
+#define AVALANCHE_POWER_MODULE_VLYNQ0P            27
+
+
+
+
+
+/*
+ * Sangam board vectors
+ */
+
+#define AVALANCHE_VECS       (KSEG1ADDR(AVALANCHE_SDRAM_BASE))
+#define AVALANCHE_VECS_KSEG0 (KSEG0ADDR(AVALANCHE_SDRAM_BASE))
+
+/*-----------------------------------------------------------------------------
+ * Sangam's system register.
+ * 
+ *---------------------------------------------------------------------------*/
+#define AVALANCHE_DCL_BOOTCR          (KSEG1ADDR(0x08611A00))
+#define AVALANCHE_EMIF_SDRAM_CFG      (AVALANCHE_EMIF_CONTROL_BASE + 0x8)
+#define AVALANCHE_RST_CTRL_PRCR       (KSEG1ADDR(0x08611600))
+#define AVALANCHE_RST_CTRL_SWRCR      (KSEG1ADDR(0x08611604))
+#define AVALANCHE_RST_CTRL_RSR        (KSEG1ADDR(0x08611600))
+
+#define AVALANCHE_POWER_CTRL_PDCR     (KSEG1ADDR(0x08610A00))
+#define AVALANCHE_WAKEUP_CTRL_WKCR    (KSEG1ADDR(0x08610A0C))
+
+#define AVALANCHE_GPIO_DATA_IN        (AVALANCHE_GPIO_BASE +  0x0)
+#define AVALANCHE_GPIO_DATA_OUT       (AVALANCHE_GPIO_BASE +  0x4)
+#define AVALANCHE_GPIO_DIR            (AVALANCHE_GPIO_BASE +  0x8)    
+#define AVALANCHE_GPIO_ENBL           (AVALANCHE_GPIO_BASE +  0xC)
+#define AVALANCHE_CVR                 (AVALANCHE_GPIO_BASE +  0x14)
+
+/*
+ * Yamon Prom print address.
+ */
+#define AVALANCHE_YAMON_FUNCTION_BASE             (KSEG1ADDR(0x10000500))
+#define AVALANCHE_YAMON_PROM_PRINT_COUNT_ADDR     (AVALANCHE_YAMON_FUNCTION_BASE + 0x4)  /* print_count function */
+#define AVALANCHE_YAMON_PROM_PRINT_ADDR           (AVALANCHE_YAMON_FUNCTION_BASE + 0x34)
+
+#define AVALANCHE_BASE_BAUD       ( 3686400 / 16 )
+
+#define  AVALANCHE_GPIO_PIN_COUNT         32             
+#define  AVALANCHE_GPIO_OFF_MAP           {0xF34FFFC0} 
+
+#include "sangam_boards.h"
+
+#endif /*_SANGAM_H_ */
diff -urN linux.old/include/asm-mips/ar7/sangam_boards.h linux.dev/include/asm-mips/ar7/sangam_boards.h
--- linux.old/include/asm-mips/ar7/sangam_boards.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/sangam_boards.h	2005-11-10 01:10:46.071588750 +0100
@@ -0,0 +1,77 @@
+#ifndef _SANGAM_BOARDS_H
+#define _SANGAM_BOARDS_H
+
+// Let us define board specific information here. 
+
+
+#if defined(CONFIG_AR7DB)
+
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x55555555  
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+
+#endif
+
+
+#if defined(CONFIG_AR7RD)
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x2
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+#endif
+
+
+#if defined(CONFIG_AR7WI)
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x2
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+#endif
+
+
+#if defined(CONFIG_AR7V)
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x2
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+#endif
+
+
+#if defined(CONFIG_AR7WRD) 
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x00010000
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+#endif
+
+
+#if defined(CONFIG_AR7VWI) 
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x00010000
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+#endif
+
+
+#if defined CONFIG_SEAD2
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0xAAAAAAAA
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x55555555
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0
+#include <asm/mips-boards/sead.h>
+#endif
+
+
+#endif
diff -urN linux.old/include/asm-mips/ar7/tnetd73xx.h linux.dev/include/asm-mips/ar7/tnetd73xx.h
--- linux.old/include/asm-mips/ar7/tnetd73xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/tnetd73xx.h	2005-11-10 01:10:46.075589000 +0100
@@ -0,0 +1,338 @@
+/******************************************************************************
+ * FILE PURPOSE:    TNETD73xx Common Header File
+ ******************************************************************************
+ * FILE NAME:       tnetd73xx.h
+ *
+ * DESCRIPTION:     shared typedef's, constants and API for TNETD73xx
+ *
+ * REVISION HISTORY:
+ * 27 Nov 02 - PSP TII  
+ *
+ * (C) Copyright 2002, Texas Instruments, Inc
+ *******************************************************************************/
+
+/*
+ *
+ *
+ *   These are const, typedef, and api definitions for tnetd73xx.
+ *
+ *   NOTES:
+ *   1. This file may be included into both C and Assembly files.
+ *       - for .s files, please do #define _ASMLANGUAGE in your ASM file to
+ *           avoid C data types (typedefs) below;
+ *       - for .c files, you don't have to do anything special.
+ *
+ *   2. This file has a number of sections for each SOC subsystem. When adding
+ *       a new constant, find the subsystem you are working on and follow the
+ *       name pattern. If you are adding another typedef for your interface, please,
+ *       place it with other typedefs and function prototypes.
+ *
+ *   3. Please, DO NOT add any macros or types that are local to a subsystem to avoid
+ *       cluttering. Include such items directly into the module's .c file or have a
+ *       local .h file to pass data between smaller modules. This file defines only
+ *       shared items.
+ */
+
+#ifndef __TNETD73XX_H__
+#define __TNETD73XX_H__
+
+#ifndef _ASMLANGUAGE        /* This part not for assembly language */
+
+extern unsigned int tnetd73xx_mips_freq;
+extern unsigned int tnetd73xx_vbus_freq;
+
+#include "tnetd73xx_err.h"
+
+#endif /* _ASMLANGUAGE */
+
+
+/*******************************************************************************************
+*   Emerald core specific
+******************************************************************************************** */
+
+#ifdef  BIG_ENDIAN
+#elif defined(LITTLE_ENDIAN)
+#else
+#error Need to define endianism
+#endif
+
+#ifndef KSEG_MSK
+#define KSEG_MSK                    0xE0000000 /* Most significant 3 bits denote kseg choice */
+#endif
+
+#ifndef KSEG_INV_MASK
+#define KSEG_INV_MASK               0x1FFFFFFF /* Inverted mask for kseg address */
+#endif
+
+#ifndef KSEG0_BASE
+#define KSEG0_BASE                  0x80000000
+#endif
+
+#ifndef KSEG1_BASE
+#define KSEG1_BASE                  0xA0000000
+#endif
+
+#ifndef KSEG0
+#define KSEG0(addr)                 (((__u32)(addr) & ~KSEG_MSK) | KSEG0_BASE)
+#endif
+
+#ifndef KSEG1
+#define KSEG1(addr)                 (((__u32)(addr) & ~KSEG_MSK) | KSEG1_BASE)
+#endif
+
+#ifndef KUSEG
+#define KUSEG(addr)                 ((__u32)(addr) & ~KSEG_MSK)
+#endif
+
+#ifndef PHYS_ADDR
+#define PHYS_ADDR(addr)             ((addr) & KSEG_INV_MASK)
+#endif
+
+#ifndef PHYS_TO_K0
+#define PHYS_TO_K0(addr)            (PHYS_ADDR(addr)|KSEG0_BASE)
+#endif
+
+#ifndef PHYS_TO_K1
+#define PHYS_TO_K1(addr)            (PHYS_ADDR(addr)|KSEG1_BASE)
+#endif
+
+#ifndef REG8_ADDR
+#define REG8_ADDR(addr)             (volatile __u8 *)(PHYS_TO_K1(addr))
+#define REG8_DATA(addr)             (*(volatile __u8 *)(PHYS_TO_K1(addr)))
+#define REG8_WRITE(addr, data)      REG8_DATA(addr) = data;
+#define REG8_READ(addr, data)       data = (__u8) REG8_DATA(addr);
+#endif
+
+#ifndef REG16_ADDR
+#define REG16_ADDR(addr)            (volatile __u16 *)(PHYS_TO_K1(addr))
+#define REG16_DATA(addr)            (*(volatile __u16 *)(PHYS_TO_K1(addr)))
+#define REG16_WRITE(addr, data)     REG16_DATA(addr) = data;
+#define REG16_READ(addr, data)      data = (__u16) REG16_DATA(addr);
+#endif
+
+#ifndef REG32_ADDR
+#define REG32_ADDR(addr)            (volatile __u32 *)(PHYS_TO_K1(addr))
+#define REG32_DATA(addr)            (*(volatile __u32 *)(PHYS_TO_K1(addr)))
+#define REG32_WRITE(addr, data)     REG32_DATA(addr) = data;
+#define REG32_READ(addr, data)      data = (__u32) REG32_DATA(addr);
+#endif
+
+#ifdef  _LINK_KSEG0_                /* Application is linked into KSEG0 space */
+#define VIRT_ADDR(addr)             PHYS_TO_K0(PHYS_ADDR(addr))
+#endif
+
+#ifdef  _LINK_KSEG1_                /* Application is linked into KSEG1 space */
+#define VIRT_ADDR(addr)             PHYS_TO_K1(PHYS_ADDR(addr))
+#endif
+
+#if !defined(_LINK_KSEG0_) && !defined(_LINK_KSEG1_)
+#error  You must define _LINK_KSEG0_ or _LINK_KSEG1_ to compile the code.
+#endif
+
+/* TNETD73XX chip definations */
+
+#define FREQ_1MHZ                       1000000
+#define TNETD73XX_MIPS_FREQ             tnetd73xx_mips_freq /* CPU clock frequency */
+#define TNETD73XX_VBUS_FREQ             tnetd73xx_vbus_freq /* originally (TNETD73XX_MIPS_FREQ/2) */
+
+#ifdef AR7SEAD2
+#define TNETD73XX_MIPS_FREQ_DEFAULT     25000000       /* 25 Mhz for sead2 board crystal */
+#else
+#define TNETD73XX_MIPS_FREQ_DEFAULT     125000000      /* 125 Mhz */
+#endif
+#define TNETD73XX_VBUS_FREQ_DEFAULT     (TNETD73XX_MIPS_FREQ_DEFAULT / 2) /* Sync mode */
+
+
+
+/* Module base addresses */
+#define TNETD73XX_ADSLSS_BASE               PHYS_TO_K1(0x01000000)      /* ADSLSS Module */
+#define TNETD73XX_BBIF_CTRL_BASE            PHYS_TO_K1(0x02000000)      /* BBIF Control */
+#define TNETD73XX_ATMSAR_BASE               PHYS_TO_K1(0x03000000)      /* ATM SAR */
+#define TNETD73XX_USB_BASE                  PHYS_TO_K1(0x03400000)      /* USB Module */
+#define TNETD73XX_VLYNQ0_BASE               PHYS_TO_K1(0x04000000)      /* VLYNQ0 Module */
+#define TNETD73xx_EMAC0_BASE                PHYS_TO_K1(0x08610000)      /* EMAC0 Module*/
+#define TNETD73XX_EMIF_BASE                 PHYS_TO_K1(0x08610800)      /* EMIF Module */
+#define TNETD73XX_GPIO_BASE                 PHYS_TO_K1(0x08610900)      /* GPIO control */
+#define TNETD73XX_CLOCK_CTRL_BASE           PHYS_TO_K1(0x08610A00)      /* Clock Control */
+#define TNETD73XX_WDTIMER_BASE              PHYS_TO_K1(0x08610B00)      /* WDTIMER Module */
+#define TNETD73XX_TIMER0_BASE               PHYS_TO_K1(0x08610C00)      /* TIMER0 Module */
+#define TNETD73XX_TIMER1_BASE               PHYS_TO_K1(0x08610D00)      /* TIMER1 Module */
+#define TNETD73XX_UARTA_BASE                PHYS_TO_K1(0x08610E00)      /* UART A */
+#define TNETD73XX_UARTB_BASE                PHYS_TO_K1(0x08610F00)      /* UART B */
+#define TNETD73XX_I2C_BASE                  PHYS_TO_K1(0x08611000)      /* I2C Module */
+#define TNETD73XX_USB_DMA_BASE              PHYS_TO_K1(0x08611200)      /* USB Module */
+#define TNETD73XX_MCDMA_BASE                PHYS_TO_K1(0x08611400)      /* MC-DMA */
+#define TNETD73xx_VDMAVT_BASE               PHYS_TO_K1(0x08611500)      /* VDMAVT Control */
+#define TNETD73XX_RST_CTRL_BASE             PHYS_TO_K1(0x08611600)      /* Reset Control */
+#define TNETD73xx_BIST_CTRL_BASE            PHYS_TO_K1(0x08611700)      /* BIST Control */
+#define TNETD73xx_VLYNQ0_CTRL_BASE          PHYS_TO_K1(0x08611800)      /* VLYNQ0 Control */
+#define TNETD73XX_DCL_BASE                  PHYS_TO_K1(0x08611A00)      /* Device Configuration Latch */
+#define TNETD73xx_VLYNQ1_CTRL_BASE          PHYS_TO_K1(0x08611C00)      /* VLYNQ1 Control */
+#define TNETD73xx_MDIO_BASE                 PHYS_TO_K1(0x08611E00)      /* MDIO Control */
+#define TNETD73XX_FSER_BASE                 PHYS_TO_K1(0x08612000)      /* FSER Control */
+#define TNETD73XX_INTC_BASE                 PHYS_TO_K1(0x08612400)      /* Interrupt Controller */
+#define TNETD73xx_EMAC1_BASE                PHYS_TO_K1(0x08612800)      /* EMAC1 Module*/
+#define TNETD73XX_VLYNQ1_BASE               PHYS_TO_K1(0x0C000000)      /* VLYNQ1 Module */
+
+/* BBIF Registers */
+#define TNETD73XX_BBIF_ADSLADR              (TNETD73XX_BBIF_CTRL_BASE + 0x0)
+
+/* Device Configuration Latch Registers */
+#define TNETD73XX_DCL_BOOTCR                (TNETD73XX_DCL_BASE + 0x0)
+#define TNETD73XX_DCL_DPLLSELR              (TNETD73XX_DCL_BASE + 0x10)
+#define TNETD73XX_DCL_SPEEDCTLR             (TNETD73XX_DCL_BASE + 0x14)
+#define TNETD73XX_DCL_SPEEDPWDR             (TNETD73XX_DCL_BASE + 0x18)
+#define TNETD73XX_DCL_SPEEDCAPR             (TNETD73XX_DCL_BASE + 0x1C)
+
+/* GPIO Control */
+#define TNETD73XX_GPIODINR                  (TNETD73XX_GPIO_BASE + 0x0)
+#define TNETD73XX_GPIODOUTR                 (TNETD73XX_GPIO_BASE + 0x4)
+#define TNETD73XX_GPIOPDIRR                 (TNETD73XX_GPIO_BASE + 0x8)
+#define TNETD73XX_GPIOENR                   (TNETD73XX_GPIO_BASE + 0xC)
+#define TNETD73XX_CVR                       (TNETD73XX_GPIO_BASE + 0x14)
+#define TNETD73XX_DIDR1                     (TNETD73XX_GPIO_BASE + 0x18)
+#define TNETD73XX_DIDR2                     (TNETD73XX_GPIO_BASE + 0x1C)
+
+/* Reset Control  */
+#define TNETD73XX_RST_CTRL_PRCR             (TNETD73XX_RST_CTRL_BASE + 0x0)
+#define TNETD73XX_RST_CTRL_SWRCR            (TNETD73XX_RST_CTRL_BASE + 0x4)
+#define TNETD73XX_RST_CTRL_RSR              (TNETD73XX_RST_CTRL_BASE + 0x8)
+
+/* Power Control  */
+#define TNETD73XX_POWER_CTRL_PDCR           (TNETD73XX_CLOCK_CTRL_BASE + 0x0)
+#define TNETD73XX_POWER_CTRL_PCLKCR         (TNETD73XX_CLOCK_CTRL_BASE + 0x4)
+#define TNETD73XX_POWER_CTRL_PDUCR          (TNETD73XX_CLOCK_CTRL_BASE + 0x8)
+#define TNETD73XX_POWER_CTRL_WKCR           (TNETD73XX_CLOCK_CTRL_BASE + 0xC)
+
+/* Clock Control */
+#define TNETD73XX_CLK_CTRL_SCLKCR           (TNETD73XX_CLOCK_CTRL_BASE + 0x20)
+#define TNETD73XX_CLK_CTRL_SCLKPLLCR        (TNETD73XX_CLOCK_CTRL_BASE + 0x30)
+#define TNETD73XX_CLK_CTRL_MCLKCR           (TNETD73XX_CLOCK_CTRL_BASE + 0x40)
+#define TNETD73XX_CLK_CTRL_MCLKPLLCR        (TNETD73XX_CLOCK_CTRL_BASE + 0x50)
+#define TNETD73XX_CLK_CTRL_UCLKCR           (TNETD73XX_CLOCK_CTRL_BASE + 0x60)
+#define TNETD73XX_CLK_CTRL_UCLKPLLCR        (TNETD73XX_CLOCK_CTRL_BASE + 0x70)
+#define TNETD73XX_CLK_CTRL_ACLKCR0          (TNETD73XX_CLOCK_CTRL_BASE + 0x80)
+#define TNETD73XX_CLK_CTRL_ACLKPLLCR0       (TNETD73XX_CLOCK_CTRL_BASE + 0x90)
+#define TNETD73XX_CLK_CTRL_ACLKCR1          (TNETD73XX_CLOCK_CTRL_BASE + 0xA0)
+#define TNETD73XX_CLK_CTRL_ACLKPLLCR1       (TNETD73XX_CLOCK_CTRL_BASE + 0xB0)
+
+/* EMIF control */
+#define TNETD73XX_EMIF_SDRAM_CFG              ( TNETD73XX_EMIF_BASE + 0x08 )                
+
+/* UART */
+#ifdef AR7SEAD2
+#define TNETD73XX_UART_FREQ                 3686400
+#else
+#define TNETD73XX_UART_FREQ                 TNETD73XX_VBUS_FREQ
+#endif
+
+/* Interrupt Controller */
+
+/* Primary interrupts */
+#define TNETD73XX_INTC_UNIFIED_SECONDARY    0   /* Unified secondary interrupt */
+#define TNETD73XX_INTC_EXTERNAL0            1   /* External Interrupt Line 0 */
+#define TNETD73XX_INTC_EXTERNAL1            2   /* External Interrupt Line 1 */
+#define TNETD73XX_INTC_RESERVED3            3   /* Reserved */
+#define TNETD73XX_INTC_RESERVED4            4   /* Reserved */
+#define TNETD73XX_INTC_TIMER0               5   /* TIMER 0 int */
+#define TNETD73XX_INTC_TIMER1               6   /* TIMER 1 int */
+#define TNETD73XX_INTC_UART0                7   /* UART 0 int */
+#define TNETD73XX_INTC_UART1                8   /* UART 1 int */
+#define TNETD73XX_INTC_MCDMA0               9   /* MCDMA 0 int */
+#define TNETD73XX_INTC_MCDMA1               10  /* MCDMA 1 int */
+#define TNETD73XX_INTC_RESERVED11           11  /* Reserved */
+#define TNETD73XX_INTC_RESERVED12           12  /* Reserved */
+#define TNETD73XX_INTC_RESERVED13           13  /* Reserved */
+#define TNETD73XX_INTC_RESERVED14           14  /* Reserved */
+#define TNETD73XX_INTC_ATMSAR               15  /* ATM SAR int */
+#define TNETD73XX_INTC_RESERVED16           16  /* Reserved */
+#define TNETD73XX_INTC_RESERVED17           17  /* Reserved */
+#define TNETD73XX_INTC_RESERVED18           18  /* Reserved */
+#define TNETD73XX_INTC_EMAC0                19  /* EMAC 0 int */
+#define TNETD73XX_INTC_RESERVED20           20  /* Reserved */
+#define TNETD73XX_INTC_VLYNQ0               21  /* VLYNQ 0 int */
+#define TNETD73XX_INTC_CODEC                22  /* CODEC int */
+#define TNETD73XX_INTC_RESERVED23           23  /* Reserved */
+#define TNETD73XX_INTC_USBSLAVE             24  /* USB Slave int */
+#define TNETD73XX_INTC_VLYNQ1               25  /* VLYNQ 1 int */
+#define TNETD73XX_INTC_RESERVED26           26  /* Reserved */
+#define TNETD73XX_INTC_RESERVED27           27  /* Reserved */
+#define TNETD73XX_INTC_ETH_PHY              28  /* Ethernet PHY   */
+#define TNETD73XX_INTC_I2C                  29  /* I2C int */
+#define TNETD73XX_INTC_MCDMA2               30  /* MCDMA 2 int */
+#define TNETD73XX_INTC_MCDMA3               31  /* MCDMA 3 int */
+#define TNETD73XX_INTC_RESERVED32           32  /* Reserved */
+#define TNETD73XX_INTC_EMAC1                33  /* EMAC 1 int */
+#define TNETD73XX_INTC_RESERVED34           34  /* Reserved */
+#define TNETD73XX_INTC_RESERVED35           35  /* Reserved */
+#define TNETD73XX_INTC_RESERVED36           36  /* Reserved */
+#define TNETD73XX_INTC_VDMAVTRX             37  /* VDMAVTRX */
+#define TNETD73XX_INTC_VDMAVTTX             38  /* VDMAVTTX */
+#define TNETD73XX_INTC_ADSLSS               39  /* ADSLSS */
+
+/* Secondary interrupts */
+#define TNETD73XX_INTC_SEC0                 40  /* Secondary */
+#define TNETD73XX_INTC_SEC1                 41  /* Secondary */
+#define TNETD73XX_INTC_SEC2                 42  /* Secondary */
+#define TNETD73XX_INTC_SEC3                 43  /* Secondary */
+#define TNETD73XX_INTC_SEC4                 44  /* Secondary */
+#define TNETD73XX_INTC_SEC5                 45  /* Secondary */
+#define TNETD73XX_INTC_SEC6                 46  /* Secondary */
+#define TNETD73XX_INTC_EMIF                 47  /* EMIF */
+#define TNETD73XX_INTC_SEC8                 48  /* Secondary */
+#define TNETD73XX_INTC_SEC9                 49  /* Secondary */
+#define TNETD73XX_INTC_SEC10                50  /* Secondary */
+#define TNETD73XX_INTC_SEC11                51  /* Secondary */
+#define TNETD73XX_INTC_SEC12                52  /* Secondary */
+#define TNETD73XX_INTC_SEC13                53  /* Secondary */
+#define TNETD73XX_INTC_SEC14                54  /* Secondary */
+#define TNETD73XX_INTC_SEC15                55  /* Secondary */
+#define TNETD73XX_INTC_SEC16                56  /* Secondary */
+#define TNETD73XX_INTC_SEC17                57  /* Secondary */
+#define TNETD73XX_INTC_SEC18                58  /* Secondary */
+#define TNETD73XX_INTC_SEC19                59  /* Secondary */
+#define TNETD73XX_INTC_SEC20                60  /* Secondary */
+#define TNETD73XX_INTC_SEC21                61  /* Secondary */
+#define TNETD73XX_INTC_SEC22                62  /* Secondary */
+#define TNETD73XX_INTC_SEC23                63  /* Secondary */
+#define TNETD73XX_INTC_SEC24                64  /* Secondary */
+#define TNETD73XX_INTC_SEC25                65  /* Secondary */
+#define TNETD73XX_INTC_SEC26                66  /* Secondary */
+#define TNETD73XX_INTC_SEC27                67  /* Secondary */
+#define TNETD73XX_INTC_SEC28                68  /* Secondary */
+#define TNETD73XX_INTC_SEC29                69  /* Secondary */
+#define TNETD73XX_INTC_SEC30                70  /* Secondary */
+#define TNETD73XX_INTC_SEC31                71  /* Secondary */
+
+/* These ugly macros are to access the -1 registers, like config1 */
+#define MFC0_SEL1_OPCODE(dst, src)\
+        .word (0x40000000 | ((dst)<<16) | ((src)<<11) | 1);\
+        nop; \
+        nop; \
+        nop
+
+#define MTC0_SEL1_OPCODE(dst, src)\
+        .word (0x40800000 | ((dst)<<16) | ((src)<<11) | 1);\
+        nop; \
+        nop; \
+        nop
+
+
+/* Below are Jade core specific */
+#define CFG0_4K_IL_MASK         0x00380000
+#define CFG0_4K_IL_SHIFT        19
+#define CFG0_4K_IA_MASK         0x00070000
+#define CFG0_4K_IA_SHIFT        16
+#define CFG0_4K_IS_MASK         0x01c00000
+#define CFG0_4K_IS_SHIFT        22
+
+#define CFG0_4K_DL_MASK         0x00001c00
+#define CFG0_4K_DL_SHIFT        10
+#define CFG0_4K_DA_MASK         0x00000380
+#define CFG0_4K_DA_SHIFT        7
+#define CFG0_4K_DS_MASK         0x0000E000
+#define CFG0_4K_DS_SHIFT        13
+
+
+
+#endif /* __TNETD73XX_H_ */
diff -urN linux.old/include/asm-mips/ar7/tnetd73xx_err.h linux.dev/include/asm-mips/ar7/tnetd73xx_err.h
--- linux.old/include/asm-mips/ar7/tnetd73xx_err.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/tnetd73xx_err.h	2005-11-10 01:10:46.075589000 +0100
@@ -0,0 +1,42 @@
+/******************************************************************************
+ * FILE PURPOSE:    TNETD73xx Error Definations Header File
+ ******************************************************************************
+ * FILE NAME:       tnetd73xx_err.h
+ *
+ * DESCRIPTION:     Error definations for TNETD73XX
+ *
+ * REVISION HISTORY:
+ * 27 Nov 02 - PSP TII  
+ *
+ * (C) Copyright 2002, Texas Instruments, Inc
+ *******************************************************************************/
+
+ 
+#ifndef __TNETD73XX_ERR_H__
+#define __TNETD73XX_ERR_H__
+
+typedef enum TNETD73XX_ERR_t
+{
+    TNETD73XX_ERR_OK        = 0,    /* OK or SUCCESS */
+    TNETD73XX_ERR_ERROR     = -1,   /* Unspecified/Generic ERROR */
+
+    /* Pointers and args */
+    TNETD73XX_ERR_INVARG        = -2,   /* Invaild argument to the call */
+    TNETD73XX_ERR_NULLPTR       = -3,   /* NULL pointer */
+    TNETD73XX_ERR_BADPTR        = -4,   /* Bad (out of mem) pointer */
+
+    /* Memory issues */
+    TNETD73XX_ERR_ALLOC_FAIL    = -10,  /* allocation failed */
+    TNETD73XX_ERR_FREE_FAIL     = -11,  /* free failed */
+    TNETD73XX_ERR_MEM_CORRUPT   = -12,  /* corrupted memory */
+    TNETD73XX_ERR_BUF_LINK      = -13,  /* buffer linking failed */
+
+    /* Device issues */
+    TNETD73XX_ERR_DEVICE_TIMEOUT    = -20,  /* device timeout on read/write */
+    TNETD73XX_ERR_DEVICE_MALFUNC    = -21,  /* device malfunction */
+
+    TNETD73XX_ERR_INVID     = -30   /* Invalid ID */
+
+} TNETD73XX_ERR;
+
+#endif /* __TNETD73XX_ERR_H__ */
diff -urN linux.old/include/asm-mips/ar7/tnetd73xx_misc.h linux.dev/include/asm-mips/ar7/tnetd73xx_misc.h
--- linux.old/include/asm-mips/ar7/tnetd73xx_misc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/tnetd73xx_misc.h	2005-11-10 01:10:46.075589000 +0100
@@ -0,0 +1,239 @@
+/******************************************************************************
+ * FILE PURPOSE:    TNETD73xx Misc modules API Header
+ ******************************************************************************
+ * FILE NAME:       tnetd73xx_misc.h
+ *
+ * DESCRIPTION:     Clock Control, Reset Control, Power Management, GPIO
+ *                  FSER Modules API 
+ *                  As per TNETD73xx specifications
+ *
+ * REVISION HISTORY:
+ * 27 Nov 02 - Sharath Kumar     PSP TII  
+ * 14 Feb 03 - Anant Gole        PSP TII
+ *
+ * (C) Copyright 2002, Texas Instruments, Inc
+ *******************************************************************************/
+
+#ifndef __TNETD73XX_MISC_H__
+#define __TNETD73XX_MISC_H__
+
+/*****************************************************************************
+ * Reset Control Module
+ *****************************************************************************/
+ 
+typedef enum TNETD73XX_RESET_MODULE_tag
+{
+    RESET_MODULE_UART0      = 0,
+    RESET_MODULE_UART1      = 1,
+    RESET_MODULE_I2C        = 2,
+    RESET_MODULE_TIMER0     = 3,
+    RESET_MODULE_TIMER1     = 4,
+    RESET_MODULE_GPIO       = 6,
+    RESET_MODULE_ADSLSS     = 7,
+    RESET_MODULE_USBS       = 8,
+    RESET_MODULE_SAR        = 9,
+    RESET_MODULE_VDMA_VT    = 11,
+    RESET_MODULE_FSER       = 12,
+    RESET_MODULE_VLYNQ1     = 16,
+    RESET_MODULE_EMAC0      = 17,
+    RESET_MODULE_DMA        = 18,
+    RESET_MODULE_BIST       = 19,
+    RESET_MODULE_VLYNQ0     = 20,
+    RESET_MODULE_EMAC1      = 21,
+    RESET_MODULE_MDIO       = 22,
+    RESET_MODULE_ADSLSS_DSP = 23,
+    RESET_MODULE_EPHY       = 26
+} TNETD73XX_RESET_MODULE_T;
+
+typedef enum TNETD73XX_RESET_CTRL_tag
+{
+    IN_RESET        = 0,
+    OUT_OF_RESET
+} TNETD73XX_RESET_CTRL_T;
+
+typedef enum TNETD73XX_SYS_RST_MODE_tag
+{
+    RESET_SOC_WITH_MEMCTRL      = 1,    /* SW0 bit in SWRCR register */
+    RESET_SOC_WITHOUT_MEMCTRL   = 2     /* SW1 bit in SWRCR register */
+} TNETD73XX_SYS_RST_MODE_T;
+
+typedef enum TNETD73XX_SYS_RESET_STATUS_tag
+{
+    HARDWARE_RESET = 0,
+    SOFTWARE_RESET0,            /* Caused by writing 1 to SW0 bit in SWRCR register */
+    WATCHDOG_RESET,
+    SOFTWARE_RESET1             /* Caused by writing 1 to SW1 bit in SWRCR register */
+} TNETD73XX_SYS_RESET_STATUS_T;
+
+void tnetd73xx_reset_ctrl(TNETD73XX_RESET_MODULE_T reset_module, 
+                                TNETD73XX_RESET_CTRL_T reset_ctrl);
+TNETD73XX_RESET_CTRL_T tnetd73xx_get_reset_status(TNETD73XX_RESET_MODULE_T reset_module);
+void tnetd73xx_sys_reset(TNETD73XX_SYS_RST_MODE_T mode);
+TNETD73XX_SYS_RESET_STATUS_T tnetd73xx_get_sys_last_reset_status(void);
+                    
+/*****************************************************************************
+ * Power Control Module
+ *****************************************************************************/
+
+typedef enum TNETD73XX_POWER_MODULE_tag
+{
+    POWER_MODULE_USBSP      = 0,
+    POWER_MODULE_WDTP       = 1,
+    POWER_MODULE_UT0P       = 2,
+    POWER_MODULE_UT1P       = 3,
+    POWER_MODULE_IICP       = 4,
+    POWER_MODULE_VDMAP      = 5,
+    POWER_MODULE_GPIOP      = 6,
+    POWER_MODULE_VLYNQ1P    = 7,
+    POWER_MODULE_SARP       = 8,
+    POWER_MODULE_ADSLP      = 9,
+    POWER_MODULE_EMIFP      = 10,
+    POWER_MODULE_ADSPP      = 12,
+    POWER_MODULE_RAMP       = 13,
+    POWER_MODULE_ROMP       = 14,
+    POWER_MODULE_DMAP       = 15,
+    POWER_MODULE_BISTP      = 16,
+    POWER_MODULE_TIMER0P    = 18,
+    POWER_MODULE_TIMER1P    = 19,
+    POWER_MODULE_EMAC0P     = 20,
+    POWER_MODULE_EMAC1P     = 22,
+    POWER_MODULE_EPHYP      = 24,
+    POWER_MODULE_VLYNQ0P    = 27,
+} TNETD73XX_POWER_MODULE_T;
+
+typedef enum TNETD73XX_POWER_CTRL_tag
+{
+    POWER_CTRL_POWER_UP = 0,
+    POWER_CTRL_POWER_DOWN
+} TNETD73XX_POWER_CTRL_T;
+
+typedef enum TNETD73XX_SYS_POWER_MODE_tag
+{
+    GLOBAL_POWER_MODE_RUN       = 0,    /* All system is up */
+    GLOBAL_POWER_MODE_IDLE,             /* MIPS is power down, all peripherals working */
+    GLOBAL_POWER_MODE_STANDBY,          /* Chip in power down, but clock to ADSKL subsystem is running */
+    GLOBAL_POWER_MODE_POWER_DOWN        /* Total chip is powered down */
+} TNETD73XX_SYS_POWER_MODE_T;
+
+void tnetd73xx_power_ctrl(TNETD73XX_POWER_MODULE_T power_module,  TNETD73XX_POWER_CTRL_T power_ctrl);
+TNETD73XX_POWER_CTRL_T tnetd73xx_get_pwr_status(TNETD73XX_POWER_MODULE_T power_module);
+void tnetd73xx_set_global_pwr_mode(TNETD73XX_SYS_POWER_MODE_T power_mode);
+TNETD73XX_SYS_POWER_MODE_T tnetd73xx_get_global_pwr_mode(void);
+
+/*****************************************************************************
+ * Wakeup Control 
+ *****************************************************************************/
+
+typedef enum TNETD73XX_WAKEUP_INTERRUPT_tag
+{
+    WAKEUP_INT0 = 1,
+    WAKEUP_INT1 = 2,
+    WAKEUP_INT2 = 4,
+    WAKEUP_INT3 = 8
+} TNETD73XX_WAKEUP_INTERRUPT_T;
+
+typedef enum TNETD73XX_WAKEUP_CTRL_tag
+{
+    WAKEUP_DISABLED = 0,
+    WAKEUP_ENABLED
+} TNETD73XX_WAKEUP_CTRL_T;
+
+typedef enum TNETD73XX_WAKEUP_POLARITY_tag
+{
+    WAKEUP_ACTIVE_HIGH = 0,
+    WAKEUP_ACTIVE_LOW
+} TNETD73XX_WAKEUP_POLARITY_T;
+
+void tnetd73xx_wakeup_ctrl(TNETD73XX_WAKEUP_INTERRUPT_T wakeup_int, 
+                           TNETD73XX_WAKEUP_CTRL_T wakeup_ctrl, 
+                           TNETD73XX_WAKEUP_POLARITY_T wakeup_polarity);
+
+/*****************************************************************************
+ * FSER  Control 
+ *****************************************************************************/
+ 
+typedef enum TNETD73XX_FSER_MODE_tag
+{
+    FSER_I2C    = 0,
+    FSER_UART   = 1
+} TNETD73XX_FSER_MODE_T;
+
+void tnetd73xx_fser_ctrl(TNETD73XX_FSER_MODE_T fser_mode);
+
+/*****************************************************************************
+ * Clock Control 
+ *****************************************************************************/
+
+#define CLK_MHZ(x)    ( (x) * 1000000 )
+
+typedef enum TNETD73XX_CLKC_ID_tag
+{
+    CLKC_SYS = 0,
+    CLKC_MIPS,
+    CLKC_USB,
+    CLKC_ADSLSS
+} TNETD73XX_CLKC_ID_T;
+
+void tnetd73xx_clkc_init(__u32 afeclk, __u32 refclk, __u32 xtal3in);
+TNETD73XX_ERR tnetd73xx_clkc_set_freq(TNETD73XX_CLKC_ID_T clk_id, __u32 output_freq);
+__u32 tnetd73xx_clkc_get_freq(TNETD73XX_CLKC_ID_T clk_id);
+
+/*****************************************************************************
+ * GPIO Control 
+ *****************************************************************************/
+
+typedef enum TNETD73XX_GPIO_PIN_tag
+{
+    GPIO_UART0_RD           = 0,
+    GPIO_UART0_TD           = 1,
+    GPIO_UART0_RTS          = 2,
+    GPIO_UART0_CTS          = 3,
+    GPIO_FSER_CLK           = 4,
+    GPIO_FSER_D             = 5,
+    GPIO_EXT_AFE_SCLK       = 6,
+    GPIO_EXT_AFE_TX_FS      = 7,
+    GPIO_EXT_AFE_TXD        = 8,
+    GPIO_EXT_AFE_RS_FS      = 9,
+    GPIO_EXT_AFE_RXD1       = 10,
+    GPIO_EXT_AFE_RXD0       = 11,
+    GPIO_EXT_AFE_CDIN       = 12,
+    GPIO_EXT_AFE_CDOUT      = 13,
+    GPIO_EPHY_SPEED100      = 14,
+    GPIO_EPHY_LINKON        = 15,
+    GPIO_EPHY_ACTIVITY      = 16,
+    GPIO_EPHY_FDUPLEX       = 17,
+    GPIO_EINT0              = 18,
+    GPIO_EINT1              = 19,
+    GPIO_MBSP0_TCLK         = 20,
+    GPIO_MBSP0_RCLK         = 21,
+    GPIO_MBSP0_RD           = 22,
+    GPIO_MBSP0_TD           = 23,
+    GPIO_MBSP0_RFS          = 24,
+    GPIO_MBSP0_TFS          = 25,
+    GPIO_MII_DIO            = 26,
+    GPIO_MII_DCLK           = 27,
+} TNETD73XX_GPIO_PIN_T;
+
+typedef enum TNETD73XX_GPIO_PIN_MODE_tag
+{
+    FUNCTIONAL_PIN = 0,
+    GPIO_PIN = 1
+} TNETD73XX_GPIO_PIN_MODE_T;
+
+typedef enum TNETD73XX_GPIO_PIN_DIRECTION_tag
+{
+    GPIO_OUTPUT_PIN = 0,
+    GPIO_INPUT_PIN = 1
+} TNETD73XX_GPIO_PIN_DIRECTION_T;
+ 
+void tnetd73xx_gpio_init(void);
+void tnetd73xx_gpio_ctrl(TNETD73XX_GPIO_PIN_T gpio_pin, 
+                         TNETD73XX_GPIO_PIN_MODE_T pin_mode,
+                         TNETD73XX_GPIO_PIN_DIRECTION_T pin_direction);
+void tnetd73xx_gpio_out(TNETD73XX_GPIO_PIN_T gpio_pin, int value);
+int tnetd73xx_gpio_in(TNETD73XX_GPIO_PIN_T gpio_pin);
+
+/* TNETD73XX Revision */
+__u32 tnetd73xx_get_revision(void);
+
+#endif /* __TNETD73XX_MISC_H__ */
diff -urN linux.old/include/asm-mips/ar7/vlynq.h linux.dev/include/asm-mips/ar7/vlynq.h
--- linux.old/include/asm-mips/ar7/vlynq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/vlynq.h	2005-11-10 01:10:46.095590250 +0100
@@ -0,0 +1,610 @@
+/***************************************************************************
+**+----------------------------------------------------------------------+**
+**|                                ****                                  |**
+**|                                ****                                  |**
+**|                                ******o***                            |**
+**|                          ********_///_****                           |**
+**|                           ***** /_//_/ ****                          |**
+**|                            ** ** (__/ ****                           |**
+**|                                *********                             |**
+**|                                 ****                                 |**
+**|                                  ***                                 |**
+**|                                                                      |**
+**|     Copyright (c) 2003 Texas Instruments Incorporated                |**
+**|                        ALL RIGHTS RESERVED                           |**
+**|                                                                      |**
+**| Permission is hereby granted to licensees of Texas Instruments       |**
+**| Incorporated (TI) products to use this computer program for the sole |**
+**| purpose of implementing a licensee product based on TI products.     |**
+**| No other rights to reproduce, use, or disseminate this computer      |**
+**| program, whether in part or in whole, are granted.                   |**
+**|                                                                      |**
+**| TI makes no representation or warranties with respect to the         |**
+**| performance of this computer program, and specifically disclaims     |**
+**| any responsibility for any damages, special or consequential,        |**
+**| connected with the use of this program.                              |**
+**|                                                                      |**
+**+----------------------------------------------------------------------+**
+***************************************************************************/
+
+/*********************************************************************************
+ *  ------------------------------------------------------------------------------
+ *   Module      : vlynq_hal.h
+ *   Description :
+ *   This header file provides the set of functions exported by the 
+ *   VLYNQ HAL. This file is included from the SOC specific VLYNQ driver wrapper.
+ *  ------------------------------------------------------------------------------
+ *********************************************************************************/
+
+#ifndef _VLYNQ_HAL_H_
+#define _VLYNQ_HAL_H_
+
+/* Enable/Disable debug feature */
+#undef VLYNQ_DEBUG 
+
+#ifdef VLYNQ_DEBUG  /* This needs to be OS abstracted - for testing use vxworks/linux calls */
+#define debugPrint(format,args...)    
+#else 
+#define debugPrint(format,args...)  
+#endif
+
+ /* number of VLYNQ memory regions supported */
+#define VLYNQ_MAX_MEMORY_REGIONS 0x04
+  
+ /* Max.number of external interrupt inputs supported by VLYNQ module */
+#define VLYNQ_IVR_MAXIVR         0x08
+
+#define VLYNQ_CLK_DIV_MAX  0x08
+#define VLYNQ_CLK_DIV_MIN  0x01
+
+
+/*** the total number of entries allocated for ICB would be
+ * 32(for 32 bits in IntPending register) + VLYNQ_IVR_CHAIN_SLOTS*/
+#define VLYNQ_IVR_CHAIN_SLOTS 10
+
+
+/* Error defines */
+#define VLYNQ_SUCCESS               0
+
+#define VLYNQ_ERRCODE_BASE          0 /* Chosen by system */
+#define VLYNQ_INVALID_ARG          -(VLYNQ_ERRCODE_BASE+1)
+#define VLYNQ_INVALID_DRV_STATE    -(VLYNQ_ERRCODE_BASE+2)
+#define VLYNQ_INT_CONFIG_ERR       -(VLYNQ_ERRCODE_BASE+3)
+#define VLYNQ_LINK_DOWN            -(VLYNQ_ERRCODE_BASE+4)
+#define VLYNQ_MEMALLOC_FAIL        -(VLYNQ_ERRCODE_BASE+5)
+#define VLYNQ_ISR_NON_EXISTENT     -(VLYNQ_ERRCODE_BASE+6)
+#define VLYNQ_INTVEC_MAP_NOT_FOUND -(VLYNQ_ERRCODE_BASE+7)
+
+/* Vlynq Defines and Macros */
+
+#define VLYNQ_NUM_INT_BITS              32 /* 32 bit interrupt staus register */
+
+/* Base address of module */
+#define VLYNQ_BASE                      (pdev->module_base)
+
+#define VLYNQ_REMOTE_REGS_OFFSET        0x0080
+
+#define VLYNQ_REV_OFFSET                0x0000
+#define VLYNQ_CTRL_OFFSET               0x0004
+#define VLYNQ_STATUS_OFFSET             0x0008
+#define VLYNQ_INT_STAT_OFFSET           0x0010
+#define VLYNQ_INT_PEND_OFFSET           0x0014
+#define VLYNQ_INT_PTR_OFFSET            0x0018
+#define VLYNQ_TXMAP_OFFSET              0x001c
+
+#define VLYNQ_RX0MAP_SIZE_REG_OFFSET    0x0020
+#define VLYNQ_RX0MAP_OFFSET_REG_OFFSET  0x0024
+
+#define VLYNQ_CHIP_VER_OFFSET           0x0040
+#define VLYNQ_IVR_REGS_OFFSET           0x0060
+
+#define VLYNQ_INT_PENDING_REG_PTR       0x14
+#define VLYNQ_R_INT_PENDING_REG_PTR     VLYNQ_REMOTE_REGS_OFFSET + 0x14
+
+#define VLYNQ_REV_REG       *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_REV_OFFSET))
+#define VLYNQ_CTRL_REG      *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_CTRL_OFFSET))
+#define VLYNQ_STATUS_REG    *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_STATUS_OFFSET))
+#define VLYNQ_INT_STAT_REG  *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_INT_STAT_OFFSET))
+#define VLYNQ_INT_PEND_REG  *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_INT_PEND_OFFSET))
+#define VLYNQ_INT_PTR_REG   *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_INT_PTR_OFFSET))
+#define VLYNQ_TXMAP_REG     *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_TXMAP_OFFSET))
+
+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+#define VLYNQ_RXMAP_SIZE_REG(map) \
+    *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_RX0MAP_SIZE_REG_OFFSET+( (map-1)<<3)))
+    
+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+#define VLYNQ_RXMAP_OFFSET_REG(map) \
+    *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_RX0MAP_OFFSET_REG_OFFSET+( (map-1)<<3)))
+
+#define VLYNQ_CHIP_VER_REG  *((volatile unsigned int *)(VLYNQ_BASE+VLYNQ_CHIP_VER_OFFSET))
+
+/* 0 =< ivr <= 31; currently ivr < VLYNQ_IVR_MAXIVR=8) */
+#define VLYNQ_IVR_OFFSET(ivr)  \
+    (VLYNQ_BASE + VLYNQ_IVR_REGS_OFFSET +((((unsigned)(ivr)) & 31) & ~3) )
+
+#define VLYNQ_IVR_03TO00_REG  *((volatile unsigned int*) (VLYNQ_IVR_OFFSET(0)) )
+#define VLYNQ_IVR_07TO04_REG  *((volatile unsigned int*) (VLYNQ_IVR_OFFSET(4)) )
+/*** Can be extended for 11TO08...31TO28 when all 31 are supported**/
+
+#define VLYNQ_IVR_INTEN(ivr)    (((unsigned int)(0x80)) << ((((unsigned)(ivr)) % 4) * 8))
+#define VLYNQ_IVR_INTTYPE(ivr)  (((unsigned int)(0x40)) << ((((unsigned)(ivr)) % 4) * 8))
+#define VLYNQ_IVR_INTPOL(ivr)   (((unsigned int)(0x20)) << ((((unsigned)(ivr)) % 4) * 8))
+#define VLYNQ_IVR_INTVEC(ivr)   (((unsigned int)(0x1F)) << ((((unsigned)(ivr)) % 4) * 8))
+#define VLYNQ_IVR_INTALL(ivr)   (((unsigned int)(0xFF)) << ((((unsigned)(ivr)) % 4) * 8))
+
+
+
+/*********************************
+ * Remote VLYNQ register set     *
+ *********************************/
+
+#define VLYNQ_R_REV_OFFSET              0x0080
+#define VLYNQ_R_CTRL_OFFSET             0x0084
+#define VLYNQ_R_STATUS_OFFSET           0x0088
+#define VLYNQ_R_INT_STAT_OFFSET         0x0090
+#define VLYNQ_R_INT_PEND_OFFSET         0x0094
+#define VLYNQ_R_INT_PTR_OFFSET          0x0098
+#define VLYNQ_R_TXMAP_OFFSET            0x009c
+
+#define VLYNQ_R_RX0MAP_SIZE_REG_OFFSET  0x00A0
+#define VLYNQ_R_RX0MAP_OFFSET_REG_OFFSET 0x00A4
+
+#define VLYNQ_R_CHIP_VER_OFFSET         0x00C0
+#define VLYNQ_R_IVR_REGS_OFFSET         0x00E0
+
+#define VLYNQ_R_REV_REG       *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_REV_OFFSET)) 
+#define VLYNQ_R_CTRL_REG      *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_CTRL_OFFSET))
+#define VLYNQ_R_STATUS_REG    *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_STATUS_OFFSET))
+#define VLYNQ_R_INT_STAT_REG  *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_INT_STAT_OFFSET))
+#define VLYNQ_R_INT_PEND_REG  *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_INT_PEND_OFFSET))
+#define VLYNQ_R_INT_PTR_REG   *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_INT_PTR_OFFSET))
+#define VLYNQ_R_TXMAP_REG     *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_TXMAP_OFFSET))
+
+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+#define VLYNQ_R_RXMAP_SIZE_REG(map) \
+    *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_RX0MAP_SIZE_REG_OFFSET + ((map-1)<<3)))
+    
+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+#define VLYNQ_R_RXMAP_OFFSET_REG(map) \
+    *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_RX0MAP_OFFSET_REG_OFFSET + ((map-1)<<3)))
+
+#define VLYNQ_R_CHIP_VER_REG  *((volatile unsigned int *)(VLYNQ_BASE + VLYNQ_R_CHIP_VER_OFFSET)
+
+#define VLYNQ_R_IVR_OFFSET(ivr)  \
+    (VLYNQ_BASE + VLYNQ_R_IVR_REGS_OFFSET +((((unsigned)(ivr)) & 31) & ~3))
+ 
+
+/*** Can be extended for 11TO08...31TO28 when all 31 are supported**/
+#define VLYNQ_R_IVR_03TO00_REG  *((volatile unsigned int*) (VLYNQ_R_IVR_OFFSET(0)) )
+#define VLYNQ_R_IVR_07TO04_REG  *((volatile unsigned int*) (VLYNQ_R_IVR_OFFSET(4)) )
+
+
+/****End of remote register set definition******/
+
+
+/*** Masks for individual register fields ***/
+
+#define VLYNQ_MODULE_ID_MASK        0xffff0000
+#define VLYNQ_MAJOR_REV_MASK        0x0000ff00
+#define VLYNQ_MINOR_REV_MASK        0x000000ff
+
+    
+#define VLYNQ_CTL_ILOOP_MASK        0x00000002
+#define VLYNQ_CTL_INT2CFG_MASK      0x00000080
+#define VLYNQ_CTL_INTVEC_MASK       0x00001f00
+#define VLYNQ_CTL_INTEN_MASK        0x00002000
+#define VLYNQ_CTL_INTLOCAL_MASK     0x00004000
+#define VLYNQ_CTL_CLKDIR_MASK       0x00008000
+#define VLYNQ_CTL_CLKDIV_MASK       0x00070000
+#define VLYNQ_CTL_MODE_MASK         0x00e00000
+
+
+#define VLYNQ_STS_LINK_MASK         0x00000001  /* Link is active */
+#define VLYNQ_STS_MPEND_MASK        0x00000002  /* Pending master requests */
+#define VLYNQ_STS_SPEND_MASK        0x00000004  /* Pending slave requests */
+#define VLYNQ_STS_NFEMPTY0_MASK     0x00000008  /* Master data FIFO not empty */
+#define VLYNQ_STS_NFEMPTY1_MASK     0x00000010  /* Master command FIFO not empty */
+#define VLYNQ_STS_NFEMPTY2_MASK     0x00000020  /* Slave data FIFO not empty */
+#define VLYNQ_STS_NFEMPTY3_MASK     0x00000040  /* Slave command FIFO not empty */
+#define VLYNQ_STS_LERROR_MASK       0x00000080  /* Local error, w/c */
+#define VLYNQ_STS_RERROR_MASK       0x00000100  /* remote error w/c */
+#define VLYNQ_STS_OFLOW_MASK        0x00000200
+#define VLYNQ_STS_IFLOW_MASK        0x00000400
+#define VLYNQ_STS_MODESUP_MASK      0x00E00000  /* Highest mode supported */
+#define VLYNQ_STS_SWIDTH_MASK       0x07000000  /* Used for reading the width of VLYNQ bus */
+#define VLYNQ_STS_DEBUG_MASK        0xE0000000 
+
+#define VLYNQ_CTL_INTVEC_SHIFT      0x08
+#define VLYNQ_CTL_INTEN_SHIFT       0x0D
+#define VLYNQ_CTL_INT2CFG_SHIFT     0x07
+#define VLYNQ_CTL_INTLOCAL_SHIFT    0x0E
+
+#define VLYNQ_CTL_INTFIELDS_CLEAR_MASK  0x7F80
+
+#define VLYNQ_CHIPVER_DEVREV_MASK   0xffff0000
+#define VLYNQ_CHIPVER_DEVID_MASK    0x0000ffff
+
+#define VLYNQ_IVR_INTEN_MASK        0x80
+#define VLYNQ_IVR_INTTYPE_MASK      0x40
+#define VLYNQ_IVR_INTPOL_MASK       0x20
+
+
+/**** Helper macros ****/
+
+#define VLYNQ_RESETCB(arg) \
+   if( pdev->reset_cb != NULL)   \
+   {                             \
+      (pdev->reset_cb)(pdev, (arg));  \
+   }
+    
+#define VLYNQ_STATUS_FLD_WIDTH(sts) (((sts) & VLYNQ_STS_SWIDTH_MASK) >> 24 )
+#define VLYNQ_CTL_INTVEC(x)         (((x) & 31) << 8 )
+
+#define VLYNQ_INRANGE(x,hi,lo)      (((x) <= (hi)) && ((x) >= (lo)))
+#define VLYNQ_OUTRANGE(x,hi,lo)     (((x) > (hi)) || ((x) < (lo)))
+
+#define VLYNQ_ALIGN4(x)             (x)=(x)&(~3)   
+
+
+/*************************************
+ *             Enums                 *
+ *************************************/
+
+/* Initialization options define what operations are
+ * undertaken during vlynq module initialization */
+typedef enum
+{
+    /* Init host local memory regions.This allows
+     * local host access remote memory regions */
+    VLYNQ_INIT_LOCAL_MEM_REGIONS = 0x01,
+    /* Init host remote memory regions.This allows
+     * remote device access local memory regions */
+    VLYNQ_INIT_REMOTE_MEM_REGIONS =0x02,
+    /* Init local interrupt config*/
+    VLYNQ_INIT_LOCAL_INTERRUPTS   =0x04,
+    /* Init remote interrupt config*/
+    VLYNQ_INIT_REMOTE_INTERRUPTS  =0x08,
+    /* Check link during initialization*/
+    VLYNQ_INIT_CHECK_LINK         =0x10,
+    /* configure clock during init */
+    VLYNQ_INIT_CONFIG_CLOCK       =0x20,
+    /* Clear errors during init */    
+    VLYNQ_INIT_CLEAR_ERRORS       =0x40,
+    /* All options */
+    VLYNQ_INIT_PERFORM_ALL        =0x7F
+}VLYNQ_INIT_OPTIONS;
+
+
+/* VLYNQ_DEV_TYPE identifies local or remote device */
+typedef enum
+{
+    VLYNQ_LOCAL_DVC  = 0,           /* vlynq local device (SOC's vlynq module) */
+    VLYNQ_REMOTE_DVC = 1            /* vlynq remote device (remote vlynq module) */
+}VLYNQ_DEV_TYPE;
+
+
+/* VLYNQ_CLK_SOURCE identifies the vlynq module clock source */
+typedef enum
+{
+    VLYNQ_CLK_SOURCE_NONE   = 0,    /* do not initialize clock generator*/
+    VLYNQ_CLK_SOURCE_LOCAL  = 1,    /* clock is generated by local machine  */
+    VLYNQ_CLK_SOURCE_REMOTE = 2     /* clock is generated by remote machine */
+}VLYNQ_CLK_SOURCE;
+
+
+/* VLYNQ_DRV_STATE indicates the current driver state */
+typedef enum
+{
+    VLYNQ_DRV_STATE_UNINIT = 0,     /* driver is uninitialized  */
+    VLYNQ_DRV_STATE_ININIT = 1,     /* VLYNQ is being initialized */
+    VLYNQ_DRV_STATE_RUN    = 2,     /* VLYNQ is running properly  */
+    VLYNQ_DRV_STATE_HOLD   = 3,     /* driver stopped temporarily */
+    VLYNQ_DRV_STATE_ERROR  = 4      /* driver stopped on unrecoverable error */
+}VLYNQ_DRV_STATE;
+
+
+/* VLYNQ_BUS_WIDTH identifies the vlynq module bus width */
+typedef enum
+{
+   VLYNQ_BUS_WIDTH_3 =  3,
+   VLYNQ_BUS_WIDTH_5 =  5,
+   VLYNQ_BUS_WIDTH_7 =  7,
+   VLYNQ_BUS_WIDTH_9 =  9
+}VLYNQ_BUS_WIDTH;
+
+
+/* VLYNQ_LOCAL_INT_CONFIG indicates whether the local vlynq 
+ * interrupts are processed by the host or passed on to the 
+ * remote device.
+ */
+typedef enum
+{
+    VLYNQ_INT_REMOTE = 0,   /* Interrupt packets sent to remote, intlocal=0 */
+    VLYNQ_INT_LOCAL  = 1    /* Interrupts are handled locally, intlocal=1 */
+}VLYNQ_LOCAL_INT_CONFIG;        
+
+
+/* VLYNQ_REMOTE_INT_CONFIG indicates whether the remote 
+ * interrupts are to be handled by the SOC system ISR 
+ * or via the vlynq root ISR
+ */
+typedef enum 
+{
+    VLYNQ_INT_ROOT_ISR   = 0,   /* remote ints handled via vlynq root ISR */
+    VLYNQ_INT_SYSTEM_ISR = 1    /* remote ints handled via system ISR */
+}VLYNQ_REMOTE_INT_CONFIG;
+
+
+/* VLYNQ_INTR_POLARITY - vlynq interrupt polarity setting */
+typedef enum
+{
+    VLYNQ_INTR_ACTIVE_HIGH = 0,
+    VLYNQ_INTR_ACTIVE_LOW  = 1
+}VLYNQ_INTR_POLARITY;
+
+
+/* VLYNQ_INTR_TYPE  - vlynq interrupt type */
+typedef enum
+{
+    VLYNQ_INTR_LEVEL  = 0,
+    VLYNQ_INTR_PULSED = 1
+}VLYNQ_INTR_TYPE;
+
+
+/* VLYNQ_RESET_MODE - vlynq reset mode */
+typedef enum
+{
+   VLYNQ_RESET_ASSERT,      /* hold device in reset state */
+   VLYNQ_RESET_DEASSERT,    /* release device from reset state */
+   VLYNQ_RESET_INITFAIL,    /* handle the device in case driver initialization fails */
+   VLYNQ_RESET_LINKESTABLISH,  /* handle the device in case driver established link */
+   VLYNQ_RESET_INITFAIL2,   /* Driver initialization failed but VLYNQ link exist. */
+   VLYNQ_RESET_INITOK       /* Driver initialization finished OK. */
+}VLYNQ_RESET_MODE;
+ 
+
+
+/*************************************
+ *             Typedefs              *
+ *************************************/
+
+struct VLYNQ_DEV_t; /*forward declaration*/
+
+/*--------Function Pointers defintions -----------*/
+
+/* prototype for interrupt handler definition */
+typedef void (*VLYNQ_INTR_CNTRL_ISR)(void *arg1,void *arg2,void *arg3);
+
+typedef void 
+(*VLYNQ_RESET_REMOTE)(struct VLYNQ_DEV_t *pDev, VLYNQ_RESET_MODE mode);
+
+typedef void 
+(*VLYNQ_REPORT_CB)( struct VLYNQ_DEV_t *pDev,   /* This VLYNQ */
+                    VLYNQ_DEV_TYPE  aSrcDvc,    /* Event Cause -local/remote? */
+                    unsigned int  dwStatRegVal);      /* Value of the relevant status register */
+
+
+/*-------Structure Definitions------------*/
+
+typedef struct VLYNQ_MEMORY_MAP_t
+{
+    unsigned int Txmap;
+    unsigned int RxOffset[VLYNQ_MAX_MEMORY_REGIONS];
+    unsigned int RxSize[VLYNQ_MAX_MEMORY_REGIONS];
+}VLYNQ_MEMORY_MAP;
+
+
+/**VLYNQ_INTERRUPT_CNTRL - defines the vlynq module interrupt
+ * settings in vlynq Control register  */ 
+typedef struct VLYNQ_INTERRUPT_CNTRL_t
+{
+    /* vlynq interrupts handled by host or remote - maps to 
+     * intLocal bit in vlynq control register */
+    VLYNQ_LOCAL_INT_CONFIG intLocal;
+
+    /* remote interrupts handled by vlynq isr or host system
+     * interrupt controller - maps to the int2Cfg in vlynq 
+     * control register */
+    VLYNQ_REMOTE_INT_CONFIG intRemote;
+    
+    /* bit in pending/set register used for module interrupts*/
+    unsigned int map_vector;
+    
+    /* used only if remote interrupts are to be handled by system ISR*/    
+    unsigned int intr_ptr;
+
+}VLYNQ_INTERRUPT_CNTRL;
+
+
+/* VLYNQ_INTR_CNTRL_ICB - defines the Interrupt control block which hold
+ * the interrupt dispatch table. The vlynq_root_isr() indexes into this 
+ * table to identify the ISR to be invoked
+ */
+typedef struct VLYNQ_INTR_CNTRL_ICB_t
+{
+    VLYNQ_INTR_CNTRL_ISR            isr;    /* Clear errors during initialization */
+    void                            *arg1 ; /* Arg 1 for the ISR */
+    void                            *arg2 ; /* Arg 2 for the ISR */
+    void                            *arg3 ; /* Arg 3 for the ISR */
+    unsigned int  isrCount; /* number of ISR invocations so far */
+    struct VLYNQ_INTR_CNTRL_ICB_t   *next;
+}VLYNQ_INTR_CNTRL_ICB;
+
+/* overlay of vlynq register set */
+typedef struct VLYNQ_REG_SET_t
+{
+    unsigned int revision; /*offset : 0x00 */
+    unsigned int control;  /* 0x04*/
+    unsigned int status;   /* 0x08*/
+    unsigned int pad1;     /* 0x0c*/
+    unsigned int intStatus;   /*0x10*/
+    unsigned int intPending;  /*0x14*/
+    unsigned int intPtr;      /*0x18*/
+    unsigned int txMap;       /*0x1C*/ 
+    unsigned int rxSize1;     /*0x20*/
+    unsigned int rxOffset1;   /*0x24*/
+    unsigned int rxSize2;     /*0x28*/
+    unsigned int rxOffset2;   /*0x2C*/
+    unsigned int rxSize3;     /*0x30*/
+    unsigned int rxOffset3;   /*0x34*/
+    unsigned int rxSize4;     /*0x38*/
+    unsigned int rxOffset4;   /*0x3C*/
+    unsigned int chipVersion; /*0x40*/
+    unsigned int pad2[8];
+    unsigned int ivr30;       /*0x60*/
+    unsigned int ivr74;       /*0x64*/
+    unsigned int pad3[7];
+}VLYNQ_REG_SET;
+    
+
+typedef struct VLYNQ_DEV_t
+{
+    /** module index:1,2,3... used for debugging purposes */
+    unsigned int dev_idx; 
+    
+    /*VLYNQ module base address */
+    unsigned int module_base;
+   
+    /* clock source selection */
+    VLYNQ_CLK_SOURCE clk_source;
+   
+    /* Clock Divider.Val=1 to 8. VLYNQ_clk = VBUSCLK/clk_div */
+    unsigned int  clk_div;
+   
+    /* State of the VLYNQ driver, set to VLYNQ_DRV_STATE_UNINIT, when initializing */
+    VLYNQ_DRV_STATE state;
+   
+    /* Valid VLYNQ bus width, filled by driver  */
+    VLYNQ_BUS_WIDTH width;
+   
+    /* local memory mapping   */
+    VLYNQ_MEMORY_MAP local_mem;
+   
+    /* remote memory mapping   */
+    VLYNQ_MEMORY_MAP remote_mem;
+   
+    /* Local module interrupt params */
+    VLYNQ_INTERRUPT_CNTRL  local_irq;
+   
+    /* remote module interrupt params */
+    VLYNQ_INTERRUPT_CNTRL  remote_irq;
+
+    /*** ICB related fields **/
+   
+    /* Sizeof of ICB = VLYNQ_NUM_INT_BITS(for 32 bits in IntPending) + 
+     * expansion slots for shared interrupts*/
+    VLYNQ_INTR_CNTRL_ICB  pIntrCB[VLYNQ_NUM_INT_BITS + VLYNQ_IVR_CHAIN_SLOTS];
+    VLYNQ_INTR_CNTRL_ICB  *freelist;
+   
+   /* table holding mapping between intVector and the bit position the interrupt
+    * is mapped to(mapVector)*/
+    char vector_map[32];
+   
+    /* user callback for vlynq events, NULL if unused */
+    VLYNQ_REPORT_CB        report_cb;    
+    
+   /* user callback for resetting/realeasing remote device */
+    VLYNQ_RESET_REMOTE     reset_cb;
+
+    /*** Handles provided for direct access to register set if need be
+     * Must be intialized to point to appropriate address during 
+     * vlynq_init */
+    volatile VLYNQ_REG_SET * local;
+    volatile VLYNQ_REG_SET * remote;
+
+    unsigned int  intCount; /* number of interrupts generated so far */
+    unsigned int  isrCount; /* number of ISR invocations so far */
+}VLYNQ_DEV;
+
+
+typedef struct VLYNQ_ISR_ARGS_t
+{
+    int irq;
+    void * arg;
+    void * regset;
+}VLYNQ_ISR_ARGS;
+
+
+/****************************************
+ *        Function Prototypes           *
+ * API exported by generic vlynq driver *
+ ****************************************/
+/* Initialization function */ 
+int vlynq_init( VLYNQ_DEV *pdev, VLYNQ_INIT_OPTIONS options);
+
+/* Check vlynq link */
+unsigned int vlynq_link_check( VLYNQ_DEV * pdev);
+
+/* Set interrupt vector in local or remote device */
+int vlynq_interrupt_vector_set( VLYNQ_DEV *pdev, 
+                                         unsigned int int_vector,
+                                         unsigned int map_vector, 
+                                         VLYNQ_DEV_TYPE dev,
+                                         VLYNQ_INTR_POLARITY pol,
+                                         VLYNQ_INTR_TYPE type);
+
+
+int vlynq_interrupt_vector_cntl( VLYNQ_DEV *pdev,
+                                          unsigned int int_vector,
+                                          VLYNQ_DEV_TYPE dev,
+                                          unsigned int enable);
+
+unsigned int vlynq_interrupt_get_count( VLYNQ_DEV *pdev,
+                                         unsigned int map_vector);
+
+int vlynq_install_isr( VLYNQ_DEV *pdev,
+                                unsigned int map_vector,
+                                VLYNQ_INTR_CNTRL_ISR isr,
+                                void *arg1, void *arg2, void *arg3);
+
+int vlynq_uninstall_isr( VLYNQ_DEV *pdev,
+                                  unsigned int map_vector,
+                                  void *arg1, void *arg2, void *arg3);
+
+
+void vlynq_root_isr(void *arg);
+
+void vlynq_delay(unsigned int clktime);
+
+/* The following functions, provide better granularity in setting
+ * interrupt parameters. (for better support of linux INT Controller)
+ * Note: The interrupt source is identified by "map_vector"- the bit 
+ * position in interrupt status register*/
+
+int vlynq_interrupt_vector_map(VLYNQ_DEV * pdev,
+                                        VLYNQ_DEV_TYPE dev,
+                                        unsigned int int_vector,
+                                        unsigned int map_vector);
+
+int vlynq_interrupt_set_polarity(VLYNQ_DEV * pdev,
+                                          VLYNQ_DEV_TYPE dev,
+                                          unsigned int map_vector,
+                                          VLYNQ_INTR_POLARITY pol);
+
+int vlynq_interrupt_get_polarity( VLYNQ_DEV *pdev ,
+                                           VLYNQ_DEV_TYPE dev_type,
+                                           unsigned int map_vector);
+
+int vlynq_interrupt_set_type(VLYNQ_DEV * pdev,
+                                      VLYNQ_DEV_TYPE dev,
+                                      unsigned int map_vector,
+                                      VLYNQ_INTR_TYPE type);
+
+int vlynq_interrupt_get_type( VLYNQ_DEV *pdev, 
+                                       VLYNQ_DEV_TYPE dev_type,
+                                       unsigned int map_vector);
+
+int vlynq_interrupt_enable(VLYNQ_DEV* pdev,
+                                    VLYNQ_DEV_TYPE dev,
+                                    unsigned int map_vector);
+
+int vlynq_interrupt_disable(VLYNQ_DEV * pdev,
+                                     VLYNQ_DEV_TYPE dev,
+                                     unsigned int map_vector);
+                 
+
+              
+        
+
+#endif /* _VLYNQ_HAL_H_ */
diff -urN linux.old/include/asm-mips/ar7/vlynq_hal.h linux.dev/include/asm-mips/ar7/vlynq_hal.h
--- linux.old/include/asm-mips/ar7/vlynq_hal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/vlynq_hal.h	2005-11-10 01:10:46.095590250 +0100
@@ -0,0 +1,606 @@
+/***************************************************************************
+**+----------------------------------------------------------------------+**
+**|                                ****                                  |**
+**|                                ****                                  |**
+**|                                ******o***                            |**
+**|                          ********_///_****                           |**
+**|                           ***** /_//_/ ****                          |**
+**|                            ** ** (__/ ****                           |**
+**|                                *********                             |**
+**|                                 ****                                 |**
+**|                                  ***                                 |**
+**|                                                                      |**
+**|     Copyright (c) 2003 Texas Instruments Incorporated                |**
+**|                        ALL RIGHTS RESERVED                           |**
+**|                                                                      |**
+**| Permission is hereby granted to licensees of Texas Instruments       |**
+**| Incorporated (TI) products to use this computer program for the sole |**
+**| purpose of implementing a licensee product based on TI products.     |**
+**| No other rights to reproduce, use, or disseminate this computer      |**
+**| program, whether in part or in whole, are granted.                   |**
+**|                                                                      |**
+**| TI makes no representation or warranties with respect to the         |**
+**| performance of this computer program, and specifically disclaims     |**
+**| any responsibility for any damages, special or consequential,        |**
+**| connected with the use of this program.                              |**
+**|                                                                      |**
+**+----------------------------------------------------------------------+**
+***************************************************************************/
+
+/*********************************************************************************
+ *  ------------------------------------------------------------------------------
+ *   Module      : vlynq_hal.h
+ *   Description :
+ *   This header file provides the set of functions exported by the 
+ *   VLYNQ HAL. This file is included from the SOC specific VLYNQ driver wrapper.
+ *  ------------------------------------------------------------------------------
+ *********************************************************************************/
+
+#ifndef _VLYNQ_HAL_H_
+#define _VLYNQ_HAL_H_
+
+#include <asm/ar7/avalanche_types.h>
+#include <asm/ar7/vlynq_hal_params.h>
+
+#ifndef PRIVATE 
+#define PRIVATE static
+#endif
+
+#ifndef GLOBAL
+#define GLOBAL
+#endif
+
+/* Enable/Disable debug feature */
+#undef VLYNQ_DEBUG 
+
+#ifdef VLYNQ_DEBUG  /* This needs to be OS abstracted - for testing use vxworks/linux calls */
+#define debugPrint(format,args...)    
+#else 
+#define debugPrint(format,args...)  
+#endif
+
+/* Error defines */
+#define VLYNQ_SUCCESS               0
+
+#define VLYNQ_ERRCODE_BASE          0 /* Chosen by system */
+#define VLYNQ_INVALID_ARG          -(VLYNQ_ERRCODE_BASE+1)
+#define VLYNQ_INVALID_DRV_STATE    -(VLYNQ_ERRCODE_BASE+2)
+#define VLYNQ_INT_CONFIG_ERR       -(VLYNQ_ERRCODE_BASE+3)
+#define VLYNQ_LINK_DOWN            -(VLYNQ_ERRCODE_BASE+4)
+#define VLYNQ_MEMALLOC_FAIL        -(VLYNQ_ERRCODE_BASE+5)
+#define VLYNQ_ISR_NON_EXISTENT     -(VLYNQ_ERRCODE_BASE+6)
+#define VLYNQ_INTVEC_MAP_NOT_FOUND -(VLYNQ_ERRCODE_BASE+7)
+
+/* Vlynq Defines and Macros */
+
+#define VLYNQ_NUM_INT_BITS              32 /* 32 bit interrupt staus register */
+
+/* Base address of module */
+#define VLYNQ_BASE                      (pdev->module_base)
+
+#define VLYNQ_REMOTE_REGS_OFFSET        0x0080
+
+#define VLYNQ_REV_OFFSET                0x0000
+#define VLYNQ_CTRL_OFFSET               0x0004
+#define VLYNQ_STATUS_OFFSET             0x0008
+#define VLYNQ_INT_STAT_OFFSET           0x0010
+#define VLYNQ_INT_PEND_OFFSET           0x0014
+#define VLYNQ_INT_PTR_OFFSET            0x0018
+#define VLYNQ_TXMAP_OFFSET              0x001c
+
+#define VLYNQ_RX0MAP_SIZE_REG_OFFSET    0x0020
+#define VLYNQ_RX0MAP_OFFSET_REG_OFFSET  0x0024
+
+#define VLYNQ_CHIP_VER_OFFSET           0x0040
+#define VLYNQ_IVR_REGS_OFFSET           0x0060
+
+#define VLYNQ_INT_PENDING_REG_PTR       0x14
+#define VLYNQ_R_INT_PENDING_REG_PTR     VLYNQ_REMOTE_REGS_OFFSET + 0x14
+
+#define VLYNQ_REV_REG       *((volatile UINT32 *)(VLYNQ_BASE+VLYNQ_REV_OFFSET))
+#define VLYNQ_CTRL_REG      *((volatile UINT32 *)(VLYNQ_BASE+VLYNQ_CTRL_OFFSET))
+#define VLYNQ_STATUS_REG    *((volatile UINT32 *)(VLYNQ_BASE+VLYNQ_STATUS_OFFSET))
+#define VLYNQ_INT_STAT_REG  *((volatile UINT32 *)(VLYNQ_BASE+VLYNQ_INT_STAT_OFFSET))
+#define VLYNQ_INT_PEND_REG  *((volatile UINT32 *)(VLYNQ_BASE+VLYNQ_INT_PEND_OFFSET))
+#define VLYNQ_INT_PTR_REG   *((volatile UINT32 *)(VLYNQ_BASE+VLYNQ_INT_PTR_OFFSET))
+#define VLYNQ_TXMAP_REG     *((volatile UINT32 *)(VLYNQ_BASE+VLYNQ_TXMAP_OFFSET))
+
+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+#define VLYNQ_RXMAP_SIZE_REG(map) \
+    *((volatile UINT32 *)(VLYNQ_BASE+VLYNQ_RX0MAP_SIZE_REG_OFFSET+( (map-1)<<3)))
+    
+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+#define VLYNQ_RXMAP_OFFSET_REG(map) \
+    *((volatile UINT32 *)(VLYNQ_BASE+VLYNQ_RX0MAP_OFFSET_REG_OFFSET+( (map-1)<<3)))
+
+#define VLYNQ_CHIP_VER_REG  *((volatile UINT32 *)(VLYNQ_BASE+VLYNQ_CHIP_VER_OFFSET))
+
+/* 0 =< ivr <= 31; currently ivr < VLYNQ_IVR_MAXIVR=8) */
+#define VLYNQ_IVR_OFFSET(ivr)  \
+    (VLYNQ_BASE + VLYNQ_IVR_REGS_OFFSET +((((unsigned)(ivr)) & 31) & ~3) )
+
+#define VLYNQ_IVR_03TO00_REG  *((volatile UINT32*) (VLYNQ_IVR_OFFSET(0)) )
+#define VLYNQ_IVR_07TO04_REG  *((volatile UINT32*) (VLYNQ_IVR_OFFSET(4)) )
+/*** Can be extended for 11TO08...31TO28 when all 31 are supported**/
+
+#define VLYNQ_IVR_INTEN(ivr)    (((UINT32)(0x80)) << ((((unsigned)(ivr)) % 4) * 8))
+#define VLYNQ_IVR_INTTYPE(ivr)  (((UINT32)(0x40)) << ((((unsigned)(ivr)) % 4) * 8))
+#define VLYNQ_IVR_INTPOL(ivr)   (((UINT32)(0x20)) << ((((unsigned)(ivr)) % 4) * 8))
+#define VLYNQ_IVR_INTVEC(ivr)   (((UINT32)(0x1F)) << ((((unsigned)(ivr)) % 4) * 8))
+#define VLYNQ_IVR_INTALL(ivr)   (((UINT32)(0xFF)) << ((((unsigned)(ivr)) % 4) * 8))
+
+
+
+/*********************************
+ * Remote VLYNQ register set     *
+ *********************************/
+
+#define VLYNQ_R_REV_OFFSET              0x0080
+#define VLYNQ_R_CTRL_OFFSET             0x0084
+#define VLYNQ_R_STATUS_OFFSET           0x0088
+#define VLYNQ_R_INT_STAT_OFFSET         0x0090
+#define VLYNQ_R_INT_PEND_OFFSET         0x0094
+#define VLYNQ_R_INT_PTR_OFFSET          0x0098
+#define VLYNQ_R_TXMAP_OFFSET            0x009c
+
+#define VLYNQ_R_RX0MAP_SIZE_REG_OFFSET  0x00A0
+#define VLYNQ_R_RX0MAP_OFFSET_REG_OFFSET 0x00A4
+
+#define VLYNQ_R_CHIP_VER_OFFSET         0x00C0
+#define VLYNQ_R_IVR_REGS_OFFSET         0x00E0
+
+#define VLYNQ_R_REV_REG       *((volatile UINT32 *)(VLYNQ_BASE + VLYNQ_R_REV_OFFSET)) 
+#define VLYNQ_R_CTRL_REG      *((volatile UINT32 *)(VLYNQ_BASE + VLYNQ_R_CTRL_OFFSET))
+#define VLYNQ_R_STATUS_REG    *((volatile UINT32 *)(VLYNQ_BASE + VLYNQ_R_STATUS_OFFSET))
+#define VLYNQ_R_INT_STAT_REG  *((volatile UINT32 *)(VLYNQ_BASE + VLYNQ_R_INT_STAT_OFFSET))
+#define VLYNQ_R_INT_PEND_REG  *((volatile UINT32 *)(VLYNQ_BASE + VLYNQ_R_INT_PEND_OFFSET))
+#define VLYNQ_R_INT_PTR_REG   *((volatile UINT32 *)(VLYNQ_BASE + VLYNQ_R_INT_PTR_OFFSET))
+#define VLYNQ_R_TXMAP_REG     *((volatile UINT32 *)(VLYNQ_BASE + VLYNQ_R_TXMAP_OFFSET))
+
+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+#define VLYNQ_R_RXMAP_SIZE_REG(map) \
+    *((volatile UINT32 *)(VLYNQ_BASE + VLYNQ_R_RX0MAP_SIZE_REG_OFFSET + ((map-1)<<3)))
+    
+/** map takes on values between 1 to VLYNQ_MAX_MEMORY_REGIONS **/
+#define VLYNQ_R_RXMAP_OFFSET_REG(map) \
+    *((volatile UINT32 *)(VLYNQ_BASE + VLYNQ_R_RX0MAP_OFFSET_REG_OFFSET + ((map-1)<<3)))
+
+#define VLYNQ_R_CHIP_VER_REG  *((volatile UINT32 *)(VLYNQ_BASE + VLYNQ_R_CHIP_VER_OFFSET)
+
+#define VLYNQ_R_IVR_OFFSET(ivr)  \
+    (VLYNQ_BASE + VLYNQ_R_IVR_REGS_OFFSET +((((unsigned)(ivr)) & 31) & ~3))
+ 
+
+/*** Can be extended for 11TO08...31TO28 when all 31 are supported**/
+#define VLYNQ_R_IVR_03TO00_REG  *((volatile UINT32*) (VLYNQ_R_IVR_OFFSET(0)) )
+#define VLYNQ_R_IVR_07TO04_REG  *((volatile UINT32*) (VLYNQ_R_IVR_OFFSET(4)) )
+
+
+/****End of remote register set definition******/
+
+
+/*** Masks for individual register fields ***/
+
+#define VLYNQ_MODULE_ID_MASK        0xffff0000
+#define VLYNQ_MAJOR_REV_MASK        0x0000ff00
+#define VLYNQ_MINOR_REV_MASK        0x000000ff
+
+    
+#define VLYNQ_CTL_ILOOP_MASK        0x00000002
+#define VLYNQ_CTL_INT2CFG_MASK      0x00000080
+#define VLYNQ_CTL_INTVEC_MASK       0x00001f00
+#define VLYNQ_CTL_INTEN_MASK        0x00002000
+#define VLYNQ_CTL_INTLOCAL_MASK     0x00004000
+#define VLYNQ_CTL_CLKDIR_MASK       0x00008000
+#define VLYNQ_CTL_CLKDIV_MASK       0x00070000
+#define VLYNQ_CTL_MODE_MASK         0x00e00000
+
+
+#define VLYNQ_STS_LINK_MASK         0x00000001  /* Link is active */
+#define VLYNQ_STS_MPEND_MASK        0x00000002  /* Pending master requests */
+#define VLYNQ_STS_SPEND_MASK        0x00000004  /* Pending slave requests */
+#define VLYNQ_STS_NFEMPTY0_MASK     0x00000008  /* Master data FIFO not empty */
+#define VLYNQ_STS_NFEMPTY1_MASK     0x00000010  /* Master command FIFO not empty */
+#define VLYNQ_STS_NFEMPTY2_MASK     0x00000020  /* Slave data FIFO not empty */
+#define VLYNQ_STS_NFEMPTY3_MASK     0x00000040  /* Slave command FIFO not empty */
+#define VLYNQ_STS_LERROR_MASK       0x00000080  /* Local error, w/c */
+#define VLYNQ_STS_RERROR_MASK       0x00000100  /* remote error w/c */
+#define VLYNQ_STS_OFLOW_MASK        0x00000200
+#define VLYNQ_STS_IFLOW_MASK        0x00000400
+#define VLYNQ_STS_MODESUP_MASK      0x00E00000  /* Highest mode supported */
+#define VLYNQ_STS_SWIDTH_MASK       0x07000000  /* Used for reading the width of VLYNQ bus */
+#define VLYNQ_STS_DEBUG_MASK        0xE0000000 
+
+#define VLYNQ_CTL_INTVEC_SHIFT      0x08
+#define VLYNQ_CTL_INTEN_SHIFT       0x0D
+#define VLYNQ_CTL_INT2CFG_SHIFT     0x07
+#define VLYNQ_CTL_INTLOCAL_SHIFT    0x0E
+
+#define VLYNQ_CTL_INTFIELDS_CLEAR_MASK  0x7F80
+
+#define VLYNQ_CHIPVER_DEVREV_MASK   0xffff0000
+#define VLYNQ_CHIPVER_DEVID_MASK    0x0000ffff
+
+#define VLYNQ_IVR_INTEN_MASK        0x80
+#define VLYNQ_IVR_INTTYPE_MASK      0x40
+#define VLYNQ_IVR_INTPOL_MASK       0x20
+
+
+/**** Helper macros ****/
+
+#define VLYNQ_RESETCB(arg) \
+   if( pdev->reset_cb != NULL)   \
+   {                             \
+      (pdev->reset_cb)(pdev, (arg));  \
+   }
+    
+#define VLYNQ_STATUS_FLD_WIDTH(sts) (((sts) & VLYNQ_STS_SWIDTH_MASK) >> 24 )
+#define VLYNQ_CTL_INTVEC(x)         (((x) & 31) << 8 )
+
+#define VLYNQ_INRANGE(x,hi,lo)      (((x) <= (hi)) && ((x) >= (lo)))
+#define VLYNQ_OUTRANGE(x,hi,lo)     (((x) > (hi)) || ((x) < (lo)))
+
+#define VLYNQ_ALIGN4(x)             (x)=(x)&(~3)   
+
+
+/*************************************
+ *             Enums                 *
+ *************************************/
+
+/* Initialization options define what operations are
+ * undertaken during vlynq module initialization */
+typedef enum
+{
+    /* Init host local memory regions.This allows
+     * local host access remote memory regions */
+    VLYNQ_INIT_LOCAL_MEM_REGIONS = 0x01,
+    /* Init host remote memory regions.This allows
+     * remote device access local memory regions */
+    VLYNQ_INIT_REMOTE_MEM_REGIONS =0x02,
+    /* Init local interrupt config*/
+    VLYNQ_INIT_LOCAL_INTERRUPTS   =0x04,
+    /* Init remote interrupt config*/
+    VLYNQ_INIT_REMOTE_INTERRUPTS  =0x08,
+    /* Check link during initialization*/
+    VLYNQ_INIT_CHECK_LINK         =0x10,
+    /* configure clock during init */
+    VLYNQ_INIT_CONFIG_CLOCK       =0x20,
+    /* Clear errors during init */    
+    VLYNQ_INIT_CLEAR_ERRORS       =0x40,
+    /* All options */
+    VLYNQ_INIT_PERFORM_ALL        =0x7F
+}VLYNQ_INIT_OPTIONS;
+
+
+/* VLYNQ_DEV_TYPE identifies local or remote device */
+typedef enum
+{
+    VLYNQ_LOCAL_DVC  = 0,           /* vlynq local device (SOC's vlynq module) */
+    VLYNQ_REMOTE_DVC = 1            /* vlynq remote device (remote vlynq module) */
+}VLYNQ_DEV_TYPE;
+
+
+/* VLYNQ_CLK_SOURCE identifies the vlynq module clock source */
+typedef enum
+{
+    VLYNQ_CLK_SOURCE_NONE   = 0,    /* do not initialize clock generator*/
+    VLYNQ_CLK_SOURCE_LOCAL  = 1,    /* clock is generated by local machine  */
+    VLYNQ_CLK_SOURCE_REMOTE = 2     /* clock is generated by remote machine */
+}VLYNQ_CLK_SOURCE;
+
+
+/* VLYNQ_DRV_STATE indicates the current driver state */
+typedef enum
+{
+    VLYNQ_DRV_STATE_UNINIT = 0,     /* driver is uninitialized  */
+    VLYNQ_DRV_STATE_ININIT = 1,     /* VLYNQ is being initialized */
+    VLYNQ_DRV_STATE_RUN    = 2,     /* VLYNQ is running properly  */
+    VLYNQ_DRV_STATE_HOLD   = 3,     /* driver stopped temporarily */
+    VLYNQ_DRV_STATE_ERROR  = 4      /* driver stopped on unrecoverable error */
+}VLYNQ_DRV_STATE;
+
+
+/* VLYNQ_BUS_WIDTH identifies the vlynq module bus width */
+typedef enum
+{
+   VLYNQ_BUS_WIDTH_3 =  3,
+   VLYNQ_BUS_WIDTH_5 =  5,
+   VLYNQ_BUS_WIDTH_7 =  7,
+   VLYNQ_BUS_WIDTH_9 =  9
+}VLYNQ_BUS_WIDTH;
+
+
+/* VLYNQ_LOCAL_INT_CONFIG indicates whether the local vlynq 
+ * interrupts are processed by the host or passed on to the 
+ * remote device.
+ */
+typedef enum
+{
+    VLYNQ_INT_REMOTE = 0,   /* Interrupt packets sent to remote, intlocal=0 */
+    VLYNQ_INT_LOCAL  = 1    /* Interrupts are handled locally, intlocal=1 */
+}VLYNQ_LOCAL_INT_CONFIG;        
+
+
+/* VLYNQ_REMOTE_INT_CONFIG indicates whether the remote 
+ * interrupts are to be handled by the SOC system ISR 
+ * or via the vlynq root ISR
+ */
+typedef enum 
+{
+    VLYNQ_INT_ROOT_ISR   = 0,   /* remote ints handled via vlynq root ISR */
+    VLYNQ_INT_SYSTEM_ISR = 1    /* remote ints handled via system ISR */
+}VLYNQ_REMOTE_INT_CONFIG;
+
+
+/* VLYNQ_INTR_POLARITY - vlynq interrupt polarity setting */
+typedef enum
+{
+    VLYNQ_INTR_ACTIVE_HIGH = 0,
+    VLYNQ_INTR_ACTIVE_LOW  = 1
+}VLYNQ_INTR_POLARITY;
+
+
+/* VLYNQ_INTR_TYPE  - vlynq interrupt type */
+typedef enum
+{
+    VLYNQ_INTR_LEVEL  = 0,
+    VLYNQ_INTR_PULSED = 1
+}VLYNQ_INTR_TYPE;
+
+
+/* VLYNQ_RESET_MODE - vlynq reset mode */
+typedef enum
+{
+   VLYNQ_RESET_ASSERT,      /* hold device in reset state */
+   VLYNQ_RESET_DEASSERT,    /* release device from reset state */
+   VLYNQ_RESET_INITFAIL,    /* handle the device in case driver initialization fails */
+   VLYNQ_RESET_LINKESTABLISH,  /* handle the device in case driver established link */
+   VLYNQ_RESET_INITFAIL2,   /* Driver initialization failed but VLYNQ link exist. */
+   VLYNQ_RESET_INITOK       /* Driver initialization finished OK. */
+}VLYNQ_RESET_MODE;
+ 
+
+
+/*************************************
+ *             Typedefs              *
+ *************************************/
+
+struct VLYNQ_DEV_t; /*forward declaration*/
+
+/*--------Function Pointers defintions -----------*/
+
+/* prototype for interrupt handler definition */
+typedef void (*VLYNQ_INTR_CNTRL_ISR)(void *arg1,void *arg2,void *arg3);
+
+typedef void 
+(*VLYNQ_RESET_REMOTE)(struct VLYNQ_DEV_t *pDev, VLYNQ_RESET_MODE mode);
+
+typedef void 
+(*VLYNQ_REPORT_CB)( struct VLYNQ_DEV_t *pDev,   /* This VLYNQ */
+                    VLYNQ_DEV_TYPE  aSrcDvc,    /* Event Cause -local/remote? */
+                    UINT32  dwStatRegVal);      /* Value of the relevant status register */
+
+
+/*-------Structure Definitions------------*/
+
+typedef struct VLYNQ_MEMORY_MAP_t
+{
+    UINT32 Txmap;
+    UINT32 RxOffset[VLYNQ_MAX_MEMORY_REGIONS];
+    UINT32 RxSize[VLYNQ_MAX_MEMORY_REGIONS];
+}VLYNQ_MEMORY_MAP;
+
+
+/**VLYNQ_INTERRUPT_CNTRL - defines the vlynq module interrupt
+ * settings in vlynq Control register  */ 
+typedef struct VLYNQ_INTERRUPT_CNTRL_t
+{
+    /* vlynq interrupts handled by host or remote - maps to 
+     * intLocal bit in vlynq control register */
+    VLYNQ_LOCAL_INT_CONFIG intLocal;
+
+    /* remote interrupts handled by vlynq isr or host system
+     * interrupt controller - maps to the int2Cfg in vlynq 
+     * control register */
+    VLYNQ_REMOTE_INT_CONFIG intRemote;
+    
+    /* bit in pending/set register used for module interrupts*/
+    UINT32 map_vector;
+    
+    /* used only if remote interrupts are to be handled by system ISR*/    
+    UINT32 intr_ptr;
+
+}VLYNQ_INTERRUPT_CNTRL;
+
+
+/* VLYNQ_INTR_CNTRL_ICB - defines the Interrupt control block which hold
+ * the interrupt dispatch table. The vlynq_root_isr() indexes into this 
+ * table to identify the ISR to be invoked
+ */
+typedef struct VLYNQ_INTR_CNTRL_ICB_t
+{
+    VLYNQ_INTR_CNTRL_ISR            isr;    /* Clear errors during initialization */
+    void                            *arg1 ; /* Arg 1 for the ISR */
+    void                            *arg2 ; /* Arg 2 for the ISR */
+    void                            *arg3 ; /* Arg 3 for the ISR */
+    UINT32  isrCount; /* number of ISR invocations so far */
+    struct VLYNQ_INTR_CNTRL_ICB_t   *next;
+}VLYNQ_INTR_CNTRL_ICB;
+
+/* overlay of vlynq register set */
+typedef struct VLYNQ_REG_SET_t
+{
+    UINT32 revision; /*offset : 0x00 */
+    UINT32 control;  /* 0x04*/
+    UINT32 status;   /* 0x08*/
+    UINT32 pad1;     /* 0x0c*/
+    UINT32 intStatus;   /*0x10*/
+    UINT32 intPending;  /*0x14*/
+    UINT32 intPtr;      /*0x18*/
+    UINT32 txMap;       /*0x1C*/ 
+    UINT32 rxSize1;     /*0x20*/
+    UINT32 rxOffset1;   /*0x24*/
+    UINT32 rxSize2;     /*0x28*/
+    UINT32 rxOffset2;   /*0x2C*/
+    UINT32 rxSize3;     /*0x30*/
+    UINT32 rxOffset3;   /*0x34*/
+    UINT32 rxSize4;     /*0x38*/
+    UINT32 rxOffset4;   /*0x3C*/
+    UINT32 chipVersion; /*0x40*/
+    UINT32 pad2[8];
+    UINT32 ivr30;       /*0x60*/
+    UINT32 ivr74;       /*0x64*/
+    UINT32 pad3[7];
+}VLYNQ_REG_SET;
+    
+
+typedef struct VLYNQ_DEV_t
+{
+    /** module index:1,2,3... used for debugging purposes */
+    UINT32 dev_idx; 
+    
+    /*VLYNQ module base address */
+    UINT32 module_base;
+   
+    /* clock source selection */
+    VLYNQ_CLK_SOURCE clk_source;
+   
+    /* Clock Divider.Val=1 to 8. VLYNQ_clk = VBUSCLK/clk_div */
+    UINT32  clk_div;
+   
+    /* State of the VLYNQ driver, set to VLYNQ_DRV_STATE_UNINIT, when initializing */
+    VLYNQ_DRV_STATE state;
+   
+    /* Valid VLYNQ bus width, filled by driver  */
+    VLYNQ_BUS_WIDTH width;
+   
+    /* local memory mapping   */
+    VLYNQ_MEMORY_MAP local_mem;
+   
+    /* remote memory mapping   */
+    VLYNQ_MEMORY_MAP remote_mem;
+   
+    /* Local module interrupt params */
+    VLYNQ_INTERRUPT_CNTRL  local_irq;
+   
+    /* remote module interrupt params */
+    VLYNQ_INTERRUPT_CNTRL  remote_irq;
+
+    /*** ICB related fields **/
+   
+    /* Sizeof of ICB = VLYNQ_NUM_INT_BITS(for 32 bits in IntPending) + 
+     * expansion slots for shared interrupts*/
+    VLYNQ_INTR_CNTRL_ICB  pIntrCB[VLYNQ_NUM_INT_BITS + VLYNQ_IVR_CHAIN_SLOTS];
+    VLYNQ_INTR_CNTRL_ICB  *freelist;
+   
+   /* table holding mapping between intVector and the bit position the interrupt
+    * is mapped to(mapVector)*/
+    INT8 vector_map[32];
+   
+    /* user callback for vlynq events, NULL if unused */
+    VLYNQ_REPORT_CB        report_cb;    
+    
+   /* user callback for resetting/realeasing remote device */
+    VLYNQ_RESET_REMOTE     reset_cb;
+
+    /*** Handles provided for direct access to register set if need be
+     * Must be intialized to point to appropriate address during 
+     * vlynq_init */
+    volatile VLYNQ_REG_SET * local;
+    volatile VLYNQ_REG_SET * remote;
+
+    UINT32  intCount; /* number of interrupts generated so far */
+    UINT32  isrCount; /* number of ISR invocations so far */
+}VLYNQ_DEV;
+
+
+typedef struct VLYNQ_ISR_ARGS_t
+{
+    int irq;
+    void * arg;
+    void * regset;
+}VLYNQ_ISR_ARGS;
+
+
+/****************************************
+ *        Function Prototypes           *
+ * API exported by generic vlynq driver *
+ ****************************************/
+/* Initialization function */ 
+GLOBAL INT32 vlynq_init( VLYNQ_DEV *pdev, VLYNQ_INIT_OPTIONS options);
+
+/* Check vlynq link */
+GLOBAL UINT32 vlynq_link_check( VLYNQ_DEV * pdev);
+
+/* Set interrupt vector in local or remote device */
+GLOBAL INT32 vlynq_interrupt_vector_set( VLYNQ_DEV *pdev, 
+                                         UINT32 int_vector,
+                                         UINT32 map_vector, 
+                                         VLYNQ_DEV_TYPE dev,
+                                         VLYNQ_INTR_POLARITY pol,
+                                         VLYNQ_INTR_TYPE type);
+
+
+GLOBAL INT32 vlynq_interrupt_vector_cntl( VLYNQ_DEV *pdev,
+                                          UINT32 int_vector,
+                                          VLYNQ_DEV_TYPE dev,
+                                          UINT32 enable);
+
+GLOBAL UINT32 vlynq_interrupt_get_count( VLYNQ_DEV *pdev,
+                                         UINT32 map_vector);
+
+GLOBAL INT32 vlynq_install_isr( VLYNQ_DEV *pdev,
+                                UINT32 map_vector,
+                                VLYNQ_INTR_CNTRL_ISR isr,
+                                void *arg1, void *arg2, void *arg3);
+
+GLOBAL INT32 vlynq_uninstall_isr( VLYNQ_DEV *pdev,
+                                  UINT32 map_vector,
+                                  void *arg1, void *arg2, void *arg3);
+
+
+GLOBAL void vlynq_root_isr(void *arg);
+
+GLOBAL void vlynq_delay(UINT32 clktime);
+
+/* The following functions, provide better granularity in setting
+ * interrupt parameters. (for better support of linux INT Controller)
+ * Note: The interrupt source is identified by "map_vector"- the bit 
+ * position in interrupt status register*/
+
+GLOBAL INT32 vlynq_interrupt_vector_map(VLYNQ_DEV * pdev,
+                                        VLYNQ_DEV_TYPE dev,
+                                        UINT32 int_vector,
+                                        UINT32 map_vector);
+
+GLOBAL INT32 vlynq_interrupt_set_polarity(VLYNQ_DEV * pdev,
+                                          VLYNQ_DEV_TYPE dev,
+                                          UINT32 map_vector,
+                                          VLYNQ_INTR_POLARITY pol);
+
+GLOBAL INT32 vlynq_interrupt_get_polarity( VLYNQ_DEV *pdev ,
+                                           VLYNQ_DEV_TYPE dev_type,
+                                           UINT32 map_vector);
+
+GLOBAL INT32 vlynq_interrupt_set_type(VLYNQ_DEV * pdev,
+                                      VLYNQ_DEV_TYPE dev,
+                                      UINT32 map_vector,
+                                      VLYNQ_INTR_TYPE type);
+
+GLOBAL INT32 vlynq_interrupt_get_type( VLYNQ_DEV *pdev, 
+                                       VLYNQ_DEV_TYPE dev_type,
+                                       UINT32 map_vector);
+
+GLOBAL INT32 vlynq_interrupt_enable(VLYNQ_DEV* pdev,
+                                    VLYNQ_DEV_TYPE dev,
+                                    UINT32 map_vector);
+
+GLOBAL INT32 vlynq_interrupt_disable(VLYNQ_DEV * pdev,
+                                     VLYNQ_DEV_TYPE dev,
+                                     UINT32 map_vector);
+                 
+
+              
+        
+
+#endif /* _VLYNQ_HAL_H_ */
diff -urN linux.old/include/asm-mips/ar7/vlynq_hal_params.h linux.dev/include/asm-mips/ar7/vlynq_hal_params.h
--- linux.old/include/asm-mips/ar7/vlynq_hal_params.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/ar7/vlynq_hal_params.h	2005-11-10 01:10:46.095590250 +0100
@@ -0,0 +1,50 @@
+/***************************************************************************
+**+----------------------------------------------------------------------+**
+**|                                ****                                  |**
+**|                                ****                                  |**
+**|                                ******o***                            |**
+**|                          ********_///_****                           |**
+**|                           ***** /_//_/ ****                          |**
+**|                            ** ** (__/ ****                           |**
+**|                                *********                             |**
+**|                                 ****                                 |**
+**|                                  ***                                 |**
+**|                                                                      |**
+**|     Copyright (c) 2003 Texas Instruments Incorporated                |**
+**|                        ALL RIGHTS RESERVED                           |**
+**|                                                                      |**
+**| Permission is hereby granted to licensees of Texas Instruments       |**
+**| Incorporated (TI) products to use this computer program for the sole |**
+**| purpose of implementing a licensee product based on TI products.     |**
+**| No other rights to reproduce, use, or disseminate this computer      |**
+**| program, whether in part or in whole, are granted.                   |**
+**|                                                                      |**
+**| TI makes no representation or warranties with respect to the         |**
+**| performance of this computer program, and specifically disclaims     |**
+**| any responsibility for any damages, special or consequential,        |**
+**| connected with the use of this program.                              |**
+**|                                                                      |**
+**+----------------------------------------------------------------------+**
+***************************************************************************/
+
+/* This file defines Vlynq module parameters*/
+
+#ifndef _VLYNQ_HAL_PARAMS_H
+#define _VLYNQ_HAL_PARAMS_H
+
+ /* number of VLYNQ memory regions supported */
+#define VLYNQ_MAX_MEMORY_REGIONS 0x04
+  
+ /* Max.number of external interrupt inputs supported by VLYNQ module */
+#define VLYNQ_IVR_MAXIVR         0x08
+
+#define VLYNQ_CLK_DIV_MAX  0x08
+#define VLYNQ_CLK_DIV_MIN  0x01
+
+
+/*** the total number of entries allocated for ICB would be
+ * 32(for 32 bits in IntPending register) + VLYNQ_IVR_CHAIN_SLOTS*/
+#define VLYNQ_IVR_CHAIN_SLOTS 10
+
+
+#endif /* _VLYNQ_HAL_PARAMS_H */
diff -urN linux.old/include/asm-mips/io.h linux.dev/include/asm-mips/io.h
--- linux.old/include/asm-mips/io.h	2003-08-25 13:44:43.000000000 +0200
+++ linux.dev/include/asm-mips/io.h	2005-11-10 01:14:16.400733500 +0100
@@ -61,9 +61,9 @@
  * Change "struct page" to physical address.
  */
 #ifdef CONFIG_64BIT_PHYS_ADDR
-#define page_to_phys(page)	((u64)(page - mem_map) << PAGE_SHIFT)
+#define page_to_phys(page)	(((u64)(page - mem_map) << PAGE_SHIFT) + PHYS_OFFSET)
 #else
-#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
+#define page_to_phys(page)	(((page - mem_map) << PAGE_SHIFT) + PHYS_OFFSET)
 #endif
 
 #define IO_SPACE_LIMIT 0xffff
diff -urN linux.old/include/asm-mips/irq.h linux.dev/include/asm-mips/irq.h
--- linux.old/include/asm-mips/irq.h	2003-08-25 13:44:43.000000000 +0200
+++ linux.dev/include/asm-mips/irq.h	2005-11-10 01:12:43.950955750 +0100
@@ -14,7 +14,20 @@
 #include <linux/config.h>
 #include <linux/linkage.h>
 
+#ifdef CONFIG_AR7
+/* MIPS   has 8 irqs
+ * AR7    has 40 primary and 32 secondary irqs
+ * vlynq0 has 32 irqs
+ * vlynq1 has 32 irqs
+ */
+#ifdef CONFIG_AR7_VLYNQ
+#define NR_IRQS (80 + 32 * CONFIG_AR7_VLYNQ_PORTS)
+#else
+#define NR_IRQS 80
+#endif
+#else
 #define NR_IRQS 128		/* Largest number of ints of all machines.  */
+#endif
 
 #ifdef CONFIG_I8259
 static inline int irq_cannonicalize(int irq)
diff -urN linux.old/include/asm-mips/mips-boards/prom.h linux.dev/include/asm-mips/mips-boards/prom.h
--- linux.old/include/asm-mips/mips-boards/prom.h	2001-09-09 19:43:02.000000000 +0200
+++ linux.dev/include/asm-mips/mips-boards/prom.h	2005-11-10 01:14:16.436735750 +0100
@@ -33,7 +33,7 @@
 extern void prom_init_cmdline(void);
 extern void prom_meminit(void);
 extern void prom_fixup_mem_map(unsigned long start_mem, unsigned long end_mem);
-extern void prom_free_prom_memory (void);
+extern unsigned long prom_free_prom_memory (void);
 extern void mips_display_message(const char *str);
 extern void mips_display_word(unsigned int num);
 extern int get_ethernet_addr(char *ethernet_addr);
diff -urN linux.old/include/asm-mips/page.h linux.dev/include/asm-mips/page.h
--- linux.old/include/asm-mips/page.h	2004-02-18 14:36:32.000000000 +0100
+++ linux.dev/include/asm-mips/page.h	2005-11-10 01:14:16.436735750 +0100
@@ -12,6 +12,7 @@
 
 #include <linux/config.h>
 #include <asm/break.h>
+#include <asm/addrspace.h>
 
 #ifdef __KERNEL__
 
@@ -129,7 +130,7 @@
 
 #define __pa(x)		((unsigned long) (x) - PAGE_OFFSET)
 #define __va(x)		((void *)((unsigned long) (x) + PAGE_OFFSET))
-#define virt_to_page(kaddr)	(mem_map + (__pa(kaddr) >> PAGE_SHIFT))
+#define virt_to_page(kaddr)	(mem_map + ((__pa(kaddr)-PHYS_OFFSET) >> PAGE_SHIFT))
 #define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
 
 #define VM_DATA_DEFAULT_FLAGS  (VM_READ | VM_WRITE | VM_EXEC | \
diff -urN linux.old/include/asm-mips/pgtable-32.h linux.dev/include/asm-mips/pgtable-32.h
--- linux.old/include/asm-mips/pgtable-32.h	2004-02-18 14:36:32.000000000 +0100
+++ linux.dev/include/asm-mips/pgtable-32.h	2005-11-10 01:14:16.436735750 +0100
@@ -108,7 +108,7 @@
  * and a page entry and page directory to the page they refer to.
  */
 
-#ifdef CONFIG_CPU_VR41XX
+#if defined(CONFIG_CPU_VR41XX)
 #define mk_pte(page, pgprot)                                            \
 ({                                                                      \
         pte_t   __pte;                                                  \
@@ -123,13 +123,14 @@
 ({									\
 	pte_t   __pte;							\
 									\
-	pte_val(__pte) = ((phys_t)(page - mem_map) << PAGE_SHIFT) | \
-	                 pgprot_val(pgprot);				\
+	pte_val(__pte) = (((phys_t)(page - mem_map) << PAGE_SHIFT) +    \
+			  PHYS_OFFSET) | pgprot_val(pgprot);            \
 									\
 	__pte;								\
 })
 #endif
 
+
 static inline pte_t mk_pte_phys(phys_t physpage, pgprot_t pgprot)
 {
 #ifdef CONFIG_CPU_VR41XX
@@ -175,12 +176,12 @@
 		set_pte(ptep, __pte(0));
 }
 
-#ifdef CONFIG_CPU_VR41XX
+#if defined(CONFIG_CPU_VR41XX)
 #define pte_page(x)  (mem_map+((unsigned long)(((x).pte_low >> (PAGE_SHIFT+2)))))
 #define __mk_pte(page_nr,pgprot) __pte(((page_nr) << (PAGE_SHIFT+2)) | pgprot_val(pgprot))
 #else
-#define pte_page(x)  (mem_map+((unsigned long)(((x).pte_low >> PAGE_SHIFT))))
-#define __mk_pte(page_nr,pgprot) __pte(((page_nr) << PAGE_SHIFT) | pgprot_val(pgprot))
+#define pte_page(x)  (mem_map+((unsigned long)((((x).pte_low-PHYS_OFFSET) >> PAGE_SHIFT))))
+#define __mk_pte(page_nr,pgprot) __pte((((page_nr) << PAGE_SHIFT)+PHYS_OFFSET)|pgprot_val(pgprot))
 #endif
 
 #endif
diff -urN linux.old/include/asm-mips/serial.h linux.dev/include/asm-mips/serial.h
--- linux.old/include/asm-mips/serial.h	2005-01-19 15:10:12.000000000 +0100
+++ linux.dev/include/asm-mips/serial.h	2005-11-10 01:14:16.436735750 +0100
@@ -65,6 +65,16 @@
 
 #define C_P(card,port) (((card)<<6|(port)<<3) + 1)
 
+#ifdef CONFIG_AR7
+#include <asm/ar7/ar7.h>
+#include <asm/ar7/avalanche_intc.h>
+#define AR7_SERIAL_PORT_DEFNS  \
+	{ 0, AR7_BASE_BAUD, AR7_UART0_REGS_BASE, LNXINTNUM(AVALANCHE_UART0_INT), STD_COM_FLAGS }, \
+	{ 0, AR7_BASE_BAUD, AR7_UART1_REGS_BASE, LNXINTNUM(AVALANCHE_UART1_INT), STD_COM_FLAGS }, 
+#else 
+#define AR7_SERIAL_PORT_DEFNS
+#endif
+
 #ifdef CONFIG_MIPS_JAZZ
 #define _JAZZ_SERIAL_INIT(int, base)					\
 	{ .baud_base = JAZZ_BASE_BAUD, .irq = int, .flags = STD_COM_FLAGS,	\
@@ -468,6 +478,7 @@
 #endif
 
 #define SERIAL_PORT_DFNS			\
+	AR7_SERIAL_PORT_DEFNS			\
 	ATLAS_SERIAL_PORT_DEFNS			\
 	AU1000_SERIAL_PORT_DEFNS		\
 	COBALT_SERIAL_PORT_DEFNS		\
