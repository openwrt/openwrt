Index: linux-2.6.23.17/drivers/mtd/devices/block2mtd.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/devices/block2mtd.c
+++ linux-2.6.23.17/drivers/mtd/devices/block2mtd.c
@@ -20,6 +20,8 @@
 #include <linux/buffer_head.h>
 #include <linux/mutex.h>
 #include <linux/mount.h>
+#include <linux/list.h>
+#include <linux/delay.h>
 
 #define VERSION "$Revision: 1.30 $"
 
@@ -27,6 +29,12 @@
 #define ERROR(fmt, args...) printk(KERN_ERR "block2mtd: " fmt "\n" , ## args)
 #define INFO(fmt, args...) printk(KERN_INFO "block2mtd: " fmt "\n" , ## args)
 
+struct retry {
+	struct list_head list;
+	const char *val;
+};
+
+static LIST_HEAD(retry_list);
 
 /* Info for the block device */
 struct block2mtd_dev {
@@ -38,10 +46,36 @@ struct block2mtd_dev {
 	char devname[0];
 };
 
+static int block2mtd_setup2(const char *val);
 
 /* Static info about the MTD, used in cleanup_module */
 static LIST_HEAD(blkmtd_device_list);
 
+static int add_retry(const char *val)
+{
+	struct retry *r = kmalloc(sizeof(struct retry), GFP_KERNEL);
+
+	INIT_LIST_HEAD(&r->list);
+	r->val = val;
+	list_add(&r->list, &retry_list);
+
+	return 0;
+}
+
+static int __init process_retries(void)
+{
+	struct list_head *p, *tmp;
+
+	list_for_each_safe(p, tmp, &retry_list) {
+		struct retry *r = list_entry(p, struct retry, list);
+		block2mtd_setup2(r->val);
+		msleep(100);
+		list_del(p);
+		kfree(r);
+	}
+	return 0;
+}
+rootfs_initcall(process_retries);
 
 static struct page *page_read(struct address_space *mapping, int index)
 {
@@ -518,7 +552,10 @@ static int block2mtd_setup2(const char *
 	if (token[2] && (strlen(token[2]) + 1 > 80))
 		parse_err("mtd device name too long");
 
-	add_device(name, erase_size, token[2]);
+	if (add_device(name, erase_size, token[2]) == NULL) {
+		add_retry(val);
+		return 0;
+	}
 
 	return 0;
 }
@@ -534,8 +571,11 @@ static int block2mtd_setup(const char *v
 	   and block2mtd_init() has already been called,
 	   we can parse the argument now. */
 
-	if (block2mtd_init_called)
+	if (block2mtd_init_called) {
+		/* if the call failed (e.g. because the device does not exist yet)
+		 * then try again just before attempting to mount the rootfs */
 		return block2mtd_setup2(val);
+	}
 
 	/* During early boot stage, we only save the parameters
 	   here. We must parse them later: if the param passed
Index: linux-2.6.23.17/init/do_mounts.c
===================================================================
--- linux-2.6.23.17.orig/init/do_mounts.c
+++ linux-2.6.23.17/init/do_mounts.c
@@ -241,16 +241,8 @@ static int __init fs_names_setup(char *s
 	return 1;
 }
 
-static unsigned int __initdata root_delay;
-static int __init root_delay_setup(char *str)
-{
-	root_delay = simple_strtoul(str, NULL, 0);
-	return 1;
-}
-
 __setup("rootflags=", root_data_setup);
 __setup("rootfstype=", fs_names_setup);
-__setup("rootdelay=", root_delay_setup);
 
 static void __init get_fs_names(char *page)
 {
@@ -426,18 +418,6 @@ void __init prepare_namespace(void)
 {
 	int is_floppy;
 
-	if (root_delay) {
-		printk(KERN_INFO "Waiting %dsec before mounting root device...\n",
-		       root_delay);
-		ssleep(root_delay);
-	}
-
-	/* wait for the known devices to complete their probing */
-	while (driver_probe_done() != 0)
-		msleep(100);
-
-	md_run_setup();
-
 	if (saved_root_name[0]) {
 		root_device_name = saved_root_name;
 		if (!strncmp(root_device_name, "mtd", 3)) {
Index: linux-2.6.23.17/init/main.c
===================================================================
--- linux-2.6.23.17.orig/init/main.c
+++ linux-2.6.23.17/init/main.c
@@ -65,6 +65,7 @@
 #ifdef CONFIG_X86_LOCAL_APIC
 #include <asm/smp.h>
 #endif
+#include "do_mounts.h"
 
 /*
  * This is one of the first .c files built. Error out early if we have compiler
@@ -662,13 +663,14 @@ static int __init initcall_debug_setup(c
 __setup("initcall_debug", initcall_debug_setup);
 
 extern initcall_t __initcall_start[], __initcall_end[];
+extern initcall_t __root_initcall_start[], __root_initcall_end[];
 
-static void __init do_initcalls(void)
+static void __init do_initcalls(initcall_t *start, initcall_t *end)
 {
 	initcall_t *call;
 	int count = preempt_count();
 
-	for (call = __initcall_start; call < __initcall_end; call++) {
+	for (call = start; call < end; call++) {
 		ktime_t t0, t1, delta;
 		char *msg = NULL;
 		char msgbuf[40];
@@ -737,7 +739,7 @@ static void __init do_basic_setup(void)
 	usermodehelper_init();
 	driver_init();
 	init_irq_proc();
-	do_initcalls();
+	do_initcalls(__initcall_start, __initcall_end);
 }
 
 static int __initdata nosoftlockup;
@@ -810,6 +812,14 @@ static int noinline init_post(void)
 	panic("No init found.  Try passing init= option to kernel.");
 }
 
+static unsigned int __initdata root_delay;
+static int __init root_delay_setup(char *str)
+{
+	root_delay = simple_strtoul(str, NULL, 0);
+	return 1;
+}
+__setup("rootdelay=", root_delay_setup);
+
 static int __init kernel_init(void * unused)
 {
 	lock_kernel();
@@ -851,6 +861,17 @@ static int __init kernel_init(void * unu
 
 	if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {
 		ramdisk_execute_command = NULL;
+		if (root_delay) {
+			printk(KERN_INFO "Waiting %dsec before mounting root device...\n",
+		       root_delay);
+			ssleep(root_delay);
+		}
+		/* wait for the known devices to complete their probing */
+		while (driver_probe_done() != 0)
+			msleep(100);
+		md_run_setup();
+		do_initcalls(__root_initcall_start, __root_initcall_end);
+
 		prepare_namespace();
 	}
 
Index: linux-2.6.23.17/arch/i386/kernel/vmlinux.lds.S
===================================================================
--- linux-2.6.23.17.orig/arch/i386/kernel/vmlinux.lds.S
+++ linux-2.6.23.17/arch/i386/kernel/vmlinux.lds.S
@@ -146,6 +146,11 @@ SECTIONS
 	INITCALLS
   	__initcall_end = .;
   }
+  .root_initcall.init : AT(ADDR(.root_initcall.init) - LOAD_OFFSET) {
+  	__root_initcall_start = .;
+	INITCALLS_ROOT
+  	__root_initcall_end = .;
+  }
   .con_initcall.init : AT(ADDR(.con_initcall.init) - LOAD_OFFSET) {
   	__con_initcall_start = .;
 	*(.con_initcall.init)
Index: linux-2.6.23.17/include/asm-generic/vmlinux.lds.h
===================================================================
--- linux-2.6.23.17.orig/include/asm-generic/vmlinux.lds.h
+++ linux-2.6.23.17/include/asm-generic/vmlinux.lds.h
@@ -243,12 +243,14 @@
   	*(.initcall4s.init)						\
   	*(.initcall5.init)						\
   	*(.initcall5s.init)						\
-	*(.initcallrootfs.init)						\
   	*(.initcall6.init)						\
   	*(.initcall6s.init)						\
   	*(.initcall7.init)						\
   	*(.initcall7s.init)
 
+#define INITCALLS_ROOT						\
+	*(.initcallrootfs.init)
+
 #define PERCPU(align)							\
 	. = ALIGN(align);						\
 	__per_cpu_start = .;						\
