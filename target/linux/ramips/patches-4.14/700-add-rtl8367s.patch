From 32326d5eb43fc183329985c6331832d9ed155491 Mon Sep 17 00:00:00 2001
From: Sean Wang <sean.wang@mediatek.com>
Date: Thu, 19 Jul 2018 16:00:39 +0800
Subject: [PATCH] net: phy: add rtl8367 switch phy

let rtl8368 work as phy for an integrating with mtk_eth_soc

Signed-off-by: Sean Wang <sean.wang@mediatek.com>
---
 drivers/net/phy/Kconfig                       |     6 +
 drivers/net/phy/Makefile                      |     1 +
 drivers/net/phy/rtk/Makefile                  |    66 +
 drivers/net/phy/rtk/rtl8367c/acl.c            |  2061 ++
 drivers/net/phy/rtk/rtl8367c/cpu.c            |   537 +
 drivers/net/phy/rtk/rtl8367c/dot1x.c          |   843 +
 drivers/net/phy/rtk/rtl8367c/eee.c            |   162 +
 drivers/net/phy/rtk/rtl8367c/i2c.c            |   436 +
 drivers/net/phy/rtk/rtl8367c/igmp.c           |  1555 ++
 drivers/net/phy/rtk/rtl8367c/include/acl.h    |   990 +
 drivers/net/phy/rtk/rtl8367c/include/cpu.h    |   327 +
 drivers/net/phy/rtk/rtl8367c/include/dot1x.h  |   470 +
 drivers/net/phy/rtk/rtl8367c/include/eee.h    |    82 +
 drivers/net/phy/rtk/rtl8367c/include/i2c.h    |   168 +
 drivers/net/phy/rtk/rtl8367c/include/igmp.h   |   769 +
 .../net/phy/rtk/rtl8367c/include/interrupt.h  |   254 +
 drivers/net/phy/rtk/rtl8367c/include/l2.h     |  1181 +
 drivers/net/phy/rtk/rtl8367c/include/leaky.h  |   371 +
 drivers/net/phy/rtk/rtl8367c/include/led.h    |   481 +
 drivers/net/phy/rtk/rtl8367c/include/mirror.h |   272 +
 drivers/net/phy/rtk/rtl8367c/include/oam.h    |   188 +
 drivers/net/phy/rtk/rtl8367c/include/port.h   |   959 +
 drivers/net/phy/rtk/rtl8367c/include/ptp.h    |   511 +
 drivers/net/phy/rtk/rtl8367c/include/qos.h    |   781 +
 drivers/net/phy/rtk/rtl8367c/include/rate.h   |   305 +
 drivers/net/phy/rtk/rtl8367c/include/rldp.h   |   264 +
 .../net/phy/rtk/rtl8367c/include/rtk_error.h  |   229 +
 .../net/phy/rtk/rtl8367c/include/rtk_hal.h    |    44 +
 .../net/phy/rtk/rtl8367c/include/rtk_switch.h |   737 +
 .../net/phy/rtk/rtl8367c/include/rtk_types.h  |   155 +
 .../rtk/rtl8367c/include/rtl8367c_asicdrv.h   |   129 +
 .../rtl8367c/include/rtl8367c_asicdrv_acl.h   |   231 +
 .../include/rtl8367c_asicdrv_cputag.h         |    49 +
 .../rtl8367c/include/rtl8367c_asicdrv_dot1x.h |    52 +
 .../rtl8367c/include/rtl8367c_asicdrv_eav.h   |   109 +
 .../rtl8367c/include/rtl8367c_asicdrv_eee.h   |    31 +
 .../rtl8367c/include/rtl8367c_asicdrv_fc.h    |    99 +
 .../rtl8367c/include/rtl8367c_asicdrv_green.h |    36 +
 .../rtl8367c/include/rtl8367c_asicdrv_hsb.h   |    43 +
 .../rtl8367c/include/rtl8367c_asicdrv_i2c.h   |    47 +
 .../rtl8367c/include/rtl8367c_asicdrv_igmp.h  |   169 +
 .../include/rtl8367c_asicdrv_inbwctrl.h       |    30 +
 .../include/rtl8367c_asicdrv_interrupt.h      |    66 +
 .../rtl8367c/include/rtl8367c_asicdrv_led.h   |   138 +
 .../rtl8367c/include/rtl8367c_asicdrv_lut.h   |   159 +
 .../rtl8367c/include/rtl8367c_asicdrv_meter.h |    34 +
 .../rtl8367c/include/rtl8367c_asicdrv_mib.h   |   133 +
 .../include/rtl8367c_asicdrv_mirror.h         |    49 +
 .../rtl8367c/include/rtl8367c_asicdrv_misc.h  |    34 +
 .../rtl8367c/include/rtl8367c_asicdrv_oam.h   |    47 +
 .../rtl8367c/include/rtl8367c_asicdrv_phy.h   |    43 +
 .../rtl8367c/include/rtl8367c_asicdrv_port.h  |   237 +
 .../include/rtl8367c_asicdrv_portIsolation.h  |    28 +
 .../rtl8367c/include/rtl8367c_asicdrv_qos.h   |    96 +
 .../rtl8367c/include/rtl8367c_asicdrv_rldp.h  |    60 +
 .../rtl8367c/include/rtl8367c_asicdrv_rma.h   |    57 +
 .../include/rtl8367c_asicdrv_scheduling.h     |    58 +
 .../rtl8367c/include/rtl8367c_asicdrv_storm.h |    61 +
 .../rtl8367c/include/rtl8367c_asicdrv_svlan.h |   132 +
 .../include/rtl8367c_asicdrv_trunking.h       |    48 +
 .../rtl8367c_asicdrv_unknownMulticast.h       |    59 +
 .../rtl8367c/include/rtl8367c_asicdrv_vlan.h  |   157 +
 .../phy/rtk/rtl8367c/include/rtl8367c_base.h  |   596 +
 .../phy/rtk/rtl8367c/include/rtl8367c_reg.h   | 22819 ++++++++++++++++
 drivers/net/phy/rtk/rtl8367c/include/smi.h    |    54 +
 drivers/net/phy/rtk/rtl8367c/include/stat.h   |   433 +
 drivers/net/phy/rtk/rtl8367c/include/storm.h  |   422 +
 drivers/net/phy/rtk/rtl8367c/include/svlan.h  |   896 +
 drivers/net/phy/rtk/rtl8367c/include/trap.h   |   757 +
 drivers/net/phy/rtk/rtl8367c/include/trunk.h  |   328 +
 drivers/net/phy/rtk/rtl8367c/include/vlan.h   |   892 +
 drivers/net/phy/rtk/rtl8367c/interrupt.c      |   434 +
 drivers/net/phy/rtk/rtl8367c/l2.c             |  2911 ++
 drivers/net/phy/rtk/rtl8367c/leaky.c          |   590 +
 drivers/net/phy/rtk/rtl8367c/led.c            |   792 +
 drivers/net/phy/rtk/rtl8367c/mirror.c         |   548 +
 drivers/net/phy/rtk/rtl8367c/oam.c            |   245 +
 drivers/net/phy/rtk/rtl8367c/port.c           |  2467 ++
 drivers/net/phy/rtk/rtl8367c/ptp.c            |   759 +
 drivers/net/phy/rtk/rtl8367c/qos.c            |  1452 +
 drivers/net/phy/rtk/rtl8367c/rate.c           |   607 +
 drivers/net/phy/rtk/rtl8367c/rldp.c           |   468 +
 drivers/net/phy/rtk/rtl8367c/rtk_hal.c        |   839 +
 drivers/net/phy/rtk/rtl8367c/rtk_switch.c     |  1796 ++
 .../net/phy/rtk/rtl8367c/rtl8367c_asicdrv.c   |   639 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_acl.c   |  1173 +
 .../rtk/rtl8367c/rtl8367c_asicdrv_cputag.c    |   369 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_dot1x.c |   415 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_eav.c   |   877 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_eee.c   |   141 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_fc.c    |  1354 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_green.c |   445 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_hsb.c   |    81 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_i2c.c   |   474 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_igmp.c  |  2109 ++
 .../rtk/rtl8367c/rtl8367c_asicdrv_inbwctrl.c  |   164 +
 .../rtk/rtl8367c/rtl8367c_asicdrv_interrupt.c |   205 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_led.c   |   727 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_lut.c   |  1549 ++
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_meter.c |   305 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_mib.c   |   570 +
 .../rtk/rtl8367c/rtl8367c_asicdrv_mirror.c    |   472 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_misc.c  |   268 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_oam.c   |   194 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_phy.c   |   394 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_port.c  |  5752 ++++
 .../rtl8367c/rtl8367c_asicdrv_portIsolation.c |   119 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_qos.c   |   778 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_rldp.c  |   674 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_rma.c   |   362 +
 .../rtl8367c/rtl8367c_asicdrv_scheduling.c    |   525 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_storm.c |   851 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_svlan.c |  1003 +
 .../rtk/rtl8367c/rtl8367c_asicdrv_trunking.c  |   356 +
 .../rtl8367c_asicdrv_unknownMulticast.c       |   238 +
 .../phy/rtk/rtl8367c/rtl8367c_asicdrv_vlan.c  |  1505 +
 drivers/net/phy/rtk/rtl8367c/smi.c            |   444 +
 drivers/net/phy/rtk/rtl8367c/stat.c           |   626 +
 drivers/net/phy/rtk/rtl8367c/storm.c          |   816 +
 drivers/net/phy/rtk/rtl8367c/svlan.c          |  2415 ++
 drivers/net/phy/rtk/rtl8367c/trap.c           |  1229 +
 drivers/net/phy/rtk/rtl8367c/trunk.c          |   605 +
 drivers/net/phy/rtk/rtl8367c/vlan.c           |  2124 ++
 drivers/net/phy/rtk/rtl8367s.c                |   580 +
 drivers/net/phy/rtk/rtl8367s_dbg.c            |   196 +
 drivers/net/phy/rtk/rtl8367s_mdio.c           |   312 +
 126 files changed, 93466 insertions(+)
 create mode 100755 drivers/net/phy/rtk/Makefile
 create mode 100644 drivers/net/phy/rtk/rtl8367c/acl.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/cpu.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/dot1x.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/eee.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/i2c.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/igmp.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/acl.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/cpu.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/dot1x.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/eee.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/i2c.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/igmp.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/interrupt.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/l2.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/leaky.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/led.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/mirror.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/oam.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/port.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/ptp.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/qos.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rate.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rldp.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtk_error.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtk_hal.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtk_switch.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtk_types.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_acl.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_cputag.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_dot1x.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_eav.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_eee.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_fc.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_green.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_hsb.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_i2c.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_igmp.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_inbwctrl.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_interrupt.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_led.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_lut.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_meter.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_mib.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_mirror.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_misc.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_oam.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_phy.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_port.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_portIsolation.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_qos.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_rldp.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_rma.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_scheduling.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_storm.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_svlan.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_trunking.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_unknownMulticast.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_vlan.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_base.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/rtl8367c_reg.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/smi.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/stat.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/storm.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/svlan.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/trap.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/trunk.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/include/vlan.h
 create mode 100644 drivers/net/phy/rtk/rtl8367c/interrupt.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/l2.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/leaky.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/led.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/mirror.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/oam.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/port.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/ptp.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/qos.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rate.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rldp.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtk_hal.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtk_switch.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_acl.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_cputag.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_dot1x.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_eav.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_eee.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_fc.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_green.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_hsb.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_i2c.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_igmp.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_inbwctrl.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_interrupt.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_led.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_lut.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_meter.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_mib.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_mirror.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_misc.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_oam.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_phy.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_port.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_portIsolation.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_qos.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_rldp.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_rma.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_scheduling.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_storm.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_svlan.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_trunking.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_unknownMulticast.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_vlan.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/smi.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/stat.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/storm.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/svlan.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/trap.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/trunk.c
 create mode 100644 drivers/net/phy/rtk/rtl8367c/vlan.c
 create mode 100755 drivers/net/phy/rtk/rtl8367s.c
 create mode 100755 drivers/net/phy/rtk/rtl8367s_dbg.c
 create mode 100755 drivers/net/phy/rtk/rtl8367s_mdio.c

diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index cd931cf9dcc26..57efe3396761a 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -398,6 +398,12 @@ config XILINX_GMII2RGMII
 	  the Reduced Gigabit Media Independent Interface(RGMII) between
 	  Ethernet physical media devices and the Gigabit Ethernet controller.
 
+config RTL8367S_GSW
+        tristate "RTL8367 Gigabit Switch support"
+        depends on NET_VENDOR_MEDIATEK
+        ---help---
+         This driver supports RTL8367s Switch
+
 endif # PHYLIB
 
 config MICREL_KS8995MA
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index 00f097e18c68a..83d0b72e4ed86 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -79,3 +79,4 @@ obj-$(CONFIG_STE10XP)		+= ste10Xp.o
 obj-$(CONFIG_TERANETICS_PHY)	+= teranetics.o
 obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 obj-$(CONFIG_XILINX_GMII2RGMII) += xilinx_gmii2rgmii.o
+obj-$(CONFIG_RTL8367S_GSW)     += rtk/
diff --git a/drivers/net/phy/rtk/Makefile b/drivers/net/phy/rtk/Makefile
new file mode 100755
index 0000000000000..81e417823de2c
--- /dev/null
+++ b/drivers/net/phy/rtk/Makefile
@@ -0,0 +1,66 @@
+ccflags-y += -Werror -D_LITTLE_ENDIAN -DMDC_MDIO_OPERATION
+ccflags-y += -Idrivers/net/phy/rtk/rtl8367c/include
+ccflags-y += -Iinclude/linux/
+
+obj-$(CONFIG_RTL8367S_GSW) += rtl8367s_gsw.o
+rtl8367s_gsw-objs := rtl8367s_mdio.o rtl8367s_dbg.o
+ifeq ($(CONFIG_SWCONFIG),y)
+rtl8367s_gsw-objs += rtl8367s.o
+endif
+rtl8367s_gsw-objs += rtl8367c/acl.o
+rtl8367s_gsw-objs += rtl8367c/cpu.o
+rtl8367s_gsw-objs += rtl8367c/dot1x.o
+rtl8367s_gsw-objs += rtl8367c/eee.o
+rtl8367s_gsw-objs += rtl8367c/igmp.o
+rtl8367s_gsw-objs += rtl8367c/interrupt.o
+rtl8367s_gsw-objs += rtl8367c/l2.o
+rtl8367s_gsw-objs += rtl8367c/leaky.o
+rtl8367s_gsw-objs += rtl8367c/led.o
+rtl8367s_gsw-objs += rtl8367c/mirror.o
+rtl8367s_gsw-objs += rtl8367c/oam.o
+rtl8367s_gsw-objs += rtl8367c/port.o
+rtl8367s_gsw-objs += rtl8367c/ptp.o
+rtl8367s_gsw-objs += rtl8367c/qos.o
+rtl8367s_gsw-objs += rtl8367c/rate.o
+rtl8367s_gsw-objs += rtl8367c/rldp.o
+rtl8367s_gsw-objs += rtl8367c/rtk_switch.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_acl.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_cputag.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_dot1x.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_eav.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_eee.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_fc.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_green.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_hsb.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_igmp.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_inbwctrl.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_interrupt.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_led.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_lut.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_meter.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_mib.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_mirror.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_misc.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_oam.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_phy.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_port.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_portIsolation.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_qos.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_rldp.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_rma.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_scheduling.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_storm.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_svlan.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_trunking.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_unknownMulticast.o
+rtl8367s_gsw-objs += rtl8367c/rtl8367c_asicdrv_vlan.o
+rtl8367s_gsw-objs += rtl8367c/smi.o
+rtl8367s_gsw-objs += rtl8367c/stat.o
+rtl8367s_gsw-objs += rtl8367c/storm.o
+rtl8367s_gsw-objs += rtl8367c/svlan.o
+rtl8367s_gsw-objs += rtl8367c/trap.o
+rtl8367s_gsw-objs += rtl8367c/trunk.o
+rtl8367s_gsw-objs += rtl8367c/vlan.o
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/acl.c b/drivers/net/phy/rtk/rtl8367c/acl.c
new file mode 100644
index 0000000000000..502c6b86817ef
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/acl.c
@@ -0,0 +1,2061 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in ACL module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <acl.h>
+#include <vlan.h>
+#include <svlan.h>
+#include <rate.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_acl.h>
+#include <rtl8367c_asicdrv_hsb.h>
+#include <rtl8367c_asicdrv_vlan.h>
+#include <rtl8367c_asicdrv_svlan.h>
+#include <rtl8367c_asicdrv_cputag.h>
+#include <rtl8367c_asicdrv_mib.h>
+
+CONST_T rtk_uint8 filter_templateField[RTL8367C_ACLTEMPLATENO][RTL8367C_ACLRULEFIELDNO] = {
+    {ACL_DMAC0,             ACL_DMAC1,          ACL_DMAC2,          ACL_SMAC0,          ACL_SMAC1,          ACL_SMAC2,          ACL_ETHERTYPE,      ACL_FIELD_SELECT15},
+    {ACL_IP4SIP0,           ACL_IP4SIP1,        ACL_IP4DIP0,        ACL_IP4DIP1,        ACL_FIELD_SELECT13, ACL_FIELD_SELECT14, ACL_FIELD_SELECT02, ACL_FIELD_SELECT15},
+    {ACL_IP6SIP0WITHIPV4,   ACL_IP6SIP1WITHIPV4,ACL_FIELD_SELECT03, ACL_FIELD_SELECT04, ACL_FIELD_SELECT05, ACL_FIELD_SELECT06, ACL_FIELD_SELECT07, ACL_FIELD_SELECT08},
+    {ACL_IP6DIP0WITHIPV4,   ACL_IP6DIP1WITHIPV4,ACL_FIELD_SELECT09, ACL_FIELD_SELECT10, ACL_FIELD_SELECT11, ACL_FIELD_SELECT12, ACL_FIELD_SELECT13, ACL_FIELD_SELECT14},
+    {ACL_VIDRANGE,          ACL_IPRANGE,        ACL_PORTRANGE,      ACL_CTAG,           ACL_STAG,           ACL_FIELD_SELECT13, ACL_FIELD_SELECT14, ACL_FIELD_SELECT15}
+};
+
+CONST_T rtk_uint8 filter_advanceCaretagField[RTL8367C_ACLTEMPLATENO][2] = {
+    {TRUE,      7},
+    {TRUE,      7},
+    {FALSE,     0},
+    {FALSE,     0},
+    {TRUE,      7},
+};
+
+
+CONST_T rtk_uint8 filter_fieldTemplateIndex[FILTER_FIELD_END][RTK_FILTER_FIELD_USED_MAX] = {
+    {0x00, 0x01,0x02},
+    {0x03, 0x04,0x05},
+    {0x06},
+    {0x43},
+    {0x44},
+    {0x10, 0x11},
+    {0x12, 0x13},
+    {0x24},
+    {0x25},
+    {0x35},
+    {0x35},
+    {0x20, 0x21,0x22,0x23},
+    {0x30, 0x31,0x32,0x33},
+    {0x26},
+    {0x27},
+    {0x14},
+    {0x15},
+    {0x16},
+    {0x14},
+    {0x15},
+    {0x14},
+    {0x14},
+    {0x14},
+
+    {0x40},
+    {0x41},
+    {0x42},
+
+    {0x14},
+    {0x15},
+    {0x16},
+    {0x22},
+    {0x23},
+    {0x24},
+    {0x25},
+    {0x26},
+    {0x27},
+    {0x32},
+    {0x33},
+    {0x34},
+    {0x35},
+    {0x36},
+    {0x37},
+    {0x47},
+
+    {0xFF} /* Pattern Match */
+};
+
+CONST_T rtk_uint8 filter_fieldSize[FILTER_FIELD_END] = {
+    3, 3, 1, 1, 1,
+    2, 2, 1, 1, 1, 1, 4, 4, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    8
+};
+
+CONST_T rtk_uint16 field_selector[RTL8367C_FIELDSEL_FORMAT_NUMBER][2] =
+{
+    {FIELDSEL_FORMAT_DEFAULT, 0},    /* Field Selector 0 */
+    {FIELDSEL_FORMAT_DEFAULT, 0},    /* Field Selector 1 */
+    {FIELDSEL_FORMAT_IPPAYLOAD, 12}, /* Field Selector 2 */
+    {FIELDSEL_FORMAT_IPV6, 10},      /* Field Selector 3 */
+    {FIELDSEL_FORMAT_IPV6, 8},       /* Field Selector 4 */
+    {FIELDSEL_FORMAT_IPV4, 0},       /* Field Selector 5 */
+    {FIELDSEL_FORMAT_IPV4, 8},       /* Field Selector 6 */
+    {FIELDSEL_FORMAT_IPV6, 0},       /* Field Selector 7 */
+    {FIELDSEL_FORMAT_IPV6, 6},       /* Field Selector 8 */
+    {FIELDSEL_FORMAT_IPV6, 26},      /* Field Selector 9 */
+    {FIELDSEL_FORMAT_IPV6, 24},      /* Field Selector 10 */
+    {FIELDSEL_FORMAT_DEFAULT, 0},    /* Field Selector 11 */
+    {FIELDSEL_FORMAT_IPV4, 6},       /* Field Selector 12 */
+    {FIELDSEL_FORMAT_IPPAYLOAD, 0},  /* Field Selector 13 */
+    {FIELDSEL_FORMAT_IPPAYLOAD, 2},  /* Field Selector 14 */
+    {FIELDSEL_FORMAT_DEFAULT, 0}     /* Field Selector 15 */
+};
+
+
+static rtk_api_ret_t _rtk_filter_igrAcl_writeDataField(rtl8367c_aclrule *aclRule, rtk_filter_field_t *fieldPtr);
+
+
+/* Function Name:
+ *      rtk_filter_igrAcl_init
+ * Description:
+ *      ACL initialization function
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - Pointer pFilter_field or pFilter_cfg point to NULL.
+ * Note:
+ *      This function enable and intialize ACL function
+ */
+rtk_api_ret_t rtk_filter_igrAcl_init(void)
+{
+    rtl8367c_acltemplate_t       aclTemp;
+    rtk_uint32                 i, j;
+    rtk_api_ret_t          ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((ret = rtk_filter_igrAcl_cfg_delAll()) != RT_ERR_OK)
+        return ret;
+
+    for(i = 0; i < RTL8367C_ACLTEMPLATENO; i++)
+    {
+        for(j = 0; j < RTL8367C_ACLRULEFIELDNO;j++)
+            aclTemp.field[j] = filter_templateField[i][j];
+
+        if ((ret = rtl8367c_setAsicAclTemplate(i, &aclTemp)) != RT_ERR_OK)
+            return ret;
+    }
+
+    for(i = 0; i < RTL8367C_FIELDSEL_FORMAT_NUMBER; i++)
+    {
+        if ((ret = rtl8367c_setAsicFieldSelector(i, field_selector[i][0], field_selector[i][1])) != RT_ERR_OK)
+            return ret;
+    }
+
+    RTK_SCAN_ALL_PHY_PORTMASK(i)
+    {
+        if ((ret = rtl8367c_setAsicAcl(i, TRUE)) != RT_ERR_OK)
+            return ret;
+
+        if ((ret = rtl8367c_setAsicAclUnmatchedPermit(i, TRUE)) != RT_ERR_OK)
+            return ret;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_field_add
+ * Description:
+ *      Add comparison rule to an ACL configuration
+ * Input:
+ *      pFilter_cfg     - The ACL configuration that this function will add comparison rule
+ *      pFilter_field   - The comparison rule that will be added.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Pointer pFilter_field or pFilter_cfg point to NULL.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      This function add a comparison rule (*pFilter_field) to an ACL configuration (*pFilter_cfg).
+ *      Pointer pFilter_cfg points to an ACL configuration structure, this structure keeps multiple ACL
+ *      comparison rules by means of linked list. Pointer pFilter_field will be added to linked
+ *      list keeped by structure that pFilter_cfg points to.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_field_add(rtk_filter_cfg_t* pFilter_cfg, rtk_filter_field_t* pFilter_field)
+{
+    rtk_uint32 i;
+    rtk_filter_field_t *tailPtr;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pFilter_cfg || NULL == pFilter_field)
+        return RT_ERR_NULL_POINTER;
+
+    if(pFilter_field->fieldType >= FILTER_FIELD_END)
+        return RT_ERR_ENTRY_INDEX;
+
+
+    if(0 == pFilter_field->fieldTemplateNo)
+    {
+        pFilter_field->fieldTemplateNo = filter_fieldSize[pFilter_field->fieldType];
+
+        for(i = 0; i < pFilter_field->fieldTemplateNo; i++)
+        {
+            pFilter_field->fieldTemplateIdx[i] = filter_fieldTemplateIndex[pFilter_field->fieldType][i];
+        }
+    }
+
+    if(NULL == pFilter_cfg->fieldHead)
+    {
+        pFilter_cfg->fieldHead = pFilter_field;
+    }
+    else
+    {
+        if (pFilter_cfg->fieldHead->next == NULL)
+        {
+            pFilter_cfg->fieldHead->next = pFilter_field;
+        }
+        else
+        {
+            tailPtr = pFilter_cfg->fieldHead->next;
+            while( tailPtr->next != NULL)
+            {
+                tailPtr = tailPtr->next;
+            }
+            tailPtr->next = pFilter_field;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+static rtk_api_ret_t _rtk_filter_igrAcl_writeDataField(rtl8367c_aclrule *aclRule, rtk_filter_field_t *fieldPtr)
+{
+    rtk_uint32 i, tempIdx,fieldIdx, ipValue, ipMask;
+    rtk_uint32 ip6addr[RTK_IPV6_ADDR_WORD_LENGTH];
+    rtk_uint32 ip6mask[RTK_IPV6_ADDR_WORD_LENGTH];
+
+    for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+    {
+        tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+
+        aclRule[tempIdx].valid = TRUE;
+    }
+
+    switch (fieldPtr->fieldType)
+    {
+    /* use DMAC structure as representative for mac structure */
+    case FILTER_FIELD_DMAC:
+    case FILTER_FIELD_SMAC:
+
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.mac.value.octet[5 - i*2] | (fieldPtr->filter_pattern_union.mac.value.octet[5 - (i*2 + 1)] << 8);
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.mac.mask.octet[5 - i*2] | (fieldPtr->filter_pattern_union.mac.mask.octet[5 - (i*2 + 1)] << 8);
+        }
+        break;
+    case FILTER_FIELD_ETHERTYPE:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.etherType.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.etherType.mask;
+        }
+        break;
+    case FILTER_FIELD_IPV4_SIP:
+    case FILTER_FIELD_IPV4_DIP:
+
+        ipValue = fieldPtr->filter_pattern_union.sip.value;
+        ipMask = fieldPtr->filter_pattern_union.sip.mask;
+
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = (0xFFFF & (ipValue >> (i*16)));
+            aclRule[tempIdx].care_bits.field[fieldIdx] = (0xFFFF & (ipMask >> (i*16)));
+        }
+        break;
+    case FILTER_FIELD_IPV4_TOS:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.ipTos.value & 0xFF;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.ipTos.mask  & 0xFF;
+        }
+        break;
+    case FILTER_FIELD_IPV4_PROTOCOL:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.protocol.value & 0xFF;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.protocol.mask  & 0xFF;
+        }
+        break;
+    case FILTER_FIELD_IPV6_SIPV6:
+    case FILTER_FIELD_IPV6_DIPV6:
+        for(i = 0; i < RTK_IPV6_ADDR_WORD_LENGTH; i++)
+        {
+            ip6addr[i] = fieldPtr->filter_pattern_union.sipv6.value.addr[i];
+            ip6mask[i] = fieldPtr->filter_pattern_union.sipv6.mask.addr[i];
+        }
+
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            if(i < 2)
+            {
+                aclRule[tempIdx].data_bits.field[fieldIdx] = ((ip6addr[0] & (0xFFFF << (i * 16))) >> (i * 16));
+                aclRule[tempIdx].care_bits.field[fieldIdx] = ((ip6mask[0] & (0xFFFF << (i * 16))) >> (i * 16));
+            }
+            else
+            {
+                /*default acl template for ipv6 address supports MSB 32-bits and LSB 32-bits only*/
+                aclRule[tempIdx].data_bits.field[fieldIdx] = ((ip6addr[3] & (0xFFFF << ((i&1) * 16))) >> ((i&1) * 16));
+                aclRule[tempIdx].care_bits.field[fieldIdx] = ((ip6mask[3] & (0xFFFF << ((i&1) * 16))) >> ((i&1) * 16));
+            }
+        }
+
+        break;
+    case FILTER_FIELD_CTAG:
+    case FILTER_FIELD_STAG:
+
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.l2tag.pri.value << 13) | (fieldPtr->filter_pattern_union.l2tag.cfi.value << 12) | fieldPtr->filter_pattern_union.l2tag.vid.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.l2tag.pri.mask << 13) | (fieldPtr->filter_pattern_union.l2tag.cfi.mask << 12) | fieldPtr->filter_pattern_union.l2tag.vid.mask;
+        }
+        break;
+    case FILTER_FIELD_IPV4_FLAG:
+
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0x1FFF;
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.xf.value << 15);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.df.value << 14);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.mf.value << 13);
+
+            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0x1FFF;
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.xf.mask << 15);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.df.mask << 14);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.ipFlag.mf.mask << 13);
+        }
+
+        break;
+    case FILTER_FIELD_IPV4_OFFSET:
+
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0xE000;
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.inData.value;
+
+            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0xE000;
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.inData.mask;
+        }
+
+        break;
+
+    case FILTER_FIELD_IPV6_TRAFFIC_CLASS:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.inData.value << 4)&0x0FF0;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.inData.mask << 4)&0x0FF0;
+        }
+        break;
+    case FILTER_FIELD_IPV6_NEXT_HEADER:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.value << 8;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.mask << 8;
+        }
+        break;
+    case FILTER_FIELD_TCP_SPORT:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpSrcPort.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpSrcPort.mask;
+        }
+        break;
+    case FILTER_FIELD_TCP_DPORT:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpDstPort.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.tcpDstPort.mask;
+        }
+        break;
+    case FILTER_FIELD_TCP_FLAG:
+
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.cwr.value << 7);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ece.value << 6);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.urg.value << 5);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ack.value << 4);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.psh.value << 3);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.rst.value << 2);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.syn.value << 1);
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.tcpFlag.fin.value;
+
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.cwr.mask << 7);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ece.mask << 6);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.urg.mask << 5);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.ack.mask << 4);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.psh.mask << 3);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.rst.mask << 2);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.tcpFlag.syn.mask << 1);
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.tcpFlag.fin.mask;
+        }
+        break;
+    case FILTER_FIELD_UDP_SPORT:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpSrcPort.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpSrcPort.mask;
+        }
+        break;
+    case FILTER_FIELD_UDP_DPORT:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpDstPort.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.udpDstPort.mask;
+        }
+        break;
+    case FILTER_FIELD_ICMP_CODE:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0xFF00;
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.icmpCode.value;
+            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0xFF00;
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= fieldPtr->filter_pattern_union.icmpCode.mask;
+        }
+        break;
+    case FILTER_FIELD_ICMP_TYPE:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] &= 0x00FF;
+            aclRule[tempIdx].data_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.icmpType.value << 8);
+            aclRule[tempIdx].care_bits.field[fieldIdx] &= 0x00FF;
+            aclRule[tempIdx].care_bits.field[fieldIdx] |= (fieldPtr->filter_pattern_union.icmpType.mask << 8);
+        }
+        break;
+    case FILTER_FIELD_IGMP_TYPE:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.igmpType.value << 8);
+            aclRule[tempIdx].care_bits.field[fieldIdx] = (fieldPtr->filter_pattern_union.igmpType.mask << 8);
+        }
+        break;
+    case FILTER_FIELD_PATTERN_MATCH:
+        for(i = 0; i < fieldPtr->fieldTemplateNo; i++)
+        {
+            tempIdx = (fieldPtr->fieldTemplateIdx[i] & 0xF0) >> 4;
+            fieldIdx = fieldPtr->fieldTemplateIdx[i] & 0x0F;
+
+            aclRule[tempIdx].data_bits.field[fieldIdx] = ((fieldPtr->filter_pattern_union.pattern.value[i/2] >> (16 * (i%2))) & 0x0000FFFF );
+            aclRule[tempIdx].care_bits.field[fieldIdx] = ((fieldPtr->filter_pattern_union.pattern.mask[i/2] >> (16 * (i%2))) & 0x0000FFFF );
+        }
+        break;
+    case FILTER_FIELD_VID_RANGE:
+    case FILTER_FIELD_IP_RANGE:
+    case FILTER_FIELD_PORT_RANGE:
+    default:
+        tempIdx = (fieldPtr->fieldTemplateIdx[0] & 0xF0) >> 4;
+        fieldIdx = fieldPtr->fieldTemplateIdx[0] & 0x0F;
+
+        aclRule[tempIdx].data_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.value;
+        aclRule[tempIdx].care_bits.field[fieldIdx] = fieldPtr->filter_pattern_union.inData.mask;
+        break;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_cfg_add
+ * Description:
+ *      Add an ACL configuration to ASIC
+ * Input:
+ *      filter_id       - Start index of ACL configuration.
+ *      pFilter_cfg     - The ACL configuration that this function will add comparison rule
+ *      pFilter_action  - Action(s) of ACL configuration.
+ * Output:
+ *      ruleNum - number of rules written in acl table
+ * Return:
+ *      RT_ERR_OK                               - OK
+ *      RT_ERR_FAILED                           - Failed
+ *      RT_ERR_SMI                              - SMI access error
+ *      RT_ERR_NULL_POINTER                     - Pointer pFilter_field or pFilter_cfg point to NULL.
+ *      RT_ERR_INPUT                            - Invalid input parameters.
+ *      RT_ERR_ENTRY_INDEX                      - Invalid filter_id .
+ *      RT_ERR_NULL_POINTER                     - Pointer pFilter_action or pFilter_cfg point to NULL.
+ *      RT_ERR_FILTER_INACL_ACT_NOT_SUPPORT     - Action is not supported in this chip.
+ *      RT_ERR_FILTER_INACL_RULE_NOT_SUPPORT    - Rule is not supported.
+ * Note:
+ *      This function store pFilter_cfg, pFilter_action into ASIC. The starting
+ *      index(es) is filter_id.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_cfg_add(rtk_filter_id_t filter_id, rtk_filter_cfg_t* pFilter_cfg, rtk_filter_action_t* pFilter_action, rtk_filter_number_t *ruleNum)
+{
+    rtk_api_ret_t               retVal;
+    rtk_uint32                  careTagData, careTagMask;
+    rtk_uint32                  i,vidx, svidx, actType, ruleId;
+    rtk_uint32                  aclActCtrl;
+    rtk_uint32                  cpuPort;
+    rtk_filter_field_t*         fieldPtr;
+    rtl8367c_aclrule            aclRule[RTL8367C_ACLTEMPLATENO];
+    rtl8367c_aclrule            tempRule;
+    rtl8367c_acl_act_t          aclAct;
+    rtk_uint32                  noRulesAdd;
+    rtk_uint32                  portmask;
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(filter_id > RTL8367C_ACLRULEMAX )
+        return RT_ERR_ENTRY_INDEX;
+
+    if((NULL == pFilter_cfg) || (NULL == pFilter_action) || (NULL == ruleNum))
+        return RT_ERR_NULL_POINTER;
+
+    fieldPtr = pFilter_cfg->fieldHead;
+
+    /* init RULE */
+    for(i = 0; i < RTL8367C_ACLTEMPLATENO; i++)
+    {
+        memset(&aclRule[i], 0, sizeof(rtl8367c_aclrule));
+
+        aclRule[i].data_bits.type= i;
+        aclRule[i].care_bits.type= 0x7;
+    }
+
+    while(NULL != fieldPtr)
+    {
+        _rtk_filter_igrAcl_writeDataField(aclRule, fieldPtr);
+
+        fieldPtr = fieldPtr->next;
+    }
+
+    /*set care tag mask in User Defined Field 15*/
+    /*Follow care tag should not be used while ACL template and User defined fields are fully control by system designer*/
+    /*those advanced packet type care tag is used in default template design structure only*/
+    careTagData = 0;
+    careTagMask = 0;
+
+    for(i = CARE_TAG_TCP; i < CARE_TAG_END; i++)
+    {
+        if(pFilter_cfg->careTag.tagType[i].mask)
+            careTagMask = careTagMask | (1 << (i-CARE_TAG_TCP));
+
+        if(pFilter_cfg->careTag.tagType[i].value)
+            careTagData = careTagData | (1 << (i-CARE_TAG_TCP));
+    }
+
+    if(careTagData || careTagMask)
+    {
+        i = 0;
+        while(i < RTL8367C_ACLTEMPLATENO)
+        {
+            if(aclRule[i].valid == 1 && filter_advanceCaretagField[i][0] == TRUE)
+            {
+
+                aclRule[i].data_bits.field[filter_advanceCaretagField[i][1]] = careTagData & 0xFFFF;
+                aclRule[i].care_bits.field[filter_advanceCaretagField[i][1]] = careTagMask & 0xFFFF;
+                break;
+            }
+            i++;
+        }
+        /*none of previous used template containing field 15*/
+        if(i == RTL8367C_ACLTEMPLATENO)
+        {
+            i = 0;
+            while(i < RTL8367C_ACLTEMPLATENO)
+            {
+                if(filter_advanceCaretagField[i][0] == TRUE)
+                {
+                    aclRule[i].data_bits.field[filter_advanceCaretagField[i][1]] = careTagData & 0xFFFF;
+                    aclRule[i].care_bits.field[filter_advanceCaretagField[i][1]] = careTagMask & 0xFFFF;
+                    aclRule[i].valid = 1;
+                    break;
+                }
+                i++;
+            }
+        }
+    }
+
+    /*Check rule number*/
+    noRulesAdd = 0;
+    for(i = 0; i < RTL8367C_ACLTEMPLATENO; i++)
+    {
+        if(1 == aclRule[i].valid)
+        {
+            noRulesAdd ++;
+        }
+    }
+
+    *ruleNum = noRulesAdd;
+
+    if((filter_id + noRulesAdd - 1) > RTL8367C_ACLRULEMAX)
+    {
+        return RT_ERR_ENTRY_INDEX;
+    }
+
+    /*set care tag mask in TAG Indicator*/
+    careTagData = 0;
+    careTagMask = 0;
+
+    for(i = 0; i <= CARE_TAG_IPV6;i++)
+    {
+        if(0 == pFilter_cfg->careTag.tagType[i].mask )
+        {
+            careTagMask &=  ~(1 << i);
+        }
+        else
+        {
+            careTagMask |= (1 << i);
+            if(0 == pFilter_cfg->careTag.tagType[i].value )
+                careTagData &= ~(1 << i);
+            else
+                careTagData |= (1 << i);
+        }
+    }
+
+    for(i = 0; i < RTL8367C_ACLTEMPLATENO; i++)
+    {
+        aclRule[i].data_bits.tag_exist = (careTagData) & ACL_RULE_CARETAG_MASK;
+        aclRule[i].care_bits.tag_exist = (careTagMask) & ACL_RULE_CARETAG_MASK;
+    }
+
+    RTK_CHK_PORTMASK_VALID(&pFilter_cfg->activeport.value);
+    RTK_CHK_PORTMASK_VALID(&pFilter_cfg->activeport.mask);
+
+    for(i = 0; i < RTL8367C_ACLTEMPLATENO; i++)
+    {
+        if(TRUE == aclRule[i].valid)
+        {
+            if(rtk_switch_portmask_L2P_get(&pFilter_cfg->activeport.value, &portmask) != RT_ERR_OK)
+                return RT_ERR_PORT_MASK;
+
+            aclRule[i].data_bits.active_portmsk = portmask;
+
+            if(rtk_switch_portmask_L2P_get(&pFilter_cfg->activeport.mask, &portmask) != RT_ERR_OK)
+                return RT_ERR_PORT_MASK;
+
+            aclRule[i].care_bits.active_portmsk = portmask;
+        }
+    }
+
+    if(pFilter_cfg->invert >= FILTER_INVERT_END )
+        return RT_ERR_INPUT;
+
+
+    /*Last action gets high priority if actions are the same*/
+    memset(&aclAct, 0, sizeof(rtl8367c_acl_act_t));
+    aclActCtrl = 0;
+    for(actType = 0; actType < FILTER_ENACT_END; actType ++)
+    {
+        if(pFilter_action->actEnable[actType])
+        {
+            switch (actType)
+            {
+            case FILTER_ENACT_CVLAN_INGRESS:
+                if(pFilter_action->filterCvlanVid > RTL8367C_EVIDMAX)
+                    return RT_ERR_INPUT;
+
+                if((retVal = rtk_vlan_checkAndCreateMbr(pFilter_action->filterCvlanVid, &vidx)) != RT_ERR_OK)
+                {
+                    return retVal;
+                }
+                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
+                aclAct.cvidx_cact = vidx;
+
+                if(aclActCtrl &(FILTER_ENACT_CVLAN_MASK))
+                {
+                    if(aclAct.cact_ext == FILTER_ENACT_CACTEXT_TAGONLY)
+                        aclAct.cact_ext = FILTER_ENACT_CACTEXT_BOTHVLANTAG;
+                }
+                else
+                {
+                    aclAct.cact_ext = FILTER_ENACT_CACTEXT_VLANONLY;
+                }
+
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+            case FILTER_ENACT_CVLAN_EGRESS:
+                if(pFilter_action->filterCvlanVid > RTL8367C_EVIDMAX)
+                    return RT_ERR_INPUT;
+
+                if((retVal = rtk_vlan_checkAndCreateMbr(pFilter_action->filterCvlanVid, &vidx)) != RT_ERR_OK)
+                    return retVal;
+
+                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
+                aclAct.cvidx_cact = vidx;
+
+                if(aclActCtrl &(FILTER_ENACT_CVLAN_MASK))
+                {
+                    if(aclAct.cact_ext == FILTER_ENACT_CACTEXT_TAGONLY)
+                        aclAct.cact_ext = FILTER_ENACT_CACTEXT_BOTHVLANTAG;
+                }
+                else
+                {
+                    aclAct.cact_ext = FILTER_ENACT_CACTEXT_VLANONLY;
+                }
+
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+             case FILTER_ENACT_CVLAN_SVID:
+
+                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
+
+                if(aclActCtrl &(FILTER_ENACT_CVLAN_MASK))
+                {
+                    if(aclAct.cact_ext == FILTER_ENACT_CACTEXT_TAGONLY)
+                        aclAct.cact_ext = FILTER_ENACT_CACTEXT_BOTHVLANTAG;
+                }
+                else
+                {
+                    aclAct.cact_ext = FILTER_ENACT_CACTEXT_VLANONLY;
+                }
+
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+             case FILTER_ENACT_POLICING_1:
+                if(pFilter_action->filterPolicingIdx[1] >= (RTK_METER_NUM + RTL8367C_MAX_LOG_CNT_NUM))
+                    return RT_ERR_INPUT;
+
+                aclAct.cact = FILTER_ENACT_CVLAN_TYPE(actType);
+                aclAct.cvidx_cact = pFilter_action->filterPolicingIdx[1];
+
+                if(aclActCtrl &(FILTER_ENACT_CVLAN_MASK))
+                {
+                    if(aclAct.cact_ext == FILTER_ENACT_CACTEXT_TAGONLY)
+                        aclAct.cact_ext = FILTER_ENACT_CACTEXT_BOTHVLANTAG;
+                }
+                else
+                {
+                    aclAct.cact_ext = FILTER_ENACT_CACTEXT_VLANONLY;
+                }
+
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+
+            case FILTER_ENACT_SVLAN_INGRESS:
+            case FILTER_ENACT_SVLAN_EGRESS:
+
+                if((retVal = rtk_svlan_checkAndCreateMbr(pFilter_action->filterSvlanVid, &svidx)) != RT_ERR_OK)
+                    return retVal;
+
+                aclAct.sact = FILTER_ENACT_SVLAN_TYPE(actType);
+                aclAct.svidx_sact = svidx;
+                aclActCtrl |= FILTER_ENACT_SVLAN_MASK;
+                break;
+            case FILTER_ENACT_SVLAN_CVID:
+
+                aclAct.sact = FILTER_ENACT_SVLAN_TYPE(actType);
+                aclActCtrl |= FILTER_ENACT_SVLAN_MASK;
+                break;
+            case FILTER_ENACT_POLICING_2:
+                if(pFilter_action->filterPolicingIdx[2] >= (RTK_METER_NUM + RTL8367C_MAX_LOG_CNT_NUM))
+                    return RT_ERR_INPUT;
+
+                aclAct.sact = FILTER_ENACT_SVLAN_TYPE(actType);
+                aclAct.svidx_sact = pFilter_action->filterPolicingIdx[2];
+                aclActCtrl |= FILTER_ENACT_SVLAN_MASK;
+                break;
+            case FILTER_ENACT_POLICING_0:
+                if(pFilter_action->filterPolicingIdx[0] >= (RTK_METER_NUM + RTL8367C_MAX_LOG_CNT_NUM))
+                    return RT_ERR_INPUT;
+
+                aclAct.aclmeteridx = pFilter_action->filterPolicingIdx[0];
+                aclActCtrl |= FILTER_ENACT_POLICING_MASK;
+                break;
+            case FILTER_ENACT_PRIORITY:
+            case FILTER_ENACT_1P_REMARK:
+                if(pFilter_action->filterPriority > RTL8367C_PRIMAX)
+                    return RT_ERR_INPUT;
+
+                aclAct.priact = FILTER_ENACT_PRI_TYPE(actType);
+                aclAct.pridx = pFilter_action->filterPriority;
+                aclActCtrl |= FILTER_ENACT_PRIORITY_MASK;
+                break;
+            case FILTER_ENACT_DSCP_REMARK:
+                if(pFilter_action->filterPriority > RTL8367C_DSCPMAX)
+                    return RT_ERR_INPUT;
+
+                aclAct.priact = FILTER_ENACT_PRI_TYPE(actType);
+                aclAct.pridx = pFilter_action->filterPriority;
+                aclActCtrl |= FILTER_ENACT_PRIORITY_MASK;
+                break;
+            case FILTER_ENACT_POLICING_3:
+                if(pFilter_action->filterPriority >= (RTK_METER_NUM + RTL8367C_MAX_LOG_CNT_NUM))
+                    return RT_ERR_INPUT;
+
+                aclAct.priact = FILTER_ENACT_PRI_TYPE(actType);
+                aclAct.pridx = pFilter_action->filterPolicingIdx[3];
+                aclActCtrl |= FILTER_ENACT_PRIORITY_MASK;
+                break;
+            case FILTER_ENACT_DROP:
+
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(FILTER_ENACT_REDIRECT);
+                aclAct.fwdact_ext = FALSE;
+
+                aclAct.fwdpmask = 0;
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+            case FILTER_ENACT_REDIRECT:
+                RTK_CHK_PORTMASK_VALID(&pFilter_action->filterPortmask);
+
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
+                aclAct.fwdact_ext = FALSE;
+
+                if(rtk_switch_portmask_L2P_get(&pFilter_action->filterPortmask, &portmask) != RT_ERR_OK)
+                    return RT_ERR_PORT_MASK;
+                aclAct.fwdpmask = portmask;
+
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+
+            case FILTER_ENACT_ADD_DSTPORT:
+                RTK_CHK_PORTMASK_VALID(&pFilter_action->filterPortmask);
+
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
+                aclAct.fwdact_ext = FALSE;
+
+                if(rtk_switch_portmask_L2P_get(&pFilter_action->filterPortmask, &portmask) != RT_ERR_OK)
+                    return RT_ERR_PORT_MASK;
+                aclAct.fwdpmask = portmask;
+
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+            case FILTER_ENACT_MIRROR:
+                RTK_CHK_PORTMASK_VALID(&pFilter_action->filterPortmask);
+
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
+                aclAct.cact_ext = FALSE;
+
+                if(rtk_switch_portmask_L2P_get(&pFilter_action->filterPortmask, &portmask) != RT_ERR_OK)
+                    return RT_ERR_PORT_MASK;
+                aclAct.fwdpmask = portmask;
+
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+            case FILTER_ENACT_TRAP_CPU:
+
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(actType);
+                aclAct.fwdact_ext = FALSE;
+
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+            case FILTER_ENACT_COPY_CPU:
+                if((retVal = rtl8367c_getAsicCputagTrapPort(&cpuPort)) != RT_ERR_OK)
+                    return retVal;
+
+                aclAct.fwdact = FILTER_ENACT_FWD_TYPE(FILTER_ENACT_MIRROR);
+                aclAct.fwdact_ext = FALSE;
+
+                aclAct.fwdpmask = 1 << cpuPort;
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+            case FILTER_ENACT_ISOLATION:
+                RTK_CHK_PORTMASK_VALID(&pFilter_action->filterPortmask);
+
+                aclAct.fwdact_ext = TRUE;
+
+                if(rtk_switch_portmask_L2P_get(&pFilter_action->filterPortmask, &portmask) != RT_ERR_OK)
+                    return RT_ERR_PORT_MASK;
+                aclAct.fwdpmask = portmask;
+
+                aclActCtrl |= FILTER_ENACT_FWD_MASK;
+                break;
+
+            case FILTER_ENACT_INTERRUPT:
+
+                aclAct.aclint = TRUE;
+                aclActCtrl |= FILTER_ENACT_INTGPIO_MASK;
+                break;
+            case FILTER_ENACT_GPO:
+
+                aclAct.gpio_en = TRUE;
+                aclAct.gpio_pin = pFilter_action->filterPin;
+                aclActCtrl |= FILTER_ENACT_INTGPIO_MASK;
+                break;
+             case FILTER_ENACT_EGRESSCTAG_TAG:
+
+                if(aclActCtrl &(FILTER_ENACT_CVLAN_MASK))
+                {
+                    if(aclAct.cact_ext == FILTER_ENACT_CACTEXT_VLANONLY)
+                        aclAct.cact_ext = FILTER_ENACT_CACTEXT_BOTHVLANTAG;
+                }
+                else
+                {
+                    aclAct.cact_ext = FILTER_ENACT_CACTEXT_TAGONLY;
+                }
+                aclAct.tag_fmt = FILTER_CTAGFMT_TAG;
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+             case FILTER_ENACT_EGRESSCTAG_UNTAG:
+
+                if(aclActCtrl &(FILTER_ENACT_CVLAN_MASK))
+                {
+                    if(aclAct.cact_ext == FILTER_ENACT_CACTEXT_VLANONLY)
+                        aclAct.cact_ext = FILTER_ENACT_CACTEXT_BOTHVLANTAG;
+                }
+                else
+                {
+                    aclAct.cact_ext = FILTER_ENACT_CACTEXT_TAGONLY;
+                }
+                aclAct.tag_fmt = FILTER_CTAGFMT_UNTAG;
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+             case FILTER_ENACT_EGRESSCTAG_KEEP:
+
+                if(aclActCtrl &(FILTER_ENACT_CVLAN_MASK))
+                {
+                    if(aclAct.cact_ext == FILTER_ENACT_CACTEXT_VLANONLY)
+                        aclAct.cact_ext = FILTER_ENACT_CACTEXT_BOTHVLANTAG;
+                }
+                else
+                {
+                    aclAct.cact_ext = FILTER_ENACT_CACTEXT_TAGONLY;
+                }
+                aclAct.tag_fmt = FILTER_CTAGFMT_KEEP;
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+             case FILTER_ENACT_EGRESSCTAG_KEEPAND1PRMK:
+
+                if(aclActCtrl &(FILTER_ENACT_CVLAN_MASK))
+                {
+                    if(aclAct.cact_ext == FILTER_ENACT_CACTEXT_VLANONLY)
+                        aclAct.cact_ext = FILTER_ENACT_CACTEXT_BOTHVLANTAG;
+                }
+                else
+                {
+                    aclAct.cact_ext = FILTER_ENACT_CACTEXT_TAGONLY;
+                }
+                aclAct.tag_fmt = FILTER_CTAGFMT_KEEP1PRMK;
+                aclActCtrl |= FILTER_ENACT_CVLAN_MASK;
+                break;
+           default:
+                return RT_ERR_FILTER_INACL_ACT_NOT_SUPPORT;
+            }
+        }
+    }
+
+
+    /*check if free ACL rules are enough*/
+    for(i = filter_id; i < (filter_id + noRulesAdd); i++)
+    {
+        if((retVal = rtl8367c_getAsicAclRule(i, &tempRule)) != RT_ERR_OK )
+            return retVal;
+
+        if(tempRule.valid == TRUE)
+        {
+            return RT_ERR_TBL_FULL;
+        }
+    }
+
+    ruleId = 0;
+    for(i = 0; i < RTL8367C_ACLTEMPLATENO; i++)
+    {
+        if(aclRule[i].valid == TRUE)
+        {
+            /* write ACL action control */
+            if((retVal = rtl8367c_setAsicAclActCtrl(filter_id + ruleId, aclActCtrl)) != RT_ERR_OK )
+                return retVal;
+            /* write ACL action */
+            if((retVal = rtl8367c_setAsicAclAct(filter_id + ruleId, &aclAct)) != RT_ERR_OK )
+                return retVal;
+
+            /* write ACL not */
+            if((retVal = rtl8367c_setAsicAclNot(filter_id + ruleId, pFilter_cfg->invert)) != RT_ERR_OK )
+                return retVal;
+            /* write ACL rule */
+            if((retVal = rtl8367c_setAsicAclRule(filter_id + ruleId, &aclRule[i])) != RT_ERR_OK )
+                return retVal;
+
+            /* only the first rule will be written with input action control, aclActCtrl of other rules will be zero */
+            aclActCtrl = 0;
+            memset(&aclAct, 0, sizeof(rtl8367c_acl_act_t));
+
+            ruleId ++;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_cfg_del
+ * Description:
+ *      Delete an ACL configuration from ASIC
+ * Input:
+ *      filter_id   - Start index of ACL configuration.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_ENTRYIDX  - Invalid filter_id.
+ * Note:
+ *      This function delete a group of ACL rules starting from filter_id.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_cfg_del(rtk_filter_id_t filter_id)
+{
+    rtl8367c_aclrule initRule;
+    rtl8367c_acl_act_t  initAct;
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(filter_id > RTL8367C_ACLRULEMAX )
+        return RT_ERR_FILTER_ENTRYIDX;
+
+    memset(&initRule, 0, sizeof(rtl8367c_aclrule));
+    memset(&initAct, 0, sizeof(rtl8367c_acl_act_t));
+
+    if((ret = rtl8367c_setAsicAclRule(filter_id, &initRule)) != RT_ERR_OK)
+        return ret;
+    if((ret = rtl8367c_setAsicAclActCtrl(filter_id, FILTER_ENACT_INIT_MASK))!= RT_ERR_OK)
+        return ret;
+    if((ret = rtl8367c_setAsicAclAct(filter_id, &initAct)) != RT_ERR_OK)
+        return ret;
+    if((ret = rtl8367c_setAsicAclNot(filter_id, DISABLED)) != RT_ERR_OK )
+        return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_cfg_delAll
+ * Description:
+ *      Delete all ACL entries from ASIC
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      This function delete all ACL configuration from ASIC.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_cfg_delAll(void)
+{
+    rtk_uint32            i;
+    rtk_api_ret_t     ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    for(i = 0; i < RTL8367C_ACLRULENO; i++)
+    {
+        if((ret = rtl8367c_setAsicAclActCtrl(i, FILTER_ENACT_INIT_MASK))!= RT_ERR_OK)
+            return ret;
+        if((ret = rtl8367c_setAsicAclNot(i, DISABLED)) != RT_ERR_OK )
+            return ret;
+    }
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_ACL_RESET_CFG, RTL8367C_ACL_RESET_CFG_OFFSET, TRUE);;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_cfg_get
+ * Description:
+ *      Get one ingress acl configuration from ASIC.
+ * Input:
+ *      filter_id       - Start index of ACL configuration.
+ * Output:
+ *      pFilter_cfg     - buffer pointer of ingress acl data
+ *      pFilter_action  - buffer pointer of ingress acl action
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Pointer pFilter_action or pFilter_cfg point to NULL.
+ *      RT_ERR_FILTER_ENTRYIDX  - Invalid entry index.
+ * Note:
+ *      This function get configuration from ASIC.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_cfg_get(rtk_filter_id_t filter_id, rtk_filter_cfg_raw_t *pFilter_cfg, rtk_filter_action_t *pAction)
+{
+    rtk_api_ret_t               retVal;
+    rtk_uint32                  i, tmp;
+    rtl8367c_aclrule            aclRule;
+    rtl8367c_acl_act_t          aclAct;
+    rtk_uint32                  cpuPort;
+    rtl8367c_acltemplate_t      type;
+    rtl8367c_svlan_memconf_t    svlan_cfg;
+    rtl8367c_vlanconfiguser     vlanMC;
+    rtk_uint32                  phyPmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pFilter_cfg || NULL == pAction)
+        return RT_ERR_NULL_POINTER;
+
+    if(filter_id > RTL8367C_ACLRULEMAX)
+        return RT_ERR_ENTRY_INDEX;
+
+    if ((retVal = rtl8367c_getAsicAclRule(filter_id, &aclRule)) != RT_ERR_OK)
+        return retVal;
+
+    /* Check valid */
+    if(aclRule.valid == 0)
+    {
+        pFilter_cfg->valid = DISABLED;
+        return RT_ERR_OK;
+    }
+
+    phyPmask = aclRule.data_bits.active_portmsk;
+    if(rtk_switch_portmask_P2L_get(phyPmask,&(pFilter_cfg->activeport.value)) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    phyPmask = aclRule.care_bits.active_portmsk;
+    if(rtk_switch_portmask_P2L_get(phyPmask,&(pFilter_cfg->activeport.mask)) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    for(i = 0; i <= CARE_TAG_IPV6; i++)
+    {
+        if(aclRule.data_bits.tag_exist & (1 << i))
+            pFilter_cfg->careTag.tagType[i].value = 1;
+        else
+            pFilter_cfg->careTag.tagType[i].value = 0;
+
+        if (aclRule.care_bits.tag_exist & (1 << i))
+            pFilter_cfg->careTag.tagType[i].mask = 1;
+        else
+            pFilter_cfg->careTag.tagType[i].mask = 0;
+    }
+
+    if(filter_advanceCaretagField[aclRule.data_bits.type][0] == TRUE)
+    {
+        /* Advanced Care tag setting */
+        for(i = CARE_TAG_TCP; i < CARE_TAG_END; i++)
+        {
+            if(aclRule.data_bits.field[filter_advanceCaretagField[aclRule.data_bits.type][1]] & (0x0001 << (i-CARE_TAG_TCP)) )
+                pFilter_cfg->careTag.tagType[i].value = 1;
+            else
+                pFilter_cfg->careTag.tagType[i].value = 0;
+
+            if(aclRule.care_bits.field[filter_advanceCaretagField[aclRule.care_bits.type][1]] & (0x0001 << (i-CARE_TAG_TCP)) )
+                pFilter_cfg->careTag.tagType[i].mask = 1;
+            else
+                pFilter_cfg->careTag.tagType[i].mask = 0;
+        }
+    }
+
+    for(i = 0; i < RTL8367C_ACLRULEFIELDNO; i++)
+    {
+        pFilter_cfg->careFieldRaw[i] = aclRule.care_bits.field[i];
+        pFilter_cfg->dataFieldRaw[i] = aclRule.data_bits.field[i];
+    }
+
+    if ((retVal = rtl8367c_getAsicAclNot(filter_id, &tmp))!= RT_ERR_OK)
+        return retVal;
+
+    pFilter_cfg->invert = tmp;
+
+    pFilter_cfg->valid = aclRule.valid;
+
+    memset(pAction, 0, sizeof(rtk_filter_action_t));
+
+    if ((retVal = rtl8367c_getAsicAclActCtrl(filter_id, &tmp))!= RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicAclAct(filter_id, &aclAct)) != RT_ERR_OK)
+        return retVal;
+
+    if(tmp & FILTER_ENACT_FWD_MASK)
+    {
+        if(TRUE == aclAct.fwdact_ext)
+        {
+            pAction->actEnable[FILTER_ENACT_ISOLATION] = TRUE;
+
+            phyPmask = aclAct.fwdpmask;
+            if(rtk_switch_portmask_P2L_get(phyPmask,&(pAction->filterPortmask)) != RT_ERR_OK)
+                return RT_ERR_FAILED;
+        }
+        else if(aclAct.fwdact == RTL8367C_ACL_FWD_TRAP)
+        {
+            pAction->actEnable[FILTER_ENACT_TRAP_CPU] = TRUE;
+        }
+        else if (aclAct.fwdact == RTL8367C_ACL_FWD_MIRRORFUNTION )
+        {
+            pAction->actEnable[FILTER_ENACT_MIRROR] = TRUE;
+
+            phyPmask = aclAct.fwdpmask;
+            if(rtk_switch_portmask_P2L_get(phyPmask,&(pAction->filterPortmask)) != RT_ERR_OK)
+                return RT_ERR_FAILED;
+        }
+        else if (aclAct.fwdact == RTL8367C_ACL_FWD_REDIRECT)
+        {
+            if(aclAct.fwdpmask == 0 )
+                pAction->actEnable[FILTER_ENACT_DROP] = TRUE;
+            else
+            {
+                pAction->actEnable[FILTER_ENACT_REDIRECT] = TRUE;
+
+                phyPmask = aclAct.fwdpmask;
+                if(rtk_switch_portmask_P2L_get(phyPmask,&(pAction->filterPortmask)) != RT_ERR_OK)
+                    return RT_ERR_FAILED;
+            }
+        }
+        else if (aclAct.fwdact == RTL8367C_ACL_FWD_MIRROR)
+        {
+            if((retVal = rtl8367c_getAsicCputagTrapPort(&cpuPort)) != RT_ERR_OK)
+                return retVal;
+            if (aclAct.fwdpmask == (1 << cpuPort))
+            {
+                pAction->actEnable[FILTER_ENACT_COPY_CPU] = TRUE;
+            }
+            else
+            {
+                pAction->actEnable[FILTER_ENACT_ADD_DSTPORT] = TRUE;
+
+                phyPmask = aclAct.fwdpmask;
+                if(rtk_switch_portmask_P2L_get(phyPmask,&(pAction->filterPortmask)) != RT_ERR_OK)
+                    return RT_ERR_FAILED;
+            }
+        }
+        else
+        {
+            return RT_ERR_FAILED;
+        }
+    }
+
+    if(tmp & FILTER_ENACT_POLICING_MASK)
+    {
+        pAction->actEnable[FILTER_ENACT_POLICING_0] = TRUE;
+        pAction->filterPolicingIdx[0] = aclAct.aclmeteridx;
+    }
+
+    if(tmp & FILTER_ENACT_PRIORITY_MASK)
+    {
+        if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_PRIORITY))
+        {
+            pAction->actEnable[FILTER_ENACT_PRIORITY] = TRUE;
+            pAction->filterPriority = aclAct.pridx;
+        }
+        else if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_1P_REMARK))
+        {
+            pAction->actEnable[FILTER_ENACT_1P_REMARK] = TRUE;
+            pAction->filterPriority = aclAct.pridx;
+        }
+        else if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_DSCP_REMARK))
+        {
+            pAction->actEnable[FILTER_ENACT_DSCP_REMARK] = TRUE;
+            pAction->filterPriority = aclAct.pridx;
+        }
+        else if(aclAct.priact == FILTER_ENACT_PRI_TYPE(FILTER_ENACT_POLICING_3))
+        {
+            pAction->actEnable[FILTER_ENACT_POLICING_3] = TRUE;
+            pAction->filterPolicingIdx[3]  = aclAct.pridx;
+        }
+    }
+
+    if(tmp & FILTER_ENACT_SVLAN_MASK)
+    {
+        if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_SVLAN_INGRESS))
+        {
+            if((retVal = rtl8367c_getAsicSvlanMemberConfiguration(aclAct.svidx_sact, &svlan_cfg)) != RT_ERR_OK)
+                return retVal;
+
+            pAction->actEnable[FILTER_ENACT_SVLAN_INGRESS] = TRUE;
+            pAction->filterSvlanIdx = aclAct.svidx_sact;
+            pAction->filterSvlanVid = svlan_cfg.vs_svid;
+        }
+        else if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_SVLAN_EGRESS))
+        {
+            if((retVal = rtl8367c_getAsicSvlanMemberConfiguration(aclAct.svidx_sact, &svlan_cfg)) != RT_ERR_OK)
+                return retVal;
+
+            pAction->actEnable[FILTER_ENACT_SVLAN_EGRESS] = TRUE;
+            pAction->filterSvlanIdx = aclAct.svidx_sact;
+            pAction->filterSvlanVid = svlan_cfg.vs_svid;
+        }
+        else if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_SVLAN_CVID))
+            pAction->actEnable[FILTER_ENACT_SVLAN_CVID] = TRUE;
+        else if(aclAct.sact == FILTER_ENACT_SVLAN_TYPE(FILTER_ENACT_POLICING_2))
+        {
+            pAction->actEnable[FILTER_ENACT_POLICING_2] = TRUE;
+            pAction->filterPolicingIdx[2]  = aclAct.svidx_sact;
+        }
+    }
+
+
+    if(tmp & FILTER_ENACT_CVLAN_MASK)
+    {
+        if(FILTER_ENACT_CACTEXT_TAGONLY == aclAct.cact_ext ||
+            FILTER_ENACT_CACTEXT_BOTHVLANTAG == aclAct.cact_ext )
+        {
+            if(FILTER_CTAGFMT_UNTAG == aclAct.tag_fmt)
+            {
+                pAction->actEnable[FILTER_ENACT_EGRESSCTAG_UNTAG] = TRUE;
+            }
+            else if(FILTER_CTAGFMT_TAG == aclAct.tag_fmt)
+            {
+                pAction->actEnable[FILTER_ENACT_EGRESSCTAG_TAG] = TRUE;
+            }
+            else if(FILTER_CTAGFMT_KEEP == aclAct.tag_fmt)
+            {
+                pAction->actEnable[FILTER_ENACT_EGRESSCTAG_KEEP] = TRUE;
+            }
+             else if(FILTER_CTAGFMT_KEEP1PRMK== aclAct.tag_fmt)
+            {
+                pAction->actEnable[FILTER_ENACT_EGRESSCTAG_KEEPAND1PRMK] = TRUE;
+            }
+
+        }
+
+        if(FILTER_ENACT_CACTEXT_VLANONLY == aclAct.cact_ext ||
+            FILTER_ENACT_CACTEXT_BOTHVLANTAG == aclAct.cact_ext )
+        {
+            if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_INGRESS))
+            {
+                if((retVal = rtl8367c_getAsicVlanMemberConfig(aclAct.cvidx_cact, &vlanMC)) != RT_ERR_OK)
+                    return retVal;
+
+                pAction->actEnable[FILTER_ENACT_CVLAN_INGRESS] = TRUE;
+                pAction->filterCvlanIdx  = aclAct.cvidx_cact;
+                pAction->filterCvlanVid  = vlanMC.evid;
+            }
+            else if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_EGRESS))
+            {
+                if((retVal = rtl8367c_getAsicVlanMemberConfig(aclAct.cvidx_cact, &vlanMC)) != RT_ERR_OK)
+                    return retVal;
+
+                pAction->actEnable[FILTER_ENACT_CVLAN_EGRESS] = TRUE;
+                pAction->filterCvlanIdx  = aclAct.cvidx_cact;
+                pAction->filterCvlanVid  = vlanMC.evid;
+            }
+            else if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_CVLAN_SVID))
+            {
+                pAction->actEnable[FILTER_ENACT_CVLAN_SVID] = TRUE;
+            }
+            else if(aclAct.cact == FILTER_ENACT_CVLAN_TYPE(FILTER_ENACT_POLICING_1))
+            {
+                pAction->actEnable[FILTER_ENACT_POLICING_1] = TRUE;
+                pAction->filterPolicingIdx[1]  = aclAct.cvidx_cact;
+            }
+        }
+    }
+
+    if(tmp & FILTER_ENACT_INTGPIO_MASK)
+    {
+        if(TRUE == aclAct.aclint)
+        {
+            pAction->actEnable[FILTER_ENACT_INTERRUPT] = TRUE;
+        }
+
+        if(TRUE == aclAct.gpio_en)
+        {
+            pAction->actEnable[FILTER_ENACT_GPO] = TRUE;
+            pAction->filterPin = aclAct.gpio_pin;
+        }
+    }
+
+    /* Get field type of RAW data */
+    if ((retVal = rtl8367c_getAsicAclTemplate(aclRule.data_bits.type, &type))!= RT_ERR_OK)
+        return retVal;
+
+    for(i = 0; i < RTL8367C_ACLRULEFIELDNO; i++)
+    {
+        pFilter_cfg->fieldRawType[i] = type.field[i];
+    }/* end of for(i...) */
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_unmatchAction_set
+ * Description:
+ *      Set action to packets when no ACL configuration match
+ * Input:
+ *      port    - Port id.
+ *      action  - Action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port id.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This function sets action of packets when no ACL configruation matches.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_unmatchAction_set(rtk_port_t port, rtk_filter_unmatch_action_t action)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(action >= FILTER_UNMATCH_END)
+        return RT_ERR_INPUT;
+
+    if((ret = rtl8367c_setAsicAclUnmatchedPermit(rtk_switch_port_L2P_get(port), action)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_unmatchAction_get
+ * Description:
+ *      Get action to packets when no ACL configuration match
+ * Input:
+ *      port    - Port id.
+ * Output:
+ *      pAction - Action.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port id.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This function gets action of packets when no ACL configruation matches.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_unmatchAction_get(rtk_port_t port, rtk_filter_unmatch_action_t* pAction)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pAction)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if((ret = rtl8367c_getAsicAclUnmatchedPermit(rtk_switch_port_L2P_get(port), pAction)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_state_set
+ * Description:
+ *      Set state of ingress ACL.
+ * Input:
+ *      port    - Port id.
+ *      state   - Ingress ACL state.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port id.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This function gets action of packets when no ACL configruation matches.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_state_set(rtk_port_t port, rtk_filter_state_t state)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(state >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if((ret = rtl8367c_setAsicAcl(rtk_switch_port_L2P_get(port), state)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_state_get
+ * Description:
+ *      Get state of ingress ACL.
+ * Input:
+ *      port    - Port id.
+ * Output:
+ *      pState  - Ingress ACL state.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port id.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This function gets action of packets when no ACL configruation matches.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_state_get(rtk_port_t port, rtk_filter_state_t* pState)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pState)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if((ret = rtl8367c_getAsicAcl(rtk_switch_port_L2P_get(port), pState)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtk_filter_igrAcl_template_set
+ * Description:
+ *      Set template of ingress ACL.
+ * Input:
+ *      template - Ingress ACL template
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Invalid input parameters.
+ * Note:
+ *      This function set ACL template.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_template_set(rtk_filter_template_t *aclTemplate)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 idxField;
+    rtl8367c_acltemplate_t aclType;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(aclTemplate->index >= RTK_MAX_NUM_OF_FILTER_TYPE)
+        return RT_ERR_INPUT;
+
+    for(idxField = 0; idxField < RTK_MAX_NUM_OF_FILTER_FIELD; idxField++)
+    {
+        if(aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_DMAC_15_0 ||
+            (aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_CTAG && aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_IPV4_SIP_15_0 ) ||
+            (aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_IPV4_DIP_31_16 && aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_IPV6_SIP_15_0 ) ||
+            (aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_IPV6_DIP_31_16 && aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_VIDRANGE ) ||
+            (aclTemplate->fieldType[idxField] > FILTER_FIELD_RAW_FIELD_VALID && aclTemplate->fieldType[idxField] < FILTER_FIELD_RAW_FIELD_SELECT00 ) ||
+            aclTemplate->fieldType[idxField] >= FILTER_FIELD_RAW_END)
+        {
+            return RT_ERR_INPUT;
+        }
+    }
+
+    for(idxField = 0; idxField < RTK_MAX_NUM_OF_FILTER_FIELD; idxField++)
+    {
+        aclType.field[idxField] = aclTemplate->fieldType[idxField];
+    }
+
+    if((retVal = rtl8367c_setAsicAclTemplate(aclTemplate->index, &aclType)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_template_get
+ * Description:
+ *      Get template of ingress ACL.
+ * Input:
+ *      template - Ingress ACL template
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This function gets template of ACL.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_template_get(rtk_filter_template_t *aclTemplate)
+{
+    rtk_api_ret_t ret;
+    rtk_uint32 idxField;
+    rtl8367c_acltemplate_t aclType;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == aclTemplate)
+        return RT_ERR_NULL_POINTER;
+
+    if(aclTemplate->index >= RTK_MAX_NUM_OF_FILTER_TYPE)
+        return RT_ERR_INPUT;
+
+   if((ret = rtl8367c_getAsicAclTemplate(aclTemplate->index, &aclType)) != RT_ERR_OK)
+       return ret;
+
+    for(idxField = 0; idxField < RTK_MAX_NUM_OF_FILTER_FIELD; idxField ++)
+    {
+        aclTemplate->fieldType[idxField] = aclType.field[idxField];
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_field_sel_set
+ * Description:
+ *      Set user defined field selectors in HSB
+ * Input:
+ *      index       - index of field selector 0-15
+ *      format      - Format of field selector
+ *      offset      - Retrieving data offset
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      System support 16 user defined field selctors.
+ *      Each selector can be enabled or disable.
+ *      User can defined retrieving 16-bits in many predefiend
+ *      standard l2/l3/l4 payload.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_field_sel_set(rtk_uint32 index, rtk_field_sel_t format, rtk_uint32 offset)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(index >= RTL8367C_FIELDSEL_FORMAT_NUMBER)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(format >= FORMAT_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(offset > RTL8367C_FIELDSEL_MAX_OFFSET)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((ret = rtl8367c_setAsicFieldSelector(index, (rtk_uint32)format, offset)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAcl_field_sel_get
+ * Description:
+ *      Get user defined field selectors in HSB
+ * Input:
+ *      index       - index of field selector 0-15
+ * Output:
+ *      pFormat     - Format of field selector
+ *      pOffset     - Retrieving data offset
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_filter_igrAcl_field_sel_get(rtk_uint32 index, rtk_field_sel_t *pFormat, rtk_uint32 *pOffset)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pFormat || NULL == pOffset)
+        return RT_ERR_NULL_POINTER;
+
+    if(index >= RTL8367C_FIELDSEL_FORMAT_NUMBER)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((ret = rtl8367c_getAsicFieldSelector(index, pFormat, pOffset)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_iprange_set
+ * Description:
+ *      Set IP Range check
+ * Input:
+ *      index       - index of IP Range 0-15
+ *      type        - IP Range check type, 0:Delete a entry, 1: IPv4_SIP, 2: IPv4_DIP, 3:IPv6_SIP, 4:IPv6_DIP
+ *      upperIp     - The upper bound of IP range
+ *      lowerIp     - The lower Bound of IP range
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
+ * Note:
+ *      upperIp must be larger or equal than lowerIp.
+ */
+rtk_api_ret_t rtk_filter_iprange_set(rtk_uint32 index, rtk_filter_iprange_t type, ipaddr_t upperIp, ipaddr_t lowerIp)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(type >= IPRANGE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(lowerIp > upperIp)
+        return RT_ERR_INPUT;
+
+    if((ret = rtl8367c_setAsicAclIpRange(index, type, upperIp, lowerIp)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_iprange_get
+ * Description:
+ *      Set IP Range check
+ * Input:
+ *      index       - index of IP Range 0-15
+ * Output:
+ *      pType        - IP Range check type, 0:Delete a entry, 1: IPv4_SIP, 2: IPv4_DIP, 3:IPv6_SIP, 4:IPv6_DIP
+ *      pUpperIp     - The upper bound of IP range
+ *      pLowerIp     - The lower Bound of IP range
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_filter_iprange_get(rtk_uint32 index, rtk_filter_iprange_t *pType, ipaddr_t *pUpperIp, ipaddr_t *pLowerIp)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if((NULL == pType) || (NULL == pUpperIp) || (NULL == pLowerIp))
+        return RT_ERR_NULL_POINTER;
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((ret = rtl8367c_getAsicAclIpRange(index, pType, pUpperIp, pLowerIp)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_vidrange_set
+ * Description:
+ *      Set VID Range check
+ * Input:
+ *      index       - index of VID Range 0-15
+ *      type        - IP Range check type, 0:Delete a entry, 1: CVID, 2: SVID
+ *      upperVid    - The upper bound of VID range
+ *      lowerVid    - The lower Bound of VID range
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
+ * Note:
+ *      upperVid must be larger or equal than lowerVid.
+ */
+rtk_api_ret_t rtk_filter_vidrange_set(rtk_uint32 index, rtk_filter_vidrange_t type, rtk_uint32 upperVid, rtk_uint32 lowerVid)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(type >= VIDRANGE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(lowerVid > upperVid)
+        return RT_ERR_INPUT;
+
+    if( (upperVid > RTL8367C_VIDMAX) || (lowerVid > RTL8367C_VIDMAX))
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((ret = rtl8367c_setAsicAclVidRange(index, type, upperVid, lowerVid)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_vidrange_get
+ * Description:
+ *      Get VID Range check
+ * Input:
+ *      index       - index of VID Range 0-15
+ * Output:
+ *      pType        - IP Range check type, 0:Unused, 1: CVID, 2: SVID
+ *      pUpperVid    - The upper bound of VID range
+ *      pLowerVid    - The lower Bound of VID range
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_filter_vidrange_get(rtk_uint32 index, rtk_filter_vidrange_t *pType, rtk_uint32 *pUpperVid, rtk_uint32 *pLowerVid)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if((NULL == pType) || (NULL == pUpperVid) || (NULL == pLowerVid))
+        return RT_ERR_NULL_POINTER;
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((ret = rtl8367c_getAsicAclVidRange(index, pType, pUpperVid, pLowerVid)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_portrange_set
+ * Description:
+ *      Set Port Range check
+ * Input:
+ *      index       - index of Port Range 0-15
+ *      type        - IP Range check type, 0:Delete a entry, 1: Source Port, 2: Destnation Port
+ *      upperPort   - The upper bound of Port range
+ *      lowerPort   - The lower Bound of Port range
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
+ * Note:
+ *      upperPort must be larger or equal than lowerPort.
+ */
+rtk_api_ret_t rtk_filter_portrange_set(rtk_uint32 index, rtk_filter_portrange_t type, rtk_uint32 upperPort, rtk_uint32 lowerPort)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(type >= PORTRANGE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(lowerPort > upperPort)
+        return RT_ERR_INPUT;
+
+    if(upperPort > RTL8367C_ACL_PORTRANGEMAX)
+        return RT_ERR_INPUT;
+
+    if(lowerPort > RTL8367C_ACL_PORTRANGEMAX)
+        return RT_ERR_INPUT;
+
+    if((ret = rtl8367c_setAsicAclPortRange(index, type, upperPort, lowerPort)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_portrange_get
+ * Description:
+ *      Set Port Range check
+ * Input:
+ *      index       - index of Port Range 0-15
+ * Output:
+ *      pType       - IP Range check type, 0:Delete a entry, 1: Source Port, 2: Destnation Port
+ *      pUpperPort  - The upper bound of Port range
+ *      pLowerPort  - The lower Bound of Port range
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_filter_portrange_get(rtk_uint32 index, rtk_filter_portrange_t *pType, rtk_uint32 *pUpperPort, rtk_uint32 *pLowerPort)
+{
+    rtk_api_ret_t ret;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if((NULL == pType) || (NULL == pUpperPort) || (NULL == pLowerPort))
+        return RT_ERR_NULL_POINTER;
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((ret = rtl8367c_getAsicAclPortRange(index, pType, pUpperPort, pLowerPort)) != RT_ERR_OK)
+       return ret;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_filter_igrAclPolarity_set
+ * Description:
+ *      Set ACL Goip control palarity
+ * Input:
+ *      polarity - 1: High, 0: Low
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      none
+ */
+rtk_api_ret_t rtk_filter_igrAclPolarity_set(rtk_uint32 polarity)
+{
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(polarity > 1)
+        return RT_ERR_OUT_OF_RANGE;
+    return rtl8367c_setAsicAclGpioPolarity(polarity);
+}
+/* Function Name:
+ *      rtk_filter_igrAclPolarity_get
+ * Description:
+ *      Get ACL Goip control palarity
+ * Input:
+ *      pPolarity - 1: High, 0: Low
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      none
+ */
+rtk_api_ret_t rtk_filter_igrAclPolarity_get(rtk_uint32* pPolarity)
+{
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPolarity)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicAclGpioPolarity(pPolarity);
+}
+
+
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/cpu.c b/drivers/net/phy/rtk/rtl8367c/cpu.c
new file mode 100644
index 0000000000000..599f1bb82cb4d
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/cpu.c
@@ -0,0 +1,537 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in CPU module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <cpu.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_cputag.h>
+
+/* Function Name:
+ *      rtk_cpu_enable_set
+ * Description:
+ *      Set CPU port function enable/disable.
+ * Input:
+ *      enable - CPU port function enable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can set CPU port function enable/disable.
+ */
+rtk_api_ret_t rtk_cpu_enable_set(rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicCputagEnable(enable)) != RT_ERR_OK)
+        return retVal;
+
+    if (DISABLED == enable)
+    {
+        if ((retVal = rtl8367c_setAsicCputagPortmask(0)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_enable_get
+ * Description:
+ *      Get CPU port and its setting.
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - CPU port function enable
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_L2_NO_CPU_PORT   - CPU port is not exist
+ * Note:
+ *      The API can get CPU port function enable/disable.
+ */
+rtk_api_ret_t rtk_cpu_enable_get(rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicCputagEnable(pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_tagPort_set
+ * Description:
+ *      Set CPU port and CPU tag insert mode.
+ * Input:
+ *      port - Port id.
+ *      mode - CPU tag insert for packets egress from CPU port.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can set CPU port and inserting proprietary CPU tag mode (Length/Type 0x8899)
+ *      to the frame that transmitting to CPU port.
+ *      The inset cpu tag mode is as following:
+ *      - CPU_INSERT_TO_ALL
+ *      - CPU_INSERT_TO_TRAPPING
+ *      - CPU_INSERT_TO_NONE
+ */
+rtk_api_ret_t rtk_cpu_tagPort_set(rtk_port_t port, rtk_cpu_insert_t mode)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (mode >= CPU_INSERT_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicCputagPortmask(1<<rtk_switch_port_L2P_get(port))) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicCputagTrapPort(rtk_switch_port_L2P_get(port))) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicCputagInsertMode(mode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_tagPort_get
+ * Description:
+ *      Get CPU port and CPU tag insert mode.
+ * Input:
+ *      None
+ * Output:
+ *      pPort - Port id.
+ *      pMode - CPU tag insert for packets egress from CPU port, 0:all insert 1:Only for trapped packets 2:no insert.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_L2_NO_CPU_PORT   - CPU port is not exist
+ * Note:
+ *      The API can get configured CPU port and its setting.
+ *      The inset cpu tag mode is as following:
+ *      - CPU_INSERT_TO_ALL
+ *      - CPU_INSERT_TO_TRAPPING
+ *      - CPU_INSERT_TO_NONE
+ */
+rtk_api_ret_t rtk_cpu_tagPort_get(rtk_port_t *pPort, rtk_cpu_insert_t *pMode)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmsk, port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPort)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pMode)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicCputagPortmask(&pmsk)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicCputagTrapPort(&port)) != RT_ERR_OK)
+        return retVal;
+
+    *pPort = rtk_switch_port_P2L_get(port);
+
+    if ((retVal = rtl8367c_getAsicCputagInsertMode(pMode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_cpu_awarePort_set
+ * Description:
+ *      Set CPU aware port mask.
+ * Input:
+ *      portmask - Port mask.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK      - Invalid port mask.
+ * Note:
+ *      The API can set configured CPU aware port mask.
+ */
+rtk_api_ret_t rtk_cpu_awarePort_set(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 phyMbrPmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Valid port mask */
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port mask valid */
+    RTK_CHK_PORTMASK_VALID(pPortmask);
+
+    if(rtk_switch_portmask_L2P_get(pPortmask, &phyMbrPmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    if ((retVal = rtl8367c_setAsicCputagPortmask(phyMbrPmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_awarePort_get
+ * Description:
+ *      Get CPU aware port mask.
+ * Input:
+ *      None
+ * Output:
+ *      pPortmask - Port mask.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ * Note:
+ *      The API can get configured CPU aware port mask.
+ */
+rtk_api_ret_t rtk_cpu_awarePort_get(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmsk;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicCputagPortmask(&pmsk)) != RT_ERR_OK)
+        return retVal;
+
+    if(rtk_switch_portmask_P2L_get(pmsk, pPortmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_tagPosition_set
+ * Description:
+ *      Set CPU tag position.
+ * Input:
+ *      position - CPU tag position.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can set CPU tag position.
+ */
+rtk_api_ret_t rtk_cpu_tagPosition_set(rtk_cpu_position_t position)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (position >= CPU_POS_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicCputagPosition(position)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_tagPosition_get
+ * Description:
+ *      Get CPU tag position.
+ * Input:
+ *      None
+ * Output:
+ *      pPosition - CPU tag position.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can get CPU tag position.
+ */
+rtk_api_ret_t rtk_cpu_tagPosition_get(rtk_cpu_position_t *pPosition)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPosition)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicCputagPosition(pPosition)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_tagLength_set
+ * Description:
+ *      Set CPU tag length.
+ * Input:
+ *      length - CPU tag length.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can set CPU tag length.
+ */
+rtk_api_ret_t rtk_cpu_tagLength_set(rtk_cpu_tag_length_t length)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (length >= CPU_LEN_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicCputagMode(length)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_tagLength_get
+ * Description:
+ *      Get CPU tag length.
+ * Input:
+ *      None
+ * Output:
+ *      pLength - CPU tag length.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can get CPU tag length.
+ */
+rtk_api_ret_t rtk_cpu_tagLength_get(rtk_cpu_tag_length_t *pLength)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pLength)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicCputagMode(pLength)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_priRemap_set
+ * Description:
+ *      Configure CPU priorities mapping to internal absolute priority.
+ * Input:
+ *      int_pri     - internal priority value.
+ *      new_pri    - new internal priority value.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_VLAN_PRIORITY    - Invalid 1p priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      Priority of CPU tag assignment for internal asic priority, and it is used for queue usage and packet scheduling.
+ */
+rtk_api_ret_t rtk_cpu_priRemap_set(rtk_pri_t int_pri, rtk_pri_t new_pri)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (new_pri > RTL8367C_PRIMAX || int_pri > RTL8367C_PRIMAX)
+        return  RT_ERR_VLAN_PRIORITY;
+
+    if ((retVal = rtl8367c_setAsicCputagPriorityRemapping(int_pri, new_pri)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_priRemap_get
+ * Description:
+ *      Configure CPU priorities mapping to internal absolute priority.
+ * Input:
+ *      int_pri     - internal priority value.
+ * Output:
+ *      pNew_pri    - new internal priority value.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_VLAN_PRIORITY    - Invalid 1p priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      Priority of CPU tag assignment for internal asic priority, and it is used for queue usage and packet scheduling.
+ */
+rtk_api_ret_t rtk_cpu_priRemap_get(rtk_pri_t int_pri, rtk_pri_t *pNew_pri)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pNew_pri)
+        return RT_ERR_NULL_POINTER;
+
+    if (int_pri > RTL8367C_PRIMAX)
+        return  RT_ERR_QOS_INT_PRIORITY;
+
+    if ((retVal = rtl8367c_getAsicCputagPriorityRemapping(int_pri, pNew_pri)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_acceptLength_set
+ * Description:
+ *      Set CPU accept  length.
+ * Input:
+ *      length - CPU tag length.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can set CPU accept length.
+ */
+rtk_api_ret_t rtk_cpu_acceptLength_set(rtk_cpu_rx_length_t length)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (length >= CPU_RX_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicCputagRxMinLength(length)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_cpu_acceptLength_get
+ * Description:
+ *      Get CPU accept length.
+ * Input:
+ *      None
+ * Output:
+ *      pLength - CPU tag length.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can get CPU accept length.
+ */
+rtk_api_ret_t rtk_cpu_acceptLength_get(rtk_cpu_rx_length_t *pLength)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pLength)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicCputagRxMinLength(pLength)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/dot1x.c b/drivers/net/phy/rtk/rtl8367c/dot1x.c
new file mode 100644
index 0000000000000..38e2ba9f20129
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/dot1x.c
@@ -0,0 +1,843 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 75783 $
+ * $Date: 2017-02-13 14:54:53 +0800 (週一, 13 二月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in 1X module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <dot1x.h>
+#include <string.h>
+#include <vlan.h>
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_dot1x.h>
+#include <rtl8367c_asicdrv_rma.h>
+#include <rtl8367c_asicdrv_lut.h>
+#include <rtl8367c_asicdrv_vlan.h>
+
+/* Function Name:
+ *      rtk_dot1x_unauthPacketOper_set
+ * Description:
+ *      Set 802.1x unauth action configuration.
+ * Input:
+ *      port            - Port id.
+ *      unauth_action   - 802.1X unauth action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      This API can set 802.1x unauth action configuration.
+ *      The unauth action is as following:
+ *      - DOT1X_ACTION_DROP
+ *      - DOT1X_ACTION_TRAP2CPU
+ *      - DOT1X_ACTION_GUESTVLAN
+ */
+rtk_api_ret_t rtk_dot1x_unauthPacketOper_set(rtk_port_t port, rtk_dot1x_unauth_action_t unauth_action)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (unauth_action >= DOT1X_ACTION_END)
+        return RT_ERR_DOT1X_PROC;
+
+    if ((retVal = rtl8367c_setAsic1xProcConfig(rtk_switch_port_L2P_get(port), unauth_action)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_unauthPacketOper_get
+ * Description:
+ *      Get 802.1x unauth action configuration.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pUnauth_action - 802.1X unauth action.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can get 802.1x unauth action configuration.
+ *      The unauth action is as following:
+ *      - DOT1X_ACTION_DROP
+ *      - DOT1X_ACTION_TRAP2CPU
+ *      - DOT1X_ACTION_GUESTVLAN
+ */
+rtk_api_ret_t rtk_dot1x_unauthPacketOper_get(rtk_port_t port, rtk_dot1x_unauth_action_t *pUnauth_action)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pUnauth_action)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsic1xProcConfig(rtk_switch_port_L2P_get(port), pUnauth_action)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_eapolFrame2CpuEnable_set
+ * Description:
+ *      Set 802.1x EAPOL packet trap to CPU configuration
+ * Input:
+ *      enable - The status of 802.1x EAPOL packet.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      To support 802.1x authentication functionality, EAPOL frame (ether type = 0x888E) has to
+ *      be trapped to CPU.
+ *      The status of EAPOL frame trap to CPU is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+rtk_api_ret_t rtk_dot1x_eapolFrame2CpuEnable_set(rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_getAsicRma(3, &rmacfg)) != RT_ERR_OK)
+        return retVal;
+
+    if (ENABLED == enable)
+        rmacfg.operation = RMAOP_TRAP_TO_CPU;
+    else if (DISABLED == enable)
+        rmacfg.operation = RMAOP_FORWARD;
+
+    if ((retVal = rtl8367c_setAsicRma(3, &rmacfg)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_eapolFrame2CpuEnable_get
+ * Description:
+ *      Get 802.1x EAPOL packet trap to CPU configuration
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - The status of 802.1x EAPOL packet.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      To support 802.1x authentication functionality, EAPOL frame (ether type = 0x888E) has to
+ *      be trapped to CPU.
+ *      The status of EAPOL frame trap to CPU is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+rtk_api_ret_t rtk_dot1x_eapolFrame2CpuEnable_get(rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicRma(3, &rmacfg)) != RT_ERR_OK)
+        return retVal;
+
+    if (RMAOP_TRAP_TO_CPU == rmacfg.operation)
+        *pEnable = ENABLED;
+    else
+        *pEnable = DISABLED;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_portBasedEnable_set
+ * Description:
+ *      Set 802.1x port-based enable configuration
+ * Input:
+ *      port - Port id.
+ *      enable - The status of 802.1x port.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_ENABLE               - Invalid enable input.
+ *      RT_ERR_DOT1X_PORTBASEDPNEN  - 802.1X port-based enable error
+ * Note:
+ *      The API can update the port-based port enable register content. If a port is 802.1x
+ *      port based network access control "enabled", it should be authenticated so packets
+ *      from that port won't be dropped or trapped to CPU.
+ *      The status of 802.1x port-based network access control is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+rtk_api_ret_t rtk_dot1x_portBasedEnable_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsic1xPBEnConfig(rtk_switch_port_L2P_get(port),enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_portBasedEnable_get
+ * Description:
+ *      Get 802.1x port-based enable configuration
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - The status of 802.1x port.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get the 802.1x port-based port status.
+ */
+rtk_api_ret_t rtk_dot1x_portBasedEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsic1xPBEnConfig(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_portBasedAuthStatus_set
+ * Description:
+ *      Set 802.1x port-based auth. port configuration
+ * Input:
+ *      port - Port id.
+ *      port_auth - The status of 802.1x port.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *     RT_ERR_DOT1X_PORTBASEDAUTH   - 802.1X port-based auth error
+ * Note:
+ *      The authenticated status of 802.1x port-based network access control is as following:
+ *      - UNAUTH
+ *      - AUTH
+ */
+rtk_api_ret_t rtk_dot1x_portBasedAuthStatus_set(rtk_port_t port, rtk_dot1x_auth_status_t port_auth)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+     if (port_auth >= AUTH_STATUS_END)
+        return RT_ERR_DOT1X_PORTBASEDAUTH;
+
+    if ((retVal = rtl8367c_setAsic1xPBAuthConfig(rtk_switch_port_L2P_get(port), port_auth)) != RT_ERR_OK)
+        return retVal;
+
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_portBasedAuthStatus_get
+ * Description:
+ *      Get 802.1x port-based auth. port configuration
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPort_auth - The status of 802.1x port.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get 802.1x port-based port auth.information.
+ */
+rtk_api_ret_t rtk_dot1x_portBasedAuthStatus_get(rtk_port_t port, rtk_dot1x_auth_status_t *pPort_auth)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPort_auth)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsic1xPBAuthConfig(rtk_switch_port_L2P_get(port), pPort_auth)) != RT_ERR_OK)
+        return retVal;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_portBasedDirection_set
+ * Description:
+ *      Set 802.1x port-based operational direction configuration
+ * Input:
+ *      port            - Port id.
+ *      port_direction  - Operation direction
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_DOT1X_PORTBASEDOPDIR - 802.1X port-based operation direction error
+ * Note:
+ *      The operate controlled direction of 802.1x port-based network access control is as following:
+ *      - BOTH
+ *      - IN
+ */
+rtk_api_ret_t rtk_dot1x_portBasedDirection_set(rtk_port_t port, rtk_dot1x_direction_t port_direction)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (port_direction >= DIRECTION_END)
+        return RT_ERR_DOT1X_PORTBASEDOPDIR;
+
+    if ((retVal = rtl8367c_setAsic1xPBOpdirConfig(rtk_switch_port_L2P_get(port), port_direction)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_portBasedDirection_get
+ * Description:
+ *      Get 802.1X port-based operational direction configuration
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPort_direction - Operation direction
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get 802.1x port-based operational direction information.
+ */
+rtk_api_ret_t rtk_dot1x_portBasedDirection_get(rtk_port_t port, rtk_dot1x_direction_t *pPort_direction)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPort_direction)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsic1xPBOpdirConfig(rtk_switch_port_L2P_get(port), pPort_direction)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_macBasedEnable_set
+ * Description:
+ *      Set 802.1x mac-based port enable configuration
+ * Input:
+ *      port - Port id.
+ *      enable - The status of 802.1x port.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_ENABLE               - Invalid enable input.
+ *      RT_ERR_DOT1X_MACBASEDPNEN   - 802.1X mac-based enable error
+ * Note:
+ *      If a port is 802.1x MAC based network access control "enabled", the incoming packets should
+ *       be authenticated so packets from that port won't be dropped or trapped to CPU.
+ *      The status of 802.1x MAC-based network access control is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+rtk_api_ret_t rtk_dot1x_macBasedEnable_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsic1xMBEnConfig(rtk_switch_port_L2P_get(port),enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_macBasedEnable_get
+ * Description:
+ *      Get 802.1x mac-based port enable configuration
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - The status of 802.1x port.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      If a port is 802.1x MAC based network access control "enabled", the incoming packets should
+ *      be authenticated so packets from that port wont be dropped or trapped to CPU.
+ *      The status of 802.1x MAC-based network access control is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+rtk_api_ret_t rtk_dot1x_macBasedEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsic1xMBEnConfig(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_macBasedAuthMac_add
+ * Description:
+ *      Add an authenticated MAC to ASIC
+ * Input:
+ *      port        - Port id.
+ *      pAuth_mac   - The authenticated MAC.
+ *      fid         - filtering database.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_ENABLE               - Invalid enable input.
+ *      RT_ERR_DOT1X_MACBASEDPNEN   - 802.1X mac-based enable error
+ * Note:
+ *      The API can add a 802.1x authenticated MAC address to port. If the MAC does not exist in LUT,
+ *      user can't add this MAC to auth status.
+ */
+rtk_api_ret_t rtk_dot1x_macBasedAuthMac_add(rtk_port_t port, rtk_mac_t *pAuth_mac, rtk_fid_t fid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* must be unicast address */
+    if ((pAuth_mac == NULL) || (pAuth_mac->octet[0] & 0x1))
+        return RT_ERR_MAC;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (fid > RTL8367C_FIDMAX)
+        return RT_ERR_L2_FID;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+
+    /* fill key (MAC,FID) to get L2 entry */
+    memcpy(l2Table.mac.octet, pAuth_mac->octet, ETHER_ADDR_LEN);
+    l2Table.fid = fid;
+    method = LUTREADMETHOD_MAC;
+    retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+    if ( RT_ERR_OK == retVal)
+    {
+        if (l2Table.spa != rtk_switch_port_L2P_get(port))
+            return RT_ERR_DOT1X_MAC_PORT_MISMATCH;
+
+        memcpy(l2Table.mac.octet, pAuth_mac->octet, ETHER_ADDR_LEN);
+        l2Table.fid = fid;
+        l2Table.efid = 0;
+        l2Table.auth = 1;
+        retVal = rtl8367c_setAsicL2LookupTb(&l2Table);
+        return retVal;
+    }
+    else
+        return retVal;
+
+}
+
+/* Function Name:
+ *      rtk_dot1x_macBasedAuthMac_del
+ * Description:
+ *      Delete an authenticated MAC to ASIC
+ * Input:
+ *      port - Port id.
+ *      pAuth_mac - The authenticated MAC.
+ *      fid - filtering database.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_MAC          - Invalid MAC address.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can delete a 802.1x authenticated MAC address to port. It only change the auth status of
+ *      the MAC and won't delete it from LUT.
+ */
+rtk_api_ret_t rtk_dot1x_macBasedAuthMac_del(rtk_port_t port, rtk_mac_t *pAuth_mac, rtk_fid_t fid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* must be unicast address */
+    if ((pAuth_mac == NULL) || (pAuth_mac->octet[0] & 0x1))
+        return RT_ERR_MAC;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (fid > RTL8367C_FIDMAX)
+        return RT_ERR_L2_FID;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+
+    /* fill key (MAC,FID) to get L2 entry */
+    memcpy(l2Table.mac.octet, pAuth_mac->octet, ETHER_ADDR_LEN);
+    l2Table.fid = fid;
+    method = LUTREADMETHOD_MAC;
+    retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+    if (RT_ERR_OK == retVal)
+    {
+        if (l2Table.spa != rtk_switch_port_L2P_get(port))
+            return RT_ERR_DOT1X_MAC_PORT_MISMATCH;
+
+        memcpy(l2Table.mac.octet, pAuth_mac->octet, ETHER_ADDR_LEN);
+        l2Table.fid = fid;
+        l2Table.auth = 0;
+        retVal = rtl8367c_setAsicL2LookupTb(&l2Table);
+        return retVal;
+    }
+    else
+        return retVal;
+
+}
+
+/* Function Name:
+ *      rtk_dot1x_macBasedDirection_set
+ * Description:
+ *      Set 802.1x mac-based operational direction configuration
+ * Input:
+ *      mac_direction - Operation direction
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_INPUT                - Invalid input parameter.
+ *      RT_ERR_DOT1X_MACBASEDOPDIR  - 802.1X mac-based operation direction error
+ * Note:
+ *      The operate controlled direction of 802.1x mac-based network access control is as following:
+ *      - BOTH
+ *      - IN
+ */
+rtk_api_ret_t rtk_dot1x_macBasedDirection_set(rtk_dot1x_direction_t mac_direction)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (mac_direction >= DIRECTION_END)
+        return RT_ERR_DOT1X_MACBASEDOPDIR;
+
+    if ((retVal = rtl8367c_setAsic1xMBOpdirConfig(mac_direction)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_macBasedDirection_get
+ * Description:
+ *      Get 802.1x mac-based operational direction configuration
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pMac_direction - Operation direction
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get 802.1x mac-based operational direction information.
+ */
+rtk_api_ret_t rtk_dot1x_macBasedDirection_get(rtk_dot1x_direction_t *pMac_direction)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pMac_direction)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsic1xMBOpdirConfig(pMac_direction)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      Set 802.1x guest VLAN configuration
+ * Description:
+ *      Set 802.1x mac-based operational direction configuration
+ * Input:
+ *      vid - 802.1x guest VLAN ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      The operate controlled 802.1x guest VLAN
+ */
+rtk_api_ret_t rtk_dot1x_guestVlan_set(rtk_vlan_t vid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 index;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* vid must be 0~4095 */
+    if (vid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    if((retVal = rtk_vlan_checkAndCreateMbr(vid, &index)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsic1xGuestVidx(index)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_guestVlan_get
+ * Description:
+ *      Get 802.1x guest VLAN configuration
+ * Input:
+ *      None
+ * Output:
+ *      pVid - 802.1x guest VLAN ID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get 802.1x guest VLAN information.
+ */
+rtk_api_ret_t rtk_dot1x_guestVlan_get(rtk_vlan_t *pVid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 gvidx;
+    rtl8367c_vlanconfiguser vlanMC;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pVid)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsic1xGuestVidx(&gvidx)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicVlanMemberConfig(gvidx, &vlanMC)) != RT_ERR_OK)
+        return retVal;
+
+    *pVid = vlanMC.evid;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_guestVlan2Auth_set
+ * Description:
+ *      Set 802.1x guest VLAN to auth host configuration
+ * Input:
+ *      enable - The status of guest VLAN to auth host.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      The operational direction of 802.1x guest VLAN to auth host control is as following:
+ *      - ENABLED
+ *      - DISABLED
+ */
+rtk_api_ret_t rtk_dot1x_guestVlan2Auth_set(rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsic1xGVOpdir(enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_dot1x_guestVlan2Auth_get
+ * Description:
+ *      Get 802.1x guest VLAN to auth host configuration
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - The status of guest VLAN to auth host.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get 802.1x guest VLAN to auth host information.
+ */
+rtk_api_ret_t rtk_dot1x_guestVlan2Auth_get(rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsic1xGVOpdir(pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/eee.c b/drivers/net/phy/rtk/rtl8367c/eee.c
new file mode 100644
index 0000000000000..e502b463e8c2d
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/eee.c
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 48156 $
+ * $Date: 2014-05-29 16:39:06 +0800 (週四, 29 五月 2014) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in EEE module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <eee.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_eee.h>
+#include <rtl8367c_asicdrv_phy.h>
+
+/* Function Name:
+ *      rtk_eee_init
+ * Description:
+ *      EEE function initialization.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API is used to initialize EEE status.
+ */
+rtk_api_ret_t rtk_eee_init(void)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if((retVal = rtl8367c_setAsicRegBit(0x0018, 10, 1)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicRegBit(0x0018, 11, 1)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_eee_portEnable_set
+ * Description:
+ *      Set enable status of EEE function.
+ * Input:
+ *      port - port id.
+ *      enable - enable EEE status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_ID - Invalid port number.
+ *      RT_ERR_ENABLE - Invalid enable input.
+ * Note:
+ *      This API can set EEE function to the specific port.
+ *      The configuration of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+rtk_api_ret_t rtk_eee_portEnable_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      regData;
+    rtk_uint32    phy_port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port is UTP port */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if (enable>=RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    phy_port = rtk_switch_port_L2P_get(port);
+
+    if ((retVal = rtl8367c_setAsicEee100M(phy_port,enable))!=RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicEeeGiga(phy_port,enable))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPHYReg(phy_port, RTL8367C_PHY_PAGE_ADDRESS, 0))!=RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_getAsicPHYReg(phy_port, 0, &regData))!=RT_ERR_OK)
+        return retVal;
+    regData |= 0x0200;
+    if ((retVal = rtl8367c_setAsicPHYReg(phy_port, 0, regData))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_eee_portEnable_get
+ * Description:
+ *      Get enable status of EEE function
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - Back pressure status.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_ID - Invalid port number.
+ * Note:
+ *      This API can get EEE function to the specific port.
+ *      The configuration of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+
+rtk_api_ret_t rtk_eee_portEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData1, regData2;
+    rtk_uint32    phy_port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port is UTP port */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    phy_port = rtk_switch_port_L2P_get(port);
+
+    if ((retVal = rtl8367c_getAsicEee100M(phy_port,&regData1))!=RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_getAsicEeeGiga(phy_port,&regData2))!=RT_ERR_OK)
+        return retVal;
+
+    if (regData1==1&&regData2==1)
+        *pEnable = ENABLED;
+    else
+        *pEnable = DISABLED;
+
+    return RT_ERR_OK;
+}
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/i2c.c b/drivers/net/phy/rtk/rtl8367c/i2c.c
new file mode 100644
index 0000000000000..17a5f3785bd4f
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/i2c.c
@@ -0,0 +1,436 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 63932 $
+ * $Date: 2015-12-08 14:06:29 +0800 (周二, 08 十二月 2015) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in i2c module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <port.h>
+#include <string.h>
+#include <rtl8367c_reg.h>
+
+#include <rtl8367c_asicdrv_i2c.h>
+#include <rtk_switch.h>
+#include <rtl8367c_asicdrv.h>
+#include <rtk_types.h>
+#include <i2c.h>
+
+
+static rtk_I2C_16bit_mode_t rtk_i2c_mode = I2C_LSB_16BIT_MODE;
+
+
+/* Function Name:
+ *      rtk_i2c_init
+ * Description:
+ *      I2C smart function initialization.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ * Note:
+ *      This API is used to initialize EEE status.
+ *      need used GPIO pins
+ *      OpenDrain and clock
+ */
+rtk_api_ret_t rtk_i2c_init(void)
+{
+    rtk_uint32 retVal;
+  switch_chip_t ChipID;
+  /* probe switch */
+  if((retVal = rtk_switch_probe(&ChipID)) != RT_ERR_OK)
+      return retVal;
+
+  if( ChipID == CHIP_RTL8370B )
+  {
+   /*set GPIO8, GPIO9, OpenDrain as I2C, clock = 252KHZ   */
+      if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, 0x5c3f)) != RT_ERR_OK)
+        return retVal;
+  }
+  else
+      return RT_ERR_FAILED;
+  return  RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_i2c_mode_set
+ * Description:
+ *      Set I2C data byte-order.
+ * Input:
+ *      i2cmode - byte-order mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      This API can set I2c traffic's byte-order .
+ */
+rtk_api_ret_t rtk_i2c_mode_set( rtk_I2C_16bit_mode_t i2cmode )
+{
+    if(i2cmode >= I2C_Mode_END)
+    {
+        return RT_ERR_INPUT;
+    }
+    else if(i2cmode == I2C_70B_LSB_16BIT_MODE)
+    {
+        rtk_i2c_mode = I2C_70B_LSB_16BIT_MODE;
+
+        return RT_ERR_OK;
+    }
+    else if( i2cmode == I2C_LSB_16BIT_MODE)
+    {
+        rtk_i2c_mode = I2C_LSB_16BIT_MODE;
+        return RT_ERR_OK;
+    }
+    else
+        return RT_ERR_FAILED;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_i2c_mode_get
+ * Description:
+ *      Get i2c traffic byte-order setting.
+ * Input:
+ *      None
+ * Output:
+ *      pI2cMode - i2c byte-order
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_NULL_POINTER     - input parameter is null pointer
+ * Note:
+ *      The API can get i2c traffic byte-order setting.
+ */
+rtk_api_ret_t rtk_i2c_mode_get( rtk_I2C_16bit_mode_t * pI2cMode)
+{
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+    if(NULL == pI2cMode)
+        return RT_ERR_NULL_POINTER;
+    if(rtk_i2c_mode == I2C_70B_LSB_16BIT_MODE)
+        *pI2cMode = 1;
+    else if ((rtk_i2c_mode == I2C_LSB_16BIT_MODE))
+        *pI2cMode = 0;
+    else
+        return RT_ERR_FAILED;
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_i2c_gpioPinGroup_set
+ * Description:
+ *      Set i2c SDA & SCL used GPIO pins group.
+ * Input:
+ *      pins_group - GPIO pins group
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      The API can set i2c used gpio pins group.
+ *      There are three group pins could be used
+ */
+rtk_api_ret_t rtk_i2c_gpioPinGroup_set( rtk_I2C_gpio_pin_t pins_group )
+{
+    rtk_uint32 retVal;
+
+
+    if( ( pins_group > I2C_GPIO_PIN_END )|| ( pins_group < I2C_GPIO_PIN_8_9) )
+        return RT_ERR_INPUT;
+
+    if( (retVal = rtl8367c_setAsicI2CGpioPinGroup(pins_group) ) != RT_ERR_OK )
+        return retVal ;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_i2c_gpioPinGroup_get
+ * Description:
+ *      Get i2c SDA & SCL used GPIO pins group.
+ * Input:
+ *      None
+ * Output:
+ *      pPins_group - GPIO pins group
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_NULL_POINTER     - input parameter is null pointer
+ * Note:
+ *      The API can get i2c used gpio pins group.
+ *      There are three group pins could be used
+ */
+rtk_api_ret_t rtk_i2c_gpioPinGroup_get( rtk_I2C_gpio_pin_t * pPins_group )
+{
+    rtk_uint32 retVal;
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPins_group)
+        return RT_ERR_NULL_POINTER;
+    if( (retVal = rtl8367c_getAsicI2CGpioPinGroup(pPins_group) ) != RT_ERR_OK )
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_i2c_data_read
+ * Description:
+ *      read i2c slave device register.
+ * Input:
+ *      deviceAddr   -   access Slave device address
+ *      slaveRegAddr -   access Slave register address
+ * Output:
+ *      pRegData     -   read data
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_NULL_POINTER     - input parameter is null pointer
+ * Note:
+ *      The API can access i2c slave and read i2c slave device register.
+ */
+rtk_api_ret_t rtk_i2c_data_read(rtk_uint8 deviceAddr, rtk_uint32 slaveRegAddr, rtk_uint32 *pRegData)
+{
+     rtk_uint32 retVal, counter=0;
+     rtk_uint8 controlByte_W, controlByte_R;
+     rtk_uint8 slaveRegAddr_L, slaveRegAddr_H = 0x0, temp;
+     rtk_uint8 regData_L, regData_H;
+
+   /* control byte :deviceAddress + W,  deviceAddress + R   */
+    controlByte_W = (rtk_uint8)(deviceAddr << 1) ;
+    controlByte_R = (rtk_uint8)(controlByte_W | 0x1);
+
+    slaveRegAddr_L = (rtk_uint8) (slaveRegAddr & 0x00FF) ;
+    slaveRegAddr_H = (rtk_uint8) (slaveRegAddr >>8) ;
+
+    if( rtk_i2c_mode == I2C_70B_LSB_16BIT_MODE)
+    {
+        temp = slaveRegAddr_L ;
+        slaveRegAddr_L = slaveRegAddr_H;
+        slaveRegAddr_H = temp;
+    }
+
+
+  /*check bus state: idle*/
+  for(counter = 3000; counter>0; counter--)
+  {
+    if ( (retVal = rtl8367c_setAsicI2C_checkBusIdle() ) == RT_ERR_OK)
+         break;
+  }
+  if( counter ==0 )
+      return retVal; /*i2c is busy*/
+
+   /*tx Start cmd*/
+   if( (retVal = rtl8367c_setAsicI2CStartCmd() ) != RT_ERR_OK )
+       return retVal ;
+
+
+  /*tx control _W*/
+   if( (retVal = rtl8367c_setAsicI2CTxOneCharCmd(controlByte_W))!= RT_ERR_OK )
+      return retVal ;
+
+
+  /*check if RX ack from slave*/
+   if( (retVal = rtl8367c_setAsicI2CcheckRxAck()) != RT_ERR_OK )
+        return retVal;
+
+    /* tx slave buffer address low 8 bits */
+   if( (retVal = rtl8367c_setAsicI2CTxOneCharCmd(slaveRegAddr_L))!= RT_ERR_OK )
+         return retVal  ;
+
+   /*check if RX ack from slave*/
+   if( (retVal = rtl8367c_setAsicI2CcheckRxAck()) != RT_ERR_OK )
+        return retVal;
+
+
+
+        /* tx slave buffer address high 8 bits */
+   if( (retVal = rtl8367c_setAsicI2CTxOneCharCmd(slaveRegAddr_H))!= RT_ERR_OK )
+         return retVal  ;
+
+
+   /*check if RX ack from slave*/
+   if( (retVal = rtl8367c_setAsicI2CcheckRxAck()) != RT_ERR_OK )
+        return retVal;
+
+
+   /*tx Start cmd*/
+   if( (retVal = rtl8367c_setAsicI2CStartCmd() ) != RT_ERR_OK )
+       return retVal ;
+
+      /*tx control _R*/
+   if( (retVal = rtl8367c_setAsicI2CTxOneCharCmd(controlByte_R))!= RT_ERR_OK )
+       return retVal ;
+
+
+  /*check if RX ack from slave*/
+   if( (retVal = rtl8367c_setAsicI2CcheckRxAck()) != RT_ERR_OK )
+        return retVal;
+
+
+    /* rx low 8bit data*/
+   if( ( retVal = rtl8367c_setAsicI2CRxOneCharCmd( &regData_L) ) != RT_ERR_OK )
+        return retVal;
+
+
+
+    /* tx ack to slave, keep receive */
+    if( (retVal = rtl8367c_setAsicI2CTxAckCmd()) != RT_ERR_OK )
+        return retVal;
+
+     /* rx high 8bit data*/
+    if( ( retVal = rtl8367c_setAsicI2CRxOneCharCmd( &regData_H) ) != RT_ERR_OK )
+        return retVal;
+
+
+
+    /* tx Noack to slave, Stop receive */
+     if( (retVal = rtl8367c_setAsicI2CTxNoAckCmd()) != RT_ERR_OK )
+        return retVal;
+
+
+    /*tx Stop cmd */
+    if( (retVal = rtl8367c_setAsicI2CStopCmd()) != RT_ERR_OK )
+        return retVal;
+
+    *pRegData = (regData_H << 8) | regData_L;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_i2c_data_write
+ * Description:
+ *      write data to i2c slave device register
+ * Input:
+ *      deviceAddr   -   access Slave device address
+ *      slaveRegAddr -   access Slave register address
+ *      regData      -   data to set
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ * Note:
+ *      The API can access i2c slave and setting i2c slave device register.
+ */
+rtk_api_ret_t rtk_i2c_data_write(rtk_uint8 deviceAddr, rtk_uint32 slaveRegAddr, rtk_uint32 regData)
+{
+     rtk_uint32 retVal,counter;
+     rtk_uint8 controlByte_W;
+     rtk_uint8 slaveRegAddr_L, slaveRegAddr_H = 0x0, temp;
+     rtk_uint8 regData_L, regData_H;
+
+  /* control byte :deviceAddress + W    */
+    controlByte_W = (rtk_uint8)(deviceAddr<< 1) ;
+
+    slaveRegAddr_L = (rtk_uint8) (slaveRegAddr & 0x00FF) ;
+    slaveRegAddr_H = (rtk_uint8) (slaveRegAddr >>8) ;
+
+    regData_H   = (rtk_uint8) (regData>> 8);
+    regData_L   = (rtk_uint8) (regData & 0x00FF);
+
+    if( rtk_i2c_mode == I2C_70B_LSB_16BIT_MODE)
+    {
+        temp = slaveRegAddr_L ;
+        slaveRegAddr_L = slaveRegAddr_H;
+        slaveRegAddr_H = temp;
+    }
+
+
+  /*check bus state: idle*/
+  for(counter = 3000; counter>0; counter--)
+  {
+    if ( (retVal = rtl8367c_setAsicI2C_checkBusIdle() ) == RT_ERR_OK)
+        break;
+  }
+
+  if( counter ==0 )
+      return retVal; /*i2c is busy*/
+
+
+   /*tx Start cmd*/
+   if( (retVal = rtl8367c_setAsicI2CStartCmd() ) != RT_ERR_OK )
+       return retVal ;
+
+
+  /*tx control _W*/
+   if( (retVal = rtl8367c_setAsicI2CTxOneCharCmd(controlByte_W))!= RT_ERR_OK )
+      return retVal ;
+
+
+  /*check if RX ack from slave*/
+   if( (retVal = rtl8367c_setAsicI2CcheckRxAck()) != RT_ERR_OK )
+        return retVal;
+
+
+    /* tx slave buffer address low 8 bits */
+   if( (retVal = rtl8367c_setAsicI2CTxOneCharCmd(slaveRegAddr_L))!= RT_ERR_OK )
+        return retVal;
+
+
+   /*check if RX ack from slave*/
+   if( (retVal = rtl8367c_setAsicI2CcheckRxAck()) != RT_ERR_OK )
+        return retVal;
+
+
+   /* tx slave buffer address high 8 bits */
+   if( (retVal = rtl8367c_setAsicI2CTxOneCharCmd(slaveRegAddr_H))!= RT_ERR_OK )
+        return retVal;
+
+
+   /*check if RX ack from slave*/
+   if( (retVal = rtl8367c_setAsicI2CcheckRxAck()) != RT_ERR_OK )
+        return retVal;
+
+
+     /*tx Datavlue LSB*/
+   if( (retVal = rtl8367c_setAsicI2CTxOneCharCmd(regData_L))!= RT_ERR_OK )
+        return retVal;
+
+
+   /*check if RX ack from slave*/
+   if( (retVal = rtl8367c_setAsicI2CcheckRxAck()) != RT_ERR_OK )
+        return retVal;
+
+
+   /*tx Datavlue MSB*/
+   if( (retVal = rtl8367c_setAsicI2CTxOneCharCmd(regData_H))!= RT_ERR_OK )
+        return retVal;
+
+
+   /*check if RX ack from slave*/
+   if( (retVal = rtl8367c_setAsicI2CcheckRxAck()) != RT_ERR_OK )
+        return retVal;
+
+
+    /*tx Stop cmd */
+    if( (retVal = rtl8367c_setAsicI2CStopCmd()) != RT_ERR_OK )
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/igmp.c b/drivers/net/phy/rtk/rtl8367c/igmp.c
new file mode 100644
index 0000000000000..728005b5d642d
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/igmp.c
@@ -0,0 +1,1555 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in IGMP module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <igmp.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_igmp.h>
+#include <rtl8367c_asicdrv_lut.h>
+
+
+/* Function Name:
+ *      rtk_igmp_init
+ * Description:
+ *      This API enables H/W IGMP and set a default initial configuration.
+ * Input:
+ *      None.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API enables H/W IGMP and set a default initial configuration.
+ */
+rtk_api_ret_t rtk_igmp_init(void)
+{
+    rtk_api_ret_t retVal;
+    rtk_port_t port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_setAsicLutIpMulticastLookup(ENABLED))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicLutIpLookupMethod(1))!=RT_ERR_OK)
+        return retVal;
+
+    RTK_SCAN_ALL_PHY_PORTMASK(port)
+    {
+        if ((retVal = rtl8367c_setAsicIGMPv1Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicIGMPv2Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicIGMPv3Opeartion(port, PROTOCOL_OP_FLOOD))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicMLDv1Opeartion(port, PROTOCOL_OP_ASIC))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicMLDv2Opeartion(port, PROTOCOL_OP_FLOOD))!=RT_ERR_OK)
+            return retVal;
+    }
+
+    if ((retVal = rtl8367c_setAsicIGMPAllowDynamicRouterPort(rtk_switch_phyPortMask_get()))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicIGMPFastLeaveEn(ENABLED))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicIGMPReportLeaveFlood(1))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicIgmp(ENABLED))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_state_set
+ * Description:
+ *      This API set H/W IGMP state.
+ * Input:
+ *      enabled     - H/W IGMP state
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set H/W IGMP state.
+ */
+rtk_api_ret_t rtk_igmp_state_set(rtk_enable_t enabled)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (enabled >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicIgmp(enabled))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_state_get
+ * Description:
+ *      This API get H/W IGMP state.
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled        - H/W IGMP state
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set current H/W IGMP state.
+ */
+rtk_api_ret_t rtk_igmp_state_get(rtk_enable_t *pEnabled)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(pEnabled == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIgmp(pEnabled))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_static_router_port_set
+ * Description:
+ *      Configure static router port
+ * Input:
+ *      pPortmask    - Static Port mask
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *      This API set static router port
+ */
+rtk_api_ret_t rtk_igmp_static_router_port_set(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Valid port mask */
+    if(pPortmask == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    RTK_CHK_PORTMASK_VALID(pPortmask);
+
+    if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicIGMPStaticRouterPort(pmask))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_static_router_port_get
+ * Description:
+ *      Get static router port
+ * Input:
+ *      None.
+ * Output:
+ *      pPortmask       - Static port mask
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *      This API get static router port
+ */
+rtk_api_ret_t rtk_igmp_static_router_port_get(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(pPortmask == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPStaticRouterPort(&pmask))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_protocol_set
+ * Description:
+ *      set IGMP/MLD protocol action
+ * Input:
+ *      port        - Port ID
+ *      protocol    - IGMP/MLD protocol
+ *      action      - Per-port and per-protocol IGMP action seeting
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *      This API set IGMP/MLD protocol action
+ */
+rtk_api_ret_t rtk_igmp_protocol_set(rtk_port_t port, rtk_igmp_protocol_t protocol, rtk_igmp_action_t action)
+{
+    rtk_uint32      operation;
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(protocol >= PROTOCOL_END)
+        return RT_ERR_INPUT;
+
+    if(action >= IGMP_ACTION_END)
+        return RT_ERR_INPUT;
+
+    switch(action)
+    {
+        case IGMP_ACTION_FORWARD:
+            operation = PROTOCOL_OP_FLOOD;
+            break;
+        case IGMP_ACTION_TRAP2CPU:
+            operation = PROTOCOL_OP_TRAP;
+            break;
+        case IGMP_ACTION_DROP:
+            operation = PROTOCOL_OP_DROP;
+            break;
+        case IGMP_ACTION_ASIC:
+            operation = PROTOCOL_OP_ASIC;
+            break;
+        default:
+            return RT_ERR_INPUT;
+    }
+
+    switch(protocol)
+    {
+        case PROTOCOL_IGMPv1:
+            if ((retVal = rtl8367c_setAsicIGMPv1Opeartion(rtk_switch_port_L2P_get(port), operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_IGMPv2:
+            if ((retVal = rtl8367c_setAsicIGMPv2Opeartion(rtk_switch_port_L2P_get(port), operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_IGMPv3:
+            if ((retVal = rtl8367c_setAsicIGMPv3Opeartion(rtk_switch_port_L2P_get(port), operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_MLDv1:
+            if ((retVal = rtl8367c_setAsicMLDv1Opeartion(rtk_switch_port_L2P_get(port), operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_MLDv2:
+            if ((retVal = rtl8367c_setAsicMLDv2Opeartion(rtk_switch_port_L2P_get(port), operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        default:
+            return RT_ERR_INPUT;
+
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_protocol_get
+ * Description:
+ *      set IGMP/MLD protocol action
+ * Input:
+ *      port        - Port ID
+ *      protocol    - IGMP/MLD protocol
+ *      action      - Per-port and per-protocol IGMP action seeting
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *      This API set IGMP/MLD protocol action
+ */
+rtk_api_ret_t rtk_igmp_protocol_get(rtk_port_t port, rtk_igmp_protocol_t protocol, rtk_igmp_action_t *pAction)
+{
+    rtk_uint32      operation;
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(protocol >= PROTOCOL_END)
+        return RT_ERR_INPUT;
+
+    if(pAction == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    switch(protocol)
+    {
+        case PROTOCOL_IGMPv1:
+            if ((retVal = rtl8367c_getAsicIGMPv1Opeartion(rtk_switch_port_L2P_get(port), &operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_IGMPv2:
+            if ((retVal = rtl8367c_getAsicIGMPv2Opeartion(rtk_switch_port_L2P_get(port), &operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_IGMPv3:
+            if ((retVal = rtl8367c_getAsicIGMPv3Opeartion(rtk_switch_port_L2P_get(port), &operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_MLDv1:
+            if ((retVal = rtl8367c_getAsicMLDv1Opeartion(rtk_switch_port_L2P_get(port), &operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        case PROTOCOL_MLDv2:
+            if ((retVal = rtl8367c_getAsicMLDv2Opeartion(rtk_switch_port_L2P_get(port), &operation))!=RT_ERR_OK)
+                return retVal;
+
+            break;
+        default:
+            return RT_ERR_INPUT;
+
+    }
+
+    switch(operation)
+    {
+        case PROTOCOL_OP_FLOOD:
+            *pAction = IGMP_ACTION_FORWARD;
+            break;
+        case PROTOCOL_OP_TRAP:
+            *pAction = IGMP_ACTION_TRAP2CPU;
+            break;
+        case PROTOCOL_OP_DROP:
+            *pAction = IGMP_ACTION_DROP;
+            break;
+        case PROTOCOL_OP_ASIC:
+            *pAction = IGMP_ACTION_ASIC;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_fastLeave_set
+ * Description:
+ *      set IGMP/MLD FastLeave state
+ * Input:
+ *      state       - ENABLED: Enable FastLeave, DISABLED: disable FastLeave
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API set IGMP/MLD FastLeave state
+ */
+rtk_api_ret_t rtk_igmp_fastLeave_set(rtk_enable_t state)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(state >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicIGMPFastLeaveEn((rtk_uint32)state))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_fastLeave_get
+ * Description:
+ *      get IGMP/MLD FastLeave state
+ * Input:
+ *      None
+ * Output:
+ *      pState      - ENABLED: Enable FastLeave, DISABLED: disable FastLeave
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - NULL pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API get IGMP/MLD FastLeave state
+ */
+rtk_api_ret_t rtk_igmp_fastLeave_get(rtk_enable_t *pState)
+{
+    rtk_uint32      fast_leave;
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(pState == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPFastLeaveEn(&fast_leave))!=RT_ERR_OK)
+        return retVal;
+
+    *pState = ((fast_leave == 1) ? ENABLED : DISABLED);
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_maxGroup_set
+ * Description:
+ *      Set per port multicast group learning limit.
+ * Input:
+ *      port        - Port ID
+ *      group       - The number of multicast group learning limit.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_PORT_ID         - Error Port ID
+ *      RT_ERR_OUT_OF_RANGE    - parameter out of range
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API set per port multicast group learning limit.
+ */
+rtk_api_ret_t rtk_igmp_maxGroup_set(rtk_port_t port, rtk_uint32 group)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(group > RTL8367C_IGMP_MAX_GOUP)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if ((retVal = rtl8367c_setAsicIGMPPortMAXGroup(rtk_switch_port_L2P_get(port), group))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_maxGroup_get
+ * Description:
+ *      Get per port multicast group learning limit.
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      pGroup      - The number of multicast group learning limit.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_PORT_ID         - Error Port ID
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API get per port multicast group learning limit.
+ */
+rtk_api_ret_t rtk_igmp_maxGroup_get(rtk_port_t port, rtk_uint32 *pGroup)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(pGroup == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPPortMAXGroup(rtk_switch_port_L2P_get(port), pGroup))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_currentGroup_get
+ * Description:
+ *      Get per port multicast group learning count.
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      pGroup      - The number of multicast group learning count.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_PORT_ID         - Error Port ID
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API get per port multicast group learning count.
+ */
+rtk_api_ret_t rtk_igmp_currentGroup_get(rtk_port_t port, rtk_uint32 *pGroup)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(pGroup == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPPortCurrentGroup(rtk_switch_port_L2P_get(port), pGroup))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_tableFullAction_set
+ * Description:
+ *      set IGMP/MLD Table Full Action
+ * Input:
+ *      action      - Table Full Action
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+rtk_api_ret_t rtk_igmp_tableFullAction_set(rtk_igmp_tableFullAction_t action)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(action >= IGMP_TABLE_FULL_OP_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicIGMPTableFullOP((rtk_uint32)action))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_tableFullAction_get
+ * Description:
+ *      get IGMP/MLD Table Full Action
+ * Input:
+ *      None
+ * Output:
+ *      pAction     - Table Full Action
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+rtk_api_ret_t rtk_igmp_tableFullAction_get(rtk_igmp_tableFullAction_t *pAction)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pAction)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPTableFullOP((rtk_uint32 *)pAction))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_checksumErrorAction_set
+ * Description:
+ *      set IGMP/MLD Checksum Error Action
+ * Input:
+ *      action      - Checksum error Action
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+rtk_api_ret_t rtk_igmp_checksumErrorAction_set(rtk_igmp_checksumErrorAction_t action)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(action >= IGMP_CRC_ERR_OP_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicIGMPCRCErrOP((rtk_uint32)action))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_igmp_checksumErrorAction_get
+ * Description:
+ *      get IGMP/MLD Checksum Error Action
+ * Input:
+ *      None
+ * Output:
+ *      pAction     - Checksum error Action
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+rtk_api_ret_t rtk_igmp_checksumErrorAction_get(rtk_igmp_checksumErrorAction_t *pAction)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pAction)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPCRCErrOP((rtk_uint32 *)pAction))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_leaveTimer_set
+ * Description:
+ *      set IGMP/MLD Leave timer
+ * Input:
+ *      timer       - Leave timer
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+rtk_api_ret_t rtk_igmp_leaveTimer_set(rtk_uint32 timer)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(timer > RTL8367C_MAX_LEAVE_TIMER)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicIGMPLeaveTimer(timer))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_leaveTimer_get
+ * Description:
+ *      get IGMP/MLD Leave timer
+ * Input:
+ *      None
+ * Output:
+ *      pTimer      - Leave Timer.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+rtk_api_ret_t rtk_igmp_leaveTimer_get(rtk_uint32 *pTimer)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pTimer)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPLeaveTimer(pTimer))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_queryInterval_set
+ * Description:
+ *      set IGMP/MLD Query Interval
+ * Input:
+ *      interval     - Query Interval
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+rtk_api_ret_t rtk_igmp_queryInterval_set(rtk_uint32 interval)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(interval > RTL8367C_MAX_QUERY_INT)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicIGMPQueryInterval(interval))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_queryInterval_get
+ * Description:
+ *      get IGMP/MLD Query Interval
+ * Input:
+ *      None.
+ * Output:
+ *      pInterval   - Query Interval
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+rtk_api_ret_t rtk_igmp_queryInterval_get(rtk_uint32 *pInterval)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pInterval)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPQueryInterval(pInterval))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_robustness_set
+ * Description:
+ *      set IGMP/MLD Robustness value
+ * Input:
+ *      robustness     - Robustness value
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+rtk_api_ret_t rtk_igmp_robustness_set(rtk_uint32 robustness)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(robustness > RTL8367C_MAX_ROB_VAR)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicIGMPRobVar(robustness))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_robustness_get
+ * Description:
+ *      get IGMP/MLD Robustness value
+ * Input:
+ *      None
+ * Output:
+ *      pRobustness     - Robustness value.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+rtk_api_ret_t rtk_igmp_robustness_get(rtk_uint32 *pRobustness)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pRobustness)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPRobVar(pRobustness))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_dynamicRouterRortAllow_set
+ * Description:
+ *      Configure dynamic router port allow option
+ * Input:
+ *      pPortmask    - Dynamic Port allow mask
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_dynamicRouterPortAllow_set(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    RTK_CHK_PORTMASK_VALID(pPortmask);
+
+    if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicIGMPAllowDynamicRouterPort(pmask))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_dynamicRouterRortAllow_get
+ * Description:
+ *      Get dynamic router port allow option
+ * Input:
+ *      None.
+ * Output:
+ *      pPortmask    - Dynamic Port allow mask
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_dynamicRouterPortAllow_get(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPAllowDynamicRouterPort(&pmask))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_dynamicRouterPort_get
+ * Description:
+ *      Get dynamic router port
+ * Input:
+ *      None.
+ * Output:
+ *      pDynamicRouterPort    - Dynamic Router Port
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_dynamicRouterPort_get(rtk_igmp_dynamicRouterPort_t *pDynamicRouterPort)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32 port;
+    rtk_uint32 timer;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pDynamicRouterPort)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPdynamicRouterPort1(&port, &timer))!= RT_ERR_OK)
+        return retVal;
+
+    if (port == RTL8367C_ROUTER_PORT_INVALID)
+    {
+        pDynamicRouterPort->dynamicRouterPort0Valid = DISABLED;
+        pDynamicRouterPort->dynamicRouterPort0      = 0;
+        pDynamicRouterPort->dynamicRouterPort0Timer = 0;
+    }
+    else
+    {
+        pDynamicRouterPort->dynamicRouterPort0Valid = ENABLED;
+        pDynamicRouterPort->dynamicRouterPort0      = rtk_switch_port_P2L_get(port);
+        pDynamicRouterPort->dynamicRouterPort0Timer = timer;
+    }
+
+    if ((retVal = rtl8367c_getAsicIGMPdynamicRouterPort2(&port, &timer))!= RT_ERR_OK)
+        return retVal;
+
+    if (port == RTL8367C_ROUTER_PORT_INVALID)
+    {
+        pDynamicRouterPort->dynamicRouterPort1Valid = DISABLED;
+        pDynamicRouterPort->dynamicRouterPort1      = 0;
+        pDynamicRouterPort->dynamicRouterPort1Timer = 0;
+    }
+    else
+    {
+        pDynamicRouterPort->dynamicRouterPort1Valid = ENABLED;
+        pDynamicRouterPort->dynamicRouterPort1      = rtk_switch_port_P2L_get(port);
+        pDynamicRouterPort->dynamicRouterPort1Timer = timer;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_suppressionEnable_set
+ * Description:
+ *      Configure IGMPv1/v2 & MLDv1 Report/Leave/Done suppression
+ * Input:
+ *      reportSuppression   - Report suppression
+ *      leaveSuppression    - Leave suppression
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_suppressionEnable_set(rtk_enable_t reportSuppression, rtk_enable_t leaveSuppression)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(reportSuppression >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if(leaveSuppression >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicIGMPSuppression((rtk_uint32)reportSuppression, (rtk_uint32)leaveSuppression))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_suppressionEnable_get
+ * Description:
+ *      Get IGMPv1/v2 & MLDv1 Report/Leave/Done suppression
+ * Input:
+ *      None
+ * Output:
+ *      pReportSuppression  - Report suppression
+ *      pLeaveSuppression   - Leave suppression
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_suppressionEnable_get(rtk_enable_t *pReportSuppression, rtk_enable_t *pLeaveSuppression)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pReportSuppression)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pLeaveSuppression)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPSuppression((rtk_uint32 *)pReportSuppression, (rtk_uint32 *)pLeaveSuppression))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_portRxPktEnable_set
+ * Description:
+ *      Configure IGMP/MLD RX Packet configuration
+ * Input:
+ *      port       - Port ID
+ *      pRxCfg     - RX Packet Configuration
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_portRxPktEnable_set(rtk_port_t port, rtk_igmp_rxPktEnable_t *pRxCfg)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pRxCfg)
+        return RT_ERR_NULL_POINTER;
+
+    if(pRxCfg->rxQuery >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if(pRxCfg->rxReport >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if(pRxCfg->rxLeave >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if(pRxCfg->rxMRP >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if(pRxCfg->rxMcast >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicIGMPQueryRX(rtk_switch_port_L2P_get(port), (rtk_uint32)pRxCfg->rxQuery))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicIGMPReportRX(rtk_switch_port_L2P_get(port), (rtk_uint32)pRxCfg->rxReport))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicIGMPLeaveRX(rtk_switch_port_L2P_get(port), (rtk_uint32)pRxCfg->rxLeave))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicIGMPMRPRX(rtk_switch_port_L2P_get(port), (rtk_uint32)pRxCfg->rxMRP))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicIGMPMcDataRX(rtk_switch_port_L2P_get(port), (rtk_uint32)pRxCfg->rxMcast))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_portRxPktEnable_get
+ * Description:
+ *      Get IGMP/MLD RX Packet configuration
+ * Input:
+ *      port       - Port ID
+ *      pRxCfg     - RX Packet Configuration
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_portRxPktEnable_get(rtk_port_t port, rtk_igmp_rxPktEnable_t *pRxCfg)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pRxCfg)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPQueryRX(rtk_switch_port_L2P_get(port), (rtk_uint32 *)&(pRxCfg->rxQuery)))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicIGMPReportRX(rtk_switch_port_L2P_get(port), (rtk_uint32 *)&(pRxCfg->rxReport)))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicIGMPLeaveRX(rtk_switch_port_L2P_get(port), (rtk_uint32 *)&(pRxCfg->rxLeave)))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicIGMPMRPRX(rtk_switch_port_L2P_get(port), (rtk_uint32 *)&(pRxCfg->rxMRP)))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicIGMPMcDataRX(rtk_switch_port_L2P_get(port), (rtk_uint32 *)&(pRxCfg->rxMcast)))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_groupInfo_get
+ * Description:
+ *      Get IGMP/MLD Group database
+ * Input:
+ *      indes       - Index (0~255)
+ * Output:
+ *      pGroup      - Group database information.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_groupInfo_get(rtk_uint32 index, rtk_igmp_groupInfo_t *pGroup)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      valid;
+    rtl8367c_igmpgroup  grp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check index */
+    if(index > RTL8367C_IGMP_MAX_GOUP)
+        return RT_ERR_INPUT;
+
+    if(NULL == pGroup)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPGroup(index, &valid, &grp))!=RT_ERR_OK)
+        return retVal;
+
+    memset(pGroup, 0x00, sizeof(rtk_igmp_groupInfo_t));
+    pGroup->valid = valid;
+    pGroup->reportSuppFlag = grp.report_supp_flag;
+
+    if(grp.p0_timer != 0)
+    {
+        RTK_PORTMASK_PORT_SET((pGroup->member), rtk_switch_port_P2L_get(0));
+        pGroup->timer[rtk_switch_port_P2L_get(0)] = grp.p0_timer;
+    }
+
+    if(grp.p1_timer != 0)
+    {
+        RTK_PORTMASK_PORT_SET((pGroup->member), rtk_switch_port_P2L_get(1));
+        pGroup->timer[rtk_switch_port_P2L_get(1)] = grp.p1_timer;
+    }
+
+    if(grp.p2_timer != 0)
+    {
+        RTK_PORTMASK_PORT_SET((pGroup->member), rtk_switch_port_P2L_get(2));
+        pGroup->timer[rtk_switch_port_P2L_get(2)] = grp.p2_timer;
+    }
+
+    if(grp.p3_timer != 0)
+    {
+        RTK_PORTMASK_PORT_SET((pGroup->member), rtk_switch_port_P2L_get(3));
+        pGroup->timer[rtk_switch_port_P2L_get(3)] = grp.p3_timer;
+    }
+
+    if(grp.p4_timer != 0)
+    {
+        RTK_PORTMASK_PORT_SET((pGroup->member), rtk_switch_port_P2L_get(4));
+        pGroup->timer[rtk_switch_port_P2L_get(4)] = grp.p4_timer;
+    }
+
+    if(grp.p5_timer != 0)
+    {
+        RTK_PORTMASK_PORT_SET((pGroup->member), rtk_switch_port_P2L_get(5));
+        pGroup->timer[rtk_switch_port_P2L_get(5)] = grp.p5_timer;
+    }
+
+    if(grp.p6_timer != 0)
+    {
+        RTK_PORTMASK_PORT_SET((pGroup->member), rtk_switch_port_P2L_get(6));
+        pGroup->timer[rtk_switch_port_P2L_get(6)] = grp.p6_timer;
+    }
+
+    if(grp.p7_timer != 0)
+    {
+        RTK_PORTMASK_PORT_SET((pGroup->member), rtk_switch_port_P2L_get(7));
+        pGroup->timer[rtk_switch_port_P2L_get(7)] = grp.p7_timer;
+    }
+
+    if(grp.p8_timer != 0)
+    {
+        RTK_PORTMASK_PORT_SET((pGroup->member), rtk_switch_port_P2L_get(8));
+        pGroup->timer[rtk_switch_port_P2L_get(8)] = grp.p8_timer;
+    }
+
+    if(grp.p9_timer != 0)
+    {
+        RTK_PORTMASK_PORT_SET((pGroup->member), rtk_switch_port_P2L_get(9));
+        pGroup->timer[rtk_switch_port_P2L_get(9)] = grp.p9_timer;
+    }
+
+    if(grp.p10_timer != 0)
+    {
+        RTK_PORTMASK_PORT_SET((pGroup->member), rtk_switch_port_P2L_get(10));
+        pGroup->timer[rtk_switch_port_P2L_get(10)] = grp.p10_timer;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_ReportLeaveFwdAction_set
+ * Description:
+ *      Set Report Leave packet forwarding action
+ * Input:
+ *      action      - Action
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_ReportLeaveFwdAction_set(rtk_igmp_ReportLeaveFwdAct_t action)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    switch(action)
+    {
+        case IGMP_REPORT_LEAVE_TO_ROUTER:
+            regData = 1;
+            break;
+        case IGMP_REPORT_LEAVE_TO_ALLPORT:
+            regData = 2;
+            break;
+        case IGMP_REPORT_LEAVE_TO_ROUTER_PORT_ADV:
+            regData = 3;
+            break;
+        default:
+            return RT_ERR_INPUT;
+    }
+
+    if ((retVal = rtl8367c_setAsicIGMPReportLeaveFlood(regData))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_ReportLeaveFwdAction_get
+ * Description:
+ *      Get Report Leave packet forwarding action
+ * Input:
+ *      action      - Action
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null Pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_ReportLeaveFwdAction_get(rtk_igmp_ReportLeaveFwdAct_t *pAction)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pAction)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPReportLeaveFlood(&regData))!=RT_ERR_OK)
+        return retVal;
+
+    switch(regData)
+    {
+        case 1:
+            *pAction = IGMP_REPORT_LEAVE_TO_ROUTER;
+            break;
+        case 2:
+            *pAction = IGMP_REPORT_LEAVE_TO_ALLPORT;
+            break;
+        case 3:
+            *pAction = IGMP_REPORT_LEAVE_TO_ROUTER_PORT_ADV;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_dropLeaveZeroEnable_set
+ * Description:
+ *      Set the function of droppping Leave packet with group IP = 0.0.0.0
+ * Input:
+ *      enabled      - Action 1: drop, 0:pass
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_dropLeaveZeroEnable_set(rtk_enable_t enabled)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(enabled >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicIGMPDropLeaveZero(enabled))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtk_igmp_dropLeaveZeroEnable_get
+ * Description:
+ *      Get the function of droppping Leave packet with group IP = 0.0.0.0
+ * Input:
+ *      None
+ * Output:
+ *      pEnabled.   - Action 1: drop, 0:pass
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null Pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_dropLeaveZeroEnable_get(rtk_enable_t *pEnabled)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnabled)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPDropLeaveZero((rtk_uint32 *)pEnabled))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtk_igmp_bypassGroupRange_set
+ * Description:
+ *      Set Bypass group
+ * Input:
+ *      group       - bypassed group
+ *      enabled     - enabled 1: Bypassed, 0: not bypass
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_bypassGroupRange_set(rtk_igmp_bypassGroup_t group, rtk_enable_t enabled)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(group >= IGMP_BYPASS_GROUP_END)
+        return RT_ERR_INPUT;
+
+    if(enabled >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicIGMPBypassGroup(group, enabled))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_igmp_bypassGroupRange_get
+ * Description:
+ *      get Bypass group
+ * Input:
+ *      group       - bypassed group
+ * Output:
+ *      pEnable     - enabled 1: Bypassed, 0: not bypass
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null Pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_igmp_bypassGroupRange_get(rtk_igmp_bypassGroup_t group, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(group >= IGMP_BYPASS_GROUP_END)
+        return RT_ERR_INPUT;
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicIGMPBypassGroup(group, pEnable))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/include/acl.h b/drivers/net/phy/rtk/rtl8367c/include/acl.h
new file mode 100644
index 0000000000000..6161c490782b1
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/acl.h
@@ -0,0 +1,990 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes ACL module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_ACL_H__
+#define __RTK_API_ACL_H__
+
+/*
+ * Data Type Declaration
+ */
+#define RTK_FILTER_RAW_FIELD_NUMBER                8
+
+#define ACL_DEFAULT_ABILITY                         0
+#define ACL_DEFAULT_UNMATCH_PERMIT                  1
+
+#define ACL_RULE_FREE                               0
+#define ACL_RULE_INAVAILABLE                        1
+#define ACL_RULE_CARETAG_MASK                       0x1F
+#define FILTER_POLICING_MAX                         4
+#define FILTER_LOGGING_MAX                          8
+#define FILTER_PATTERN_MAX                          4
+
+#define FILTER_ENACT_CVLAN_MASK         0x01
+#define FILTER_ENACT_SVLAN_MASK         0x02
+#define FILTER_ENACT_PRIORITY_MASK      0x04
+#define FILTER_ENACT_POLICING_MASK      0x08
+#define FILTER_ENACT_FWD_MASK           0x10
+#define FILTER_ENACT_INTGPIO_MASK       0x20
+#define FILTER_ENACT_INIT_MASK          0x3F
+
+typedef enum rtk_filter_act_cactext_e
+{
+    FILTER_ENACT_CACTEXT_VLANONLY=0,
+    FILTER_ENACT_CACTEXT_BOTHVLANTAG,
+    FILTER_ENACT_CACTEXT_TAGONLY,
+    FILTER_ENACT_CACTEXT_END,
+
+
+}rtk_filter_act_cactext_t;
+
+typedef enum rtk_filter_act_ctagfmt_e
+{
+    FILTER_CTAGFMT_UNTAG=0,
+    FILTER_CTAGFMT_TAG,
+    FILTER_CTAGFMT_KEEP,
+    FILTER_CTAGFMT_KEEP1PRMK,
+
+
+}rtk_filter_act_ctag_t;
+
+
+
+
+
+#define RTK_MAX_NUM_OF_FILTER_TYPE                  5
+#define RTK_MAX_NUM_OF_FILTER_FIELD                 8
+
+#define RTK_DOT_1AS_TIMESTAMP_UNIT_IN_WORD_LENGTH   3UL
+#define RTK_IPV6_ADDR_WORD_LENGTH                   4UL
+
+#define FILTER_ENACT_CVLAN_TYPE(type)   (type - FILTER_ENACT_CVLAN_INGRESS)
+#define FILTER_ENACT_SVLAN_TYPE(type)   (type - FILTER_ENACT_SVLAN_INGRESS)
+#define FILTER_ENACT_FWD_TYPE(type)     (type - FILTER_ENACT_ADD_DSTPORT)
+#define FILTER_ENACT_PRI_TYPE(type)     (type - FILTER_ENACT_PRIORITY)
+
+#define RTK_FILTER_FIELD_USED_MAX                   8
+#define RTK_FILTER_FIELD_INDEX(template, index)     ((template << 4) + index)
+
+
+typedef enum rtk_filter_act_enable_e
+{
+    /* CVLAN */
+    FILTER_ENACT_CVLAN_INGRESS = 0,
+    FILTER_ENACT_CVLAN_EGRESS,
+    FILTER_ENACT_CVLAN_SVID,
+    FILTER_ENACT_POLICING_1,
+
+    /* SVLAN */
+    FILTER_ENACT_SVLAN_INGRESS,
+    FILTER_ENACT_SVLAN_EGRESS,
+    FILTER_ENACT_SVLAN_CVID,
+    FILTER_ENACT_POLICING_2,
+
+    /* Policing and Logging */
+    FILTER_ENACT_POLICING_0,
+
+    /* Forward */
+    FILTER_ENACT_COPY_CPU,
+    FILTER_ENACT_DROP,
+    FILTER_ENACT_ADD_DSTPORT,
+    FILTER_ENACT_REDIRECT,
+    FILTER_ENACT_MIRROR,
+    FILTER_ENACT_TRAP_CPU,
+    FILTER_ENACT_ISOLATION,
+
+    /* QoS */
+    FILTER_ENACT_PRIORITY,
+    FILTER_ENACT_DSCP_REMARK,
+    FILTER_ENACT_1P_REMARK,
+    FILTER_ENACT_POLICING_3,
+
+    /* Interrutp and GPO */
+    FILTER_ENACT_INTERRUPT,
+    FILTER_ENACT_GPO,
+
+    /*VLAN tag*/
+    FILTER_ENACT_EGRESSCTAG_UNTAG,
+    FILTER_ENACT_EGRESSCTAG_TAG,
+    FILTER_ENACT_EGRESSCTAG_KEEP,
+    FILTER_ENACT_EGRESSCTAG_KEEPAND1PRMK,
+
+    FILTER_ENACT_END,
+} rtk_filter_act_enable_t;
+
+
+typedef struct
+{
+    rtk_filter_act_enable_t actEnable[FILTER_ENACT_END];
+
+    /* CVLAN acton */
+    rtk_uint32      filterCvlanVid;
+    rtk_uint32      filterCvlanIdx;
+    /* SVLAN action */
+    rtk_uint32      filterSvlanVid;
+    rtk_uint32      filterSvlanIdx;
+
+    /* Policing action */
+    rtk_uint32      filterPolicingIdx[FILTER_POLICING_MAX];
+
+    /* Forwarding action */
+    rtk_portmask_t  filterPortmask;
+
+    /* QOS action */
+    rtk_uint32      filterPriority;
+
+    /*GPO*/
+    rtk_uint32      filterPin;
+
+} rtk_filter_action_t;
+
+typedef struct rtk_filter_flag_s
+{
+    rtk_uint32 value;
+    rtk_uint32 mask;
+} rtk_filter_flag_t;
+
+typedef enum rtk_filter_care_tag_index_e
+{
+    CARE_TAG_CTAG = 0,
+    CARE_TAG_STAG,
+    CARE_TAG_PPPOE,
+    CARE_TAG_IPV4,
+    CARE_TAG_IPV6,
+    CARE_TAG_TCP,
+    CARE_TAG_UDP,
+    CARE_TAG_ARP,
+    CARE_TAG_RSV1,
+    CARE_TAG_RSV2,
+    CARE_TAG_ICMP,
+    CARE_TAG_IGMP,
+    CARE_TAG_LLC,
+    CARE_TAG_RSV3,
+    CARE_TAG_HTTP,
+    CARE_TAG_RSV4,
+    CARE_TAG_RSV5,
+    CARE_TAG_DHCP,
+    CARE_TAG_DHCPV6,
+    CARE_TAG_SNMP,
+    CARE_TAG_OAM,
+    CARE_TAG_END,
+} rtk_filter_care_tag_index_t;
+
+typedef struct rtk_filter_care_tag_s
+{
+    rtk_filter_flag_t tagType[CARE_TAG_END];
+} rtk_filter_care_tag_t;
+
+typedef struct rtk_filter_field rtk_filter_field_t;
+
+typedef struct
+{
+    rtk_uint32 value[RTK_DOT_1AS_TIMESTAMP_UNIT_IN_WORD_LENGTH];
+} rtk_filter_dot1as_timestamp_t;
+
+typedef enum rtk_filter_field_data_type_e
+{
+    FILTER_FIELD_DATA_MASK = 0,
+    FILTER_FIELD_DATA_RANGE,
+    FILTER_FIELD_DATA_END ,
+} rtk_filter_field_data_type_t;
+
+typedef struct rtk_filter_ip_s
+{
+    rtk_uint32 dataType;
+    rtk_uint32 rangeStart;
+    rtk_uint32 rangeEnd;
+    rtk_uint32 value;
+    rtk_uint32 mask;
+} rtk_filter_ip_t;
+
+typedef struct rtk_filter_mac_s
+{
+    rtk_uint32 dataType;
+    rtk_mac_t value;
+    rtk_mac_t mask;
+    rtk_mac_t rangeStart;
+    rtk_mac_t rangeEnd;
+} rtk_filter_mac_t;
+
+typedef rtk_uint32 rtk_filter_op_t;
+
+typedef struct rtk_filter_value_s
+{
+    rtk_uint32 dataType;
+    rtk_uint32 value;
+    rtk_uint32 mask;
+    rtk_uint32 rangeStart;
+    rtk_uint32 rangeEnd;
+
+} rtk_filter_value_t;
+
+typedef struct rtk_filter_activeport_s
+{
+    rtk_portmask_t value;
+    rtk_portmask_t mask;
+
+} rtk_filter_activeport_t;
+
+
+
+typedef struct rtk_filter_tag_s
+{
+    rtk_filter_value_t pri;
+    rtk_filter_flag_t cfi;
+    rtk_filter_value_t vid;
+} rtk_filter_tag_t;
+
+typedef struct rtk_filter_ipFlag_s
+{
+    rtk_filter_flag_t xf;
+    rtk_filter_flag_t mf;
+    rtk_filter_flag_t df;
+} rtk_filter_ipFlag_t;
+
+typedef struct
+{
+    rtk_uint32 addr[RTK_IPV6_ADDR_WORD_LENGTH];
+} rtk_filter_ip6_addr_t;
+
+typedef struct
+{
+    rtk_uint32 dataType;
+    rtk_filter_ip6_addr_t value;
+    rtk_filter_ip6_addr_t mask;
+    rtk_filter_ip6_addr_t rangeStart;
+    rtk_filter_ip6_addr_t rangeEnd;
+} rtk_filter_ip6_t;
+
+typedef rtk_uint32 rtk_filter_number_t;
+
+typedef struct rtk_filter_pattern_s
+{
+    rtk_uint32 value[FILTER_PATTERN_MAX];
+    rtk_uint32 mask[FILTER_PATTERN_MAX];
+} rtk_filter_pattern_t;
+
+typedef struct rtk_filter_tcpFlag_s
+{
+    rtk_filter_flag_t urg;
+    rtk_filter_flag_t ack;
+    rtk_filter_flag_t psh;
+    rtk_filter_flag_t rst;
+    rtk_filter_flag_t syn;
+    rtk_filter_flag_t fin;
+    rtk_filter_flag_t ns;
+    rtk_filter_flag_t cwr;
+    rtk_filter_flag_t ece;
+} rtk_filter_tcpFlag_t;
+
+typedef rtk_uint32 rtk_filter_field_raw_t;
+
+typedef enum rtk_filter_field_temple_input_e
+{
+    FILTER_FIELD_TEMPLE_INPUT_TYPE = 0,
+    FILTER_FIELD_TEMPLE_INPUT_INDEX,
+    FILTER_FIELD_TEMPLE_INPUT_MAX ,
+} rtk_filter_field_temple_input_t;
+
+struct rtk_filter_field
+{
+    rtk_uint32 fieldType;
+
+    union
+    {
+        /* L2 struct */
+        rtk_filter_mac_t       dmac;
+        rtk_filter_mac_t       smac;
+        rtk_filter_value_t     etherType;
+        rtk_filter_tag_t       ctag;
+        rtk_filter_tag_t       relayCtag;
+        rtk_filter_tag_t       stag;
+        rtk_filter_tag_t       l2tag;
+        rtk_filter_dot1as_timestamp_t dot1asTimeStamp;
+        rtk_filter_mac_t       mac;
+
+        /* L3 struct */
+        rtk_filter_ip_t      sip;
+        rtk_filter_ip_t      dip;
+        rtk_filter_ip_t      ip;
+        rtk_filter_value_t   protocol;
+        rtk_filter_value_t   ipTos;
+        rtk_filter_ipFlag_t  ipFlag;
+        rtk_filter_value_t   ipOffset;
+        rtk_filter_ip6_t     sipv6;
+        rtk_filter_ip6_t     dipv6;
+        rtk_filter_ip6_t     ipv6;
+        rtk_filter_value_t   ipv6TrafficClass;
+        rtk_filter_value_t   ipv6NextHeader;
+        rtk_filter_value_t   flowLabel;
+
+        /* L4 struct */
+        rtk_filter_value_t   tcpSrcPort;
+        rtk_filter_value_t   tcpDstPort;
+        rtk_filter_tcpFlag_t tcpFlag;
+        rtk_filter_value_t   tcpSeqNumber;
+        rtk_filter_value_t   tcpAckNumber;
+        rtk_filter_value_t   udpSrcPort;
+        rtk_filter_value_t   udpDstPort;
+        rtk_filter_value_t   icmpCode;
+        rtk_filter_value_t   icmpType;
+        rtk_filter_value_t   igmpType;
+
+        /* pattern match */
+        rtk_filter_pattern_t pattern;
+
+        rtk_filter_value_t   inData;
+
+    } filter_pattern_union;
+
+    rtk_uint32 fieldTemplateNo;
+    rtk_uint32 fieldTemplateIdx[RTK_FILTER_FIELD_USED_MAX];
+
+    struct rtk_filter_field *next;
+};
+
+typedef enum rtk_filter_field_type_e
+{
+    FILTER_FIELD_DMAC = 0,
+    FILTER_FIELD_SMAC,
+    FILTER_FIELD_ETHERTYPE,
+    FILTER_FIELD_CTAG,
+    FILTER_FIELD_STAG,
+
+    FILTER_FIELD_IPV4_SIP,
+    FILTER_FIELD_IPV4_DIP,
+    FILTER_FIELD_IPV4_TOS,
+    FILTER_FIELD_IPV4_PROTOCOL,
+    FILTER_FIELD_IPV4_FLAG,
+    FILTER_FIELD_IPV4_OFFSET,
+    FILTER_FIELD_IPV6_SIPV6,
+    FILTER_FIELD_IPV6_DIPV6,
+    FILTER_FIELD_IPV6_TRAFFIC_CLASS,
+    FILTER_FIELD_IPV6_NEXT_HEADER,
+
+    FILTER_FIELD_TCP_SPORT,
+    FILTER_FIELD_TCP_DPORT,
+    FILTER_FIELD_TCP_FLAG,
+    FILTER_FIELD_UDP_SPORT,
+    FILTER_FIELD_UDP_DPORT,
+    FILTER_FIELD_ICMP_CODE,
+    FILTER_FIELD_ICMP_TYPE,
+    FILTER_FIELD_IGMP_TYPE,
+
+    FILTER_FIELD_VID_RANGE,
+    FILTER_FIELD_IP_RANGE,
+    FILTER_FIELD_PORT_RANGE,
+
+    FILTER_FIELD_USER_DEFINED00,
+    FILTER_FIELD_USER_DEFINED01,
+    FILTER_FIELD_USER_DEFINED02,
+    FILTER_FIELD_USER_DEFINED03,
+    FILTER_FIELD_USER_DEFINED04,
+    FILTER_FIELD_USER_DEFINED05,
+    FILTER_FIELD_USER_DEFINED06,
+    FILTER_FIELD_USER_DEFINED07,
+    FILTER_FIELD_USER_DEFINED08,
+    FILTER_FIELD_USER_DEFINED09,
+    FILTER_FIELD_USER_DEFINED10,
+    FILTER_FIELD_USER_DEFINED11,
+    FILTER_FIELD_USER_DEFINED12,
+    FILTER_FIELD_USER_DEFINED13,
+    FILTER_FIELD_USER_DEFINED14,
+    FILTER_FIELD_USER_DEFINED15,
+
+    FILTER_FIELD_PATTERN_MATCH,
+
+    FILTER_FIELD_END,
+} rtk_filter_field_type_t;
+
+
+typedef enum rtk_filter_field_type_raw_e
+{
+    FILTER_FIELD_RAW_UNUSED = 0,
+    FILTER_FIELD_RAW_DMAC_15_0,
+    FILTER_FIELD_RAW_DMAC_31_16,
+    FILTER_FIELD_RAW_DMAC_47_32,
+    FILTER_FIELD_RAW_SMAC_15_0,
+    FILTER_FIELD_RAW_SMAC_31_16,
+    FILTER_FIELD_RAW_SMAC_47_32,
+    FILTER_FIELD_RAW_ETHERTYPE,
+    FILTER_FIELD_RAW_STAG,
+    FILTER_FIELD_RAW_CTAG,
+
+    FILTER_FIELD_RAW_IPV4_SIP_15_0 = 0x10,
+    FILTER_FIELD_RAW_IPV4_SIP_31_16,
+    FILTER_FIELD_RAW_IPV4_DIP_15_0,
+    FILTER_FIELD_RAW_IPV4_DIP_31_16,
+
+
+    FILTER_FIELD_RAW_IPV6_SIP_15_0 = 0x20,
+    FILTER_FIELD_RAW_IPV6_SIP_31_16,
+    FILTER_FIELD_RAW_IPV6_DIP_15_0 = 0x28,
+    FILTER_FIELD_RAW_IPV6_DIP_31_16,
+
+    FILTER_FIELD_RAW_VIDRANGE = 0x30,
+    FILTER_FIELD_RAW_IPRANGE,
+    FILTER_FIELD_RAW_PORTRANGE,
+    FILTER_FIELD_RAW_FIELD_VALID,
+
+    FILTER_FIELD_RAW_FIELD_SELECT00 = 0x40,
+    FILTER_FIELD_RAW_FIELD_SELECT01,
+    FILTER_FIELD_RAW_FIELD_SELECT02,
+    FILTER_FIELD_RAW_FIELD_SELECT03,
+    FILTER_FIELD_RAW_FIELD_SELECT04,
+    FILTER_FIELD_RAW_FIELD_SELECT05,
+    FILTER_FIELD_RAW_FIELD_SELECT06,
+    FILTER_FIELD_RAW_FIELD_SELECT07,
+    FILTER_FIELD_RAW_FIELD_SELECT08,
+    FILTER_FIELD_RAW_FIELD_SELECT09,
+    FILTER_FIELD_RAW_FIELD_SELECT10,
+    FILTER_FIELD_RAW_FIELD_SELECT11,
+    FILTER_FIELD_RAW_FIELD_SELECT12,
+    FILTER_FIELD_RAW_FIELD_SELECT13,
+    FILTER_FIELD_RAW_FIELD_SELECT14,
+    FILTER_FIELD_RAW_FIELD_SELECT15,
+
+    FILTER_FIELD_RAW_END,
+} rtk_filter_field_type_raw_t;
+
+typedef enum rtk_filter_flag_care_type_e
+{
+    FILTER_FLAG_CARE_DONT_CARE = 0,
+    FILTER_FLAG_CARE_1,
+    FILTER_FLAG_CARE_0,
+    FILTER_FLAG_END
+} rtk_filter_flag_care_type_t;
+
+typedef rtk_uint32  rtk_filter_id_t;    /* filter id type */
+
+typedef enum rtk_filter_invert_e
+{
+    FILTER_INVERT_DISABLE = 0,
+    FILTER_INVERT_ENABLE,
+    FILTER_INVERT_END,
+} rtk_filter_invert_t;
+
+typedef rtk_uint32 rtk_filter_state_t;
+
+typedef rtk_uint32 rtk_filter_unmatch_action_t;
+
+typedef enum rtk_filter_unmatch_action_e
+{
+    FILTER_UNMATCH_DROP = 0,
+    FILTER_UNMATCH_PERMIT,
+    FILTER_UNMATCH_END,
+} rtk_filter_unmatch_action_type_t;
+
+typedef struct
+{
+    rtk_filter_field_t      *fieldHead;
+    rtk_filter_care_tag_t   careTag;
+    rtk_filter_activeport_t activeport;
+
+    rtk_filter_invert_t     invert;
+} rtk_filter_cfg_t;
+
+typedef struct
+{
+    rtk_filter_field_raw_t      dataFieldRaw[RTK_FILTER_RAW_FIELD_NUMBER];
+    rtk_filter_field_raw_t      careFieldRaw[RTK_FILTER_RAW_FIELD_NUMBER];
+    rtk_filter_field_type_raw_t fieldRawType[RTK_FILTER_RAW_FIELD_NUMBER];
+    rtk_filter_care_tag_t       careTag;
+    rtk_filter_activeport_t     activeport;
+
+    rtk_filter_invert_t         invert;
+    rtk_enable_t                valid;
+} rtk_filter_cfg_raw_t;
+
+typedef struct
+{
+    rtk_uint32 index;
+    rtk_filter_field_type_raw_t fieldType[RTK_FILTER_RAW_FIELD_NUMBER];
+} rtk_filter_template_t;
+
+typedef enum rtk_field_sel_e
+{
+    FORMAT_DEFAULT = 0,
+    FORMAT_RAW,
+    FORMAT_LLC,
+    FORMAT_IPV4,
+    FORMAT_ARP,
+    FORMAT_IPV6,
+    FORMAT_IPPAYLOAD,
+    FORMAT_L4PAYLOAD,
+    FORMAT_END
+}rtk_field_sel_t;
+
+typedef enum rtk_filter_iprange_e
+{
+    IPRANGE_UNUSED = 0,
+    IPRANGE_IPV4_SIP,
+    IPRANGE_IPV4_DIP,
+    IPRANGE_IPV6_SIP,
+    IPRANGE_IPV6_DIP,
+    IPRANGE_END
+}rtk_filter_iprange_t;
+
+typedef enum rtk_filter_vidrange_e
+{
+    VIDRANGE_UNUSED = 0,
+    VIDRANGE_CVID,
+    VIDRANGE_SVID,
+    VIDRANGE_END
+}rtk_filter_vidrange_t;
+
+typedef enum rtk_filter_portrange_e
+{
+    PORTRANGE_UNUSED = 0,
+    PORTRANGE_SPORT,
+    PORTRANGE_DPORT,
+    PORTRANGE_END
+}rtk_filter_portrange_t;
+
+/* Function Name:
+ *      rtk_filter_igrAcl_init
+ * Description:
+ *      ACL initialization function
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - Pointer pFilter_field or pFilter_cfg point to NULL.
+ * Note:
+ *      This function enable and intialize ACL function
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_init(void);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_field_add
+ * Description:
+ *      Add comparison rule to an ACL configuration
+ * Input:
+ *      pFilter_cfg     - The ACL configuration that this function will add comparison rule
+ *      pFilter_field   - The comparison rule that will be added.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Pointer pFilter_field or pFilter_cfg point to NULL.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      This function add a comparison rule (*pFilter_field) to an ACL configuration (*pFilter_cfg).
+ *      Pointer pFilter_cfg points to an ACL configuration structure, this structure keeps multiple ACL
+ *      comparison rules by means of linked list. Pointer pFilter_field will be added to linked
+ *      list keeped by structure that pFilter_cfg points to.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_field_add(rtk_filter_cfg_t *pFilter_cfg, rtk_filter_field_t *pFilter_field);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_cfg_add
+ * Description:
+ *      Add an ACL configuration to ASIC
+ * Input:
+ *      filter_id       - Start index of ACL configuration.
+ *      pFilter_cfg     - The ACL configuration that this function will add comparison rule
+ *      pFilter_action  - Action(s) of ACL configuration.
+ * Output:
+ *      ruleNum - number of rules written in acl table
+ * Return:
+ *      RT_ERR_OK                               - OK
+ *      RT_ERR_FAILED                           - Failed
+ *      RT_ERR_SMI                              - SMI access error
+ *      RT_ERR_NULL_POINTER                     - Pointer pFilter_field or pFilter_cfg point to NULL.
+ *      RT_ERR_INPUT                            - Invalid input parameters.
+ *      RT_ERR_ENTRY_INDEX                      - Invalid filter_id .
+ *      RT_ERR_NULL_POINTER                     - Pointer pFilter_action or pFilter_cfg point to NULL.
+ *      RT_ERR_FILTER_INACL_ACT_NOT_SUPPORT     - Action is not supported in this chip.
+ *      RT_ERR_FILTER_INACL_RULE_NOT_SUPPORT    - Rule is not supported.
+ * Note:
+ *      This function store pFilter_cfg, pFilter_action into ASIC. The starting
+ *      index(es) is filter_id.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_cfg_add(rtk_filter_id_t filter_id, rtk_filter_cfg_t *pFilter_cfg, rtk_filter_action_t *pAction, rtk_filter_number_t *ruleNum);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_cfg_del
+ * Description:
+ *      Delete an ACL configuration from ASIC
+ * Input:
+ *      filter_id   - Start index of ACL configuration.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_ENTRYIDX  - Invalid filter_id.
+ * Note:
+ *      This function delete a group of ACL rules starting from filter_id.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_cfg_del(rtk_filter_id_t filter_id);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_cfg_delAll
+ * Description:
+ *      Delete all ACL entries from ASIC
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      This function delete all ACL configuration from ASIC.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_cfg_delAll(void);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_cfg_get
+ * Description:
+ *      Get one ingress acl configuration from ASIC.
+ * Input:
+ *      filter_id       - Start index of ACL configuration.
+ * Output:
+ *      pFilter_cfg     - buffer pointer of ingress acl data
+ *      pFilter_action  - buffer pointer of ingress acl action
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Pointer pFilter_action or pFilter_cfg point to NULL.
+ *      RT_ERR_FILTER_ENTRYIDX  - Invalid entry index.
+ * Note:
+ *      This function delete all ACL configuration from ASIC.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_cfg_get(rtk_filter_id_t filter_id, rtk_filter_cfg_raw_t *pFilter_cfg, rtk_filter_action_t *pAction);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_unmatchAction_set
+ * Description:
+ *      Set action to packets when no ACL configuration match
+ * Input:
+ *      port    - Port id.
+ *      action  - Action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port id.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This function sets action of packets when no ACL configruation matches.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_unmatchAction_set(rtk_port_t port, rtk_filter_unmatch_action_t action);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_unmatchAction_get
+ * Description:
+ *      Get action to packets when no ACL configuration match
+ * Input:
+ *      port    - Port id.
+ * Output:
+ *      pAction - Action.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port id.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This function gets action of packets when no ACL configruation matches.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_unmatchAction_get(rtk_port_t port, rtk_filter_unmatch_action_t* action);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_state_set
+ * Description:
+ *      Set state of ingress ACL.
+ * Input:
+ *      port    - Port id.
+ *      state   - Ingress ACL state.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port id.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This function gets action of packets when no ACL configruation matches.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_state_set(rtk_port_t port, rtk_filter_state_t state);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_state_get
+ * Description:
+ *      Get state of ingress ACL.
+ * Input:
+ *      port    - Port id.
+ * Output:
+ *      pState  - Ingress ACL state.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port id.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This function gets action of packets when no ACL configruation matches.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_state_get(rtk_port_t port, rtk_filter_state_t* state);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_template_set
+ * Description:
+ *      Set template of ingress ACL.
+ * Input:
+ *      template - Ingress ACL template
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Invalid input parameters.
+ * Note:
+ *      This function set ACL template.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_template_set(rtk_filter_template_t *aclTemplate);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_template_get
+ * Description:
+ *      Get template of ingress ACL.
+ * Input:
+ *      template - Ingress ACL template
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This function gets template of ACL.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_template_get(rtk_filter_template_t *aclTemplate);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_field_sel_set
+ * Description:
+ *      Set user defined field selectors in HSB
+ * Input:
+ *      index       - index of field selector 0-15
+ *      format      - Format of field selector
+ *      offset      - Retrieving data offset
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      System support 16 user defined field selctors.
+ *      Each selector can be enabled or disable.
+ *      User can defined retrieving 16-bits in many predefiend
+ *      standard l2/l3/l4 payload.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_field_sel_set(rtk_uint32 index, rtk_field_sel_t format, rtk_uint32 offset);
+
+/* Function Name:
+ *      rtk_filter_igrAcl_field_sel_get
+ * Description:
+ *      Get user defined field selectors in HSB
+ * Input:
+ *      index       - index of field selector 0-15
+ * Output:
+ *      pFormat     - Format of field selector
+ *      pOffset     - Retrieving data offset
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_filter_igrAcl_field_sel_get(rtk_uint32 index, rtk_field_sel_t *pFormat, rtk_uint32 *pOffset);
+
+/* Function Name:
+ *      rtk_filter_iprange_set
+ * Description:
+ *      Set IP Range check
+ * Input:
+ *      index       - index of IP Range 0-15
+ *      type        - IP Range check type, 0:Delete a entry, 1: IPv4_SIP, 2: IPv4_DIP, 3:IPv6_SIP, 4:IPv6_DIP
+ *      upperIp     - The upper bound of IP range
+ *      lowerIp     - The lower Bound of IP range
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
+ * Note:
+ *      upperIp must be larger or equal than lowerIp.
+ */
+extern rtk_api_ret_t rtk_filter_iprange_set(rtk_uint32 index, rtk_filter_iprange_t type, ipaddr_t upperIp, ipaddr_t lowerIp);
+
+/* Function Name:
+ *      rtk_filter_iprange_get
+ * Description:
+ *      Set IP Range check
+ * Input:
+ *      index       - index of IP Range 0-15
+ * Output:
+ *      pType        - IP Range check type, 0:Delete a entry, 1: IPv4_SIP, 2: IPv4_DIP, 3:IPv6_SIP, 4:IPv6_DIP
+ *      pUpperIp     - The upper bound of IP range
+ *      pLowerIp     - The lower Bound of IP range
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ * Note:
+ *      upperIp must be larger or equal than lowerIp.
+ */
+extern rtk_api_ret_t rtk_filter_iprange_get(rtk_uint32 index, rtk_filter_iprange_t *pType, ipaddr_t *pUpperIp, ipaddr_t *pLowerIp);
+
+/* Function Name:
+ *      rtk_filter_vidrange_set
+ * Description:
+ *      Set VID Range check
+ * Input:
+ *      index       - index of VID Range 0-15
+ *      type        - IP Range check type, 0:Delete a entry, 1: CVID, 2: SVID
+ *      upperVid    - The upper bound of VID range
+ *      lowerVid    - The lower Bound of VID range
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
+ * Note:
+ *      upperVid must be larger or equal than lowerVid.
+ */
+extern rtk_api_ret_t rtk_filter_vidrange_set(rtk_uint32 index, rtk_filter_vidrange_t type, rtk_uint32 upperVid, rtk_uint32 lowerVid);
+
+/* Function Name:
+ *      rtk_filter_vidrange_get
+ * Description:
+ *      Get VID Range check
+ * Input:
+ *      index       - index of VID Range 0-15
+ * Output:
+ *      pType        - IP Range check type, 0:Unused, 1: CVID, 2: SVID
+ *      pUpperVid    - The upper bound of VID range
+ *      pLowerVid    - The lower Bound of VID range
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_filter_vidrange_get(rtk_uint32 index, rtk_filter_vidrange_t *pType, rtk_uint32 *pUpperVid, rtk_uint32 *pLowerVid);
+
+/* Function Name:
+ *      rtk_filter_portrange_set
+ * Description:
+ *      Set Port Range check
+ * Input:
+ *      index       - index of Port Range 0-15
+ *      type        - IP Range check type, 0:Delete a entry, 1: Source Port, 2: Destnation Port
+ *      upperPort   - The upper bound of Port range
+ *      lowerPort   - The lower Bound of Port range
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
+ * Note:
+ *      upperPort must be larger or equal than lowerPort.
+ */
+extern rtk_api_ret_t rtk_filter_portrange_set(rtk_uint32 index, rtk_filter_portrange_t type, rtk_uint32 upperPort, rtk_uint32 lowerPort);
+
+/* Function Name:
+ *      rtk_filter_portrange_get
+ * Description:
+ *      Set Port Range check
+ * Input:
+ *      index       - index of Port Range 0-15
+ * Output:
+ *      pType       - IP Range check type, 0:Delete a entry, 1: Source Port, 2: Destnation Port
+ *      pUpperPort  - The upper bound of Port range
+ *      pLowerPort  - The lower Bound of Port range
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_OUT_OF_RANGE    - The parameter is out of range
+ *      RT_ERR_INPUT           - Input error
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_filter_portrange_get(rtk_uint32 index, rtk_filter_portrange_t *pType, rtk_uint32 *pUpperPort, rtk_uint32 *pLowerPort);
+
+/* Function Name:
+ *      rtk_filter_igrAclPolarity_set
+ * Description:
+ *      Set ACL Goip control palarity
+ * Input:
+ *      polarity - 1: High, 0: Low
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      none
+ */
+extern rtk_api_ret_t rtk_filter_igrAclPolarity_set(rtk_uint32 polarity);
+
+/* Function Name:
+ *      rtk_filter_igrAclPolarity_get
+ * Description:
+ *      Get ACL Goip control palarity
+ * Input:
+ *      pPolarity - 1: High, 0: Low
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      none
+ */
+extern rtk_api_ret_t rtk_filter_igrAclPolarity_get(rtk_uint32* pPolarity);
+
+
+#endif /* __RTK_API_ACL_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/cpu.h b/drivers/net/phy/rtk/rtl8367c/include/cpu.h
new file mode 100644
index 0000000000000..acd1407754be7
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/cpu.h
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes CPU module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_CPU_H__
+#define __RTK_API_CPU_H__
+
+
+/*
+ * Data Type Declaration
+ */
+typedef enum rtk_cpu_insert_e
+{
+    CPU_INSERT_TO_ALL = 0,
+    CPU_INSERT_TO_TRAPPING,
+    CPU_INSERT_TO_NONE,
+    CPU_INSERT_END
+}rtk_cpu_insert_t;
+
+typedef enum rtk_cpu_position_e
+{
+    CPU_POS_AFTER_SA = 0,
+    CPU_POS_BEFORE_CRC,
+    CPU_POS_END
+}rtk_cpu_position_t;
+
+typedef enum rtk_cpu_tag_length_e
+{
+    CPU_LEN_8BYTES = 0,
+    CPU_LEN_4BYTES,
+    CPU_LEN_END
+}rtk_cpu_tag_length_t;
+
+
+typedef enum rtk_cpu_rx_length_e
+{
+    CPU_RX_72BYTES = 0,
+    CPU_RX_64BYTES,
+    CPU_RX_END
+}rtk_cpu_rx_length_t;
+
+
+/* Function Name:
+ *      rtk_cpu_enable_set
+ * Description:
+ *      Set CPU port function enable/disable.
+ * Input:
+ *      enable - CPU port function enable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can set CPU port function enable/disable.
+ */
+extern rtk_api_ret_t rtk_cpu_enable_set(rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_cpu_enable_get
+ * Description:
+ *      Get CPU port and its setting.
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - CPU port function enable
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_L2_NO_CPU_PORT   - CPU port is not exist
+ * Note:
+ *      The API can get CPU port function enable/disable.
+ */
+extern rtk_api_ret_t rtk_cpu_enable_get(rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_cpu_tagPort_set
+ * Description:
+ *      Set CPU port and CPU tag insert mode.
+ * Input:
+ *      port - Port id.
+ *      mode - CPU tag insert for packets egress from CPU port.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can set CPU port and inserting proprietary CPU tag mode (Length/Type 0x8899)
+ *      to the frame that transmitting to CPU port.
+ *      The inset cpu tag mode is as following:
+ *      - CPU_INSERT_TO_ALL
+ *      - CPU_INSERT_TO_TRAPPING
+ *      - CPU_INSERT_TO_NONE
+ */
+extern rtk_api_ret_t rtk_cpu_tagPort_set(rtk_port_t port, rtk_cpu_insert_t mode);
+
+/* Function Name:
+ *      rtk_cpu_tagPort_get
+ * Description:
+ *      Get CPU port and CPU tag insert mode.
+ * Input:
+ *      None
+ * Output:
+ *      pPort - Port id.
+ *      pMode - CPU tag insert for packets egress from CPU port, 0:all insert 1:Only for trapped packets 2:no insert.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_L2_NO_CPU_PORT   - CPU port is not exist
+ * Note:
+ *      The API can get configured CPU port and its setting.
+ *      The inset cpu tag mode is as following:
+ *      - CPU_INSERT_TO_ALL
+ *      - CPU_INSERT_TO_TRAPPING
+ *      - CPU_INSERT_TO_NONE
+ */
+extern rtk_api_ret_t rtk_cpu_tagPort_get(rtk_port_t *pPort, rtk_cpu_insert_t *pMode);
+
+/* Function Name:
+ *      rtk_cpu_awarePort_set
+ * Description:
+ *      Set CPU aware port mask.
+ * Input:
+ *      portmask - Port mask.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK      - Invalid port mask.
+ * Note:
+ *      The API can set configured CPU aware port mask.
+ */
+extern rtk_api_ret_t rtk_cpu_awarePort_set(rtk_portmask_t *pPortmask);
+
+
+/* Function Name:
+ *      rtk_cpu_awarePort_get
+ * Description:
+ *      Get CPU aware port mask.
+ * Input:
+ *      None
+ * Output:
+ *      pPortmask - Port mask.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ * Note:
+ *      The API can get configured CPU aware port mask.
+ */
+extern rtk_api_ret_t rtk_cpu_awarePort_get(rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_cpu_tagPosition_set
+ * Description:
+ *      Set CPU tag position.
+ * Input:
+ *      position - CPU tag position.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can set CPU tag position.
+ */
+extern rtk_api_ret_t rtk_cpu_tagPosition_set(rtk_cpu_position_t position);
+
+/* Function Name:
+ *      rtk_cpu_tagPosition_get
+ * Description:
+ *      Get CPU tag position.
+ * Input:
+ *      None
+ * Output:
+ *      pPosition - CPU tag position.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can get CPU tag position.
+ */
+extern rtk_api_ret_t rtk_cpu_tagPosition_get(rtk_cpu_position_t *pPosition);
+
+/* Function Name:
+ *      rtk_cpu_tagLength_set
+ * Description:
+ *      Set CPU tag length.
+ * Input:
+ *      length - CPU tag length.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can set CPU tag length.
+ */
+extern rtk_api_ret_t rtk_cpu_tagLength_set(rtk_cpu_tag_length_t length);
+
+/* Function Name:
+ *      rtk_cpu_tagLength_get
+ * Description:
+ *      Get CPU tag length.
+ * Input:
+ *      None
+ * Output:
+ *      pLength - CPU tag length.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can get CPU tag length.
+ */
+extern rtk_api_ret_t rtk_cpu_tagLength_get(rtk_cpu_tag_length_t *pLength);
+
+/* Function Name:
+ *      rtk_cpu_acceptLength_set
+ * Description:
+ *      Set CPU accept  length.
+ * Input:
+ *      length - CPU tag length.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can set CPU accept length.
+ */
+extern rtk_api_ret_t rtk_cpu_acceptLength_set(rtk_cpu_rx_length_t length);
+
+/* Function Name:
+ *      rtk_cpu_acceptLength_get
+ * Description:
+ *      Get CPU accept length.
+ * Input:
+ *      None
+ * Output:
+ *      pLength - CPU tag length.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT      - Invalid input.
+ * Note:
+ *      The API can get CPU accept length.
+ */
+extern rtk_api_ret_t rtk_cpu_acceptLength_get(rtk_cpu_rx_length_t *pLength);
+
+/* Function Name:
+ *      rtk_cpu_priRemap_set
+ * Description:
+ *      Configure CPU priorities mapping to internal absolute priority.
+ * Input:
+ *      int_pri     - internal priority value.
+ *      new_pri    - new internal priority value.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_VLAN_PRIORITY    - Invalid 1p priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      Priority of CPU tag assignment for internal asic priority, and it is used for queue usage and packet scheduling.
+ */
+extern rtk_api_ret_t rtk_cpu_priRemap_set(rtk_pri_t int_pri, rtk_pri_t new_pri);
+
+/* Function Name:
+ *      rtk_cpu_priRemap_get
+ * Description:
+ *      Configure CPU priorities mapping to internal absolute priority.
+ * Input:
+ *      int_pri     - internal priority value.
+ * Output:
+ *      pNew_pri    - new internal priority value.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_VLAN_PRIORITY    - Invalid 1p priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      Priority of CPU tag assignment for internal asic priority, and it is used for queue usage and packet scheduling.
+ */
+extern rtk_api_ret_t rtk_cpu_priRemap_get(rtk_pri_t int_pri, rtk_pri_t *pNew_pri);
+
+
+#endif /* __RTK_API_CPU_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/dot1x.h b/drivers/net/phy/rtk/rtl8367c/include/dot1x.h
new file mode 100644
index 0000000000000..e520852ac5c3c
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/dot1x.h
@@ -0,0 +1,470 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes 1X module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_DOT1X_H__
+#define __RTK_API_DOT1X_H__
+
+
+/* Type of port-based dot1x auth/unauth*/
+typedef enum rtk_dot1x_auth_status_e
+{
+    UNAUTH = 0,
+    AUTH,
+    AUTH_STATUS_END
+} rtk_dot1x_auth_status_t;
+
+typedef enum rtk_dot1x_direction_e
+{
+    DIR_BOTH = 0,
+    DIR_IN,
+    DIRECTION_END
+} rtk_dot1x_direction_t;
+
+/* unauth pkt action */
+typedef enum rtk_dot1x_unauth_action_e
+{
+    DOT1X_ACTION_DROP = 0,
+    DOT1X_ACTION_TRAP2CPU,
+    DOT1X_ACTION_GUESTVLAN,
+    DOT1X_ACTION_END
+} rtk_dot1x_unauth_action_t;
+
+/* Function Name:
+ *      rtk_dot1x_unauthPacketOper_set
+ * Description:
+ *      Set 802.1x unauth action configuration.
+ * Input:
+ *      port            - Port id.
+ *      unauth_action   - 802.1X unauth action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      This API can set 802.1x unauth action configuration.
+ *      The unauth action is as following:
+ *      - DOT1X_ACTION_DROP
+ *      - DOT1X_ACTION_TRAP2CPU
+ *      - DOT1X_ACTION_GUESTVLAN
+ */
+extern rtk_api_ret_t rtk_dot1x_unauthPacketOper_set(rtk_port_t port, rtk_dot1x_unauth_action_t unauth_action);
+
+/* Function Name:
+ *      rtk_dot1x_unauthPacketOper_get
+ * Description:
+ *      Get 802.1x unauth action configuration.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pUnauth_action - 802.1X unauth action.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can get 802.1x unauth action configuration.
+ *      The unauth action is as following:
+ *      - DOT1X_ACTION_DROP
+ *      - DOT1X_ACTION_TRAP2CPU
+ *      - DOT1X_ACTION_GUESTVLAN
+ */
+extern rtk_api_ret_t rtk_dot1x_unauthPacketOper_get(rtk_port_t port, rtk_dot1x_unauth_action_t *pUnauth_action);
+
+/* Function Name:
+ *      rtk_dot1x_eapolFrame2CpuEnable_set
+ * Description:
+ *      Set 802.1x EAPOL packet trap to CPU configuration
+ * Input:
+ *      enable - The status of 802.1x EAPOL packet.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      To support 802.1x authentication functionality, EAPOL frame (ether type = 0x888E) has to
+ *      be trapped to CPU.
+ *      The status of EAPOL frame trap to CPU is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+extern rtk_api_ret_t rtk_dot1x_eapolFrame2CpuEnable_set(rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_dot1x_eapolFrame2CpuEnable_get
+ * Description:
+ *      Get 802.1x EAPOL packet trap to CPU configuration
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - The status of 802.1x EAPOL packet.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      To support 802.1x authentication functionality, EAPOL frame (ether type = 0x888E) has to
+ *      be trapped to CPU.
+ *      The status of EAPOL frame trap to CPU is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+extern rtk_api_ret_t rtk_dot1x_eapolFrame2CpuEnable_get(rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_dot1x_portBasedEnable_set
+ * Description:
+ *      Set 802.1x port-based enable configuration
+ * Input:
+ *      port - Port id.
+ *      enable - The status of 802.1x port.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_ENABLE               - Invalid enable input.
+ *      RT_ERR_DOT1X_PORTBASEDPNEN  - 802.1X port-based enable error
+ * Note:
+ *      The API can update the port-based port enable register content. If a port is 802.1x
+ *      port based network access control "enabled", it should be authenticated so packets
+ *      from that port won't be dropped or trapped to CPU.
+ *      The status of 802.1x port-based network access control is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+extern rtk_api_ret_t rtk_dot1x_portBasedEnable_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_dot1x_portBasedEnable_get
+ * Description:
+ *      Get 802.1x port-based enable configuration
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - The status of 802.1x port.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get the 802.1x port-based port status.
+ */
+extern rtk_api_ret_t rtk_dot1x_portBasedEnable_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_dot1x_portBasedAuthStatus_set
+ * Description:
+ *      Set 802.1x port-based auth. port configuration
+ * Input:
+ *      port - Port id.
+ *      port_auth - The status of 802.1x port.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *     RT_ERR_DOT1X_PORTBASEDAUTH   - 802.1X port-based auth error
+ * Note:
+ *      The authenticated status of 802.1x port-based network access control is as following:
+ *      - UNAUTH
+ *      - AUTH
+ */
+extern rtk_api_ret_t rtk_dot1x_portBasedAuthStatus_set(rtk_port_t port, rtk_dot1x_auth_status_t port_auth);
+
+/* Function Name:
+ *      rtk_dot1x_portBasedAuthStatus_get
+ * Description:
+ *      Get 802.1x port-based auth. port configuration
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPort_auth - The status of 802.1x port.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get 802.1x port-based port auth.information.
+ */
+extern rtk_api_ret_t rtk_dot1x_portBasedAuthStatus_get(rtk_port_t port, rtk_dot1x_auth_status_t *pPort_auth);
+
+/* Function Name:
+ *      rtk_dot1x_portBasedDirection_set
+ * Description:
+ *      Set 802.1x port-based operational direction configuration
+ * Input:
+ *      port            - Port id.
+ *      port_direction  - Operation direction
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_DOT1X_PORTBASEDOPDIR - 802.1X port-based operation direction error
+ * Note:
+ *      The operate controlled direction of 802.1x port-based network access control is as following:
+ *      - BOTH
+ *      - IN
+ */
+extern rtk_api_ret_t rtk_dot1x_portBasedDirection_set(rtk_port_t port, rtk_dot1x_direction_t port_direction);
+
+/* Function Name:
+ *      rtk_dot1x_portBasedDirection_get
+ * Description:
+ *      Get 802.1X port-based operational direction configuration
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPort_direction - Operation direction
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get 802.1x port-based operational direction information.
+ */
+extern rtk_api_ret_t rtk_dot1x_portBasedDirection_get(rtk_port_t port, rtk_dot1x_direction_t *pPort_direction);
+
+/* Function Name:
+ *      rtk_dot1x_macBasedEnable_set
+ * Description:
+ *      Set 802.1x mac-based port enable configuration
+ * Input:
+ *      port - Port id.
+ *      enable - The status of 802.1x port.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_ENABLE               - Invalid enable input.
+ *      RT_ERR_DOT1X_MACBASEDPNEN   - 802.1X mac-based enable error
+ * Note:
+ *      If a port is 802.1x MAC based network access control "enabled", the incoming packets should
+ *       be authenticated so packets from that port won't be dropped or trapped to CPU.
+ *      The status of 802.1x MAC-based network access control is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+extern rtk_api_ret_t rtk_dot1x_macBasedEnable_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_dot1x_macBasedEnable_get
+ * Description:
+ *      Get 802.1x mac-based port enable configuration
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - The status of 802.1x port.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      If a port is 802.1x MAC based network access control "enabled", the incoming packets should
+ *      be authenticated so packets from that port wont be dropped or trapped to CPU.
+ *      The status of 802.1x MAC-based network access control is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+extern rtk_api_ret_t rtk_dot1x_macBasedEnable_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_dot1x_macBasedAuthMac_add
+ * Description:
+ *      Add an authenticated MAC to ASIC
+ * Input:
+ *      port        - Port id.
+ *      pAuth_mac   - The authenticated MAC.
+ *      fid         - filtering database.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_ENABLE               - Invalid enable input.
+ *      RT_ERR_DOT1X_MACBASEDPNEN   - 802.1X mac-based enable error
+ * Note:
+ *      The API can add a 802.1x authenticated MAC address to port. If the MAC does not exist in LUT,
+ *      user can't add this MAC to auth status.
+ */
+extern rtk_api_ret_t rtk_dot1x_macBasedAuthMac_add(rtk_port_t port, rtk_mac_t *pAuth_mac, rtk_fid_t fid);
+
+/* Function Name:
+ *      rtk_dot1x_macBasedAuthMac_del
+ * Description:
+ *      Delete an authenticated MAC to ASIC
+ * Input:
+ *      port - Port id.
+ *      pAuth_mac - The authenticated MAC.
+ *      fid - filtering database.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_MAC          - Invalid MAC address.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can delete a 802.1x authenticated MAC address to port. It only change the auth status of
+ *      the MAC and won't delete it from LUT.
+ */
+extern rtk_api_ret_t rtk_dot1x_macBasedAuthMac_del(rtk_port_t port, rtk_mac_t *pAuth_mac, rtk_fid_t fid);
+
+/* Function Name:
+ *      rtk_dot1x_macBasedDirection_set
+ * Description:
+ *      Set 802.1x mac-based operational direction configuration
+ * Input:
+ *      mac_direction - Operation direction
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_INPUT                - Invalid input parameter.
+ *      RT_ERR_DOT1X_MACBASEDOPDIR  - 802.1X mac-based operation direction error
+ * Note:
+ *      The operate controlled direction of 802.1x mac-based network access control is as following:
+ *      - BOTH
+ *      - IN
+ */
+extern rtk_api_ret_t rtk_dot1x_macBasedDirection_set(rtk_dot1x_direction_t mac_direction);
+
+/* Function Name:
+ *      rtk_dot1x_macBasedDirection_get
+ * Description:
+ *      Get 802.1x mac-based operational direction configuration
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pMac_direction - Operation direction
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get 802.1x mac-based operational direction information.
+ */
+extern rtk_api_ret_t rtk_dot1x_macBasedDirection_get(rtk_dot1x_direction_t *pMac_direction);
+
+/* Function Name:
+ *      Set 802.1x guest VLAN configuration
+ * Description:
+ *      Set 802.1x mac-based operational direction configuration
+ * Input:
+ *      vid - 802.1x guest VLAN ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      The operate controlled 802.1x guest VLAN
+ */
+extern rtk_api_ret_t rtk_dot1x_guestVlan_set(rtk_vlan_t vid);
+
+/* Function Name:
+ *      rtk_dot1x_guestVlan_get
+ * Description:
+ *      Get 802.1x guest VLAN configuration
+ * Input:
+ *      None
+ * Output:
+ *      pVid - 802.1x guest VLAN ID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get 802.1x guest VLAN information.
+ */
+extern rtk_api_ret_t rtk_dot1x_guestVlan_get(rtk_vlan_t *pVid);
+
+/* Function Name:
+ *      rtk_dot1x_guestVlan2Auth_set
+ * Description:
+ *      Set 802.1x guest VLAN to auth host configuration
+ * Input:
+ *      enable - The status of guest VLAN to auth host.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      The operational direction of 802.1x guest VLAN to auth host control is as following:
+ *      - ENABLED
+ *      - DISABLED
+ */
+extern rtk_api_ret_t rtk_dot1x_guestVlan2Auth_set(rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_dot1x_guestVlan2Auth_get
+ * Description:
+ *      Get 802.1x guest VLAN to auth host configuration
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - The status of guest VLAN to auth host.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get 802.1x guest VLAN to auth host information.
+ */
+extern rtk_api_ret_t rtk_dot1x_guestVlan2Auth_get(rtk_enable_t *pEnable);
+
+
+#endif /* __RTK_API_DOT1X_H__ */
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/eee.h b/drivers/net/phy/rtk/rtl8367c/include/eee.h
new file mode 100644
index 0000000000000..2cdb1704260b4
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/eee.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes EEE module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_EEE_H__
+#define __RTK_API_EEE_H__
+
+/* Function Name:
+ *      rtk_eee_init
+ * Description:
+ *      EEE function initialization.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API is used to initialize EEE status.
+ */
+extern rtk_api_ret_t rtk_eee_init(void);
+
+/* Function Name:
+ *      rtk_eee_portEnable_set
+ * Description:
+ *      Set enable status of EEE function.
+ * Input:
+ *      port - port id.
+ *      enable - enable EEE status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_ID - Invalid port number.
+ *      RT_ERR_ENABLE - Invalid enable input.
+ * Note:
+ *      This API can set EEE function to the specific port.
+ *      The configuration of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+extern rtk_api_ret_t rtk_eee_portEnable_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_eee_portEnable_get
+ * Description:
+ *      Get port admin configuration of the specific port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - Back pressure status.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_ID - Invalid port number.
+ * Note:
+ *      This API can set EEE function to the specific port.
+ *      The configuration of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+extern rtk_api_ret_t rtk_eee_portEnable_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+
+#endif /* __RTK_API_EEE_H__ */
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/i2c.h b/drivers/net/phy/rtk/rtl8367c/include/i2c.h
new file mode 100644
index 0000000000000..2c7f0756ae502
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/i2c.h
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes I2C module high-layer API defination
+ *
+ */
+
+
+#ifndef __RTK_API_I2C_H__
+#define __RTK_API_I2C_H__
+#include <rtk_types.h>
+
+#define I2C_GPIO_MAX_GROUP (3)
+
+typedef enum rtk_I2C_16bit_mode_e{
+    I2C_LSB_16BIT_MODE = 0,
+    I2C_70B_LSB_16BIT_MODE,
+    I2C_Mode_END
+}rtk_I2C_16bit_mode_t;
+
+
+typedef enum rtk_I2C_gpio_pin_e{
+    I2C_GPIO_PIN_8_9 = 0,
+    I2C_GPIO_PIN_15_16 ,
+    I2C_GPIO_PIN_35_36 ,
+    I2C_GPIO_PIN_END
+}rtk_I2C_gpio_pin_t;
+
+
+/* Function Name:
+ *      rtk_i2c_data_read
+ * Description:
+ *      read i2c slave device register.
+ * Input:
+ *      deviceAddr   -   access Slave device address
+ *      slaveRegAddr -   access Slave register address
+ * Output:
+ *      pRegData     -   read data
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_NULL_POINTER     - input parameter is null pointer
+ * Note:
+ *      The API can access i2c slave and read i2c slave device register.
+ */
+extern rtk_api_ret_t rtk_i2c_data_read(rtk_uint8 deviceAddr, rtk_uint32 slaveRegAddr, rtk_uint32 *pRegData);
+
+/* Function Name:
+ *      rtk_i2c_data_write
+ * Description:
+ *      write data to i2c slave device register
+ * Input:
+ *      deviceAddr   -   access Slave device address
+ *      slaveRegAddr -   access Slave register address
+ *      regData      -   data to set
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ * Note:
+ *      The API can access i2c slave and setting i2c slave device register.
+ */
+extern rtk_api_ret_t rtk_i2c_data_write(rtk_uint8 deviceAddr, rtk_uint32 slaveRegAddr, rtk_uint32 regData);
+
+
+/* Function Name:
+ *      rtk_i2c_init
+ * Description:
+ *      I2C smart function initialization.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ * Note:
+ *      This API is used to initialize EEE status.
+ *      need used GPIO pins
+ *      OpenDrain and clock
+ */
+extern rtk_api_ret_t rtk_i2c_init(void);
+
+/* Function Name:
+ *      rtk_i2c_mode_set
+ * Description:
+ *      Set I2C data byte-order.
+ * Input:
+ *      i2cmode - byte-order mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      This API can set I2c traffic's byte-order .
+ */
+extern rtk_api_ret_t rtk_i2c_mode_set( rtk_I2C_16bit_mode_t i2cmode);
+
+/* Function Name:
+ *      rtk_i2c_mode_get
+ * Description:
+ *      Get i2c traffic byte-order setting.
+ * Input:
+ *      None
+ * Output:
+ *      pI2cMode - i2c byte-order
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_NULL_POINTER     - input parameter is null pointer
+ * Note:
+ *      The API can get i2c traffic byte-order setting.
+ */
+extern rtk_api_ret_t rtk_i2c_mode_get( rtk_I2C_16bit_mode_t * pI2cMode);
+
+
+/* Function Name:
+ *      rtk_i2c_gpioPinGroup_set
+ * Description:
+ *      Set i2c SDA & SCL used GPIO pins group.
+ * Input:
+ *      pins_group - GPIO pins group
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      The API can set i2c used gpio pins group.
+ *      There are three group pins could be used
+ */
+extern rtk_api_ret_t rtk_i2c_gpioPinGroup_set( rtk_I2C_gpio_pin_t pins_group);
+
+/* Function Name:
+ *      rtk_i2c_gpioPinGroup_get
+ * Description:
+ *      Get i2c SDA & SCL used GPIO pins group.
+ * Input:
+ *      None
+ * Output:
+ *      pPins_group - GPIO pins group
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_NULL_POINTER     - input parameter is null pointer
+ * Note:
+ *      The API can get i2c used gpio pins group.
+ *      There are three group pins could be used
+ */
+extern rtk_api_ret_t rtk_i2c_gpioPinGroup_get(rtk_I2C_gpio_pin_t * pPins_group);
+
+
+
+
+
+
+
+#endif
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/igmp.h b/drivers/net/phy/rtk/rtl8367c/include/igmp.h
new file mode 100644
index 0000000000000..86b4d93df63f7
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/igmp.h
@@ -0,0 +1,769 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes IGMP module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_IGMP_H__
+#define __RTK_API_IGMP_H__
+
+/*
+ * Data Type Declaration
+ */
+typedef enum rtk_igmp_type_e
+{
+    IGMP_IPV4 = 0,
+    IGMP_PPPOE_IPV4,
+    IGMP_MLD,
+    IGMP_PPPOE_MLD,
+    IGMP_TYPE_END
+} rtk_igmp_type_t;
+
+typedef enum rtk_trap_igmp_action_e
+{
+    IGMP_ACTION_FORWARD = 0,
+    IGMP_ACTION_TRAP2CPU,
+    IGMP_ACTION_DROP,
+    IGMP_ACTION_ASIC,
+    IGMP_ACTION_END
+} rtk_igmp_action_t;
+
+typedef enum rtk_igmp_protocol_e
+{
+    PROTOCOL_IGMPv1 = 0,
+    PROTOCOL_IGMPv2,
+    PROTOCOL_IGMPv3,
+    PROTOCOL_MLDv1,
+    PROTOCOL_MLDv2,
+    PROTOCOL_END
+} rtk_igmp_protocol_t;
+
+typedef enum rtk_igmp_tableFullAction_e
+{
+    IGMP_TABLE_FULL_FORWARD = 0,
+    IGMP_TABLE_FULL_DROP,
+    IGMP_TABLE_FULL_TRAP,
+    IGMP_TABLE_FULL_OP_END
+}rtk_igmp_tableFullAction_t;
+
+typedef enum rtk_igmp_checksumErrorAction_e
+{
+    IGMP_CRC_ERR_DROP = 0,
+    IGMP_CRC_ERR_TRAP,
+    IGMP_CRC_ERR_FORWARD,
+    IGMP_CRC_ERR_OP_END
+}rtk_igmp_checksumErrorAction_t;
+
+typedef enum rtk_igmp_bypassGroup_e
+{
+    IGMP_BYPASS_224_0_0_X = 0,
+    IGMP_BYPASS_224_0_1_X,
+    IGMP_BYPASS_239_255_255_X,
+    IGMP_BYPASS_IPV6_00XX,
+    IGMP_BYPASS_GROUP_END
+}rtk_igmp_bypassGroup_t;
+
+
+typedef struct rtk_igmp_dynamicRouterPort_s
+{
+    rtk_enable_t    dynamicRouterPort0Valid;
+    rtk_port_t      dynamicRouterPort0;
+    rtk_uint32      dynamicRouterPort0Timer;
+    rtk_enable_t    dynamicRouterPort1Valid;
+    rtk_port_t      dynamicRouterPort1;
+    rtk_uint32      dynamicRouterPort1Timer;
+
+}rtk_igmp_dynamicRouterPort_t;
+
+typedef struct rtk_igmp_rxPktEnable_s
+{
+    rtk_enable_t rxQuery;
+    rtk_enable_t rxReport;
+    rtk_enable_t rxLeave;
+    rtk_enable_t rxMRP;
+    rtk_enable_t rxMcast;
+}rtk_igmp_rxPktEnable_t;
+
+typedef struct rtk_igmp_groupInfo_s
+{
+    rtk_enable_t    valid;
+    rtk_portmask_t  member;
+    rtk_uint32      timer[RTK_PORT_MAX];
+    rtk_uint32      reportSuppFlag;
+}rtk_igmp_groupInfo_t;
+
+typedef enum rtk_igmp_ReportLeaveFwdAct_e
+{
+    IGMP_REPORT_LEAVE_TO_ROUTER = 0,
+    IGMP_REPORT_LEAVE_TO_ALLPORT,
+    IGMP_REPORT_LEAVE_TO_ROUTER_PORT_ADV,
+    IGMP_REPORT_LEAVE_ACT_END
+}rtk_igmp_ReportLeaveFwdAct_t;
+
+/* Function Name:
+ *      rtk_igmp_init
+ * Description:
+ *      This API enables H/W IGMP and set a default initial configuration.
+ * Input:
+ *      None.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API enables H/W IGMP and set a default initial configuration.
+ */
+extern rtk_api_ret_t rtk_igmp_init(void);
+
+/* Function Name:
+ *      rtk_igmp_state_set
+ * Description:
+ *      This API set H/W IGMP state.
+ * Input:
+ *      enabled     - H/W IGMP state
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set H/W IGMP state.
+ */
+extern rtk_api_ret_t rtk_igmp_state_set(rtk_enable_t enabled);
+
+/* Function Name:
+ *      rtk_igmp_state_get
+ * Description:
+ *      This API get H/W IGMP state.
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled        - H/W IGMP state
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set current H/W IGMP state.
+ */
+extern rtk_api_ret_t rtk_igmp_state_get(rtk_enable_t *pEnabled);
+
+/* Function Name:
+ *      rtk_igmp_static_router_port_set
+ * Description:
+ *      Configure static router port
+ * Input:
+ *      pPortmask    - Static Port mask
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *      This API set static router port
+ */
+extern rtk_api_ret_t rtk_igmp_static_router_port_set(rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_igmp_static_router_port_get
+ * Description:
+ *      Get static router port
+ * Input:
+ *      None.
+ * Output:
+ *      pPortmask       - Static port mask
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *      This API get static router port
+ */
+extern rtk_api_ret_t rtk_igmp_static_router_port_get(rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_igmp_protocol_set
+ * Description:
+ *      set IGMP/MLD protocol action
+ * Input:
+ *      port        - Port ID
+ *      protocol    - IGMP/MLD protocol
+ *      action      - Per-port and per-protocol IGMP action seeting
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *      This API set IGMP/MLD protocol action
+ */
+extern rtk_api_ret_t rtk_igmp_protocol_set(rtk_port_t port, rtk_igmp_protocol_t protocol, rtk_igmp_action_t action);
+
+/* Function Name:
+ *      rtk_igmp_protocol_get
+ * Description:
+ *      set IGMP/MLD protocol action
+ * Input:
+ *      port        - Port ID
+ *      protocol    - IGMP/MLD protocol
+ *      action      - Per-port and per-protocol IGMP action seeting
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *      This API set IGMP/MLD protocol action
+ */
+extern rtk_api_ret_t rtk_igmp_protocol_get(rtk_port_t port, rtk_igmp_protocol_t protocol, rtk_igmp_action_t *pAction);
+
+/* Function Name:
+ *      rtk_igmp_fastLeave_set
+ * Description:
+ *      set IGMP/MLD FastLeave state
+ * Input:
+ *      state       - ENABLED: Enable FastLeave, DISABLED: disable FastLeave
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API set IGMP/MLD FastLeave state
+ */
+extern rtk_api_ret_t rtk_igmp_fastLeave_set(rtk_enable_t state);
+
+/* Function Name:
+ *      rtk_igmp_fastLeave_get
+ * Description:
+ *      get IGMP/MLD FastLeave state
+ * Input:
+ *      None
+ * Output:
+ *      pState      - ENABLED: Enable FastLeave, DISABLED: disable FastLeave
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - NULL pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API get IGMP/MLD FastLeave state
+ */
+extern rtk_api_ret_t rtk_igmp_fastLeave_get(rtk_enable_t *pState);
+
+/* Function Name:
+ *      rtk_igmp_maxGroup_set
+ * Description:
+ *      Set per port multicast group learning limit.
+ * Input:
+ *      port        - Port ID
+ *      group       - The number of multicast group learning limit.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_PORT_ID         - Error Port ID
+ *      RT_ERR_OUT_OF_RANGE    - parameter out of range
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API set per port multicast group learning limit.
+ */
+extern rtk_api_ret_t rtk_igmp_maxGroup_set(rtk_port_t port, rtk_uint32 group);
+
+/* Function Name:
+ *      rtk_igmp_maxGroup_get
+ * Description:
+ *      Get per port multicast group learning limit.
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      pGroup      - The number of multicast group learning limit.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_PORT_ID         - Error Port ID
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API get per port multicast group learning limit.
+ */
+extern rtk_api_ret_t rtk_igmp_maxGroup_get(rtk_port_t port, rtk_uint32 *pGroup);
+
+/* Function Name:
+ *      rtk_igmp_currentGroup_get
+ * Description:
+ *      Get per port multicast group learning count.
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      pGroup      - The number of multicast group learning count.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_PORT_ID         - Error Port ID
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API get per port multicast group learning count.
+ */
+extern rtk_api_ret_t rtk_igmp_currentGroup_get(rtk_port_t port, rtk_uint32 *pGroup);
+
+/* Function Name:
+ *      rtk_igmp_tableFullAction_set
+ * Description:
+ *      set IGMP/MLD Table Full Action
+ * Input:
+ *      action      - Table Full Action
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+extern rtk_api_ret_t rtk_igmp_tableFullAction_set(rtk_igmp_tableFullAction_t action);
+
+/* Function Name:
+ *      rtk_igmp_tableFullAction_get
+ * Description:
+ *      get IGMP/MLD Table Full Action
+ * Input:
+ *      None
+ * Output:
+ *      pAction     - Table Full Action
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+extern rtk_api_ret_t rtk_igmp_tableFullAction_get(rtk_igmp_tableFullAction_t *pAction);
+
+/* Function Name:
+ *      rtk_igmp_checksumErrorAction_set
+ * Description:
+ *      set IGMP/MLD Checksum Error Action
+ * Input:
+ *      action      - Checksum error Action
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+extern rtk_api_ret_t rtk_igmp_checksumErrorAction_set(rtk_igmp_checksumErrorAction_t action);
+
+/* Function Name:
+ *      rtk_igmp_checksumErrorAction_get
+ * Description:
+ *      get IGMP/MLD Checksum Error Action
+ * Input:
+ *      None
+ * Output:
+ *      pAction     - Checksum error Action
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+extern rtk_api_ret_t rtk_igmp_checksumErrorAction_get(rtk_igmp_checksumErrorAction_t *pAction);
+
+/* Function Name:
+ *      rtk_igmp_leaveTimer_set
+ * Description:
+ *      set IGMP/MLD Leave timer
+ * Input:
+ *      timer       - Leave timer
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+extern rtk_api_ret_t rtk_igmp_leaveTimer_set(rtk_uint32 timer);
+
+/* Function Name:
+ *      rtk_igmp_leaveTimer_get
+ * Description:
+ *      get IGMP/MLD Leave timer
+ * Input:
+ *      None
+ * Output:
+ *      pTimer      - Leave Timer.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+extern rtk_api_ret_t rtk_igmp_leaveTimer_get(rtk_uint32 *pTimer);
+
+/* Function Name:
+ *      rtk_igmp_queryInterval_set
+ * Description:
+ *      set IGMP/MLD Query Interval
+ * Input:
+ *      interval     - Query Interval
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+extern rtk_api_ret_t rtk_igmp_queryInterval_set(rtk_uint32 interval);
+
+/* Function Name:
+ *      rtk_igmp_queryInterval_get
+ * Description:
+ *      get IGMP/MLD Query Interval
+ * Input:
+ *      None.
+ * Output:
+ *      pInterval   - Query Interval
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+extern rtk_api_ret_t rtk_igmp_queryInterval_get(rtk_uint32 *pInterval);
+
+/* Function Name:
+ *      rtk_igmp_robustness_set
+ * Description:
+ *      set IGMP/MLD Robustness value
+ * Input:
+ *      robustness     - Robustness value
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+extern rtk_api_ret_t rtk_igmp_robustness_set(rtk_uint32 robustness);
+
+/* Function Name:
+ *      rtk_igmp_robustness_get
+ * Description:
+ *      get IGMP/MLD Robustness value
+ * Input:
+ *      None
+ * Output:
+ *      pRobustness     - Robustness value.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ */
+extern rtk_api_ret_t rtk_igmp_robustness_get(rtk_uint32 *pRobustness);
+
+/* Function Name:
+ *      rtk_igmp_dynamicRouterRortAllow_set
+ * Description:
+ *      Configure dynamic router port allow option
+ * Input:
+ *      pPortmask    - Dynamic Port allow mask
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_dynamicRouterPortAllow_set(rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_igmp_dynamicRouterRortAllow_get
+ * Description:
+ *      Get dynamic router port allow option
+ * Input:
+ *      None.
+ * Output:
+ *      pPortmask    - Dynamic Port allow mask
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_dynamicRouterPortAllow_get(rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_igmp_dynamicRouterPort_get
+ * Description:
+ *      Get dynamic router port
+ * Input:
+ *      None.
+ * Output:
+ *      pDynamicRouterPort    - Dynamic Router Port
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_PORT_MASK       - Error parameter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_dynamicRouterPort_get(rtk_igmp_dynamicRouterPort_t *pDynamicRouterPort);
+
+/* Function Name:
+ *      rtk_igmp_suppressionEnable_set
+ * Description:
+ *      Configure IGMPv1/v2 & MLDv1 Report/Leave/Done suppression
+ * Input:
+ *      reportSuppression   - Report suppression
+ *      leaveSuppression    - Leave suppression
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_suppressionEnable_set(rtk_enable_t reportSuppression, rtk_enable_t leaveSuppression);
+
+/* Function Name:
+ *      rtk_igmp_suppressionEnable_get
+ * Description:
+ *      Get IGMPv1/v2 & MLDv1 Report/Leave/Done suppression
+ * Input:
+ *      None
+ * Output:
+ *      pReportSuppression  - Report suppression
+ *      pLeaveSuppression   - Leave suppression
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_suppressionEnable_get(rtk_enable_t *pReportSuppression, rtk_enable_t *pLeaveSuppression);
+
+/* Function Name:
+ *      rtk_igmp_portRxPktEnable_set
+ * Description:
+ *      Configure IGMP/MLD RX Packet configuration
+ * Input:
+ *      port       - Port ID
+ *      pRxCfg     - RX Packet Configuration
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_portRxPktEnable_set(rtk_port_t port, rtk_igmp_rxPktEnable_t *pRxCfg);
+
+/* Function Name:
+ *      rtk_igmp_portRxPktEnable_get
+ * Description:
+ *      Get IGMP/MLD RX Packet configuration
+ * Input:
+ *      port       - Port ID
+ *      pRxCfg     - RX Packet Configuration
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_portRxPktEnable_get(rtk_port_t port, rtk_igmp_rxPktEnable_t *pRxCfg);
+
+/* Function Name:
+ *      rtk_igmp_groupInfo_get
+ * Description:
+ *      Get IGMP/MLD Group database
+ * Input:
+ *      indes       - Index (0~255)
+ * Output:
+ *      pGroup      - Group database information.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_groupInfo_get(rtk_uint32 index, rtk_igmp_groupInfo_t *pGroup);
+
+/* Function Name:
+ *      rtk_igmp_ReportLeaveFwdAction_set
+ * Description:
+ *      Set Report Leave packet forwarding action
+ * Input:
+ *      action      - Action
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_ReportLeaveFwdAction_set(rtk_igmp_ReportLeaveFwdAct_t action);
+
+/* Function Name:
+ *      rtk_igmp_ReportLeaveFwdAction_get
+ * Description:
+ *      Get Report Leave packet forwarding action
+ * Input:
+ *      action      - Action
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null Pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_ReportLeaveFwdAction_get(rtk_igmp_ReportLeaveFwdAct_t *pAction);
+
+/* Function Name:
+ *      rtk_igmp_dropLeaveZeroEnable_set
+ * Description:
+ *      Set the function of droppping Leave packet with group IP = 0.0.0.0
+ * Input:
+ *      enabled      - Action 1: drop, 0:pass
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_dropLeaveZeroEnable_set(rtk_enable_t enabled);
+
+/* Function Name:
+ *      rtk_igmp_dropLeaveZeroEnable_get
+ * Description:
+ *      Get the function of droppping Leave packet with group IP = 0.0.0.0
+ * Input:
+ *      None
+ * Output:
+ *      pEnabled.   - Action 1: drop, 0:pass
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null Pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_dropLeaveZeroEnable_get(rtk_enable_t *pEnabled);
+
+/* Function Name:
+ *      rtk_igmp_bypassGroupRange_set
+ * Description:
+ *      Set Bypass group
+ * Input:
+ *      group       - bypassed group
+ *      enabled     - enabled 1: Bypassed, 0: not bypass
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_bypassGroupRange_set(rtk_igmp_bypassGroup_t group, rtk_enable_t enabled);
+
+/* Function Name:
+ *      rtk_igmp_bypassGroupRange_get
+ * Description:
+ *      get Bypass group
+ * Input:
+ *      group       - bypassed group
+ * Output:
+ *      pEnable     - enabled 1: Bypassed, 0: not bypass
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error Input
+ *      RT_ERR_NULL_POINTER    - Null Pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_igmp_bypassGroupRange_get(rtk_igmp_bypassGroup_t group, rtk_enable_t *pEnable);
+
+#endif /* __RTK_API_IGMP_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/interrupt.h b/drivers/net/phy/rtk/rtl8367c/include/interrupt.h
new file mode 100644
index 0000000000000..071e2f098ea40
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/interrupt.h
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes Interrupt module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_INTERRUPT_H__
+#define __RTK_API_INTERRUPT_H__
+
+
+/*
+ * Data Type Declaration
+ */
+#define RTK_MAX_NUM_OF_INTERRUPT_TYPE               1
+
+
+typedef struct  rtk_int_status_s
+{
+    rtk_uint16 value[RTK_MAX_NUM_OF_INTERRUPT_TYPE];
+} rtk_int_status_t;
+
+typedef struct rtk_int_info_s
+{
+    rtk_portmask_t  portMask;
+    rtk_uint32      meterMask;
+    rtk_uint32      systemLearnOver;
+}rtk_int_info_t;
+
+typedef enum rtk_int_type_e
+{
+    INT_TYPE_LINK_STATUS = 0,
+    INT_TYPE_METER_EXCEED,
+    INT_TYPE_LEARN_LIMIT,
+    INT_TYPE_LINK_SPEED,
+    INT_TYPE_CONGEST,
+    INT_TYPE_GREEN_FEATURE,
+    INT_TYPE_LOOP_DETECT,
+    INT_TYPE_8051,
+    INT_TYPE_CABLE_DIAG,
+    INT_TYPE_ACL,
+    INT_TYPE_RESERVED, /* Unused */
+    INT_TYPE_SLIENT,
+    INT_TYPE_END
+}rtk_int_type_t;
+
+typedef enum rtk_int_advType_e
+{
+    ADV_L2_LEARN_PORT_MASK = 0,
+    ADV_SPEED_CHANGE_PORT_MASK,
+    ADV_SPECIAL_CONGESTION_PORT_MASK,
+    ADV_PORT_LINKDOWN_PORT_MASK,
+    ADV_PORT_LINKUP_PORT_MASK,
+    ADV_METER_EXCEED_MASK,
+    ADV_RLDP_LOOPED,
+    ADV_RLDP_RELEASED,
+    ADV_END,
+} rtk_int_advType_t;
+
+typedef enum rtk_int_polarity_e
+{
+    INT_POLAR_HIGH = 0,
+    INT_POLAR_LOW,
+    INT_POLAR_END
+} rtk_int_polarity_t;
+
+/* Function Name:
+ *      rtk_int_polarity_set
+ * Description:
+ *      Set interrupt polarity configuration.
+ * Input:
+ *      type - Interruptpolarity type.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can set interrupt polarity configuration.
+ */
+extern rtk_api_ret_t rtk_int_polarity_set(rtk_int_polarity_t type);
+
+/* Function Name:
+ *      rtk_int_polarity_get
+ * Description:
+ *      Get interrupt polarity configuration.
+ * Input:
+ *      None
+ * Output:
+ *      pType - Interruptpolarity type.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      The API can get interrupt polarity configuration.
+ */
+extern rtk_api_ret_t rtk_int_polarity_get(rtk_int_polarity_t *pType);
+
+/* Function Name:
+ *      rtk_int_control_set
+ * Description:
+ *      Set interrupt trigger status configuration.
+ * Input:
+ *      type - Interrupt type.
+ *      enable - Interrupt status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      The API can set interrupt status configuration.
+ *      The interrupt trigger status is shown in the following:
+ *      - INT_TYPE_LINK_STATUS
+ *      - INT_TYPE_METER_EXCEED
+ *      - INT_TYPE_LEARN_LIMIT
+ *      - INT_TYPE_LINK_SPEED
+ *      - INT_TYPE_CONGEST
+ *      - INT_TYPE_GREEN_FEATURE
+ *      - INT_TYPE_LOOP_DETECT
+ *      - INT_TYPE_8051,
+ *      - INT_TYPE_CABLE_DIAG,
+ *      - INT_TYPE_ACL,
+ *      - INT_TYPE_SLIENT
+ */
+extern rtk_api_ret_t rtk_int_control_set(rtk_int_type_t type, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_int_control_get
+ * Description:
+ *      Get interrupt trigger status configuration.
+ * Input:
+ *      type - Interrupt type.
+ * Output:
+ *      pEnable - Interrupt status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get interrupt status configuration.
+ *      The interrupt trigger status is shown in the following:
+ *      - INT_TYPE_LINK_STATUS
+ *      - INT_TYPE_METER_EXCEED
+ *      - INT_TYPE_LEARN_LIMIT
+ *      - INT_TYPE_LINK_SPEED
+ *      - INT_TYPE_CONGEST
+ *      - INT_TYPE_GREEN_FEATURE
+ *      - INT_TYPE_LOOP_DETECT
+ *      - INT_TYPE_8051,
+ *      - INT_TYPE_CABLE_DIAG,
+ *      - INT_TYPE_ACL,
+ *      - INT_TYPE_SLIENT
+ */
+extern rtk_api_ret_t rtk_int_control_get(rtk_int_type_t type, rtk_enable_t* pEnable);
+
+/* Function Name:
+ *      rtk_int_status_set
+ * Description:
+ *      Set interrupt trigger status to clean.
+ * Input:
+ *      None
+ * Output:
+ *      pStatusMask - Interrupt status bit mask.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT - Invalid input parameters.
+ * Note:
+ *      The API can clean interrupt trigger status when interrupt happened.
+ *      The interrupt trigger status is shown in the following:
+ *      - INT_TYPE_LINK_STATUS    (value[0] (Bit0))
+ *      - INT_TYPE_METER_EXCEED   (value[0] (Bit1))
+ *      - INT_TYPE_LEARN_LIMIT    (value[0] (Bit2))
+ *      - INT_TYPE_LINK_SPEED     (value[0] (Bit3))
+ *      - INT_TYPE_CONGEST        (value[0] (Bit4))
+ *      - INT_TYPE_GREEN_FEATURE  (value[0] (Bit5))
+ *      - INT_TYPE_LOOP_DETECT    (value[0] (Bit6))
+ *      - INT_TYPE_8051           (value[0] (Bit7))
+ *      - INT_TYPE_CABLE_DIAG     (value[0] (Bit8))
+ *      - INT_TYPE_ACL            (value[0] (Bit9))
+ *      - INT_TYPE_SLIENT         (value[0] (Bit11))
+ *      The status will be cleared after execute this API.
+ */
+extern rtk_api_ret_t rtk_int_status_set(rtk_int_status_t *pStatusMask);
+
+/* Function Name:
+ *      rtk_int_status_get
+ * Description:
+ *      Get interrupt trigger status.
+ * Input:
+ *      None
+ * Output:
+ *      pStatusMask - Interrupt status bit mask.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get interrupt trigger status when interrupt happened.
+ *      The interrupt trigger status is shown in the following:
+ *      - INT_TYPE_LINK_STATUS    (value[0] (Bit0))
+ *      - INT_TYPE_METER_EXCEED   (value[0] (Bit1))
+ *      - INT_TYPE_LEARN_LIMIT    (value[0] (Bit2))
+ *      - INT_TYPE_LINK_SPEED     (value[0] (Bit3))
+ *      - INT_TYPE_CONGEST        (value[0] (Bit4))
+ *      - INT_TYPE_GREEN_FEATURE  (value[0] (Bit5))
+ *      - INT_TYPE_LOOP_DETECT    (value[0] (Bit6))
+ *      - INT_TYPE_8051           (value[0] (Bit7))
+ *      - INT_TYPE_CABLE_DIAG     (value[0] (Bit8))
+ *      - INT_TYPE_ACL            (value[0] (Bit9))
+ *      - INT_TYPE_SLIENT         (value[0] (Bit11))
+ *
+ */
+extern rtk_api_ret_t rtk_int_status_get(rtk_int_status_t* pStatusMask);
+
+/* Function Name:
+ *      rtk_int_advanceInfo_get
+ * Description:
+ *      Get interrupt advanced information.
+ * Input:
+ *      adv_type - Advanced interrupt type.
+ * Output:
+ *      info - Information per type.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get advanced information when interrupt happened.
+ *      The status will be cleared after execute this API.
+ */
+extern rtk_api_ret_t rtk_int_advanceInfo_get(rtk_int_advType_t adv_type, rtk_int_info_t* info);
+
+
+#endif /* __RTK_API_INTERRUPT_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/l2.h b/drivers/net/phy/rtk/rtl8367c/include/l2.h
new file mode 100644
index 0000000000000..d6ff827d61835
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/l2.h
@@ -0,0 +1,1181 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes L2 module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_L2_H__
+#define __RTK_API_L2_H__
+
+
+/*
+ * Data Type Declaration
+ */
+#define RTK_MAX_NUM_OF_LEARN_LIMIT                  (rtk_switch_maxLutAddrNumber_get())
+
+#define RTK_MAC_ADDR_LEN                            6
+#define RTK_MAX_LUT_ADDRESS                         (RTK_MAX_NUM_OF_LEARN_LIMIT)
+#define RTK_MAX_LUT_ADDR_ID                         (RTK_MAX_LUT_ADDRESS - 1)
+
+typedef rtk_uint32 rtk_l2_age_time_t;
+
+typedef enum rtk_l2_flood_type_e
+{
+    FLOOD_UNKNOWNDA = 0,
+    FLOOD_UNKNOWNMC,
+    FLOOD_BC,
+    FLOOD_END
+} rtk_l2_flood_type_t;
+
+typedef rtk_uint32 rtk_l2_flushItem_t;
+
+typedef enum rtk_l2_flushType_e
+{
+    FLUSH_TYPE_BY_PORT = 0,       /* physical port       */
+    FLUSH_TYPE_BY_PORT_VID,       /* physical port + VID */
+    FLUSH_TYPE_BY_PORT_FID,       /* physical port + FID */
+    FLUSH_TYPE_END
+} rtk_l2_flushType_t;
+
+typedef struct rtk_l2_flushCfg_s
+{
+    rtk_enable_t    flushByVid;
+    rtk_vlan_t      vid;
+    rtk_enable_t    flushByFid;
+    rtk_uint32      fid;
+    rtk_enable_t    flushByPort;
+    rtk_port_t      port;
+    rtk_enable_t    flushByMac;
+    rtk_mac_t       ucastAddr;
+    rtk_enable_t    flushStaticAddr;
+    rtk_enable_t    flushAddrOnAllPorts; /* this is used when flushByVid */
+} rtk_l2_flushCfg_t;
+
+typedef enum rtk_l2_read_method_e{
+
+    READMETHOD_MAC = 0,
+    READMETHOD_ADDRESS,
+    READMETHOD_NEXT_ADDRESS,
+    READMETHOD_NEXT_L2UC,
+    READMETHOD_NEXT_L2MC,
+    READMETHOD_NEXT_L3MC,
+    READMETHOD_NEXT_L2L3MC,
+    READMETHOD_NEXT_L2UCSPA,
+    READMETHOD_END
+}rtk_l2_read_method_t;
+
+/* l2 limit learning count action */
+typedef enum rtk_l2_limitLearnCntAction_e
+{
+    LIMIT_LEARN_CNT_ACTION_DROP = 0,
+    LIMIT_LEARN_CNT_ACTION_FORWARD,
+    LIMIT_LEARN_CNT_ACTION_TO_CPU,
+    LIMIT_LEARN_CNT_ACTION_END
+} rtk_l2_limitLearnCntAction_t;
+
+typedef enum rtk_l2_ipmc_lookup_type_e
+{
+    LOOKUP_MAC = 0,
+    LOOKUP_IP,
+    LOOKUP_IP_VID,
+    LOOKUP_END
+} rtk_l2_ipmc_lookup_type_t;
+
+/* l2 address table - unicast data structure */
+typedef struct rtk_l2_ucastAddr_s
+{
+    rtk_mac_t       mac;
+    rtk_uint32      ivl;
+    rtk_uint32      cvid;
+    rtk_uint32      fid;
+    rtk_uint32      efid;
+    rtk_uint32      port;
+    rtk_uint32      sa_block;
+    rtk_uint32      da_block;
+    rtk_uint32      auth;
+    rtk_uint32      is_static;
+    rtk_uint32      priority;
+    rtk_uint32      sa_pri_en;
+    rtk_uint32      fwd_pri_en;
+    rtk_uint32      address;
+}rtk_l2_ucastAddr_t;
+
+/* l2 address table - multicast data structure */
+typedef struct rtk_l2_mcastAddr_s
+{
+    rtk_uint32      vid;
+    rtk_mac_t       mac;
+    rtk_uint32      fid;
+    rtk_portmask_t  portmask;
+    rtk_uint32      ivl;
+    rtk_uint32      priority;
+    rtk_uint32      fwd_pri_en;
+    rtk_uint32      igmp_asic;
+    rtk_uint32      igmp_index;
+    rtk_uint32      address;
+}rtk_l2_mcastAddr_t;
+
+/* l2 address table - ip multicast data structure */
+typedef struct rtk_l2_ipMcastAddr_s
+{
+    ipaddr_t        dip;
+    ipaddr_t        sip;
+    rtk_portmask_t  portmask;
+    rtk_uint32      priority;
+    rtk_uint32      fwd_pri_en;
+    rtk_uint32      igmp_asic;
+    rtk_uint32      igmp_index;
+    rtk_uint32      address;
+}rtk_l2_ipMcastAddr_t;
+
+/* l2 address table - ip VID multicast data structure */
+typedef struct rtk_l2_ipVidMcastAddr_s
+{
+    ipaddr_t        dip;
+    ipaddr_t        sip;
+    rtk_uint32      vid;
+    rtk_portmask_t  portmask;
+    rtk_uint32      address;
+}rtk_l2_ipVidMcastAddr_t;
+
+typedef struct rtk_l2_addr_table_s
+{
+    rtk_uint32  index;
+    ipaddr_t    sip;
+    ipaddr_t    dip;
+    rtk_mac_t   mac;
+    rtk_uint32  sa_block;
+    rtk_uint32  auth;
+    rtk_portmask_t  portmask;
+    rtk_uint32  age;
+    rtk_uint32  ivl;
+    rtk_uint32  cvid;
+    rtk_uint32  fid;
+    rtk_uint32  is_ipmul;
+    rtk_uint32  is_static;
+    rtk_uint32  is_ipvidmul;
+    rtk_uint32  l3_vid;
+}rtk_l2_addr_table_t;
+
+typedef enum rtk_l2_clearStatus_e
+{
+    L2_CLEAR_STATE_FINISH = 0,
+    L2_CLEAR_STATE_BUSY,
+    L2_CLEAR_STATE_END
+}rtk_l2_clearStatus_t;
+
+/* Function Name:
+ *      rtk_l2_init
+ * Description:
+ *      Initialize l2 module of the specified device.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ * Note:
+ *      Initialize l2 module before calling any l2 APIs.
+ */
+extern rtk_api_ret_t rtk_l2_init(void);
+
+/* Function Name:
+ *      rtk_l2_addr_add
+ * Description:
+ *      Add LUT unicast entry.
+ * Input:
+ *      pMac - 6 bytes unicast(I/G bit is 0) mac address to be written into LUT.
+ *      pL2_data - Unicast entry parameter
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_MAC              - Invalid MAC address.
+ *      RT_ERR_L2_FID           - Invalid FID .
+ *      RT_ERR_L2_INDEXTBL_FULL - hashed index is full of entries.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      If the unicast mac address already existed in LUT, it will udpate the status of the entry.
+ *      Otherwise, it will find an empty or asic auto learned entry to write. If all the entries
+ *      with the same hash value can't be replaced, ASIC will return a RT_ERR_L2_INDEXTBL_FULL error.
+ */
+extern rtk_api_ret_t rtk_l2_addr_add(rtk_mac_t *pMac, rtk_l2_ucastAddr_t *pL2_data);
+
+/* Function Name:
+ *      rtk_l2_addr_get
+ * Description:
+ *      Get LUT unicast entry.
+ * Input:
+ *      pMac    - 6 bytes unicast(I/G bit is 0) mac address to be written into LUT.
+ * Output:
+ *      pL2_data - Unicast entry parameter
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_MAC                  - Invalid MAC address.
+ *      RT_ERR_L2_FID               - Invalid FID .
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      If the unicast mac address existed in LUT, it will return the port and fid where
+ *      the mac is learned. Otherwise, it will return a RT_ERR_L2_ENTRY_NOTFOUND error.
+ */
+extern rtk_api_ret_t rtk_l2_addr_get(rtk_mac_t *pMac, rtk_l2_ucastAddr_t *pL2_data);
+
+/* Function Name:
+ *      rtk_l2_addr_next_get
+ * Description:
+ *      Get Next LUT unicast entry.
+ * Input:
+ *      read_method     - The reading method.
+ *      port            - The port number if the read_metohd is READMETHOD_NEXT_L2UCSPA
+ *      pAddress        - The Address ID
+ * Output:
+ *      pL2_data - Unicast entry parameter
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_MAC                  - Invalid MAC address.
+ *      RT_ERR_L2_FID               - Invalid FID .
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      Get the next unicast entry after the current entry pointed by pAddress.
+ *      The address of next entry is returned by pAddress. User can use (address + 1)
+ *      as pAddress to call this API again for dumping all entries is LUT.
+ */
+extern rtk_api_ret_t rtk_l2_addr_next_get(rtk_l2_read_method_t read_method, rtk_port_t port, rtk_uint32 *pAddress, rtk_l2_ucastAddr_t *pL2_data);
+
+/* Function Name:
+ *      rtk_l2_addr_del
+ * Description:
+ *      Delete LUT unicast entry.
+ * Input:
+ *      pMac - 6 bytes unicast(I/G bit is 0) mac address to be written into LUT.
+ *      fid - Filtering database
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_MAC                  - Invalid MAC address.
+ *      RT_ERR_L2_FID               - Invalid FID .
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      If the mac has existed in the LUT, it will be deleted. Otherwise, it will return RT_ERR_L2_ENTRY_NOTFOUND.
+ */
+extern rtk_api_ret_t rtk_l2_addr_del(rtk_mac_t *pMac, rtk_l2_ucastAddr_t *pL2_data);
+
+/* Function Name:
+ *      rtk_l2_mcastAddr_add
+ * Description:
+ *      Add LUT multicast entry.
+ * Input:
+ *      pMcastAddr  - L2 multicast entry structure
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_MAC              - Invalid MAC address.
+ *      RT_ERR_L2_FID           - Invalid FID .
+ *      RT_ERR_L2_VID           - Invalid VID .
+ *      RT_ERR_L2_INDEXTBL_FULL - hashed index is full of entries.
+ *      RT_ERR_PORT_MASK        - Invalid portmask.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      If the multicast mac address already existed in the LUT, it will udpate the
+ *      port mask of the entry. Otherwise, it will find an empty or asic auto learned
+ *      entry to write. If all the entries with the same hash value can't be replaced,
+ *      ASIC will return a RT_ERR_L2_INDEXTBL_FULL error.
+ */
+extern rtk_api_ret_t rtk_l2_mcastAddr_add(rtk_l2_mcastAddr_t *pMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_mcastAddr_get
+ * Description:
+ *      Get LUT multicast entry.
+ * Input:
+ *      pMcastAddr  - L2 multicast entry structure
+ * Output:
+ *      pMcastAddr  - L2 multicast entry structure
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_MAC                  - Invalid MAC address.
+ *      RT_ERR_L2_FID               - Invalid FID .
+ *      RT_ERR_L2_VID               - Invalid VID .
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      If the multicast mac address existed in the LUT, it will return the port where
+ *      the mac is learned. Otherwise, it will return a RT_ERR_L2_ENTRY_NOTFOUND error.
+ */
+extern rtk_api_ret_t rtk_l2_mcastAddr_get(rtk_l2_mcastAddr_t *pMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_mcastAddr_next_get
+ * Description:
+ *      Get Next L2 Multicast entry.
+ * Input:
+ *      pAddress        - The Address ID
+ * Output:
+ *      pMcastAddr  - L2 multicast entry structure
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      Get the next L2 multicast entry after the current entry pointed by pAddress.
+ *      The address of next entry is returned by pAddress. User can use (address + 1)
+ *      as pAddress to call this API again for dumping all multicast entries is LUT.
+ */
+extern rtk_api_ret_t rtk_l2_mcastAddr_next_get(rtk_uint32 *pAddress, rtk_l2_mcastAddr_t *pMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_mcastAddr_del
+ * Description:
+ *      Delete LUT multicast entry.
+ * Input:
+ *      pMcastAddr  - L2 multicast entry structure
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_MAC                  - Invalid MAC address.
+ *      RT_ERR_L2_FID               - Invalid FID .
+ *      RT_ERR_L2_VID               - Invalid VID .
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      If the mac has existed in the LUT, it will be deleted. Otherwise, it will return RT_ERR_L2_ENTRY_NOTFOUND.
+ */
+extern rtk_api_ret_t rtk_l2_mcastAddr_del(rtk_l2_mcastAddr_t *pMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddr_add
+ * Description:
+ *      Add Lut IP multicast entry
+ * Input:
+ *      pIpMcastAddr    - IP Multicast entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_L2_INDEXTBL_FULL - hashed index is full of entries.
+ *      RT_ERR_PORT_MASK        - Invalid portmask.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      System supports L2 entry with IP multicast DIP/SIP to forward IP multicasting frame as user
+ *      desired. If this function is enabled, then system will be looked up L2 IP multicast entry to
+ *      forward IP multicast frame directly without flooding.
+ */
+extern rtk_api_ret_t rtk_l2_ipMcastAddr_add(rtk_l2_ipMcastAddr_t *pIpMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddr_get
+ * Description:
+ *      Get LUT IP multicast entry.
+ * Input:
+ *      pIpMcastAddr    - IP Multicast entry
+ * Output:
+ *      pIpMcastAddr    - IP Multicast entry
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      The API can get Lut table of IP multicast entry.
+ */
+extern rtk_api_ret_t rtk_l2_ipMcastAddr_get(rtk_l2_ipMcastAddr_t *pIpMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddr_next_get
+ * Description:
+ *      Get Next IP Multicast entry.
+ * Input:
+ *      pAddress        - The Address ID
+ * Output:
+ *      pIpMcastAddr    - IP Multicast entry
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      Get the next IP multicast entry after the current entry pointed by pAddress.
+ *      The address of next entry is returned by pAddress. User can use (address + 1)
+ *      as pAddress to call this API again for dumping all IP multicast entries is LUT.
+ */
+extern rtk_api_ret_t rtk_l2_ipMcastAddr_next_get(rtk_uint32 *pAddress, rtk_l2_ipMcastAddr_t *pIpMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddr_del
+ * Description:
+ *      Delete a ip multicast address entry from the specified device.
+ * Input:
+ *      pIpMcastAddr    - IP Multicast entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      The API can delete a IP multicast address entry from the specified device.
+ */
+extern rtk_api_ret_t rtk_l2_ipMcastAddr_del(rtk_l2_ipMcastAddr_t *pIpMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_ipVidMcastAddr_add
+ * Description:
+ *      Add Lut IP multicast+VID entry
+ * Input:
+ *      pIpVidMcastAddr - IP & VID multicast Entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_L2_INDEXTBL_FULL - hashed index is full of entries.
+ *      RT_ERR_PORT_MASK        - Invalid portmask.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_l2_ipVidMcastAddr_add(rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_ipVidMcastAddr_get
+ * Description:
+ *      Get LUT IP multicast+VID entry.
+ * Input:
+ *      pIpVidMcastAddr - IP & VID multicast Entry
+ * Output:
+ *      pIpVidMcastAddr - IP & VID multicast Entry
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_l2_ipVidMcastAddr_get(rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_ipVidMcastAddr_next_get
+ * Description:
+ *      Get Next IP Multicast+VID entry.
+ * Input:
+ *      pAddress        - The Address ID
+ * Output:
+ *      pIpVidMcastAddr - IP & VID multicast Entry
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      Get the next IP multicast entry after the current entry pointed by pAddress.
+ *      The address of next entry is returned by pAddress. User can use (address + 1)
+ *      as pAddress to call this API again for dumping all IP multicast entries is LUT.
+ */
+extern rtk_api_ret_t rtk_l2_ipVidMcastAddr_next_get(rtk_uint32 *pAddress, rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_ipVidMcastAddr_del
+ * Description:
+ *      Delete a ip multicast+VID address entry from the specified device.
+ * Input:
+ *      pIpVidMcastAddr - IP & VID multicast Entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_l2_ipVidMcastAddr_del(rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr);
+
+/* Function Name:
+ *      rtk_l2_ucastAddr_flush
+ * Description:
+ *      Flush L2 mac address by type in the specified device (both dynamic and static).
+ * Input:
+ *      pConfig - flush configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      flushByVid          - 1: Flush by VID, 0: Don't flush by VID
+ *      vid                 - VID (0 ~ 4095)
+ *      flushByFid          - 1: Flush by FID, 0: Don't flush by FID
+ *      fid                 - FID (0 ~ 15)
+ *      flushByPort         - 1: Flush by Port, 0: Don't flush by Port
+ *      port                - Port ID
+ *      flushByMac          - Not Supported
+ *      ucastAddr           - Not Supported
+ *      flushStaticAddr     - 1: Flush both Static and Dynamic entries, 0: Flush only Dynamic entries
+ *      flushAddrOnAllPorts - 1: Flush VID-matched entries at all ports, 0: Flush VID-matched entries per port.
+ */
+extern rtk_api_ret_t rtk_l2_ucastAddr_flush(rtk_l2_flushCfg_t *pConfig);
+
+/* Function Name:
+ *      rtk_l2_table_clear
+ * Description:
+ *      Flush all static & dynamic entries in LUT.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_l2_table_clear(void);
+
+/* Function Name:
+ *      rtk_l2_table_clearStatus_get
+ * Description:
+ *      Get table clear status
+ * Input:
+ *      None
+ * Output:
+ *      pStatus - Clear status, 1:Busy, 0:finish
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_l2_table_clearStatus_get(rtk_l2_clearStatus_t *pStatus);
+
+/* Function Name:
+ *      rtk_l2_flushLinkDownPortAddrEnable_set
+ * Description:
+ *      Set HW flush linkdown port mac configuration of the specified device.
+ * Input:
+ *      port - Port id.
+ *      enable - link down flush status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      The status of flush linkdown port address is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+extern rtk_api_ret_t rtk_l2_flushLinkDownPortAddrEnable_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_l2_flushLinkDownPortAddrEnable_get
+ * Description:
+ *      Get HW flush linkdown port mac configuration of the specified device.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - link down flush status
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The status of flush linkdown port address is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+extern rtk_api_ret_t rtk_l2_flushLinkDownPortAddrEnable_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_l2_agingEnable_set
+ * Description:
+ *      Set L2 LUT aging status per port setting.
+ * Input:
+ *      port    - Port id.
+ *      enable  - Aging status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      This API can be used to set L2 LUT aging status per port.
+ */
+extern rtk_api_ret_t rtk_l2_agingEnable_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_l2_agingEnable_get
+ * Description:
+ *      Get L2 LUT aging status per port setting.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - Aging status
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can be used to get L2 LUT aging function per port.
+ */
+extern rtk_api_ret_t rtk_l2_agingEnable_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_l2_limitLearningCnt_set
+ * Description:
+ *      Set per-Port auto learning limit number
+ * Input:
+ *      port    - Port id.
+ *      mac_cnt - Auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_LIMITED_L2ENTRY_NUM  - Invalid auto learning limit number
+ * Note:
+ *      The API can set per-port ASIC auto learning limit number from 0(disable learning)
+ *      to 8k.
+ */
+extern rtk_api_ret_t rtk_l2_limitLearningCnt_set(rtk_port_t port, rtk_mac_cnt_t mac_cnt);
+
+/* Function Name:
+ *      rtk_l2_limitLearningCnt_get
+ * Description:
+ *      Get per-Port auto learning limit number
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pMac_cnt - Auto learning entries limit number
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get per-port ASIC auto learning limit number.
+ */
+extern rtk_api_ret_t rtk_l2_limitLearningCnt_get(rtk_port_t port, rtk_mac_cnt_t *pMac_cnt);
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCnt_set
+ * Description:
+ *      Set System auto learning limit number
+ * Input:
+ *      mac_cnt - Auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_LIMITED_L2ENTRY_NUM  - Invalid auto learning limit number
+ * Note:
+ *      The API can set system ASIC auto learning limit number from 0(disable learning)
+ *      to 2112.
+ */
+extern rtk_api_ret_t rtk_l2_limitSystemLearningCnt_set(rtk_mac_cnt_t mac_cnt);
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCnt_get
+ * Description:
+ *      Get System auto learning limit number
+ * Input:
+ *      None
+ * Output:
+ *      pMac_cnt - Auto learning entries limit number
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get system ASIC auto learning limit number.
+ */
+extern rtk_api_ret_t rtk_l2_limitSystemLearningCnt_get(rtk_mac_cnt_t *pMac_cnt);
+
+/* Function Name:
+ *      rtk_l2_limitLearningCntAction_set
+ * Description:
+ *      Configure auto learn over limit number action.
+ * Input:
+ *      port - Port id.
+ *      action - Auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_NOT_ALLOWED  - Invalid learn over action
+ * Note:
+ *      The API can set SA unknown packet action while auto learn limit number is over
+ *      The action symbol as following:
+ *      - LIMIT_LEARN_CNT_ACTION_DROP,
+ *      - LIMIT_LEARN_CNT_ACTION_FORWARD,
+ *      - LIMIT_LEARN_CNT_ACTION_TO_CPU,
+ */
+extern rtk_api_ret_t rtk_l2_limitLearningCntAction_set(rtk_port_t port, rtk_l2_limitLearnCntAction_t action);
+
+/* Function Name:
+ *      rtk_l2_limitLearningCntAction_get
+ * Description:
+ *      Get auto learn over limit number action.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pAction - Learn over action
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get SA unknown packet action while auto learn limit number is over
+ *      The action symbol as following:
+ *      - LIMIT_LEARN_CNT_ACTION_DROP,
+ *      - LIMIT_LEARN_CNT_ACTION_FORWARD,
+ *      - LIMIT_LEARN_CNT_ACTION_TO_CPU,
+ */
+extern rtk_api_ret_t rtk_l2_limitLearningCntAction_get(rtk_port_t port, rtk_l2_limitLearnCntAction_t *pAction);
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCntAction_set
+ * Description:
+ *      Configure system auto learn over limit number action.
+ * Input:
+ *      port - Port id.
+ *      action - Auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_NOT_ALLOWED  - Invalid learn over action
+ * Note:
+ *      The API can set SA unknown packet action while auto learn limit number is over
+ *      The action symbol as following:
+ *      - LIMIT_LEARN_CNT_ACTION_DROP,
+ *      - LIMIT_LEARN_CNT_ACTION_FORWARD,
+ *      - LIMIT_LEARN_CNT_ACTION_TO_CPU,
+ */
+extern rtk_api_ret_t rtk_l2_limitSystemLearningCntAction_set(rtk_l2_limitLearnCntAction_t action);
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCntAction_get
+ * Description:
+ *      Get system auto learn over limit number action.
+ * Input:
+ *      None.
+ * Output:
+ *      pAction - Learn over action
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get SA unknown packet action while auto learn limit number is over
+ *      The action symbol as following:
+ *      - LIMIT_LEARN_CNT_ACTION_DROP,
+ *      - LIMIT_LEARN_CNT_ACTION_FORWARD,
+ *      - LIMIT_LEARN_CNT_ACTION_TO_CPU,
+ */
+extern rtk_api_ret_t rtk_l2_limitSystemLearningCntAction_get(rtk_l2_limitLearnCntAction_t *pAction);
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCntPortMask_set
+ * Description:
+ *      Configure system auto learn portmask
+ * Input:
+ *      pPortmask - Port Mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid port mask.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_l2_limitSystemLearningCntPortMask_set(rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCntPortMask_get
+ * Description:
+ *      get system auto learn portmask
+ * Input:
+ *      None
+ * Output:
+ *      pPortmask - Port Mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - Null pointer.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_l2_limitSystemLearningCntPortMask_get(rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_l2_learningCnt_get
+ * Description:
+ *      Get per-Port current auto learning number
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pMac_cnt - ASIC auto learning entries number
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get per-port ASIC auto learning number
+ */
+extern rtk_api_ret_t rtk_l2_learningCnt_get(rtk_port_t port, rtk_mac_cnt_t *pMac_cnt);
+
+/* Function Name:
+ *      rtk_l2_floodPortMask_set
+ * Description:
+ *      Set flooding portmask
+ * Input:
+ *      type - flooding type.
+ *      pFlood_portmask - flooding porkmask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can set the flooding mask.
+ *      The flooding type is as following:
+ *      - FLOOD_UNKNOWNDA
+ *      - FLOOD_UNKNOWNMC
+ *      - FLOOD_BC
+ */
+extern rtk_api_ret_t rtk_l2_floodPortMask_set(rtk_l2_flood_type_t floood_type, rtk_portmask_t *pFlood_portmask);
+
+/* Function Name:
+ *      rtk_l2_floodPortMask_get
+ * Description:
+ *      Get flooding portmask
+ * Input:
+ *      type - flooding type.
+ * Output:
+ *      pFlood_portmask - flooding porkmask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can get the flooding mask.
+ *      The flooding type is as following:
+ *      - FLOOD_UNKNOWNDA
+ *      - FLOOD_UNKNOWNMC
+ *      - FLOOD_BC
+ */
+extern rtk_api_ret_t rtk_l2_floodPortMask_get(rtk_l2_flood_type_t floood_type, rtk_portmask_t *pFlood_portmask);
+
+/* Function Name:
+ *      rtk_l2_localPktPermit_set
+ * Description:
+ *      Set permittion of frames if source port and destination port are the same.
+ * Input:
+ *      port - Port id.
+ *      permit - permittion status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid permit value.
+ * Note:
+ *      This API is setted to permit frame if its source port is equal to destination port.
+ */
+extern rtk_api_ret_t rtk_l2_localPktPermit_set(rtk_port_t port, rtk_enable_t permit);
+
+/* Function Name:
+ *      rtk_l2_localPktPermit_get
+ * Description:
+ *      Get permittion of frames if source port and destination port are the same.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPermit - permittion status
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API is to get permittion status for frames if its source port is equal to destination port.
+ */
+extern rtk_api_ret_t rtk_l2_localPktPermit_get(rtk_port_t port, rtk_enable_t *pPermit);
+
+/* Function Name:
+ *      rtk_l2_aging_set
+ * Description:
+ *      Set LUT agging out speed
+ * Input:
+ *      aging_time - Agging out time.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The API can set LUT agging out period for each entry and the range is from 14s to 800s.
+ */
+extern rtk_api_ret_t rtk_l2_aging_set(rtk_l2_age_time_t aging_time);
+
+/* Function Name:
+ *      rtk_l2_aging_get
+ * Description:
+ *      Get LUT agging out time
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - Aging status
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get LUT agging out period for each entry.
+ */
+extern rtk_api_ret_t rtk_l2_aging_get(rtk_l2_age_time_t *pAging_time);
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddrLookup_set
+ * Description:
+ *      Set Lut IP multicast lookup function
+ * Input:
+ *      type - Lookup type for IPMC packet.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ * Note:
+ *      This API can work with rtk_l2_ipMcastAddrLookupException_add.
+ *      If users set the lookup type to DIP, the group in exception table
+ *      will be lookup by DIP+SIP
+ *      If users set the lookup type to DIP+SIP, the group in exception table
+ *      will be lookup by only DIP
+ */
+extern rtk_api_ret_t rtk_l2_ipMcastAddrLookup_set(rtk_l2_ipmc_lookup_type_t type);
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddrLookup_get
+ * Description:
+ *      Get Lut IP multicast lookup function
+ * Input:
+ *      None.
+ * Output:
+ *      pType - Lookup type for IPMC packet.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_l2_ipMcastAddrLookup_get(rtk_l2_ipmc_lookup_type_t *pType);
+
+/* Function Name:
+ *      rtk_l2_ipMcastForwardRouterPort_set
+ * Description:
+ *      Set IPMC packet forward to rounter port also or not
+ * Input:
+ *      enabled - 1: Inlcude router port, 0, exclude router port
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_l2_ipMcastForwardRouterPort_set(rtk_enable_t enabled);
+
+/* Function Name:
+ *      rtk_l2_ipMcastForwardRouterPort_get
+ * Description:
+ *      Get IPMC packet forward to rounter port also or not
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled    - 1: Inlcude router port, 0, exclude router port
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_l2_ipMcastForwardRouterPort_get(rtk_enable_t *pEnabled);
+
+/* Function Name:
+ *      rtk_l2_ipMcastGroupEntry_add
+ * Description:
+ *      Add an IP Multicast entry to group table
+ * Input:
+ *      ip_addr     - IP address
+ *      vid         - VLAN ID
+ *      pPortmask   - portmask
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ *      RT_ERR_TBL_FULL    - Table Full
+ * Note:
+ *      Add an entry to IP Multicast Group table.
+ */
+extern rtk_api_ret_t rtk_l2_ipMcastGroupEntry_add(ipaddr_t ip_addr, rtk_uint32 vid, rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_l2_ipMcastGroupEntry_del
+ * Description:
+ *      Delete an entry from IP Multicast group table
+ * Input:
+ *      ip_addr     - IP address
+ *      vid         - VLAN ID
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ *      RT_ERR_TBL_FULL    - Table Full
+ * Note:
+ *      Delete an entry from IP Multicast group table.
+ */
+extern rtk_api_ret_t rtk_l2_ipMcastGroupEntry_del(ipaddr_t ip_addr, rtk_uint32 vid);
+
+/* Function Name:
+ *      rtk_l2_ipMcastGroupEntry_get
+ * Description:
+ *      get an entry from IP Multicast group table
+ * Input:
+ *      ip_addr     - IP address
+ *      vid         - VLAN ID
+ * Output:
+ *      pPortmask   - member port mask
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ *      RT_ERR_TBL_FULL    - Table Full
+ * Note:
+ *      Delete an entry from IP Multicast group table.
+ */
+extern rtk_api_ret_t rtk_l2_ipMcastGroupEntry_get(ipaddr_t ip_addr, rtk_uint32 vid, rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_l2_entry_get
+ * Description:
+ *      Get LUT unicast entry.
+ * Input:
+ *      pL2_entry - Index field in the structure.
+ * Output:
+ *      pL2_entry - other fields such as MAC, port, age...
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_L2_EMPTY_ENTRY   - Empty LUT entry.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      This API is used to get address by index from 0~2111.
+ */
+extern rtk_api_ret_t rtk_l2_entry_get(rtk_l2_addr_table_t *pL2_entry);
+
+
+#endif /* __RTK_API_L2_H__ */
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/leaky.h b/drivers/net/phy/rtk/rtl8367c/include/leaky.h
new file mode 100644
index 0000000000000..f44ec5c224f7a
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/leaky.h
@@ -0,0 +1,371 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes Leaky module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_LEAKY_H__
+#define __RTK_API_LEAKY_H__
+
+
+typedef enum rtk_leaky_type_e
+{
+    LEAKY_BRG_GROUP = 0,
+    LEAKY_FD_PAUSE,
+    LEAKY_SP_MCAST,
+    LEAKY_1X_PAE,
+    LEAKY_UNDEF_BRG_04,
+    LEAKY_UNDEF_BRG_05,
+    LEAKY_UNDEF_BRG_06,
+    LEAKY_UNDEF_BRG_07,
+    LEAKY_PROVIDER_BRIDGE_GROUP_ADDRESS,
+    LEAKY_UNDEF_BRG_09,
+    LEAKY_UNDEF_BRG_0A,
+    LEAKY_UNDEF_BRG_0B,
+    LEAKY_UNDEF_BRG_0C,
+    LEAKY_PROVIDER_BRIDGE_GVRP_ADDRESS,
+    LEAKY_8021AB,
+    LEAKY_UNDEF_BRG_0F,
+    LEAKY_BRG_MNGEMENT,
+    LEAKY_UNDEFINED_11,
+    LEAKY_UNDEFINED_12,
+    LEAKY_UNDEFINED_13,
+    LEAKY_UNDEFINED_14,
+    LEAKY_UNDEFINED_15,
+    LEAKY_UNDEFINED_16,
+    LEAKY_UNDEFINED_17,
+    LEAKY_UNDEFINED_18,
+    LEAKY_UNDEFINED_19,
+    LEAKY_UNDEFINED_1A,
+    LEAKY_UNDEFINED_1B,
+    LEAKY_UNDEFINED_1C,
+    LEAKY_UNDEFINED_1D,
+    LEAKY_UNDEFINED_1E,
+    LEAKY_UNDEFINED_1F,
+    LEAKY_GMRP,
+    LEAKY_GVRP,
+    LEAKY_UNDEF_GARP_22,
+    LEAKY_UNDEF_GARP_23,
+    LEAKY_UNDEF_GARP_24,
+    LEAKY_UNDEF_GARP_25,
+    LEAKY_UNDEF_GARP_26,
+    LEAKY_UNDEF_GARP_27,
+    LEAKY_UNDEF_GARP_28,
+    LEAKY_UNDEF_GARP_29,
+    LEAKY_UNDEF_GARP_2A,
+    LEAKY_UNDEF_GARP_2B,
+    LEAKY_UNDEF_GARP_2C,
+    LEAKY_UNDEF_GARP_2D,
+    LEAKY_UNDEF_GARP_2E,
+    LEAKY_UNDEF_GARP_2F,
+    LEAKY_IGMP,
+    LEAKY_IPMULTICAST,
+    LEAKY_CDP,
+    LEAKY_CSSTP,
+    LEAKY_LLDP,
+    LEAKY_END,
+}rtk_leaky_type_t;
+
+/* Function Name:
+ *      rtk_leaky_vlan_set
+ * Description:
+ *      Set VLAN leaky.
+ * Input:
+ *      type - Packet type for VLAN leaky.
+ *      enable - Leaky status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      This API can set VLAN leaky for RMA ,IGMP/MLD, CDP, CSSTP, and LLDP packets.
+ *      The leaky frame types are as following:
+ *      - LEAKY_BRG_GROUP,
+ *      - LEAKY_FD_PAUSE,
+ *      - LEAKY_SP_MCAST,
+ *      - LEAKY_1X_PAE,
+ *      - LEAKY_UNDEF_BRG_04,
+ *      - LEAKY_UNDEF_BRG_05,
+ *      - LEAKY_UNDEF_BRG_06,
+ *      - LEAKY_UNDEF_BRG_07,
+ *      - LEAKY_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - LEAKY_UNDEF_BRG_09,
+ *      - LEAKY_UNDEF_BRG_0A,
+ *      - LEAKY_UNDEF_BRG_0B,
+ *      - LEAKY_UNDEF_BRG_0C,
+ *      - LEAKY_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - LEAKY_8021AB,
+ *      - LEAKY_UNDEF_BRG_0F,
+ *      - LEAKY_BRG_MNGEMENT,
+ *      - LEAKY_UNDEFINED_11,
+ *      - LEAKY_UNDEFINED_12,
+ *      - LEAKY_UNDEFINED_13,
+ *      - LEAKY_UNDEFINED_14,
+ *      - LEAKY_UNDEFINED_15,
+ *      - LEAKY_UNDEFINED_16,
+ *      - LEAKY_UNDEFINED_17,
+ *      - LEAKY_UNDEFINED_18,
+ *      - LEAKY_UNDEFINED_19,
+ *      - LEAKY_UNDEFINED_1A,
+ *      - LEAKY_UNDEFINED_1B,
+ *      - LEAKY_UNDEFINED_1C,
+ *      - LEAKY_UNDEFINED_1D,
+ *      - LEAKY_UNDEFINED_1E,
+ *      - LEAKY_UNDEFINED_1F,
+ *      - LEAKY_GMRP,
+ *      - LEAKY_GVRP,
+ *      - LEAKY_UNDEF_GARP_22,
+ *      - LEAKY_UNDEF_GARP_23,
+ *      - LEAKY_UNDEF_GARP_24,
+ *      - LEAKY_UNDEF_GARP_25,
+ *      - LEAKY_UNDEF_GARP_26,
+ *      - LEAKY_UNDEF_GARP_27,
+ *      - LEAKY_UNDEF_GARP_28,
+ *      - LEAKY_UNDEF_GARP_29,
+ *      - LEAKY_UNDEF_GARP_2A,
+ *      - LEAKY_UNDEF_GARP_2B,
+ *      - LEAKY_UNDEF_GARP_2C,
+ *      - LEAKY_UNDEF_GARP_2D,
+ *      - LEAKY_UNDEF_GARP_2E,
+ *      - LEAKY_UNDEF_GARP_2F,
+ *      - LEAKY_IGMP,
+ *      - LEAKY_IPMULTICAST.
+ *      - LEAKY_CDP,
+ *      - LEAKY_CSSTP,
+ *      - LEAKY_LLDP.
+ */
+extern rtk_api_ret_t rtk_leaky_vlan_set(rtk_leaky_type_t type, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_leaky_vlan_get
+ * Description:
+ *      Get VLAN leaky.
+ * Input:
+ *      type - Packet type for VLAN leaky.
+ * Output:
+ *      pEnable - Leaky status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get VLAN leaky status for RMA ,IGMP/MLD, CDP, CSSTP, and LLDP  packets.
+ *      The leaky frame types are as following:
+ *      - LEAKY_BRG_GROUP,
+ *      - LEAKY_FD_PAUSE,
+ *      - LEAKY_SP_MCAST,
+ *      - LEAKY_1X_PAE,
+ *      - LEAKY_UNDEF_BRG_04,
+ *      - LEAKY_UNDEF_BRG_05,
+ *      - LEAKY_UNDEF_BRG_06,
+ *      - LEAKY_UNDEF_BRG_07,
+ *      - LEAKY_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - LEAKY_UNDEF_BRG_09,
+ *      - LEAKY_UNDEF_BRG_0A,
+ *      - LEAKY_UNDEF_BRG_0B,
+ *      - LEAKY_UNDEF_BRG_0C,
+ *      - LEAKY_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - LEAKY_8021AB,
+ *      - LEAKY_UNDEF_BRG_0F,
+ *      - LEAKY_BRG_MNGEMENT,
+ *      - LEAKY_UNDEFINED_11,
+ *      - LEAKY_UNDEFINED_12,
+ *      - LEAKY_UNDEFINED_13,
+ *      - LEAKY_UNDEFINED_14,
+ *      - LEAKY_UNDEFINED_15,
+ *      - LEAKY_UNDEFINED_16,
+ *      - LEAKY_UNDEFINED_17,
+ *      - LEAKY_UNDEFINED_18,
+ *      - LEAKY_UNDEFINED_19,
+ *      - LEAKY_UNDEFINED_1A,
+ *      - LEAKY_UNDEFINED_1B,
+ *      - LEAKY_UNDEFINED_1C,
+ *      - LEAKY_UNDEFINED_1D,
+ *      - LEAKY_UNDEFINED_1E,
+ *      - LEAKY_UNDEFINED_1F,
+ *      - LEAKY_GMRP,
+ *      - LEAKY_GVRP,
+ *      - LEAKY_UNDEF_GARP_22,
+ *      - LEAKY_UNDEF_GARP_23,
+ *      - LEAKY_UNDEF_GARP_24,
+ *      - LEAKY_UNDEF_GARP_25,
+ *      - LEAKY_UNDEF_GARP_26,
+ *      - LEAKY_UNDEF_GARP_27,
+ *      - LEAKY_UNDEF_GARP_28,
+ *      - LEAKY_UNDEF_GARP_29,
+ *      - LEAKY_UNDEF_GARP_2A,
+ *      - LEAKY_UNDEF_GARP_2B,
+ *      - LEAKY_UNDEF_GARP_2C,
+ *      - LEAKY_UNDEF_GARP_2D,
+ *      - LEAKY_UNDEF_GARP_2E,
+ *      - LEAKY_UNDEF_GARP_2F,
+ *      - LEAKY_IGMP,
+ *      - LEAKY_IPMULTICAST.
+ *      - LEAKY_CDP,
+ *      - LEAKY_CSSTP,
+ *      - LEAKY_LLDP.
+ */
+extern rtk_api_ret_t rtk_leaky_vlan_get(rtk_leaky_type_t type, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_leaky_portIsolation_set
+ * Description:
+ *      Set port isolation leaky.
+ * Input:
+ *      type - Packet type for port isolation leaky.
+ *      enable - Leaky status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      This API can set port isolation leaky for RMA ,IGMP/MLD, CDP, CSSTP, and LLDP  packets.
+ *      The leaky frame types are as following:
+ *      - LEAKY_BRG_GROUP,
+ *      - LEAKY_FD_PAUSE,
+ *      - LEAKY_SP_MCAST,
+ *      - LEAKY_1X_PAE,
+ *      - LEAKY_UNDEF_BRG_04,
+ *      - LEAKY_UNDEF_BRG_05,
+ *      - LEAKY_UNDEF_BRG_06,
+ *      - LEAKY_UNDEF_BRG_07,
+ *      - LEAKY_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - LEAKY_UNDEF_BRG_09,
+ *      - LEAKY_UNDEF_BRG_0A,
+ *      - LEAKY_UNDEF_BRG_0B,
+ *      - LEAKY_UNDEF_BRG_0C,
+ *      - LEAKY_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - LEAKY_8021AB,
+ *      - LEAKY_UNDEF_BRG_0F,
+ *      - LEAKY_BRG_MNGEMENT,
+ *      - LEAKY_UNDEFINED_11,
+ *      - LEAKY_UNDEFINED_12,
+ *      - LEAKY_UNDEFINED_13,
+ *      - LEAKY_UNDEFINED_14,
+ *      - LEAKY_UNDEFINED_15,
+ *      - LEAKY_UNDEFINED_16,
+ *      - LEAKY_UNDEFINED_17,
+ *      - LEAKY_UNDEFINED_18,
+ *      - LEAKY_UNDEFINED_19,
+ *      - LEAKY_UNDEFINED_1A,
+ *      - LEAKY_UNDEFINED_1B,
+ *      - LEAKY_UNDEFINED_1C,
+ *      - LEAKY_UNDEFINED_1D,
+ *      - LEAKY_UNDEFINED_1E,
+ *      - LEAKY_UNDEFINED_1F,
+ *      - LEAKY_GMRP,
+ *      - LEAKY_GVRP,
+ *      - LEAKY_UNDEF_GARP_22,
+ *      - LEAKY_UNDEF_GARP_23,
+ *      - LEAKY_UNDEF_GARP_24,
+ *      - LEAKY_UNDEF_GARP_25,
+ *      - LEAKY_UNDEF_GARP_26,
+ *      - LEAKY_UNDEF_GARP_27,
+ *      - LEAKY_UNDEF_GARP_28,
+ *      - LEAKY_UNDEF_GARP_29,
+ *      - LEAKY_UNDEF_GARP_2A,
+ *      - LEAKY_UNDEF_GARP_2B,
+ *      - LEAKY_UNDEF_GARP_2C,
+ *      - LEAKY_UNDEF_GARP_2D,
+ *      - LEAKY_UNDEF_GARP_2E,
+ *      - LEAKY_UNDEF_GARP_2F,
+ *      - LEAKY_IGMP,
+ *      - LEAKY_IPMULTICAST.
+ *      - LEAKY_CDP,
+ *      - LEAKY_CSSTP,
+ *      - LEAKY_LLDP.
+ */
+extern rtk_api_ret_t rtk_leaky_portIsolation_set(rtk_leaky_type_t type, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_leaky_portIsolation_get
+ * Description:
+ *      Get port isolation leaky.
+ * Input:
+ *      type - Packet type for port isolation leaky.
+ * Output:
+ *      pEnable - Leaky status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get port isolation leaky status for RMA ,IGMP/MLD, CDP, CSSTP, and LLDP  packets.
+ *      The leaky frame types are as following:
+ *      - LEAKY_BRG_GROUP,
+ *      - LEAKY_FD_PAUSE,
+ *      - LEAKY_SP_MCAST,
+ *      - LEAKY_1X_PAE,
+ *      - LEAKY_UNDEF_BRG_04,
+ *      - LEAKY_UNDEF_BRG_05,
+ *      - LEAKY_UNDEF_BRG_06,
+ *      - LEAKY_UNDEF_BRG_07,
+ *      - LEAKY_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - LEAKY_UNDEF_BRG_09,
+ *      - LEAKY_UNDEF_BRG_0A,
+ *      - LEAKY_UNDEF_BRG_0B,
+ *      - LEAKY_UNDEF_BRG_0C,
+ *      - LEAKY_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - LEAKY_8021AB,
+ *      - LEAKY_UNDEF_BRG_0F,
+ *      - LEAKY_BRG_MNGEMENT,
+ *      - LEAKY_UNDEFINED_11,
+ *      - LEAKY_UNDEFINED_12,
+ *      - LEAKY_UNDEFINED_13,
+ *      - LEAKY_UNDEFINED_14,
+ *      - LEAKY_UNDEFINED_15,
+ *      - LEAKY_UNDEFINED_16,
+ *      - LEAKY_UNDEFINED_17,
+ *      - LEAKY_UNDEFINED_18,
+ *      - LEAKY_UNDEFINED_19,
+ *      - LEAKY_UNDEFINED_1A,
+ *      - LEAKY_UNDEFINED_1B,
+ *      - LEAKY_UNDEFINED_1C,
+ *      - LEAKY_UNDEFINED_1D,
+ *      - LEAKY_UNDEFINED_1E,
+ *      - LEAKY_UNDEFINED_1F,
+ *      - LEAKY_GMRP,
+ *      - LEAKY_GVRP,
+ *      - LEAKY_UNDEF_GARP_22,
+ *      - LEAKY_UNDEF_GARP_23,
+ *      - LEAKY_UNDEF_GARP_24,
+ *      - LEAKY_UNDEF_GARP_25,
+ *      - LEAKY_UNDEF_GARP_26,
+ *      - LEAKY_UNDEF_GARP_27,
+ *      - LEAKY_UNDEF_GARP_28,
+ *      - LEAKY_UNDEF_GARP_29,
+ *      - LEAKY_UNDEF_GARP_2A,
+ *      - LEAKY_UNDEF_GARP_2B,
+ *      - LEAKY_UNDEF_GARP_2C,
+ *      - LEAKY_UNDEF_GARP_2D,
+ *      - LEAKY_UNDEF_GARP_2E,
+ *      - LEAKY_UNDEF_GARP_2F,
+ *      - LEAKY_IGMP,
+ *      - LEAKY_IPMULTICAST.
+ *      - LEAKY_CDP,
+ *      - LEAKY_CSSTP,
+ *      - LEAKY_LLDP.
+ */
+extern rtk_api_ret_t rtk_leaky_portIsolation_get(rtk_leaky_type_t type, rtk_enable_t *pEnable);
+
+#endif /* __RTK_API_LEAKY_H__ */
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/led.h b/drivers/net/phy/rtk/rtl8367c/include/led.h
new file mode 100644
index 0000000000000..19e8c7b229070
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/led.h
@@ -0,0 +1,481 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes LED module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_LED_H__
+#define __RTK_API_LED_H__
+
+typedef enum rtk_led_operation_e
+{
+    LED_OP_SCAN=0,
+    LED_OP_PARALLEL,
+    LED_OP_SERIAL,
+    LED_OP_END,
+}rtk_led_operation_t;
+
+
+typedef enum rtk_led_active_e
+{
+    LED_ACTIVE_HIGH=0,
+    LED_ACTIVE_LOW,
+    LED_ACTIVE_END,
+}rtk_led_active_t;
+
+typedef enum rtk_led_config_e
+{
+    LED_CONFIG_LEDOFF=0,
+    LED_CONFIG_DUPCOL,
+    LED_CONFIG_LINK_ACT,
+    LED_CONFIG_SPD1000,
+    LED_CONFIG_SPD100,
+    LED_CONFIG_SPD10,
+    LED_CONFIG_SPD1000ACT,
+    LED_CONFIG_SPD100ACT,
+    LED_CONFIG_SPD10ACT,
+    LED_CONFIG_SPD10010ACT,
+    LED_CONFIG_LOOPDETECT,
+    LED_CONFIG_EEE,
+    LED_CONFIG_LINKRX,
+    LED_CONFIG_LINKTX,
+    LED_CONFIG_MASTER,
+    LED_CONFIG_ACT,
+    LED_CONFIG_END,
+}rtk_led_congig_t;
+
+typedef struct rtk_led_ability_s
+{
+    rtk_enable_t link_10m;
+    rtk_enable_t link_100m;
+    rtk_enable_t link_500m;
+    rtk_enable_t link_1000m;
+    rtk_enable_t act_rx;
+    rtk_enable_t act_tx;
+}rtk_led_ability_t;
+
+typedef enum rtk_led_blink_rate_e
+{
+    LED_BLINKRATE_32MS=0,
+    LED_BLINKRATE_64MS,
+    LED_BLINKRATE_128MS,
+    LED_BLINKRATE_256MS,
+    LED_BLINKRATE_512MS,
+    LED_BLINKRATE_1024MS,
+    LED_BLINKRATE_48MS,
+    LED_BLINKRATE_96MS,
+    LED_BLINKRATE_END,
+}rtk_led_blink_rate_t;
+
+typedef enum rtk_led_group_e
+{
+    LED_GROUP_0 = 0,
+    LED_GROUP_1,
+    LED_GROUP_2,
+    LED_GROUP_END
+}rtk_led_group_t;
+
+
+typedef enum rtk_led_force_mode_e
+{
+    LED_FORCE_NORMAL=0,
+    LED_FORCE_BLINK,
+    LED_FORCE_OFF,
+    LED_FORCE_ON,
+    LED_FORCE_END
+}rtk_led_force_mode_t;
+
+typedef enum rtk_led_serialOutput_e
+{
+    SERIAL_LED_NONE = 0,
+    SERIAL_LED_0,
+    SERIAL_LED_0_1,
+    SERIAL_LED_0_2,
+    SERIAL_LED_END,
+}rtk_led_serialOutput_t;
+
+
+/* Function Name:
+ *      rtk_led_enable_set
+ * Description:
+ *      Set Led enable congiuration
+ * Input:
+ *      group       - LED group id.
+ *      pPortmask    - LED enable port mask.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can be used to enable LED per port per group.
+ */
+extern rtk_api_ret_t rtk_led_enable_set(rtk_led_group_t group, rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_led_enable_get
+ * Description:
+ *      Get Led enable congiuration
+ * Input:
+ *      group - LED group id.
+ * Output:
+ *      pPortmask - LED enable port mask.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can be used to get LED enable status.
+ */
+extern rtk_api_ret_t rtk_led_enable_get(rtk_led_group_t group, rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_led_operation_set
+ * Description:
+ *      Set Led operation mode
+ * Input:
+ *      mode - LED operation mode.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can set Led operation mode.
+ *      The modes that can be set are as following:
+ *      - LED_OP_SCAN,
+ *      - LED_OP_PARALLEL,
+ *      - LED_OP_SERIAL,
+ */
+extern rtk_api_ret_t rtk_led_operation_set(rtk_led_operation_t mode);
+
+/* Function Name:
+ *      rtk_led_operation_get
+ * Description:
+ *      Get Led operation mode
+ * Input:
+ *      None
+ * Output:
+ *      pMode - Support LED operation mode.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get Led operation mode.
+ *      The modes that can be set are as following:
+ *      - LED_OP_SCAN,
+ *      - LED_OP_PARALLEL,
+ *      - LED_OP_SERIAL,
+ */
+extern rtk_api_ret_t rtk_led_operation_get(rtk_led_operation_t *pMode);
+
+/* Function Name:
+ *      rtk_led_modeForce_set
+ * Description:
+ *      Set Led group to congiuration force mode
+ * Input:
+ *      port    - port ID
+ *      group   - Support LED group id.
+ *      mode    - Support LED force mode.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Error Port ID
+ * Note:
+ *      The API can force to one force mode.
+ *      The force modes that can be set are as following:
+ *      - LED_FORCE_NORMAL,
+ *      - LED_FORCE_BLINK,
+ *      - LED_FORCE_OFF,
+ *      - LED_FORCE_ON.
+ */
+extern rtk_api_ret_t rtk_led_modeForce_set(rtk_port_t port, rtk_led_group_t group, rtk_led_force_mode_t mode);
+
+/* Function Name:
+ *      rtk_led_modeForce_get
+ * Description:
+ *      Get Led group to congiuration force mode
+ * Input:
+ *      port  - port ID
+ *      group - Support LED group id.
+ *      pMode - Support LED force mode.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Error Port ID
+ * Note:
+ *      The API can get forced Led group mode.
+ *      The force modes that can be set are as following:
+ *      - LED_FORCE_NORMAL,
+ *      - LED_FORCE_BLINK,
+ *      - LED_FORCE_OFF,
+ *      - LED_FORCE_ON.
+ */
+extern rtk_api_ret_t rtk_led_modeForce_get(rtk_port_t port, rtk_led_group_t group, rtk_led_force_mode_t *pMode);
+
+/* Function Name:
+ *      rtk_led_blinkRate_set
+ * Description:
+ *      Set LED blinking rate
+ * Input:
+ *      blinkRate - blinking rate.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      ASIC support 6 types of LED blinking rates at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms.
+ */
+extern rtk_api_ret_t rtk_led_blinkRate_set(rtk_led_blink_rate_t blinkRate);
+
+/* Function Name:
+ *      rtk_led_blinkRate_get
+ * Description:
+ *      Get LED blinking rate at mode 0 to mode 3
+ * Input:
+ *      None
+ * Output:
+ *      pBlinkRate - blinking rate.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      There are  6 types of LED blinking rates at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms.
+ */
+extern rtk_api_ret_t rtk_led_blinkRate_get(rtk_led_blink_rate_t *pBlinkRate);
+
+/* Function Name:
+ *      rtk_led_groupConfig_set
+ * Description:
+ *      Set per group Led to congiuration mode
+ * Input:
+ *      group   - LED group.
+ *      config  - LED configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can set LED indicated information configuration for each LED group with 1 to 1 led mapping to each port.
+ *      - Definition  LED Statuses      Description
+ *      - 0000        LED_Off           LED pin Tri-State.
+ *      - 0001        Dup/Col           Collision, Full duplex Indicator.
+ *      - 0010        Link/Act          Link, Activity Indicator.
+ *      - 0011        Spd1000           1000Mb/s Speed Indicator.
+ *      - 0100        Spd100            100Mb/s Speed Indicator.
+ *      - 0101        Spd10             10Mb/s Speed Indicator.
+ *      - 0110        Spd1000/Act       1000Mb/s Speed/Activity Indicator.
+ *      - 0111        Spd100/Act        100Mb/s Speed/Activity Indicator.
+ *      - 1000        Spd10/Act         10Mb/s Speed/Activity Indicator.
+ *      - 1001        Spd100 (10)/Act   10/100Mb/s Speed/Activity Indicator.
+ *      - 1010        LoopDetect        LoopDetect Indicator.
+ *      - 1011        EEE               EEE Indicator.
+ *      - 1100        Link/Rx           Link, Activity Indicator.
+ *      - 1101        Link/Tx           Link, Activity Indicator.
+ *      - 1110        Master            Link on Master Indicator.
+ *      - 1111        Act               Activity Indicator. Low for link established.
+ */
+extern rtk_api_ret_t rtk_led_groupConfig_set(rtk_led_group_t group, rtk_led_congig_t config);
+
+/* Function Name:
+ *      rtk_led_groupConfig_get
+ * Description:
+ *      Get Led group congiuration mode
+ * Input:
+ *      group - LED group.
+ * Output:
+ *      pConfig - LED configuration.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *       The API can get LED indicated information configuration for each LED group.
+ */
+extern rtk_api_ret_t rtk_led_groupConfig_get(rtk_led_group_t group, rtk_led_congig_t *pConfig);
+
+/* Function Name:
+ *      rtk_led_groupAbility_set
+ * Description:
+ *      Configure per group Led ability
+ * Input:
+ *      group    - LED group.
+ *      pAbility - LED ability
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      None.
+ */
+
+extern rtk_api_ret_t rtk_led_groupAbility_set(rtk_led_group_t group, rtk_led_ability_t *pAbility);
+
+/* Function Name:
+ *      rtk_led_groupAbility_get
+ * Description:
+ *      Get per group Led ability
+ * Input:
+ *      group    - LED group.
+ *      pAbility - LED ability
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      None.
+ */
+
+extern rtk_api_ret_t rtk_led_groupAbility_get(rtk_led_group_t group, rtk_led_ability_t *pAbility);
+
+/* Function Name:
+ *      rtk_led_serialMode_set
+ * Description:
+ *      Set Led serial mode active congiuration
+ * Input:
+ *      active - LED group.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can set LED serial mode active congiuration.
+ */
+extern rtk_api_ret_t rtk_led_serialMode_set(rtk_led_active_t active);
+
+/* Function Name:
+ *      rtk_led_serialMode_get
+ * Description:
+ *      Get Led group congiuration mode
+ * Input:
+ *      group - LED group.
+ * Output:
+ *      pConfig - LED configuration.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *       The API can get LED serial mode active configuration.
+ */
+extern rtk_api_ret_t rtk_led_serialMode_get(rtk_led_active_t *pActive);
+
+/* Function Name:
+ *      rtk_led_OutputEnable_set
+ * Description:
+ *      This API set LED I/O state.
+ * Input:
+ *      enabled     - LED I/O state
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set LED I/O state.
+ */
+extern rtk_api_ret_t rtk_led_OutputEnable_set(rtk_enable_t state);
+
+
+/* Function Name:
+ *      rtk_led_OutputEnable_get
+ * Description:
+ *      This API get LED I/O state.
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled        - LED I/O state
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set current LED I/O  state.
+ */
+extern rtk_api_ret_t rtk_led_OutputEnable_get(rtk_enable_t *pState);
+
+/* Function Name:
+ *      rtk_led_serialModePortmask_set
+ * Description:
+ *      This API configure Serial LED output Group and portmask
+ * Input:
+ *      output          - output group
+ *      pPortmask       - output portmask
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_led_serialModePortmask_set(rtk_led_serialOutput_t output, rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_led_serialModePortmask_get
+ * Description:
+ *      This API get Serial LED output Group and portmask
+ * Input:
+ *      None.
+ * Output:
+ *      pOutput         - output group
+ *      pPortmask       - output portmask
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_led_serialModePortmask_get(rtk_led_serialOutput_t *pOutput, rtk_portmask_t *pPortmask);
+
+#endif /* __RTK_API_LED_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/mirror.h b/drivers/net/phy/rtk/rtl8367c/include/mirror.h
new file mode 100644
index 0000000000000..f27ddbcea6cb5
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/mirror.h
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes Mirror module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_MIRROR_H__
+#define __RTK_API_MIRROR_H__
+
+typedef enum rtk_mirror_keep_e
+{
+    MIRROR_FOLLOW_VLAN = 0,
+    MIRROR_KEEP_ORIGINAL,
+    MIRROR_KEEP_END
+}rtk_mirror_keep_t;
+
+
+/* Function Name:
+ *      rtk_mirror_portBased_set
+ * Description:
+ *      Set port mirror function.
+ * Input:
+ *      mirroring_port          - Monitor port.
+ *      pMirrored_rx_portmask   - Rx mirror port mask.
+ *      pMirrored_tx_portmask   - Tx mirror port mask.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_PORT_MASK    - Invalid portmask.
+ * Note:
+ *      The API is to set mirror function of source port and mirror port.
+ *      The mirror port can only be set to one port and the TX and RX mirror ports
+ *      should be identical.
+ */
+extern rtk_api_ret_t rtk_mirror_portBased_set(rtk_port_t mirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask);
+
+/* Function Name:
+ *      rtk_mirror_portBased_get
+ * Description:
+ *      Get port mirror function.
+ * Input:
+ *      None
+ * Output:
+ *      pMirroring_port         - Monitor port.
+ *      pMirrored_rx_portmask   - Rx mirror port mask.
+ *      pMirrored_tx_portmask   - Tx mirror port mask.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API is to get mirror function of source port and mirror port.
+ */
+extern rtk_api_ret_t rtk_mirror_portBased_get(rtk_port_t* pMirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask);
+
+/* Function Name:
+ *      rtk_mirror_portIso_set
+ * Description:
+ *      Set mirror port isolation.
+ * Input:
+ *      enable |Mirror isolation status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      The API is to set mirror isolation function that prevent normal forwarding packets to miror port.
+ */
+extern rtk_api_ret_t rtk_mirror_portIso_set(rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_mirror_portIso_get
+ * Description:
+ *      Get mirror port isolation.
+ * Input:
+ *      None
+ * Output:
+ *      pEnable |Mirror isolation status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API is to get mirror isolation status.
+ */
+extern rtk_api_ret_t rtk_mirror_portIso_get(rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_mirror_vlanLeaky_set
+ * Description:
+ *      Set mirror VLAN leaky.
+ * Input:
+ *      txenable -TX leaky enable.
+ *      rxenable - RX leaky enable.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      The API is to set mirror VLAN leaky function forwarding packets to miror port.
+ */
+extern rtk_api_ret_t rtk_mirror_vlanLeaky_set(rtk_enable_t txenable, rtk_enable_t rxenable);
+
+
+/* Function Name:
+ *      rtk_mirror_vlanLeaky_get
+ * Description:
+ *      Get mirror VLAN leaky.
+ * Input:
+ *      None
+ * Output:
+ *      pTxenable - TX leaky enable.
+ *      pRxenable - RX leaky enable.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API is to get mirror VLAN leaky status.
+ */
+extern rtk_api_ret_t rtk_mirror_vlanLeaky_get(rtk_enable_t *pTxenable, rtk_enable_t *pRxenable);
+
+/* Function Name:
+ *      rtk_mirror_isolationLeaky_set
+ * Description:
+ *      Set mirror Isolation leaky.
+ * Input:
+ *      txenable -TX leaky enable.
+ *      rxenable - RX leaky enable.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      The API is to set mirror VLAN leaky function forwarding packets to miror port.
+ */
+extern rtk_api_ret_t rtk_mirror_isolationLeaky_set(rtk_enable_t txenable, rtk_enable_t rxenable);
+
+/* Function Name:
+ *      rtk_mirror_isolationLeaky_get
+ * Description:
+ *      Get mirror isolation leaky.
+ * Input:
+ *      None
+ * Output:
+ *      pTxenable - TX leaky enable.
+ *      pRxenable - RX leaky enable.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API is to get mirror isolation leaky status.
+ */
+extern rtk_api_ret_t rtk_mirror_isolationLeaky_get(rtk_enable_t *pTxenable, rtk_enable_t *pRxenable);
+
+/* Function Name:
+ *      rtk_mirror_keep_set
+ * Description:
+ *      Set mirror packet format keep.
+ * Input:
+ *      mode - -mirror keep mode.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      The API is to set  -mirror keep mode.
+ *      The mirror keep mode is as following:
+ *      - MIRROR_FOLLOW_VLAN
+ *      - MIRROR_KEEP_ORIGINAL
+ *      - MIRROR_KEEP_END
+ */
+extern rtk_api_ret_t rtk_mirror_keep_set(rtk_mirror_keep_t mode);
+
+
+/* Function Name:
+ *      rtk_mirror_keep_get
+ * Description:
+ *      Get mirror packet format keep.
+ * Input:
+ *      None
+ * Output:
+ *      pMode -mirror keep mode.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API is to get mirror keep mode.
+  *      The mirror keep mode is as following:
+ *      - MIRROR_FOLLOW_VLAN
+ *      - MIRROR_KEEP_ORIGINAL
+ *      - MIRROR_KEEP_END
+ */
+extern rtk_api_ret_t rtk_mirror_keep_get(rtk_mirror_keep_t *pMode);
+
+/* Function Name:
+ *      rtk_mirror_override_set
+ * Description:
+ *      Set port mirror override function.
+ * Input:
+ *      rxMirror        - 1: output mirrored packet, 0: output normal forward packet
+ *      txMirror        - 1: output mirrored packet, 0: output normal forward packet
+ *      aclMirror       - 1: output mirrored packet, 0: output normal forward packet
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      The API is to set mirror override function.
+ *      This function control the output format when a port output
+ *      normal forward & mirrored packet at the same time.
+ */
+extern rtk_api_ret_t rtk_mirror_override_set(rtk_enable_t rxMirror, rtk_enable_t txMirror, rtk_enable_t aclMirror);
+
+/* Function Name:
+ *      rtk_mirror_override_get
+ * Description:
+ *      Get port mirror override function.
+ * Input:
+ *      None
+ * Output:
+ *      pRxMirror       - 1: output mirrored packet, 0: output normal forward packet
+ *      pTxMirror       - 1: output mirrored packet, 0: output normal forward packet
+ *      pAclMirror      - 1: output mirrored packet, 0: output normal forward packet
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - Null Pointer
+ * Note:
+ *      The API is to Get mirror override function.
+ *      This function control the output format when a port output
+ *      normal forward & mirrored packet at the same time.
+ */
+extern rtk_api_ret_t rtk_mirror_override_get(rtk_enable_t *pRxMirror, rtk_enable_t *pTxMirror, rtk_enable_t *pAclMirror);
+
+#endif /* __RTK_API_MIRROR_H__ */
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/oam.h b/drivers/net/phy/rtk/rtl8367c/include/oam.h
new file mode 100644
index 0000000000000..bd7b8f6c295ef
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/oam.h
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes the following modules and sub-modules
+ *           (1) OAM (802.3ah) configuration
+ *
+ */
+
+#ifndef __RTK_OAM_H__
+#define __RTK_OAM_H__
+
+/*
+ * Symbol Definition
+ */
+
+
+/*
+ * Data Declaration
+ */
+
+
+/*
+ * Macro Declaration
+ */
+
+typedef enum rtk_oam_parser_act_e
+{
+    OAM_PARSER_ACTION_FORWARD = 0,
+    OAM_PARSER_ACTION_LOOPBACK,
+    OAM_PARSER_ACTION_DISCARD,
+    OAM_PARSER_ACTION_END,
+
+} rtk_oam_parser_act_t;
+
+typedef enum rtk_oam_multiplexer_act_e
+{
+    OAM_MULTIPLEXER_ACTION_FORWARD = 0,
+    OAM_MULTIPLEXER_ACTION_DISCARD,
+    OAM_MULTIPLEXER_ACTION_CPUONLY,
+    OAM_MULTIPLEXER_ACTION_END,
+
+} rtk_oam_multiplexer_act_t;
+
+
+/*
+ * Function Declaration
+ */
+
+/* Function Name:
+ *      rtk_oam_init
+ * Description:
+ *      Initialize oam module.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ * Note:
+ *      Must initialize oam module before calling any oam APIs.
+ */
+extern rtk_api_ret_t rtk_oam_init(void);
+
+/* Function Name:
+ *      rtk_oam_state_set
+ * Description:
+ *      This API set OAM state.
+ * Input:
+ *      enabled     -OAMstate
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set OAM state.
+ */
+extern rtk_api_ret_t rtk_oam_state_set(rtk_enable_t enabled);
+
+/* Function Name:
+ *      rtk_oam_state_get
+ * Description:
+ *      This API get OAM state.
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled        - H/W IGMP state
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set current OAM state.
+ */
+extern rtk_api_ret_t rtk_oam_state_get(rtk_enable_t *pEnabled);
+
+
+/* Module Name : OAM */
+
+/* Function Name:
+ *      rtk_oam_parserAction_set
+ * Description:
+ *      Set OAM parser action
+ * Input:
+ *      port    - port id
+ *      action  - parser action
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID      - invalid port id
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_oam_parserAction_set(rtk_port_t port, rtk_oam_parser_act_t action);
+
+/* Function Name:
+ *      rtk_oam_parserAction_set
+ * Description:
+ *      Get OAM parser action
+ * Input:
+ *      port    - port id
+ * Output:
+ *      pAction  - parser action
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID      - invalid port id
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_oam_parserAction_get(rtk_port_t port, rtk_oam_parser_act_t *pAction);
+
+
+/* Function Name:
+ *      rtk_oam_multiplexerAction_set
+ * Description:
+ *      Set OAM multiplexer action
+ * Input:
+ *      port    - port id
+ *      action  - parser action
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID      - invalid port id
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_oam_multiplexerAction_set(rtk_port_t port, rtk_oam_multiplexer_act_t action);
+
+/* Function Name:
+ *      rtk_oam_multiplexerAction_set
+ * Description:
+ *      Get OAM multiplexer action
+ * Input:
+ *      port    - port id
+ * Output:
+ *      pAction  - parser action
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID      - invalid port id
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_oam_multiplexerAction_get(rtk_port_t port, rtk_oam_multiplexer_act_t *pAction);
+
+
+#endif /* __RTK_OAM_H__ */
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/port.h b/drivers/net/phy/rtk/rtl8367c/include/port.h
new file mode 100644
index 0000000000000..4a80004d4eb4c
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/port.h
@@ -0,0 +1,959 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes port module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_PORT_H__
+#define __RTK_API_PORT_H__
+
+/*
+ * Data Type Declaration
+ */
+
+#define PHY_CONTROL_REG                             0
+#define PHY_STATUS_REG                              1
+#define PHY_AN_ADVERTISEMENT_REG                    4
+#define PHY_AN_LINKPARTNER_REG                      5
+#define PHY_1000_BASET_CONTROL_REG                  9
+#define PHY_1000_BASET_STATUS_REG                   10
+#define PHY_RESOLVED_REG                            26
+
+#define RTK_EFID_MAX                                0x7
+
+#define RTK_FIBER_FORCE_1000M                       3
+#define RTK_FIBER_FORCE_100M                        5
+#define RTK_FIBER_FORCE_100M1000M                   7
+
+#define RTK_INDRECT_ACCESS_CRTL                     0x1f00
+#define RTK_INDRECT_ACCESS_STATUS                   0x1f01
+#define RTK_INDRECT_ACCESS_ADDRESS                  0x1f02
+#define RTK_INDRECT_ACCESS_WRITE_DATA               0x1f03
+#define RTK_INDRECT_ACCESS_READ_DATA                0x1f04
+#define RTK_INDRECT_ACCESS_DELAY                    0x1f80
+#define RTK_INDRECT_ACCESS_BURST                    0x1f81
+#define RTK_RW_MASK                                 0x2
+#define RTK_CMD_MASK                                0x1
+#define RTK_PHY_BUSY_OFFSET                         2
+
+
+typedef enum rtk_mode_ext_e
+{
+    MODE_EXT_DISABLE = 0,
+    MODE_EXT_RGMII,
+    MODE_EXT_MII_MAC,
+    MODE_EXT_MII_PHY,
+    MODE_EXT_TMII_MAC,
+    MODE_EXT_TMII_PHY,
+    MODE_EXT_GMII,
+    MODE_EXT_RMII_MAC,
+    MODE_EXT_RMII_PHY,
+    MODE_EXT_SGMII,
+    MODE_EXT_HSGMII,
+    MODE_EXT_1000X_100FX,
+    MODE_EXT_1000X,
+    MODE_EXT_100FX,
+    MODE_EXT_RGMII_2,
+    MODE_EXT_MII_MAC_2,
+    MODE_EXT_MII_PHY_2,
+    MODE_EXT_TMII_MAC_2,
+    MODE_EXT_TMII_PHY_2,
+    MODE_EXT_RMII_MAC_2,
+    MODE_EXT_RMII_PHY_2,
+    MODE_EXT_END
+} rtk_mode_ext_t;
+
+typedef enum rtk_port_duplex_e
+{
+    PORT_HALF_DUPLEX = 0,
+    PORT_FULL_DUPLEX,
+    PORT_DUPLEX_END
+} rtk_port_duplex_t;
+
+typedef enum rtk_port_linkStatus_e
+{
+    PORT_LINKDOWN = 0,
+    PORT_LINKUP,
+    PORT_LINKSTATUS_END
+} rtk_port_linkStatus_t;
+
+typedef struct  rtk_port_mac_ability_s
+{
+    rtk_uint32 forcemode;
+    rtk_uint32 speed;
+    rtk_uint32 duplex;
+    rtk_uint32 link;
+    rtk_uint32 nway;
+    rtk_uint32 txpause;
+    rtk_uint32 rxpause;
+}rtk_port_mac_ability_t;
+
+typedef struct rtk_port_phy_ability_s
+{
+    rtk_uint32    AutoNegotiation;  /*PHY register 0.12 setting for auto-negotiation process*/
+    rtk_uint32    Half_10;          /*PHY register 4.5 setting for 10BASE-TX half duplex capable*/
+    rtk_uint32    Full_10;          /*PHY register 4.6 setting for 10BASE-TX full duplex capable*/
+    rtk_uint32    Half_100;         /*PHY register 4.7 setting for 100BASE-TX half duplex capable*/
+    rtk_uint32    Full_100;         /*PHY register 4.8 setting for 100BASE-TX full duplex capable*/
+    rtk_uint32    Full_1000;        /*PHY register 9.9 setting for 1000BASE-T full duplex capable*/
+    rtk_uint32    FC;               /*PHY register 4.10 setting for flow control capability*/
+    rtk_uint32    AsyFC;            /*PHY register 4.11 setting for  asymmetric flow control capability*/
+} rtk_port_phy_ability_t;
+
+typedef rtk_uint32  rtk_port_phy_data_t;     /* phy page  */
+
+typedef enum rtk_port_phy_mdix_mode_e
+{
+    PHY_AUTO_CROSSOVER_MODE= 0,
+    PHY_FORCE_MDI_MODE,
+    PHY_FORCE_MDIX_MODE,
+    PHY_FORCE_MODE_END
+} rtk_port_phy_mdix_mode_t;
+
+typedef enum rtk_port_phy_mdix_status_e
+{
+    PHY_STATUS_AUTO_MDI_MODE= 0,
+    PHY_STATUS_AUTO_MDIX_MODE,
+    PHY_STATUS_FORCE_MDI_MODE,
+    PHY_STATUS_FORCE_MDIX_MODE,
+    PHY_STATUS_FORCE_MODE_END
+} rtk_port_phy_mdix_status_t;
+
+typedef rtk_uint32  rtk_port_phy_page_t;     /* phy page  */
+
+typedef enum rtk_port_phy_reg_e
+{
+    PHY_REG_CONTROL             = 0,
+    PHY_REG_STATUS,
+    PHY_REG_IDENTIFIER_1,
+    PHY_REG_IDENTIFIER_2,
+    PHY_REG_AN_ADVERTISEMENT,
+    PHY_REG_AN_LINKPARTNER,
+    PHY_REG_1000_BASET_CONTROL  = 9,
+    PHY_REG_1000_BASET_STATUS,
+    PHY_REG_END                 = 32
+} rtk_port_phy_reg_t;
+
+typedef enum rtk_port_phy_test_mode_e
+{
+    PHY_TEST_MODE_NORMAL= 0,
+    PHY_TEST_MODE_1,
+    PHY_TEST_MODE_2,
+    PHY_TEST_MODE_3,
+    PHY_TEST_MODE_4,
+    PHY_TEST_MODE_END
+} rtk_port_phy_test_mode_t;
+
+typedef enum rtk_port_speed_e
+{
+    PORT_SPEED_10M = 0,
+    PORT_SPEED_100M,
+    PORT_SPEED_1000M,
+    PORT_SPEED_500M,
+    PORT_SPEED_2500M,
+    PORT_SPEED_END
+} rtk_port_speed_t;
+
+typedef enum rtk_port_media_e
+{
+    PORT_MEDIA_COPPER = 0,
+    PORT_MEDIA_FIBER,
+    PORT_MEDIA_END
+}rtk_port_media_t;
+
+typedef struct rtk_rtctResult_s
+{
+    rtk_port_speed_t    linkType;
+    union
+    {
+        struct fe_result_s
+        {
+            rtk_uint32      isRxShort;
+            rtk_uint32      isTxShort;
+            rtk_uint32      isRxOpen;
+            rtk_uint32      isTxOpen;
+            rtk_uint32      isRxMismatch;
+            rtk_uint32      isTxMismatch;
+            rtk_uint32      isRxLinedriver;
+            rtk_uint32      isTxLinedriver;
+            rtk_uint32      rxLen;
+            rtk_uint32      txLen;
+        } fe_result;
+
+        struct ge_result_s
+        {
+            rtk_uint32      channelAShort;
+            rtk_uint32      channelBShort;
+            rtk_uint32      channelCShort;
+            rtk_uint32      channelDShort;
+
+            rtk_uint32      channelAOpen;
+            rtk_uint32      channelBOpen;
+            rtk_uint32      channelCOpen;
+            rtk_uint32      channelDOpen;
+
+            rtk_uint32      channelAMismatch;
+            rtk_uint32      channelBMismatch;
+            rtk_uint32      channelCMismatch;
+            rtk_uint32      channelDMismatch;
+
+            rtk_uint32      channelALinedriver;
+            rtk_uint32      channelBLinedriver;
+            rtk_uint32      channelCLinedriver;
+            rtk_uint32      channelDLinedriver;
+
+            rtk_uint32      channelALen;
+            rtk_uint32      channelBLen;
+            rtk_uint32      channelCLen;
+            rtk_uint32      channelDLen;
+        } ge_result;
+    }result;
+} rtk_rtctResult_t;
+
+/* Function Name:
+ *      rtk_port_phyAutoNegoAbility_set
+ * Description:
+ *      Set ethernet PHY auto-negotiation desired ability.
+ * Input:
+ *      port        - port id.
+ *      pAbility    - Ability structure
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      If Full_1000 bit is set to 1, the AutoNegotiation will be automatic set to 1. While both AutoNegotiation and Full_1000 are set to 0, the PHY speed and duplex selection will
+ *      be set as following 100F > 100H > 10F > 10H priority sequence.
+ */
+extern rtk_api_ret_t rtk_port_phyAutoNegoAbility_set(rtk_port_t port, rtk_port_phy_ability_t *pAbility);
+
+/* Function Name:
+ *      rtk_port_phyAutoNegoAbility_get
+ * Description:
+ *      Get PHY ability through PHY registers.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pAbility - Ability structure
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      Get the capablity of specified PHY.
+ */
+extern rtk_api_ret_t rtk_port_phyAutoNegoAbility_get(rtk_port_t port, rtk_port_phy_ability_t *pAbility);
+
+/* Function Name:
+ *      rtk_port_phyForceModeAbility_set
+ * Description:
+ *      Set the port speed/duplex mode/pause/asy_pause in the PHY force mode.
+ * Input:
+ *      port        - port id.
+ *      pAbility    - Ability structure
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      While both AutoNegotiation and Full_1000 are set to 0, the PHY speed and duplex selection will
+ *      be set as following 100F > 100H > 10F > 10H priority sequence.
+ */
+extern rtk_api_ret_t rtk_port_phyForceModeAbility_set(rtk_port_t port, rtk_port_phy_ability_t *pAbility);
+
+/* Function Name:
+ *      rtk_port_phyForceModeAbility_get
+ * Description:
+ *      Get PHY ability through PHY registers.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pAbility - Ability structure
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      Get the capablity of specified PHY.
+ */
+extern rtk_api_ret_t rtk_port_phyForceModeAbility_get(rtk_port_t port, rtk_port_phy_ability_t *pAbility);
+
+/* Function Name:
+ *      rtk_port_phyStatus_get
+ * Description:
+ *      Get ethernet PHY linking status
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      linkStatus  - PHY link status
+ *      speed       - PHY link speed
+ *      duplex      - PHY duplex mode
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      API will return auto negotiation status of phy.
+ */
+extern rtk_api_ret_t rtk_port_phyStatus_get(rtk_port_t port, rtk_port_linkStatus_t *pLinkStatus, rtk_port_speed_t *pSpeed, rtk_port_duplex_t *pDuplex);
+
+/* Function Name:
+ *      rtk_port_macForceLink_set
+ * Description:
+ *      Set port force linking configuration.
+ * Input:
+ *      port            - port id.
+ *      pPortability    - port ability configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can set Port/MAC force mode properties.
+ */
+extern rtk_api_ret_t rtk_port_macForceLink_set(rtk_port_t port, rtk_port_mac_ability_t *pPortability);
+
+/* Function Name:
+ *      rtk_port_macForceLink_get
+ * Description:
+ *      Get port force linking configuration.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPortability - port ability configuration
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get Port/MAC force mode properties.
+ */
+extern rtk_api_ret_t rtk_port_macForceLink_get(rtk_port_t port, rtk_port_mac_ability_t *pPortability);
+
+/* Function Name:
+ *      rtk_port_macForceLinkExt_set
+ * Description:
+ *      Set external interface force linking configuration.
+ * Input:
+ *      port            - external port ID
+ *      mode            - external interface mode
+ *      pPortability    - port ability configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can set external interface force mode properties.
+ *      The external interface can be set to:
+ *      - MODE_EXT_DISABLE,
+ *      - MODE_EXT_RGMII,
+ *      - MODE_EXT_MII_MAC,
+ *      - MODE_EXT_MII_PHY,
+ *      - MODE_EXT_TMII_MAC,
+ *      - MODE_EXT_TMII_PHY,
+ *      - MODE_EXT_GMII,
+ *      - MODE_EXT_RMII_MAC,
+ *      - MODE_EXT_RMII_PHY,
+ *      - MODE_EXT_SGMII,
+ *      - MODE_EXT_HSGMII,
+ *      - MODE_EXT_1000X_100FX,
+ *      - MODE_EXT_1000X,
+ *      - MODE_EXT_100FX,
+ */
+extern rtk_api_ret_t rtk_port_macForceLinkExt_set(rtk_port_t port, rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability);
+
+/* Function Name:
+ *      rtk_port_macForceLinkExt_get
+ * Description:
+ *      Set external interface force linking configuration.
+ * Input:
+ *      port            - external port ID
+ * Output:
+ *      pMode           - external interface mode
+ *      pPortability    - port ability configuration
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get external interface force mode properties.
+ */
+extern rtk_api_ret_t rtk_port_macForceLinkExt_get(rtk_port_t port, rtk_mode_ext_t *pMode, rtk_port_mac_ability_t *pPortability);
+
+/* Function Name:
+ *      rtk_port_macStatus_get
+ * Description:
+ *      Get port link status.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPortstatus - port ability configuration
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can get Port/PHY properties.
+ */
+extern rtk_api_ret_t rtk_port_macStatus_get(rtk_port_t port, rtk_port_mac_ability_t *pPortstatus);
+
+/* Function Name:
+ *      rtk_port_macLocalLoopbackEnable_set
+ * Description:
+ *      Set Port Local Loopback. (Redirect TX to RX.)
+ * Input:
+ *      port    - Port id.
+ *      enable  - Loopback state, 0:disable, 1:enable
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can enable/disable Local loopback in MAC.
+ *      For UTP port, This API will also enable the digital
+ *      loopback bit in PHY register for sync of speed between
+ *      PHY and MAC. For EXT port, users need to force the
+ *      link state by themself.
+ */
+extern rtk_api_ret_t rtk_port_macLocalLoopbackEnable_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_port_macLocalLoopbackEnable_get
+ * Description:
+ *      Get Port Local Loopback. (Redirect TX to RX.)
+ * Input:
+ *      port    - Port id.
+ * Output:
+ *      pEnable  - Loopback state, 0:disable, 1:enable
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_port_macLocalLoopbackEnable_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_port_phyReg_set
+ * Description:
+ *      Set PHY register data of the specific port.
+ * Input:
+ *      port    - port id.
+ *      reg     - Register id
+ *      regData - Register data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      This API can set PHY register data of the specific port.
+ */
+extern rtk_api_ret_t rtk_port_phyReg_set(rtk_port_t port, rtk_port_phy_reg_t reg, rtk_port_phy_data_t value);
+
+/* Function Name:
+ *      rtk_port_phyReg_get
+ * Description:
+ *      Get PHY register data of the specific port.
+ * Input:
+ *      port    - Port id.
+ *      reg     - Register id
+ * Output:
+ *      pData   - Register data
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      This API can get PHY register data of the specific port.
+ */
+extern rtk_api_ret_t rtk_port_phyReg_get(rtk_port_t port, rtk_port_phy_reg_t reg, rtk_port_phy_data_t *pData);
+
+/* Function Name:
+ *      rtk_port_backpressureEnable_set
+ * Description:
+ *      Set the half duplex backpressure enable status of the specific port.
+ * Input:
+ *      port    - port id.
+ *      enable  - Back pressure status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      This API can set the half duplex backpressure enable status of the specific port.
+ *      The half duplex backpressure enable status of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+extern rtk_api_ret_t rtk_port_backpressureEnable_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_port_backpressureEnable_get
+ * Description:
+ *      Get the half duplex backpressure enable status of the specific port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - Back pressure status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can get the half duplex backpressure enable status of the specific port.
+ *      The half duplex backpressure enable status of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+extern rtk_api_ret_t rtk_port_backpressureEnable_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_port_adminEnable_set
+ * Description:
+ *      Set port admin configuration of the specific port.
+ * Input:
+ *      port    - port id.
+ *      enable  - Back pressure status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      This API can set port admin configuration of the specific port.
+ *      The port admin configuration of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+extern rtk_api_ret_t rtk_port_adminEnable_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_port_adminEnable_get
+ * Description:
+ *      Get port admin configurationof the specific port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - Back pressure status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can get port admin configuration of the specific port.
+ *      The port admin configuration of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+extern rtk_api_ret_t rtk_port_adminEnable_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_port_isolation_set
+ * Description:
+ *      Set permitted port isolation portmask
+ * Input:
+ *      port         - port id.
+ *      pPortmask    - Permit port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_PORT_MASK    - Invalid portmask.
+ * Note:
+ *      This API set the port mask that a port can trasmit packet to of each port
+ *      A port can only transmit packet to ports included in permitted portmask
+ */
+extern rtk_api_ret_t rtk_port_isolation_set(rtk_port_t port, rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_port_isolation_get
+ * Description:
+ *      Get permitted port isolation portmask
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPortmask - Permit port mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API get the port mask that a port can trasmit packet to of each port
+ *      A port can only transmit packet to ports included in permitted portmask
+ */
+extern rtk_api_ret_t rtk_port_isolation_get(rtk_port_t port, rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_port_rgmiiDelayExt_set
+ * Description:
+ *      Set RGMII interface delay value for TX and RX.
+ * Input:
+ *      txDelay - TX delay value, 1 for delay 2ns and 0 for no-delay
+ *      rxDelay - RX delay value, 0~7 for delay setup.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can set external interface 2 RGMII delay.
+ *      In TX delay, there are 2 selection: no-delay and 2ns delay.
+ *      In RX dekay, there are 8 steps for delay tunning. 0 for no-delay, and 7 for maximum delay.
+ */
+extern rtk_api_ret_t rtk_port_rgmiiDelayExt_set(rtk_port_t port, rtk_data_t txDelay, rtk_data_t rxDelay);
+
+/* Function Name:
+ *      rtk_port_rgmiiDelayExt_get
+ * Description:
+ *      Get RGMII interface delay value for TX and RX.
+ * Input:
+ *      None
+ * Output:
+ *      pTxDelay - TX delay value
+ *      pRxDelay - RX delay value
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can set external interface 2 RGMII delay.
+ *      In TX delay, there are 2 selection: no-delay and 2ns delay.
+ *      In RX dekay, there are 8 steps for delay tunning. 0 for n0-delay, and 7 for maximum delay.
+ */
+extern rtk_api_ret_t rtk_port_rgmiiDelayExt_get(rtk_port_t port, rtk_data_t *pTxDelay, rtk_data_t *pRxDelay);
+
+/* Function Name:
+ *      rtk_port_phyEnableAll_set
+ * Description:
+ *      Set all PHY enable status.
+ * Input:
+ *      enable - PHY Enable State.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      This API can set all PHY status.
+ *      The configuration of all PHY is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+extern rtk_api_ret_t rtk_port_phyEnableAll_set(rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_port_phyEnableAll_get
+ * Description:
+ *      Get all PHY enable status.
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - PHY Enable State.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      This API can set all PHY status.
+ *      The configuration of all PHY is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+extern rtk_api_ret_t rtk_port_phyEnableAll_get(rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_port_efid_set
+ * Description:
+ *      Set port-based enhanced filtering database
+ * Input:
+ *      port - Port id.
+ *      efid - Specified enhanced filtering database.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_L2_FID - Invalid fid.
+ *      RT_ERR_INPUT - Invalid input parameter.
+ *      RT_ERR_PORT_ID - Invalid port ID.
+ * Note:
+ *      The API can set port-based enhanced filtering database.
+ */
+extern rtk_api_ret_t rtk_port_efid_set(rtk_port_t port, rtk_data_t efid);
+
+/* Function Name:
+ *      rtk_port_efid_get
+ * Description:
+ *      Get port-based enhanced filtering database
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEfid - Specified enhanced filtering database.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT - Invalid input parameters.
+ *      RT_ERR_PORT_ID - Invalid port ID.
+ * Note:
+ *      The API can get port-based enhanced filtering database status.
+ */
+extern rtk_api_ret_t rtk_port_efid_get(rtk_port_t port, rtk_data_t *pEfid);
+
+/* Function Name:
+ *      rtk_port_phyComboPortMedia_set
+ * Description:
+ *      Set Combo port media type
+ * Input:
+ *      port    - Port id. (Should be Port 4)
+ *      media   - Media (COPPER or FIBER)
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_PORT_ID          - Invalid port ID.
+ * Note:
+ *      The API can Set Combo port media type.
+ */
+extern rtk_api_ret_t rtk_port_phyComboPortMedia_set(rtk_port_t port, rtk_port_media_t media);
+
+/* Function Name:
+ *      rtk_port_phyComboPortMedia_get
+ * Description:
+ *      Get Combo port media type
+ * Input:
+ *      port    - Port id. (Should be Port 4)
+ * Output:
+ *      pMedia  - Media (COPPER or FIBER)
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_PORT_ID          - Invalid port ID.
+ * Note:
+ *      The API can Set Combo port media type.
+ */
+extern rtk_api_ret_t rtk_port_phyComboPortMedia_get(rtk_port_t port, rtk_port_media_t *pMedia);
+
+/* Function Name:
+ *      rtk_port_rtctEnable_set
+ * Description:
+ *      Enable RTCT test
+ * Input:
+ *      pPortmask    - Port mask of RTCT enabled port
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_MASK        - Invalid port mask.
+ * Note:
+ *      The API can enable RTCT Test
+ */
+extern rtk_api_ret_t rtk_port_rtctEnable_set(rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_port_rtctDisable_set
+ * Description:
+ *      Disable RTCT test
+ * Input:
+ *      pPortmask    - Port mask of RTCT disabled port
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_MASK        - Invalid port mask.
+ * Note:
+ *      The API can disable RTCT Test
+ */
+rtk_api_ret_t rtk_port_rtctDisable_set(rtk_portmask_t *pPortmask);
+
+
+/* Function Name:
+ *      rtk_port_rtctResult_get
+ * Description:
+ *      Get the result of RTCT test
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      pRtctResult - The result of RTCT result
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port ID.
+ *      RT_ERR_PHY_RTCT_NOT_FINISH  - Testing does not finish.
+ * Note:
+ *      The API can get RTCT test result.
+ *      RTCT test may takes 4.8 seconds to finish its test at most.
+ *      Thus, if this API return RT_ERR_PHY_RTCT_NOT_FINISH or
+ *      other error code, the result can not be referenced and
+ *      user should call this API again until this API returns
+ *      a RT_ERR_OK.
+ *      The result is stored at pRtctResult->ge_result
+ *      pRtctResult->linkType is unused.
+ *      The unit of channel length is 2.5cm. Ex. 300 means 300 * 2.5 = 750cm = 7.5M
+ */
+extern rtk_api_ret_t rtk_port_rtctResult_get(rtk_port_t port, rtk_rtctResult_t *pRtctResult);
+
+/* Function Name:
+ *      rtk_port_sds_reset
+ * Description:
+ *      Reset Serdes
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port ID.
+ * Note:
+ *      The API can reset Serdes
+ */
+extern rtk_api_ret_t rtk_port_sds_reset(rtk_port_t port);
+
+/* Function Name:
+ *      rtk_port_sgmiiLinkStatus_get
+ * Description:
+ *      Get SGMII status
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      pSignalDetect   - Signal detect
+ *      pSync           - Sync
+ *      pLink           - Link
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port ID.
+ * Note:
+ *      The API can reset Serdes
+ */
+extern rtk_api_ret_t rtk_port_sgmiiLinkStatus_get(rtk_port_t port, rtk_data_t *pSignalDetect, rtk_data_t *pSync, rtk_port_linkStatus_t *pLink);
+
+/* Function Name:
+ *      rtk_port_sgmiiNway_set
+ * Description:
+ *      Configure SGMII/HSGMII port Nway state
+ * Input:
+ *      port        - Port ID
+ *      state       - Nway state
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port ID.
+ * Note:
+ *      The API configure SGMII/HSGMII port Nway state
+ */
+extern rtk_api_ret_t rtk_port_sgmiiNway_set(rtk_port_t port, rtk_enable_t state);
+
+/* Function Name:
+ *      rtk_port_sgmiiNway_get
+ * Description:
+ *      Get SGMII/HSGMII port Nway state
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      pState      - Nway state
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port ID.
+ * Note:
+ *      The API can get SGMII/HSGMII port Nway state
+ */
+extern rtk_api_ret_t rtk_port_sgmiiNway_get(rtk_port_t port, rtk_enable_t *pState);
+
+#endif /* __RTK_API_PORT_H__ */
+
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/ptp.h b/drivers/net/phy/rtk/rtl8367c/include/ptp.h
new file mode 100644
index 0000000000000..edb2355091e99
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/ptp.h
@@ -0,0 +1,511 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes time module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_PTP_H__
+#define __RTK_API_PTP_H__
+
+/*
+ * Symbol Definition
+ */
+#define RTK_MAX_NUM_OF_NANO_SECOND                     0x3B9AC9FF
+#define RTK_PTP_INTR_MASK                                          0xFF
+#define RTK_MAX_NUM_OF_TPID                                    0xFFFF
+
+/* Message Type */
+typedef enum rtk_ptp_msgType_e
+{
+    PTP_MSG_TYPE_TX_SYNC = 0,
+    PTP_MSG_TYPE_TX_DELAY_REQ,
+    PTP_MSG_TYPE_TX_PDELAY_REQ,
+    PTP_MSG_TYPE_TX_PDELAY_RESP,
+    PTP_MSG_TYPE_RX_SYNC,
+    PTP_MSG_TYPE_RX_DELAY_REQ,
+    PTP_MSG_TYPE_RX_PDELAY_REQ,
+    PTP_MSG_TYPE_RX_PDELAY_RESP,
+    PTP_MSG_TYPE_END
+} rtk_ptp_msgType_t;
+
+typedef enum rtk_ptp_intType_e
+{
+    PTP_INT_TYPE_TX_SYNC = 0,
+    PTP_INT_TYPE_TX_DELAY_REQ,
+    PTP_INT_TYPE_TX_PDELAY_REQ,
+    PTP_INT_TYPE_TX_PDELAY_RESP,
+    PTP_INT_TYPE_RX_SYNC,
+    PTP_INT_TYPE_RX_DELAY_REQ,
+    PTP_INT_TYPE_RX_PDELAY_REQ,
+    PTP_INT_TYPE_RX_PDELAY_RESP,
+    PTP_INT_TYPE_ALL,
+    PTP_INT_TYPE_END
+}rtk_ptp_intType_t;
+
+typedef enum rtk_ptp_sys_adjust_e
+{
+    SYS_ADJUST_PLUS = 0,
+    SYS_ADJUST_MINUS,
+    SYS_ADJUST_END
+} rtk_ptp_sys_adjust_t;
+
+
+/* Reference Time */
+typedef struct rtk_ptp_timeStamp_s
+{
+    rtk_uint32 sec;
+    rtk_uint32 nsec;
+} rtk_ptp_timeStamp_t;
+
+typedef struct rtk_ptp_info_s
+{
+    rtk_uint32 sequenceId;
+    rtk_ptp_timeStamp_t   timeStamp;
+} rtk_ptp_info_t;
+
+typedef rtk_uint32 rtk_ptp_tpid_t;
+
+typedef rtk_uint32  rtk_ptp_intStatus_t;     /* interrupt status mask  */
+
+/*
+ * Data Declaration
+ */
+
+/*
+ * Function Declaration
+ */
+/* Function Name:
+ *      rtk_time_init
+ * Description:
+ *      PTP function initialization.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API is used to initialize EEE status.
+ */
+extern rtk_api_ret_t rtk_ptp_init(void);
+
+/* Function Name:
+ *      rtk_ptp_mac_set
+ * Description:
+ *      Configure PTP mac address.
+ * Input:
+ *      mac - mac address to parser PTP packets.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_mac_set(rtk_mac_t mac);
+
+/* Function Name:
+ *      rtk_ptp_mac_get
+ * Description:
+ *      Get PTP mac address.
+ * Input:
+ *      None
+ * Output:
+ *      pMac - mac address to parser PTP packets.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_mac_get(rtk_mac_t *pMac);
+
+/* Function Name:
+ *      rtk_ptp_tpid_set
+ * Description:
+ *      Configure PTP accepted outer & inner tag TPID.
+ * Input:
+ *      outerId - Ether type of S-tag frame parsing in PTP ports.
+ *      innerId - Ether type of C-tag frame parsing in PTP ports.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_tpid_set(rtk_ptp_tpid_t outerId, rtk_ptp_tpid_t innerId);
+
+/* Function Name:
+ *      rtk_ptp_tpid_get
+ * Description:
+ *      Get PTP accepted outer & inner tag TPID.
+ * Input:
+ *      None
+ * Output:
+ *      pOuterId - Ether type of S-tag frame parsing in PTP ports.
+ *      pInnerId - Ether type of C-tag frame parsing in PTP ports.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_tpid_get(rtk_ptp_tpid_t *pOuterId, rtk_ptp_tpid_t *pInnerId);
+
+/* Function Name:
+ *      rtk_ptp_refTime_set
+ * Description:
+ *      Set the reference time of the specified device.
+ * Input:
+ *      timeStamp - reference timestamp value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT    - invalid input parameter
+ * Applicable:
+ *      8390, 8380
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_refTime_set(rtk_ptp_timeStamp_t timeStamp);
+
+/* Function Name:
+ *      rtk_ptp_refTime_get
+ * Description:
+ *      Get the reference time of the specified device.
+ * Input:
+ * Output:
+ *      pTimeStamp - pointer buffer of the reference time
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID      - invalid unit id
+ *      RT_ERR_NOT_INIT     - The module is not initial
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Applicable:
+ *      8390, 8380
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_refTime_get(rtk_ptp_timeStamp_t *pTimeStamp);
+
+/* Function Name:
+ *      rtk_ptp_refTimeAdjust_set
+ * Description:
+ *      Adjust the reference time.
+ * Input:
+ *      unit      - unit id
+ *      sign      - significant
+ *      timeStamp - reference timestamp value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID  - invalid unit id
+ *      RT_ERR_NOT_INIT - The module is not initial
+ *      RT_ERR_INPUT    - invalid input parameter
+ * Note:
+ *      sign=0 for positive adjustment, sign=1 for negative adjustment.
+ */
+extern rtk_api_ret_t rtk_ptp_refTimeAdjust_set(rtk_ptp_sys_adjust_t sign, rtk_ptp_timeStamp_t timeStamp);
+
+/* Function Name:
+ *      rtk_ptp_refTimeEnable_set
+ * Description:
+ *      Set the enable state of reference time of the specified device.
+ * Input:
+ *      enable - status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT    - invalid input parameter
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_refTimeEnable_set(rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_ptp_refTimeEnable_get
+ * Description:
+ *      Get the enable state of reference time of the specified device.
+ * Input:
+ * Output:
+ *      pEnable - status
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID      - invalid unit id
+ *      RT_ERR_NOT_INIT     - The module is not initial
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Applicable:
+ *      8390, 8380
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_refTimeEnable_get(rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_ptp_portEnable_set
+ * Description:
+ *      Set PTP status of the specified port.
+ * Input:
+ *      port   - port id
+ *      enable - status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT     - invalid port id
+ *      RT_ERR_INPUT    - invalid input parameter
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_portEnable_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_ptp_portEnable_get
+ * Description:
+ *      Get PTP status of the specified port.
+ * Input:
+ *      port    - port id
+ * Output:
+ *      pEnable - status
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT         - invalid port id
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_portEnable_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_ptp_portTimestamp_get
+ * Description:
+ *      Get PTP timstamp according to the PTP identifier on the dedicated port from the specified device.
+ * Input:
+ *      unit       - unit id
+ *      port       - port id
+ *      type       - PTP message type
+ * Output:
+ *      pInfo      - pointer buffer of sequence ID and timestamp
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID      - invalid port id
+ *      RT_ERR_INPUT        - invalid input parameter
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Applicable:
+ *      8390, 8380
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_portTimestamp_get( rtk_port_t port, rtk_ptp_msgType_t type, rtk_ptp_info_t *pInfo);
+
+/* Function Name:
+ *      rtk_ptp_intControl_set
+ * Description:
+ *      Set PTP interrupt trigger status configuration.
+ * Input:
+ *      type - Interrupt type.
+ *      enable - Interrupt status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      The API can set PTP interrupt status configuration.
+ *      The interrupt trigger status is shown in the following:
+ *          PTP_INT_TYPE_TX_SYNC = 0,
+ *          PTP_INT_TYPE_TX_DELAY_REQ,
+ *          PTP_INT_TYPE_TX_PDELAY_REQ,
+ *          PTP_INT_TYPE_TX_PDELAY_RESP,
+ *          PTP_INT_TYPE_RX_SYNC,
+ *          PTP_INT_TYPE_RX_DELAY_REQ,
+ *          PTP_INT_TYPE_RX_PDELAY_REQ,
+ *          PTP_INT_TYPE_RX_PDELAY_RESP,
+ *          PTP_INT_TYPE_ALL,
+ */
+extern rtk_api_ret_t rtk_ptp_intControl_set(rtk_ptp_intType_t type, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_ptp_intControl_get
+ * Description:
+ *      Get PTP interrupt trigger status configuration.
+ * Input:
+ *      type - Interrupt type.
+ * Output:
+ *      pEnable - Interrupt status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get interrupt status configuration.
+ *      The interrupt trigger status is shown in the following:
+ *          PTP_INT_TYPE_TX_SYNC = 0,
+ *          PTP_INT_TYPE_TX_DELAY_REQ,
+ *          PTP_INT_TYPE_TX_PDELAY_REQ,
+ *          PTP_INT_TYPE_TX_PDELAY_RESP,
+ *          PTP_INT_TYPE_RX_SYNC,
+ *          PTP_INT_TYPE_RX_DELAY_REQ,
+ *          PTP_INT_TYPE_RX_PDELAY_REQ,
+ *          PTP_INT_TYPE_RX_PDELAY_RESP,
+ */
+extern rtk_api_ret_t rtk_ptp_intControl_get(rtk_ptp_intType_t type, rtk_enable_t *pEnable);
+
+
+/* Function Name:
+ *      rtk_ptp_intStatus_get
+ * Description:
+ *      Get PTP port interrupt trigger status.
+ * Input:
+ *      port           - physical port
+ * Output:
+ *      pStatusMask - Interrupt status bit mask.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get interrupt trigger status when interrupt happened.
+ *      The interrupt trigger status is shown in the following:
+ *      - PORT 0  INT    (value[0] (Bit0))
+ *      - PORT 1  INT    (value[0] (Bit1))
+ *      - PORT 2  INT    (value[0] (Bit2))
+ *      - PORT 3  INT    (value[0] (Bit3))
+ *      - PORT 4  INT   (value[0] (Bit4))
+
+ *
+ */
+extern rtk_api_ret_t rtk_ptp_intStatus_get(rtk_ptp_intStatus_t *pStatusMask);
+
+/* Function Name:
+ *      rtk_ptp_portIntStatus_set
+ * Description:
+ *      Set PTP port interrupt trigger status to clean.
+ * Input:
+ *      port           - physical port
+ *      statusMask - Interrupt status bit mask.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT - Invalid input parameters.
+ * Note:
+ *      The API can clean interrupt trigger status when interrupt happened.
+ *      The interrupt trigger status is shown in the following:
+ *      - PTP_INT_TYPE_TX_SYNC              (value[0] (Bit0))
+ *      - PTP_INT_TYPE_TX_DELAY_REQ      (value[0] (Bit1))
+ *      - PTP_INT_TYPE_TX_PDELAY_REQ    (value[0] (Bit2))
+ *      - PTP_INT_TYPE_TX_PDELAY_RESP   (value[0] (Bit3))
+ *      - PTP_INT_TYPE_RX_SYNC              (value[0] (Bit4))
+ *      - PTP_INT_TYPE_RX_DELAY_REQ      (value[0] (Bit5))
+ *      - PTP_INT_TYPE_RX_PDELAY_REQ    (value[0] (Bit6))
+ *      - PTP_INT_TYPE_RX_PDELAY_RESP   (value[0] (Bit7))
+ *      The status will be cleared after execute this API.
+ */
+extern rtk_api_ret_t rtk_ptp_portIntStatus_set(rtk_port_t port, rtk_ptp_intStatus_t statusMask);
+
+/* Function Name:
+ *      rtk_ptp_portIntStatus_get
+ * Description:
+ *      Get PTP port interrupt trigger status.
+ * Input:
+ *      port           - physical port
+ * Output:
+ *      pStatusMask - Interrupt status bit mask.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get interrupt trigger status when interrupt happened.
+ *      The interrupt trigger status is shown in the following:
+ *      - PTP_INT_TYPE_TX_SYNC              (value[0] (Bit0))
+ *      - PTP_INT_TYPE_TX_DELAY_REQ      (value[0] (Bit1))
+ *      - PTP_INT_TYPE_TX_PDELAY_REQ    (value[0] (Bit2))
+ *      - PTP_INT_TYPE_TX_PDELAY_RESP   (value[0] (Bit3))
+ *      - PTP_INT_TYPE_RX_SYNC              (value[0] (Bit4))
+ *      - PTP_INT_TYPE_RX_DELAY_REQ      (value[0] (Bit5))
+ *      - PTP_INT_TYPE_RX_PDELAY_REQ    (value[0] (Bit6))
+ *      - PTP_INT_TYPE_RX_PDELAY_RESP   (value[0] (Bit7))
+ *
+ */
+extern rtk_api_ret_t rtk_ptp_portIntStatus_get(rtk_port_t port, rtk_ptp_intStatus_t *pStatusMask);
+
+/* Function Name:
+ *      rtk_ptp_portPtpTrap_set
+ * Description:
+ *      Set PTP packet trap of the specified port.
+ * Input:
+ *      port   - port id
+ *      enable - status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT     - invalid port id
+ *      RT_ERR_INPUT    - invalid input parameter
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_portTrap_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_ptp_portPtpEnable_get
+ * Description:
+ *      Get PTP packet trap of the specified port.
+ * Input:
+ *      port    - port id
+ * Output:
+ *      pEnable - status
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT         - invalid port id
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_ptp_portTrap_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+#endif /* __RTK_API_PTP_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/qos.h b/drivers/net/phy/rtk/rtl8367c/include/qos.h
new file mode 100644
index 0000000000000..9cd9674fa3cc5
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/qos.h
@@ -0,0 +1,781 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes QoS module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_QOS_H__
+#define __RTK_API_QOS_H__
+
+/*
+ * Data Type Declaration
+ */
+#define QOS_DEFAULT_TICK_PERIOD                     (19-1)
+#define QOS_DEFAULT_BYTE_PER_TOKEN                  34
+#define QOS_DEFAULT_LK_THRESHOLD                    (34*3) /* Why use 0x400? */
+
+
+#define QOS_DEFAULT_INGRESS_BANDWIDTH               0x3FFF /* 0x3FFF => unlimit */
+#define QOS_DEFAULT_EGRESS_BANDWIDTH                0x3D08 /*( 0x3D08 + 1) * 64Kbps => 1Gbps*/
+#define QOS_DEFAULT_PREIFP                          1
+#define QOS_DEFAULT_PACKET_USED_PAGES_FC            0x60
+#define QOS_DEFAULT_PACKET_USED_FC_EN               0
+#define QOS_DEFAULT_QUEUE_BASED_FC_EN               1
+
+#define QOS_DEFAULT_PRIORITY_SELECT_PORT            8
+#define QOS_DEFAULT_PRIORITY_SELECT_1Q              0
+#define QOS_DEFAULT_PRIORITY_SELECT_ACL             0
+#define QOS_DEFAULT_PRIORITY_SELECT_DSCP            0
+
+#define QOS_DEFAULT_DSCP_MAPPING_PRIORITY           0
+
+#define QOS_DEFAULT_1Q_REMARKING_ABILITY            0
+#define QOS_DEFAULT_DSCP_REMARKING_ABILITY          0
+#define QOS_DEFAULT_QUEUE_GAP                       20
+#define QOS_DEFAULT_QUEUE_NO_MAX                    6
+#define QOS_DEFAULT_AVERAGE_PACKET_RATE             0x3FFF
+#define QOS_DEFAULT_BURST_SIZE_IN_APR               0x3F
+#define QOS_DEFAULT_PEAK_PACKET_RATE                2
+#define QOS_DEFAULT_SCHEDULER_ABILITY_APR           1     /*disable*/
+#define QOS_DEFAULT_SCHEDULER_ABILITY_PPR           1    /*disable*/
+#define QOS_DEFAULT_SCHEDULER_ABILITY_WFQ           1    /*disable*/
+
+#define QOS_WEIGHT_MAX                              127
+
+#define RTK_MAX_NUM_OF_PRIORITY                     8
+#define RTK_MAX_NUM_OF_QUEUE                        8
+
+#define RTK_PRIMAX                                             7
+#define RTK_QIDMAX                                             7
+#define RTK_DSCPMAX                                         63
+
+
+/* enum Priority Selection Index */
+typedef enum rtk_qos_priDecTbl_e
+{
+    PRIDECTBL_IDX0 = 0,
+    PRIDECTBL_IDX1,
+    PRIDECTBL_END,
+}rtk_qos_priDecTbl_t;
+
+
+/* Types of 802.1p remarking source */
+typedef enum rtk_qos_1pRmkSrc_e
+{
+    DOT1P_RMK_SRC_USER_PRI,
+    DOT1P_RMK_SRC_TAG_PRI,
+    DOT1P_RMK_SRC_END
+} rtk_qos_1pRmkSrc_t;
+
+
+/* Types of DSCP remarking source */
+typedef enum rtk_qos_dscpRmkSrc_e
+{
+    DSCP_RMK_SRC_INT_PRI,
+    DSCP_RMK_SRC_DSCP,
+    DSCP_RMK_SRC_USER_PRI,
+    DSCP_RMK_SRC_END
+} rtk_qos_dscpRmkSrc_t;
+
+
+
+
+typedef struct rtk_priority_select_s
+{
+    rtk_uint32 port_pri;
+    rtk_uint32 dot1q_pri;
+    rtk_uint32 acl_pri;
+    rtk_uint32 dscp_pri;
+    rtk_uint32 cvlan_pri;
+    rtk_uint32 svlan_pri;
+    rtk_uint32 dmac_pri;
+    rtk_uint32 smac_pri;
+} rtk_priority_select_t;
+
+typedef struct rtk_qos_pri2queue_s
+{
+    rtk_uint32 pri2queue[RTK_MAX_NUM_OF_PRIORITY];
+} rtk_qos_pri2queue_t;
+
+typedef struct rtk_qos_queue_weights_s
+{
+    rtk_uint32 weights[RTK_MAX_NUM_OF_QUEUE];
+} rtk_qos_queue_weights_t;
+
+typedef enum rtk_qos_scheduling_type_e
+{
+    WFQ = 0,        /* Weighted-Fair-Queue */
+    WRR,            /* Weighted-Round-Robin */
+    SCHEDULING_TYPE_END
+} rtk_qos_scheduling_type_t;
+
+typedef rtk_uint32  rtk_queue_num_t;    /* queue number*/
+
+/* Function Name:
+ *      rtk_qos_init
+ * Description:
+ *      Configure Qos default settings with queue number assigment to each port.
+ * Input:
+ *      queueNum - Queue number of each port.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_QUEUE_NUM    - Invalid queue number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API will initialize related Qos setting with queue number assigment.
+ *      The queue number is from 1 to 8.
+ */
+extern rtk_api_ret_t rtk_qos_init(rtk_queue_num_t queueNum);
+
+/* Function Name:
+ *      rtk_qos_priSel_set
+ * Description:
+ *      Configure the priority order among different priority mechanism.
+ * Input:
+ *      index - Priority decision table index (0~1)
+ *      pPriDec - Priority assign for port, dscp, 802.1p, cvlan, svlan, acl based priority decision.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_QOS_SEL_PRI_SOURCE   - Invalid priority decision source parameter.
+ * Note:
+ *      ASIC will follow user priority setting of mechanisms to select mapped queue priority for receiving frame.
+ *      If two priority mechanisms are the same, the ASIC will chose the highest priority from mechanisms to
+ *      assign queue priority to receiving frame.
+ *      The priority sources are:
+ *      - PRIDEC_PORT
+ *      - PRIDEC_ACL
+ *      - PRIDEC_DSCP
+ *      - PRIDEC_1Q
+ *      - PRIDEC_1AD
+ *      - PRIDEC_CVLAN
+ *      - PRIDEC_DA
+ *      - PRIDEC_SA
+ */
+extern rtk_api_ret_t rtk_qos_priSel_set(rtk_qos_priDecTbl_t index, rtk_priority_select_t *pPriDec);
+
+
+/* Function Name:
+ *      rtk_qos_priSel_get
+ * Description:
+ *      Get the priority order configuration among different priority mechanism.
+ * Input:
+ *      index - Priority decision table index (0~1)
+ * Output:
+ *      pPriDec - Priority assign for port, dscp, 802.1p, cvlan, svlan, acl based priority decision .
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      ASIC will follow user priority setting of mechanisms to select mapped queue priority for receiving frame.
+ *      If two priority mechanisms are the same, the ASIC will chose the highest priority from mechanisms to
+ *      assign queue priority to receiving frame.
+ *      The priority sources are:
+ *      - PRIDEC_PORT,
+ *      - PRIDEC_ACL,
+ *      - PRIDEC_DSCP,
+ *      - PRIDEC_1Q,
+ *      - PRIDEC_1AD,
+ *      - PRIDEC_CVLAN,
+ *      - PRIDEC_DA,
+ *      - PRIDEC_SA,
+ */
+extern rtk_api_ret_t rtk_qos_priSel_get(rtk_qos_priDecTbl_t index, rtk_priority_select_t *pPriDec);
+
+/* Function Name:
+ *      rtk_qos_1pPriRemap_set
+ * Description:
+ *      Configure 1Q priorities mapping to internal absolute priority.
+ * Input:
+ *      dot1p_pri   - 802.1p priority value.
+ *      int_pri     - internal priority value.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_VLAN_PRIORITY    - Invalid 1p priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      Priority of 802.1Q assignment for internal asic priority, and it is used for queue usage and packet scheduling.
+ */
+extern rtk_api_ret_t rtk_qos_1pPriRemap_set(rtk_pri_t dot1p_pri, rtk_pri_t int_pri);
+
+/* Function Name:
+ *      rtk_qos_1pPriRemap_get
+ * Description:
+ *      Get 1Q priorities mapping to internal absolute priority.
+ * Input:
+ *      dot1p_pri - 802.1p priority value .
+ * Output:
+ *      pInt_pri - internal priority value.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_VLAN_PRIORITY    - Invalid priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      Priority of 802.1Q assigment for internal asic priority, and it is uesed for queue usage and packet scheduling.
+ */
+extern rtk_api_ret_t rtk_qos_1pPriRemap_get(rtk_pri_t dot1p_pri, rtk_pri_t *pInt_pri);
+
+
+/* Function Name:
+ *      rtk_qos_1pRemarkSrcSel_set
+ * Description:
+ *      Set remarking source of 802.1p remarking.
+ * Input:
+ *      type      - remarking source
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID  - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+
+ * Note:
+ *      The API can configure 802.1p remark functionality to map original 802.1p value or internal
+ *      priority to TX DSCP value.
+ */
+extern rtk_api_ret_t rtk_qos_1pRemarkSrcSel_set(rtk_qos_1pRmkSrc_t type);
+
+/* Function Name:
+ *      rtk_qos_1pRemarkSrcSel_get
+ * Description:
+ *      Get remarking source of 802.1p remarking.
+ * Input:
+ *      none
+ * Output:
+ *      pType      - remarking source
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+ *      RT_ERR_NULL_POINTER     - input parameter may be null pointer
+
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_qos_1pRemarkSrcSel_get(rtk_qos_1pRmkSrc_t *pType);
+
+/* Function Name:
+ *      rtk_qos_dscpPriRemap_set
+ * Description:
+ *      Map dscp value to internal priority.
+ * Input:
+ *      dscp    - Dscp value of receiving frame
+ *      int_pri - internal priority value .
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid DSCP value.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      The Differentiated Service Code Point is a selector for router's per-hop behaviors. As a selector, there is no implication that a numerically
+ *      greater DSCP implies a better network service. As can be seen, the DSCP totally overlaps the old precedence field of TOS. So if values of
+ *      DSCP are carefully chosen then backward compatibility can be achieved.
+ */
+extern rtk_api_ret_t rtk_qos_dscpPriRemap_set(rtk_dscp_t dscp, rtk_pri_t int_pri);
+
+/* Function Name:
+ *      rtk_qos_dscpPriRemap_get
+ * Description:
+ *      Get dscp value to internal priority.
+ * Input:
+ *      dscp - Dscp value of receiving frame
+ * Output:
+ *      pInt_pri - internal priority value.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid DSCP value.
+ * Note:
+ *      The Differentiated Service Code Point is a selector for router's per-hop behaviors. As a selector, there is no implication that a numerically
+ *      greater DSCP implies a better network service. As can be seen, the DSCP totally overlaps the old precedence field of TOS. So if values of
+ *      DSCP are carefully chosen then backward compatibility can be achieved.
+ */
+extern rtk_api_ret_t rtk_qos_dscpPriRemap_get(rtk_dscp_t dscp, rtk_pri_t *pInt_pri);
+
+/* Function Name:
+ *      rtk_qos_portPri_set
+ * Description:
+ *      Configure priority usage to each port.
+ * Input:
+ *      port - Port id.
+ *      int_pri - internal priority value.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_QOS_SEL_PORT_PRI - Invalid port priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      The API can set priority of port assignments for queue usage and packet scheduling.
+ */
+extern rtk_api_ret_t rtk_qos_portPri_set(rtk_port_t port, rtk_pri_t int_pri) ;
+
+/* Function Name:
+ *      rtk_qos_portPri_get
+ * Description:
+ *      Get priority usage to each port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pInt_pri - internal priority value.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get priority of port assignments for queue usage and packet scheduling.
+ */
+extern rtk_api_ret_t rtk_qos_portPri_get(rtk_port_t port, rtk_pri_t *pInt_pri) ;
+
+/* Function Name:
+ *      rtk_qos_queueNum_set
+ * Description:
+ *      Set output queue number for each port.
+ * Input:
+ *      port    - Port id.
+ *      index   - Mapping queue number (1~8)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_QUEUE_NUM    - Invalid queue number.
+ * Note:
+ *      The API can set the output queue number of the specified port. The queue number is from 1 to 8.
+ */
+extern rtk_api_ret_t rtk_qos_queueNum_set(rtk_port_t port, rtk_queue_num_t queue_num);
+
+/* Function Name:
+ *      rtk_qos_queueNum_get
+ * Description:
+ *      Get output queue number.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pQueue_num - Mapping queue number
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API will return the output queue number of the specified port. The queue number is from 1 to 8.
+ */
+extern rtk_api_ret_t rtk_qos_queueNum_get(rtk_port_t port, rtk_queue_num_t *pQueue_num);
+
+/* Function Name:
+ *      rtk_qos_priMap_set
+ * Description:
+ *      Set output queue number for each port.
+ * Input:
+ *      queue_num   - Queue number usage.
+ *      pPri2qid    - Priority mapping to queue ID.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_QUEUE_NUM        - Invalid queue number.
+ *      RT_ERR_QUEUE_ID         - Invalid queue id.
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      ASIC supports priority mapping to queue with different queue number from 1 to 8.
+ *      For different queue numbers usage, ASIC supports different internal available queue IDs.
+ */
+extern rtk_api_ret_t rtk_qos_priMap_set(rtk_queue_num_t queue_num, rtk_qos_pri2queue_t *pPri2qid);
+
+
+/* Function Name:
+ *      rtk_qos_priMap_get
+ * Description:
+ *      Get priority to queue ID mapping table parameters.
+ * Input:
+ *      queue_num - Queue number usage.
+ * Output:
+ *      pPri2qid - Priority mapping to queue ID.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_QUEUE_NUM    - Invalid queue number.
+ * Note:
+ *      The API can return the mapping queue id of the specified priority and queue number.
+ *      The queue number is from 1 to 8.
+ */
+extern rtk_api_ret_t rtk_qos_priMap_get(rtk_queue_num_t queue_num, rtk_qos_pri2queue_t *pPri2qid);
+
+/* Function Name:
+ *      rtk_qos_schedulingQueue_set
+ * Description:
+ *      Set weight and type of queues in dedicated port.
+ * Input:
+ *      port        - Port id.
+ *      pQweights   - The array of weights for WRR/WFQ queue (0 for STRICT_PRIORITY queue).
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_QOS_QUEUE_WEIGHT - Invalid queue weight.
+ * Note:
+ *      The API can set weight and type, strict priority or weight fair queue (WFQ) for
+ *      dedicated port for using queues. If queue id is not included in queue usage,
+ *      then its type and weight setting in dummy for setting. There are priorities
+ *      as queue id in strict queues. It means strict queue id 5 carrying higher priority
+ *      than strict queue id 4. The WFQ queue weight is from 1 to 128, and weight 0 is
+ *      for strict priority queue type.
+ */
+extern rtk_api_ret_t rtk_qos_schedulingQueue_set(rtk_port_t port, rtk_qos_queue_weights_t *pQweights);
+
+/* Function Name:
+ *      rtk_qos_schedulingQueue_get
+ * Description:
+ *      Get weight and type of queues in dedicated port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pQweights - The array of weights for WRR/WFQ queue (0 for STRICT_PRIORITY queue).
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get weight and type, strict priority or weight fair queue (WFQ) for dedicated port for using queues.
+ *      The WFQ queue weight is from 1 to 128, and weight 0 is for strict priority queue type.
+ */
+extern rtk_api_ret_t rtk_qos_schedulingQueue_get(rtk_port_t port, rtk_qos_queue_weights_t *pQweights);
+
+/* Function Name:
+ *      rtk_qos_1pRemarkEnable_set
+ * Description:
+ *      Set 1p Remarking state
+ * Input:
+ *      port        - Port id.
+ *      enable      - State of per-port 1p Remarking
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid enable parameter.
+ * Note:
+ *      The API can enable or disable 802.1p remarking ability for whole system.
+ *      The status of 802.1p remark:
+ *      - DISABLED
+ *      - ENABLED
+ */
+extern rtk_api_ret_t rtk_qos_1pRemarkEnable_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_qos_1pRemarkEnable_get
+ * Description:
+ *      Get 802.1p remarking ability.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - Status of 802.1p remark.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get 802.1p remarking ability.
+ *      The status of 802.1p remark:
+ *      - DISABLED
+ *      - ENABLED
+ */
+extern rtk_api_ret_t rtk_qos_1pRemarkEnable_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_qos_1pRemark_set
+ * Description:
+ *      Set 802.1p remarking parameter.
+ * Input:
+ *      int_pri     - Internal priority value.
+ *      dot1p_pri   - 802.1p priority value.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_VLAN_PRIORITY    - Invalid 1p priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      The API can set 802.1p parameters source priority and new priority.
+ */
+extern rtk_api_ret_t rtk_qos_1pRemark_set(rtk_pri_t int_pri, rtk_pri_t dot1p_pri);
+
+/* Function Name:
+ *      rtk_qos_1pRemark_get
+ * Description:
+ *      Get 802.1p remarking parameter.
+ * Input:
+ *      int_pri - Internal priority value.
+ * Output:
+ *      pDot1p_pri - 802.1p priority value.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      The API can get 802.1p remarking parameters. It would return new priority of ingress priority.
+ */
+extern rtk_api_ret_t rtk_qos_1pRemark_get(rtk_pri_t int_pri, rtk_pri_t *pDot1p_pri);
+
+/* Function Name:
+ *      rtk_qos_dscpRemarkEnable_set
+ * Description:
+ *      Set DSCP remarking ability.
+ * Input:
+ *      port    - Port id.
+ *      enable  - status of DSCP remark.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ *      RT_ERR_ENABLE           - Invalid enable parameter.
+ * Note:
+ *      The API can enable or disable DSCP remarking ability for whole system.
+ *      The status of DSCP remark:
+ *      - DISABLED
+ *      - ENABLED
+ */
+extern rtk_api_ret_t rtk_qos_dscpRemarkEnable_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_qos_dscpRemarkEnable_get
+ * Description:
+ *      Get DSCP remarking ability.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - status of DSCP remarking.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get DSCP remarking ability.
+ *      The status of DSCP remark:
+ *      - DISABLED
+ *      - ENABLED
+ */
+extern rtk_api_ret_t rtk_qos_dscpRemarkEnable_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_qos_dscpRemark_set
+ * Description:
+ *      Set DSCP remarking parameter.
+ * Input:
+ *      int_pri - Internal priority value.
+ *      dscp    - DSCP value.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid DSCP value.
+ * Note:
+ *      The API can set DSCP value and mapping priority.
+ */
+extern rtk_api_ret_t rtk_qos_dscpRemark_set(rtk_pri_t int_pri, rtk_dscp_t dscp);
+
+/* Function Name:
+ *      rtk_qos_dscpRemark_get
+ * Description:
+ *      Get DSCP remarking parameter.
+ * Input:
+ *      int_pri - Internal priority value.
+ * Output:
+ *      Dscp - DSCP value.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      The API can get DSCP parameters. It would return DSCP value for mapping priority.
+ */
+extern rtk_api_ret_t rtk_qos_dscpRemark_get(rtk_pri_t int_pri, rtk_dscp_t *pDscp);
+
+/* Function Name:
+ *      rtk_qos_dscpRemarkSrcSel_set
+ * Description:
+ *      Set remarking source of DSCP remarking.
+ * Input:
+ *      type      - remarking source
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID  - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+
+ * Note:
+ *      The API can configure DSCP remark functionality to map original DSCP value or internal
+ *      priority to TX DSCP value.
+ */
+extern rtk_api_ret_t rtk_qos_dscpRemarkSrcSel_set(rtk_qos_dscpRmkSrc_t type);
+
+
+/* Function Name:
+ *      rtk_qos_dcpRemarkSrcSel_get
+ * Description:
+ *      Get remarking source of DSCP remarking.
+ * Input:
+ *      none
+ * Output:
+ *      pType      - remarking source
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+ *      RT_ERR_NULL_POINTER     - input parameter may be null pointer
+
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_qos_dscpRemarkSrcSel_get(rtk_qos_dscpRmkSrc_t *pType);
+
+
+/* Function Name:
+ *      rtk_qos_dscpRemark2Dscp_set
+ * Description:
+ *      Set DSCP to remarked DSCP mapping.
+ * Input:
+ *      dscp    - DSCP value
+ *      rmkDscp - remarked DSCP value
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid dscp value
+ * Note:
+ *      dscp parameter can be DSCP value or internal priority according to configuration of API
+ *      dal_apollomp_qos_dscpRemarkSrcSel_set(), because DSCP remark functionality can map original DSCP
+ *      value or internal priority to TX DSCP value.
+ */
+extern rtk_api_ret_t rtk_qos_dscpRemark2Dscp_set(rtk_dscp_t dscp, rtk_dscp_t rmkDscp);
+
+/* Function Name:
+ *      rtk_qos_dscpRemark2Dscp_get
+ * Description:
+ *      Get DSCP to remarked DSCP mapping.
+ * Input:
+ *      dscp    - DSCP value
+ * Output:
+ *      pDscp   - remarked DSCP value
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid dscp value
+ *      RT_ERR_NULL_POINTER     - NULL pointer
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_qos_dscpRemark2Dscp_get(rtk_dscp_t dscp, rtk_dscp_t *pDscp);
+
+/* Function Name:
+ *      rtk_qos_portPriSelIndex_set
+ * Description:
+ *      Configure priority decision index to each port.
+ * Input:
+ *      port - Port id.
+ *      index - priority decision index.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_ENTRY_INDEX - Invalid entry index.
+ * Note:
+ *      The API can set priority of port assignments for queue usage and packet scheduling.
+ */
+extern rtk_api_ret_t rtk_qos_portPriSelIndex_set(rtk_port_t port, rtk_qos_priDecTbl_t index);
+
+/* Function Name:
+ *      rtk_qos_portPriSelIndex_get
+ * Description:
+ *      Get priority decision index from each port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pIndex - priority decision index.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get priority of port assignments for queue usage and packet scheduling.
+ */
+extern rtk_api_ret_t rtk_qos_portPriSelIndex_get(rtk_port_t port, rtk_qos_priDecTbl_t *pIndex);
+
+#endif /* __RTK_API_QOS_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rate.h b/drivers/net/phy/rtk/rtl8367c/include/rate.h
new file mode 100644
index 0000000000000..82f499af02a40
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rate.h
@@ -0,0 +1,305 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes rate module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_RATE_H__
+#define __RTK_API_RATE_H__
+
+/*
+ * Include Files
+ */
+//#include <rtk_types.h>
+
+/*
+ * Data Type Declaration
+ */
+#define RTK_MAX_METER_ID            (rtk_switch_maxMeterId_get())
+#define RTK_METER_NUM               (RTK_MAX_METER_ID + 1)
+
+typedef enum rtk_meter_type_e{
+    METER_TYPE_KBPS = 0,    /* Kbps */
+    METER_TYPE_PPS,         /* Packet per second */
+    METER_TYPE_END
+}rtk_meter_type_t;
+
+
+/*
+ * Function Declaration
+ */
+
+ /* Rate */
+/* Function Name:
+ *      rtk_rate_shareMeter_set
+ * Description:
+ *      Set meter configuration
+ * Input:
+ *      index       - shared meter index
+ *      type        - shared meter type
+ *      rate        - rate of share meter
+ *      ifg_include - include IFG or not, ENABLE:include DISABLE:exclude
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ *      RT_ERR_RATE             - Invalid rate
+ *      RT_ERR_INPUT            - Invalid input parameters
+ * Note:
+ *      The API can set shared meter rate and ifg include for each meter.
+ *      The rate unit is 1 kbps and the range is from 8k to 1048568k if type is METER_TYPE_KBPS and
+ *      the granularity of rate is 8 kbps.
+ *      The rate unit is packets per second and the range is 1 ~ 0x1FFF if type is METER_TYPE_PPS.
+ *      The ifg_include parameter is used
+ *      for rate calculation with/without inter-frame-gap and preamble.
+ */
+rtk_api_ret_t rtk_rate_shareMeter_set(rtk_meter_id_t index, rtk_meter_type_t type, rtk_rate_t rate, rtk_enable_t ifg_include);
+
+/* Function Name:
+ *      rtk_rate_shareMeter_get
+ * Description:
+ *      Get meter configuration
+ * Input:
+ *      index        - shared meter index
+ * Output:
+ *      pType        - Meter Type
+ *      pRate        - pointer of rate of share meter
+ *      pIfg_include - include IFG or not, ENABLE:include DISABLE:exclude
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_shareMeter_get(rtk_meter_id_t index, rtk_meter_type_t *pType, rtk_rate_t *pRate, rtk_enable_t *pIfg_include);
+
+/* Function Name:
+ *      rtk_rate_shareMeterBucket_set
+ * Description:
+ *      Set meter Bucket Size
+ * Input:
+ *      index        - shared meter index
+ *      bucket_size  - Bucket Size
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_INPUT            - Error Input
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      The API can set shared meter bucket size.
+ */
+extern rtk_api_ret_t rtk_rate_shareMeterBucket_set(rtk_meter_id_t index, rtk_uint32 bucket_size);
+
+/* Function Name:
+ *      rtk_rate_shareMeterBucket_get
+ * Description:
+ *      Get meter Bucket Size
+ * Input:
+ *      index        - shared meter index
+ * Output:
+ *      pBucket_size - Bucket Size
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      The API can get shared meter bucket size.
+ */
+extern rtk_api_ret_t rtk_rate_shareMeterBucket_get(rtk_meter_id_t index, rtk_uint32 *pBucket_size);
+
+/* Function Name:
+ *      rtk_rate_igrBandwidthCtrlRate_set
+ * Description:
+ *      Set port ingress bandwidth control
+ * Input:
+ *      port        - Port id
+ *      rate        - Rate of share meter
+ *      ifg_include - include IFG or not, ENABLE:include DISABLE:exclude
+ *      fc_enable   - enable flow control or not, ENABLE:use flow control DISABLE:drop
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid IFG parameter.
+ *      RT_ERR_INBW_RATE    - Invalid ingress rate parameter.
+ * Note:
+ *      The rate unit is 1 kbps and the range is from 8k to 1048568k. The granularity of rate is 8 kbps.
+ *      The ifg_include parameter is used for rate calculation with/without inter-frame-gap and preamble.
+ */
+extern rtk_api_ret_t rtk_rate_igrBandwidthCtrlRate_set( rtk_port_t port, rtk_rate_t rate,  rtk_enable_t ifg_include, rtk_enable_t fc_enable);
+
+/* Function Name:
+ *      rtk_rate_igrBandwidthCtrlRate_get
+ * Description:
+ *      Get port ingress bandwidth control
+ * Input:
+ *      port - Port id
+ * Output:
+ *      pRate           - Rate of share meter
+ *      pIfg_include    - Rate's calculation including IFG, ENABLE:include DISABLE:exclude
+ *      pFc_enable      - enable flow control or not, ENABLE:use flow control DISABLE:drop
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *     The rate unit is 1 kbps and the range is from 8k to 1048568k. The granularity of rate is 8 kbps.
+ *     The ifg_include parameter is used for rate calculation with/without inter-frame-gap and preamble.
+ */
+extern rtk_api_ret_t rtk_rate_igrBandwidthCtrlRate_get(rtk_port_t port, rtk_rate_t *pRate, rtk_enable_t *pIfg_include, rtk_enable_t *pFc_enable);
+
+/* Function Name:
+ *      rtk_rate_egrBandwidthCtrlRate_set
+ * Description:
+ *      Set port egress bandwidth control
+ * Input:
+ *      port        - Port id
+ *      rate        - Rate of egress bandwidth
+ *      ifg_include - include IFG or not, ENABLE:include DISABLE:exclude
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_QOS_EBW_RATE - Invalid egress bandwidth/rate
+ * Note:
+ *     The rate unit is 1 kbps and the range is from 8k to 1048568k. The granularity of rate is 8 kbps.
+ *     The ifg_include parameter is used for rate calculation with/without inter-frame-gap and preamble.
+ */
+extern rtk_api_ret_t rtk_rate_egrBandwidthCtrlRate_set(rtk_port_t port, rtk_rate_t rate,  rtk_enable_t ifg_includ);
+
+/* Function Name:
+ *      rtk_rate_egrBandwidthCtrlRate_get
+ * Description:
+ *      Get port egress bandwidth control
+ * Input:
+ *      port - Port id
+ * Output:
+ *      pRate           - Rate of egress bandwidth
+ *      pIfg_include    - Rate's calculation including IFG, ENABLE:include DISABLE:exclude
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *     The rate unit is 1 kbps and the range is from 8k to 1048568k. The granularity of rate is 8 kbps.
+ *     The ifg_include parameter is used for rate calculation with/without inter-frame-gap and preamble.
+ */
+extern rtk_api_ret_t rtk_rate_egrBandwidthCtrlRate_get(rtk_port_t port, rtk_rate_t *pRate, rtk_enable_t *pIfg_include);
+
+/* Function Name:
+ *      rtk_rate_egrQueueBwCtrlEnable_set
+ * Description:
+ *      Set enable status of egress bandwidth control on specified queue.
+ * Input:
+ *      port   - port id
+ *      queue  - queue id
+ *      enable - enable status of egress queue bandwidth control
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_QUEUE_ID         - invalid queue id
+ *      RT_ERR_INPUT            - invalid input parameter
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_rate_egrQueueBwCtrlEnable_set(rtk_port_t port, rtk_qid_t queue, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_rate_egrQueueBwCtrlRate_get
+ * Description:
+ *      Get rate of egress bandwidth control on specified queue.
+ * Input:
+ *      port  - port id
+ *      queue - queue id
+ *      pIndex - shared meter index
+ * Output:
+ *      pRate - pointer to rate of egress queue bandwidth control
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_QUEUE_ID         - invalid queue id
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter id
+ * Note:
+ *    None.
+ */
+extern rtk_api_ret_t rtk_rate_egrQueueBwCtrlEnable_get(rtk_port_t port, rtk_qid_t queue, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_rate_egrQueueBwCtrlRate_set
+ * Description:
+ *      Set rate of egress bandwidth control on specified queue.
+ * Input:
+ *      port  - port id
+ *      queue - queue id
+ *      index - shared meter index
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_QUEUE_ID         - invalid queue id
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter id
+ * Note:
+ *    The actual rate control is set in shared meters.
+ *    The unit of granularity is 8Kbps.
+ */
+extern rtk_api_ret_t rtk_rate_egrQueueBwCtrlRate_set(rtk_port_t port, rtk_qid_t queue, rtk_meter_id_t index);
+
+/* Function Name:
+ *      rtk_rate_egrQueueBwCtrlRate_get
+ * Description:
+ *      Get rate of egress bandwidth control on specified queue.
+ * Input:
+ *      port  - port id
+ *      queue - queue id
+ *      pIndex - shared meter index
+ * Output:
+ *      pRate - pointer to rate of egress queue bandwidth control
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_QUEUE_ID         - invalid queue id
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter id
+ * Note:
+ *    The actual rate control is set in shared meters.
+ *    The unit of granularity is 8Kbps.
+ */
+extern rtk_api_ret_t rtk_rate_egrQueueBwCtrlRate_get(rtk_port_t port, rtk_qid_t queue, rtk_meter_id_t *pIndex);
+
+#endif /* __RTK_API_RATE_H__ */
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rldp.h b/drivers/net/phy/rtk/rtl8367c/include/rldp.h
new file mode 100644
index 0000000000000..48c0eeecc769a
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rldp.h
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : Declaration of RLDP and RLPP API
+ *
+ * Feature : The file have include the following module and sub-modules
+ *           1) RLDP and RLPP configuration and status
+ *
+ */
+
+
+#ifndef __RTK_RLDP_H__
+#define __RTK_RLDP_H__
+
+
+/*
+ * Include Files
+ */
+
+
+/*
+ * Symbol Definition
+ */
+typedef enum rtk_rldp_trigger_e
+{
+    RTK_RLDP_TRIGGER_SAMOVING = 0,
+    RTK_RLDP_TRIGGER_PERIOD,
+    RTK_RLDP_TRIGGER_END
+} rtk_rldp_trigger_t;
+
+typedef enum rtk_rldp_cmpType_e
+{
+    RTK_RLDP_CMPTYPE_MAGIC = 0,     /* Compare the RLDP with magic only */
+    RTK_RLDP_CMPTYPE_MAGIC_ID,      /* Compare the RLDP with both magic + ID */
+    RTK_RLDP_CMPTYPE_END
+} rtk_rldp_cmpType_t;
+
+typedef enum rtk_rldp_loopStatus_e
+{
+    RTK_RLDP_LOOPSTS_NONE = 0,
+    RTK_RLDP_LOOPSTS_LOOPING,
+    RTK_RLDP_LOOPSTS_END
+} rtk_rldp_loopStatus_t;
+
+typedef enum rtk_rlpp_trapType_e
+{
+    RTK_RLPP_TRAPTYPE_NONE = 0,
+    RTK_RLPP_TRAPTYPE_CPU,
+    RTK_RLPP_TRAPTYPE_END
+} rtk_rlpp_trapType_t;
+
+typedef struct rtk_rldp_config_s
+{
+    rtk_enable_t        rldp_enable;
+    rtk_rldp_trigger_t trigger_mode;
+    rtk_mac_t           magic;
+    rtk_rldp_cmpType_t  compare_type;
+    rtk_uint32              interval_check; /* Checking interval for check state */
+    rtk_uint32              num_check;      /* Checking number for check state */
+    rtk_uint32              interval_loop;  /* Checking interval for loop state */
+    rtk_uint32              num_loop;       /* Checking number for loop state */
+} rtk_rldp_config_t;
+
+typedef struct rtk_rldp_portConfig_s
+{
+    rtk_enable_t        tx_enable;
+} rtk_rldp_portConfig_t;
+
+typedef struct rtk_rldp_status_s
+{
+    rtk_mac_t           id;
+} rtk_rldp_status_t;
+
+typedef struct rtk_rldp_portStatus_s
+{
+    rtk_rldp_loopStatus_t   loop_status;
+    rtk_rldp_loopStatus_t   loop_enter;
+    rtk_rldp_loopStatus_t   loop_leave;
+} rtk_rldp_portStatus_t;
+
+/*
+ * Data Declaration
+ */
+
+
+/*
+ * Macro Declaration
+ */
+
+#define RTK_RLDP_INTERVAL_MAX  0xffff
+#define RTK_RLDP_NUM_MAX       0xff
+
+
+/*
+ * Function Declaration
+ */
+
+/* Module Name : RLDP */
+
+
+/* Function Name:
+ *      rtk_rldp_config_set
+ * Description:
+ *      Set RLDP module configuration
+ * Input:
+ *      pConfig - configuration structure of RLDP
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_rldp_config_set(rtk_rldp_config_t *pConfig);
+
+
+/* Function Name:
+ *      rtk_rldp_config_get
+ * Description:
+ *      Get RLDP module configuration
+ * Input:
+ *      None
+ * Output:
+ *      pConfig - configuration structure of RLDP
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_rldp_config_get(rtk_rldp_config_t *pConfig);
+
+
+/* Function Name:
+ *      rtk_rldp_portConfig_set
+ * Description:
+ *      Set per port RLDP module configuration
+ * Input:
+ *      port   - port number to be configured
+ *      pPortConfig - per port configuration structure of RLDP
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_rldp_portConfig_set(rtk_port_t port, rtk_rldp_portConfig_t *pPortConfig);
+
+
+/* Function Name:
+ *      rtk_rldp_portConfig_get
+ * Description:
+ *      Get per port RLDP module configuration
+ * Input:
+ *      port    - port number to be get
+ * Output:
+ *      pPortConfig - per port configuration structure of RLDP
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_rldp_portConfig_get(rtk_port_t port, rtk_rldp_portConfig_t *pPortConfig);
+
+
+/* Function Name:
+ *      rtk_rldp_status_get
+ * Description:
+ *      Get RLDP module status
+ * Input:
+ *      None
+ * Output:
+ *      pStatus - status structure of RLDP
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_rldp_status_get(rtk_rldp_status_t *pStatus);
+
+
+/* Function Name:
+ *      rtk_rldp_portStatus_get
+ * Description:
+ *      Get RLDP module status
+ * Input:
+ *      port    - port number to be get
+ * Output:
+ *      pPortStatus - per port status structure of RLDP
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_rldp_portStatus_get(rtk_port_t port, rtk_rldp_portStatus_t *pPortStatus);
+
+
+/* Function Name:
+ *      rtk_rldp_portStatus_clear
+ * Description:
+ *      Clear RLDP module status
+ * Input:
+ *      port    - port number to be clear
+ *      pPortStatus - per port status structure of RLDP
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      Clear operation effect loop_enter and loop_leave only, other field in
+ *      the structure are don't care
+ */
+extern rtk_api_ret_t rtk_rldp_portStatus_set(rtk_port_t port, rtk_rldp_portStatus_t *pPortStatus);
+
+
+/* Function Name:
+ *      rtk_rldp_portLoopPair_get
+ * Description:
+ *      Get RLDP port loop pairs
+ * Input:
+ *      port    - port number to be get
+ * Output:
+ *      pPortmask - per port related loop ports
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_rldp_portLoopPair_get(rtk_port_t port, rtk_portmask_t *pPortmask);
+
+#endif /* __RTK_RLDP_H__ */
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtk_error.h b/drivers/net/phy/rtk/rtl8367c/include/rtk_error.h
new file mode 100644
index 0000000000000..dc9c0bed35feb
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtk_error.h
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : Definition the error number in the SDK.
+ * Feature : error definition
+ *
+ */
+
+#ifndef __COMMON_RT_ERROR_H__
+#define __COMMON_RT_ERROR_H__
+
+/*
+ * Include Files
+ */
+
+/*
+ * Data Type Declaration
+ */
+typedef enum rt_error_code_e
+{
+    RT_ERR_FAILED = -1,                             /* General Error                                                                    */
+
+    /* 0x0000xxxx for common error code */
+    RT_ERR_OK = 0,                                  /* 0x00000000, OK                                                                   */
+    RT_ERR_INPUT,                                   /* 0x00000001, invalid input parameter                                              */
+    RT_ERR_UNIT_ID,                                 /* 0x00000002, invalid unit id                                                      */
+    RT_ERR_PORT_ID,                                 /* 0x00000003, invalid port id                                                      */
+    RT_ERR_PORT_MASK,                               /* 0x00000004, invalid port mask                                                    */
+    RT_ERR_PORT_LINKDOWN,                           /* 0x00000005, link down port status                                                */
+    RT_ERR_ENTRY_INDEX,                             /* 0x00000006, invalid entry index                                                  */
+    RT_ERR_NULL_POINTER,                            /* 0x00000007, input parameter is null pointer                                      */
+    RT_ERR_QUEUE_ID,                                /* 0x00000008, invalid queue id                                                     */
+    RT_ERR_QUEUE_NUM,                               /* 0x00000009, invalid queue number                                                 */
+    RT_ERR_BUSYWAIT_TIMEOUT,                        /* 0x0000000a, busy watting time out                                                */
+    RT_ERR_MAC,                                     /* 0x0000000b, invalid mac address                                                  */
+    RT_ERR_OUT_OF_RANGE,                            /* 0x0000000c, input parameter out of range                                         */
+    RT_ERR_CHIP_NOT_SUPPORTED,                      /* 0x0000000d, functions not supported by this chip model                           */
+    RT_ERR_SMI,                                     /* 0x0000000e, SMI error                                                            */
+    RT_ERR_NOT_INIT,                                /* 0x0000000f, The module is not initial                                            */
+    RT_ERR_CHIP_NOT_FOUND,                          /* 0x00000010, The chip can not found                                               */
+    RT_ERR_NOT_ALLOWED,                             /* 0x00000011, actions not allowed by the function                                  */
+    RT_ERR_DRIVER_NOT_FOUND,                        /* 0x00000012, The driver can not found                                             */
+    RT_ERR_SEM_LOCK_FAILED,                         /* 0x00000013, Failed to lock semaphore                                             */
+    RT_ERR_SEM_UNLOCK_FAILED,                       /* 0x00000014, Failed to unlock semaphore                                           */
+    RT_ERR_ENABLE,                                  /* 0x00000015, invalid enable parameter                                             */
+    RT_ERR_TBL_FULL,                                /* 0x00000016, input table full                                                     */
+
+    /* 0x0001xxxx for vlan */
+    RT_ERR_VLAN_VID = 0x00010000,                   /* 0x00010000, invalid vid                                                          */
+    RT_ERR_VLAN_PRIORITY,                           /* 0x00010001, invalid 1p priority                                                  */
+    RT_ERR_VLAN_EMPTY_ENTRY,                        /* 0x00010002, emtpy entry of vlan table                                            */
+    RT_ERR_VLAN_ACCEPT_FRAME_TYPE,                  /* 0x00010003, invalid accept frame type                                            */
+    RT_ERR_VLAN_EXIST,                              /* 0x00010004, vlan is exist                                                        */
+    RT_ERR_VLAN_ENTRY_NOT_FOUND,                    /* 0x00010005, specified vlan entry not found                                       */
+    RT_ERR_VLAN_PORT_MBR_EXIST,                     /* 0x00010006, member port exist in the specified vlan                              */
+    RT_ERR_VLAN_PROTO_AND_PORT,                     /* 0x00010008, invalid protocol and port based vlan                              */
+
+    /* 0x0002xxxx for svlan */
+    RT_ERR_SVLAN_ENTRY_INDEX = 0x00020000,          /* 0x00020000, invalid svid entry no                                                */
+    RT_ERR_SVLAN_ETHER_TYPE,                        /* 0x00020001, invalid SVLAN ether type                                             */
+    RT_ERR_SVLAN_TABLE_FULL,                        /* 0x00020002, no empty entry in SVLAN table                                        */
+    RT_ERR_SVLAN_ENTRY_NOT_FOUND,                   /* 0x00020003, specified svlan entry not found                                      */
+    RT_ERR_SVLAN_EXIST,                             /* 0x00020004, SVLAN entry is exist                                                 */
+    RT_ERR_SVLAN_VID,                               /* 0x00020005, invalid svid                                                         */
+
+    /* 0x0003xxxx for MSTP */
+    RT_ERR_MSTI = 0x00030000,                       /* 0x00030000, invalid msti                                                         */
+    RT_ERR_MSTP_STATE,                              /* 0x00030001, invalid spanning tree status                                         */
+    RT_ERR_MSTI_EXIST,                              /* 0x00030002, MSTI exist                                                           */
+    RT_ERR_MSTI_NOT_EXIST,                          /* 0x00030003, MSTI not exist                                                       */
+
+    /* 0x0004xxxx for BUCKET */
+    RT_ERR_TIMESLOT = 0x00040000,                   /* 0x00040000, invalid time slot                                                    */
+    RT_ERR_TOKEN,                                   /* 0x00040001, invalid token amount                                                 */
+    RT_ERR_RATE,                                    /* 0x00040002, invalid rate                                                         */
+    RT_ERR_TICK,                                    /* 0x00040003, invalid tick                                                 */
+
+    /* 0x0005xxxx for RMA */
+    RT_ERR_RMA_ADDR = 0x00050000,                   /* 0x00050000, invalid rma mac address                                              */
+    RT_ERR_RMA_ACTION,                              /* 0x00050001, invalid rma action                                                   */
+
+    /* 0x0006xxxx for L2 */
+    RT_ERR_L2_HASH_KEY = 0x00060000,                /* 0x00060000, invalid L2 Hash key                                                  */
+    RT_ERR_L2_HASH_INDEX,                           /* 0x00060001, invalid L2 Hash index                                                */
+    RT_ERR_L2_CAM_INDEX,                            /* 0x00060002, invalid L2 CAM index                                                 */
+    RT_ERR_L2_ENRTYSEL,                             /* 0x00060003, invalid EntrySel                                                     */
+    RT_ERR_L2_INDEXTABLE_INDEX,                     /* 0x00060004, invalid L2 index table(=portMask table) index                        */
+    RT_ERR_LIMITED_L2ENTRY_NUM,                     /* 0x00060005, invalid limited L2 entry number                                      */
+    RT_ERR_L2_AGGREG_PORT,                          /* 0x00060006, this aggregated port is not the lowest physical
+                                                                   port of its aggregation group                                        */
+    RT_ERR_L2_FID,                                  /* 0x00060007, invalid fid                                                          */
+    RT_ERR_L2_VID,                                 /* 0x00060008, invalid cvid                                                         */
+    RT_ERR_L2_NO_EMPTY_ENTRY,                       /* 0x00060009, no empty entry in L2 table                                           */
+    RT_ERR_L2_ENTRY_NOTFOUND,                       /* 0x0006000a, specified entry not found                                            */
+    RT_ERR_L2_INDEXTBL_FULL,                        /* 0x0006000b, the L2 index table is full                                           */
+    RT_ERR_L2_INVALID_FLOWTYPE,                     /* 0x0006000c, invalid L2 flow type                                                 */
+    RT_ERR_L2_L2UNI_PARAM,                          /* 0x0006000d, invalid L2 unicast parameter                                         */
+    RT_ERR_L2_L2MULTI_PARAM,                        /* 0x0006000e, invalid L2 multicast parameter                                       */
+    RT_ERR_L2_IPMULTI_PARAM,                        /* 0x0006000f, invalid L2 ip multicast parameter                                    */
+    RT_ERR_L2_PARTIAL_HASH_KEY,                     /* 0x00060010, invalid L2 partial Hash key                                          */
+    RT_ERR_L2_EMPTY_ENTRY,                          /* 0x00060011, the entry is empty(invalid)                                          */
+    RT_ERR_L2_FLUSH_TYPE,                           /* 0x00060012, the flush type is invalid                                            */
+    RT_ERR_L2_NO_CPU_PORT,                          /* 0x00060013, CPU port not exist                                                   */
+
+    /* 0x0007xxxx for FILTER (PIE) */
+    RT_ERR_FILTER_BLOCKNUM = 0x00070000,            /* 0x00070000, invalid block number                                                 */
+    RT_ERR_FILTER_ENTRYIDX,                         /* 0x00070001, invalid entry index                                                  */
+    RT_ERR_FILTER_CUTLINE,                          /* 0x00070002, invalid cutline value                                                */
+    RT_ERR_FILTER_FLOWTBLBLOCK,                     /* 0x00070003, block belongs to flow table                                          */
+    RT_ERR_FILTER_INACLBLOCK,                       /* 0x00070004, block belongs to ingress ACL                                         */
+    RT_ERR_FILTER_ACTION,                           /* 0x00070005, action doesn't consist to entry type                                 */
+    RT_ERR_FILTER_INACL_RULENUM,                    /* 0x00070006, invalid ACL rulenum                                                  */
+    RT_ERR_FILTER_INACL_TYPE,                       /* 0x00070007, entry type isn't an ingress ACL rule                                 */
+    RT_ERR_FILTER_INACL_EXIST,                      /* 0x00070008, ACL entry is already exit                                            */
+    RT_ERR_FILTER_INACL_EMPTY,                      /* 0x00070009, ACL entry is empty                                                   */
+    RT_ERR_FILTER_FLOWTBL_TYPE,                     /* 0x0007000a, entry type isn't an flow table rule                                  */
+    RT_ERR_FILTER_FLOWTBL_RULENUM,                  /* 0x0007000b, invalid flow table rulenum                                           */
+    RT_ERR_FILTER_FLOWTBL_EMPTY,                    /* 0x0007000c, flow table entry is empty                                            */
+    RT_ERR_FILTER_FLOWTBL_EXIST,                    /* 0x0007000d, flow table entry is already exist                                    */
+    RT_ERR_FILTER_METER_ID,                         /* 0x0007000e, invalid metering id                                                  */
+    RT_ERR_FILTER_LOG_ID,                           /* 0x0007000f, invalid log id                                                       */
+    RT_ERR_FILTER_INACL_NONE_BEGIN_IDX,             /* 0x00070010, entry index is not starting index of a group of rules                */
+    RT_ERR_FILTER_INACL_ACT_NOT_SUPPORT,            /* 0x00070011, action not support                                                    */
+    RT_ERR_FILTER_INACL_RULE_NOT_SUPPORT,           /* 0x00070012, rule not support                                                   */
+
+    /* 0x0008xxxx for ACL Rate Limit */
+    RT_ERR_ACLRL_HTHR = 0x00080000,                 /* 0x00080000, invalid high threshold                                               */
+    RT_ERR_ACLRL_TIMESLOT,                          /* 0x00080001, invalid time slot                                                    */
+    RT_ERR_ACLRL_TOKEN,                             /* 0x00080002, invalid token amount                                                 */
+    RT_ERR_ACLRL_RATE,                              /* 0x00080003, invalid rate                                                         */
+
+    /* 0x0009xxxx for Link aggregation */
+    RT_ERR_LA_CPUPORT = 0x00090000,                 /* 0x00090000, CPU port can not be aggregated port                                  */
+    RT_ERR_LA_TRUNK_ID,                             /* 0x00090001, invalid trunk id                                                     */
+    RT_ERR_LA_PORTMASK,                             /* 0x00090002, invalid port mask                                                    */
+    RT_ERR_LA_HASHMASK,                             /* 0x00090003, invalid hash mask                                                    */
+    RT_ERR_LA_DUMB,                                 /* 0x00090004, this API should be used in 802.1ad dumb mode                         */
+    RT_ERR_LA_PORTNUM_DUMB,                         /* 0x00090005, it can only aggregate at most four ports when 802.1ad dumb mode      */
+    RT_ERR_LA_PORTNUM_NORMAL,                       /* 0x00090006, it can only aggregate at most eight ports when 802.1ad normal mode   */
+    RT_ERR_LA_MEMBER_OVERLAP,                       /* 0x00090007, the specified port mask is overlapped with other group               */
+    RT_ERR_LA_NOT_MEMBER_PORT,                      /* 0x00090008, the port is not a member port of the trunk                           */
+    RT_ERR_LA_TRUNK_NOT_EXIST,                      /* 0x00090009, the trunk doesn't exist                                              */
+
+
+    /* 0x000axxxx for storm filter */
+    RT_ERR_SFC_TICK_PERIOD = 0x000a0000,            /* 0x000a0000, invalid SFC tick period                                              */
+    RT_ERR_SFC_UNKNOWN_GROUP,                       /* 0x000a0001, Unknown Storm filter group                                           */
+
+    /* 0x000bxxxx for pattern match */
+    RT_ERR_PM_MASK = 0x000b0000,                    /* 0x000b0000, invalid pattern length. Pattern length should be 8                   */
+    RT_ERR_PM_LENGTH,                               /* 0x000b0001, invalid pattern match mask, first byte must care                     */
+    RT_ERR_PM_MODE,                                 /* 0x000b0002, invalid pattern match mode                                           */
+
+    /* 0x000cxxxx for input bandwidth control */
+    RT_ERR_INBW_TICK_PERIOD = 0x000c0000,           /* 0x000c0000, invalid tick period for input bandwidth control                      */
+    RT_ERR_INBW_TOKEN_AMOUNT,                       /* 0x000c0001, invalid amount of token for input bandwidth control                  */
+    RT_ERR_INBW_FCON_VALUE,                         /* 0x000c0002, invalid flow control ON threshold value for input bandwidth control  */
+    RT_ERR_INBW_FCOFF_VALUE,                        /* 0x000c0003, invalid flow control OFF threshold value for input bandwidth control */
+    RT_ERR_INBW_FC_ALLOWANCE,                       /* 0x000c0004, invalid allowance of incomming packet for input bandwidth control    */
+    RT_ERR_INBW_RATE,                               /* 0x000c0005, invalid input bandwidth                                              */
+
+    /* 0x000dxxxx for QoS */
+    RT_ERR_QOS_1P_PRIORITY = 0x000d0000,            /* 0x000d0000, invalid 802.1P priority                                              */
+    RT_ERR_QOS_DSCP_VALUE,                          /* 0x000d0001, invalid DSCP value                                                   */
+    RT_ERR_QOS_INT_PRIORITY,                        /* 0x000d0002, invalid internal priority                                            */
+    RT_ERR_QOS_SEL_DSCP_PRI,                        /* 0x000d0003, invalid DSCP selection priority                                      */
+    RT_ERR_QOS_SEL_PORT_PRI,                        /* 0x000d0004, invalid port selection priority                                      */
+    RT_ERR_QOS_SEL_IN_ACL_PRI,                      /* 0x000d0005, invalid ingress ACL selection priority                               */
+    RT_ERR_QOS_SEL_CLASS_PRI,                       /* 0x000d0006, invalid classifier selection priority                                */
+    RT_ERR_QOS_EBW_RATE,                            /* 0x000d0007, invalid egress bandwidth rate                                        */
+    RT_ERR_QOS_SCHE_TYPE,                           /* 0x000d0008, invalid QoS scheduling type                                          */
+    RT_ERR_QOS_QUEUE_WEIGHT,                        /* 0x000d0009, invalid Queue weight                                                 */
+    RT_ERR_QOS_SEL_PRI_SOURCE,                      /* 0x000d000a, invalid selection of priority source                                                 */
+
+    /* 0x000exxxx for port ability */
+    RT_ERR_PHY_PAGE_ID = 0x000e0000,                /* 0x000e0000, invalid PHY page id                                                  */
+    RT_ERR_PHY_REG_ID,                              /* 0x000e0001, invalid PHY reg id                                                   */
+    RT_ERR_PHY_DATAMASK,                            /* 0x000e0002, invalid PHY data mask                                                */
+    RT_ERR_PHY_AUTO_NEGO_MODE,                      /* 0x000e0003, invalid PHY auto-negotiation mode*/
+    RT_ERR_PHY_SPEED,                               /* 0x000e0004, invalid PHY speed setting                                            */
+    RT_ERR_PHY_DUPLEX,                              /* 0x000e0005, invalid PHY duplex setting                                           */
+    RT_ERR_PHY_FORCE_ABILITY,                       /* 0x000e0006, invalid PHY force mode ability parameter                             */
+    RT_ERR_PHY_FORCE_1000,                          /* 0x000e0007, invalid PHY force mode 1G speed setting                              */
+    RT_ERR_PHY_TXRX,                                /* 0x000e0008, invalid PHY tx/rx                                                    */
+    RT_ERR_PHY_ID,                                  /* 0x000e0009, invalid PHY id                                                       */
+    RT_ERR_PHY_RTCT_NOT_FINISH,                     /* 0x000e000a, PHY RTCT in progress                                                 */
+
+    /* 0x000fxxxx for mirror */
+    RT_ERR_MIRROR_DIRECTION = 0x000f0000,           /* 0x000f0000, invalid error mirror direction                                       */
+    RT_ERR_MIRROR_SESSION_FULL,                     /* 0x000f0001, mirroring session is full                                            */
+    RT_ERR_MIRROR_SESSION_NOEXIST,                  /* 0x000f0002, mirroring session not exist                                          */
+    RT_ERR_MIRROR_PORT_EXIST,                       /* 0x000f0003, mirroring port already exists                                        */
+    RT_ERR_MIRROR_PORT_NOT_EXIST,                   /* 0x000f0004, mirroring port does not exists                                       */
+    RT_ERR_MIRROR_PORT_FULL,                        /* 0x000f0005, Exceeds maximum number of supported mirroring port                   */
+
+    /* 0x0010xxxx for stat */
+    RT_ERR_STAT_INVALID_GLOBAL_CNTR = 0x00100000,   /* 0x00100000, Invalid Global Counter                                               */
+    RT_ERR_STAT_INVALID_PORT_CNTR,                  /* 0x00100001, Invalid Port Counter                                                 */
+    RT_ERR_STAT_GLOBAL_CNTR_FAIL,                   /* 0x00100002, Could not retrieve/reset Global Counter                              */
+    RT_ERR_STAT_PORT_CNTR_FAIL,                     /* 0x00100003, Could not retrieve/reset Port Counter                                */
+    RT_ERR_STAT_INVALID_CNTR,                       /* 0x00100004, Invalid Counter                                                      */
+    RT_ERR_STAT_CNTR_FAIL,                          /* 0x00100005, Could not retrieve/reset Counter                                     */
+
+    /* 0x0011xxxx for dot1x */
+    RT_ERR_DOT1X_INVALID_DIRECTION = 0x00110000,    /* 0x00110000, Invalid Authentication Direction                                     */
+    RT_ERR_DOT1X_PORTBASEDPNEN,                     /* 0x00110001, Port-based enable port error                                         */
+    RT_ERR_DOT1X_PORTBASEDAUTH,                     /* 0x00110002, Port-based auth port error                                           */
+    RT_ERR_DOT1X_PORTBASEDOPDIR,                    /* 0x00110003, Port-based opdir error                                               */
+    RT_ERR_DOT1X_MACBASEDPNEN,                      /* 0x00110004, MAC-based enable port error                                          */
+    RT_ERR_DOT1X_MACBASEDOPDIR,                     /* 0x00110005, MAC-based opdir error                                                */
+    RT_ERR_DOT1X_PROC,                              /* 0x00110006, unauthorized behavior error                                          */
+    RT_ERR_DOT1X_GVLANIDX,                          /* 0x00110007, guest vlan index error                                               */
+    RT_ERR_DOT1X_GVLANTALK,                         /* 0x00110008, guest vlan OPDIR error                                               */
+    RT_ERR_DOT1X_MAC_PORT_MISMATCH,                 /* 0x00110009, Auth MAC and port mismatch eror                                      */
+
+    RT_ERR_END                                       /* The symbol is the latest symbol                                                  */
+} rt_error_code_t;
+
+
+#endif /* __COMMON_RT_ERROR_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtk_hal.h b/drivers/net/phy/rtk/rtl8367c/include/rtk_hal.h
new file mode 100644
index 0000000000000..6ddb23f2ede7c
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtk_hal.h
@@ -0,0 +1,44 @@
+#ifndef __RTK_HAL_H__
+#define __RTK_HAL_H__
+#include "ra_ioctl.h"
+
+#define RTK_SW_VID_RANGE        16
+void rtk_hal_switch_init(void);
+void rtk_hal_dump_mib(void);
+void rtk_hal_dump_full_mib(void);
+int rtk_hal_dump_vlan(void);
+void rtk_hal_clear_vlan(void);
+int rtk_hal_set_vlan(struct ra_switch_ioctl_data *data);
+int rtk_hal_set_ingress_rate(struct ra_switch_ioctl_data *data);
+int rtk_hal_set_egress_rate(struct ra_switch_ioctl_data *data);
+void rtk_hal_dump_table(void);
+void rtk_hal_clear_table(void);
+void rtk_hal_get_phy_status(struct ra_switch_ioctl_data *data);
+void rtk_hal_set_port_mirror(struct ra_switch_ioctl_data *data);
+void rtk_hal_read_reg(struct ra_switch_ioctl_data *data);
+void rtk_hal_write_reg(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_en(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_set_table2type(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_get_table2type(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_set_port2table(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_get_port2table(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_set_port2pri(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_get_port2pri(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_set_dscp2pri(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_get_dscp2pri(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_set_pri2queue(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_get_pri2queue(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_set_queue_weight(struct ra_switch_ioctl_data *data);
+void rtk_hal_qos_get_queue_weight(struct ra_switch_ioctl_data *data);
+void rtk_hal_enable_igmpsnoop(struct ra_switch_ioctl_data *data);
+void rtk_hal_disable_igmpsnoop(void);
+void rtk_hal_set_phy_test_mode(struct ra_switch_ioctl_data *data);
+void rtk_hal_get_phy_reg(struct ra_switch_ioctl_data *data);
+void rtk_hal_set_phy_reg(struct ra_switch_ioctl_data *data);
+void rtk_hal_vlan_tag(struct ra_switch_ioctl_data *data);
+void rtk_hal_vlan_portpvid_set(rtk_port_t port, rtk_vlan_t pvid, rtk_pri_t priority);
+void rtk_hal_add_table(struct ra_switch_ioctl_data *data);
+void rtk_hal_del_table(struct ra_switch_ioctl_data *data);
+void rtk_hal_vlan_mode(struct ra_switch_ioctl_data *data);
+void rtk_hal_set_port_trunk(struct ra_switch_ioctl_data *data);
+#endif
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtk_switch.h b/drivers/net/phy/rtk/rtl8367c/include/rtk_switch.h
new file mode 100644
index 0000000000000..34df0fdb32e80
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtk_switch.h
@@ -0,0 +1,737 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76336 $
+ * $Date: 2017-03-09 10:41:21 +0800 (週四, 09 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API
+ * Feature : Here is a list of all functions and variables in this module.
+ *
+ */
+
+#ifndef __RTK_SWITCH_H__
+#define __RTK_SWITCH_H__
+
+#include <rtk_types.h>
+
+#define UNDEFINE_PHY_PORT   (0xFF)
+#define RTK_SWITCH_PORT_NUM (32)
+
+#define MAXPKTLEN_CFG_ID_MAX (1)
+
+#define RTK_SWITCH_MAX_PKTLEN (0x3FFF)
+
+typedef enum init_state_e
+{
+    INIT_NOT_COMPLETED = 0,
+    INIT_COMPLETED,
+    INIT_STATE_END
+} init_state_t;
+
+typedef enum switch_chip_e
+{
+    CHIP_RTL8367C = 0,
+    CHIP_RTL8370B,
+    CHIP_RTL8364B,
+    CHIP_RTL8363SC_VB,
+    CHIP_END
+}switch_chip_t;
+
+typedef enum port_type_e
+{
+    UTP_PORT = 0,
+    EXT_PORT,
+    UNKNOWN_PORT = 0xFF,
+    PORT_TYPE_END
+}port_type_t;
+
+typedef struct rtk_switch_halCtrl_s
+{
+    switch_chip_t   switch_type;
+    rtk_uint32      l2p_port[RTK_SWITCH_PORT_NUM];
+    rtk_uint32      p2l_port[RTK_SWITCH_PORT_NUM];
+    port_type_t     log_port_type[RTK_SWITCH_PORT_NUM];
+    rtk_uint32      ptp_port[RTK_SWITCH_PORT_NUM];
+    rtk_uint32      valid_portmask;
+    rtk_uint32      valid_utp_portmask;
+    rtk_uint32      valid_ext_portmask;
+    rtk_uint32      valid_cpu_portmask;
+    rtk_uint32      min_phy_port;
+    rtk_uint32      max_phy_port;
+    rtk_uint32      phy_portmask;
+    rtk_uint32      combo_logical_port;
+    rtk_uint32      hsg_logical_port;
+    rtk_uint32      sg_logical_portmask;
+    rtk_uint32      max_meter_id;
+    rtk_uint32      max_lut_addr_num;
+    rtk_uint32      trunk_group_mask;
+
+}rtk_switch_halCtrl_t;
+
+typedef enum rtk_switch_maxPktLen_linkSpeed_e {
+     MAXPKTLEN_LINK_SPEED_FE = 0,
+     MAXPKTLEN_LINK_SPEED_GE,
+     MAXPKTLEN_LINK_SPEED_END,
+} rtk_switch_maxPktLen_linkSpeed_t;
+
+
+/* UTIL MACRO */
+#define RTK_CHK_INIT_STATE()                                \
+    do                                                      \
+    {                                                       \
+        if(rtk_switch_initialState_get() != INIT_COMPLETED) \
+        {                                                   \
+            return RT_ERR_NOT_INIT;                         \
+        }                                                   \
+    }while(0)
+
+#define RTK_CHK_PORT_VALID(__port__)                            \
+    do                                                          \
+    {                                                           \
+        if(rtk_switch_logicalPortCheck(__port__) != RT_ERR_OK)  \
+        {                                                       \
+            return RT_ERR_PORT_ID;                              \
+        }                                                       \
+    }while(0)
+
+#define RTK_CHK_PORT_IS_UTP(__port__)                           \
+    do                                                          \
+    {                                                           \
+        if(rtk_switch_isUtpPort(__port__) != RT_ERR_OK)         \
+        {                                                       \
+            return RT_ERR_PORT_ID;                              \
+        }                                                       \
+    }while(0)
+
+#define RTK_CHK_PORT_IS_EXT(__port__)                           \
+    do                                                          \
+    {                                                           \
+        if(rtk_switch_isExtPort(__port__) != RT_ERR_OK)         \
+        {                                                       \
+            return RT_ERR_PORT_ID;                              \
+        }                                                       \
+    }while(0)
+
+#define RTK_CHK_PORT_IS_COMBO(__port__)                         \
+    do                                                          \
+    {                                                           \
+        if(rtk_switch_isComboPort(__port__) != RT_ERR_OK)       \
+        {                                                       \
+            return RT_ERR_PORT_ID;                              \
+        }                                                       \
+    }while(0)
+
+#define RTK_CHK_PORT_IS_PTP(__port__)                           \
+    do                                                          \
+    {                                                           \
+        if(rtk_switch_isPtpPort(__port__) != RT_ERR_OK)         \
+        {                                                       \
+            return RT_ERR_PORT_ID;                              \
+        }                                                       \
+    }while(0)
+
+#define RTK_CHK_PORTMASK_VALID(__portmask__)                        \
+    do                                                              \
+    {                                                               \
+        if(rtk_switch_isPortMaskValid(__portmask__) != RT_ERR_OK)   \
+        {                                                           \
+            return RT_ERR_PORT_MASK;                                \
+        }                                                           \
+    }while(0)
+
+#define RTK_CHK_PORTMASK_VALID_ONLY_UTP(__portmask__)               \
+    do                                                              \
+    {                                                               \
+        if(rtk_switch_isPortMaskUtp(__portmask__) != RT_ERR_OK)     \
+        {                                                           \
+            return RT_ERR_PORT_MASK;                                \
+        }                                                           \
+    }while(0)
+
+#define RTK_CHK_PORTMASK_VALID_ONLY_EXT(__portmask__)               \
+    do                                                              \
+    {                                                               \
+        if(rtk_switch_isPortMaskExt(__portmask__) != RT_ERR_OK)     \
+        {                                                           \
+            return RT_ERR_PORT_MASK;                                \
+        }                                                           \
+    }while(0)
+
+#define RTK_CHK_TRUNK_GROUP_VALID(__grpId__)                        \
+    do                                                              \
+    {                                                               \
+        if(rtk_switch_isValidTrunkGrpId(__grpId__) != RT_ERR_OK)    \
+        {                                                           \
+            return RT_ERR_LA_TRUNK_ID;                              \
+        }                                                           \
+    }while(0)
+
+#define RTK_PORTMASK_IS_PORT_SET(__portmask__, __port__)    (((__portmask__).bits[0] & (0x00000001 << __port__)) ? 1 : 0)
+#define RTK_PORTMASK_IS_EMPTY(__portmask__)                 (((__portmask__).bits[0] == 0) ? 1 : 0)
+#define RTK_PORTMASK_CLEAR(__portmask__)                    ((__portmask__).bits[0] = 0)
+#define RTK_PORTMASK_PORT_SET(__portmask__, __port__)       ((__portmask__).bits[0] |= (0x00000001 << __port__))
+#define RTK_PORTMASK_PORT_CLEAR(__portmask__, __port__)     ((__portmask__).bits[0] &= ~(0x00000001 << __port__))
+#define RTK_PORTMASK_ALLPORT_SET(__portmask__)              (rtk_switch_logPortMask_get(&__portmask__))
+#define RTK_PORTMASK_SCAN(__portmask__, __port__)           for(__port__ = 0; __port__ < RTK_SWITCH_PORT_NUM; __port__++)  if(RTK_PORTMASK_IS_PORT_SET(__portmask__, __port__))
+#define RTK_PORTMASK_COMPARE(__portmask_A__, __portmask_B__)    ((__portmask_A__).bits[0] - (__portmask_B__).bits[0])
+
+#define RTK_SCAN_ALL_PHY_PORTMASK(__port__)                 for(__port__ = 0; __port__ < RTK_SWITCH_PORT_NUM; __port__++)  if( (rtk_switch_phyPortMask_get() & (0x00000001 << __port__)))
+#define RTK_SCAN_ALL_LOG_PORT(__port__)                     for(__port__ = 0; __port__ < RTK_SWITCH_PORT_NUM; __port__++)  if( rtk_switch_logicalPortCheck(__port__) == RT_ERR_OK)
+#define RTK_SCAN_ALL_LOG_PORTMASK(__portmask__)             for((__portmask__).bits[0] = 0; (__portmask__).bits[0] < 0x7FFFF; (__portmask__).bits[0]++)  if( rtk_switch_isPortMaskValid(&__portmask__) == RT_ERR_OK)
+
+/* Port mask defination */
+#define RTK_PHY_PORTMASK_ALL                                (rtk_switch_phyPortMask_get())
+
+/* Port defination*/
+#define RTK_MAX_LOGICAL_PORT_ID                             (rtk_switch_maxLogicalPort_get())
+
+/* Function Name:
+ *      rtk_switch_probe
+ * Description:
+ *      Probe switch
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Switch probed
+ *      RT_ERR_FAILED   - Switch Unprobed.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_probe(switch_chip_t *pSwitchChip);
+
+/* Function Name:
+ *      rtk_switch_initialState_set
+ * Description:
+ *      Set initial status
+ * Input:
+ *      state   - Initial state;
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Initialized
+ *      RT_ERR_FAILED   - Uninitialized
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_initialState_set(init_state_t state);
+
+/* Function Name:
+ *      rtk_switch_initialState_get
+ * Description:
+ *      Get initial status
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      INIT_COMPLETED     - Initialized
+ *      INIT_NOT_COMPLETED - Uninitialized
+ * Note:
+ *
+ */
+extern init_state_t rtk_switch_initialState_get(void);
+
+/* Function Name:
+ *      rtk_switch_logicalPortCheck
+ * Description:
+ *      Check logical port ID.
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is correct
+ *      RT_ERR_FAILED   - Port ID is not correct
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_logicalPortCheck(rtk_port_t logicalPort);
+
+/* Function Name:
+ *      rtk_switch_isUtpPort
+ * Description:
+ *      Check is logical port a UTP port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a UTP port
+ *      RT_ERR_FAILED   - Port ID is not a UTP port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_isUtpPort(rtk_port_t logicalPort);
+
+/* Function Name:
+ *      rtk_switch_isExtPort
+ * Description:
+ *      Check is logical port a Extension port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a EXT port
+ *      RT_ERR_FAILED   - Port ID is not a EXT port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_isExtPort(rtk_port_t logicalPort);
+
+/* Function Name:
+ *      rtk_switch_isHsgPort
+ * Description:
+ *      Check is logical port a HSG port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a HSG port
+ *      RT_ERR_FAILED   - Port ID is not a HSG port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_isHsgPort(rtk_port_t logicalPort);
+
+/* Function Name:
+ *      rtk_switch_isSgmiiPort
+ * Description:
+ *      Check is logical port a SGMII port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a SGMII port
+ *      RT_ERR_FAILED   - Port ID is not a SGMII port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_isSgmiiPort(rtk_port_t logicalPort);
+
+/* Function Name:
+ *      rtk_switch_isCPUPort
+ * Description:
+ *      Check is logical port a CPU port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a CPU port
+ *      RT_ERR_FAILED   - Port ID is not a CPU port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_isCPUPort(rtk_port_t logicalPort);
+
+/* Function Name:
+ *      rtk_switch_isComboPort
+ * Description:
+ *      Check is logical port a Combo port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a combo port
+ *      RT_ERR_FAILED   - Port ID is not a combo port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_isComboPort(rtk_port_t logicalPort);
+
+/* Function Name:
+ *      rtk_switch_ComboPort_get
+ * Description:
+ *      Get Combo port ID
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      Port ID of combo port
+ * Note:
+ *
+ */
+extern rtk_uint32 rtk_switch_ComboPort_get(void);
+
+/* Function Name:
+ *      rtk_switch_isPtpPort
+ * Description:
+ *      Check is logical port a PTP port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a PTP port
+ *      RT_ERR_FAILED   - Port ID is not a PTP port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_isPtpPort(rtk_port_t logicalPort);
+
+/* Function Name:
+ *      rtk_switch_port_L2P_get
+ * Description:
+ *      Get physical port ID
+ * Input:
+ *      logicalPort       - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      Physical port ID
+ * Note:
+ *
+ */
+extern rtk_uint32 rtk_switch_port_L2P_get(rtk_port_t logicalPort);
+
+/* Function Name:
+ *      rtk_switch_port_P2L_get
+ * Description:
+ *      Get logical port ID
+ * Input:
+ *      physicalPort       - physical port ID
+ * Output:
+ *      None
+ * Return:
+ *      logical port ID
+ * Note:
+ *
+ */
+extern rtk_port_t rtk_switch_port_P2L_get(rtk_uint32 physicalPort);
+
+/* Function Name:
+ *      rtk_switch_isPortMaskValid
+ * Description:
+ *      Check portmask is valid or not
+ * Input:
+ *      pPmask       - logical port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - port mask is valid
+ *      RT_ERR_FAILED       - port mask is not valid
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_isPortMaskValid(rtk_portmask_t *pPmask);
+
+/* Function Name:
+ *      rtk_switch_isPortMaskUtp
+ * Description:
+ *      Check all ports in portmask are only UTP port
+ * Input:
+ *      pPmask       - logical port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Only UTP port in port mask
+ *      RT_ERR_FAILED       - Not only UTP port in port mask
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_isPortMaskUtp(rtk_portmask_t *pPmask);
+
+/* Function Name:
+ *      rtk_switch_isPortMaskExt
+ * Description:
+ *      Check all ports in portmask are only EXT port
+ * Input:
+ *      pPmask       - logical port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Only EXT port in port mask
+ *      RT_ERR_FAILED       - Not only EXT port in port mask
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_isPortMaskExt(rtk_portmask_t *pPmask);
+
+/* Function Name:
+ *      rtk_switch_portmask_L2P_get
+ * Description:
+ *      Get physicl portmask from logical portmask
+ * Input:
+ *      pLogicalPmask       - logical port mask
+ * Output:
+ *      pPhysicalPortmask   - physical port mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ *      RT_ERR_PORT_MASK    - Error port mask
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_portmask_L2P_get(rtk_portmask_t *pLogicalPmask, rtk_uint32 *pPhysicalPortmask);
+
+/* Function Name:
+ *      rtk_switch_portmask_P2L_get
+ * Description:
+ *      Get logical portmask from physical portmask
+ * Input:
+ *      physicalPortmask    - physical port mask
+ * Output:
+ *      pLogicalPmask       - logical port mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ *      RT_ERR_PORT_MASK    - Error port mask
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_switch_portmask_P2L_get(rtk_uint32 physicalPortmask, rtk_portmask_t *pLogicalPmask);
+
+/* Function Name:
+ *      rtk_switch_phyPortMask_get
+ * Description:
+ *      Get physical portmask
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      0x00                - Not Initialize
+ *      Other value         - Physical port mask
+ * Note:
+ *
+ */
+rtk_uint32 rtk_switch_phyPortMask_get(void);
+
+/* Function Name:
+ *      rtk_switch_logPortMask_get
+ * Description:
+ *      Get Logical portmask
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_logPortMask_get(rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_switch_init
+ * Description:
+ *      Set chip to default configuration enviroment
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      The API can set chip registers to default configuration for different release chip model.
+ */
+extern rtk_api_ret_t rtk_switch_init(void);
+
+/* Function Name:
+ *      rtk_switch_portMaxPktLen_set
+ * Description:
+ *      Set Max packet length
+ * Input:
+ *      port    - Port ID
+ *      speed   - Speed
+ *      cfgId   - Configuration ID
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ */
+extern rtk_api_ret_t rtk_switch_portMaxPktLen_set(rtk_port_t port, rtk_switch_maxPktLen_linkSpeed_t speed, rtk_uint32 cfgId);
+
+/* Function Name:
+ *      rtk_switch_portMaxPktLen_get
+ * Description:
+ *      Get Max packet length
+ * Input:
+ *      port    - Port ID
+ *      speed   - Speed
+ * Output:
+ *      pCfgId  - Configuration ID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ */
+extern rtk_api_ret_t rtk_switch_portMaxPktLen_get(rtk_port_t port, rtk_switch_maxPktLen_linkSpeed_t speed, rtk_uint32 *pCfgId);
+
+/* Function Name:
+ *      rtk_switch_maxPktLenCfg_set
+ * Description:
+ *      Set Max packet length configuration
+ * Input:
+ *      cfgId   - Configuration ID
+ *      pktLen  - Max packet length
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ */
+extern rtk_api_ret_t rtk_switch_maxPktLenCfg_set(rtk_uint32 cfgId, rtk_uint32 pktLen);
+
+/* Function Name:
+ *      rtk_switch_maxPktLenCfg_get
+ * Description:
+ *      Get Max packet length configuration
+ * Input:
+ *      cfgId   - Configuration ID
+ *      pPktLen - Max packet length
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ */
+extern rtk_api_ret_t rtk_switch_maxPktLenCfg_get(rtk_uint32 cfgId, rtk_uint32 *pPktLen);
+
+/* Function Name:
+ *      rtk_switch_greenEthernet_set
+ * Description:
+ *      Set all Ports Green Ethernet state.
+ * Input:
+ *      enable - Green Ethernet state.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - OK
+ *      RT_ERR_FAILED   - Failed
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_ENABLE   - Invalid enable input.
+ * Note:
+ *      This API can set all Ports Green Ethernet state.
+ *      The configuration is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+extern rtk_api_ret_t rtk_switch_greenEthernet_set(rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_switch_greenEthernet_get
+ * Description:
+ *      Get all Ports Green Ethernet state.
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - Green Ethernet state.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API can get Green Ethernet state.
+ */
+extern rtk_api_ret_t rtk_switch_greenEthernet_get(rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_switch_maxLogicalPort_get
+ * Description:
+ *      Get Max logical port ID
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      Max logical port
+ * Note:
+ *      This API can get max logical port
+ */
+extern rtk_port_t rtk_switch_maxLogicalPort_get(void);
+
+/* Function Name:
+ *      rtk_switch_maxMeterId_get
+ * Description:
+ *      Get Max Meter ID
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      0x00                - Not Initialize
+ *      Other value         - Max Meter ID
+ * Note:
+ *
+ */
+extern rtk_uint32 rtk_switch_maxMeterId_get(void);
+
+/* Function Name:
+ *      rtk_switch_maxLutAddrNumber_get
+ * Description:
+ *      Get Max LUT Address number
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      0x00                - Not Initialize
+ *      Other value         - Max LUT Address number
+ * Note:
+ *
+ */
+extern rtk_uint32 rtk_switch_maxLutAddrNumber_get(void);
+
+/* Function Name:
+ *      rtk_switch_isValidTrunkGrpId
+ * Description:
+ *      Check if trunk group is valid or not
+ * Input:
+ *      grpId       - Group ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Trunk Group ID is valid
+ *      RT_ERR_LA_TRUNK_ID  - Trunk Group ID is not valid
+ * Note:
+ *
+ */
+rtk_uint32 rtk_switch_isValidTrunkGrpId(rtk_uint32 grpId);
+
+#endif
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtk_types.h b/drivers/net/phy/rtk/rtl8367c/include/rtk_types.h
new file mode 100644
index 0000000000000..589ecb78114a9
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtk_types.h
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level type enum definition.
+ * Feature :
+ *
+ */
+
+#ifndef _RTL8367C_TYPES_H_
+#define _RTL8367C_TYPES_H_
+
+//#include <stdio.h>
+
+typedef unsigned long long      rtk_uint64;
+typedef long long               rtk_int64;
+typedef unsigned int            rtk_uint32;
+typedef int                     rtk_int32;
+typedef unsigned short          rtk_uint16;
+typedef short                   rtk_int16;
+typedef unsigned char           rtk_uint8;
+typedef char                    rtk_int8;
+
+#define CONST_T     const
+
+#define RTK_TOTAL_NUM_OF_WORD_FOR_1BIT_PORT_LIST    1
+
+#define RTK_MAX_NUM_OF_PORT                         8
+#define RTK_PORT_ID_MAX                             (RTK_MAX_NUM_OF_PORT-1)
+#define RTK_PHY_ID_MAX                              (RTK_MAX_NUM_OF_PORT-4)
+#define RTK_MAX_PORT_MASK                           0xFF
+
+#define RTK_WHOLE_SYSTEM                            0xFF
+
+typedef struct rtk_portmask_s
+{
+    rtk_uint32  bits[RTK_TOTAL_NUM_OF_WORD_FOR_1BIT_PORT_LIST];
+} rtk_portmask_t;
+
+typedef enum rtk_enable_e
+{
+    DISABLED = 0,
+    ENABLED,
+    RTK_ENABLE_END
+} rtk_enable_t;
+
+#ifndef ETHER_ADDR_LEN
+#define ETHER_ADDR_LEN      6
+#endif
+
+/* ethernet address type */
+typedef struct  rtk_mac_s
+{
+    rtk_uint8 octet[ETHER_ADDR_LEN];
+} rtk_mac_t;
+
+typedef rtk_uint32  rtk_pri_t;      /* priority vlaue */
+typedef rtk_uint32  rtk_qid_t;      /* queue id type */
+typedef rtk_uint32  rtk_data_t;
+typedef rtk_uint32  rtk_dscp_t;     /* dscp vlaue */
+typedef rtk_uint32  rtk_fid_t;      /* filter id type */
+typedef rtk_uint32  rtk_vlan_t;     /* vlan id type */
+typedef rtk_uint32  rtk_mac_cnt_t;  /* MAC count type  */
+typedef rtk_uint32  rtk_meter_id_t; /* meter id type  */
+typedef rtk_uint32  rtk_rate_t;     /* rate type  */
+
+typedef enum rtk_port_e
+{
+    UTP_PORT0 = 0,
+    UTP_PORT1,
+    UTP_PORT2,
+    UTP_PORT3,
+    UTP_PORT4,
+    UTP_PORT5,
+    UTP_PORT6,
+    UTP_PORT7,
+
+    EXT_PORT0 = 16,
+    EXT_PORT1,
+    EXT_PORT2,
+
+    UNDEFINE_PORT = 30,
+    RTK_PORT_MAX = 31
+} rtk_port_t;
+
+
+#ifndef _RTL_TYPES_H
+
+#if 0
+typedef unsigned long long      uint64;
+typedef long long               int64;
+typedef unsigned int            uint32;
+typedef int                     int32;
+typedef unsigned short          uint16;
+typedef short                   int16;
+typedef unsigned char           uint8;
+typedef char                    int8;
+#endif
+
+typedef rtk_uint32                  ipaddr_t;
+typedef rtk_uint32                  memaddr;
+
+#ifndef ETHER_ADDR_LEN
+#define ETHER_ADDR_LEN      6
+#endif
+
+typedef struct ether_addr_s {
+    rtk_uint8 octet[ETHER_ADDR_LEN];
+} ether_addr_t;
+
+#ifdef __KERNEL__
+#define rtlglue_printf printk
+#else
+#define rtlglue_printf printf
+#endif
+#define PRINT           rtlglue_printf
+#endif /*_RTL_TYPES_H*/
+
+/* type abstraction */
+#ifdef EMBEDDED_SUPPORT
+
+typedef rtk_int16                   rtk_api_ret_t;
+typedef rtk_int16                   ret_t;
+typedef rtk_uint32                  rtk_u_long;
+
+#else
+
+typedef rtk_int32                   rtk_api_ret_t;
+typedef rtk_int32                   ret_t;
+typedef rtk_uint64                  rtk_u_long_t;
+
+#endif
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#define CONST           const
+#endif /* _RTL8367C_TYPES_H_ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv.h
new file mode 100644
index 0000000000000..55cb41b067287
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature :
+ *
+ */
+
+
+#ifndef _RTL8367C_ASICDRV_H_
+#define _RTL8367C_ASICDRV_H_
+
+#include <rtk_types.h>
+#include <rtk_error.h>
+#include <rtl8367c_reg.h>
+#include <rtl8367c_base.h>
+
+#define RTL8367C_REGBITLENGTH               16
+#define RTL8367C_REGDATAMAX                 0xFFFF
+
+#define RTL8367C_VIDMAX                     0xFFF
+#define RTL8367C_EVIDMAX                    0x1FFF
+#define RTL8367C_CVIDXNO                    32
+#define RTL8367C_CVIDXMAX                   (RTL8367C_CVIDXNO-1)
+
+#define RTL8367C_PRIMAX                     7
+#define RTL8367C_DSCPMAX                    63
+
+#define RTL8367C_PORTNO                     11
+#define RTL8367C_PORTIDMAX                  (RTL8367C_PORTNO-1)
+#define RTL8367C_PMSKMAX                    ((1<<(RTL8367C_PORTNO))-1)
+#define RTL8367C_PORTMASK                   0x7FF
+
+#define RTL8367C_PHYNO                      5
+#define RTL8367C_PHYIDMAX                  (RTL8367C_PHYNO-1)
+
+#define RTL8367C_SVIDXNO                    64
+#define RTL8367C_SVIDXMAX                   (RTL8367C_SVIDXNO-1)
+#define RTL8367C_MSTIMAX                    15
+
+#define RTL8367C_METERNO                    64
+#define RTL8367C_METERMAX                   (RTL8367C_METERNO-1)
+#define RTL8367C_METERBUCKETSIZEMAX         0xFFFF
+
+#define RTL8367C_QUEUENO                    8
+#define RTL8367C_QIDMAX                     (RTL8367C_QUEUENO-1)
+
+#define RTL8367C_PHY_BUSY_CHECK_COUNTER     1000
+
+#define RTL8367C_QOS_GRANULARTY_MAX         0x7FFFF
+#define RTL8367C_QOS_GRANULARTY_LSB_MASK    0xFFFF
+#define RTL8367C_QOS_GRANULARTY_LSB_OFFSET  0
+#define RTL8367C_QOS_GRANULARTY_MSB_MASK    0x70000
+#define RTL8367C_QOS_GRANULARTY_MSB_OFFSET  16
+
+#define RTL8367C_QOS_GRANULARTY_UNIT_KBPS   8
+
+#define RTL8367C_QOS_RATE_INPUT_MAX         (0x1FFFF * 8)
+#define RTL8367C_QOS_RATE_INPUT_MAX_HSG     (0x7FFFF * 8)
+#define RTL8367C_QOS_RATE_INPUT_MIN         8
+#define RTL8367C_QOS_PPS_INPUT_MAX          (0x7FFFF)
+#define RTL8367C_QOS_PPS_INPUT_MIN          1
+
+#define RTL8367C_QUEUE_MASK                 0xFF
+
+#define RTL8367C_EFIDMAX                    0x7
+#define RTL8367C_FIDMAX                     0xF
+
+#define RTL8367C_EAV_SECONDMAX                  0xFFFFFFFF
+#define RTL8367C_EAV_NANOSECONDMAX          0x3B9AC9FF
+
+
+/* the above macro is generated by genDotH */
+#define RTL8367C_VALID_REG_NO               3869
+
+/*=======================================================================
+ *  Enum
+ *========================================================================*/
+enum RTL8367C_TABLE_ACCESS_OP
+{
+    TB_OP_READ = 0,
+    TB_OP_WRITE
+};
+
+enum RTL8367C_TABLE_ACCESS_TARGET
+{
+    TB_TARGET_ACLRULE = 1,
+    TB_TARGET_ACLACT,
+    TB_TARGET_CVLAN,
+    TB_TARGET_L2,
+    TB_TARGET_IGMP_GROUP
+};
+
+#define RTL8367C_TABLE_ACCESS_REG_DATA(op, target)    ((op << 3) | target)
+
+/*=======================================================================
+ *  Structures
+ *========================================================================*/
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern ret_t rtl8367c_setAsicRegBit(rtk_uint32 reg, rtk_uint32 bit, rtk_uint32 value);
+extern ret_t rtl8367c_getAsicRegBit(rtk_uint32 reg, rtk_uint32 bit, rtk_uint32 *pValue);
+
+extern ret_t rtl8367c_setAsicRegBits(rtk_uint32 reg, rtk_uint32 bits, rtk_uint32 value);
+extern ret_t rtl8367c_getAsicRegBits(rtk_uint32 reg, rtk_uint32 bits, rtk_uint32 *pValue);
+
+extern ret_t rtl8367c_setAsicReg(rtk_uint32 reg, rtk_uint32 value);
+extern ret_t rtl8367c_getAsicReg(rtk_uint32 reg, rtk_uint32 *pValue);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+#endif /*#ifndef _RTL8367C_ASICDRV_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_acl.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_acl.h
new file mode 100644
index 0000000000000..8ae69ac332c24
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_acl.h
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : ACL related function drivers
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_ACL_H_
+#define _RTL8367C_ASICDRV_ACL_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_ACLRULENO                  96
+
+#define RTL8367C_ACLRULEMAX                 (RTL8367C_ACLRULENO-1)
+#define RTL8367C_ACLRULEFIELDNO             8
+#define RTL8367C_ACLTEMPLATENO              5
+#define RTL8367C_ACLTYPEMAX                 (RTL8367C_ACLTEMPLATENO-1)
+
+#define RTL8367C_ACLRULETBLEN               9
+#define RTL8367C_ACLACTTBLEN                4
+#define RTL8367C_ACLRULETBADDR(type, rule)  ((type << 6) | rule)
+#define RTL8367C_ACLRULETBADDR2(type, rule) ((type << 5) | (rule + 64))
+
+#define ACL_ACT_CVLAN_ENABLE_MASK           0x1
+#define ACL_ACT_SVLAN_ENABLE_MASK           0x2
+#define ACL_ACT_PRIORITY_ENABLE_MASK        0x4
+#define ACL_ACT_POLICING_ENABLE_MASK        0x8
+#define ACL_ACT_FWD_ENABLE_MASK             0x10
+#define ACL_ACT_INTGPIO_ENABLE_MASK         0x20
+
+#define RTL8367C_ACLRULETAGBITS             5
+
+#define RTL8367C_ACLRANGENO                 16
+
+#define RTL8367C_ACLRANGEMAX                (RTL8367C_ACLRANGENO-1)
+
+#define RTL8367C_ACL_PORTRANGEMAX           (0xFFFF)
+#define RTL8367C_ACL_ACT_TABLE_LEN          (4)
+
+enum ACLTCAMTYPES
+{
+    CAREBITS= 0,
+    DATABITS
+};
+
+typedef enum aclFwdAct
+{
+    RTL8367C_ACL_FWD_MIRROR = 0,
+    RTL8367C_ACL_FWD_REDIRECT,
+    RTL8367C_ACL_FWD_MIRRORFUNTION,
+    RTL8367C_ACL_FWD_TRAP,
+} rtl8367c_aclFwd_t;
+
+enum ACLFIELDTYPES
+{
+    ACL_UNUSED,
+    ACL_DMAC0,
+    ACL_DMAC1,
+    ACL_DMAC2,
+    ACL_SMAC0,
+    ACL_SMAC1,
+    ACL_SMAC2,
+    ACL_ETHERTYPE,
+    ACL_STAG,
+    ACL_CTAG,
+    ACL_IP4SIP0 = 0x10,
+    ACL_IP4SIP1,
+    ACL_IP4DIP0,
+    ACL_IP4DIP1,
+    ACL_IP6SIP0WITHIPV4 = 0x20,
+    ACL_IP6SIP1WITHIPV4,
+    ACL_IP6DIP0WITHIPV4 = 0x28,
+    ACL_IP6DIP1WITHIPV4,
+    ACL_VIDRANGE = 0x30,
+    ACL_IPRANGE,
+    ACL_PORTRANGE,
+    ACL_FIELD_VALID,
+    ACL_FIELD_SELECT00 = 0x40,
+    ACL_FIELD_SELECT01,
+    ACL_FIELD_SELECT02,
+    ACL_FIELD_SELECT03,
+    ACL_FIELD_SELECT04,
+    ACL_FIELD_SELECT05,
+    ACL_FIELD_SELECT06,
+    ACL_FIELD_SELECT07,
+    ACL_FIELD_SELECT08,
+    ACL_FIELD_SELECT09,
+    ACL_FIELD_SELECT10,
+    ACL_FIELD_SELECT11,
+    ACL_FIELD_SELECT12,
+    ACL_FIELD_SELECT13,
+    ACL_FIELD_SELECT14,
+    ACL_FIELD_SELECT15,
+    ACL_TCPSPORT = 0x80,
+    ACL_TCPDPORT,
+    ACL_TCPFLAG,
+    ACL_UDPSPORT,
+    ACL_UDPDPORT,
+    ACL_ICMPCODETYPE,
+    ACL_IGMPTYPE,
+    ACL_SPORT,
+    ACL_DPORT,
+    ACL_IP4TOSPROTO,
+    ACL_IP4FLAGOFF,
+    ACL_TCNH,
+    ACL_CPUTAG,
+    ACL_L2PAYLOAD,
+    ACL_IP6SIP0,
+    ACL_IP6SIP1,
+    ACL_IP6SIP2,
+    ACL_IP6SIP3,
+    ACL_IP6SIP4,
+    ACL_IP6SIP5,
+    ACL_IP6SIP6,
+    ACL_IP6SIP7,
+    ACL_IP6DIP0,
+    ACL_IP6DIP1,
+    ACL_IP6DIP2,
+    ACL_IP6DIP3,
+    ACL_IP6DIP4,
+    ACL_IP6DIP5,
+    ACL_IP6DIP6,
+    ACL_IP6DIP7,
+    ACL_TYPE_END
+};
+
+struct acl_rule_smi_st{
+    rtk_uint16 rule_info;
+    rtk_uint16 field[RTL8367C_ACLRULEFIELDNO];
+};
+
+struct acl_rule_smi_ext_st{
+    rtk_uint16 rule_info;
+};
+
+typedef struct ACLRULESMI{
+    struct acl_rule_smi_st  care_bits;
+    rtk_uint16      valid:1;
+    struct acl_rule_smi_st  data_bits;
+
+    struct acl_rule_smi_ext_st care_bits_ext;
+    struct acl_rule_smi_ext_st data_bits_ext;
+}rtl8367c_aclrulesmi;
+
+struct acl_rule_st{
+    rtk_uint16 active_portmsk:11;
+    rtk_uint16 type:3;
+    rtk_uint16 tag_exist:5;
+    rtk_uint16 field[RTL8367C_ACLRULEFIELDNO];
+};
+
+typedef struct ACLRULE{
+    struct acl_rule_st  data_bits;
+    rtk_uint16      valid:1;
+    struct acl_rule_st  care_bits;
+}rtl8367c_aclrule;
+
+
+typedef struct rtl8367c_acltemplate_s{
+    rtk_uint8 field[8];
+}rtl8367c_acltemplate_t;
+
+
+typedef struct acl_act_s{
+    rtk_uint16 cvidx_cact:7;
+    rtk_uint16 cact:2;
+    rtk_uint16 svidx_sact:7;
+    rtk_uint16 sact:2;
+
+
+    rtk_uint16 aclmeteridx:7;
+    rtk_uint16 fwdpmask:11;
+    rtk_uint16 fwdact:2;
+
+    rtk_uint16 pridx:7;
+    rtk_uint16 priact:2;
+    rtk_uint16 gpio_pin:4;
+    rtk_uint16 gpio_en:1;
+    rtk_uint16 aclint:1;
+
+    rtk_uint16 cact_ext:2;
+    rtk_uint16 fwdact_ext:1;
+    rtk_uint16 tag_fmt:2;
+}rtl8367c_acl_act_t;
+
+typedef struct acl_rule_union_s
+{
+    rtl8367c_aclrule aclRule;
+    rtl8367c_acl_act_t aclAct;
+    rtk_uint32 aclActCtrl;
+    rtk_uint32 aclNot;
+}rtl8367c_acl_rule_union_t;
+
+
+extern ret_t rtl8367c_setAsicAcl(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicAcl(rtk_uint32 port, rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicAclUnmatchedPermit(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicAclUnmatchedPermit(rtk_uint32 port, rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicAclRule(rtk_uint32 index, rtl8367c_aclrule *pAclRule);
+extern ret_t rtl8367c_getAsicAclRule(rtk_uint32 index, rtl8367c_aclrule *pAclRule);
+extern ret_t rtl8367c_setAsicAclNot(rtk_uint32 index, rtk_uint32 not);
+extern ret_t rtl8367c_getAsicAclNot(rtk_uint32 index, rtk_uint32* pNot);
+extern ret_t rtl8367c_setAsicAclTemplate(rtk_uint32 index, rtl8367c_acltemplate_t* pAclType);
+extern ret_t rtl8367c_getAsicAclTemplate(rtk_uint32 index, rtl8367c_acltemplate_t *pAclType);
+extern ret_t rtl8367c_setAsicAclAct(rtk_uint32 index, rtl8367c_acl_act_t* pAclAct);
+extern ret_t rtl8367c_getAsicAclAct(rtk_uint32 index, rtl8367c_acl_act_t *pAclAct);
+extern ret_t rtl8367c_setAsicAclActCtrl(rtk_uint32 index, rtk_uint32 aclActCtrl);
+extern ret_t rtl8367c_getAsicAclActCtrl(rtk_uint32 index, rtk_uint32 *aclActCtrl);
+extern ret_t rtl8367c_setAsicAclPortRange(rtk_uint32 index, rtk_uint32 type, rtk_uint32 upperPort, rtk_uint32 lowerPort);
+extern ret_t rtl8367c_getAsicAclPortRange(rtk_uint32 index, rtk_uint32* pType, rtk_uint32* pUpperPort, rtk_uint32* pLowerPort);
+extern ret_t rtl8367c_setAsicAclVidRange(rtk_uint32 index, rtk_uint32 type, rtk_uint32 upperVid, rtk_uint32 lowerVid);
+extern ret_t rtl8367c_getAsicAclVidRange(rtk_uint32 index, rtk_uint32* pType, rtk_uint32* pUpperVid, rtk_uint32* pLowerVid);
+extern ret_t rtl8367c_setAsicAclIpRange(rtk_uint32 index, rtk_uint32 type, ipaddr_t upperIp, ipaddr_t lowerIp);
+extern ret_t rtl8367c_getAsicAclIpRange(rtk_uint32 index, rtk_uint32* pType, ipaddr_t* pUpperIp, ipaddr_t* pLowerIp);
+extern ret_t rtl8367c_setAsicAclGpioPolarity(rtk_uint32 polarity);
+extern ret_t rtl8367c_getAsicAclGpioPolarity(rtk_uint32* pPolarity);
+
+#endif /*_RTL8367C_ASICDRV_ACL_H_*/
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_cputag.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_cputag.h
new file mode 100644
index 0000000000000..f7a460145e667
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_cputag.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Proprietary CPU-tag related function drivers
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_CPUTAG_H_
+#define _RTL8367C_ASICDRV_CPUTAG_H_
+
+#include <rtl8367c_asicdrv.h>
+
+enum CPUTAG_INSERT_MODE
+{
+    CPUTAG_INSERT_TO_ALL = 0,
+    CPUTAG_INSERT_TO_TRAPPING,
+    CPUTAG_INSERT_TO_NO,
+    CPUTAG_INSERT_END
+};
+
+extern ret_t rtl8367c_setAsicCputagEnable(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicCputagEnable(rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicCputagTrapPort(rtk_uint32 port);
+extern ret_t rtl8367c_getAsicCputagTrapPort(rtk_uint32 *pPort);
+extern ret_t rtl8367c_setAsicCputagPortmask(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicCputagPortmask(rtk_uint32 *pPmsk);
+extern ret_t rtl8367c_setAsicCputagInsertMode(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicCputagInsertMode(rtk_uint32 *pMode);
+extern ret_t rtl8367c_setAsicCputagPriorityRemapping(rtk_uint32 srcPri, rtk_uint32 newPri);
+extern ret_t rtl8367c_getAsicCputagPriorityRemapping(rtk_uint32 srcPri, rtk_uint32 *pNewPri);
+extern ret_t rtl8367c_setAsicCputagPosition(rtk_uint32 postion);
+extern ret_t rtl8367c_getAsicCputagPosition(rtk_uint32* pPostion);
+extern ret_t rtl8367c_setAsicCputagMode(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicCputagMode(rtk_uint32 *pMode);
+extern ret_t rtl8367c_setAsicCputagRxMinLength(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicCputagRxMinLength(rtk_uint32 *pMode);
+
+#endif /*#ifndef _RTL8367C_ASICDRV_CPUTAG_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_dot1x.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_dot1x.h
new file mode 100644
index 0000000000000..7639ae782b5ce
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_dot1x.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : 802.1X related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_DOT1X_H_
+#define _RTL8367C_ASICDRV_DOT1X_H_
+
+#include <rtl8367c_asicdrv.h>
+
+enum DOT1X_UNAUTH_BEHAV
+{
+    DOT1X_UNAUTH_DROP = 0,
+    DOT1X_UNAUTH_TRAP,
+    DOT1X_UNAUTH_GVLAN,
+    DOT1X_UNAUTH_END
+};
+
+extern ret_t rtl8367c_setAsic1xPBEnConfig(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsic1xPBEnConfig(rtk_uint32 port, rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsic1xPBAuthConfig(rtk_uint32 port, rtk_uint32 auth);
+extern ret_t rtl8367c_getAsic1xPBAuthConfig(rtk_uint32 port, rtk_uint32 *pAuth);
+extern ret_t rtl8367c_setAsic1xPBOpdirConfig(rtk_uint32 port, rtk_uint32 opdir);
+extern ret_t rtl8367c_getAsic1xPBOpdirConfig(rtk_uint32 port, rtk_uint32 *pOpdir);
+extern ret_t rtl8367c_setAsic1xMBEnConfig(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsic1xMBEnConfig(rtk_uint32 port, rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsic1xMBOpdirConfig(rtk_uint32 opdir);
+extern ret_t rtl8367c_getAsic1xMBOpdirConfig(rtk_uint32 *pOpdir);
+extern ret_t rtl8367c_setAsic1xProcConfig(rtk_uint32 port, rtk_uint32 proc);
+extern ret_t rtl8367c_getAsic1xProcConfig(rtk_uint32 port, rtk_uint32 *pProc);
+extern ret_t rtl8367c_setAsic1xGuestVidx(rtk_uint32 index);
+extern ret_t rtl8367c_getAsic1xGuestVidx(rtk_uint32 *pIndex);
+extern ret_t rtl8367c_setAsic1xGVOpdir(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsic1xGVOpdir(rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsic1xTrapPriority(rtk_uint32 priority);
+extern ret_t rtl8367c_getAsic1xTrapPriority(rtk_uint32 *pPriority);
+
+
+#endif /*_RTL8367C_ASICDRV_DOT1X_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_eav.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_eav.h
new file mode 100644
index 0000000000000..b633f66fb0c03
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_eav.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Ethernet AV related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_EAV_H_
+#define _RTL8367C_ASICDRV_EAV_H_
+
+#include <rtl8367c_asicdrv.h>
+
+typedef enum RTL8367C_PTP_TIME_CMD_E
+{
+    PTP_TIME_READ = 0,
+    PTP_TIME_WRITE,
+    PTP_TIME_INC,
+    PTP_TIME_DEC,
+    PTP_TIME_CMD_END
+}RTL8367C_PTP_TIME_CMD;
+
+typedef enum RTL8367C_PTP_TIME_ADJ_E
+{
+    PTP_TIME_ADJ_INC = 0,
+    PTP_TIME_ADJ_DEC,
+    PTP_TIME_ADJ_END
+}RTL8367C_PTP_TIME_ADJ;
+
+typedef enum RTL8367C_PTP_TIME_CTRL_E
+{
+    PTP_TIME_CTRL_STOP = 0,
+    PTP_TIME_CTRL_START,
+    PTP_TIME_CTRL_END
+}RTL8367C_PTP_TIME_CTRL;
+
+typedef enum RTL8367C_PTP_INTR_IMRS_E
+{
+    PTP_IMRS_TX_SYNC,
+    PTP_IMRS_TX_DELAY_REQ,
+    PTP_IMRS_TX_PDELAY_REQ,
+    PTP_IMRS_TX_PDELAY_RESP,
+    PTP_IMRS_RX_SYNC,
+    PTP_IMRS_RX_DELAY_REQ,
+    PTP_IMRS_RX_PDELAY_REQ,
+    PTP_IMRS_RX_PDELAY_RESP,
+    PTP_IMRS_END,
+}RTL8367C_PTP_INTR_IMRS;
+
+
+typedef enum RTL8367C_PTP_PKT_TYPE_E
+{
+    PTP_PKT_TYPE_TX_SYNC,
+    PTP_PKT_TYPE_TX_DELAY_REQ,
+    PTP_PKT_TYPE_TX_PDELAY_REQ,
+    PTP_PKT_TYPE_TX_PDELAY_RESP,
+    PTP_PKT_TYPE_RX_SYNC,
+    PTP_PKT_TYPE_RX_DELAY_REQ,
+    PTP_PKT_TYPE_RX_PDELAY_REQ,
+    PTP_PKT_TYPE_RX_PDELAY_RESP,
+    PTP_PKT_TYPE_END,
+}RTL8367C_PTP_PKT_TYPE;
+
+typedef struct  rtl8367c_ptp_time_stamp_s{
+    rtk_uint32 sequence_id;
+    rtk_uint32 second;
+    rtk_uint32 nano_second;
+}rtl8367c_ptp_time_stamp_t;
+
+#define RTL8367C_PTP_INTR_MASK        0xFF
+
+#define RTL8367C_PTP_PORT_MASK        0x3FF
+
+extern ret_t rtl8367c_setAsicEavMacAddress(ether_addr_t mac);
+extern ret_t rtl8367c_getAsicEavMacAddress(ether_addr_t *pMac);
+extern ret_t rtl8367c_setAsicEavTpid(rtk_uint32 outerTag, rtk_uint32 innerTag);
+extern ret_t rtl8367c_getAsicEavTpid(rtk_uint32* pOuterTag, rtk_uint32* pInnerTag);
+extern ret_t rtl8367c_setAsicEavSysTime(rtk_uint32 second, rtk_uint32 nanoSecond);
+extern ret_t rtl8367c_getAsicEavSysTime(rtk_uint32* pSecond, rtk_uint32* pNanoSecond);
+extern ret_t rtl8367c_setAsicEavSysTimeAdjust(rtk_uint32 type, rtk_uint32 second, rtk_uint32 nanoSecond);
+extern ret_t rtl8367c_setAsicEavSysTimeCtrl(rtk_uint32 control);
+extern ret_t rtl8367c_getAsicEavSysTimeCtrl(rtk_uint32* pControl);
+extern ret_t rtl8367c_setAsicEavInterruptMask(rtk_uint32 imr);
+extern ret_t rtl8367c_getAsicEavInterruptMask(rtk_uint32* pImr);
+extern ret_t rtl8367c_getAsicEavInterruptStatus(rtk_uint32* pIms);
+extern ret_t rtl8367c_setAsicEavPortInterruptStatus(rtk_uint32 port, rtk_uint32 ims);
+extern ret_t rtl8367c_getAsicEavPortInterruptStatus(rtk_uint32 port, rtk_uint32* pIms);
+extern ret_t rtl8367c_setAsicEavPortEnable(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicEavPortEnable(rtk_uint32 port, rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_getAsicEavPortTimeStamp(rtk_uint32 port, rtk_uint32 type, rtl8367c_ptp_time_stamp_t* timeStamp);
+
+extern ret_t rtl8367c_setAsicEavTrap(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicEavTrap(rtk_uint32 port, rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicEavEnable(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicEavEnable(rtk_uint32 port, rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicEavPriRemapping(rtk_uint32 srcpriority, rtk_uint32 priority);
+extern ret_t rtl8367c_getAsicEavPriRemapping(rtk_uint32 srcpriority, rtk_uint32 *pPriority);
+
+#endif /*#ifndef _RTL8367C_ASICDRV_EAV_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_eee.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_eee.h
new file mode 100644
index 0000000000000..91cd9418068c0
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_eee.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 48989 $
+ * $Date: 2014-07-01 15:45:24 +0800 (gG, 01 C 2014) $
+ *
+ * Purpose : RTL8370 switch high-level API for RTL8367C
+ * Feature :
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_EEE_H_
+#define _RTL8367C_ASICDRV_EEE_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define EEE_OCP_PHY_ADDR    (0xA5D0)
+
+extern ret_t rtl8367c_setAsicEee100M(rtk_uint32 port, rtk_uint32 enable);
+extern ret_t rtl8367c_getAsicEee100M(rtk_uint32 port, rtk_uint32 *enable);
+extern ret_t rtl8367c_setAsicEeeGiga(rtk_uint32 port, rtk_uint32 enable);
+extern ret_t rtl8367c_getAsicEeeGiga(rtk_uint32 port, rtk_uint32 *enable);
+
+
+#endif /*_RTL8367C_ASICDRV_EEE_H_*/
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_fc.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_fc.h
new file mode 100644
index 0000000000000..ce67cdebacadc
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_fc.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Flow control related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_FC_H_
+#define _RTL8367C_ASICDRV_FC_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_PAGE_NUMBER    0x600
+
+
+enum FLOW_CONTROL_TYPE
+{
+    FC_EGRESS = 0,
+    FC_INGRESS,
+};
+
+enum FC_JUMBO_SIZE
+{
+    FC_JUMBO_SIZE_3K = 0,
+    FC_JUMBO_SIZE_4K,
+    FC_JUMBO_SIZE_6K,
+    FC_JUMBO_SIZE_9K,
+    FC_JUMBO_SIZE_END,
+
+};
+
+
+extern ret_t rtl8367c_setAsicFlowControlSelect(rtk_uint32 select);
+extern ret_t rtl8367c_getAsicFlowControlSelect(rtk_uint32 *pSelect);
+extern ret_t rtl8367c_setAsicFlowControlJumboMode(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicFlowControlJumboMode(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicFlowControlJumboModeSize(rtk_uint32 size);
+extern ret_t rtl8367c_getAsicFlowControlJumboModeSize(rtk_uint32* pSize);
+extern ret_t rtl8367c_setAsicFlowControlQueueEgressEnable(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicFlowControlQueueEgressEnable(rtk_uint32 port, rtk_uint32 qid, rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicFlowControlDropAll(rtk_uint32 dropall);
+extern ret_t rtl8367c_getAsicFlowControlDropAll(rtk_uint32* pDropall);
+extern ret_t rtl8367c_setAsicFlowControlPauseAllThreshold(rtk_uint32 threshold);
+extern ret_t rtl8367c_getAsicFlowControlPauseAllThreshold(rtk_uint32 *pThreshold);
+extern ret_t rtl8367c_setAsicFlowControlSystemThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlSystemThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+extern ret_t rtl8367c_setAsicFlowControlSharedThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlSharedThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+extern ret_t rtl8367c_setAsicFlowControlPortThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlPortThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+extern ret_t rtl8367c_setAsicFlowControlPortPrivateThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlPortPrivateThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+extern ret_t rtl8367c_setAsicFlowControlSystemDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlSystemDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+extern ret_t rtl8367c_setAsicFlowControlSharedDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlSharedDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+extern ret_t rtl8367c_setAsicFlowControlPortDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlPortDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+extern ret_t rtl8367c_setAsicFlowControlPortPrivateDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlPortPrivateDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+extern ret_t rtl8367c_setAsicFlowControlSystemJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlSystemJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+extern ret_t rtl8367c_setAsicFlowControlSharedJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlSharedJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+extern ret_t rtl8367c_setAsicFlowControlPortJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlPortJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+extern ret_t rtl8367c_setAsicFlowControlPortPrivateJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold);
+extern ret_t rtl8367c_getAsicFlowControlPortPrivateJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold);
+
+extern ret_t rtl8367c_setAsicEgressFlowControlPortDropGap(rtk_uint32 gap);
+extern ret_t rtl8367c_getAsicEgressFlowControlPortDropGap(rtk_uint32 *pGap);
+extern ret_t rtl8367c_setAsicEgressFlowControlQueueDropGap(rtk_uint32 gap);
+extern ret_t rtl8367c_getAsicEgressFlowControlQueueDropGap(rtk_uint32 *pGap);
+extern ret_t rtl8367c_setAsicEgressFlowControlPortDropThreshold(rtk_uint32 port, rtk_uint32 threshold);
+extern ret_t rtl8367c_getAsicEgressFlowControlPortDropThreshold(rtk_uint32 port, rtk_uint32 *pThreshold);
+extern ret_t rtl8367c_setAsicEgressFlowControlQueueDropThreshold(rtk_uint32 qid, rtk_uint32 threshold);
+extern ret_t rtl8367c_getAsicEgressFlowControlQueueDropThreshold(rtk_uint32 qid, rtk_uint32 *pThreshold);
+extern ret_t rtl8367c_getAsicEgressQueueEmptyPortMask(rtk_uint32 *pPortmask);
+extern ret_t rtl8367c_getAsicTotalPage(rtk_uint32 *pPageCount);
+extern ret_t rtl8367c_getAsicPulbicPage(rtk_uint32 *pPageCount);
+extern ret_t rtl8367c_getAsicMaxTotalPage(rtk_uint32 *pPageCount);
+extern ret_t rtl8367c_getAsicMaxPulbicPage(rtk_uint32 *pPageCount);
+extern ret_t rtl8367c_getAsicPortPage(rtk_uint32 port, rtk_uint32 *pPageCount);
+extern ret_t rtl8367c_getAsicPortPageMax(rtk_uint32 port, rtk_uint32 *pPageCount);
+extern ret_t rtl8367c_setAsicFlowControlEgressPortIndep(rtk_uint32 port, rtk_uint32 enable);
+extern ret_t rtl8367c_getAsicFlowControlEgressPortIndep(rtk_uint32 port, rtk_uint32 *pEnable);
+
+#endif /*_RTL8367C_ASICDRV_FC_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_green.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_green.h
new file mode 100644
index 0000000000000..38fd085d066ec
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_green.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Green ethernet related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_GREEN_H_
+#define _RTL8367C_ASICDRV_GREEN_H_
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_phy.h>
+
+#define PHY_POWERSAVING_REG                         24
+
+extern ret_t rtl8367c_setAsicGreenTrafficType(rtk_uint32 priority, rtk_uint32 traffictype);
+extern ret_t rtl8367c_getAsicGreenTrafficType(rtk_uint32 priority, rtk_uint32* pTraffictype);
+extern ret_t rtl8367c_getAsicGreenPortPage(rtk_uint32 port, rtk_uint32* pPage);
+extern ret_t rtl8367c_getAsicGreenHighPriorityTraffic(rtk_uint32 port, rtk_uint32* pIndicator);
+extern ret_t rtl8367c_setAsicGreenHighPriorityTraffic(rtk_uint32 port);
+extern ret_t rtl8367c_setAsicGreenEthernet(rtk_uint32 port, rtk_uint32 green);
+extern ret_t rtl8367c_getAsicGreenEthernet(rtk_uint32 port, rtk_uint32* green);
+extern ret_t rtl8367c_setAsicPowerSaving(rtk_uint32 phy, rtk_uint32 enable);
+extern ret_t rtl8367c_getAsicPowerSaving(rtk_uint32 phy, rtk_uint32* enable);
+#endif /*#ifndef _RTL8367C_ASICDRV_GREEN_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_hsb.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_hsb.h
new file mode 100644
index 0000000000000..f4f9bb377b9fc
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_hsb.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Field selector related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV__HSB_H_
+#define _RTL8367C_ASICDRV__HSB_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_FIELDSEL_FORMAT_NUMBER      (16)
+#define RTL8367C_FIELDSEL_MAX_OFFSET         (255)
+
+enum FIELDSEL_FORMAT_FORMAT
+{
+    FIELDSEL_FORMAT_DEFAULT = 0,
+    FIELDSEL_FORMAT_RAW,
+    FIELDSEL_FORMAT_LLC,
+    FIELDSEL_FORMAT_IPV4,
+    FIELDSEL_FORMAT_ARP,
+    FIELDSEL_FORMAT_IPV6,
+    FIELDSEL_FORMAT_IPPAYLOAD,
+    FIELDSEL_FORMAT_L4PAYLOAD,
+    FIELDSEL_FORMAT_END
+};
+
+extern ret_t rtl8367c_setAsicFieldSelector(rtk_uint32 index, rtk_uint32 format, rtk_uint32 offset);
+extern ret_t rtl8367c_getAsicFieldSelector(rtk_uint32 index, rtk_uint32* pFormat, rtk_uint32* pOffset);
+
+#endif /*_RTL8367C_ASICDRV__HSB_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_i2c.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_i2c.h
new file mode 100644
index 0000000000000..d5b095a0e5c6a
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_i2c.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 38651 $
+ * $Date: 2016-02-27 14:32:56 +0800 (PT, 17 | 2016) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : I2C related functions
+ *
+ */
+
+
+#ifndef _RTL8367C_ASICDRV_I2C_H_
+#define _RTL8367C_ASICDRV_I2C_H_
+#include <rtk_types.h>
+#include <rtl8367c_asicdrv.h>
+
+
+#define TIMEROUT_FOR_MICROSEMI (0x400)
+
+#define GPIO_INPUT 1
+#define GPIO_OUTPUT 2
+
+extern ret_t rtl8367c_setAsicI2C_checkBusIdle(void);
+extern ret_t rtl8367c_setAsicI2CStartCmd(void);
+extern ret_t rtl8367c_setAsicI2CStopCmd(void);
+extern ret_t rtl8367c_setAsicI2CTxOneCharCmd(rtk_uint8 oneChar);
+extern ret_t rtl8367c_setAsicI2CcheckRxAck(void);
+extern ret_t rtl8367c_setAsicI2CRxOneCharCmd(rtk_uint8 *pValue);
+extern ret_t rtl8367c_setAsicI2CTxAckCmd(void);
+extern ret_t rtl8367c_setAsicI2CTxNoAckCmd(void);
+extern ret_t rtl8367c_setAsicI2CSoftRSTseqCmd(void);
+extern ret_t rtl8367c_setAsicI2CGpioPinGroup(rtk_uint32 pinGroup_ID);
+extern ret_t rtl8367c_getAsicI2CGpioPinGroup(rtk_uint32 * pPinGroup_ID);
+
+
+
+
+
+#endif /*#ifndef _RTL8367C_ASICDRV_I2C_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_igmp.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_igmp.h
new file mode 100644
index 0000000000000..b879b6b520e49
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_igmp.h
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : IGMP related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_IGMP_H_
+#define _RTL8367C_ASICDRV_IGMP_H_
+
+/****************************************************************/
+/* Header File inclusion                                        */
+/****************************************************************/
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_MAX_LEAVE_TIMER        (7)
+#define RTL8367C_MAX_QUERY_INT          (0xFFFF)
+#define RTL8367C_MAX_ROB_VAR            (7)
+
+#define RTL8367C_IGMP_GOUP_NO           (256)
+#define RTL8367C_IGMP_MAX_GOUP          (0xFF)
+#define RTL8367C_IGMP_GRP_BLEN          (3)
+#define RTL8367C_ROUTER_PORT_INVALID    (0xF)
+
+enum RTL8367C_IGMPTABLE_FULL_OP
+{
+    TABLE_FULL_FORWARD = 0,
+    TABLE_FULL_DROP,
+    TABLE_FULL_TRAP,
+    TABLE_FULL_OP_END
+};
+
+enum RTL8367C_CRC_ERR_OP
+{
+    CRC_ERR_DROP = 0,
+    CRC_ERR_TRAP,
+    CRC_ERR_FORWARD,
+    CRC_ERR_OP_END
+};
+
+enum RTL8367C_IGMP_MLD_PROTOCOL_OP
+{
+    PROTOCOL_OP_ASIC = 0,
+    PROTOCOL_OP_FLOOD,
+    PROTOCOL_OP_TRAP,
+    PROTOCOL_OP_DROP,
+    PROTOCOL_OP_END
+};
+
+enum RTL8367C_IGMP_MLD_BYPASS_GROUP
+{
+    BYPASS_224_0_0_X = 0,
+    BYPASS_224_0_1_X,
+    BYPASS_239_255_255_X,
+    BYPASS_IPV6_00XX,
+    BYPASS_GROUP_END
+};
+
+typedef struct
+{
+    rtk_uint32 p0_timer;
+    rtk_uint32 p1_timer;
+    rtk_uint32 p2_timer;
+    rtk_uint32 p3_timer;
+    rtk_uint32 p4_timer;
+    rtk_uint32 p5_timer;
+    rtk_uint32 p6_timer;
+    rtk_uint32 p7_timer;
+    rtk_uint32 p8_timer;
+    rtk_uint32 p9_timer;
+    rtk_uint32 p10_timer;
+    rtk_uint32 report_supp_flag;
+
+}rtl8367c_igmpgroup;
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * This program is the proprietary software of Realtek Semiconductor
+ * Corporation and/or its licensors, and only be used, duplicated,
+ * modified or distributed under the authorized license from Realtek.
+ *
+ * ANY USE OF THE SOFTWARE OTHER THAN AS AUTHORIZED UNDER
+ * THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : IGMP related functions
+ *
+ */
+#include <rtl8367c_asicdrv_igmp.h>
+
+ret_t rtl8367c_setAsicIgmp(rtk_uint32 enabled);
+ret_t rtl8367c_getAsicIgmp(rtk_uint32 *pEnabled);
+ret_t rtl8367c_setAsicIpMulticastVlanLeaky(rtk_uint32 port, rtk_uint32 enabled );
+ret_t rtl8367c_getAsicIpMulticastVlanLeaky(rtk_uint32 port, rtk_uint32 *pEnabled );
+ret_t rtl8367c_setAsicIGMPTableFullOP(rtk_uint32 operation);
+ret_t rtl8367c_getAsicIGMPTableFullOP(rtk_uint32 *pOperation);
+ret_t rtl8367c_setAsicIGMPCRCErrOP(rtk_uint32 operation);
+ret_t rtl8367c_getAsicIGMPCRCErrOP(rtk_uint32 *pOperation);
+ret_t rtl8367c_setAsicIGMPFastLeaveEn(rtk_uint32 enabled);
+ret_t rtl8367c_getAsicIGMPFastLeaveEn(rtk_uint32 *pEnabled);
+ret_t rtl8367c_setAsicIGMPLeaveTimer(rtk_uint32 leave_timer);
+ret_t rtl8367c_getAsicIGMPLeaveTimer(rtk_uint32 *pLeave_timer);
+ret_t rtl8367c_setAsicIGMPQueryInterval(rtk_uint32 interval);
+ret_t rtl8367c_getAsicIGMPQueryInterval(rtk_uint32 *pInterval);
+ret_t rtl8367c_setAsicIGMPRobVar(rtk_uint32 rob_var);
+ret_t rtl8367c_getAsicIGMPRobVar(rtk_uint32 *pRob_var);
+ret_t rtl8367c_setAsicIGMPStaticRouterPort(rtk_uint32 pmsk);
+ret_t rtl8367c_getAsicIGMPStaticRouterPort(rtk_uint32 *pMsk);
+ret_t rtl8367c_setAsicIGMPAllowDynamicRouterPort(rtk_uint32 pmsk);
+ret_t rtl8367c_getAsicIGMPAllowDynamicRouterPort(rtk_uint32 *pPmsk);
+ret_t rtl8367c_getAsicIGMPdynamicRouterPort1(rtk_uint32 *pPort, rtk_uint32 *pTimer);
+ret_t rtl8367c_getAsicIGMPdynamicRouterPort2(rtk_uint32 *pPort, rtk_uint32 *pTimer);
+ret_t rtl8367c_setAsicIGMPSuppression(rtk_uint32 report_supp_enabled, rtk_uint32 leave_supp_enabled);
+ret_t rtl8367c_getAsicIGMPSuppression(rtk_uint32 *pReport_supp_enabled, rtk_uint32 *pLeave_supp_enabled);
+ret_t rtl8367c_setAsicIGMPQueryRX(rtk_uint32 port, rtk_uint32 allow_query);
+ret_t rtl8367c_getAsicIGMPQueryRX(rtk_uint32 port, rtk_uint32 *pAllow_query);
+ret_t rtl8367c_setAsicIGMPReportRX(rtk_uint32 port, rtk_uint32 allow_report);
+ret_t rtl8367c_getAsicIGMPReportRX(rtk_uint32 port, rtk_uint32 *pAllow_report);
+ret_t rtl8367c_setAsicIGMPLeaveRX(rtk_uint32 port, rtk_uint32 allow_leave);
+ret_t rtl8367c_getAsicIGMPLeaveRX(rtk_uint32 port, rtk_uint32 *pAllow_leave);
+ret_t rtl8367c_setAsicIGMPMRPRX(rtk_uint32 port, rtk_uint32 allow_mrp);
+ret_t rtl8367c_getAsicIGMPMRPRX(rtk_uint32 port, rtk_uint32 *pAllow_mrp);
+ret_t rtl8367c_setAsicIGMPMcDataRX(rtk_uint32 port, rtk_uint32 allow_mcdata);
+ret_t rtl8367c_getAsicIGMPMcDataRX(rtk_uint32 port, rtk_uint32 *pAllow_mcdata);
+ret_t rtl8367c_setAsicIGMPv1Opeartion(rtk_uint32 port, rtk_uint32 igmpv1_op);
+ret_t rtl8367c_getAsicIGMPv1Opeartion(rtk_uint32 port, rtk_uint32 *pIgmpv1_op);
+ret_t rtl8367c_setAsicIGMPv2Opeartion(rtk_uint32 port, rtk_uint32 igmpv2_op);
+ret_t rtl8367c_getAsicIGMPv2Opeartion(rtk_uint32 port, rtk_uint32 *pIgmpv2_op);
+ret_t rtl8367c_setAsicIGMPv3Opeartion(rtk_uint32 port, rtk_uint32 igmpv3_op);
+ret_t rtl8367c_getAsicIGMPv3Opeartion(rtk_uint32 port, rtk_uint32 *pIgmpv3_op);
+ret_t rtl8367c_setAsicMLDv1Opeartion(rtk_uint32 port, rtk_uint32 mldv1_op);
+ret_t rtl8367c_getAsicMLDv1Opeartion(rtk_uint32 port, rtk_uint32 *pMldv1_op);
+ret_t rtl8367c_setAsicMLDv2Opeartion(rtk_uint32 port, rtk_uint32 mldv2_op);
+ret_t rtl8367c_getAsicMLDv2Opeartion(rtk_uint32 port, rtk_uint32 *pMldv2_op);
+ret_t rtl8367c_setAsicIGMPPortMAXGroup(rtk_uint32 port, rtk_uint32 max_group);
+ret_t rtl8367c_getAsicIGMPPortMAXGroup(rtk_uint32 port, rtk_uint32 *pMax_group);
+ret_t rtl8367c_getAsicIGMPPortCurrentGroup(rtk_uint32 port, rtk_uint32 *pCurrent_group);
+ret_t rtl8367c_getAsicIGMPGroup(rtk_uint32 idx, rtk_uint32 *pValid, rtl8367c_igmpgroup *pGrp);
+ret_t rtl8367c_setAsicIpMulticastPortIsoLeaky(rtk_uint32 port, rtk_uint32 enabled);
+ret_t rtl8367c_getAsicIpMulticastPortIsoLeaky(rtk_uint32 port, rtk_uint32 *pEnabled);
+ret_t rtl8367c_setAsicIGMPReportLeaveFlood(rtk_uint32 flood);
+ret_t rtl8367c_getAsicIGMPReportLeaveFlood(rtk_uint32 *pFlood);
+ret_t rtl8367c_setAsicIGMPDropLeaveZero(rtk_uint32 drop);
+ret_t rtl8367c_getAsicIGMPDropLeaveZero(rtk_uint32 *pDrop);
+ret_t rtl8367c_setAsicIGMPBypassStormCTRL(rtk_uint32 bypass);
+ret_t rtl8367c_getAsicIGMPBypassStormCTRL(rtk_uint32 *pBypass);
+ret_t rtl8367c_setAsicIGMPIsoLeaky(rtk_uint32 leaky);
+ret_t rtl8367c_getAsicIGMPIsoLeaky(rtk_uint32 *pLeaky);
+ret_t rtl8367c_setAsicIGMPVLANLeaky(rtk_uint32 leaky);
+ret_t rtl8367c_getAsicIGMPVLANLeaky(rtk_uint32 *pLeaky);
+ret_t rtl8367c_setAsicIGMPBypassGroup(rtk_uint32 bypassType, rtk_uint32 enabled);
+ret_t rtl8367c_getAsicIGMPBypassGroup(rtk_uint32 bypassType, rtk_uint32 *pEnabled);
+
+#endif /*#ifndef _RTL8367C_ASICDRV_IGMP_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_inbwctrl.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_inbwctrl.h
new file mode 100644
index 0000000000000..10f3545322c93
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_inbwctrl.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Ingress bandwidth control related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_INBWCTRL_H_
+#define _RTL8367C_ASICDRV_INBWCTRL_H_
+
+#include <rtl8367c_asicdrv.h>
+
+extern ret_t rtl8367c_setAsicPortIngressBandwidth(rtk_uint32 port, rtk_uint32 bandwidth, rtk_uint32 preifg, rtk_uint32 enableFC);
+extern ret_t rtl8367c_getAsicPortIngressBandwidth(rtk_uint32 port, rtk_uint32* pBandwidth, rtk_uint32* pPreifg, rtk_uint32* pEnableFC );
+extern ret_t rtl8367c_setAsicPortIngressBandwidthBypass(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicPortIngressBandwidthBypass(rtk_uint32* pEnabled);
+
+
+#endif /*_RTL8367C_ASICDRV_INBWCTRL_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_interrupt.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_interrupt.h
new file mode 100644
index 0000000000000..8b78014ab01bc
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_interrupt.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Interrupt related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_INTERRUPT_H_
+#define _RTL8367C_ASICDRV_INTERRUPT_H_
+
+#include <rtl8367c_asicdrv.h>
+
+typedef enum RTL8367C_INTR_IMRS_E
+{
+    IMRS_LINK_CHANGE,
+    IMRS_METER_EXCEED,
+    IMRS_L2_LEARN,
+    IMRS_SPEED_CHANGE,
+    IMRS_SPECIAL_CONGESTION,
+    IMRS_GREEN_FEATURE,
+    IMRS_LOOP_DETECTION,
+    IMRS_8051,
+    IMRS_CABLE_DIAG,
+    IMRS_ACL,
+    IMRS_RESERVED, /* Unused */
+    IMRS_SLIENT,
+    IMRS_END,
+}RTL8367C_INTR_IMRS;
+
+typedef enum RTL8367C_INTR_INDICATOR_E
+{
+    INTRST_L2_LEARN = 0,
+    INTRST_SPEED_CHANGE,
+    INTRST_SPECIAL_CONGESTION,
+    INTRST_PORT_LINKDOWN,
+    INTRST_PORT_LINKUP,
+    INTRST_METER0_15,
+    INTRST_METER16_31,
+    INTRST_RLDP_LOOPED,
+    INTRST_RLDP_RELEASED,
+    INTRST_SYS_LEARN,
+    INTRST_END,
+}RTL8367C_INTR_INDICATOR;
+
+extern ret_t rtl8367c_setAsicInterruptPolarity(rtk_uint32 polarity);
+extern ret_t rtl8367c_getAsicInterruptPolarity(rtk_uint32* pPolarity);
+extern ret_t rtl8367c_setAsicInterruptMask(rtk_uint32 imr);
+extern ret_t rtl8367c_getAsicInterruptMask(rtk_uint32* pImr);
+extern ret_t rtl8367c_setAsicInterruptStatus(rtk_uint32 ims);
+extern ret_t rtl8367c_getAsicInterruptStatus(rtk_uint32* pIms);
+extern ret_t rtl8367c_setAsicInterruptRelatedStatus(rtk_uint32 type, rtk_uint32 status);
+extern ret_t rtl8367c_getAsicInterruptRelatedStatus(rtk_uint32 type, rtk_uint32* pStatus);
+
+
+#endif /*#ifndef _RTL8367C_ASICDRV_INTERRUPT_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_led.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_led.h
new file mode 100644
index 0000000000000..a7f8e20643200
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_led.h
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : LED related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_LED_H_
+#define _RTL8367C_ASICDRV_LED_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_LEDGROUPNO                 3
+#define RTL8367C_LEDGROUPMASK               0x7
+#define RTL8367C_LED_FORCE_MODE_BASE        RTL8367C_REG_CPU_FORCE_LED0_CFG0
+#define RTL8367C_LED_FORCE_CTRL             RTL8367C_REG_CPU_FORCE_LED_CFG
+
+enum RTL8367C_LEDOP{
+
+    LEDOP_SCAN0=0,
+    LEDOP_SCAN1,
+    LEDOP_PARALLEL,
+    LEDOP_SERIAL,
+    LEDOP_END,
+};
+
+enum RTL8367C_LEDSERACT{
+
+    LEDSERACT_HIGH=0,
+    LEDSERACT_LOW,
+    LEDSERACT_MAX,
+};
+
+enum RTL8367C_LEDSER{
+
+    LEDSER_16G=0,
+    LEDSER_8G,
+    LEDSER_MAX,
+};
+
+enum RTL8367C_LEDCONF{
+
+    LEDCONF_LEDOFF=0,
+    LEDCONF_DUPCOL,
+    LEDCONF_LINK_ACT,
+    LEDCONF_SPD1000,
+    LEDCONF_SPD100,
+    LEDCONF_SPD10,
+    LEDCONF_SPD1000ACT,
+    LEDCONF_SPD100ACT,
+    LEDCONF_SPD10ACT,
+    LEDCONF_SPD10010ACT,
+    LEDCONF_LOOPDETECT,
+    LEDCONF_EEE,
+    LEDCONF_LINKRX,
+    LEDCONF_LINKTX,
+    LEDCONF_MASTER,
+    LEDCONF_ACT,
+    LEDCONF_END
+};
+
+enum RTL8367C_LEDBLINKRATE{
+
+    LEDBLINKRATE_32MS=0,
+    LEDBLINKRATE_64MS,
+    LEDBLINKRATE_128MS,
+    LEDBLINKRATE_256MS,
+    LEDBLINKRATE_512MS,
+    LEDBLINKRATE_1024MS,
+    LEDBLINKRATE_48MS,
+    LEDBLINKRATE_96MS,
+    LEDBLINKRATE_END,
+};
+
+enum RTL8367C_LEDFORCEMODE{
+
+    LEDFORCEMODE_NORMAL=0,
+    LEDFORCEMODE_BLINK,
+    LEDFORCEMODE_OFF,
+    LEDFORCEMODE_ON,
+    LEDFORCEMODE_END,
+};
+
+enum RTL8367C_LEDFORCERATE{
+
+    LEDFORCERATE_512MS=0,
+    LEDFORCERATE_1024MS,
+    LEDFORCERATE_2048MS,
+    LEDFORCERATE_NORMAL,
+    LEDFORCERATE_END,
+
+};
+
+enum RTL8367C_LEDMODE
+{
+    RTL8367C_LED_MODE_0 = 0,
+    RTL8367C_LED_MODE_1,
+    RTL8367C_LED_MODE_2,
+    RTL8367C_LED_MODE_3,
+    RTL8367C_LED_MODE_END
+};
+
+extern ret_t rtl8367c_setAsicLedIndicateInfoConfig(rtk_uint32 ledno, rtk_uint32 config);
+extern ret_t rtl8367c_getAsicLedIndicateInfoConfig(rtk_uint32 ledno, rtk_uint32* pConfig);
+extern ret_t rtl8367c_setAsicForceLed(rtk_uint32 port, rtk_uint32 group, rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicForceLed(rtk_uint32 port, rtk_uint32 group, rtk_uint32* pMode);
+extern ret_t rtl8367c_setAsicForceGroupLed(rtk_uint32 groupmask, rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicForceGroupLed(rtk_uint32* groupmask, rtk_uint32* pMode);
+extern ret_t rtl8367c_setAsicLedBlinkRate(rtk_uint32 blinkRate);
+extern ret_t rtl8367c_getAsicLedBlinkRate(rtk_uint32* pBlinkRate);
+extern ret_t rtl8367c_setAsicLedForceBlinkRate(rtk_uint32 blinkRate);
+extern ret_t rtl8367c_getAsicLedForceBlinkRate(rtk_uint32* pBlinkRate);
+extern ret_t rtl8367c_setAsicLedGroupMode(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicLedGroupMode(rtk_uint32* pMode);
+extern ret_t rtl8367c_setAsicLedGroupEnable(rtk_uint32 group, rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicLedGroupEnable(rtk_uint32 group, rtk_uint32 *portmask);
+extern ret_t rtl8367c_setAsicLedOperationMode(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicLedOperationMode(rtk_uint32 *mode);
+extern ret_t rtl8367c_setAsicLedSerialModeConfig(rtk_uint32 active, rtk_uint32 serimode);
+extern ret_t rtl8367c_getAsicLedSerialModeConfig(rtk_uint32 *active, rtk_uint32 *serimode);
+extern ret_t rtl8367c_setAsicLedOutputEnable(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicLedOutputEnable(rtk_uint32 *ptr_enabled);
+extern ret_t rtl8367c_setAsicLedSerialOutput(rtk_uint32 output, rtk_uint32 pmask);
+extern ret_t rtl8367c_getAsicLedSerialOutput(rtk_uint32 *pOutput, rtk_uint32 *pPmask);
+
+
+#endif /*#ifndef _RTL8367C_ASICDRV_LED_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_lut.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_lut.h
new file mode 100644
index 0000000000000..c94ea07601930
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_lut.h
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : LUT related functions
+ *
+ */
+
+
+#ifndef _RTL8367C_ASICDRV_LUT_H_
+#define _RTL8367C_ASICDRV_LUT_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_LUT_AGETIMERMAX        (7)
+#define RTL8367C_LUT_AGESPEEDMAX        (3)
+#define RTL8367C_LUT_LEARNLIMITMAX      (0x1040)
+#define RTL8367C_LUT_ADDRMAX            (0x103F)
+#define RTL8367C_LUT_IPMCGRP_TABLE_MAX  (0x3F)
+#define RTL8367C_LUT_ENTRY_SIZE         (6)
+#define RTL8367C_LUT_BUSY_CHECK_NO      (10)
+
+#define RTL8367C_LUT_TABLE_SIZE         (6)
+
+enum RTL8367C_LUTHASHMETHOD{
+
+    LUTHASHMETHOD_SVL=0,
+    LUTHASHMETHOD_IVL,
+    LUTHASHMETHOD_END,
+};
+
+
+enum RTL8367C_LRNOVERACT{
+
+    LRNOVERACT_FORWARD=0,
+    LRNOVERACT_DROP,
+    LRNOVERACT_TRAP,
+    LRNOVERACT_END,
+};
+
+enum RTL8367C_LUTREADMETHOD{
+
+    LUTREADMETHOD_MAC =0,
+    LUTREADMETHOD_ADDRESS,
+    LUTREADMETHOD_NEXT_ADDRESS,
+    LUTREADMETHOD_NEXT_L2UC,
+    LUTREADMETHOD_NEXT_L2MC,
+    LUTREADMETHOD_NEXT_L3MC,
+    LUTREADMETHOD_NEXT_L2L3MC,
+    LUTREADMETHOD_NEXT_L2UCSPA,
+};
+
+enum RTL8367C_FLUSHMODE
+{
+    FLUSHMDOE_PORT = 0,
+    FLUSHMDOE_VID,
+    FLUSHMDOE_FID,
+    FLUSHMDOE_END,
+};
+
+enum RTL8367C_FLUSHTYPE
+{
+    FLUSHTYPE_DYNAMIC = 0,
+    FLUSHTYPE_BOTH,
+    FLUSHTYPE_END,
+};
+
+
+typedef struct LUTTABLE{
+
+    ipaddr_t sip;
+    ipaddr_t dip;
+    ether_addr_t mac;
+    rtk_uint16 ivl_svl:1;
+    rtk_uint16 cvid_fid:12;
+    rtk_uint16 fid:4;
+    rtk_uint16 efid:3;
+
+    rtk_uint16 nosalearn:1;
+    rtk_uint16 da_block:1;
+    rtk_uint16 sa_block:1;
+    rtk_uint16 auth:1;
+    rtk_uint16 lut_pri:3;
+    rtk_uint16 sa_en:1;
+    rtk_uint16 fwd_en:1;
+    rtk_uint16 mbr:11;
+    rtk_uint16 spa:4;
+    rtk_uint16 age:3;
+    rtk_uint16 l3lookup:1;
+    rtk_uint16 igmp_asic:1;
+    rtk_uint16 igmpidx:8;
+
+    rtk_uint16 lookup_hit:1;
+    rtk_uint16 lookup_busy:1;
+    rtk_uint16 address:13;
+
+    rtk_uint16 l3vidlookup:1;
+    rtk_uint16 l3_vid:12;
+
+    rtk_uint16 wait_time;
+
+}rtl8367c_luttb;
+
+extern ret_t rtl8367c_setAsicLutIpMulticastLookup(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicLutIpMulticastLookup(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicLutIpMulticastVidLookup(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicLutIpMulticastVidLookup(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicLutAgeTimerSpeed(rtk_uint32 timer, rtk_uint32 speed);
+extern ret_t rtl8367c_getAsicLutAgeTimerSpeed(rtk_uint32* pTimer, rtk_uint32* pSpeed);
+extern ret_t rtl8367c_setAsicLutCamTbUsage(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicLutCamTbUsage(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_getAsicLutCamType(rtk_uint32* pType);
+extern ret_t rtl8367c_setAsicLutLearnLimitNo(rtk_uint32 port, rtk_uint32 number);
+extern ret_t rtl8367c_getAsicLutLearnLimitNo(rtk_uint32 port, rtk_uint32* pNumber);
+extern ret_t rtl8367c_setAsicSystemLutLearnLimitNo(rtk_uint32 number);
+extern ret_t rtl8367c_getAsicSystemLutLearnLimitNo(rtk_uint32 *pNumber);
+extern ret_t rtl8367c_setAsicLutLearnOverAct(rtk_uint32 action);
+extern ret_t rtl8367c_getAsicLutLearnOverAct(rtk_uint32* pAction);
+extern ret_t rtl8367c_setAsicSystemLutLearnOverAct(rtk_uint32 action);
+extern ret_t rtl8367c_getAsicSystemLutLearnOverAct(rtk_uint32 *pAction);
+extern ret_t rtl8367c_setAsicSystemLutLearnPortMask(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicSystemLutLearnPortMask(rtk_uint32 *pPortmask);
+extern ret_t rtl8367c_setAsicL2LookupTb(rtl8367c_luttb *pL2Table);
+extern ret_t rtl8367c_getAsicL2LookupTb(rtk_uint32 method, rtl8367c_luttb *pL2Table);
+extern ret_t rtl8367c_getAsicLutLearnNo(rtk_uint32 port, rtk_uint32* pNumber);
+extern ret_t rtl8367c_setAsicLutIpLookupMethod(rtk_uint32 type);
+extern ret_t rtl8367c_getAsicLutIpLookupMethod(rtk_uint32* pType);
+extern ret_t rtl8367c_setAsicLutForceFlush(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicLutForceFlushStatus(rtk_uint32 *pPortmask);
+extern ret_t rtl8367c_setAsicLutFlushMode(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicLutFlushMode(rtk_uint32* pMode);
+extern ret_t rtl8367c_setAsicLutFlushType(rtk_uint32 type);
+extern ret_t rtl8367c_getAsicLutFlushType(rtk_uint32* pType);
+extern ret_t rtl8367c_setAsicLutFlushVid(rtk_uint32 vid);
+extern ret_t rtl8367c_getAsicLutFlushVid(rtk_uint32* pVid);
+extern ret_t rtl8367c_setAsicLutFlushFid(rtk_uint32 fid);
+extern ret_t rtl8367c_getAsicLutFlushFid(rtk_uint32* pFid);
+extern ret_t rtl8367c_setAsicLutDisableAging(rtk_uint32 port, rtk_uint32 disabled);
+extern ret_t rtl8367c_getAsicLutDisableAging(rtk_uint32 port, rtk_uint32 *pDisabled);
+extern ret_t rtl8367c_setAsicLutIPMCGroup(rtk_uint32 index, ipaddr_t group_addr, rtk_uint32 vid, rtk_uint32 pmask, rtk_uint32 valid);
+extern ret_t rtl8367c_getAsicLutIPMCGroup(rtk_uint32 index, ipaddr_t *pGroup_addr, rtk_uint32 *pVid, rtk_uint32 *pPmask, rtk_uint32 *pValid);
+extern ret_t rtl8367c_setAsicLutLinkDownForceAging(rtk_uint32 enable);
+extern ret_t rtl8367c_getAsicLutLinkDownForceAging(rtk_uint32 *pEnable);
+extern ret_t rtl8367c_setAsicLutFlushAll(void);
+extern ret_t rtl8367c_getAsicLutFlushAllStatus(rtk_uint32 *pBusyStatus);
+extern ret_t rtl8367c_setAsicLutIpmcFwdRouterPort(rtk_uint32 enable);
+extern ret_t rtl8367c_getAsicLutIpmcFwdRouterPort(rtk_uint32 *pEnable);
+
+#endif /*_RTL8367C_ASICDRV_LUT_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_meter.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_meter.h
new file mode 100644
index 0000000000000..ba761a94f8da8
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_meter.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Shared meter related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_METER_H_
+#define _RTL8367C_ASICDRV_METER_H_
+
+#include <rtl8367c_asicdrv.h>
+
+
+extern ret_t rtl8367c_setAsicShareMeter(rtk_uint32 index, rtk_uint32 rate, rtk_uint32 ifg);
+extern ret_t rtl8367c_getAsicShareMeter(rtk_uint32 index, rtk_uint32 *pRate, rtk_uint32 *pIfg);
+extern ret_t rtl8367c_setAsicShareMeterBucketSize(rtk_uint32 index, rtk_uint32 lbThreshold);
+extern ret_t rtl8367c_getAsicShareMeterBucketSize(rtk_uint32 index, rtk_uint32 *pLbThreshold);
+extern ret_t rtl8367c_setAsicShareMeterType(rtk_uint32 index, rtk_uint32 type);
+extern ret_t rtl8367c_getAsicShareMeterType(rtk_uint32 index, rtk_uint32 *pType);
+extern ret_t rtl8367c_setAsicMeterExceedStatus(rtk_uint32 index);
+extern ret_t rtl8367c_getAsicMeterExceedStatus(rtk_uint32 index, rtk_uint32* pStatus);
+
+#endif /*_RTL8367C_ASICDRV_FC_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_mib.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_mib.h
new file mode 100644
index 0000000000000..ca46e0f4706c7
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_mib.h
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : MIB related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_MIB_H_
+#define _RTL8367C_ASICDRV_MIB_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_MIB_PORT_OFFSET                (0x7C)
+#define RTL8367C_MIB_LEARNENTRYDISCARD_OFFSET   (0x420)
+
+#define RTL8367C_MAX_LOG_CNT_NUM                (32)
+#define RTL8367C_MIB_MAX_LOG_CNT_IDX            (RTL8367C_MAX_LOG_CNT_NUM - 1)
+#define RTL8367C_MIB_LOG_CNT_OFFSET             (0x3E0)
+#define RTL8367C_MIB_MAX_LOG_MODE_IDX           (16-1)
+
+typedef enum RTL8367C_MIBCOUNTER_E{
+
+    /* RX */
+    ifInOctets = 0,
+
+    dot3StatsFCSErrors,
+    dot3StatsSymbolErrors,
+    dot3InPauseFrames,
+    dot3ControlInUnknownOpcodes,
+
+    etherStatsFragments,
+    etherStatsJabbers,
+    ifInUcastPkts,
+    etherStatsDropEvents,
+
+    ifInMulticastPkts,
+    ifInBroadcastPkts,
+    inMldChecksumError,
+    inIgmpChecksumError,
+    inMldSpecificQuery,
+    inMldGeneralQuery,
+    inIgmpSpecificQuery,
+    inIgmpGeneralQuery,
+    inMldLeaves,
+    inIgmpLeaves,
+
+    /* TX/RX */
+    etherStatsOctets,
+
+    etherStatsUnderSizePkts,
+    etherOversizeStats,
+    etherStatsPkts64Octets,
+    etherStatsPkts65to127Octets,
+    etherStatsPkts128to255Octets,
+    etherStatsPkts256to511Octets,
+    etherStatsPkts512to1023Octets,
+    etherStatsPkts1024to1518Octets,
+
+    /* TX */
+    ifOutOctets,
+
+    dot3StatsSingleCollisionFrames,
+    dot3StatMultipleCollisionFrames,
+    dot3sDeferredTransmissions,
+    dot3StatsLateCollisions,
+    etherStatsCollisions,
+    dot3StatsExcessiveCollisions,
+    dot3OutPauseFrames,
+    ifOutDiscards,
+
+    /* ALE */
+    dot1dTpPortInDiscards,
+    ifOutUcastPkts,
+    ifOutMulticastPkts,
+    ifOutBroadcastPkts,
+    outOampduPkts,
+    inOampduPkts,
+
+    inIgmpJoinsSuccess,
+    inIgmpJoinsFail,
+    inMldJoinsSuccess,
+    inMldJoinsFail,
+    inReportSuppressionDrop,
+    inLeaveSuppressionDrop,
+    outIgmpReports,
+    outIgmpLeaves,
+    outIgmpGeneralQuery,
+    outIgmpSpecificQuery,
+    outMldReports,
+    outMldLeaves,
+    outMldGeneralQuery,
+    outMldSpecificQuery,
+    inKnownMulticastPkts,
+
+    /*Device only */
+    dot1dTpLearnedEntryDiscards,
+    RTL8367C_MIBS_NUMBER,
+
+}RTL8367C_MIBCOUNTER;
+
+
+extern ret_t rtl8367c_setAsicMIBsCounterReset(rtk_uint32 greset, rtk_uint32 qmreset, rtk_uint32 pmask);
+extern ret_t rtl8367c_getAsicMIBsCounter(rtk_uint32 port,RTL8367C_MIBCOUNTER mibIdx, rtk_uint64* pCounter);
+extern ret_t rtl8367c_getAsicMIBsLogCounter(rtk_uint32 index, rtk_uint32 *pCounter);
+extern ret_t rtl8367c_getAsicMIBsControl(rtk_uint32* pMask);
+
+extern ret_t rtl8367c_setAsicMIBsResetValue(rtk_uint32 value);
+extern ret_t rtl8367c_getAsicMIBsResetValue(rtk_uint32* value);
+
+extern ret_t rtl8367c_setAsicMIBsUsageMode(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicMIBsUsageMode(rtk_uint32* pMode);
+extern ret_t rtl8367c_setAsicMIBsTimer(rtk_uint32 timer);
+extern ret_t rtl8367c_getAsicMIBsTimer(rtk_uint32* pTimer);
+extern ret_t rtl8367c_setAsicMIBsLoggingMode(rtk_uint32 index, rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicMIBsLoggingMode(rtk_uint32 index, rtk_uint32* pMode);
+extern ret_t rtl8367c_setAsicMIBsLoggingType(rtk_uint32 index, rtk_uint32 type);
+extern ret_t rtl8367c_getAsicMIBsLoggingType(rtk_uint32 index, rtk_uint32* pType);
+extern ret_t rtl8367c_setAsicMIBsResetLoggingCounter(rtk_uint32 index);
+extern ret_t rtl8367c_setAsicMIBsLength(rtk_uint32 txLengthMode, rtk_uint32 rxLengthMode);
+extern ret_t rtl8367c_getAsicMIBsLength(rtk_uint32 *pTxLengthMode, rtk_uint32 *pRxLengthMode);
+
+#endif /*#ifndef _RTL8367C_ASICDRV_MIB_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_mirror.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_mirror.h
new file mode 100644
index 0000000000000..23b788d7a6293
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_mirror.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Port mirror related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_MIRROR_H_
+#define _RTL8367C_ASICDRV_MIRROR_H_
+
+#include <rtl8367c_asicdrv.h>
+
+extern ret_t rtl8367c_setAsicPortMirror(rtk_uint32 source, rtk_uint32 monitor);
+extern ret_t rtl8367c_getAsicPortMirror(rtk_uint32 *pSource, rtk_uint32 *pMonitor);
+extern ret_t rtl8367c_setAsicPortMirrorRxFunction(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicPortMirrorRxFunction(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicPortMirrorTxFunction(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicPortMirrorTxFunction(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicPortMirrorIsolation(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicPortMirrorIsolation(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicPortMirrorPriority(rtk_uint32 priority);
+extern ret_t rtl8367c_getAsicPortMirrorPriority(rtk_uint32* pPriority);
+extern ret_t rtl8367c_setAsicPortMirrorMask(rtk_uint32 SourcePortmask);
+extern ret_t rtl8367c_getAsicPortMirrorMask(rtk_uint32 *pSourcePortmask);
+extern ret_t rtl8367c_setAsicPortMirrorVlanRxLeaky(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicPortMirrorVlanRxLeaky(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicPortMirrorVlanTxLeaky(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicPortMirrorVlanTxLeaky(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicPortMirrorIsolationRxLeaky(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicPortMirrorIsolationRxLeaky(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicPortMirrorIsolationTxLeaky(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicPortMirrorIsolationTxLeaky(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicPortMirrorRealKeep(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicPortMirrorRealKeep(rtk_uint32* pMode);
+extern ret_t rtl8367c_setAsicPortMirrorOverride(rtk_uint32 rxMirror, rtk_uint32 txMirror, rtk_uint32 aclMirror);
+extern ret_t rtl8367c_getAsicPortMirrorOverride(rtk_uint32 *pRxMirror, rtk_uint32 *pTxMirror, rtk_uint32 *pAclMirror);
+
+#endif /*#ifndef _RTL8367C_ASICDRV_MIRROR_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_misc.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_misc.h
new file mode 100644
index 0000000000000..c666a7b58bd5c
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_misc.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Miscellaneous functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_MISC_H_
+#define _RTL8367C_ASICDRV_MISC_H_
+
+#include <rtl8367c_asicdrv.h>
+
+extern ret_t rtl8367c_setAsicMacAddress(ether_addr_t mac);
+extern ret_t rtl8367c_getAsicMacAddress(ether_addr_t *pMac);
+extern ret_t rtl8367c_getAsicDebugInfo(rtk_uint32 port, rtk_uint32 *pDebugifo);
+extern ret_t rtl8367c_setAsicPortJamMode(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicPortJamMode(rtk_uint32* pMode);
+extern ret_t rtl8367c_setAsicMaxLengthCfg(rtk_uint32 cfgId, rtk_uint32 maxLength);
+extern ret_t rtl8367c_getAsicMaxLengthCfg(rtk_uint32 cfgId, rtk_uint32 *pMaxLength);
+extern ret_t rtl8367c_setAsicMaxLength(rtk_uint32 port, rtk_uint32 type, rtk_uint32 cfgId);
+extern ret_t rtl8367c_getAsicMaxLength(rtk_uint32 port, rtk_uint32 type, rtk_uint32 *pCfgId);
+
+#endif /*_RTL8367C_ASICDRV_MISC_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_oam.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_oam.h
new file mode 100644
index 0000000000000..c09dc7698868c
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_oam.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 42321 $
+ * $Date: 2013-08-26 13:51:29 +0800 (g@, 26 K 2013) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : OAM related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_OAM_H_
+#define _RTL8367C_ASICDRV_OAM_H_
+
+#include <rtl8367c_asicdrv.h>
+
+enum OAMPARACT
+{
+    OAM_PARFWD = 0,
+    OAM_PARLB,
+    OAM_PARDISCARD,
+    OAM_PARFWDCPU
+};
+
+enum OAMMULACT
+{
+    OAM_MULFWD = 0,
+    OAM_MULDISCARD,
+    OAM_MULCPU
+};
+
+extern ret_t rtl8367c_setAsicOamParser(rtk_uint32 port, rtk_uint32 parser);
+extern ret_t rtl8367c_getAsicOamParser(rtk_uint32 port, rtk_uint32* pParser);
+extern ret_t rtl8367c_setAsicOamMultiplexer(rtk_uint32 port, rtk_uint32 multiplexer);
+extern ret_t rtl8367c_getAsicOamMultiplexer(rtk_uint32 port, rtk_uint32* pMultiplexer);
+extern ret_t rtl8367c_setAsicOamCpuPri(rtk_uint32 priority);
+extern ret_t rtl8367c_getAsicOamCpuPri(rtk_uint32 *pPriority);
+extern ret_t rtl8367c_setAsicOamEnable(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicOamEnable(rtk_uint32 *pEnabled);
+#endif /*_RTL8367C_ASICDRV_OAM_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_phy.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_phy.h
new file mode 100644
index 0000000000000..e993d6edf73cf
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_phy.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : PHY related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_PHY_H_
+#define _RTL8367C_ASICDRV_PHY_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_PHY_REGNOMAX           0x1F
+#define RTL8367C_PHY_EXTERNALMAX        0x7
+
+#define RTL8367C_PHY_BASE               0x2000
+#define RTL8367C_PHY_EXT_BASE           0xA000
+
+#define RTL8367C_PHY_OFFSET             5
+#define RTL8367C_PHY_EXT_OFFSET         9
+
+#define RTL8367C_PHY_PAGE_ADDRESS       31
+
+
+extern ret_t rtl8367c_setAsicPHYReg(rtk_uint32 phyNo, rtk_uint32 phyAddr, rtk_uint32 regData );
+extern ret_t rtl8367c_getAsicPHYReg(rtk_uint32 phyNo, rtk_uint32 phyAddr, rtk_uint32* pRegData );
+extern ret_t rtl8367c_setAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 ocpData );
+extern ret_t rtl8367c_getAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 *pRegData );
+extern ret_t rtl8367c_setAsicSdsReg(rtk_uint32 sdsId, rtk_uint32 sdsReg, rtk_uint32 sdsPage,  rtk_uint32 value);
+extern ret_t rtl8367c_getAsicSdsReg(rtk_uint32 sdsId, rtk_uint32 sdsReg, rtk_uint32 sdsPage, rtk_uint32 *value);
+
+#endif /*#ifndef _RTL8367C_ASICDRV_PHY_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_port.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_port.h
new file mode 100644
index 0000000000000..ad99d8560b7e9
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_port.h
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76333 $
+ * $Date: 2017-03-09 09:33:15 +0800 (g|, 09 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Port security related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_PORTSECURITY_H_
+#define _RTL8367C_ASICDRV_PORTSECURITY_H_
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_unknownMulticast.h>
+#include <rtl8367c_asicdrv_phy.h>
+
+/****************************************************************/
+/* Type Definition                                              */
+/****************************************************************/
+
+#define RTL8367C_MAC7       7
+#define RTL8367C_EXTNO       3
+
+#define RTL8367C_RTCT_PAGE          (11)
+#define RTL8367C_RTCT_RESULT_A_REG  (27)
+#define RTL8367C_RTCT_RESULT_B_REG  (28)
+#define RTL8367C_RTCT_RESULT_C_REG  (29)
+#define RTL8367C_RTCT_RESULT_D_REG  (30)
+#define RTL8367C_RTCT_STATUS_REG    (26)
+
+enum L2_SECURITY_BEHAVE
+{
+    L2_BEHAVE_FLOODING = 0,
+    L2_BEHAVE_DROP,
+    L2_BEHAVE_TRAP,
+    L2_BEHAVE_END
+};
+
+enum L2_UNDA_BEHAVE
+{
+    L2_UNDA_BEHAVE_FLOODING_PMASK = 0,
+    L2_UNDA_BEHAVE_DROP,
+    L2_UNDA_BEHAVE_TRAP,
+    L2_UNDA_BEHAVE_FLOODING,
+    L2_UNDA_BEHAVE_END
+};
+
+enum L2_SECURITY_SA_BEHAVE
+{
+    L2_BEHAVE_SA_FLOODING = 0,
+    L2_BEHAVE_SA_DROP,
+    L2_BEHAVE_SA_TRAP,
+    L2_BEHAVE_SA_COPY28051,
+    L2_BEHAVE_SA_END
+};
+
+/* enum for port current link speed */
+enum SPEEDMODE
+{
+    SPD_10M = 0,
+    SPD_100M,
+    SPD_1000M,
+    SPD_2500M
+};
+
+/* enum for mac link mode */
+enum LINKMODE
+{
+    MAC_NORMAL = 0,
+    MAC_FORCE,
+};
+
+/* enum for port current link duplex mode */
+enum DUPLEXMODE
+{
+    HALF_DUPLEX = 0,
+    FULL_DUPLEX
+};
+
+/* enum for port current MST mode */
+enum MSTMODE
+{
+    SLAVE_MODE= 0,
+    MASTER_MODE
+};
+
+
+enum EXTMODE
+{
+    EXT_DISABLE = 0,
+    EXT_RGMII,
+    EXT_MII_MAC,
+    EXT_MII_PHY,
+    EXT_TMII_MAC,
+    EXT_TMII_PHY,
+    EXT_GMII,
+    EXT_RMII_MAC,
+    EXT_RMII_PHY,
+    EXT_SGMII,
+    EXT_HSGMII,
+    EXT_1000X_100FX,
+    EXT_1000X,
+    EXT_100FX,
+    EXT_RGMII_2,
+    EXT_MII_MAC_2,
+    EXT_MII_PHY_2,
+    EXT_TMII_MAC_2,
+    EXT_TMII_PHY_2,
+    EXT_RMII_MAC_2,
+    EXT_RMII_PHY_2,
+    EXT_END
+};
+
+enum DOSTYPE
+{
+    DOS_DAEQSA = 0,
+    DOS_LANDATTACKS,
+    DOS_BLATATTACKS,
+    DOS_SYNFINSCAN,
+    DOS_XMASCAN,
+    DOS_NULLSCAN,
+    DOS_SYN1024,
+    DOS_TCPSHORTHDR,
+    DOS_TCPFRAGERROR,
+    DOS_ICMPFRAGMENT,
+    DOS_END,
+
+};
+
+typedef struct  rtl8367c_port_ability_s{
+    rtk_uint16 forcemode;
+    rtk_uint16 mstfault;
+    rtk_uint16 mstmode;
+    rtk_uint16 nway;
+    rtk_uint16 txpause;
+    rtk_uint16 rxpause;
+    rtk_uint16 link;
+    rtk_uint16 duplex;
+    rtk_uint16 speed;
+}rtl8367c_port_ability_t;
+
+typedef struct  rtl8367c_port_status_s{
+
+    rtk_uint16 lpi1000;
+    rtk_uint16 lpi100;
+    rtk_uint16 mstfault;
+    rtk_uint16 mstmode;
+    rtk_uint16 nway;
+    rtk_uint16 txpause;
+    rtk_uint16 rxpause;
+    rtk_uint16 link;
+    rtk_uint16 duplex;
+    rtk_uint16 speed;
+
+}rtl8367c_port_status_t;
+
+typedef struct rtct_result_s
+{
+    rtk_uint32      channelAShort;
+    rtk_uint32      channelBShort;
+    rtk_uint32      channelCShort;
+    rtk_uint32      channelDShort;
+
+    rtk_uint32      channelAOpen;
+    rtk_uint32      channelBOpen;
+    rtk_uint32      channelCOpen;
+    rtk_uint32      channelDOpen;
+
+    rtk_uint32      channelAMismatch;
+    rtk_uint32      channelBMismatch;
+    rtk_uint32      channelCMismatch;
+    rtk_uint32      channelDMismatch;
+
+    rtk_uint32      channelALinedriver;
+    rtk_uint32      channelBLinedriver;
+    rtk_uint32      channelCLinedriver;
+    rtk_uint32      channelDLinedriver;
+
+    rtk_uint32      channelALen;
+    rtk_uint32      channelBLen;
+    rtk_uint32      channelCLen;
+    rtk_uint32      channelDLen;
+} rtl8367c_port_rtct_result_t;
+
+
+/****************************************************************/
+/* Driver Proto Type Definition                                 */
+/****************************************************************/
+extern ret_t rtl8367c_setAsicPortUnknownDaBehavior(rtk_uint32 port, rtk_uint32 behavior);
+extern ret_t rtl8367c_getAsicPortUnknownDaBehavior(rtk_uint32 port, rtk_uint32 *pBehavior);
+extern ret_t rtl8367c_setAsicPortUnknownSaBehavior(rtk_uint32 behavior);
+extern ret_t rtl8367c_getAsicPortUnknownSaBehavior(rtk_uint32 *pBehavior);
+extern ret_t rtl8367c_setAsicPortUnmatchedSaBehavior(rtk_uint32 behavior);
+extern ret_t rtl8367c_getAsicPortUnmatchedSaBehavior(rtk_uint32 *pBehavior);
+extern ret_t rtl8367c_setAsicPortUnmatchedSaMoving(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicPortUnmatchedSaMoving(rtk_uint32 port, rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicPortUnknownDaFloodingPortmask(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicPortUnknownDaFloodingPortmask(rtk_uint32 *pPortmask);
+extern ret_t rtl8367c_setAsicPortUnknownMulticastFloodingPortmask(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicPortUnknownMulticastFloodingPortmask(rtk_uint32 *pPortmask);
+extern ret_t rtl8367c_setAsicPortBcastFloodingPortmask(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicPortBcastFloodingPortmask(rtk_uint32 *pPortmask);
+extern ret_t rtl8367c_setAsicPortBlockSpa(rtk_uint32 port, rtk_uint32 block);
+extern ret_t rtl8367c_getAsicPortBlockSpa(rtk_uint32 port, rtk_uint32 *pBlock);
+extern ret_t rtl8367c_setAsicPortForceLink(rtk_uint32 port, rtl8367c_port_ability_t *pPortAbility);
+extern ret_t rtl8367c_getAsicPortForceLink(rtk_uint32 port, rtl8367c_port_ability_t *pPortAbility);
+extern ret_t rtl8367c_getAsicPortStatus(rtk_uint32 port, rtl8367c_port_status_t *pPortStatus);
+extern ret_t rtl8367c_setAsicPortForceLinkExt(rtk_uint32 id, rtl8367c_port_ability_t *pPortAbility);
+extern ret_t rtl8367c_getAsicPortForceLinkExt(rtk_uint32 id, rtl8367c_port_ability_t *pPortAbility);
+extern ret_t rtl8367c_setAsicPortExtMode(rtk_uint32 id, rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicPortExtMode(rtk_uint32 id, rtk_uint32 *pMode);
+extern ret_t rtl8367c_setAsicPortDos(rtk_uint32 type, rtk_uint32 drop);
+extern ret_t rtl8367c_getAsicPortDos(rtk_uint32 type, rtk_uint32* pDrop);
+extern ret_t rtl8367c_setAsicPortEnableAll(rtk_uint32 enable);
+extern ret_t rtl8367c_getAsicPortEnableAll(rtk_uint32 *pEnable);
+extern ret_t rtl8367c_setAsicPortSmallIpg(rtk_uint32 port, rtk_uint32 enable);
+extern ret_t rtl8367c_getAsicPortSmallIpg(rtk_uint32 port, rtk_uint32* pEnable);
+extern ret_t rtl8367c_setAsicPortLoopback(rtk_uint32 port, rtk_uint32 enable);
+extern ret_t rtl8367c_getAsicPortLoopback(rtk_uint32 port, rtk_uint32 *pEnable);
+extern ret_t rtl8367c_setAsicPortRTCTEnable(rtk_uint32 portmask);
+extern ret_t rtl8367c_setAsicPortRTCTDisable(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicPortRTCTResult(rtk_uint32 port, rtl8367c_port_rtct_result_t *pResult);
+extern ret_t rtl8367c_sdsReset(rtk_uint32 id);
+extern ret_t rtl8367c_getSdsLinkStatus(rtk_uint32 ext_id, rtk_uint32 *pSignalDetect, rtk_uint32 *pSync, rtk_uint32 *pLink);
+extern ret_t rtl8367c_setSgmiiNway(rtk_uint32 ext_id, rtk_uint32 state);
+extern ret_t rtl8367c_getSgmiiNway(rtk_uint32 ext_id, rtk_uint32 *pState);
+
+#endif /*_RTL8367C_ASICDRV_PORTSECURITY_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_portIsolation.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_portIsolation.h
new file mode 100644
index 0000000000000..e23d88e81f609
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_portIsolation.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Port isolation related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_PORTISOLATION_H_
+#define _RTL8367C_ASICDRV_PORTISOLATION_H_
+
+#include <rtl8367c_asicdrv.h>
+
+extern ret_t rtl8367c_setAsicPortIsolationPermittedPortmask(rtk_uint32 port, rtk_uint32 permitPortmask);
+extern ret_t rtl8367c_getAsicPortIsolationPermittedPortmask(rtk_uint32 port, rtk_uint32 *pPermitPortmask);
+extern ret_t rtl8367c_setAsicPortIsolationEfid(rtk_uint32 port, rtk_uint32 efid);
+extern ret_t rtl8367c_getAsicPortIsolationEfid(rtk_uint32 port, rtk_uint32 *pEfid);
+
+#endif /*_RTL8367C_ASICDRV_PORTISOLATION_H_*/
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_qos.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_qos.h
new file mode 100644
index 0000000000000..26042bfa13b4c
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_qos.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Qos related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_QOS_H_
+#define _RTL8367C_ASICDRV_QOS_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_DECISIONPRIMAX    0xFF
+
+/* enum Priority Selection Types */
+enum PRIDECISION
+{
+    PRIDEC_PORT = 0,
+    PRIDEC_ACL,
+    PRIDEC_DSCP,
+    PRIDEC_1Q,
+    PRIDEC_1AD,
+    PRIDEC_CVLAN,
+    PRIDEC_DA,
+    PRIDEC_SA,
+    PRIDEC_END,
+};
+
+/* enum Priority Selection Index */
+enum RTL8367C_PRIDEC_TABLE
+{
+    PRIDEC_IDX0 = 0,
+    PRIDEC_IDX1,
+    PRIDEC_IDX_END,
+};
+
+enum RTL8367C_DOT1P_PRISEL
+{
+    DOT1P_PRISEL_USER =  0,
+    DOT1P_PRISEL_TAG,
+    DOT1P_PRISEL_END
+};
+
+enum RTL8367C_DSCP_PRISEL
+{
+    DSCP_PRISEL_INTERNAL =  0,
+    DSCP_PRISEL_DSCP,
+    DSCP_PRISEL_USER ,
+    DSCP_PRISEL_END
+};
+
+
+extern ret_t rtl8367c_setAsicRemarkingDot1pAbility(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicRemarkingDot1pAbility(rtk_uint32 port, rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicRemarkingDot1pParameter(rtk_uint32 priority, rtk_uint32 newPriority );
+extern ret_t rtl8367c_getAsicRemarkingDot1pParameter(rtk_uint32 priority, rtk_uint32 *pNewPriority );
+extern  ret_t rtl8367c_setAsicRemarkingDot1pSrc(rtk_uint32 type);
+extern  ret_t rtl8367c_getAsicRemarkingDot1pSrc(rtk_uint32 *pType);
+extern ret_t rtl8367c_setAsicRemarkingDscpAbility(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicRemarkingDscpAbility(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicRemarkingDscpParameter(rtk_uint32 priority, rtk_uint32 newDscp );
+extern ret_t rtl8367c_getAsicRemarkingDscpParameter(rtk_uint32 priority, rtk_uint32* pNewDscp );
+
+extern ret_t rtl8367c_setAsicPriorityDot1qRemapping(rtk_uint32 srcpriority, rtk_uint32 priority );
+extern ret_t rtl8367c_getAsicPriorityDot1qRemapping(rtk_uint32 srcpriority, rtk_uint32 *pPriority );
+extern ret_t rtl8367c_setAsicPriorityDscpBased(rtk_uint32 dscp, rtk_uint32 priority );
+extern ret_t rtl8367c_getAsicPriorityDscpBased(rtk_uint32 dscp, rtk_uint32 *pPriority );
+extern ret_t rtl8367c_setAsicPriorityPortBased(rtk_uint32 port, rtk_uint32 priority );
+extern ret_t rtl8367c_getAsicPriorityPortBased(rtk_uint32 port, rtk_uint32 *pPriority );
+extern ret_t rtl8367c_setAsicPriorityDecision(rtk_uint32 index, rtk_uint32 prisrc, rtk_uint32 decisionPri);
+extern ret_t rtl8367c_getAsicPriorityDecision(rtk_uint32 index, rtk_uint32 prisrc, rtk_uint32* pDecisionPri);
+extern ret_t rtl8367c_setAsicPriorityToQIDMappingTable(rtk_uint32 qnum, rtk_uint32 priority, rtk_uint32 qid );
+extern ret_t rtl8367c_getAsicPriorityToQIDMappingTable(rtk_uint32 qnum, rtk_uint32 priority, rtk_uint32* pQid);
+extern ret_t rtl8367c_setAsicOutputQueueMappingIndex(rtk_uint32 port, rtk_uint32 qnum );
+extern ret_t rtl8367c_getAsicOutputQueueMappingIndex(rtk_uint32 port, rtk_uint32 *pQnum );
+
+extern ret_t rtl8367c_setAsicRemarkingDscpSrc(rtk_uint32 type);
+extern ret_t rtl8367c_getAsicRemarkingDscpSrc(rtk_uint32 *pType);
+extern ret_t rtl8367c_setAsicRemarkingDscp2Dscp(rtk_uint32 dscp, rtk_uint32 rmkDscp);
+extern ret_t rtl8367c_getAsicRemarkingDscp2Dscp(rtk_uint32 dscp, rtk_uint32 *pRmkDscp);
+
+extern ret_t rtl8367c_setAsicPortPriorityDecisionIndex(rtk_uint32 port, rtk_uint32 index );
+extern ret_t rtl8367c_getAsicPortPriorityDecisionIndex(rtk_uint32 port, rtk_uint32 *pIndex );
+
+#endif /*#ifndef _RTL8367C_ASICDRV_QOS_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_rldp.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_rldp.h
new file mode 100644
index 0000000000000..cde970b638b32
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_rldp.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 42321 $
+ * $Date: 2013-08-26 13:51:29 +0800 (g@, 26 K 2013) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : RLDP related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_RLDP_H_
+#define _RTL8367C_ASICDRV_RLDP_H_
+
+#include <rtl8367c_asicdrv.h>
+#include <string.h>
+
+extern ret_t rtl8367c_setAsicRldp(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicRldp(rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicRldpEnable8051(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicRldpEnable8051(rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicRldpCompareRandomNumber(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicRldpCompareRandomNumber(rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicRldpIndicatorSource(rtk_uint32 src);
+extern ret_t rtl8367c_getAsicRldpIndicatorSource(rtk_uint32 *pSrc);
+extern ret_t rtl8367c_setAsicRldpCheckingStatePara(rtk_uint32 retryCount, rtk_uint32 retryPeriod);
+extern ret_t rtl8367c_getAsicRldpCheckingStatePara(rtk_uint32 *pRetryCount, rtk_uint32 *pRetryPeriod);
+extern ret_t rtl8367c_setAsicRldpLoopStatePara(rtk_uint32 retryCount, rtk_uint32 retryPeriod);
+extern ret_t rtl8367c_getAsicRldpLoopStatePara(rtk_uint32 *pRetryCount, rtk_uint32 *pRetryPeriod);
+extern ret_t rtl8367c_setAsicRldpTxPortmask(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicRldpTxPortmask(rtk_uint32 *pPortmask);
+extern ret_t rtl8367c_setAsicRldpMagicNum(ether_addr_t seed);
+extern ret_t rtl8367c_getAsicRldpMagicNum(ether_addr_t *pSeed);
+extern ret_t rtl8367c_getAsicRldpLoopedPortmask(rtk_uint32 *pPortmask);
+extern ret_t rtl8367c_setAsicRldp8051Portmask(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicRldp8051Portmask(rtk_uint32 *pPortmask);
+
+
+extern ret_t rtl8367c_getAsicRldpRandomNumber(ether_addr_t *pRandNumber);
+extern ret_t rtl8367c_getAsicRldpLoopedPortPair(rtk_uint32 port, rtk_uint32 *pLoopedPair);
+extern ret_t rtl8367c_setAsicRlppTrap8051(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicRlppTrap8051(rtk_uint32 *pEnabled);
+
+extern ret_t rtl8367c_setAsicRldpLeaveLoopedPortmask(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicRldpLeaveLoopedPortmask(rtk_uint32 *pPortmask);
+
+extern ret_t rtl8367c_setAsicRldpEnterLoopedPortmask(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicRldpEnterLoopedPortmask(rtk_uint32 *pPortmask);
+
+extern ret_t rtl8367c_setAsicRldpTriggerMode(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicRldpTriggerMode(rtk_uint32 *pEnabled);
+
+#endif /*_RTL8367C_ASICDRV_RLDP_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_rma.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_rma.h
new file mode 100644
index 0000000000000..10c707544f93b
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_rma.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 64716 $
+ * $Date: 2015-12-31 16:31:55 +0800 (g|, 31 QG 2015) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : RMA related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_RMA_H_
+#define _RTL8367C_ASICDRV_RMA_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_RMAMAX                     0x2F
+
+enum RTL8367C_RMAOP
+{
+    RMAOP_FORWARD = 0,
+    RMAOP_TRAP_TO_CPU,
+    RMAOP_DROP,
+    RMAOP_FORWARD_EXCLUDE_CPU,
+    RMAOP_END
+};
+
+
+typedef struct  rtl8367c_rma_s{
+
+    rtk_uint16 operation;
+    rtk_uint16 discard_storm_filter;
+    rtk_uint16 trap_priority;
+    rtk_uint16 keep_format;
+    rtk_uint16 vlan_leaky;
+    rtk_uint16 portiso_leaky;
+
+}rtl8367c_rma_t;
+
+
+extern ret_t rtl8367c_setAsicRma(rtk_uint32 index, rtl8367c_rma_t* pRmacfg);
+extern ret_t rtl8367c_getAsicRma(rtk_uint32 index, rtl8367c_rma_t* pRmacfg);
+extern ret_t rtl8367c_setAsicRmaCdp(rtl8367c_rma_t* pRmacfg);
+extern ret_t rtl8367c_getAsicRmaCdp(rtl8367c_rma_t* pRmacfg);
+extern ret_t rtl8367c_setAsicRmaCsstp(rtl8367c_rma_t* pRmacfg);
+extern ret_t rtl8367c_getAsicRmaCsstp(rtl8367c_rma_t* pRmacfg);
+extern ret_t rtl8367c_setAsicRmaLldp(rtk_uint32 enabled, rtl8367c_rma_t* pRmacfg);
+extern ret_t rtl8367c_getAsicRmaLldp(rtk_uint32 *pEnabled, rtl8367c_rma_t* pRmacfg);
+
+#endif /*#ifndef _RTL8367C_ASICDRV_RMA_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_scheduling.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_scheduling.h
new file mode 100644
index 0000000000000..919a4ca692627
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_scheduling.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Packet Scheduling related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_SCHEDULING_H_
+#define _RTL8367C_ASICDRV_SCHEDULING_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_QWEIGHTMAX    0x7F
+#define RTL8367C_PORT_QUEUE_METER_INDEX_MAX    7
+
+/* enum for queue type */
+enum QUEUETYPE
+{
+    QTYPE_STRICT = 0,
+    QTYPE_WFQ,
+};
+extern ret_t rtl8367c_setAsicLeakyBucketParameter(rtk_uint32 tick, rtk_uint32 token);
+extern ret_t rtl8367c_getAsicLeakyBucketParameter(rtk_uint32 *tick, rtk_uint32 *token);
+extern ret_t rtl8367c_setAsicAprMeter(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 apridx);
+extern ret_t rtl8367c_getAsicAprMeter(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 *apridx);
+extern ret_t rtl8367c_setAsicPprMeter(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 ppridx);
+extern ret_t rtl8367c_getAsicPprMeter(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 *ppridx);
+extern ret_t rtl8367c_setAsicAprEnable(rtk_uint32 port, rtk_uint32 aprEnable);
+extern ret_t rtl8367c_getAsicAprEnable(rtk_uint32 port, rtk_uint32 *aprEnable);
+extern ret_t rtl8367c_setAsicPprEnable(rtk_uint32 port, rtk_uint32 pprEnable);
+extern ret_t rtl8367c_getAsicPprEnable(rtk_uint32 port, rtk_uint32 *pprEnable);
+
+extern ret_t rtl8367c_setAsicWFQWeight(rtk_uint32, rtk_uint32 queueid, rtk_uint32 weight );
+extern ret_t rtl8367c_getAsicWFQWeight(rtk_uint32, rtk_uint32 queueid, rtk_uint32 *weight );
+extern ret_t rtl8367c_setAsicWFQBurstSize(rtk_uint32 burstsize);
+extern ret_t rtl8367c_getAsicWFQBurstSize(rtk_uint32 *burstsize);
+
+extern ret_t rtl8367c_setAsicQueueType(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 queueType);
+extern ret_t rtl8367c_getAsicQueueType(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 *queueType);
+extern ret_t rtl8367c_setAsicQueueRate(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 ppridx, rtk_uint32 apridx );
+extern ret_t rtl8367c_getAsicQueueRate(rtk_uint32 port, rtk_uint32 qid, rtk_uint32* ppridx, rtk_uint32* apridx );
+extern ret_t rtl8367c_setAsicPortEgressRate(rtk_uint32 port, rtk_uint32 rate);
+extern ret_t rtl8367c_getAsicPortEgressRate(rtk_uint32 port, rtk_uint32 *rate);
+extern ret_t rtl8367c_setAsicPortEgressRateIfg(rtk_uint32 ifg);
+extern ret_t rtl8367c_getAsicPortEgressRateIfg(rtk_uint32 *ifg);
+
+#endif /*_RTL8367C_ASICDRV_SCHEDULING_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_storm.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_storm.h
new file mode 100644
index 0000000000000..3865b5225a811
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_storm.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Storm control filtering related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_STORM_H_
+#define _RTL8367C_ASICDRV_STORM_H_
+
+#include <rtl8367c_asicdrv.h>
+
+extern ret_t rtl8367c_setAsicStormFilterBroadcastEnable(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicStormFilterBroadcastEnable(rtk_uint32 port, rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicStormFilterBroadcastMeter(rtk_uint32 port, rtk_uint32 meter);
+extern ret_t rtl8367c_getAsicStormFilterBroadcastMeter(rtk_uint32 port, rtk_uint32 *pMeter);
+extern ret_t rtl8367c_setAsicStormFilterMulticastEnable(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicStormFilterMulticastEnable(rtk_uint32 port, rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicStormFilterMulticastMeter(rtk_uint32 port, rtk_uint32 meter);
+extern ret_t rtl8367c_getAsicStormFilterMulticastMeter(rtk_uint32 port, rtk_uint32 *pMeter);
+extern ret_t rtl8367c_setAsicStormFilterUnknownMulticastEnable(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicStormFilterUnknownMulticastEnable(rtk_uint32 port, rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicStormFilterUnknownMulticastMeter(rtk_uint32 port, rtk_uint32 meter);
+extern ret_t rtl8367c_getAsicStormFilterUnknownMulticastMeter(rtk_uint32 port, rtk_uint32 *pMeter);
+extern ret_t rtl8367c_setAsicStormFilterUnknownUnicastEnable(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicStormFilterUnknownUnicastEnable(rtk_uint32 port, rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicStormFilterUnknownUnicastMeter(rtk_uint32 port, rtk_uint32 meter);
+extern ret_t rtl8367c_getAsicStormFilterUnknownUnicastMeter(rtk_uint32 port, rtk_uint32 *pMeter);
+extern ret_t rtl8367c_setAsicStormFilterExtBroadcastMeter(rtk_uint32 meter);
+extern ret_t rtl8367c_getAsicStormFilterExtBroadcastMeter(rtk_uint32 *pMeter);
+extern ret_t rtl8367c_setAsicStormFilterExtMulticastMeter(rtk_uint32 meter);
+extern ret_t rtl8367c_getAsicStormFilterExtMulticastMeter(rtk_uint32 *pMeter);
+extern ret_t rtl8367c_setAsicStormFilterExtUnknownMulticastMeter(rtk_uint32 meter);
+extern ret_t rtl8367c_getAsicStormFilterExtUnknownMulticastMeter(rtk_uint32 *pMeter);
+extern ret_t rtl8367c_setAsicStormFilterExtUnknownUnicastMeter(rtk_uint32 meter);
+extern ret_t rtl8367c_getAsicStormFilterExtUnknownUnicastMeter(rtk_uint32 *pMeter);
+extern ret_t rtl8367c_setAsicStormFilterExtBroadcastEnable(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicStormFilterExtBroadcastEnable(rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicStormFilterExtMulticastEnable(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicStormFilterExtMulticastEnable(rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicStormFilterExtUnknownMulticastEnable(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicStormFilterExtUnknownMulticastEnable(rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicStormFilterExtUnknownUnicastEnable(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicStormFilterExtUnknownUnicastEnable(rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_setAsicStormFilterExtEnablePortMask(rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicStormFilterExtEnablePortMask(rtk_uint32 *pPortmask);
+
+
+#endif /*_RTL8367C_ASICDRV_STORM_H_*/
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_svlan.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_svlan.h
new file mode 100644
index 0000000000000..5a6a4a83290a3
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_svlan.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : SVLAN related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_SVLAN_H_
+#define _RTL8367C_ASICDRV_SVLAN_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_C2SIDXNO               128
+#define RTL8367C_C2SIDXMAX              (RTL8367C_C2SIDXNO-1)
+#define RTL8367C_MC2SIDXNO              32
+#define RTL8367C_MC2SIDXMAX             (RTL8367C_MC2SIDXNO-1)
+#define RTL8367C_SP2CIDXNO              128
+#define RTL8367C_SP2CMAX                (RTL8367C_SP2CIDXNO-1)
+
+#define RTL8367C_SVLAN_MEMCONF_LEN      4
+#define RTL8367C_SVLAN_MC2S_LEN         5
+#define RTL8367C_SVLAN_SP2C_LEN         2
+
+enum RTL8367C_SPRISEL
+{
+    SPRISEL_INTERNALPRI =  0,
+    SPRISEL_CTAGPRI,
+    SPRISEL_VSPRI,
+    SPRISEL_PBPRI,
+    SPRISEL_END
+};
+
+enum RTL8367C_SUNACCEPT
+{
+    SUNACCEPT_DROP =  0,
+    SUNACCEPT_TRAP,
+    SUNACCEPT_SVLAN,
+    SUNACCEPT_END
+};
+
+enum RTL8367C_SVLAN_MC2S_MODE
+{
+    SVLAN_MC2S_MODE_MAC =  0,
+    SVLAN_MC2S_MODE_IP,
+    SVLAN_MC2S_MODE_END
+};
+
+
+typedef struct  rtl8367c_svlan_memconf_s{
+
+    rtk_uint16 vs_member:11;
+    rtk_uint16 vs_untag:11;
+
+    rtk_uint16 vs_fid_msti:4;
+    rtk_uint16 vs_priority:3;
+    rtk_uint16 vs_force_fid:1;
+    rtk_uint16 reserved:8;
+
+    rtk_uint16 vs_svid:12;
+    rtk_uint16 vs_efiden:1;
+    rtk_uint16 vs_efid:3;
+
+
+}rtl8367c_svlan_memconf_t;
+
+
+typedef struct  rtl8367c_svlan_mc2s_s{
+
+    rtk_uint16 valid:1;
+    rtk_uint16 format:1;
+    rtk_uint16 svidx:6;
+    rtk_uint32 sdata;
+    rtk_uint32 smask;
+}rtl8367c_svlan_mc2s_t;
+
+
+typedef struct  rtl8367c_svlan_s2c_s{
+
+    rtk_uint16 valid:1;
+    rtk_uint16 svidx:6;
+    rtk_uint16 dstport:4;
+    rtk_uint32 vid:12;
+}rtl8367c_svlan_s2c_t;
+
+extern ret_t rtl8367c_setAsicSvlanIngressUntag(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicSvlanIngressUntag(rtk_uint32* pMode);
+extern ret_t rtl8367c_setAsicSvlanIngressUnmatch(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicSvlanIngressUnmatch(rtk_uint32* pMode);
+extern ret_t rtl8367c_setAsicSvlanTrapPriority(rtk_uint32 priority);
+extern ret_t rtl8367c_getAsicSvlanTrapPriority(rtk_uint32* pPriority);
+extern ret_t rtl8367c_setAsicSvlanDefaultVlan(rtk_uint32 port, rtk_uint32 index);
+extern ret_t rtl8367c_getAsicSvlanDefaultVlan(rtk_uint32 port, rtk_uint32* pIndex);
+
+extern ret_t rtl8367c_setAsicSvlanMemberConfiguration(rtk_uint32 index,rtl8367c_svlan_memconf_t* pSvlanMemCfg);
+extern ret_t rtl8367c_getAsicSvlanMemberConfiguration(rtk_uint32 index,rtl8367c_svlan_memconf_t* pSvlanMemCfg);
+
+extern ret_t rtl8367c_setAsicSvlanPrioritySel(rtk_uint32 priSel);
+extern ret_t rtl8367c_getAsicSvlanPrioritySel(rtk_uint32* pPriSel);
+extern ret_t rtl8367c_setAsicSvlanTpid(rtk_uint32 protocolType);
+extern ret_t rtl8367c_getAsicSvlanTpid(rtk_uint32* pProtocolType);
+extern ret_t rtl8367c_setAsicSvlanUplinkPortMask(rtk_uint32 portMask);
+extern ret_t rtl8367c_getAsicSvlanUplinkPortMask(rtk_uint32* pPortmask);
+extern ret_t rtl8367c_setAsicSvlanEgressUnassign(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicSvlanEgressUnassign(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicSvlanC2SConf(rtk_uint32 index, rtk_uint32 evid, rtk_uint32 portmask, rtk_uint32 svidx);
+extern ret_t rtl8367c_getAsicSvlanC2SConf(rtk_uint32 index, rtk_uint32* pEvid, rtk_uint32* pPortmask, rtk_uint32* pSvidx);
+extern ret_t rtl8367c_setAsicSvlanMC2SConf(rtk_uint32 index,rtl8367c_svlan_mc2s_t* pSvlanMc2sCfg);
+extern ret_t rtl8367c_getAsicSvlanMC2SConf(rtk_uint32 index,rtl8367c_svlan_mc2s_t* pSvlanMc2sCfg);
+extern ret_t rtl8367c_setAsicSvlanSP2CConf(rtk_uint32 index,rtl8367c_svlan_s2c_t* pSvlanSp2cCfg);
+extern ret_t rtl8367c_getAsicSvlanSP2CConf(rtk_uint32 index,rtl8367c_svlan_s2c_t* pSvlanSp2cCfg);
+extern ret_t rtl8367c_setAsicSvlanDmacCvidSel(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicSvlanDmacCvidSel(rtk_uint32 port, rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicSvlanUntagVlan(rtk_uint32 index);
+extern ret_t rtl8367c_getAsicSvlanUntagVlan(rtk_uint32* pIndex);
+extern ret_t rtl8367c_setAsicSvlanUnmatchVlan(rtk_uint32 index);
+extern ret_t rtl8367c_getAsicSvlanUnmatchVlan(rtk_uint32* pIndex);
+extern ret_t rtl8367c_setAsicSvlanLookupType(rtk_uint32 type);
+extern ret_t rtl8367c_getAsicSvlanLookupType(rtk_uint32* pType);
+
+
+#endif /*#ifndef _RTL8367C_ASICDRV_SVLAN_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_trunking.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_trunking.h
new file mode 100644
index 0000000000000..2e3a682819db1
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_trunking.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Port trunking related functions
+ *
+ */
+
+
+#ifndef _RTL8367C_ASICDRV_TRUNKING_H_
+#define _RTL8367C_ASICDRV_TRUNKING_H_
+
+#include <rtl8367c_asicdrv.h>
+
+#define RTL8367C_MAX_TRUNK_GID              (2)
+#define RTL8367C_TRUNKING_PORTNO            (4)
+#define RTL8367C_TRUNKING1_PORTN0           (2)
+#define RTL8367C_TRUNKING_HASHVALUE_MAX     (15)
+
+extern ret_t rtl8367c_setAsicTrunkingGroup(rtk_uint32 group, rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicTrunkingGroup(rtk_uint32 group, rtk_uint32* pPortmask);
+extern ret_t rtl8367c_setAsicTrunkingFlood(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicTrunkingFlood(rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicTrunkingHashSelect(rtk_uint32 hashsel);
+extern ret_t rtl8367c_getAsicTrunkingHashSelect(rtk_uint32* pHashsel);
+
+extern ret_t rtl8367c_getAsicQeueuEmptyStatus(rtk_uint32* pPortmask);
+
+extern ret_t rtl8367c_setAsicTrunkingMode(rtk_uint32 mode);
+extern ret_t rtl8367c_getAsicTrunkingMode(rtk_uint32* pMode);
+extern ret_t rtl8367c_setAsicTrunkingFc(rtk_uint32 group, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicTrunkingFc(rtk_uint32 group, rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicTrunkingHashTable(rtk_uint32 hashval, rtk_uint32 portId);
+extern ret_t rtl8367c_getAsicTrunkingHashTable(rtk_uint32 hashval, rtk_uint32* pPortId);
+extern ret_t rtl8367c_setAsicTrunkingHashTable1(rtk_uint32 hashval, rtk_uint32 portId);
+extern ret_t rtl8367c_getAsicTrunkingHashTable1(rtk_uint32 hashval, rtk_uint32* pPortId);
+
+#endif /*_RTL8367C_ASICDRV_TRUNKING_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_unknownMulticast.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_unknownMulticast.h
new file mode 100644
index 0000000000000..d142d25cff135
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_unknownMulticast.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Unkown multicast related functions
+ *
+ */
+
+#ifndef _RTL8367C_ASICDRV_UNKNOWNMULTICAST_H_
+#define _RTL8367C_ASICDRV_UNKNOWNMULTICAST_H_
+
+#include <rtl8367c_asicdrv.h>
+
+enum L2_UNKOWN_MULTICAST_BEHAVE
+{
+    L2_UNKOWN_MULTICAST_FLOODING = 0,
+    L2_UNKOWN_MULTICAST_DROP,
+    L2_UNKOWN_MULTICAST_TRAP,
+    L2_UNKOWN_MULTICAST_DROP_EXCLUDE_RMA,
+    L2_UNKOWN_MULTICAST_END
+};
+
+enum L3_UNKOWN_MULTICAST_BEHAVE
+{
+    L3_UNKOWN_MULTICAST_FLOODING = 0,
+    L3_UNKOWN_MULTICAST_DROP,
+    L3_UNKOWN_MULTICAST_TRAP,
+    L3_UNKOWN_MULTICAST_ROUTER,
+    L3_UNKOWN_MULTICAST_END
+};
+
+enum MULTICASTTYPE{
+    MULTICAST_TYPE_IPV4 = 0,
+    MULTICAST_TYPE_IPV6,
+    MULTICAST_TYPE_L2,
+    MULTICAST_TYPE_END
+};
+
+extern ret_t rtl8367c_setAsicUnknownL2MulticastBehavior(rtk_uint32 port, rtk_uint32 behave);
+extern ret_t rtl8367c_getAsicUnknownL2MulticastBehavior(rtk_uint32 port, rtk_uint32 *pBehave);
+extern ret_t rtl8367c_setAsicUnknownIPv4MulticastBehavior(rtk_uint32 port, rtk_uint32 behave);
+extern ret_t rtl8367c_getAsicUnknownIPv4MulticastBehavior(rtk_uint32 port, rtk_uint32 *pBehave);
+extern ret_t rtl8367c_setAsicUnknownIPv6MulticastBehavior(rtk_uint32 port, rtk_uint32 behave);
+extern ret_t rtl8367c_getAsicUnknownIPv6MulticastBehavior(rtk_uint32 port, rtk_uint32 *pBehave);
+extern ret_t rtl8367c_setAsicUnknownMulticastTrapPriority(rtk_uint32 priority);
+extern ret_t rtl8367c_getAsicUnknownMulticastTrapPriority(rtk_uint32 *pPriority);
+
+#endif /*_RTL8367C_ASICDRV_UNKNOWNMULTICAST_H_*/
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_vlan.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_vlan.h
new file mode 100644
index 0000000000000..61848650b5793
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_asicdrv_vlan.h
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : VLAN related functions
+ *
+ */
+
+
+#ifndef _RTL8367C_ASICDRV_VLAN_H_
+#define _RTL8367C_ASICDRV_VLAN_H_
+
+/****************************************************************/
+/* Header File inclusion                                        */
+/****************************************************************/
+#include <rtl8367c_asicdrv.h>
+
+/****************************************************************/
+/* Constant Definition                                          */
+/****************************************************************/
+#define RTL8367C_PROTOVLAN_GIDX_MAX 3
+#define RTL8367C_PROTOVLAN_GROUPNO  4
+
+#define RTL8367C_VLAN_BUSY_CHECK_NO     (10)
+
+#define RTL8367C_VLAN_MBRCFG_LEN    (4)
+#define RTL8367C_VLAN_4KTABLE_LEN   (3)
+
+/****************************************************************/
+/* Type Definition                                              */
+/****************************************************************/
+typedef struct  VLANCONFIGUSER
+{
+    rtk_uint16  evid;
+    rtk_uint16  mbr;
+    rtk_uint16  fid_msti;
+    rtk_uint16  envlanpol;
+    rtk_uint16  meteridx;
+    rtk_uint16  vbpen;
+    rtk_uint16  vbpri;
+}rtl8367c_vlanconfiguser;
+
+typedef struct  USER_VLANTABLE{
+
+    rtk_uint16  vid;
+    rtk_uint16  mbr;
+    rtk_uint16  untag;
+    rtk_uint16  fid_msti;
+    rtk_uint16  envlanpol;
+    rtk_uint16  meteridx;
+    rtk_uint16  vbpen;
+    rtk_uint16  vbpri;
+    rtk_uint16  ivl_svl;
+
+}rtl8367c_user_vlan4kentry;
+
+typedef enum
+{
+    FRAME_TYPE_BOTH = 0,
+    FRAME_TYPE_TAGGED_ONLY,
+    FRAME_TYPE_UNTAGGED_ONLY,
+    FRAME_TYPE_MAX_BOUND
+} rtl8367c_accframetype;
+
+typedef enum
+{
+    EG_TAG_MODE_ORI = 0,
+    EG_TAG_MODE_KEEP,
+    EG_TAG_MODE_PRI_TAG,
+    EG_TAG_MODE_REAL_KEEP,
+    EG_TAG_MODE_END
+} rtl8367c_egtagmode;
+
+typedef enum
+{
+    PPVLAN_FRAME_TYPE_ETHERNET = 0,
+    PPVLAN_FRAME_TYPE_LLC,
+    PPVLAN_FRAME_TYPE_RFC1042,
+    PPVLAN_FRAME_TYPE_END
+} rtl8367c_provlan_frametype;
+
+enum RTL8367C_STPST
+{
+    STPST_DISABLED = 0,
+    STPST_BLOCKING,
+    STPST_LEARNING,
+    STPST_FORWARDING
+};
+
+enum RTL8367C_RESVIDACT
+{
+    RES_VID_ACT_UNTAG = 0,
+    RES_VID_ACT_TAG,
+    RES_VID_ACT_END
+};
+
+typedef struct
+{
+    rtl8367c_provlan_frametype  frameType;
+    rtk_uint32                      etherType;
+} rtl8367c_protocolgdatacfg;
+
+typedef struct
+{
+    rtk_uint32 valid;
+    rtk_uint32 vlan_idx;
+    rtk_uint32 priority;
+} rtl8367c_protocolvlancfg;
+
+extern ret_t rtl8367c_setAsicVlanMemberConfig(rtk_uint32 index, rtl8367c_vlanconfiguser *pVlanCg);
+extern ret_t rtl8367c_getAsicVlanMemberConfig(rtk_uint32 index, rtl8367c_vlanconfiguser *pVlanCg);
+extern ret_t rtl8367c_setAsicVlan4kEntry(rtl8367c_user_vlan4kentry *pVlan4kEntry );
+extern ret_t rtl8367c_getAsicVlan4kEntry(rtl8367c_user_vlan4kentry *pVlan4kEntry );
+extern ret_t rtl8367c_setAsicVlanAccpetFrameType(rtk_uint32 port, rtl8367c_accframetype frameType);
+extern ret_t rtl8367c_getAsicVlanAccpetFrameType(rtk_uint32 port, rtl8367c_accframetype *pFrameType);
+extern ret_t rtl8367c_setAsicVlanIngressFilter(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicVlanIngressFilter(rtk_uint32 port, rtk_uint32 *pEnable);
+extern ret_t rtl8367c_setAsicVlanEgressTagMode(rtk_uint32 port, rtl8367c_egtagmode tagMode);
+extern ret_t rtl8367c_getAsicVlanEgressTagMode(rtk_uint32 port, rtl8367c_egtagmode *pTagMode);
+extern ret_t rtl8367c_setAsicVlanPortBasedVID(rtk_uint32 port, rtk_uint32 index, rtk_uint32 pri);
+extern ret_t rtl8367c_getAsicVlanPortBasedVID(rtk_uint32 port, rtk_uint32 *pIndex, rtk_uint32 *pPri);
+extern ret_t rtl8367c_setAsicVlanProtocolBasedGroupData(rtk_uint32 index, rtl8367c_protocolgdatacfg *pPbCfg);
+extern ret_t rtl8367c_getAsicVlanProtocolBasedGroupData(rtk_uint32 index, rtl8367c_protocolgdatacfg *pPbCfg);
+extern ret_t rtl8367c_setAsicVlanPortAndProtocolBased(rtk_uint32 port, rtk_uint32 index, rtl8367c_protocolvlancfg *pPpbCfg);
+extern ret_t rtl8367c_getAsicVlanPortAndProtocolBased(rtk_uint32 port, rtk_uint32 index, rtl8367c_protocolvlancfg *pPpbCfg);
+extern ret_t rtl8367c_setAsicVlanFilter(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicVlanFilter(rtk_uint32* pEnabled);
+
+extern ret_t rtl8367c_setAsicPortBasedFid(rtk_uint32 port, rtk_uint32 fid);
+extern ret_t rtl8367c_getAsicPortBasedFid(rtk_uint32 port, rtk_uint32* pFid);
+extern ret_t rtl8367c_setAsicPortBasedFidEn(rtk_uint32 port, rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicPortBasedFidEn(rtk_uint32 port, rtk_uint32* pEnabled);
+extern ret_t rtl8367c_setAsicSpanningTreeStatus(rtk_uint32 port, rtk_uint32 msti, rtk_uint32 state);
+extern ret_t rtl8367c_getAsicSpanningTreeStatus(rtk_uint32 port, rtk_uint32 msti, rtk_uint32* pState);
+extern ret_t rtl8367c_setAsicVlanUntagDscpPriorityEn(rtk_uint32 enabled);
+extern ret_t rtl8367c_getAsicVlanUntagDscpPriorityEn(rtk_uint32* enabled);
+extern ret_t rtl8367c_setAsicVlanTransparent(rtk_uint32 port, rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicVlanTransparent(rtk_uint32 port, rtk_uint32 *pPortmask);
+extern ret_t rtl8367c_setAsicVlanEgressKeep(rtk_uint32 port, rtk_uint32 portmask);
+extern ret_t rtl8367c_getAsicVlanEgressKeep(rtk_uint32 port, rtk_uint32* pPortmask);
+extern ret_t rtl8367c_setReservedVidAction(rtk_uint32 vid0Action, rtk_uint32 vid4095Action);
+extern ret_t rtl8367c_getReservedVidAction(rtk_uint32 *pVid0Action, rtk_uint32 *pVid4095Action);
+extern ret_t rtl8367c_setRealKeepRemarkEn(rtk_uint32 enabled);
+extern ret_t rtl8367c_getRealKeepRemarkEn(rtk_uint32 *pEnabled);
+extern ret_t rtl8367c_resetVlan(void);
+
+#endif /*#ifndef _RTL8367C_ASICDRV_VLAN_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_base.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_base.h
new file mode 100644
index 0000000000000..676ca8ed744de
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_base.h
@@ -0,0 +1,596 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Regsiter MACRO related definition
+ *
+ */
+
+#ifndef _RTL8367C_BASE_H_
+#define _RTL8367C_BASE_H_
+
+#include <rtl8367c_reg.h>
+
+/* (16'h0000) port_reg */
+
+#define    RTL8367C_PORT_SPECIAL_CONGEST_MODE_TIMER_BASE        RTL8367C_REG_PKTGEN_PORT0_TIMER
+#define    RTL8367C_PORT_SPECIAL_CONGEST_MODE_TIMER_REG(port)    (RTL8367C_PORT_SPECIAL_CONGEST_MODE_TIMER_BASE + (port << 5))
+
+#define    RTL8367C_PORT_MISC_CFG_BASE                            RTL8367C_REG_PORT0_MISC_CFG
+#define    RTL8367C_PORT_MISC_CFG_REG(port)                        (RTL8367C_PORT_MISC_CFG_BASE + (port << 5))
+#define    RTL8367C_1QREMARK_ENABLE_OFFSET                         RTL8367C_PORT0_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET
+#define    RTL8367C_1QREMARK_ENABLE_MASK                        RTL8367C_PORT0_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK
+
+#define    RTL8367C_INGRESSBW_PORT_IFG_MASK                        RTL8367C_PORT0_MISC_CFG_INGRESSBW_IFG_MASK
+#define    RTL8367C_VLAN_EGRESS_MDOE_MASK                        RTL8367C_PORT0_MISC_CFG_VLAN_EGRESS_MODE_MASK
+#define    RTL8367C_SPECIALCONGEST_SUSTAIN_TIMER_MASK            RTL8367C_PORT0_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK
+
+#define    RTL8367C_INGRESSBW_PORT_RATE_LSB_BASE                RTL8367C_REG_INGRESSBW_PORT0_RATE_CTRL0
+#define    RTL8367C_INGRESSBW_PORT_RATE_LSB_REG(port)            (RTL8367C_INGRESSBW_PORT_RATE_LSB_BASE + (port << 5))
+
+#define    RTL8367C_PORT_SMALL_IPG_REG(port)                    (RTL8367C_REG_PORT0_MISC_CFG + (port*0x20))
+
+#define    RTL8367C_PORT_EEE_CFG_BASE                           RTL8367C_REG_PORT0_EEECFG
+#define    RTL8367C_PORT_EEE_CFG_REG(port)                      (RTL8367C_REG_PORT0_EEECFG + (port << 5))
+#define    RTL8367C_PORT_EEE_100M_OFFSET                        RTL8367C_PORT0_EEECFG_EEE_100M_OFFSET
+#define    RTL8367C_PORT_EEE_100M_MASK                          RTL8367C_PORT0_EEECFG_EEE_100M_MASK
+#define    RTL8367C_PORT_EEE_GIGA_OFFSET                        RTL8367C_PORT0_EEECFG_EEE_GIGA_500M_OFFSET
+#define    RTL8367C_PORT_EEE_GIGA_MASK                          RTL8367C_PORT0_EEECFG_EEE_GIGA_500M_MASK
+
+
+/* (16'h0200) outq_reg */
+
+#define    RTL8367C_FLOWCTRL_QUEUE_DROP_ON_BASE                    RTL8367C_REG_FLOWCTRL_QUEUE0_DROP_ON
+#define    RTL8367C_FLOWCTRL_QUEUE_DROP_ON_REG(queue)            (RTL8367C_FLOWCTRL_QUEUE_DROP_ON_BASE + queue)
+#define    RTL8367C_FLOWCTRL_QUEUE_DROP_ON_MASK                    RTL8367C_FLOWCTRL_QUEUE0_DROP_ON_MASK
+
+#define    RTL8367C_FLOWCTRL_PORT_DROP_ON_BASE                    RTL8367C_REG_FLOWCTRL_PORT0_DROP_ON
+#define    RTL8367C_FLOWCTRL_PORT_DROP_ON_REG(PORT)                (RTL8367C_FLOWCTRL_PORT_DROP_ON_BASE + PORT)
+#define    RTL8367C_FLOWCTRL_PORT_DROP_ON_MASK                    RTL8367C_FLOWCTRL_PORT0_DROP_ON_MASK
+
+#define    RTL8367C_FLOWCTRL_PORT_GAP_REG                        RTL8367C_REG_FLOWCTRL_PORT_GAP
+#define    RTL8367C_FLOWCTRL_QUEUE_GAP_REG                        RTL8367C_REG_FLOWCTRL_QUEUE_GAP
+#define    RTL8367C_FLOWCTRL_PORT_QEMPTY_REG                    RTL8367C_REG_PORT_QEMPTY
+
+/* (16'h0300) sch_reg */
+
+#define    RTL8367C_SCHEDULE_WFQ_BURST_SIZE_REG                    RTL8367C_REG_SCHEDULE_WFQ_BURST_SIZE
+
+#define    RTL8367C_SCHEDULE_QUEUE_TYPE_BASE                    RTL8367C_REG_SCHEDULE_QUEUE_TYPE_CTRL0
+#define    RTL8367C_SCHEDULE_QUEUE_TYPE_REG(port)                (RTL8367C_SCHEDULE_QUEUE_TYPE_BASE + (port >> 1))
+#define    RTL8367C_SCHEDULE_QUEUE_TYPE_OFFSET(port, queue)        (((port & 0x1) << 3) + queue)
+#define    RTL8367C_SCHEDULE_QUEUE_TYPE_MASK(port, queue)         RTL8367C_SCHEDULE_QUEUE_TYPE_OFFSET(port, queue)
+
+#define    RTL8367C_SCHEDULE_PORT_QUEUE_WFQ_WEIGHT_BASE            RTL8367C_REG_SCHEDULE_PORT0_QUEUE0_WFQ_WEIGHT
+#define    RTL8367C_SCHEDULE_PORT_QUEUE_WFQ_WEIGHT_REG(port, queue)    (RTL8367C_SCHEDULE_PORT_QUEUE_WFQ_WEIGHT_BASE + (port << 3) + queue)
+
+#define    RTL8367C_SCHEDULE_APR_CTRL_REG                       RTL8367C_REG_SCHEDULE_APR_CTRL0
+#define    RTL8367C_SCHEDULE_APR_CTRL_OFFSET(port)                (port)
+#define    RTL8367C_SCHEDULE_APR_CTRL_MASK(port)                (1 << RTL8367C_SCHEDULE_APR_CTRL_OFFSET(port))
+
+#define    RTL8367C_SCHEDULE_PORT_APR_METER_BASE                RTL8367C_REG_SCHEDULE_PORT0_APR_METER_CTRL0
+#define    RTL8367C_SCHEDULE_PORT_APR_METER_REG(port, queue)    (RTL8367C_SCHEDULE_PORT_APR_METER_BASE + (port << 2) + (queue / 5))
+#define    RTL8367C_SCHEDULE_PORT_APR_METER_OFFSET(queue)        (3 * (queue % 5))
+#define    RTL8367C_SCHEDULE_PORT_APR_METER_MASK(queue)            (RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL0_QUEUE0_APR_METER_MASK << RTL8367C_SCHEDULE_PORT_APR_METER_OFFSET(queue))
+
+#define    RTL8367C_PORT_EGRESSBW_LSB_BASE                        RTL8367C_REG_PORT0_EGRESSBW_CTRL0
+#define    RTL8367C_PORT_EGRESSBW_LSB_REG(port)                    (RTL8367C_PORT_EGRESSBW_LSB_BASE + (port << 1))
+
+#define    RTL8367C_PORT_EGRESSBW_MSB_BASE                        RTL8367C_REG_PORT0_EGRESSBW_CTRL1
+#define    RTL8367C_PORT_EGRESSBW_MSB_REG(port)                    (RTL8367C_PORT_EGRESSBW_MSB_BASE + (port << 1))
+
+/* (16'h0500) table_reg */
+
+#define    RTL8367C_TABLE_ACCESS_CTRL_REG                        RTL8367C_REG_TABLE_ACCESS_CTRL
+
+#define    RTL8367C_TABLE_ACCESS_ADDR_REG                        RTL8367C_REG_TABLE_ACCESS_ADDR
+
+#define    RTL8367C_TABLE_ACCESS_STATUS_REG                        RTL8367C_REG_TABLE_LUT_ADDR
+
+#define    RTL8367C_TABLE_ACCESS_WRDATA_BASE                    RTL8367C_REG_TABLE_WRITE_DATA0
+#define    RTL8367C_TABLE_ACCESS_WRDATA_REG(index)                (RTL8367C_TABLE_ACCESS_WRDATA_BASE + index)
+
+#define    RTL8367C_TABLE_ACCESS_RDDATA_BASE                    RTL8367C_REG_TABLE_READ_DATA0
+#define    RTL8367C_TABLE_ACCESS_RDDATA_REG(index)                (RTL8367C_TABLE_ACCESS_RDDATA_BASE + index)
+
+
+
+/* (16'h0600) acl_reg */
+
+#define    RTL8367C_ACL_RULE_TEMPLATE_CTRL_BASE                    RTL8367C_REG_ACL_RULE_TEMPLATE0_CTRL0
+#define    RTL8367C_ACL_RULE_TEMPLATE_CTRL_REG(template)        (RTL8367C_ACL_RULE_TEMPLATE_CTRL_BASE + template * 0x4)
+#define    RTL8367C_ACL_TEMPLATE_FIELD_OFFSET(field)            ((field & 0x01) <<3)
+#define    RTL8367C_ACL_TEMPLATE_FIELD_MASK(field)                (0x3F << RTL8367C_ACL_TEMPLATE_FIELD_OFFSET(field))
+
+#define    RTL8367C_ACL_ACTION_CTRL_BASE                        RTL8367C_REG_ACL_ACTION_CTRL0
+#define    RTL8367C_ACL_ACTION_CTRL_REG(rule)                   (RTL8367C_ACL_ACTION_CTRL_BASE + (rule >> 1))
+#define    RTL8367C_ACL_ACTION_CTRL2_BASE                        RTL8367C_REG_ACL_ACTION_CTRL32
+#define    RTL8367C_ACL_ACTION_CTRL2_REG(rule)                  (RTL8367C_ACL_ACTION_CTRL2_BASE + ((rule-64) >> 1))
+
+#define    RTL8367C_ACL_OP_NOT_OFFSET(rule)                        (6 + ((rule & 0x1) << 3))
+#define    RTL8367C_ACL_OP_NOT_MASK(rule)                        (1 << RTL8367C_ACL_OP_NOT_OFFSET(rule))
+#define    RTL8367C_ACL_OP_ACTION_OFFSET(rule)                    ((rule & 0x1) << 3)
+#define    RTL8367C_ACL_OP_ACTION_MASK(rule)                    (0x3F << RTL8367C_ACL_OP_ACTION_OFFSET(rule))
+
+#define    RTL8367C_ACL_ENABLE_REG                                RTL8367C_REG_ACL_ENABLE
+#define    RTL8367C_ACL_UNMATCH_PERMIT_REG                        RTL8367C_REG_ACL_UNMATCH_PERMIT
+
+/* (16'h0700) cvlan_reg */
+
+#define    RTL8367C_VLAN_PVID_CTRL_BASE                            RTL8367C_REG_VLAN_PVID_CTRL0
+#define    RTL8367C_VLAN_PVID_CTRL_REG(port)                    (RTL8367C_VLAN_PVID_CTRL_BASE + (port >> 1))
+#define    RTL8367C_PORT_VIDX_OFFSET(port)                        ((port &1)<<3)
+#define    RTL8367C_PORT_VIDX_MASK(port)                        (RTL8367C_PORT0_VIDX_MASK << RTL8367C_PORT_VIDX_OFFSET(port))
+
+#define    RTL8367C_VLAN_PPB_VALID_BASE                            RTL8367C_REG_VLAN_PPB0_VALID
+#define    RTL8367C_VLAN_PPB_VALID_REG(item)                    (RTL8367C_VLAN_PPB_VALID_BASE + (item << 3))
+
+#define    RTL8367C_VLAN_PPB_CTRL_BASE                            RTL8367C_REG_VLAN_PPB0_CTRL0
+#define    RTL8367C_VLAN_PPB_CTRL_REG(item, port)               (RTL8367C_VLAN_PPB_CTRL_BASE + (item << 3) + (port / 3) )
+#define    RTL8367C_VLAN_PPB_CTRL_OFFSET(port)                    ((port % 3) * 5)
+#define    RTL8367C_VLAN_PPB_CTRL_MASK(port)                    (RTL8367C_VLAN_PPB0_CTRL0_PORT0_INDEX_MASK << RTL8367C_VLAN_PPB_CTRL_OFFSET(port))
+
+#define    RTL8367C_VLAN_PPB_FRAMETYPE_BASE                    RTL8367C_REG_VLAN_PPB0_CTRL2
+#define    RTL8367C_VLAN_PPB_FRAMETYPE_REG(item)               (RTL8367C_VLAN_PPB_FRAMETYPE_BASE + (item << 3))
+#define    RTL8367C_VLAN_PPB_FRAMETYPE_MASK                    RTL8367C_VLAN_PPB0_CTRL2_FRAME_TYPE_MASK
+
+#define    RTL8367C_VLAN_PPB_ETHERTYPR_BASE                        RTL8367C_REG_VLAN_PPB0_CTRL3
+#define    RTL8367C_VLAN_PPB_ETHERTYPR_REG(item)                (RTL8367C_VLAN_PPB_ETHERTYPR_BASE + (item << 3))
+
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION_BASE                RTL8367C_REG_VLAN_MEMBER_CONFIGURATION0_CTRL0
+
+
+#define    RTL8367C_VLAN_CTRL_REG                                RTL8367C_REG_VLAN_CTRL
+
+#define    RTL8367C_VLAN_INGRESS_REG                            RTL8367C_REG_VLAN_INGRESS
+
+#define    RTL8367C_VLAN_ACCEPT_FRAME_TYPE_BASE                    RTL8367C_REG_VLAN_ACCEPT_FRAME_TYPE_CTRL0
+#define    RTL8367C_VLAN_ACCEPT_FRAME_TYPE_REG(port)            (RTL8367C_VLAN_ACCEPT_FRAME_TYPE_BASE + (port >> 3))
+#define    RTL8367C_VLAN_ACCEPT_FRAME_TYPE_MASK(port)           (RTL8367C_PORT0_FRAME_TYPE_MASK << ((port & 0x7) << 1))
+
+#define    RTL8367C_PORT_EFID_BASE                                RTL8367C_REG_PORT_EFID_CTRL0
+#define    RTL8367C_PORT_EFID_REG(port)                            (RTL8367C_PORT_EFID_BASE + (port >> 2))
+#define    RTL8367C_PORT_EFID_OFFSET(port)                         ((port & 0x3) << 2)
+#define    RTL8367C_PORT_EFID_MASK(port)                        (RTL8367C_PORT0_EFID_MASK << RTL8367C_PORT_EFID_OFFSET(port))
+
+#define    RTL8367C_PORT_PBFIDEN_REG                            RTL8367C_REG_PORT_PBFIDEN
+
+#define    RTL8367C_PORT_PBFID_BASE                             RTL8367C_REG_PORT0_PBFID
+#define    RTL8367C_PORT_PBFID_REG(port)                        (RTL8367C_PORT_PBFID_BASE + port)
+
+/* (16'h0800) dpm_reg */
+
+#define    RTL8367C_RMA_CTRL_BASE                                RTL8367C_REG_RMA_CTRL00
+
+
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_BASE                RTL8367C_REG_VLAN_PORTBASED_PRIORITY_CTRL0
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_REG(port)            (RTL8367C_VLAN_PORTBASED_PRIORITY_BASE + (port >> 2))
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_OFFSET(port)        ((port & 0x3) << 2)
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_MASK(port)            (0x7 << RTL8367C_VLAN_PORTBASED_PRIORITY_OFFSET(port))
+
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM_BASE                    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM0_CTRL0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM_REG(port, item)        (RTL8367C_VLAN_PPB_PRIORITY_ITEM_BASE + (item << 2)+ (port>>2))
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM_OFFSET(port)            ((port & 0x3) <<2)
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM_MASK(port)            (RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL0_PORT0_PRIORITY_MASK << RTL8367C_VLAN_PPB_PRIORITY_ITEM_OFFSET(port))
+
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_BASE                RTL8367C_REG_QOS_1Q_PRIORITY_REMAPPING_CTRL0
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_REG(pri)            (RTL8367C_QOS_1Q_PRIORITY_REMAPPING_BASE + (pri >> 2))
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_OFFSET(pri)        ((pri & 0x3) << 2)
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_MASK(pri)            (0x7 << RTL8367C_QOS_1Q_PRIORITY_REMAPPING_OFFSET(pri))
+
+#define    RTL8367C_QOS_DSCP_TO_PRIORITY_BASE                    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL0
+#define    RTL8367C_QOS_DSCP_TO_PRIORITY_REG(dscp)                (RTL8367C_QOS_DSCP_TO_PRIORITY_BASE + (dscp >> 2))
+#define    RTL8367C_QOS_DSCP_TO_PRIORITY_OFFSET(dscp)            ((dscp & 0x3) << 2)
+#define    RTL8367C_QOS_DSCP_TO_PRIORITY_MASK(dscp)                (0x7 << RTL8367C_QOS_DSCP_TO_PRIORITY_OFFSET(dscp))
+
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_BASE                    RTL8367C_REG_QOS_PORTBASED_PRIORITY_CTRL0
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_REG(port)            (RTL8367C_QOS_PORTBASED_PRIORITY_BASE + (port >> 2))
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_OFFSET(port)            ((port & 0x3) << 2)
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_MASK(port)            (0x7 << RTL8367C_QOS_PORTBASED_PRIORITY_OFFSET(port))
+
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_BASE            RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION_CTRL0
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_REG(src)        (RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_BASE + (src >> 1))
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_OFFSET(src)  ((src & 1) << 3)
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_MASK(src)    (RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL0_QOS_PORT_WEIGHT_MASK << RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_OFFSET(src))
+
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_BASE            RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION2_CTRL0
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_REG(src)        (RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_BASE + (src >> 1))
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_OFFSET(src)  ((src & 1) << 3)
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_MASK(src)    (RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL0_QOS_PORT_WEIGHT_MASK << RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_OFFSET(src))
+
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_IDX_CTRL            RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION_IDX
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_IDX(port)  (1 << port)
+
+#define    RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_BASE            RTL8367C_REG_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL0
+#define    RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_REG(pri)        (RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_BASE + (pri >> 2))
+#define    RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_OFFSET(pri)  ((pri & 0x3) << 2)
+#define    RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_MASK(pri)    (RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL0_PRIORITY0_MASK << RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_OFFSET(pri))
+
+#define    RTL8367C_QOS_TRAP_PRIORITY_CTRL0_REG                RTL8367C_REG_QOS_TRAP_PRIORITY0
+
+#define    RTL8367C_QOS_TRAP_PRIORITY_CTRL1_REG                RTL8367C_REG_QOS_TRAP_PRIORITY1
+
+#define    RTL8367C_QOS_DSCP_TO_DSCP_BASE                             RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL0
+#define    RTL8367C_QOS_DSCP_TO_DSCP_REG(dscp)                     (RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL0 + (dscp >> 1))
+#define    RTL8367C_QOS_DSCP_TO_DSCP_OFFSET(dscp)                ((dscp & 0x1) << 8)
+#define    RTL8367C_QOS_DSCP_TO_DSCP_MASK(dscp)                   (0x3F << RTL8367C_QOS_DSCP_TO_DSCP_OFFSET(dscp))
+
+#define    RTL8367C_UNUCAST_FLOADING_PMSK_REG                    RTL8367C_REG_UNDA_FLOODING_PMSK
+
+#define    RTL8367C_UNMCAST_FLOADING_PMSK_REG                    RTL8367C_REG_UNMCAST_FLOADING_PMSK
+
+#define    RTL8367C_BCAST_FLOADING_PMSK_REG                        RTL8367C_REG_BCAST_FLOADING_PMSK
+
+#define    RTL8367C_PORT_ISOLATION_PORT_MASK_BASE                RTL8367C_REG_PORT_ISOLATION_PORT0_MASK
+#define    RTL8367C_PORT_ISOLATION_PORT_MASK_REG(port)            (RTL8367C_PORT_ISOLATION_PORT_MASK_BASE + port)
+
+#define    RTL8367C_FORCE_CTRL_REG                                RTL8367C_REG_FORCE_CTRL
+
+#define    RTL8367C_SOURCE_PORT_BLOCK_REG                        RTL8367C_REG_SOURCE_PORT_PERMIT
+
+#define    RTL8367C_IPMCAST_VLAN_LEAKY_REG                        RTL8367C_REG_IPMCAST_VLAN_LEAKY
+
+#define    RTL8367C_IPMCAST_PORTISO_LEAKY_REG                    RTL8367C_REG_IPMCAST_PORTISO_LEAKY
+
+#define    RTL8367C_PORT_SECURIT_CTRL_REG                        RTL8367C_REG_PORT_SECURITY_CTRL
+
+#define    RTL8367C_UNKNOWN_IPV4_MULTICAST_BASE                    RTL8367C_REG_UNKNOWN_IPV4_MULTICAST_CTRL0
+#define    RTL8367C_UNKNOWN_IPV4_MULTICAST_REG(port)            (RTL8367C_UNKNOWN_IPV4_MULTICAST_BASE + (port >> 3))
+#define    RTL8367C_UNKNOWN_IPV4_MULTICAST_OFFSET(port)            ((port & 0x7) << 1)
+#define    RTL8367C_UNKNOWN_IPV4_MULTICAST_MASK(port)            (RTL8367C_PORT0_UNKNOWN_IP4_MCAST_MASK << RTL8367C_UNKNOWN_IPV4_MULTICAST_OFFSET(port))
+
+#define    RTL8367C_UNKNOWN_IPV6_MULTICAST_BASE                    RTL8367C_REG_UNKNOWN_IPV6_MULTICAST_CTRL0
+#define    RTL8367C_UNKNOWN_IPV6_MULTICAST_REG(port)            (RTL8367C_UNKNOWN_IPV6_MULTICAST_BASE + (port >> 3))
+#define    RTL8367C_UNKNOWN_IPV6_MULTICAST_OFFSET(port)            ((port & 0x7) << 1)
+#define    RTL8367C_UNKNOWN_IPV6_MULTICAST_MASK(port)            (RTL8367C_PORT0_UNKNOWN_IP4_MCAST_MASK << RTL8367C_UNKNOWN_IPV6_MULTICAST_OFFSET(port))
+
+#define    RTL8367C_UNKNOWN_L2_MULTICAST_BASE                    RTL8367C_REG_UNKNOWN_L2_MULTICAST_CTRL0
+#define    RTL8367C_UNKNOWN_L2_MULTICAST_REG(port)                (RTL8367C_UNKNOWN_L2_MULTICAST_BASE + (port >> 3))
+#define    RTL8367C_UNKNOWN_L2_MULTICAST_OFFSET(port)            ((port & 0x7) << 1)
+#define    RTL8367C_UNKNOWN_L2_MULTICAST_MASK(port)                (RTL8367C_PORT0_UNKNOWN_L2_MCAST_MASK << RTL8367C_UNKNOWN_L2_MULTICAST_OFFSET(port))
+
+#define    RTL8367C_PORT_TRUNK_CTRL_REG                            RTL8367C_REG_PORT_TRUNK_CTRL
+#define    RTL8367C_PORT_TRUNK_HASH_MASK                           0x007F
+
+#define    RTL8367C_PORT_TRUNK_GROUP_MASK_REG    RTL8367C_REG_PORT_TRUNK_GROUP_MASK
+#define    RTL8367C_PORT_TRUNK_GROUP_MASK_OFFSET(group)    (group << 2)
+#define    RTL8367C_PORT_TRUNK_GROUP_MASK_MASK(group)    (RTL8367C_PORT_TRUNK_GROUP0_MASK_MASK << RTL8367C_PORT_TRUNK_GROUP_MASK_OFFSET(group))
+
+#define    RTL8367C_PORT_TRUNK_FLOWCTRL_REG                        RTL8367C_REG_PORT_TRUNK_FLOWCTRL
+
+#define    RTL8367C_QOS_PORT_QUEUE_NUMBER_BASE                    RTL8367C_REG_QOS_PORT_QUEUE_NUMBER_CTRL0
+#define    RTL8367C_QOS_PORT_QUEUE_NUMBER_REG(port)                (RTL8367C_QOS_PORT_QUEUE_NUMBER_BASE + (port >> 2))
+#define    RTL8367C_QOS_PORT_QUEUE_NUMBER_OFFSET(port)            ((port & 0x3) << 2)
+#define    RTL8367C_QOS_PORT_QUEUE_NUMBER_MASK(port)            (0x7 << RTL8367C_QOS_PORT_QUEUE_NUMBER_OFFSET(port))
+
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_BASE                    RTL8367C_REG_QOS_1Q_PRIORITY_TO_QID_CTRL0
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_REG(index, pri)        (RTL8367C_QOS_1Q_PRIORITY_TO_QID_BASE + (index << 1) + (pri >> 2))
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_OFFSET(pri)            ((pri & 0x3) << 2)
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_MASK(pri)            (RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_MASK << RTL8367C_QOS_1Q_PRIORITY_TO_QID_OFFSET(pri))
+
+#define    RTL8367C_DEBUG_INFO_BASE                                RTL8367C_REG_PORT_DEBUG_INFO_CTRL0
+#define    RTL8367C_DEBUG_INFO_REG(port)                        (RTL8367C_DEBUG_INFO_BASE + (port >>1))
+#define    RTL8367C_DEBUG_INFO_OFFSET(port)                        ((port&1)<<3)
+#define    RTL8367C_DEBUG_INFO_MASK(port)                        (RTL8367C_PORT0_DEBUG_INFO_MASK << RTL8367C_DEBUG_INFO_OFFSET(port))
+
+/* (16'h0a00) l2_reg */
+
+#define    RTL8367C_VLAN_MSTI_BASE                                RTL8367C_REG_VLAN_MSTI0_CTRL0
+#define    RTL8367C_VLAN_MSTI_REG(tree, port)                    (RTL8367C_VLAN_MSTI_BASE + (tree << 1) + (port >> 3))
+#define    RTL8367C_VLAN_MSTI_OFFSET(port)                        ((port & 0x7) << 1)
+#define    RTL8367C_VLAN_MSTI_MASK(port)                        (RTL8367C_VLAN_MSTI0_CTRL0_PORT0_STATE_MASK << RTL8367C_VLAN_MSTI_OFFSET(port))
+
+#define    RTL8367C_LUT_PORT_LEARN_LIMITNO_BASE                    RTL8367C_REG_LUT_PORT0_LEARN_LIMITNO
+#define    RTL8367C_LUT_PORT_LEARN_LIMITNO_REG(port)            (RTL8367C_LUT_PORT_LEARN_LIMITNO_BASE + port)
+
+#define    RTL8367C_LUT_CFG_REG                                    RTL8367C_REG_LUT_CFG
+
+#define    RTL8367C_LUT_AGEOUT_CTRL_REG                            RTL8367C_REG_LUT_AGEOUT_CTRL
+
+#define    RTL8367C_FORCE_FLUSH_REG                                RTL8367C_REG_FORCE_FLUSH
+
+#define    RTL8367C_STORM_BCAST_REG                                RTL8367C_REG_STORM_BCAST
+
+#define    RTL8367C_STORM_MCAST_REG                                RTL8367C_REG_STORM_MCAST
+
+#define    RTL8367C_STORM_UNKNOWN_UCAST_REG                        RTL8367C_REG_STORM_UNKOWN_UCAST
+
+#define    RTL8367C_STORM_UNKNOWN_MCAST_REG                        RTL8367C_REG_STORM_UNKOWN_MCAST
+
+#define    RTL8367C_STORM_BCAST_METER_CTRL_BASE                    RTL8367C_REG_STORM_BCAST_METER_CTRL0
+#define    RTL8367C_STORM_BCAST_METER_CTRL_REG(port)            (RTL8367C_STORM_BCAST_METER_CTRL_BASE + (port >> 1))
+#define    RTL8367C_STORM_BCAST_METER_CTRL_OFFSET(port)            ((port & 0x1) << 3)
+#define    RTL8367C_STORM_BCAST_METER_CTRL_MASK(port)            (0xFF << RTL8367C_STORM_BCAST_METER_CTRL_OFFSET(port))
+
+#define    RTL8367C_STORM_MCAST_METER_CTRL_BASE                    RTL8367C_REG_STORM_MCAST_METER_CTRL0
+#define    RTL8367C_STORM_MCAST_METER_CTRL_REG(port)            (RTL8367C_STORM_MCAST_METER_CTRL_BASE + (port >> 1))
+#define    RTL8367C_STORM_MCAST_METER_CTRL_OFFSET(port)            ((port & 0x1) << 3)
+#define    RTL8367C_STORM_MCAST_METER_CTRL_MASK(port)            (0xFF << RTL8367C_STORM_MCAST_METER_CTRL_OFFSET(port))
+
+#define    RTL8367C_STORM_UNDA_METER_CTRL_BASE                    RTL8367C_REG_STORM_UNDA_METER_CTRL0
+#define    RTL8367C_STORM_UNDA_METER_CTRL_REG(port)                (RTL8367C_STORM_UNDA_METER_CTRL_BASE + (port >> 1))
+#define    RTL8367C_STORM_UNDA_METER_CTRL_OFFSET(port)            ((port & 0x1) << 3)
+#define    RTL8367C_STORM_UNDA_METER_CTRL_MASK(port)            (0xFF << RTL8367C_STORM_UNDA_METER_CTRL_OFFSET(port))
+
+#define    RTL8367C_STORM_UNMC_METER_CTRL_BASE                    RTL8367C_REG_STORM_UNMC_METER_CTRL0
+#define    RTL8367C_STORM_UNMC_METER_CTRL_REG(port)                (RTL8367C_STORM_UNMC_METER_CTRL_BASE + (port >> 1))
+#define    RTL8367C_STORM_UNMC_METER_CTRL_OFFSET(port)            ((port & 0x1) << 3)
+#define    RTL8367C_STORM_UNMC_METER_CTRL_MASK(port)            (0xFF << RTL8367C_STORM_UNMC_METER_CTRL_OFFSET(port))
+
+#define    RTL8367C_OAM_PARSER_OFFSET(port)                        (port*2)
+#define    RTL8367C_OAM_PARSER_MASK(port)                        (RTL8367C_PORT0_PARACT_MASK << RTL8367C_OAM_PARSER_OFFSET(port))
+
+#define    RTL8367C_OAM_MULTIPLEXER_OFFSET(port)                (port*2)
+#define    RTL8367C_OAM_MULTIPLEXER_MASK(port)                    (RTL8367C_PORT0_PARACT_MASK << RTL8367C_OAM_MULTIPLEXER_OFFSET(port))
+
+#define    RTL8367C_OAM_CTRL_REG                                RTL8367C_REG_OAM_CTRL
+
+#define    RTL8367C_DOT1X_PORT_ENABLE_REG                        RTL8367C_REG_DOT1X_PORT_ENABLE
+
+#define    RTL8367C_DOT1X_MAC_ENABLE_REG                        RTL8367C_REG_DOT1X_MAC_ENABLE
+
+#define    RTL8367C_DOT1X_PORT_AUTH_REG                            RTL8367C_REG_DOT1X_PORT_AUTH
+
+#define    RTL8367C_DOT1X_PORT_OPDIR_REG                        RTL8367C_REG_DOT1X_PORT_OPDIR
+
+#define    RTL8367C_DOT1X_UNAUTH_ACT_BASE                        RTL8367C_REG_DOT1X_UNAUTH_ACT_W0
+#define    RTL8367C_DOT1X_UNAUTH_ACT_OFFSET(port)                ((port & 0x7) << 1)
+#define    RTL8367C_DOT1X_UNAUTH_ACT_MASK(port)                    (RTL8367C_DOT1X_PORT0_UNAUTHBH_MASK << RTL8367C_DOT1X_UNAUTH_ACT_OFFSET(port))
+
+#define    RTL8367C_DOT1X_CFG_REG                                RTL8367C_REG_DOT1X_CFG
+
+#define    RTL8367C_REG_L2_LRN_CNT_BASE                            RTL8367C_REG_L2_LRN_CNT_CTRL0
+#define    RTL8367C_REG_L2_LRN_CNT_REG(port)                    (RTL8367C_REG_L2_LRN_CNT_BASE + port)
+
+/* (16'h0b00) mltvlan_reg */
+
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY_BASE_REG(index)        (RTL8367C_REG_SVLAN_MCAST2S_ENTRY0_CTRL0 + index*5)
+
+/* (16'h0c00) svlan_reg */
+
+#define    RTL8367C_SVLAN_MEMBERCFG_BASE_REG(index)                (RTL8367C_REG_SVLAN_MEMBERCFG0_CTRL1 + index*3)
+#define    RTL8367C_SVLAN_C2SCFG_BASE_REG(index)                  (RTL8367C_REG_SVLAN_C2SCFG0_CTRL0+ index*3)
+#define    RTL8367C_SVLAN_CFG_REG                                RTL8367C_REG_SVLAN_CFG
+
+/* (16'h0f00) hsactrl_reg */
+
+#define    RTL8367C_SVLAN_S2C_ENTRY_BASE_REG(index)                (RTL8367C_REG_SVLAN_SP2C_ENTRY0_CTRL0 + index*2)
+
+/* (16'h1000) mib_reg */
+
+#define    RTL8367C_MIB_COUNTER_BASE_REG                        RTL8367C_REG_MIB_COUNTER0
+
+#define    RTL8367C_MIB_ADDRESS_REG                                RTL8367C_REG_MIB_ADDRESS
+
+#define    RTL8367C_MIB_CTRL_REG                                RTL8367C_REG_MIB_CTRL0
+#define    RTL8367C_MIB_PORT07_MASK                                (0xFF<<RTL8367C_PORT0_RESET_OFFSET)
+
+/* (16'h1100) intrpt_reg */
+
+#define    RTL8367C_INTR_CTRL_REG                                RTL8367C_REG_INTR_CTRL
+
+#define    RTL8367C_INTR_IMR_REG                                RTL8367C_REG_INTR_IMR
+
+#define    RTL8367C_INTR_IMS_REG                                RTL8367C_REG_INTR_IMS
+
+#define    RTL8367C_INTR_INDICATOR_BASED                        RTL8367C_REG_LEARN_OVER_INDICATOR
+#define    RTL8367C_LEARN_OVER_INDICATOR_REG                    RTL8367C_REG_LEARN_OVER_INDICATOR
+
+#define    RTL8367C_SPEED_CHANGE_INDICATOR_REG                    RTL8367C_REG_SPEED_CHANGE_INDICATOR
+
+#define    RTL8367C_PORT_LINKDOWN_INDICATOR_REG                    RTL8367C_REG_PORT_LINKDOWN_INDICATOR
+
+#define    RTL8367C_PORT_LINKUP_INDICATOR_REG                    RTL8367C_REG_PORT_LINKUP_INDICATOR
+
+#define    RTL8367C_REG_METER_EXCEED_INDICATOR_BASE                RTL8367C_REG_METER_EXCEED_INDICATOR0
+#define    RTL8367C_REG_METER_EXCEED_INDICATOR_REG(meter)        (RTL8367C_REG_METER_EXCEED_INDICATOR_BASE + (meter >> 4))
+#define    RTL8367C_REG_METER_EXCEED_INDICATOR_OFFSET(meter)    (meter & 0xF)
+
+/* (16'h1200) swcore_reg */
+
+#define    RTL8367C_VS_TPID_REG                                    RTL8367C_REG_VS_TPID
+
+#define    RTL8367C_SWITCH_MAC_BASE                                RTL8367C_REG_SWITCH_MAC0
+
+#define    RTL8367C_REMARKING_CTRL_REG                            RTL8367C_REG_SWITCH_CTRL0
+
+#define    RTL8367C_QOS_DSCP_REMARK_BASE                        RTL8367C_REG_QOS_DSCP_REMARK_CTRL0
+#define    RTL8367C_QOS_DSCP_REMARK_REG(pri)                    (RTL8367C_QOS_DSCP_REMARK_BASE + (pri >> 1))
+#define    RTL8367C_QOS_DSCP_REMARK_OFFSET(pri)                    (((pri) & 0x1) << 3)
+#define    RTL8367C_QOS_DSCP_REMARK_MASK(pri)                    (0x3F << RTL8367C_QOS_DSCP_REMARK_OFFSET(pri))
+
+#define    RTL8367C_QOS_1Q_REMARK_BASE                            RTL8367C_REG_QOS_1Q_REMARK_CTRL0
+#define    RTL8367C_QOS_1Q_REMARK_REG(pri)                        (RTL8367C_QOS_1Q_REMARK_BASE + (pri >> 2))
+#define    RTL8367C_QOS_1Q_REMARK_OFFSET(pri)                    ((pri & 0x3) << 2)
+#define    RTL8367C_QOS_1Q_REMARK_MASK(pri)                        (0x7 << RTL8367C_QOS_1Q_REMARK_OFFSET(pri))
+
+#define    RTL8367C_PTKGEN_PAYLOAD_CTRL0_REG                    RTL8367C_REG_PTKGEN_PAYLOAD_CTRL0
+
+#define    RTL8367C_PTKGEN_PAYLOAD_CTRL1_REG                    RTL8367C_REG_PTKGEN_PAYLOAD_CTRL1
+
+#define    RTL8367C_SVLAN_UPLINK_PORTMASK_REG                    RTL8367C_REG_SVLAN_UPLINK_PORTMASK
+
+#define    RTL8367C_CPU_PORT_MASK_REG                            RTL8367C_REG_CPU_PORT_MASK
+
+#define    RTL8367C_CPU_CTRL_REG                                RTL8367C_REG_CPU_CTRL
+
+#define    RTL8367C_MIRROR_CTRL_REG                                RTL8367C_REG_MIRROR_CTRL
+
+
+#define    RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_BASE            RTL8367C_REG_FLOWCRTL_EGRESS_QUEUE_ENABLE_CTRL0
+#define    RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG(port)        (RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_BASE + (port >> 1))
+#define    RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG_OFFSET(port)    ((port & 0x1) << 3)
+#define    RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG_MASK(port)    (RTL8367C_PORT0_QUEUE_MASK_MASK << RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG_OFFSET(port))
+
+
+#define    RTL8367C_FLOWCTRL_PORT_PAGE_COUNTER_BASE                RTL8367C_REG_FLOWCTRL_PORT0_PAGE_COUNTER
+#define    RTL8367C_FLOWCTRL_PORT_PAGE_COUNTER_REG(port)        (RTL8367C_FLOWCTRL_PORT_PAGE_COUNTER_BASE + port)
+#define    RTL8367C_FLOWCTRL_PORT_PAGE_COUNTER_MASK                RTL8367C_FLOWCTRL_PORT0_PAGE_COUNTER_MASK
+
+#define    RTL8367C_FLOWCTRL_PORT_PAGE_MAX_BASE                    RTL8367C_REG_FLOWCTRL_PORT0_PAGE_MAX
+#define    RTL8367C_FLOWCTRL_PORT_PAGE_MAX_REG(port)            (RTL8367C_FLOWCTRL_PORT_PAGE_MAX_BASE + port)
+#define    RTL8367C_FLOWCTRL_PORT_PAGE_MAX_MASK                    RTL8367C_FLOWCTRL_PORT0_PAGE_MAX_MASK
+
+#define    RTL8367C_FIELD_SELECTOR_REG(index)                    (RTL8367C_REG_FIELD_SELECTOR0 + index)
+#define    RTL8367C_FIELD_SELECTOR_ENABLE_OFFSET                 RTL8367C_FIELD_SELECTOR0_ENABLE_OFFSET
+#define    RTL8367C_FIELD_SELECTOR_ENABLE_MASK                    RTL8367C_FIELD_SELECTOR0_ENABLE_MASK
+#define    RTL8367C_FIELD_SELECTOR_FORMAT_OFFSET                RTL8367C_FIELD_SELECTOR0_FORMAT_OFFSET
+#define    RTL8367C_FIELD_SELECTOR_FORMAT_MASK                    RTL8367C_FIELD_SELECTOR0_FORMAT_MASK
+#define    RTL8367C_FIELD_SELECTOR_OFFSET_OFFSET                  RTL8367C_FIELD_SELECTOR0_OFFSET_OFFSET
+#define    RTL8367C_FIELD_SELECTOR_OFFSET_MASK                    RTL8367C_FIELD_SELECTOR0_OFFSET_MASK
+
+/* (16'h1300) chip_reg*/
+
+/* (16'h1400) mtrpool_reg */
+#define    RTL8367C_METER_RATE_BASE                                RTL8367C_REG_METER0_RATE_CTRL0
+#define    RTL8367C_METER_RATE_REG(meter)                        ((meter << 1) + RTL8367C_METER_RATE_BASE)
+
+#define    RTL8367C_METER_BUCKET_SIZE_BASE                        RTL8367C_REG_METER0_BUCKET_SIZE
+#define    RTL8367C_METER_BUCKET_SIZE_REG(meter)                (RTL8367C_METER_BUCKET_SIZE_BASE + meter)
+
+#define    RTL8367C_LEAKY_BUCKET_TICK_REG                        RTL8367C_REG_METER_CTRL0
+#define    RTL8367C_LEAKY_BUCKET_TICK_OFFSET                    RTL8367C_METER_TICK_OFFSET
+#define    RTL8367C_LEAKY_BUCKET_TICK_MASK                        RTL8367C_METER_TICK_MASK
+
+#define    RTL8367C_LEAKY_BUCKET_TOKEN_REG                        RTL8367C_REG_METER_CTRL1
+#define    RTL8367C_LEAKY_BUCKET_TOKEN_OFFSET                    RTL8367C_METER_CTRL1_OFFSET
+#define    RTL8367C_LEAKY_BUCKET_TOKEN_MASK                        RTL8367C_METER_CTRL1_MASK
+
+#define    RTL8367C_METER_OVERRATE_INDICATOR_BASE                RTL8367C_REG_METER_OVERRATE_INDICATOR0
+#define    RTL8367C_METER_OVERRATE_INDICATOR_REG(meter)            (RTL8367C_METER_OVERRATE_INDICATOR_BASE + (meter >> 4))
+#define    RTL8367C_METER_EXCEED_OFFSET(meter)                    (meter & 0xF)
+#define    RTL8367C_METER_EXCEED_MASK(meter)                    (1 << RTL8367C_METER_EXCEED_OFFSET(meter))
+
+#define    RTL8367C_METER_IFG_CTRL_BASE                            RTL8367C_REG_METER_IFG_CTRL0
+#define    RTL8367C_METER_IFG_CTRL_REG(meter)                    (RTL8367C_METER_IFG_CTRL_BASE + (meter >> 4))
+#define    RTL8367C_METER_IFG_OFFSET(meter)                        (meter & 0xF)
+#define    RTL8367C_METER_IFG_MASK(meter)                        (1 << RTL8367C_METER_IFG_OFFSET(meter))
+
+#define    RTL8367C_FLOWCTRL_CTRL_REG                            RTL8367C_REG_FLOWCTRL_CTRL0
+
+/* (16'h1800)8051_RLDP_EEE_reg */
+#define    RTL8367C_EEELLDP_CTRL0_REG                            RTL8367C_REG_EEELLDP_CTRL0
+
+#define    RTL8367C_EEELLDP_CTRL1_REG                            RTL8367C_REG_EEELLDP_CTRL1
+
+#define    RTL8367C_EEELLDP_PMSK_REG                            RTL8367C_REG_EEELLDP_PMSK
+
+#define    RTL8367C_EEELLDP_TX_FRAMEU_REG_BASE                    RTL8367C_REG_EEELLDP_FRAMEU00
+
+#define    RTL8367C_EEELLDP_TX_CAP_FRAMEL_REG_BASE                RTL8367C_REG_EEELLDP_CAP_FRAMEL00
+
+#define    RTL8367C_EEELLDP_RX_VALUE_PORT_BASE                    RTL8367C_REG_EEELLDP_RX_VALUE_P00_00
+#define    RTL8367C_EEELLDP_RX_VALUE_PORT_REG(port)                (RTL8367C_EEELLDP_RX_VALUE_PORT_BASE + (port * 9))
+
+#define    RTL8367C_RLDP_CTRL0_REG                                RTL8367C_REG_RLDP_CTRL0
+#define    RTL8367C_RLDP_MODE_OFFSET    14
+
+#define    RTL8367C_RLDP_RETRY_COUNT_REG                        RTL8367C_REG_RLDP_CTRL1
+
+#define    RTL8367C_RLDP_RETRY_PERIOD_LOOPSTATE_REG                RTL8367C_REG_RLDP_CTRL2
+
+#define    RTL8367C_RLDP_RETRY_PERIOD_CHKSTATE_REG                RTL8367C_REG_RLDP_CTRL3
+
+#define    RTL8367C_RLDP_TX_PMSK_REG                            RTL8367C_REG_RLDP_CTRL4
+
+#define    RTL8367C_RLDP_RAND_NUM_REG_BASE                        RTL8367C_REG_RLDP_RAND_NUM0
+
+#define    RTL8367C_RLDP_MAGIC_NUM_REG_BASE                        RTL8367C_REG_RLDP_MAGIC_NUM0
+
+#define    RTL8367C_RLDP_LOOP_PMSK_REG                            RTL8367C_REG_RLDP_LOOPSTATUS_INDICATOR
+
+#define    RTL8367C_RLDP_LOOP_PORT_BASE                            RTL8367C_REG_RLDP_LOOP_PORT_REG0
+#define    RTL8367C_RLDP_LOOP_PORT_REG(port)                    (RTL8367C_RLDP_LOOP_PORT_BASE + (port >> 1))
+#define    RTL8367C_RLDP_LOOP_PORT_OFFSET(port)                    ((port & 0x1) << 3)
+#define    RTL8367C_RLDP_LOOP_PORT_MASK(port)                    (RTL8367C_RLDP_LOOP_PORT_00_MASK << RTL8367C_RLDP_LOOP_PORT_OFFSET(port))
+
+#define    RTL8367C_PAGEMETER_PORT_BASE                            RTL8367C_REG_PAGEMETER_PORT0_CTRL0
+#define    RTL8367C_PAGEMETER_PORT_REG(port)                    (RTL8367C_PAGEMETER_PORT_BASE + 0x20*port)
+
+#define    RTL8367C_HIGHPRI_INDICATOR_REG                        RTL8367C_REG_HIGHPRI_INDICATOR
+#define    RTL8367C_PORT_INDICATOR_OFFSET(port)                    (port)
+#define    RTL8367C_PORT_INDICATOR_MASK(port)                    (RTL8367C_PORT0_INDICATOR_MASK << RTL8367C_PORT_INDICATOR_OFFSET(port))
+
+#define    RTL8367C_HIGHPRI_CFG_REG                                RTL8367C_REG_HIGHPRI_CFG
+
+#define    RTL8367C_EAV_PRIORITY_REMAPPING_BASE                    RTL8367C_REG_EAV_CTRL1
+#define    RTL8367C_EAV_PRIORITY_REMAPPING_REG(pri)                (RTL8367C_EAV_PRIORITY_REMAPPING_BASE + (pri >> 2))
+#define    RTL8367C_EAV_PRIORITY_REMAPPING_OFFSET(pri)            ((pri & 0x3) * RTL8367C_REMAP_EAV_PRI1_REGEN_OFFSET)
+#define    RTL8367C_EAV_PRIORITY_REMAPPING_MASK(pri)            (RTL8367C_REMAP_EAV_PRI0_REGEN_MASK << RTL8367C_EAV_PRIORITY_REMAPPING_OFFSET(pri))
+
+#define    RTL8367C_EEEP_CFG_BASE                                RTL8367C_REG_PORT0_EEECFG
+#define    RTL8367C_EEEP_CFG_REG(port)                            (RTL8367C_EEEP_CFG_BASE + (port*0x20))
+
+#define    RTL8367C_PKG_CFG_BASE                                RTL8367C_REG_PKTGEN_PORT0_CTRL
+#define    RTL8367C_PKG_CFG_REG(port)                            (RTL8367C_PKG_CFG_BASE + (port*0x20))
+
+#define    RTL8367C_PKG_DA_BASE                                    RTL8367C_REG_PKTGEN_PORT0_DA0
+#define    RTL8367C_PKG_DA_REG(port)                            (RTL8367C_PKG_DA_BASE + (port*0x20))
+
+#define    RTL8367C_PKG_SA_BASE                                    RTL8367C_REG_PKTGEN_PORT0_SA0
+#define    RTL8367C_PKG_SA_REG(port)                            (RTL8367C_PKG_SA_BASE + (port*0x20))
+
+#define    RTL8367C_PKG_NUM_BASE                                RTL8367C_REG_PKTGEN_PORT0_COUNTER0
+#define    RTL8367C_PKG_NUM_REG(port)                            (RTL8367C_PKG_NUM_BASE + (port*0x20))
+
+#define    RTL8367C_PKG_LENGTH_BASE                                RTL8367C_REG_PKTGEN_PORT0_TX_LENGTH
+#define    RTL8367C_PKG_LENGTH_REG(port)                        (RTL8367C_PKG_LENGTH_BASE + (port*0x20))
+
+/* (16'h1c00)IGMP_MLD_reg */
+#define    RTL8367C_IGMP_GROUP_USAGE_BASE                       RTL8367C_REG_IGMP_GROUP_USAGE_LIST0
+#define    RTL8367C_IGMP_GROUP_USAGE_REG(idx)                   (RTL8367C_IGMP_GROUP_USAGE_BASE + (idx / 16))
+
+#define    RTL8367C_FALLBACK_BASE                               RTL8367C_REG_FALLBACK_PORT0_CFG0
+#define    RTL8367C_FALLBACK_PORT_CFG_REG(port)                 (RTL8367C_FALLBACK_BASE + (port * 4))
+#define    RTL8367C_FALLBACK_PORT_MON_CNT_REG(port)             (RTL8367C_FALLBACK_BASE + 1 + (port * 4))
+#define    RTL8367C_FALLBACK_PORT_ERR_CNT_REG(port)             (RTL8367C_FALLBACK_BASE + 3 + (port * 4))
+
+
+/* (16'h6400)timer_1588 */
+#define    RTL8367C_EAV_CFG_BASE                                              RTL8367C_REG_P0_EAV_CFG
+#define    RTL8367C_EAV_PORT_CFG_REG(port)                              (RTL8367C_EAV_CFG_BASE + (port *0x10))
+#define    RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET                 RTL8367C_P0_EAV_CFG_PTP_PHY_EN_EN_OFFSET
+#define    RTL8367C_EAV_CFG_RX_PDELAY_RESP_OFFSET                RTL8367C_P0_EAV_CFG_RX_PDELAY_RESP_OFFSET
+#define    RTL8367C_EAV_CFG_RX_PDELAY_REQ_OFFSET                 RTL8367C_P0_EAV_CFG_RX_PDELAY_REQ_OFFSET
+#define    RTL8367C_EAV_CFG_RX_DELAY_REQ_OFFSET                   RTL8367C_P0_EAV_CFG_RX_DELAY_REQ_OFFSET
+#define    RTL8367C_EAV_CFG_RX_SYNC_OFFSET                            RTL8367C_P0_EAV_CFG_RX_SYNC_OFFSET
+#define    RTL8367C_EAV_CFG_TX_PDELAY_RESP_OFFSET                RTL8367C_P0_EAV_CFG_TX_PDELAY_RESP_OFFSET
+#define    RTL8367C_EAV_CFG_TX_PDELAY_REQ_OFFSET                 RTL8367C_P0_EAV_CFG_TX_PDELAY_REQ_OFFSET
+#define    RTL8367C_EAV_CFG_TX_DELAY_REQ_OFFSET                   RTL8367C_P0_EAV_CFG_TX_DELAY_REQ_OFFSET
+#define    RTL8367C_EAV_CFG_TX_SYNC_OFFSET                            RTL8367C_P0_EAV_CFG_TX_SYNC_OFFSET
+
+#define    RTL8367C_REG_TX_SYNC_SEQ_ID_BASE                       RTL8367C_REG_P0_TX_SYNC_SEQ_ID
+#define    RTL8367C_REG_TX_SYNC_SEQ_ID(port)                        (RTL8367C_REG_TX_SYNC_SEQ_ID_BASE + (port *0x10))
+#define    RTL8367C_REG_SEQ_ID(port, type)                              (RTL8367C_REG_TX_SYNC_SEQ_ID_BASE + type + (port *0x10))
+
+#define    RTL8367C_REG_TX_DELAY_REQ_SEQ_ID_BASE              RTL8367C_REG_P0_TX_DELAY_REQ_SEQ_ID
+#define    RTL8367C_REG_TX_PDELAY_REQ_SEQ_ID_BASE          RTL8367C_REG_P0_TX_PDELAY_REQ_SEQ_ID
+#define    RTL8367C_REG_TX_PDELAY_RESP_SEQ_ID_BASE        RTL8367C_REG_P0_TX_PDELAY_RESP_SEQ_ID
+#define    RTL8367C_REG_RX_SYNC_SEQ_ID_BASE                        RTL8367C_REG_P0_RX_SYNC_SEQ_ID
+#define    RTL8367C_REG_RX_DELAY_REQ_SEQ_ID_BASE            RTL8367C_REG_P0_RX_DELAY_REQ_SEQ_ID
+#define    RTL8367C_REG_RX_PDELAY_REQ_SEQ_ID_BASE        RTL8367C_REG_P0_RX_PDELAY_REQ_SEQ_ID
+#define    RTL8367C_REG_RX_PDELAY_RESP_SEQ_ID_BASE        RTL8367C_REG_P0_RX_PDELAY_RESP_SEQ_ID
+
+#define    RTL8367C_REG_PORT_NSEC_L_BASE                            RTL8367C_REG_P0_PORT_NSEC_15_0
+#define    RTL8367C_REG_PORT_NSEC_L(port)                            (RTL8367C_REG_PORT_NSEC_L_BASE + (port *0x10))
+#define    RTL8367C_REG_PORT_NSEC_H_BASE                            RTL8367C_REG_P0_PORT_NSEC_26_16
+#define    RTL8367C_REG_PORT_NSEC_H(port)                            (RTL8367C_REG_PORT_NSEC_H_BASE + (port *0x10))
+#define    RTL8367C_PORT_NSEC_H_OFFSET                                RTL8367C_P0_PORT_NSEC_26_16_OFFSET
+#define    RTL8367C_PORT_NSEC_H_MASK                                   RTL8367C_P0_PORT_NSEC_26_16_MASK
+
+#define    RTL8367C_REG_PORT_SEC_L_BASE                                RTL8367C_REG_P0_PORT_SEC_15_0
+#define    RTL8367C_REG_PORT_SEC_L(port)                            (RTL8367C_REG_PORT_SEC_L_BASE + (port *0x10))
+#define    RTL8367C_REG_PORT_SEC_H_BASE                            RTL8367C_REG_P0_PORT_SEC_31_16
+#define    RTL8367C_REG_PORT_SEC_H(port)                            (RTL8367C_REG_PORT_SEC_H_BASE + (port *0x10))
+
+#endif /*#ifndef _RTL8367C_BASE_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_reg.h b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_reg.h
new file mode 100644
index 0000000000000..9f43f0a1c3da9
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/rtl8367c_reg.h
@@ -0,0 +1,22819 @@
+#ifndef _RTL8367C_REG_H_
+#define _RTL8367C_REG_H_
+
+/************************************************************
+auto-generated register address and field data
+*************************************************************/
+
+/* (16'h0000)port_reg */
+
+#define    RTL8367C_REG_PORT0_CGST_HALF_CFG    0x0000
+#define    RTL8367C_PORT0_CGST_HALF_CFG_CONGESTION_TIME_OFFSET    4
+#define    RTL8367C_PORT0_CGST_HALF_CFG_CONGESTION_TIME_MASK    0xF0
+#define    RTL8367C_PORT0_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT0_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_PKTGEN_PORT0_CTRL    0x0001
+#define    RTL8367C_PKTGEN_PORT0_CTRL_STATUS_OFFSET    15
+#define    RTL8367C_PKTGEN_PORT0_CTRL_STATUS_MASK    0x8000
+#define    RTL8367C_PKTGEN_PORT0_CTRL_PKTGEN_STS_OFFSET    13
+#define    RTL8367C_PKTGEN_PORT0_CTRL_PKTGEN_STS_MASK    0x2000
+#define    RTL8367C_PKTGEN_PORT0_CTRL_CRC_NO_ERROR_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT0_CTRL_CRC_NO_ERROR_MASK    0x10
+#define    RTL8367C_PKTGEN_PORT0_CTRL_CMD_START_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT0_CTRL_CMD_START_MASK    0x1
+
+#define    RTL8367C_REG_TX_ERR_CNT_PORT0    0x0002
+#define    RTL8367C_TX_ERR_CNT_PORT0_OFFSET    0
+#define    RTL8367C_TX_ERR_CNT_PORT0_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_PORT0_DA0    0x0003
+
+#define    RTL8367C_REG_PKTGEN_PORT0_DA1    0x0004
+
+#define    RTL8367C_REG_PKTGEN_PORT0_DA2    0x0005
+
+#define    RTL8367C_REG_PKTGEN_PORT0_SA0    0x0006
+
+#define    RTL8367C_REG_PKTGEN_PORT0_SA1    0x0007
+
+#define    RTL8367C_REG_PKTGEN_PORT0_SA2    0x0008
+
+#define    RTL8367C_REG_PKTGEN_PORT0_COUNTER0    0x0009
+
+#define    RTL8367C_REG_PKTGEN_PORT0_COUNTER1    0x000a
+#define    RTL8367C_PKTGEN_PORT0_COUNTER1_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT0_COUNTER1_MASK    0xFF
+
+#define    RTL8367C_REG_PKTGEN_PORT0_TX_LENGTH    0x000b
+#define    RTL8367C_PKTGEN_PORT0_TX_LENGTH_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT0_TX_LENGTH_MASK    0x3FFF
+
+#define    RTL8367C_REG_PKTGEN_PORT0_TIMER    0x000d
+#define    RTL8367C_PKTGEN_PORT0_TIMER_TIMER_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT0_TIMER_TIMER_MASK    0xF0
+#define    RTL8367C_PKTGEN_PORT0_TIMER_RX_DMA_ERR_FLAG_OFFSET    3
+#define    RTL8367C_PKTGEN_PORT0_TIMER_RX_DMA_ERR_FLAG_MASK    0x8
+
+#define    RTL8367C_REG_PORT0_MISC_CFG    0x000e
+#define    RTL8367C_PORT0_MISC_CFG_SMALL_TAG_IPG_OFFSET    15
+#define    RTL8367C_PORT0_MISC_CFG_SMALL_TAG_IPG_MASK    0x8000
+#define    RTL8367C_PORT0_MISC_CFG_TX_ITFSP_MODE_OFFSET    14
+#define    RTL8367C_PORT0_MISC_CFG_TX_ITFSP_MODE_MASK    0x4000
+#define    RTL8367C_PORT0_MISC_CFG_FLOWCTRL_INDEP_OFFSET    13
+#define    RTL8367C_PORT0_MISC_CFG_FLOWCTRL_INDEP_MASK    0x2000
+#define    RTL8367C_PORT0_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET    12
+#define    RTL8367C_PORT0_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK    0x1000
+#define    RTL8367C_PORT0_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+#define    RTL8367C_PORT0_MISC_CFG_INGRESSBW_FLOWCTRL_MASK    0x800
+#define    RTL8367C_PORT0_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT0_MISC_CFG_INGRESSBW_IFG_MASK    0x400
+#define    RTL8367C_PORT0_MISC_CFG_RX_SPC_OFFSET    9
+#define    RTL8367C_PORT0_MISC_CFG_RX_SPC_MASK    0x200
+#define    RTL8367C_PORT0_MISC_CFG_CRC_SKIP_OFFSET    8
+#define    RTL8367C_PORT0_MISC_CFG_CRC_SKIP_MASK    0x100
+#define    RTL8367C_PORT0_MISC_CFG_PKTGEN_TX_FIRST_OFFSET    7
+#define    RTL8367C_PORT0_MISC_CFG_PKTGEN_TX_FIRST_MASK    0x80
+#define    RTL8367C_PORT0_MISC_CFG_MAC_LOOPBACK_OFFSET    6
+#define    RTL8367C_PORT0_MISC_CFG_MAC_LOOPBACK_MASK    0x40
+#define    RTL8367C_PORT0_MISC_CFG_VLAN_EGRESS_MODE_OFFSET    4
+#define    RTL8367C_PORT0_MISC_CFG_VLAN_EGRESS_MODE_MASK    0x30
+#define    RTL8367C_PORT0_MISC_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT0_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_INGRESSBW_PORT0_RATE_CTRL0    0x000f
+
+#define    RTL8367C_REG_INGRESSBW_PORT0_RATE_CTRL1    0x0010
+#define    RTL8367C_INGRESSBW_PORT0_RATE_CTRL1_DUMMY_OFFSET    3
+#define    RTL8367C_INGRESSBW_PORT0_RATE_CTRL1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_INGRESSBW_PORT0_RATE_CTRL1_INGRESSBW_RATE16_OFFSET    0
+#define    RTL8367C_INGRESSBW_PORT0_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+
+#define    RTL8367C_REG_PORT0_FORCE_RATE0    0x0011
+
+#define    RTL8367C_REG_PORT0_FORCE_RATE1    0x0012
+
+#define    RTL8367C_REG_PORT0_CURENT_RATE0    0x0013
+
+#define    RTL8367C_REG_PORT0_CURENT_RATE1    0x0014
+
+#define    RTL8367C_REG_PORT0_PAGE_COUNTER    0x0015
+#define    RTL8367C_PORT0_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_PORT0_PAGE_COUNTER_MASK    0x7F
+
+#define    RTL8367C_REG_PAGEMETER_PORT0_CTRL0    0x0016
+
+#define    RTL8367C_REG_PAGEMETER_PORT0_CTRL1    0x0017
+
+#define    RTL8367C_REG_PORT0_EEECFG    0x0018
+#define    RTL8367C_PORT0_EEECFG_EEEP_ENABLE_TX_OFFSET    14
+#define    RTL8367C_PORT0_EEECFG_EEEP_ENABLE_TX_MASK    0x4000
+#define    RTL8367C_PORT0_EEECFG_EEEP_ENABLE_RX_OFFSET    13
+#define    RTL8367C_PORT0_EEECFG_EEEP_ENABLE_RX_MASK    0x2000
+#define    RTL8367C_PORT0_EEECFG_EEE_FORCE_OFFSET    12
+#define    RTL8367C_PORT0_EEECFG_EEE_FORCE_MASK    0x1000
+#define    RTL8367C_PORT0_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT0_EEECFG_EEE_100M_MASK    0x800
+#define    RTL8367C_PORT0_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT0_EEECFG_EEE_GIGA_500M_MASK    0x400
+#define    RTL8367C_PORT0_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT0_EEECFG_EEE_TX_MASK    0x200
+#define    RTL8367C_PORT0_EEECFG_EEE_RX_OFFSET    8
+#define    RTL8367C_PORT0_EEECFG_EEE_RX_MASK    0x100
+#define    RTL8367C_PORT0_EEECFG_EEE_DSP_RX_OFFSET    6
+#define    RTL8367C_PORT0_EEECFG_EEE_DSP_RX_MASK    0x40
+#define    RTL8367C_PORT0_EEECFG_EEE_LPI_OFFSET    5
+#define    RTL8367C_PORT0_EEECFG_EEE_LPI_MASK    0x20
+#define    RTL8367C_PORT0_EEECFG_EEE_TX_LPI_OFFSET    4
+#define    RTL8367C_PORT0_EEECFG_EEE_TX_LPI_MASK    0x10
+#define    RTL8367C_PORT0_EEECFG_EEE_RX_LPI_OFFSET    3
+#define    RTL8367C_PORT0_EEECFG_EEE_RX_LPI_MASK    0x8
+#define    RTL8367C_PORT0_EEECFG_EEE_PAUSE_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT0_EEECFG_EEE_PAUSE_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT0_EEECFG_EEE_WAKE_REQ_OFFSET    1
+#define    RTL8367C_PORT0_EEECFG_EEE_WAKE_REQ_MASK    0x2
+#define    RTL8367C_PORT0_EEECFG_EEE_SLEEP_REQ_OFFSET    0
+#define    RTL8367C_PORT0_EEECFG_EEE_SLEEP_REQ_MASK    0x1
+
+#define    RTL8367C_REG_PORT0_EEETXMTR    0x0019
+
+#define    RTL8367C_REG_PORT0_EEERXMTR    0x001a
+
+#define    RTL8367C_REG_PORT0_EEEPTXMTR    0x001b
+
+#define    RTL8367C_REG_PORT0_EEEPRXMTR    0x001c
+
+#define    RTL8367C_REG_PTP_PORT0_CFG1    0x001e
+#define    RTL8367C_PTP_PORT0_CFG1_OFFSET    7
+#define    RTL8367C_PTP_PORT0_CFG1_MASK    0xFF
+
+#define    RTL8367C_REG_P0_MSIC1    0x001f
+#define    RTL8367C_P0_MSIC1_OFFSET    0
+#define    RTL8367C_P0_MSIC1_MASK    0x1
+
+#define    RTL8367C_REG_PORT1_CGST_HALF_CFG    0x0020
+#define    RTL8367C_PORT1_CGST_HALF_CFG_CONGESTION_TIME_OFFSET    4
+#define    RTL8367C_PORT1_CGST_HALF_CFG_CONGESTION_TIME_MASK    0xF0
+#define    RTL8367C_PORT1_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT1_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_PKTGEN_PORT1_CTRL    0x0021
+#define    RTL8367C_PKTGEN_PORT1_CTRL_STATUS_OFFSET    15
+#define    RTL8367C_PKTGEN_PORT1_CTRL_STATUS_MASK    0x8000
+#define    RTL8367C_PKTGEN_PORT1_CTRL_PKTGEN_STS_OFFSET    13
+#define    RTL8367C_PKTGEN_PORT1_CTRL_PKTGEN_STS_MASK    0x2000
+#define    RTL8367C_PKTGEN_PORT1_CTRL_CRC_NO_ERROR_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT1_CTRL_CRC_NO_ERROR_MASK    0x10
+#define    RTL8367C_PKTGEN_PORT1_CTRL_CMD_START_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT1_CTRL_CMD_START_MASK    0x1
+
+#define    RTL8367C_REG_TX_ERR_CNT_PORT1    0x0022
+#define    RTL8367C_TX_ERR_CNT_PORT1_OFFSET    0
+#define    RTL8367C_TX_ERR_CNT_PORT1_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_PORT1_DA0    0x0023
+
+#define    RTL8367C_REG_PKTGEN_PORT1_DA1    0x0024
+
+#define    RTL8367C_REG_PKTGEN_PORT1_DA2    0x0025
+
+#define    RTL8367C_REG_PKTGEN_PORT1_SA0    0x0026
+
+#define    RTL8367C_REG_PKTGEN_PORT1_SA1    0x0027
+
+#define    RTL8367C_REG_PKTGEN_PORT1_SA2    0x0028
+
+#define    RTL8367C_REG_PKTGEN_PORT1_COUNTER0    0x0029
+
+#define    RTL8367C_REG_PKTGEN_PORT1_COUNTER1    0x002a
+#define    RTL8367C_PKTGEN_PORT1_COUNTER1_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT1_COUNTER1_MASK    0xFF
+
+#define    RTL8367C_REG_PKTGEN_PORT1_TX_LENGTH    0x002b
+#define    RTL8367C_PKTGEN_PORT1_TX_LENGTH_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT1_TX_LENGTH_MASK    0x3FFF
+
+#define    RTL8367C_REG_PKTGEN_PORT1_TIMER    0x002d
+#define    RTL8367C_PKTGEN_PORT1_TIMER_TIMER_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT1_TIMER_TIMER_MASK    0xF0
+#define    RTL8367C_PKTGEN_PORT1_TIMER_RX_DMA_ERR_FLAG_OFFSET    3
+#define    RTL8367C_PKTGEN_PORT1_TIMER_RX_DMA_ERR_FLAG_MASK    0x8
+
+#define    RTL8367C_REG_PORT1_MISC_CFG    0x002e
+#define    RTL8367C_PORT1_MISC_CFG_SMALL_TAG_IPG_OFFSET    15
+#define    RTL8367C_PORT1_MISC_CFG_SMALL_TAG_IPG_MASK    0x8000
+#define    RTL8367C_PORT1_MISC_CFG_TX_ITFSP_MODE_OFFSET    14
+#define    RTL8367C_PORT1_MISC_CFG_TX_ITFSP_MODE_MASK    0x4000
+#define    RTL8367C_PORT1_MISC_CFG_FLOWCTRL_INDEP_OFFSET    13
+#define    RTL8367C_PORT1_MISC_CFG_FLOWCTRL_INDEP_MASK    0x2000
+#define    RTL8367C_PORT1_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET    12
+#define    RTL8367C_PORT1_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK    0x1000
+#define    RTL8367C_PORT1_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+#define    RTL8367C_PORT1_MISC_CFG_INGRESSBW_FLOWCTRL_MASK    0x800
+#define    RTL8367C_PORT1_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT1_MISC_CFG_INGRESSBW_IFG_MASK    0x400
+#define    RTL8367C_PORT1_MISC_CFG_RX_SPC_OFFSET    9
+#define    RTL8367C_PORT1_MISC_CFG_RX_SPC_MASK    0x200
+#define    RTL8367C_PORT1_MISC_CFG_CRC_SKIP_OFFSET    8
+#define    RTL8367C_PORT1_MISC_CFG_CRC_SKIP_MASK    0x100
+#define    RTL8367C_PORT1_MISC_CFG_PKTGEN_TX_FIRST_OFFSET    7
+#define    RTL8367C_PORT1_MISC_CFG_PKTGEN_TX_FIRST_MASK    0x80
+#define    RTL8367C_PORT1_MISC_CFG_MAC_LOOPBACK_OFFSET    6
+#define    RTL8367C_PORT1_MISC_CFG_MAC_LOOPBACK_MASK    0x40
+#define    RTL8367C_PORT1_MISC_CFG_VLAN_EGRESS_MODE_OFFSET    4
+#define    RTL8367C_PORT1_MISC_CFG_VLAN_EGRESS_MODE_MASK    0x30
+#define    RTL8367C_PORT1_MISC_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT1_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_INGRESSBW_PORT1_RATE_CTRL0    0x002f
+
+#define    RTL8367C_REG_INGRESSBW_PORT1_RATE_CTRL1    0x0030
+#define    RTL8367C_INGRESSBW_PORT1_RATE_CTRL1_DUMMY_OFFSET    3
+#define    RTL8367C_INGRESSBW_PORT1_RATE_CTRL1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_INGRESSBW_PORT1_RATE_CTRL1_INGRESSBW_RATE16_OFFSET    0
+#define    RTL8367C_INGRESSBW_PORT1_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+
+#define    RTL8367C_REG_PORT1_FORCE_RATE0    0x0031
+
+#define    RTL8367C_REG_PORT1_FORCE_RATE1    0x0032
+
+#define    RTL8367C_REG_PORT1_CURENT_RATE0    0x0033
+
+#define    RTL8367C_REG_PORT1_CURENT_RATE1    0x0034
+
+#define    RTL8367C_REG_PORT1_PAGE_COUNTER    0x0035
+#define    RTL8367C_PORT1_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_PORT1_PAGE_COUNTER_MASK    0x7F
+
+#define    RTL8367C_REG_PAGEMETER_PORT1_CTRL0    0x0036
+
+#define    RTL8367C_REG_PAGEMETER_PORT1_CTRL1    0x0037
+
+#define    RTL8367C_REG_PORT1_EEECFG    0x0038
+#define    RTL8367C_PORT1_EEECFG_EEEP_ENABLE_TX_OFFSET    14
+#define    RTL8367C_PORT1_EEECFG_EEEP_ENABLE_TX_MASK    0x4000
+#define    RTL8367C_PORT1_EEECFG_EEEP_ENABLE_RX_OFFSET    13
+#define    RTL8367C_PORT1_EEECFG_EEEP_ENABLE_RX_MASK    0x2000
+#define    RTL8367C_PORT1_EEECFG_EEE_FORCE_OFFSET    12
+#define    RTL8367C_PORT1_EEECFG_EEE_FORCE_MASK    0x1000
+#define    RTL8367C_PORT1_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT1_EEECFG_EEE_100M_MASK    0x800
+#define    RTL8367C_PORT1_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT1_EEECFG_EEE_GIGA_500M_MASK    0x400
+#define    RTL8367C_PORT1_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT1_EEECFG_EEE_TX_MASK    0x200
+#define    RTL8367C_PORT1_EEECFG_EEE_RX_OFFSET    8
+#define    RTL8367C_PORT1_EEECFG_EEE_RX_MASK    0x100
+#define    RTL8367C_PORT1_EEECFG_EEE_DSP_RX_OFFSET    6
+#define    RTL8367C_PORT1_EEECFG_EEE_DSP_RX_MASK    0x40
+#define    RTL8367C_PORT1_EEECFG_EEE_LPI_OFFSET    5
+#define    RTL8367C_PORT1_EEECFG_EEE_LPI_MASK    0x20
+#define    RTL8367C_PORT1_EEECFG_EEE_TX_LPI_OFFSET    4
+#define    RTL8367C_PORT1_EEECFG_EEE_TX_LPI_MASK    0x10
+#define    RTL8367C_PORT1_EEECFG_EEE_RX_LPI_OFFSET    3
+#define    RTL8367C_PORT1_EEECFG_EEE_RX_LPI_MASK    0x8
+#define    RTL8367C_PORT1_EEECFG_EEE_PAUSE_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT1_EEECFG_EEE_PAUSE_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT1_EEECFG_EEE_WAKE_REQ_OFFSET    1
+#define    RTL8367C_PORT1_EEECFG_EEE_WAKE_REQ_MASK    0x2
+#define    RTL8367C_PORT1_EEECFG_EEE_SLEEP_REQ_OFFSET    0
+#define    RTL8367C_PORT1_EEECFG_EEE_SLEEP_REQ_MASK    0x1
+
+#define    RTL8367C_REG_PORT1_EEETXMTR    0x0039
+
+#define    RTL8367C_REG_PORT1_EEERXMTR    0x003a
+
+#define    RTL8367C_REG_PORT1_EEEPTXMTR    0x003b
+
+#define    RTL8367C_REG_PORT1_EEEPRXMTR    0x003c
+
+#define    RTL8367C_REG_PTP_PORT1_CFG1    0x003e
+#define    RTL8367C_PTP_PORT1_CFG1_OFFSET    7
+#define    RTL8367C_PTP_PORT1_CFG1_MASK    0xFF
+
+#define    RTL8367C_REG_P1_MSIC1    0x003f
+#define    RTL8367C_P1_MSIC1_OFFSET    0
+#define    RTL8367C_P1_MSIC1_MASK    0x1
+
+#define    RTL8367C_REG_PORT2_CGST_HALF_CFG    0x0040
+#define    RTL8367C_PORT2_CGST_HALF_CFG_CONGESTION_TIME_OFFSET    4
+#define    RTL8367C_PORT2_CGST_HALF_CFG_CONGESTION_TIME_MASK    0xF0
+#define    RTL8367C_PORT2_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT2_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_PKTGEN_PORT2_CTRL    0x0041
+#define    RTL8367C_PKTGEN_PORT2_CTRL_STATUS_OFFSET    15
+#define    RTL8367C_PKTGEN_PORT2_CTRL_STATUS_MASK    0x8000
+#define    RTL8367C_PKTGEN_PORT2_CTRL_PKTGEN_STS_OFFSET    13
+#define    RTL8367C_PKTGEN_PORT2_CTRL_PKTGEN_STS_MASK    0x2000
+#define    RTL8367C_PKTGEN_PORT2_CTRL_CRC_NO_ERROR_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT2_CTRL_CRC_NO_ERROR_MASK    0x10
+#define    RTL8367C_PKTGEN_PORT2_CTRL_CMD_START_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT2_CTRL_CMD_START_MASK    0x1
+
+#define    RTL8367C_REG_TX_ERR_CNT_PORT2    0x0042
+#define    RTL8367C_TX_ERR_CNT_PORT2_OFFSET    0
+#define    RTL8367C_TX_ERR_CNT_PORT2_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_PORT2_DA0    0x0043
+
+#define    RTL8367C_REG_PKTGEN_PORT2_DA1    0x0044
+
+#define    RTL8367C_REG_PKTGEN_PORT2_DA2    0x0045
+
+#define    RTL8367C_REG_PKTGEN_PORT2_SA0    0x0046
+
+#define    RTL8367C_REG_PKTGEN_PORT2_SA1    0x0047
+
+#define    RTL8367C_REG_PKTGEN_PORT2_SA2    0x0048
+
+#define    RTL8367C_REG_PKTGEN_PORT2_COUNTER0    0x0049
+
+#define    RTL8367C_REG_PKTGEN_PORT2_COUNTER1    0x004a
+#define    RTL8367C_PKTGEN_PORT2_COUNTER1_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT2_COUNTER1_MASK    0xFF
+
+#define    RTL8367C_REG_PKTGEN_PORT2_TX_LENGTH    0x004b
+#define    RTL8367C_PKTGEN_PORT2_TX_LENGTH_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT2_TX_LENGTH_MASK    0x3FFF
+
+#define    RTL8367C_REG_PKTGEN_PORT2_TIMER    0x004d
+#define    RTL8367C_PKTGEN_PORT2_TIMER_TIMER_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT2_TIMER_TIMER_MASK    0xF0
+#define    RTL8367C_PKTGEN_PORT2_TIMER_RX_DMA_ERR_FLAG_OFFSET    3
+#define    RTL8367C_PKTGEN_PORT2_TIMER_RX_DMA_ERR_FLAG_MASK    0x8
+
+#define    RTL8367C_REG_PORT2_MISC_CFG    0x004e
+#define    RTL8367C_PORT2_MISC_CFG_SMALL_TAG_IPG_OFFSET    15
+#define    RTL8367C_PORT2_MISC_CFG_SMALL_TAG_IPG_MASK    0x8000
+#define    RTL8367C_PORT2_MISC_CFG_TX_ITFSP_MODE_OFFSET    14
+#define    RTL8367C_PORT2_MISC_CFG_TX_ITFSP_MODE_MASK    0x4000
+#define    RTL8367C_PORT2_MISC_CFG_FLOWCTRL_INDEP_OFFSET    13
+#define    RTL8367C_PORT2_MISC_CFG_FLOWCTRL_INDEP_MASK    0x2000
+#define    RTL8367C_PORT2_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET    12
+#define    RTL8367C_PORT2_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK    0x1000
+#define    RTL8367C_PORT2_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+#define    RTL8367C_PORT2_MISC_CFG_INGRESSBW_FLOWCTRL_MASK    0x800
+#define    RTL8367C_PORT2_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT2_MISC_CFG_INGRESSBW_IFG_MASK    0x400
+#define    RTL8367C_PORT2_MISC_CFG_RX_SPC_OFFSET    9
+#define    RTL8367C_PORT2_MISC_CFG_RX_SPC_MASK    0x200
+#define    RTL8367C_PORT2_MISC_CFG_CRC_SKIP_OFFSET    8
+#define    RTL8367C_PORT2_MISC_CFG_CRC_SKIP_MASK    0x100
+#define    RTL8367C_PORT2_MISC_CFG_PKTGEN_TX_FIRST_OFFSET    7
+#define    RTL8367C_PORT2_MISC_CFG_PKTGEN_TX_FIRST_MASK    0x80
+#define    RTL8367C_PORT2_MISC_CFG_MAC_LOOPBACK_OFFSET    6
+#define    RTL8367C_PORT2_MISC_CFG_MAC_LOOPBACK_MASK    0x40
+#define    RTL8367C_PORT2_MISC_CFG_VLAN_EGRESS_MODE_OFFSET    4
+#define    RTL8367C_PORT2_MISC_CFG_VLAN_EGRESS_MODE_MASK    0x30
+#define    RTL8367C_PORT2_MISC_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT2_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_INGRESSBW_PORT2_RATE_CTRL0    0x004f
+
+#define    RTL8367C_REG_INGRESSBW_PORT2_RATE_CTRL1    0x0050
+#define    RTL8367C_INGRESSBW_PORT2_RATE_CTRL1_DUMMY_OFFSET    3
+#define    RTL8367C_INGRESSBW_PORT2_RATE_CTRL1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_INGRESSBW_PORT2_RATE_CTRL1_INGRESSBW_RATE16_OFFSET    0
+#define    RTL8367C_INGRESSBW_PORT2_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+
+#define    RTL8367C_REG_PORT2_FORCE_RATE0    0x0051
+
+#define    RTL8367C_REG_PORT2_FORCE_RATE1    0x0052
+
+#define    RTL8367C_REG_PORT2_CURENT_RATE0    0x0053
+
+#define    RTL8367C_REG_PORT2_CURENT_RATE1    0x0054
+
+#define    RTL8367C_REG_PORT2_PAGE_COUNTER    0x0055
+#define    RTL8367C_PORT2_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_PORT2_PAGE_COUNTER_MASK    0x7F
+
+#define    RTL8367C_REG_PAGEMETER_PORT2_CTRL0    0x0056
+
+#define    RTL8367C_REG_PAGEMETER_PORT2_CTRL1    0x0057
+
+#define    RTL8367C_REG_PORT2_EEECFG    0x0058
+#define    RTL8367C_PORT2_EEECFG_EEEP_ENABLE_TX_OFFSET    14
+#define    RTL8367C_PORT2_EEECFG_EEEP_ENABLE_TX_MASK    0x4000
+#define    RTL8367C_PORT2_EEECFG_EEEP_ENABLE_RX_OFFSET    13
+#define    RTL8367C_PORT2_EEECFG_EEEP_ENABLE_RX_MASK    0x2000
+#define    RTL8367C_PORT2_EEECFG_EEE_FORCE_OFFSET    12
+#define    RTL8367C_PORT2_EEECFG_EEE_FORCE_MASK    0x1000
+#define    RTL8367C_PORT2_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT2_EEECFG_EEE_100M_MASK    0x800
+#define    RTL8367C_PORT2_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT2_EEECFG_EEE_GIGA_500M_MASK    0x400
+#define    RTL8367C_PORT2_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT2_EEECFG_EEE_TX_MASK    0x200
+#define    RTL8367C_PORT2_EEECFG_EEE_RX_OFFSET    8
+#define    RTL8367C_PORT2_EEECFG_EEE_RX_MASK    0x100
+#define    RTL8367C_PORT2_EEECFG_EEE_DSP_RX_OFFSET    6
+#define    RTL8367C_PORT2_EEECFG_EEE_DSP_RX_MASK    0x40
+#define    RTL8367C_PORT2_EEECFG_EEE_LPI_OFFSET    5
+#define    RTL8367C_PORT2_EEECFG_EEE_LPI_MASK    0x20
+#define    RTL8367C_PORT2_EEECFG_EEE_TX_LPI_OFFSET    4
+#define    RTL8367C_PORT2_EEECFG_EEE_TX_LPI_MASK    0x10
+#define    RTL8367C_PORT2_EEECFG_EEE_RX_LPI_OFFSET    3
+#define    RTL8367C_PORT2_EEECFG_EEE_RX_LPI_MASK    0x8
+#define    RTL8367C_PORT2_EEECFG_EEE_PAUSE_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT2_EEECFG_EEE_PAUSE_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT2_EEECFG_EEE_WAKE_REQ_OFFSET    1
+#define    RTL8367C_PORT2_EEECFG_EEE_WAKE_REQ_MASK    0x2
+#define    RTL8367C_PORT2_EEECFG_EEE_SLEEP_REQ_OFFSET    0
+#define    RTL8367C_PORT2_EEECFG_EEE_SLEEP_REQ_MASK    0x1
+
+#define    RTL8367C_REG_PORT2_EEETXMTR    0x0059
+
+#define    RTL8367C_REG_PORT2_EEERXMTR    0x005a
+
+#define    RTL8367C_REG_PORT2_EEEPTXMTR    0x005b
+
+#define    RTL8367C_REG_PORT2_EEEPRXMTR    0x005c
+
+#define    RTL8367C_REG_PTP_PORT2_CFG1    0x005e
+#define    RTL8367C_PTP_PORT2_CFG1_OFFSET    7
+#define    RTL8367C_PTP_PORT2_CFG1_MASK    0xFF
+
+#define    RTL8367C_REG_P2_MSIC1    0x005f
+#define    RTL8367C_P2_MSIC1_OFFSET    0
+#define    RTL8367C_P2_MSIC1_MASK    0x1
+
+#define    RTL8367C_REG_PORT3_CGST_HALF_CFG    0x0060
+#define    RTL8367C_PORT3_CGST_HALF_CFG_CONGESTION_TIME_OFFSET    4
+#define    RTL8367C_PORT3_CGST_HALF_CFG_CONGESTION_TIME_MASK    0xF0
+#define    RTL8367C_PORT3_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT3_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_PKTGEN_PORT3_CTRL    0x0061
+#define    RTL8367C_PKTGEN_PORT3_CTRL_STATUS_OFFSET    15
+#define    RTL8367C_PKTGEN_PORT3_CTRL_STATUS_MASK    0x8000
+#define    RTL8367C_PKTGEN_PORT3_CTRL_PKTGEN_STS_OFFSET    13
+#define    RTL8367C_PKTGEN_PORT3_CTRL_PKTGEN_STS_MASK    0x2000
+#define    RTL8367C_PKTGEN_PORT3_CTRL_CRC_NO_ERROR_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT3_CTRL_CRC_NO_ERROR_MASK    0x10
+#define    RTL8367C_PKTGEN_PORT3_CTRL_CMD_START_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT3_CTRL_CMD_START_MASK    0x1
+
+#define    RTL8367C_REG_TX_ERR_CNT_PORT3    0x0062
+#define    RTL8367C_TX_ERR_CNT_PORT3_OFFSET    0
+#define    RTL8367C_TX_ERR_CNT_PORT3_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_PORT3_DA0    0x0063
+
+#define    RTL8367C_REG_PKTGEN_PORT3_DA1    0x0064
+
+#define    RTL8367C_REG_PKTGEN_PORT3_DA2    0x0065
+
+#define    RTL8367C_REG_PKTGEN_PORT3_SA0    0x0066
+
+#define    RTL8367C_REG_PKTGEN_PORT3_SA1    0x0067
+
+#define    RTL8367C_REG_PKTGEN_PORT3_SA2    0x0068
+
+#define    RTL8367C_REG_PKTGEN_PORT3_COUNTER0    0x0069
+
+#define    RTL8367C_REG_PKTGEN_PORT3_COUNTER1    0x006a
+#define    RTL8367C_PKTGEN_PORT3_COUNTER1_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT3_COUNTER1_MASK    0xFF
+
+#define    RTL8367C_REG_PKTGEN_PORT3_TX_LENGTH    0x006b
+#define    RTL8367C_PKTGEN_PORT3_TX_LENGTH_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT3_TX_LENGTH_MASK    0x3FFF
+
+#define    RTL8367C_REG_PKTGEN_PORT3_TIMER    0x006d
+#define    RTL8367C_PKTGEN_PORT3_TIMER_TIMER_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT3_TIMER_TIMER_MASK    0xF0
+#define    RTL8367C_PKTGEN_PORT3_TIMER_RX_DMA_ERR_FLAG_OFFSET    3
+#define    RTL8367C_PKTGEN_PORT3_TIMER_RX_DMA_ERR_FLAG_MASK    0x8
+
+#define    RTL8367C_REG_PORT3_MISC_CFG    0x006e
+#define    RTL8367C_PORT3_MISC_CFG_SMALL_TAG_IPG_OFFSET    15
+#define    RTL8367C_PORT3_MISC_CFG_SMALL_TAG_IPG_MASK    0x8000
+#define    RTL8367C_PORT3_MISC_CFG_TX_ITFSP_MODE_OFFSET    14
+#define    RTL8367C_PORT3_MISC_CFG_TX_ITFSP_MODE_MASK    0x4000
+#define    RTL8367C_PORT3_MISC_CFG_FLOWCTRL_INDEP_OFFSET    13
+#define    RTL8367C_PORT3_MISC_CFG_FLOWCTRL_INDEP_MASK    0x2000
+#define    RTL8367C_PORT3_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET    12
+#define    RTL8367C_PORT3_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK    0x1000
+#define    RTL8367C_PORT3_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+#define    RTL8367C_PORT3_MISC_CFG_INGRESSBW_FLOWCTRL_MASK    0x800
+#define    RTL8367C_PORT3_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT3_MISC_CFG_INGRESSBW_IFG_MASK    0x400
+#define    RTL8367C_PORT3_MISC_CFG_RX_SPC_OFFSET    9
+#define    RTL8367C_PORT3_MISC_CFG_RX_SPC_MASK    0x200
+#define    RTL8367C_PORT3_MISC_CFG_CRC_SKIP_OFFSET    8
+#define    RTL8367C_PORT3_MISC_CFG_CRC_SKIP_MASK    0x100
+#define    RTL8367C_PORT3_MISC_CFG_PKTGEN_TX_FIRST_OFFSET    7
+#define    RTL8367C_PORT3_MISC_CFG_PKTGEN_TX_FIRST_MASK    0x80
+#define    RTL8367C_PORT3_MISC_CFG_MAC_LOOPBACK_OFFSET    6
+#define    RTL8367C_PORT3_MISC_CFG_MAC_LOOPBACK_MASK    0x40
+#define    RTL8367C_PORT3_MISC_CFG_VLAN_EGRESS_MODE_OFFSET    4
+#define    RTL8367C_PORT3_MISC_CFG_VLAN_EGRESS_MODE_MASK    0x30
+#define    RTL8367C_PORT3_MISC_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT3_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_INGRESSBW_PORT3_RATE_CTRL0    0x006f
+
+#define    RTL8367C_REG_INGRESSBW_PORT3_RATE_CTRL1    0x0070
+#define    RTL8367C_INGRESSBW_PORT3_RATE_CTRL1_DUMMY_OFFSET    3
+#define    RTL8367C_INGRESSBW_PORT3_RATE_CTRL1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_INGRESSBW_PORT3_RATE_CTRL1_INGRESSBW_RATE16_OFFSET    0
+#define    RTL8367C_INGRESSBW_PORT3_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+
+#define    RTL8367C_REG_PORT3_FORCE_RATE0    0x0071
+
+#define    RTL8367C_REG_PORT3_FORCE_RATE1    0x0072
+
+#define    RTL8367C_REG_PORT3_CURENT_RATE0    0x0073
+
+#define    RTL8367C_REG_PORT3_CURENT_RATE1    0x0074
+
+#define    RTL8367C_REG_PORT3_PAGE_COUNTER    0x0075
+#define    RTL8367C_PORT3_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_PORT3_PAGE_COUNTER_MASK    0x7F
+
+#define    RTL8367C_REG_PAGEMETER_PORT3_CTRL0    0x0076
+
+#define    RTL8367C_REG_PAGEMETER_PORT3_CTRL1    0x0077
+
+#define    RTL8367C_REG_PORT3_EEECFG    0x0078
+#define    RTL8367C_PORT3_EEECFG_EEEP_ENABLE_TX_OFFSET    14
+#define    RTL8367C_PORT3_EEECFG_EEEP_ENABLE_TX_MASK    0x4000
+#define    RTL8367C_PORT3_EEECFG_EEEP_ENABLE_RX_OFFSET    13
+#define    RTL8367C_PORT3_EEECFG_EEEP_ENABLE_RX_MASK    0x2000
+#define    RTL8367C_PORT3_EEECFG_EEE_FORCE_OFFSET    12
+#define    RTL8367C_PORT3_EEECFG_EEE_FORCE_MASK    0x1000
+#define    RTL8367C_PORT3_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT3_EEECFG_EEE_100M_MASK    0x800
+#define    RTL8367C_PORT3_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT3_EEECFG_EEE_GIGA_500M_MASK    0x400
+#define    RTL8367C_PORT3_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT3_EEECFG_EEE_TX_MASK    0x200
+#define    RTL8367C_PORT3_EEECFG_EEE_RX_OFFSET    8
+#define    RTL8367C_PORT3_EEECFG_EEE_RX_MASK    0x100
+#define    RTL8367C_PORT3_EEECFG_EEE_DSP_RX_OFFSET    6
+#define    RTL8367C_PORT3_EEECFG_EEE_DSP_RX_MASK    0x40
+#define    RTL8367C_PORT3_EEECFG_EEE_LPI_OFFSET    5
+#define    RTL8367C_PORT3_EEECFG_EEE_LPI_MASK    0x20
+#define    RTL8367C_PORT3_EEECFG_EEE_TX_LPI_OFFSET    4
+#define    RTL8367C_PORT3_EEECFG_EEE_TX_LPI_MASK    0x10
+#define    RTL8367C_PORT3_EEECFG_EEE_RX_LPI_OFFSET    3
+#define    RTL8367C_PORT3_EEECFG_EEE_RX_LPI_MASK    0x8
+#define    RTL8367C_PORT3_EEECFG_EEE_PAUSE_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT3_EEECFG_EEE_PAUSE_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT3_EEECFG_EEE_WAKE_REQ_OFFSET    1
+#define    RTL8367C_PORT3_EEECFG_EEE_WAKE_REQ_MASK    0x2
+#define    RTL8367C_PORT3_EEECFG_EEE_SLEEP_REQ_OFFSET    0
+#define    RTL8367C_PORT3_EEECFG_EEE_SLEEP_REQ_MASK    0x1
+
+#define    RTL8367C_REG_PORT3_EEETXMTR    0x0079
+
+#define    RTL8367C_REG_PORT3_EEERXMTR    0x007a
+
+#define    RTL8367C_REG_PORT3_EEEPTXMTR    0x007b
+
+#define    RTL8367C_REG_PORT3_EEEPRXMTR    0x007c
+
+#define    RTL8367C_REG_PTP_PORT3_CFG1    0x007e
+#define    RTL8367C_PTP_PORT3_CFG1_OFFSET    7
+#define    RTL8367C_PTP_PORT3_CFG1_MASK    0xFF
+
+#define    RTL8367C_REG_P3_MSIC1    0x007f
+#define    RTL8367C_P3_MSIC1_OFFSET    0
+#define    RTL8367C_P3_MSIC1_MASK    0x1
+
+#define    RTL8367C_REG_PORT4_CGST_HALF_CFG    0x0080
+#define    RTL8367C_PORT4_CGST_HALF_CFG_CONGESTION_TIME_OFFSET    4
+#define    RTL8367C_PORT4_CGST_HALF_CFG_CONGESTION_TIME_MASK    0xF0
+#define    RTL8367C_PORT4_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT4_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_PKTGEN_PORT4_CTRL    0x0081
+#define    RTL8367C_PKTGEN_PORT4_CTRL_STATUS_OFFSET    15
+#define    RTL8367C_PKTGEN_PORT4_CTRL_STATUS_MASK    0x8000
+#define    RTL8367C_PKTGEN_PORT4_CTRL_PKTGEN_STS_OFFSET    13
+#define    RTL8367C_PKTGEN_PORT4_CTRL_PKTGEN_STS_MASK    0x2000
+#define    RTL8367C_PKTGEN_PORT4_CTRL_CRC_NO_ERROR_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT4_CTRL_CRC_NO_ERROR_MASK    0x10
+#define    RTL8367C_PKTGEN_PORT4_CTRL_CMD_START_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT4_CTRL_CMD_START_MASK    0x1
+
+#define    RTL8367C_REG_TX_ERR_CNT_PORT4    0x0082
+#define    RTL8367C_TX_ERR_CNT_PORT4_OFFSET    0
+#define    RTL8367C_TX_ERR_CNT_PORT4_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_PORT4_DA0    0x0083
+
+#define    RTL8367C_REG_PKTGEN_PORT4_DA1    0x0084
+
+#define    RTL8367C_REG_PKTGEN_PORT4_DA2    0x0085
+
+#define    RTL8367C_REG_PKTGEN_PORT4_SA0    0x0086
+
+#define    RTL8367C_REG_PKTGEN_PORT4_SA1    0x0087
+
+#define    RTL8367C_REG_PKTGEN_PORT4_SA2    0x0088
+
+#define    RTL8367C_REG_PKTGEN_PORT4_COUNTER0    0x0089
+
+#define    RTL8367C_REG_PKTGEN_PORT4_COUNTER1    0x008a
+#define    RTL8367C_PKTGEN_PORT4_COUNTER1_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT4_COUNTER1_MASK    0xFF
+
+#define    RTL8367C_REG_PKTGEN_PORT4_TX_LENGTH    0x008b
+#define    RTL8367C_PKTGEN_PORT4_TX_LENGTH_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT4_TX_LENGTH_MASK    0x3FFF
+
+#define    RTL8367C_REG_PKTGEN_PORT4_TIMER    0x008d
+#define    RTL8367C_PKTGEN_PORT4_TIMER_TIMER_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT4_TIMER_TIMER_MASK    0xF0
+#define    RTL8367C_PKTGEN_PORT4_TIMER_RX_DMA_ERR_FLAG_OFFSET    3
+#define    RTL8367C_PKTGEN_PORT4_TIMER_RX_DMA_ERR_FLAG_MASK    0x8
+
+#define    RTL8367C_REG_PORT4_MISC_CFG    0x008e
+#define    RTL8367C_PORT4_MISC_CFG_SMALL_TAG_IPG_OFFSET    15
+#define    RTL8367C_PORT4_MISC_CFG_SMALL_TAG_IPG_MASK    0x8000
+#define    RTL8367C_PORT4_MISC_CFG_TX_ITFSP_MODE_OFFSET    14
+#define    RTL8367C_PORT4_MISC_CFG_TX_ITFSP_MODE_MASK    0x4000
+#define    RTL8367C_PORT4_MISC_CFG_FLOWCTRL_INDEP_OFFSET    13
+#define    RTL8367C_PORT4_MISC_CFG_FLOWCTRL_INDEP_MASK    0x2000
+#define    RTL8367C_PORT4_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET    12
+#define    RTL8367C_PORT4_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK    0x1000
+#define    RTL8367C_PORT4_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+#define    RTL8367C_PORT4_MISC_CFG_INGRESSBW_FLOWCTRL_MASK    0x800
+#define    RTL8367C_PORT4_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT4_MISC_CFG_INGRESSBW_IFG_MASK    0x400
+#define    RTL8367C_PORT4_MISC_CFG_RX_SPC_OFFSET    9
+#define    RTL8367C_PORT4_MISC_CFG_RX_SPC_MASK    0x200
+#define    RTL8367C_PORT4_MISC_CFG_CRC_SKIP_OFFSET    8
+#define    RTL8367C_PORT4_MISC_CFG_CRC_SKIP_MASK    0x100
+#define    RTL8367C_PORT4_MISC_CFG_PKTGEN_TX_FIRST_OFFSET    7
+#define    RTL8367C_PORT4_MISC_CFG_PKTGEN_TX_FIRST_MASK    0x80
+#define    RTL8367C_PORT4_MISC_CFG_MAC_LOOPBACK_OFFSET    6
+#define    RTL8367C_PORT4_MISC_CFG_MAC_LOOPBACK_MASK    0x40
+#define    RTL8367C_PORT4_MISC_CFG_VLAN_EGRESS_MODE_OFFSET    4
+#define    RTL8367C_PORT4_MISC_CFG_VLAN_EGRESS_MODE_MASK    0x30
+#define    RTL8367C_PORT4_MISC_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT4_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_INGRESSBW_PORT4_RATE_CTRL0    0x008f
+
+#define    RTL8367C_REG_INGRESSBW_PORT4_RATE_CTRL1    0x0090
+#define    RTL8367C_INGRESSBW_PORT4_RATE_CTRL1_DUMMY_OFFSET    3
+#define    RTL8367C_INGRESSBW_PORT4_RATE_CTRL1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_INGRESSBW_PORT4_RATE_CTRL1_INGRESSBW_RATE16_OFFSET    0
+#define    RTL8367C_INGRESSBW_PORT4_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+
+#define    RTL8367C_REG_PORT4_FORCE_RATE0    0x0091
+
+#define    RTL8367C_REG_PORT4_FORCE_RATE1    0x0092
+
+#define    RTL8367C_REG_PORT4_CURENT_RATE0    0x0093
+
+#define    RTL8367C_REG_PORT4_CURENT_RATE1    0x0094
+
+#define    RTL8367C_REG_PORT4_PAGE_COUNTER    0x0095
+#define    RTL8367C_PORT4_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_PORT4_PAGE_COUNTER_MASK    0x7F
+
+#define    RTL8367C_REG_PAGEMETER_PORT4_CTRL0    0x0096
+
+#define    RTL8367C_REG_PAGEMETER_PORT4_CTRL1    0x0097
+
+#define    RTL8367C_REG_PORT4_EEECFG    0x0098
+#define    RTL8367C_PORT4_EEECFG_EEEP_ENABLE_TX_OFFSET    14
+#define    RTL8367C_PORT4_EEECFG_EEEP_ENABLE_TX_MASK    0x4000
+#define    RTL8367C_PORT4_EEECFG_EEEP_ENABLE_RX_OFFSET    13
+#define    RTL8367C_PORT4_EEECFG_EEEP_ENABLE_RX_MASK    0x2000
+#define    RTL8367C_PORT4_EEECFG_EEE_FORCE_OFFSET    12
+#define    RTL8367C_PORT4_EEECFG_EEE_FORCE_MASK    0x1000
+#define    RTL8367C_PORT4_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT4_EEECFG_EEE_100M_MASK    0x800
+#define    RTL8367C_PORT4_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT4_EEECFG_EEE_GIGA_500M_MASK    0x400
+#define    RTL8367C_PORT4_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT4_EEECFG_EEE_TX_MASK    0x200
+#define    RTL8367C_PORT4_EEECFG_EEE_RX_OFFSET    8
+#define    RTL8367C_PORT4_EEECFG_EEE_RX_MASK    0x100
+#define    RTL8367C_PORT4_EEECFG_EEE_DSP_RX_OFFSET    6
+#define    RTL8367C_PORT4_EEECFG_EEE_DSP_RX_MASK    0x40
+#define    RTL8367C_PORT4_EEECFG_EEE_LPI_OFFSET    5
+#define    RTL8367C_PORT4_EEECFG_EEE_LPI_MASK    0x20
+#define    RTL8367C_PORT4_EEECFG_EEE_TX_LPI_OFFSET    4
+#define    RTL8367C_PORT4_EEECFG_EEE_TX_LPI_MASK    0x10
+#define    RTL8367C_PORT4_EEECFG_EEE_RX_LPI_OFFSET    3
+#define    RTL8367C_PORT4_EEECFG_EEE_RX_LPI_MASK    0x8
+#define    RTL8367C_PORT4_EEECFG_EEE_PAUSE_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT4_EEECFG_EEE_PAUSE_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT4_EEECFG_EEE_WAKE_REQ_OFFSET    1
+#define    RTL8367C_PORT4_EEECFG_EEE_WAKE_REQ_MASK    0x2
+#define    RTL8367C_PORT4_EEECFG_EEE_SLEEP_REQ_OFFSET    0
+#define    RTL8367C_PORT4_EEECFG_EEE_SLEEP_REQ_MASK    0x1
+
+#define    RTL8367C_REG_PORT4_EEETXMTR    0x0099
+
+#define    RTL8367C_REG_PORT4_EEERXMTR    0x009a
+
+#define    RTL8367C_REG_PORT4_EEEPTXMTR    0x009b
+
+#define    RTL8367C_REG_PORT4_EEEPRXMTR    0x009c
+
+#define    RTL8367C_REG_PTP_PORT4_CFG1    0x009e
+#define    RTL8367C_PTP_PORT4_CFG1_OFFSET    7
+#define    RTL8367C_PTP_PORT4_CFG1_MASK    0xFF
+
+#define    RTL8367C_REG_P4_MSIC1    0x009f
+#define    RTL8367C_P4_MSIC1_OFFSET    0
+#define    RTL8367C_P4_MSIC1_MASK    0x1
+
+#define    RTL8367C_REG_PORT5_CGST_HALF_CFG    0x00a0
+#define    RTL8367C_PORT5_CGST_HALF_CFG_CONGESTION_TIME_OFFSET    4
+#define    RTL8367C_PORT5_CGST_HALF_CFG_CONGESTION_TIME_MASK    0xF0
+#define    RTL8367C_PORT5_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT5_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_PKTGEN_PORT5_CTRL    0x00a1
+#define    RTL8367C_PKTGEN_PORT5_CTRL_STATUS_OFFSET    15
+#define    RTL8367C_PKTGEN_PORT5_CTRL_STATUS_MASK    0x8000
+#define    RTL8367C_PKTGEN_PORT5_CTRL_PKTGEN_STS_OFFSET    13
+#define    RTL8367C_PKTGEN_PORT5_CTRL_PKTGEN_STS_MASK    0x2000
+#define    RTL8367C_PKTGEN_PORT5_CTRL_CRC_NO_ERROR_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT5_CTRL_CRC_NO_ERROR_MASK    0x10
+#define    RTL8367C_PKTGEN_PORT5_CTRL_CMD_START_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT5_CTRL_CMD_START_MASK    0x1
+
+#define    RTL8367C_REG_TX_ERR_CNT_PORT5    0x00a2
+#define    RTL8367C_TX_ERR_CNT_PORT5_OFFSET    0
+#define    RTL8367C_TX_ERR_CNT_PORT5_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_PORT5_DA0    0x00a3
+
+#define    RTL8367C_REG_PKTGEN_PORT5_DA1    0x00a4
+
+#define    RTL8367C_REG_PKTGEN_PORT5_DA2    0x00a5
+
+#define    RTL8367C_REG_PKTGEN_PORT5_SA0    0x00a6
+
+#define    RTL8367C_REG_PKTGEN_PORT5_SA1    0x00a7
+
+#define    RTL8367C_REG_PKTGEN_PORT5_SA2    0x00a8
+
+#define    RTL8367C_REG_PKTGEN_PORT5_COUNTER0    0x00a9
+
+#define    RTL8367C_REG_PKTGEN_PORT5_COUNTER1    0x00aa
+#define    RTL8367C_PKTGEN_PORT5_COUNTER1_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT5_COUNTER1_MASK    0xFF
+
+#define    RTL8367C_REG_PKTGEN_PORT5_TX_LENGTH    0x00ab
+#define    RTL8367C_PKTGEN_PORT5_TX_LENGTH_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT5_TX_LENGTH_MASK    0x3FFF
+
+#define    RTL8367C_REG_PKTGEN_PORT5_TIMER    0x00ad
+#define    RTL8367C_PKTGEN_PORT5_TIMER_TIMER_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT5_TIMER_TIMER_MASK    0xF0
+#define    RTL8367C_PKTGEN_PORT5_TIMER_RX_DMA_ERR_FLAG_OFFSET    3
+#define    RTL8367C_PKTGEN_PORT5_TIMER_RX_DMA_ERR_FLAG_MASK    0x8
+
+#define    RTL8367C_REG_PORT5_MISC_CFG    0x00ae
+#define    RTL8367C_PORT5_MISC_CFG_SMALL_TAG_IPG_OFFSET    15
+#define    RTL8367C_PORT5_MISC_CFG_SMALL_TAG_IPG_MASK    0x8000
+#define    RTL8367C_PORT5_MISC_CFG_TX_ITFSP_MODE_OFFSET    14
+#define    RTL8367C_PORT5_MISC_CFG_TX_ITFSP_MODE_MASK    0x4000
+#define    RTL8367C_PORT5_MISC_CFG_FLOWCTRL_INDEP_OFFSET    13
+#define    RTL8367C_PORT5_MISC_CFG_FLOWCTRL_INDEP_MASK    0x2000
+#define    RTL8367C_PORT5_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET    12
+#define    RTL8367C_PORT5_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK    0x1000
+#define    RTL8367C_PORT5_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+#define    RTL8367C_PORT5_MISC_CFG_INGRESSBW_FLOWCTRL_MASK    0x800
+#define    RTL8367C_PORT5_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT5_MISC_CFG_INGRESSBW_IFG_MASK    0x400
+#define    RTL8367C_PORT5_MISC_CFG_RX_SPC_OFFSET    9
+#define    RTL8367C_PORT5_MISC_CFG_RX_SPC_MASK    0x200
+#define    RTL8367C_PORT5_MISC_CFG_CRC_SKIP_OFFSET    8
+#define    RTL8367C_PORT5_MISC_CFG_CRC_SKIP_MASK    0x100
+#define    RTL8367C_PORT5_MISC_CFG_PKTGEN_TX_FIRST_OFFSET    7
+#define    RTL8367C_PORT5_MISC_CFG_PKTGEN_TX_FIRST_MASK    0x80
+#define    RTL8367C_PORT5_MISC_CFG_MAC_LOOPBACK_OFFSET    6
+#define    RTL8367C_PORT5_MISC_CFG_MAC_LOOPBACK_MASK    0x40
+#define    RTL8367C_PORT5_MISC_CFG_VLAN_EGRESS_MODE_OFFSET    4
+#define    RTL8367C_PORT5_MISC_CFG_VLAN_EGRESS_MODE_MASK    0x30
+#define    RTL8367C_PORT5_MISC_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT5_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_INGRESSBW_PORT5_RATE_CTRL0    0x00af
+
+#define    RTL8367C_REG_INGRESSBW_PORT5_RATE_CTRL1    0x00b0
+#define    RTL8367C_INGRESSBW_PORT5_RATE_CTRL1_DUMMY_OFFSET    3
+#define    RTL8367C_INGRESSBW_PORT5_RATE_CTRL1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_INGRESSBW_PORT5_RATE_CTRL1_INGRESSBW_RATE16_OFFSET    0
+#define    RTL8367C_INGRESSBW_PORT5_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+
+#define    RTL8367C_REG_PORT5_FORCE_RATE0    0x00b1
+
+#define    RTL8367C_REG_PORT5_FORCE_RATE1    0x00b2
+
+#define    RTL8367C_REG_PORT5_CURENT_RATE0    0x00b3
+
+#define    RTL8367C_REG_PORT5_CURENT_RATE1    0x00b4
+
+#define    RTL8367C_REG_PORT5_PAGE_COUNTER    0x00b5
+#define    RTL8367C_PORT5_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_PORT5_PAGE_COUNTER_MASK    0x7F
+
+#define    RTL8367C_REG_PAGEMETER_PORT5_CTRL0    0x00b6
+
+#define    RTL8367C_REG_PAGEMETER_PORT5_CTRL1    0x00b7
+
+#define    RTL8367C_REG_PORT5_EEECFG    0x00b8
+#define    RTL8367C_PORT5_EEECFG_EEEP_ENABLE_TX_OFFSET    14
+#define    RTL8367C_PORT5_EEECFG_EEEP_ENABLE_TX_MASK    0x4000
+#define    RTL8367C_PORT5_EEECFG_EEEP_ENABLE_RX_OFFSET    13
+#define    RTL8367C_PORT5_EEECFG_EEEP_ENABLE_RX_MASK    0x2000
+#define    RTL8367C_PORT5_EEECFG_EEE_FORCE_OFFSET    12
+#define    RTL8367C_PORT5_EEECFG_EEE_FORCE_MASK    0x1000
+#define    RTL8367C_PORT5_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT5_EEECFG_EEE_100M_MASK    0x800
+#define    RTL8367C_PORT5_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT5_EEECFG_EEE_GIGA_500M_MASK    0x400
+#define    RTL8367C_PORT5_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT5_EEECFG_EEE_TX_MASK    0x200
+#define    RTL8367C_PORT5_EEECFG_EEE_RX_OFFSET    8
+#define    RTL8367C_PORT5_EEECFG_EEE_RX_MASK    0x100
+#define    RTL8367C_PORT5_EEECFG_EEE_DSP_RX_OFFSET    6
+#define    RTL8367C_PORT5_EEECFG_EEE_DSP_RX_MASK    0x40
+#define    RTL8367C_PORT5_EEECFG_EEE_LPI_OFFSET    5
+#define    RTL8367C_PORT5_EEECFG_EEE_LPI_MASK    0x20
+#define    RTL8367C_PORT5_EEECFG_EEE_TX_LPI_OFFSET    4
+#define    RTL8367C_PORT5_EEECFG_EEE_TX_LPI_MASK    0x10
+#define    RTL8367C_PORT5_EEECFG_EEE_RX_LPI_OFFSET    3
+#define    RTL8367C_PORT5_EEECFG_EEE_RX_LPI_MASK    0x8
+#define    RTL8367C_PORT5_EEECFG_EEE_PAUSE_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT5_EEECFG_EEE_PAUSE_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT5_EEECFG_EEE_WAKE_REQ_OFFSET    1
+#define    RTL8367C_PORT5_EEECFG_EEE_WAKE_REQ_MASK    0x2
+#define    RTL8367C_PORT5_EEECFG_EEE_SLEEP_REQ_OFFSET    0
+#define    RTL8367C_PORT5_EEECFG_EEE_SLEEP_REQ_MASK    0x1
+
+#define    RTL8367C_REG_PORT5_EEETXMTR    0x00b9
+
+#define    RTL8367C_REG_PORT5_EEERXMTR    0x00ba
+
+#define    RTL8367C_REG_PORT5_EEEPTXMTR    0x00bb
+
+#define    RTL8367C_REG_PORT5_EEEPRXMTR    0x00bc
+
+#define    RTL8367C_REG_PTP_PORT5_CFG1    0x00be
+#define    RTL8367C_PTP_PORT5_CFG1_OFFSET    7
+#define    RTL8367C_PTP_PORT5_CFG1_MASK    0xFF
+
+#define    RTL8367C_REG_P5_MSIC1    0x00bf
+#define    RTL8367C_P5_MSIC1_OFFSET    0
+#define    RTL8367C_P5_MSIC1_MASK    0x1
+
+#define    RTL8367C_REG_PORT6_CGST_HALF_CFG    0x00c0
+#define    RTL8367C_PORT6_CGST_HALF_CFG_CONGESTION_TIME_OFFSET    4
+#define    RTL8367C_PORT6_CGST_HALF_CFG_CONGESTION_TIME_MASK    0xF0
+#define    RTL8367C_PORT6_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT6_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_PKTGEN_PORT6_CTRL    0x00c1
+#define    RTL8367C_PKTGEN_PORT6_CTRL_STATUS_OFFSET    15
+#define    RTL8367C_PKTGEN_PORT6_CTRL_STATUS_MASK    0x8000
+#define    RTL8367C_PKTGEN_PORT6_CTRL_PKTGEN_STS_OFFSET    13
+#define    RTL8367C_PKTGEN_PORT6_CTRL_PKTGEN_STS_MASK    0x2000
+#define    RTL8367C_PKTGEN_PORT6_CTRL_CRC_NO_ERROR_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT6_CTRL_CRC_NO_ERROR_MASK    0x10
+#define    RTL8367C_PKTGEN_PORT6_CTRL_CMD_START_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT6_CTRL_CMD_START_MASK    0x1
+
+#define    RTL8367C_REG_TX_ERR_CNT_PORT6    0x00c2
+#define    RTL8367C_TX_ERR_CNT_PORT6_OFFSET    0
+#define    RTL8367C_TX_ERR_CNT_PORT6_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_PORT6_DA0    0x00c3
+
+#define    RTL8367C_REG_PKTGEN_PORT6_DA1    0x00c4
+
+#define    RTL8367C_REG_PKTGEN_PORT6_DA2    0x00c5
+
+#define    RTL8367C_REG_PKTGEN_PORT6_SA0    0x00c6
+
+#define    RTL8367C_REG_PKTGEN_PORT6_SA1    0x00c7
+
+#define    RTL8367C_REG_PKTGEN_PORT6_SA2    0x00c8
+
+#define    RTL8367C_REG_PKTGEN_PORT6_COUNTER0    0x00c9
+
+#define    RTL8367C_REG_PKTGEN_PORT6_COUNTER1    0x00ca
+#define    RTL8367C_PKTGEN_PORT6_COUNTER1_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT6_COUNTER1_MASK    0xFF
+
+#define    RTL8367C_REG_PKTGEN_PORT6_TX_LENGTH    0x00cb
+#define    RTL8367C_PKTGEN_PORT6_TX_LENGTH_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT6_TX_LENGTH_MASK    0x3FFF
+
+#define    RTL8367C_REG_PKTGEN_PORT6_TIMER    0x00cd
+#define    RTL8367C_PKTGEN_PORT6_TIMER_TIMER_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT6_TIMER_TIMER_MASK    0xF0
+#define    RTL8367C_PKTGEN_PORT6_TIMER_RX_DMA_ERR_FLAG_OFFSET    3
+#define    RTL8367C_PKTGEN_PORT6_TIMER_RX_DMA_ERR_FLAG_MASK    0x8
+
+#define    RTL8367C_REG_PORT6_MISC_CFG    0x00ce
+#define    RTL8367C_PORT6_MISC_CFG_SMALL_TAG_IPG_OFFSET    15
+#define    RTL8367C_PORT6_MISC_CFG_SMALL_TAG_IPG_MASK    0x8000
+#define    RTL8367C_PORT6_MISC_CFG_TX_ITFSP_MODE_OFFSET    14
+#define    RTL8367C_PORT6_MISC_CFG_TX_ITFSP_MODE_MASK    0x4000
+#define    RTL8367C_PORT6_MISC_CFG_FLOWCTRL_INDEP_OFFSET    13
+#define    RTL8367C_PORT6_MISC_CFG_FLOWCTRL_INDEP_MASK    0x2000
+#define    RTL8367C_PORT6_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET    12
+#define    RTL8367C_PORT6_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK    0x1000
+#define    RTL8367C_PORT6_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+#define    RTL8367C_PORT6_MISC_CFG_INGRESSBW_FLOWCTRL_MASK    0x800
+#define    RTL8367C_PORT6_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT6_MISC_CFG_INGRESSBW_IFG_MASK    0x400
+#define    RTL8367C_PORT6_MISC_CFG_RX_SPC_OFFSET    9
+#define    RTL8367C_PORT6_MISC_CFG_RX_SPC_MASK    0x200
+#define    RTL8367C_PORT6_MISC_CFG_CRC_SKIP_OFFSET    8
+#define    RTL8367C_PORT6_MISC_CFG_CRC_SKIP_MASK    0x100
+#define    RTL8367C_PORT6_MISC_CFG_PKTGEN_TX_FIRST_OFFSET    7
+#define    RTL8367C_PORT6_MISC_CFG_PKTGEN_TX_FIRST_MASK    0x80
+#define    RTL8367C_PORT6_MISC_CFG_MAC_LOOPBACK_OFFSET    6
+#define    RTL8367C_PORT6_MISC_CFG_MAC_LOOPBACK_MASK    0x40
+#define    RTL8367C_PORT6_MISC_CFG_VLAN_EGRESS_MODE_OFFSET    4
+#define    RTL8367C_PORT6_MISC_CFG_VLAN_EGRESS_MODE_MASK    0x30
+#define    RTL8367C_PORT6_MISC_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT6_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_INGRESSBW_PORT6_RATE_CTRL0    0x00cf
+
+#define    RTL8367C_REG_INGRESSBW_PORT6_RATE_CTRL1    0x00d0
+#define    RTL8367C_INGRESSBW_PORT6_RATE_CTRL1_DUMMY_OFFSET    3
+#define    RTL8367C_INGRESSBW_PORT6_RATE_CTRL1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_INGRESSBW_PORT6_RATE_CTRL1_INGRESSBW_RATE16_OFFSET    0
+#define    RTL8367C_INGRESSBW_PORT6_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+
+#define    RTL8367C_REG_PORT6_FORCE_RATE0    0x00d1
+
+#define    RTL8367C_REG_PORT6_FORCE_RATE1    0x00d2
+
+#define    RTL8367C_REG_PORT6_CURENT_RATE0    0x00d3
+
+#define    RTL8367C_REG_PORT6_CURENT_RATE1    0x00d4
+
+#define    RTL8367C_REG_PORT6_PAGE_COUNTER    0x00d5
+#define    RTL8367C_PORT6_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_PORT6_PAGE_COUNTER_MASK    0x7F
+
+#define    RTL8367C_REG_PAGEMETER_PORT6_CTRL0    0x00d6
+
+#define    RTL8367C_REG_PAGEMETER_PORT6_CTRL1    0x00d7
+
+#define    RTL8367C_REG_PORT6_EEECFG    0x00d8
+#define    RTL8367C_PORT6_EEECFG_EEEP_ENABLE_TX_OFFSET    14
+#define    RTL8367C_PORT6_EEECFG_EEEP_ENABLE_TX_MASK    0x4000
+#define    RTL8367C_PORT6_EEECFG_EEEP_ENABLE_RX_OFFSET    13
+#define    RTL8367C_PORT6_EEECFG_EEEP_ENABLE_RX_MASK    0x2000
+#define    RTL8367C_PORT6_EEECFG_EEE_FORCE_OFFSET    12
+#define    RTL8367C_PORT6_EEECFG_EEE_FORCE_MASK    0x1000
+#define    RTL8367C_PORT6_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT6_EEECFG_EEE_100M_MASK    0x800
+#define    RTL8367C_PORT6_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT6_EEECFG_EEE_GIGA_500M_MASK    0x400
+#define    RTL8367C_PORT6_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT6_EEECFG_EEE_TX_MASK    0x200
+#define    RTL8367C_PORT6_EEECFG_EEE_RX_OFFSET    8
+#define    RTL8367C_PORT6_EEECFG_EEE_RX_MASK    0x100
+#define    RTL8367C_PORT6_EEECFG_EEE_DSP_RX_OFFSET    6
+#define    RTL8367C_PORT6_EEECFG_EEE_DSP_RX_MASK    0x40
+#define    RTL8367C_PORT6_EEECFG_EEE_LPI_OFFSET    5
+#define    RTL8367C_PORT6_EEECFG_EEE_LPI_MASK    0x20
+#define    RTL8367C_PORT6_EEECFG_EEE_TX_LPI_OFFSET    4
+#define    RTL8367C_PORT6_EEECFG_EEE_TX_LPI_MASK    0x10
+#define    RTL8367C_PORT6_EEECFG_EEE_RX_LPI_OFFSET    3
+#define    RTL8367C_PORT6_EEECFG_EEE_RX_LPI_MASK    0x8
+#define    RTL8367C_PORT6_EEECFG_EEE_PAUSE_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT6_EEECFG_EEE_PAUSE_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT6_EEECFG_EEE_WAKE_REQ_OFFSET    1
+#define    RTL8367C_PORT6_EEECFG_EEE_WAKE_REQ_MASK    0x2
+#define    RTL8367C_PORT6_EEECFG_EEE_SLEEP_REQ_OFFSET    0
+#define    RTL8367C_PORT6_EEECFG_EEE_SLEEP_REQ_MASK    0x1
+
+#define    RTL8367C_REG_PORT6_EEETXMTR    0x00d9
+
+#define    RTL8367C_REG_PORT6_EEERXMTR    0x00da
+
+#define    RTL8367C_REG_PORT6_EEEPTXMTR    0x00db
+
+#define    RTL8367C_REG_PORT6_EEEPRXMTR    0x00dc
+
+#define    RTL8367C_REG_PTP_PORT6_CFG1    0x00de
+#define    RTL8367C_PTP_PORT6_CFG1_OFFSET    7
+#define    RTL8367C_PTP_PORT6_CFG1_MASK    0xFF
+
+#define    RTL8367C_REG_P6_MSIC1    0x00df
+#define    RTL8367C_P6_MSIC1_OFFSET    0
+#define    RTL8367C_P6_MSIC1_MASK    0x1
+
+#define    RTL8367C_REG_PORT7_CGST_HALF_CFG    0x00e0
+#define    RTL8367C_PORT7_CGST_HALF_CFG_CONGESTION_TIME_OFFSET    4
+#define    RTL8367C_PORT7_CGST_HALF_CFG_CONGESTION_TIME_MASK    0xF0
+#define    RTL8367C_PORT7_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT7_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_PKTGEN_PORT7_CTRL    0x00e1
+#define    RTL8367C_PKTGEN_PORT7_CTRL_STATUS_OFFSET    15
+#define    RTL8367C_PKTGEN_PORT7_CTRL_STATUS_MASK    0x8000
+#define    RTL8367C_PKTGEN_PORT7_CTRL_PKTGEN_STS_OFFSET    13
+#define    RTL8367C_PKTGEN_PORT7_CTRL_PKTGEN_STS_MASK    0x2000
+#define    RTL8367C_PKTGEN_PORT7_CTRL_CRC_NO_ERROR_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT7_CTRL_CRC_NO_ERROR_MASK    0x10
+#define    RTL8367C_PKTGEN_PORT7_CTRL_CMD_START_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT7_CTRL_CMD_START_MASK    0x1
+
+#define    RTL8367C_REG_TX_ERR_CNT_PORT7    0x00e2
+#define    RTL8367C_TX_ERR_CNT_PORT7_OFFSET    0
+#define    RTL8367C_TX_ERR_CNT_PORT7_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_PORT7_DA0    0x00e3
+
+#define    RTL8367C_REG_PKTGEN_PORT7_DA1    0x00e4
+
+#define    RTL8367C_REG_PKTGEN_PORT7_DA2    0x00e5
+
+#define    RTL8367C_REG_PKTGEN_PORT7_SA0    0x00e6
+
+#define    RTL8367C_REG_PKTGEN_PORT7_SA1    0x00e7
+
+#define    RTL8367C_REG_PKTGEN_PORT7_SA2    0x00e8
+
+#define    RTL8367C_REG_PKTGEN_PORT7_COUNTER0    0x00e9
+
+#define    RTL8367C_REG_PKTGEN_PORT7_COUNTER1    0x00ea
+#define    RTL8367C_PKTGEN_PORT7_COUNTER1_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT7_COUNTER1_MASK    0xFF
+
+#define    RTL8367C_REG_PKTGEN_PORT7_TX_LENGTH    0x00eb
+#define    RTL8367C_PKTGEN_PORT7_TX_LENGTH_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT7_TX_LENGTH_MASK    0x3FFF
+
+#define    RTL8367C_REG_PKTGEN_PORT7_TIMER    0x00ed
+#define    RTL8367C_PKTGEN_PORT7_TIMER_TIMER_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT7_TIMER_TIMER_MASK    0xF0
+#define    RTL8367C_PKTGEN_PORT7_TIMER_RX_DMA_ERR_FLAG_OFFSET    3
+#define    RTL8367C_PKTGEN_PORT7_TIMER_RX_DMA_ERR_FLAG_MASK    0x8
+
+#define    RTL8367C_REG_PORT7_MISC_CFG    0x00ee
+#define    RTL8367C_PORT7_MISC_CFG_SMALL_TAG_IPG_OFFSET    15
+#define    RTL8367C_PORT7_MISC_CFG_SMALL_TAG_IPG_MASK    0x8000
+#define    RTL8367C_PORT7_MISC_CFG_TX_ITFSP_MODE_OFFSET    14
+#define    RTL8367C_PORT7_MISC_CFG_TX_ITFSP_MODE_MASK    0x4000
+#define    RTL8367C_PORT7_MISC_CFG_FLOWCTRL_INDEP_OFFSET    13
+#define    RTL8367C_PORT7_MISC_CFG_FLOWCTRL_INDEP_MASK    0x2000
+#define    RTL8367C_PORT7_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET    12
+#define    RTL8367C_PORT7_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK    0x1000
+#define    RTL8367C_PORT7_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+#define    RTL8367C_PORT7_MISC_CFG_INGRESSBW_FLOWCTRL_MASK    0x800
+#define    RTL8367C_PORT7_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT7_MISC_CFG_INGRESSBW_IFG_MASK    0x400
+#define    RTL8367C_PORT7_MISC_CFG_RX_SPC_OFFSET    9
+#define    RTL8367C_PORT7_MISC_CFG_RX_SPC_MASK    0x200
+#define    RTL8367C_PORT7_MISC_CFG_CRC_SKIP_OFFSET    8
+#define    RTL8367C_PORT7_MISC_CFG_CRC_SKIP_MASK    0x100
+#define    RTL8367C_PORT7_MISC_CFG_PKTGEN_TX_FIRST_OFFSET    7
+#define    RTL8367C_PORT7_MISC_CFG_PKTGEN_TX_FIRST_MASK    0x80
+#define    RTL8367C_PORT7_MISC_CFG_MAC_LOOPBACK_OFFSET    6
+#define    RTL8367C_PORT7_MISC_CFG_MAC_LOOPBACK_MASK    0x40
+#define    RTL8367C_PORT7_MISC_CFG_VLAN_EGRESS_MODE_OFFSET    4
+#define    RTL8367C_PORT7_MISC_CFG_VLAN_EGRESS_MODE_MASK    0x30
+#define    RTL8367C_PORT7_MISC_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT7_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_INGRESSBW_PORT7_RATE_CTRL0    0x00ef
+
+#define    RTL8367C_REG_INGRESSBW_PORT7_RATE_CTRL1    0x00f0
+#define    RTL8367C_INGRESSBW_PORT7_RATE_CTRL1_DUMMY_OFFSET    3
+#define    RTL8367C_INGRESSBW_PORT7_RATE_CTRL1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_INGRESSBW_PORT7_RATE_CTRL1_INGRESSBW_RATE16_OFFSET    0
+#define    RTL8367C_INGRESSBW_PORT7_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+
+#define    RTL8367C_REG_PORT7_FORCE_RATE0    0x00f1
+
+#define    RTL8367C_REG_PORT7_FORCE_RATE1    0x00f2
+
+#define    RTL8367C_REG_PORT7_CURENT_RATE0    0x00f3
+
+#define    RTL8367C_REG_PORT7_CURENT_RATE1    0x00f4
+
+#define    RTL8367C_REG_PORT7_PAGE_COUNTER    0x00f5
+#define    RTL8367C_PORT7_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_PORT7_PAGE_COUNTER_MASK    0x7F
+
+#define    RTL8367C_REG_PAGEMETER_PORT7_CTRL0    0x00f6
+
+#define    RTL8367C_REG_PAGEMETER_PORT7_CTRL1    0x00f7
+
+#define    RTL8367C_REG_PORT7_EEECFG    0x00f8
+#define    RTL8367C_PORT7_EEECFG_EEEP_ENABLE_TX_OFFSET    14
+#define    RTL8367C_PORT7_EEECFG_EEEP_ENABLE_TX_MASK    0x4000
+#define    RTL8367C_PORT7_EEECFG_EEEP_ENABLE_RX_OFFSET    13
+#define    RTL8367C_PORT7_EEECFG_EEEP_ENABLE_RX_MASK    0x2000
+#define    RTL8367C_PORT7_EEECFG_EEE_FORCE_OFFSET    12
+#define    RTL8367C_PORT7_EEECFG_EEE_FORCE_MASK    0x1000
+#define    RTL8367C_PORT7_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT7_EEECFG_EEE_100M_MASK    0x800
+#define    RTL8367C_PORT7_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT7_EEECFG_EEE_GIGA_500M_MASK    0x400
+#define    RTL8367C_PORT7_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT7_EEECFG_EEE_TX_MASK    0x200
+#define    RTL8367C_PORT7_EEECFG_EEE_RX_OFFSET    8
+#define    RTL8367C_PORT7_EEECFG_EEE_RX_MASK    0x100
+#define    RTL8367C_PORT7_EEECFG_EEE_DSP_RX_OFFSET    6
+#define    RTL8367C_PORT7_EEECFG_EEE_DSP_RX_MASK    0x40
+#define    RTL8367C_PORT7_EEECFG_EEE_LPI_OFFSET    5
+#define    RTL8367C_PORT7_EEECFG_EEE_LPI_MASK    0x20
+#define    RTL8367C_PORT7_EEECFG_EEE_TX_LPI_OFFSET    4
+#define    RTL8367C_PORT7_EEECFG_EEE_TX_LPI_MASK    0x10
+#define    RTL8367C_PORT7_EEECFG_EEE_RX_LPI_OFFSET    3
+#define    RTL8367C_PORT7_EEECFG_EEE_RX_LPI_MASK    0x8
+#define    RTL8367C_PORT7_EEECFG_EEE_PAUSE_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT7_EEECFG_EEE_PAUSE_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT7_EEECFG_EEE_WAKE_REQ_OFFSET    1
+#define    RTL8367C_PORT7_EEECFG_EEE_WAKE_REQ_MASK    0x2
+#define    RTL8367C_PORT7_EEECFG_EEE_SLEEP_REQ_OFFSET    0
+#define    RTL8367C_PORT7_EEECFG_EEE_SLEEP_REQ_MASK    0x1
+
+#define    RTL8367C_REG_PORT7_EEETXMTR    0x00f9
+
+#define    RTL8367C_REG_PORT7_EEERXMTR    0x00fa
+
+#define    RTL8367C_REG_PORT7_EEEPTXMTR    0x00fb
+
+#define    RTL8367C_REG_PORT7_EEEPRXMTR    0x00fc
+
+#define    RTL8367C_REG_PTP_PORT7_CFG1    0x00fe
+#define    RTL8367C_PTP_PORT7_CFG1_OFFSET    7
+#define    RTL8367C_PTP_PORT7_CFG1_MASK    0xFF
+
+#define    RTL8367C_REG_P7_MSIC1    0x00ff
+#define    RTL8367C_P7_MSIC1_OFFSET    0
+#define    RTL8367C_P7_MSIC1_MASK    0x1
+
+#define    RTL8367C_REG_PORT8_CGST_HALF_CFG    0x0100
+#define    RTL8367C_PORT8_CGST_HALF_CFG_CONGESTION_TIME_OFFSET    4
+#define    RTL8367C_PORT8_CGST_HALF_CFG_CONGESTION_TIME_MASK    0xF0
+#define    RTL8367C_PORT8_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT8_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_PKTGEN_PORT8_CTRL    0x0101
+#define    RTL8367C_PKTGEN_PORT8_CTRL_STATUS_OFFSET    15
+#define    RTL8367C_PKTGEN_PORT8_CTRL_STATUS_MASK    0x8000
+#define    RTL8367C_PKTGEN_PORT8_CTRL_PKTGEN_STS_OFFSET    13
+#define    RTL8367C_PKTGEN_PORT8_CTRL_PKTGEN_STS_MASK    0x2000
+#define    RTL8367C_PKTGEN_PORT8_CTRL_CRC_NO_ERROR_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT8_CTRL_CRC_NO_ERROR_MASK    0x10
+#define    RTL8367C_PKTGEN_PORT8_CTRL_CMD_START_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT8_CTRL_CMD_START_MASK    0x1
+
+#define    RTL8367C_REG_TX_ERR_CNT_PORT8    0x0102
+#define    RTL8367C_TX_ERR_CNT_PORT8_OFFSET    0
+#define    RTL8367C_TX_ERR_CNT_PORT8_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_PORT8_DA0    0x0103
+
+#define    RTL8367C_REG_PKTGEN_PORT8_DA1    0x0104
+
+#define    RTL8367C_REG_PKTGEN_PORT8_DA2    0x0105
+
+#define    RTL8367C_REG_PKTGEN_PORT8_SA0    0x0106
+
+#define    RTL8367C_REG_PKTGEN_PORT8_SA1    0x0107
+
+#define    RTL8367C_REG_PKTGEN_PORT8_SA2    0x0108
+
+#define    RTL8367C_REG_PKTGEN_PORT8_COUNTER0    0x0109
+
+#define    RTL8367C_REG_PKTGEN_PORT8_COUNTER1    0x010a
+#define    RTL8367C_PKTGEN_PORT8_COUNTER1_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT8_COUNTER1_MASK    0xFF
+
+#define    RTL8367C_REG_PKTGEN_PORT8_TX_LENGTH    0x010b
+#define    RTL8367C_PKTGEN_PORT8_TX_LENGTH_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT8_TX_LENGTH_MASK    0x3FFF
+
+#define    RTL8367C_REG_PKTGEN_PORT8_TIMER    0x010d
+#define    RTL8367C_PKTGEN_PORT8_TIMER_TIMER_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT8_TIMER_TIMER_MASK    0xF0
+#define    RTL8367C_PKTGEN_PORT8_TIMER_RX_DMA_ERR_FLAG_OFFSET    3
+#define    RTL8367C_PKTGEN_PORT8_TIMER_RX_DMA_ERR_FLAG_MASK    0x8
+
+#define    RTL8367C_REG_PORT8_MISC_CFG    0x010e
+#define    RTL8367C_PORT8_MISC_CFG_SMALL_TAG_IPG_OFFSET    15
+#define    RTL8367C_PORT8_MISC_CFG_SMALL_TAG_IPG_MASK    0x8000
+#define    RTL8367C_PORT8_MISC_CFG_TX_ITFSP_MODE_OFFSET    14
+#define    RTL8367C_PORT8_MISC_CFG_TX_ITFSP_MODE_MASK    0x4000
+#define    RTL8367C_PORT8_MISC_CFG_FLOWCTRL_INDEP_OFFSET    13
+#define    RTL8367C_PORT8_MISC_CFG_FLOWCTRL_INDEP_MASK    0x2000
+#define    RTL8367C_PORT8_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET    12
+#define    RTL8367C_PORT8_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK    0x1000
+#define    RTL8367C_PORT8_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+#define    RTL8367C_PORT8_MISC_CFG_INGRESSBW_FLOWCTRL_MASK    0x800
+#define    RTL8367C_PORT8_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT8_MISC_CFG_INGRESSBW_IFG_MASK    0x400
+#define    RTL8367C_PORT8_MISC_CFG_RX_SPC_OFFSET    9
+#define    RTL8367C_PORT8_MISC_CFG_RX_SPC_MASK    0x200
+#define    RTL8367C_PORT8_MISC_CFG_CRC_SKIP_OFFSET    8
+#define    RTL8367C_PORT8_MISC_CFG_CRC_SKIP_MASK    0x100
+#define    RTL8367C_PORT8_MISC_CFG_PKTGEN_TX_FIRST_OFFSET    7
+#define    RTL8367C_PORT8_MISC_CFG_PKTGEN_TX_FIRST_MASK    0x80
+#define    RTL8367C_PORT8_MISC_CFG_MAC_LOOPBACK_OFFSET    6
+#define    RTL8367C_PORT8_MISC_CFG_MAC_LOOPBACK_MASK    0x40
+#define    RTL8367C_PORT8_MISC_CFG_VLAN_EGRESS_MODE_OFFSET    4
+#define    RTL8367C_PORT8_MISC_CFG_VLAN_EGRESS_MODE_MASK    0x30
+#define    RTL8367C_PORT8_MISC_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT8_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_INGRESSBW_PORT8_RATE_CTRL0    0x010f
+
+#define    RTL8367C_REG_INGRESSBW_PORT8_RATE_CTRL1    0x0110
+#define    RTL8367C_INGRESSBW_PORT8_RATE_CTRL1_DUMMY_OFFSET    3
+#define    RTL8367C_INGRESSBW_PORT8_RATE_CTRL1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_INGRESSBW_PORT8_RATE_CTRL1_INGRESSBW_RATE16_OFFSET    0
+#define    RTL8367C_INGRESSBW_PORT8_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+
+#define    RTL8367C_REG_PORT8_FORCE_RATE0    0x0111
+
+#define    RTL8367C_REG_PORT8_FORCE_RATE1    0x0112
+
+#define    RTL8367C_REG_PORT8_CURENT_RATE0    0x0113
+
+#define    RTL8367C_REG_PORT8_CURENT_RATE1    0x0114
+
+#define    RTL8367C_REG_PORT8_PAGE_COUNTER    0x0115
+#define    RTL8367C_PORT8_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_PORT8_PAGE_COUNTER_MASK    0x7F
+
+#define    RTL8367C_REG_PAGEMETER_PORT8_CTRL0    0x0116
+
+#define    RTL8367C_REG_PAGEMETER_PORT8_CTRL1    0x0117
+
+#define    RTL8367C_REG_PORT8_EEECFG    0x0118
+#define    RTL8367C_PORT8_EEECFG_EEEP_ENABLE_TX_OFFSET    14
+#define    RTL8367C_PORT8_EEECFG_EEEP_ENABLE_TX_MASK    0x4000
+#define    RTL8367C_PORT8_EEECFG_EEEP_ENABLE_RX_OFFSET    13
+#define    RTL8367C_PORT8_EEECFG_EEEP_ENABLE_RX_MASK    0x2000
+#define    RTL8367C_PORT8_EEECFG_EEE_FORCE_OFFSET    12
+#define    RTL8367C_PORT8_EEECFG_EEE_FORCE_MASK    0x1000
+#define    RTL8367C_PORT8_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT8_EEECFG_EEE_100M_MASK    0x800
+#define    RTL8367C_PORT8_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT8_EEECFG_EEE_GIGA_500M_MASK    0x400
+#define    RTL8367C_PORT8_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT8_EEECFG_EEE_TX_MASK    0x200
+#define    RTL8367C_PORT8_EEECFG_EEE_RX_OFFSET    8
+#define    RTL8367C_PORT8_EEECFG_EEE_RX_MASK    0x100
+#define    RTL8367C_PORT8_EEECFG_EEE_DSP_RX_OFFSET    6
+#define    RTL8367C_PORT8_EEECFG_EEE_DSP_RX_MASK    0x40
+#define    RTL8367C_PORT8_EEECFG_EEE_LPI_OFFSET    5
+#define    RTL8367C_PORT8_EEECFG_EEE_LPI_MASK    0x20
+#define    RTL8367C_PORT8_EEECFG_EEE_TX_LPI_OFFSET    4
+#define    RTL8367C_PORT8_EEECFG_EEE_TX_LPI_MASK    0x10
+#define    RTL8367C_PORT8_EEECFG_EEE_RX_LPI_OFFSET    3
+#define    RTL8367C_PORT8_EEECFG_EEE_RX_LPI_MASK    0x8
+#define    RTL8367C_PORT8_EEECFG_EEE_PAUSE_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT8_EEECFG_EEE_PAUSE_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT8_EEECFG_EEE_WAKE_REQ_OFFSET    1
+#define    RTL8367C_PORT8_EEECFG_EEE_WAKE_REQ_MASK    0x2
+#define    RTL8367C_PORT8_EEECFG_EEE_SLEEP_REQ_OFFSET    0
+#define    RTL8367C_PORT8_EEECFG_EEE_SLEEP_REQ_MASK    0x1
+
+#define    RTL8367C_REG_PORT8_EEETXMTR    0x0119
+
+#define    RTL8367C_REG_PORT8_EEERXMTR    0x011a
+
+#define    RTL8367C_REG_PORT8_EEEPTXMTR    0x011b
+
+#define    RTL8367C_REG_PORT8_EEEPRXMTR    0x011c
+
+#define    RTL8367C_REG_PTP_PORT8_CFG1    0x011e
+#define    RTL8367C_PTP_PORT8_CFG1_OFFSET    7
+#define    RTL8367C_PTP_PORT8_CFG1_MASK    0xFF
+
+#define    RTL8367C_REG_P8_MSIC1    0x011f
+#define    RTL8367C_P8_MSIC1_OFFSET    0
+#define    RTL8367C_P8_MSIC1_MASK    0x1
+
+#define    RTL8367C_REG_PORT9_CGST_HALF_CFG    0x0120
+#define    RTL8367C_PORT9_CGST_HALF_CFG_CONGESTION_TIME_OFFSET    4
+#define    RTL8367C_PORT9_CGST_HALF_CFG_CONGESTION_TIME_MASK    0xF0
+#define    RTL8367C_PORT9_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT9_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_PKTGEN_PORT9_CTRL    0x0121
+#define    RTL8367C_PKTGEN_PORT9_CTRL_STATUS_OFFSET    15
+#define    RTL8367C_PKTGEN_PORT9_CTRL_STATUS_MASK    0x8000
+#define    RTL8367C_PKTGEN_PORT9_CTRL_PKTGEN_STS_OFFSET    13
+#define    RTL8367C_PKTGEN_PORT9_CTRL_PKTGEN_STS_MASK    0x2000
+#define    RTL8367C_PKTGEN_PORT9_CTRL_CRC_NO_ERROR_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT9_CTRL_CRC_NO_ERROR_MASK    0x10
+#define    RTL8367C_PKTGEN_PORT9_CTRL_CMD_START_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT9_CTRL_CMD_START_MASK    0x1
+
+#define    RTL8367C_REG_TX_ERR_CNT_PORT9    0x0122
+#define    RTL8367C_TX_ERR_CNT_PORT9_OFFSET    0
+#define    RTL8367C_TX_ERR_CNT_PORT9_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_PORT9_DA0    0x0123
+
+#define    RTL8367C_REG_PKTGEN_PORT9_DA1    0x0124
+
+#define    RTL8367C_REG_PKTGEN_PORT9_DA2    0x0125
+
+#define    RTL8367C_REG_PKTGEN_PORT9_SA0    0x0126
+
+#define    RTL8367C_REG_PKTGEN_PORT9_SA1    0x0127
+
+#define    RTL8367C_REG_PKTGEN_PORT9_SA2    0x0128
+
+#define    RTL8367C_REG_PKTGEN_PORT9_COUNTER0    0x0129
+
+#define    RTL8367C_REG_PKTGEN_PORT9_COUNTER1    0x012a
+#define    RTL8367C_PKTGEN_PORT9_COUNTER1_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT9_COUNTER1_MASK    0xFF
+
+#define    RTL8367C_REG_PKTGEN_PORT9_TX_LENGTH    0x012b
+#define    RTL8367C_PKTGEN_PORT9_TX_LENGTH_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT9_TX_LENGTH_MASK    0x3FFF
+
+#define    RTL8367C_REG_PKTGEN_PORT9_TIMER    0x012d
+#define    RTL8367C_PKTGEN_PORT9_TIMER_TIMER_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT9_TIMER_TIMER_MASK    0xF0
+#define    RTL8367C_PKTGEN_PORT9_TIMER_RX_DMA_ERR_FLAG_OFFSET    3
+#define    RTL8367C_PKTGEN_PORT9_TIMER_RX_DMA_ERR_FLAG_MASK    0x8
+
+#define    RTL8367C_REG_PORT9_MISC_CFG    0x012e
+#define    RTL8367C_PORT9_MISC_CFG_SMALL_TAG_IPG_OFFSET    15
+#define    RTL8367C_PORT9_MISC_CFG_SMALL_TAG_IPG_MASK    0x8000
+#define    RTL8367C_PORT9_MISC_CFG_TX_ITFSP_MODE_OFFSET    14
+#define    RTL8367C_PORT9_MISC_CFG_TX_ITFSP_MODE_MASK    0x4000
+#define    RTL8367C_PORT9_MISC_CFG_FLOWCTRL_INDEP_OFFSET    13
+#define    RTL8367C_PORT9_MISC_CFG_FLOWCTRL_INDEP_MASK    0x2000
+#define    RTL8367C_PORT9_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET    12
+#define    RTL8367C_PORT9_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK    0x1000
+#define    RTL8367C_PORT9_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+#define    RTL8367C_PORT9_MISC_CFG_INGRESSBW_FLOWCTRL_MASK    0x800
+#define    RTL8367C_PORT9_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT9_MISC_CFG_INGRESSBW_IFG_MASK    0x400
+#define    RTL8367C_PORT9_MISC_CFG_RX_SPC_OFFSET    9
+#define    RTL8367C_PORT9_MISC_CFG_RX_SPC_MASK    0x200
+#define    RTL8367C_PORT9_MISC_CFG_CRC_SKIP_OFFSET    8
+#define    RTL8367C_PORT9_MISC_CFG_CRC_SKIP_MASK    0x100
+#define    RTL8367C_PORT9_MISC_CFG_PKTGEN_TX_FIRST_OFFSET    7
+#define    RTL8367C_PORT9_MISC_CFG_PKTGEN_TX_FIRST_MASK    0x80
+#define    RTL8367C_PORT9_MISC_CFG_MAC_LOOPBACK_OFFSET    6
+#define    RTL8367C_PORT9_MISC_CFG_MAC_LOOPBACK_MASK    0x40
+#define    RTL8367C_PORT9_MISC_CFG_VLAN_EGRESS_MODE_OFFSET    4
+#define    RTL8367C_PORT9_MISC_CFG_VLAN_EGRESS_MODE_MASK    0x30
+#define    RTL8367C_PORT9_MISC_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT9_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_INGRESSBW_PORT9_RATE_CTRL0    0x012f
+
+#define    RTL8367C_REG_INGRESSBW_PORT9_RATE_CTRL1    0x0130
+#define    RTL8367C_INGRESSBW_PORT9_RATE_CTRL1_DUMMY_OFFSET    3
+#define    RTL8367C_INGRESSBW_PORT9_RATE_CTRL1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_INGRESSBW_PORT9_RATE_CTRL1_INGRESSBW_RATE16_OFFSET    0
+#define    RTL8367C_INGRESSBW_PORT9_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+
+#define    RTL8367C_REG_PORT9_FORCE_RATE0    0x0131
+
+#define    RTL8367C_REG_PORT9_FORCE_RATE1    0x0132
+
+#define    RTL8367C_REG_PORT9_CURENT_RATE0    0x0133
+
+#define    RTL8367C_REG_PORT9_CURENT_RATE1    0x0134
+
+#define    RTL8367C_REG_PORT9_PAGE_COUNTER    0x0135
+#define    RTL8367C_PORT9_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_PORT9_PAGE_COUNTER_MASK    0x7F
+
+#define    RTL8367C_REG_PAGEMETER_PORT9_CTRL0    0x0136
+
+#define    RTL8367C_REG_PAGEMETER_PORT9_CTRL1    0x0137
+
+#define    RTL8367C_REG_PORT9_EEECFG    0x0138
+#define    RTL8367C_PORT9_EEECFG_EEEP_ENABLE_TX_OFFSET    14
+#define    RTL8367C_PORT9_EEECFG_EEEP_ENABLE_TX_MASK    0x4000
+#define    RTL8367C_PORT9_EEECFG_EEEP_ENABLE_RX_OFFSET    13
+#define    RTL8367C_PORT9_EEECFG_EEEP_ENABLE_RX_MASK    0x2000
+#define    RTL8367C_PORT9_EEECFG_EEE_FORCE_OFFSET    12
+#define    RTL8367C_PORT9_EEECFG_EEE_FORCE_MASK    0x1000
+#define    RTL8367C_PORT9_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT9_EEECFG_EEE_100M_MASK    0x800
+#define    RTL8367C_PORT9_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT9_EEECFG_EEE_GIGA_500M_MASK    0x400
+#define    RTL8367C_PORT9_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT9_EEECFG_EEE_TX_MASK    0x200
+#define    RTL8367C_PORT9_EEECFG_EEE_RX_OFFSET    8
+#define    RTL8367C_PORT9_EEECFG_EEE_RX_MASK    0x100
+#define    RTL8367C_PORT9_EEECFG_EEE_DSP_RX_OFFSET    6
+#define    RTL8367C_PORT9_EEECFG_EEE_DSP_RX_MASK    0x40
+#define    RTL8367C_PORT9_EEECFG_EEE_LPI_OFFSET    5
+#define    RTL8367C_PORT9_EEECFG_EEE_LPI_MASK    0x20
+#define    RTL8367C_PORT9_EEECFG_EEE_TX_LPI_OFFSET    4
+#define    RTL8367C_PORT9_EEECFG_EEE_TX_LPI_MASK    0x10
+#define    RTL8367C_PORT9_EEECFG_EEE_RX_LPI_OFFSET    3
+#define    RTL8367C_PORT9_EEECFG_EEE_RX_LPI_MASK    0x8
+#define    RTL8367C_PORT9_EEECFG_EEE_PAUSE_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT9_EEECFG_EEE_PAUSE_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT9_EEECFG_EEE_WAKE_REQ_OFFSET    1
+#define    RTL8367C_PORT9_EEECFG_EEE_WAKE_REQ_MASK    0x2
+#define    RTL8367C_PORT9_EEECFG_EEE_SLEEP_REQ_OFFSET    0
+#define    RTL8367C_PORT9_EEECFG_EEE_SLEEP_REQ_MASK    0x1
+
+#define    RTL8367C_REG_PORT9_EEETXMTR    0x0139
+
+#define    RTL8367C_REG_PORT9_EEERXMTR    0x013a
+
+#define    RTL8367C_REG_PORT9_EEEPTXMTR    0x013b
+
+#define    RTL8367C_REG_PORT9_EEEPRXMTR    0x013c
+
+#define    RTL8367C_REG_PTP_PORT9_CFG1    0x013e
+#define    RTL8367C_PTP_PORT9_CFG1_OFFSET    7
+#define    RTL8367C_PTP_PORT9_CFG1_MASK    0xFF
+
+#define    RTL8367C_REG_P9_MSIC1    0x013f
+#define    RTL8367C_P9_MSIC1_OFFSET    0
+#define    RTL8367C_P9_MSIC1_MASK    0x1
+
+#define    RTL8367C_REG_PORT10_CGST_HALF_CFG    0x0140
+#define    RTL8367C_PORT10_CGST_HALF_CFG_CONGESTION_TIME_OFFSET    4
+#define    RTL8367C_PORT10_CGST_HALF_CFG_CONGESTION_TIME_MASK    0xF0
+#define    RTL8367C_PORT10_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT10_CGST_HALF_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_PKTGEN_PORT10_CTRL    0x0141
+#define    RTL8367C_PKTGEN_PORT10_CTRL_STATUS_OFFSET    15
+#define    RTL8367C_PKTGEN_PORT10_CTRL_STATUS_MASK    0x8000
+#define    RTL8367C_PKTGEN_PORT10_CTRL_PKTGEN_STS_OFFSET    13
+#define    RTL8367C_PKTGEN_PORT10_CTRL_PKTGEN_STS_MASK    0x2000
+#define    RTL8367C_PKTGEN_PORT10_CTRL_CRC_NO_ERROR_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT10_CTRL_CRC_NO_ERROR_MASK    0x10
+#define    RTL8367C_PKTGEN_PORT10_CTRL_CMD_START_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT10_CTRL_CMD_START_MASK    0x1
+
+#define    RTL8367C_REG_TX_ERR_CNT_PORT10    0x0142
+#define    RTL8367C_TX_ERR_CNT_PORT10_OFFSET    0
+#define    RTL8367C_TX_ERR_CNT_PORT10_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_PORT10_DA0    0x0143
+
+#define    RTL8367C_REG_PKTGEN_PORT10_DA1    0x0144
+
+#define    RTL8367C_REG_PKTGEN_PORT10_DA2    0x0145
+
+#define    RTL8367C_REG_PKTGEN_PORT10_SA0    0x0146
+
+#define    RTL8367C_REG_PKTGEN_PORT10_SA1    0x0147
+
+#define    RTL8367C_REG_PKTGEN_PORT10_SA2    0x0148
+
+#define    RTL8367C_REG_PKTGEN_PORT10_COUNTER0    0x0149
+
+#define    RTL8367C_REG_PKTGEN_PORT10_COUNTER1    0x014a
+#define    RTL8367C_PKTGEN_PORT10_COUNTER1_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT10_COUNTER1_MASK    0xFF
+
+#define    RTL8367C_REG_PKTGEN_PORT10_TX_LENGTH    0x014b
+#define    RTL8367C_PKTGEN_PORT10_TX_LENGTH_OFFSET    0
+#define    RTL8367C_PKTGEN_PORT10_TX_LENGTH_MASK    0x3FFF
+
+#define    RTL8367C_REG_PKTGEN_PORT10_TIMER    0x014d
+#define    RTL8367C_PKTGEN_PORT10_TIMER_TIMER_OFFSET    4
+#define    RTL8367C_PKTGEN_PORT10_TIMER_TIMER_MASK    0xF0
+#define    RTL8367C_PKTGEN_PORT10_TIMER_RX_DMA_ERR_FLAG_OFFSET    3
+#define    RTL8367C_PKTGEN_PORT10_TIMER_RX_DMA_ERR_FLAG_MASK    0x8
+
+#define    RTL8367C_REG_PORT10_MISC_CFG    0x014e
+#define    RTL8367C_PORT10_MISC_CFG_SMALL_TAG_IPG_OFFSET    15
+#define    RTL8367C_PORT10_MISC_CFG_SMALL_TAG_IPG_MASK    0x8000
+#define    RTL8367C_PORT10_MISC_CFG_TX_ITFSP_MODE_OFFSET    14
+#define    RTL8367C_PORT10_MISC_CFG_TX_ITFSP_MODE_MASK    0x4000
+#define    RTL8367C_PORT10_MISC_CFG_FLOWCTRL_INDEP_OFFSET    13
+#define    RTL8367C_PORT10_MISC_CFG_FLOWCTRL_INDEP_MASK    0x2000
+#define    RTL8367C_PORT10_MISC_CFG_DOT1Q_REMARK_ENABLE_OFFSET    12
+#define    RTL8367C_PORT10_MISC_CFG_DOT1Q_REMARK_ENABLE_MASK    0x1000
+#define    RTL8367C_PORT10_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET    11
+#define    RTL8367C_PORT10_MISC_CFG_INGRESSBW_FLOWCTRL_MASK    0x800
+#define    RTL8367C_PORT10_MISC_CFG_INGRESSBW_IFG_OFFSET    10
+#define    RTL8367C_PORT10_MISC_CFG_INGRESSBW_IFG_MASK    0x400
+#define    RTL8367C_PORT10_MISC_CFG_RX_SPC_OFFSET    9
+#define    RTL8367C_PORT10_MISC_CFG_RX_SPC_MASK    0x200
+#define    RTL8367C_PORT10_MISC_CFG_CRC_SKIP_OFFSET    8
+#define    RTL8367C_PORT10_MISC_CFG_CRC_SKIP_MASK    0x100
+#define    RTL8367C_PORT10_MISC_CFG_PKTGEN_TX_FIRST_OFFSET    7
+#define    RTL8367C_PORT10_MISC_CFG_PKTGEN_TX_FIRST_MASK    0x80
+#define    RTL8367C_PORT10_MISC_CFG_MAC_LOOPBACK_OFFSET    6
+#define    RTL8367C_PORT10_MISC_CFG_MAC_LOOPBACK_MASK    0x40
+#define    RTL8367C_PORT10_MISC_CFG_VLAN_EGRESS_MODE_OFFSET    4
+#define    RTL8367C_PORT10_MISC_CFG_VLAN_EGRESS_MODE_MASK    0x30
+#define    RTL8367C_PORT10_MISC_CFG_CONGESTION_SUSTAIN_TIME_OFFSET    0
+#define    RTL8367C_PORT10_MISC_CFG_CONGESTION_SUSTAIN_TIME_MASK    0xF
+
+#define    RTL8367C_REG_INGRESSBW_PORT10_RATE_CTRL0    0x014f
+
+#define    RTL8367C_REG_INGRESSBW_PORT10_RATE_CTRL1    0x0150
+#define    RTL8367C_INGRESSBW_PORT10_RATE_CTRL1_DUMMY_OFFSET    3
+#define    RTL8367C_INGRESSBW_PORT10_RATE_CTRL1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_INGRESSBW_PORT10_RATE_CTRL1_INGRESSBW_RATE16_OFFSET    0
+#define    RTL8367C_INGRESSBW_PORT10_RATE_CTRL1_INGRESSBW_RATE16_MASK    0x7
+
+#define    RTL8367C_REG_PORT10_FORCE_RATE0    0x0151
+
+#define    RTL8367C_REG_PORT10_FORCE_RATE1    0x0152
+
+#define    RTL8367C_REG_PORT10_CURENT_RATE0    0x0153
+
+#define    RTL8367C_REG_PORT10_CURENT_RATE1    0x0154
+
+#define    RTL8367C_REG_PORT10_PAGE_COUNTER    0x0155
+#define    RTL8367C_PORT10_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_PORT10_PAGE_COUNTER_MASK    0x7F
+
+#define    RTL8367C_REG_PAGEMETER_PORT10_CTRL0    0x0156
+
+#define    RTL8367C_REG_PAGEMETER_PORT10_CTRL1    0x0157
+
+#define    RTL8367C_REG_PORT10_EEECFG    0x0158
+#define    RTL8367C_PORT10_EEECFG_EEEP_ENABLE_TX_OFFSET    14
+#define    RTL8367C_PORT10_EEECFG_EEEP_ENABLE_TX_MASK    0x4000
+#define    RTL8367C_PORT10_EEECFG_EEEP_ENABLE_RX_OFFSET    13
+#define    RTL8367C_PORT10_EEECFG_EEEP_ENABLE_RX_MASK    0x2000
+#define    RTL8367C_PORT10_EEECFG_EEE_FORCE_OFFSET    12
+#define    RTL8367C_PORT10_EEECFG_EEE_FORCE_MASK    0x1000
+#define    RTL8367C_PORT10_EEECFG_EEE_100M_OFFSET    11
+#define    RTL8367C_PORT10_EEECFG_EEE_100M_MASK    0x800
+#define    RTL8367C_PORT10_EEECFG_EEE_GIGA_500M_OFFSET    10
+#define    RTL8367C_PORT10_EEECFG_EEE_GIGA_500M_MASK    0x400
+#define    RTL8367C_PORT10_EEECFG_EEE_TX_OFFSET    9
+#define    RTL8367C_PORT10_EEECFG_EEE_TX_MASK    0x200
+#define    RTL8367C_PORT10_EEECFG_EEE_RX_OFFSET    8
+#define    RTL8367C_PORT10_EEECFG_EEE_RX_MASK    0x100
+#define    RTL8367C_PORT10_EEECFG_EEE_DSP_RX_OFFSET    6
+#define    RTL8367C_PORT10_EEECFG_EEE_DSP_RX_MASK    0x40
+#define    RTL8367C_PORT10_EEECFG_EEE_LPI_OFFSET    5
+#define    RTL8367C_PORT10_EEECFG_EEE_LPI_MASK    0x20
+#define    RTL8367C_PORT10_EEECFG_EEE_TX_LPI_OFFSET    4
+#define    RTL8367C_PORT10_EEECFG_EEE_TX_LPI_MASK    0x10
+#define    RTL8367C_PORT10_EEECFG_EEE_RX_LPI_OFFSET    3
+#define    RTL8367C_PORT10_EEECFG_EEE_RX_LPI_MASK    0x8
+#define    RTL8367C_PORT10_EEECFG_EEE_PAUSE_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT10_EEECFG_EEE_PAUSE_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT10_EEECFG_EEE_WAKE_REQ_OFFSET    1
+#define    RTL8367C_PORT10_EEECFG_EEE_WAKE_REQ_MASK    0x2
+#define    RTL8367C_PORT10_EEECFG_EEE_SLEEP_REQ_OFFSET    0
+#define    RTL8367C_PORT10_EEECFG_EEE_SLEEP_REQ_MASK    0x1
+
+#define    RTL8367C_REG_PORT10_EEETXMTR    0x0159
+
+#define    RTL8367C_REG_PORT10_EEERXMTR    0x015a
+
+#define    RTL8367C_REG_PORT10_EEEPTXMTR    0x015b
+
+#define    RTL8367C_REG_PORT10_EEEPRXMTR    0x015c
+
+#define    RTL8367C_REG_PTP_PORT10_CFG1    0x015e
+#define    RTL8367C_PTP_PORT10_CFG1_OFFSET    7
+#define    RTL8367C_PTP_PORT10_CFG1_MASK    0xFF
+
+#define    RTL8367C_REG_P10_MSIC1    0x015f
+#define    RTL8367C_P10_MSIC1_OFFSET    0
+#define    RTL8367C_P10_MSIC1_MASK    0x1
+
+/* (16'h0200)outq_reg */
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE0_DROP_ON    0x0200
+#define    RTL8367C_FLOWCTRL_QUEUE0_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE0_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE1_DROP_ON    0x0201
+#define    RTL8367C_FLOWCTRL_QUEUE1_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE1_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE2_DROP_ON    0x0202
+#define    RTL8367C_FLOWCTRL_QUEUE2_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE2_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE3_DROP_ON    0x0203
+#define    RTL8367C_FLOWCTRL_QUEUE3_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE3_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE4_DROP_ON    0x0204
+#define    RTL8367C_FLOWCTRL_QUEUE4_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE4_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE5_DROP_ON    0x0205
+#define    RTL8367C_FLOWCTRL_QUEUE5_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE5_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE6_DROP_ON    0x0206
+#define    RTL8367C_FLOWCTRL_QUEUE6_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE6_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE7_DROP_ON    0x0207
+#define    RTL8367C_FLOWCTRL_QUEUE7_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE7_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT0_DROP_ON    0x0208
+#define    RTL8367C_FLOWCTRL_PORT0_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT0_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT1_DROP_ON    0x0209
+#define    RTL8367C_FLOWCTRL_PORT1_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT1_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT2_DROP_ON    0x020a
+#define    RTL8367C_FLOWCTRL_PORT2_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT2_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT3_DROP_ON    0x020b
+#define    RTL8367C_FLOWCTRL_PORT3_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT3_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT4_DROP_ON    0x020c
+#define    RTL8367C_FLOWCTRL_PORT4_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT4_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT5_DROP_ON    0x020d
+#define    RTL8367C_FLOWCTRL_PORT5_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT5_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT6_DROP_ON    0x020e
+#define    RTL8367C_FLOWCTRL_PORT6_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT6_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT7_DROP_ON    0x020f
+#define    RTL8367C_FLOWCTRL_PORT7_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT7_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT8_DROP_ON    0x0210
+#define    RTL8367C_FLOWCTRL_PORT8_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT8_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT9_DROP_ON    0x0211
+#define    RTL8367C_FLOWCTRL_PORT9_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT9_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT10_DROP_ON    0x0212
+#define    RTL8367C_FLOWCTRL_PORT10_DROP_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT10_DROP_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT_GAP    0x0218
+#define    RTL8367C_FLOWCTRL_PORT_GAP_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT_GAP_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE_GAP    0x0219
+#define    RTL8367C_FLOWCTRL_QUEUE_GAP_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE_GAP_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_QEMPTY    0x022d
+#define    RTL8367C_PORT_QEMPTY_OFFSET    0
+#define    RTL8367C_PORT_QEMPTY_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_DEBUG_CTRL0    0x022e
+#define    RTL8367C_FLOWCTRL_DEBUG_CTRL0_OFFSET    0
+#define    RTL8367C_FLOWCTRL_DEBUG_CTRL0_MASK    0xF
+
+#define    RTL8367C_REG_FLOWCTRL_DEBUG_CTRL1    0x022f
+#define    RTL8367C_TOTAL_OFFSET    9
+#define    RTL8367C_TOTAL_MASK    0x200
+#define    RTL8367C_PORT_MAX_OFFSET    8
+#define    RTL8367C_PORT_MAX_MASK    0x100
+#define    RTL8367C_QMAX_MASK_OFFSET    0
+#define    RTL8367C_QMAX_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE0_PAGE_COUNT    0x0230
+#define    RTL8367C_FLOWCTRL_QUEUE0_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE0_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE1_PAGE_COUNT    0x0231
+#define    RTL8367C_FLOWCTRL_QUEUE1_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE1_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE2_PAGE_COUNT    0x0232
+#define    RTL8367C_FLOWCTRL_QUEUE2_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE2_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE3_PAGE_COUNT    0x0233
+#define    RTL8367C_FLOWCTRL_QUEUE3_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE3_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE4_PAGE_COUNT    0x0234
+#define    RTL8367C_FLOWCTRL_QUEUE4_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE4_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE5_PAGE_COUNT    0x0235
+#define    RTL8367C_FLOWCTRL_QUEUE5_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE5_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE6_PAGE_COUNT    0x0236
+#define    RTL8367C_FLOWCTRL_QUEUE6_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE6_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE7_PAGE_COUNT    0x0237
+#define    RTL8367C_FLOWCTRL_QUEUE7_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE7_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT_PAGE_COUNT    0x0238
+#define    RTL8367C_FLOWCTRL_PORT_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE0_MAX_PAGE_COUNT    0x0239
+#define    RTL8367C_FLOWCTRL_QUEUE0_MAX_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE0_MAX_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE1_MAX_PAGE_COUNT    0x023a
+#define    RTL8367C_FLOWCTRL_QUEUE1_MAX_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE1_MAX_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE2_MAX_PAGE_COUNT    0x023b
+#define    RTL8367C_FLOWCTRL_QUEUE2_MAX_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE2_MAX_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE3_MAX_PAGE_COUNT    0x023c
+#define    RTL8367C_FLOWCTRL_QUEUE3_MAX_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE3_MAX_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE4_MAX_PAGE_COUNT    0x023d
+#define    RTL8367C_FLOWCTRL_QUEUE4_MAX_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE4_MAX_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE5_MAX_PAGE_COUNT    0x023e
+#define    RTL8367C_FLOWCTRL_QUEUE5_MAX_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE5_MAX_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE6_MAX_PAGE_COUNT    0x023f
+#define    RTL8367C_FLOWCTRL_QUEUE6_MAX_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE6_MAX_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_QUEUE7_MAX_PAGE_COUNT    0x0240
+#define    RTL8367C_FLOWCTRL_QUEUE7_MAX_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_QUEUE7_MAX_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT_MAX_PAGE_COUNT    0x0241
+#define    RTL8367C_FLOWCTRL_PORT_MAX_PAGE_COUNT_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT_MAX_PAGE_COUNT_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_TOTAL_PACKET_COUNT    0x0243
+
+#define    RTL8367C_REG_HIGH_QUEUE_MASK0    0x0244
+#define    RTL8367C_PORT1_HIGH_QUEUE_MASK_OFFSET    8
+#define    RTL8367C_PORT1_HIGH_QUEUE_MASK_MASK    0xFF00
+#define    RTL8367C_PORT0_HIGH_QUEUE_MASK_OFFSET    0
+#define    RTL8367C_PORT0_HIGH_QUEUE_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_HIGH_QUEUE_MASK1    0x0245
+#define    RTL8367C_PORT3_HIGH_QUEUE_MASK_OFFSET    8
+#define    RTL8367C_PORT3_HIGH_QUEUE_MASK_MASK    0xFF00
+#define    RTL8367C_PORT2_HIGH_QUEUE_MASK_OFFSET    0
+#define    RTL8367C_PORT2_HIGH_QUEUE_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_HIGH_QUEUE_MASK2    0x0246
+#define    RTL8367C_PORT5_HIGH_QUEUE_MASK_OFFSET    8
+#define    RTL8367C_PORT5_HIGH_QUEUE_MASK_MASK    0xFF00
+#define    RTL8367C_PORT4_HIGH_QUEUE_MASK_OFFSET    0
+#define    RTL8367C_PORT4_HIGH_QUEUE_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_HIGH_QUEUE_MASK3    0x0247
+#define    RTL8367C_PORT7_HIGH_QUEUE_MASK_OFFSET    8
+#define    RTL8367C_PORT7_HIGH_QUEUE_MASK_MASK    0xFF00
+#define    RTL8367C_PORT6_HIGH_QUEUE_MASK_OFFSET    0
+#define    RTL8367C_PORT6_HIGH_QUEUE_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_HIGH_QUEUE_MASK4    0x0248
+#define    RTL8367C_PORT9_HIGH_QUEUE_MASK_OFFSET    8
+#define    RTL8367C_PORT9_HIGH_QUEUE_MASK_MASK    0xFF00
+#define    RTL8367C_PORT8_HIGH_QUEUE_MASK_OFFSET    0
+#define    RTL8367C_PORT8_HIGH_QUEUE_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_HIGH_QUEUE_MASK5    0x0249
+#define    RTL8367C_HIGH_QUEUE_MASK5_OFFSET    0
+#define    RTL8367C_HIGH_QUEUE_MASK5_MASK    0xFF
+
+#define    RTL8367C_REG_LOW_QUEUE_TH    0x024c
+#define    RTL8367C_LOW_QUEUE_TH_OFFSET    0
+#define    RTL8367C_LOW_QUEUE_TH_MASK    0x7FF
+
+#define    RTL8367C_REG_TH_TX_PREFET    0x0250
+#define    RTL8367C_TH_TX_PREFET_OFFSET    0
+#define    RTL8367C_TH_TX_PREFET_MASK    0xFF
+
+#define    RTL8367C_REG_DUMMY_0251    0x0251
+
+#define    RTL8367C_REG_DUMMY_0252    0x0252
+
+#define    RTL8367C_REG_DUMMY_0253    0x0253
+
+#define    RTL8367C_REG_DUMMY_0254    0x0254
+
+#define    RTL8367C_REG_DUMMY_0255    0x0255
+
+#define    RTL8367C_REG_DUMMY_0256    0x0256
+
+#define    RTL8367C_REG_DUMMY_0257    0x0257
+
+#define    RTL8367C_REG_DUMMY_0258    0x0258
+
+#define    RTL8367C_REG_DUMMY_0259    0x0259
+
+#define    RTL8367C_REG_DUMMY_025A    0x025A
+
+#define    RTL8367C_REG_DUMMY_025B    0x025B
+
+#define    RTL8367C_REG_DUMMY_025C    0x025C
+
+#define    RTL8367C_REG_Q_TXPKT_CNT_CTL    0x025d
+#define    RTL8367C_QUEUE_PKT_CNT_CLR_OFFSET    4
+#define    RTL8367C_QUEUE_PKT_CNT_CLR_MASK    0x10
+#define    RTL8367C_PORT_ID_QUEUE_PKT_CNT_OFFSET    0
+#define    RTL8367C_PORT_ID_QUEUE_PKT_CNT_MASK    0xF
+
+#define    RTL8367C_REG_Q0_TXPKT_CNT_L    0x025e
+
+#define    RTL8367C_REG_Q0_TXPKT_CNT_H    0x025f
+
+#define    RTL8367C_REG_Q1_TXPKT_CNT_L    0x0260
+
+#define    RTL8367C_REG_Q1_TXPKT_CNT_H    0x0261
+
+#define    RTL8367C_REG_Q2_TXPKT_CNT_L    0x0262
+
+#define    RTL8367C_REG_Q2_TXPKT_CNT_H    0x0263
+
+#define    RTL8367C_REG_Q3_TXPKT_CNT_L    0x0264
+
+#define    RTL8367C_REG_Q3_TXPKT_CNT_H    0x0265
+
+#define    RTL8367C_REG_Q4_TXPKT_CNT_L    0x0266
+
+#define    RTL8367C_REG_Q4_TXPKT_CNT_H    0x0267
+
+#define    RTL8367C_REG_Q5_TXPKT_CNT_L    0x0268
+
+#define    RTL8367C_REG_Q5_TXPKT_CNT_H    0x0269
+
+#define    RTL8367C_REG_Q6_TXPKT_CNT_L    0x026a
+
+#define    RTL8367C_REG_Q6_TXPKT_CNT_H    0x026b
+
+#define    RTL8367C_REG_Q7_TXPKT_CNT_L    0x026c
+
+#define    RTL8367C_REG_Q7_TXPKT_CNT_H    0x026d
+
+/* (16'h0300)sch_reg */
+
+#define    RTL8367C_REG_SCHEDULE_WFQ_CTRL    0x0300
+#define    RTL8367C_SCHEDULE_WFQ_CTRL_OFFSET    0
+#define    RTL8367C_SCHEDULE_WFQ_CTRL_MASK    0x1
+
+#define    RTL8367C_REG_SCHEDULE_WFQ_BURST_SIZE    0x0301
+
+#define    RTL8367C_REG_SCHEDULE_QUEUE_TYPE_CTRL0    0x0302
+#define    RTL8367C_PORT1_QUEUE7_TYPE_OFFSET    15
+#define    RTL8367C_PORT1_QUEUE7_TYPE_MASK    0x8000
+#define    RTL8367C_PORT1_QUEUE6_TYPE_OFFSET    14
+#define    RTL8367C_PORT1_QUEUE6_TYPE_MASK    0x4000
+#define    RTL8367C_PORT1_QUEUE5_TYPE_OFFSET    13
+#define    RTL8367C_PORT1_QUEUE5_TYPE_MASK    0x2000
+#define    RTL8367C_PORT1_QUEUE4_TYPE_OFFSET    12
+#define    RTL8367C_PORT1_QUEUE4_TYPE_MASK    0x1000
+#define    RTL8367C_PORT1_QUEUE3_TYPE_OFFSET    11
+#define    RTL8367C_PORT1_QUEUE3_TYPE_MASK    0x800
+#define    RTL8367C_PORT1_QUEUE2_TYPE_OFFSET    10
+#define    RTL8367C_PORT1_QUEUE2_TYPE_MASK    0x400
+#define    RTL8367C_PORT1_QUEUE1_TYPE_OFFSET    9
+#define    RTL8367C_PORT1_QUEUE1_TYPE_MASK    0x200
+#define    RTL8367C_PORT1_QUEUE0_TYPE_OFFSET    8
+#define    RTL8367C_PORT1_QUEUE0_TYPE_MASK    0x100
+#define    RTL8367C_PORT0_QUEUE7_TYPE_OFFSET    7
+#define    RTL8367C_PORT0_QUEUE7_TYPE_MASK    0x80
+#define    RTL8367C_PORT0_QUEUE6_TYPE_OFFSET    6
+#define    RTL8367C_PORT0_QUEUE6_TYPE_MASK    0x40
+#define    RTL8367C_PORT0_QUEUE5_TYPE_OFFSET    5
+#define    RTL8367C_PORT0_QUEUE5_TYPE_MASK    0x20
+#define    RTL8367C_PORT0_QUEUE4_TYPE_OFFSET    4
+#define    RTL8367C_PORT0_QUEUE4_TYPE_MASK    0x10
+#define    RTL8367C_PORT0_QUEUE3_TYPE_OFFSET    3
+#define    RTL8367C_PORT0_QUEUE3_TYPE_MASK    0x8
+#define    RTL8367C_PORT0_QUEUE2_TYPE_OFFSET    2
+#define    RTL8367C_PORT0_QUEUE2_TYPE_MASK    0x4
+#define    RTL8367C_PORT0_QUEUE1_TYPE_OFFSET    1
+#define    RTL8367C_PORT0_QUEUE1_TYPE_MASK    0x2
+#define    RTL8367C_PORT0_QUEUE0_TYPE_OFFSET    0
+#define    RTL8367C_PORT0_QUEUE0_TYPE_MASK    0x1
+
+#define    RTL8367C_REG_SCHEDULE_QUEUE_TYPE_CTRL1    0x0303
+#define    RTL8367C_PORT3_QUEUE7_TYPE_OFFSET    15
+#define    RTL8367C_PORT3_QUEUE7_TYPE_MASK    0x8000
+#define    RTL8367C_PORT3_QUEUE6_TYPE_OFFSET    14
+#define    RTL8367C_PORT3_QUEUE6_TYPE_MASK    0x4000
+#define    RTL8367C_PORT3_QUEUE5_TYPE_OFFSET    13
+#define    RTL8367C_PORT3_QUEUE5_TYPE_MASK    0x2000
+#define    RTL8367C_PORT3_QUEUE4_TYPE_OFFSET    12
+#define    RTL8367C_PORT3_QUEUE4_TYPE_MASK    0x1000
+#define    RTL8367C_PORT3_QUEUE3_TYPE_OFFSET    11
+#define    RTL8367C_PORT3_QUEUE3_TYPE_MASK    0x800
+#define    RTL8367C_PORT3_QUEUE2_TYPE_OFFSET    10
+#define    RTL8367C_PORT3_QUEUE2_TYPE_MASK    0x400
+#define    RTL8367C_PORT3_QUEUE1_TYPE_OFFSET    9
+#define    RTL8367C_PORT3_QUEUE1_TYPE_MASK    0x200
+#define    RTL8367C_PORT3_QUEUE0_TYPE_OFFSET    8
+#define    RTL8367C_PORT3_QUEUE0_TYPE_MASK    0x100
+#define    RTL8367C_PORT2_QUEUE7_TYPE_OFFSET    7
+#define    RTL8367C_PORT2_QUEUE7_TYPE_MASK    0x80
+#define    RTL8367C_PORT2_QUEUE6_TYPE_OFFSET    6
+#define    RTL8367C_PORT2_QUEUE6_TYPE_MASK    0x40
+#define    RTL8367C_PORT2_QUEUE5_TYPE_OFFSET    5
+#define    RTL8367C_PORT2_QUEUE5_TYPE_MASK    0x20
+#define    RTL8367C_PORT2_QUEUE4_TYPE_OFFSET    4
+#define    RTL8367C_PORT2_QUEUE4_TYPE_MASK    0x10
+#define    RTL8367C_PORT2_QUEUE3_TYPE_OFFSET    3
+#define    RTL8367C_PORT2_QUEUE3_TYPE_MASK    0x8
+#define    RTL8367C_PORT2_QUEUE2_TYPE_OFFSET    2
+#define    RTL8367C_PORT2_QUEUE2_TYPE_MASK    0x4
+#define    RTL8367C_PORT2_QUEUE1_TYPE_OFFSET    1
+#define    RTL8367C_PORT2_QUEUE1_TYPE_MASK    0x2
+#define    RTL8367C_PORT2_QUEUE0_TYPE_OFFSET    0
+#define    RTL8367C_PORT2_QUEUE0_TYPE_MASK    0x1
+
+#define    RTL8367C_REG_SCHEDULE_QUEUE_TYPE_CTRL2    0x0304
+#define    RTL8367C_PORT5_QUEUE7_TYPE_OFFSET    15
+#define    RTL8367C_PORT5_QUEUE7_TYPE_MASK    0x8000
+#define    RTL8367C_PORT5_QUEUE6_TYPE_OFFSET    14
+#define    RTL8367C_PORT5_QUEUE6_TYPE_MASK    0x4000
+#define    RTL8367C_PORT5_QUEUE5_TYPE_OFFSET    13
+#define    RTL8367C_PORT5_QUEUE5_TYPE_MASK    0x2000
+#define    RTL8367C_PORT5_QUEUE4_TYPE_OFFSET    12
+#define    RTL8367C_PORT5_QUEUE4_TYPE_MASK    0x1000
+#define    RTL8367C_PORT5_QUEUE3_TYPE_OFFSET    11
+#define    RTL8367C_PORT5_QUEUE3_TYPE_MASK    0x800
+#define    RTL8367C_PORT5_QUEUE2_TYPE_OFFSET    10
+#define    RTL8367C_PORT5_QUEUE2_TYPE_MASK    0x400
+#define    RTL8367C_PORT5_QUEUE1_TYPE_OFFSET    9
+#define    RTL8367C_PORT5_QUEUE1_TYPE_MASK    0x200
+#define    RTL8367C_PORT5_QUEUE0_TYPE_OFFSET    8
+#define    RTL8367C_PORT5_QUEUE0_TYPE_MASK    0x100
+#define    RTL8367C_PORT4_QUEUE7_TYPE_OFFSET    7
+#define    RTL8367C_PORT4_QUEUE7_TYPE_MASK    0x80
+#define    RTL8367C_PORT4_QUEUE6_TYPE_OFFSET    6
+#define    RTL8367C_PORT4_QUEUE6_TYPE_MASK    0x40
+#define    RTL8367C_PORT4_QUEUE5_TYPE_OFFSET    5
+#define    RTL8367C_PORT4_QUEUE5_TYPE_MASK    0x20
+#define    RTL8367C_PORT4_QUEUE4_TYPE_OFFSET    4
+#define    RTL8367C_PORT4_QUEUE4_TYPE_MASK    0x10
+#define    RTL8367C_PORT4_QUEUE3_TYPE_OFFSET    3
+#define    RTL8367C_PORT4_QUEUE3_TYPE_MASK    0x8
+#define    RTL8367C_PORT4_QUEUE2_TYPE_OFFSET    2
+#define    RTL8367C_PORT4_QUEUE2_TYPE_MASK    0x4
+#define    RTL8367C_PORT4_QUEUE1_TYPE_OFFSET    1
+#define    RTL8367C_PORT4_QUEUE1_TYPE_MASK    0x2
+#define    RTL8367C_PORT4_QUEUE0_TYPE_OFFSET    0
+#define    RTL8367C_PORT4_QUEUE0_TYPE_MASK    0x1
+
+#define    RTL8367C_REG_SCHEDULE_QUEUE_TYPE_CTRL3    0x0305
+#define    RTL8367C_PORT7_QUEUE7_TYPE_OFFSET    15
+#define    RTL8367C_PORT7_QUEUE7_TYPE_MASK    0x8000
+#define    RTL8367C_PORT7_QUEUE6_TYPE_OFFSET    14
+#define    RTL8367C_PORT7_QUEUE6_TYPE_MASK    0x4000
+#define    RTL8367C_PORT7_QUEUE5_TYPE_OFFSET    13
+#define    RTL8367C_PORT7_QUEUE5_TYPE_MASK    0x2000
+#define    RTL8367C_PORT7_QUEUE4_TYPE_OFFSET    12
+#define    RTL8367C_PORT7_QUEUE4_TYPE_MASK    0x1000
+#define    RTL8367C_PORT7_QUEUE3_TYPE_OFFSET    11
+#define    RTL8367C_PORT7_QUEUE3_TYPE_MASK    0x800
+#define    RTL8367C_PORT7_QUEUE2_TYPE_OFFSET    10
+#define    RTL8367C_PORT7_QUEUE2_TYPE_MASK    0x400
+#define    RTL8367C_PORT7_QUEUE1_TYPE_OFFSET    9
+#define    RTL8367C_PORT7_QUEUE1_TYPE_MASK    0x200
+#define    RTL8367C_PORT7_QUEUE0_TYPE_OFFSET    8
+#define    RTL8367C_PORT7_QUEUE0_TYPE_MASK    0x100
+#define    RTL8367C_PORT6_QUEUE7_TYPE_OFFSET    7
+#define    RTL8367C_PORT6_QUEUE7_TYPE_MASK    0x80
+#define    RTL8367C_PORT6_QUEUE6_TYPE_OFFSET    6
+#define    RTL8367C_PORT6_QUEUE6_TYPE_MASK    0x40
+#define    RTL8367C_PORT6_QUEUE5_TYPE_OFFSET    5
+#define    RTL8367C_PORT6_QUEUE5_TYPE_MASK    0x20
+#define    RTL8367C_PORT6_QUEUE4_TYPE_OFFSET    4
+#define    RTL8367C_PORT6_QUEUE4_TYPE_MASK    0x10
+#define    RTL8367C_PORT6_QUEUE3_TYPE_OFFSET    3
+#define    RTL8367C_PORT6_QUEUE3_TYPE_MASK    0x8
+#define    RTL8367C_PORT6_QUEUE2_TYPE_OFFSET    2
+#define    RTL8367C_PORT6_QUEUE2_TYPE_MASK    0x4
+#define    RTL8367C_PORT6_QUEUE1_TYPE_OFFSET    1
+#define    RTL8367C_PORT6_QUEUE1_TYPE_MASK    0x2
+#define    RTL8367C_SCHEDULE_QUEUE_TYPE_CTRL3_PORT6_QUEUE0_TYPE_OFFSET    0
+#define    RTL8367C_SCHEDULE_QUEUE_TYPE_CTRL3_PORT6_QUEUE0_TYPE_MASK    0x1
+
+#define    RTL8367C_REG_SCHEDULE_QUEUE_TYPE_CTRL4    0x0306
+#define    RTL8367C_PORT9_QUEUE7_TYPE_OFFSET    15
+#define    RTL8367C_PORT9_QUEUE7_TYPE_MASK    0x8000
+#define    RTL8367C_PORT9_QUEUE6_TYPE_OFFSET    14
+#define    RTL8367C_PORT9_QUEUE6_TYPE_MASK    0x4000
+#define    RTL8367C_PORT9_QUEUE5_TYPE_OFFSET    13
+#define    RTL8367C_PORT9_QUEUE5_TYPE_MASK    0x2000
+#define    RTL8367C_PORT9_QUEUE4_TYPE_OFFSET    12
+#define    RTL8367C_PORT9_QUEUE4_TYPE_MASK    0x1000
+#define    RTL8367C_PORT9_QUEUE3_TYPE_OFFSET    11
+#define    RTL8367C_PORT9_QUEUE3_TYPE_MASK    0x800
+#define    RTL8367C_PORT9_QUEUE2_TYPE_OFFSET    10
+#define    RTL8367C_PORT9_QUEUE2_TYPE_MASK    0x400
+#define    RTL8367C_PORT9_QUEUE1_TYPE_OFFSET    9
+#define    RTL8367C_PORT9_QUEUE1_TYPE_MASK    0x200
+#define    RTL8367C_PORT9_QUEUE0_TYPE_OFFSET    8
+#define    RTL8367C_PORT9_QUEUE0_TYPE_MASK    0x100
+#define    RTL8367C_PORT8_QUEUE7_TYPE_OFFSET    7
+#define    RTL8367C_PORT8_QUEUE7_TYPE_MASK    0x80
+#define    RTL8367C_PORT8_QUEUE6_TYPE_OFFSET    6
+#define    RTL8367C_PORT8_QUEUE6_TYPE_MASK    0x40
+#define    RTL8367C_PORT8_QUEUE5_TYPE_OFFSET    5
+#define    RTL8367C_PORT8_QUEUE5_TYPE_MASK    0x20
+#define    RTL8367C_PORT8_QUEUE4_TYPE_OFFSET    4
+#define    RTL8367C_PORT8_QUEUE4_TYPE_MASK    0x10
+#define    RTL8367C_PORT8_QUEUE3_TYPE_OFFSET    3
+#define    RTL8367C_PORT8_QUEUE3_TYPE_MASK    0x8
+#define    RTL8367C_PORT8_QUEUE2_TYPE_OFFSET    2
+#define    RTL8367C_PORT8_QUEUE2_TYPE_MASK    0x4
+#define    RTL8367C_PORT8_QUEUE1_TYPE_OFFSET    1
+#define    RTL8367C_PORT8_QUEUE1_TYPE_MASK    0x2
+#define    RTL8367C_SCHEDULE_QUEUE_TYPE_CTRL4_PORT6_QUEUE0_TYPE_OFFSET    0
+#define    RTL8367C_SCHEDULE_QUEUE_TYPE_CTRL4_PORT6_QUEUE0_TYPE_MASK    0x1
+
+#define    RTL8367C_REG_SCHEDULE_QUEUE_TYPE_CTRL5    0x0307
+#define    RTL8367C_PORT10_QUEUE7_TYPE_OFFSET    7
+#define    RTL8367C_PORT10_QUEUE7_TYPE_MASK    0x80
+#define    RTL8367C_PORT10_QUEUE6_TYPE_OFFSET    6
+#define    RTL8367C_PORT10_QUEUE6_TYPE_MASK    0x40
+#define    RTL8367C_PORT10_QUEUE5_TYPE_OFFSET    5
+#define    RTL8367C_PORT10_QUEUE5_TYPE_MASK    0x20
+#define    RTL8367C_PORT10_QUEUE4_TYPE_OFFSET    4
+#define    RTL8367C_PORT10_QUEUE4_TYPE_MASK    0x10
+#define    RTL8367C_PORT10_QUEUE3_TYPE_OFFSET    3
+#define    RTL8367C_PORT10_QUEUE3_TYPE_MASK    0x8
+#define    RTL8367C_PORT10_QUEUE2_TYPE_OFFSET    2
+#define    RTL8367C_PORT10_QUEUE2_TYPE_MASK    0x4
+#define    RTL8367C_PORT10_QUEUE1_TYPE_OFFSET    1
+#define    RTL8367C_PORT10_QUEUE1_TYPE_MASK    0x2
+#define    RTL8367C_PORT10_QUEUE0_TYPE_OFFSET    0
+#define    RTL8367C_PORT10_QUEUE0_TYPE_MASK    0x1
+
+#define    RTL8367C_REG_SCHEDULE_APR_CTRL0    0x030a
+#define    RTL8367C_PORT10_APR_ENABLE_OFFSET    10
+#define    RTL8367C_PORT10_APR_ENABLE_MASK    0x400
+#define    RTL8367C_PORT9_APR_ENABLE_OFFSET    9
+#define    RTL8367C_PORT9_APR_ENABLE_MASK    0x200
+#define    RTL8367C_PORT8_APR_ENABLE_OFFSET    8
+#define    RTL8367C_PORT8_APR_ENABLE_MASK    0x100
+#define    RTL8367C_PORT7_APR_ENABLE_OFFSET    7
+#define    RTL8367C_PORT7_APR_ENABLE_MASK    0x80
+#define    RTL8367C_PORT6_APR_ENABLE_OFFSET    6
+#define    RTL8367C_PORT6_APR_ENABLE_MASK    0x40
+#define    RTL8367C_PORT5_APR_ENABLE_OFFSET    5
+#define    RTL8367C_PORT5_APR_ENABLE_MASK    0x20
+#define    RTL8367C_PORT4_APR_ENABLE_OFFSET    4
+#define    RTL8367C_PORT4_APR_ENABLE_MASK    0x10
+#define    RTL8367C_PORT3_APR_ENABLE_OFFSET    3
+#define    RTL8367C_PORT3_APR_ENABLE_MASK    0x8
+#define    RTL8367C_PORT2_APR_ENABLE_OFFSET    2
+#define    RTL8367C_PORT2_APR_ENABLE_MASK    0x4
+#define    RTL8367C_PORT1_APR_ENABLE_OFFSET    1
+#define    RTL8367C_PORT1_APR_ENABLE_MASK    0x2
+#define    RTL8367C_PORT0_APR_ENABLE_OFFSET    0
+#define    RTL8367C_PORT0_APR_ENABLE_MASK    0x1
+
+#define    RTL8367C_REG_SCHEDULE_PORT0_QUEUE0_WFQ_WEIGHT    0x030c
+
+#define    RTL8367C_REG_SCHEDULE_PORT0_QUEUE1_WFQ_WEIGHT    0x030d
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE1_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE1_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT0_QUEUE2_WFQ_WEIGHT    0x030e
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE2_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE2_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT0_QUEUE3_WFQ_WEIGHT    0x030f
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE3_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE3_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT0_QUEUE4_WFQ_WEIGHT    0x0310
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE4_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE4_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT0_QUEUE5_WFQ_WEIGHT    0x0311
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE5_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE5_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT0_QUEUE6_WFQ_WEIGHT    0x0312
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE6_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE6_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT0_QUEUE7_WFQ_WEIGHT    0x0313
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE7_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT0_QUEUE7_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT1_QUEUE0_WFQ_WEIGHT    0x0314
+
+#define    RTL8367C_REG_SCHEDULE_PORT1_QUEUE1_WFQ_WEIGHT    0x0315
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE1_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE1_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT1_QUEUE2_WFQ_WEIGHT    0x0316
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE2_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE2_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT1_QUEUE3_WFQ_WEIGHT    0x0317
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE3_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE3_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT1_QUEUE4_WFQ_WEIGHT    0x0318
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE4_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE4_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT1_QUEUE5_WFQ_WEIGHT    0x0319
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE5_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE5_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT1_QUEUE6_WFQ_WEIGHT    0x031a
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE6_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE6_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT1_QUEUE7_WFQ_WEIGHT    0x031b
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE7_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT1_QUEUE7_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT2_QUEUE0_WFQ_WEIGHT    0x031c
+
+#define    RTL8367C_REG_SCHEDULE_PORT2_QUEUE1_WFQ_WEIGHT    0x031d
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE1_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE1_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT2_QUEUE2_WFQ_WEIGHT    0x031e
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE2_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE2_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT2_QUEUE3_WFQ_WEIGHT    0x031f
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE3_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE3_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT2_QUEUE4_WFQ_WEIGHT    0x0320
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE4_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE4_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT2_QUEUE5_WFQ_WEIGHT    0x0321
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE5_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE5_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT2_QUEUE6_WFQ_WEIGHT    0x0322
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE6_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE6_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT2_QUEUE7_WFQ_WEIGHT    0x0323
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE7_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT2_QUEUE7_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT3_QUEUE0_WFQ_WEIGHT    0x0324
+
+#define    RTL8367C_REG_SCHEDULE_PORT3_QUEUE1_WFQ_WEIGHT    0x0325
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE1_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE1_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT3_QUEUE2_WFQ_WEIGHT    0x0326
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE2_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE2_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT3_QUEUE3_WFQ_WEIGHT    0x0327
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE3_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE3_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT3_QUEUE4_WFQ_WEIGHT    0x0328
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE4_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE4_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT3_QUEUE5_WFQ_WEIGHT    0x0329
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE5_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE5_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT3_QUEUE6_WFQ_WEIGHT    0x032a
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE6_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE6_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT3_QUEUE7_WFQ_WEIGHT    0x032b
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE7_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT3_QUEUE7_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT4_QUEUE0_WFQ_WEIGHT    0x032c
+
+#define    RTL8367C_REG_SCHEDULE_PORT4_QUEUE1_WFQ_WEIGHT    0x032d
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE1_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE1_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT4_QUEUE2_WFQ_WEIGHT    0x032e
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE2_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE2_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT4_QUEUE3_WFQ_WEIGHT    0x032f
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE3_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE3_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT4_QUEUE4_WFQ_WEIGHT    0x0330
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE4_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE4_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT4_QUEUE5_WFQ_WEIGHT    0x0331
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE5_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE5_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT4_QUEUE6_WFQ_WEIGHT    0x0332
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE6_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE6_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT4_QUEUE7_WFQ_WEIGHT    0x0333
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE7_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT4_QUEUE7_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT5_QUEUE0_WFQ_WEIGHT    0x0334
+
+#define    RTL8367C_REG_SCHEDULE_PORT5_QUEUE1_WFQ_WEIGHT    0x0335
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE1_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE1_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT5_QUEUE2_WFQ_WEIGHT    0x0336
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE2_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE2_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT5_QUEUE3_WFQ_WEIGHT    0x0337
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE3_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE3_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT5_QUEUE4_WFQ_WEIGHT    0x0338
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE4_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE4_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT5_QUEUE5_WFQ_WEIGHT    0x0339
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE5_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE5_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT5_QUEUE6_WFQ_WEIGHT    0x033a
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE6_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE6_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT5_QUEUE7_WFQ_WEIGHT    0x033b
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE7_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT5_QUEUE7_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT6_QUEUE0_WFQ_WEIGHT    0x033c
+
+#define    RTL8367C_REG_SCHEDULE_PORT6_QUEUE1_WFQ_WEIGHT    0x033d
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE1_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE1_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT6_QUEUE2_WFQ_WEIGHT    0x033e
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE2_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE2_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT6_QUEUE3_WFQ_WEIGHT    0x033f
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE3_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE3_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT6_QUEUE4_WFQ_WEIGHT    0x0340
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE4_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE4_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT6_QUEUE5_WFQ_WEIGHT    0x0341
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE5_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE5_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT6_QUEUE6_WFQ_WEIGHT    0x0342
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE6_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE6_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT6_QUEUE7_WFQ_WEIGHT    0x0343
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE7_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT6_QUEUE7_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT7_QUEUE0_WFQ_WEIGHT    0x0344
+
+#define    RTL8367C_REG_SCHEDULE_PORT7_QUEUE1_WFQ_WEIGHT    0x0345
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE1_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE1_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT7_QUEUE2_WFQ_WEIGHT    0x0346
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE2_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE2_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT7_QUEUE3_WFQ_WEIGHT    0x0347
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE3_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE3_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT7_QUEUE4_WFQ_WEIGHT    0x0348
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE4_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE4_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT7_QUEUE5_WFQ_WEIGHT    0x0349
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE5_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE5_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT7_QUEUE6_WFQ_WEIGHT    0x034a
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE6_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE6_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT7_QUEUE7_WFQ_WEIGHT    0x034b
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE7_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT7_QUEUE7_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT8_QUEUE0_WFQ_WEIGHT    0x034c
+
+#define    RTL8367C_REG_SCHEDULE_PORT8_QUEUE1_WFQ_WEIGHT    0x034d
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE1_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE1_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT8_QUEUE2_WFQ_WEIGHT    0x034e
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE2_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE2_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT8_QUEUE3_WFQ_WEIGHT    0x034f
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE3_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE3_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT8_QUEUE4_WFQ_WEIGHT    0x0350
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE4_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE4_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT8_QUEUE5_WFQ_WEIGHT    0x0351
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE5_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE5_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT8_QUEUE6_WFQ_WEIGHT    0x0352
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE6_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE6_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT8_QUEUE7_WFQ_WEIGHT    0x0353
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE7_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT8_QUEUE7_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT9_QUEUE0_WFQ_WEIGHT    0x0354
+
+#define    RTL8367C_REG_SCHEDULE_PORT9_QUEUE1_WFQ_WEIGHT    0x0355
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE1_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE1_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT9_QUEUE2_WFQ_WEIGHT    0x0356
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE2_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE2_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT9_QUEUE3_WFQ_WEIGHT    0x0357
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE3_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE3_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT9_QUEUE4_WFQ_WEIGHT    0x0358
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE4_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE4_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT9_QUEUE5_WFQ_WEIGHT    0x0359
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE5_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE5_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT9_QUEUE6_WFQ_WEIGHT    0x035a
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE6_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE6_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT9_QUEUE7_WFQ_WEIGHT    0x035b
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE7_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT9_QUEUE7_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT10_QUEUE0_WFQ_WEIGHT    0x035c
+
+#define    RTL8367C_REG_SCHEDULE_PORT10_QUEUE1_WFQ_WEIGHT    0x035d
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE1_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE1_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT10_QUEUE2_WFQ_WEIGHT    0x035e
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE2_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE2_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT10_QUEUE3_WFQ_WEIGHT    0x035f
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE3_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE3_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT10_QUEUE4_WFQ_WEIGHT    0x0360
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE4_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE4_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT10_QUEUE5_WFQ_WEIGHT    0x0361
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE5_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE5_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT10_QUEUE6_WFQ_WEIGHT    0x0362
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE6_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE6_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_SCHEDULE_PORT10_QUEUE7_WFQ_WEIGHT    0x0363
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE7_WFQ_WEIGHT_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT10_QUEUE7_WFQ_WEIGHT_MASK    0x7F
+
+#define    RTL8367C_REG_PORT0_EGRESSBW_CTRL0    0x038c
+
+#define    RTL8367C_REG_PORT0_EGRESSBW_CTRL1    0x038d
+#define    RTL8367C_PORT0_EGRESSBW_CTRL1_OFFSET    0
+#define    RTL8367C_PORT0_EGRESSBW_CTRL1_MASK    0x1
+
+#define    RTL8367C_REG_PORT1_EGRESSBW_CTRL0    0x038e
+
+#define    RTL8367C_REG_PORT1_EGRESSBW_CTRL1    0x038f
+#define    RTL8367C_PORT1_EGRESSBW_CTRL1_OFFSET    0
+#define    RTL8367C_PORT1_EGRESSBW_CTRL1_MASK    0x1
+
+#define    RTL8367C_REG_PORT2_EGRESSBW_CTRL0    0x0390
+
+#define    RTL8367C_REG_PORT2_EGRESSBW_CTRL1    0x0391
+#define    RTL8367C_PORT2_EGRESSBW_CTRL1_OFFSET    0
+#define    RTL8367C_PORT2_EGRESSBW_CTRL1_MASK    0x1
+
+#define    RTL8367C_REG_PORT3_EGRESSBW_CTRL0    0x0392
+
+#define    RTL8367C_REG_PORT3_EGRESSBW_CTRL1    0x0393
+#define    RTL8367C_PORT3_EGRESSBW_CTRL1_OFFSET    0
+#define    RTL8367C_PORT3_EGRESSBW_CTRL1_MASK    0x1
+
+#define    RTL8367C_REG_PORT4_EGRESSBW_CTRL0    0x0394
+
+#define    RTL8367C_REG_PORT4_EGRESSBW_CTRL1    0x0395
+#define    RTL8367C_PORT4_EGRESSBW_CTRL1_OFFSET    0
+#define    RTL8367C_PORT4_EGRESSBW_CTRL1_MASK    0x1
+
+#define    RTL8367C_REG_PORT5_EGRESSBW_CTRL0    0x0396
+
+#define    RTL8367C_REG_PORT5_EGRESSBW_CTRL1    0x0397
+#define    RTL8367C_PORT5_EGRESSBW_CTRL1_OFFSET    0
+#define    RTL8367C_PORT5_EGRESSBW_CTRL1_MASK    0x1
+
+#define    RTL8367C_REG_PORT6_EGRESSBW_CTRL0    0x0398
+
+#define    RTL8367C_REG_PORT6_EGRESSBW_CTRL1    0x0399
+#define    RTL8367C_PORT6_EGRESSBW_CTRL1_OFFSET    0
+#define    RTL8367C_PORT6_EGRESSBW_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_PORT7_EGRESSBW_CTRL0    0x039a
+
+#define    RTL8367C_REG_PORT7_EGRESSBW_CTRL1    0x039b
+#define    RTL8367C_PORT7_EGRESSBW_CTRL1_OFFSET    0
+#define    RTL8367C_PORT7_EGRESSBW_CTRL1_MASK    0x1
+
+#define    RTL8367C_REG_PORT8_EGRESSBW_CTRL0    0x039c
+
+#define    RTL8367C_REG_PORT8_EGRESSBW_CTRL1    0x039d
+#define    RTL8367C_PORT8_EGRESSBW_CTRL1_OFFSET    0
+#define    RTL8367C_PORT8_EGRESSBW_CTRL1_MASK    0x1
+
+#define    RTL8367C_REG_PORT9_EGRESSBW_CTRL0    0x039e
+
+#define    RTL8367C_REG_PORT9_EGRESSBW_CTRL1    0x039f
+#define    RTL8367C_PORT9_EGRESSBW_CTRL1_OFFSET    0
+#define    RTL8367C_PORT9_EGRESSBW_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_PORT10_EGRESSBW_CTRL0    0x03a0
+
+#define    RTL8367C_REG_PORT10_EGRESSBW_CTRL1    0x03a1
+#define    RTL8367C_PORT10_EGRESSBW_CTRL1_OFFSET    0
+#define    RTL8367C_PORT10_EGRESSBW_CTRL1_MASK    0x1
+
+#define    RTL8367C_REG_SCHEDULE_PORT0_APR_METER_CTRL0    0x03ac
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL0_QUEUE4_APR_METER_OFFSET    12
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL0_QUEUE4_APR_METER_MASK    0x7000
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL0_QUEUE3_APR_METER_OFFSET    9
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL0_QUEUE3_APR_METER_MASK    0xE00
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL0_QUEUE2_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL0_QUEUE2_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL0_QUEUE1_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL0_QUEUE1_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL0_QUEUE0_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL0_QUEUE0_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT0_APR_METER_CTRL1    0x03ad
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL1_QUEUE7_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL1_QUEUE7_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL1_QUEUE6_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL1_QUEUE6_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL1_QUEUE5_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT0_APR_METER_CTRL1_QUEUE5_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT1_APR_METER_CTRL0    0x03b0
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL0_QUEUE4_APR_METER_OFFSET    12
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL0_QUEUE4_APR_METER_MASK    0x7000
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL0_QUEUE3_APR_METER_OFFSET    9
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL0_QUEUE3_APR_METER_MASK    0xE00
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL0_QUEUE2_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL0_QUEUE2_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL0_QUEUE1_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL0_QUEUE1_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL0_QUEUE0_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL0_QUEUE0_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT1_APR_METER_CTRL1    0x03b1
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL1_QUEUE7_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL1_QUEUE7_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL1_QUEUE6_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL1_QUEUE6_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL1_QUEUE5_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT1_APR_METER_CTRL1_QUEUE5_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT2_APR_METER_CTRL0    0x03b4
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL0_QUEUE4_APR_METER_OFFSET    12
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL0_QUEUE4_APR_METER_MASK    0x7000
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL0_QUEUE3_APR_METER_OFFSET    9
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL0_QUEUE3_APR_METER_MASK    0xE00
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL0_QUEUE2_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL0_QUEUE2_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL0_QUEUE1_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL0_QUEUE1_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL0_QUEUE0_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL0_QUEUE0_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT2_APR_METER_CTRL1    0x03b5
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL1_QUEUE7_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL1_QUEUE7_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL1_QUEUE6_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL1_QUEUE6_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL1_QUEUE5_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT2_APR_METER_CTRL1_QUEUE5_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT3_APR_METER_CTRL0    0x03b8
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL0_QUEUE4_APR_METER_OFFSET    12
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL0_QUEUE4_APR_METER_MASK    0x7000
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL0_QUEUE3_APR_METER_OFFSET    9
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL0_QUEUE3_APR_METER_MASK    0xE00
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL0_QUEUE2_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL0_QUEUE2_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL0_QUEUE1_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL0_QUEUE1_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL0_QUEUE0_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL0_QUEUE0_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT3_APR_METER_CTRL1    0x03b9
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL1_QUEUE7_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL1_QUEUE7_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL1_QUEUE6_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL1_QUEUE6_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL1_QUEUE5_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT3_APR_METER_CTRL1_QUEUE5_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT4_APR_METER_CTRL0    0x03bc
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL0_QUEUE4_APR_METER_OFFSET    12
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL0_QUEUE4_APR_METER_MASK    0x7000
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL0_QUEUE3_APR_METER_OFFSET    9
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL0_QUEUE3_APR_METER_MASK    0xE00
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL0_QUEUE2_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL0_QUEUE2_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL0_QUEUE1_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL0_QUEUE1_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL0_QUEUE0_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL0_QUEUE0_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT4_APR_METER_CTRL1    0x03bd
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL1_QUEUE7_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL1_QUEUE7_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL1_QUEUE6_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL1_QUEUE6_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL1_QUEUE5_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT4_APR_METER_CTRL1_QUEUE5_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT5_APR_METER_CTRL0    0x03c0
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL0_QUEUE4_APR_METER_OFFSET    12
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL0_QUEUE4_APR_METER_MASK    0x7000
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL0_QUEUE3_APR_METER_OFFSET    9
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL0_QUEUE3_APR_METER_MASK    0xE00
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL0_QUEUE2_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL0_QUEUE2_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL0_QUEUE1_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL0_QUEUE1_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL0_QUEUE0_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL0_QUEUE0_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT5_APR_METER_CTRL1    0x03c1
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL1_QUEUE7_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL1_QUEUE7_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL1_QUEUE6_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL1_QUEUE6_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL1_QUEUE5_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT5_APR_METER_CTRL1_QUEUE5_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT6_APR_METER_CTRL0    0x03c4
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL0_QUEUE4_APR_METER_OFFSET    12
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL0_QUEUE4_APR_METER_MASK    0x7000
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL0_QUEUE3_APR_METER_OFFSET    9
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL0_QUEUE3_APR_METER_MASK    0xE00
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL0_QUEUE2_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL0_QUEUE2_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL0_QUEUE1_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL0_QUEUE1_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL0_QUEUE0_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL0_QUEUE0_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT6_APR_METER_CTRL1    0x03c5
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL1_QUEUE7_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL1_QUEUE7_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL1_QUEUE6_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL1_QUEUE6_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL1_QUEUE5_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT6_APR_METER_CTRL1_QUEUE5_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT7_APR_METER_CTRL0    0x03c8
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL0_QUEUE4_APR_METER_OFFSET    12
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL0_QUEUE4_APR_METER_MASK    0x7000
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL0_QUEUE3_APR_METER_OFFSET    9
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL0_QUEUE3_APR_METER_MASK    0xE00
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL0_QUEUE2_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL0_QUEUE2_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL0_QUEUE1_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL0_QUEUE1_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL0_QUEUE0_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL0_QUEUE0_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT7_APR_METER_CTRL1    0x03c9
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL1_QUEUE7_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL1_QUEUE7_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL1_QUEUE6_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL1_QUEUE6_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL1_QUEUE5_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT7_APR_METER_CTRL1_QUEUE5_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT8_APR_METER_CTRL0    0x03ca
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL0_QUEUE4_APR_METER_OFFSET    12
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL0_QUEUE4_APR_METER_MASK    0x7000
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL0_QUEUE3_APR_METER_OFFSET    9
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL0_QUEUE3_APR_METER_MASK    0xE00
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL0_QUEUE2_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL0_QUEUE2_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL0_QUEUE1_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL0_QUEUE1_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL0_QUEUE0_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL0_QUEUE0_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT8_APR_METER_CTRL1    0x03cb
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL1_QUEUE7_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL1_QUEUE7_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL1_QUEUE6_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL1_QUEUE6_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL1_QUEUE5_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT8_APR_METER_CTRL1_QUEUE5_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT9_APR_METER_CTRL0    0x03cc
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL0_QUEUE4_APR_METER_OFFSET    12
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL0_QUEUE4_APR_METER_MASK    0x7000
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL0_QUEUE3_APR_METER_OFFSET    9
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL0_QUEUE3_APR_METER_MASK    0xE00
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL0_QUEUE2_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL0_QUEUE2_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL0_QUEUE1_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL0_QUEUE1_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL0_QUEUE0_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL0_QUEUE0_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT9_APR_METER_CTRL1    0x03cd
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL1_QUEUE7_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL1_QUEUE7_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL1_QUEUE6_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL1_QUEUE6_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL1_QUEUE5_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT9_APR_METER_CTRL1_QUEUE5_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT10_APR_METER_CTRL0    0x03ce
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL0_QUEUE4_APR_METER_OFFSET    12
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL0_QUEUE4_APR_METER_MASK    0x7000
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL0_QUEUE3_APR_METER_OFFSET    9
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL0_QUEUE3_APR_METER_MASK    0xE00
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL0_QUEUE2_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL0_QUEUE2_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL0_QUEUE1_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL0_QUEUE1_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL0_QUEUE0_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL0_QUEUE0_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_SCHEDULE_PORT10_APR_METER_CTRL1    0x03cf
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL1_QUEUE7_APR_METER_OFFSET    6
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL1_QUEUE7_APR_METER_MASK    0x1C0
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL1_QUEUE6_APR_METER_OFFSET    3
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL1_QUEUE6_APR_METER_MASK    0x38
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL1_QUEUE5_APR_METER_OFFSET    0
+#define    RTL8367C_SCHEDULE_PORT10_APR_METER_CTRL1_QUEUE5_APR_METER_MASK    0x7
+
+#define    RTL8367C_REG_LINE_RATE_1G_L    0x03ec
+
+#define    RTL8367C_REG_LINE_RATE_1G_H    0x03ed
+#define    RTL8367C_LINE_RATE_1G_H_OFFSET    0
+#define    RTL8367C_LINE_RATE_1G_H_MASK    0x1
+
+#define    RTL8367C_REG_LINE_RATE_100_L    0x03ee
+
+#define    RTL8367C_REG_LINE_RATE_100_H    0x03ef
+#define    RTL8367C_LINE_RATE_100_H_OFFSET    0
+#define    RTL8367C_LINE_RATE_100_H_MASK    0x1
+
+#define    RTL8367C_REG_LINE_RATE_10_L    0x03f0
+
+#define    RTL8367C_REG_LINE_RATE_10_H    0x03f1
+#define    RTL8367C_LINE_RATE_10_H_OFFSET    0
+#define    RTL8367C_LINE_RATE_10_H_MASK    0x1
+
+#define    RTL8367C_REG_DUMMY_03f2    0x03f2
+
+#define    RTL8367C_REG_DUMMY_03f3    0x03f3
+
+#define    RTL8367C_REG_DUMMY_03f4    0x03f4
+
+#define    RTL8367C_REG_DUMMY_03f5    0x03f5
+
+#define    RTL8367C_REG_DUMMY_03f6    0x03f6
+
+#define    RTL8367C_REG_BYPASS_LINE_RATE    0x03f7
+#define    RTL8367C_BYPASS_PORT10_CONSTRAINT_OFFSET    5
+#define    RTL8367C_BYPASS_PORT10_CONSTRAINT_MASK    0x20
+#define    RTL8367C_BYPASS_PORT9_CONSTRAINT_OFFSET    4
+#define    RTL8367C_BYPASS_PORT9_CONSTRAINT_MASK    0x10
+#define    RTL8367C_BYPASS_PORT8_CONSTRAINT_OFFSET    3
+#define    RTL8367C_BYPASS_PORT8_CONSTRAINT_MASK    0x8
+#define    RTL8367C_BYPASS_PORT7_CONSTRAINT_OFFSET    2
+#define    RTL8367C_BYPASS_PORT7_CONSTRAINT_MASK    0x4
+#define    RTL8367C_BYPASS_PORT6_CONSTRAINT_OFFSET    1
+#define    RTL8367C_BYPASS_PORT6_CONSTRAINT_MASK    0x2
+#define    RTL8367C_BYPASS_PORT5_CONSTRAINT_OFFSET    0
+#define    RTL8367C_BYPASS_PORT5_CONSTRAINT_MASK    0x1
+
+#define    RTL8367C_REG_LINE_RATE_500_H    0x03f8
+#define    RTL8367C_LINE_RATE_500_H_OFFSET    0
+#define    RTL8367C_LINE_RATE_500_H_MASK    0x7
+
+#define    RTL8367C_REG_LINE_RATE_500_L    0x03f9
+
+#define    RTL8367C_REG_LINE_RATE_HSG_H    0x03fa
+#define    RTL8367C_LINE_RATE_HSG_H_OFFSET    0
+#define    RTL8367C_LINE_RATE_HSG_H_MASK    0x7
+
+#define    RTL8367C_REG_LINE_RATE_HSG_L    0x03fb
+
+/* (16'h0500)table_reg */
+
+#define    RTL8367C_REG_TABLE_ACCESS_CTRL    0x0500
+#define    RTL8367C_TABLE_ACCESS_CTRL_SPA_OFFSET    8
+#define    RTL8367C_TABLE_ACCESS_CTRL_SPA_MASK    0xF00
+#define    RTL8367C_ACCESS_METHOD_OFFSET    4
+#define    RTL8367C_ACCESS_METHOD_MASK    0x70
+#define    RTL8367C_COMMAND_TYPE_OFFSET    3
+#define    RTL8367C_COMMAND_TYPE_MASK    0x8
+#define    RTL8367C_TABLE_TYPE_OFFSET    0
+#define    RTL8367C_TABLE_TYPE_MASK    0x7
+
+#define    RTL8367C_REG_TABLE_ACCESS_ADDR    0x0501
+#define    RTL8367C_TABLE_ACCESS_ADDR_OFFSET    0
+#define    RTL8367C_TABLE_ACCESS_ADDR_MASK    0x1FFF
+
+#define    RTL8367C_REG_TABLE_LUT_ADDR    0x0502
+#define    RTL8367C_ADDRESS2_OFFSET    14
+#define    RTL8367C_ADDRESS2_MASK    0x4000
+#define    RTL8367C_TABLE_LUT_ADDR_BUSY_FLAG_OFFSET    13
+#define    RTL8367C_TABLE_LUT_ADDR_BUSY_FLAG_MASK    0x2000
+#define    RTL8367C_HIT_STATUS_OFFSET    12
+#define    RTL8367C_HIT_STATUS_MASK    0x1000
+#define    RTL8367C_TABLE_LUT_ADDR_TYPE_OFFSET    11
+#define    RTL8367C_TABLE_LUT_ADDR_TYPE_MASK    0x800
+#define    RTL8367C_TABLE_LUT_ADDR_ADDRESS_OFFSET    0
+#define    RTL8367C_TABLE_LUT_ADDR_ADDRESS_MASK    0x7FF
+
+#define    RTL8367C_REG_HSA_HSB_LATCH    0x0503
+#define    RTL8367C_LATCH_ALWAYS_OFFSET    15
+#define    RTL8367C_LATCH_ALWAYS_MASK    0x8000
+#define    RTL8367C_LATCH_FIRST_OFFSET    14
+#define    RTL8367C_LATCH_FIRST_MASK    0x4000
+#define    RTL8367C_SPA_EN_OFFSET    13
+#define    RTL8367C_SPA_EN_MASK    0x2000
+#define    RTL8367C_FORWARD_EN_OFFSET    12
+#define    RTL8367C_FORWARD_EN_MASK    0x1000
+#define    RTL8367C_REASON_EN_OFFSET    11
+#define    RTL8367C_REASON_EN_MASK    0x800
+#define    RTL8367C_HSA_HSB_LATCH_SPA_OFFSET    8
+#define    RTL8367C_HSA_HSB_LATCH_SPA_MASK    0x700
+#define    RTL8367C_FORWARD_OFFSET    6
+#define    RTL8367C_FORWARD_MASK    0xC0
+#define    RTL8367C_REASON_OFFSET    0
+#define    RTL8367C_REASON_MASK    0x3F
+
+#define    RTL8367C_REG_HSA_HSB_LATCH2    0x0504
+#define    RTL8367C_HSA_HSB_LATCH2_Reserved_OFFSET    1
+#define    RTL8367C_HSA_HSB_LATCH2_Reserved_MASK    0xFFFE
+#define    RTL8367C_SPA2_OFFSET    0
+#define    RTL8367C_SPA2_MASK    0x1
+
+#define    RTL8367C_REG_TABLE_WRITE_DATA0    0x0510
+
+#define    RTL8367C_REG_TABLE_WRITE_DATA1    0x0511
+
+#define    RTL8367C_REG_TABLE_WRITE_DATA2    0x0512
+
+#define    RTL8367C_REG_TABLE_WRITE_DATA3    0x0513
+
+#define    RTL8367C_REG_TABLE_WRITE_DATA4    0x0514
+
+#define    RTL8367C_REG_TABLE_WRITE_DATA5    0x0515
+
+#define    RTL8367C_REG_TABLE_WRITE_DATA6    0x0516
+
+#define    RTL8367C_REG_TABLE_WRITE_DATA7    0x0517
+
+#define    RTL8367C_REG_TABLE_WRITE_DATA8    0x0518
+
+#define    RTL8367C_REG_TABLE_WRITE_DATA9    0x0519
+#define    RTL8367C_TABLE_WRITE_DATA9_OFFSET    0
+#define    RTL8367C_TABLE_WRITE_DATA9_MASK    0xF
+
+#define    RTL8367C_REG_TABLE_READ_DATA0    0x0520
+
+#define    RTL8367C_REG_TABLE_READ_DATA1    0x0521
+
+#define    RTL8367C_REG_TABLE_READ_DATA2    0x0522
+
+#define    RTL8367C_REG_TABLE_READ_DATA3    0x0523
+
+#define    RTL8367C_REG_TABLE_READ_DATA4    0x0524
+
+#define    RTL8367C_REG_TABLE_READ_DATA5    0x0525
+
+#define    RTL8367C_REG_TABLE_READ_DATA6    0x0526
+
+#define    RTL8367C_REG_TABLE_READ_DATA7    0x0527
+
+#define    RTL8367C_REG_TABLE_READ_DATA8    0x0528
+
+#define    RTL8367C_REG_TABLE_READ_DATA9    0x0529
+#define    RTL8367C_TABLE_READ_DATA9_OFFSET    0
+#define    RTL8367C_TABLE_READ_DATA9_MASK    0xF
+
+#define    RTL8367C_REG_TBL_DUMMY00    0x0550
+
+#define    RTL8367C_REG_TBL_DUMMY01    0x0551
+
+/* (16'h0600)acl_reg */
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE0_CTRL0    0x0600
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL0_FIELD1_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL0_FIELD1_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL0_FIELD0_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL0_FIELD0_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE0_CTRL1    0x0601
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL1_FIELD3_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL1_FIELD3_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL1_FIELD2_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL1_FIELD2_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE0_CTRL2    0x0602
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL2_FIELD5_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL2_FIELD5_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL2_FIELD4_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL2_FIELD4_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE0_CTRL3    0x0603
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL3_FIELD7_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL3_FIELD7_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL3_FIELD6_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE0_CTRL3_FIELD6_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE1_CTRL0    0x0604
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL0_FIELD1_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL0_FIELD1_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL0_FIELD0_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL0_FIELD0_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE1_CTRL1    0x0605
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL1_FIELD3_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL1_FIELD3_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL1_FIELD2_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL1_FIELD2_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE1_CTRL2    0x0606
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL2_FIELD5_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL2_FIELD5_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL2_FIELD4_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL2_FIELD4_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE1_CTRL3    0x0607
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL3_FIELD7_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL3_FIELD7_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL3_FIELD6_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE1_CTRL3_FIELD6_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE2_CTRL0    0x0608
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL0_FIELD1_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL0_FIELD1_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL0_FIELD0_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL0_FIELD0_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE2_CTRL1    0x0609
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL1_FIELD3_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL1_FIELD3_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL1_FIELD2_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL1_FIELD2_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE2_CTRL2    0x060a
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL2_FIELD5_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL2_FIELD5_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL2_FIELD4_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL2_FIELD4_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE2_CTRL3    0x060b
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL3_FIELD7_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL3_FIELD7_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL3_FIELD6_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE2_CTRL3_FIELD6_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE3_CTRL0    0x060c
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL0_FIELD1_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL0_FIELD1_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL0_FIELD0_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL0_FIELD0_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE3_CTRL1    0x060d
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL1_FIELD3_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL1_FIELD3_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL1_FIELD2_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL1_FIELD2_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE3_CTRL2    0x060e
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL2_FIELD5_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL2_FIELD5_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL2_FIELD4_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL2_FIELD4_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE3_CTRL3    0x060f
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL3_FIELD7_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL3_FIELD7_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL3_FIELD6_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE3_CTRL3_FIELD6_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE4_CTRL0    0x0610
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL0_FIELD1_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL0_FIELD1_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL0_FIELD0_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL0_FIELD0_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE4_CTRL1    0x0611
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL1_FIELD3_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL1_FIELD3_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL1_FIELD2_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL1_FIELD2_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE4_CTRL2    0x0612
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL2_FIELD5_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL2_FIELD5_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL2_FIELD4_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL2_FIELD4_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_RULE_TEMPLATE4_CTRL3    0x0613
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL3_FIELD7_OFFSET    8
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL3_FIELD7_MASK    0x7F00
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL3_FIELD6_OFFSET    0
+#define    RTL8367C_ACL_RULE_TEMPLATE4_CTRL3_FIELD6_MASK    0x7F
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL0    0x0614
+#define    RTL8367C_OP1_NOT_OFFSET    14
+#define    RTL8367C_OP1_NOT_MASK    0x4000
+#define    RTL8367C_ACT1_GPIO_OFFSET    13
+#define    RTL8367C_ACT1_GPIO_MASK    0x2000
+#define    RTL8367C_ACT1_FORWARD_OFFSET    12
+#define    RTL8367C_ACT1_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT1_POLICING_OFFSET    11
+#define    RTL8367C_ACT1_POLICING_MASK    0x800
+#define    RTL8367C_ACT1_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT1_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT1_SVID_OFFSET    9
+#define    RTL8367C_ACT1_SVID_MASK    0x200
+#define    RTL8367C_ACT1_CVID_OFFSET    8
+#define    RTL8367C_ACT1_CVID_MASK    0x100
+#define    RTL8367C_OP0_NOT_OFFSET    6
+#define    RTL8367C_OP0_NOT_MASK    0x40
+#define    RTL8367C_ACT0_GPIO_OFFSET    5
+#define    RTL8367C_ACT0_GPIO_MASK    0x20
+#define    RTL8367C_ACT0_FORWARD_OFFSET    4
+#define    RTL8367C_ACT0_FORWARD_MASK    0x10
+#define    RTL8367C_ACT0_POLICING_OFFSET    3
+#define    RTL8367C_ACT0_POLICING_MASK    0x8
+#define    RTL8367C_ACT0_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT0_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT0_SVID_OFFSET    1
+#define    RTL8367C_ACT0_SVID_MASK    0x2
+#define    RTL8367C_ACT0_CVID_OFFSET    0
+#define    RTL8367C_ACT0_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL1    0x0615
+#define    RTL8367C_OP3_NOT_OFFSET    14
+#define    RTL8367C_OP3_NOT_MASK    0x4000
+#define    RTL8367C_ACT3_GPIO_OFFSET    13
+#define    RTL8367C_ACT3_GPIO_MASK    0x2000
+#define    RTL8367C_ACT3_FORWARD_OFFSET    12
+#define    RTL8367C_ACT3_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT3_POLICING_OFFSET    11
+#define    RTL8367C_ACT3_POLICING_MASK    0x800
+#define    RTL8367C_ACT3_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT3_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT3_SVID_OFFSET    9
+#define    RTL8367C_ACT3_SVID_MASK    0x200
+#define    RTL8367C_ACT3_CVID_OFFSET    8
+#define    RTL8367C_ACT3_CVID_MASK    0x100
+#define    RTL8367C_OP2_NOT_OFFSET    6
+#define    RTL8367C_OP2_NOT_MASK    0x40
+#define    RTL8367C_ACT2_GPIO_OFFSET    5
+#define    RTL8367C_ACT2_GPIO_MASK    0x20
+#define    RTL8367C_ACT2_FORWARD_OFFSET    4
+#define    RTL8367C_ACT2_FORWARD_MASK    0x10
+#define    RTL8367C_ACT2_POLICING_OFFSET    3
+#define    RTL8367C_ACT2_POLICING_MASK    0x8
+#define    RTL8367C_ACT2_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT2_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT2_SVID_OFFSET    1
+#define    RTL8367C_ACT2_SVID_MASK    0x2
+#define    RTL8367C_ACT2_CVID_OFFSET    0
+#define    RTL8367C_ACT2_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL2    0x0616
+#define    RTL8367C_OP5_NOT_OFFSET    14
+#define    RTL8367C_OP5_NOT_MASK    0x4000
+#define    RTL8367C_ACT5_GPIO_OFFSET    13
+#define    RTL8367C_ACT5_GPIO_MASK    0x2000
+#define    RTL8367C_ACT5_FORWARD_OFFSET    12
+#define    RTL8367C_ACT5_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT5_POLICING_OFFSET    11
+#define    RTL8367C_ACT5_POLICING_MASK    0x800
+#define    RTL8367C_ACT5_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT5_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT5_SVID_OFFSET    9
+#define    RTL8367C_ACT5_SVID_MASK    0x200
+#define    RTL8367C_ACT5_CVID_OFFSET    8
+#define    RTL8367C_ACT5_CVID_MASK    0x100
+#define    RTL8367C_OP4_NOT_OFFSET    6
+#define    RTL8367C_OP4_NOT_MASK    0x40
+#define    RTL8367C_ACT4_GPIO_OFFSET    5
+#define    RTL8367C_ACT4_GPIO_MASK    0x20
+#define    RTL8367C_ACT4_FORWARD_OFFSET    4
+#define    RTL8367C_ACT4_FORWARD_MASK    0x10
+#define    RTL8367C_ACT4_POLICING_OFFSET    3
+#define    RTL8367C_ACT4_POLICING_MASK    0x8
+#define    RTL8367C_ACT4_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT4_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT4_SVID_OFFSET    1
+#define    RTL8367C_ACT4_SVID_MASK    0x2
+#define    RTL8367C_ACT4_CVID_OFFSET    0
+#define    RTL8367C_ACT4_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL3    0x0617
+#define    RTL8367C_OP7_NOT_OFFSET    14
+#define    RTL8367C_OP7_NOT_MASK    0x4000
+#define    RTL8367C_ACT7_GPIO_OFFSET    13
+#define    RTL8367C_ACT7_GPIO_MASK    0x2000
+#define    RTL8367C_ACT7_FORWARD_OFFSET    12
+#define    RTL8367C_ACT7_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT7_POLICING_OFFSET    11
+#define    RTL8367C_ACT7_POLICING_MASK    0x800
+#define    RTL8367C_ACT7_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT7_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT7_SVID_OFFSET    9
+#define    RTL8367C_ACT7_SVID_MASK    0x200
+#define    RTL8367C_ACT7_CVID_OFFSET    8
+#define    RTL8367C_ACT7_CVID_MASK    0x100
+#define    RTL8367C_OP6_NOT_OFFSET    6
+#define    RTL8367C_OP6_NOT_MASK    0x40
+#define    RTL8367C_ACT6_GPIO_OFFSET    5
+#define    RTL8367C_ACT6_GPIO_MASK    0x20
+#define    RTL8367C_ACT6_FORWARD_OFFSET    4
+#define    RTL8367C_ACT6_FORWARD_MASK    0x10
+#define    RTL8367C_ACT6_POLICING_OFFSET    3
+#define    RTL8367C_ACT6_POLICING_MASK    0x8
+#define    RTL8367C_ACT6_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT6_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT6_SVID_OFFSET    1
+#define    RTL8367C_ACT6_SVID_MASK    0x2
+#define    RTL8367C_ACT6_CVID_OFFSET    0
+#define    RTL8367C_ACT6_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL4    0x0618
+#define    RTL8367C_OP9_NOT_OFFSET    14
+#define    RTL8367C_OP9_NOT_MASK    0x4000
+#define    RTL8367C_ACT9_GPIO_OFFSET    13
+#define    RTL8367C_ACT9_GPIO_MASK    0x2000
+#define    RTL8367C_ACT9_FORWARD_OFFSET    12
+#define    RTL8367C_ACT9_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT9_POLICING_OFFSET    11
+#define    RTL8367C_ACT9_POLICING_MASK    0x800
+#define    RTL8367C_ACT9_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT9_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT9_SVID_OFFSET    9
+#define    RTL8367C_ACT9_SVID_MASK    0x200
+#define    RTL8367C_ACT9_CVID_OFFSET    8
+#define    RTL8367C_ACT9_CVID_MASK    0x100
+#define    RTL8367C_OP8_NOT_OFFSET    6
+#define    RTL8367C_OP8_NOT_MASK    0x40
+#define    RTL8367C_ACT8_GPIO_OFFSET    5
+#define    RTL8367C_ACT8_GPIO_MASK    0x20
+#define    RTL8367C_ACT8_FORWARD_OFFSET    4
+#define    RTL8367C_ACT8_FORWARD_MASK    0x10
+#define    RTL8367C_ACT8_POLICING_OFFSET    3
+#define    RTL8367C_ACT8_POLICING_MASK    0x8
+#define    RTL8367C_ACT8_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT8_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT8_SVID_OFFSET    1
+#define    RTL8367C_ACT8_SVID_MASK    0x2
+#define    RTL8367C_ACT8_CVID_OFFSET    0
+#define    RTL8367C_ACT8_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL5    0x0619
+#define    RTL8367C_OP11_NOT_OFFSET    14
+#define    RTL8367C_OP11_NOT_MASK    0x4000
+#define    RTL8367C_ACT11_GPIO_OFFSET    13
+#define    RTL8367C_ACT11_GPIO_MASK    0x2000
+#define    RTL8367C_ACT11_FORWARD_OFFSET    12
+#define    RTL8367C_ACT11_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT11_POLICING_OFFSET    11
+#define    RTL8367C_ACT11_POLICING_MASK    0x800
+#define    RTL8367C_ACT11_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT11_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT11_SVID_OFFSET    9
+#define    RTL8367C_ACT11_SVID_MASK    0x200
+#define    RTL8367C_ACT11_CVID_OFFSET    8
+#define    RTL8367C_ACT11_CVID_MASK    0x100
+#define    RTL8367C_OP10_NOT_OFFSET    6
+#define    RTL8367C_OP10_NOT_MASK    0x40
+#define    RTL8367C_ACT10_GPIO_OFFSET    5
+#define    RTL8367C_ACT10_GPIO_MASK    0x20
+#define    RTL8367C_ACT10_FORWARD_OFFSET    4
+#define    RTL8367C_ACT10_FORWARD_MASK    0x10
+#define    RTL8367C_ACT10_POLICING_OFFSET    3
+#define    RTL8367C_ACT10_POLICING_MASK    0x8
+#define    RTL8367C_ACT10_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT10_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT10_SVID_OFFSET    1
+#define    RTL8367C_ACT10_SVID_MASK    0x2
+#define    RTL8367C_ACT10_CVID_OFFSET    0
+#define    RTL8367C_ACT10_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL6    0x061a
+#define    RTL8367C_OP13_NOT_OFFSET    14
+#define    RTL8367C_OP13_NOT_MASK    0x4000
+#define    RTL8367C_ACT13_GPIO_OFFSET    13
+#define    RTL8367C_ACT13_GPIO_MASK    0x2000
+#define    RTL8367C_ACT13_FORWARD_OFFSET    12
+#define    RTL8367C_ACT13_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT13_POLICING_OFFSET    11
+#define    RTL8367C_ACT13_POLICING_MASK    0x800
+#define    RTL8367C_ACT13_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT13_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT13_SVID_OFFSET    9
+#define    RTL8367C_ACT13_SVID_MASK    0x200
+#define    RTL8367C_ACT13_CVID_OFFSET    8
+#define    RTL8367C_ACT13_CVID_MASK    0x100
+#define    RTL8367C_OP12_NOT_OFFSET    6
+#define    RTL8367C_OP12_NOT_MASK    0x40
+#define    RTL8367C_ACT12_GPIO_OFFSET    5
+#define    RTL8367C_ACT12_GPIO_MASK    0x20
+#define    RTL8367C_ACT12_FORWARD_OFFSET    4
+#define    RTL8367C_ACT12_FORWARD_MASK    0x10
+#define    RTL8367C_ACT12_POLICING_OFFSET    3
+#define    RTL8367C_ACT12_POLICING_MASK    0x8
+#define    RTL8367C_ACT12_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT12_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT12_SVID_OFFSET    1
+#define    RTL8367C_ACT12_SVID_MASK    0x2
+#define    RTL8367C_ACT12_CVID_OFFSET    0
+#define    RTL8367C_ACT12_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL7    0x061b
+#define    RTL8367C_OP15_NOT_OFFSET    14
+#define    RTL8367C_OP15_NOT_MASK    0x4000
+#define    RTL8367C_ACT15_GPIO_OFFSET    13
+#define    RTL8367C_ACT15_GPIO_MASK    0x2000
+#define    RTL8367C_ACT15_FORWARD_OFFSET    12
+#define    RTL8367C_ACT15_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT15_POLICING_OFFSET    11
+#define    RTL8367C_ACT15_POLICING_MASK    0x800
+#define    RTL8367C_ACT15_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT15_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT15_SVID_OFFSET    9
+#define    RTL8367C_ACT15_SVID_MASK    0x200
+#define    RTL8367C_ACT15_CVID_OFFSET    8
+#define    RTL8367C_ACT15_CVID_MASK    0x100
+#define    RTL8367C_OP14_NOT_OFFSET    6
+#define    RTL8367C_OP14_NOT_MASK    0x40
+#define    RTL8367C_ACT14_GPIO_OFFSET    5
+#define    RTL8367C_ACT14_GPIO_MASK    0x20
+#define    RTL8367C_ACT14_FORWARD_OFFSET    4
+#define    RTL8367C_ACT14_FORWARD_MASK    0x10
+#define    RTL8367C_ACT14_POLICING_OFFSET    3
+#define    RTL8367C_ACT14_POLICING_MASK    0x8
+#define    RTL8367C_ACT14_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT14_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT14_SVID_OFFSET    1
+#define    RTL8367C_ACT14_SVID_MASK    0x2
+#define    RTL8367C_ACT14_CVID_OFFSET    0
+#define    RTL8367C_ACT14_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL8    0x061c
+#define    RTL8367C_OP17_NOT_OFFSET    14
+#define    RTL8367C_OP17_NOT_MASK    0x4000
+#define    RTL8367C_ACT17_GPIO_OFFSET    13
+#define    RTL8367C_ACT17_GPIO_MASK    0x2000
+#define    RTL8367C_ACT17_FORWARD_OFFSET    12
+#define    RTL8367C_ACT17_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT17_POLICING_OFFSET    11
+#define    RTL8367C_ACT17_POLICING_MASK    0x800
+#define    RTL8367C_ACT17_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT17_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT17_SVID_OFFSET    9
+#define    RTL8367C_ACT17_SVID_MASK    0x200
+#define    RTL8367C_ACT17_CVID_OFFSET    8
+#define    RTL8367C_ACT17_CVID_MASK    0x100
+#define    RTL8367C_OP16_NOT_OFFSET    6
+#define    RTL8367C_OP16_NOT_MASK    0x40
+#define    RTL8367C_ACT16_GPIO_OFFSET    5
+#define    RTL8367C_ACT16_GPIO_MASK    0x20
+#define    RTL8367C_ACT16_FORWARD_OFFSET    4
+#define    RTL8367C_ACT16_FORWARD_MASK    0x10
+#define    RTL8367C_ACT16_POLICING_OFFSET    3
+#define    RTL8367C_ACT16_POLICING_MASK    0x8
+#define    RTL8367C_ACT16_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT16_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT16_SVID_OFFSET    1
+#define    RTL8367C_ACT16_SVID_MASK    0x2
+#define    RTL8367C_ACT16_CVID_OFFSET    0
+#define    RTL8367C_ACT16_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL9    0x061d
+#define    RTL8367C_OP19_NOT_OFFSET    14
+#define    RTL8367C_OP19_NOT_MASK    0x4000
+#define    RTL8367C_ACT19_GPIO_OFFSET    13
+#define    RTL8367C_ACT19_GPIO_MASK    0x2000
+#define    RTL8367C_ACT19_FORWARD_OFFSET    12
+#define    RTL8367C_ACT19_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT19_POLICING_OFFSET    11
+#define    RTL8367C_ACT19_POLICING_MASK    0x800
+#define    RTL8367C_ACT19_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT19_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT19_SVID_OFFSET    9
+#define    RTL8367C_ACT19_SVID_MASK    0x200
+#define    RTL8367C_ACT19_CVID_OFFSET    8
+#define    RTL8367C_ACT19_CVID_MASK    0x100
+#define    RTL8367C_OP18_NOT_OFFSET    6
+#define    RTL8367C_OP18_NOT_MASK    0x40
+#define    RTL8367C_ACT18_GPIO_OFFSET    5
+#define    RTL8367C_ACT18_GPIO_MASK    0x20
+#define    RTL8367C_ACT18_FORWARD_OFFSET    4
+#define    RTL8367C_ACT18_FORWARD_MASK    0x10
+#define    RTL8367C_ACT18_POLICING_OFFSET    3
+#define    RTL8367C_ACT18_POLICING_MASK    0x8
+#define    RTL8367C_ACT18_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT18_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT18_SVID_OFFSET    1
+#define    RTL8367C_ACT18_SVID_MASK    0x2
+#define    RTL8367C_ACT18_CVID_OFFSET    0
+#define    RTL8367C_ACT18_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL10    0x061e
+#define    RTL8367C_OP21_NOT_OFFSET    14
+#define    RTL8367C_OP21_NOT_MASK    0x4000
+#define    RTL8367C_ACT21_GPIO_OFFSET    13
+#define    RTL8367C_ACT21_GPIO_MASK    0x2000
+#define    RTL8367C_ACT21_FORWARD_OFFSET    12
+#define    RTL8367C_ACT21_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT21_POLICING_OFFSET    11
+#define    RTL8367C_ACT21_POLICING_MASK    0x800
+#define    RTL8367C_ACT21_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT21_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT21_SVID_OFFSET    9
+#define    RTL8367C_ACT21_SVID_MASK    0x200
+#define    RTL8367C_ACT21_CVID_OFFSET    8
+#define    RTL8367C_ACT21_CVID_MASK    0x100
+#define    RTL8367C_OP20_NOT_OFFSET    6
+#define    RTL8367C_OP20_NOT_MASK    0x40
+#define    RTL8367C_ACT20_GPIO_OFFSET    5
+#define    RTL8367C_ACT20_GPIO_MASK    0x20
+#define    RTL8367C_ACT20_FORWARD_OFFSET    4
+#define    RTL8367C_ACT20_FORWARD_MASK    0x10
+#define    RTL8367C_ACT20_POLICING_OFFSET    3
+#define    RTL8367C_ACT20_POLICING_MASK    0x8
+#define    RTL8367C_ACT20_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT20_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT20_SVID_OFFSET    1
+#define    RTL8367C_ACT20_SVID_MASK    0x2
+#define    RTL8367C_ACT20_CVID_OFFSET    0
+#define    RTL8367C_ACT20_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL11    0x061f
+#define    RTL8367C_OP23_NOT_OFFSET    14
+#define    RTL8367C_OP23_NOT_MASK    0x4000
+#define    RTL8367C_ACT23_GPIO_OFFSET    13
+#define    RTL8367C_ACT23_GPIO_MASK    0x2000
+#define    RTL8367C_ACT23_FORWARD_OFFSET    12
+#define    RTL8367C_ACT23_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT23_POLICING_OFFSET    11
+#define    RTL8367C_ACT23_POLICING_MASK    0x800
+#define    RTL8367C_ACT23_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT23_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT23_SVID_OFFSET    9
+#define    RTL8367C_ACT23_SVID_MASK    0x200
+#define    RTL8367C_ACT23_CVID_OFFSET    8
+#define    RTL8367C_ACT23_CVID_MASK    0x100
+#define    RTL8367C_OP22_NOT_OFFSET    6
+#define    RTL8367C_OP22_NOT_MASK    0x40
+#define    RTL8367C_ACT22_GPIO_OFFSET    5
+#define    RTL8367C_ACT22_GPIO_MASK    0x20
+#define    RTL8367C_ACT22_FORWARD_OFFSET    4
+#define    RTL8367C_ACT22_FORWARD_MASK    0x10
+#define    RTL8367C_ACT22_POLICING_OFFSET    3
+#define    RTL8367C_ACT22_POLICING_MASK    0x8
+#define    RTL8367C_ACT22_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT22_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT22_SVID_OFFSET    1
+#define    RTL8367C_ACT22_SVID_MASK    0x2
+#define    RTL8367C_ACT22_CVID_OFFSET    0
+#define    RTL8367C_ACT22_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL12    0x0620
+#define    RTL8367C_OP25_NOT_OFFSET    14
+#define    RTL8367C_OP25_NOT_MASK    0x4000
+#define    RTL8367C_ACT25_GPIO_OFFSET    13
+#define    RTL8367C_ACT25_GPIO_MASK    0x2000
+#define    RTL8367C_ACT25_FORWARD_OFFSET    12
+#define    RTL8367C_ACT25_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT25_POLICING_OFFSET    11
+#define    RTL8367C_ACT25_POLICING_MASK    0x800
+#define    RTL8367C_ACT25_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT25_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT25_SVID_OFFSET    9
+#define    RTL8367C_ACT25_SVID_MASK    0x200
+#define    RTL8367C_ACT25_CVID_OFFSET    8
+#define    RTL8367C_ACT25_CVID_MASK    0x100
+#define    RTL8367C_OP24_NOT_OFFSET    6
+#define    RTL8367C_OP24_NOT_MASK    0x40
+#define    RTL8367C_ACT24_GPIO_OFFSET    5
+#define    RTL8367C_ACT24_GPIO_MASK    0x20
+#define    RTL8367C_ACT24_FORWARD_OFFSET    4
+#define    RTL8367C_ACT24_FORWARD_MASK    0x10
+#define    RTL8367C_ACT24_POLICING_OFFSET    3
+#define    RTL8367C_ACT24_POLICING_MASK    0x8
+#define    RTL8367C_ACT24_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT24_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT24_SVID_OFFSET    1
+#define    RTL8367C_ACT24_SVID_MASK    0x2
+#define    RTL8367C_ACT24_CVID_OFFSET    0
+#define    RTL8367C_ACT24_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL13    0x0621
+#define    RTL8367C_OP27_NOT_OFFSET    14
+#define    RTL8367C_OP27_NOT_MASK    0x4000
+#define    RTL8367C_ACT27_GPIO_OFFSET    13
+#define    RTL8367C_ACT27_GPIO_MASK    0x2000
+#define    RTL8367C_ACT27_FORWARD_OFFSET    12
+#define    RTL8367C_ACT27_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT27_POLICING_OFFSET    11
+#define    RTL8367C_ACT27_POLICING_MASK    0x800
+#define    RTL8367C_ACT27_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT27_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT27_SVID_OFFSET    9
+#define    RTL8367C_ACT27_SVID_MASK    0x200
+#define    RTL8367C_ACT27_CVID_OFFSET    8
+#define    RTL8367C_ACT27_CVID_MASK    0x100
+#define    RTL8367C_OP26_NOT_OFFSET    6
+#define    RTL8367C_OP26_NOT_MASK    0x40
+#define    RTL8367C_ACT26_GPIO_OFFSET    5
+#define    RTL8367C_ACT26_GPIO_MASK    0x20
+#define    RTL8367C_ACT26_FORWARD_OFFSET    4
+#define    RTL8367C_ACT26_FORWARD_MASK    0x10
+#define    RTL8367C_ACT26_POLICING_OFFSET    3
+#define    RTL8367C_ACT26_POLICING_MASK    0x8
+#define    RTL8367C_ACT26_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT26_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT26_SVID_OFFSET    1
+#define    RTL8367C_ACT26_SVID_MASK    0x2
+#define    RTL8367C_ACT26_CVID_OFFSET    0
+#define    RTL8367C_ACT26_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL14    0x0622
+#define    RTL8367C_OP29_NOT_OFFSET    14
+#define    RTL8367C_OP29_NOT_MASK    0x4000
+#define    RTL8367C_ACT29_GPIO_OFFSET    13
+#define    RTL8367C_ACT29_GPIO_MASK    0x2000
+#define    RTL8367C_ACT29_FORWARD_OFFSET    12
+#define    RTL8367C_ACT29_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT29_POLICING_OFFSET    11
+#define    RTL8367C_ACT29_POLICING_MASK    0x800
+#define    RTL8367C_ACT29_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT29_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT29_SVID_OFFSET    9
+#define    RTL8367C_ACT29_SVID_MASK    0x200
+#define    RTL8367C_ACT29_CVID_OFFSET    8
+#define    RTL8367C_ACT29_CVID_MASK    0x100
+#define    RTL8367C_OP28_NOT_OFFSET    6
+#define    RTL8367C_OP28_NOT_MASK    0x40
+#define    RTL8367C_ACT28_GPIO_OFFSET    5
+#define    RTL8367C_ACT28_GPIO_MASK    0x20
+#define    RTL8367C_ACT28_FORWARD_OFFSET    4
+#define    RTL8367C_ACT28_FORWARD_MASK    0x10
+#define    RTL8367C_ACT28_POLICING_OFFSET    3
+#define    RTL8367C_ACT28_POLICING_MASK    0x8
+#define    RTL8367C_ACT28_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT28_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT28_SVID_OFFSET    1
+#define    RTL8367C_ACT28_SVID_MASK    0x2
+#define    RTL8367C_ACT28_CVID_OFFSET    0
+#define    RTL8367C_ACT28_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL15    0x0623
+#define    RTL8367C_OP31_NOT_OFFSET    14
+#define    RTL8367C_OP31_NOT_MASK    0x4000
+#define    RTL8367C_ACT31_GPIO_OFFSET    13
+#define    RTL8367C_ACT31_GPIO_MASK    0x2000
+#define    RTL8367C_ACT31_FORWARD_OFFSET    12
+#define    RTL8367C_ACT31_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT31_POLICING_OFFSET    11
+#define    RTL8367C_ACT31_POLICING_MASK    0x800
+#define    RTL8367C_ACT31_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT31_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT31_SVID_OFFSET    9
+#define    RTL8367C_ACT31_SVID_MASK    0x200
+#define    RTL8367C_ACT31_CVID_OFFSET    8
+#define    RTL8367C_ACT31_CVID_MASK    0x100
+#define    RTL8367C_OP30_NOT_OFFSET    6
+#define    RTL8367C_OP30_NOT_MASK    0x40
+#define    RTL8367C_ACT30_GPIO_OFFSET    5
+#define    RTL8367C_ACT30_GPIO_MASK    0x20
+#define    RTL8367C_ACT30_FORWARD_OFFSET    4
+#define    RTL8367C_ACT30_FORWARD_MASK    0x10
+#define    RTL8367C_ACT30_POLICING_OFFSET    3
+#define    RTL8367C_ACT30_POLICING_MASK    0x8
+#define    RTL8367C_ACT30_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT30_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT30_SVID_OFFSET    1
+#define    RTL8367C_ACT30_SVID_MASK    0x2
+#define    RTL8367C_ACT30_CVID_OFFSET    0
+#define    RTL8367C_ACT30_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL16    0x0624
+#define    RTL8367C_OP33_NOT_OFFSET    14
+#define    RTL8367C_OP33_NOT_MASK    0x4000
+#define    RTL8367C_ACT33_GPIO_OFFSET    13
+#define    RTL8367C_ACT33_GPIO_MASK    0x2000
+#define    RTL8367C_ACT33_FORWARD_OFFSET    12
+#define    RTL8367C_ACT33_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT33_POLICING_OFFSET    11
+#define    RTL8367C_ACT33_POLICING_MASK    0x800
+#define    RTL8367C_ACT33_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT33_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT33_SVID_OFFSET    9
+#define    RTL8367C_ACT33_SVID_MASK    0x200
+#define    RTL8367C_ACT33_CVID_OFFSET    8
+#define    RTL8367C_ACT33_CVID_MASK    0x100
+#define    RTL8367C_OP32_NOT_OFFSET    6
+#define    RTL8367C_OP32_NOT_MASK    0x40
+#define    RTL8367C_ACT32_GPIO_OFFSET    5
+#define    RTL8367C_ACT32_GPIO_MASK    0x20
+#define    RTL8367C_ACT32_FORWARD_OFFSET    4
+#define    RTL8367C_ACT32_FORWARD_MASK    0x10
+#define    RTL8367C_ACT32_POLICING_OFFSET    3
+#define    RTL8367C_ACT32_POLICING_MASK    0x8
+#define    RTL8367C_ACT32_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT32_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT32_SVID_OFFSET    1
+#define    RTL8367C_ACT32_SVID_MASK    0x2
+#define    RTL8367C_ACT32_CVID_OFFSET    0
+#define    RTL8367C_ACT32_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL17    0x0625
+#define    RTL8367C_OP35_NOT_OFFSET    14
+#define    RTL8367C_OP35_NOT_MASK    0x4000
+#define    RTL8367C_ACT35_GPIO_OFFSET    13
+#define    RTL8367C_ACT35_GPIO_MASK    0x2000
+#define    RTL8367C_ACT35_FORWARD_OFFSET    12
+#define    RTL8367C_ACT35_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT35_POLICING_OFFSET    11
+#define    RTL8367C_ACT35_POLICING_MASK    0x800
+#define    RTL8367C_ACT35_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT35_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT35_SVID_OFFSET    9
+#define    RTL8367C_ACT35_SVID_MASK    0x200
+#define    RTL8367C_ACT35_CVID_OFFSET    8
+#define    RTL8367C_ACT35_CVID_MASK    0x100
+#define    RTL8367C_OP34_NOT_OFFSET    6
+#define    RTL8367C_OP34_NOT_MASK    0x40
+#define    RTL8367C_ACT34_GPIO_OFFSET    5
+#define    RTL8367C_ACT34_GPIO_MASK    0x20
+#define    RTL8367C_ACT34_FORWARD_OFFSET    4
+#define    RTL8367C_ACT34_FORWARD_MASK    0x10
+#define    RTL8367C_ACT34_POLICING_OFFSET    3
+#define    RTL8367C_ACT34_POLICING_MASK    0x8
+#define    RTL8367C_ACT34_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT34_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT34_SVID_OFFSET    1
+#define    RTL8367C_ACT34_SVID_MASK    0x2
+#define    RTL8367C_ACT34_CVID_OFFSET    0
+#define    RTL8367C_ACT34_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL18    0x0626
+#define    RTL8367C_OP37_NOT_OFFSET    14
+#define    RTL8367C_OP37_NOT_MASK    0x4000
+#define    RTL8367C_ACT37_GPIO_OFFSET    13
+#define    RTL8367C_ACT37_GPIO_MASK    0x2000
+#define    RTL8367C_ACT37_FORWARD_OFFSET    12
+#define    RTL8367C_ACT37_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT37_POLICING_OFFSET    11
+#define    RTL8367C_ACT37_POLICING_MASK    0x800
+#define    RTL8367C_ACT37_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT37_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT37_SVID_OFFSET    9
+#define    RTL8367C_ACT37_SVID_MASK    0x200
+#define    RTL8367C_ACT37_CVID_OFFSET    8
+#define    RTL8367C_ACT37_CVID_MASK    0x100
+#define    RTL8367C_OP36_NOT_OFFSET    6
+#define    RTL8367C_OP36_NOT_MASK    0x40
+#define    RTL8367C_ACT36_GPIO_OFFSET    5
+#define    RTL8367C_ACT36_GPIO_MASK    0x20
+#define    RTL8367C_ACT36_FORWARD_OFFSET    4
+#define    RTL8367C_ACT36_FORWARD_MASK    0x10
+#define    RTL8367C_ACT36_POLICING_OFFSET    3
+#define    RTL8367C_ACT36_POLICING_MASK    0x8
+#define    RTL8367C_ACT36_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT36_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT36_SVID_OFFSET    1
+#define    RTL8367C_ACT36_SVID_MASK    0x2
+#define    RTL8367C_ACT36_CVID_OFFSET    0
+#define    RTL8367C_ACT36_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL19    0x0627
+#define    RTL8367C_OP39_NOT_OFFSET    14
+#define    RTL8367C_OP39_NOT_MASK    0x4000
+#define    RTL8367C_ACT39_GPIO_OFFSET    13
+#define    RTL8367C_ACT39_GPIO_MASK    0x2000
+#define    RTL8367C_ACT39_FORWARD_OFFSET    12
+#define    RTL8367C_ACT39_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT39_POLICING_OFFSET    11
+#define    RTL8367C_ACT39_POLICING_MASK    0x800
+#define    RTL8367C_ACT39_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT39_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT39_SVID_OFFSET    9
+#define    RTL8367C_ACT39_SVID_MASK    0x200
+#define    RTL8367C_ACT39_CVID_OFFSET    8
+#define    RTL8367C_ACT39_CVID_MASK    0x100
+#define    RTL8367C_OP38_NOT_OFFSET    6
+#define    RTL8367C_OP38_NOT_MASK    0x40
+#define    RTL8367C_ACT38_GPIO_OFFSET    5
+#define    RTL8367C_ACT38_GPIO_MASK    0x20
+#define    RTL8367C_ACT38_FORWARD_OFFSET    4
+#define    RTL8367C_ACT38_FORWARD_MASK    0x10
+#define    RTL8367C_ACT38_POLICING_OFFSET    3
+#define    RTL8367C_ACT38_POLICING_MASK    0x8
+#define    RTL8367C_ACT38_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT38_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT38_SVID_OFFSET    1
+#define    RTL8367C_ACT38_SVID_MASK    0x2
+#define    RTL8367C_ACT38_CVID_OFFSET    0
+#define    RTL8367C_ACT38_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL20    0x0628
+#define    RTL8367C_OP41_NOT_OFFSET    14
+#define    RTL8367C_OP41_NOT_MASK    0x4000
+#define    RTL8367C_ACT41_GPIO_OFFSET    13
+#define    RTL8367C_ACT41_GPIO_MASK    0x2000
+#define    RTL8367C_ACT41_FORWARD_OFFSET    12
+#define    RTL8367C_ACT41_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT41_POLICING_OFFSET    11
+#define    RTL8367C_ACT41_POLICING_MASK    0x800
+#define    RTL8367C_ACT41_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT41_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT41_SVID_OFFSET    9
+#define    RTL8367C_ACT41_SVID_MASK    0x200
+#define    RTL8367C_ACT41_CVID_OFFSET    8
+#define    RTL8367C_ACT41_CVID_MASK    0x100
+#define    RTL8367C_OP40_NOT_OFFSET    6
+#define    RTL8367C_OP40_NOT_MASK    0x40
+#define    RTL8367C_ACT40_GPIO_OFFSET    5
+#define    RTL8367C_ACT40_GPIO_MASK    0x20
+#define    RTL8367C_ACT40_FORWARD_OFFSET    4
+#define    RTL8367C_ACT40_FORWARD_MASK    0x10
+#define    RTL8367C_ACT40_POLICING_OFFSET    3
+#define    RTL8367C_ACT40_POLICING_MASK    0x8
+#define    RTL8367C_ACT40_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT40_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT40_SVID_OFFSET    1
+#define    RTL8367C_ACT40_SVID_MASK    0x2
+#define    RTL8367C_ACT40_CVID_OFFSET    0
+#define    RTL8367C_ACT40_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL21    0x0629
+#define    RTL8367C_OP43_NOT_OFFSET    14
+#define    RTL8367C_OP43_NOT_MASK    0x4000
+#define    RTL8367C_ACT43_GPIO_OFFSET    13
+#define    RTL8367C_ACT43_GPIO_MASK    0x2000
+#define    RTL8367C_ACT43_FORWARD_OFFSET    12
+#define    RTL8367C_ACT43_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT43_POLICING_OFFSET    11
+#define    RTL8367C_ACT43_POLICING_MASK    0x800
+#define    RTL8367C_ACT43_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT43_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT43_SVID_OFFSET    9
+#define    RTL8367C_ACT43_SVID_MASK    0x200
+#define    RTL8367C_ACT43_CVID_OFFSET    8
+#define    RTL8367C_ACT43_CVID_MASK    0x100
+#define    RTL8367C_OP42_NOT_OFFSET    6
+#define    RTL8367C_OP42_NOT_MASK    0x40
+#define    RTL8367C_ACT42_GPIO_OFFSET    5
+#define    RTL8367C_ACT42_GPIO_MASK    0x20
+#define    RTL8367C_ACT42_FORWARD_OFFSET    4
+#define    RTL8367C_ACT42_FORWARD_MASK    0x10
+#define    RTL8367C_ACT42_POLICING_OFFSET    3
+#define    RTL8367C_ACT42_POLICING_MASK    0x8
+#define    RTL8367C_ACT42_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT42_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT42_SVID_OFFSET    1
+#define    RTL8367C_ACT42_SVID_MASK    0x2
+#define    RTL8367C_ACT42_CVID_OFFSET    0
+#define    RTL8367C_ACT42_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL22    0x062a
+#define    RTL8367C_OP45_NOT_OFFSET    14
+#define    RTL8367C_OP45_NOT_MASK    0x4000
+#define    RTL8367C_ACT45_GPIO_OFFSET    13
+#define    RTL8367C_ACT45_GPIO_MASK    0x2000
+#define    RTL8367C_ACT45_FORWARD_OFFSET    12
+#define    RTL8367C_ACT45_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT45_POLICING_OFFSET    11
+#define    RTL8367C_ACT45_POLICING_MASK    0x800
+#define    RTL8367C_ACT45_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT45_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT45_SVID_OFFSET    9
+#define    RTL8367C_ACT45_SVID_MASK    0x200
+#define    RTL8367C_ACT45_CVID_OFFSET    8
+#define    RTL8367C_ACT45_CVID_MASK    0x100
+#define    RTL8367C_OP44_NOT_OFFSET    6
+#define    RTL8367C_OP44_NOT_MASK    0x40
+#define    RTL8367C_ACT44_GPIO_OFFSET    5
+#define    RTL8367C_ACT44_GPIO_MASK    0x20
+#define    RTL8367C_ACT44_FORWARD_OFFSET    4
+#define    RTL8367C_ACT44_FORWARD_MASK    0x10
+#define    RTL8367C_ACT44_POLICING_OFFSET    3
+#define    RTL8367C_ACT44_POLICING_MASK    0x8
+#define    RTL8367C_ACT44_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT44_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT44_SVID_OFFSET    1
+#define    RTL8367C_ACT44_SVID_MASK    0x2
+#define    RTL8367C_ACT44_CVID_OFFSET    0
+#define    RTL8367C_ACT44_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL23    0x062b
+#define    RTL8367C_OP47_NOT_OFFSET    14
+#define    RTL8367C_OP47_NOT_MASK    0x4000
+#define    RTL8367C_ACT47_GPIO_OFFSET    13
+#define    RTL8367C_ACT47_GPIO_MASK    0x2000
+#define    RTL8367C_ACT47_FORWARD_OFFSET    12
+#define    RTL8367C_ACT47_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT47_POLICING_OFFSET    11
+#define    RTL8367C_ACT47_POLICING_MASK    0x800
+#define    RTL8367C_ACT47_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT47_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT47_SVID_OFFSET    9
+#define    RTL8367C_ACT47_SVID_MASK    0x200
+#define    RTL8367C_ACT47_CVID_OFFSET    8
+#define    RTL8367C_ACT47_CVID_MASK    0x100
+#define    RTL8367C_OP46_NOT_OFFSET    6
+#define    RTL8367C_OP46_NOT_MASK    0x40
+#define    RTL8367C_ACT46_GPIO_OFFSET    5
+#define    RTL8367C_ACT46_GPIO_MASK    0x20
+#define    RTL8367C_ACT46_FORWARD_OFFSET    4
+#define    RTL8367C_ACT46_FORWARD_MASK    0x10
+#define    RTL8367C_ACT46_POLICING_OFFSET    3
+#define    RTL8367C_ACT46_POLICING_MASK    0x8
+#define    RTL8367C_ACT46_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT46_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT46_SVID_OFFSET    1
+#define    RTL8367C_ACT46_SVID_MASK    0x2
+#define    RTL8367C_ACT46_CVID_OFFSET    0
+#define    RTL8367C_ACT46_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL24    0x062c
+#define    RTL8367C_OP49_NOT_OFFSET    14
+#define    RTL8367C_OP49_NOT_MASK    0x4000
+#define    RTL8367C_ACT49_GPIO_OFFSET    13
+#define    RTL8367C_ACT49_GPIO_MASK    0x2000
+#define    RTL8367C_ACT49_FORWARD_OFFSET    12
+#define    RTL8367C_ACT49_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT49_POLICING_OFFSET    11
+#define    RTL8367C_ACT49_POLICING_MASK    0x800
+#define    RTL8367C_ACT49_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT49_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT49_SVID_OFFSET    9
+#define    RTL8367C_ACT49_SVID_MASK    0x200
+#define    RTL8367C_ACT49_CVID_OFFSET    8
+#define    RTL8367C_ACT49_CVID_MASK    0x100
+#define    RTL8367C_OP48_NOT_OFFSET    6
+#define    RTL8367C_OP48_NOT_MASK    0x40
+#define    RTL8367C_ACT48_GPIO_OFFSET    5
+#define    RTL8367C_ACT48_GPIO_MASK    0x20
+#define    RTL8367C_ACT48_FORWARD_OFFSET    4
+#define    RTL8367C_ACT48_FORWARD_MASK    0x10
+#define    RTL8367C_ACT48_POLICING_OFFSET    3
+#define    RTL8367C_ACT48_POLICING_MASK    0x8
+#define    RTL8367C_ACT48_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT48_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT48_SVID_OFFSET    1
+#define    RTL8367C_ACT48_SVID_MASK    0x2
+#define    RTL8367C_ACT48_CVID_OFFSET    0
+#define    RTL8367C_ACT48_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL25    0x062d
+#define    RTL8367C_OP51_NOT_OFFSET    14
+#define    RTL8367C_OP51_NOT_MASK    0x4000
+#define    RTL8367C_ACT51_GPIO_OFFSET    13
+#define    RTL8367C_ACT51_GPIO_MASK    0x2000
+#define    RTL8367C_ACT51_FORWARD_OFFSET    12
+#define    RTL8367C_ACT51_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT51_POLICING_OFFSET    11
+#define    RTL8367C_ACT51_POLICING_MASK    0x800
+#define    RTL8367C_ACT51_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT51_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT51_SVID_OFFSET    9
+#define    RTL8367C_ACT51_SVID_MASK    0x200
+#define    RTL8367C_ACT51_CVID_OFFSET    8
+#define    RTL8367C_ACT51_CVID_MASK    0x100
+#define    RTL8367C_OP50_NOT_OFFSET    6
+#define    RTL8367C_OP50_NOT_MASK    0x40
+#define    RTL8367C_ACT50_GPIO_OFFSET    5
+#define    RTL8367C_ACT50_GPIO_MASK    0x20
+#define    RTL8367C_ACT50_FORWARD_OFFSET    4
+#define    RTL8367C_ACT50_FORWARD_MASK    0x10
+#define    RTL8367C_ACT50_POLICING_OFFSET    3
+#define    RTL8367C_ACT50_POLICING_MASK    0x8
+#define    RTL8367C_ACT50_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT50_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT50_SVID_OFFSET    1
+#define    RTL8367C_ACT50_SVID_MASK    0x2
+#define    RTL8367C_ACT50_CVID_OFFSET    0
+#define    RTL8367C_ACT50_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL26    0x062e
+#define    RTL8367C_OP53_NOT_OFFSET    14
+#define    RTL8367C_OP53_NOT_MASK    0x4000
+#define    RTL8367C_ACT53_GPIO_OFFSET    13
+#define    RTL8367C_ACT53_GPIO_MASK    0x2000
+#define    RTL8367C_ACT53_FORWARD_OFFSET    12
+#define    RTL8367C_ACT53_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT53_POLICING_OFFSET    11
+#define    RTL8367C_ACT53_POLICING_MASK    0x800
+#define    RTL8367C_ACT53_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT53_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT53_SVID_OFFSET    9
+#define    RTL8367C_ACT53_SVID_MASK    0x200
+#define    RTL8367C_ACT53_CVID_OFFSET    8
+#define    RTL8367C_ACT53_CVID_MASK    0x100
+#define    RTL8367C_OP52_NOT_OFFSET    6
+#define    RTL8367C_OP52_NOT_MASK    0x40
+#define    RTL8367C_ACT52_GPIO_OFFSET    5
+#define    RTL8367C_ACT52_GPIO_MASK    0x20
+#define    RTL8367C_ACT52_FORWARD_OFFSET    4
+#define    RTL8367C_ACT52_FORWARD_MASK    0x10
+#define    RTL8367C_ACT52_POLICING_OFFSET    3
+#define    RTL8367C_ACT52_POLICING_MASK    0x8
+#define    RTL8367C_ACT52_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT52_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT52_SVID_OFFSET    1
+#define    RTL8367C_ACT52_SVID_MASK    0x2
+#define    RTL8367C_ACT52_CVID_OFFSET    0
+#define    RTL8367C_ACT52_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL27    0x062f
+#define    RTL8367C_OP55_NOT_OFFSET    14
+#define    RTL8367C_OP55_NOT_MASK    0x4000
+#define    RTL8367C_ACT55_GPIO_OFFSET    13
+#define    RTL8367C_ACT55_GPIO_MASK    0x2000
+#define    RTL8367C_ACT55_FORWARD_OFFSET    12
+#define    RTL8367C_ACT55_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT55_POLICING_OFFSET    11
+#define    RTL8367C_ACT55_POLICING_MASK    0x800
+#define    RTL8367C_ACT55_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT55_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT55_SVID_OFFSET    9
+#define    RTL8367C_ACT55_SVID_MASK    0x200
+#define    RTL8367C_ACT55_CVID_OFFSET    8
+#define    RTL8367C_ACT55_CVID_MASK    0x100
+#define    RTL8367C_OP54_NOT_OFFSET    6
+#define    RTL8367C_OP54_NOT_MASK    0x40
+#define    RTL8367C_ACT54_GPIO_OFFSET    5
+#define    RTL8367C_ACT54_GPIO_MASK    0x20
+#define    RTL8367C_ACT54_FORWARD_OFFSET    4
+#define    RTL8367C_ACT54_FORWARD_MASK    0x10
+#define    RTL8367C_ACT54_POLICING_OFFSET    3
+#define    RTL8367C_ACT54_POLICING_MASK    0x8
+#define    RTL8367C_ACT54_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT54_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT54_SVID_OFFSET    1
+#define    RTL8367C_ACT54_SVID_MASK    0x2
+#define    RTL8367C_ACT54_CVID_OFFSET    0
+#define    RTL8367C_ACT54_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL28    0x0630
+#define    RTL8367C_OP57_NOT_OFFSET    14
+#define    RTL8367C_OP57_NOT_MASK    0x4000
+#define    RTL8367C_ACT57_GPIO_OFFSET    13
+#define    RTL8367C_ACT57_GPIO_MASK    0x2000
+#define    RTL8367C_ACT57_FORWARD_OFFSET    12
+#define    RTL8367C_ACT57_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT57_POLICING_OFFSET    11
+#define    RTL8367C_ACT57_POLICING_MASK    0x800
+#define    RTL8367C_ACT57_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT57_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT57_SVID_OFFSET    9
+#define    RTL8367C_ACT57_SVID_MASK    0x200
+#define    RTL8367C_ACT57_CVID_OFFSET    8
+#define    RTL8367C_ACT57_CVID_MASK    0x100
+#define    RTL8367C_OP56_NOT_OFFSET    6
+#define    RTL8367C_OP56_NOT_MASK    0x40
+#define    RTL8367C_ACT56_GPIO_OFFSET    5
+#define    RTL8367C_ACT56_GPIO_MASK    0x20
+#define    RTL8367C_ACT56_FORWARD_OFFSET    4
+#define    RTL8367C_ACT56_FORWARD_MASK    0x10
+#define    RTL8367C_ACT56_POLICING_OFFSET    3
+#define    RTL8367C_ACT56_POLICING_MASK    0x8
+#define    RTL8367C_ACT56_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT56_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT56_SVID_OFFSET    1
+#define    RTL8367C_ACT56_SVID_MASK    0x2
+#define    RTL8367C_ACT56_CVID_OFFSET    0
+#define    RTL8367C_ACT56_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL29    0x0631
+#define    RTL8367C_OP59_NOT_OFFSET    14
+#define    RTL8367C_OP59_NOT_MASK    0x4000
+#define    RTL8367C_ACT59_GPIO_OFFSET    13
+#define    RTL8367C_ACT59_GPIO_MASK    0x2000
+#define    RTL8367C_ACT59_FORWARD_OFFSET    12
+#define    RTL8367C_ACT59_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT59_POLICING_OFFSET    11
+#define    RTL8367C_ACT59_POLICING_MASK    0x800
+#define    RTL8367C_ACT59_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT59_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT59_SVID_OFFSET    9
+#define    RTL8367C_ACT59_SVID_MASK    0x200
+#define    RTL8367C_ACT59_CVID_OFFSET    8
+#define    RTL8367C_ACT59_CVID_MASK    0x100
+#define    RTL8367C_OP58_NOT_OFFSET    6
+#define    RTL8367C_OP58_NOT_MASK    0x40
+#define    RTL8367C_ACT58_GPIO_OFFSET    5
+#define    RTL8367C_ACT58_GPIO_MASK    0x20
+#define    RTL8367C_ACT58_FORWARD_OFFSET    4
+#define    RTL8367C_ACT58_FORWARD_MASK    0x10
+#define    RTL8367C_ACT58_POLICING_OFFSET    3
+#define    RTL8367C_ACT58_POLICING_MASK    0x8
+#define    RTL8367C_ACT58_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT58_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT58_SVID_OFFSET    1
+#define    RTL8367C_ACT58_SVID_MASK    0x2
+#define    RTL8367C_ACT58_CVID_OFFSET    0
+#define    RTL8367C_ACT58_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL30    0x0632
+#define    RTL8367C_OP61_NOT_OFFSET    14
+#define    RTL8367C_OP61_NOT_MASK    0x4000
+#define    RTL8367C_ACT61_GPIO_OFFSET    13
+#define    RTL8367C_ACT61_GPIO_MASK    0x2000
+#define    RTL8367C_ACT61_FORWARD_OFFSET    12
+#define    RTL8367C_ACT61_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT61_POLICING_OFFSET    11
+#define    RTL8367C_ACT61_POLICING_MASK    0x800
+#define    RTL8367C_ACT61_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT61_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT61_SVID_OFFSET    9
+#define    RTL8367C_ACT61_SVID_MASK    0x200
+#define    RTL8367C_ACT61_CVID_OFFSET    8
+#define    RTL8367C_ACT61_CVID_MASK    0x100
+#define    RTL8367C_OP60_NOT_OFFSET    6
+#define    RTL8367C_OP60_NOT_MASK    0x40
+#define    RTL8367C_ACT60_GPIO_OFFSET    5
+#define    RTL8367C_ACT60_GPIO_MASK    0x20
+#define    RTL8367C_ACT60_FORWARD_OFFSET    4
+#define    RTL8367C_ACT60_FORWARD_MASK    0x10
+#define    RTL8367C_ACT60_POLICING_OFFSET    3
+#define    RTL8367C_ACT60_POLICING_MASK    0x8
+#define    RTL8367C_ACT60_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT60_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT60_SVID_OFFSET    1
+#define    RTL8367C_ACT60_SVID_MASK    0x2
+#define    RTL8367C_ACT60_CVID_OFFSET    0
+#define    RTL8367C_ACT60_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL31    0x0633
+#define    RTL8367C_OP63_NOT_OFFSET    14
+#define    RTL8367C_OP63_NOT_MASK    0x4000
+#define    RTL8367C_ACT63_GPIO_OFFSET    13
+#define    RTL8367C_ACT63_GPIO_MASK    0x2000
+#define    RTL8367C_ACT63_FORWARD_OFFSET    12
+#define    RTL8367C_ACT63_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT63_POLICING_OFFSET    11
+#define    RTL8367C_ACT63_POLICING_MASK    0x800
+#define    RTL8367C_ACT63_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT63_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT63_SVID_OFFSET    9
+#define    RTL8367C_ACT63_SVID_MASK    0x200
+#define    RTL8367C_ACT63_CVID_OFFSET    8
+#define    RTL8367C_ACT63_CVID_MASK    0x100
+#define    RTL8367C_OP62_NOT_OFFSET    6
+#define    RTL8367C_OP62_NOT_MASK    0x40
+#define    RTL8367C_ACT62_GPIO_OFFSET    5
+#define    RTL8367C_ACT62_GPIO_MASK    0x20
+#define    RTL8367C_ACT62_FORWARD_OFFSET    4
+#define    RTL8367C_ACT62_FORWARD_MASK    0x10
+#define    RTL8367C_ACT62_POLICING_OFFSET    3
+#define    RTL8367C_ACT62_POLICING_MASK    0x8
+#define    RTL8367C_ACT62_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT62_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT62_SVID_OFFSET    1
+#define    RTL8367C_ACT62_SVID_MASK    0x2
+#define    RTL8367C_ACT62_CVID_OFFSET    0
+#define    RTL8367C_ACT62_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL0    0x0635
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL1    0x0636
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL2    0x0637
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY0_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY0_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY1_CTRL0    0x0638
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY1_CTRL1    0x0639
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY1_CTRL2    0x063a
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY1_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY1_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY2_CTRL0    0x063b
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY2_CTRL1    0x063c
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY2_CTRL2    0x063d
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY2_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY2_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY3_CTRL0    0x063e
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY3_CTRL1    0x063f
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY3_CTRL2    0x0640
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY3_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY3_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY4_CTRL0    0x0641
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY4_CTRL1    0x0642
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY4_CTRL2    0x0643
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY4_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY4_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY5_CTRL0    0x0644
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY5_CTRL1    0x0645
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY5_CTRL2    0x0646
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY5_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY5_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY6_CTRL0    0x0647
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY6_CTRL1    0x0648
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY6_CTRL2    0x0649
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY6_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY6_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY7_CTRL0    0x064a
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY7_CTRL1    0x064b
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY7_CTRL2    0x064c
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY7_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY7_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY8_CTRL0    0x064d
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY8_CTRL1    0x064e
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY8_CTRL2    0x064f
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY8_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY8_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY9_CTRL0    0x0650
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY9_CTRL1    0x0651
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY9_CTRL2    0x0652
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY9_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY9_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY10_CTRL0    0x0653
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY10_CTRL1    0x0654
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY10_CTRL2    0x0655
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY10_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY10_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY11_CTRL0    0x0656
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY11_CTRL1    0x0657
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY11_CTRL2    0x0658
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY11_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY11_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY12_CTRL0    0x0659
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY12_CTRL1    0x065a
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY12_CTRL2    0x065b
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY12_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY12_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY13_CTRL0    0x065c
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY13_CTRL1    0x065d
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY13_CTRL2    0x065e
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY13_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY13_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY14_CTRL0    0x065f
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY14_CTRL1    0x0660
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY14_CTRL2    0x0661
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY14_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY14_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY15_CTRL0    0x0662
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY15_CTRL1    0x0663
+
+#define    RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY15_CTRL2    0x0664
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY15_CTRL2_OFFSET    0
+#define    RTL8367C_ACL_SDPORT_RANGE_ENTRY15_CTRL2_MASK    0x3
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY0_CTRL0    0x0665
+#define    RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY0_CTRL1    0x0666
+#define    RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY1_CTRL0    0x0667
+#define    RTL8367C_ACL_VID_RANGE_ENTRY1_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY1_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY1_CTRL1    0x0668
+#define    RTL8367C_ACL_VID_RANGE_ENTRY1_CTRL1_CHECK1_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY1_CTRL1_CHECK1_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY1_CTRL1_CHECK1_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY1_CTRL1_CHECK1_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY2_CTRL0    0x0669
+#define    RTL8367C_ACL_VID_RANGE_ENTRY2_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY2_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY2_CTRL1    0x066a
+#define    RTL8367C_ACL_VID_RANGE_ENTRY2_CTRL1_CHECK2_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY2_CTRL1_CHECK2_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY2_CTRL1_CHECK2_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY2_CTRL1_CHECK2_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY3_CTRL0    0x066b
+#define    RTL8367C_ACL_VID_RANGE_ENTRY3_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY3_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY3_CTRL1    0x066c
+#define    RTL8367C_ACL_VID_RANGE_ENTRY3_CTRL1_CHECK3_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY3_CTRL1_CHECK3_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY3_CTRL1_CHECK3_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY3_CTRL1_CHECK3_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY4_CTRL0    0x066d
+#define    RTL8367C_ACL_VID_RANGE_ENTRY4_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY4_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY4_CTRL1    0x066e
+#define    RTL8367C_ACL_VID_RANGE_ENTRY4_CTRL1_CHECK4_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY4_CTRL1_CHECK4_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY4_CTRL1_CHECK4_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY4_CTRL1_CHECK4_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY5_CTRL0    0x066f
+#define    RTL8367C_ACL_VID_RANGE_ENTRY5_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY5_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY5_CTRL1    0x0670
+#define    RTL8367C_ACL_VID_RANGE_ENTRY5_CTRL1_CHECK5_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY5_CTRL1_CHECK5_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY5_CTRL1_CHECK5_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY5_CTRL1_CHECK5_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY6_CTRL0    0x0671
+#define    RTL8367C_ACL_VID_RANGE_ENTRY6_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY6_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY6_CTRL1    0x0672
+#define    RTL8367C_ACL_VID_RANGE_ENTRY6_CTRL1_CHECK6_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY6_CTRL1_CHECK6_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY6_CTRL1_CHECK6_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY6_CTRL1_CHECK6_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY7_CTRL0    0x0673
+#define    RTL8367C_ACL_VID_RANGE_ENTRY7_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY7_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY7_CTRL1    0x0674
+#define    RTL8367C_ACL_VID_RANGE_ENTRY7_CTRL1_CHECK7_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY7_CTRL1_CHECK7_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY7_CTRL1_CHECK7_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY7_CTRL1_CHECK7_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY8_CTRL0    0x0675
+#define    RTL8367C_ACL_VID_RANGE_ENTRY8_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY8_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY8_CTRL1    0x0676
+#define    RTL8367C_ACL_VID_RANGE_ENTRY8_CTRL1_CHECK8_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY8_CTRL1_CHECK8_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY8_CTRL1_CHECK8_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY8_CTRL1_CHECK8_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY9_CTRL0    0x0677
+#define    RTL8367C_ACL_VID_RANGE_ENTRY9_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY9_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY9_CTRL1    0x0678
+#define    RTL8367C_ACL_VID_RANGE_ENTRY9_CTRL1_CHECK9_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY9_CTRL1_CHECK9_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY9_CTRL1_CHECK9_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY9_CTRL1_CHECK9_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY10_CTRL0    0x0679
+#define    RTL8367C_ACL_VID_RANGE_ENTRY10_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY10_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY10_CTRL1    0x067a
+#define    RTL8367C_ACL_VID_RANGE_ENTRY10_CTRL1_CHECK10_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY10_CTRL1_CHECK10_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY10_CTRL1_CHECK10_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY10_CTRL1_CHECK10_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY11_CTRL0    0x067b
+#define    RTL8367C_ACL_VID_RANGE_ENTRY11_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY11_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY11_CTRL1    0x067c
+#define    RTL8367C_ACL_VID_RANGE_ENTRY11_CTRL1_CHECK11_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY11_CTRL1_CHECK11_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY11_CTRL1_CHECK11_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY11_CTRL1_CHECK11_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY12_CTRL0    0x067d
+#define    RTL8367C_ACL_VID_RANGE_ENTRY12_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY12_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY12_CTRL1    0x067e
+#define    RTL8367C_ACL_VID_RANGE_ENTRY12_CTRL1_CHECK12_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY12_CTRL1_CHECK12_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY12_CTRL1_CHECK12_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY12_CTRL1_CHECK12_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY13_CTRL0    0x067f
+#define    RTL8367C_ACL_VID_RANGE_ENTRY13_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY13_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY13_CTRL1    0x0680
+#define    RTL8367C_ACL_VID_RANGE_ENTRY13_CTRL1_CHECK13_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY13_CTRL1_CHECK13_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY13_CTRL1_CHECK13_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY13_CTRL1_CHECK13_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY14_CTRL0    0x0681
+#define    RTL8367C_ACL_VID_RANGE_ENTRY14_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY14_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY14_CTRL1    0x0682
+#define    RTL8367C_ACL_VID_RANGE_ENTRY14_CTRL1_CHECK14_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY14_CTRL1_CHECK14_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY14_CTRL1_CHECK14_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY14_CTRL1_CHECK14_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY15_CTRL0    0x0683
+#define    RTL8367C_ACL_VID_RANGE_ENTRY15_CTRL0_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY15_CTRL0_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_VID_RANGE_ENTRY15_CTRL1    0x0684
+#define    RTL8367C_ACL_VID_RANGE_ENTRY15_CTRL1_CHECK15_TYPE_OFFSET    12
+#define    RTL8367C_ACL_VID_RANGE_ENTRY15_CTRL1_CHECK15_TYPE_MASK    0x3000
+#define    RTL8367C_ACL_VID_RANGE_ENTRY15_CTRL1_CHECK15_HIGH_OFFSET    0
+#define    RTL8367C_ACL_VID_RANGE_ENTRY15_CTRL1_CHECK15_HIGH_MASK    0xFFF
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL0    0x0685
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL1    0x0686
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL2    0x0687
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL3    0x0688
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL4    0x0689
+#define    RTL8367C_ACL_IP_RANGE_ENTRY0_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY0_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY1_CTRL0    0x068a
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY1_CTRL1    0x068b
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY1_CTRL2    0x068c
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY1_CTRL3    0x068d
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY1_CTRL4    0x068e
+#define    RTL8367C_ACL_IP_RANGE_ENTRY1_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY1_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY2_CTRL0    0x068f
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY2_CTRL1    0x0690
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY2_CTRL2    0x0691
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY2_CTRL3    0x0692
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY2_CTRL4    0x0693
+#define    RTL8367C_ACL_IP_RANGE_ENTRY2_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY2_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY3_CTRL0    0x0694
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY3_CTRL1    0x0695
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY3_CTRL2    0x0696
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY3_CTRL3    0x0697
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY3_CTRL4    0x0698
+#define    RTL8367C_ACL_IP_RANGE_ENTRY3_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY3_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY4_CTRL0    0x0699
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY4_CTRL1    0x069a
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY4_CTRL2    0x069b
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY4_CTRL3    0x069c
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY4_CTRL4    0x069d
+#define    RTL8367C_ACL_IP_RANGE_ENTRY4_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY4_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY5_CTRL0    0x069e
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY5_CTRL1    0x069f
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY5_CTRL2    0x06a0
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY5_CTRL3    0x06a1
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY5_CTRL4    0x06a2
+#define    RTL8367C_ACL_IP_RANGE_ENTRY5_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY5_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY6_CTRL0    0x06a3
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY6_CTRL1    0x06a4
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY6_CTRL2    0x06a5
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY6_CTRL3    0x06a6
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY6_CTRL4    0x06a7
+#define    RTL8367C_ACL_IP_RANGE_ENTRY6_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY6_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY7_CTRL0    0x06a8
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY7_CTRL1    0x06a9
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY7_CTRL2    0x06aa
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY7_CTRL3    0x06ab
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY7_CTRL4    0x06ac
+#define    RTL8367C_ACL_IP_RANGE_ENTRY7_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY7_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY8_CTRL0    0x06ad
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY8_CTRL1    0x06ae
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY8_CTRL2    0x06af
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY8_CTRL3    0x06b0
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY8_CTRL4    0x06b1
+#define    RTL8367C_ACL_IP_RANGE_ENTRY8_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY8_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY9_CTRL0    0x06b2
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY9_CTRL1    0x06b3
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY9_CTRL2    0x06b4
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY9_CTRL3    0x06b5
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY9_CTRL4    0x06b6
+#define    RTL8367C_ACL_IP_RANGE_ENTRY9_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY9_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY10_CTRL0    0x06b7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY10_CTRL1    0x06b8
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY10_CTRL2    0x06b9
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY10_CTRL3    0x06ba
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY10_CTRL4    0x06bb
+#define    RTL8367C_ACL_IP_RANGE_ENTRY10_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY10_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY11_CTRL0    0x06bc
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY11_CTRL1    0x06bd
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY11_CTRL2    0x06be
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY11_CTRL3    0x06bf
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY11_CTRL4    0x06c0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY11_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY11_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY12_CTRL0    0x06c1
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY12_CTRL1    0x06c2
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY12_CTRL2    0x06c3
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY12_CTRL3    0x06c4
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY12_CTRL4    0x06c5
+#define    RTL8367C_ACL_IP_RANGE_ENTRY12_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY12_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY13_CTRL0    0x06c6
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY13_CTRL1    0x06c7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY13_CTRL2    0x06c8
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY13_CTRL3    0x06c9
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY13_CTRL4    0x06ca
+#define    RTL8367C_ACL_IP_RANGE_ENTRY13_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY13_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY14_CTRL0    0x06cb
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY14_CTRL1    0x06cc
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY14_CTRL2    0x06cd
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY14_CTRL3    0x06ce
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY14_CTRL4    0x06cf
+#define    RTL8367C_ACL_IP_RANGE_ENTRY14_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY14_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY15_CTRL0    0x06d0
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY15_CTRL1    0x06d1
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY15_CTRL2    0x06d2
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY15_CTRL3    0x06d3
+
+#define    RTL8367C_REG_ACL_IP_RANGE_ENTRY15_CTRL4    0x06d4
+#define    RTL8367C_ACL_IP_RANGE_ENTRY15_CTRL4_OFFSET    0
+#define    RTL8367C_ACL_IP_RANGE_ENTRY15_CTRL4_MASK    0x7
+
+#define    RTL8367C_REG_ACL_ENABLE    0x06d5
+#define    RTL8367C_PORT10_ENABLE_OFFSET    10
+#define    RTL8367C_PORT10_ENABLE_MASK    0x400
+#define    RTL8367C_PORT9_ENABLE_OFFSET    9
+#define    RTL8367C_PORT9_ENABLE_MASK    0x200
+#define    RTL8367C_PORT8_ENABLE_OFFSET    8
+#define    RTL8367C_PORT8_ENABLE_MASK    0x100
+#define    RTL8367C_PORT7_ENABLE_OFFSET    7
+#define    RTL8367C_PORT7_ENABLE_MASK    0x80
+#define    RTL8367C_PORT6_ENABLE_OFFSET    6
+#define    RTL8367C_PORT6_ENABLE_MASK    0x40
+#define    RTL8367C_PORT5_ENABLE_OFFSET    5
+#define    RTL8367C_PORT5_ENABLE_MASK    0x20
+#define    RTL8367C_PORT4_ENABLE_OFFSET    4
+#define    RTL8367C_PORT4_ENABLE_MASK    0x10
+#define    RTL8367C_PORT3_ENABLE_OFFSET    3
+#define    RTL8367C_PORT3_ENABLE_MASK    0x8
+#define    RTL8367C_PORT2_ENABLE_OFFSET    2
+#define    RTL8367C_PORT2_ENABLE_MASK    0x4
+#define    RTL8367C_PORT1_ENABLE_OFFSET    1
+#define    RTL8367C_PORT1_ENABLE_MASK    0x2
+#define    RTL8367C_PORT0_ENABLE_OFFSET    0
+#define    RTL8367C_PORT0_ENABLE_MASK    0x1
+
+#define    RTL8367C_REG_ACL_UNMATCH_PERMIT    0x06d6
+#define    RTL8367C_PORT10_PERMIT_OFFSET    10
+#define    RTL8367C_PORT10_PERMIT_MASK    0x400
+#define    RTL8367C_PORT9_PERMIT_OFFSET    9
+#define    RTL8367C_PORT9_PERMIT_MASK    0x200
+#define    RTL8367C_PORT8_PERMIT_OFFSET    8
+#define    RTL8367C_PORT8_PERMIT_MASK    0x100
+#define    RTL8367C_PORT7_PERMIT_OFFSET    7
+#define    RTL8367C_PORT7_PERMIT_MASK    0x80
+#define    RTL8367C_PORT6_PERMIT_OFFSET    6
+#define    RTL8367C_PORT6_PERMIT_MASK    0x40
+#define    RTL8367C_PORT5_PERMIT_OFFSET    5
+#define    RTL8367C_PORT5_PERMIT_MASK    0x20
+#define    RTL8367C_PORT4_PERMIT_OFFSET    4
+#define    RTL8367C_PORT4_PERMIT_MASK    0x10
+#define    RTL8367C_PORT3_PERMIT_OFFSET    3
+#define    RTL8367C_PORT3_PERMIT_MASK    0x8
+#define    RTL8367C_PORT2_PERMIT_OFFSET    2
+#define    RTL8367C_PORT2_PERMIT_MASK    0x4
+#define    RTL8367C_PORT1_PERMIT_OFFSET    1
+#define    RTL8367C_PORT1_PERMIT_MASK    0x2
+#define    RTL8367C_PORT0_PERMIT_OFFSET    0
+#define    RTL8367C_PORT0_PERMIT_MASK    0x1
+
+#define    RTL8367C_REG_ACL_GPIO_POLARITY    0x06d7
+#define    RTL8367C_ACL_GPIO_POLARITY_OFFSET    0
+#define    RTL8367C_ACL_GPIO_POLARITY_MASK    0x1
+
+#define    RTL8367C_REG_ACL_LOG_CNT_TYPE    0x06d8
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER15_TYPE_OFFSET    15
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER15_TYPE_MASK    0x8000
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER14_TYPE_OFFSET    14
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER14_TYPE_MASK    0x4000
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER13_TYPE_OFFSET    13
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER13_TYPE_MASK    0x2000
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER12_TYPE_OFFSET    12
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER12_TYPE_MASK    0x1000
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER11_TYPE_OFFSET    11
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER11_TYPE_MASK    0x800
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER10_TYPE_OFFSET    10
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER10_TYPE_MASK    0x400
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER9_TYPE_OFFSET    9
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER9_TYPE_MASK    0x200
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER8_TYPE_OFFSET    8
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER8_TYPE_MASK    0x100
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER7_TYPE_OFFSET    7
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER7_TYPE_MASK    0x80
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER6_TYPE_OFFSET    6
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER6_TYPE_MASK    0x40
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER5_TYPE_OFFSET    5
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER5_TYPE_MASK    0x20
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER4_TYPE_OFFSET    4
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER4_TYPE_MASK    0x10
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER3_TYPE_OFFSET    3
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER3_TYPE_MASK    0x8
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER2_TYPE_OFFSET    2
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER2_TYPE_MASK    0x4
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER1_TYPE_OFFSET    1
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER1_TYPE_MASK    0x2
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER0_TYPE_OFFSET    0
+#define    RTL8367C_ACL_LOG_CNT_TYPE_COUNTER0_TYPE_MASK    0x1
+
+#define    RTL8367C_REG_ACL_RESET_CFG    0x06d9
+#define    RTL8367C_ACL_RESET_CFG_OFFSET    0
+#define    RTL8367C_ACL_RESET_CFG_MASK    0x1
+
+#define    RTL8367C_REG_ACL_DUMMY00    0x06E0
+
+#define    RTL8367C_REG_ACL_DUMMY01    0x06E1
+
+#define    RTL8367C_REG_ACL_DUMMY02    0x06E2
+
+#define    RTL8367C_REG_ACL_DUMMY03    0x06E3
+
+#define    RTL8367C_REG_ACL_DUMMY04    0x06E4
+
+#define    RTL8367C_REG_ACL_DUMMY05    0x06E5
+
+#define    RTL8367C_REG_ACL_DUMMY06    0x06E6
+
+#define    RTL8367C_REG_ACL_DUMMY07    0x06E7
+
+#define    RTL8367C_REG_ACL_REASON_01    0x06E8
+#define    RTL8367C_ACL_ACT_1_OFFSET    8
+#define    RTL8367C_ACL_ACT_1_MASK    0xFF00
+#define    RTL8367C_ACL_ACT_0_OFFSET    0
+#define    RTL8367C_ACL_ACT_0_MASK    0xFF
+
+#define    RTL8367C_REG_ACL_REASON_23    0x06E9
+#define    RTL8367C_ACL_ACT_3_OFFSET    8
+#define    RTL8367C_ACL_ACT_3_MASK    0xFF00
+#define    RTL8367C_ACL_ACT_2_OFFSET    0
+#define    RTL8367C_ACL_ACT_2_MASK    0xFF
+
+#define    RTL8367C_REG_ACL_REASON_45    0x06EA
+#define    RTL8367C_ACL_ACT_5_OFFSET    8
+#define    RTL8367C_ACL_ACT_5_MASK    0xFF00
+#define    RTL8367C_ACL_ACT_4_OFFSET    0
+#define    RTL8367C_ACL_ACT_4_MASK    0xFF
+
+#define    RTL8367C_REG_ACL_ACCESS_MODE    0x06EB
+#define    RTL8367C_ACL_ACCESS_MODE_OFFSET    0
+#define    RTL8367C_ACL_ACCESS_MODE_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL32    0x06F0
+#define    RTL8367C_OP65_NOT_OFFSET    14
+#define    RTL8367C_OP65_NOT_MASK    0x4000
+#define    RTL8367C_ACT65_GPIO_OFFSET    13
+#define    RTL8367C_ACT65_GPIO_MASK    0x2000
+#define    RTL8367C_ACT65_FORWARD_OFFSET    12
+#define    RTL8367C_ACT65_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT65_POLICING_OFFSET    11
+#define    RTL8367C_ACT65_POLICING_MASK    0x800
+#define    RTL8367C_ACT65_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT65_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT65_SVID_OFFSET    9
+#define    RTL8367C_ACT65_SVID_MASK    0x200
+#define    RTL8367C_ACT65_CVID_OFFSET    8
+#define    RTL8367C_ACT65_CVID_MASK    0x100
+#define    RTL8367C_OP64_NOT_OFFSET    6
+#define    RTL8367C_OP64_NOT_MASK    0x40
+#define    RTL8367C_ACT64_GPIO_OFFSET    5
+#define    RTL8367C_ACT64_GPIO_MASK    0x20
+#define    RTL8367C_ACT64_FORWARD_OFFSET    4
+#define    RTL8367C_ACT64_FORWARD_MASK    0x10
+#define    RTL8367C_ACT64_POLICING_OFFSET    3
+#define    RTL8367C_ACT64_POLICING_MASK    0x8
+#define    RTL8367C_ACT64_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT64_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT64_SVID_OFFSET    1
+#define    RTL8367C_ACT64_SVID_MASK    0x2
+#define    RTL8367C_ACT64_CVID_OFFSET    0
+#define    RTL8367C_ACT64_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL33    0x06F1
+#define    RTL8367C_OP67_NOT_OFFSET    14
+#define    RTL8367C_OP67_NOT_MASK    0x4000
+#define    RTL8367C_ACT67_GPIO_OFFSET    13
+#define    RTL8367C_ACT67_GPIO_MASK    0x2000
+#define    RTL8367C_ACT67_FORWARD_OFFSET    12
+#define    RTL8367C_ACT67_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT67_POLICING_OFFSET    11
+#define    RTL8367C_ACT67_POLICING_MASK    0x800
+#define    RTL8367C_ACT67_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT67_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT67_SVID_OFFSET    9
+#define    RTL8367C_ACT67_SVID_MASK    0x200
+#define    RTL8367C_ACT67_CVID_OFFSET    8
+#define    RTL8367C_ACT67_CVID_MASK    0x100
+#define    RTL8367C_OP66_NOT_OFFSET    6
+#define    RTL8367C_OP66_NOT_MASK    0x40
+#define    RTL8367C_ACT66_GPIO_OFFSET    5
+#define    RTL8367C_ACT66_GPIO_MASK    0x20
+#define    RTL8367C_ACT66_FORWARD_OFFSET    4
+#define    RTL8367C_ACT66_FORWARD_MASK    0x10
+#define    RTL8367C_ACT66_POLICING_OFFSET    3
+#define    RTL8367C_ACT66_POLICING_MASK    0x8
+#define    RTL8367C_ACT66_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT66_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT66_SVID_OFFSET    1
+#define    RTL8367C_ACT66_SVID_MASK    0x2
+#define    RTL8367C_ACT66_CVID_OFFSET    0
+#define    RTL8367C_ACT66_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL34    0x06F2
+#define    RTL8367C_OP69_NOT_OFFSET    14
+#define    RTL8367C_OP69_NOT_MASK    0x4000
+#define    RTL8367C_ACT69_GPIO_OFFSET    13
+#define    RTL8367C_ACT69_GPIO_MASK    0x2000
+#define    RTL8367C_ACT69_FORWARD_OFFSET    12
+#define    RTL8367C_ACT69_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT69_POLICING_OFFSET    11
+#define    RTL8367C_ACT69_POLICING_MASK    0x800
+#define    RTL8367C_ACT69_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT69_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT69_SVID_OFFSET    9
+#define    RTL8367C_ACT69_SVID_MASK    0x200
+#define    RTL8367C_ACT69_CVID_OFFSET    8
+#define    RTL8367C_ACT69_CVID_MASK    0x100
+#define    RTL8367C_OP68_NOT_OFFSET    6
+#define    RTL8367C_OP68_NOT_MASK    0x40
+#define    RTL8367C_ACT68_GPIO_OFFSET    5
+#define    RTL8367C_ACT68_GPIO_MASK    0x20
+#define    RTL8367C_ACT68_FORWARD_OFFSET    4
+#define    RTL8367C_ACT68_FORWARD_MASK    0x10
+#define    RTL8367C_ACT68_POLICING_OFFSET    3
+#define    RTL8367C_ACT68_POLICING_MASK    0x8
+#define    RTL8367C_ACT68_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT68_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT68_SVID_OFFSET    1
+#define    RTL8367C_ACT68_SVID_MASK    0x2
+#define    RTL8367C_ACT68_CVID_OFFSET    0
+#define    RTL8367C_ACT68_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL35    0x06F3
+#define    RTL8367C_OP71_NOT_OFFSET    14
+#define    RTL8367C_OP71_NOT_MASK    0x4000
+#define    RTL8367C_ACT71_GPIO_OFFSET    13
+#define    RTL8367C_ACT71_GPIO_MASK    0x2000
+#define    RTL8367C_ACT71_FORWARD_OFFSET    12
+#define    RTL8367C_ACT71_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT71_POLICING_OFFSET    11
+#define    RTL8367C_ACT71_POLICING_MASK    0x800
+#define    RTL8367C_ACT71_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT71_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT71_SVID_OFFSET    9
+#define    RTL8367C_ACT71_SVID_MASK    0x200
+#define    RTL8367C_ACT71_CVID_OFFSET    8
+#define    RTL8367C_ACT71_CVID_MASK    0x100
+#define    RTL8367C_OP70_NOT_OFFSET    6
+#define    RTL8367C_OP70_NOT_MASK    0x40
+#define    RTL8367C_ACT70_GPIO_OFFSET    5
+#define    RTL8367C_ACT70_GPIO_MASK    0x20
+#define    RTL8367C_ACT70_FORWARD_OFFSET    4
+#define    RTL8367C_ACT70_FORWARD_MASK    0x10
+#define    RTL8367C_ACT70_POLICING_OFFSET    3
+#define    RTL8367C_ACT70_POLICING_MASK    0x8
+#define    RTL8367C_ACT70_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT70_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT70_SVID_OFFSET    1
+#define    RTL8367C_ACT70_SVID_MASK    0x2
+#define    RTL8367C_ACT70_CVID_OFFSET    0
+#define    RTL8367C_ACT70_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL36    0x06F4
+#define    RTL8367C_OP73_NOT_OFFSET    14
+#define    RTL8367C_OP73_NOT_MASK    0x4000
+#define    RTL8367C_ACT73_GPIO_OFFSET    13
+#define    RTL8367C_ACT73_GPIO_MASK    0x2000
+#define    RTL8367C_ACT73_FORWARD_OFFSET    12
+#define    RTL8367C_ACT73_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT73_POLICING_OFFSET    11
+#define    RTL8367C_ACT73_POLICING_MASK    0x800
+#define    RTL8367C_ACT73_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT73_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT73_SVID_OFFSET    9
+#define    RTL8367C_ACT73_SVID_MASK    0x200
+#define    RTL8367C_ACT73_CVID_OFFSET    8
+#define    RTL8367C_ACT73_CVID_MASK    0x100
+#define    RTL8367C_OP72_NOT_OFFSET    6
+#define    RTL8367C_OP72_NOT_MASK    0x40
+#define    RTL8367C_ACT72_GPIO_OFFSET    5
+#define    RTL8367C_ACT72_GPIO_MASK    0x20
+#define    RTL8367C_ACT72_FORWARD_OFFSET    4
+#define    RTL8367C_ACT72_FORWARD_MASK    0x10
+#define    RTL8367C_ACT72_POLICING_OFFSET    3
+#define    RTL8367C_ACT72_POLICING_MASK    0x8
+#define    RTL8367C_ACT72_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT72_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT72_SVID_OFFSET    1
+#define    RTL8367C_ACT72_SVID_MASK    0x2
+#define    RTL8367C_ACT72_CVID_OFFSET    0
+#define    RTL8367C_ACT72_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL37    0x06F5
+#define    RTL8367C_OP75_NOT_OFFSET    14
+#define    RTL8367C_OP75_NOT_MASK    0x4000
+#define    RTL8367C_ACT75_GPIO_OFFSET    13
+#define    RTL8367C_ACT75_GPIO_MASK    0x2000
+#define    RTL8367C_ACT75_FORWARD_OFFSET    12
+#define    RTL8367C_ACT75_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT75_POLICING_OFFSET    11
+#define    RTL8367C_ACT75_POLICING_MASK    0x800
+#define    RTL8367C_ACT75_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT75_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT75_SVID_OFFSET    9
+#define    RTL8367C_ACT75_SVID_MASK    0x200
+#define    RTL8367C_ACT75_CVID_OFFSET    8
+#define    RTL8367C_ACT75_CVID_MASK    0x100
+#define    RTL8367C_OP74_NOT_OFFSET    6
+#define    RTL8367C_OP74_NOT_MASK    0x40
+#define    RTL8367C_ACT74_GPIO_OFFSET    5
+#define    RTL8367C_ACT74_GPIO_MASK    0x20
+#define    RTL8367C_ACT74_FORWARD_OFFSET    4
+#define    RTL8367C_ACT74_FORWARD_MASK    0x10
+#define    RTL8367C_ACT74_POLICING_OFFSET    3
+#define    RTL8367C_ACT74_POLICING_MASK    0x8
+#define    RTL8367C_ACT74_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT74_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT74_SVID_OFFSET    1
+#define    RTL8367C_ACT74_SVID_MASK    0x2
+#define    RTL8367C_ACT74_CVID_OFFSET    0
+#define    RTL8367C_ACT74_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL38    0x06F6
+#define    RTL8367C_OP77_NOT_OFFSET    14
+#define    RTL8367C_OP77_NOT_MASK    0x4000
+#define    RTL8367C_ACT77_GPIO_OFFSET    13
+#define    RTL8367C_ACT77_GPIO_MASK    0x2000
+#define    RTL8367C_ACT77_FORWARD_OFFSET    12
+#define    RTL8367C_ACT77_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT77_POLICING_OFFSET    11
+#define    RTL8367C_ACT77_POLICING_MASK    0x800
+#define    RTL8367C_ACT77_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT77_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT77_SVID_OFFSET    9
+#define    RTL8367C_ACT77_SVID_MASK    0x200
+#define    RTL8367C_ACT77_CVID_OFFSET    8
+#define    RTL8367C_ACT77_CVID_MASK    0x100
+#define    RTL8367C_OP76_NOT_OFFSET    6
+#define    RTL8367C_OP76_NOT_MASK    0x40
+#define    RTL8367C_ACT76_GPIO_OFFSET    5
+#define    RTL8367C_ACT76_GPIO_MASK    0x20
+#define    RTL8367C_ACT76_FORWARD_OFFSET    4
+#define    RTL8367C_ACT76_FORWARD_MASK    0x10
+#define    RTL8367C_ACT76_POLICING_OFFSET    3
+#define    RTL8367C_ACT76_POLICING_MASK    0x8
+#define    RTL8367C_ACT76_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT76_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT76_SVID_OFFSET    1
+#define    RTL8367C_ACT76_SVID_MASK    0x2
+#define    RTL8367C_ACT76_CVID_OFFSET    0
+#define    RTL8367C_ACT76_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL39    0x06F7
+#define    RTL8367C_OP79_NOT_OFFSET    14
+#define    RTL8367C_OP79_NOT_MASK    0x4000
+#define    RTL8367C_ACT79_GPIO_OFFSET    13
+#define    RTL8367C_ACT79_GPIO_MASK    0x2000
+#define    RTL8367C_ACT79_FORWARD_OFFSET    12
+#define    RTL8367C_ACT79_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT79_POLICING_OFFSET    11
+#define    RTL8367C_ACT79_POLICING_MASK    0x800
+#define    RTL8367C_ACT79_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT79_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT79_SVID_OFFSET    9
+#define    RTL8367C_ACT79_SVID_MASK    0x200
+#define    RTL8367C_ACT79_CVID_OFFSET    8
+#define    RTL8367C_ACT79_CVID_MASK    0x100
+#define    RTL8367C_OP78_NOT_OFFSET    6
+#define    RTL8367C_OP78_NOT_MASK    0x40
+#define    RTL8367C_ACT78_GPIO_OFFSET    5
+#define    RTL8367C_ACT78_GPIO_MASK    0x20
+#define    RTL8367C_ACT78_FORWARD_OFFSET    4
+#define    RTL8367C_ACT78_FORWARD_MASK    0x10
+#define    RTL8367C_ACT78_POLICING_OFFSET    3
+#define    RTL8367C_ACT78_POLICING_MASK    0x8
+#define    RTL8367C_ACT78_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT78_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT78_SVID_OFFSET    1
+#define    RTL8367C_ACT78_SVID_MASK    0x2
+#define    RTL8367C_ACT78_CVID_OFFSET    0
+#define    RTL8367C_ACT78_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL40    0x06F8
+#define    RTL8367C_OP81_NOT_OFFSET    14
+#define    RTL8367C_OP81_NOT_MASK    0x4000
+#define    RTL8367C_ACT81_GPIO_OFFSET    13
+#define    RTL8367C_ACT81_GPIO_MASK    0x2000
+#define    RTL8367C_ACT81_FORWARD_OFFSET    12
+#define    RTL8367C_ACT81_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT81_POLICING_OFFSET    11
+#define    RTL8367C_ACT81_POLICING_MASK    0x800
+#define    RTL8367C_ACT81_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT81_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT81_SVID_OFFSET    9
+#define    RTL8367C_ACT81_SVID_MASK    0x200
+#define    RTL8367C_ACT81_CVID_OFFSET    8
+#define    RTL8367C_ACT81_CVID_MASK    0x100
+#define    RTL8367C_OP80_NOT_OFFSET    6
+#define    RTL8367C_OP80_NOT_MASK    0x40
+#define    RTL8367C_ACT80_GPIO_OFFSET    5
+#define    RTL8367C_ACT80_GPIO_MASK    0x20
+#define    RTL8367C_ACT80_FORWARD_OFFSET    4
+#define    RTL8367C_ACT80_FORWARD_MASK    0x10
+#define    RTL8367C_ACT80_POLICING_OFFSET    3
+#define    RTL8367C_ACT80_POLICING_MASK    0x8
+#define    RTL8367C_ACT80_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT80_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT80_SVID_OFFSET    1
+#define    RTL8367C_ACT80_SVID_MASK    0x2
+#define    RTL8367C_ACT80_CVID_OFFSET    0
+#define    RTL8367C_ACT80_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL41    0x06F9
+#define    RTL8367C_OP83_NOT_OFFSET    14
+#define    RTL8367C_OP83_NOT_MASK    0x4000
+#define    RTL8367C_ACT83_GPIO_OFFSET    13
+#define    RTL8367C_ACT83_GPIO_MASK    0x2000
+#define    RTL8367C_ACT83_FORWARD_OFFSET    12
+#define    RTL8367C_ACT83_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT83_POLICING_OFFSET    11
+#define    RTL8367C_ACT83_POLICING_MASK    0x800
+#define    RTL8367C_ACT83_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT83_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT83_SVID_OFFSET    9
+#define    RTL8367C_ACT83_SVID_MASK    0x200
+#define    RTL8367C_ACT83_CVID_OFFSET    8
+#define    RTL8367C_ACT83_CVID_MASK    0x100
+#define    RTL8367C_OP82_NOT_OFFSET    6
+#define    RTL8367C_OP82_NOT_MASK    0x40
+#define    RTL8367C_ACT82_GPIO_OFFSET    5
+#define    RTL8367C_ACT82_GPIO_MASK    0x20
+#define    RTL8367C_ACT82_FORWARD_OFFSET    4
+#define    RTL8367C_ACT82_FORWARD_MASK    0x10
+#define    RTL8367C_ACT82_POLICING_OFFSET    3
+#define    RTL8367C_ACT82_POLICING_MASK    0x8
+#define    RTL8367C_ACT82_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT82_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT82_SVID_OFFSET    1
+#define    RTL8367C_ACT82_SVID_MASK    0x2
+#define    RTL8367C_ACT82_CVID_OFFSET    0
+#define    RTL8367C_ACT82_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL42    0x06FA
+#define    RTL8367C_OP85_NOT_OFFSET    14
+#define    RTL8367C_OP85_NOT_MASK    0x4000
+#define    RTL8367C_ACT85_GPIO_OFFSET    13
+#define    RTL8367C_ACT85_GPIO_MASK    0x2000
+#define    RTL8367C_ACT85_FORWARD_OFFSET    12
+#define    RTL8367C_ACT85_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT85_POLICING_OFFSET    11
+#define    RTL8367C_ACT85_POLICING_MASK    0x800
+#define    RTL8367C_ACT85_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT85_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT85_SVID_OFFSET    9
+#define    RTL8367C_ACT85_SVID_MASK    0x200
+#define    RTL8367C_ACT85_CVID_OFFSET    8
+#define    RTL8367C_ACT85_CVID_MASK    0x100
+#define    RTL8367C_OP84_NOT_OFFSET    6
+#define    RTL8367C_OP84_NOT_MASK    0x40
+#define    RTL8367C_ACT84_GPIO_OFFSET    5
+#define    RTL8367C_ACT84_GPIO_MASK    0x20
+#define    RTL8367C_ACT84_FORWARD_OFFSET    4
+#define    RTL8367C_ACT84_FORWARD_MASK    0x10
+#define    RTL8367C_ACT84_POLICING_OFFSET    3
+#define    RTL8367C_ACT84_POLICING_MASK    0x8
+#define    RTL8367C_ACT84_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT84_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT84_SVID_OFFSET    1
+#define    RTL8367C_ACT84_SVID_MASK    0x2
+#define    RTL8367C_ACT84_CVID_OFFSET    0
+#define    RTL8367C_ACT84_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL43    0x06FB
+#define    RTL8367C_OP87_NOT_OFFSET    14
+#define    RTL8367C_OP87_NOT_MASK    0x4000
+#define    RTL8367C_ACT87_GPIO_OFFSET    13
+#define    RTL8367C_ACT87_GPIO_MASK    0x2000
+#define    RTL8367C_ACT87_FORWARD_OFFSET    12
+#define    RTL8367C_ACT87_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT87_POLICING_OFFSET    11
+#define    RTL8367C_ACT87_POLICING_MASK    0x800
+#define    RTL8367C_ACT87_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT87_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT87_SVID_OFFSET    9
+#define    RTL8367C_ACT87_SVID_MASK    0x200
+#define    RTL8367C_ACT87_CVID_OFFSET    8
+#define    RTL8367C_ACT87_CVID_MASK    0x100
+#define    RTL8367C_OP86_NOT_OFFSET    6
+#define    RTL8367C_OP86_NOT_MASK    0x40
+#define    RTL8367C_ACT86_GPIO_OFFSET    5
+#define    RTL8367C_ACT86_GPIO_MASK    0x20
+#define    RTL8367C_ACT86_FORWARD_OFFSET    4
+#define    RTL8367C_ACT86_FORWARD_MASK    0x10
+#define    RTL8367C_ACT86_POLICING_OFFSET    3
+#define    RTL8367C_ACT86_POLICING_MASK    0x8
+#define    RTL8367C_ACT86_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT86_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT86_SVID_OFFSET    1
+#define    RTL8367C_ACT86_SVID_MASK    0x2
+#define    RTL8367C_ACT86_CVID_OFFSET    0
+#define    RTL8367C_ACT86_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL44    0x06FC
+#define    RTL8367C_OP89_NOT_OFFSET    14
+#define    RTL8367C_OP89_NOT_MASK    0x4000
+#define    RTL8367C_ACT89_GPIO_OFFSET    13
+#define    RTL8367C_ACT89_GPIO_MASK    0x2000
+#define    RTL8367C_ACT89_FORWARD_OFFSET    12
+#define    RTL8367C_ACT89_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT89_POLICING_OFFSET    11
+#define    RTL8367C_ACT89_POLICING_MASK    0x800
+#define    RTL8367C_ACT89_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT89_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT89_SVID_OFFSET    9
+#define    RTL8367C_ACT89_SVID_MASK    0x200
+#define    RTL8367C_ACT89_CVID_OFFSET    8
+#define    RTL8367C_ACT89_CVID_MASK    0x100
+#define    RTL8367C_OP88_NOT_OFFSET    6
+#define    RTL8367C_OP88_NOT_MASK    0x40
+#define    RTL8367C_ACT88_GPIO_OFFSET    5
+#define    RTL8367C_ACT88_GPIO_MASK    0x20
+#define    RTL8367C_ACT88_FORWARD_OFFSET    4
+#define    RTL8367C_ACT88_FORWARD_MASK    0x10
+#define    RTL8367C_ACT88_POLICING_OFFSET    3
+#define    RTL8367C_ACT88_POLICING_MASK    0x8
+#define    RTL8367C_ACT88_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT88_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT88_SVID_OFFSET    1
+#define    RTL8367C_ACT88_SVID_MASK    0x2
+#define    RTL8367C_ACT88_CVID_OFFSET    0
+#define    RTL8367C_ACT88_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL45    0x06FD
+#define    RTL8367C_OP91_NOT_OFFSET    14
+#define    RTL8367C_OP91_NOT_MASK    0x4000
+#define    RTL8367C_ACT91_GPIO_OFFSET    13
+#define    RTL8367C_ACT91_GPIO_MASK    0x2000
+#define    RTL8367C_ACT91_FORWARD_OFFSET    12
+#define    RTL8367C_ACT91_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT91_POLICING_OFFSET    11
+#define    RTL8367C_ACT91_POLICING_MASK    0x800
+#define    RTL8367C_ACT91_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT91_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT91_SVID_OFFSET    9
+#define    RTL8367C_ACT91_SVID_MASK    0x200
+#define    RTL8367C_ACT91_CVID_OFFSET    8
+#define    RTL8367C_ACT91_CVID_MASK    0x100
+#define    RTL8367C_OP90_NOT_OFFSET    6
+#define    RTL8367C_OP90_NOT_MASK    0x40
+#define    RTL8367C_ACT90_GPIO_OFFSET    5
+#define    RTL8367C_ACT90_GPIO_MASK    0x20
+#define    RTL8367C_ACT90_FORWARD_OFFSET    4
+#define    RTL8367C_ACT90_FORWARD_MASK    0x10
+#define    RTL8367C_ACT90_POLICING_OFFSET    3
+#define    RTL8367C_ACT90_POLICING_MASK    0x8
+#define    RTL8367C_ACT90_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT90_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT90_SVID_OFFSET    1
+#define    RTL8367C_ACT90_SVID_MASK    0x2
+#define    RTL8367C_ACT90_CVID_OFFSET    0
+#define    RTL8367C_ACT90_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL46    0x06FE
+#define    RTL8367C_OP93_NOT_OFFSET    14
+#define    RTL8367C_OP93_NOT_MASK    0x4000
+#define    RTL8367C_ACT93_GPIO_OFFSET    13
+#define    RTL8367C_ACT93_GPIO_MASK    0x2000
+#define    RTL8367C_ACT93_FORWARD_OFFSET    12
+#define    RTL8367C_ACT93_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT93_POLICING_OFFSET    11
+#define    RTL8367C_ACT93_POLICING_MASK    0x800
+#define    RTL8367C_ACT93_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT93_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT93_SVID_OFFSET    9
+#define    RTL8367C_ACT93_SVID_MASK    0x200
+#define    RTL8367C_ACT93_CVID_OFFSET    8
+#define    RTL8367C_ACT93_CVID_MASK    0x100
+#define    RTL8367C_OP92_NOT_OFFSET    6
+#define    RTL8367C_OP92_NOT_MASK    0x40
+#define    RTL8367C_ACT92_GPIO_OFFSET    5
+#define    RTL8367C_ACT92_GPIO_MASK    0x20
+#define    RTL8367C_ACT92_FORWARD_OFFSET    4
+#define    RTL8367C_ACT92_FORWARD_MASK    0x10
+#define    RTL8367C_ACT92_POLICING_OFFSET    3
+#define    RTL8367C_ACT92_POLICING_MASK    0x8
+#define    RTL8367C_ACT92_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT92_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT92_SVID_OFFSET    1
+#define    RTL8367C_ACT92_SVID_MASK    0x2
+#define    RTL8367C_ACT92_CVID_OFFSET    0
+#define    RTL8367C_ACT92_CVID_MASK    0x1
+
+#define    RTL8367C_REG_ACL_ACTION_CTRL47    0x06FF
+#define    RTL8367C_OP95_NOT_OFFSET    14
+#define    RTL8367C_OP95_NOT_MASK    0x4000
+#define    RTL8367C_ACT95_GPIO_OFFSET    13
+#define    RTL8367C_ACT95_GPIO_MASK    0x2000
+#define    RTL8367C_ACT95_FORWARD_OFFSET    12
+#define    RTL8367C_ACT95_FORWARD_MASK    0x1000
+#define    RTL8367C_ACT95_POLICING_OFFSET    11
+#define    RTL8367C_ACT95_POLICING_MASK    0x800
+#define    RTL8367C_ACT95_PRIORITY_OFFSET    10
+#define    RTL8367C_ACT95_PRIORITY_MASK    0x400
+#define    RTL8367C_ACT95_SVID_OFFSET    9
+#define    RTL8367C_ACT95_SVID_MASK    0x200
+#define    RTL8367C_ACT95_CVID_OFFSET    8
+#define    RTL8367C_ACT95_CVID_MASK    0x100
+#define    RTL8367C_OP94_NOT_OFFSET    6
+#define    RTL8367C_OP94_NOT_MASK    0x40
+#define    RTL8367C_ACT94_GPIO_OFFSET    5
+#define    RTL8367C_ACT94_GPIO_MASK    0x20
+#define    RTL8367C_ACT94_FORWARD_OFFSET    4
+#define    RTL8367C_ACT94_FORWARD_MASK    0x10
+#define    RTL8367C_ACT94_POLICING_OFFSET    3
+#define    RTL8367C_ACT94_POLICING_MASK    0x8
+#define    RTL8367C_ACT94_PRIORITY_OFFSET    2
+#define    RTL8367C_ACT94_PRIORITY_MASK    0x4
+#define    RTL8367C_ACT94_SVID_OFFSET    1
+#define    RTL8367C_ACT94_SVID_MASK    0x2
+#define    RTL8367C_ACT94_CVID_OFFSET    0
+#define    RTL8367C_ACT94_CVID_MASK    0x1
+
+/* (16'h0700)cvlan_reg */
+
+#define    RTL8367C_REG_VLAN_PVID_CTRL0    0x0700
+#define    RTL8367C_PORT1_VIDX_OFFSET    8
+#define    RTL8367C_PORT1_VIDX_MASK    0x1F00
+#define    RTL8367C_PORT0_VIDX_OFFSET    0
+#define    RTL8367C_PORT0_VIDX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PVID_CTRL1    0x0701
+#define    RTL8367C_PORT3_VIDX_OFFSET    8
+#define    RTL8367C_PORT3_VIDX_MASK    0x1F00
+#define    RTL8367C_PORT2_VIDX_OFFSET    0
+#define    RTL8367C_PORT2_VIDX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PVID_CTRL2    0x0702
+#define    RTL8367C_PORT5_VIDX_OFFSET    8
+#define    RTL8367C_PORT5_VIDX_MASK    0x1F00
+#define    RTL8367C_PORT4_VIDX_OFFSET    0
+#define    RTL8367C_PORT4_VIDX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PVID_CTRL3    0x0703
+#define    RTL8367C_PORT7_VIDX_OFFSET    8
+#define    RTL8367C_PORT7_VIDX_MASK    0x1F00
+#define    RTL8367C_PORT6_VIDX_OFFSET    0
+#define    RTL8367C_PORT6_VIDX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PVID_CTRL4    0x0704
+#define    RTL8367C_PORT9_VIDX_OFFSET    8
+#define    RTL8367C_PORT9_VIDX_MASK    0x1F00
+#define    RTL8367C_PORT8_VIDX_OFFSET    0
+#define    RTL8367C_PORT8_VIDX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PVID_CTRL5    0x0705
+#define    RTL8367C_VLAN_PVID_CTRL5_OFFSET    0
+#define    RTL8367C_VLAN_PVID_CTRL5_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB0_VALID    0x0708
+#define    RTL8367C_VLAN_PPB0_VALID_VALID_EXT_OFFSET    8
+#define    RTL8367C_VLAN_PPB0_VALID_VALID_EXT_MASK    0x700
+#define    RTL8367C_VLAN_PPB0_VALID_VALID_OFFSET    0
+#define    RTL8367C_VLAN_PPB0_VALID_VALID_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_PPB0_CTRL0    0x0709
+#define    RTL8367C_VLAN_PPB0_CTRL0_PORT2_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB0_CTRL0_PORT2_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB0_CTRL0_PORT1_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB0_CTRL0_PORT1_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB0_CTRL0_PORT0_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB0_CTRL0_PORT0_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB0_CTRL1    0x070a
+#define    RTL8367C_VLAN_PPB0_CTRL1_PORT5_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB0_CTRL1_PORT5_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB0_CTRL1_PORT4_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB0_CTRL1_PORT4_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB0_CTRL1_PORT3_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB0_CTRL1_PORT3_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB0_CTRL2    0x070b
+#define    RTL8367C_VLAN_PPB0_CTRL2_FRAME_TYPE_OFFSET    10
+#define    RTL8367C_VLAN_PPB0_CTRL2_FRAME_TYPE_MASK    0xC00
+#define    RTL8367C_VLAN_PPB0_CTRL2_PORT7_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB0_CTRL2_PORT7_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB0_CTRL2_PORT6_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB0_CTRL2_PORT6_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB0_CTRL4    0x070c
+#define    RTL8367C_VLAN_PPB0_CTRL4_PORT10_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB0_CTRL4_PORT10_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB0_CTRL4_PORT9_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB0_CTRL4_PORT9_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB0_CTRL4_PORT8_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB0_CTRL4_PORT8_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB0_CTRL3    0x070f
+
+#define    RTL8367C_REG_VLAN_PPB1_VALID    0x0710
+#define    RTL8367C_VLAN_PPB1_VALID_VALID_EXT_OFFSET    8
+#define    RTL8367C_VLAN_PPB1_VALID_VALID_EXT_MASK    0x700
+#define    RTL8367C_VLAN_PPB1_VALID_VALID_OFFSET    0
+#define    RTL8367C_VLAN_PPB1_VALID_VALID_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_PPB1_CTRL0    0x0711
+#define    RTL8367C_VLAN_PPB1_CTRL0_PORT2_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB1_CTRL0_PORT2_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB1_CTRL0_PORT1_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB1_CTRL0_PORT1_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB1_CTRL0_PORT0_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB1_CTRL0_PORT0_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB1_CTRL1    0x0712
+#define    RTL8367C_VLAN_PPB1_CTRL1_PORT5_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB1_CTRL1_PORT5_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB1_CTRL1_PORT4_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB1_CTRL1_PORT4_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB1_CTRL1_PORT3_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB1_CTRL1_PORT3_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB1_CTRL2    0x0713
+#define    RTL8367C_VLAN_PPB1_CTRL2_FRAME_TYPE_OFFSET    10
+#define    RTL8367C_VLAN_PPB1_CTRL2_FRAME_TYPE_MASK    0xC00
+#define    RTL8367C_VLAN_PPB1_CTRL2_PORT7_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB1_CTRL2_PORT7_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB1_CTRL2_PORT6_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB1_CTRL2_PORT6_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB1_CTRL4    0x0714
+#define    RTL8367C_VLAN_PPB1_CTRL4_PORT10_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB1_CTRL4_PORT10_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB1_CTRL4_PORT9_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB1_CTRL4_PORT9_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB1_CTRL4_PORT8_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB1_CTRL4_PORT8_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB1_CTRL3    0x0717
+
+#define    RTL8367C_REG_VLAN_PPB2_VALID    0x0718
+#define    RTL8367C_VLAN_PPB2_VALID_VALID_EXT_OFFSET    8
+#define    RTL8367C_VLAN_PPB2_VALID_VALID_EXT_MASK    0x700
+#define    RTL8367C_VLAN_PPB2_VALID_VALID_OFFSET    0
+#define    RTL8367C_VLAN_PPB2_VALID_VALID_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_PPB2_CTRL0    0x0719
+#define    RTL8367C_VLAN_PPB2_CTRL0_PORT2_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB2_CTRL0_PORT2_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB2_CTRL0_PORT1_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB2_CTRL0_PORT1_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB2_CTRL0_PORT0_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB2_CTRL0_PORT0_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB2_CTRL1    0x071a
+#define    RTL8367C_VLAN_PPB2_CTRL1_PORT5_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB2_CTRL1_PORT5_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB2_CTRL1_PORT4_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB2_CTRL1_PORT4_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB2_CTRL1_PORT3_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB2_CTRL1_PORT3_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB2_CTRL2    0x071b
+#define    RTL8367C_VLAN_PPB2_CTRL2_FRAME_TYPE_OFFSET    10
+#define    RTL8367C_VLAN_PPB2_CTRL2_FRAME_TYPE_MASK    0xC00
+#define    RTL8367C_VLAN_PPB2_CTRL2_PORT7_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB2_CTRL2_PORT7_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB2_CTRL2_PORT6_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB2_CTRL2_PORT6_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB2_CTRL4    0x071c
+#define    RTL8367C_VLAN_PPB2_CTRL4_PORT10_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB2_CTRL4_PORT10_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB2_CTRL4_PORT9_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB2_CTRL4_PORT9_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB2_CTRL4_PORT8_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB2_CTRL4_PORT8_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB2_CTRL3    0x071f
+
+#define    RTL8367C_REG_VLAN_PPB3_VALID    0x0720
+#define    RTL8367C_VLAN_PPB3_VALID_VALID_EXT_OFFSET    8
+#define    RTL8367C_VLAN_PPB3_VALID_VALID_EXT_MASK    0x700
+#define    RTL8367C_VLAN_PPB3_VALID_VALID_OFFSET    0
+#define    RTL8367C_VLAN_PPB3_VALID_VALID_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_PPB3_CTRL0    0x0721
+#define    RTL8367C_VLAN_PPB3_CTRL0_PORT2_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB3_CTRL0_PORT2_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB3_CTRL0_PORT1_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB3_CTRL0_PORT1_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB3_CTRL0_PORT0_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB3_CTRL0_PORT0_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB3_CTRL1    0x0722
+#define    RTL8367C_VLAN_PPB3_CTRL1_PORT5_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB3_CTRL1_PORT5_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB3_CTRL1_PORT4_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB3_CTRL1_PORT4_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB3_CTRL1_PORT3_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB3_CTRL1_PORT3_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB3_CTRL2    0x0723
+#define    RTL8367C_VLAN_PPB3_CTRL2_FRAME_TYPE_OFFSET    10
+#define    RTL8367C_VLAN_PPB3_CTRL2_FRAME_TYPE_MASK    0xC00
+#define    RTL8367C_VLAN_PPB3_CTRL2_PORT7_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB3_CTRL2_PORT7_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB3_CTRL2_PORT6_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB3_CTRL2_PORT6_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB3_CTRL4    0x0724
+#define    RTL8367C_VLAN_PPB3_CTRL4_PORT10_INDEX_OFFSET    10
+#define    RTL8367C_VLAN_PPB3_CTRL4_PORT10_INDEX_MASK    0x7C00
+#define    RTL8367C_VLAN_PPB3_CTRL4_PORT9_INDEX_OFFSET    5
+#define    RTL8367C_VLAN_PPB3_CTRL4_PORT9_INDEX_MASK    0x3E0
+#define    RTL8367C_VLAN_PPB3_CTRL4_PORT8_INDEX_OFFSET    0
+#define    RTL8367C_VLAN_PPB3_CTRL4_PORT8_INDEX_MASK    0x1F
+
+#define    RTL8367C_REG_VLAN_PPB3_CTRL3    0x0727
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION0_CTRL0    0x0728
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION0_CTRL1    0x0729
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION0_CTRL2    0x072a
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION0_CTRL3    0x072b
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION0_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION1_CTRL0    0x072c
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION1_CTRL1    0x072d
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION1_CTRL2    0x072e
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION1_CTRL3    0x072f
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION1_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION2_CTRL0    0x0730
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION2_CTRL1    0x0731
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION2_CTRL2    0x0732
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION2_CTRL3    0x0733
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION2_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION3_CTRL0    0x0734
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION3_CTRL1    0x0735
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION3_CTRL2    0x0736
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION3_CTRL3    0x0737
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION3_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION4_CTRL0    0x0738
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION4_CTRL1    0x0739
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION4_CTRL2    0x073a
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION4_CTRL3    0x073b
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION4_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION5_CTRL0    0x073c
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION5_CTRL1    0x073d
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION5_CTRL2    0x073e
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION5_CTRL3    0x073f
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION5_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION6_CTRL0    0x0740
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION6_CTRL1    0x0741
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION6_CTRL2    0x0742
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION6_CTRL3    0x0743
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION6_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION7_CTRL0    0x0744
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION7_CTRL1    0x0745
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION7_CTRL2    0x0746
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION7_CTRL3    0x0747
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION7_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION8_CTRL0    0x0748
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION8_CTRL1    0x0749
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION8_CTRL2    0x074a
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION8_CTRL3    0x074b
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION8_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION9_CTRL0    0x074c
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION9_CTRL1    0x074d
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION9_CTRL2    0x074e
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION9_CTRL3    0x074f
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION9_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION10_CTRL0    0x0750
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION10_CTRL1    0x0751
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION10_CTRL2    0x0752
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION10_CTRL3    0x0753
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION10_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION11_CTRL0    0x0754
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION11_CTRL1    0x0755
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION11_CTRL2    0x0756
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION11_CTRL3    0x0757
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION11_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION12_CTRL0    0x0758
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION12_CTRL1    0x0759
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION12_CTRL2    0x075a
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION12_CTRL3    0x075b
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION12_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION13_CTRL0    0x075c
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION13_CTRL1    0x075d
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION13_CTRL2    0x075e
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION13_CTRL3    0x075f
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION13_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION14_CTRL0    0x0760
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION14_CTRL1    0x0761
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION14_CTRL2    0x0762
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION14_CTRL3    0x0763
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION14_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION15_CTRL0    0x0764
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION15_CTRL1    0x0765
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION15_CTRL2    0x0766
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION15_CTRL3    0x0767
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION15_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION16_CTRL0    0x0768
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION16_CTRL1    0x0769
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION16_CTRL2    0x076a
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION16_CTRL3    0x076b
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION16_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION17_CTRL0    0x076c
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION17_CTRL1    0x076d
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION17_CTRL2    0x076e
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION17_CTRL3    0x076f
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION17_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION18_CTRL0    0x0770
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION18_CTRL1    0x0771
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION18_CTRL2    0x0772
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION18_CTRL3    0x0773
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION18_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION19_CTRL0    0x0774
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION19_CTRL1    0x0775
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION19_CTRL2    0x0776
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION19_CTRL3    0x0777
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION19_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION20_CTRL0    0x0778
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION20_CTRL1    0x0779
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION20_CTRL2    0x077a
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION20_CTRL3    0x077b
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION20_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION21_CTRL0    0x077c
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION21_CTRL1    0x077d
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION21_CTRL2    0x077e
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION21_CTRL3    0x077f
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION21_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION22_CTRL0    0x0780
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION22_CTRL1    0x0781
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION22_CTRL2    0x0782
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION22_CTRL3    0x0783
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION22_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION23_CTRL0    0x0784
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION23_CTRL1    0x0785
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION23_CTRL2    0x0786
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION23_CTRL3    0x0787
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION23_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION24_CTRL0    0x0788
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION24_CTRL1    0x0789
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION24_CTRL2    0x078a
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION24_CTRL3    0x078b
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION24_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION25_CTRL0    0x078c
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION25_CTRL1    0x078d
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION25_CTRL2    0x078e
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION25_CTRL3    0x078f
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION25_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION26_CTRL0    0x0790
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION26_CTRL1    0x0791
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION26_CTRL2    0x0792
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION26_CTRL3    0x0793
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION26_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION27_CTRL0    0x0794
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION27_CTRL1    0x0795
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION27_CTRL2    0x0796
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION27_CTRL3    0x0797
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION27_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION28_CTRL0    0x0798
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION28_CTRL1    0x0799
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION28_CTRL2    0x079a
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION28_CTRL3    0x079b
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION28_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION29_CTRL0    0x079c
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION29_CTRL1    0x079d
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION29_CTRL2    0x079e
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION29_CTRL3    0x079f
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION29_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION30_CTRL0    0x07a0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION30_CTRL1    0x07a1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION30_CTRL2    0x07a2
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION30_CTRL3    0x07a3
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION30_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION31_CTRL0    0x07a4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL0_MBR_EXT_OFFSET    8
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL0_MBR_EXT_MASK    0x700
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL0_MBR_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL0_MBR_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION31_CTRL1    0x07a5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL1_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION31_CTRL2    0x07a6
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL2_METERIDX_EXT_OFFSET    10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL2_METERIDX_EXT_MASK    0x400
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL2_METERIDX_OFFSET    5
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL2_METERIDX_MASK    0x3E0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL2_ENVLANPOL_OFFSET    4
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL2_ENVLANPOL_MASK    0x10
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL2_VBPRI_OFFSET    1
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL2_VBPRI_MASK    0xE
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL2_VBPEN_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL2_VBPEN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_MEMBER_CONFIGURATION31_CTRL3    0x07a7
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_MEMBER_CONFIGURATION31_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_VLAN_CTRL    0x07a8
+#define    RTL8367C_VLAN_CTRL_OFFSET    0
+#define    RTL8367C_VLAN_CTRL_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_INGRESS    0x07a9
+#define    RTL8367C_VLAN_INGRESS_OFFSET    0
+#define    RTL8367C_VLAN_INGRESS_MASK    0x7FF
+
+#define    RTL8367C_REG_VLAN_ACCEPT_FRAME_TYPE_CTRL0    0x07aa
+#define    RTL8367C_PORT7_FRAME_TYPE_OFFSET    14
+#define    RTL8367C_PORT7_FRAME_TYPE_MASK    0xC000
+#define    RTL8367C_PORT6_FRAME_TYPE_OFFSET    12
+#define    RTL8367C_PORT6_FRAME_TYPE_MASK    0x3000
+#define    RTL8367C_PORT5_FRAME_TYPE_OFFSET    10
+#define    RTL8367C_PORT5_FRAME_TYPE_MASK    0xC00
+#define    RTL8367C_PORT4_FRAME_TYPE_OFFSET    8
+#define    RTL8367C_PORT4_FRAME_TYPE_MASK    0x300
+#define    RTL8367C_PORT3_FRAME_TYPE_OFFSET    6
+#define    RTL8367C_PORT3_FRAME_TYPE_MASK    0xC0
+#define    RTL8367C_PORT2_FRAME_TYPE_OFFSET    4
+#define    RTL8367C_PORT2_FRAME_TYPE_MASK    0x30
+#define    RTL8367C_PORT1_FRAME_TYPE_OFFSET    2
+#define    RTL8367C_PORT1_FRAME_TYPE_MASK    0xC
+#define    RTL8367C_PORT0_FRAME_TYPE_OFFSET    0
+#define    RTL8367C_PORT0_FRAME_TYPE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_ACCEPT_FRAME_TYPE_CTRL1    0x07ab
+#define    RTL8367C_PORT10_FRAME_TYPE_OFFSET    4
+#define    RTL8367C_PORT10_FRAME_TYPE_MASK    0x30
+#define    RTL8367C_PORT9_FRAME_TYPE_OFFSET    2
+#define    RTL8367C_PORT9_FRAME_TYPE_MASK    0xC
+#define    RTL8367C_PORT8_FRAME_TYPE_OFFSET    0
+#define    RTL8367C_PORT8_FRAME_TYPE_MASK    0x3
+
+#define    RTL8367C_REG_PORT_PBFIDEN    0x07ac
+#define    RTL8367C_PORT_PBFIDEN_OFFSET    0
+#define    RTL8367C_PORT_PBFIDEN_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT0_PBFID    0x07ad
+#define    RTL8367C_PORT0_PBFID_OFFSET    0
+#define    RTL8367C_PORT0_PBFID_MASK    0xF
+
+#define    RTL8367C_REG_PORT1_PBFID    0x07ae
+#define    RTL8367C_PORT1_PBFID_OFFSET    0
+#define    RTL8367C_PORT1_PBFID_MASK    0xF
+
+#define    RTL8367C_REG_PORT2_PBFID    0x07af
+#define    RTL8367C_PORT2_PBFID_OFFSET    0
+#define    RTL8367C_PORT2_PBFID_MASK    0xF
+
+#define    RTL8367C_REG_PORT3_PBFID    0x07b0
+#define    RTL8367C_PORT3_PBFID_OFFSET    0
+#define    RTL8367C_PORT3_PBFID_MASK    0xF
+
+#define    RTL8367C_REG_PORT4_PBFID    0x07b1
+#define    RTL8367C_PORT4_PBFID_OFFSET    0
+#define    RTL8367C_PORT4_PBFID_MASK    0xF
+
+#define    RTL8367C_REG_PORT5_PBFID    0x07b2
+#define    RTL8367C_PORT5_PBFID_OFFSET    0
+#define    RTL8367C_PORT5_PBFID_MASK    0xF
+
+#define    RTL8367C_REG_PORT6_PBFID    0x07b3
+#define    RTL8367C_PORT6_PBFID_OFFSET    0
+#define    RTL8367C_PORT6_PBFID_MASK    0xF
+
+#define    RTL8367C_REG_PORT7_PBFID    0x07b4
+#define    RTL8367C_PORT7_PBFID_OFFSET    0
+#define    RTL8367C_PORT7_PBFID_MASK    0xF
+
+#define    RTL8367C_REG_VLAN_EXT_CTRL    0x07b5
+#define    RTL8367C_VLAN_1P_REMARK_BYPASS_REALKEEP_OFFSET    2
+#define    RTL8367C_VLAN_1P_REMARK_BYPASS_REALKEEP_MASK    0x4
+#define    RTL8367C_VLAN_VID4095_TYPE_OFFSET    1
+#define    RTL8367C_VLAN_VID4095_TYPE_MASK    0x2
+#define    RTL8367C_VLAN_VID0_TYPE_OFFSET    0
+#define    RTL8367C_VLAN_VID0_TYPE_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_EXT_CTRL2    0x07b6
+#define    RTL8367C_VLAN_EXT_CTRL2_OFFSET    0
+#define    RTL8367C_VLAN_EXT_CTRL2_MASK    0x1
+
+#define    RTL8367C_REG_PORT8_PBFID    0x07b7
+#define    RTL8367C_PORT8_PBFID_OFFSET    0
+#define    RTL8367C_PORT8_PBFID_MASK    0xF
+
+#define    RTL8367C_REG_PORT9_PBFID    0x07b8
+#define    RTL8367C_PORT9_PBFID_OFFSET    0
+#define    RTL8367C_PORT9_PBFID_MASK    0xF
+
+#define    RTL8367C_REG_PORT10_PBFID    0x07b9
+#define    RTL8367C_PORT10_PBFID_OFFSET    0
+#define    RTL8367C_PORT10_PBFID_MASK    0xF
+
+#define    RTL8367C_REG_CVLAN_DUMMY00    0x07E0
+
+#define    RTL8367C_REG_CVLAN_DUMMY01    0x07E1
+
+#define    RTL8367C_REG_CVLAN_DUMMY02    0x07E2
+
+#define    RTL8367C_REG_CVLAN_DUMMY03    0x07E3
+
+#define    RTL8367C_REG_CVLAN_DUMMY04    0x07E4
+
+#define    RTL8367C_REG_CVLAN_DUMMY05    0x07E5
+
+#define    RTL8367C_REG_CVLAN_DUMMY06    0x07E6
+
+#define    RTL8367C_REG_CVLAN_DUMMY07    0x07E7
+
+#define    RTL8367C_REG_CVLAN_DUMMY08    0x07E8
+
+#define    RTL8367C_REG_CVLAN_DUMMY09    0x07E9
+
+#define    RTL8367C_REG_CVLAN_DUMMY10    0x07EA
+
+#define    RTL8367C_REG_CVLAN_DUMMY11    0x07EB
+
+#define    RTL8367C_REG_CVLAN_DUMMY12    0x07EC
+
+#define    RTL8367C_REG_CVLAN_DUMMY13    0x07ED
+
+#define    RTL8367C_REG_CVLAN_DUMMY14    0x07EE
+
+#define    RTL8367C_REG_CVLAN_DUMMY15    0x07EF
+
+/* (16'h0800)dpm_reg */
+
+#define    RTL8367C_REG_RMA_CTRL00    0x0800
+#define    RTL8367C_RMA_CTRL00_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL00_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL00_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL00_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_TRAP_PRIORITY_OFFSET    3
+#define    RTL8367C_TRAP_PRIORITY_MASK    0x38
+#define    RTL8367C_RMA_CTRL00_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL00_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL00_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL00_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL00_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL00_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL01    0x0801
+#define    RTL8367C_RMA_CTRL01_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL01_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL01_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL01_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL01_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL01_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL01_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL01_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL01_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL01_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL02    0x0802
+#define    RTL8367C_RMA_CTRL02_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL02_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL02_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL02_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL02_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL02_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL02_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL02_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL02_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL02_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL03    0x0803
+#define    RTL8367C_RMA_CTRL03_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL03_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL03_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL03_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL03_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL03_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL03_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL03_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL03_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL03_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL04    0x0804
+#define    RTL8367C_RMA_CTRL04_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL04_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL04_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL04_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL04_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL04_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL04_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL04_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL04_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL04_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL08    0x0808
+#define    RTL8367C_RMA_CTRL08_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL08_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL08_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL08_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL08_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL08_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL08_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL08_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL08_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL08_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL0D    0x080d
+#define    RTL8367C_RMA_CTRL0D_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL0D_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL0D_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL0D_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL0D_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL0D_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL0D_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL0D_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL0D_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL0D_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL0E    0x080e
+#define    RTL8367C_RMA_CTRL0E_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL0E_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL0E_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL0E_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL0E_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL0E_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL0E_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL0E_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL0E_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL0E_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL10    0x0810
+#define    RTL8367C_RMA_CTRL10_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL10_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL10_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL10_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL10_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL10_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL10_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL10_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL10_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL10_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL11    0x0811
+#define    RTL8367C_RMA_CTRL11_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL11_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL11_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL11_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL11_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL11_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL11_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL11_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL11_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL11_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL12    0x0812
+#define    RTL8367C_RMA_CTRL12_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL12_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL12_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL12_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL12_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL12_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL12_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL12_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL12_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL12_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL13    0x0813
+#define    RTL8367C_RMA_CTRL13_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL13_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL13_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL13_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL13_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL13_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL13_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL13_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL13_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL13_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL18    0x0818
+#define    RTL8367C_RMA_CTRL18_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL18_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL18_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL18_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL18_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL18_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL18_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL18_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL18_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL18_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL1A    0x081a
+#define    RTL8367C_RMA_CTRL1A_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL1A_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL1A_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL1A_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL1A_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL1A_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL1A_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL1A_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL1A_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL1A_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL20    0x0820
+#define    RTL8367C_RMA_CTRL20_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL20_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL20_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL20_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL20_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL20_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL20_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL20_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL20_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL20_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL21    0x0821
+#define    RTL8367C_RMA_CTRL21_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL21_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL21_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL21_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL21_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL21_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL21_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL21_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL21_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL21_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL22    0x0822
+#define    RTL8367C_RMA_CTRL22_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL22_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL22_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL22_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL22_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL22_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL22_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL22_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL22_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL22_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL_CDP    0x0830
+#define    RTL8367C_RMA_CTRL_CDP_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL_CDP_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL_CDP_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL_CDP_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL_CDP_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL_CDP_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL_CDP_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL_CDP_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL_CDP_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL_CDP_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL_CSSTP    0x0831
+#define    RTL8367C_RMA_CTRL_CSSTP_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL_CSSTP_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL_CSSTP_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL_CSSTP_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL_CSSTP_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL_CSSTP_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL_CSSTP_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL_CSSTP_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL_CSSTP_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL_CSSTP_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_CTRL_LLDP    0x0832
+#define    RTL8367C_RMA_CTRL_LLDP_OPERATION_OFFSET    7
+#define    RTL8367C_RMA_CTRL_LLDP_OPERATION_MASK    0x180
+#define    RTL8367C_RMA_CTRL_LLDP_DISCARD_STORM_FILTER_OFFSET    6
+#define    RTL8367C_RMA_CTRL_LLDP_DISCARD_STORM_FILTER_MASK    0x40
+#define    RTL8367C_RMA_CTRL_LLDP_KEEP_FORMAT_OFFSET    2
+#define    RTL8367C_RMA_CTRL_LLDP_KEEP_FORMAT_MASK    0x4
+#define    RTL8367C_RMA_CTRL_LLDP_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_RMA_CTRL_LLDP_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_RMA_CTRL_LLDP_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_RMA_CTRL_LLDP_PORTISO_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_RMA_LLDP_EN    0x0833
+#define    RTL8367C_RMA_LLDP_EN_OFFSET    0
+#define    RTL8367C_RMA_LLDP_EN_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_PORTBASED_PRIORITY_CTRL0    0x0851
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL0_PORT3_PRIORITY_OFFSET    12
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL0_PORT3_PRIORITY_MASK    0x7000
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL0_PORT2_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL0_PORT2_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL0_PORT1_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL0_PORT1_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL0_PORT0_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL0_PORT0_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PORTBASED_PRIORITY_CTRL1    0x0852
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL1_PORT7_PRIORITY_OFFSET    12
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL1_PORT7_PRIORITY_MASK    0x7000
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL1_PORT6_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL1_PORT6_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL1_PORT5_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL1_PORT5_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL1_PORT4_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL1_PORT4_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PORTBASED_PRIORITY_CTRL2    0x0853
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL2_PORT10_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL2_PORT10_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL2_PORT9_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL2_PORT9_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL2_PORT8_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PORTBASED_PRIORITY_CTRL2_PORT8_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM0_CTRL0    0x0855
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL0_PORT3_PRIORITY_OFFSET    12
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL0_PORT3_PRIORITY_MASK    0x7000
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL0_PORT2_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL0_PORT2_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL0_PORT1_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL0_PORT1_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL0_PORT0_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL0_PORT0_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM0_CTRL1    0x0856
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL1_PORT7_PRIORITY_OFFSET    12
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL1_PORT7_PRIORITY_MASK    0x7000
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL1_PORT6_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL1_PORT6_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL1_PORT5_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL1_PORT5_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL1_PORT4_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL1_PORT4_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM0_CTRL2    0x0857
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL2_PORT10_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL2_PORT10_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL2_PORT9_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL2_PORT9_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL2_PORT8_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM0_CTRL2_PORT8_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM1_CTRL0    0x0859
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL0_PORT3_PRIORITY_OFFSET    12
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL0_PORT3_PRIORITY_MASK    0x7000
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL0_PORT2_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL0_PORT2_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL0_PORT1_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL0_PORT1_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL0_PORT0_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL0_PORT0_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM1_CTRL1    0x085a
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL1_PORT7_PRIORITY_OFFSET    12
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL1_PORT7_PRIORITY_MASK    0x7000
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL1_PORT6_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL1_PORT6_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL1_PORT5_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL1_PORT5_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL1_PORT4_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL1_PORT4_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM1_CTRL2    0x085b
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL2_PORT10_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL2_PORT10_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL2_PORT9_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL2_PORT9_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL2_PORT8_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM1_CTRL2_PORT8_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM2_CTRL0    0x085d
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL0_PORT3_PRIORITY_OFFSET    12
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL0_PORT3_PRIORITY_MASK    0x7000
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL0_PORT2_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL0_PORT2_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL0_PORT1_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL0_PORT1_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL0_PORT0_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL0_PORT0_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM2_CTRL1    0x085e
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL1_PORT7_PRIORITY_OFFSET    12
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL1_PORT7_PRIORITY_MASK    0x7000
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL1_PORT6_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL1_PORT6_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL1_PORT5_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL1_PORT5_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL1_PORT4_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL1_PORT4_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM2_CTRL2    0x085f
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL2_PORT10_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL2_PORT10_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL2_PORT9_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL2_PORT9_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL2_PORT8_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM2_CTRL2_PORT8_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM3_CTRL0    0x0861
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL0_PORT3_PRIORITY_OFFSET    12
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL0_PORT3_PRIORITY_MASK    0x7000
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL0_PORT2_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL0_PORT2_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL0_PORT1_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL0_PORT1_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL0_PORT0_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL0_PORT0_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM3_CTRL1    0x0862
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL1_PORT7_PRIORITY_OFFSET    12
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL1_PORT7_PRIORITY_MASK    0x7000
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL1_PORT6_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL1_PORT6_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL1_PORT5_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL1_PORT5_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL1_PORT4_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL1_PORT4_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_PPB_PRIORITY_ITEM3_CTRL2    0x0863
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL2_PORT10_PRIORITY_OFFSET    8
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL2_PORT10_PRIORITY_MASK    0x700
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL2_PORT9_PRIORITY_OFFSET    4
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL2_PORT9_PRIORITY_MASK    0x70
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL2_PORT8_PRIORITY_OFFSET    0
+#define    RTL8367C_VLAN_PPB_PRIORITY_ITEM3_CTRL2_PORT8_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_1Q_PRIORITY_REMAPPING_CTRL0    0x0865
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL0_PRIORITY3_OFFSET    12
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL0_PRIORITY3_MASK    0x7000
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL0_PRIORITY2_OFFSET    8
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL0_PRIORITY2_MASK    0x700
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL0_PRIORITY1_OFFSET    4
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL0_PRIORITY1_MASK    0x70
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL0_PRIORITY0_OFFSET    0
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL0_PRIORITY0_MASK    0x7
+
+#define    RTL8367C_REG_QOS_1Q_PRIORITY_REMAPPING_CTRL1    0x0866
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL1_PRIORITY7_OFFSET    12
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL1_PRIORITY7_MASK    0x7000
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL1_PRIORITY6_OFFSET    8
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL1_PRIORITY6_MASK    0x700
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL1_PRIORITY5_OFFSET    4
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL1_PRIORITY5_MASK    0x70
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL1_PRIORITY4_OFFSET    0
+#define    RTL8367C_QOS_1Q_PRIORITY_REMAPPING_CTRL1_PRIORITY4_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL0    0x0867
+#define    RTL8367C_DSCP3_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP3_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP2_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP2_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP1_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP1_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP0_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP0_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL1    0x0868
+#define    RTL8367C_DSCP7_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP7_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP6_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP6_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP5_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP5_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP4_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP4_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL2    0x0869
+#define    RTL8367C_DSCP11_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP11_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP10_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP10_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP9_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP9_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP8_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP8_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL3    0x086a
+#define    RTL8367C_DSCP15_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP15_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP14_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP14_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP13_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP13_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP12_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP12_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL4    0x086b
+#define    RTL8367C_DSCP19_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP19_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP18_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP18_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP17_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP17_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP16_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP16_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL5    0x086c
+#define    RTL8367C_DSCP23_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP23_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP22_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP22_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP21_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP21_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP20_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP20_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL6    0x086d
+#define    RTL8367C_DSCP27_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP27_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP26_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP26_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP25_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP25_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP24_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP24_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL7    0x086e
+#define    RTL8367C_DSCP31_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP31_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP30_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP30_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP29_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP29_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP28_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP28_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL8    0x086f
+#define    RTL8367C_DSCP35_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP35_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP34_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP34_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP33_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP33_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP32_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP32_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL9    0x0870
+#define    RTL8367C_DSCP39_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP39_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP38_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP38_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP37_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP37_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP36_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP36_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL10    0x0871
+#define    RTL8367C_DSCP43_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP43_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP42_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP42_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP41_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP41_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP40_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP40_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL11    0x0872
+#define    RTL8367C_DSCP47_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP47_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP46_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP46_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP45_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP45_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP44_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP44_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL12    0x0873
+#define    RTL8367C_DSCP51_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP51_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP50_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP50_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP49_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP49_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP48_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP48_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL13    0x0874
+#define    RTL8367C_DSCP55_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP55_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP54_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP54_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP53_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP53_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP52_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP52_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL14    0x0875
+#define    RTL8367C_DSCP59_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP59_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP58_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP58_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP57_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP57_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP56_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP56_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_DSCP_TO_PRIORITY_CTRL15    0x0876
+#define    RTL8367C_DSCP63_PRIORITY_OFFSET    12
+#define    RTL8367C_DSCP63_PRIORITY_MASK    0x7000
+#define    RTL8367C_DSCP62_PRIORITY_OFFSET    8
+#define    RTL8367C_DSCP62_PRIORITY_MASK    0x700
+#define    RTL8367C_DSCP61_PRIORITY_OFFSET    4
+#define    RTL8367C_DSCP61_PRIORITY_MASK    0x70
+#define    RTL8367C_DSCP60_PRIORITY_OFFSET    0
+#define    RTL8367C_DSCP60_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_PORTBASED_PRIORITY_CTRL0    0x0877
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL0_PORT3_PRIORITY_OFFSET    12
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL0_PORT3_PRIORITY_MASK    0x7000
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL0_PORT2_PRIORITY_OFFSET    8
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL0_PORT2_PRIORITY_MASK    0x700
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL0_PORT1_PRIORITY_OFFSET    4
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL0_PORT1_PRIORITY_MASK    0x70
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL0_PORT0_PRIORITY_OFFSET    0
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL0_PORT0_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_PORTBASED_PRIORITY_CTRL1    0x0878
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL1_PORT7_PRIORITY_OFFSET    12
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL1_PORT7_PRIORITY_MASK    0x7000
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL1_PORT6_PRIORITY_OFFSET    8
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL1_PORT6_PRIORITY_MASK    0x700
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL1_PORT5_PRIORITY_OFFSET    4
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL1_PORT5_PRIORITY_MASK    0x70
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL1_PORT4_PRIORITY_OFFSET    0
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL1_PORT4_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_DUMMY0879    0x0879
+#define    RTL8367C_DUMMY0879_OFFSET    0
+#define    RTL8367C_DUMMY0879_MASK    0x1
+
+#define    RTL8367C_REG_QOS_PORTBASED_PRIORITY_CTRL2    0x087a
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL2_PORT10_PRIORITY_OFFSET    8
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL2_PORT10_PRIORITY_MASK    0x700
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL2_PORT9_PRIORITY_OFFSET    4
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL2_PORT9_PRIORITY_MASK    0x70
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL2_PORT8_PRIORITY_OFFSET    0
+#define    RTL8367C_QOS_PORTBASED_PRIORITY_CTRL2_PORT8_PRIORITY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION_CTRL0    0x087b
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL0_QOS_ACL_WEIGHT_OFFSET    8
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL0_QOS_ACL_WEIGHT_MASK    0xFF00
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL0_QOS_PORT_WEIGHT_OFFSET    0
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL0_QOS_PORT_WEIGHT_MASK    0xFF
+
+#define    RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION_CTRL1    0x087c
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL1_QOS_DOT1Q_WEIGHT_OFFSET    8
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL1_QOS_DOT1Q_WEIGHT_MASK    0xFF00
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL1_QOS_DSCP_WEIGHT_OFFSET    0
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL1_QOS_DSCP_WEIGHT_MASK    0xFF
+
+#define    RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION_CTRL2    0x087d
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL2_QOS_CVLAN_WEIGHT_OFFSET    8
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL2_QOS_CVLAN_WEIGHT_MASK    0xFF00
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL2_QOS_SVLAN_WEIGHT_OFFSET    0
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL2_QOS_SVLAN_WEIGHT_MASK    0xFF
+
+#define    RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION_CTRL3    0x087e
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL3_QOS_SA_WEIGHT_OFFSET    8
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL3_QOS_SA_WEIGHT_MASK    0xFF00
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL3_QOS_LUTFWD_WEIGHT_OFFSET    0
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_CTRL3_QOS_LUTFWD_WEIGHT_MASK    0xFF
+
+#define    RTL8367C_REG_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL0    0x087f
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL0_PRIORITY3_OFFSET    12
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL0_PRIORITY3_MASK    0x7000
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL0_PRIORITY2_OFFSET    8
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL0_PRIORITY2_MASK    0x700
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL0_PRIORITY1_OFFSET    4
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL0_PRIORITY1_MASK    0x70
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL0_PRIORITY0_OFFSET    0
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL0_PRIORITY0_MASK    0x7
+
+#define    RTL8367C_REG_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL1    0x0880
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL1_PRIORITY7_OFFSET    12
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL1_PRIORITY7_MASK    0x7000
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL1_PRIORITY6_OFFSET    8
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL1_PRIORITY6_MASK    0x700
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL1_PRIORITY5_OFFSET    4
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL1_PRIORITY5_MASK    0x70
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL1_PRIORITY4_OFFSET    0
+#define    RTL8367C_QOS_PRIORITY_REMAPPING_IN_CPU_CTRL1_PRIORITY4_MASK    0x7
+
+#define    RTL8367C_REG_QOS_TRAP_PRIORITY0    0x0881
+#define    RTL8367C_UNKNOWN_MC_PRIORTY_OFFSET    12
+#define    RTL8367C_UNKNOWN_MC_PRIORTY_MASK    0x7000
+#define    RTL8367C_SVLAN_PRIOIRTY_OFFSET    8
+#define    RTL8367C_SVLAN_PRIOIRTY_MASK    0x700
+#define    RTL8367C_OAM_PRIOIRTY_OFFSET    4
+#define    RTL8367C_OAM_PRIOIRTY_MASK    0x70
+#define    RTL8367C_DOT1X_PRIORTY_OFFSET    0
+#define    RTL8367C_DOT1X_PRIORTY_MASK    0x7
+
+#define    RTL8367C_REG_QOS_TRAP_PRIORITY1    0x0882
+#define    RTL8367C_DW8051_TRAP_PRI_OFFSET    4
+#define    RTL8367C_DW8051_TRAP_PRI_MASK    0x70
+#define    RTL8367C_EEELLDP_TRAP_PRI_OFFSET    0
+#define    RTL8367C_EEELLDP_TRAP_PRI_MASK    0x7
+
+#define    RTL8367C_REG_MAX_LENGTH_CFG    0x0883
+#define    RTL8367C_MAX_LENGTH_GIGA_OFFSET    8
+#define    RTL8367C_MAX_LENGTH_GIGA_MASK    0xFF00
+#define    RTL8367C_MAX_LENGTH_10_100M_OFFSET    0
+#define    RTL8367C_MAX_LENGTH_10_100M_MASK    0xFF
+
+#define    RTL8367C_REG_MAX_LEN_RX_TX    0x0884
+#define    RTL8367C_MAX_LEN_RX_TX_OFFSET    0
+#define    RTL8367C_MAX_LEN_RX_TX_MASK    0x3
+
+#define    RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION2_CTRL0    0x0885
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL0_QOS_ACL_WEIGHT_OFFSET    8
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL0_QOS_ACL_WEIGHT_MASK    0xFF00
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL0_QOS_PORT_WEIGHT_OFFSET    0
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL0_QOS_PORT_WEIGHT_MASK    0xFF
+
+#define    RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION2_CTRL1    0x0886
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL1_QOS_DOT1Q_WEIGHT_OFFSET    8
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL1_QOS_DOT1Q_WEIGHT_MASK    0xFF00
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL1_QOS_DSCP_WEIGHT_OFFSET    0
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL1_QOS_DSCP_WEIGHT_MASK    0xFF
+
+#define    RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION2_CTRL2    0x0887
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL2_QOS_CVLAN_WEIGHT_OFFSET    8
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL2_QOS_CVLAN_WEIGHT_MASK    0xFF00
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL2_QOS_SVLAN_WEIGHT_OFFSET    0
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL2_QOS_SVLAN_WEIGHT_MASK    0xFF
+
+#define    RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION2_CTRL3    0x0888
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL3_QOS_SA_WEIGHT_OFFSET    8
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL3_QOS_SA_WEIGHT_MASK    0xFF00
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL3_QOS_LUTFWD_WEIGHT_OFFSET    0
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_CTRL3_QOS_LUTFWD_WEIGHT_MASK    0xFF
+
+#define    RTL8367C_REG_QOS_INTERNAL_PRIORITY_DECISION_IDX    0x0889
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_IDX_OFFSET    0
+#define    RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_IDX_MASK    0x7FF
+
+#define    RTL8367C_REG_MAX_LENGTH_CFG_EXT    0x088a
+#define    RTL8367C_MAX_LENGTH_GIGA_EXT_OFFSET    3
+#define    RTL8367C_MAX_LENGTH_GIGA_EXT_MASK    0x38
+#define    RTL8367C_MAX_LENGTH_10_100M_EXT_OFFSET    0
+#define    RTL8367C_MAX_LENGTH_10_100M_EXT_MASK    0x7
+
+#define    RTL8367C_REG_MAX_LEN_RX_TX_CFG0    0x088c
+#define    RTL8367C_MAX_LEN_RX_TX_CFG0_OFFSET    0
+#define    RTL8367C_MAX_LEN_RX_TX_CFG0_MASK    0x3FFF
+
+#define    RTL8367C_REG_MAX_LEN_RX_TX_CFG1    0x088d
+#define    RTL8367C_MAX_LEN_RX_TX_CFG1_OFFSET    0
+#define    RTL8367C_MAX_LEN_RX_TX_CFG1_MASK    0x3FFF
+
+#define    RTL8367C_REG_UNDA_FLOODING_PMSK    0x0890
+#define    RTL8367C_UNDA_FLOODING_PMSK_OFFSET    0
+#define    RTL8367C_UNDA_FLOODING_PMSK_MASK    0x7FF
+
+#define    RTL8367C_REG_UNMCAST_FLOADING_PMSK    0x0891
+#define    RTL8367C_UNMCAST_FLOADING_PMSK_OFFSET    0
+#define    RTL8367C_UNMCAST_FLOADING_PMSK_MASK    0x7FF
+
+#define    RTL8367C_REG_BCAST_FLOADING_PMSK    0x0892
+#define    RTL8367C_BCAST_FLOADING_PMSK_OFFSET    0
+#define    RTL8367C_BCAST_FLOADING_PMSK_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL2    0x08a0
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH7_OFFSET    14
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH7_MASK    0xC000
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH6_OFFSET    12
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH6_MASK    0x3000
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH5_OFFSET    10
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH5_MASK    0xC00
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH4_OFFSET    8
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH4_MASK    0x300
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH3_OFFSET    6
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH3_MASK    0xC0
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH2_OFFSET    4
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH2_MASK    0x30
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH1_OFFSET    2
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH1_MASK    0xC
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH0_OFFSET    0
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH0_MASK    0x3
+
+#define    RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL3    0x08a1
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH15_OFFSET    14
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH15_MASK    0xC000
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH14_OFFSET    12
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH14_MASK    0x3000
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH13_OFFSET    10
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH13_MASK    0xC00
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH12_OFFSET    8
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH12_MASK    0x300
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH11_OFFSET    6
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH11_MASK    0xC0
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH10_OFFSET    4
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH10_MASK    0x30
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH9_OFFSET    2
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH9_MASK    0xC
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH8_OFFSET    0
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH8_MASK    0x3
+
+#define    RTL8367C_REG_PORT_ISOLATION_PORT0_MASK    0x08a2
+#define    RTL8367C_PORT_ISOLATION_PORT0_MASK_OFFSET    0
+#define    RTL8367C_PORT_ISOLATION_PORT0_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_ISOLATION_PORT1_MASK    0x08a3
+#define    RTL8367C_PORT_ISOLATION_PORT1_MASK_OFFSET    0
+#define    RTL8367C_PORT_ISOLATION_PORT1_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_ISOLATION_PORT2_MASK    0x08a4
+#define    RTL8367C_PORT_ISOLATION_PORT2_MASK_OFFSET    0
+#define    RTL8367C_PORT_ISOLATION_PORT2_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_ISOLATION_PORT3_MASK    0x08a5
+#define    RTL8367C_PORT_ISOLATION_PORT3_MASK_OFFSET    0
+#define    RTL8367C_PORT_ISOLATION_PORT3_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_ISOLATION_PORT4_MASK    0x08a6
+#define    RTL8367C_PORT_ISOLATION_PORT4_MASK_OFFSET    0
+#define    RTL8367C_PORT_ISOLATION_PORT4_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_ISOLATION_PORT5_MASK    0x08a7
+#define    RTL8367C_PORT_ISOLATION_PORT5_MASK_OFFSET    0
+#define    RTL8367C_PORT_ISOLATION_PORT5_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_ISOLATION_PORT6_MASK    0x08a8
+#define    RTL8367C_PORT_ISOLATION_PORT6_MASK_OFFSET    0
+#define    RTL8367C_PORT_ISOLATION_PORT6_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_ISOLATION_PORT7_MASK    0x08a9
+#define    RTL8367C_PORT_ISOLATION_PORT7_MASK_OFFSET    0
+#define    RTL8367C_PORT_ISOLATION_PORT7_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_ISOLATION_PORT8_MASK    0x08aa
+#define    RTL8367C_PORT_ISOLATION_PORT8_MASK_OFFSET    0
+#define    RTL8367C_PORT_ISOLATION_PORT8_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_ISOLATION_PORT9_MASK    0x08ab
+#define    RTL8367C_PORT_ISOLATION_PORT9_MASK_OFFSET    0
+#define    RTL8367C_PORT_ISOLATION_PORT9_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_ISOLATION_PORT10_MASK    0x08ac
+#define    RTL8367C_PORT_ISOLATION_PORT10_MASK_OFFSET    0
+#define    RTL8367C_PORT_ISOLATION_PORT10_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_CTRL    0x08b4
+#define    RTL8367C_FORCE_CTRL_OFFSET    0
+#define    RTL8367C_FORCE_CTRL_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_PORT0_MASK    0x08b5
+#define    RTL8367C_FORCE_PORT0_MASK_OFFSET    0
+#define    RTL8367C_FORCE_PORT0_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_PORT1_MASK    0x08b6
+#define    RTL8367C_FORCE_PORT1_MASK_OFFSET    0
+#define    RTL8367C_FORCE_PORT1_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_PORT2_MASK    0x08b7
+#define    RTL8367C_FORCE_PORT2_MASK_OFFSET    0
+#define    RTL8367C_FORCE_PORT2_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_PORT3_MASK    0x08b8
+#define    RTL8367C_FORCE_PORT3_MASK_OFFSET    0
+#define    RTL8367C_FORCE_PORT3_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_PORT4_MASK    0x08b9
+#define    RTL8367C_FORCE_PORT4_MASK_OFFSET    0
+#define    RTL8367C_FORCE_PORT4_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_PORT5_MASK    0x08ba
+#define    RTL8367C_FORCE_PORT5_MASK_OFFSET    0
+#define    RTL8367C_FORCE_PORT5_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_PORT6_MASK    0x08bb
+#define    RTL8367C_FORCE_PORT6_MASK_OFFSET    0
+#define    RTL8367C_FORCE_PORT6_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_PORT7_MASK    0x08bc
+#define    RTL8367C_FORCE_PORT7_MASK_OFFSET    0
+#define    RTL8367C_FORCE_PORT7_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_PORT8_MASK    0x08bd
+#define    RTL8367C_FORCE_PORT8_MASK_OFFSET    0
+#define    RTL8367C_FORCE_PORT8_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_PORT9_MASK    0x08be
+#define    RTL8367C_FORCE_PORT9_MASK_OFFSET    0
+#define    RTL8367C_FORCE_PORT9_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_FORCE_PORT10_MASK    0x08bf
+#define    RTL8367C_FORCE_PORT10_MASK_OFFSET    0
+#define    RTL8367C_FORCE_PORT10_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_SOURCE_PORT_PERMIT    0x08c5
+#define    RTL8367C_SOURCE_PORT_PERMIT_OFFSET    0
+#define    RTL8367C_SOURCE_PORT_PERMIT_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMCAST_VLAN_LEAKY    0x08c6
+#define    RTL8367C_IPMCAST_VLAN_LEAKY_OFFSET    0
+#define    RTL8367C_IPMCAST_VLAN_LEAKY_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMCAST_PORTISO_LEAKY    0x08c7
+#define    RTL8367C_IPMCAST_PORTISO_LEAKY_OFFSET    0
+#define    RTL8367C_IPMCAST_PORTISO_LEAKY_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_SECURITY_CTRL    0x08c8
+#define    RTL8367C_UNKNOWN_UNICAST_DA_BEHAVE_OFFSET    6
+#define    RTL8367C_UNKNOWN_UNICAST_DA_BEHAVE_MASK    0xC0
+#define    RTL8367C_LUT_LEARN_OVER_ACT_OFFSET    4
+#define    RTL8367C_LUT_LEARN_OVER_ACT_MASK    0x30
+#define    RTL8367C_UNMATCHED_SA_BEHAVE_OFFSET    2
+#define    RTL8367C_UNMATCHED_SA_BEHAVE_MASK    0xC
+#define    RTL8367C_UNKNOWN_SA_BEHAVE_OFFSET    0
+#define    RTL8367C_UNKNOWN_SA_BEHAVE_MASK    0x3
+
+#define    RTL8367C_REG_UNKNOWN_IPV4_MULTICAST_CTRL0    0x08c9
+#define    RTL8367C_PORT7_UNKNOWN_IP4_MCAST_OFFSET    14
+#define    RTL8367C_PORT7_UNKNOWN_IP4_MCAST_MASK    0xC000
+#define    RTL8367C_PORT6_UNKNOWN_IP4_MCAST_OFFSET    12
+#define    RTL8367C_PORT6_UNKNOWN_IP4_MCAST_MASK    0x3000
+#define    RTL8367C_PORT5_UNKNOWN_IP4_MCAST_OFFSET    10
+#define    RTL8367C_PORT5_UNKNOWN_IP4_MCAST_MASK    0xC00
+#define    RTL8367C_PORT4_UNKNOWN_IP4_MCAST_OFFSET    8
+#define    RTL8367C_PORT4_UNKNOWN_IP4_MCAST_MASK    0x300
+#define    RTL8367C_PORT3_UNKNOWN_IP4_MCAST_OFFSET    6
+#define    RTL8367C_PORT3_UNKNOWN_IP4_MCAST_MASK    0xC0
+#define    RTL8367C_PORT2_UNKNOWN_IP4_MCAST_OFFSET    4
+#define    RTL8367C_PORT2_UNKNOWN_IP4_MCAST_MASK    0x30
+#define    RTL8367C_PORT1_UNKNOWN_IP4_MCAST_OFFSET    2
+#define    RTL8367C_PORT1_UNKNOWN_IP4_MCAST_MASK    0xC
+#define    RTL8367C_PORT0_UNKNOWN_IP4_MCAST_OFFSET    0
+#define    RTL8367C_PORT0_UNKNOWN_IP4_MCAST_MASK    0x3
+
+#define    RTL8367C_REG_UNKNOWN_IPV4_MULTICAST_CTRL1    0x08ca
+#define    RTL8367C_PORT10_UNKNOWN_IP4_MCAST_OFFSET    4
+#define    RTL8367C_PORT10_UNKNOWN_IP4_MCAST_MASK    0x30
+#define    RTL8367C_PORT9_UNKNOWN_IP4_MCAST_OFFSET    2
+#define    RTL8367C_PORT9_UNKNOWN_IP4_MCAST_MASK    0xC
+#define    RTL8367C_PORT8_UNKNOWN_IP4_MCAST_OFFSET    0
+#define    RTL8367C_PORT8_UNKNOWN_IP4_MCAST_MASK    0x3
+
+#define    RTL8367C_REG_UNKNOWN_IPV6_MULTICAST_CTRL0    0x08cb
+#define    RTL8367C_PORT7_UNKNOWN_IP6_MCAST_OFFSET    14
+#define    RTL8367C_PORT7_UNKNOWN_IP6_MCAST_MASK    0xC000
+#define    RTL8367C_PORT6_UNKNOWN_IP6_MCAST_OFFSET    12
+#define    RTL8367C_PORT6_UNKNOWN_IP6_MCAST_MASK    0x3000
+#define    RTL8367C_PORT5_UNKNOWN_IP6_MCAST_OFFSET    10
+#define    RTL8367C_PORT5_UNKNOWN_IP6_MCAST_MASK    0xC00
+#define    RTL8367C_PORT4_UNKNOWN_IP6_MCAST_OFFSET    8
+#define    RTL8367C_PORT4_UNKNOWN_IP6_MCAST_MASK    0x300
+#define    RTL8367C_PORT3_UNKNOWN_IP6_MCAST_OFFSET    6
+#define    RTL8367C_PORT3_UNKNOWN_IP6_MCAST_MASK    0xC0
+#define    RTL8367C_PORT2_UNKNOWN_IP6_MCAST_OFFSET    4
+#define    RTL8367C_PORT2_UNKNOWN_IP6_MCAST_MASK    0x30
+#define    RTL8367C_PORT1_UNKNOWN_IP6_MCAST_OFFSET    2
+#define    RTL8367C_PORT1_UNKNOWN_IP6_MCAST_MASK    0xC
+#define    RTL8367C_PORT0_UNKNOWN_IP6_MCAST_OFFSET    0
+#define    RTL8367C_PORT0_UNKNOWN_IP6_MCAST_MASK    0x3
+
+#define    RTL8367C_REG_UNKNOWN_IPV6_MULTICAST_CTRL1    0x08cc
+#define    RTL8367C_PORT10_UNKNOWN_IP6_MCAST_OFFSET    4
+#define    RTL8367C_PORT10_UNKNOWN_IP6_MCAST_MASK    0x30
+#define    RTL8367C_PORT9_UNKNOWN_IP6_MCAST_OFFSET    2
+#define    RTL8367C_PORT9_UNKNOWN_IP6_MCAST_MASK    0xC
+#define    RTL8367C_PORT8_UNKNOWN_IP6_MCAST_OFFSET    0
+#define    RTL8367C_PORT8_UNKNOWN_IP6_MCAST_MASK    0x3
+
+#define    RTL8367C_REG_UNKNOWN_L2_MULTICAST_CTRL0    0x08cd
+#define    RTL8367C_PORT7_UNKNOWN_L2_MCAST_OFFSET    14
+#define    RTL8367C_PORT7_UNKNOWN_L2_MCAST_MASK    0xC000
+#define    RTL8367C_PORT6_UNKNOWN_L2_MCAST_OFFSET    12
+#define    RTL8367C_PORT6_UNKNOWN_L2_MCAST_MASK    0x3000
+#define    RTL8367C_PORT5_UNKNOWN_L2_MCAST_OFFSET    10
+#define    RTL8367C_PORT5_UNKNOWN_L2_MCAST_MASK    0xC00
+#define    RTL8367C_PORT4_UNKNOWN_L2_MCAST_OFFSET    8
+#define    RTL8367C_PORT4_UNKNOWN_L2_MCAST_MASK    0x300
+#define    RTL8367C_PORT3_UNKNOWN_L2_MCAST_OFFSET    6
+#define    RTL8367C_PORT3_UNKNOWN_L2_MCAST_MASK    0xC0
+#define    RTL8367C_PORT2_UNKNOWN_L2_MCAST_OFFSET    4
+#define    RTL8367C_PORT2_UNKNOWN_L2_MCAST_MASK    0x30
+#define    RTL8367C_PORT1_UNKNOWN_L2_MCAST_OFFSET    2
+#define    RTL8367C_PORT1_UNKNOWN_L2_MCAST_MASK    0xC
+#define    RTL8367C_PORT0_UNKNOWN_L2_MCAST_OFFSET    0
+#define    RTL8367C_PORT0_UNKNOWN_L2_MCAST_MASK    0x3
+
+#define    RTL8367C_REG_PORT_TRUNK_DROP_CTRL    0x08ce
+#define    RTL8367C_PORT_TRUNK_DROP_CTRL_OFFSET    0
+#define    RTL8367C_PORT_TRUNK_DROP_CTRL_MASK    0x1
+
+#define    RTL8367C_REG_PORT_TRUNK_CTRL    0x08cf
+#define    RTL8367C_PORT_TRUNK_DUMB_OFFSET    8
+#define    RTL8367C_PORT_TRUNK_DUMB_MASK    0x100
+#define    RTL8367C_PORT_TRUNK_FLOOD_OFFSET    7
+#define    RTL8367C_PORT_TRUNK_FLOOD_MASK    0x80
+#define    RTL8367C_DPORT_HASH_OFFSET    6
+#define    RTL8367C_DPORT_HASH_MASK    0x40
+#define    RTL8367C_SPORT_HASH_OFFSET    5
+#define    RTL8367C_SPORT_HASH_MASK    0x20
+#define    RTL8367C_DIP_HASH_OFFSET    4
+#define    RTL8367C_DIP_HASH_MASK    0x10
+#define    RTL8367C_SIP_HASH_OFFSET    3
+#define    RTL8367C_SIP_HASH_MASK    0x8
+#define    RTL8367C_DMAC_HASH_OFFSET    2
+#define    RTL8367C_DMAC_HASH_MASK    0x4
+#define    RTL8367C_SMAC_HASH_OFFSET    1
+#define    RTL8367C_SMAC_HASH_MASK    0x2
+#define    RTL8367C_SPA_HASH_OFFSET    0
+#define    RTL8367C_SPA_HASH_MASK    0x1
+
+#define    RTL8367C_REG_PORT_TRUNK_GROUP_MASK    0x08d0
+#define    RTL8367C_PORT_TRUNK_GROUP2_MASK_OFFSET    8
+#define    RTL8367C_PORT_TRUNK_GROUP2_MASK_MASK    0x300
+#define    RTL8367C_PORT_TRUNK_GROUP1_MASK_OFFSET    4
+#define    RTL8367C_PORT_TRUNK_GROUP1_MASK_MASK    0xF0
+#define    RTL8367C_PORT_TRUNK_GROUP0_MASK_OFFSET    0
+#define    RTL8367C_PORT_TRUNK_GROUP0_MASK_MASK    0xF
+
+#define    RTL8367C_REG_PORT_TRUNK_FLOWCTRL    0x08d1
+#define    RTL8367C_EN_FLOWCTRL_TG2_OFFSET    2
+#define    RTL8367C_EN_FLOWCTRL_TG2_MASK    0x4
+#define    RTL8367C_EN_FLOWCTRL_TG1_OFFSET    1
+#define    RTL8367C_EN_FLOWCTRL_TG1_MASK    0x2
+#define    RTL8367C_EN_FLOWCTRL_TG0_OFFSET    0
+#define    RTL8367C_EN_FLOWCTRL_TG0_MASK    0x1
+
+#define    RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL0    0x08d2
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH7_OFFSET    14
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH7_MASK    0xC000
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH6_OFFSET    12
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH6_MASK    0x3000
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH5_OFFSET    10
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH5_MASK    0xC00
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH4_OFFSET    8
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH4_MASK    0x300
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH3_OFFSET    6
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH3_MASK    0xC0
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH2_OFFSET    4
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH2_MASK    0x30
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH1_OFFSET    2
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH1_MASK    0xC
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH0_OFFSET    0
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH0_MASK    0x3
+
+#define    RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL1    0x08d3
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH15_OFFSET    14
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH15_MASK    0xC000
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH14_OFFSET    12
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH14_MASK    0x3000
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH13_OFFSET    10
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH13_MASK    0xC00
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH12_OFFSET    8
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH12_MASK    0x300
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH11_OFFSET    6
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH11_MASK    0xC0
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH10_OFFSET    4
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH10_MASK    0x30
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH9_OFFSET    2
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH9_MASK    0xC
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH8_OFFSET    0
+#define    RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH8_MASK    0x3
+
+#define    RTL8367C_REG_DOS_CFG    0x08d4
+#define    RTL8367C_DROP_ICMPFRAGMENT_OFFSET    9
+#define    RTL8367C_DROP_ICMPFRAGMENT_MASK    0x200
+#define    RTL8367C_DROP_TCPFRAGERROR_OFFSET    8
+#define    RTL8367C_DROP_TCPFRAGERROR_MASK    0x100
+#define    RTL8367C_DROP_TCPSHORTHDR_OFFSET    7
+#define    RTL8367C_DROP_TCPSHORTHDR_MASK    0x80
+#define    RTL8367C_DROP_SYN1024_OFFSET    6
+#define    RTL8367C_DROP_SYN1024_MASK    0x40
+#define    RTL8367C_DROP_NULLSCAN_OFFSET    5
+#define    RTL8367C_DROP_NULLSCAN_MASK    0x20
+#define    RTL8367C_DROP_XMASCAN_OFFSET    4
+#define    RTL8367C_DROP_XMASCAN_MASK    0x10
+#define    RTL8367C_DROP_SYNFINSCAN_OFFSET    3
+#define    RTL8367C_DROP_SYNFINSCAN_MASK    0x8
+#define    RTL8367C_DROP_BLATATTACKS_OFFSET    2
+#define    RTL8367C_DROP_BLATATTACKS_MASK    0x4
+#define    RTL8367C_DROP_LANDATTACKS_OFFSET    1
+#define    RTL8367C_DROP_LANDATTACKS_MASK    0x2
+#define    RTL8367C_DROP_DAEQSA_OFFSET    0
+#define    RTL8367C_DROP_DAEQSA_MASK    0x1
+
+#define    RTL8367C_REG_UNKNOWN_L2_MULTICAST_CTRL1    0x08d5
+#define    RTL8367C_PORT10_UNKNOWN_L2_MCAST_OFFSET    4
+#define    RTL8367C_PORT10_UNKNOWN_L2_MCAST_MASK    0x30
+#define    RTL8367C_PORT9_UNKNOWN_L2_MCAST_OFFSET    2
+#define    RTL8367C_PORT9_UNKNOWN_L2_MCAST_MASK    0xC
+#define    RTL8367C_PORT8_UNKNOWN_L2_MCAST_OFFSET    0
+#define    RTL8367C_PORT8_UNKNOWN_L2_MCAST_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL4    0x08d6
+#define    RTL8367C_PORT9_VLAN_KEEP_MASK_OFFSET    8
+#define    RTL8367C_PORT9_VLAN_KEEP_MASK_MASK    0xFF00
+#define    RTL8367C_PORT8_VLAN_KEEP_MASK_OFFSET    0
+#define    RTL8367C_PORT8_VLAN_KEEP_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL5    0x08d7
+#define    RTL8367C_VLAN_EGRESS_KEEP_CTRL5_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_KEEP_CTRL5_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL0_EXT    0x08d8
+#define    RTL8367C_PORT1_VLAN_KEEP_MASK_EXT_OFFSET    3
+#define    RTL8367C_PORT1_VLAN_KEEP_MASK_EXT_MASK    0x38
+#define    RTL8367C_PORT0_VLAN_KEEP_MASK_EXT_OFFSET    0
+#define    RTL8367C_PORT0_VLAN_KEEP_MASK_EXT_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL1_EXT    0x08d9
+#define    RTL8367C_PORT3_VLAN_KEEP_MASK_EXT_OFFSET    3
+#define    RTL8367C_PORT3_VLAN_KEEP_MASK_EXT_MASK    0x38
+#define    RTL8367C_PORT2_VLAN_KEEP_MASK_EXT_OFFSET    0
+#define    RTL8367C_PORT2_VLAN_KEEP_MASK_EXT_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL2_EXT    0x08da
+#define    RTL8367C_PORT5_VLAN_KEEP_MASK_EXT_OFFSET    3
+#define    RTL8367C_PORT5_VLAN_KEEP_MASK_EXT_MASK    0x38
+#define    RTL8367C_PORT4_VLAN_KEEP_MASK_EXT_OFFSET    0
+#define    RTL8367C_PORT4_VLAN_KEEP_MASK_EXT_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL3_EXT    0x08db
+#define    RTL8367C_PORT7_VLAN_KEEP_MASK_EXT_OFFSET    3
+#define    RTL8367C_PORT7_VLAN_KEEP_MASK_EXT_MASK    0x38
+#define    RTL8367C_PORT6_VLAN_KEEP_MASK_EXT_OFFSET    0
+#define    RTL8367C_PORT6_VLAN_KEEP_MASK_EXT_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL4_EXT    0x08dc
+#define    RTL8367C_PORT9_VLAN_KEEP_MASK_EXT_OFFSET    3
+#define    RTL8367C_PORT9_VLAN_KEEP_MASK_EXT_MASK    0x38
+#define    RTL8367C_PORT8_VLAN_KEEP_MASK_EXT_OFFSET    0
+#define    RTL8367C_PORT8_VLAN_KEEP_MASK_EXT_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL5_EXT    0x08dd
+#define    RTL8367C_VLAN_EGRESS_KEEP_CTRL5_EXT_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_KEEP_CTRL5_EXT_MASK    0x7
+
+#define    RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL10    0x08de
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL10_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL10_MASK    0x7FF
+
+#define    RTL8367C_REG_FPGA_VER_CEN    0x08e0
+
+#define    RTL8367C_REG_FPGA_TIME_CEN    0x08e1
+
+#define    RTL8367C_REG_FPGA_DATE_CEN    0x08e2
+
+#define    RTL8367C_REG_QOS_PORT_QUEUE_NUMBER_CTRL0    0x0900
+#define    RTL8367C_PORT3_NUMBER_OFFSET    12
+#define    RTL8367C_PORT3_NUMBER_MASK    0x7000
+#define    RTL8367C_PORT2_NUMBER_OFFSET    8
+#define    RTL8367C_PORT2_NUMBER_MASK    0x700
+#define    RTL8367C_PORT1_NUMBER_OFFSET    4
+#define    RTL8367C_PORT1_NUMBER_MASK    0x70
+#define    RTL8367C_PORT0_NUMBER_OFFSET    0
+#define    RTL8367C_PORT0_NUMBER_MASK    0x7
+
+#define    RTL8367C_REG_QOS_PORT_QUEUE_NUMBER_CTRL1    0x0901
+#define    RTL8367C_PORT7_NUMBER_OFFSET    12
+#define    RTL8367C_PORT7_NUMBER_MASK    0x7000
+#define    RTL8367C_PORT6_NUMBER_OFFSET    8
+#define    RTL8367C_PORT6_NUMBER_MASK    0x700
+#define    RTL8367C_PORT5_NUMBER_OFFSET    4
+#define    RTL8367C_PORT5_NUMBER_MASK    0x70
+#define    RTL8367C_PORT4_NUMBER_OFFSET    0
+#define    RTL8367C_PORT4_NUMBER_MASK    0x7
+
+#define    RTL8367C_REG_QOS_PORT_QUEUE_NUMBER_CTRL2    0x0902
+#define    RTL8367C_PORT10_NUMBER_OFFSET    8
+#define    RTL8367C_PORT10_NUMBER_MASK    0x700
+#define    RTL8367C_PORT9_NUMBER_OFFSET    4
+#define    RTL8367C_PORT9_NUMBER_MASK    0x70
+#define    RTL8367C_PORT8_NUMBER_OFFSET    0
+#define    RTL8367C_PORT8_NUMBER_MASK    0x7
+
+#define    RTL8367C_REG_QOS_1Q_PRIORITY_TO_QID_CTRL0    0x0904
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_1Q_PRIORITY_TO_QID_CTRL1    0x0905
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_1Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_2Q_PRIORITY_TO_QID_CTRL0    0x0906
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_2Q_PRIORITY_TO_QID_CTRL1    0x0907
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_2Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_3Q_PRIORITY_TO_QID_CTRL0    0x0908
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_3Q_PRIORITY_TO_QID_CTRL1    0x0909
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_3Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_4Q_PRIORITY_TO_QID_CTRL0    0x090a
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_4Q_PRIORITY_TO_QID_CTRL1    0x090b
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_4Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_5Q_PRIORITY_TO_QID_CTRL0    0x090c
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_5Q_PRIORITY_TO_QID_CTRL1    0x090d
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_5Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_6Q_PRIORITY_TO_QID_CTRL0    0x090e
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_6Q_PRIORITY_TO_QID_CTRL1    0x090f
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_6Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_7Q_PRIORITY_TO_QID_CTRL0    0x0910
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_7Q_PRIORITY_TO_QID_CTRL1    0x0911
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_7Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_8Q_PRIORITY_TO_QID_CTRL0    0x0912
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL0_PRIORITY3_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL0_PRIORITY2_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL0_PRIORITY1_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL0_PRIORITY0_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_QOS_8Q_PRIORITY_TO_QID_CTRL1    0x0913
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_OFFSET    12
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL1_PRIORITY7_TO_QID_MASK    0x7000
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_OFFSET    8
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL1_PRIORITY6_TO_QID_MASK    0x700
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_OFFSET    4
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL1_PRIORITY5_TO_QID_MASK    0x70
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_OFFSET    0
+#define    RTL8367C_QOS_8Q_PRIORITY_TO_QID_CTRL1_PRIORITY4_TO_QID_MASK    0x7
+
+#define    RTL8367C_REG_HIGHPRI_INDICATOR    0x0915
+#define    RTL8367C_PORT10_INDICATOR_OFFSET    10
+#define    RTL8367C_PORT10_INDICATOR_MASK    0x400
+#define    RTL8367C_PORT9_INDICATOR_OFFSET    9
+#define    RTL8367C_PORT9_INDICATOR_MASK    0x200
+#define    RTL8367C_PORT8_INDICATOR_OFFSET    8
+#define    RTL8367C_PORT8_INDICATOR_MASK    0x100
+#define    RTL8367C_PORT7_INDICATOR_OFFSET    7
+#define    RTL8367C_PORT7_INDICATOR_MASK    0x80
+#define    RTL8367C_PORT6_INDICATOR_OFFSET    6
+#define    RTL8367C_PORT6_INDICATOR_MASK    0x40
+#define    RTL8367C_PORT5_INDICATOR_OFFSET    5
+#define    RTL8367C_PORT5_INDICATOR_MASK    0x20
+#define    RTL8367C_PORT4_INDICATOR_OFFSET    4
+#define    RTL8367C_PORT4_INDICATOR_MASK    0x10
+#define    RTL8367C_PORT3_INDICATOR_OFFSET    3
+#define    RTL8367C_PORT3_INDICATOR_MASK    0x8
+#define    RTL8367C_PORT2_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT2_INDICATOR_MASK    0x4
+#define    RTL8367C_PORT1_INDICATOR_OFFSET    1
+#define    RTL8367C_PORT1_INDICATOR_MASK    0x2
+#define    RTL8367C_PORT0_INDICATOR_OFFSET    0
+#define    RTL8367C_PORT0_INDICATOR_MASK    0x1
+
+#define    RTL8367C_REG_HIGHPRI_CFG    0x0916
+#define    RTL8367C_HIGHPRI_CFG_OFFSET    0
+#define    RTL8367C_HIGHPRI_CFG_MASK    0xFF
+
+#define    RTL8367C_REG_PORT_DEBUG_INFO_CTRL0    0x0917
+#define    RTL8367C_PORT1_DEBUG_INFO_OFFSET    8
+#define    RTL8367C_PORT1_DEBUG_INFO_MASK    0xFF00
+#define    RTL8367C_PORT0_DEBUG_INFO_OFFSET    0
+#define    RTL8367C_PORT0_DEBUG_INFO_MASK    0xFF
+
+#define    RTL8367C_REG_PORT_DEBUG_INFO_CTRL1    0x0918
+#define    RTL8367C_PORT3_DEBUG_INFO_OFFSET    8
+#define    RTL8367C_PORT3_DEBUG_INFO_MASK    0xFF00
+#define    RTL8367C_PORT2_DEBUG_INFO_OFFSET    0
+#define    RTL8367C_PORT2_DEBUG_INFO_MASK    0xFF
+
+#define    RTL8367C_REG_PORT_DEBUG_INFO_CTRL2    0x0919
+#define    RTL8367C_PORT5_DEBUG_INFO_OFFSET    8
+#define    RTL8367C_PORT5_DEBUG_INFO_MASK    0xFF00
+#define    RTL8367C_PORT4_DEBUG_INFO_OFFSET    0
+#define    RTL8367C_PORT4_DEBUG_INFO_MASK    0xFF
+
+#define    RTL8367C_REG_PORT_DEBUG_INFO_CTRL3    0x091a
+#define    RTL8367C_PORT7_DEBUG_INFO_OFFSET    8
+#define    RTL8367C_PORT7_DEBUG_INFO_MASK    0xFF00
+#define    RTL8367C_PORT6_DEBUG_INFO_OFFSET    0
+#define    RTL8367C_PORT6_DEBUG_INFO_MASK    0xFF
+
+#define    RTL8367C_REG_PORT_DEBUG_INFO_CTRL4    0x091b
+#define    RTL8367C_PORT9_DEBUG_INFO_OFFSET    8
+#define    RTL8367C_PORT9_DEBUG_INFO_MASK    0xFF00
+#define    RTL8367C_PORT8_DEBUG_INFO_OFFSET    0
+#define    RTL8367C_PORT8_DEBUG_INFO_MASK    0xFF
+
+#define    RTL8367C_REG_PORT_DEBUG_INFO_CTRL5    0x091c
+#define    RTL8367C_PORT10_DEBUG_INFO_OFFSET    0
+#define    RTL8367C_PORT10_DEBUG_INFO_MASK    0xFF
+
+#define    RTL8367C_REG_PORT_DEBUG_INFO_CTRL6    0x091d
+#define    RTL8367C_PORT7_DEBUG_INDICATOR_OFFSET    14
+#define    RTL8367C_PORT7_DEBUG_INDICATOR_MASK    0xC000
+#define    RTL8367C_PORT6_DEBUG_INDICATOR_OFFSET    12
+#define    RTL8367C_PORT6_DEBUG_INDICATOR_MASK    0x3000
+#define    RTL8367C_PORT5_DEBUG_INDICATOR_OFFSET    10
+#define    RTL8367C_PORT5_DEBUG_INDICATOR_MASK    0xC00
+#define    RTL8367C_PORT4_DEBUG_INDICATOR_OFFSET    8
+#define    RTL8367C_PORT4_DEBUG_INDICATOR_MASK    0x300
+#define    RTL8367C_PORT3_DEBUG_INDICATOR_OFFSET    6
+#define    RTL8367C_PORT3_DEBUG_INDICATOR_MASK    0xC0
+#define    RTL8367C_PORT2_DEBUG_INDICATOR_OFFSET    4
+#define    RTL8367C_PORT2_DEBUG_INDICATOR_MASK    0x30
+#define    RTL8367C_PORT1_DEBUG_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT1_DEBUG_INDICATOR_MASK    0xC
+#define    RTL8367C_PORT0_DEBUG_INDICATOR_OFFSET    0
+#define    RTL8367C_PORT0_DEBUG_INDICATOR_MASK    0x3
+
+#define    RTL8367C_REG_PORT_DEBUG_INFO_CTRL7    0x091e
+#define    RTL8367C_PORT10_DEBUG_INDICATOR_OFFSET    4
+#define    RTL8367C_PORT10_DEBUG_INDICATOR_MASK    0x30
+#define    RTL8367C_PORT9_DEBUG_INDICATOR_OFFSET    2
+#define    RTL8367C_PORT9_DEBUG_INDICATOR_MASK    0xC
+#define    RTL8367C_PORT8_DEBUG_INDICATOR_OFFSET    0
+#define    RTL8367C_PORT8_DEBUG_INDICATOR_MASK    0x3
+
+#define    RTL8367C_REG_FLOWCRTL_EGRESS_QUEUE_ENABLE_CTRL0    0x0930
+#define    RTL8367C_PORT1_QUEUE_MASK_OFFSET    8
+#define    RTL8367C_PORT1_QUEUE_MASK_MASK    0xFF00
+#define    RTL8367C_PORT0_QUEUE_MASK_OFFSET    0
+#define    RTL8367C_PORT0_QUEUE_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_FLOWCRTL_EGRESS_QUEUE_ENABLE_CTRL1    0x0931
+#define    RTL8367C_PORT3_QUEUE_MASK_OFFSET    8
+#define    RTL8367C_PORT3_QUEUE_MASK_MASK    0xFF00
+#define    RTL8367C_PORT2_QUEUE_MASK_OFFSET    0
+#define    RTL8367C_PORT2_QUEUE_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_FLOWCRTL_EGRESS_QUEUE_ENABLE_CTRL2    0x0932
+#define    RTL8367C_PORT5_QUEUE_MASK_OFFSET    8
+#define    RTL8367C_PORT5_QUEUE_MASK_MASK    0xFF00
+#define    RTL8367C_PORT4_QUEUE_MASK_OFFSET    0
+#define    RTL8367C_PORT4_QUEUE_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_FLOWCRTL_EGRESS_QUEUE_ENABLE_CTRL3    0x0933
+#define    RTL8367C_PORT7_QUEUE_MASK_OFFSET    8
+#define    RTL8367C_PORT7_QUEUE_MASK_MASK    0xFF00
+#define    RTL8367C_PORT6_QUEUE_MASK_OFFSET    0
+#define    RTL8367C_PORT6_QUEUE_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_FLOWCRTL_EGRESS_QUEUE_ENABLE_CTRL4    0x0934
+#define    RTL8367C_PORT9_QUEUE_MASK_OFFSET    8
+#define    RTL8367C_PORT9_QUEUE_MASK_MASK    0xFF00
+#define    RTL8367C_PORT8_QUEUE_MASK_OFFSET    0
+#define    RTL8367C_PORT8_QUEUE_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_FLOWCRTL_EGRESS_QUEUE_ENABLE_CTRL5    0x0935
+#define    RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_CTRL5_OFFSET    0
+#define    RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_CTRL5_MASK    0xFF
+
+#define    RTL8367C_REG_FLOWCRTL_EGRESS_PORT_ENABLE    0x0938
+#define    RTL8367C_FLOWCRTL_EGRESS_PORT_ENABLE_OFFSET    0
+#define    RTL8367C_FLOWCRTL_EGRESS_PORT_ENABLE_MASK    0xFF
+
+#define    RTL8367C_REG_EAV_CTRL    0x0939
+#define    RTL8367C_EAV_TRAP_CPU_OFFSET    1
+#define    RTL8367C_EAV_TRAP_CPU_MASK    0x2
+#define    RTL8367C_EAV_TRAP_8051_OFFSET    0
+#define    RTL8367C_EAV_TRAP_8051_MASK    0x1
+
+#define    RTL8367C_REG_UNTAG_DSCP_PRI_CFG    0x093a
+#define    RTL8367C_UNTAG_DSCP_PRI_CFG_OFFSET    0
+#define    RTL8367C_UNTAG_DSCP_PRI_CFG_MASK    0x1
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL0    0x093b
+#define    RTL8367C_PORT1_VLAN_KEEP_MASK_OFFSET    8
+#define    RTL8367C_PORT1_VLAN_KEEP_MASK_MASK    0xFF00
+#define    RTL8367C_PORT0_VLAN_KEEP_MASK_OFFSET    0
+#define    RTL8367C_PORT0_VLAN_KEEP_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL1    0x093c
+#define    RTL8367C_PORT3_VLAN_KEEP_MASK_OFFSET    8
+#define    RTL8367C_PORT3_VLAN_KEEP_MASK_MASK    0xFF00
+#define    RTL8367C_PORT2_VLAN_KEEP_MASK_OFFSET    0
+#define    RTL8367C_PORT2_VLAN_KEEP_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL2    0x093d
+#define    RTL8367C_PORT5_VLAN_KEEP_MASK_OFFSET    8
+#define    RTL8367C_PORT5_VLAN_KEEP_MASK_MASK    0xFF00
+#define    RTL8367C_PORT4_VLAN_KEEP_MASK_OFFSET    0
+#define    RTL8367C_PORT4_VLAN_KEEP_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL3    0x093e
+#define    RTL8367C_PORT7_VLAN_KEEP_MASK_OFFSET    8
+#define    RTL8367C_PORT7_VLAN_KEEP_MASK_MASK    0xFF00
+#define    RTL8367C_PORT6_VLAN_KEEP_MASK_OFFSET    0
+#define    RTL8367C_PORT6_VLAN_KEEP_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_VLAN_TRANSPARENT_EN_CFG    0x093f
+#define    RTL8367C_VLAN_TRANSPARENT_EN_CFG_OFFSET    0
+#define    RTL8367C_VLAN_TRANSPARENT_EN_CFG_MASK    0x1
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY0_H    0x0940
+#define    RTL8367C_IPMC_GROUP_ENTRY0_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY0_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY0_L    0x0941
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY1_H    0x0942
+#define    RTL8367C_IPMC_GROUP_ENTRY1_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY1_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY1_L    0x0943
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY2_H    0x0944
+#define    RTL8367C_IPMC_GROUP_ENTRY2_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY2_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY2_L    0x0945
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY3_H    0x0946
+#define    RTL8367C_IPMC_GROUP_ENTRY3_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY3_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY3_L    0x0947
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY4_H    0x0948
+#define    RTL8367C_IPMC_GROUP_ENTRY4_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY4_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY4_L    0x0949
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY5_H    0x094a
+#define    RTL8367C_IPMC_GROUP_ENTRY5_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY5_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY5_L    0x094b
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY6_H    0x094c
+#define    RTL8367C_IPMC_GROUP_ENTRY6_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY6_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY6_L    0x094d
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY7_H    0x094e
+#define    RTL8367C_IPMC_GROUP_ENTRY7_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY7_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY7_L    0x094f
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY8_H    0x0950
+#define    RTL8367C_IPMC_GROUP_ENTRY8_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY8_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY8_L    0x0951
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY9_H    0x0952
+#define    RTL8367C_IPMC_GROUP_ENTRY9_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY9_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY9_L    0x0953
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY10_H    0x0954
+#define    RTL8367C_IPMC_GROUP_ENTRY10_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY10_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY10_L    0x0955
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY11_H    0x0956
+#define    RTL8367C_IPMC_GROUP_ENTRY11_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY11_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY11_L    0x0957
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY12_H    0x0958
+#define    RTL8367C_IPMC_GROUP_ENTRY12_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY12_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY12_L    0x0959
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY13_H    0x095a
+#define    RTL8367C_IPMC_GROUP_ENTRY13_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY13_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY13_L    0x095b
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY14_H    0x095c
+#define    RTL8367C_IPMC_GROUP_ENTRY14_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY14_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY14_L    0x095d
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY15_H    0x095e
+#define    RTL8367C_IPMC_GROUP_ENTRY15_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY15_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY15_L    0x095f
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY16_H    0x0960
+#define    RTL8367C_IPMC_GROUP_ENTRY16_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY16_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY16_L    0x0961
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY17_H    0x0962
+#define    RTL8367C_IPMC_GROUP_ENTRY17_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY17_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY17_L    0x0963
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY18_H    0x0964
+#define    RTL8367C_IPMC_GROUP_ENTRY18_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY18_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY18_L    0x0965
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY19_H    0x0966
+#define    RTL8367C_IPMC_GROUP_ENTRY19_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY19_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY19_L    0x0967
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY20_H    0x0968
+#define    RTL8367C_IPMC_GROUP_ENTRY20_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY20_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY20_L    0x0969
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY21_H    0x096a
+#define    RTL8367C_IPMC_GROUP_ENTRY21_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY21_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY21_L    0x096b
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY22_H    0x096c
+#define    RTL8367C_IPMC_GROUP_ENTRY22_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY22_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY22_L    0x096d
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY23_H    0x096e
+#define    RTL8367C_IPMC_GROUP_ENTRY23_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY23_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY23_L    0x096f
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY24_H    0x0970
+#define    RTL8367C_IPMC_GROUP_ENTRY24_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY24_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY24_L    0x0971
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY25_H    0x0972
+#define    RTL8367C_IPMC_GROUP_ENTRY25_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY25_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY25_L    0x0973
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY26_H    0x0974
+#define    RTL8367C_IPMC_GROUP_ENTRY26_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY26_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY26_L    0x0975
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY27_H    0x0976
+#define    RTL8367C_IPMC_GROUP_ENTRY27_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY27_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY27_L    0x0977
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY28_H    0x0978
+#define    RTL8367C_IPMC_GROUP_ENTRY28_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY28_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY28_L    0x0979
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY29_H    0x097a
+#define    RTL8367C_IPMC_GROUP_ENTRY29_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY29_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY29_L    0x097b
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY30_H    0x097c
+#define    RTL8367C_IPMC_GROUP_ENTRY30_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY30_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY30_L    0x097d
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY31_H    0x097e
+#define    RTL8367C_IPMC_GROUP_ENTRY31_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY31_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY31_L    0x097f
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY32_H    0x0980
+#define    RTL8367C_IPMC_GROUP_ENTRY32_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY32_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY32_L    0x0981
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY33_H    0x0982
+#define    RTL8367C_IPMC_GROUP_ENTRY33_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY33_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY33_L    0x0983
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY34_H    0x0984
+#define    RTL8367C_IPMC_GROUP_ENTRY34_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY34_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY34_L    0x0985
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY35_H    0x0986
+#define    RTL8367C_IPMC_GROUP_ENTRY35_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY35_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY35_L    0x0987
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY36_H    0x0988
+#define    RTL8367C_IPMC_GROUP_ENTRY36_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY36_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY36_L    0x0989
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY37_H    0x098a
+#define    RTL8367C_IPMC_GROUP_ENTRY37_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY37_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY37_L    0x098b
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY38_H    0x098c
+#define    RTL8367C_IPMC_GROUP_ENTRY38_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY38_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY38_L    0x098d
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY39_H    0x098e
+#define    RTL8367C_IPMC_GROUP_ENTRY39_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY39_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY39_L    0x098f
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY40_H    0x0990
+#define    RTL8367C_IPMC_GROUP_ENTRY40_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY40_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY40_L    0x0991
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY41_H    0x0992
+#define    RTL8367C_IPMC_GROUP_ENTRY41_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY41_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY41_L    0x0993
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY42_H    0x0994
+#define    RTL8367C_IPMC_GROUP_ENTRY42_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY42_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY42_L    0x0995
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY43_H    0x0996
+#define    RTL8367C_IPMC_GROUP_ENTRY43_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY43_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY43_L    0x0997
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY44_H    0x0998
+#define    RTL8367C_IPMC_GROUP_ENTRY44_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY44_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY44_L    0x0999
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY45_H    0x099a
+#define    RTL8367C_IPMC_GROUP_ENTRY45_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY45_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY45_L    0x099b
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY46_H    0x099c
+#define    RTL8367C_IPMC_GROUP_ENTRY46_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY46_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY46_L    0x099d
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY47_H    0x099e
+#define    RTL8367C_IPMC_GROUP_ENTRY47_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY47_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY47_L    0x099f
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY48_H    0x09a0
+#define    RTL8367C_IPMC_GROUP_ENTRY48_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY48_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY48_L    0x09a1
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY49_H    0x09a2
+#define    RTL8367C_IPMC_GROUP_ENTRY49_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY49_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY49_L    0x09a3
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY50_H    0x09a4
+#define    RTL8367C_IPMC_GROUP_ENTRY50_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY50_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY50_L    0x09a5
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY51_H    0x09a6
+#define    RTL8367C_IPMC_GROUP_ENTRY51_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY51_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY51_L    0x09a7
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY52_H    0x09a8
+#define    RTL8367C_IPMC_GROUP_ENTRY52_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY52_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY52_L    0x09a9
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY53_H    0x09aa
+#define    RTL8367C_IPMC_GROUP_ENTRY53_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY53_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY53_L    0x09ab
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY54_H    0x09ac
+#define    RTL8367C_IPMC_GROUP_ENTRY54_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY54_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY54_L    0x09ad
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY55_H    0x09ae
+#define    RTL8367C_IPMC_GROUP_ENTRY55_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY55_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY55_L    0x09af
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY56_H    0x09b0
+#define    RTL8367C_IPMC_GROUP_ENTRY56_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY56_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY56_L    0x09b1
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY57_H    0x09b2
+#define    RTL8367C_IPMC_GROUP_ENTRY57_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY57_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY57_L    0x09b3
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY58_H    0x09b4
+#define    RTL8367C_IPMC_GROUP_ENTRY58_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY58_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY58_L    0x09b5
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY59_H    0x09b6
+#define    RTL8367C_IPMC_GROUP_ENTRY59_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY59_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY59_L    0x09b7
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY60_H    0x09b8
+#define    RTL8367C_IPMC_GROUP_ENTRY60_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY60_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY60_L    0x09b9
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY61_H    0x09ba
+#define    RTL8367C_IPMC_GROUP_ENTRY61_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY61_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY61_L    0x09bb
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY62_H    0x09bc
+#define    RTL8367C_IPMC_GROUP_ENTRY62_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY62_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY62_L    0x09bd
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY63_H    0x09be
+#define    RTL8367C_IPMC_GROUP_ENTRY63_H_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_ENTRY63_H_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_ENTRY63_L    0x09bf
+
+#define    RTL8367C_REG_UNKNOWN_UNICAST_DA_PORT_BEHAVE    0x09C0
+#define    RTL8367C_Port7_ACTION_OFFSET    14
+#define    RTL8367C_Port7_ACTION_MASK    0xC000
+#define    RTL8367C_Port6_ACTION_OFFSET    12
+#define    RTL8367C_Port6_ACTION_MASK    0x3000
+#define    RTL8367C_Port5_ACTION_OFFSET    10
+#define    RTL8367C_Port5_ACTION_MASK    0xC00
+#define    RTL8367C_Port4_ACTION_OFFSET    8
+#define    RTL8367C_Port4_ACTION_MASK    0x300
+#define    RTL8367C_Port3_ACTION_OFFSET    6
+#define    RTL8367C_Port3_ACTION_MASK    0xC0
+#define    RTL8367C_Port2_ACTION_OFFSET    4
+#define    RTL8367C_Port2_ACTION_MASK    0x30
+#define    RTL8367C_Port1_ACTION_OFFSET    2
+#define    RTL8367C_Port1_ACTION_MASK    0xC
+#define    RTL8367C_Port0_ACTION_OFFSET    0
+#define    RTL8367C_Port0_ACTION_MASK    0x3
+
+#define    RTL8367C_REG_MIRROR_CTRL3    0x09C1
+#define    RTL8367C_MIRROR_ACL_OVERRIDE_EN_OFFSET    2
+#define    RTL8367C_MIRROR_ACL_OVERRIDE_EN_MASK    0x4
+#define    RTL8367C_MIRROR_TX_OVERRIDE_EN_OFFSET    1
+#define    RTL8367C_MIRROR_TX_OVERRIDE_EN_MASK    0x2
+#define    RTL8367C_MIRROR_RX_OVERRIDE_EN_OFFSET    0
+#define    RTL8367C_MIRROR_RX_OVERRIDE_EN_MASK    0x1
+
+#define    RTL8367C_REG_DPM_DUMMY02    0x09C2
+
+#define    RTL8367C_REG_DPM_DUMMY03    0x09C3
+
+#define    RTL8367C_REG_DPM_DUMMY04    0x09C4
+
+#define    RTL8367C_REG_DPM_DUMMY05    0x09C5
+
+#define    RTL8367C_REG_DPM_DUMMY06    0x09C6
+
+#define    RTL8367C_REG_DPM_DUMMY07    0x09C7
+
+#define    RTL8367C_REG_DPM_DUMMY08    0x09C8
+
+#define    RTL8367C_REG_DPM_DUMMY09    0x09C9
+
+#define    RTL8367C_REG_DPM_DUMMY10    0x09CA
+
+#define    RTL8367C_REG_DPM_DUMMY11    0x09CB
+
+#define    RTL8367C_REG_DPM_DUMMY12    0x09CC
+
+#define    RTL8367C_REG_DPM_DUMMY13    0x09CD
+
+#define    RTL8367C_REG_DPM_DUMMY14    0x09CE
+
+#define    RTL8367C_REG_DPM_DUMMY15    0x09CF
+
+#define    RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL0    0x09D0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL0_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL0_MASK    0x7FF
+
+#define    RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL1    0x09D1
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL1_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL1_MASK    0x7FF
+
+#define    RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL2    0x09D2
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL2_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL2_MASK    0x7FF
+
+#define    RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL3    0x09D3
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL3_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL3_MASK    0x7FF
+
+#define    RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL4    0x09D4
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL4_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL4_MASK    0x7FF
+
+#define    RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL5    0x09D5
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL5_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL5_MASK    0x7FF
+
+#define    RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL6    0x09D6
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL6_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL6_MASK    0x7FF
+
+#define    RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL7    0x09D7
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL7_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL7_MASK    0x7FF
+
+#define    RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL8    0x09D8
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL8_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL8_MASK    0x7FF
+
+#define    RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL9    0x09D9
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL9_OFFSET    0
+#define    RTL8367C_VLAN_EGRESS_TRANS_CTRL9_MASK    0x7FF
+
+#define    RTL8367C_REG_MIRROR_CTRL2    0x09DA
+#define    RTL8367C_MIRROR_REALKEEP_EN_OFFSET    4
+#define    RTL8367C_MIRROR_REALKEEP_EN_MASK    0x10
+#define    RTL8367C_MIRROR_RX_ISOLATION_LEAKY_OFFSET    3
+#define    RTL8367C_MIRROR_RX_ISOLATION_LEAKY_MASK    0x8
+#define    RTL8367C_MIRROR_TX_ISOLATION_LEAKY_OFFSET    2
+#define    RTL8367C_MIRROR_TX_ISOLATION_LEAKY_MASK    0x4
+#define    RTL8367C_MIRROR_RX_VLAN_LEAKY_OFFSET    1
+#define    RTL8367C_MIRROR_RX_VLAN_LEAKY_MASK    0x2
+#define    RTL8367C_MIRROR_TX_VLAN_LEAKY_OFFSET    0
+#define    RTL8367C_MIRROR_TX_VLAN_LEAKY_MASK    0x1
+
+#define    RTL8367C_REG_OUTPUT_DROP_CFG    0x09DB
+#define    RTL8367C_ENABLE_PMASK_EXT_OFFSET    13
+#define    RTL8367C_ENABLE_PMASK_EXT_MASK    0xE000
+#define    RTL8367C_ENABLE_BC_OFFSET    12
+#define    RTL8367C_ENABLE_BC_MASK    0x1000
+#define    RTL8367C_ENABLE_MC_OFFSET    11
+#define    RTL8367C_ENABLE_MC_MASK    0x800
+#define    RTL8367C_ENABLE_UC_OFFSET    10
+#define    RTL8367C_ENABLE_UC_MASK    0x400
+#define    RTL8367C_ENABLE_PMASK_OFFSET    0
+#define    RTL8367C_ENABLE_PMASK_MASK    0xFF
+
+#define    RTL8367C_REG_UNKNOWN_UNICAST_DA_PORT_BEHAVE_EXT    0x09DC
+#define    RTL8367C_PORT10_ACTION_OFFSET    4
+#define    RTL8367C_PORT10_ACTION_MASK    0x30
+#define    RTL8367C_PORT9_ACTION_OFFSET    2
+#define    RTL8367C_PORT9_ACTION_MASK    0xC
+#define    RTL8367C_PORT8_ACTION_OFFSET    0
+#define    RTL8367C_PORT8_ACTION_MASK    0x3
+
+#define    RTL8367C_REG_RMK_CFG_SEL_CTRL    0x09DF
+#define    RTL8367C_RMK_1Q_CFG_SEL_OFFSET    2
+#define    RTL8367C_RMK_1Q_CFG_SEL_MASK    0x4
+#define    RTL8367C_RMK_DSCP_CFG_SEL_OFFSET    0
+#define    RTL8367C_RMK_DSCP_CFG_SEL_MASK    0x3
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL0    0x09E0
+#define    RTL8367C_DSCP1_DSCP_OFFSET    8
+#define    RTL8367C_DSCP1_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP0_DSCP_OFFSET    0
+#define    RTL8367C_DSCP0_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL1    0x09E1
+#define    RTL8367C_DSCP3_DSCP_OFFSET    8
+#define    RTL8367C_DSCP3_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP2_DSCP_OFFSET    0
+#define    RTL8367C_DSCP2_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL2    0x09E2
+#define    RTL8367C_DSCP5_DSCP_OFFSET    8
+#define    RTL8367C_DSCP5_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP4_DSCP_OFFSET    0
+#define    RTL8367C_DSCP4_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL3    0x09E3
+#define    RTL8367C_DSCP7_DSCP_OFFSET    8
+#define    RTL8367C_DSCP7_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP6_DSCP_OFFSET    0
+#define    RTL8367C_DSCP6_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL4    0x09E4
+#define    RTL8367C_DSCP9_DSCP_OFFSET    8
+#define    RTL8367C_DSCP9_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP8_DSCP_OFFSET    0
+#define    RTL8367C_DSCP8_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL5    0x09E5
+#define    RTL8367C_DSCP11_DSCP_OFFSET    8
+#define    RTL8367C_DSCP11_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP10_DSCP_OFFSET    0
+#define    RTL8367C_DSCP10_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL6    0x09E6
+#define    RTL8367C_DSCP13_DSCP_OFFSET    8
+#define    RTL8367C_DSCP13_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP12_DSCP_OFFSET    0
+#define    RTL8367C_DSCP12_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL7    0x09E7
+#define    RTL8367C_DSCP15_DSCP_OFFSET    8
+#define    RTL8367C_DSCP15_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP14_DSCP_OFFSET    0
+#define    RTL8367C_DSCP14_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL8    0x09E8
+#define    RTL8367C_DSCP17_DSCP_OFFSET    8
+#define    RTL8367C_DSCP17_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP16_DSCP_OFFSET    0
+#define    RTL8367C_DSCP16_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL9    0x09E9
+#define    RTL8367C_DSCP19_DSCP_OFFSET    8
+#define    RTL8367C_DSCP19_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP18_DSCP_OFFSET    0
+#define    RTL8367C_DSCP18_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL10    0x09EA
+#define    RTL8367C_DSCP21_DSCP_OFFSET    8
+#define    RTL8367C_DSCP21_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP20_DSCP_OFFSET    0
+#define    RTL8367C_DSCP20_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL11    0x09EB
+#define    RTL8367C_DSCP23_DSCP_OFFSET    8
+#define    RTL8367C_DSCP23_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP22_DSCP_OFFSET    0
+#define    RTL8367C_DSCP22_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL12    0x09EC
+#define    RTL8367C_DSCP25_DSCP_OFFSET    8
+#define    RTL8367C_DSCP25_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP24_DSCP_OFFSET    0
+#define    RTL8367C_DSCP24_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL13    0x09ED
+#define    RTL8367C_DSCP27_DSCP_OFFSET    8
+#define    RTL8367C_DSCP27_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP26_DSCP_OFFSET    0
+#define    RTL8367C_DSCP26_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL14    0x09EE
+#define    RTL8367C_DSCP29_DSCP_OFFSET    8
+#define    RTL8367C_DSCP29_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP28_DSCP_OFFSET    0
+#define    RTL8367C_DSCP28_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL15    0x09EF
+#define    RTL8367C_DSCP31_DSCP_OFFSET    8
+#define    RTL8367C_DSCP31_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP30_DSCP_OFFSET    0
+#define    RTL8367C_DSCP30_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL16    0x09F0
+#define    RTL8367C_DSCP33_DSCP_OFFSET    8
+#define    RTL8367C_DSCP33_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP32_DSCP_OFFSET    0
+#define    RTL8367C_DSCP32_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL17    0x09F1
+#define    RTL8367C_DSCP35_DSCP_OFFSET    8
+#define    RTL8367C_DSCP35_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP34_DSCP_OFFSET    0
+#define    RTL8367C_DSCP34_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL18    0x09F2
+#define    RTL8367C_DSCP37_DSCP_OFFSET    8
+#define    RTL8367C_DSCP37_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP36_DSCP_OFFSET    0
+#define    RTL8367C_DSCP36_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL19    0x09F3
+#define    RTL8367C_DSCP39_DSCP_OFFSET    8
+#define    RTL8367C_DSCP39_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP38_DSCP_OFFSET    0
+#define    RTL8367C_DSCP38_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL20    0x09F4
+#define    RTL8367C_DSCP41_DSCP_OFFSET    8
+#define    RTL8367C_DSCP41_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP40_DSCP_OFFSET    0
+#define    RTL8367C_DSCP40_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL21    0x09F5
+#define    RTL8367C_DSCP43_DSCP_OFFSET    8
+#define    RTL8367C_DSCP43_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP42_DSCP_OFFSET    0
+#define    RTL8367C_DSCP42_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL22    0x09F6
+#define    RTL8367C_DSCP45_DSCP_OFFSET    8
+#define    RTL8367C_DSCP45_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP44_DSCP_OFFSET    0
+#define    RTL8367C_DSCP44_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL23    0x09F7
+#define    RTL8367C_DSCP47_DSCP_OFFSET    8
+#define    RTL8367C_DSCP47_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP46_DSCP_OFFSET    0
+#define    RTL8367C_DSCP46_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL24    0x09F8
+#define    RTL8367C_DSCP49_DSCP_OFFSET    8
+#define    RTL8367C_DSCP49_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP48_DSCP_OFFSET    0
+#define    RTL8367C_DSCP48_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL25    0x09F9
+#define    RTL8367C_DSCP51_DSCP_OFFSET    8
+#define    RTL8367C_DSCP51_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP50_DSCP_OFFSET    0
+#define    RTL8367C_DSCP50_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL26    0x09FA
+#define    RTL8367C_DSCP53_DSCP_OFFSET    8
+#define    RTL8367C_DSCP53_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP52_DSCP_OFFSET    0
+#define    RTL8367C_DSCP52_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL27    0x09FB
+#define    RTL8367C_DSCP55_DSCP_OFFSET    8
+#define    RTL8367C_DSCP55_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP54_DSCP_OFFSET    0
+#define    RTL8367C_DSCP54_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL28    0x09FC
+#define    RTL8367C_DSCP57_DSCP_OFFSET    8
+#define    RTL8367C_DSCP57_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP56_DSCP_OFFSET    0
+#define    RTL8367C_DSCP56_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL29    0x09FD
+#define    RTL8367C_DSCP59_DSCP_OFFSET    8
+#define    RTL8367C_DSCP59_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP58_DSCP_OFFSET    0
+#define    RTL8367C_DSCP58_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL30    0x09FE
+#define    RTL8367C_DSCP61_DSCP_OFFSET    8
+#define    RTL8367C_DSCP61_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP60_DSCP_OFFSET    0
+#define    RTL8367C_DSCP60_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_DSCP_CTRL31    0x09FF
+#define    RTL8367C_DSCP63_DSCP_OFFSET    8
+#define    RTL8367C_DSCP63_DSCP_MASK    0x3F00
+#define    RTL8367C_DSCP62_DSCP_OFFSET    0
+#define    RTL8367C_DSCP62_DSCP_MASK    0x3F
+
+/* (16'h0a00)l2_reg */
+
+#define    RTL8367C_REG_VLAN_MSTI0_CTRL0    0x0a00
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI0_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI0_CTRL1    0x0a01
+#define    RTL8367C_VLAN_MSTI0_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI0_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI0_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI0_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI0_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI0_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI1_CTRL0    0x0a02
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI1_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI1_CTRL1    0x0a03
+#define    RTL8367C_VLAN_MSTI1_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI1_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI1_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI1_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI1_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI1_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI2_CTRL0    0x0a04
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI2_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI2_CTRL1    0x0a05
+#define    RTL8367C_VLAN_MSTI2_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI2_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI2_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI2_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI2_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI2_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI3_CTRL0    0x0a06
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI3_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI3_CTRL1    0x0a07
+#define    RTL8367C_VLAN_MSTI3_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI3_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI3_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI3_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI3_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI3_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI4_CTRL0    0x0a08
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI4_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI4_CTRL1    0x0a09
+#define    RTL8367C_VLAN_MSTI4_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI4_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI4_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI4_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI4_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI4_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI5_CTRL0    0x0a0a
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI5_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI5_CTRL1    0x0a0b
+#define    RTL8367C_VLAN_MSTI5_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI5_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI5_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI5_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI5_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI5_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI6_CTRL0    0x0a0c
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI6_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI6_CTRL1    0x0a0d
+#define    RTL8367C_VLAN_MSTI6_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI6_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI6_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI6_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI6_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI6_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI7_CTRL0    0x0a0e
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI7_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI7_CTRL1    0x0a0f
+#define    RTL8367C_VLAN_MSTI7_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI7_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI7_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI7_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI7_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI7_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI8_CTRL0    0x0a10
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI8_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI8_CTRL1    0x0a11
+#define    RTL8367C_VLAN_MSTI8_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI8_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI8_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI8_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI8_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI8_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI9_CTRL0    0x0a12
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI9_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI9_CTRL1    0x0a13
+#define    RTL8367C_VLAN_MSTI9_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI9_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI9_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI9_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI9_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI9_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI10_CTRL0    0x0a14
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI10_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI10_CTRL1    0x0a15
+#define    RTL8367C_VLAN_MSTI10_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI10_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI10_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI10_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI10_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI10_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI11_CTRL0    0x0a16
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI11_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI11_CTRL1    0x0a17
+#define    RTL8367C_VLAN_MSTI11_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI11_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI11_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI11_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI11_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI11_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI12_CTRL0    0x0a18
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI12_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI12_CTRL1    0x0a19
+#define    RTL8367C_VLAN_MSTI12_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI12_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI12_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI12_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI12_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI12_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI13_CTRL0    0x0a1a
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI13_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI13_CTRL1    0x0a1b
+#define    RTL8367C_VLAN_MSTI13_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI13_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI13_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI13_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI13_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI13_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI14_CTRL0    0x0a1c
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI14_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI14_CTRL1    0x0a1d
+#define    RTL8367C_VLAN_MSTI14_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI14_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI14_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI14_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI14_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI14_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI15_CTRL0    0x0a1e
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT7_STATE_OFFSET    14
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT7_STATE_MASK    0xC000
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT6_STATE_OFFSET    12
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT6_STATE_MASK    0x3000
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT5_STATE_OFFSET    10
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT5_STATE_MASK    0xC00
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT4_STATE_OFFSET    8
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT4_STATE_MASK    0x300
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT3_STATE_OFFSET    6
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT3_STATE_MASK    0xC0
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT2_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT2_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT1_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT1_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT0_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI15_CTRL0_PORT0_STATE_MASK    0x3
+
+#define    RTL8367C_REG_VLAN_MSTI15_CTRL1    0x0a1f
+#define    RTL8367C_VLAN_MSTI15_CTRL1_PORT10_STATE_OFFSET    4
+#define    RTL8367C_VLAN_MSTI15_CTRL1_PORT10_STATE_MASK    0x30
+#define    RTL8367C_VLAN_MSTI15_CTRL1_PORT9_STATE_OFFSET    2
+#define    RTL8367C_VLAN_MSTI15_CTRL1_PORT9_STATE_MASK    0xC
+#define    RTL8367C_VLAN_MSTI15_CTRL1_PORT8_STATE_OFFSET    0
+#define    RTL8367C_VLAN_MSTI15_CTRL1_PORT8_STATE_MASK    0x3
+
+#define    RTL8367C_REG_LUT_PORT0_LEARN_LIMITNO    0x0a20
+#define    RTL8367C_LUT_PORT0_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_PORT0_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_PORT1_LEARN_LIMITNO    0x0a21
+#define    RTL8367C_LUT_PORT1_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_PORT1_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_PORT2_LEARN_LIMITNO    0x0a22
+#define    RTL8367C_LUT_PORT2_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_PORT2_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_PORT3_LEARN_LIMITNO    0x0a23
+#define    RTL8367C_LUT_PORT3_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_PORT3_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_PORT4_LEARN_LIMITNO    0x0a24
+#define    RTL8367C_LUT_PORT4_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_PORT4_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_PORT5_LEARN_LIMITNO    0x0a25
+#define    RTL8367C_LUT_PORT5_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_PORT5_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_PORT6_LEARN_LIMITNO    0x0a26
+#define    RTL8367C_LUT_PORT6_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_PORT6_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_PORT7_LEARN_LIMITNO    0x0a27
+#define    RTL8367C_LUT_PORT7_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_PORT7_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_SYS_LEARN_LIMITNO    0x0a28
+#define    RTL8367C_LUT_SYS_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_SYS_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL    0x0a29
+#define    RTL8367C_LUT_SYSTEM_LEARN_PMASK1_OFFSET    12
+#define    RTL8367C_LUT_SYSTEM_LEARN_PMASK1_MASK    0x7000
+#define    RTL8367C_LUT_SYSTEM_LEARN_OVER_ACT_OFFSET    10
+#define    RTL8367C_LUT_SYSTEM_LEARN_OVER_ACT_MASK    0xC00
+#define    RTL8367C_LUT_SYSTEM_LEARN_PMASK_OFFSET    0
+#define    RTL8367C_LUT_SYSTEM_LEARN_PMASK_MASK    0xFF
+
+#define    RTL8367C_REG_LUT_PORT8_LEARN_LIMITNO    0x0a2a
+#define    RTL8367C_LUT_PORT8_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_PORT8_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_PORT9_LEARN_LIMITNO    0x0a2b
+#define    RTL8367C_LUT_PORT9_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_PORT9_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_PORT10_LEARN_LIMITNO    0x0a2c
+#define    RTL8367C_LUT_PORT10_LEARN_LIMITNO_OFFSET    0
+#define    RTL8367C_LUT_PORT10_LEARN_LIMITNO_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_CFG    0x0a30
+#define    RTL8367C_AGE_SPEED_OFFSET    8
+#define    RTL8367C_AGE_SPEED_MASK    0x300
+#define    RTL8367C_BCAM_DISABLE_OFFSET    6
+#define    RTL8367C_BCAM_DISABLE_MASK    0x40
+#define    RTL8367C_LINKDOWN_AGEOUT_OFFSET    5
+#define    RTL8367C_LINKDOWN_AGEOUT_MASK    0x20
+#define    RTL8367C_LUT_IPMC_HASH_OFFSET    4
+#define    RTL8367C_LUT_IPMC_HASH_MASK    0x10
+#define    RTL8367C_LUT_IPMC_LOOKUP_OP_OFFSET    3
+#define    RTL8367C_LUT_IPMC_LOOKUP_OP_MASK    0x8
+#define    RTL8367C_AGE_TIMER_OFFSET    0
+#define    RTL8367C_AGE_TIMER_MASK    0x7
+
+#define    RTL8367C_REG_LUT_AGEOUT_CTRL    0x0a31
+#define    RTL8367C_LUT_AGEOUT_CTRL_OFFSET    0
+#define    RTL8367C_LUT_AGEOUT_CTRL_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_EFID_CTRL0    0x0a32
+#define    RTL8367C_PORT3_EFID_OFFSET    12
+#define    RTL8367C_PORT3_EFID_MASK    0x7000
+#define    RTL8367C_PORT2_EFID_OFFSET    8
+#define    RTL8367C_PORT2_EFID_MASK    0x700
+#define    RTL8367C_PORT1_EFID_OFFSET    4
+#define    RTL8367C_PORT1_EFID_MASK    0x70
+#define    RTL8367C_PORT0_EFID_OFFSET    0
+#define    RTL8367C_PORT0_EFID_MASK    0x7
+
+#define    RTL8367C_REG_PORT_EFID_CTRL1    0x0a33
+#define    RTL8367C_PORT7_EFID_OFFSET    12
+#define    RTL8367C_PORT7_EFID_MASK    0x7000
+#define    RTL8367C_PORT6_EFID_OFFSET    8
+#define    RTL8367C_PORT6_EFID_MASK    0x700
+#define    RTL8367C_PORT5_EFID_OFFSET    4
+#define    RTL8367C_PORT5_EFID_MASK    0x70
+#define    RTL8367C_PORT4_EFID_OFFSET    0
+#define    RTL8367C_PORT4_EFID_MASK    0x7
+
+#define    RTL8367C_REG_PORT_EFID_CTRL2    0x0a34
+#define    RTL8367C_PORT10_EFID_OFFSET    8
+#define    RTL8367C_PORT10_EFID_MASK    0x700
+#define    RTL8367C_PORT9_EFID_OFFSET    4
+#define    RTL8367C_PORT9_EFID_MASK    0x70
+#define    RTL8367C_PORT8_EFID_OFFSET    0
+#define    RTL8367C_PORT8_EFID_MASK    0x7
+
+#define    RTL8367C_REG_FORCE_FLUSH1    0x0a35
+#define    RTL8367C_BUSY_STATUS1_OFFSET    3
+#define    RTL8367C_BUSY_STATUS1_MASK    0x38
+#define    RTL8367C_PORTMASK1_OFFSET    0
+#define    RTL8367C_PORTMASK1_MASK    0x7
+
+#define    RTL8367C_REG_FORCE_FLUSH    0x0a36
+#define    RTL8367C_BUSY_STATUS_OFFSET    8
+#define    RTL8367C_BUSY_STATUS_MASK    0xFF00
+#define    RTL8367C_FORCE_FLUSH_PORTMASK_OFFSET    0
+#define    RTL8367C_FORCE_FLUSH_PORTMASK_MASK    0xFF
+
+#define    RTL8367C_REG_L2_FLUSH_CTRL1    0x0a37
+#define    RTL8367C_LUT_FLUSH_FID_OFFSET    12
+#define    RTL8367C_LUT_FLUSH_FID_MASK    0xF000
+#define    RTL8367C_LUT_FLUSH_VID_OFFSET    0
+#define    RTL8367C_LUT_FLUSH_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_L2_FLUSH_CTRL2    0x0a38
+#define    RTL8367C_LUT_FLUSH_TYPE_OFFSET    2
+#define    RTL8367C_LUT_FLUSH_TYPE_MASK    0x4
+#define    RTL8367C_LUT_FLUSH_MODE_OFFSET    0
+#define    RTL8367C_LUT_FLUSH_MODE_MASK    0x3
+
+#define    RTL8367C_REG_L2_FLUSH_CTRL3    0x0a39
+#define    RTL8367C_L2_FLUSH_CTRL3_OFFSET    0
+#define    RTL8367C_L2_FLUSH_CTRL3_MASK    0x1
+
+#define    RTL8367C_REG_LUT_CFG2    0x0a3a
+#define    RTL8367C_LUT_IPMC_FWD_RPORT_OFFSET    1
+#define    RTL8367C_LUT_IPMC_FWD_RPORT_MASK    0x2
+#define    RTL8367C_LUT_IPMC_VID_HASH_OFFSET    0
+#define    RTL8367C_LUT_IPMC_VID_HASH_MASK    0x1
+
+#define    RTL8367C_REG_FLUSH_STATUS    0x0a3f
+#define    RTL8367C_FLUSH_STATUS_OFFSET    0
+#define    RTL8367C_FLUSH_STATUS_MASK    0x1
+
+#define    RTL8367C_REG_STORM_BCAST    0x0a40
+#define    RTL8367C_STORM_BCAST_OFFSET    0
+#define    RTL8367C_STORM_BCAST_MASK    0x7FF
+
+#define    RTL8367C_REG_STORM_MCAST    0x0a41
+#define    RTL8367C_STORM_MCAST_OFFSET    0
+#define    RTL8367C_STORM_MCAST_MASK    0x7FF
+
+#define    RTL8367C_REG_STORM_UNKOWN_UCAST    0x0a42
+#define    RTL8367C_STORM_UNKOWN_UCAST_OFFSET    0
+#define    RTL8367C_STORM_UNKOWN_UCAST_MASK    0x7FF
+
+#define    RTL8367C_REG_STORM_UNKOWN_MCAST    0x0a43
+#define    RTL8367C_STORM_UNKOWN_MCAST_OFFSET    0
+#define    RTL8367C_STORM_UNKOWN_MCAST_MASK    0x7FF
+
+#define    RTL8367C_REG_STORM_BCAST_METER_CTRL0    0x0a44
+#define    RTL8367C_STORM_BCAST_METER_CTRL0_PORT1_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_BCAST_METER_CTRL0_PORT1_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_BCAST_METER_CTRL0_PORT0_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_BCAST_METER_CTRL0_PORT0_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_BCAST_METER_CTRL1    0x0a45
+#define    RTL8367C_STORM_BCAST_METER_CTRL1_PORT3_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_BCAST_METER_CTRL1_PORT3_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_BCAST_METER_CTRL1_PORT2_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_BCAST_METER_CTRL1_PORT2_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_BCAST_METER_CTRL2    0x0a46
+#define    RTL8367C_STORM_BCAST_METER_CTRL2_PORT5_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_BCAST_METER_CTRL2_PORT5_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_BCAST_METER_CTRL2_PORT4_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_BCAST_METER_CTRL2_PORT4_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_BCAST_METER_CTRL3    0x0a47
+#define    RTL8367C_STORM_BCAST_METER_CTRL3_PORT7_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_BCAST_METER_CTRL3_PORT7_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_BCAST_METER_CTRL3_PORT6_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_BCAST_METER_CTRL3_PORT6_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_BCAST_METER_CTRL4    0x0a48
+#define    RTL8367C_STORM_BCAST_METER_CTRL4_PORT9_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_BCAST_METER_CTRL4_PORT9_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_BCAST_METER_CTRL4_PORT8_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_BCAST_METER_CTRL4_PORT8_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_BCAST_METER_CTRL5    0x0a49
+#define    RTL8367C_STORM_BCAST_METER_CTRL5_OFFSET    0
+#define    RTL8367C_STORM_BCAST_METER_CTRL5_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_MCAST_METER_CTRL0    0x0a4c
+#define    RTL8367C_STORM_MCAST_METER_CTRL0_PORT1_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_MCAST_METER_CTRL0_PORT1_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_MCAST_METER_CTRL0_PORT0_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_MCAST_METER_CTRL0_PORT0_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_MCAST_METER_CTRL1    0x0a4d
+#define    RTL8367C_STORM_MCAST_METER_CTRL1_PORT3_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_MCAST_METER_CTRL1_PORT3_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_MCAST_METER_CTRL1_PORT2_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_MCAST_METER_CTRL1_PORT2_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_MCAST_METER_CTRL2    0x0a4e
+#define    RTL8367C_STORM_MCAST_METER_CTRL2_PORT5_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_MCAST_METER_CTRL2_PORT5_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_MCAST_METER_CTRL2_PORT4_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_MCAST_METER_CTRL2_PORT4_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_MCAST_METER_CTRL3    0x0a4f
+#define    RTL8367C_STORM_MCAST_METER_CTRL3_PORT7_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_MCAST_METER_CTRL3_PORT7_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_MCAST_METER_CTRL3_PORT6_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_MCAST_METER_CTRL3_PORT6_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_MCAST_METER_CTRL4    0x0a50
+#define    RTL8367C_STORM_MCAST_METER_CTRL4_PORT9_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_MCAST_METER_CTRL4_PORT9_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_MCAST_METER_CTRL4_PORT8_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_MCAST_METER_CTRL4_PORT8_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_MCAST_METER_CTRL5    0x0a51
+#define    RTL8367C_STORM_MCAST_METER_CTRL5_OFFSET    0
+#define    RTL8367C_STORM_MCAST_METER_CTRL5_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNDA_METER_CTRL0    0x0a54
+#define    RTL8367C_STORM_UNDA_METER_CTRL0_PORT1_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_UNDA_METER_CTRL0_PORT1_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_UNDA_METER_CTRL0_PORT0_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_UNDA_METER_CTRL0_PORT0_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNDA_METER_CTRL1    0x0a55
+#define    RTL8367C_STORM_UNDA_METER_CTRL1_PORT3_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_UNDA_METER_CTRL1_PORT3_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_UNDA_METER_CTRL1_PORT2_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_UNDA_METER_CTRL1_PORT2_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNDA_METER_CTRL2    0x0a56
+#define    RTL8367C_STORM_UNDA_METER_CTRL2_PORT5_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_UNDA_METER_CTRL2_PORT5_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_UNDA_METER_CTRL2_PORT4_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_UNDA_METER_CTRL2_PORT4_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNDA_METER_CTRL3    0x0a57
+#define    RTL8367C_STORM_UNDA_METER_CTRL3_PORT7_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_UNDA_METER_CTRL3_PORT7_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_UNDA_METER_CTRL3_PORT6_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_UNDA_METER_CTRL3_PORT6_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNDA_METER_CTRL4    0x0a58
+#define    RTL8367C_STORM_UNDA_METER_CTRL4_PORT9_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_UNDA_METER_CTRL4_PORT9_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_UNDA_METER_CTRL4_PORT8_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_UNDA_METER_CTRL4_PORT8_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNDA_METER_CTRL5    0x0a59
+#define    RTL8367C_STORM_UNDA_METER_CTRL5_OFFSET    0
+#define    RTL8367C_STORM_UNDA_METER_CTRL5_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNMC_METER_CTRL0    0x0a5c
+#define    RTL8367C_STORM_UNMC_METER_CTRL0_PORT1_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_UNMC_METER_CTRL0_PORT1_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_UNMC_METER_CTRL0_PORT0_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_UNMC_METER_CTRL0_PORT0_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNMC_METER_CTRL1    0x0a5d
+#define    RTL8367C_STORM_UNMC_METER_CTRL1_PORT3_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_UNMC_METER_CTRL1_PORT3_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_UNMC_METER_CTRL1_PORT2_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_UNMC_METER_CTRL1_PORT2_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNMC_METER_CTRL2    0x0a5e
+#define    RTL8367C_STORM_UNMC_METER_CTRL2_PORT5_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_UNMC_METER_CTRL2_PORT5_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_UNMC_METER_CTRL2_PORT4_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_UNMC_METER_CTRL2_PORT4_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNMC_METER_CTRL3    0x0a5f
+#define    RTL8367C_STORM_UNMC_METER_CTRL3_PORT7_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_UNMC_METER_CTRL3_PORT7_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_UNMC_METER_CTRL3_PORT6_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_UNMC_METER_CTRL3_PORT6_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_EXT_CFG    0x0a60
+#define    RTL8367C_STORM_EXT_EN_PORTMASK_EXT_OFFSET    14
+#define    RTL8367C_STORM_EXT_EN_PORTMASK_EXT_MASK    0x4000
+#define    RTL8367C_STORM_UNKNOWN_MCAST_EXT_EN_OFFSET    13
+#define    RTL8367C_STORM_UNKNOWN_MCAST_EXT_EN_MASK    0x2000
+#define    RTL8367C_STORM_UNKNOWN_UCAST_EXT_EN_OFFSET    12
+#define    RTL8367C_STORM_UNKNOWN_UCAST_EXT_EN_MASK    0x1000
+#define    RTL8367C_STORM_MCAST_EXT_EN_OFFSET    11
+#define    RTL8367C_STORM_MCAST_EXT_EN_MASK    0x800
+#define    RTL8367C_STORM_BCAST_EXT_EN_OFFSET    10
+#define    RTL8367C_STORM_BCAST_EXT_EN_MASK    0x400
+#define    RTL8367C_STORM_EXT_EN_PORTMASK_OFFSET    0
+#define    RTL8367C_STORM_EXT_EN_PORTMASK_MASK    0x3FF
+
+#define    RTL8367C_REG_STORM_EXT_MTRIDX_CFG0    0x0a61
+#define    RTL8367C_MC_STORM_EXT_METERIDX_OFFSET    8
+#define    RTL8367C_MC_STORM_EXT_METERIDX_MASK    0x3F00
+#define    RTL8367C_BC_STORM_EXT_METERIDX_OFFSET    0
+#define    RTL8367C_BC_STORM_EXT_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_EXT_MTRIDX_CFG1    0x0a62
+#define    RTL8367C_UNMC_STORM_EXT_METERIDX_OFFSET    8
+#define    RTL8367C_UNMC_STORM_EXT_METERIDX_MASK    0x3F00
+#define    RTL8367C_UNUC_STORM_EXT_METERIDX_OFFSET    0
+#define    RTL8367C_UNUC_STORM_EXT_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNMC_METER_CTRL4    0x0a63
+#define    RTL8367C_STORM_UNMC_METER_CTRL4_PORT9_METERIDX_OFFSET    8
+#define    RTL8367C_STORM_UNMC_METER_CTRL4_PORT9_METERIDX_MASK    0x3F00
+#define    RTL8367C_STORM_UNMC_METER_CTRL4_PORT8_METERIDX_OFFSET    0
+#define    RTL8367C_STORM_UNMC_METER_CTRL4_PORT8_METERIDX_MASK    0x3F
+
+#define    RTL8367C_REG_STORM_UNMC_METER_CTRL5    0x0a64
+#define    RTL8367C_STORM_UNMC_METER_CTRL5_OFFSET    0
+#define    RTL8367C_STORM_UNMC_METER_CTRL5_MASK    0x3F
+
+#define    RTL8367C_REG_OAM_PARSER_CTRL0    0x0a70
+#define    RTL8367C_PORT7_PARACT_OFFSET    14
+#define    RTL8367C_PORT7_PARACT_MASK    0xC000
+#define    RTL8367C_PORT6_PARACT_OFFSET    12
+#define    RTL8367C_PORT6_PARACT_MASK    0x3000
+#define    RTL8367C_PORT5_PARACT_OFFSET    10
+#define    RTL8367C_PORT5_PARACT_MASK    0xC00
+#define    RTL8367C_PORT4_PARACT_OFFSET    8
+#define    RTL8367C_PORT4_PARACT_MASK    0x300
+#define    RTL8367C_PORT3_PARACT_OFFSET    6
+#define    RTL8367C_PORT3_PARACT_MASK    0xC0
+#define    RTL8367C_PORT2_PARACT_OFFSET    4
+#define    RTL8367C_PORT2_PARACT_MASK    0x30
+#define    RTL8367C_PORT1_PARACT_OFFSET    2
+#define    RTL8367C_PORT1_PARACT_MASK    0xC
+#define    RTL8367C_PORT0_PARACT_OFFSET    0
+#define    RTL8367C_PORT0_PARACT_MASK    0x3
+
+#define    RTL8367C_REG_OAM_PARSER_CTRL1    0x0a71
+#define    RTL8367C_PORT10_PARACT_OFFSET    4
+#define    RTL8367C_PORT10_PARACT_MASK    0x30
+#define    RTL8367C_PORT9_PARACT_OFFSET    2
+#define    RTL8367C_PORT9_PARACT_MASK    0xC
+#define    RTL8367C_PORT8_PARACT_OFFSET    0
+#define    RTL8367C_PORT8_PARACT_MASK    0x3
+
+#define    RTL8367C_REG_OAM_MULTIPLEXER_CTRL0    0x0a72
+#define    RTL8367C_PORT7_MULACT_OFFSET    14
+#define    RTL8367C_PORT7_MULACT_MASK    0xC000
+#define    RTL8367C_PORT6_MULACT_OFFSET    12
+#define    RTL8367C_PORT6_MULACT_MASK    0x3000
+#define    RTL8367C_PORT5_MULACT_OFFSET    10
+#define    RTL8367C_PORT5_MULACT_MASK    0xC00
+#define    RTL8367C_PORT4_MULACT_OFFSET    8
+#define    RTL8367C_PORT4_MULACT_MASK    0x300
+#define    RTL8367C_PORT3_MULACT_OFFSET    6
+#define    RTL8367C_PORT3_MULACT_MASK    0xC0
+#define    RTL8367C_PORT2_MULACT_OFFSET    4
+#define    RTL8367C_PORT2_MULACT_MASK    0x30
+#define    RTL8367C_PORT1_MULACT_OFFSET    2
+#define    RTL8367C_PORT1_MULACT_MASK    0xC
+#define    RTL8367C_PORT0_MULACT_OFFSET    0
+#define    RTL8367C_PORT0_MULACT_MASK    0x3
+
+#define    RTL8367C_REG_OAM_MULTIPLEXER_CTRL1    0x0a73
+#define    RTL8367C_PORT10_MULACT_OFFSET    4
+#define    RTL8367C_PORT10_MULACT_MASK    0x30
+#define    RTL8367C_PORT9_MULACT_OFFSET    2
+#define    RTL8367C_PORT9_MULACT_MASK    0xC
+#define    RTL8367C_PORT8_MULACT_OFFSET    0
+#define    RTL8367C_PORT8_MULACT_MASK    0x3
+
+#define    RTL8367C_REG_OAM_CTRL    0x0a74
+#define    RTL8367C_OAM_CTRL_OFFSET    0
+#define    RTL8367C_OAM_CTRL_MASK    0x1
+
+#define    RTL8367C_REG_DOT1X_PORT_ENABLE    0x0a80
+#define    RTL8367C_DOT1X_PORT_ENABLE_OFFSET    0
+#define    RTL8367C_DOT1X_PORT_ENABLE_MASK    0x7FF
+
+#define    RTL8367C_REG_DOT1X_MAC_ENABLE    0x0a81
+#define    RTL8367C_DOT1X_MAC_ENABLE_OFFSET    0
+#define    RTL8367C_DOT1X_MAC_ENABLE_MASK    0x7FF
+
+#define    RTL8367C_REG_DOT1X_PORT_AUTH    0x0a82
+#define    RTL8367C_DOT1X_PORT_AUTH_OFFSET    0
+#define    RTL8367C_DOT1X_PORT_AUTH_MASK    0x7FF
+
+#define    RTL8367C_REG_DOT1X_PORT_OPDIR    0x0a83
+#define    RTL8367C_DOT1X_PORT_OPDIR_OFFSET    0
+#define    RTL8367C_DOT1X_PORT_OPDIR_MASK    0x7FF
+
+#define    RTL8367C_REG_DOT1X_UNAUTH_ACT_W0    0x0a84
+#define    RTL8367C_DOT1X_PORT7_UNAUTHBH_OFFSET    14
+#define    RTL8367C_DOT1X_PORT7_UNAUTHBH_MASK    0xC000
+#define    RTL8367C_DOT1X_PORT6_UNAUTHBH_OFFSET    12
+#define    RTL8367C_DOT1X_PORT6_UNAUTHBH_MASK    0x3000
+#define    RTL8367C_DOT1X_PORT5_UNAUTHBH_OFFSET    10
+#define    RTL8367C_DOT1X_PORT5_UNAUTHBH_MASK    0xC00
+#define    RTL8367C_DOT1X_PORT4_UNAUTHBH_OFFSET    8
+#define    RTL8367C_DOT1X_PORT4_UNAUTHBH_MASK    0x300
+#define    RTL8367C_DOT1X_PORT3_UNAUTHBH_OFFSET    6
+#define    RTL8367C_DOT1X_PORT3_UNAUTHBH_MASK    0xC0
+#define    RTL8367C_DOT1X_PORT2_UNAUTHBH_OFFSET    4
+#define    RTL8367C_DOT1X_PORT2_UNAUTHBH_MASK    0x30
+#define    RTL8367C_DOT1X_PORT1_UNAUTHBH_OFFSET    2
+#define    RTL8367C_DOT1X_PORT1_UNAUTHBH_MASK    0xC
+#define    RTL8367C_DOT1X_PORT0_UNAUTHBH_OFFSET    0
+#define    RTL8367C_DOT1X_PORT0_UNAUTHBH_MASK    0x3
+
+#define    RTL8367C_REG_DOT1X_UNAUTH_ACT_W1    0x0a85
+#define    RTL8367C_DOT1X_PORT10_UNAUTHBH_OFFSET    4
+#define    RTL8367C_DOT1X_PORT10_UNAUTHBH_MASK    0x30
+#define    RTL8367C_DOT1X_PORT9_UNAUTHBH_OFFSET    2
+#define    RTL8367C_DOT1X_PORT9_UNAUTHBH_MASK    0xC
+#define    RTL8367C_DOT1X_PORT8_UNAUTHBH_OFFSET    0
+#define    RTL8367C_DOT1X_PORT8_UNAUTHBH_MASK    0x3
+
+#define    RTL8367C_REG_DOT1X_CFG    0x0a86
+#define    RTL8367C_DOT1X_GVOPDIR_OFFSET    6
+#define    RTL8367C_DOT1X_GVOPDIR_MASK    0x40
+#define    RTL8367C_DOT1X_MAC_OPDIR_OFFSET    5
+#define    RTL8367C_DOT1X_MAC_OPDIR_MASK    0x20
+#define    RTL8367C_DOT1X_GVIDX_OFFSET    0
+#define    RTL8367C_DOT1X_GVIDX_MASK    0x1F
+
+#define    RTL8367C_REG_L2_LRN_CNT_CTRL0    0x0a87
+#define    RTL8367C_L2_LRN_CNT_CTRL0_OFFSET    0
+#define    RTL8367C_L2_LRN_CNT_CTRL0_MASK    0x1FFF
+
+#define    RTL8367C_REG_L2_LRN_CNT_CTRL1    0x0a88
+#define    RTL8367C_L2_LRN_CNT_CTRL1_OFFSET    0
+#define    RTL8367C_L2_LRN_CNT_CTRL1_MASK    0x1FFF
+
+#define    RTL8367C_REG_L2_LRN_CNT_CTRL2    0x0a89
+#define    RTL8367C_L2_LRN_CNT_CTRL2_OFFSET    0
+#define    RTL8367C_L2_LRN_CNT_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_L2_LRN_CNT_CTRL3    0x0a8a
+#define    RTL8367C_L2_LRN_CNT_CTRL3_OFFSET    0
+#define    RTL8367C_L2_LRN_CNT_CTRL3_MASK    0x1FFF
+
+#define    RTL8367C_REG_L2_LRN_CNT_CTRL4    0x0a8b
+#define    RTL8367C_L2_LRN_CNT_CTRL4_OFFSET    0
+#define    RTL8367C_L2_LRN_CNT_CTRL4_MASK    0x1FFF
+
+#define    RTL8367C_REG_L2_LRN_CNT_CTRL5    0x0a8c
+#define    RTL8367C_L2_LRN_CNT_CTRL5_OFFSET    0
+#define    RTL8367C_L2_LRN_CNT_CTRL5_MASK    0x1FFF
+
+#define    RTL8367C_REG_L2_LRN_CNT_CTRL6    0x0a8d
+#define    RTL8367C_L2_LRN_CNT_CTRL6_OFFSET    0
+#define    RTL8367C_L2_LRN_CNT_CTRL6_MASK    0x1FFF
+
+#define    RTL8367C_REG_L2_LRN_CNT_CTRL7    0x0a8e
+#define    RTL8367C_L2_LRN_CNT_CTRL7_OFFSET    0
+#define    RTL8367C_L2_LRN_CNT_CTRL7_MASK    0x1FFF
+
+#define    RTL8367C_REG_L2_LRN_CNT_CTRL8    0x0a8f
+#define    RTL8367C_L2_LRN_CNT_CTRL8_OFFSET    0
+#define    RTL8367C_L2_LRN_CNT_CTRL8_MASK    0x1FFF
+
+#define    RTL8367C_REG_L2_LRN_CNT_CTRL9    0x0a90
+#define    RTL8367C_L2_LRN_CNT_CTRL9_OFFSET    0
+#define    RTL8367C_L2_LRN_CNT_CTRL9_MASK    0x1FFF
+
+#define    RTL8367C_REG_L2_LRN_CNT_CTRL10    0x0a92
+#define    RTL8367C_L2_LRN_CNT_CTRL10_OFFSET    0
+#define    RTL8367C_L2_LRN_CNT_CTRL10_MASK    0x1FFF
+
+#define    RTL8367C_REG_LUT_LRN_UNDER_STATUS    0x0a91
+#define    RTL8367C_LUT_LRN_UNDER_STATUS_OFFSET    0
+#define    RTL8367C_LUT_LRN_UNDER_STATUS_MASK    0x7FF
+
+#define    RTL8367C_REG_L2_SA_MOVING_FORBID    0x0aa0
+#define    RTL8367C_L2_SA_MOVING_FORBID_OFFSET    0
+#define    RTL8367C_L2_SA_MOVING_FORBID_MASK    0x7FF
+
+#define    RTL8367C_REG_DRPORT_LEARN_CTRL    0x0aa1
+#define    RTL8367C_FORBID1_OFFSET    1
+#define    RTL8367C_FORBID1_MASK    0x2
+#define    RTL8367C_FORBID0_OFFSET    0
+#define    RTL8367C_FORBID0_MASK    0x1
+
+#define    RTL8367C_REG_L2_DUMMY02    0x0aa2
+
+#define    RTL8367C_REG_L2_DUMMY03    0x0aa3
+
+#define    RTL8367C_REG_L2_DUMMY04    0x0aa4
+
+#define    RTL8367C_REG_L2_DUMMY05    0x0aa5
+
+#define    RTL8367C_REG_L2_DUMMY06    0x0aa6
+
+#define    RTL8367C_REG_L2_DUMMY07    0x0aa7
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_00    0x0AC0
+#define    RTL8367C_IPMC_GROUP_PMSK_00_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_00_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_01    0x0AC1
+#define    RTL8367C_IPMC_GROUP_PMSK_01_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_01_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_02    0x0AC2
+#define    RTL8367C_IPMC_GROUP_PMSK_02_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_02_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_03    0x0AC3
+#define    RTL8367C_IPMC_GROUP_PMSK_03_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_03_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_04    0x0AC4
+#define    RTL8367C_IPMC_GROUP_PMSK_04_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_04_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_05    0x0AC5
+#define    RTL8367C_IPMC_GROUP_PMSK_05_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_05_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_06    0x0AC6
+#define    RTL8367C_IPMC_GROUP_PMSK_06_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_06_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_07    0x0AC7
+#define    RTL8367C_IPMC_GROUP_PMSK_07_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_07_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_08    0x0AC8
+#define    RTL8367C_IPMC_GROUP_PMSK_08_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_08_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_09    0x0AC9
+#define    RTL8367C_IPMC_GROUP_PMSK_09_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_09_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_10    0x0ACA
+#define    RTL8367C_IPMC_GROUP_PMSK_10_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_10_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_11    0x0ACB
+#define    RTL8367C_IPMC_GROUP_PMSK_11_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_11_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_12    0x0ACC
+#define    RTL8367C_IPMC_GROUP_PMSK_12_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_12_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_13    0x0ACD
+#define    RTL8367C_IPMC_GROUP_PMSK_13_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_13_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_14    0x0ACE
+#define    RTL8367C_IPMC_GROUP_PMSK_14_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_14_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_15    0x0ACF
+#define    RTL8367C_IPMC_GROUP_PMSK_15_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_15_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_16    0x0AD0
+#define    RTL8367C_IPMC_GROUP_PMSK_16_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_16_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_17    0x0AD1
+#define    RTL8367C_IPMC_GROUP_PMSK_17_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_17_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_18    0x0AD2
+#define    RTL8367C_IPMC_GROUP_PMSK_18_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_18_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_19    0x0AD3
+#define    RTL8367C_IPMC_GROUP_PMSK_19_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_19_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_20    0x0AD4
+#define    RTL8367C_IPMC_GROUP_PMSK_20_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_20_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_21    0x0AD5
+#define    RTL8367C_IPMC_GROUP_PMSK_21_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_21_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_22    0x0AD6
+#define    RTL8367C_IPMC_GROUP_PMSK_22_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_22_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_23    0x0AD7
+#define    RTL8367C_IPMC_GROUP_PMSK_23_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_23_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_24    0x0AD8
+#define    RTL8367C_IPMC_GROUP_PMSK_24_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_24_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_25    0x0AD9
+#define    RTL8367C_IPMC_GROUP_PMSK_25_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_25_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_26    0x0ADA
+#define    RTL8367C_IPMC_GROUP_PMSK_26_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_26_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_27    0x0ADB
+#define    RTL8367C_IPMC_GROUP_PMSK_27_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_27_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_28    0x0ADC
+#define    RTL8367C_IPMC_GROUP_PMSK_28_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_28_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_29    0x0ADD
+#define    RTL8367C_IPMC_GROUP_PMSK_29_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_29_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_30    0x0ADE
+#define    RTL8367C_IPMC_GROUP_PMSK_30_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_30_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_31    0x0ADF
+#define    RTL8367C_IPMC_GROUP_PMSK_31_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_31_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_32    0x0AE0
+#define    RTL8367C_IPMC_GROUP_PMSK_32_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_32_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_33    0x0AE1
+#define    RTL8367C_IPMC_GROUP_PMSK_33_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_33_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_34    0x0AE2
+#define    RTL8367C_IPMC_GROUP_PMSK_34_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_34_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_35    0x0AE3
+#define    RTL8367C_IPMC_GROUP_PMSK_35_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_35_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_36    0x0AE4
+#define    RTL8367C_IPMC_GROUP_PMSK_36_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_36_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_37    0x0AE5
+#define    RTL8367C_IPMC_GROUP_PMSK_37_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_37_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_38    0x0AE6
+#define    RTL8367C_IPMC_GROUP_PMSK_38_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_38_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_39    0x0AE7
+#define    RTL8367C_IPMC_GROUP_PMSK_39_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_39_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_40    0x0AE8
+#define    RTL8367C_IPMC_GROUP_PMSK_40_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_40_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_41    0x0AE9
+#define    RTL8367C_IPMC_GROUP_PMSK_41_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_41_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_42    0x0AEA
+#define    RTL8367C_IPMC_GROUP_PMSK_42_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_42_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_43    0x0AEB
+#define    RTL8367C_IPMC_GROUP_PMSK_43_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_43_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_44    0x0AEC
+#define    RTL8367C_IPMC_GROUP_PMSK_44_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_44_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_45    0x0AED
+#define    RTL8367C_IPMC_GROUP_PMSK_45_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_45_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_46    0x0AEE
+#define    RTL8367C_IPMC_GROUP_PMSK_46_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_46_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_47    0x0AEF
+#define    RTL8367C_IPMC_GROUP_PMSK_47_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_47_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_48    0x0AF0
+#define    RTL8367C_IPMC_GROUP_PMSK_48_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_48_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_49    0x0AF1
+#define    RTL8367C_IPMC_GROUP_PMSK_49_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_49_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_50    0x0AF2
+#define    RTL8367C_IPMC_GROUP_PMSK_50_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_50_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_51    0x0AF3
+#define    RTL8367C_IPMC_GROUP_PMSK_51_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_51_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_52    0x0AF4
+#define    RTL8367C_IPMC_GROUP_PMSK_52_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_52_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_53    0x0AF5
+#define    RTL8367C_IPMC_GROUP_PMSK_53_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_53_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_54    0x0AF6
+#define    RTL8367C_IPMC_GROUP_PMSK_54_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_54_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_55    0x0AF7
+#define    RTL8367C_IPMC_GROUP_PMSK_55_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_55_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_56    0x0AF8
+#define    RTL8367C_IPMC_GROUP_PMSK_56_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_56_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_57    0x0AF9
+#define    RTL8367C_IPMC_GROUP_PMSK_57_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_57_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_58    0x0AFA
+#define    RTL8367C_IPMC_GROUP_PMSK_58_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_58_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_59    0x0AFB
+#define    RTL8367C_IPMC_GROUP_PMSK_59_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_59_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_60    0x0AFC
+#define    RTL8367C_IPMC_GROUP_PMSK_60_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_60_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_61    0x0AFD
+#define    RTL8367C_IPMC_GROUP_PMSK_61_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_61_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_62    0x0AFE
+#define    RTL8367C_IPMC_GROUP_PMSK_62_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_62_MASK    0x7FF
+
+#define    RTL8367C_REG_IPMC_GROUP_PMSK_63    0x0AFF
+#define    RTL8367C_IPMC_GROUP_PMSK_63_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_PMSK_63_MASK    0x7FF
+
+/* (16'h0b00)mltvlan_reg */
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY0_CTRL0    0x0b00
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY0_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY0_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY0_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY0_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY0_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY0_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY0_CTRL1    0x0b01
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY0_CTRL2    0x0b02
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY0_CTRL3    0x0b03
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY0_CTRL4    0x0b04
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY1_CTRL0    0x0b05
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY1_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY1_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY1_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY1_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY1_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY1_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY1_CTRL1    0x0b06
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY1_CTRL2    0x0b07
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY1_CTRL3    0x0b08
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY1_CTRL4    0x0b09
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY2_CTRL0    0x0b0a
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY2_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY2_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY2_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY2_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY2_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY2_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY2_CTRL1    0x0b0b
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY2_CTRL2    0x0b0c
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY2_CTRL3    0x0b0d
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY2_CTRL4    0x0b0e
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY3_CTRL0    0x0b0f
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY3_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY3_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY3_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY3_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY3_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY3_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY3_CTRL1    0x0b10
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY3_CTRL2    0x0b11
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY3_CTRL3    0x0b12
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY3_CTRL4    0x0b13
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY4_CTRL0    0x0b14
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY4_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY4_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY4_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY4_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY4_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY4_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY4_CTRL1    0x0b15
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY4_CTRL2    0x0b16
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY4_CTRL3    0x0b17
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY4_CTRL4    0x0b18
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY5_CTRL0    0x0b19
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY5_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY5_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY5_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY5_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY5_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY5_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY5_CTRL1    0x0b1a
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY5_CTRL2    0x0b1b
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY5_CTRL3    0x0b1c
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY5_CTRL4    0x0b1d
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY6_CTRL0    0x0b1e
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY6_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY6_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY6_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY6_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY6_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY6_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY6_CTRL1    0x0b1f
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY6_CTRL2    0x0b20
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY6_CTRL3    0x0b21
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY6_CTRL4    0x0b22
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY7_CTRL0    0x0b23
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY7_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY7_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY7_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY7_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY7_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY7_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY7_CTRL1    0x0b24
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY7_CTRL2    0x0b25
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY7_CTRL3    0x0b26
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY7_CTRL4    0x0b27
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY8_CTRL0    0x0b28
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY8_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY8_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY8_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY8_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY8_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY8_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY8_CTRL1    0x0b29
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY8_CTRL2    0x0b2a
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY8_CTRL3    0x0b2b
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY8_CTRL4    0x0b2c
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY9_CTRL0    0x0b2d
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY9_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY9_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY9_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY9_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY9_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY9_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY9_CTRL1    0x0b2e
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY9_CTRL2    0x0b2f
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY9_CTRL3    0x0b30
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY9_CTRL4    0x0b31
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY10_CTRL0    0x0b32
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY10_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY10_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY10_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY10_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY10_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY10_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY10_CTRL1    0x0b33
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY10_CTRL2    0x0b34
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY10_CTRL3    0x0b35
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY10_CTRL4    0x0b36
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY11_CTRL0    0x0b37
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY11_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY11_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY11_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY11_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY11_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY11_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY11_CTRL1    0x0b38
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY11_CTRL2    0x0b39
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY11_CTRL3    0x0b3a
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY11_CTRL4    0x0b3b
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY12_CTRL0    0x0b3c
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY12_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY12_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY12_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY12_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY12_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY12_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY12_CTRL1    0x0b3d
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY12_CTRL2    0x0b3e
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY12_CTRL3    0x0b3f
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY12_CTRL4    0x0b40
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY13_CTRL0    0x0b41
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY13_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY13_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY13_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY13_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY13_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY13_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY13_CTRL1    0x0b42
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY13_CTRL2    0x0b43
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY13_CTRL3    0x0b44
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY13_CTRL4    0x0b45
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY14_CTRL0    0x0b46
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY14_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY14_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY14_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY14_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY14_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY14_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY14_CTRL1    0x0b47
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY14_CTRL2    0x0b48
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY14_CTRL3    0x0b49
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY14_CTRL4    0x0b4a
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY15_CTRL0    0x0b4b
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY15_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY15_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY15_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY15_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY15_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY15_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY15_CTRL1    0x0b4c
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY15_CTRL2    0x0b4d
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY15_CTRL3    0x0b4e
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY15_CTRL4    0x0b4f
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY16_CTRL0    0x0b50
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY16_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY16_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY16_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY16_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY16_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY16_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY16_CTRL1    0x0b51
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY16_CTRL2    0x0b52
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY16_CTRL3    0x0b53
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY16_CTRL4    0x0b54
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY17_CTRL0    0x0b55
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY17_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY17_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY17_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY17_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY17_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY17_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY17_CTRL1    0x0b56
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY17_CTRL2    0x0b57
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY17_CTRL3    0x0b58
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY17_CTRL4    0x0b59
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY18_CTRL0    0x0b5a
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY18_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY18_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY18_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY18_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY18_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY18_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY18_CTRL1    0x0b5b
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY18_CTRL2    0x0b5c
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY18_CTRL3    0x0b5d
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY18_CTRL4    0x0b5e
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY19_CTRL0    0x0b5f
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY19_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY19_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY19_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY19_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY19_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY19_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY19_CTRL1    0x0b60
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY19_CTRL2    0x0b61
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY19_CTRL3    0x0b62
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY19_CTRL4    0x0b63
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY20_CTRL0    0x0b64
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY20_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY20_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY20_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY20_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY20_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY20_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY20_CTRL1    0x0b65
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY20_CTRL2    0x0b66
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY20_CTRL3    0x0b67
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY20_CTRL4    0x0b68
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY21_CTRL0    0x0b69
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY21_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY21_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY21_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY21_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY21_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY21_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY21_CTRL1    0x0b6a
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY21_CTRL2    0x0b6b
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY21_CTRL3    0x0b6c
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY21_CTRL4    0x0b6d
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY22_CTRL0    0x0b6e
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY22_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY22_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY22_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY22_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY22_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY22_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY22_CTRL1    0x0b6f
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY22_CTRL2    0x0b70
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY22_CTRL3    0x0b71
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY22_CTRL4    0x0b72
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY23_CTRL0    0x0b73
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY23_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY23_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY23_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY23_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY23_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY23_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY23_CTRL1    0x0b74
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY23_CTRL2    0x0b75
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY23_CTRL3    0x0b76
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY23_CTRL4    0x0b77
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY24_CTRL0    0x0b78
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY24_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY24_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY24_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY24_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY24_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY24_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY24_CTRL1    0x0b79
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY24_CTRL2    0x0b7a
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY24_CTRL3    0x0b7b
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY24_CTRL4    0x0b7c
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY25_CTRL0    0x0b7d
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY25_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY25_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY25_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY25_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY25_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY25_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY25_CTRL1    0x0b7e
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY25_CTRL2    0x0b7f
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY25_CTRL3    0x0b80
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY25_CTRL4    0x0b81
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY26_CTRL0    0x0b82
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY26_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY26_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY26_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY26_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY26_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY26_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY26_CTRL1    0x0b83
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY26_CTRL2    0x0b84
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY26_CTRL3    0x0b85
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY26_CTRL4    0x0b86
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY27_CTRL0    0x0b87
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY27_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY27_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY27_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY27_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY27_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY27_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY27_CTRL1    0x0b88
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY27_CTRL2    0x0b89
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY27_CTRL3    0x0b8a
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY27_CTRL4    0x0b8b
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY28_CTRL0    0x0b8c
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY28_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY28_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY28_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY28_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY28_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY28_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY28_CTRL1    0x0b8d
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY28_CTRL2    0x0b8e
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY28_CTRL3    0x0b8f
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY28_CTRL4    0x0b90
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY29_CTRL0    0x0b91
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY29_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY29_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY29_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY29_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY29_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY29_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY29_CTRL1    0x0b92
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY29_CTRL2    0x0b93
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY29_CTRL3    0x0b94
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY29_CTRL4    0x0b95
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY30_CTRL0    0x0b96
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY30_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY30_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY30_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY30_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY30_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY30_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY30_CTRL1    0x0b97
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY30_CTRL2    0x0b98
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY30_CTRL3    0x0b99
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY30_CTRL4    0x0b9a
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY31_CTRL0    0x0b9b
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY31_CTRL0_VALID_OFFSET    7
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY31_CTRL0_VALID_MASK    0x80
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY31_CTRL0_FORMAT_OFFSET    6
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY31_CTRL0_FORMAT_MASK    0x40
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY31_CTRL0_SVIDX_OFFSET    0
+#define    RTL8367C_SVLAN_MCAST2S_ENTRY31_CTRL0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY31_CTRL1    0x0b9c
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY31_CTRL2    0x0b9d
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY31_CTRL3    0x0b9e
+
+#define    RTL8367C_REG_SVLAN_MCAST2S_ENTRY31_CTRL4    0x0b9f
+
+#define    RTL8367C_REG_MLTVLAN_DUMMY_0    0x0ba0
+
+#define    RTL8367C_REG_MLTVLAN_DUMMY_1    0x0ba1
+
+#define    RTL8367C_REG_MLTVLAN_DUMMY_2    0x0ba2
+
+#define    RTL8367C_REG_MLTVLAN_DUMMY_3    0x0ba3
+
+#define    RTL8367C_REG_MLTVLAN_DUMMY_4    0x0ba4
+
+#define    RTL8367C_REG_MLTVLAN_DUMMY_5    0x0ba5
+
+#define    RTL8367C_REG_MLTVLAN_DUMMY_6    0x0ba6
+
+#define    RTL8367C_REG_MLTVLAN_DUMMY_7    0x0ba7
+
+/* (16'h0c00)svlan_reg */
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG0_CTRL1    0x0c01
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG0_CTRL2    0x0c02
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG0_CTRL3    0x0c03
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG1_CTRL1    0x0c04
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG1_CTRL2    0x0c05
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG1_CTRL3    0x0c06
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG2_CTRL1    0x0c07
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG2_CTRL2    0x0c08
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG2_CTRL3    0x0c09
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG3_CTRL1    0x0c0a
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG3_CTRL2    0x0c0b
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG3_CTRL3    0x0c0c
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG4_CTRL1    0x0c0d
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG4_CTRL2    0x0c0e
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG4_CTRL3    0x0c0f
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG5_CTRL1    0x0c10
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG5_CTRL2    0x0c11
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG5_CTRL3    0x0c12
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG6_CTRL1    0x0c13
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG6_CTRL2    0x0c14
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG6_CTRL3    0x0c15
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG7_CTRL1    0x0c16
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG7_CTRL2    0x0c17
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG7_CTRL3    0x0c18
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG8_CTRL1    0x0c19
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG8_CTRL2    0x0c1a
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG8_CTRL3    0x0c1b
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG9_CTRL1    0x0c1c
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG9_CTRL2    0x0c1d
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG9_CTRL3    0x0c1e
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG10_CTRL1    0x0c1f
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG10_CTRL2    0x0c20
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG10_CTRL3    0x0c21
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG11_CTRL1    0x0c22
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG11_CTRL2    0x0c23
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG11_CTRL3    0x0c24
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG12_CTRL1    0x0c25
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG12_CTRL2    0x0c26
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG12_CTRL3    0x0c27
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG13_CTRL1    0x0c28
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG13_CTRL2    0x0c29
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG13_CTRL3    0x0c2a
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG14_CTRL1    0x0c2b
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG14_CTRL2    0x0c2c
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG14_CTRL3    0x0c2d
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG15_CTRL1    0x0c2e
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG15_CTRL2    0x0c2f
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG15_CTRL3    0x0c30
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG16_CTRL1    0x0c31
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG16_CTRL2    0x0c32
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG16_CTRL3    0x0c33
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG17_CTRL1    0x0c34
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG17_CTRL2    0x0c35
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG17_CTRL3    0x0c36
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG18_CTRL1    0x0c37
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG18_CTRL2    0x0c38
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG18_CTRL3    0x0c39
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG19_CTRL1    0x0c3a
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG19_CTRL2    0x0c3b
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG19_CTRL3    0x0c3c
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG20_CTRL1    0x0c3d
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG20_CTRL2    0x0c3e
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG20_CTRL3    0x0c3f
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG21_CTRL1    0x0c40
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG21_CTRL2    0x0c41
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG21_CTRL3    0x0c42
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG22_CTRL1    0x0c43
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG22_CTRL2    0x0c44
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG22_CTRL3    0x0c45
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG23_CTRL1    0x0c46
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG23_CTRL2    0x0c47
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG23_CTRL3    0x0c48
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG24_CTRL1    0x0c49
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG24_CTRL2    0x0c4a
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG24_CTRL3    0x0c4b
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG25_CTRL1    0x0c4c
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG25_CTRL2    0x0c4d
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG25_CTRL3    0x0c4e
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG26_CTRL1    0x0c4f
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG26_CTRL2    0x0c50
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG26_CTRL3    0x0c51
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG27_CTRL1    0x0c52
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG27_CTRL2    0x0c53
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG27_CTRL3    0x0c54
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG28_CTRL1    0x0c55
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG28_CTRL2    0x0c56
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG28_CTRL3    0x0c57
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG29_CTRL1    0x0c58
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG29_CTRL2    0x0c59
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG29_CTRL3    0x0c5a
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG30_CTRL1    0x0c5b
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG30_CTRL2    0x0c5c
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG30_CTRL3    0x0c5d
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG31_CTRL1    0x0c5e
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG31_CTRL2    0x0c5f
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG31_CTRL3    0x0c60
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG32_CTRL1    0x0c61
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG32_CTRL2    0x0c62
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG32_CTRL3    0x0c63
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG33_CTRL1    0x0c64
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG33_CTRL2    0x0c65
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG33_CTRL3    0x0c66
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG34_CTRL1    0x0c67
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG34_CTRL2    0x0c68
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG34_CTRL3    0x0c69
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG35_CTRL1    0x0c6a
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG35_CTRL2    0x0c6b
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG35_CTRL3    0x0c6c
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG36_CTRL1    0x0c6d
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG36_CTRL2    0x0c6e
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG36_CTRL3    0x0c6f
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG37_CTRL1    0x0c70
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG37_CTRL2    0x0c71
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG37_CTRL3    0x0c72
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG38_CTRL1    0x0c73
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG38_CTRL2    0x0c74
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG38_CTRL3    0x0c75
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG39_CTRL1    0x0c76
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG39_CTRL2    0x0c77
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG39_CTRL3    0x0c78
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG40_CTRL1    0x0c79
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG40_CTRL2    0x0c7a
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG40_CTRL3    0x0c7b
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG41_CTRL1    0x0c7c
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG41_CTRL2    0x0c7d
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG41_CTRL3    0x0c7e
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG42_CTRL1    0x0c7f
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG42_CTRL2    0x0c80
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG42_CTRL3    0x0c81
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG43_CTRL1    0x0c82
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG43_CTRL2    0x0c83
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG43_CTRL3    0x0c84
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG44_CTRL1    0x0c85
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG44_CTRL2    0x0c86
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG44_CTRL3    0x0c87
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG45_CTRL1    0x0c88
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG45_CTRL2    0x0c89
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG45_CTRL3    0x0c8a
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG46_CTRL1    0x0c8b
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG46_CTRL2    0x0c8c
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG46_CTRL3    0x0c8d
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG47_CTRL1    0x0c8e
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG47_CTRL2    0x0c8f
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG47_CTRL3    0x0c90
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG48_CTRL1    0x0c91
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG48_CTRL2    0x0c92
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG48_CTRL3    0x0c93
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG49_CTRL1    0x0c94
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG49_CTRL2    0x0c95
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG49_CTRL3    0x0c96
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG50_CTRL1    0x0c97
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG50_CTRL2    0x0c98
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG50_CTRL3    0x0c99
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG51_CTRL1    0x0c9a
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG51_CTRL2    0x0c9b
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG51_CTRL3    0x0c9c
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG52_CTRL1    0x0c9d
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG52_CTRL2    0x0c9e
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG52_CTRL3    0x0c9f
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG53_CTRL1    0x0ca0
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG53_CTRL2    0x0ca1
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG53_CTRL3    0x0ca2
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG54_CTRL1    0x0ca3
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG54_CTRL2    0x0ca4
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG54_CTRL3    0x0ca5
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG55_CTRL1    0x0ca6
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG55_CTRL2    0x0ca7
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG55_CTRL3    0x0ca8
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG56_CTRL1    0x0ca9
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG56_CTRL2    0x0caa
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG56_CTRL3    0x0cab
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG57_CTRL1    0x0cac
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG57_CTRL2    0x0cad
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG57_CTRL3    0x0cae
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG58_CTRL1    0x0caf
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG58_CTRL2    0x0cb0
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG58_CTRL3    0x0cb1
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG59_CTRL1    0x0cb2
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG59_CTRL2    0x0cb3
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG59_CTRL3    0x0cb4
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG60_CTRL1    0x0cb5
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG60_CTRL2    0x0cb6
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG60_CTRL3    0x0cb7
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG61_CTRL1    0x0cb8
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG61_CTRL2    0x0cb9
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG61_CTRL3    0x0cba
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG62_CTRL1    0x0cbb
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG62_CTRL2    0x0cbc
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG62_CTRL3    0x0cbd
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG63_CTRL1    0x0cbe
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL1_VS_UNTAGSET_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL1_VS_UNTAGSET_MASK    0xFF00
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL1_VS_SMBR_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL1_VS_SMBR_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG63_CTRL2    0x0cbf
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL2_VS_FIDEN_OFFSET    7
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL2_VS_FIDEN_MASK    0x80
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL2_VS_SPRI_OFFSET    4
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL2_VS_SPRI_MASK    0x70
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL2_VS_FID_MSTI_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL2_VS_FID_MSTI_MASK    0xF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG63_CTRL3    0x0cc0
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL3_VS_EFID_OFFSET    13
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL3_VS_EFID_MASK    0xE000
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL3_VS_EFIDEN_OFFSET    12
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL3_VS_EFIDEN_MASK    0x1000
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL3_VS_SVID_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL3_VS_SVID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG0_CTRL4    0x0cc1
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG0_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG1_CTRL4    0x0cc2
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG1_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG2_CTRL4    0x0cc3
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG2_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG3_CTRL4    0x0cc4
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG3_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG4_CTRL4    0x0cc5
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG4_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG5_CTRL4    0x0cc6
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG5_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG6_CTRL4    0x0cc7
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG6_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG7_CTRL4    0x0cc8
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG7_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG8_CTRL4    0x0cc9
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG8_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG9_CTRL4    0x0cca
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG9_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG10_CTRL4    0x0ccb
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG10_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG11_CTRL4    0x0ccc
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG11_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG12_CTRL4    0x0ccd
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG12_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG13_CTRL4    0x0cce
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG13_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG14_CTRL4    0x0ccf
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG14_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG15_CTRL4    0x0cd0
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG15_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG16_CTRL4    0x0cd1
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG16_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG17_CTRL4    0x0cd2
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG17_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG18_CTRL4    0x0cd3
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG18_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG19_CTRL4    0x0cd4
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG19_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG20_CTRL4    0x0cd5
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG20_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG21_CTRL4    0x0cd6
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG21_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG22_CTRL4    0x0cd7
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG22_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG23_CTRL4    0x0cd8
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG23_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG24_CTRL4    0x0cd9
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG24_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG25_CTRL4    0x0cda
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG25_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG26_CTRL4    0x0cdb
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG26_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG27_CTRL4    0x0cdc
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG27_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG28_CTRL4    0x0cdd
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG28_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG29_CTRL4    0x0cde
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG29_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG30_CTRL4    0x0cdf
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG30_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG31_CTRL4    0x0ce0
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG31_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG32_CTRL4    0x0ce1
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG32_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG33_CTRL4    0x0ce2
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG33_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG34_CTRL4    0x0ce3
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG34_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG35_CTRL4    0x0ce4
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG35_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG36_CTRL4    0x0ce5
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG36_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG37_CTRL4    0x0ce6
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG37_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG38_CTRL4    0x0ce7
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG38_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG39_CTRL4    0x0ce8
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG39_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG40_CTRL4    0x0ce9
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG40_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG41_CTRL4    0x0cea
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG41_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG42_CTRL4    0x0ceb
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG42_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG43_CTRL4    0x0cec
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG43_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG44_CTRL4    0x0ced
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG44_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG45_CTRL4    0x0cee
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG45_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG46_CTRL4    0x0cef
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG46_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG47_CTRL4    0x0cf0
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG47_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG48_CTRL4    0x0cf1
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG48_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG49_CTRL4    0x0cf2
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG49_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG50_CTRL4    0x0cf3
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG50_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG51_CTRL4    0x0cf4
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG51_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG52_CTRL4    0x0cf5
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG52_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG53_CTRL4    0x0cf6
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG53_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG54_CTRL4    0x0cf7
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG54_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG55_CTRL4    0x0cf8
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG55_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG56_CTRL4    0x0cf9
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG56_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG57_CTRL4    0x0cfa
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG57_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG58_CTRL4    0x0cfb
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG58_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG59_CTRL4    0x0cfc
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG59_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG60_CTRL4    0x0cfd
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG60_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG61_CTRL4    0x0cfe
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG61_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG62_CTRL4    0x0cff
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG62_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_C2SCFG0_CTRL0    0x0d00
+#define    RTL8367C_SVLAN_C2SCFG0_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG0_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG0_CTRL1    0x0d01
+#define    RTL8367C_SVLAN_C2SCFG0_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG0_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG0_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG0_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG0_CTRL2    0x0d02
+#define    RTL8367C_SVLAN_C2SCFG0_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG0_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG1_CTRL0    0x0d03
+#define    RTL8367C_SVLAN_C2SCFG1_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG1_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG1_CTRL1    0x0d04
+#define    RTL8367C_SVLAN_C2SCFG1_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG1_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG1_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG1_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG1_CTRL2    0x0d05
+#define    RTL8367C_SVLAN_C2SCFG1_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG1_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG2_CTRL0    0x0d06
+#define    RTL8367C_SVLAN_C2SCFG2_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG2_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG2_CTRL1    0x0d07
+#define    RTL8367C_SVLAN_C2SCFG2_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG2_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG2_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG2_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG2_CTRL2    0x0d08
+#define    RTL8367C_SVLAN_C2SCFG2_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG2_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG3_CTRL0    0x0d09
+#define    RTL8367C_SVLAN_C2SCFG3_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG3_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG3_CTRL1    0x0d0a
+#define    RTL8367C_SVLAN_C2SCFG3_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG3_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG3_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG3_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG3_CTRL2    0x0d0b
+#define    RTL8367C_SVLAN_C2SCFG3_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG3_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG4_CTRL0    0x0d0c
+#define    RTL8367C_SVLAN_C2SCFG4_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG4_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG4_CTRL1    0x0d0d
+#define    RTL8367C_SVLAN_C2SCFG4_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG4_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG4_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG4_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG4_CTRL2    0x0d0e
+#define    RTL8367C_SVLAN_C2SCFG4_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG4_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG5_CTRL0    0x0d0f
+#define    RTL8367C_SVLAN_C2SCFG5_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG5_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG5_CTRL1    0x0d10
+#define    RTL8367C_SVLAN_C2SCFG5_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG5_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG5_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG5_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG5_CTRL2    0x0d11
+#define    RTL8367C_SVLAN_C2SCFG5_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG5_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG6_CTRL0    0x0d12
+#define    RTL8367C_SVLAN_C2SCFG6_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG6_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG6_CTRL1    0x0d13
+#define    RTL8367C_SVLAN_C2SCFG6_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG6_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG6_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG6_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG6_CTRL2    0x0d14
+#define    RTL8367C_SVLAN_C2SCFG6_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG6_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG7_CTRL0    0x0d15
+#define    RTL8367C_SVLAN_C2SCFG7_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG7_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG7_CTRL1    0x0d16
+#define    RTL8367C_SVLAN_C2SCFG7_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG7_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG7_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG7_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG7_CTRL2    0x0d17
+#define    RTL8367C_SVLAN_C2SCFG7_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG7_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG8_CTRL0    0x0d18
+#define    RTL8367C_SVLAN_C2SCFG8_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG8_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG8_CTRL1    0x0d19
+#define    RTL8367C_SVLAN_C2SCFG8_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG8_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG8_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG8_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG8_CTRL2    0x0d1a
+#define    RTL8367C_SVLAN_C2SCFG8_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG8_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG9_CTRL0    0x0d1b
+#define    RTL8367C_SVLAN_C2SCFG9_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG9_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG9_CTRL1    0x0d1c
+#define    RTL8367C_SVLAN_C2SCFG9_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG9_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG9_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG9_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG9_CTRL2    0x0d1d
+#define    RTL8367C_SVLAN_C2SCFG9_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG9_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG10_CTRL0    0x0d1e
+#define    RTL8367C_SVLAN_C2SCFG10_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG10_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG10_CTRL1    0x0d1f
+#define    RTL8367C_SVLAN_C2SCFG10_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG10_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG10_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG10_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG10_CTRL2    0x0d20
+#define    RTL8367C_SVLAN_C2SCFG10_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG10_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG11_CTRL0    0x0d21
+#define    RTL8367C_SVLAN_C2SCFG11_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG11_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG11_CTRL1    0x0d22
+#define    RTL8367C_SVLAN_C2SCFG11_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG11_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG11_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG11_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG11_CTRL2    0x0d23
+#define    RTL8367C_SVLAN_C2SCFG11_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG11_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG12_CTRL0    0x0d24
+#define    RTL8367C_SVLAN_C2SCFG12_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG12_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG12_CTRL1    0x0d25
+#define    RTL8367C_SVLAN_C2SCFG12_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG12_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG12_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG12_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG12_CTRL2    0x0d26
+#define    RTL8367C_SVLAN_C2SCFG12_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG12_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG13_CTRL0    0x0d27
+#define    RTL8367C_SVLAN_C2SCFG13_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG13_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG13_CTRL1    0x0d28
+#define    RTL8367C_SVLAN_C2SCFG13_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG13_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG13_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG13_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG13_CTRL2    0x0d29
+#define    RTL8367C_SVLAN_C2SCFG13_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG13_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG14_CTRL0    0x0d2a
+#define    RTL8367C_SVLAN_C2SCFG14_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG14_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG14_CTRL1    0x0d2b
+#define    RTL8367C_SVLAN_C2SCFG14_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG14_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG14_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG14_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG14_CTRL2    0x0d2c
+#define    RTL8367C_SVLAN_C2SCFG14_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG14_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG15_CTRL0    0x0d2d
+#define    RTL8367C_SVLAN_C2SCFG15_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG15_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG15_CTRL1    0x0d2e
+#define    RTL8367C_SVLAN_C2SCFG15_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG15_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG15_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG15_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG15_CTRL2    0x0d2f
+#define    RTL8367C_SVLAN_C2SCFG15_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG15_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG16_CTRL0    0x0d30
+#define    RTL8367C_SVLAN_C2SCFG16_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG16_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG16_CTRL1    0x0d31
+#define    RTL8367C_SVLAN_C2SCFG16_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG16_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG16_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG16_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG16_CTRL2    0x0d32
+#define    RTL8367C_SVLAN_C2SCFG16_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG16_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG17_CTRL0    0x0d33
+#define    RTL8367C_SVLAN_C2SCFG17_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG17_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG17_CTRL1    0x0d34
+#define    RTL8367C_SVLAN_C2SCFG17_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG17_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG17_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG17_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG17_CTRL2    0x0d35
+#define    RTL8367C_SVLAN_C2SCFG17_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG17_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG18_CTRL0    0x0d36
+#define    RTL8367C_SVLAN_C2SCFG18_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG18_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG18_CTRL1    0x0d37
+#define    RTL8367C_SVLAN_C2SCFG18_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG18_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG18_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG18_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG18_CTRL2    0x0d38
+#define    RTL8367C_SVLAN_C2SCFG18_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG18_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG19_CTRL0    0x0d39
+#define    RTL8367C_SVLAN_C2SCFG19_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG19_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG19_CTRL1    0x0d3a
+#define    RTL8367C_SVLAN_C2SCFG19_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG19_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG19_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG19_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG19_CTRL2    0x0d3b
+#define    RTL8367C_SVLAN_C2SCFG19_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG19_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG20_CTRL0    0x0d3c
+#define    RTL8367C_SVLAN_C2SCFG20_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG20_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG20_CTRL1    0x0d3d
+#define    RTL8367C_SVLAN_C2SCFG20_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG20_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG20_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG20_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG20_CTRL2    0x0d3e
+#define    RTL8367C_SVLAN_C2SCFG20_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG20_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG21_CTRL0    0x0d3f
+#define    RTL8367C_SVLAN_C2SCFG21_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG21_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG21_CTRL1    0x0d40
+#define    RTL8367C_SVLAN_C2SCFG21_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG21_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG21_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG21_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG21_CTRL2    0x0d41
+#define    RTL8367C_SVLAN_C2SCFG21_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG21_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG22_CTRL0    0x0d42
+#define    RTL8367C_SVLAN_C2SCFG22_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG22_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG22_CTRL1    0x0d43
+#define    RTL8367C_SVLAN_C2SCFG22_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG22_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG22_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG22_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG22_CTRL2    0x0d44
+#define    RTL8367C_SVLAN_C2SCFG22_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG22_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG23_CTRL0    0x0d45
+#define    RTL8367C_SVLAN_C2SCFG23_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG23_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG23_CTRL1    0x0d46
+#define    RTL8367C_SVLAN_C2SCFG23_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG23_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG23_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG23_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG23_CTRL2    0x0d47
+#define    RTL8367C_SVLAN_C2SCFG23_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG23_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG24_CTRL0    0x0d48
+#define    RTL8367C_SVLAN_C2SCFG24_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG24_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG24_CTRL1    0x0d49
+#define    RTL8367C_SVLAN_C2SCFG24_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG24_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG24_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG24_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG24_CTRL2    0x0d4a
+#define    RTL8367C_SVLAN_C2SCFG24_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG24_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG25_CTRL0    0x0d4b
+#define    RTL8367C_SVLAN_C2SCFG25_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG25_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG25_CTRL1    0x0d4c
+#define    RTL8367C_SVLAN_C2SCFG25_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG25_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG25_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG25_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG25_CTRL2    0x0d4d
+#define    RTL8367C_SVLAN_C2SCFG25_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG25_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG26_CTRL0    0x0d4e
+#define    RTL8367C_SVLAN_C2SCFG26_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG26_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG26_CTRL1    0x0d4f
+#define    RTL8367C_SVLAN_C2SCFG26_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG26_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG26_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG26_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG26_CTRL2    0x0d50
+#define    RTL8367C_SVLAN_C2SCFG26_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG26_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG27_CTRL0    0x0d51
+#define    RTL8367C_SVLAN_C2SCFG27_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG27_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG27_CTRL1    0x0d52
+#define    RTL8367C_SVLAN_C2SCFG27_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG27_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG27_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG27_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG27_CTRL2    0x0d53
+#define    RTL8367C_SVLAN_C2SCFG27_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG27_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG28_CTRL0    0x0d54
+#define    RTL8367C_SVLAN_C2SCFG28_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG28_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG28_CTRL1    0x0d55
+#define    RTL8367C_SVLAN_C2SCFG28_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG28_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG28_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG28_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG28_CTRL2    0x0d56
+#define    RTL8367C_SVLAN_C2SCFG28_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG28_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG29_CTRL0    0x0d57
+#define    RTL8367C_SVLAN_C2SCFG29_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG29_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG29_CTRL1    0x0d58
+#define    RTL8367C_SVLAN_C2SCFG29_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG29_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG29_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG29_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG29_CTRL2    0x0d59
+#define    RTL8367C_SVLAN_C2SCFG29_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG29_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG30_CTRL0    0x0d5a
+#define    RTL8367C_SVLAN_C2SCFG30_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG30_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG30_CTRL1    0x0d5b
+#define    RTL8367C_SVLAN_C2SCFG30_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG30_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG30_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG30_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG30_CTRL2    0x0d5c
+#define    RTL8367C_SVLAN_C2SCFG30_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG30_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG31_CTRL0    0x0d5d
+#define    RTL8367C_SVLAN_C2SCFG31_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG31_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG31_CTRL1    0x0d5e
+#define    RTL8367C_SVLAN_C2SCFG31_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG31_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG31_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG31_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG31_CTRL2    0x0d5f
+#define    RTL8367C_SVLAN_C2SCFG31_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG31_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG32_CTRL0    0x0d60
+#define    RTL8367C_SVLAN_C2SCFG32_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG32_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG32_CTRL1    0x0d61
+#define    RTL8367C_SVLAN_C2SCFG32_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG32_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG32_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG32_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG32_CTRL2    0x0d62
+#define    RTL8367C_SVLAN_C2SCFG32_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG32_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG33_CTRL0    0x0d63
+#define    RTL8367C_SVLAN_C2SCFG33_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG33_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG33_CTRL1    0x0d64
+#define    RTL8367C_SVLAN_C2SCFG33_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG33_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG33_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG33_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG33_CTRL2    0x0d65
+#define    RTL8367C_SVLAN_C2SCFG33_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG33_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG34_CTRL0    0x0d66
+#define    RTL8367C_SVLAN_C2SCFG34_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG34_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG34_CTRL1    0x0d67
+#define    RTL8367C_SVLAN_C2SCFG34_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG34_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG34_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG34_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG34_CTRL2    0x0d68
+#define    RTL8367C_SVLAN_C2SCFG34_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG34_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG35_CTRL0    0x0d69
+#define    RTL8367C_SVLAN_C2SCFG35_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG35_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG35_CTRL1    0x0d6a
+#define    RTL8367C_SVLAN_C2SCFG35_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG35_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG35_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG35_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG35_CTRL2    0x0d6b
+#define    RTL8367C_SVLAN_C2SCFG35_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG35_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG36_CTRL0    0x0d6c
+#define    RTL8367C_SVLAN_C2SCFG36_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG36_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG36_CTRL1    0x0d6d
+#define    RTL8367C_SVLAN_C2SCFG36_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG36_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG36_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG36_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG36_CTRL2    0x0d6e
+#define    RTL8367C_SVLAN_C2SCFG36_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG36_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG37_CTRL0    0x0d6f
+#define    RTL8367C_SVLAN_C2SCFG37_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG37_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG37_CTRL1    0x0d70
+#define    RTL8367C_SVLAN_C2SCFG37_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG37_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG37_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG37_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG37_CTRL2    0x0d71
+#define    RTL8367C_SVLAN_C2SCFG37_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG37_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG38_CTRL0    0x0d72
+#define    RTL8367C_SVLAN_C2SCFG38_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG38_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG38_CTRL1    0x0d73
+#define    RTL8367C_SVLAN_C2SCFG38_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG38_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG38_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG38_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG38_CTRL2    0x0d74
+#define    RTL8367C_SVLAN_C2SCFG38_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG38_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG39_CTRL0    0x0d75
+#define    RTL8367C_SVLAN_C2SCFG39_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG39_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG39_CTRL1    0x0d76
+#define    RTL8367C_SVLAN_C2SCFG39_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG39_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG39_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG39_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG39_CTRL2    0x0d77
+#define    RTL8367C_SVLAN_C2SCFG39_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG39_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG40_CTRL0    0x0d78
+#define    RTL8367C_SVLAN_C2SCFG40_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG40_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG40_CTRL1    0x0d79
+#define    RTL8367C_SVLAN_C2SCFG40_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG40_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG40_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG40_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG40_CTRL2    0x0d7a
+#define    RTL8367C_SVLAN_C2SCFG40_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG40_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG41_CTRL0    0x0d7b
+#define    RTL8367C_SVLAN_C2SCFG41_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG41_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG41_CTRL1    0x0d7c
+#define    RTL8367C_SVLAN_C2SCFG41_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG41_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG41_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG41_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG41_CTRL2    0x0d7d
+#define    RTL8367C_SVLAN_C2SCFG41_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG41_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG42_CTRL0    0x0d7e
+#define    RTL8367C_SVLAN_C2SCFG42_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG42_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG42_CTRL1    0x0d7f
+#define    RTL8367C_SVLAN_C2SCFG42_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG42_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG42_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG42_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG42_CTRL2    0x0d80
+#define    RTL8367C_SVLAN_C2SCFG42_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG42_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG43_CTRL0    0x0d81
+#define    RTL8367C_SVLAN_C2SCFG43_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG43_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG43_CTRL1    0x0d82
+#define    RTL8367C_SVLAN_C2SCFG43_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG43_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG43_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG43_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG43_CTRL2    0x0d83
+#define    RTL8367C_SVLAN_C2SCFG43_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG43_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG44_CTRL0    0x0d84
+#define    RTL8367C_SVLAN_C2SCFG44_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG44_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG44_CTRL1    0x0d85
+#define    RTL8367C_SVLAN_C2SCFG44_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG44_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG44_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG44_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG44_CTRL2    0x0d86
+#define    RTL8367C_SVLAN_C2SCFG44_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG44_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG45_CTRL0    0x0d87
+#define    RTL8367C_SVLAN_C2SCFG45_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG45_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG45_CTRL1    0x0d88
+#define    RTL8367C_SVLAN_C2SCFG45_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG45_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG45_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG45_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG45_CTRL2    0x0d89
+#define    RTL8367C_SVLAN_C2SCFG45_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG45_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG46_CTRL0    0x0d8a
+#define    RTL8367C_SVLAN_C2SCFG46_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG46_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG46_CTRL1    0x0d8b
+#define    RTL8367C_SVLAN_C2SCFG46_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG46_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG46_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG46_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG46_CTRL2    0x0d8c
+#define    RTL8367C_SVLAN_C2SCFG46_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG46_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG47_CTRL0    0x0d8d
+#define    RTL8367C_SVLAN_C2SCFG47_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG47_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG47_CTRL1    0x0d8e
+#define    RTL8367C_SVLAN_C2SCFG47_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG47_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG47_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG47_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG47_CTRL2    0x0d8f
+#define    RTL8367C_SVLAN_C2SCFG47_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG47_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG48_CTRL0    0x0d90
+#define    RTL8367C_SVLAN_C2SCFG48_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG48_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG48_CTRL1    0x0d91
+#define    RTL8367C_SVLAN_C2SCFG48_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG48_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG48_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG48_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG48_CTRL2    0x0d92
+#define    RTL8367C_SVLAN_C2SCFG48_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG48_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG49_CTRL0    0x0d93
+#define    RTL8367C_SVLAN_C2SCFG49_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG49_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG49_CTRL1    0x0d94
+#define    RTL8367C_SVLAN_C2SCFG49_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG49_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG49_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG49_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG49_CTRL2    0x0d95
+#define    RTL8367C_SVLAN_C2SCFG49_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG49_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG50_CTRL0    0x0d96
+#define    RTL8367C_SVLAN_C2SCFG50_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG50_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG50_CTRL1    0x0d97
+#define    RTL8367C_SVLAN_C2SCFG50_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG50_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG50_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG50_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG50_CTRL2    0x0d98
+#define    RTL8367C_SVLAN_C2SCFG50_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG50_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG51_CTRL0    0x0d99
+#define    RTL8367C_SVLAN_C2SCFG51_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG51_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG51_CTRL1    0x0d9a
+#define    RTL8367C_SVLAN_C2SCFG51_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG51_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG51_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG51_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG51_CTRL2    0x0d9b
+#define    RTL8367C_SVLAN_C2SCFG51_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG51_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG52_CTRL0    0x0d9c
+#define    RTL8367C_SVLAN_C2SCFG52_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG52_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG52_CTRL1    0x0d9d
+#define    RTL8367C_SVLAN_C2SCFG52_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG52_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG52_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG52_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG52_CTRL2    0x0d9e
+#define    RTL8367C_SVLAN_C2SCFG52_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG52_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG53_CTRL0    0x0d9f
+#define    RTL8367C_SVLAN_C2SCFG53_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG53_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG53_CTRL1    0x0da0
+#define    RTL8367C_SVLAN_C2SCFG53_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG53_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG53_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG53_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG53_CTRL2    0x0da1
+#define    RTL8367C_SVLAN_C2SCFG53_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG53_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG54_CTRL0    0x0da2
+#define    RTL8367C_SVLAN_C2SCFG54_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG54_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG54_CTRL1    0x0da3
+#define    RTL8367C_SVLAN_C2SCFG54_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG54_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG54_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG54_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG54_CTRL2    0x0da4
+#define    RTL8367C_SVLAN_C2SCFG54_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG54_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG55_CTRL0    0x0da5
+#define    RTL8367C_SVLAN_C2SCFG55_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG55_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG55_CTRL1    0x0da6
+#define    RTL8367C_SVLAN_C2SCFG55_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG55_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG55_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG55_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG55_CTRL2    0x0da7
+#define    RTL8367C_SVLAN_C2SCFG55_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG55_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG56_CTRL0    0x0da8
+#define    RTL8367C_SVLAN_C2SCFG56_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG56_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG56_CTRL1    0x0da9
+#define    RTL8367C_SVLAN_C2SCFG56_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG56_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG56_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG56_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG56_CTRL2    0x0daa
+#define    RTL8367C_SVLAN_C2SCFG56_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG56_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG57_CTRL0    0x0dab
+#define    RTL8367C_SVLAN_C2SCFG57_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG57_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG57_CTRL1    0x0dac
+#define    RTL8367C_SVLAN_C2SCFG57_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG57_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG57_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG57_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG57_CTRL2    0x0dad
+#define    RTL8367C_SVLAN_C2SCFG57_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG57_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG58_CTRL0    0x0dae
+#define    RTL8367C_SVLAN_C2SCFG58_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG58_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG58_CTRL1    0x0daf
+#define    RTL8367C_SVLAN_C2SCFG58_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG58_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG58_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG58_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG58_CTRL2    0x0db0
+#define    RTL8367C_SVLAN_C2SCFG58_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG58_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG59_CTRL0    0x0db1
+#define    RTL8367C_SVLAN_C2SCFG59_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG59_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG59_CTRL1    0x0db2
+#define    RTL8367C_SVLAN_C2SCFG59_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG59_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG59_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG59_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG59_CTRL2    0x0db3
+#define    RTL8367C_SVLAN_C2SCFG59_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG59_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG60_CTRL0    0x0db4
+#define    RTL8367C_SVLAN_C2SCFG60_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG60_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG60_CTRL1    0x0db5
+#define    RTL8367C_SVLAN_C2SCFG60_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG60_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG60_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG60_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG60_CTRL2    0x0db6
+#define    RTL8367C_SVLAN_C2SCFG60_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG60_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG61_CTRL0    0x0db7
+#define    RTL8367C_SVLAN_C2SCFG61_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG61_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG61_CTRL1    0x0db8
+#define    RTL8367C_SVLAN_C2SCFG61_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG61_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG61_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG61_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG61_CTRL2    0x0db9
+#define    RTL8367C_SVLAN_C2SCFG61_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG61_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG62_CTRL0    0x0dba
+#define    RTL8367C_SVLAN_C2SCFG62_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG62_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG62_CTRL1    0x0dbb
+#define    RTL8367C_SVLAN_C2SCFG62_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG62_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG62_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG62_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG62_CTRL2    0x0dbc
+#define    RTL8367C_SVLAN_C2SCFG62_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG62_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG63_CTRL0    0x0dbd
+#define    RTL8367C_SVLAN_C2SCFG63_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG63_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG63_CTRL1    0x0dbe
+#define    RTL8367C_SVLAN_C2SCFG63_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG63_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG63_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG63_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG63_CTRL2    0x0dbf
+#define    RTL8367C_SVLAN_C2SCFG63_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG63_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG64_CTRL0    0x0dc0
+#define    RTL8367C_SVLAN_C2SCFG64_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG64_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG64_CTRL1    0x0dc1
+#define    RTL8367C_SVLAN_C2SCFG64_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG64_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG64_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG64_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG64_CTRL2    0x0dc2
+#define    RTL8367C_SVLAN_C2SCFG64_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG64_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG65_CTRL0    0x0dc3
+#define    RTL8367C_SVLAN_C2SCFG65_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG65_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG65_CTRL1    0x0dc4
+#define    RTL8367C_SVLAN_C2SCFG65_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG65_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG65_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG65_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG65_CTRL2    0x0dc5
+#define    RTL8367C_SVLAN_C2SCFG65_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG65_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG66_CTRL0    0x0dc6
+#define    RTL8367C_SVLAN_C2SCFG66_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG66_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG66_CTRL1    0x0dc7
+#define    RTL8367C_SVLAN_C2SCFG66_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG66_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG66_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG66_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG66_CTRL2    0x0dc8
+#define    RTL8367C_SVLAN_C2SCFG66_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG66_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG67_CTRL0    0x0dc9
+#define    RTL8367C_SVLAN_C2SCFG67_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG67_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG67_CTRL1    0x0dca
+#define    RTL8367C_SVLAN_C2SCFG67_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG67_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG67_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG67_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG67_CTRL2    0x0dcb
+#define    RTL8367C_SVLAN_C2SCFG67_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG67_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG68_CTRL0    0x0dcc
+#define    RTL8367C_SVLAN_C2SCFG68_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG68_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG68_CTRL1    0x0dcd
+#define    RTL8367C_SVLAN_C2SCFG68_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG68_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG68_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG68_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG68_CTRL2    0x0dce
+#define    RTL8367C_SVLAN_C2SCFG68_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG68_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG69_CTRL0    0x0dcf
+#define    RTL8367C_SVLAN_C2SCFG69_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG69_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG69_CTRL1    0x0dd0
+#define    RTL8367C_SVLAN_C2SCFG69_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG69_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG69_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG69_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG69_CTRL2    0x0dd1
+#define    RTL8367C_SVLAN_C2SCFG69_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG69_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG70_CTRL0    0x0dd2
+#define    RTL8367C_SVLAN_C2SCFG70_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG70_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG70_CTRL1    0x0dd3
+#define    RTL8367C_SVLAN_C2SCFG70_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG70_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG70_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG70_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG70_CTRL2    0x0dd4
+#define    RTL8367C_SVLAN_C2SCFG70_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG70_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG71_CTRL0    0x0dd5
+#define    RTL8367C_SVLAN_C2SCFG71_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG71_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG71_CTRL1    0x0dd6
+#define    RTL8367C_SVLAN_C2SCFG71_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG71_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG71_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG71_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG71_CTRL2    0x0dd7
+#define    RTL8367C_SVLAN_C2SCFG71_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG71_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG72_CTRL0    0x0dd8
+#define    RTL8367C_SVLAN_C2SCFG72_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG72_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG72_CTRL1    0x0dd9
+#define    RTL8367C_SVLAN_C2SCFG72_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG72_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG72_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG72_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG72_CTRL2    0x0dda
+#define    RTL8367C_SVLAN_C2SCFG72_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG72_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG73_CTRL0    0x0ddb
+#define    RTL8367C_SVLAN_C2SCFG73_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG73_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG73_CTRL1    0x0ddc
+#define    RTL8367C_SVLAN_C2SCFG73_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG73_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG73_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG73_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG73_CTRL2    0x0ddd
+#define    RTL8367C_SVLAN_C2SCFG73_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG73_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG74_CTRL0    0x0dde
+#define    RTL8367C_SVLAN_C2SCFG74_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG74_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG74_CTRL1    0x0ddf
+#define    RTL8367C_SVLAN_C2SCFG74_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG74_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG74_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG74_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG74_CTRL2    0x0de0
+#define    RTL8367C_SVLAN_C2SCFG74_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG74_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG75_CTRL0    0x0de1
+#define    RTL8367C_SVLAN_C2SCFG75_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG75_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG75_CTRL1    0x0de2
+#define    RTL8367C_SVLAN_C2SCFG75_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG75_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG75_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG75_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG75_CTRL2    0x0de3
+#define    RTL8367C_SVLAN_C2SCFG75_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG75_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG76_CTRL0    0x0de4
+#define    RTL8367C_SVLAN_C2SCFG76_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG76_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG76_CTRL1    0x0de5
+#define    RTL8367C_SVLAN_C2SCFG76_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG76_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG76_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG76_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG76_CTRL2    0x0de6
+#define    RTL8367C_SVLAN_C2SCFG76_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG76_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG77_CTRL0    0x0de7
+#define    RTL8367C_SVLAN_C2SCFG77_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG77_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG77_CTRL1    0x0de8
+#define    RTL8367C_SVLAN_C2SCFG77_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG77_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG77_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG77_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG77_CTRL2    0x0de9
+#define    RTL8367C_SVLAN_C2SCFG77_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG77_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG78_CTRL0    0x0dea
+#define    RTL8367C_SVLAN_C2SCFG78_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG78_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG78_CTRL1    0x0deb
+#define    RTL8367C_SVLAN_C2SCFG78_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG78_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG78_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG78_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG78_CTRL2    0x0dec
+#define    RTL8367C_SVLAN_C2SCFG78_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG78_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG79_CTRL0    0x0ded
+#define    RTL8367C_SVLAN_C2SCFG79_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG79_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG79_CTRL1    0x0dee
+#define    RTL8367C_SVLAN_C2SCFG79_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG79_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG79_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG79_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG79_CTRL2    0x0def
+#define    RTL8367C_SVLAN_C2SCFG79_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG79_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG80_CTRL0    0x0df0
+#define    RTL8367C_SVLAN_C2SCFG80_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG80_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG80_CTRL1    0x0df1
+#define    RTL8367C_SVLAN_C2SCFG80_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG80_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG80_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG80_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG80_CTRL2    0x0df2
+#define    RTL8367C_SVLAN_C2SCFG80_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG80_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG81_CTRL0    0x0df3
+#define    RTL8367C_SVLAN_C2SCFG81_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG81_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG81_CTRL1    0x0df4
+#define    RTL8367C_SVLAN_C2SCFG81_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG81_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG81_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG81_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG81_CTRL2    0x0df5
+#define    RTL8367C_SVLAN_C2SCFG81_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG81_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG82_CTRL0    0x0df6
+#define    RTL8367C_SVLAN_C2SCFG82_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG82_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG82_CTRL1    0x0df7
+#define    RTL8367C_SVLAN_C2SCFG82_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG82_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG82_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG82_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG82_CTRL2    0x0df8
+#define    RTL8367C_SVLAN_C2SCFG82_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG82_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG83_CTRL0    0x0df9
+#define    RTL8367C_SVLAN_C2SCFG83_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG83_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG83_CTRL1    0x0dfa
+#define    RTL8367C_SVLAN_C2SCFG83_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG83_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG83_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG83_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG83_CTRL2    0x0dfb
+#define    RTL8367C_SVLAN_C2SCFG83_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG83_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG84_CTRL0    0x0dfc
+#define    RTL8367C_SVLAN_C2SCFG84_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG84_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG84_CTRL1    0x0dfd
+#define    RTL8367C_SVLAN_C2SCFG84_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG84_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG84_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG84_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG84_CTRL2    0x0dfe
+#define    RTL8367C_SVLAN_C2SCFG84_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG84_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG85_CTRL0    0x0dff
+#define    RTL8367C_SVLAN_C2SCFG85_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG85_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG85_CTRL1    0x0e00
+#define    RTL8367C_SVLAN_C2SCFG85_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG85_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG85_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG85_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG85_CTRL2    0x0e01
+#define    RTL8367C_SVLAN_C2SCFG85_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG85_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG86_CTRL0    0x0e02
+#define    RTL8367C_SVLAN_C2SCFG86_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG86_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG86_CTRL1    0x0e03
+#define    RTL8367C_SVLAN_C2SCFG86_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG86_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG86_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG86_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG86_CTRL2    0x0e04
+#define    RTL8367C_SVLAN_C2SCFG86_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG86_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG87_CTRL0    0x0e05
+#define    RTL8367C_SVLAN_C2SCFG87_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG87_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG87_CTRL1    0x0e06
+#define    RTL8367C_SVLAN_C2SCFG87_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG87_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG87_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG87_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG87_CTRL2    0x0e07
+#define    RTL8367C_SVLAN_C2SCFG87_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG87_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG88_CTRL0    0x0e08
+#define    RTL8367C_SVLAN_C2SCFG88_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG88_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG88_CTRL1    0x0e09
+#define    RTL8367C_SVLAN_C2SCFG88_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG88_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG88_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG88_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG88_CTRL2    0x0e0a
+#define    RTL8367C_SVLAN_C2SCFG88_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG88_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG89_CTRL0    0x0e0b
+#define    RTL8367C_SVLAN_C2SCFG89_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG89_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG89_CTRL1    0x0e0c
+#define    RTL8367C_SVLAN_C2SCFG89_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG89_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG89_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG89_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG89_CTRL2    0x0e0d
+#define    RTL8367C_SVLAN_C2SCFG89_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG89_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG90_CTRL0    0x0e0e
+#define    RTL8367C_SVLAN_C2SCFG90_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG90_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG90_CTRL1    0x0e0f
+#define    RTL8367C_SVLAN_C2SCFG90_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG90_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG90_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG90_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG90_CTRL2    0x0e10
+#define    RTL8367C_SVLAN_C2SCFG90_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG90_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG91_CTRL0    0x0e11
+#define    RTL8367C_SVLAN_C2SCFG91_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG91_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG91_CTRL1    0x0e12
+#define    RTL8367C_SVLAN_C2SCFG91_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG91_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG91_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG91_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG91_CTRL2    0x0e13
+#define    RTL8367C_SVLAN_C2SCFG91_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG91_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG92_CTRL0    0x0e14
+#define    RTL8367C_SVLAN_C2SCFG92_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG92_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG92_CTRL1    0x0e15
+#define    RTL8367C_SVLAN_C2SCFG92_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG92_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG92_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG92_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG92_CTRL2    0x0e16
+#define    RTL8367C_SVLAN_C2SCFG92_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG92_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG93_CTRL0    0x0e17
+#define    RTL8367C_SVLAN_C2SCFG93_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG93_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG93_CTRL1    0x0e18
+#define    RTL8367C_SVLAN_C2SCFG93_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG93_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG93_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG93_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG93_CTRL2    0x0e19
+#define    RTL8367C_SVLAN_C2SCFG93_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG93_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG94_CTRL0    0x0e1a
+#define    RTL8367C_SVLAN_C2SCFG94_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG94_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG94_CTRL1    0x0e1b
+#define    RTL8367C_SVLAN_C2SCFG94_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG94_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG94_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG94_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG94_CTRL2    0x0e1c
+#define    RTL8367C_SVLAN_C2SCFG94_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG94_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG95_CTRL0    0x0e1d
+#define    RTL8367C_SVLAN_C2SCFG95_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG95_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG95_CTRL1    0x0e1e
+#define    RTL8367C_SVLAN_C2SCFG95_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG95_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG95_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG95_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG95_CTRL2    0x0e1f
+#define    RTL8367C_SVLAN_C2SCFG95_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG95_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG96_CTRL0    0x0e20
+#define    RTL8367C_SVLAN_C2SCFG96_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG96_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG96_CTRL1    0x0e21
+#define    RTL8367C_SVLAN_C2SCFG96_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG96_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG96_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG96_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG96_CTRL2    0x0e22
+#define    RTL8367C_SVLAN_C2SCFG96_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG96_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG97_CTRL0    0x0e23
+#define    RTL8367C_SVLAN_C2SCFG97_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG97_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG97_CTRL1    0x0e24
+#define    RTL8367C_SVLAN_C2SCFG97_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG97_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG97_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG97_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG97_CTRL2    0x0e25
+#define    RTL8367C_SVLAN_C2SCFG97_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG97_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG98_CTRL0    0x0e26
+#define    RTL8367C_SVLAN_C2SCFG98_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG98_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG98_CTRL1    0x0e27
+#define    RTL8367C_SVLAN_C2SCFG98_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG98_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG98_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG98_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG98_CTRL2    0x0e28
+#define    RTL8367C_SVLAN_C2SCFG98_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG98_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG99_CTRL0    0x0e29
+#define    RTL8367C_SVLAN_C2SCFG99_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG99_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG99_CTRL1    0x0e2a
+#define    RTL8367C_SVLAN_C2SCFG99_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG99_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG99_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG99_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG99_CTRL2    0x0e2b
+#define    RTL8367C_SVLAN_C2SCFG99_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG99_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG100_CTRL0    0x0e2c
+#define    RTL8367C_SVLAN_C2SCFG100_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG100_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG100_CTRL1    0x0e2d
+#define    RTL8367C_SVLAN_C2SCFG100_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG100_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG100_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG100_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG100_CTRL2    0x0e2e
+#define    RTL8367C_SVLAN_C2SCFG100_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG100_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG101_CTRL0    0x0e2f
+#define    RTL8367C_SVLAN_C2SCFG101_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG101_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG101_CTRL1    0x0e30
+#define    RTL8367C_SVLAN_C2SCFG101_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG101_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG101_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG101_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG101_CTRL2    0x0e31
+#define    RTL8367C_SVLAN_C2SCFG101_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG101_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG102_CTRL0    0x0e32
+#define    RTL8367C_SVLAN_C2SCFG102_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG102_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG102_CTRL1    0x0e33
+#define    RTL8367C_SVLAN_C2SCFG102_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG102_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG102_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG102_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG102_CTRL2    0x0e34
+#define    RTL8367C_SVLAN_C2SCFG102_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG102_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG103_CTRL0    0x0e35
+#define    RTL8367C_SVLAN_C2SCFG103_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG103_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG103_CTRL1    0x0e36
+#define    RTL8367C_SVLAN_C2SCFG103_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG103_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG103_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG103_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG103_CTRL2    0x0e37
+#define    RTL8367C_SVLAN_C2SCFG103_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG103_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG104_CTRL0    0x0e38
+#define    RTL8367C_SVLAN_C2SCFG104_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG104_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG104_CTRL1    0x0e39
+#define    RTL8367C_SVLAN_C2SCFG104_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG104_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG104_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG104_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG104_CTRL2    0x0e3a
+#define    RTL8367C_SVLAN_C2SCFG104_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG104_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG105_CTRL0    0x0e3b
+#define    RTL8367C_SVLAN_C2SCFG105_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG105_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG105_CTRL1    0x0e3c
+#define    RTL8367C_SVLAN_C2SCFG105_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG105_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG105_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG105_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG105_CTRL2    0x0e3d
+#define    RTL8367C_SVLAN_C2SCFG105_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG105_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG106_CTRL0    0x0e3e
+#define    RTL8367C_SVLAN_C2SCFG106_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG106_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG106_CTRL1    0x0e3f
+#define    RTL8367C_SVLAN_C2SCFG106_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG106_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG106_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG106_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG106_CTRL2    0x0e40
+#define    RTL8367C_SVLAN_C2SCFG106_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG106_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG107_CTRL0    0x0e41
+#define    RTL8367C_SVLAN_C2SCFG107_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG107_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG107_CTRL1    0x0e42
+#define    RTL8367C_SVLAN_C2SCFG107_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG107_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG107_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG107_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG107_CTRL2    0x0e43
+#define    RTL8367C_SVLAN_C2SCFG107_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG107_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG108_CTRL0    0x0e44
+#define    RTL8367C_SVLAN_C2SCFG108_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG108_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG108_CTRL1    0x0e45
+#define    RTL8367C_SVLAN_C2SCFG108_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG108_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG108_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG108_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG108_CTRL2    0x0e46
+#define    RTL8367C_SVLAN_C2SCFG108_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG108_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG109_CTRL0    0x0e47
+#define    RTL8367C_SVLAN_C2SCFG109_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG109_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG109_CTRL1    0x0e48
+#define    RTL8367C_SVLAN_C2SCFG109_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG109_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG109_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG109_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG109_CTRL2    0x0e49
+#define    RTL8367C_SVLAN_C2SCFG109_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG109_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG110_CTRL0    0x0e4a
+#define    RTL8367C_SVLAN_C2SCFG110_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG110_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG110_CTRL1    0x0e4b
+#define    RTL8367C_SVLAN_C2SCFG110_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG110_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG110_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG110_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG110_CTRL2    0x0e4c
+#define    RTL8367C_SVLAN_C2SCFG110_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG110_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG111_CTRL0    0x0e4d
+#define    RTL8367C_SVLAN_C2SCFG111_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG111_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG111_CTRL1    0x0e4e
+#define    RTL8367C_SVLAN_C2SCFG111_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG111_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG111_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG111_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG111_CTRL2    0x0e4f
+#define    RTL8367C_SVLAN_C2SCFG111_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG111_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG112_CTRL0    0x0e50
+#define    RTL8367C_SVLAN_C2SCFG112_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG112_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG112_CTRL1    0x0e51
+#define    RTL8367C_SVLAN_C2SCFG112_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG112_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG112_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG112_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG112_CTRL2    0x0e52
+#define    RTL8367C_SVLAN_C2SCFG112_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG112_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG113_CTRL0    0x0e53
+#define    RTL8367C_SVLAN_C2SCFG113_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG113_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG113_CTRL1    0x0e54
+#define    RTL8367C_SVLAN_C2SCFG113_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG113_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG113_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG113_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG113_CTRL2    0x0e55
+#define    RTL8367C_SVLAN_C2SCFG113_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG113_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG114_CTRL0    0x0e56
+#define    RTL8367C_SVLAN_C2SCFG114_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG114_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG114_CTRL1    0x0e57
+#define    RTL8367C_SVLAN_C2SCFG114_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG114_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG114_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG114_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG114_CTRL2    0x0e58
+#define    RTL8367C_SVLAN_C2SCFG114_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG114_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG115_CTRL0    0x0e59
+#define    RTL8367C_SVLAN_C2SCFG115_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG115_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG115_CTRL1    0x0e5a
+#define    RTL8367C_SVLAN_C2SCFG115_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG115_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG115_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG115_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG115_CTRL2    0x0e5b
+#define    RTL8367C_SVLAN_C2SCFG115_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG115_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG116_CTRL0    0x0e5c
+#define    RTL8367C_SVLAN_C2SCFG116_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG116_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG116_CTRL1    0x0e5d
+#define    RTL8367C_SVLAN_C2SCFG116_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG116_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG116_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG116_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG116_CTRL2    0x0e5e
+#define    RTL8367C_SVLAN_C2SCFG116_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG116_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG117_CTRL0    0x0e5f
+#define    RTL8367C_SVLAN_C2SCFG117_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG117_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG117_CTRL1    0x0e60
+#define    RTL8367C_SVLAN_C2SCFG117_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG117_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG117_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG117_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG117_CTRL2    0x0e61
+#define    RTL8367C_SVLAN_C2SCFG117_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG117_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG118_CTRL0    0x0e62
+#define    RTL8367C_SVLAN_C2SCFG118_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG118_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG118_CTRL1    0x0e63
+#define    RTL8367C_SVLAN_C2SCFG118_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG118_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG118_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG118_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG118_CTRL2    0x0e64
+#define    RTL8367C_SVLAN_C2SCFG118_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG118_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG119_CTRL0    0x0e65
+#define    RTL8367C_SVLAN_C2SCFG119_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG119_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG119_CTRL1    0x0e66
+#define    RTL8367C_SVLAN_C2SCFG119_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG119_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG119_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG119_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG119_CTRL2    0x0e67
+#define    RTL8367C_SVLAN_C2SCFG119_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG119_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG120_CTRL0    0x0e68
+#define    RTL8367C_SVLAN_C2SCFG120_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG120_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG120_CTRL1    0x0e69
+#define    RTL8367C_SVLAN_C2SCFG120_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG120_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG120_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG120_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG120_CTRL2    0x0e6a
+#define    RTL8367C_SVLAN_C2SCFG120_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG120_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG121_CTRL0    0x0e6b
+#define    RTL8367C_SVLAN_C2SCFG121_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG121_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG121_CTRL1    0x0e6c
+#define    RTL8367C_SVLAN_C2SCFG121_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG121_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG121_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG121_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG121_CTRL2    0x0e6d
+#define    RTL8367C_SVLAN_C2SCFG121_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG121_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG122_CTRL0    0x0e6e
+#define    RTL8367C_SVLAN_C2SCFG122_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG122_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG122_CTRL1    0x0e6f
+#define    RTL8367C_SVLAN_C2SCFG122_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG122_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG122_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG122_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG122_CTRL2    0x0e70
+#define    RTL8367C_SVLAN_C2SCFG122_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG122_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG123_CTRL0    0x0e71
+#define    RTL8367C_SVLAN_C2SCFG123_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG123_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG123_CTRL1    0x0e72
+#define    RTL8367C_SVLAN_C2SCFG123_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG123_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG123_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG123_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG123_CTRL2    0x0e73
+#define    RTL8367C_SVLAN_C2SCFG123_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG123_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG124_CTRL0    0x0e74
+#define    RTL8367C_SVLAN_C2SCFG124_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG124_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG124_CTRL1    0x0e75
+#define    RTL8367C_SVLAN_C2SCFG124_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG124_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG124_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG124_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG124_CTRL2    0x0e76
+#define    RTL8367C_SVLAN_C2SCFG124_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG124_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG125_CTRL0    0x0e77
+#define    RTL8367C_SVLAN_C2SCFG125_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG125_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG125_CTRL1    0x0e78
+#define    RTL8367C_SVLAN_C2SCFG125_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG125_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG125_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG125_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG125_CTRL2    0x0e79
+#define    RTL8367C_SVLAN_C2SCFG125_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG125_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG126_CTRL0    0x0e7a
+#define    RTL8367C_SVLAN_C2SCFG126_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG126_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG126_CTRL1    0x0e7b
+#define    RTL8367C_SVLAN_C2SCFG126_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG126_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG126_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG126_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG126_CTRL2    0x0e7c
+#define    RTL8367C_SVLAN_C2SCFG126_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG126_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG127_CTRL0    0x0e7d
+#define    RTL8367C_SVLAN_C2SCFG127_CTRL0_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG127_CTRL0_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_C2SCFG127_CTRL1    0x0e7e
+#define    RTL8367C_SVLAN_C2SCFG127_CTRL1_C2SENPMSK_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_C2SCFG127_CTRL1_C2SENPMSK_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_C2SCFG127_CTRL1_C2SENPMSK_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG127_CTRL1_C2SENPMSK_MASK    0xFF
+
+#define    RTL8367C_REG_SVLAN_C2SCFG127_CTRL2    0x0e7f
+#define    RTL8367C_SVLAN_C2SCFG127_CTRL2_OFFSET    0
+#define    RTL8367C_SVLAN_C2SCFG127_CTRL2_MASK    0x1FFF
+
+#define    RTL8367C_REG_SVLAN_CFG    0x0e80
+#define    RTL8367C_VS_PORT7_DMACVIDSEL_OFFSET    14
+#define    RTL8367C_VS_PORT7_DMACVIDSEL_MASK    0x4000
+#define    RTL8367C_VS_PORT6_DMACVIDSEL_OFFSET    13
+#define    RTL8367C_VS_PORT6_DMACVIDSEL_MASK    0x2000
+#define    RTL8367C_VS_PORT5_DMACVIDSEL_OFFSET    12
+#define    RTL8367C_VS_PORT5_DMACVIDSEL_MASK    0x1000
+#define    RTL8367C_VS_PORT4_DMACVIDSEL_OFFSET    11
+#define    RTL8367C_VS_PORT4_DMACVIDSEL_MASK    0x800
+#define    RTL8367C_VS_PORT3_DMACVIDSEL_OFFSET    10
+#define    RTL8367C_VS_PORT3_DMACVIDSEL_MASK    0x400
+#define    RTL8367C_VS_PORT2_DMACVIDSEL_OFFSET    9
+#define    RTL8367C_VS_PORT2_DMACVIDSEL_MASK    0x200
+#define    RTL8367C_VS_PORT1_DMACVIDSEL_OFFSET    8
+#define    RTL8367C_VS_PORT1_DMACVIDSEL_MASK    0x100
+#define    RTL8367C_VS_PORT0_DMACVIDSEL_OFFSET    7
+#define    RTL8367C_VS_PORT0_DMACVIDSEL_MASK    0x80
+#define    RTL8367C_VS_UIFSEG_OFFSET    6
+#define    RTL8367C_VS_UIFSEG_MASK    0x40
+#define    RTL8367C_VS_UNMAT_OFFSET    4
+#define    RTL8367C_VS_UNMAT_MASK    0x30
+#define    RTL8367C_VS_UNTAG_OFFSET    2
+#define    RTL8367C_VS_UNTAG_MASK    0xC
+#define    RTL8367C_VS_SPRISEL_OFFSET    0
+#define    RTL8367C_VS_SPRISEL_MASK    0x3
+
+#define    RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL0    0x0e81
+#define    RTL8367C_VS_PORT1_SVIDX_OFFSET    8
+#define    RTL8367C_VS_PORT1_SVIDX_MASK    0x3F00
+#define    RTL8367C_VS_PORT0_SVIDX_OFFSET    0
+#define    RTL8367C_VS_PORT0_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL1    0x0e82
+#define    RTL8367C_VS_PORT3_SVIDX_OFFSET    8
+#define    RTL8367C_VS_PORT3_SVIDX_MASK    0x3F00
+#define    RTL8367C_VS_PORT2_SVIDX_OFFSET    0
+#define    RTL8367C_VS_PORT2_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL2    0x0e83
+#define    RTL8367C_VS_PORT5_SVIDX_OFFSET    8
+#define    RTL8367C_VS_PORT5_SVIDX_MASK    0x3F00
+#define    RTL8367C_VS_PORT4_SVIDX_OFFSET    0
+#define    RTL8367C_VS_PORT4_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL3    0x0e84
+#define    RTL8367C_VS_PORT7_SVIDX_OFFSET    8
+#define    RTL8367C_VS_PORT7_SVIDX_MASK    0x3F00
+#define    RTL8367C_VS_PORT6_SVIDX_OFFSET    0
+#define    RTL8367C_VS_PORT6_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_UNTAG_UNMAT_CFG    0x0e85
+#define    RTL8367C_VS_UNTAG_SVIDX_OFFSET    8
+#define    RTL8367C_VS_UNTAG_SVIDX_MASK    0x3F00
+#define    RTL8367C_VS_UNMAT_SVIDX_OFFSET    0
+#define    RTL8367C_VS_UNMAT_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_LOOKUP_TYPE    0x0e86
+#define    RTL8367C_SVLAN_LOOKUP_TYPE_OFFSET    0
+#define    RTL8367C_SVLAN_LOOKUP_TYPE_MASK    0x1
+
+#define    RTL8367C_REG_IPMC_GROUP_VALID_15_0    0x0e87
+
+#define    RTL8367C_REG_IPMC_GROUP_VALID_31_16    0x0e88
+
+#define    RTL8367C_REG_IPMC_GROUP_VALID_47_32    0x0e89
+
+#define    RTL8367C_REG_IPMC_GROUP_VALID_63_48    0x0e8a
+
+#define    RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL4    0x0e8b
+#define    RTL8367C_VS_PORT9_SVIDX_OFFSET    8
+#define    RTL8367C_VS_PORT9_SVIDX_MASK    0x3F00
+#define    RTL8367C_VS_PORT8_SVIDX_OFFSET    0
+#define    RTL8367C_VS_PORT8_SVIDX_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL5    0x0e8c
+#define    RTL8367C_SVLAN_PORTBASED_SVIDX_CTRL5_OFFSET    0
+#define    RTL8367C_SVLAN_PORTBASED_SVIDX_CTRL5_MASK    0x3F
+
+#define    RTL8367C_REG_SVLAN_CFG_EXT    0x0e8d
+#define    RTL8367C_VS_PORT10_DMACVIDSEL_OFFSET    2
+#define    RTL8367C_VS_PORT10_DMACVIDSEL_MASK    0x4
+#define    RTL8367C_VS_PORT9_DMACVIDSEL_OFFSET    1
+#define    RTL8367C_VS_PORT9_DMACVIDSEL_MASK    0x2
+#define    RTL8367C_VS_PORT8_DMACVIDSEL_OFFSET    0
+#define    RTL8367C_VS_PORT8_DMACVIDSEL_MASK    0x1
+
+#define    RTL8367C_REG_SVLAN_MEMBERCFG63_CTRL4    0x0e8e
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL4_VS_UNTAGSET_EXT_OFFSET    8
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL4_VS_UNTAGSET_EXT_MASK    0x700
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL4_VS_SMBR_EXT_OFFSET    0
+#define    RTL8367C_SVLAN_MEMBERCFG63_CTRL4_VS_SMBR_EXT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_DUMMY_0    0x0e90
+
+#define    RTL8367C_REG_SVLAN_DUMMY_1    0x0e91
+
+#define    RTL8367C_REG_SVLAN_DUMMY_2    0x0e92
+
+#define    RTL8367C_REG_SVLAN_DUMMY_3    0x0e93
+
+#define    RTL8367C_REG_SVLAN_DUMMY_4    0x0e94
+
+#define    RTL8367C_REG_SVLAN_DUMMY_5    0x0e95
+
+#define    RTL8367C_REG_SVLAN_DUMMY_6    0x0e96
+
+#define    RTL8367C_REG_SVLAN_DUMMY_7    0x0e97
+
+#define    RTL8367C_REG_SVLAN_DUMMY_8    0x0e98
+
+#define    RTL8367C_REG_SVLAN_DUMMY_9    0x0e99
+
+#define    RTL8367C_REG_SVLAN_DUMMY_10    0x0e9a
+
+#define    RTL8367C_REG_SVLAN_DUMMY_11    0x0e9b
+
+#define    RTL8367C_REG_SVLAN_DUMMY_12    0x0e9c
+
+#define    RTL8367C_REG_SVLAN_DUMMY_13    0x0e9d
+
+#define    RTL8367C_REG_SVLAN_DUMMY_14    0x0e9e
+
+#define    RTL8367C_REG_SVLAN_DUMMY_15    0x0e9f
+
+#define    RTL8367C_REG_SVLAN_DUMMY_16    0x0ea0
+
+#define    RTL8367C_REG_SVLAN_DUMMY_17    0x0ea1
+
+#define    RTL8367C_REG_SVLAN_DUMMY_18    0x0ea2
+
+#define    RTL8367C_REG_SVLAN_DUMMY_19    0x0ea3
+
+#define    RTL8367C_REG_SVLAN_DUMMY_20    0x0ea4
+
+#define    RTL8367C_REG_SVLAN_DUMMY_21    0x0ea5
+
+#define    RTL8367C_REG_SVLAN_DUMMY_22    0x0ea6
+
+#define    RTL8367C_REG_SVLAN_DUMMY_23    0x0ea7
+
+#define    RTL8367C_REG_SVLAN_DUMMY_24    0x0ea8
+
+#define    RTL8367C_REG_SVLAN_DUMMY_25    0x0ea9
+
+#define    RTL8367C_REG_SVLAN_DUMMY_26    0x0eaa
+
+#define    RTL8367C_REG_SVLAN_DUMMY_27    0x0eab
+
+#define    RTL8367C_REG_SVLAN_DUMMY_28    0x0eac
+
+#define    RTL8367C_REG_SVLAN_DUMMY_29    0x0ead
+
+#define    RTL8367C_REG_SVLAN_DUMMY_30    0x0eae
+
+#define    RTL8367C_REG_SVLAN_DUMMY_31    0x0eaf
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_00    0x0eb0
+#define    RTL8367C_IPMC_GROUP_VID_00_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_00_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_01    0x0eb1
+#define    RTL8367C_IPMC_GROUP_VID_01_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_01_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_02    0x0eb2
+#define    RTL8367C_IPMC_GROUP_VID_02_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_02_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_03    0x0eb3
+#define    RTL8367C_IPMC_GROUP_VID_03_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_03_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_04    0x0eb4
+#define    RTL8367C_IPMC_GROUP_VID_04_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_04_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_05    0x0eb5
+#define    RTL8367C_IPMC_GROUP_VID_05_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_05_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_06    0x0eb6
+#define    RTL8367C_IPMC_GROUP_VID_06_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_06_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_07    0x0eb7
+#define    RTL8367C_IPMC_GROUP_VID_07_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_07_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_08    0x0eb8
+#define    RTL8367C_IPMC_GROUP_VID_08_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_08_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_09    0x0eb9
+#define    RTL8367C_IPMC_GROUP_VID_09_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_09_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_10    0x0eba
+#define    RTL8367C_IPMC_GROUP_VID_10_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_10_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_11    0x0ebb
+#define    RTL8367C_IPMC_GROUP_VID_11_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_11_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_12    0x0ebc
+#define    RTL8367C_IPMC_GROUP_VID_12_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_12_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_13    0x0ebd
+#define    RTL8367C_IPMC_GROUP_VID_13_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_13_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_14    0x0ebe
+#define    RTL8367C_IPMC_GROUP_VID_14_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_14_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_15    0x0ebf
+#define    RTL8367C_IPMC_GROUP_VID_15_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_15_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_16    0x0ec0
+#define    RTL8367C_IPMC_GROUP_VID_16_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_16_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_17    0x0ec1
+#define    RTL8367C_IPMC_GROUP_VID_17_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_17_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_18    0x0ec2
+#define    RTL8367C_IPMC_GROUP_VID_18_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_18_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_19    0x0ec3
+#define    RTL8367C_IPMC_GROUP_VID_19_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_19_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_20    0x0ec4
+#define    RTL8367C_IPMC_GROUP_VID_20_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_20_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_21    0x0ec5
+#define    RTL8367C_IPMC_GROUP_VID_21_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_21_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_22    0x0ec6
+#define    RTL8367C_IPMC_GROUP_VID_22_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_22_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_23    0x0ec7
+#define    RTL8367C_IPMC_GROUP_VID_23_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_23_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_24    0x0ec8
+#define    RTL8367C_IPMC_GROUP_VID_24_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_24_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_25    0x0ec9
+#define    RTL8367C_IPMC_GROUP_VID_25_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_25_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_26    0x0eca
+#define    RTL8367C_IPMC_GROUP_VID_26_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_26_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_27    0x0ecb
+#define    RTL8367C_IPMC_GROUP_VID_27_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_27_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_28    0x0ecc
+#define    RTL8367C_IPMC_GROUP_VID_28_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_28_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_29    0x0ecd
+#define    RTL8367C_IPMC_GROUP_VID_29_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_29_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_30    0x0ece
+#define    RTL8367C_IPMC_GROUP_VID_30_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_30_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_31    0x0ecf
+#define    RTL8367C_IPMC_GROUP_VID_31_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_31_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_32    0x0ed0
+#define    RTL8367C_IPMC_GROUP_VID_32_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_32_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_33    0x0ed1
+#define    RTL8367C_IPMC_GROUP_VID_33_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_33_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_34    0x0ed2
+#define    RTL8367C_IPMC_GROUP_VID_34_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_34_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_35    0x0ed3
+#define    RTL8367C_IPMC_GROUP_VID_35_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_35_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_36    0x0ed4
+#define    RTL8367C_IPMC_GROUP_VID_36_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_36_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_37    0x0ed5
+#define    RTL8367C_IPMC_GROUP_VID_37_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_37_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_38    0x0ed6
+#define    RTL8367C_IPMC_GROUP_VID_38_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_38_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_39    0x0ed7
+#define    RTL8367C_IPMC_GROUP_VID_39_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_39_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_40    0x0ed8
+#define    RTL8367C_IPMC_GROUP_VID_40_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_40_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_41    0x0ed9
+#define    RTL8367C_IPMC_GROUP_VID_41_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_41_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_42    0x0eda
+#define    RTL8367C_IPMC_GROUP_VID_42_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_42_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_43    0x0edb
+#define    RTL8367C_IPMC_GROUP_VID_43_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_43_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_44    0x0edc
+#define    RTL8367C_IPMC_GROUP_VID_44_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_44_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_45    0x0edd
+#define    RTL8367C_IPMC_GROUP_VID_45_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_45_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_46    0x0ede
+#define    RTL8367C_IPMC_GROUP_VID_46_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_46_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_47    0x0edf
+#define    RTL8367C_IPMC_GROUP_VID_47_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_47_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_48    0x0ef0
+#define    RTL8367C_IPMC_GROUP_VID_48_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_48_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_49    0x0ef1
+#define    RTL8367C_IPMC_GROUP_VID_49_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_49_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_50    0x0ef2
+#define    RTL8367C_IPMC_GROUP_VID_50_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_50_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_51    0x0ef3
+#define    RTL8367C_IPMC_GROUP_VID_51_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_51_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_52    0x0ef4
+#define    RTL8367C_IPMC_GROUP_VID_52_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_52_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_53    0x0ef5
+#define    RTL8367C_IPMC_GROUP_VID_53_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_53_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_54    0x0ef6
+#define    RTL8367C_IPMC_GROUP_VID_54_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_54_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_55    0x0ef7
+#define    RTL8367C_IPMC_GROUP_VID_55_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_55_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_56    0x0ef8
+#define    RTL8367C_IPMC_GROUP_VID_56_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_56_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_57    0x0ef9
+#define    RTL8367C_IPMC_GROUP_VID_57_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_57_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_58    0x0efa
+#define    RTL8367C_IPMC_GROUP_VID_58_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_58_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_59    0x0efb
+#define    RTL8367C_IPMC_GROUP_VID_59_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_59_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_60    0x0efc
+#define    RTL8367C_IPMC_GROUP_VID_60_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_60_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_61    0x0efd
+#define    RTL8367C_IPMC_GROUP_VID_61_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_61_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_62    0x0efe
+#define    RTL8367C_IPMC_GROUP_VID_62_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_62_MASK    0xFFF
+
+#define    RTL8367C_REG_IPMC_GROUP_VID_63    0x0eff
+#define    RTL8367C_IPMC_GROUP_VID_63_OFFSET    0
+#define    RTL8367C_IPMC_GROUP_VID_63_MASK    0xFFF
+
+/* (16'h0f00)hsactrl_reg */
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY0_CTRL0    0x0f00
+#define    RTL8367C_SVLAN_SP2C_ENTRY0_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY0_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY0_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY0_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY0_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY0_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY0_CTRL1    0x0f01
+#define    RTL8367C_SVLAN_SP2C_ENTRY0_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY0_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY0_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY0_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY1_CTRL0    0x0f02
+#define    RTL8367C_SVLAN_SP2C_ENTRY1_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY1_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY1_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY1_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY1_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY1_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY1_CTRL1    0x0f03
+#define    RTL8367C_SVLAN_SP2C_ENTRY1_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY1_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY1_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY1_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY2_CTRL0    0x0f04
+#define    RTL8367C_SVLAN_SP2C_ENTRY2_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY2_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY2_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY2_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY2_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY2_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY2_CTRL1    0x0f05
+#define    RTL8367C_SVLAN_SP2C_ENTRY2_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY2_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY2_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY2_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY3_CTRL0    0x0f06
+#define    RTL8367C_SVLAN_SP2C_ENTRY3_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY3_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY3_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY3_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY3_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY3_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY3_CTRL1    0x0f07
+#define    RTL8367C_SVLAN_SP2C_ENTRY3_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY3_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY3_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY3_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY4_CTRL0    0x0f08
+#define    RTL8367C_SVLAN_SP2C_ENTRY4_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY4_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY4_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY4_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY4_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY4_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY4_CTRL1    0x0f09
+#define    RTL8367C_SVLAN_SP2C_ENTRY4_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY4_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY4_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY4_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY5_CTRL0    0x0f0a
+#define    RTL8367C_SVLAN_SP2C_ENTRY5_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY5_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY5_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY5_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY5_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY5_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY5_CTRL1    0x0f0b
+#define    RTL8367C_SVLAN_SP2C_ENTRY5_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY5_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY5_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY5_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY6_CTRL0    0x0f0c
+#define    RTL8367C_SVLAN_SP2C_ENTRY6_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY6_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY6_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY6_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY6_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY6_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY6_CTRL1    0x0f0d
+#define    RTL8367C_SVLAN_SP2C_ENTRY6_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY6_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY6_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY6_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY7_CTRL0    0x0f0e
+#define    RTL8367C_SVLAN_SP2C_ENTRY7_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY7_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY7_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY7_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY7_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY7_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY7_CTRL1    0x0f0f
+#define    RTL8367C_SVLAN_SP2C_ENTRY7_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY7_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY7_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY7_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY8_CTRL0    0x0f10
+#define    RTL8367C_SVLAN_SP2C_ENTRY8_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY8_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY8_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY8_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY8_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY8_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY8_CTRL1    0x0f11
+#define    RTL8367C_SVLAN_SP2C_ENTRY8_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY8_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY8_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY8_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY9_CTRL0    0x0f12
+#define    RTL8367C_SVLAN_SP2C_ENTRY9_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY9_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY9_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY9_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY9_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY9_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY9_CTRL1    0x0f13
+#define    RTL8367C_SVLAN_SP2C_ENTRY9_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY9_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY9_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY9_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY10_CTRL0    0x0f14
+#define    RTL8367C_SVLAN_SP2C_ENTRY10_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY10_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY10_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY10_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY10_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY10_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY10_CTRL1    0x0f15
+#define    RTL8367C_SVLAN_SP2C_ENTRY10_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY10_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY10_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY10_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY11_CTRL0    0x0f16
+#define    RTL8367C_SVLAN_SP2C_ENTRY11_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY11_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY11_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY11_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY11_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY11_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY11_CTRL1    0x0f17
+#define    RTL8367C_SVLAN_SP2C_ENTRY11_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY11_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY11_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY11_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY12_CTRL0    0x0f18
+#define    RTL8367C_SVLAN_SP2C_ENTRY12_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY12_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY12_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY12_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY12_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY12_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY12_CTRL1    0x0f19
+#define    RTL8367C_SVLAN_SP2C_ENTRY12_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY12_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY12_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY12_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY13_CTRL0    0x0f1a
+#define    RTL8367C_SVLAN_SP2C_ENTRY13_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY13_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY13_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY13_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY13_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY13_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY13_CTRL1    0x0f1b
+#define    RTL8367C_SVLAN_SP2C_ENTRY13_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY13_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY13_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY13_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY14_CTRL0    0x0f1c
+#define    RTL8367C_SVLAN_SP2C_ENTRY14_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY14_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY14_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY14_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY14_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY14_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY14_CTRL1    0x0f1d
+#define    RTL8367C_SVLAN_SP2C_ENTRY14_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY14_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY14_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY14_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY15_CTRL0    0x0f1e
+#define    RTL8367C_SVLAN_SP2C_ENTRY15_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY15_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY15_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY15_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY15_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY15_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY15_CTRL1    0x0f1f
+#define    RTL8367C_SVLAN_SP2C_ENTRY15_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY15_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY15_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY15_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY16_CTRL0    0x0f20
+#define    RTL8367C_SVLAN_SP2C_ENTRY16_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY16_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY16_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY16_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY16_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY16_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY16_CTRL1    0x0f21
+#define    RTL8367C_SVLAN_SP2C_ENTRY16_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY16_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY16_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY16_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY17_CTRL0    0x0f22
+#define    RTL8367C_SVLAN_SP2C_ENTRY17_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY17_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY17_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY17_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY17_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY17_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY17_CTRL1    0x0f23
+#define    RTL8367C_SVLAN_SP2C_ENTRY17_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY17_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY17_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY17_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY18_CTRL0    0x0f24
+#define    RTL8367C_SVLAN_SP2C_ENTRY18_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY18_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY18_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY18_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY18_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY18_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY18_CTRL1    0x0f25
+#define    RTL8367C_SVLAN_SP2C_ENTRY18_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY18_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY18_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY18_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY19_CTRL0    0x0f26
+#define    RTL8367C_SVLAN_SP2C_ENTRY19_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY19_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY19_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY19_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY19_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY19_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY19_CTRL1    0x0f27
+#define    RTL8367C_SVLAN_SP2C_ENTRY19_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY19_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY19_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY19_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY20_CTRL0    0x0f28
+#define    RTL8367C_SVLAN_SP2C_ENTRY20_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY20_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY20_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY20_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY20_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY20_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY20_CTRL1    0x0f29
+#define    RTL8367C_SVLAN_SP2C_ENTRY20_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY20_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY20_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY20_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY21_CTRL0    0x0f2a
+#define    RTL8367C_SVLAN_SP2C_ENTRY21_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY21_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY21_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY21_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY21_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY21_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY21_CTRL1    0x0f2b
+#define    RTL8367C_SVLAN_SP2C_ENTRY21_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY21_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY21_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY21_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY22_CTRL0    0x0f2c
+#define    RTL8367C_SVLAN_SP2C_ENTRY22_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY22_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY22_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY22_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY22_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY22_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY22_CTRL1    0x0f2d
+#define    RTL8367C_SVLAN_SP2C_ENTRY22_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY22_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY22_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY22_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY23_CTRL0    0x0f2e
+#define    RTL8367C_SVLAN_SP2C_ENTRY23_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY23_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY23_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY23_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY23_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY23_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY23_CTRL1    0x0f2f
+#define    RTL8367C_SVLAN_SP2C_ENTRY23_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY23_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY23_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY23_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY24_CTRL0    0x0f30
+#define    RTL8367C_SVLAN_SP2C_ENTRY24_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY24_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY24_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY24_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY24_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY24_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY24_CTRL1    0x0f31
+#define    RTL8367C_SVLAN_SP2C_ENTRY24_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY24_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY24_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY24_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY25_CTRL0    0x0f32
+#define    RTL8367C_SVLAN_SP2C_ENTRY25_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY25_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY25_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY25_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY25_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY25_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY25_CTRL1    0x0f33
+#define    RTL8367C_SVLAN_SP2C_ENTRY25_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY25_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY25_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY25_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY26_CTRL0    0x0f34
+#define    RTL8367C_SVLAN_SP2C_ENTRY26_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY26_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY26_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY26_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY26_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY26_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY26_CTRL1    0x0f35
+#define    RTL8367C_SVLAN_SP2C_ENTRY26_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY26_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY26_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY26_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY27_CTRL0    0x0f36
+#define    RTL8367C_SVLAN_SP2C_ENTRY27_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY27_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY27_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY27_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY27_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY27_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY27_CTRL1    0x0f37
+#define    RTL8367C_SVLAN_SP2C_ENTRY27_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY27_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY27_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY27_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY28_CTRL0    0x0f38
+#define    RTL8367C_SVLAN_SP2C_ENTRY28_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY28_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY28_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY28_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY28_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY28_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY28_CTRL1    0x0f39
+#define    RTL8367C_SVLAN_SP2C_ENTRY28_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY28_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY28_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY28_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY29_CTRL0    0x0f3a
+#define    RTL8367C_SVLAN_SP2C_ENTRY29_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY29_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY29_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY29_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY29_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY29_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY29_CTRL1    0x0f3b
+#define    RTL8367C_SVLAN_SP2C_ENTRY29_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY29_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY29_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY29_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY30_CTRL0    0x0f3c
+#define    RTL8367C_SVLAN_SP2C_ENTRY30_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY30_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY30_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY30_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY30_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY30_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY30_CTRL1    0x0f3d
+#define    RTL8367C_SVLAN_SP2C_ENTRY30_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY30_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY30_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY30_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY31_CTRL0    0x0f3e
+#define    RTL8367C_SVLAN_SP2C_ENTRY31_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY31_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY31_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY31_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY31_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY31_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY31_CTRL1    0x0f3f
+#define    RTL8367C_SVLAN_SP2C_ENTRY31_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY31_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY31_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY31_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY32_CTRL0    0x0f40
+#define    RTL8367C_SVLAN_SP2C_ENTRY32_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY32_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY32_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY32_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY32_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY32_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY32_CTRL1    0x0f41
+#define    RTL8367C_SVLAN_SP2C_ENTRY32_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY32_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY32_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY32_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY33_CTRL0    0x0f42
+#define    RTL8367C_SVLAN_SP2C_ENTRY33_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY33_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY33_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY33_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY33_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY33_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY33_CTRL1    0x0f43
+#define    RTL8367C_SVLAN_SP2C_ENTRY33_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY33_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY33_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY33_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY34_CTRL0    0x0f44
+#define    RTL8367C_SVLAN_SP2C_ENTRY34_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY34_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY34_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY34_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY34_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY34_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY34_CTRL1    0x0f45
+#define    RTL8367C_SVLAN_SP2C_ENTRY34_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY34_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY34_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY34_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY35_CTRL0    0x0f46
+#define    RTL8367C_SVLAN_SP2C_ENTRY35_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY35_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY35_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY35_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY35_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY35_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY35_CTRL1    0x0f47
+#define    RTL8367C_SVLAN_SP2C_ENTRY35_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY35_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY35_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY35_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY36_CTRL0    0x0f48
+#define    RTL8367C_SVLAN_SP2C_ENTRY36_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY36_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY36_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY36_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY36_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY36_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY36_CTRL1    0x0f49
+#define    RTL8367C_SVLAN_SP2C_ENTRY36_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY36_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY36_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY36_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY37_CTRL0    0x0f4a
+#define    RTL8367C_SVLAN_SP2C_ENTRY37_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY37_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY37_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY37_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY37_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY37_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY37_CTRL1    0x0f4b
+#define    RTL8367C_SVLAN_SP2C_ENTRY37_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY37_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY37_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY37_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY38_CTRL0    0x0f4c
+#define    RTL8367C_SVLAN_SP2C_ENTRY38_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY38_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY38_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY38_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY38_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY38_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY38_CTRL1    0x0f4d
+#define    RTL8367C_SVLAN_SP2C_ENTRY38_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY38_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY38_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY38_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY39_CTRL0    0x0f4e
+#define    RTL8367C_SVLAN_SP2C_ENTRY39_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY39_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY39_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY39_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY39_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY39_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY39_CTRL1    0x0f4f
+#define    RTL8367C_SVLAN_SP2C_ENTRY39_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY39_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY39_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY39_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY40_CTRL0    0x0f50
+#define    RTL8367C_SVLAN_SP2C_ENTRY40_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY40_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY40_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY40_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY40_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY40_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY40_CTRL1    0x0f51
+#define    RTL8367C_SVLAN_SP2C_ENTRY40_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY40_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY40_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY40_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY41_CTRL0    0x0f52
+#define    RTL8367C_SVLAN_SP2C_ENTRY41_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY41_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY41_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY41_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY41_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY41_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY41_CTRL1    0x0f53
+#define    RTL8367C_SVLAN_SP2C_ENTRY41_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY41_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY41_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY41_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY42_CTRL0    0x0f54
+#define    RTL8367C_SVLAN_SP2C_ENTRY42_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY42_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY42_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY42_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY42_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY42_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY42_CTRL1    0x0f55
+#define    RTL8367C_SVLAN_SP2C_ENTRY42_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY42_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY42_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY42_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY43_CTRL0    0x0f56
+#define    RTL8367C_SVLAN_SP2C_ENTRY43_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY43_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY43_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY43_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY43_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY43_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY43_CTRL1    0x0f57
+#define    RTL8367C_SVLAN_SP2C_ENTRY43_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY43_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY43_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY43_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY44_CTRL0    0x0f58
+#define    RTL8367C_SVLAN_SP2C_ENTRY44_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY44_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY44_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY44_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY44_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY44_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY44_CTRL1    0x0f59
+#define    RTL8367C_SVLAN_SP2C_ENTRY44_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY44_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY44_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY44_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY45_CTRL0    0x0f5a
+#define    RTL8367C_SVLAN_SP2C_ENTRY45_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY45_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY45_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY45_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY45_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY45_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY45_CTRL1    0x0f5b
+#define    RTL8367C_SVLAN_SP2C_ENTRY45_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY45_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY45_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY45_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY46_CTRL0    0x0f5c
+#define    RTL8367C_SVLAN_SP2C_ENTRY46_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY46_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY46_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY46_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY46_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY46_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY46_CTRL1    0x0f5d
+#define    RTL8367C_SVLAN_SP2C_ENTRY46_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY46_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY46_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY46_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY47_CTRL0    0x0f5e
+#define    RTL8367C_SVLAN_SP2C_ENTRY47_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY47_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY47_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY47_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY47_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY47_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY47_CTRL1    0x0f5f
+#define    RTL8367C_SVLAN_SP2C_ENTRY47_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY47_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY47_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY47_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY48_CTRL0    0x0f60
+#define    RTL8367C_SVLAN_SP2C_ENTRY48_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY48_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY48_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY48_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY48_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY48_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY48_CTRL1    0x0f61
+#define    RTL8367C_SVLAN_SP2C_ENTRY48_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY48_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY48_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY48_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY49_CTRL0    0x0f62
+#define    RTL8367C_SVLAN_SP2C_ENTRY49_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY49_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY49_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY49_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY49_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY49_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY49_CTRL1    0x0f63
+#define    RTL8367C_SVLAN_SP2C_ENTRY49_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY49_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY49_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY49_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY50_CTRL0    0x0f64
+#define    RTL8367C_SVLAN_SP2C_ENTRY50_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY50_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY50_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY50_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY50_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY50_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY50_CTRL1    0x0f65
+#define    RTL8367C_SVLAN_SP2C_ENTRY50_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY50_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY50_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY50_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY51_CTRL0    0x0f66
+#define    RTL8367C_SVLAN_SP2C_ENTRY51_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY51_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY51_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY51_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY51_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY51_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY51_CTRL1    0x0f67
+#define    RTL8367C_SVLAN_SP2C_ENTRY51_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY51_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY51_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY51_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY52_CTRL0    0x0f68
+#define    RTL8367C_SVLAN_SP2C_ENTRY52_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY52_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY52_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY52_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY52_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY52_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY52_CTRL1    0x0f69
+#define    RTL8367C_SVLAN_SP2C_ENTRY52_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY52_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY52_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY52_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY53_CTRL0    0x0f6a
+#define    RTL8367C_SVLAN_SP2C_ENTRY53_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY53_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY53_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY53_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY53_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY53_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY53_CTRL1    0x0f6b
+#define    RTL8367C_SVLAN_SP2C_ENTRY53_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY53_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY53_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY53_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY54_CTRL0    0x0f6c
+#define    RTL8367C_SVLAN_SP2C_ENTRY54_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY54_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY54_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY54_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY54_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY54_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY54_CTRL1    0x0f6d
+#define    RTL8367C_SVLAN_SP2C_ENTRY54_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY54_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY54_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY54_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY55_CTRL0    0x0f6e
+#define    RTL8367C_SVLAN_SP2C_ENTRY55_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY55_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY55_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY55_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY55_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY55_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY55_CTRL1    0x0f6f
+#define    RTL8367C_SVLAN_SP2C_ENTRY55_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY55_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY55_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY55_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY56_CTRL0    0x0f70
+#define    RTL8367C_SVLAN_SP2C_ENTRY56_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY56_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY56_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY56_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY56_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY56_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY56_CTRL1    0x0f71
+#define    RTL8367C_SVLAN_SP2C_ENTRY56_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY56_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY56_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY56_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY57_CTRL0    0x0f72
+#define    RTL8367C_SVLAN_SP2C_ENTRY57_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY57_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY57_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY57_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY57_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY57_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY57_CTRL1    0x0f73
+#define    RTL8367C_SVLAN_SP2C_ENTRY57_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY57_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY57_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY57_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY58_CTRL0    0x0f74
+#define    RTL8367C_SVLAN_SP2C_ENTRY58_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY58_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY58_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY58_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY58_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY58_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY58_CTRL1    0x0f75
+#define    RTL8367C_SVLAN_SP2C_ENTRY58_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY58_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY58_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY58_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY59_CTRL0    0x0f76
+#define    RTL8367C_SVLAN_SP2C_ENTRY59_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY59_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY59_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY59_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY59_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY59_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY59_CTRL1    0x0f77
+#define    RTL8367C_SVLAN_SP2C_ENTRY59_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY59_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY59_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY59_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY60_CTRL0    0x0f78
+#define    RTL8367C_SVLAN_SP2C_ENTRY60_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY60_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY60_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY60_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY60_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY60_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY60_CTRL1    0x0f79
+#define    RTL8367C_SVLAN_SP2C_ENTRY60_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY60_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY60_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY60_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY61_CTRL0    0x0f7a
+#define    RTL8367C_SVLAN_SP2C_ENTRY61_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY61_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY61_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY61_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY61_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY61_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY61_CTRL1    0x0f7b
+#define    RTL8367C_SVLAN_SP2C_ENTRY61_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY61_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY61_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY61_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY62_CTRL0    0x0f7c
+#define    RTL8367C_SVLAN_SP2C_ENTRY62_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY62_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY62_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY62_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY62_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY62_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY62_CTRL1    0x0f7d
+#define    RTL8367C_SVLAN_SP2C_ENTRY62_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY62_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY62_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY62_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY63_CTRL0    0x0f7e
+#define    RTL8367C_SVLAN_SP2C_ENTRY63_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY63_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY63_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY63_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY63_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY63_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY63_CTRL1    0x0f7f
+#define    RTL8367C_SVLAN_SP2C_ENTRY63_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY63_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY63_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY63_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY64_CTRL0    0x0f80
+#define    RTL8367C_SVLAN_SP2C_ENTRY64_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY64_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY64_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY64_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY64_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY64_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY64_CTRL1    0x0f81
+#define    RTL8367C_SVLAN_SP2C_ENTRY64_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY64_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY64_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY64_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY65_CTRL0    0x0f82
+#define    RTL8367C_SVLAN_SP2C_ENTRY65_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY65_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY65_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY65_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY65_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY65_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY65_CTRL1    0x0f83
+#define    RTL8367C_SVLAN_SP2C_ENTRY65_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY65_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY65_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY65_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY66_CTRL0    0x0f84
+#define    RTL8367C_SVLAN_SP2C_ENTRY66_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY66_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY66_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY66_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY66_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY66_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY66_CTRL1    0x0f85
+#define    RTL8367C_SVLAN_SP2C_ENTRY66_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY66_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY66_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY66_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY67_CTRL0    0x0f86
+#define    RTL8367C_SVLAN_SP2C_ENTRY67_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY67_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY67_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY67_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY67_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY67_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY67_CTRL1    0x0f87
+#define    RTL8367C_SVLAN_SP2C_ENTRY67_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY67_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY67_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY67_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY68_CTRL0    0x0f88
+#define    RTL8367C_SVLAN_SP2C_ENTRY68_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY68_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY68_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY68_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY68_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY68_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY68_CTRL1    0x0f89
+#define    RTL8367C_SVLAN_SP2C_ENTRY68_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY68_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY68_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY68_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY69_CTRL0    0x0f8a
+#define    RTL8367C_SVLAN_SP2C_ENTRY69_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY69_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY69_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY69_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY69_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY69_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY69_CTRL1    0x0f8b
+#define    RTL8367C_SVLAN_SP2C_ENTRY69_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY69_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY69_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY69_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY70_CTRL0    0x0f8c
+#define    RTL8367C_SVLAN_SP2C_ENTRY70_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY70_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY70_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY70_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY70_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY70_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY70_CTRL1    0x0f8d
+#define    RTL8367C_SVLAN_SP2C_ENTRY70_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY70_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY70_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY70_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY71_CTRL0    0x0f8e
+#define    RTL8367C_SVLAN_SP2C_ENTRY71_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY71_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY71_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY71_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY71_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY71_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY71_CTRL1    0x0f8f
+#define    RTL8367C_SVLAN_SP2C_ENTRY71_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY71_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY71_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY71_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY72_CTRL0    0x0f90
+#define    RTL8367C_SVLAN_SP2C_ENTRY72_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY72_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY72_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY72_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY72_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY72_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY72_CTRL1    0x0f91
+#define    RTL8367C_SVLAN_SP2C_ENTRY72_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY72_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY72_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY72_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY73_CTRL0    0x0f92
+#define    RTL8367C_SVLAN_SP2C_ENTRY73_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY73_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY73_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY73_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY73_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY73_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY73_CTRL1    0x0f93
+#define    RTL8367C_SVLAN_SP2C_ENTRY73_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY73_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY73_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY73_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY74_CTRL0    0x0f94
+#define    RTL8367C_SVLAN_SP2C_ENTRY74_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY74_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY74_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY74_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY74_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY74_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY74_CTRL1    0x0f95
+#define    RTL8367C_SVLAN_SP2C_ENTRY74_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY74_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY74_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY74_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY75_CTRL0    0x0f96
+#define    RTL8367C_SVLAN_SP2C_ENTRY75_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY75_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY75_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY75_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY75_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY75_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY75_CTRL1    0x0f97
+#define    RTL8367C_SVLAN_SP2C_ENTRY75_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY75_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY75_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY75_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY76_CTRL0    0x0f98
+#define    RTL8367C_SVLAN_SP2C_ENTRY76_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY76_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY76_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY76_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY76_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY76_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY76_CTRL1    0x0f99
+#define    RTL8367C_SVLAN_SP2C_ENTRY76_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY76_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY76_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY76_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY77_CTRL0    0x0f9a
+#define    RTL8367C_SVLAN_SP2C_ENTRY77_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY77_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY77_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY77_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY77_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY77_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY77_CTRL1    0x0f9b
+#define    RTL8367C_SVLAN_SP2C_ENTRY77_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY77_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY77_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY77_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY78_CTRL0    0x0f9c
+#define    RTL8367C_SVLAN_SP2C_ENTRY78_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY78_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY78_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY78_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY78_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY78_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY78_CTRL1    0x0f9d
+#define    RTL8367C_SVLAN_SP2C_ENTRY78_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY78_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY78_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY78_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY79_CTRL0    0x0f9e
+#define    RTL8367C_SVLAN_SP2C_ENTRY79_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY79_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY79_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY79_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY79_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY79_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY79_CTRL1    0x0f9f
+#define    RTL8367C_SVLAN_SP2C_ENTRY79_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY79_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY79_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY79_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY80_CTRL0    0x0fa0
+#define    RTL8367C_SVLAN_SP2C_ENTRY80_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY80_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY80_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY80_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY80_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY80_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY80_CTRL1    0x0fa1
+#define    RTL8367C_SVLAN_SP2C_ENTRY80_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY80_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY80_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY80_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY81_CTRL0    0x0fa2
+#define    RTL8367C_SVLAN_SP2C_ENTRY81_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY81_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY81_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY81_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY81_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY81_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY81_CTRL1    0x0fa3
+#define    RTL8367C_SVLAN_SP2C_ENTRY81_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY81_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY81_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY81_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY82_CTRL0    0x0fa4
+#define    RTL8367C_SVLAN_SP2C_ENTRY82_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY82_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY82_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY82_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY82_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY82_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY82_CTRL1    0x0fa5
+#define    RTL8367C_SVLAN_SP2C_ENTRY82_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY82_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY82_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY82_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY83_CTRL0    0x0fa6
+#define    RTL8367C_SVLAN_SP2C_ENTRY83_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY83_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY83_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY83_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY83_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY83_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY83_CTRL1    0x0fa7
+#define    RTL8367C_SVLAN_SP2C_ENTRY83_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY83_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY83_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY83_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY84_CTRL0    0x0fa8
+#define    RTL8367C_SVLAN_SP2C_ENTRY84_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY84_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY84_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY84_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY84_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY84_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY84_CTRL1    0x0fa9
+#define    RTL8367C_SVLAN_SP2C_ENTRY84_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY84_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY84_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY84_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY85_CTRL0    0x0faa
+#define    RTL8367C_SVLAN_SP2C_ENTRY85_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY85_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY85_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY85_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY85_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY85_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY85_CTRL1    0x0fab
+#define    RTL8367C_SVLAN_SP2C_ENTRY85_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY85_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY85_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY85_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY86_CTRL0    0x0fac
+#define    RTL8367C_SVLAN_SP2C_ENTRY86_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY86_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY86_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY86_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY86_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY86_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY86_CTRL1    0x0fad
+#define    RTL8367C_SVLAN_SP2C_ENTRY86_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY86_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY86_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY86_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY87_CTRL0    0x0fae
+#define    RTL8367C_SVLAN_SP2C_ENTRY87_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY87_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY87_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY87_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY87_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY87_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY87_CTRL1    0x0faf
+#define    RTL8367C_SVLAN_SP2C_ENTRY87_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY87_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY87_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY87_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY88_CTRL0    0x0fb0
+#define    RTL8367C_SVLAN_SP2C_ENTRY88_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY88_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY88_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY88_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY88_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY88_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY88_CTRL1    0x0fb1
+#define    RTL8367C_SVLAN_SP2C_ENTRY88_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY88_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY88_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY88_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY89_CTRL0    0x0fb2
+#define    RTL8367C_SVLAN_SP2C_ENTRY89_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY89_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY89_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY89_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY89_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY89_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY89_CTRL1    0x0fb3
+#define    RTL8367C_SVLAN_SP2C_ENTRY89_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY89_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY89_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY89_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY90_CTRL0    0x0fb4
+#define    RTL8367C_SVLAN_SP2C_ENTRY90_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY90_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY90_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY90_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY90_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY90_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY90_CTRL1    0x0fb5
+#define    RTL8367C_SVLAN_SP2C_ENTRY90_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY90_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY90_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY90_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY91_CTRL0    0x0fb6
+#define    RTL8367C_SVLAN_SP2C_ENTRY91_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY91_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY91_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY91_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY91_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY91_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY91_CTRL1    0x0fb7
+#define    RTL8367C_SVLAN_SP2C_ENTRY91_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY91_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY91_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY91_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY92_CTRL0    0x0fb8
+#define    RTL8367C_SVLAN_SP2C_ENTRY92_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY92_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY92_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY92_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY92_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY92_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY92_CTRL1    0x0fb9
+#define    RTL8367C_SVLAN_SP2C_ENTRY92_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY92_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY92_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY92_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY93_CTRL0    0x0fba
+#define    RTL8367C_SVLAN_SP2C_ENTRY93_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY93_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY93_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY93_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY93_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY93_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY93_CTRL1    0x0fbb
+#define    RTL8367C_SVLAN_SP2C_ENTRY93_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY93_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY93_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY93_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY94_CTRL0    0x0fbc
+#define    RTL8367C_SVLAN_SP2C_ENTRY94_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY94_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY94_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY94_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY94_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY94_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY94_CTRL1    0x0fbd
+#define    RTL8367C_SVLAN_SP2C_ENTRY94_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY94_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY94_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY94_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY95_CTRL0    0x0fbe
+#define    RTL8367C_SVLAN_SP2C_ENTRY95_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY95_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY95_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY95_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY95_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY95_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY95_CTRL1    0x0fbf
+#define    RTL8367C_SVLAN_SP2C_ENTRY95_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY95_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY95_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY95_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY96_CTRL0    0x0fc0
+#define    RTL8367C_SVLAN_SP2C_ENTRY96_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY96_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY96_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY96_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY96_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY96_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY96_CTRL1    0x0fc1
+#define    RTL8367C_SVLAN_SP2C_ENTRY96_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY96_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY96_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY96_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY97_CTRL0    0x0fc2
+#define    RTL8367C_SVLAN_SP2C_ENTRY97_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY97_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY97_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY97_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY97_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY97_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY97_CTRL1    0x0fc3
+#define    RTL8367C_SVLAN_SP2C_ENTRY97_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY97_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY97_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY97_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY98_CTRL0    0x0fc4
+#define    RTL8367C_SVLAN_SP2C_ENTRY98_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY98_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY98_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY98_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY98_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY98_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY98_CTRL1    0x0fc5
+#define    RTL8367C_SVLAN_SP2C_ENTRY98_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY98_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY98_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY98_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY99_CTRL0    0x0fc6
+#define    RTL8367C_SVLAN_SP2C_ENTRY99_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY99_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY99_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY99_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY99_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY99_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY99_CTRL1    0x0fc7
+#define    RTL8367C_SVLAN_SP2C_ENTRY99_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY99_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY99_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY99_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY100_CTRL0    0x0fc8
+#define    RTL8367C_SVLAN_SP2C_ENTRY100_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY100_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY100_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY100_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY100_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY100_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY100_CTRL1    0x0fc9
+#define    RTL8367C_SVLAN_SP2C_ENTRY100_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY100_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY100_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY100_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY101_CTRL0    0x0fca
+#define    RTL8367C_SVLAN_SP2C_ENTRY101_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY101_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY101_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY101_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY101_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY101_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY101_CTRL1    0x0fcb
+#define    RTL8367C_SVLAN_SP2C_ENTRY101_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY101_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY101_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY101_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY102_CTRL0    0x0fcc
+#define    RTL8367C_SVLAN_SP2C_ENTRY102_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY102_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY102_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY102_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY102_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY102_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY102_CTRL1    0x0fcd
+#define    RTL8367C_SVLAN_SP2C_ENTRY102_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY102_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY102_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY102_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY103_CTRL0    0x0fce
+#define    RTL8367C_SVLAN_SP2C_ENTRY103_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY103_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY103_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY103_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY103_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY103_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY103_CTRL1    0x0fcf
+#define    RTL8367C_SVLAN_SP2C_ENTRY103_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY103_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY103_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY103_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY104_CTRL0    0x0fd0
+#define    RTL8367C_SVLAN_SP2C_ENTRY104_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY104_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY104_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY104_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY104_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY104_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY104_CTRL1    0x0fd1
+#define    RTL8367C_SVLAN_SP2C_ENTRY104_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY104_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY104_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY104_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY105_CTRL0    0x0fd2
+#define    RTL8367C_SVLAN_SP2C_ENTRY105_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY105_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY105_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY105_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY105_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY105_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY105_CTRL1    0x0fd3
+#define    RTL8367C_SVLAN_SP2C_ENTRY105_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY105_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY105_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY105_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY106_CTRL0    0x0fd4
+#define    RTL8367C_SVLAN_SP2C_ENTRY106_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY106_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY106_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY106_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY106_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY106_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY106_CTRL1    0x0fd5
+#define    RTL8367C_SVLAN_SP2C_ENTRY106_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY106_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY106_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY106_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY107_CTRL0    0x0fd6
+#define    RTL8367C_SVLAN_SP2C_ENTRY107_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY107_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY107_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY107_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY107_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY107_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY107_CTRL1    0x0fd7
+#define    RTL8367C_SVLAN_SP2C_ENTRY107_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY107_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY107_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY107_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY108_CTRL0    0x0fd8
+#define    RTL8367C_SVLAN_SP2C_ENTRY108_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY108_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY108_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY108_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY108_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY108_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY108_CTRL1    0x0fd9
+#define    RTL8367C_SVLAN_SP2C_ENTRY108_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY108_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY108_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY108_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY109_CTRL0    0x0fda
+#define    RTL8367C_SVLAN_SP2C_ENTRY109_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY109_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY109_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY109_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY109_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY109_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY109_CTRL1    0x0fdb
+#define    RTL8367C_SVLAN_SP2C_ENTRY109_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY109_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY109_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY109_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY110_CTRL0    0x0fdc
+#define    RTL8367C_SVLAN_SP2C_ENTRY110_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY110_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY110_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY110_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY110_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY110_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY110_CTRL1    0x0fdd
+#define    RTL8367C_SVLAN_SP2C_ENTRY110_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY110_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY110_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY110_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY111_CTRL0    0x0fde
+#define    RTL8367C_SVLAN_SP2C_ENTRY111_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY111_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY111_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY111_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY111_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY111_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY111_CTRL1    0x0fdf
+#define    RTL8367C_SVLAN_SP2C_ENTRY111_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY111_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY111_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY111_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY112_CTRL0    0x0fe0
+#define    RTL8367C_SVLAN_SP2C_ENTRY112_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY112_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY112_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY112_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY112_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY112_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY112_CTRL1    0x0fe1
+#define    RTL8367C_SVLAN_SP2C_ENTRY112_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY112_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY112_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY112_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY113_CTRL0    0x0fe2
+#define    RTL8367C_SVLAN_SP2C_ENTRY113_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY113_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY113_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY113_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY113_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY113_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY113_CTRL1    0x0fe3
+#define    RTL8367C_SVLAN_SP2C_ENTRY113_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY113_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY113_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY113_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY114_CTRL0    0x0fe4
+#define    RTL8367C_SVLAN_SP2C_ENTRY114_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY114_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY114_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY114_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY114_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY114_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY114_CTRL1    0x0fe5
+#define    RTL8367C_SVLAN_SP2C_ENTRY114_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY114_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY114_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY114_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY115_CTRL0    0x0fe6
+#define    RTL8367C_SVLAN_SP2C_ENTRY115_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY115_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY115_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY115_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY115_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY115_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY115_CTRL1    0x0fe7
+#define    RTL8367C_SVLAN_SP2C_ENTRY115_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY115_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY115_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY115_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY116_CTRL0    0x0fe8
+#define    RTL8367C_SVLAN_SP2C_ENTRY116_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY116_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY116_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY116_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY116_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY116_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY116_CTRL1    0x0fe9
+#define    RTL8367C_SVLAN_SP2C_ENTRY116_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY116_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY116_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY116_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY117_CTRL0    0x0fea
+#define    RTL8367C_SVLAN_SP2C_ENTRY117_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY117_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY117_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY117_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY117_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY117_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY117_CTRL1    0x0feb
+#define    RTL8367C_SVLAN_SP2C_ENTRY117_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY117_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY117_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY117_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY118_CTRL0    0x0fec
+#define    RTL8367C_SVLAN_SP2C_ENTRY118_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY118_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY118_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY118_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY118_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY118_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY118_CTRL1    0x0fed
+#define    RTL8367C_SVLAN_SP2C_ENTRY118_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY118_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY118_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY118_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY119_CTRL0    0x0fee
+#define    RTL8367C_SVLAN_SP2C_ENTRY119_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY119_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY119_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY119_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY119_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY119_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY119_CTRL1    0x0fef
+#define    RTL8367C_SVLAN_SP2C_ENTRY119_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY119_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY119_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY119_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY120_CTRL0    0x0ff0
+#define    RTL8367C_SVLAN_SP2C_ENTRY120_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY120_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY120_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY120_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY120_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY120_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY120_CTRL1    0x0ff1
+#define    RTL8367C_SVLAN_SP2C_ENTRY120_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY120_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY120_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY120_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY121_CTRL0    0x0ff2
+#define    RTL8367C_SVLAN_SP2C_ENTRY121_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY121_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY121_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY121_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY121_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY121_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY121_CTRL1    0x0ff3
+#define    RTL8367C_SVLAN_SP2C_ENTRY121_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY121_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY121_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY121_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY122_CTRL0    0x0ff4
+#define    RTL8367C_SVLAN_SP2C_ENTRY122_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY122_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY122_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY122_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY122_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY122_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY122_CTRL1    0x0ff5
+#define    RTL8367C_SVLAN_SP2C_ENTRY122_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY122_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY122_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY122_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY123_CTRL0    0x0ff6
+#define    RTL8367C_SVLAN_SP2C_ENTRY123_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY123_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY123_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY123_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY123_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY123_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY123_CTRL1    0x0ff7
+#define    RTL8367C_SVLAN_SP2C_ENTRY123_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY123_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY123_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY123_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY124_CTRL0    0x0ff8
+#define    RTL8367C_SVLAN_SP2C_ENTRY124_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY124_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY124_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY124_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY124_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY124_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY124_CTRL1    0x0ff9
+#define    RTL8367C_SVLAN_SP2C_ENTRY124_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY124_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY124_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY124_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY125_CTRL0    0x0ffa
+#define    RTL8367C_SVLAN_SP2C_ENTRY125_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY125_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY125_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY125_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY125_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY125_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY125_CTRL1    0x0ffb
+#define    RTL8367C_SVLAN_SP2C_ENTRY125_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY125_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY125_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY125_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY126_CTRL0    0x0ffc
+#define    RTL8367C_SVLAN_SP2C_ENTRY126_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY126_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY126_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY126_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY126_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY126_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY126_CTRL1    0x0ffd
+#define    RTL8367C_SVLAN_SP2C_ENTRY126_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY126_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY126_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY126_CTRL1_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY127_CTRL0    0x0ffe
+#define    RTL8367C_SVLAN_SP2C_ENTRY127_CTRL0_DST_PORT1_OFFSET    9
+#define    RTL8367C_SVLAN_SP2C_ENTRY127_CTRL0_DST_PORT1_MASK    0x200
+#define    RTL8367C_SVLAN_SP2C_ENTRY127_CTRL0_SVIDX_OFFSET    3
+#define    RTL8367C_SVLAN_SP2C_ENTRY127_CTRL0_SVIDX_MASK    0x1F8
+#define    RTL8367C_SVLAN_SP2C_ENTRY127_CTRL0_DST_PORT_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY127_CTRL0_DST_PORT_MASK    0x7
+
+#define    RTL8367C_REG_SVLAN_SP2C_ENTRY127_CTRL1    0x0fff
+#define    RTL8367C_SVLAN_SP2C_ENTRY127_CTRL1_VALID_OFFSET    12
+#define    RTL8367C_SVLAN_SP2C_ENTRY127_CTRL1_VALID_MASK    0x1000
+#define    RTL8367C_SVLAN_SP2C_ENTRY127_CTRL1_VID_OFFSET    0
+#define    RTL8367C_SVLAN_SP2C_ENTRY127_CTRL1_VID_MASK    0xFFF
+
+/* (16'h1000)mib_reg */
+
+#define    RTL8367C_REG_MIB_COUNTER0    0x1000
+
+#define    RTL8367C_REG_MIB_COUNTER1    0x1001
+
+#define    RTL8367C_REG_MIB_COUNTER2    0x1002
+
+#define    RTL8367C_REG_MIB_COUNTER3    0x1003
+
+#define    RTL8367C_REG_MIB_ADDRESS    0x1004
+#define    RTL8367C_MIB_ADDRESS_OFFSET    0
+#define    RTL8367C_MIB_ADDRESS_MASK    0x1FF
+
+#define    RTL8367C_REG_MIB_CTRL0    0x1005
+#define    RTL8367C_PORT10_RESET_OFFSET    15
+#define    RTL8367C_PORT10_RESET_MASK    0x8000
+#define    RTL8367C_PORT9_RESET_OFFSET    14
+#define    RTL8367C_PORT9_RESET_MASK    0x4000
+#define    RTL8367C_PORT8_RESET_OFFSET    13
+#define    RTL8367C_PORT8_RESET_MASK    0x2000
+#define    RTL8367C_RESET_VALUE_OFFSET    12
+#define    RTL8367C_RESET_VALUE_MASK    0x1000
+#define    RTL8367C_GLOBAL_RESET_OFFSET    11
+#define    RTL8367C_GLOBAL_RESET_MASK    0x800
+#define    RTL8367C_QM_RESET_OFFSET    10
+#define    RTL8367C_QM_RESET_MASK    0x400
+#define    RTL8367C_PORT7_RESET_OFFSET    9
+#define    RTL8367C_PORT7_RESET_MASK    0x200
+#define    RTL8367C_PORT6_RESET_OFFSET    8
+#define    RTL8367C_PORT6_RESET_MASK    0x100
+#define    RTL8367C_PORT5_RESET_OFFSET    7
+#define    RTL8367C_PORT5_RESET_MASK    0x80
+#define    RTL8367C_PORT4_RESET_OFFSET    6
+#define    RTL8367C_PORT4_RESET_MASK    0x40
+#define    RTL8367C_PORT3_RESET_OFFSET    5
+#define    RTL8367C_PORT3_RESET_MASK    0x20
+#define    RTL8367C_PORT2_RESET_OFFSET    4
+#define    RTL8367C_PORT2_RESET_MASK    0x10
+#define    RTL8367C_PORT1_RESET_OFFSET    3
+#define    RTL8367C_PORT1_RESET_MASK    0x8
+#define    RTL8367C_PORT0_RESET_OFFSET    2
+#define    RTL8367C_PORT0_RESET_MASK    0x4
+#define    RTL8367C_RESET_FLAG_OFFSET    1
+#define    RTL8367C_RESET_FLAG_MASK    0x2
+#define    RTL8367C_MIB_CTRL0_BUSY_FLAG_OFFSET    0
+#define    RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK    0x1
+
+#define    RTL8367C_REG_MIB_CTRL1    0x1007
+#define    RTL8367C_COUNTER15_RESET_OFFSET    15
+#define    RTL8367C_COUNTER15_RESET_MASK    0x8000
+#define    RTL8367C_COUNTER14_RESET_OFFSET    14
+#define    RTL8367C_COUNTER14_RESET_MASK    0x4000
+#define    RTL8367C_COUNTER13_RESET_OFFSET    13
+#define    RTL8367C_COUNTER13_RESET_MASK    0x2000
+#define    RTL8367C_COUNTER12_RESET_OFFSET    12
+#define    RTL8367C_COUNTER12_RESET_MASK    0x1000
+#define    RTL8367C_COUNTER11_RESET_OFFSET    11
+#define    RTL8367C_COUNTER11_RESET_MASK    0x800
+#define    RTL8367C_COUNTER10_RESET_OFFSET    10
+#define    RTL8367C_COUNTER10_RESET_MASK    0x400
+#define    RTL8367C_COUNTER9_RESET_OFFSET    9
+#define    RTL8367C_COUNTER9_RESET_MASK    0x200
+#define    RTL8367C_COUNTER8_RESET_OFFSET    8
+#define    RTL8367C_COUNTER8_RESET_MASK    0x100
+#define    RTL8367C_COUNTER7_RESET_OFFSET    7
+#define    RTL8367C_COUNTER7_RESET_MASK    0x80
+#define    RTL8367C_COUNTER6_RESET_OFFSET    6
+#define    RTL8367C_COUNTER6_RESET_MASK    0x40
+#define    RTL8367C_COUNTER5_RESET_OFFSET    5
+#define    RTL8367C_COUNTER5_RESET_MASK    0x20
+#define    RTL8367C_COUNTER4_RESET_OFFSET    4
+#define    RTL8367C_COUNTER4_RESET_MASK    0x10
+#define    RTL8367C_COUNTER3_RESET_OFFSET    3
+#define    RTL8367C_COUNTER3_RESET_MASK    0x8
+#define    RTL8367C_COUNTER2_RESET_OFFSET    2
+#define    RTL8367C_COUNTER2_RESET_MASK    0x4
+#define    RTL8367C_COUNTER1_RESET_OFFSET    1
+#define    RTL8367C_COUNTER1_RESET_MASK    0x2
+#define    RTL8367C_COUNTER0_RESET_OFFSET    0
+#define    RTL8367C_COUNTER0_RESET_MASK    0x1
+
+#define    RTL8367C_REG_MIB_CTRL2    0x1008
+#define    RTL8367C_COUNTER31_RESET_OFFSET    15
+#define    RTL8367C_COUNTER31_RESET_MASK    0x8000
+#define    RTL8367C_COUNTER30_RESET_OFFSET    14
+#define    RTL8367C_COUNTER30_RESET_MASK    0x4000
+#define    RTL8367C_COUNTER29_RESET_OFFSET    13
+#define    RTL8367C_COUNTER29_RESET_MASK    0x2000
+#define    RTL8367C_COUNTER28_RESET_OFFSET    12
+#define    RTL8367C_COUNTER28_RESET_MASK    0x1000
+#define    RTL8367C_COUNTER27_RESET_OFFSET    11
+#define    RTL8367C_COUNTER27_RESET_MASK    0x800
+#define    RTL8367C_COUNTER26_RESET_OFFSET    10
+#define    RTL8367C_COUNTER26_RESET_MASK    0x400
+#define    RTL8367C_COUNTER25_RESET_OFFSET    9
+#define    RTL8367C_COUNTER25_RESET_MASK    0x200
+#define    RTL8367C_COUNTER24_RESET_OFFSET    8
+#define    RTL8367C_COUNTER24_RESET_MASK    0x100
+#define    RTL8367C_COUNTER23_RESET_OFFSET    7
+#define    RTL8367C_COUNTER23_RESET_MASK    0x80
+#define    RTL8367C_COUNTER22_RESET_OFFSET    6
+#define    RTL8367C_COUNTER22_RESET_MASK    0x40
+#define    RTL8367C_COUNTER21_RESET_OFFSET    5
+#define    RTL8367C_COUNTER21_RESET_MASK    0x20
+#define    RTL8367C_COUNTER20_RESET_OFFSET    4
+#define    RTL8367C_COUNTER20_RESET_MASK    0x10
+#define    RTL8367C_COUNTER19_RESET_OFFSET    3
+#define    RTL8367C_COUNTER19_RESET_MASK    0x8
+#define    RTL8367C_COUNTER18_RESET_OFFSET    2
+#define    RTL8367C_COUNTER18_RESET_MASK    0x4
+#define    RTL8367C_COUNTER17_RESET_OFFSET    1
+#define    RTL8367C_COUNTER17_RESET_MASK    0x2
+#define    RTL8367C_COUNTER16_RESET_OFFSET    0
+#define    RTL8367C_COUNTER16_RESET_MASK    0x1
+
+#define    RTL8367C_REG_MIB_CTRL3    0x1009
+#define    RTL8367C_COUNTER15_MODE_OFFSET    15
+#define    RTL8367C_COUNTER15_MODE_MASK    0x8000
+#define    RTL8367C_COUNTER14_MODE_OFFSET    14
+#define    RTL8367C_COUNTER14_MODE_MASK    0x4000
+#define    RTL8367C_COUNTER13_MODE_OFFSET    13
+#define    RTL8367C_COUNTER13_MODE_MASK    0x2000
+#define    RTL8367C_COUNTER12_MODE_OFFSET    12
+#define    RTL8367C_COUNTER12_MODE_MASK    0x1000
+#define    RTL8367C_COUNTER11_MODE_OFFSET    11
+#define    RTL8367C_COUNTER11_MODE_MASK    0x800
+#define    RTL8367C_COUNTER10_MODE_OFFSET    10
+#define    RTL8367C_COUNTER10_MODE_MASK    0x400
+#define    RTL8367C_COUNTER9_MODE_OFFSET    9
+#define    RTL8367C_COUNTER9_MODE_MASK    0x200
+#define    RTL8367C_COUNTER8_MODE_OFFSET    8
+#define    RTL8367C_COUNTER8_MODE_MASK    0x100
+#define    RTL8367C_COUNTER7_MODE_OFFSET    7
+#define    RTL8367C_COUNTER7_MODE_MASK    0x80
+#define    RTL8367C_COUNTER6_MODE_OFFSET    6
+#define    RTL8367C_COUNTER6_MODE_MASK    0x40
+#define    RTL8367C_COUNTER5_MODE_OFFSET    5
+#define    RTL8367C_COUNTER5_MODE_MASK    0x20
+#define    RTL8367C_COUNTER4_MODE_OFFSET    4
+#define    RTL8367C_COUNTER4_MODE_MASK    0x10
+#define    RTL8367C_COUNTER3_MODE_OFFSET    3
+#define    RTL8367C_COUNTER3_MODE_MASK    0x8
+#define    RTL8367C_COUNTER2_MODE_OFFSET    2
+#define    RTL8367C_COUNTER2_MODE_MASK    0x4
+#define    RTL8367C_COUNTER1_MODE_OFFSET    1
+#define    RTL8367C_COUNTER1_MODE_MASK    0x2
+#define    RTL8367C_COUNTER0_MODE_OFFSET    0
+#define    RTL8367C_COUNTER0_MODE_MASK    0x1
+
+#define    RTL8367C_REG_MIB_CTRL4    0x100a
+#define    RTL8367C_MIB_USAGE_MODE_OFFSET    8
+#define    RTL8367C_MIB_USAGE_MODE_MASK    0x100
+#define    RTL8367C_MIB_TIMER_OFFSET    0
+#define    RTL8367C_MIB_TIMER_MASK    0xFF
+
+#define    RTL8367C_REG_MIB_CTRL5    0x100b
+#define    RTL8367C_MIB_CTRL5_COUNTER15_TYPE_OFFSET    15
+#define    RTL8367C_MIB_CTRL5_COUNTER15_TYPE_MASK    0x8000
+#define    RTL8367C_MIB_CTRL5_COUNTER14_TYPE_OFFSET    14
+#define    RTL8367C_MIB_CTRL5_COUNTER14_TYPE_MASK    0x4000
+#define    RTL8367C_MIB_CTRL5_COUNTER13_TYPE_OFFSET    13
+#define    RTL8367C_MIB_CTRL5_COUNTER13_TYPE_MASK    0x2000
+#define    RTL8367C_MIB_CTRL5_COUNTER12_TYPE_OFFSET    12
+#define    RTL8367C_MIB_CTRL5_COUNTER12_TYPE_MASK    0x1000
+#define    RTL8367C_MIB_CTRL5_COUNTER11_TYPE_OFFSET    11
+#define    RTL8367C_MIB_CTRL5_COUNTER11_TYPE_MASK    0x800
+#define    RTL8367C_MIB_CTRL5_COUNTER10_TYPE_OFFSET    10
+#define    RTL8367C_MIB_CTRL5_COUNTER10_TYPE_MASK    0x400
+#define    RTL8367C_MIB_CTRL5_COUNTER9_TYPE_OFFSET    9
+#define    RTL8367C_MIB_CTRL5_COUNTER9_TYPE_MASK    0x200
+#define    RTL8367C_MIB_CTRL5_COUNTER8_TYPE_OFFSET    8
+#define    RTL8367C_MIB_CTRL5_COUNTER8_TYPE_MASK    0x100
+#define    RTL8367C_MIB_CTRL5_COUNTER7_TYPE_OFFSET    7
+#define    RTL8367C_MIB_CTRL5_COUNTER7_TYPE_MASK    0x80
+#define    RTL8367C_MIB_CTRL5_COUNTER6_TYPE_OFFSET    6
+#define    RTL8367C_MIB_CTRL5_COUNTER6_TYPE_MASK    0x40
+#define    RTL8367C_MIB_CTRL5_COUNTER5_TYPE_OFFSET    5
+#define    RTL8367C_MIB_CTRL5_COUNTER5_TYPE_MASK    0x20
+#define    RTL8367C_MIB_CTRL5_COUNTER4_TYPE_OFFSET    4
+#define    RTL8367C_MIB_CTRL5_COUNTER4_TYPE_MASK    0x10
+#define    RTL8367C_MIB_CTRL5_COUNTER3_TYPE_OFFSET    3
+#define    RTL8367C_MIB_CTRL5_COUNTER3_TYPE_MASK    0x8
+#define    RTL8367C_MIB_CTRL5_COUNTER2_TYPE_OFFSET    2
+#define    RTL8367C_MIB_CTRL5_COUNTER2_TYPE_MASK    0x4
+#define    RTL8367C_MIB_CTRL5_COUNTER1_TYPE_OFFSET    1
+#define    RTL8367C_MIB_CTRL5_COUNTER1_TYPE_MASK    0x2
+#define    RTL8367C_MIB_CTRL5_COUNTER0_TYPE_OFFSET    0
+#define    RTL8367C_MIB_CTRL5_COUNTER0_TYPE_MASK    0x1
+
+/* (16'h1100)intrpt_reg */
+
+#define    RTL8367C_REG_INTR_CTRL    0x1100
+#define    RTL8367C_INTR_CTRL_OFFSET    0
+#define    RTL8367C_INTR_CTRL_MASK    0x1
+
+#define    RTL8367C_REG_INTR_IMR    0x1101
+#define    RTL8367C_INTR_IMR_SLIENT_START_2_OFFSET    12
+#define    RTL8367C_INTR_IMR_SLIENT_START_2_MASK    0x1000
+#define    RTL8367C_INTR_IMR_SLIENT_START_OFFSET    11
+#define    RTL8367C_INTR_IMR_SLIENT_START_MASK    0x800
+#define    RTL8367C_INTR_IMR_ACL_ACTION_OFFSET    9
+#define    RTL8367C_INTR_IMR_ACL_ACTION_MASK    0x200
+#define    RTL8367C_INTR_IMR_CABLE_DIAG_FIN_OFFSET    8
+#define    RTL8367C_INTR_IMR_CABLE_DIAG_FIN_MASK    0x100
+#define    RTL8367C_INTR_IMR_INTERRUPT_8051_OFFSET    7
+#define    RTL8367C_INTR_IMR_INTERRUPT_8051_MASK    0x80
+#define    RTL8367C_INTR_IMR_LOOP_DETECTION_OFFSET    6
+#define    RTL8367C_INTR_IMR_LOOP_DETECTION_MASK    0x40
+#define    RTL8367C_INTR_IMR_GREEN_TIMER_OFFSET    5
+#define    RTL8367C_INTR_IMR_GREEN_TIMER_MASK    0x20
+#define    RTL8367C_INTR_IMR_SPECIAL_CONGEST_OFFSET    4
+#define    RTL8367C_INTR_IMR_SPECIAL_CONGEST_MASK    0x10
+#define    RTL8367C_INTR_IMR_SPEED_CHANGE_OFFSET    3
+#define    RTL8367C_INTR_IMR_SPEED_CHANGE_MASK    0x8
+#define    RTL8367C_INTR_IMR_LEARN_OVER_OFFSET    2
+#define    RTL8367C_INTR_IMR_LEARN_OVER_MASK    0x4
+#define    RTL8367C_INTR_IMR_METER_EXCEEDED_OFFSET    1
+#define    RTL8367C_INTR_IMR_METER_EXCEEDED_MASK    0x2
+#define    RTL8367C_INTR_IMR_LINK_CHANGE_OFFSET    0
+#define    RTL8367C_INTR_IMR_LINK_CHANGE_MASK    0x1
+
+#define    RTL8367C_REG_INTR_IMS    0x1102
+#define    RTL8367C_INTR_IMS_SLIENT_START_2_OFFSET    12
+#define    RTL8367C_INTR_IMS_SLIENT_START_2_MASK    0x1000
+#define    RTL8367C_INTR_IMS_SLIENT_START_OFFSET    11
+#define    RTL8367C_INTR_IMS_SLIENT_START_MASK    0x800
+#define    RTL8367C_INTR_IMS_ACL_ACTION_OFFSET    9
+#define    RTL8367C_INTR_IMS_ACL_ACTION_MASK    0x200
+#define    RTL8367C_INTR_IMS_CABLE_DIAG_FIN_OFFSET    8
+#define    RTL8367C_INTR_IMS_CABLE_DIAG_FIN_MASK    0x100
+#define    RTL8367C_INTR_IMS_INTERRUPT_8051_OFFSET    7
+#define    RTL8367C_INTR_IMS_INTERRUPT_8051_MASK    0x80
+#define    RTL8367C_INTR_IMS_LOOP_DETECTION_OFFSET    6
+#define    RTL8367C_INTR_IMS_LOOP_DETECTION_MASK    0x40
+#define    RTL8367C_INTR_IMS_GREEN_TIMER_OFFSET    5
+#define    RTL8367C_INTR_IMS_GREEN_TIMER_MASK    0x20
+#define    RTL8367C_INTR_IMS_SPECIAL_CONGEST_OFFSET    4
+#define    RTL8367C_INTR_IMS_SPECIAL_CONGEST_MASK    0x10
+#define    RTL8367C_INTR_IMS_SPEED_CHANGE_OFFSET    3
+#define    RTL8367C_INTR_IMS_SPEED_CHANGE_MASK    0x8
+#define    RTL8367C_INTR_IMS_LEARN_OVER_OFFSET    2
+#define    RTL8367C_INTR_IMS_LEARN_OVER_MASK    0x4
+#define    RTL8367C_INTR_IMS_METER_EXCEEDED_OFFSET    1
+#define    RTL8367C_INTR_IMS_METER_EXCEEDED_MASK    0x2
+#define    RTL8367C_INTR_IMS_LINK_CHANGE_OFFSET    0
+#define    RTL8367C_INTR_IMS_LINK_CHANGE_MASK    0x1
+
+#define    RTL8367C_REG_LEARN_OVER_INDICATOR    0x1103
+#define    RTL8367C_LEARN_OVER_INDICATOR_OFFSET    0
+#define    RTL8367C_LEARN_OVER_INDICATOR_MASK    0x7FF
+
+#define    RTL8367C_REG_SPEED_CHANGE_INDICATOR    0x1104
+#define    RTL8367C_SPEED_CHANGE_INDICATOR_OFFSET    0
+#define    RTL8367C_SPEED_CHANGE_INDICATOR_MASK    0x7FF
+
+#define    RTL8367C_REG_SPECIAL_CONGEST_INDICATOR    0x1105
+#define    RTL8367C_SPECIAL_CONGEST_INDICATOR_OFFSET    0
+#define    RTL8367C_SPECIAL_CONGEST_INDICATOR_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_LINKDOWN_INDICATOR    0x1106
+#define    RTL8367C_PORT_LINKDOWN_INDICATOR_OFFSET    0
+#define    RTL8367C_PORT_LINKDOWN_INDICATOR_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_LINKUP_INDICATOR    0x1107
+#define    RTL8367C_PORT_LINKUP_INDICATOR_OFFSET    0
+#define    RTL8367C_PORT_LINKUP_INDICATOR_MASK    0x7FF
+
+#define    RTL8367C_REG_SYSTEM_LEARN_OVER_INDICATOR    0x1108
+#define    RTL8367C_SYSTEM_LEARN_OVER_INDICATOR_OFFSET    0
+#define    RTL8367C_SYSTEM_LEARN_OVER_INDICATOR_MASK    0x1
+
+#define    RTL8367C_REG_INTR_IMR_8051    0x1118
+#define    RTL8367C_INTR_IMR_8051_SLIENT_START_2_OFFSET    13
+#define    RTL8367C_INTR_IMR_8051_SLIENT_START_2_MASK    0x2000
+#define    RTL8367C_INTR_IMR_8051_SLIENT_START_OFFSET    12
+#define    RTL8367C_INTR_IMR_8051_SLIENT_START_MASK    0x1000
+#define    RTL8367C_INTR_IMR_8051_ACL_ACTION_OFFSET    10
+#define    RTL8367C_INTR_IMR_8051_ACL_ACTION_MASK    0x400
+#define    RTL8367C_INTR_IMR_8051_SAMOVING_8051_OFFSET    9
+#define    RTL8367C_INTR_IMR_8051_SAMOVING_8051_MASK    0x200
+#define    RTL8367C_INTR_IMR_8051_CABLE_DIAG_FIN_8051_OFFSET    8
+#define    RTL8367C_INTR_IMR_8051_CABLE_DIAG_FIN_8051_MASK    0x100
+#define    RTL8367C_INTR_IMR_8051_EEELLDP_8051_OFFSET    7
+#define    RTL8367C_INTR_IMR_8051_EEELLDP_8051_MASK    0x80
+#define    RTL8367C_INTR_IMR_8051_LOOP_DETECTION_8051_OFFSET    6
+#define    RTL8367C_INTR_IMR_8051_LOOP_DETECTION_8051_MASK    0x40
+#define    RTL8367C_INTR_IMR_8051_GREEN_TIMER_8051_OFFSET    5
+#define    RTL8367C_INTR_IMR_8051_GREEN_TIMER_8051_MASK    0x20
+#define    RTL8367C_INTR_IMR_8051_SPECIAL_CONGEST_8051_OFFSET    4
+#define    RTL8367C_INTR_IMR_8051_SPECIAL_CONGEST_8051_MASK    0x10
+#define    RTL8367C_INTR_IMR_8051_SPEED_CHANGE_8051_OFFSET    3
+#define    RTL8367C_INTR_IMR_8051_SPEED_CHANGE_8051_MASK    0x8
+#define    RTL8367C_INTR_IMR_8051_LEARN_OVER_8051_OFFSET    2
+#define    RTL8367C_INTR_IMR_8051_LEARN_OVER_8051_MASK    0x4
+#define    RTL8367C_INTR_IMR_8051_METER_EXCEEDED_8051_OFFSET    1
+#define    RTL8367C_INTR_IMR_8051_METER_EXCEEDED_8051_MASK    0x2
+#define    RTL8367C_INTR_IMR_8051_LINK_CHANGE_8051_OFFSET    0
+#define    RTL8367C_INTR_IMR_8051_LINK_CHANGE_8051_MASK    0x1
+
+#define    RTL8367C_REG_INTR_IMS_8051    0x1119
+#define    RTL8367C_INTR_IMS_8051_SLIENT_START_2_OFFSET    13
+#define    RTL8367C_INTR_IMS_8051_SLIENT_START_2_MASK    0x2000
+#define    RTL8367C_INTR_IMS_8051_SLIENT_START_OFFSET    12
+#define    RTL8367C_INTR_IMS_8051_SLIENT_START_MASK    0x1000
+#define    RTL8367C_INTR_IMS_8051_ACL_ACTION_OFFSET    10
+#define    RTL8367C_INTR_IMS_8051_ACL_ACTION_MASK    0x400
+#define    RTL8367C_INTR_IMS_8051_SAMOVING_8051_OFFSET    9
+#define    RTL8367C_INTR_IMS_8051_SAMOVING_8051_MASK    0x200
+#define    RTL8367C_INTR_IMS_8051_CABLE_DIAG_FIN_8051_OFFSET    8
+#define    RTL8367C_INTR_IMS_8051_CABLE_DIAG_FIN_8051_MASK    0x100
+#define    RTL8367C_INTR_IMS_8051_EEELLDP_8051_OFFSET    7
+#define    RTL8367C_INTR_IMS_8051_EEELLDP_8051_MASK    0x80
+#define    RTL8367C_INTR_IMS_8051_LOOP_DETECTION_8051_OFFSET    6
+#define    RTL8367C_INTR_IMS_8051_LOOP_DETECTION_8051_MASK    0x40
+#define    RTL8367C_INTR_IMS_8051_GREEN_TIMER_8051_OFFSET    5
+#define    RTL8367C_INTR_IMS_8051_GREEN_TIMER_8051_MASK    0x20
+#define    RTL8367C_INTR_IMS_8051_SPECIAL_CONGEST_8051_OFFSET    4
+#define    RTL8367C_INTR_IMS_8051_SPECIAL_CONGEST_8051_MASK    0x10
+#define    RTL8367C_INTR_IMS_8051_SPEED_CHANGE_8051_OFFSET    3
+#define    RTL8367C_INTR_IMS_8051_SPEED_CHANGE_8051_MASK    0x8
+#define    RTL8367C_INTR_IMS_8051_LEARN_OVER_8051_OFFSET    2
+#define    RTL8367C_INTR_IMS_8051_LEARN_OVER_8051_MASK    0x4
+#define    RTL8367C_INTR_IMS_8051_METER_EXCEEDED_8051_OFFSET    1
+#define    RTL8367C_INTR_IMS_8051_METER_EXCEEDED_8051_MASK    0x2
+#define    RTL8367C_INTR_IMS_8051_LINK_CHANGE_8051_OFFSET    0
+#define    RTL8367C_INTR_IMS_8051_LINK_CHANGE_8051_MASK    0x1
+
+#define    RTL8367C_REG_DW8051_INT_CPU    0x111a
+#define    RTL8367C_DW8051_INT_CPU_OFFSET    0
+#define    RTL8367C_DW8051_INT_CPU_MASK    0x1
+
+#define    RTL8367C_REG_LEARN_OVER_INDICATOR_8051    0x1120
+#define    RTL8367C_LEARN_OVER_INDICATOR_8051_OFFSET    0
+#define    RTL8367C_LEARN_OVER_INDICATOR_8051_MASK    0x7FF
+
+#define    RTL8367C_REG_SPEED_CHANGE_INDICATOR_8051    0x1121
+#define    RTL8367C_SPEED_CHANGE_INDICATOR_8051_OFFSET    0
+#define    RTL8367C_SPEED_CHANGE_INDICATOR_8051_MASK    0x7FF
+
+#define    RTL8367C_REG_SPECIAL_CONGEST_INDICATOR_8051    0x1122
+#define    RTL8367C_SPECIAL_CONGEST_INDICATOR_8051_OFFSET    0
+#define    RTL8367C_SPECIAL_CONGEST_INDICATOR_8051_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_LINKDOWN_INDICATOR_8051    0x1123
+#define    RTL8367C_PORT_LINKDOWN_INDICATOR_8051_OFFSET    0
+#define    RTL8367C_PORT_LINKDOWN_INDICATOR_8051_MASK    0x7FF
+
+#define    RTL8367C_REG_PORT_LINKUP_INDICATOR_8051    0x1124
+#define    RTL8367C_PORT_LINKUP_INDICATOR_8051_OFFSET    0
+#define    RTL8367C_PORT_LINKUP_INDICATOR_8051_MASK    0x7FF
+
+#define    RTL8367C_REG_DUMMY_1125    0x1125
+
+#define    RTL8367C_REG_DUMMY_1126    0x1126
+
+#define    RTL8367C_REG_DUMMY_1127    0x1127
+
+#define    RTL8367C_REG_DUMMY_1128    0x1128
+
+#define    RTL8367C_REG_DUMMY_1129    0x1129
+
+#define    RTL8367C_REG_INTR_IMS_BUFFER_RESET    0x112a
+#define    RTL8367C_INTR_IMS_BUFFER_RESET_IMR_BUFF_RESET_OFFSET    1
+#define    RTL8367C_INTR_IMS_BUFFER_RESET_IMR_BUFF_RESET_MASK    0x2
+#define    RTL8367C_INTR_IMS_BUFFER_RESET_BUFFER_RESET_OFFSET    0
+#define    RTL8367C_INTR_IMS_BUFFER_RESET_BUFFER_RESET_MASK    0x1
+
+#define    RTL8367C_REG_INTR_IMS_8051_BUFFER_RESET    0x112b
+#define    RTL8367C_INTR_IMS_8051_BUFFER_RESET_IMR_BUFF_RESET_OFFSET    1
+#define    RTL8367C_INTR_IMS_8051_BUFFER_RESET_IMR_BUFF_RESET_MASK    0x2
+#define    RTL8367C_INTR_IMS_8051_BUFFER_RESET_BUFFER_RESET_OFFSET    0
+#define    RTL8367C_INTR_IMS_8051_BUFFER_RESET_BUFFER_RESET_MASK    0x1
+
+#define    RTL8367C_REG_GPHY_INTRPT_8051    0x112c
+#define    RTL8367C_IMS_GPHY_8051_H_OFFSET    13
+#define    RTL8367C_IMS_GPHY_8051_H_MASK    0xE000
+#define    RTL8367C_IMR_GPHY_8051_H_OFFSET    10
+#define    RTL8367C_IMR_GPHY_8051_H_MASK    0x1C00
+#define    RTL8367C_IMS_GPHY_8051_OFFSET    5
+#define    RTL8367C_IMS_GPHY_8051_MASK    0x3E0
+#define    RTL8367C_IMR_GPHY_8051_OFFSET    0
+#define    RTL8367C_IMR_GPHY_8051_MASK    0x1F
+
+#define    RTL8367C_REG_GPHY_INTRPT    0x112d
+#define    RTL8367C_IMS_GPHY_H_OFFSET    13
+#define    RTL8367C_IMS_GPHY_H_MASK    0xE000
+#define    RTL8367C_IMR_GPHY_H_OFFSET    10
+#define    RTL8367C_IMR_GPHY_H_MASK    0x1C00
+#define    RTL8367C_IMS_GPHY_OFFSET    5
+#define    RTL8367C_IMS_GPHY_MASK    0x3E0
+#define    RTL8367C_IMR_GPHY_OFFSET    0
+#define    RTL8367C_IMR_GPHY_MASK    0x1F
+
+#define    RTL8367C_REG_THERMAL_INTRPT    0x112e
+#define    RTL8367C_IMS_TM_HIGH_OFFSET    3
+#define    RTL8367C_IMS_TM_HIGH_MASK    0x8
+#define    RTL8367C_IMR_TM_HIGH_OFFSET    2
+#define    RTL8367C_IMR_TM_HIGH_MASK    0x4
+#define    RTL8367C_IMS_TM_LOW_OFFSET    1
+#define    RTL8367C_IMS_TM_LOW_MASK    0x2
+#define    RTL8367C_IMR_TM_LOW_OFFSET    0
+#define    RTL8367C_IMR_TM_LOW_MASK    0x1
+
+#define    RTL8367C_REG_THERMAL_INTRPT_8051    0x112f
+#define    RTL8367C_IMS_TM_HIGH_8051_OFFSET    3
+#define    RTL8367C_IMS_TM_HIGH_8051_MASK    0x8
+#define    RTL8367C_IMR_TM_HIGH_8051_OFFSET    2
+#define    RTL8367C_IMR_TM_HIGH_8051_MASK    0x4
+#define    RTL8367C_IMS_TM_LOW_8051_OFFSET    1
+#define    RTL8367C_IMS_TM_LOW_8051_MASK    0x2
+#define    RTL8367C_IMR_TM_LOW_8051_OFFSET    0
+#define    RTL8367C_IMR_TM_LOW_8051_MASK    0x1
+
+#define    RTL8367C_REG_SDS_LINK_CHG_INT    0x1130
+#define    RTL8367C_IMS_SDS_LINK_STS_C7_OFFSET    15
+#define    RTL8367C_IMS_SDS_LINK_STS_C7_MASK    0x8000
+#define    RTL8367C_IMS_SDS_LINK_STS_C6_OFFSET    14
+#define    RTL8367C_IMS_SDS_LINK_STS_C6_MASK    0x4000
+#define    RTL8367C_IMS_SDS_LINK_STS_C5_OFFSET    13
+#define    RTL8367C_IMS_SDS_LINK_STS_C5_MASK    0x2000
+#define    RTL8367C_IMS_SDS_LINK_STS_C4_OFFSET    12
+#define    RTL8367C_IMS_SDS_LINK_STS_C4_MASK    0x1000
+#define    RTL8367C_IMS_SDS_LINK_STS_C3_OFFSET    11
+#define    RTL8367C_IMS_SDS_LINK_STS_C3_MASK    0x800
+#define    RTL8367C_IMS_SDS_LINK_STS_C2_OFFSET    10
+#define    RTL8367C_IMS_SDS_LINK_STS_C2_MASK    0x400
+#define    RTL8367C_IMS_SDS_LINK_STS_C1_OFFSET    9
+#define    RTL8367C_IMS_SDS_LINK_STS_C1_MASK    0x200
+#define    RTL8367C_IMS_SDS_LINK_STS_C0_OFFSET    8
+#define    RTL8367C_IMS_SDS_LINK_STS_C0_MASK    0x100
+#define    RTL8367C_IMR_SDS_LINK_STS_C7_OFFSET    7
+#define    RTL8367C_IMR_SDS_LINK_STS_C7_MASK    0x80
+#define    RTL8367C_IMR_SDS_LINK_STS_C6_OFFSET    6
+#define    RTL8367C_IMR_SDS_LINK_STS_C6_MASK    0x40
+#define    RTL8367C_IMR_SDS_LINK_STS_C5_OFFSET    5
+#define    RTL8367C_IMR_SDS_LINK_STS_C5_MASK    0x20
+#define    RTL8367C_IMR_SDS_LINK_STS_C4_OFFSET    4
+#define    RTL8367C_IMR_SDS_LINK_STS_C4_MASK    0x10
+#define    RTL8367C_IMR_SDS_LINK_STS_C3_OFFSET    3
+#define    RTL8367C_IMR_SDS_LINK_STS_C3_MASK    0x8
+#define    RTL8367C_IMR_SDS_LINK_STS_C2_OFFSET    2
+#define    RTL8367C_IMR_SDS_LINK_STS_C2_MASK    0x4
+#define    RTL8367C_IMR_SDS_LINK_STS_C1_OFFSET    1
+#define    RTL8367C_IMR_SDS_LINK_STS_C1_MASK    0x2
+#define    RTL8367C_IMR_SDS_LINK_STS_C0_OFFSET    0
+#define    RTL8367C_IMR_SDS_LINK_STS_C0_MASK    0x1
+
+#define    RTL8367C_REG_SDS_LINK_CHG_INT_8051    0x1131
+#define    RTL8367C_IMS_SDS_LINK_STS_C7_8051_OFFSET    15
+#define    RTL8367C_IMS_SDS_LINK_STS_C7_8051_MASK    0x8000
+#define    RTL8367C_IMS_SDS_LINK_STS_C6_8051_OFFSET    14
+#define    RTL8367C_IMS_SDS_LINK_STS_C6_8051_MASK    0x4000
+#define    RTL8367C_IMS_SDS_LINK_STS_C5_8051_OFFSET    13
+#define    RTL8367C_IMS_SDS_LINK_STS_C5_8051_MASK    0x2000
+#define    RTL8367C_IMS_SDS_LINK_STS_C4_8051_OFFSET    12
+#define    RTL8367C_IMS_SDS_LINK_STS_C4_8051_MASK    0x1000
+#define    RTL8367C_IMS_SDS_LINK_STS_C3_8051_OFFSET    11
+#define    RTL8367C_IMS_SDS_LINK_STS_C3_8051_MASK    0x800
+#define    RTL8367C_IMS_SDS_LINK_STS_C2_8051_OFFSET    10
+#define    RTL8367C_IMS_SDS_LINK_STS_C2_8051_MASK    0x400
+#define    RTL8367C_IMS_SDS_LINK_STS_C1_8051_OFFSET    9
+#define    RTL8367C_IMS_SDS_LINK_STS_C1_8051_MASK    0x200
+#define    RTL8367C_IMS_SDS_LINK_STS_C0_8051_OFFSET    8
+#define    RTL8367C_IMS_SDS_LINK_STS_C0_8051_MASK    0x100
+#define    RTL8367C_IMR_SDS_LINK_STS_C7_8051_OFFSET    7
+#define    RTL8367C_IMR_SDS_LINK_STS_C7_8051_MASK    0x80
+#define    RTL8367C_IMR_SDS_LINK_STS_C6_8051_OFFSET    6
+#define    RTL8367C_IMR_SDS_LINK_STS_C6_8051_MASK    0x40
+#define    RTL8367C_IMR_SDS_LINK_STS_C5_8051_OFFSET    5
+#define    RTL8367C_IMR_SDS_LINK_STS_C5_8051_MASK    0x20
+#define    RTL8367C_IMR_SDS_LINK_STS_C4_8051_OFFSET    4
+#define    RTL8367C_IMR_SDS_LINK_STS_C4_8051_MASK    0x10
+#define    RTL8367C_IMR_SDS_LINK_STS_C3_8051_OFFSET    3
+#define    RTL8367C_IMR_SDS_LINK_STS_C3_8051_MASK    0x8
+#define    RTL8367C_IMR_SDS_LINK_STS_C2_8051_OFFSET    2
+#define    RTL8367C_IMR_SDS_LINK_STS_C2_8051_MASK    0x4
+#define    RTL8367C_IMR_SDS_LINK_STS_C1_8051_OFFSET    1
+#define    RTL8367C_IMR_SDS_LINK_STS_C1_8051_MASK    0x2
+#define    RTL8367C_IMR_SDS_LINK_STS_C0_8051_OFFSET    0
+#define    RTL8367C_IMR_SDS_LINK_STS_C0_8051_MASK    0x1
+
+/* (16'h1200)swcore_reg */
+
+#define    RTL8367C_REG_MAX_LENGTH_LIMINT_IPG    0x1200
+#define    RTL8367C_MAX_LENTH_CTRL_OFFSET    13
+#define    RTL8367C_MAX_LENTH_CTRL_MASK    0x6000
+#define    RTL8367C_PAGES_BEFORE_FCDROP_OFFSET    6
+#define    RTL8367C_PAGES_BEFORE_FCDROP_MASK    0x1FC0
+#define    RTL8367C_CHECK_MIN_IPG_RXDV_OFFSET    5
+#define    RTL8367C_CHECK_MIN_IPG_RXDV_MASK    0x20
+#define    RTL8367C_LIMIT_IPG_CFG_OFFSET    0
+#define    RTL8367C_LIMIT_IPG_CFG_MASK    0x1F
+
+#define    RTL8367C_REG_IOL_RXDROP_CFG    0x1201
+#define    RTL8367C_RX_IOL_MAX_LENGTH_CFG_OFFSET    13
+#define    RTL8367C_RX_IOL_MAX_LENGTH_CFG_MASK    0x2000
+#define    RTL8367C_RX_IOL_ERROR_LENGTH_CFG_OFFSET    12
+#define    RTL8367C_RX_IOL_ERROR_LENGTH_CFG_MASK    0x1000
+#define    RTL8367C_RX_NODROP_PAUSE_CFG_OFFSET    8
+#define    RTL8367C_RX_NODROP_PAUSE_CFG_MASK    0x100
+#define    RTL8367C_RX_DV_CNT_CFG_OFFSET    0
+#define    RTL8367C_RX_DV_CNT_CFG_MASK    0x3F
+
+#define    RTL8367C_REG_VS_TPID    0x1202
+
+#define    RTL8367C_REG_INBW_BOUND    0x1203
+#define    RTL8367C_LBOUND_OFFSET    4
+#define    RTL8367C_LBOUND_MASK    0xF0
+#define    RTL8367C_HBOUND_OFFSET    0
+#define    RTL8367C_HBOUND_MASK    0xF
+
+#define    RTL8367C_REG_CFG_TX_ITFSP_OP    0x1204
+#define    RTL8367C_MASK_OFFSET    1
+#define    RTL8367C_MASK_MASK    0x2
+#define    RTL8367C_OP_OFFSET    0
+#define    RTL8367C_OP_MASK    0x1
+
+#define    RTL8367C_REG_INBW_BOUND2    0x1205
+#define    RTL8367C_LBOUND2_H_OFFSET    9
+#define    RTL8367C_LBOUND2_H_MASK    0x200
+#define    RTL8367C_HBOUND2_H_OFFSET    8
+#define    RTL8367C_HBOUND2_H_MASK    0x100
+#define    RTL8367C_LBOUND2_OFFSET    4
+#define    RTL8367C_LBOUND2_MASK    0xF0
+#define    RTL8367C_HBOUND2_OFFSET    0
+#define    RTL8367C_HBOUND2_MASK    0xF
+
+#define    RTL8367C_REG_CFG_48PASS1_DROP    0x1206
+#define    RTL8367C_CFG_48PASS1_DROP_OFFSET    0
+#define    RTL8367C_CFG_48PASS1_DROP_MASK    0x1
+
+#define    RTL8367C_REG_CFG_BACKPRESSURE    0x1207
+#define    RTL8367C_LONGTXE_OFFSET    12
+#define    RTL8367C_LONGTXE_MASK    0x1000
+#define    RTL8367C_EN_BYPASS_ERROR_OFFSET    8
+#define    RTL8367C_EN_BYPASS_ERROR_MASK    0x100
+#define    RTL8367C_EN_BACKPRESSURE_OFFSET    4
+#define    RTL8367C_EN_BACKPRESSURE_MASK    0x10
+#define    RTL8367C_EN_48_PASS_1_OFFSET    0
+#define    RTL8367C_EN_48_PASS_1_MASK    0x1
+
+#define    RTL8367C_REG_CFG_UNHIOL    0x1208
+#define    RTL8367C_IOL_BACKOFF_OFFSET    12
+#define    RTL8367C_IOL_BACKOFF_MASK    0x1000
+#define    RTL8367C_BACKOFF_RANDOM_TIME_OFFSET    8
+#define    RTL8367C_BACKOFF_RANDOM_TIME_MASK    0x100
+#define    RTL8367C_DISABLE_BACK_OFF_OFFSET    4
+#define    RTL8367C_DISABLE_BACK_OFF_MASK    0x10
+#define    RTL8367C_IPG_COMPENSATION_OFFSET    0
+#define    RTL8367C_IPG_COMPENSATION_MASK    0x1
+
+#define    RTL8367C_REG_SWITCH_MAC0    0x1209
+
+#define    RTL8367C_REG_SWITCH_MAC1    0x120a
+
+#define    RTL8367C_REG_SWITCH_MAC2    0x120b
+
+#define    RTL8367C_REG_SWITCH_CTRL0    0x120c
+#define    RTL8367C_REMARKING_DSCP_ENABLE_OFFSET    8
+#define    RTL8367C_REMARKING_DSCP_ENABLE_MASK    0x100
+#define    RTL8367C_SHORT_IPG_OFFSET    4
+#define    RTL8367C_SHORT_IPG_MASK    0x10
+#define    RTL8367C_PAUSE_MAX128_OFFSET    0
+#define    RTL8367C_PAUSE_MAX128_MASK    0x1
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_CTRL0    0x120d
+#define    RTL8367C_INTPRI1_DSCP_OFFSET    8
+#define    RTL8367C_INTPRI1_DSCP_MASK    0x3F00
+#define    RTL8367C_INTPRI0_DSCP_OFFSET    0
+#define    RTL8367C_INTPRI0_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_CTRL1    0x120e
+#define    RTL8367C_INTPRI3_DSCP_OFFSET    8
+#define    RTL8367C_INTPRI3_DSCP_MASK    0x3F00
+#define    RTL8367C_INTPRI2_DSCP_OFFSET    0
+#define    RTL8367C_INTPRI2_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_CTRL2    0x120f
+#define    RTL8367C_INTPRI5_DSCP_OFFSET    8
+#define    RTL8367C_INTPRI5_DSCP_MASK    0x3F00
+#define    RTL8367C_INTPRI4_DSCP_OFFSET    0
+#define    RTL8367C_INTPRI4_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_DSCP_REMARK_CTRL3    0x1210
+#define    RTL8367C_INTPRI7_DSCP_OFFSET    8
+#define    RTL8367C_INTPRI7_DSCP_MASK    0x3F00
+#define    RTL8367C_INTPRI6_DSCP_OFFSET    0
+#define    RTL8367C_INTPRI6_DSCP_MASK    0x3F
+
+#define    RTL8367C_REG_QOS_1Q_REMARK_CTRL0    0x1211
+#define    RTL8367C_INTPRI3_PRI_OFFSET    12
+#define    RTL8367C_INTPRI3_PRI_MASK    0x7000
+#define    RTL8367C_INTPRI2_PRI_OFFSET    8
+#define    RTL8367C_INTPRI2_PRI_MASK    0x700
+#define    RTL8367C_INTPRI1_PRI_OFFSET    4
+#define    RTL8367C_INTPRI1_PRI_MASK    0x70
+#define    RTL8367C_INTPRI0_PRI_OFFSET    0
+#define    RTL8367C_INTPRI0_PRI_MASK    0x7
+
+#define    RTL8367C_REG_QOS_1Q_REMARK_CTRL1    0x1212
+#define    RTL8367C_INTPRI7_PRI_OFFSET    12
+#define    RTL8367C_INTPRI7_PRI_MASK    0x7000
+#define    RTL8367C_INTPRI6_PRI_OFFSET    8
+#define    RTL8367C_INTPRI6_PRI_MASK    0x700
+#define    RTL8367C_INTPRI5_PRI_OFFSET    4
+#define    RTL8367C_INTPRI5_PRI_MASK    0x70
+#define    RTL8367C_INTPRI4_PRI_OFFSET    0
+#define    RTL8367C_INTPRI4_PRI_MASK    0x7
+
+#define    RTL8367C_REG_PKTGEN_COMMAND    0x1213
+#define    RTL8367C_PKTGEN_STOP_OFFSET    8
+#define    RTL8367C_PKTGEN_STOP_MASK    0x100
+#define    RTL8367C_PKTGEN_START_OFFSET    4
+#define    RTL8367C_PKTGEN_START_MASK    0x10
+#define    RTL8367C_PKTGEN_BYPASS_FLOWCONTROL_OFFSET    0
+#define    RTL8367C_PKTGEN_BYPASS_FLOWCONTROL_MASK    0x1
+
+#define    RTL8367C_REG_SW_DUMMY0    0x1214
+#define    RTL8367C_SW_DUMMY0_DUMMY_OFFSET    4
+#define    RTL8367C_SW_DUMMY0_DUMMY_MASK    0xFFF0
+#define    RTL8367C_EEE_DEFER_TXLPI_OFFSET    3
+#define    RTL8367C_EEE_DEFER_TXLPI_MASK    0x8
+#define    RTL8367C_INGRESSBW_BYPASS_EN_OFFSET    2
+#define    RTL8367C_INGRESSBW_BYPASS_EN_MASK    0x4
+#define    RTL8367C_CFG_RX_MIN_OFFSET    0
+#define    RTL8367C_CFG_RX_MIN_MASK    0x3
+
+#define    RTL8367C_REG_SW_DUMMY1    0x1215
+
+#define    RTL8367C_REG_PKTGEN_PAUSE_TIME    0x1216
+
+#define    RTL8367C_REG_SVLAN_UPLINK_PORTMASK    0x1218
+#define    RTL8367C_SVLAN_UPLINK_PORTMASK_OFFSET    0
+#define    RTL8367C_SVLAN_UPLINK_PORTMASK_MASK    0x7FF
+
+#define    RTL8367C_REG_CPU_PORT_MASK    0x1219
+#define    RTL8367C_CPU_PORT_MASK_OFFSET    0
+#define    RTL8367C_CPU_PORT_MASK_MASK    0x7FF
+
+#define    RTL8367C_REG_CPU_CTRL    0x121a
+#define    RTL8367C_CPU_TRAP_PORT_EXT_OFFSET    10
+#define    RTL8367C_CPU_TRAP_PORT_EXT_MASK    0x400
+#define    RTL8367C_CPU_TAG_FORMAT_OFFSET    9
+#define    RTL8367C_CPU_TAG_FORMAT_MASK    0x200
+#define    RTL8367C_IOL_16DROP_OFFSET    8
+#define    RTL8367C_IOL_16DROP_MASK    0x100
+#define    RTL8367C_CPU_TAG_RXBYTECOUNT_OFFSET    7
+#define    RTL8367C_CPU_TAG_RXBYTECOUNT_MASK    0x80
+#define    RTL8367C_CPU_TAG_POSITION_OFFSET    6
+#define    RTL8367C_CPU_TAG_POSITION_MASK    0x40
+#define    RTL8367C_CPU_TRAP_PORT_OFFSET    3
+#define    RTL8367C_CPU_TRAP_PORT_MASK    0x38
+#define    RTL8367C_CPU_INSERTMODE_OFFSET    1
+#define    RTL8367C_CPU_INSERTMODE_MASK    0x6
+#define    RTL8367C_CPU_EN_OFFSET    0
+#define    RTL8367C_CPU_EN_MASK    0x1
+
+#define    RTL8367C_REG_MIRROR_CTRL    0x121c
+#define    RTL8367C_MIRROR_CTRL_DUMMY_OFFSET    12
+#define    RTL8367C_MIRROR_CTRL_DUMMY_MASK    0xF000
+#define    RTL8367C_MIRROR_ISO_OFFSET    11
+#define    RTL8367C_MIRROR_ISO_MASK    0x800
+#define    RTL8367C_MIRROR_TX_OFFSET    10
+#define    RTL8367C_MIRROR_TX_MASK    0x400
+#define    RTL8367C_MIRROR_RX_OFFSET    9
+#define    RTL8367C_MIRROR_RX_MASK    0x200
+#define    RTL8367C_MIRROR_MONITOR_PORT_OFFSET    4
+#define    RTL8367C_MIRROR_MONITOR_PORT_MASK    0xF0
+#define    RTL8367C_MIRROR_SOURCE_PORT_OFFSET    0
+#define    RTL8367C_MIRROR_SOURCE_PORT_MASK    0xF
+
+#define    RTL8367C_REG_FLOWCTRL_CTRL0    0x121d
+#define    RTL8367C_FLOWCTRL_TYPE_OFFSET    15
+#define    RTL8367C_FLOWCTRL_TYPE_MASK    0x8000
+#define    RTL8367C_DROP_ALL_THRESHOLD_OFFSET    5
+#define    RTL8367C_DROP_ALL_THRESHOLD_MASK    0x7FE0
+#define    RTL8367C_DROP_ALL_THRESHOLD_MSB_OFFSET    4
+#define    RTL8367C_DROP_ALL_THRESHOLD_MSB_MASK    0x10
+#define    RTL8367C_ITFSP_REG_OFFSET    0
+#define    RTL8367C_ITFSP_REG_MASK    0x7
+
+#define    RTL8367C_REG_FLOWCTRL_ALL_ON    0x121e
+#define    RTL8367C_CFG_RLDPACT_OFFSET    12
+#define    RTL8367C_CFG_RLDPACT_MASK    0x1000
+#define    RTL8367C_FLOWCTRL_ALL_ON_THRESHOLD_OFFSET    0
+#define    RTL8367C_FLOWCTRL_ALL_ON_THRESHOLD_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_SYS_ON    0x121f
+#define    RTL8367C_FLOWCTRL_SYS_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_SYS_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_SYS_OFF    0x1220
+#define    RTL8367C_FLOWCTRL_SYS_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_SYS_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_SHARE_ON    0x1221
+#define    RTL8367C_FLOWCTRL_SHARE_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_SHARE_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_SHARE_OFF    0x1222
+#define    RTL8367C_FLOWCTRL_SHARE_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_SHARE_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_FCOFF_SYS_ON    0x1223
+#define    RTL8367C_FLOWCTRL_FCOFF_SYS_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_FCOFF_SYS_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_FCOFF_SYS_OFF    0x1224
+#define    RTL8367C_FLOWCTRL_FCOFF_SYS_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_FCOFF_SYS_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_FCOFF_SHARE_ON    0x1225
+#define    RTL8367C_FLOWCTRL_FCOFF_SHARE_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_FCOFF_SHARE_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_FCOFF_SHARE_OFF    0x1226
+#define    RTL8367C_FLOWCTRL_FCOFF_SHARE_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_FCOFF_SHARE_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT_ON    0x1227
+#define    RTL8367C_FLOWCTRL_PORT_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT_OFF    0x1228
+#define    RTL8367C_FLOWCTRL_PORT_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT_PRIVATE_ON    0x1229
+#define    RTL8367C_FLOWCTRL_PORT_PRIVATE_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT_PRIVATE_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT_PRIVATE_OFF    0x122a
+#define    RTL8367C_FLOWCTRL_PORT_PRIVATE_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT_PRIVATE_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_RRCP_CTRL0    0x122b
+#define    RTL8367C_COL_SEL_OFFSET    14
+#define    RTL8367C_COL_SEL_MASK    0x4000
+#define    RTL8367C_CRS_SEL_OFFSET    13
+#define    RTL8367C_CRS_SEL_MASK    0x2000
+#define    RTL8367C_RRCP_PBVLAN_EN_OFFSET    11
+#define    RTL8367C_RRCP_PBVLAN_EN_MASK    0x800
+#define    RTL8367C_RRCPV3_SECURITY_CRC_OFFSET    10
+#define    RTL8367C_RRCPV3_SECURITY_CRC_MASK    0x400
+#define    RTL8367C_RRCPV3_HANDLE_OFFSET    8
+#define    RTL8367C_RRCPV3_HANDLE_MASK    0x300
+#define    RTL8367C_RRCPV1_MALFORMED_ACT_OFFSET    5
+#define    RTL8367C_RRCPV1_MALFORMED_ACT_MASK    0x60
+#define    RTL8367C_RRCP_VLANLEAKY_OFFSET    4
+#define    RTL8367C_RRCP_VLANLEAKY_MASK    0x10
+#define    RTL8367C_RRCPV1_SECURITY_CRC_GET_OFFSET    3
+#define    RTL8367C_RRCPV1_SECURITY_CRC_GET_MASK    0x8
+#define    RTL8367C_RRCPV1_SECURITY_CRC_SET_OFFSET    2
+#define    RTL8367C_RRCPV1_SECURITY_CRC_SET_MASK    0x4
+#define    RTL8367C_RRCPV1_HANDLE_OFFSET    1
+#define    RTL8367C_RRCPV1_HANDLE_MASK    0x2
+#define    RTL8367C_RRCP_ENABLE_OFFSET    0
+#define    RTL8367C_RRCP_ENABLE_MASK    0x1
+
+#define    RTL8367C_REG_RRCP_CTRL1    0x122c
+#define    RTL8367C_RRCP_ADMIN_PMSK_OFFSET    8
+#define    RTL8367C_RRCP_ADMIN_PMSK_MASK    0xFF00
+#define    RTL8367C_RRCP_AUTH_PMSK_OFFSET    0
+#define    RTL8367C_RRCP_AUTH_PMSK_MASK    0xFF
+
+#define    RTL8367C_REG_RRCP_CTRL2    0x122d
+#define    RTL8367C_RRCPV1_HELLOFWD_TAG_OFFSET    9
+#define    RTL8367C_RRCPV1_HELLOFWD_TAG_MASK    0x600
+#define    RTL8367C_RRCP_FWD_TAG_OFFSET    7
+#define    RTL8367C_RRCP_FWD_TAG_MASK    0x180
+#define    RTL8367C_RRCPV1_REPLY_TAG_OFFSET    6
+#define    RTL8367C_RRCPV1_REPLY_TAG_MASK    0x40
+#define    RTL8367C_RRCPV1_HELLO_COUNT_OFFSET    3
+#define    RTL8367C_RRCPV1_HELLO_COUNT_MASK    0x38
+#define    RTL8367C_RRCPV1_HELLO_PEDIOD_OFFSET    0
+#define    RTL8367C_RRCPV1_HELLO_PEDIOD_MASK    0x3
+
+#define    RTL8367C_REG_RRCP_CTRL3    0x122e
+#define    RTL8367C_RRCP_TAG_PRIORITY_OFFSET    13
+#define    RTL8367C_RRCP_TAG_PRIORITY_MASK    0xE000
+#define    RTL8367C_RRCP_TAG_VID_OFFSET    0
+#define    RTL8367C_RRCP_TAG_VID_MASK    0xFFF
+
+#define    RTL8367C_REG_FLOWCTRL_FCOFF_PORT_ON    0x122f
+#define    RTL8367C_FLOWCTRL_FCOFF_PORT_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_FCOFF_PORT_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_FCOFF_PORT_OFF    0x1230
+#define    RTL8367C_FLOWCTRL_FCOFF_PORT_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_FCOFF_PORT_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_FCOFF_PORT_PRIVATE_ON    0x1231
+#define    RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_FCOFF_PORT_PRIVATE_OFF    0x1232
+#define    RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_JUMBO_SYS_ON    0x1233
+#define    RTL8367C_FLOWCTRL_JUMBO_SYS_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_JUMBO_SYS_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_JUMBO_SYS_OFF    0x1234
+#define    RTL8367C_FLOWCTRL_JUMBO_SYS_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_JUMBO_SYS_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_JUMBO_SHARE_ON    0x1235
+#define    RTL8367C_FLOWCTRL_JUMBO_SHARE_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_JUMBO_SHARE_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_JUMBO_SHARE_OFF    0x1236
+#define    RTL8367C_FLOWCTRL_JUMBO_SHARE_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_JUMBO_SHARE_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_JUMBO_PORT_ON    0x1237
+#define    RTL8367C_FLOWCTRL_JUMBO_PORT_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_JUMBO_PORT_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_JUMBO_PORT_OFF    0x1238
+#define    RTL8367C_FLOWCTRL_JUMBO_PORT_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_JUMBO_PORT_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_JUMBO_PORT_PRIVATE_ON    0x1239
+#define    RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_ON_OFFSET    0
+#define    RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_ON_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_JUMBO_PORT_PRIVATE_OFF    0x123a
+#define    RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_OFF_OFFSET    0
+#define    RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_OFF_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_JUMBO_SIZE    0x123b
+#define    RTL8367C_JUMBO_MODE_OFFSET    2
+#define    RTL8367C_JUMBO_MODE_MASK    0x4
+#define    RTL8367C_JUMBO_SIZE_OFFSET    0
+#define    RTL8367C_JUMBO_SIZE_MASK    0x3
+
+#define    RTL8367C_REG_FLOWCTRL_TOTAL_PAGE_COUNTER    0x124c
+#define    RTL8367C_FLOWCTRL_TOTAL_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_TOTAL_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PUBLIC_PAGE_COUNTER    0x124d
+#define    RTL8367C_FLOWCTRL_PUBLIC_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PUBLIC_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_TOTAL_PAGE_MAX    0x124e
+#define    RTL8367C_FLOWCTRL_TOTAL_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_TOTAL_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PUBLIC_PAGE_MAX    0x124f
+#define    RTL8367C_FLOWCTRL_PUBLIC_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PUBLIC_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT0_PAGE_COUNTER    0x1250
+#define    RTL8367C_FLOWCTRL_PORT0_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT0_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT1_PAGE_COUNTER    0x1251
+#define    RTL8367C_FLOWCTRL_PORT1_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT1_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT2_PAGE_COUNTER    0x1252
+#define    RTL8367C_FLOWCTRL_PORT2_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT2_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT3_PAGE_COUNTER    0x1253
+#define    RTL8367C_FLOWCTRL_PORT3_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT3_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT4_PAGE_COUNTER    0x1254
+#define    RTL8367C_FLOWCTRL_PORT4_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT4_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT5_PAGE_COUNTER    0x1255
+#define    RTL8367C_FLOWCTRL_PORT5_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT5_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT6_PAGE_COUNTER    0x1256
+#define    RTL8367C_FLOWCTRL_PORT6_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT6_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT7_PAGE_COUNTER    0x1257
+#define    RTL8367C_FLOWCTRL_PORT7_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT7_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PUBLIC_FCOFF_PAGE_COUNTER    0x1258
+#define    RTL8367C_FLOWCTRL_PUBLIC_FCOFF_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PUBLIC_FCOFF_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PUBLIC_JUMBO_PAGE_COUNTER    0x1259
+#define    RTL8367C_FLOWCTRL_PUBLIC_JUMBO_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PUBLIC_JUMBO_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_MAX_PUBLIC_FCOFF_PAGE_COUNTER    0x125a
+#define    RTL8367C_FLOWCTRL_MAX_PUBLIC_FCOFF_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_MAX_PUBLIC_FCOFF_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_MAX_PUBLIC_JUMBO_PAGE_COUNTER    0x125b
+#define    RTL8367C_FLOWCTRL_MAX_PUBLIC_JUMBO_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_MAX_PUBLIC_JUMBO_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT0_PAGE_MAX    0x1260
+#define    RTL8367C_FLOWCTRL_PORT0_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT0_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT1_PAGE_MAX    0x1261
+#define    RTL8367C_FLOWCTRL_PORT1_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT1_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT2_PAGE_MAX    0x1262
+#define    RTL8367C_FLOWCTRL_PORT2_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT2_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT3_PAGE_MAX    0x1263
+#define    RTL8367C_FLOWCTRL_PORT3_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT3_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT4_PAGE_MAX    0x1264
+#define    RTL8367C_FLOWCTRL_PORT4_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT4_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT5_PAGE_MAX    0x1265
+#define    RTL8367C_FLOWCTRL_PORT5_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT5_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT6_PAGE_MAX    0x1266
+#define    RTL8367C_FLOWCTRL_PORT6_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT6_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT7_PAGE_MAX    0x1267
+#define    RTL8367C_FLOWCTRL_PORT7_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT7_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PAGE_COUNT_CLEAR    0x1268
+#define    RTL8367C_DIS_SKIP_FP_OFFSET    1
+#define    RTL8367C_DIS_SKIP_FP_MASK    0x2
+#define    RTL8367C_PAGE_COUNT_CLEAR_OFFSET    0
+#define    RTL8367C_PAGE_COUNT_CLEAR_MASK    0x1
+
+#define    RTL8367C_REG_FLOWCTRL_PORT8_PAGE_MAX    0x1269
+#define    RTL8367C_FLOWCTRL_PORT8_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT8_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT9_PAGE_MAX    0x126a
+#define    RTL8367C_FLOWCTRL_PORT9_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT9_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT10_PAGE_MAX    0x126b
+#define    RTL8367C_FLOWCTRL_PORT10_PAGE_MAX_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT10_PAGE_MAX_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT8_PAGE_COUNTER    0x126c
+#define    RTL8367C_FLOWCTRL_PORT8_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT8_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT9_PAGE_COUNTER    0x126d
+#define    RTL8367C_FLOWCTRL_PORT9_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT9_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_FLOWCTRL_PORT10_PAGE_COUNTER    0x126e
+#define    RTL8367C_FLOWCTRL_PORT10_PAGE_COUNTER_OFFSET    0
+#define    RTL8367C_FLOWCTRL_PORT10_PAGE_COUNTER_MASK    0x7FF
+
+#define    RTL8367C_REG_RRCP_CTRL1_H    0x126f
+#define    RTL8367C_RRCP_ADMIN_PMSK_P10_8_OFFSET    3
+#define    RTL8367C_RRCP_ADMIN_PMSK_P10_8_MASK    0x38
+#define    RTL8367C_RRCP_AUTH_PMSK_P10_8_OFFSET    0
+#define    RTL8367C_RRCP_AUTH_PMSK_P10_8_MASK    0x7
+
+#define    RTL8367C_REG_EMA_CTRL0    0x1270
+#define    RTL8367C_CFG_DVSE_VIAROM_OFFSET    13
+#define    RTL8367C_CFG_DVSE_VIAROM_MASK    0x2000
+#define    RTL8367C_CFG_DVSE_MIBRAM_OFFSET    12
+#define    RTL8367C_CFG_DVSE_MIBRAM_MASK    0x1000
+#define    RTL8367C_CFG_DVSE_IROM_OFFSET    11
+#define    RTL8367C_CFG_DVSE_IROM_MASK    0x800
+#define    RTL8367C_CFG_DVSE_ERAM_OFFSET    10
+#define    RTL8367C_CFG_DVSE_ERAM_MASK    0x400
+#define    RTL8367C_CFG_DVSE_IRAM_OFFSET    9
+#define    RTL8367C_CFG_DVSE_IRAM_MASK    0x200
+#define    RTL8367C_CFG_DVSE_NICRAM_OFFSET    8
+#define    RTL8367C_CFG_DVSE_NICRAM_MASK    0x100
+#define    RTL8367C_CFG_DVSE_CVLANRAM_OFFSET    7
+#define    RTL8367C_CFG_DVSE_CVLANRAM_MASK    0x80
+#define    RTL8367C_CFG_DVSE_ACTRAM_OFFSET    6
+#define    RTL8367C_CFG_DVSE_ACTRAM_MASK    0x40
+#define    RTL8367C_CFG_DVSE_INQRAM_OFFSET    5
+#define    RTL8367C_CFG_DVSE_INQRAM_MASK    0x20
+#define    RTL8367C_CFG_DVSE_HSARAM_OFFSET    4
+#define    RTL8367C_CFG_DVSE_HSARAM_MASK    0x10
+#define    RTL8367C_CFG_DVSE_OUTQRAM_OFFSET    3
+#define    RTL8367C_CFG_DVSE_OUTQRAM_MASK    0x8
+#define    RTL8367C_CFG_DVSE_HTRAM_OFFSET    2
+#define    RTL8367C_CFG_DVSE_HTRAM_MASK    0x4
+#define    RTL8367C_CFG_DVSE_PBRAM_OFFSET    1
+#define    RTL8367C_CFG_DVSE_PBRAM_MASK    0x2
+#define    RTL8367C_CFG_DVSE_L2RAM_OFFSET    0
+#define    RTL8367C_CFG_DVSE_L2RAM_MASK    0x1
+
+#define    RTL8367C_REG_EMA_CTRL1    0x1271
+#define    RTL8367C_CFG_DVS_OUTQRAM_OFFSET    12
+#define    RTL8367C_CFG_DVS_OUTQRAM_MASK    0xF000
+#define    RTL8367C_CFG_DVS_HTRAM_OFFSET    8
+#define    RTL8367C_CFG_DVS_HTRAM_MASK    0x700
+#define    RTL8367C_CFG_DVS_PBRAM_OFFSET    4
+#define    RTL8367C_CFG_DVS_PBRAM_MASK    0xF0
+#define    RTL8367C_CFG_DVS_L2RAM_OFFSET    0
+#define    RTL8367C_CFG_DVS_L2RAM_MASK    0xF
+
+#define    RTL8367C_REG_EMA_CTRL2    0x1272
+#define    RTL8367C_CFG_DVS_CVLANRAM_OFFSET    12
+#define    RTL8367C_CFG_DVS_CVLANRAM_MASK    0xF000
+#define    RTL8367C_CFG_DVS_ACTRAM_OFFSET    8
+#define    RTL8367C_CFG_DVS_ACTRAM_MASK    0xF00
+#define    RTL8367C_CFG_DVS_INQRAM_OFFSET    4
+#define    RTL8367C_CFG_DVS_INQRAM_MASK    0xF0
+#define    RTL8367C_CFG_DVS_HSARAM_OFFSET    0
+#define    RTL8367C_CFG_DVS_HSARAM_MASK    0xF
+
+#define    RTL8367C_REG_EMA_CTRL3    0x1273
+#define    RTL8367C_CFG_DVS_IROM_OFFSET    12
+#define    RTL8367C_CFG_DVS_IROM_MASK    0xF000
+#define    RTL8367C_CFG_DVS_ERAM_OFFSET    8
+#define    RTL8367C_CFG_DVS_ERAM_MASK    0xF00
+#define    RTL8367C_CFG_DVS_IRAM_OFFSET    4
+#define    RTL8367C_CFG_DVS_IRAM_MASK    0xF0
+#define    RTL8367C_CFG_DVS_NICRAM_OFFSET    0
+#define    RTL8367C_CFG_DVS_NICRAM_MASK    0xF
+
+#define    RTL8367C_REG_EMA_CTRL4    0x1274
+#define    RTL8367C_CFG_DVS_VIAROM_OFFSET    4
+#define    RTL8367C_CFG_DVS_VIAROM_MASK    0xF0
+#define    RTL8367C_CFG_DVS_MIBRAM_OFFSET    0
+#define    RTL8367C_CFG_DVS_MIBRAM_MASK    0xF
+
+#define    RTL8367C_REG_DIAG_MODE    0x1275
+#define    RTL8367C_DIAG_MODE_OFFSET    0
+#define    RTL8367C_DIAG_MODE_MASK    0x1F
+
+#define    RTL8367C_REG_BIST_MODE    0x1276
+
+#define    RTL8367C_REG_STS_BIST_DONE    0x1277
+
+#define    RTL8367C_REG_STS_BIST_RLT0    0x1278
+#define    RTL8367C_STS_BIST_RLT0_OFFSET    0
+#define    RTL8367C_STS_BIST_RLT0_MASK    0x1
+
+#define    RTL8367C_REG_STS_BIST_RLT1    0x1279
+
+#define    RTL8367C_REG_STS_BIST_RLT2    0x127a
+
+#define    RTL8367C_REG_STS_BIST_RLT3    0x127b
+#define    RTL8367C_STS_BIST_RLT3_OFFSET    0
+#define    RTL8367C_STS_BIST_RLT3_MASK    0x3FF
+
+#define    RTL8367C_REG_STS_BIST_RLT4    0x127c
+#define    RTL8367C_STS_BIST_RLT4_OFFSET    0
+#define    RTL8367C_STS_BIST_RLT4_MASK    0x7
+
+#define    RTL8367C_REG_VIAROM_MISR    0x127d
+
+#define    RTL8367C_REG_DRF_BIST_MODE    0x1280
+#define    RTL8367C_DRF_TCAMDEL_OFFSET    15
+#define    RTL8367C_DRF_TCAMDEL_MASK    0x8000
+#define    RTL8367C_CFG_DRF_BIST_MODE_OFFSET    0
+#define    RTL8367C_CFG_DRF_BIST_MODE_MASK    0x7FFF
+
+#define    RTL8367C_REG_STS_DRF_BIST    0x1281
+#define    RTL8367C_STS_DRF_BIST_OFFSET    0
+#define    RTL8367C_STS_DRF_BIST_MASK    0x7FFF
+
+#define    RTL8367C_REG_STS_DRF_BIST_RLT0    0x1282
+#define    RTL8367C_STS_DRF_BIST_RLT0_OFFSET    0
+#define    RTL8367C_STS_DRF_BIST_RLT0_MASK    0x1
+
+#define    RTL8367C_REG_STS_DRF_BIST_RLT1    0x1283
+
+#define    RTL8367C_REG_STS_DRF_BIST_RLT2    0x1284
+
+#define    RTL8367C_REG_STS_DRF_BIST_RLT3    0x1285
+#define    RTL8367C_STS_DRF_BIST_RLT3_OFFSET    0
+#define    RTL8367C_STS_DRF_BIST_RLT3_MASK    0x3FF
+
+#define    RTL8367C_REG_STS_DRF_BIST_RLT4    0x1286
+#define    RTL8367C_STS_DRF_BIST_RLT4_OFFSET    0
+#define    RTL8367C_STS_DRF_BIST_RLT4_MASK    0x7FFF
+
+#define    RTL8367C_REG_RAM_DRF_CTRL    0x1289
+#define    RTL8367C_RAM_DRF_CTRL_OFFSET    0
+#define    RTL8367C_RAM_DRF_CTRL_MASK    0x1
+
+#define    RTL8367C_REG_MIB_RMON_LEN_CTRL    0x128a
+#define    RTL8367C_RX_LENGTH_CTRL_OFFSET    1
+#define    RTL8367C_RX_LENGTH_CTRL_MASK    0x2
+#define    RTL8367C_TX_LENGTH_CTRL_OFFSET    0
+#define    RTL8367C_TX_LENGTH_CTRL_MASK    0x1
+
+#define    RTL8367C_REG_COND0_BISR_OUT0    0x1290
+
+#define    RTL8367C_REG_COND0_BISR_OUT1    0x1291
+
+#define    RTL8367C_REG_COND0_BISR_OUT2    0x1292
+
+#define    RTL8367C_REG_COND0_BISR_OUT3    0x1293
+
+#define    RTL8367C_REG_COND0_BISR_OUT4    0x1294
+#define    RTL8367C_COND0_BISR_OUT4_OFFSET    0
+#define    RTL8367C_COND0_BISR_OUT4_MASK    0x3F
+
+#define    RTL8367C_REG_COND0_BISR_OUT5    0x1295
+#define    RTL8367C_COND0_BISR_OUT5_OFFSET    0
+#define    RTL8367C_COND0_BISR_OUT5_MASK    0x7
+
+#define    RTL8367C_REG_CHG_DUPLEX_CFG    0x1296
+#define    RTL8367C_CHG_COL_CNT_PORT_OFFSET    13
+#define    RTL8367C_CHG_COL_CNT_PORT_MASK    0xE000
+#define    RTL8367C_CHG_COL_CNT_OFFSET    8
+#define    RTL8367C_CHG_COL_CNT_MASK    0x1F00
+#define    RTL8367C_CFG_CHG_DUP_EN_OFFSET    7
+#define    RTL8367C_CFG_CHG_DUP_EN_MASK    0x80
+#define    RTL8367C_CFG_CHG_DUP_THR_OFFSET    2
+#define    RTL8367C_CFG_CHG_DUP_THR_MASK    0x7C
+#define    RTL8367C_CFG_CHG_DUP_CONGEST_OFFSET    1
+#define    RTL8367C_CFG_CHG_DUP_CONGEST_MASK    0x2
+#define    RTL8367C_CFG_CHG_DUP_REF_OFFSET    0
+#define    RTL8367C_CFG_CHG_DUP_REF_MASK    0x1
+
+#define    RTL8367C_REG_COND0_BIST_PASS    0x1297
+#define    RTL8367C_COND0_DRF_BIST_NOFAIL_OFFSET    1
+#define    RTL8367C_COND0_DRF_BIST_NOFAIL_MASK    0x2
+#define    RTL8367C_COND0_BIST_NOFAIL_OFFSET    0
+#define    RTL8367C_COND0_BIST_NOFAIL_MASK    0x1
+
+#define    RTL8367C_REG_COND1_BISR_OUT0    0x1298
+
+#define    RTL8367C_REG_COND1_BISR_OUT1    0x1299
+
+#define    RTL8367C_REG_COND1_BISR_OUT2    0x129a
+
+#define    RTL8367C_REG_COND1_BISR_OUT3    0x129b
+
+#define    RTL8367C_REG_COND1_BISR_OUT4    0x129c
+#define    RTL8367C_COND1_BISR_OUT4_OFFSET    0
+#define    RTL8367C_COND1_BISR_OUT4_MASK    0x3F
+
+#define    RTL8367C_REG_COND1_BISR_OUT5    0x129d
+#define    RTL8367C_COND1_BISR_OUT5_OFFSET    0
+#define    RTL8367C_COND1_BISR_OUT5_MASK    0x7
+
+#define    RTL8367C_REG_COND1_BIST_PASS    0x129f
+#define    RTL8367C_COND1_DRF_BIST_NOFAIL_OFFSET    1
+#define    RTL8367C_COND1_DRF_BIST_NOFAIL_MASK    0x2
+#define    RTL8367C_COND1_BIST_NOFAIL_OFFSET    0
+#define    RTL8367C_COND1_BIST_NOFAIL_MASK    0x1
+
+#define    RTL8367C_REG_EEE_TX_THR_Giga_500M    0x12a0
+
+#define    RTL8367C_REG_EEE_TX_THR_FE    0x12a1
+
+#define    RTL8367C_REG_EEE_MISC    0x12a3
+#define    RTL8367C_EEE_REQ_SET1_OFFSET    13
+#define    RTL8367C_EEE_REQ_SET1_MASK    0x2000
+#define    RTL8367C_EEE_REQ_SET0_OFFSET    12
+#define    RTL8367C_EEE_REQ_SET0_MASK    0x1000
+#define    RTL8367C_EEE_WAKE_SET1_OFFSET    9
+#define    RTL8367C_EEE_WAKE_SET1_MASK    0x200
+#define    RTL8367C_EEE_Wake_SET0_OFFSET    8
+#define    RTL8367C_EEE_Wake_SET0_MASK    0x100
+#define    RTL8367C_EEE_TU_GIGA_500M_OFFSET    4
+#define    RTL8367C_EEE_TU_GIGA_500M_MASK    0x30
+#define    RTL8367C_EEE_TU_100M_OFFSET    2
+#define    RTL8367C_EEE_TU_100M_MASK    0xC
+
+#define    RTL8367C_REG_EEE_GIGA_CTRL0    0x12a4
+#define    RTL8367C_EEE_TW_GIGA_OFFSET    8
+#define    RTL8367C_EEE_TW_GIGA_MASK    0xFF00
+#define    RTL8367C_EEE_TR_GIGA_500M_OFFSET    0
+#define    RTL8367C_EEE_TR_GIGA_500M_MASK    0xFF
+
+#define    RTL8367C_REG_EEE_GIGA_CTRL1    0x12a5
+#define    RTL8367C_EEE_TD_GIGA_500M_OFFSET    8
+#define    RTL8367C_EEE_TD_GIGA_500M_MASK    0xFF00
+#define    RTL8367C_EEE_TP_GIGA_OFFSET    0
+#define    RTL8367C_EEE_TP_GIGA_MASK    0xFF
+
+#define    RTL8367C_REG_EEE_100M_CTRL0    0x12a6
+#define    RTL8367C_EEE_TW_100M_OFFSET    8
+#define    RTL8367C_EEE_TW_100M_MASK    0xFF00
+#define    RTL8367C_EEE_TR_100M_OFFSET    0
+#define    RTL8367C_EEE_TR_100M_MASK    0xFF
+
+#define    RTL8367C_REG_EEE_100M_CTRL1    0x12a7
+#define    RTL8367C_EEE_TD_100M_OFFSET    8
+#define    RTL8367C_EEE_TD_100M_MASK    0xFF00
+#define    RTL8367C_EEE_TP_100M_OFFSET    0
+#define    RTL8367C_EEE_TP_100M_MASK    0xFF
+
+#define    RTL8367C_REG_RX_FC_REG    0x12aa
+#define    RTL8367C_EN_EEE_HALF_DUP_OFFSET    8
+#define    RTL8367C_EN_EEE_HALF_DUP_MASK    0x100
+#define    RTL8367C_RX_PGCNT_OFFSET    0
+#define    RTL8367C_RX_PGCNT_MASK    0xFF
+
+#define    RTL8367C_REG_MAX_FIFO_SIZE    0x12af
+#define    RTL8367C_MAX_FIFO_SIZE_OFFSET    0
+#define    RTL8367C_MAX_FIFO_SIZE_MASK    0xF
+
+#define    RTL8367C_REG_EEEP_RX_RATE_GIGA    0x12b0
+
+#define    RTL8367C_REG_EEEP_RX_RATE_100M    0x12b1
+
+#define    RTL8367C_REG_DUMMY_REG_12_2    0x12b2
+
+#define    RTL8367C_REG_EEEP_TX_RATE_GIGA    0x12b3
+
+#define    RTL8367C_REG_EEEP_TX_RATE_100M    0x12b4
+
+#define    RTL8367C_REG_DUMMY_REG_12_3    0x12b5
+
+#define    RTL8367C_REG_EEEP_GIGA_CTRL0    0x12b6
+#define    RTL8367C_EEEP_TR_GIGA_OFFSET    8
+#define    RTL8367C_EEEP_TR_GIGA_MASK    0xFF00
+#define    RTL8367C_EEEP_RW_GIGA_MST_OFFSET    0
+#define    RTL8367C_EEEP_RW_GIGA_MST_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_GIGA_CTRL1    0x12b7
+#define    RTL8367C_EEEP_TW_GIGA_OFFSET    8
+#define    RTL8367C_EEEP_TW_GIGA_MASK    0xFF00
+#define    RTL8367C_EEEP_TP_GIGA_OFFSET    0
+#define    RTL8367C_EEEP_TP_GIGA_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_GIGA_CTRL2    0x12b8
+#define    RTL8367C_EEEP_TXEN_GIGA_OFFSET    12
+#define    RTL8367C_EEEP_TXEN_GIGA_MASK    0x1000
+#define    RTL8367C_EEEP_TU_GIGA_OFFSET    8
+#define    RTL8367C_EEEP_TU_GIGA_MASK    0x300
+#define    RTL8367C_EEEP_TS_GIGA_OFFSET    0
+#define    RTL8367C_EEEP_TS_GIGA_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_100M_CTRL0    0x12b9
+#define    RTL8367C_EEEP_TR_100M_OFFSET    8
+#define    RTL8367C_EEEP_TR_100M_MASK    0xFF00
+#define    RTL8367C_EEEP_RW_100M_OFFSET    0
+#define    RTL8367C_EEEP_RW_100M_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_100M_CTRL1    0x12ba
+#define    RTL8367C_EEEP_TW_100M_OFFSET    8
+#define    RTL8367C_EEEP_TW_100M_MASK    0xFF00
+#define    RTL8367C_EEEP_TP_100M_OFFSET    0
+#define    RTL8367C_EEEP_TP_100M_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_100M_CTRL2    0x12bb
+#define    RTL8367C_EEEP_TXEN_100M_OFFSET    12
+#define    RTL8367C_EEEP_TXEN_100M_MASK    0x1000
+#define    RTL8367C_EEEP_TU_100M_OFFSET    8
+#define    RTL8367C_EEEP_TU_100M_MASK    0x300
+#define    RTL8367C_EEEP_TS_100M_OFFSET    0
+#define    RTL8367C_EEEP_TS_100M_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_CTRL0    0x12bc
+#define    RTL8367C_EEEP_CTRL0_DUMMY_OFFSET    8
+#define    RTL8367C_EEEP_CTRL0_DUMMY_MASK    0xFF00
+#define    RTL8367C_EEEP_SLEEP_STEP_OFFSET    0
+#define    RTL8367C_EEEP_SLEEP_STEP_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_CTRL1    0x12bd
+#define    RTL8367C_EEEP_TXR_GIGA_OFFSET    8
+#define    RTL8367C_EEEP_TXR_GIGA_MASK    0xFF00
+#define    RTL8367C_EEEP_TXR_100M_OFFSET    0
+#define    RTL8367C_EEEP_TXR_100M_MASK    0xFF
+
+#define    RTL8367C_REG_BACK_PRESSURE_IPG    0x12be
+#define    RTL8367C_BACK_PRESSURE_IPG_OFFSET    0
+#define    RTL8367C_BACK_PRESSURE_IPG_MASK    0x3
+
+#define    RTL8367C_REG_TX_ESD_LEVEL    0x12bf
+#define    RTL8367C_TX_ESD_LEVEL_MODE_OFFSET    8
+#define    RTL8367C_TX_ESD_LEVEL_MODE_MASK    0x100
+#define    RTL8367C_LEVEL_OFFSET    0
+#define    RTL8367C_LEVEL_MASK    0xFF
+
+#define    RTL8367C_REG_RRCP_CTRL4    0x12e0
+
+#define    RTL8367C_REG_RRCP_CTRL5    0x12e1
+
+#define    RTL8367C_REG_RRCP_CTRL6    0x12e2
+
+#define    RTL8367C_REG_RRCP_CTRL7    0x12e3
+
+#define    RTL8367C_REG_RRCP_CTRL8    0x12e4
+
+#define    RTL8367C_REG_RRCP_CTRL9    0x12e5
+
+#define    RTL8367C_REG_RRCP_CTRL10    0x12e6
+
+#define    RTL8367C_REG_FIELD_SELECTOR0    0x12e7
+#define    RTL8367C_FIELD_SELECTOR0_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR0_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR0_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR0_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR1    0x12e8
+#define    RTL8367C_FIELD_SELECTOR1_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR1_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR1_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR1_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR2    0x12e9
+#define    RTL8367C_FIELD_SELECTOR2_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR2_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR2_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR2_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR3    0x12ea
+#define    RTL8367C_FIELD_SELECTOR3_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR3_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR3_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR3_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR4    0x12eb
+#define    RTL8367C_FIELD_SELECTOR4_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR4_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR4_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR4_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR5    0x12ec
+#define    RTL8367C_FIELD_SELECTOR5_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR5_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR5_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR5_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR6    0x12ed
+#define    RTL8367C_FIELD_SELECTOR6_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR6_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR6_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR6_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR7    0x12ee
+#define    RTL8367C_FIELD_SELECTOR7_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR7_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR7_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR7_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR8    0x12ef
+#define    RTL8367C_FIELD_SELECTOR8_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR8_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR8_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR8_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR9    0x12f0
+#define    RTL8367C_FIELD_SELECTOR9_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR9_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR9_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR9_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR10    0x12f1
+#define    RTL8367C_FIELD_SELECTOR10_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR10_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR10_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR10_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR11    0x12f2
+#define    RTL8367C_FIELD_SELECTOR11_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR11_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR11_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR11_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR12    0x12f3
+#define    RTL8367C_FIELD_SELECTOR12_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR12_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR12_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR12_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR13    0x12f4
+#define    RTL8367C_FIELD_SELECTOR13_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR13_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR13_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR13_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR14    0x12f5
+#define    RTL8367C_FIELD_SELECTOR14_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR14_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR14_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR14_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_FIELD_SELECTOR15    0x12f6
+#define    RTL8367C_FIELD_SELECTOR15_FORMAT_OFFSET    8
+#define    RTL8367C_FIELD_SELECTOR15_FORMAT_MASK    0x700
+#define    RTL8367C_FIELD_SELECTOR15_OFFSET_OFFSET    0
+#define    RTL8367C_FIELD_SELECTOR15_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_HWPKT_GEN_MISC_H    0x12f7
+#define    RTL8367C_PKT_GEN_SUSPEND_P10_8_OFFSET    3
+#define    RTL8367C_PKT_GEN_SUSPEND_P10_8_MASK    0x38
+#define    RTL8367C_PKT_GEN_STATUS_P10_8_OFFSET    0
+#define    RTL8367C_PKT_GEN_STATUS_P10_8_MASK    0x7
+
+#define    RTL8367C_REG_MIRROR_SRC_PMSK    0x12fb
+#define    RTL8367C_MIRROR_SRC_PMSK_OFFSET    0
+#define    RTL8367C_MIRROR_SRC_PMSK_MASK    0x7FF
+
+#define    RTL8367C_REG_EEE_BURSTSIZE    0x12fc
+
+#define    RTL8367C_REG_EEE_IFG_CFG    0x12fd
+#define    RTL8367C_EEE_IFG_CFG_OFFSET    0
+#define    RTL8367C_EEE_IFG_CFG_MASK    0x1
+
+#define    RTL8367C_REG_FPGA_VER_MAC    0x12fe
+
+#define    RTL8367C_REG_HWPKT_GEN_MISC    0x12ff
+#define    RTL8367C_PKT_GEN_SUSPEND_OFFSET    8
+#define    RTL8367C_PKT_GEN_SUSPEND_MASK    0xFF00
+#define    RTL8367C_PKT_GEN_STATUS_OFFSET    0
+#define    RTL8367C_PKT_GEN_STATUS_MASK    0xFF
+
+/* (16'h1300)chip_reg */
+
+#define    RTL8367C_REG_CHIP_NUMBER    0x1300
+
+#define    RTL8367C_REG_CHIP_VER    0x1301
+#define    RTL8367C_VERID_OFFSET    12
+#define    RTL8367C_VERID_MASK    0xF000
+#define    RTL8367C_MCID_OFFSET    8
+#define    RTL8367C_MCID_MASK    0xF00
+#define    RTL8367C_MODEL_ID_OFFSET    4
+#define    RTL8367C_MODEL_ID_MASK    0xF0
+#define    RTL8367C_AFE_VERSION_OFFSET    0
+#define    RTL8367C_AFE_VERSION_MASK    0x1
+
+#define    RTL8367C_REG_CHIP_DEBUG0    0x1303
+#define    RTL8367C_SEL33_EXT2_OFFSET    10
+#define    RTL8367C_SEL33_EXT2_MASK    0x400
+#define    RTL8367C_SEL33_EXT1_OFFSET    9
+#define    RTL8367C_SEL33_EXT1_MASK    0x200
+#define    RTL8367C_SEL33_EXT0_OFFSET    8
+#define    RTL8367C_SEL33_EXT0_MASK    0x100
+#define    RTL8367C_DRI_OTHER_OFFSET    7
+#define    RTL8367C_DRI_OTHER_MASK    0x80
+#define    RTL8367C_DRI_EXT1_RG_OFFSET    6
+#define    RTL8367C_DRI_EXT1_RG_MASK    0x40
+#define    RTL8367C_DRI_EXT0_RG_OFFSET    5
+#define    RTL8367C_DRI_EXT0_RG_MASK    0x20
+#define    RTL8367C_DRI_EXT1_OFFSET    4
+#define    RTL8367C_DRI_EXT1_MASK    0x10
+#define    RTL8367C_DRI_EXT0_OFFSET    3
+#define    RTL8367C_DRI_EXT0_MASK    0x8
+#define    RTL8367C_SLR_OTHER_OFFSET    2
+#define    RTL8367C_SLR_OTHER_MASK    0x4
+#define    RTL8367C_SLR_EXT1_OFFSET    1
+#define    RTL8367C_SLR_EXT1_MASK    0x2
+#define    RTL8367C_SLR_EXT0_OFFSET    0
+#define    RTL8367C_SLR_EXT0_MASK    0x1
+
+#define    RTL8367C_REG_CHIP_DEBUG1    0x1304
+#define    RTL8367C_RG1_DN_OFFSET    12
+#define    RTL8367C_RG1_DN_MASK    0x7000
+#define    RTL8367C_RG1_DP_OFFSET    8
+#define    RTL8367C_RG1_DP_MASK    0x700
+#define    RTL8367C_RG0_DN_OFFSET    4
+#define    RTL8367C_RG0_DN_MASK    0x70
+#define    RTL8367C_RG0_DP_OFFSET    0
+#define    RTL8367C_RG0_DP_MASK    0x7
+
+#define    RTL8367C_REG_DIGITAL_INTERFACE_SELECT    0x1305
+#define    RTL8367C_ORG_COL_OFFSET    15
+#define    RTL8367C_ORG_COL_MASK    0x8000
+#define    RTL8367C_ORG_CRS_OFFSET    14
+#define    RTL8367C_ORG_CRS_MASK    0x4000
+#define    RTL8367C_SKIP_MII_1_RXER_OFFSET    13
+#define    RTL8367C_SKIP_MII_1_RXER_MASK    0x2000
+#define    RTL8367C_SKIP_MII_0_RXER_OFFSET    12
+#define    RTL8367C_SKIP_MII_0_RXER_MASK    0x1000
+#define    RTL8367C_SELECT_GMII_1_OFFSET    4
+#define    RTL8367C_SELECT_GMII_1_MASK    0xF0
+#define    RTL8367C_SELECT_GMII_0_OFFSET    0
+#define    RTL8367C_SELECT_GMII_0_MASK    0xF
+
+#define    RTL8367C_REG_EXT0_RGMXF    0x1306
+#define    RTL8367C_EXT0_RGTX_INV_OFFSET    6
+#define    RTL8367C_EXT0_RGTX_INV_MASK    0x40
+#define    RTL8367C_EXT0_RGRX_INV_OFFSET    5
+#define    RTL8367C_EXT0_RGRX_INV_MASK    0x20
+#define    RTL8367C_EXT0_RGMXF_OFFSET    0
+#define    RTL8367C_EXT0_RGMXF_MASK    0x1F
+
+#define    RTL8367C_REG_EXT1_RGMXF    0x1307
+#define    RTL8367C_EXT1_RGTX_INV_OFFSET    6
+#define    RTL8367C_EXT1_RGTX_INV_MASK    0x40
+#define    RTL8367C_EXT1_RGRX_INV_OFFSET    5
+#define    RTL8367C_EXT1_RGRX_INV_MASK    0x20
+#define    RTL8367C_EXT1_RGMXF_OFFSET    0
+#define    RTL8367C_EXT1_RGMXF_MASK    0x1F
+
+#define    RTL8367C_REG_BISR_CTRL    0x1308
+#define    RTL8367C_BISR_CTRL_OFFSET    0
+#define    RTL8367C_BISR_CTRL_MASK    0x7
+
+#define    RTL8367C_REG_SLF_IF    0x1309
+#define    RTL8367C_LINK_DOWN_CLR_FIFO_OFFSET    7
+#define    RTL8367C_LINK_DOWN_CLR_FIFO_MASK    0x80
+#define    RTL8367C_LOOPBACK_OFFSET    6
+#define    RTL8367C_LOOPBACK_MASK    0x40
+#define    RTL8367C_WATER_LEVEL_OFFSET    4
+#define    RTL8367C_WATER_LEVEL_MASK    0x30
+#define    RTL8367C_SLF_IF_OFFSET    0
+#define    RTL8367C_SLF_IF_MASK    0x3
+
+#define    RTL8367C_REG_I2C_CLOCK_DIV    0x130a
+#define    RTL8367C_I2C_CLOCK_DIV_OFFSET    0
+#define    RTL8367C_I2C_CLOCK_DIV_MASK    0x3FF
+
+#define    RTL8367C_REG_MDX_MDC_DIV    0x130b
+#define    RTL8367C_MDX_MDC_DIV_OFFSET    0
+#define    RTL8367C_MDX_MDC_DIV_MASK    0x3FF
+
+#define    RTL8367C_REG_MISCELLANEOUS_CONFIGURE0    0x130c
+#define    RTL8367C_ADCCKI_FROM_PAD_OFFSET    14
+#define    RTL8367C_ADCCKI_FROM_PAD_MASK    0x4000
+#define    RTL8367C_ADCCKI_EN_OFFSET    13
+#define    RTL8367C_ADCCKI_EN_MASK    0x2000
+#define    RTL8367C_FLASH_ENABLE_OFFSET    12
+#define    RTL8367C_FLASH_ENABLE_MASK    0x1000
+#define    RTL8367C_EEE_ENABLE_OFFSET    11
+#define    RTL8367C_EEE_ENABLE_MASK    0x800
+#define    RTL8367C_NIC_ENABLE_OFFSET    10
+#define    RTL8367C_NIC_ENABLE_MASK    0x400
+#define    RTL8367C_FT_ENABLE_OFFSET    9
+#define    RTL8367C_FT_ENABLE_MASK    0x200
+#define    RTL8367C_OLT_ENABLE_OFFSET    8
+#define    RTL8367C_OLT_ENABLE_MASK    0x100
+#define    RTL8367C_RTCT_EN_OFFSET    7
+#define    RTL8367C_RTCT_EN_MASK    0x80
+#define    RTL8367C_PON_LIGHT_EN_OFFSET    6
+#define    RTL8367C_PON_LIGHT_EN_MASK    0x40
+#define    RTL8367C_DW8051_EN_OFFSET    5
+#define    RTL8367C_DW8051_EN_MASK    0x20
+#define    RTL8367C_AUTOLOAD_EN_OFFSET    4
+#define    RTL8367C_AUTOLOAD_EN_MASK    0x10
+#define    RTL8367C_NRESTORE_EN_OFFSET    3
+#define    RTL8367C_NRESTORE_EN_MASK    0x8
+#define    RTL8367C_DIS_PON_TABLE_INIT_OFFSET    2
+#define    RTL8367C_DIS_PON_TABLE_INIT_MASK    0x4
+#define    RTL8367C_DIS_PON_BIST_OFFSET    1
+#define    RTL8367C_DIS_PON_BIST_MASK    0x2
+#define    RTL8367C_EFUSE_EN_OFFSET    0
+#define    RTL8367C_EFUSE_EN_MASK    0x1
+
+#define    RTL8367C_REG_MISCELLANEOUS_CONFIGURE1    0x130d
+#define    RTL8367C_EEPROM_DEV_ADR_OFFSET    8
+#define    RTL8367C_EEPROM_DEV_ADR_MASK    0x7F00
+#define    RTL8367C_EEPROM_MSB_OFFSET    7
+#define    RTL8367C_EEPROM_MSB_MASK    0x80
+#define    RTL8367C_EEPROM_ADDRESS_16B_OFFSET    6
+#define    RTL8367C_EEPROM_ADDRESS_16B_MASK    0x40
+#define    RTL8367C_EEPROM_DWONLOAD_COMPLETE_OFFSET    3
+#define    RTL8367C_EEPROM_DWONLOAD_COMPLETE_MASK    0x8
+#define    RTL8367C_SPI_SLAVE_EN_OFFSET    2
+#define    RTL8367C_SPI_SLAVE_EN_MASK    0x4
+#define    RTL8367C_SMI_SEL_OFFSET    0
+#define    RTL8367C_SMI_SEL_MASK    0x3
+
+#define    RTL8367C_REG_PHY_AD    0x130f
+#define    RTL8367C_EN_PHY_MAX_POWER_OFFSET    14
+#define    RTL8367C_EN_PHY_MAX_POWER_MASK    0x4000
+#define    RTL8367C_EN_PHY_SEL_DEG_OFFSET    13
+#define    RTL8367C_EN_PHY_SEL_DEG_MASK    0x2000
+#define    RTL8367C_EXTPHY_AD_OFFSET    8
+#define    RTL8367C_EXTPHY_AD_MASK    0x1F00
+#define    RTL8367C_EN_PHY_LOW_POWER_MODE_OFFSET    7
+#define    RTL8367C_EN_PHY_LOW_POWER_MODE_MASK    0x80
+#define    RTL8367C_EN_PHY_GREEN_OFFSET    6
+#define    RTL8367C_EN_PHY_GREEN_MASK    0x40
+#define    RTL8367C_PDNPHY_OFFSET    5
+#define    RTL8367C_PDNPHY_MASK    0x20
+#define    RTL8367C_INTPHY_AD_OFFSET    0
+#define    RTL8367C_INTPHY_AD_MASK    0x1F
+
+#define    RTL8367C_REG_DIGITAL_INTERFACE0_FORCE    0x1310
+#define    RTL8367C_GMII_0_FORCE_OFFSET    12
+#define    RTL8367C_GMII_0_FORCE_MASK    0x1000
+#define    RTL8367C_RGMII_0_FORCE_OFFSET    0
+#define    RTL8367C_RGMII_0_FORCE_MASK    0xFFF
+
+#define    RTL8367C_REG_DIGITAL_INTERFACE1_FORCE    0x1311
+#define    RTL8367C_GMII_1_FORCE_OFFSET    12
+#define    RTL8367C_GMII_1_FORCE_MASK    0x1000
+#define    RTL8367C_RGMII_1_FORCE_OFFSET    0
+#define    RTL8367C_RGMII_1_FORCE_MASK    0xFFF
+
+#define    RTL8367C_REG_MAC0_FORCE_SELECT    0x1312
+#define    RTL8367C_EN_MAC0_FORCE_OFFSET    12
+#define    RTL8367C_EN_MAC0_FORCE_MASK    0x1000
+#define    RTL8367C_MAC0_FORCE_ABLTY_OFFSET    0
+#define    RTL8367C_MAC0_FORCE_ABLTY_MASK    0xFFF
+
+#define    RTL8367C_REG_MAC1_FORCE_SELECT    0x1313
+#define    RTL8367C_EN_MAC1_FORCE_OFFSET    12
+#define    RTL8367C_EN_MAC1_FORCE_MASK    0x1000
+#define    RTL8367C_MAC1_FORCE_ABLTY_OFFSET    0
+#define    RTL8367C_MAC1_FORCE_ABLTY_MASK    0xFFF
+
+#define    RTL8367C_REG_MAC2_FORCE_SELECT    0x1314
+#define    RTL8367C_EN_MAC2_FORCE_OFFSET    12
+#define    RTL8367C_EN_MAC2_FORCE_MASK    0x1000
+#define    RTL8367C_MAC2_FORCE_ABLTY_OFFSET    0
+#define    RTL8367C_MAC2_FORCE_ABLTY_MASK    0xFFF
+
+#define    RTL8367C_REG_MAC3_FORCE_SELECT    0x1315
+#define    RTL8367C_EN_MAC3_FORCE_OFFSET    12
+#define    RTL8367C_EN_MAC3_FORCE_MASK    0x1000
+#define    RTL8367C_MAC3_FORCE_ABLTY_OFFSET    0
+#define    RTL8367C_MAC3_FORCE_ABLTY_MASK    0xFFF
+
+#define    RTL8367C_REG_MAC4_FORCE_SELECT    0x1316
+#define    RTL8367C_EN_MAC4_FORCE_OFFSET    12
+#define    RTL8367C_EN_MAC4_FORCE_MASK    0x1000
+#define    RTL8367C_MAC4_FORCE_ABLTY_OFFSET    0
+#define    RTL8367C_MAC4_FORCE_ABLTY_MASK    0xFFF
+
+#define    RTL8367C_REG_MAC5_FORCE_SELECT    0x1317
+#define    RTL8367C_EN_MAC5_FORCE_OFFSET    12
+#define    RTL8367C_EN_MAC5_FORCE_MASK    0x1000
+#define    RTL8367C_MAC5_FORCE_ABLTY_OFFSET    0
+#define    RTL8367C_MAC5_FORCE_ABLTY_MASK    0xFFF
+
+#define    RTL8367C_REG_MAC6_FORCE_SELECT    0x1318
+#define    RTL8367C_EN_MAC6_FORCE_OFFSET    12
+#define    RTL8367C_EN_MAC6_FORCE_MASK    0x1000
+#define    RTL8367C_MAC6_FORCE_ABLTY_OFFSET    0
+#define    RTL8367C_MAC6_FORCE_ABLTY_MASK    0xFFF
+
+#define    RTL8367C_REG_MAC7_FORCE_SELECT    0x1319
+#define    RTL8367C_EN_MAC7_FORCE_OFFSET    12
+#define    RTL8367C_EN_MAC7_FORCE_MASK    0x1000
+#define    RTL8367C_MAC7_FORCE_ABLTY_OFFSET    0
+#define    RTL8367C_MAC7_FORCE_ABLTY_MASK    0xFFF
+
+#define    RTL8367C_REG_M10_FORCE_SELECT    0x131c
+#define    RTL8367C_EN_M10_FORCE_OFFSET    12
+#define    RTL8367C_EN_M10_FORCE_MASK    0x1000
+#define    RTL8367C_M10_FORCE_ABLTY_OFFSET    0
+#define    RTL8367C_M10_FORCE_ABLTY_MASK    0xFFF
+
+#define    RTL8367C_REG_CHIP_RESET    0x1322
+#define    RTL8367C_GPHY_RESET_OFFSET    6
+#define    RTL8367C_GPHY_RESET_MASK    0x40
+#define    RTL8367C_NIC_RST_OFFSET    5
+#define    RTL8367C_NIC_RST_MASK    0x20
+#define    RTL8367C_DW8051_RST_OFFSET    4
+#define    RTL8367C_DW8051_RST_MASK    0x10
+#define    RTL8367C_SDS_RST_OFFSET    3
+#define    RTL8367C_SDS_RST_MASK    0x8
+#define    RTL8367C_CONFIG_RST_OFFSET    2
+#define    RTL8367C_CONFIG_RST_MASK    0x4
+#define    RTL8367C_SW_RST_OFFSET    1
+#define    RTL8367C_SW_RST_MASK    0x2
+#define    RTL8367C_CHIP_RST_OFFSET    0
+#define    RTL8367C_CHIP_RST_MASK    0x1
+
+#define    RTL8367C_REG_DIGITAL_DEBUG_0    0x1323
+
+#define    RTL8367C_REG_DIGITAL_DEBUG_1    0x1324
+
+#define    RTL8367C_REG_INTERNAL_PHY_MDC_DRIVER    0x1325
+#define    RTL8367C_INTERNAL_PHY_MDC_DRIVER_OFFSET    0
+#define    RTL8367C_INTERNAL_PHY_MDC_DRIVER_MASK    0x3FF
+
+#define    RTL8367C_REG_LINKDOWN_TIME_CTRL    0x1326
+#define    RTL8367C_LINKDOWN_TIME_CFG_OFFSET    9
+#define    RTL8367C_LINKDOWN_TIME_CFG_MASK    0x7E00
+#define    RTL8367C_LINKDOWN_TIME_ENABLE_OFFSET    8
+#define    RTL8367C_LINKDOWN_TIME_ENABLE_MASK    0x100
+#define    RTL8367C_LINKDOWN_TIME_OFFSET    0
+#define    RTL8367C_LINKDOWN_TIME_MASK    0xFF
+
+#define    RTL8367C_REG_PHYACK_TIMEOUT    0x1331
+
+#define    RTL8367C_REG_MDXACK_TIMEOUT    0x1333
+
+#define    RTL8367C_REG_DW8051_RDY    0x1336
+#define    RTL8367C_VIAROM_WRITE_EN_OFFSET    9
+#define    RTL8367C_VIAROM_WRITE_EN_MASK    0x200
+#define    RTL8367C_SPIF_CK2_OFFSET    8
+#define    RTL8367C_SPIF_CK2_MASK    0x100
+#define    RTL8367C_RRCP_MDOE_OFFSET    7
+#define    RTL8367C_RRCP_MDOE_MASK    0x80
+#define    RTL8367C_DW8051_RATE_OFFSET    4
+#define    RTL8367C_DW8051_RATE_MASK    0x70
+#define    RTL8367C_IROM_MSB_OFFSET    2
+#define    RTL8367C_IROM_MSB_MASK    0xC
+#define    RTL8367C_ACS_IROM_ENABLE_OFFSET    1
+#define    RTL8367C_ACS_IROM_ENABLE_MASK    0x2
+#define    RTL8367C_DW8051_READY_OFFSET    0
+#define    RTL8367C_DW8051_READY_MASK    0x1
+
+#define    RTL8367C_REG_BIST_CTRL    0x133c
+#define    RTL8367C_DRF_BIST_DONE_ALL_OFFSET    5
+#define    RTL8367C_DRF_BIST_DONE_ALL_MASK    0x20
+#define    RTL8367C_DRF_BIST_PAUSE_ALL_OFFSET    4
+#define    RTL8367C_DRF_BIST_PAUSE_ALL_MASK    0x10
+#define    RTL8367C_BIST_DOAN_ALL_OFFSET    3
+#define    RTL8367C_BIST_DOAN_ALL_MASK    0x8
+#define    RTL8367C_BIST_PASS_OFFSET    0
+#define    RTL8367C_BIST_PASS_MASK    0x7
+
+#define    RTL8367C_REG_DIAG_MODE2    0x133d
+#define    RTL8367C_DIAG_MODE2_ACTRAM_OFFSET    1
+#define    RTL8367C_DIAG_MODE2_ACTRAM_MASK    0x2
+#define    RTL8367C_DIAG_MODE2_BCAM_ACTION_OFFSET    0
+#define    RTL8367C_DIAG_MODE2_BCAM_ACTION_MASK    0x1
+
+#define    RTL8367C_REG_MDX_PHY_REG0    0x133e
+#define    RTL8367C_PHY_BRD_MASK_OFFSET    4
+#define    RTL8367C_PHY_BRD_MASK_MASK    0x1F0
+#define    RTL8367C_MDX_INDACC_PAGE_OFFSET    0
+#define    RTL8367C_MDX_INDACC_PAGE_MASK    0xF
+
+#define    RTL8367C_REG_MDX_PHY_REG1    0x133f
+#define    RTL8367C_PHY_BRD_MODE_OFFSET    5
+#define    RTL8367C_PHY_BRD_MODE_MASK    0x20
+#define    RTL8367C_BRD_PHYAD_OFFSET    0
+#define    RTL8367C_BRD_PHYAD_MASK    0x1F
+
+#define    RTL8367C_REG_DEBUG_SIGNAL_SELECT_SW    0x1340
+
+#define    RTL8367C_REG_DEBUG_SIGNAL_SELECT_B    0x1341
+#define    RTL8367C_DEBUG_MX_OFFSET    9
+#define    RTL8367C_DEBUG_MX_MASK    0xE00
+#define    RTL8367C_DEBUG_SHIFT_MISC_OFFSET    6
+#define    RTL8367C_DEBUG_SHIFT_MISC_MASK    0x1C0
+#define    RTL8367C_DEBUG_SHIFT_SW_OFFSET    3
+#define    RTL8367C_DEBUG_SHIFT_SW_MASK    0x38
+#define    RTL8367C_DEBUG_SHIFT_GPHY_OFFSET    0
+#define    RTL8367C_DEBUG_SHIFT_GPHY_MASK    0x7
+
+#define    RTL8367C_REG_DEBUG_SIGNAL_I    0x1343
+
+#define    RTL8367C_REG_DEBUG_SIGNAL_H    0x1344
+
+#define    RTL8367C_REG_DBGO_SEL_GPHY    0x1345
+
+#define    RTL8367C_REG_DBGO_SEL_MISC    0x1346
+
+#define    RTL8367C_REG_BYPASS_ABLTY_LOCK    0x1349
+#define    RTL8367C_BYPASS_ABLTY_LOCK_OFFSET    0
+#define    RTL8367C_BYPASS_ABLTY_LOCK_MASK    0xFF
+
+#define    RTL8367C_REG_BYPASS_ABLTY_LOCK_EXT    0x134a
+#define    RTL8367C_BYPASS_P10_ABILIITY_LOCK_OFFSET    3
+#define    RTL8367C_BYPASS_P10_ABILIITY_LOCK_MASK    0x8
+#define    RTL8367C_BYPASS_EXT_ABILITY_LOCK_OFFSET    0
+#define    RTL8367C_BYPASS_EXT_ABILITY_LOCK_MASK    0x7
+
+#define    RTL8367C_REG_ACL_GPIO    0x134f
+#define    RTL8367C_ACL_GPIO_13_OFFSET    13
+#define    RTL8367C_ACL_GPIO_13_MASK    0x2000
+#define    RTL8367C_ACL_GPIO_12_OFFSET    12
+#define    RTL8367C_ACL_GPIO_12_MASK    0x1000
+#define    RTL8367C_ACL_GPIO_11_OFFSET    11
+#define    RTL8367C_ACL_GPIO_11_MASK    0x800
+#define    RTL8367C_ACL_GPIO_10_OFFSET    10
+#define    RTL8367C_ACL_GPIO_10_MASK    0x400
+#define    RTL8367C_ACL_GPIO_9_OFFSET    9
+#define    RTL8367C_ACL_GPIO_9_MASK    0x200
+#define    RTL8367C_ACL_GPIO_8_OFFSET    8
+#define    RTL8367C_ACL_GPIO_8_MASK    0x100
+#define    RTL8367C_ACL_GPIO_7_OFFSET    7
+#define    RTL8367C_ACL_GPIO_7_MASK    0x80
+#define    RTL8367C_ACL_GPIO_6_OFFSET    6
+#define    RTL8367C_ACL_GPIO_6_MASK    0x40
+#define    RTL8367C_ACL_GPIO_5_OFFSET    5
+#define    RTL8367C_ACL_GPIO_5_MASK    0x20
+#define    RTL8367C_ACL_GPIO_4_OFFSET    4
+#define    RTL8367C_ACL_GPIO_4_MASK    0x10
+#define    RTL8367C_ACL_GPIO_3_OFFSET    3
+#define    RTL8367C_ACL_GPIO_3_MASK    0x8
+#define    RTL8367C_ACL_GPIO_2_OFFSET    2
+#define    RTL8367C_ACL_GPIO_2_MASK    0x4
+#define    RTL8367C_ACL_GPIO_1_OFFSET    1
+#define    RTL8367C_ACL_GPIO_1_MASK    0x2
+#define    RTL8367C_ACL_GPIO_0_OFFSET    0
+#define    RTL8367C_ACL_GPIO_0_MASK    0x1
+
+#define    RTL8367C_REG_EN_GPIO    0x1350
+#define    RTL8367C_EN_GPIO_13_OFFSET    13
+#define    RTL8367C_EN_GPIO_13_MASK    0x2000
+#define    RTL8367C_EN_GPIO_12_OFFSET    12
+#define    RTL8367C_EN_GPIO_12_MASK    0x1000
+#define    RTL8367C_EN_GPIO_11_OFFSET    11
+#define    RTL8367C_EN_GPIO_11_MASK    0x800
+#define    RTL8367C_EN_GPIO_10_OFFSET    10
+#define    RTL8367C_EN_GPIO_10_MASK    0x400
+#define    RTL8367C_EN_GPIO_9_OFFSET    9
+#define    RTL8367C_EN_GPIO_9_MASK    0x200
+#define    RTL8367C_EN_GPIO_8_OFFSET    8
+#define    RTL8367C_EN_GPIO_8_MASK    0x100
+#define    RTL8367C_EN_GPIO_7_OFFSET    7
+#define    RTL8367C_EN_GPIO_7_MASK    0x80
+#define    RTL8367C_EN_GPIO_6_OFFSET    6
+#define    RTL8367C_EN_GPIO_6_MASK    0x40
+#define    RTL8367C_EN_GPIO_5_OFFSET    5
+#define    RTL8367C_EN_GPIO_5_MASK    0x20
+#define    RTL8367C_EN_GPIO_4_OFFSET    4
+#define    RTL8367C_EN_GPIO_4_MASK    0x10
+#define    RTL8367C_EN_GPIO_3_OFFSET    3
+#define    RTL8367C_EN_GPIO_3_MASK    0x8
+#define    RTL8367C_EN_GPIO_2_OFFSET    2
+#define    RTL8367C_EN_GPIO_2_MASK    0x4
+#define    RTL8367C_EN_GPIO_1_OFFSET    1
+#define    RTL8367C_EN_GPIO_1_MASK    0x2
+#define    RTL8367C_EN_GPIO_0_OFFSET    0
+#define    RTL8367C_EN_GPIO_0_MASK    0x1
+
+#define    RTL8367C_REG_CFG_MULTI_PIN    0x1351
+#define    RTL8367C_CFG_MULTI_PIN_OFFSET    0
+#define    RTL8367C_CFG_MULTI_PIN_MASK    0x3
+
+#define    RTL8367C_REG_PORT0_STATUS    0x1352
+#define    RTL8367C_PORT0_STATUS_EN_1000_LPI_OFFSET    11
+#define    RTL8367C_PORT0_STATUS_EN_1000_LPI_MASK    0x800
+#define    RTL8367C_PORT0_STATUS_EN_100_LPI_OFFSET    10
+#define    RTL8367C_PORT0_STATUS_EN_100_LPI_MASK    0x400
+#define    RTL8367C_PORT0_STATUS_NWAY_FAULT_OFFSET    9
+#define    RTL8367C_PORT0_STATUS_NWAY_FAULT_MASK    0x200
+#define    RTL8367C_PORT0_STATUS_LINK_ON_MASTER_OFFSET    8
+#define    RTL8367C_PORT0_STATUS_LINK_ON_MASTER_MASK    0x100
+#define    RTL8367C_PORT0_STATUS_NWAY_CAP_OFFSET    7
+#define    RTL8367C_PORT0_STATUS_NWAY_CAP_MASK    0x80
+#define    RTL8367C_PORT0_STATUS_TX_FLOWCTRL_CAP_OFFSET    6
+#define    RTL8367C_PORT0_STATUS_TX_FLOWCTRL_CAP_MASK    0x40
+#define    RTL8367C_PORT0_STATUS_RX_FLOWCTRL_CAP_OFFSET    5
+#define    RTL8367C_PORT0_STATUS_RX_FLOWCTRL_CAP_MASK    0x20
+#define    RTL8367C_PORT0_STATUS_LINK_STATE_OFFSET    4
+#define    RTL8367C_PORT0_STATUS_LINK_STATE_MASK    0x10
+#define    RTL8367C_PORT0_STATUS_FULL_DUPLUX_CAP_OFFSET    2
+#define    RTL8367C_PORT0_STATUS_FULL_DUPLUX_CAP_MASK    0x4
+#define    RTL8367C_PORT0_STATUS_LINK_SPEED_OFFSET    0
+#define    RTL8367C_PORT0_STATUS_LINK_SPEED_MASK    0x3
+
+#define    RTL8367C_REG_PORT1_STATUS    0x1353
+#define    RTL8367C_PORT1_STATUS_EN_1000_LPI_OFFSET    11
+#define    RTL8367C_PORT1_STATUS_EN_1000_LPI_MASK    0x800
+#define    RTL8367C_PORT1_STATUS_EN_100_LPI_OFFSET    10
+#define    RTL8367C_PORT1_STATUS_EN_100_LPI_MASK    0x400
+#define    RTL8367C_PORT1_STATUS_NWAY_FAULT_OFFSET    9
+#define    RTL8367C_PORT1_STATUS_NWAY_FAULT_MASK    0x200
+#define    RTL8367C_PORT1_STATUS_LINK_ON_MASTER_OFFSET    8
+#define    RTL8367C_PORT1_STATUS_LINK_ON_MASTER_MASK    0x100
+#define    RTL8367C_PORT1_STATUS_NWAY_CAP_OFFSET    7
+#define    RTL8367C_PORT1_STATUS_NWAY_CAP_MASK    0x80
+#define    RTL8367C_PORT1_STATUS_TX_FLOWCTRL_CAP_OFFSET    6
+#define    RTL8367C_PORT1_STATUS_TX_FLOWCTRL_CAP_MASK    0x40
+#define    RTL8367C_PORT1_STATUS_RX_FLOWCTRL_CAP_OFFSET    5
+#define    RTL8367C_PORT1_STATUS_RX_FLOWCTRL_CAP_MASK    0x20
+#define    RTL8367C_PORT1_STATUS_LINK_STATE_OFFSET    4
+#define    RTL8367C_PORT1_STATUS_LINK_STATE_MASK    0x10
+#define    RTL8367C_PORT1_STATUS_FULL_DUPLUX_CAP_OFFSET    2
+#define    RTL8367C_PORT1_STATUS_FULL_DUPLUX_CAP_MASK    0x4
+#define    RTL8367C_PORT1_STATUS_LINK_SPEED_OFFSET    0
+#define    RTL8367C_PORT1_STATUS_LINK_SPEED_MASK    0x3
+
+#define    RTL8367C_REG_PORT2_STATUS    0x1354
+#define    RTL8367C_PORT2_STATUS_EN_1000_LPI_OFFSET    11
+#define    RTL8367C_PORT2_STATUS_EN_1000_LPI_MASK    0x800
+#define    RTL8367C_PORT2_STATUS_EN_100_LPI_OFFSET    10
+#define    RTL8367C_PORT2_STATUS_EN_100_LPI_MASK    0x400
+#define    RTL8367C_PORT2_STATUS_NWAY_FAULT_OFFSET    9
+#define    RTL8367C_PORT2_STATUS_NWAY_FAULT_MASK    0x200
+#define    RTL8367C_PORT2_STATUS_LINK_ON_MASTER_OFFSET    8
+#define    RTL8367C_PORT2_STATUS_LINK_ON_MASTER_MASK    0x100
+#define    RTL8367C_PORT2_STATUS_NWAY_CAP_OFFSET    7
+#define    RTL8367C_PORT2_STATUS_NWAY_CAP_MASK    0x80
+#define    RTL8367C_PORT2_STATUS_TX_FLOWCTRL_CAP_OFFSET    6
+#define    RTL8367C_PORT2_STATUS_TX_FLOWCTRL_CAP_MASK    0x40
+#define    RTL8367C_PORT2_STATUS_RX_FLOWCTRL_CAP_OFFSET    5
+#define    RTL8367C_PORT2_STATUS_RX_FLOWCTRL_CAP_MASK    0x20
+#define    RTL8367C_PORT2_STATUS_LINK_STATE_OFFSET    4
+#define    RTL8367C_PORT2_STATUS_LINK_STATE_MASK    0x10
+#define    RTL8367C_PORT2_STATUS_FULL_DUPLUX_CAP_OFFSET    2
+#define    RTL8367C_PORT2_STATUS_FULL_DUPLUX_CAP_MASK    0x4
+#define    RTL8367C_PORT2_STATUS_LINK_SPEED_OFFSET    0
+#define    RTL8367C_PORT2_STATUS_LINK_SPEED_MASK    0x3
+
+#define    RTL8367C_REG_PORT3_STATUS    0x1355
+#define    RTL8367C_PORT3_STATUS_EN_1000_LPI_OFFSET    11
+#define    RTL8367C_PORT3_STATUS_EN_1000_LPI_MASK    0x800
+#define    RTL8367C_PORT3_STATUS_EN_100_LPI_OFFSET    10
+#define    RTL8367C_PORT3_STATUS_EN_100_LPI_MASK    0x400
+#define    RTL8367C_PORT3_STATUS_NWAY_FAULT_OFFSET    9
+#define    RTL8367C_PORT3_STATUS_NWAY_FAULT_MASK    0x200
+#define    RTL8367C_PORT3_STATUS_LINK_ON_MASTER_OFFSET    8
+#define    RTL8367C_PORT3_STATUS_LINK_ON_MASTER_MASK    0x100
+#define    RTL8367C_PORT3_STATUS_NWAY_CAP_OFFSET    7
+#define    RTL8367C_PORT3_STATUS_NWAY_CAP_MASK    0x80
+#define    RTL8367C_PORT3_STATUS_TX_FLOWCTRL_CAP_OFFSET    6
+#define    RTL8367C_PORT3_STATUS_TX_FLOWCTRL_CAP_MASK    0x40
+#define    RTL8367C_PORT3_STATUS_RX_FLOWCTRL_CAP_OFFSET    5
+#define    RTL8367C_PORT3_STATUS_RX_FLOWCTRL_CAP_MASK    0x20
+#define    RTL8367C_PORT3_STATUS_LINK_STATE_OFFSET    4
+#define    RTL8367C_PORT3_STATUS_LINK_STATE_MASK    0x10
+#define    RTL8367C_PORT3_STATUS_FULL_DUPLUX_CAP_OFFSET    2
+#define    RTL8367C_PORT3_STATUS_FULL_DUPLUX_CAP_MASK    0x4
+#define    RTL8367C_PORT3_STATUS_LINK_SPEED_OFFSET    0
+#define    RTL8367C_PORT3_STATUS_LINK_SPEED_MASK    0x3
+
+#define    RTL8367C_REG_PORT4_STATUS    0x1356
+#define    RTL8367C_PORT4_STATUS_EN_1000_LPI_OFFSET    11
+#define    RTL8367C_PORT4_STATUS_EN_1000_LPI_MASK    0x800
+#define    RTL8367C_PORT4_STATUS_EN_100_LPI_OFFSET    10
+#define    RTL8367C_PORT4_STATUS_EN_100_LPI_MASK    0x400
+#define    RTL8367C_PORT4_STATUS_NWAY_FAULT_OFFSET    9
+#define    RTL8367C_PORT4_STATUS_NWAY_FAULT_MASK    0x200
+#define    RTL8367C_PORT4_STATUS_LINK_ON_MASTER_OFFSET    8
+#define    RTL8367C_PORT4_STATUS_LINK_ON_MASTER_MASK    0x100
+#define    RTL8367C_PORT4_STATUS_NWAY_CAP_OFFSET    7
+#define    RTL8367C_PORT4_STATUS_NWAY_CAP_MASK    0x80
+#define    RTL8367C_PORT4_STATUS_TX_FLOWCTRL_CAP_OFFSET    6
+#define    RTL8367C_PORT4_STATUS_TX_FLOWCTRL_CAP_MASK    0x40
+#define    RTL8367C_PORT4_STATUS_RX_FLOWCTRL_CAP_OFFSET    5
+#define    RTL8367C_PORT4_STATUS_RX_FLOWCTRL_CAP_MASK    0x20
+#define    RTL8367C_PORT4_STATUS_LINK_STATE_OFFSET    4
+#define    RTL8367C_PORT4_STATUS_LINK_STATE_MASK    0x10
+#define    RTL8367C_PORT4_STATUS_FULL_DUPLUX_CAP_OFFSET    2
+#define    RTL8367C_PORT4_STATUS_FULL_DUPLUX_CAP_MASK    0x4
+#define    RTL8367C_PORT4_STATUS_LINK_SPEED_OFFSET    0
+#define    RTL8367C_PORT4_STATUS_LINK_SPEED_MASK    0x3
+
+#define    RTL8367C_REG_PORT5_STATUS    0x1357
+#define    RTL8367C_PORT5_STATUS_EN_1000_LPI_OFFSET    11
+#define    RTL8367C_PORT5_STATUS_EN_1000_LPI_MASK    0x800
+#define    RTL8367C_PORT5_STATUS_EN_100_LPI_OFFSET    10
+#define    RTL8367C_PORT5_STATUS_EN_100_LPI_MASK    0x400
+#define    RTL8367C_PORT5_STATUS_NWAY_FAULT_OFFSET    9
+#define    RTL8367C_PORT5_STATUS_NWAY_FAULT_MASK    0x200
+#define    RTL8367C_PORT5_STATUS_LINK_ON_MASTER_OFFSET    8
+#define    RTL8367C_PORT5_STATUS_LINK_ON_MASTER_MASK    0x100
+#define    RTL8367C_PORT5_STATUS_NWAY_CAP_OFFSET    7
+#define    RTL8367C_PORT5_STATUS_NWAY_CAP_MASK    0x80
+#define    RTL8367C_PORT5_STATUS_TX_FLOWCTRL_CAP_OFFSET    6
+#define    RTL8367C_PORT5_STATUS_TX_FLOWCTRL_CAP_MASK    0x40
+#define    RTL8367C_PORT5_STATUS_RX_FLOWCTRL_CAP_OFFSET    5
+#define    RTL8367C_PORT5_STATUS_RX_FLOWCTRL_CAP_MASK    0x20
+#define    RTL8367C_PORT5_STATUS_LINK_STATE_OFFSET    4
+#define    RTL8367C_PORT5_STATUS_LINK_STATE_MASK    0x10
+#define    RTL8367C_PORT5_STATUS_FULL_DUPLUX_CAP_OFFSET    2
+#define    RTL8367C_PORT5_STATUS_FULL_DUPLUX_CAP_MASK    0x4
+#define    RTL8367C_PORT5_STATUS_LINK_SPEED_OFFSET    0
+#define    RTL8367C_PORT5_STATUS_LINK_SPEED_MASK    0x3
+
+#define    RTL8367C_REG_PORT6_STATUS    0x1358
+#define    RTL8367C_PORT6_STATUS_EN_1000_LPI_OFFSET    11
+#define    RTL8367C_PORT6_STATUS_EN_1000_LPI_MASK    0x800
+#define    RTL8367C_PORT6_STATUS_EN_100_LPI_OFFSET    10
+#define    RTL8367C_PORT6_STATUS_EN_100_LPI_MASK    0x400
+#define    RTL8367C_PORT6_STATUS_NWAY_FAULT_OFFSET    9
+#define    RTL8367C_PORT6_STATUS_NWAY_FAULT_MASK    0x200
+#define    RTL8367C_PORT6_STATUS_LINK_ON_MASTER_OFFSET    8
+#define    RTL8367C_PORT6_STATUS_LINK_ON_MASTER_MASK    0x100
+#define    RTL8367C_PORT6_STATUS_NWAY_CAP_OFFSET    7
+#define    RTL8367C_PORT6_STATUS_NWAY_CAP_MASK    0x80
+#define    RTL8367C_PORT6_STATUS_TX_FLOWCTRL_CAP_OFFSET    6
+#define    RTL8367C_PORT6_STATUS_TX_FLOWCTRL_CAP_MASK    0x40
+#define    RTL8367C_PORT6_STATUS_RX_FLOWCTRL_CAP_OFFSET    5
+#define    RTL8367C_PORT6_STATUS_RX_FLOWCTRL_CAP_MASK    0x20
+#define    RTL8367C_PORT6_STATUS_LINK_STATE_OFFSET    4
+#define    RTL8367C_PORT6_STATUS_LINK_STATE_MASK    0x10
+#define    RTL8367C_PORT6_STATUS_FULL_DUPLUX_CAP_OFFSET    2
+#define    RTL8367C_PORT6_STATUS_FULL_DUPLUX_CAP_MASK    0x4
+#define    RTL8367C_PORT6_STATUS_LINK_SPEED_OFFSET    0
+#define    RTL8367C_PORT6_STATUS_LINK_SPEED_MASK    0x3
+
+#define    RTL8367C_REG_PORT7_STATUS    0x1359
+#define    RTL8367C_PORT7_STATUS_EN_1000_LPI_OFFSET    11
+#define    RTL8367C_PORT7_STATUS_EN_1000_LPI_MASK    0x800
+#define    RTL8367C_PORT7_STATUS_EN_100_LPI_OFFSET    10
+#define    RTL8367C_PORT7_STATUS_EN_100_LPI_MASK    0x400
+#define    RTL8367C_PORT7_STATUS_NWAY_FAULT_OFFSET    9
+#define    RTL8367C_PORT7_STATUS_NWAY_FAULT_MASK    0x200
+#define    RTL8367C_PORT7_STATUS_LINK_ON_MASTER_OFFSET    8
+#define    RTL8367C_PORT7_STATUS_LINK_ON_MASTER_MASK    0x100
+#define    RTL8367C_PORT7_STATUS_NWAY_CAP_OFFSET    7
+#define    RTL8367C_PORT7_STATUS_NWAY_CAP_MASK    0x80
+#define    RTL8367C_PORT7_STATUS_TX_FLOWCTRL_CAP_OFFSET    6
+#define    RTL8367C_PORT7_STATUS_TX_FLOWCTRL_CAP_MASK    0x40
+#define    RTL8367C_PORT7_STATUS_RX_FLOWCTRL_CAP_OFFSET    5
+#define    RTL8367C_PORT7_STATUS_RX_FLOWCTRL_CAP_MASK    0x20
+#define    RTL8367C_PORT7_STATUS_LINK_STATE_OFFSET    4
+#define    RTL8367C_PORT7_STATUS_LINK_STATE_MASK    0x10
+#define    RTL8367C_PORT7_STATUS_FULL_DUPLUX_CAP_OFFSET    2
+#define    RTL8367C_PORT7_STATUS_FULL_DUPLUX_CAP_MASK    0x4
+#define    RTL8367C_PORT7_STATUS_LINK_SPEED_OFFSET    0
+#define    RTL8367C_PORT7_STATUS_LINK_SPEED_MASK    0x3
+
+#define    RTL8367C_REG_PORT8_STATUS    0x135a
+#define    RTL8367C_PORT8_STATUS_EN_1000_LPI_OFFSET    11
+#define    RTL8367C_PORT8_STATUS_EN_1000_LPI_MASK    0x800
+#define    RTL8367C_PORT8_STATUS_EN_100_LPI_OFFSET    10
+#define    RTL8367C_PORT8_STATUS_EN_100_LPI_MASK    0x400
+#define    RTL8367C_PORT8_STATUS_NWAY_FAULT_OFFSET    9
+#define    RTL8367C_PORT8_STATUS_NWAY_FAULT_MASK    0x200
+#define    RTL8367C_PORT8_STATUS_LINK_ON_MASTER_OFFSET    8
+#define    RTL8367C_PORT8_STATUS_LINK_ON_MASTER_MASK    0x100
+#define    RTL8367C_PORT8_STATUS_NWAY_CAP_OFFSET    7
+#define    RTL8367C_PORT8_STATUS_NWAY_CAP_MASK    0x80
+#define    RTL8367C_PORT8_STATUS_TX_FLOWCTRL_CAP_OFFSET    6
+#define    RTL8367C_PORT8_STATUS_TX_FLOWCTRL_CAP_MASK    0x40
+#define    RTL8367C_PORT8_STATUS_RX_FLOWCTRL_CAP_OFFSET    5
+#define    RTL8367C_PORT8_STATUS_RX_FLOWCTRL_CAP_MASK    0x20
+#define    RTL8367C_PORT8_STATUS_LINK_STATE_OFFSET    4
+#define    RTL8367C_PORT8_STATUS_LINK_STATE_MASK    0x10
+#define    RTL8367C_PORT8_STATUS_FULL_DUPLUX_CAP_OFFSET    2
+#define    RTL8367C_PORT8_STATUS_FULL_DUPLUX_CAP_MASK    0x4
+#define    RTL8367C_PORT8_STATUS_LINK_SPEED_OFFSET    0
+#define    RTL8367C_PORT8_STATUS_LINK_SPEED_MASK    0x3
+
+#define    RTL8367C_REG_PORT9_STATUS    0x135b
+#define    RTL8367C_PORT9_STATUS_EN_1000_LPI_OFFSET    11
+#define    RTL8367C_PORT9_STATUS_EN_1000_LPI_MASK    0x800
+#define    RTL8367C_PORT9_STATUS_EN_100_LPI_OFFSET    10
+#define    RTL8367C_PORT9_STATUS_EN_100_LPI_MASK    0x400
+#define    RTL8367C_PORT9_STATUS_NWAY_FAULT_OFFSET    9
+#define    RTL8367C_PORT9_STATUS_NWAY_FAULT_MASK    0x200
+#define    RTL8367C_PORT9_STATUS_LINK_ON_MASTER_OFFSET    8
+#define    RTL8367C_PORT9_STATUS_LINK_ON_MASTER_MASK    0x100
+#define    RTL8367C_PORT9_STATUS_NWAY_CAP_OFFSET    7
+#define    RTL8367C_PORT9_STATUS_NWAY_CAP_MASK    0x80
+#define    RTL8367C_PORT9_STATUS_TX_FLOWCTRL_CAP_OFFSET    6
+#define    RTL8367C_PORT9_STATUS_TX_FLOWCTRL_CAP_MASK    0x40
+#define    RTL8367C_PORT9_STATUS_RX_FLOWCTRL_CAP_OFFSET    5
+#define    RTL8367C_PORT9_STATUS_RX_FLOWCTRL_CAP_MASK    0x20
+#define    RTL8367C_PORT9_STATUS_LINK_STATE_OFFSET    4
+#define    RTL8367C_PORT9_STATUS_LINK_STATE_MASK    0x10
+#define    RTL8367C_PORT9_STATUS_FULL_DUPLUX_CAP_OFFSET    2
+#define    RTL8367C_PORT9_STATUS_FULL_DUPLUX_CAP_MASK    0x4
+#define    RTL8367C_PORT9_STATUS_LINK_SPEED_OFFSET    0
+#define    RTL8367C_PORT9_STATUS_LINK_SPEED_MASK    0x3
+
+#define    RTL8367C_REG_PORT10_STATUS    0x135c
+#define    RTL8367C_PORT10_STATUS_EN_1000_LPI_OFFSET    11
+#define    RTL8367C_PORT10_STATUS_EN_1000_LPI_MASK    0x800
+#define    RTL8367C_PORT10_STATUS_EN_100_LPI_OFFSET    10
+#define    RTL8367C_PORT10_STATUS_EN_100_LPI_MASK    0x400
+#define    RTL8367C_PORT10_STATUS_NWAY_FAULT_OFFSET    9
+#define    RTL8367C_PORT10_STATUS_NWAY_FAULT_MASK    0x200
+#define    RTL8367C_PORT10_STATUS_LINK_ON_MASTER_OFFSET    8
+#define    RTL8367C_PORT10_STATUS_LINK_ON_MASTER_MASK    0x100
+#define    RTL8367C_PORT10_STATUS_NWAY_CAP_OFFSET    7
+#define    RTL8367C_PORT10_STATUS_NWAY_CAP_MASK    0x80
+#define    RTL8367C_PORT10_STATUS_TX_FLOWCTRL_CAP_OFFSET    6
+#define    RTL8367C_PORT10_STATUS_TX_FLOWCTRL_CAP_MASK    0x40
+#define    RTL8367C_PORT10_STATUS_RX_FLOWCTRL_CAP_OFFSET    5
+#define    RTL8367C_PORT10_STATUS_RX_FLOWCTRL_CAP_MASK    0x20
+#define    RTL8367C_PORT10_STATUS_LINK_STATE_OFFSET    4
+#define    RTL8367C_PORT10_STATUS_LINK_STATE_MASK    0x10
+#define    RTL8367C_PORT10_STATUS_FULL_DUPLUX_CAP_OFFSET    2
+#define    RTL8367C_PORT10_STATUS_FULL_DUPLUX_CAP_MASK    0x4
+#define    RTL8367C_PORT10_STATUS_LINK_SPEED_OFFSET    0
+#define    RTL8367C_PORT10_STATUS_LINK_SPEED_MASK    0x3
+
+#define    RTL8367C_REG_UPS_CTRL0    0x1362
+#define    RTL8367C_P3_REF_SD_BIT0_OFFSET    8
+#define    RTL8367C_P3_REF_SD_BIT0_MASK    0xFF00
+#define    RTL8367C_P2_REF_SD_OFFSET    0
+#define    RTL8367C_P2_REF_SD_MASK    0xFF
+
+#define    RTL8367C_REG_UPS_CTRL1    0x1363
+#define    RTL8367C_UPS_OUT_OFFSET    8
+#define    RTL8367C_UPS_OUT_MASK    0xFF00
+#define    RTL8367C_UPS_WRITE_PULSE_OFFSET    1
+#define    RTL8367C_UPS_WRITE_PULSE_MASK    0x2
+#define    RTL8367C_UPS_EN_OFFSET    0
+#define    RTL8367C_UPS_EN_MASK    0x1
+
+#define    RTL8367C_REG_UPS_CTRL2    0x1364
+#define    RTL8367C_IGNOE_MAC8_LINK_OFFSET    15
+#define    RTL8367C_IGNOE_MAC8_LINK_MASK    0x8000
+#define    RTL8367C_AGREE_SLEEP_OFFSET    14
+#define    RTL8367C_AGREE_SLEEP_MASK    0x4000
+#define    RTL8367C_WAIT_FOR_AGREEMENT_OFFSET    13
+#define    RTL8367C_WAIT_FOR_AGREEMENT_MASK    0x2000
+#define    RTL8367C_WAKE_UP_BY_LINK_OFFSET    12
+#define    RTL8367C_WAKE_UP_BY_LINK_MASK    0x1000
+#define    RTL8367C_WAKE_UP_BY_PHY_OFFSET    11
+#define    RTL8367C_WAKE_UP_BY_PHY_MASK    0x800
+#define    RTL8367C_SLOW_CLK_TGL_RATE_OFFSET    7
+#define    RTL8367C_SLOW_CLK_TGL_RATE_MASK    0x780
+#define    RTL8367C_PLL_G1_CTRL_EN_OFFSET    6
+#define    RTL8367C_PLL_G1_CTRL_EN_MASK    0x40
+#define    RTL8367C_PLL_G0_CTRL_EN_OFFSET    5
+#define    RTL8367C_PLL_G0_CTRL_EN_MASK    0x20
+#define    RTL8367C_SLOW_DOWN_PLL_EN_OFFSET    4
+#define    RTL8367C_SLOW_DOWN_PLL_EN_MASK    0x10
+#define    RTL8367C_SLOW_DOWN_CLK_EN_OFFSET    3
+#define    RTL8367C_SLOW_DOWN_CLK_EN_MASK    0x8
+#define    RTL8367C_GATING_CLK_SDS_EN_OFFSET    2
+#define    RTL8367C_GATING_CLK_SDS_EN_MASK    0x4
+#define    RTL8367C_GATING_CLK_CHIP_EN_OFFSET    1
+#define    RTL8367C_GATING_CLK_CHIP_EN_MASK    0x2
+#define    RTL8367C_GATING_SW_EN_OFFSET    0
+#define    RTL8367C_GATING_SW_EN_MASK    0x1
+
+#define    RTL8367C_REG_GATING_CLK_1    0x1365
+#define    RTL8367C_ALDPS_MODE_4_OFFSET    15
+#define    RTL8367C_ALDPS_MODE_4_MASK    0x8000
+#define    RTL8367C_ALDPS_MODE_3_OFFSET    14
+#define    RTL8367C_ALDPS_MODE_3_MASK    0x4000
+#define    RTL8367C_ALDPS_MODE_2_OFFSET    13
+#define    RTL8367C_ALDPS_MODE_2_MASK    0x2000
+#define    RTL8367C_ALDPS_MODE_1_OFFSET    12
+#define    RTL8367C_ALDPS_MODE_1_MASK    0x1000
+#define    RTL8367C_ALDPS_MODE_0_OFFSET    11
+#define    RTL8367C_ALDPS_MODE_0_MASK    0x800
+#define    RTL8367C_UPS_DBGO_OFFSET    10
+#define    RTL8367C_UPS_DBGO_MASK    0x400
+#define    RTL8367C_IFMX_AFF_NOT_FF_OUT_OFFSET    9
+#define    RTL8367C_IFMX_AFF_NOT_FF_OUT_MASK    0x200
+#define    RTL8367C_WATER_LEVEL_FD_OFFSET    6
+#define    RTL8367C_WATER_LEVEL_FD_MASK    0x1C0
+#define    RTL8367C_WATER_LEVEL_Y2X_OFFSET    3
+#define    RTL8367C_WATER_LEVEL_Y2X_MASK    0x38
+#define    RTL8367C_WATER_LEVEL_X2Y_2_OFFSET    2
+#define    RTL8367C_WATER_LEVEL_X2Y_2_MASK    0x4
+#define    RTL8367C_IGNOE_MAC10_LINK_OFFSET    1
+#define    RTL8367C_IGNOE_MAC10_LINK_MASK    0x2
+#define    RTL8367C_IGNOE_MAC9_LINK_OFFSET    0
+#define    RTL8367C_IGNOE_MAC9_LINK_MASK    0x1
+
+#define    RTL8367C_REG_UPS_CTRL4    0x1366
+#define    RTL8367C_PROB_EN_OFFSET    6
+#define    RTL8367C_PROB_EN_MASK    0x40
+#define    RTL8367C_PLL_DOWN_OFFSET    1
+#define    RTL8367C_PLL_DOWN_MASK    0x2
+#define    RTL8367C_XTAL_DOWN_OFFSET    0
+#define    RTL8367C_XTAL_DOWN_MASK    0x1
+
+#define    RTL8367C_REG_UPS_CTRL5    0x1367
+#define    RTL8367C_FRC_CPU_ACPT_OFFSET    3
+#define    RTL8367C_FRC_CPU_ACPT_MASK    0x8
+#define    RTL8367C_UPS_CPU_ACPT_OFFSET    2
+#define    RTL8367C_UPS_CPU_ACPT_MASK    0x4
+#define    RTL8367C_UPS_DBG_4_OFFSET    0
+#define    RTL8367C_UPS_DBG_4_MASK    0x3
+
+#define    RTL8367C_REG_UPS_CTRL6    0x1368
+#define    RTL8367C_UPS_CTRL6_OFFSET    0
+#define    RTL8367C_UPS_CTRL6_MASK    0xF
+
+#define    RTL8367C_REG_EFUSE_CMD_70B    0x1369
+
+#define    RTL8367C_REG_EFUSE_CMD    0x1370
+#define    RTL8367C_EFUSE_TIME_OUT_FLAG_OFFSET    3
+#define    RTL8367C_EFUSE_TIME_OUT_FLAG_MASK    0x8
+#define    RTL8367C_EFUSE_ACCESS_BUSY_OFFSET    2
+#define    RTL8367C_EFUSE_ACCESS_BUSY_MASK    0x4
+#define    RTL8367C_EFUSE_COMMAND_EN_OFFSET    1
+#define    RTL8367C_EFUSE_COMMAND_EN_MASK    0x2
+#define    RTL8367C_EFUSE_WR_OFFSET    0
+#define    RTL8367C_EFUSE_WR_MASK    0x1
+
+#define    RTL8367C_REG_EFUSE_ADR    0x1371
+#define    RTL8367C_DUMMY_15_10_OFFSET    8
+#define    RTL8367C_DUMMY_15_10_MASK    0xFF00
+#define    RTL8367C_EFUSE_ADDRESS_OFFSET    0
+#define    RTL8367C_EFUSE_ADDRESS_MASK    0xFF
+
+#define    RTL8367C_REG_EFUSE_WDAT    0x1372
+
+#define    RTL8367C_REG_EFUSE_RDAT    0x1373
+
+#define    RTL8367C_REG_I2C_CTRL    0x1374
+#define    RTL8367C_MDX_MST_FAIL_LAT_OFFSET    1
+#define    RTL8367C_MDX_MST_FAIL_LAT_MASK    0x2
+#define    RTL8367C_MDX_MST_FAIL_CLRPS_OFFSET    0
+#define    RTL8367C_MDX_MST_FAIL_CLRPS_MASK    0x1
+
+#define    RTL8367C_REG_EEE_CFG    0x1375
+#define    RTL8367C_CFG_BYPASS_GATELPTD_OFFSET    11
+#define    RTL8367C_CFG_BYPASS_GATELPTD_MASK    0x800
+#define    RTL8367C_EEE_ABT_ADDR2_OFFSET    6
+#define    RTL8367C_EEE_ABT_ADDR2_MASK    0x7C0
+#define    RTL8367C_EEE_ABT_ADDR1_OFFSET    1
+#define    RTL8367C_EEE_ABT_ADDR1_MASK    0x3E
+#define    RTL8367C_EEE_POLL_EN_OFFSET    0
+#define    RTL8367C_EEE_POLL_EN_MASK    0x1
+
+#define    RTL8367C_REG_EEE_PAGE    0x1376
+
+#define    RTL8367C_REG_EEE_EXT_PAGE    0x1377
+
+#define    RTL8367C_REG_EEE_EN_SPD1000    0x1378
+
+#define    RTL8367C_REG_EEE_EN_SPD100    0x1379
+
+#define    RTL8367C_REG_EEE_LP_SPD1000    0x137a
+
+#define    RTL8367C_REG_EEE_LP_SPD100    0x137b
+
+#define    RTL8367C_REG_DW8051_PRO_REG0    0x13a0
+
+#define    RTL8367C_REG_DW8051_PRO_REG1    0x13a1
+
+#define    RTL8367C_REG_DW8051_PRO_REG2    0x13a2
+
+#define    RTL8367C_REG_DW8051_PRO_REG3    0x13a3
+
+#define    RTL8367C_REG_DW8051_PRO_REG4    0x13a4
+
+#define    RTL8367C_REG_DW8051_PRO_REG5    0x13a5
+
+#define    RTL8367C_REG_DW8051_PRO_REG6    0x13a6
+
+#define    RTL8367C_REG_DW8051_PRO_REG7    0x13a7
+
+#define    RTL8367C_REG_PROTECT_ID    0x13c0
+
+#define    RTL8367C_REG_CHIP_VER_INTL    0x13c1
+#define    RTL8367C_CHIP_VER_INTL_OFFSET    0
+#define    RTL8367C_CHIP_VER_INTL_MASK    0xF
+
+#define    RTL8367C_REG_MAGIC_ID    0x13c2
+
+#define    RTL8367C_REG_DIGITAL_INTERFACE_SELECT_1    0x13c3
+#define    RTL8367C_SKIP_MII_2_RXER_OFFSET    4
+#define    RTL8367C_SKIP_MII_2_RXER_MASK    0x10
+#define    RTL8367C_SELECT_GMII_2_OFFSET    0
+#define    RTL8367C_SELECT_GMII_2_MASK    0xF
+
+#define    RTL8367C_REG_DIGITAL_INTERFACE2_FORCE    0x13c4
+#define    RTL8367C_GMII_2_FORCE_OFFSET    12
+#define    RTL8367C_GMII_2_FORCE_MASK    0x1000
+#define    RTL8367C_RGMII_2_FORCE_OFFSET    0
+#define    RTL8367C_RGMII_2_FORCE_MASK    0xFFF
+
+#define    RTL8367C_REG_EXT2_RGMXF    0x13c5
+#define    RTL8367C_EXT2_RGTX_INV_OFFSET    6
+#define    RTL8367C_EXT2_RGTX_INV_MASK    0x40
+#define    RTL8367C_EXT2_RGRX_INV_OFFSET    5
+#define    RTL8367C_EXT2_RGRX_INV_MASK    0x20
+#define    RTL8367C_EXT2_RGMXF_OFFSET    0
+#define    RTL8367C_EXT2_RGMXF_MASK    0x1F
+
+#define    RTL8367C_REG_ROUTER_UPS_CFG    0x13c6
+#define    RTL8367C_UPS_Status_OFFSET    1
+#define    RTL8367C_UPS_Status_MASK    0x2
+#define    RTL8367C_SoftStart_OFFSET    0
+#define    RTL8367C_SoftStart_MASK    0x1
+
+#define    RTL8367C_REG_CTRL_GPIO    0x13c7
+#define    RTL8367C_CTRL_GPIO_13_OFFSET    13
+#define    RTL8367C_CTRL_GPIO_13_MASK    0x2000
+#define    RTL8367C_CTRL_GPIO_12_OFFSET    12
+#define    RTL8367C_CTRL_GPIO_12_MASK    0x1000
+#define    RTL8367C_CTRL_GPIO_11_OFFSET    11
+#define    RTL8367C_CTRL_GPIO_11_MASK    0x800
+#define    RTL8367C_CTRL_GPIO_10_OFFSET    10
+#define    RTL8367C_CTRL_GPIO_10_MASK    0x400
+#define    RTL8367C_CTRL_GPIO_9_OFFSET    9
+#define    RTL8367C_CTRL_GPIO_9_MASK    0x200
+#define    RTL8367C_CTRL_GPIO_8_OFFSET    8
+#define    RTL8367C_CTRL_GPIO_8_MASK    0x100
+#define    RTL8367C_CTRL_GPIO_7_OFFSET    7
+#define    RTL8367C_CTRL_GPIO_7_MASK    0x80
+#define    RTL8367C_CTRL_GPIO_6_OFFSET    6
+#define    RTL8367C_CTRL_GPIO_6_MASK    0x40
+#define    RTL8367C_CTRL_GPIO_5_OFFSET    5
+#define    RTL8367C_CTRL_GPIO_5_MASK    0x20
+#define    RTL8367C_CTRL_GPIO_4_OFFSET    4
+#define    RTL8367C_CTRL_GPIO_4_MASK    0x10
+#define    RTL8367C_CTRL_GPIO_3_OFFSET    3
+#define    RTL8367C_CTRL_GPIO_3_MASK    0x8
+#define    RTL8367C_CTRL_GPIO_2_OFFSET    2
+#define    RTL8367C_CTRL_GPIO_2_MASK    0x4
+#define    RTL8367C_CTRL_GPIO_1_OFFSET    1
+#define    RTL8367C_CTRL_GPIO_1_MASK    0x2
+#define    RTL8367C_CTRL_GPIO_0_OFFSET    0
+#define    RTL8367C_CTRL_GPIO_0_MASK    0x1
+
+#define    RTL8367C_REG_SEL_GPIO    0x13c8
+#define    RTL8367C_SEL_GPIO_13_OFFSET    13
+#define    RTL8367C_SEL_GPIO_13_MASK    0x2000
+#define    RTL8367C_SEL_GPIO_12_OFFSET    12
+#define    RTL8367C_SEL_GPIO_12_MASK    0x1000
+#define    RTL8367C_SEL_GPIO_11_OFFSET    11
+#define    RTL8367C_SEL_GPIO_11_MASK    0x800
+#define    RTL8367C_SEL_GPIO_10_OFFSET    10
+#define    RTL8367C_SEL_GPIO_10_MASK    0x400
+#define    RTL8367C_SEL_GPIO_9_OFFSET    9
+#define    RTL8367C_SEL_GPIO_9_MASK    0x200
+#define    RTL8367C_SEL_GPIO_8_OFFSET    8
+#define    RTL8367C_SEL_GPIO_8_MASK    0x100
+#define    RTL8367C_SEL_GPIO_7_OFFSET    7
+#define    RTL8367C_SEL_GPIO_7_MASK    0x80
+#define    RTL8367C_SEL_GPIO_6_OFFSET    6
+#define    RTL8367C_SEL_GPIO_6_MASK    0x40
+#define    RTL8367C_SEL_GPIO_5_OFFSET    5
+#define    RTL8367C_SEL_GPIO_5_MASK    0x20
+#define    RTL8367C_SEL_GPIO_4_OFFSET    4
+#define    RTL8367C_SEL_GPIO_4_MASK    0x10
+#define    RTL8367C_SEL_GPIO_3_OFFSET    3
+#define    RTL8367C_SEL_GPIO_3_MASK    0x8
+#define    RTL8367C_SEL_GPIO_2_OFFSET    2
+#define    RTL8367C_SEL_GPIO_2_MASK    0x4
+#define    RTL8367C_SEL_GPIO_1_OFFSET    1
+#define    RTL8367C_SEL_GPIO_1_MASK    0x2
+#define    RTL8367C_SEL_GPIO_0_OFFSET    0
+#define    RTL8367C_SEL_GPIO_0_MASK    0x1
+
+#define    RTL8367C_REG_STATUS_GPIO    0x13c9
+#define    RTL8367C_STATUS_GPIO_OFFSET    0
+#define    RTL8367C_STATUS_GPIO_MASK    0x3FFF
+
+#define    RTL8367C_REG_SYNC_ETH_CFG    0x13e0
+#define    RTL8367C_DUMMY2_OFFSET    9
+#define    RTL8367C_DUMMY2_MASK    0xFE00
+#define    RTL8367C_RFC2819_TYPE_OFFSET    8
+#define    RTL8367C_RFC2819_TYPE_MASK    0x100
+#define    RTL8367C_DUMMY1_OFFSET    7
+#define    RTL8367C_DUMMY1_MASK    0x80
+#define    RTL8367C_FIBER_SYNCE125_L_SEL_OFFSET    6
+#define    RTL8367C_FIBER_SYNCE125_L_SEL_MASK    0x40
+#define    RTL8367C_SYNC_ETH_EN_RTT2_OFFSET    5
+#define    RTL8367C_SYNC_ETH_EN_RTT2_MASK    0x20
+#define    RTL8367C_SYNC_ETH_EN_RTT1_OFFSET    4
+#define    RTL8367C_SYNC_ETH_EN_RTT1_MASK    0x10
+#define    RTL8367C_SYNC_ETH_SEL_DPLL_OFFSET    3
+#define    RTL8367C_SYNC_ETH_SEL_DPLL_MASK    0x8
+#define    RTL8367C_SYNC_ETH_SEL_PHYREF_OFFSET    2
+#define    RTL8367C_SYNC_ETH_SEL_PHYREF_MASK    0x4
+#define    RTL8367C_SYNC_ETH_SEL_XTAL_OFFSET    1
+#define    RTL8367C_SYNC_ETH_SEL_XTAL_MASK    0x2
+#define    RTL8367C_DUMMY0_OFFSET    0
+#define    RTL8367C_DUMMY0_MASK    0x1
+
+#define    RTL8367C_REG_LED_DRI_CFG    0x13e1
+#define    RTL8367C_LED_DRI_CFG_DUMMY_OFFSET    1
+#define    RTL8367C_LED_DRI_CFG_DUMMY_MASK    0xFFFE
+#define    RTL8367C_LED_DRIVING_OFFSET    0
+#define    RTL8367C_LED_DRIVING_MASK    0x1
+
+#define    RTL8367C_REG_CHIP_DEBUG2    0x13e2
+#define    RTL8367C_RG2_DN_OFFSET    6
+#define    RTL8367C_RG2_DN_MASK    0x1C0
+#define    RTL8367C_RG2_DP_OFFSET    3
+#define    RTL8367C_RG2_DP_MASK    0x38
+#define    RTL8367C_DRI_EXT2_RG_OFFSET    2
+#define    RTL8367C_DRI_EXT2_RG_MASK    0x4
+#define    RTL8367C_DRI_EXT2_OFFSET    1
+#define    RTL8367C_DRI_EXT2_MASK    0x2
+#define    RTL8367C_SLR_EXT2_OFFSET    0
+#define    RTL8367C_SLR_EXT2_MASK    0x1
+
+#define    RTL8367C_REG_DIGITAL_DEBUG_2    0x13e3
+
+#define    RTL8367C_REG_FIBER_RTL_OUI_CFG0    0x13e4
+#define    RTL8367C_FIBER_RTL_OUI_CFG0_OFFSET    0
+#define    RTL8367C_FIBER_RTL_OUI_CFG0_MASK    0xFF
+
+#define    RTL8367C_REG_FIBER_RTL_OUI_CFG1    0x13e5
+
+#define    RTL8367C_REG_FIBER_CFG_0    0x13e6
+#define    RTL8367C_REV_NUM_OFFSET    8
+#define    RTL8367C_REV_NUM_MASK    0xF00
+#define    RTL8367C_MODEL_NUM_OFFSET    0
+#define    RTL8367C_MODEL_NUM_MASK    0x3F
+
+#define    RTL8367C_REG_FIBER_CFG_1    0x13e7
+#define    RTL8367C_SDS_FRC_REG4_OFFSET    12
+#define    RTL8367C_SDS_FRC_REG4_MASK    0x1000
+#define    RTL8367C_SDS_FRC_REG4_FIB100_OFFSET    11
+#define    RTL8367C_SDS_FRC_REG4_FIB100_MASK    0x800
+#define    RTL8367C_SEL_MASK_ONL_OFFSET    5
+#define    RTL8367C_SEL_MASK_ONL_MASK    0x20
+#define    RTL8367C_DIS_QUALITY_IN_MASK_OFFSET    4
+#define    RTL8367C_DIS_QUALITY_IN_MASK_MASK    0x10
+#define    RTL8367C_SDS_FRC_MODE_OFFSET    3
+#define    RTL8367C_SDS_FRC_MODE_MASK    0x8
+#define    RTL8367C_SDS_MODE_OFFSET    0
+#define    RTL8367C_SDS_MODE_MASK    0x7
+
+#define    RTL8367C_REG_FIBER_CFG_2    0x13e8
+#define    RTL8367C_SEL_SDET_PS_OFFSET    12
+#define    RTL8367C_SEL_SDET_PS_MASK    0xF000
+#define    RTL8367C_UTP_DIS_RX_OFFSET    10
+#define    RTL8367C_UTP_DIS_RX_MASK    0xC00
+#define    RTL8367C_UTP_FRC_LD_OFFSET    8
+#define    RTL8367C_UTP_FRC_LD_MASK    0x300
+#define    RTL8367C_SDS_RX_DISABLE_OFFSET    6
+#define    RTL8367C_SDS_RX_DISABLE_MASK    0xC0
+#define    RTL8367C_SDS_TX_DISABLE_OFFSET    4
+#define    RTL8367C_SDS_TX_DISABLE_MASK    0x30
+#define    RTL8367C_FIBER_CFG_2_SDS_PWR_ISO_OFFSET    2
+#define    RTL8367C_FIBER_CFG_2_SDS_PWR_ISO_MASK    0xC
+#define    RTL8367C_SDS_FRC_LD_OFFSET    0
+#define    RTL8367C_SDS_FRC_LD_MASK    0x3
+
+#define    RTL8367C_REG_FIBER_CFG_3    0x13e9
+#define    RTL8367C_FIBER_CFG_3_OFFSET    0
+#define    RTL8367C_FIBER_CFG_3_MASK    0xFFF
+
+#define    RTL8367C_REG_FIBER_CFG_4    0x13ea
+
+#define    RTL8367C_REG_UTP_FIB_DET    0x13eb
+#define    RTL8367C_FORCE_SEL_FIBER_OFFSET    14
+#define    RTL8367C_FORCE_SEL_FIBER_MASK    0xC000
+#define    RTL8367C_FIB_FINAL_TIMER_OFFSET    12
+#define    RTL8367C_FIB_FINAL_TIMER_MASK    0x3000
+#define    RTL8367C_FIB_LINK_TIMER_OFFSET    10
+#define    RTL8367C_FIB_LINK_TIMER_MASK    0xC00
+#define    RTL8367C_FIB_SDET_TIMER_OFFSET    8
+#define    RTL8367C_FIB_SDET_TIMER_MASK    0x300
+#define    RTL8367C_UTP_LINK_TIMER_OFFSET    6
+#define    RTL8367C_UTP_LINK_TIMER_MASK    0xC0
+#define    RTL8367C_UTP_SDET_TIMER_OFFSET    4
+#define    RTL8367C_UTP_SDET_TIMER_MASK    0x30
+#define    RTL8367C_FORCE_AUTODET_OFFSET    3
+#define    RTL8367C_FORCE_AUTODET_MASK    0x8
+#define    RTL8367C_AUTODET_FSM_CLR_OFFSET    2
+#define    RTL8367C_AUTODET_FSM_CLR_MASK    0x4
+#define    RTL8367C_UTP_FIRST_OFFSET    1
+#define    RTL8367C_UTP_FIRST_MASK    0x2
+#define    RTL8367C_UTP_FIB_DISAUTODET_OFFSET    0
+#define    RTL8367C_UTP_FIB_DISAUTODET_MASK    0x1
+
+#define    RTL8367C_REG_NRESTORE_MAGIC_NUM    0x13ec
+#define    RTL8367C_NRESTORE_MAGIC_NUM_MASK    0xFFFF
+#define    RTL8367C_EEPROM_PROGRAM_CYCLE_OFFSET    0
+#define    RTL8367C_EEPROM_PROGRAM_CYCLE_MASK    0x3
+
+#define    RTL8367C_REG_MAC_ACTIVE    0x13ee
+#define    RTL8367C_MAC_ACTIVE_H_OFFSET    9
+#define    RTL8367C_MAC_ACTIVE_H_MASK    0xE00
+#define    RTL8367C_FORCE_MAC_ACTIVE_OFFSET    8
+#define    RTL8367C_FORCE_MAC_ACTIVE_MASK    0x100
+#define    RTL8367C_MAC_ACTIVE_OFFSET    0
+#define    RTL8367C_MAC_ACTIVE_MASK    0xFF
+
+#define    RTL8367C_REG_SERDES_RESULT    0x13ef
+#define    RTL8367C_FIB100_DET_1_OFFSET    12
+#define    RTL8367C_FIB100_DET_1_MASK    0x1000
+#define    RTL8367C_FIB_ISO_1_OFFSET    11
+#define    RTL8367C_FIB_ISO_1_MASK    0x800
+#define    RTL8367C_SDS_ANFAULT_1_OFFSET    10
+#define    RTL8367C_SDS_ANFAULT_1_MASK    0x400
+#define    RTL8367C_SDS_INTB_1_OFFSET    9
+#define    RTL8367C_SDS_INTB_1_MASK    0x200
+#define    RTL8367C_SDS_LINK_OK_1_OFFSET    8
+#define    RTL8367C_SDS_LINK_OK_1_MASK    0x100
+#define    RTL8367C_FIB100_DET_OFFSET    4
+#define    RTL8367C_FIB100_DET_MASK    0x10
+#define    RTL8367C_FIB_ISO_OFFSET    3
+#define    RTL8367C_FIB_ISO_MASK    0x8
+#define    RTL8367C_SDS_ANFAULT_OFFSET    2
+#define    RTL8367C_SDS_ANFAULT_MASK    0x4
+#define    RTL8367C_SDS_INTB_OFFSET    1
+#define    RTL8367C_SDS_INTB_MASK    0x2
+#define    RTL8367C_SDS_LINK_OK_OFFSET    0
+#define    RTL8367C_SDS_LINK_OK_MASK    0x1
+
+#define    RTL8367C_REG_CHIP_ECO    0x13f0
+#define    RTL8367C_CFG_CHIP_ECO_OFFSET    1
+#define    RTL8367C_CFG_CHIP_ECO_MASK    0xFFFE
+#define    RTL8367C_CFG_CKOUTEN_OFFSET    0
+#define    RTL8367C_CFG_CKOUTEN_MASK    0x1
+
+#define    RTL8367C_REG_WAKELPI_SLOT_PRD    0x13f1
+#define    RTL8367C_WAKELPI_SLOT_PRD_OFFSET    0
+#define    RTL8367C_WAKELPI_SLOT_PRD_MASK    0x1F
+
+#define    RTL8367C_REG_WAKELPI_SLOT_PG0    0x13f2
+#define    RTL8367C_WAKELPI_SLOT_P1_OFFSET    8
+#define    RTL8367C_WAKELPI_SLOT_P1_MASK    0x1F00
+#define    RTL8367C_WAKELPI_SLOT_P0_OFFSET    0
+#define    RTL8367C_WAKELPI_SLOT_P0_MASK    0x1F
+
+#define    RTL8367C_REG_WAKELPI_SLOT_PG1    0x13f3
+#define    RTL8367C_WAKELPI_SLOT_P3_OFFSET    8
+#define    RTL8367C_WAKELPI_SLOT_P3_MASK    0x1F00
+#define    RTL8367C_WAKELPI_SLOT_P2_OFFSET    0
+#define    RTL8367C_WAKELPI_SLOT_P2_MASK    0x1F
+
+#define    RTL8367C_REG_WAKELPI_SLOT_PG2    0x13f4
+#define    RTL8367C_WAKELPI_SLOT_P5_OFFSET    8
+#define    RTL8367C_WAKELPI_SLOT_P5_MASK    0x1F00
+#define    RTL8367C_WAKELPI_SLOT_P4_OFFSET    0
+#define    RTL8367C_WAKELPI_SLOT_P4_MASK    0x1F
+
+#define    RTL8367C_REG_WAKELPI_SLOT_PG3    0x13f5
+#define    RTL8367C_WAKELPI_SLOT_P7_OFFSET    8
+#define    RTL8367C_WAKELPI_SLOT_P7_MASK    0x1F00
+#define    RTL8367C_WAKELPI_SLOT_P6_OFFSET    0
+#define    RTL8367C_WAKELPI_SLOT_P6_MASK    0x1F
+
+#define    RTL8367C_REG_SYNC_FIFO_0    0x13f6
+#define    RTL8367C_SYNC_FIFO_TX_OFFSET    8
+#define    RTL8367C_SYNC_FIFO_TX_MASK    0x700
+#define    RTL8367C_SYNC_FIFO_RX_OFFSET    0
+#define    RTL8367C_SYNC_FIFO_RX_MASK    0xFF
+
+#define    RTL8367C_REG_SYNC_FIFO_1    0x13f7
+#define    RTL8367C_SYNC_FIFO_RX_ERR_P10_8_OFFSET    11
+#define    RTL8367C_SYNC_FIFO_RX_ERR_P10_8_MASK    0x3800
+#define    RTL8367C_SYNC_FIFO_TX_ERR_OFFSET    8
+#define    RTL8367C_SYNC_FIFO_TX_ERR_MASK    0x700
+#define    RTL8367C_SYNC_FIFO_RX_ERR_OFFSET    0
+#define    RTL8367C_SYNC_FIFO_RX_ERR_MASK    0xFF
+
+#define    RTL8367C_REG_RGM_EEE    0x13f8
+#define    RTL8367C_EXT2_PAD_STOP_EN_OFFSET    14
+#define    RTL8367C_EXT2_PAD_STOP_EN_MASK    0x4000
+#define    RTL8367C_EXT1_PAD_STOP_EN_OFFSET    13
+#define    RTL8367C_EXT1_PAD_STOP_EN_MASK    0x2000
+#define    RTL8367C_EXT0_PAD_STOP_EN_OFFSET    12
+#define    RTL8367C_EXT0_PAD_STOP_EN_MASK    0x1000
+#define    RTL8367C_EXT2_CYCLE_PAD_OFFSET    8
+#define    RTL8367C_EXT2_CYCLE_PAD_MASK    0xF00
+#define    RTL8367C_EXT1_CYCLE_PAD_OFFSET    4
+#define    RTL8367C_EXT1_CYCLE_PAD_MASK    0xF0
+#define    RTL8367C_EXT0_CYCLE_PAD_OFFSET    0
+#define    RTL8367C_EXT0_CYCLE_PAD_MASK    0xF
+
+#define    RTL8367C_REG_EXT_TXC_DLY    0x13f9
+#define    RTL8367C_EXT1_GMII_TX_DELAY_OFFSET    12
+#define    RTL8367C_EXT1_GMII_TX_DELAY_MASK    0x7000
+#define    RTL8367C_EXT0_GMII_TX_DELAY_OFFSET    9
+#define    RTL8367C_EXT0_GMII_TX_DELAY_MASK    0xE00
+#define    RTL8367C_EXT2_RGMII_TX_DELAY_OFFSET    6
+#define    RTL8367C_EXT2_RGMII_TX_DELAY_MASK    0x1C0
+#define    RTL8367C_EXT1_RGMII_TX_DELAY_OFFSET    3
+#define    RTL8367C_EXT1_RGMII_TX_DELAY_MASK    0x38
+#define    RTL8367C_EXT0_RGMII_TX_DELAY_OFFSET    0
+#define    RTL8367C_EXT0_RGMII_TX_DELAY_MASK    0x7
+
+#define    RTL8367C_REG_IO_MISC_CTRL    0x13fa
+#define    RTL8367C_IO_BUZZER_EN_OFFSET    3
+#define    RTL8367C_IO_BUZZER_EN_MASK    0x8
+#define    RTL8367C_IO_INTRPT_EN_OFFSET    2
+#define    RTL8367C_IO_INTRPT_EN_MASK    0x4
+#define    RTL8367C_IO_NRESTORE_EN_OFFSET    1
+#define    RTL8367C_IO_NRESTORE_EN_MASK    0x2
+#define    RTL8367C_IO_UART_EN_OFFSET    0
+#define    RTL8367C_IO_UART_EN_MASK    0x1
+
+#define    RTL8367C_REG_CHIP_DUMMY_NO    0x13fb
+#define    RTL8367C_CHIP_DUMMY_NO_OFFSET    0
+#define    RTL8367C_CHIP_DUMMY_NO_MASK    0xF
+
+#define    RTL8367C_REG_RC_CALIB_CFG    0x13fc
+#define    RTL8367C_TRIG_BURN_EFUSE_OFFSET    9
+#define    RTL8367C_TRIG_BURN_EFUSE_MASK    0x200
+#define    RTL8367C_AMP_CALIB_FAIL_OFFSET    8
+#define    RTL8367C_AMP_CALIB_FAIL_MASK    0x100
+#define    RTL8367C_R_CALIB_FAIL_OFFSET    7
+#define    RTL8367C_R_CALIB_FAIL_MASK    0x80
+#define    RTL8367C_CFG_CALIB_MODE_OFFSET    6
+#define    RTL8367C_CFG_CALIB_MODE_MASK    0x40
+#define    RTL8367C_CENTER_PORT_SEL_OFFSET    3
+#define    RTL8367C_CENTER_PORT_SEL_MASK    0x38
+#define    RTL8367C_CALIB_FINISH_OFFSET    2
+#define    RTL8367C_CALIB_FINISH_MASK    0x4
+#define    RTL8367C_CFG_CALIB_OPTION_OFFSET    1
+#define    RTL8367C_CFG_CALIB_OPTION_MASK    0x2
+#define    RTL8367C_CFG_CALIB_EN_OFFSET    0
+#define    RTL8367C_CFG_CALIB_EN_MASK    0x1
+
+#define    RTL8367C_REG_WAKELPI_SLOT_PG4    0x13fd
+#define    RTL8367C_WAKELPI_SLOT_P9_OFFSET    8
+#define    RTL8367C_WAKELPI_SLOT_P9_MASK    0x1F00
+#define    RTL8367C_WAKELPI_SLOT_P8_OFFSET    0
+#define    RTL8367C_WAKELPI_SLOT_P8_MASK    0x1F
+
+#define    RTL8367C_REG_WAKELPI_SLOT_PG5    0x13fe
+#define    RTL8367C_WAKELPI_SLOT_PG5_OFFSET    0
+#define    RTL8367C_WAKELPI_SLOT_PG5_MASK    0x1F
+
+/* (16'h1400)mtrpool_reg */
+
+#define    RTL8367C_REG_METER0_RATE_CTRL0    0x1400
+
+#define    RTL8367C_REG_METER0_RATE_CTRL1    0x1401
+#define    RTL8367C_METER0_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER0_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER1_RATE_CTRL0    0x1402
+
+#define    RTL8367C_REG_METER1_RATE_CTRL1    0x1403
+#define    RTL8367C_METER1_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER1_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER2_RATE_CTRL0    0x1404
+
+#define    RTL8367C_REG_METER2_RATE_CTRL1    0x1405
+#define    RTL8367C_METER2_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER2_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER3_RATE_CTRL0    0x1406
+
+#define    RTL8367C_REG_METER3_RATE_CTRL1    0x1407
+#define    RTL8367C_METER3_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER3_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER4_RATE_CTRL0    0x1408
+
+#define    RTL8367C_REG_METER4_RATE_CTRL1    0x1409
+#define    RTL8367C_METER4_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER4_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER5_RATE_CTRL0    0x140a
+
+#define    RTL8367C_REG_METER5_RATE_CTRL1    0x140b
+#define    RTL8367C_METER5_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER5_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER6_RATE_CTRL0    0x140c
+
+#define    RTL8367C_REG_METER6_RATE_CTRL1    0x140d
+#define    RTL8367C_METER6_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER6_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER7_RATE_CTRL0    0x140e
+
+#define    RTL8367C_REG_METER7_RATE_CTRL1    0x140f
+#define    RTL8367C_METER7_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER7_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER8_RATE_CTRL0    0x1410
+
+#define    RTL8367C_REG_METER8_RATE_CTRL1    0x1411
+#define    RTL8367C_METER8_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER8_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER9_RATE_CTRL0    0x1412
+
+#define    RTL8367C_REG_METER9_RATE_CTRL1    0x1413
+#define    RTL8367C_METER9_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER9_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER10_RATE_CTRL0    0x1414
+
+#define    RTL8367C_REG_METER10_RATE_CTRL1    0x1415
+#define    RTL8367C_METER10_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER10_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER11_RATE_CTRL0    0x1416
+
+#define    RTL8367C_REG_METER11_RATE_CTRL1    0x1417
+#define    RTL8367C_METER11_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER11_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER12_RATE_CTRL0    0x1418
+
+#define    RTL8367C_REG_METER12_RATE_CTRL1    0x1419
+#define    RTL8367C_METER12_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER12_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER13_RATE_CTRL0    0x141a
+
+#define    RTL8367C_REG_METER13_RATE_CTRL1    0x141b
+#define    RTL8367C_METER13_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER13_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER14_RATE_CTRL0    0x141c
+
+#define    RTL8367C_REG_METER14_RATE_CTRL1    0x141d
+#define    RTL8367C_METER14_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER14_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER15_RATE_CTRL0    0x141e
+
+#define    RTL8367C_REG_METER15_RATE_CTRL1    0x141f
+#define    RTL8367C_METER15_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER15_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER16_RATE_CTRL0    0x1420
+
+#define    RTL8367C_REG_METER16_RATE_CTRL1    0x1421
+#define    RTL8367C_METER16_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER16_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER17_RATE_CTRL0    0x1422
+
+#define    RTL8367C_REG_METER17_RATE_CTRL1    0x1423
+#define    RTL8367C_METER17_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER17_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER18_RATE_CTRL0    0x1424
+
+#define    RTL8367C_REG_METER18_RATE_CTRL1    0x1425
+#define    RTL8367C_METER18_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER18_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER19_RATE_CTRL0    0x1426
+
+#define    RTL8367C_REG_METER19_RATE_CTRL1    0x1427
+#define    RTL8367C_METER19_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER19_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER20_RATE_CTRL0    0x1428
+
+#define    RTL8367C_REG_METER20_RATE_CTRL1    0x1429
+#define    RTL8367C_METER20_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER20_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER21_RATE_CTRL0    0x142a
+
+#define    RTL8367C_REG_METER21_RATE_CTRL1    0x142b
+#define    RTL8367C_METER21_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER21_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER22_RATE_CTRL0    0x142c
+
+#define    RTL8367C_REG_METER22_RATE_CTRL1    0x142d
+#define    RTL8367C_METER22_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER22_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER23_RATE_CTRL0    0x142e
+
+#define    RTL8367C_REG_METER23_RATE_CTRL1    0x142f
+#define    RTL8367C_METER23_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER23_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER24_RATE_CTRL0    0x1430
+
+#define    RTL8367C_REG_METER24_RATE_CTRL1    0x1431
+#define    RTL8367C_METER24_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER24_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER25_RATE_CTRL0    0x1432
+
+#define    RTL8367C_REG_METER25_RATE_CTRL1    0x1433
+#define    RTL8367C_METER25_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER25_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER26_RATE_CTRL0    0x1434
+
+#define    RTL8367C_REG_METER26_RATE_CTRL1    0x1435
+#define    RTL8367C_METER26_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER26_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER27_RATE_CTRL0    0x1436
+
+#define    RTL8367C_REG_METER27_RATE_CTRL1    0x1437
+#define    RTL8367C_METER27_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER27_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER28_RATE_CTRL0    0x1438
+
+#define    RTL8367C_REG_METER28_RATE_CTRL1    0x1439
+#define    RTL8367C_METER28_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER28_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER29_RATE_CTRL0    0x143a
+
+#define    RTL8367C_REG_METER29_RATE_CTRL1    0x143b
+#define    RTL8367C_METER29_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER29_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER30_RATE_CTRL0    0x143c
+
+#define    RTL8367C_REG_METER30_RATE_CTRL1    0x143d
+#define    RTL8367C_METER30_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER30_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER31_RATE_CTRL0    0x143e
+
+#define    RTL8367C_REG_METER31_RATE_CTRL1    0x143f
+#define    RTL8367C_METER31_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER31_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER_MODE_SETTING0    0x1440
+
+#define    RTL8367C_REG_METER_MODE_SETTING1    0x1441
+
+#define    RTL8367C_REG_METER_MODE_TOKEN_CFG    0x1442
+#define    RTL8367C_METER_MODE_TOKEN_CFG_OFFSET    0
+#define    RTL8367C_METER_MODE_TOKEN_CFG_MASK    0x7FF
+
+#define    RTL8367C_REG_METER0_BUCKET_SIZE    0x1600
+
+#define    RTL8367C_REG_METER1_BUCKET_SIZE    0x1601
+
+#define    RTL8367C_REG_METER2_BUCKET_SIZE    0x1602
+
+#define    RTL8367C_REG_METER3_BUCKET_SIZE    0x1603
+
+#define    RTL8367C_REG_METER4_BUCKET_SIZE    0x1604
+
+#define    RTL8367C_REG_METER5_BUCKET_SIZE    0x1605
+
+#define    RTL8367C_REG_METER6_BUCKET_SIZE    0x1606
+
+#define    RTL8367C_REG_METER7_BUCKET_SIZE    0x1607
+
+#define    RTL8367C_REG_METER8_BUCKET_SIZE    0x1608
+
+#define    RTL8367C_REG_METER9_BUCKET_SIZE    0x1609
+
+#define    RTL8367C_REG_METER10_BUCKET_SIZE    0x160a
+
+#define    RTL8367C_REG_METER11_BUCKET_SIZE    0x160b
+
+#define    RTL8367C_REG_METER12_BUCKET_SIZE    0x160c
+
+#define    RTL8367C_REG_METER13_BUCKET_SIZE    0x160d
+
+#define    RTL8367C_REG_METER14_BUCKET_SIZE    0x160e
+
+#define    RTL8367C_REG_METER15_BUCKET_SIZE    0x160f
+
+#define    RTL8367C_REG_METER16_BUCKET_SIZE    0x1610
+
+#define    RTL8367C_REG_METER17_BUCKET_SIZE    0x1611
+
+#define    RTL8367C_REG_METER18_BUCKET_SIZE    0x1612
+
+#define    RTL8367C_REG_METER19_BUCKET_SIZE    0x1613
+
+#define    RTL8367C_REG_METER20_BUCKET_SIZE    0x1614
+
+#define    RTL8367C_REG_METER21_BUCKET_SIZE    0x1615
+
+#define    RTL8367C_REG_METER22_BUCKET_SIZE    0x1616
+
+#define    RTL8367C_REG_METER23_BUCKET_SIZE    0x1617
+
+#define    RTL8367C_REG_METER24_BUCKET_SIZE    0x1618
+
+#define    RTL8367C_REG_METER25_BUCKET_SIZE    0x1619
+
+#define    RTL8367C_REG_METER26_BUCKET_SIZE    0x161a
+
+#define    RTL8367C_REG_METER27_BUCKET_SIZE    0x161b
+
+#define    RTL8367C_REG_METER28_BUCKET_SIZE    0x161c
+
+#define    RTL8367C_REG_METER29_BUCKET_SIZE    0x161d
+
+#define    RTL8367C_REG_METER30_BUCKET_SIZE    0x161e
+
+#define    RTL8367C_REG_METER31_BUCKET_SIZE    0x161f
+
+#define    RTL8367C_REG_METER_CTRL0    0x1700
+#define    RTL8367C_METER_OP_OFFSET    8
+#define    RTL8367C_METER_OP_MASK    0x100
+#define    RTL8367C_METER_TICK_OFFSET    0
+#define    RTL8367C_METER_TICK_MASK    0xFF
+
+#define    RTL8367C_REG_METER_CTRL1    0x1701
+#define    RTL8367C_METER_CTRL1_OFFSET    0
+#define    RTL8367C_METER_CTRL1_MASK    0xFF
+
+#define    RTL8367C_REG_METER_OVERRATE_INDICATOR0    0x1702
+
+#define    RTL8367C_REG_METER_OVERRATE_INDICATOR1    0x1703
+
+#define    RTL8367C_REG_METER_OVERRATE_INDICATOR0_8051    0x1704
+
+#define    RTL8367C_REG_METER_OVERRATE_INDICATOR1_8051    0x1705
+
+#define    RTL8367C_REG_METER_IFG_CTRL0    0x1712
+#define    RTL8367C_METER15_IFG_OFFSET    15
+#define    RTL8367C_METER15_IFG_MASK    0x8000
+#define    RTL8367C_METER14_IFG_OFFSET    14
+#define    RTL8367C_METER14_IFG_MASK    0x4000
+#define    RTL8367C_METER13_IFG_OFFSET    13
+#define    RTL8367C_METER13_IFG_MASK    0x2000
+#define    RTL8367C_METER12_IFG_OFFSET    12
+#define    RTL8367C_METER12_IFG_MASK    0x1000
+#define    RTL8367C_METER11_IFG_OFFSET    11
+#define    RTL8367C_METER11_IFG_MASK    0x800
+#define    RTL8367C_METER10_IFG_OFFSET    10
+#define    RTL8367C_METER10_IFG_MASK    0x400
+#define    RTL8367C_METER9_IFG_OFFSET    9
+#define    RTL8367C_METER9_IFG_MASK    0x200
+#define    RTL8367C_METER8_IFG_OFFSET    8
+#define    RTL8367C_METER8_IFG_MASK    0x100
+#define    RTL8367C_METER7_IFG_OFFSET    7
+#define    RTL8367C_METER7_IFG_MASK    0x80
+#define    RTL8367C_METER6_IFG_OFFSET    6
+#define    RTL8367C_METER6_IFG_MASK    0x40
+#define    RTL8367C_METER5_IFG_OFFSET    5
+#define    RTL8367C_METER5_IFG_MASK    0x20
+#define    RTL8367C_METER4_IFG_OFFSET    4
+#define    RTL8367C_METER4_IFG_MASK    0x10
+#define    RTL8367C_METER3_IFG_OFFSET    3
+#define    RTL8367C_METER3_IFG_MASK    0x8
+#define    RTL8367C_METER2_IFG_OFFSET    2
+#define    RTL8367C_METER2_IFG_MASK    0x4
+#define    RTL8367C_METER1_IFG_OFFSET    1
+#define    RTL8367C_METER1_IFG_MASK    0x2
+#define    RTL8367C_METER0_IFG_OFFSET    0
+#define    RTL8367C_METER0_IFG_MASK    0x1
+
+#define    RTL8367C_REG_METER_IFG_CTRL1    0x1713
+#define    RTL8367C_METER31_IFG_OFFSET    15
+#define    RTL8367C_METER31_IFG_MASK    0x8000
+#define    RTL8367C_METER30_IFG_OFFSET    14
+#define    RTL8367C_METER30_IFG_MASK    0x4000
+#define    RTL8367C_METER29_IFG_OFFSET    13
+#define    RTL8367C_METER29_IFG_MASK    0x2000
+#define    RTL8367C_METER28_IFG_OFFSET    12
+#define    RTL8367C_METER28_IFG_MASK    0x1000
+#define    RTL8367C_METER27_IFG_OFFSET    11
+#define    RTL8367C_METER27_IFG_MASK    0x800
+#define    RTL8367C_METER26_IFG_OFFSET    10
+#define    RTL8367C_METER26_IFG_MASK    0x400
+#define    RTL8367C_METER25_IFG_OFFSET    9
+#define    RTL8367C_METER25_IFG_MASK    0x200
+#define    RTL8367C_METER24_IFG_OFFSET    8
+#define    RTL8367C_METER24_IFG_MASK    0x100
+#define    RTL8367C_METER23_IFG_OFFSET    7
+#define    RTL8367C_METER23_IFG_MASK    0x80
+#define    RTL8367C_METER22_IFG_OFFSET    6
+#define    RTL8367C_METER22_IFG_MASK    0x40
+#define    RTL8367C_METER21_IFG_OFFSET    5
+#define    RTL8367C_METER21_IFG_MASK    0x20
+#define    RTL8367C_METER20_IFG_OFFSET    4
+#define    RTL8367C_METER20_IFG_MASK    0x10
+#define    RTL8367C_METER19_IFG_OFFSET    3
+#define    RTL8367C_METER19_IFG_MASK    0x8
+#define    RTL8367C_METER18_IFG_OFFSET    2
+#define    RTL8367C_METER18_IFG_MASK    0x4
+#define    RTL8367C_METER17_IFG_OFFSET    1
+#define    RTL8367C_METER17_IFG_MASK    0x2
+#define    RTL8367C_METER16_IFG_OFFSET    0
+#define    RTL8367C_METER16_IFG_MASK    0x1
+
+#define    RTL8367C_REG_METER_CTRL2    0x1722
+#define    RTL8367C_cfg_mtr_tick_8g_OFFSET    8
+#define    RTL8367C_cfg_mtr_tick_8g_MASK    0xFF00
+#define    RTL8367C_cfg_mtr_dec_cnt_8g_OFFSET    0
+#define    RTL8367C_cfg_mtr_dec_cnt_8g_MASK    0xFF
+
+#define    RTL8367C_REG_DUMMY_1723    0x1723
+
+#define    RTL8367C_REG_DUMMY_1724    0x1724
+
+#define    RTL8367C_REG_DUMMY_1725    0x1725
+
+#define    RTL8367C_REG_DUMMY_1726    0x1726
+
+#define    RTL8367C_REG_DUMMY_1727    0x1727
+
+#define    RTL8367C_REG_DUMMY_1728    0x1728
+
+#define    RTL8367C_REG_DUMMY_1729    0x1729
+
+#define    RTL8367C_REG_DUMMY_172A    0x172a
+
+#define    RTL8367C_REG_DUMMY_172B    0x172b
+
+#define    RTL8367C_REG_DUMMY_172C    0x172c
+
+#define    RTL8367C_REG_DUMMY_172D    0x172d
+
+#define    RTL8367C_REG_DUMMY_172E    0x172e
+
+#define    RTL8367C_REG_DUMMY_172F    0x172f
+
+#define    RTL8367C_REG_DUMMY_1730    0x1730
+
+#define    RTL8367C_REG_DUMMY_1731    0x1731
+
+#define    RTL8367C_REG_METER32_RATE_CTRL0    0x1740
+
+#define    RTL8367C_REG_METER32_RATE_CTRL1    0x1741
+#define    RTL8367C_METER32_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER32_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER33_RATE_CTRL0    0x1742
+
+#define    RTL8367C_REG_METER33_RATE_CTRL1    0x1743
+#define    RTL8367C_METER33_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER33_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER34_RATE_CTRL0    0x1744
+
+#define    RTL8367C_REG_METER34_RATE_CTRL1    0x1745
+#define    RTL8367C_METER34_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER34_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER35_RATE_CTRL0    0x1746
+
+#define    RTL8367C_REG_METER35_RATE_CTRL1    0x1747
+#define    RTL8367C_METER35_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER35_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER36_RATE_CTRL0    0x1748
+
+#define    RTL8367C_REG_METER36_RATE_CTRL1    0x1749
+#define    RTL8367C_METER36_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER36_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER37_RATE_CTRL0    0x174a
+
+#define    RTL8367C_REG_METER37_RATE_CTRL1    0x174b
+#define    RTL8367C_METER37_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER37_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER38_RATE_CTRL0    0x174c
+
+#define    RTL8367C_REG_METER38_RATE_CTRL1    0x174d
+#define    RTL8367C_METER38_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER38_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER39_RATE_CTRL0    0x174e
+
+#define    RTL8367C_REG_METER39_RATE_CTRL1    0x174f
+#define    RTL8367C_METER39_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER39_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER40_RATE_CTRL0    0x1750
+
+#define    RTL8367C_REG_METER40_RATE_CTRL1    0x1751
+#define    RTL8367C_METER40_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER40_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER41_RATE_CTRL0    0x1752
+
+#define    RTL8367C_REG_METER41_RATE_CTRL1    0x1753
+#define    RTL8367C_METER41_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER41_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER42_RATE_CTRL0    0x1754
+
+#define    RTL8367C_REG_METER42_RATE_CTRL1    0x1755
+#define    RTL8367C_METER42_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER42_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER43_RATE_CTRL0    0x1756
+
+#define    RTL8367C_REG_METER43_RATE_CTRL1    0x1757
+#define    RTL8367C_METER43_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER43_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER44_RATE_CTRL0    0x1758
+
+#define    RTL8367C_REG_METER44_RATE_CTRL1    0x1759
+#define    RTL8367C_METER44_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER44_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER45_RATE_CTRL0    0x175a
+
+#define    RTL8367C_REG_METER45_RATE_CTRL1    0x175b
+#define    RTL8367C_METER45_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER45_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER46_RATE_CTRL0    0x175c
+
+#define    RTL8367C_REG_METER46_RATE_CTRL1    0x175d
+#define    RTL8367C_METER46_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER46_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER47_RATE_CTRL0    0x175e
+
+#define    RTL8367C_REG_METER47_RATE_CTRL1    0x175f
+#define    RTL8367C_METER47_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER47_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER48_RATE_CTRL0    0x1760
+
+#define    RTL8367C_REG_METER48_RATE_CTRL1    0x1761
+#define    RTL8367C_METER48_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER48_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER49_RATE_CTRL0    0x1762
+
+#define    RTL8367C_REG_METER49_RATE_CTRL1    0x1763
+#define    RTL8367C_METER49_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER49_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER50_RATE_CTRL0    0x1764
+
+#define    RTL8367C_REG_METER50_RATE_CTRL1    0x1765
+#define    RTL8367C_METER50_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER50_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER51_RATE_CTRL0    0x1766
+
+#define    RTL8367C_REG_METER51_RATE_CTRL1    0x1767
+#define    RTL8367C_METER51_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER51_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER52_RATE_CTRL0    0x1768
+
+#define    RTL8367C_REG_METER52_RATE_CTRL1    0x1769
+#define    RTL8367C_METER52_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER52_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER53_RATE_CTRL0    0x176a
+
+#define    RTL8367C_REG_METER53_RATE_CTRL1    0x176b
+#define    RTL8367C_METER53_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER53_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER54_RATE_CTRL0    0x176c
+
+#define    RTL8367C_REG_METER54_RATE_CTRL1    0x176d
+#define    RTL8367C_METER54_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER54_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER55_RATE_CTRL0    0x176e
+
+#define    RTL8367C_REG_METER55_RATE_CTRL1    0x176f
+#define    RTL8367C_METER55_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER55_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER56_RATE_CTRL0    0x1770
+
+#define    RTL8367C_REG_METER56_RATE_CTRL1    0x1771
+#define    RTL8367C_METER56_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER56_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER57_RATE_CTRL0    0x1772
+
+#define    RTL8367C_REG_METER57_RATE_CTRL1    0x1773
+#define    RTL8367C_METER57_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER57_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER58_RATE_CTRL0    0x1774
+
+#define    RTL8367C_REG_METER58_RATE_CTRL1    0x1775
+#define    RTL8367C_METER58_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER58_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER59_RATE_CTRL0    0x1776
+
+#define    RTL8367C_REG_METER59_RATE_CTRL1    0x1777
+#define    RTL8367C_METER59_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER59_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER60_RATE_CTRL0    0x1778
+
+#define    RTL8367C_REG_METER60_RATE_CTRL1    0x1779
+#define    RTL8367C_METER60_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER60_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER61_RATE_CTRL0    0x177a
+
+#define    RTL8367C_REG_METER61_RATE_CTRL1    0x177b
+#define    RTL8367C_METER61_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER61_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER62_RATE_CTRL0    0x177c
+
+#define    RTL8367C_REG_METER62_RATE_CTRL1    0x177d
+#define    RTL8367C_METER62_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER62_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER63_RATE_CTRL0    0x177e
+
+#define    RTL8367C_REG_METER63_RATE_CTRL1    0x177f
+#define    RTL8367C_METER63_RATE_CTRL1_OFFSET    0
+#define    RTL8367C_METER63_RATE_CTRL1_MASK    0x7
+
+#define    RTL8367C_REG_METER_MODE_SETTING2    0x1780
+
+#define    RTL8367C_REG_METER_MODE_SETTING3    0x1781
+
+#define    RTL8367C_REG_METER32_BUCKET_SIZE    0x1790
+
+#define    RTL8367C_REG_METER33_BUCKET_SIZE    0x1791
+
+#define    RTL8367C_REG_METER34_BUCKET_SIZE    0x1792
+
+#define    RTL8367C_REG_METER35_BUCKET_SIZE    0x1793
+
+#define    RTL8367C_REG_METER36_BUCKET_SIZE    0x1794
+
+#define    RTL8367C_REG_METER37_BUCKET_SIZE    0x1795
+
+#define    RTL8367C_REG_METER38_BUCKET_SIZE    0x1796
+
+#define    RTL8367C_REG_METER39_BUCKET_SIZE    0x1797
+
+#define    RTL8367C_REG_METER40_BUCKET_SIZE    0x1798
+
+#define    RTL8367C_REG_METER41_BUCKET_SIZE    0x1799
+
+#define    RTL8367C_REG_METER42_BUCKET_SIZE    0x179a
+
+#define    RTL8367C_REG_METER43_BUCKET_SIZE    0x179b
+
+#define    RTL8367C_REG_METER44_BUCKET_SIZE    0x179c
+
+#define    RTL8367C_REG_METER45_BUCKET_SIZE    0x179d
+
+#define    RTL8367C_REG_METER46_BUCKET_SIZE    0x179e
+
+#define    RTL8367C_REG_METER47_BUCKET_SIZE    0x179f
+
+#define    RTL8367C_REG_METER48_BUCKET_SIZE    0x17a0
+
+#define    RTL8367C_REG_METER49_BUCKET_SIZE    0x17a1
+
+#define    RTL8367C_REG_METER50_BUCKET_SIZE    0x17a2
+
+#define    RTL8367C_REG_METER51_BUCKET_SIZE    0x17a3
+
+#define    RTL8367C_REG_METER52_BUCKET_SIZE    0x17a4
+
+#define    RTL8367C_REG_METER53_BUCKET_SIZE    0x17a5
+
+#define    RTL8367C_REG_METER54_BUCKET_SIZE    0x17a6
+
+#define    RTL8367C_REG_METER55_BUCKET_SIZE    0x17a7
+
+#define    RTL8367C_REG_METER56_BUCKET_SIZE    0x17a8
+
+#define    RTL8367C_REG_METER57_BUCKET_SIZE    0x17a9
+
+#define    RTL8367C_REG_METER58_BUCKET_SIZE    0x17aa
+
+#define    RTL8367C_REG_METER59_BUCKET_SIZE    0x17ab
+
+#define    RTL8367C_REG_METER60_BUCKET_SIZE    0x17ac
+
+#define    RTL8367C_REG_METER61_BUCKET_SIZE    0x17ad
+
+#define    RTL8367C_REG_METER62_BUCKET_SIZE    0x17ae
+
+#define    RTL8367C_REG_METER63_BUCKET_SIZE    0x17af
+
+#define    RTL8367C_REG_METER_OVERRATE_INDICATOR2    0x17b0
+
+#define    RTL8367C_REG_METER_OVERRATE_INDICATOR3    0x17b1
+
+#define    RTL8367C_REG_METER_OVERRATE_INDICATOR2_8051    0x17b2
+
+#define    RTL8367C_REG_METER_OVERRATE_INDICATOR3_8051    0x17b3
+
+#define    RTL8367C_REG_METER_IFG_CTRL2    0x17b4
+#define    RTL8367C_METER47_IFG_OFFSET    15
+#define    RTL8367C_METER47_IFG_MASK    0x8000
+#define    RTL8367C_METER46_IFG_OFFSET    14
+#define    RTL8367C_METER46_IFG_MASK    0x4000
+#define    RTL8367C_METER45_IFG_OFFSET    13
+#define    RTL8367C_METER45_IFG_MASK    0x2000
+#define    RTL8367C_METER44_IFG_OFFSET    12
+#define    RTL8367C_METER44_IFG_MASK    0x1000
+#define    RTL8367C_METER43_IFG_OFFSET    11
+#define    RTL8367C_METER43_IFG_MASK    0x800
+#define    RTL8367C_METER42_IFG_OFFSET    10
+#define    RTL8367C_METER42_IFG_MASK    0x400
+#define    RTL8367C_METER41_IFG_OFFSET    9
+#define    RTL8367C_METER41_IFG_MASK    0x200
+#define    RTL8367C_METER40_IFG_OFFSET    8
+#define    RTL8367C_METER40_IFG_MASK    0x100
+#define    RTL8367C_METER39_IFG_OFFSET    7
+#define    RTL8367C_METER39_IFG_MASK    0x80
+#define    RTL8367C_METER38_IFG_OFFSET    6
+#define    RTL8367C_METER38_IFG_MASK    0x40
+#define    RTL8367C_METER37_IFG_OFFSET    5
+#define    RTL8367C_METER37_IFG_MASK    0x20
+#define    RTL8367C_METER36_IFG_OFFSET    4
+#define    RTL8367C_METER36_IFG_MASK    0x10
+#define    RTL8367C_METER35_IFG_OFFSET    3
+#define    RTL8367C_METER35_IFG_MASK    0x8
+#define    RTL8367C_METER34_IFG_OFFSET    2
+#define    RTL8367C_METER34_IFG_MASK    0x4
+#define    RTL8367C_METER33_IFG_OFFSET    1
+#define    RTL8367C_METER33_IFG_MASK    0x2
+#define    RTL8367C_METER32_IFG_OFFSET    0
+#define    RTL8367C_METER32_IFG_MASK    0x1
+
+#define    RTL8367C_REG_METER_IFG_CTRL3    0x17b5
+#define    RTL8367C_METER63_IFG_OFFSET    15
+#define    RTL8367C_METER63_IFG_MASK    0x8000
+#define    RTL8367C_METER62_IFG_OFFSET    14
+#define    RTL8367C_METER62_IFG_MASK    0x4000
+#define    RTL8367C_METER61_IFG_OFFSET    13
+#define    RTL8367C_METER61_IFG_MASK    0x2000
+#define    RTL8367C_METER60_IFG_OFFSET    12
+#define    RTL8367C_METER60_IFG_MASK    0x1000
+#define    RTL8367C_METER59_IFG_OFFSET    11
+#define    RTL8367C_METER59_IFG_MASK    0x800
+#define    RTL8367C_METER58_IFG_OFFSET    10
+#define    RTL8367C_METER58_IFG_MASK    0x400
+#define    RTL8367C_METER57_IFG_OFFSET    9
+#define    RTL8367C_METER57_IFG_MASK    0x200
+#define    RTL8367C_METER56_IFG_OFFSET    8
+#define    RTL8367C_METER56_IFG_MASK    0x100
+#define    RTL8367C_METER55_IFG_OFFSET    7
+#define    RTL8367C_METER55_IFG_MASK    0x80
+#define    RTL8367C_METER54_IFG_OFFSET    6
+#define    RTL8367C_METER54_IFG_MASK    0x40
+#define    RTL8367C_METER53_IFG_OFFSET    5
+#define    RTL8367C_METER53_IFG_MASK    0x20
+#define    RTL8367C_METER52_IFG_OFFSET    4
+#define    RTL8367C_METER52_IFG_MASK    0x10
+#define    RTL8367C_METER51_IFG_OFFSET    3
+#define    RTL8367C_METER51_IFG_MASK    0x8
+#define    RTL8367C_METER50_IFG_OFFSET    2
+#define    RTL8367C_METER50_IFG_MASK    0x4
+#define    RTL8367C_METER49_IFG_OFFSET    1
+#define    RTL8367C_METER49_IFG_MASK    0x2
+#define    RTL8367C_METER48_IFG_OFFSET    0
+#define    RTL8367C_METER48_IFG_MASK    0x1
+
+#define    RTL8367C_REG_METER_MISC    0x17b6
+#define    RTL8367C_METER_MISC_OFFSET    0
+#define    RTL8367C_METER_MISC_MASK    0x1
+
+/* (16'h1800)8051_RLDP_EEE_reg */
+
+#define    RTL8367C_REG_EEELLDP_CTRL0    0x1820
+#define    RTL8367C_EEELLDP_SUBTYPE_OFFSET    6
+#define    RTL8367C_EEELLDP_SUBTYPE_MASK    0x3FC0
+#define    RTL8367C_EEELLDP_TRAP_8051_OFFSET    2
+#define    RTL8367C_EEELLDP_TRAP_8051_MASK    0x4
+#define    RTL8367C_EEELLDP_TRAP_CPU_OFFSET    1
+#define    RTL8367C_EEELLDP_TRAP_CPU_MASK    0x2
+#define    RTL8367C_EEELLDP_ENABLE_OFFSET    0
+#define    RTL8367C_EEELLDP_ENABLE_MASK    0x1
+
+#define    RTL8367C_REG_EEELLDP_PMSK    0x1822
+#define    RTL8367C_EEELLDP_PMSK_OFFSET    0
+#define    RTL8367C_EEELLDP_PMSK_MASK    0x7FF
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P00_08    0x1843
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P00_07    0x1844
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P00_06    0x1845
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P00_05    0x1846
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P00_04    0x1847
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P00_03    0x1848
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P00_02    0x1849
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P00_01    0x184a
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P00_00    0x184b
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P01_08    0x184c
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P01_07    0x184d
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P01_06    0x184e
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P01_05    0x184f
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P01_04    0x1850
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P01_03    0x1851
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P01_02    0x1852
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P01_01    0x1853
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P01_00    0x1854
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P02_08    0x1855
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P02_07    0x1856
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P02_06    0x1857
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P02_05    0x1858
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P02_04    0x1859
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P02_03    0x185a
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P02_02    0x185b
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P02_01    0x185c
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P02_00    0x185d
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P03_08    0x185e
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P03_07    0x185f
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P03_06    0x1860
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P03_05    0x1861
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P03_04    0x1862
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P03_03    0x1863
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P03_02    0x1864
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P03_01    0x1865
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P03_00    0x1866
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P04_08    0x1867
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P04_07    0x1868
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P04_06    0x1869
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P04_05    0x186a
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P04_04    0x186b
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P04_03    0x186c
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P04_02    0x186d
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P04_01    0x186e
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P04_00    0x186f
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P05_08    0x1870
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P05_07    0x1871
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P05_06    0x1872
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P05_05    0x1873
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P05_04    0x1874
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P05_03    0x1875
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P05_02    0x1876
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P05_01    0x1877
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P05_00    0x1878
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P06_08    0x1879
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P06_07    0x187a
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P06_06    0x187b
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P06_05    0x187c
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P06_04    0x187d
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P06_03    0x187e
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P06_02    0x187f
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P06_01    0x1880
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P06_00    0x1881
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P07_08    0x1882
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P07_07    0x1883
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P07_06    0x1884
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P07_05    0x1885
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P07_04    0x1886
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P07_03    0x1887
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P07_02    0x1888
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P07_01    0x1889
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P07_00    0x188a
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P08_08    0x188b
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P08_07    0x188c
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P08_06    0x188d
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P08_05    0x188e
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P08_04    0x188f
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P08_03    0x1890
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P08_02    0x1891
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P08_01    0x1892
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P08_00    0x1893
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P09_08    0x1894
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P09_07    0x1895
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P09_06    0x1896
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P09_05    0x1897
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P09_04    0x1898
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P09_03    0x1899
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P09_02    0x189a
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P09_01    0x189b
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P09_00    0x189c
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P10_08    0x189d
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P10_07    0x189e
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P10_06    0x189f
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P10_05    0x18a0
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P10_04    0x18a1
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P10_03    0x18a2
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P10_02    0x18a3
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P10_01    0x18a4
+
+#define    RTL8367C_REG_EEELLDP_RX_VALUE_P10_00    0x18a5
+
+#define    RTL8367C_REG_RLDP_CTRL0    0x18e0
+#define    RTL8367C_RLDP_TRIGGER_MODE_OFFSET    14
+#define    RTL8367C_RLDP_TRIGGER_MODE_MASK    0x4000
+#define    RTL8367C_RLDP_8051_LOOP_PORTMSK_OFFSET    6
+#define    RTL8367C_RLDP_8051_LOOP_PORTMSK_MASK    0x3FC0
+#define    RTL8367C_RLPP_8051_TRAP_OFFSET    5
+#define    RTL8367C_RLPP_8051_TRAP_MASK    0x20
+#define    RTL8367C_RLDP_INDICATOR_SOURCE_OFFSET    4
+#define    RTL8367C_RLDP_INDICATOR_SOURCE_MASK    0x10
+#define    RTL8367C_RLDP_GEN_RANDOM_OFFSET    3
+#define    RTL8367C_RLDP_GEN_RANDOM_MASK    0x8
+#define    RTL8367C_RLDP_COMP_ID_OFFSET    2
+#define    RTL8367C_RLDP_COMP_ID_MASK    0x4
+#define    RTL8367C_RLDP_8051_ENABLE_OFFSET    1
+#define    RTL8367C_RLDP_8051_ENABLE_MASK    0x2
+#define    RTL8367C_RLDP_ENABLE_OFFSET    0
+#define    RTL8367C_RLDP_ENABLE_MASK    0x1
+
+#define    RTL8367C_REG_RLDP_CTRL1    0x18e1
+#define    RTL8367C_RLDP_RETRY_COUNT_LOOPSTATE_OFFSET    8
+#define    RTL8367C_RLDP_RETRY_COUNT_LOOPSTATE_MASK    0xFF00
+#define    RTL8367C_RLDP_RETRY_COUNT_CHKSTATE_OFFSET    0
+#define    RTL8367C_RLDP_RETRY_COUNT_CHKSTATE_MASK    0xFF
+
+#define    RTL8367C_REG_RLDP_CTRL2    0x18e2
+
+#define    RTL8367C_REG_RLDP_CTRL3    0x18e3
+
+#define    RTL8367C_REG_RLDP_CTRL4    0x18e4
+#define    RTL8367C_RLDP_CTRL4_OFFSET    0
+#define    RTL8367C_RLDP_CTRL4_MASK    0x7FF
+
+#define    RTL8367C_REG_RLDP_RAND_NUM0    0x18e5
+
+#define    RTL8367C_REG_RLDP_RAND_NUM1    0x18e6
+
+#define    RTL8367C_REG_RLDP_RAND_NUM2    0x18e7
+
+#define    RTL8367C_REG_RLDP_MAGIC_NUM0    0x18e8
+
+#define    RTL8367C_REG_RLDP_MAGIC_NUM1    0x18e9
+
+#define    RTL8367C_REG_RLDP_MAGIC_NUM2    0x18ea
+
+#define    RTL8367C_REG_RLDP_LOOPED_INDICATOR    0x18eb
+#define    RTL8367C_RLDP_LOOPED_INDICATOR_OFFSET    0
+#define    RTL8367C_RLDP_LOOPED_INDICATOR_MASK    0x7FF
+
+#define    RTL8367C_REG_RLDP_LOOP_PORT_REG0    0x18ec
+#define    RTL8367C_RLDP_LOOP_PORT_01_OFFSET    8
+#define    RTL8367C_RLDP_LOOP_PORT_01_MASK    0xF00
+#define    RTL8367C_RLDP_LOOP_PORT_00_OFFSET    0
+#define    RTL8367C_RLDP_LOOP_PORT_00_MASK    0xF
+
+#define    RTL8367C_REG_RLDP_LOOP_PORT_REG1    0x18ed
+#define    RTL8367C_RLDP_LOOP_PORT_03_OFFSET    8
+#define    RTL8367C_RLDP_LOOP_PORT_03_MASK    0xF00
+#define    RTL8367C_RLDP_LOOP_PORT_02_OFFSET    0
+#define    RTL8367C_RLDP_LOOP_PORT_02_MASK    0xF
+
+#define    RTL8367C_REG_RLDP_LOOP_PORT_REG2    0x18ee
+#define    RTL8367C_RLDP_LOOP_PORT_05_OFFSET    8
+#define    RTL8367C_RLDP_LOOP_PORT_05_MASK    0xF00
+#define    RTL8367C_RLDP_LOOP_PORT_04_OFFSET    0
+#define    RTL8367C_RLDP_LOOP_PORT_04_MASK    0xF
+
+#define    RTL8367C_REG_RLDP_LOOP_PORT_REG3    0x18ef
+#define    RTL8367C_RLDP_LOOP_PORT_07_OFFSET    8
+#define    RTL8367C_RLDP_LOOP_PORT_07_MASK    0xF00
+#define    RTL8367C_RLDP_LOOP_PORT_06_OFFSET    0
+#define    RTL8367C_RLDP_LOOP_PORT_06_MASK    0xF
+
+#define    RTL8367C_REG_RLDP_RELEASED_INDICATOR    0x18f0
+#define    RTL8367C_RLDP_RELEASED_INDICATOR_OFFSET    0
+#define    RTL8367C_RLDP_RELEASED_INDICATOR_MASK    0x7FF
+
+#define    RTL8367C_REG_RLDP_LOOPSTATUS_INDICATOR    0x18f1
+#define    RTL8367C_RLDP_LOOPSTATUS_INDICATOR_OFFSET    0
+#define    RTL8367C_RLDP_LOOPSTATUS_INDICATOR_MASK    0x7FF
+
+#define    RTL8367C_REG_RLDP_LOOP_PORT_REG4    0x18f2
+#define    RTL8367C_RLDP_LOOP_PORT_9_OFFSET    8
+#define    RTL8367C_RLDP_LOOP_PORT_9_MASK    0xF00
+#define    RTL8367C_RLDP_LOOP_PORT_8_OFFSET    0
+#define    RTL8367C_RLDP_LOOP_PORT_8_MASK    0xF
+
+#define    RTL8367C_REG_RLDP_LOOP_PORT_REG5    0x18f3
+#define    RTL8367C_RLDP_LOOP_PORT_REG5_OFFSET    0
+#define    RTL8367C_RLDP_LOOP_PORT_REG5_MASK    0xF
+
+#define    RTL8367C_REG_RLDP_CTRL5    0x18f4
+#define    RTL8367C_RLDP_CTRL5_OFFSET    0
+#define    RTL8367C_RLDP_CTRL5_MASK    0x7
+
+/* (16'h1900)EEE_EEEP_reg */
+
+#define    RTL8367C_REG_EEE_500M_CTRL0    0x1900
+#define    RTL8367C_EEE_500M_CTRL0_OFFSET    0
+#define    RTL8367C_EEE_500M_CTRL0_MASK    0xFF
+
+#define    RTL8367C_REG_EEE_RXIDLE_GIGA_CTRL    0x1901
+#define    RTL8367C_EEE_RXIDLE_GIGA_EN_OFFSET    8
+#define    RTL8367C_EEE_RXIDLE_GIGA_EN_MASK    0x100
+#define    RTL8367C_EEE_RXIDLE_GIGA_OFFSET    0
+#define    RTL8367C_EEE_RXIDLE_GIGA_MASK    0xFF
+
+#define    RTL8367C_REG_EEE_RXIDLE_500M_CTRL    0x1902
+#define    RTL8367C_EEE_RXIDLE_500M_EN_OFFSET    8
+#define    RTL8367C_EEE_RXIDLE_500M_EN_MASK    0x100
+#define    RTL8367C_EEE_RXIDLE_500M_OFFSET    0
+#define    RTL8367C_EEE_RXIDLE_500M_MASK    0xFF
+
+#define    RTL8367C_REG_EEE_DECISION_GIGA_500M    0x1903
+#define    RTL8367C_EEE_DECISION_GIGA_OFFSET    8
+#define    RTL8367C_EEE_DECISION_GIGA_MASK    0xFF00
+#define    RTL8367C_EEE_DECISION_500M_OFFSET    0
+#define    RTL8367C_EEE_DECISION_500M_MASK    0xFF
+
+#define    RTL8367C_REG_EEE_DECISION_100M    0x1904
+#define    RTL8367C_EEE_DECISION_100M_OFFSET    0
+#define    RTL8367C_EEE_DECISION_100M_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_DEFER_TXLPI    0x1905
+#define    RTL8367C_EEEP_DEFER_TXLPI_OFFSET    0
+#define    RTL8367C_EEEP_DEFER_TXLPI_MASK    0x1
+
+#define    RTL8367C_REG_EEEP_EN    0x1906
+#define    RTL8367C_EEEP_SLAVE_EN_OFFSET    3
+#define    RTL8367C_EEEP_SLAVE_EN_MASK    0x8
+#define    RTL8367C_EEEP_100M_OFFSET    2
+#define    RTL8367C_EEEP_100M_MASK    0x4
+#define    RTL8367C_EEEP_500M_OFFSET    1
+#define    RTL8367C_EEEP_500M_MASK    0x2
+#define    RTL8367C_EEEP_GIGA_OFFSET    0
+#define    RTL8367C_EEEP_GIGA_MASK    0x1
+
+#define    RTL8367C_REG_EEEP_TI_GIGA_500M    0x1907
+#define    RTL8367C_EEEP_TI_GIGA_OFFSET    8
+#define    RTL8367C_EEEP_TI_GIGA_MASK    0xFF00
+#define    RTL8367C_EEEP_TI_500M_OFFSET    0
+#define    RTL8367C_EEEP_TI_500M_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_TI_100M    0x1908
+#define    RTL8367C_EEEP_TI_100M_OFFSET    0
+#define    RTL8367C_EEEP_TI_100M_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_CTRL2    0x1909
+#define    RTL8367C_EEEP_CTRL2_OFFSET    0
+#define    RTL8367C_EEEP_CTRL2_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_RX_RATE_500M    0x190b
+
+#define    RTL8367C_REG_EEEP_RW_GIGA_SLV    0x190c
+#define    RTL8367C_EEEP_RW_GIGA_SLV_OFFSET    0
+#define    RTL8367C_EEEP_RW_GIGA_SLV_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_TMR_GIGA    0x190d
+#define    RTL8367C_RX_IDLE_EEEP_GIGA_OFFSET    8
+#define    RTL8367C_RX_IDLE_EEEP_GIGA_MASK    0xFF00
+#define    RTL8367C_RX_MIN_SLP_TMR_GIGA_OFFSET    0
+#define    RTL8367C_RX_MIN_SLP_TMR_GIGA_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_TMR_500M    0x190e
+#define    RTL8367C_RX_IDLE_EEEP_500M_OFFSET    8
+#define    RTL8367C_RX_IDLE_EEEP_500M_MASK    0xFF00
+#define    RTL8367C_RX_MIN_SLP_TMR_500M_OFFSET    0
+#define    RTL8367C_RX_MIN_SLP_TMR_500M_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_TMR_100M    0x190f
+#define    RTL8367C_RX_IDLE_EEEP_100M_OFFSET    8
+#define    RTL8367C_RX_IDLE_EEEP_100M_MASK    0xFF00
+#define    RTL8367C_RX_MIN_SLP_TMR_100M_OFFSET    0
+#define    RTL8367C_RX_MIN_SLP_TMR_100M_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_RW_500M_MST_SLV    0x1910
+#define    RTL8367C_EEEP_RW_500M_MST_OFFSET    8
+#define    RTL8367C_EEEP_RW_500M_MST_MASK    0xFF00
+#define    RTL8367C_EEEP_RW_500M_SLV_OFFSET    0
+#define    RTL8367C_EEEP_RW_500M_SLV_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_500M_CTRL0    0x1911
+#define    RTL8367C_EEEP_500M_CTRL0_OFFSET    0
+#define    RTL8367C_EEEP_500M_CTRL0_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_500M_CTRL1    0x1912
+#define    RTL8367C_EEEP_TW_500M_OFFSET    8
+#define    RTL8367C_EEEP_TW_500M_MASK    0xFF00
+#define    RTL8367C_EEEP_TP_500M_OFFSET    0
+#define    RTL8367C_EEEP_TP_500M_MASK    0xFF
+
+#define    RTL8367C_REG_EEEP_500M_CTRL2    0x1913
+#define    RTL8367C_EEEP_TXEN_500M_OFFSET    12
+#define    RTL8367C_EEEP_TXEN_500M_MASK    0x1000
+#define    RTL8367C_EEEP_TU_500M_OFFSET    8
+#define    RTL8367C_EEEP_TU_500M_MASK    0x300
+#define    RTL8367C_EEEP_TS_500M_OFFSET    0
+#define    RTL8367C_EEEP_TS_500M_MASK    0xFF
+
+#define    RTL8367C_REG_EEE_NEW_CTRL0    0x1914
+#define    RTL8367C_LINK_UP_DELAY_OFFSET    3
+#define    RTL8367C_LINK_UP_DELAY_MASK    0x18
+#define    RTL8367C_EEE_TXLPI_ORI_OFFSET    2
+#define    RTL8367C_EEE_TXLPI_ORI_MASK    0x4
+#define    RTL8367C_REALTX_SEL_OFFSET    1
+#define    RTL8367C_REALTX_SEL_MASK    0x2
+#define    RTL8367C_EN_FC_EFCT_OFFSET    0
+#define    RTL8367C_EN_FC_EFCT_MASK    0x1
+
+#define    RTL8367C_REG_EEE_LONGIDLE_100M    0x1915
+#define    RTL8367C_EEE_LONGIDLE_100M_OFFSET    0
+#define    RTL8367C_EEE_LONGIDLE_100M_MASK    0x3FF
+
+#define    RTL8367C_REG_EEE_LONGIDLE_500M    0x1916
+#define    RTL8367C_EEE_LONGIDLE_500M_OFFSET    0
+#define    RTL8367C_EEE_LONGIDLE_500M_MASK    0x3FF
+
+#define    RTL8367C_REG_EEE_LONGIDLE_GIGA    0x1917
+#define    RTL8367C_EEE_LONGIDLE_GIGA_OFFSET    0
+#define    RTL8367C_EEE_LONGIDLE_GIGA_MASK    0x3FF
+
+#define    RTL8367C_REG_EEE_MINIPG_100M    0x1918
+
+#define    RTL8367C_REG_EEE_MINIPG_500M    0x1919
+
+#define    RTL8367C_REG_EEE_MINIPG_GIGA    0x191A
+
+#define    RTL8367C_REG_EEE_LONGIDLE_CTRL0    0x191B
+#define    RTL8367C_TX_IDLEN_REQ_100M_OFFSET    10
+#define    RTL8367C_TX_IDLEN_REQ_100M_MASK    0x400
+#define    RTL8367C_TX_IDLEN_REQ_500M_OFFSET    9
+#define    RTL8367C_TX_IDLEN_REQ_500M_MASK    0x200
+#define    RTL8367C_TX_IDLEN_REQ_GIGA_OFFSET    8
+#define    RTL8367C_TX_IDLEN_REQ_GIGA_MASK    0x100
+#define    RTL8367C_EEE_LONGIDLE_CTRL0_TX_LPI_MINIPG_100M_OFFSET    0
+#define    RTL8367C_EEE_LONGIDLE_CTRL0_TX_LPI_MINIPG_100M_MASK    0xFF
+
+#define    RTL8367C_REG_EEE_LONGIDLE_CTRL1    0x191C
+#define    RTL8367C_EEE_LONGIDLE_CTRL1_TX_LPI_MINIPG_GELITE_OFFSET    8
+#define    RTL8367C_EEE_LONGIDLE_CTRL1_TX_LPI_MINIPG_GELITE_MASK    0xFF00
+#define    RTL8367C_EEE_LONGIDLE_CTRL1_TX_LPI_MINIPG_GIGA_OFFSET    0
+#define    RTL8367C_EEE_LONGIDLE_CTRL1_TX_LPI_MINIPG_GIGA_MASK    0xFF
+
+#define    RTL8367C_REG_EEE_TD_CTRL_H    0x191d
+#define    RTL8367C_REF_RXLPI_OFFSET    8
+#define    RTL8367C_REF_RXLPI_MASK    0x100
+#define    RTL8367C_LOW_Q_TX_DELAY_GE_500M_H_OFFSET    4
+#define    RTL8367C_LOW_Q_TX_DELAY_GE_500M_H_MASK    0xF0
+#define    RTL8367C_LOW_Q_TX_DELAY_FE_H_OFFSET    0
+#define    RTL8367C_LOW_Q_TX_DELAY_FE_H_MASK    0xF
+
+/* (16'h1a00)nic_reg */
+
+#define    RTL8367C_REG_NIC_RXRDRL    0x1a04
+#define    RTL8367C_NIC_RXRDRL_OFFSET    0
+#define    RTL8367C_NIC_RXRDRL_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_RXRDRH    0x1a05
+#define    RTL8367C_NIC_RXRDRH_OFFSET    0
+#define    RTL8367C_NIC_RXRDRH_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_TXASRL    0x1a08
+#define    RTL8367C_NIC_TXASRL_OFFSET    0
+#define    RTL8367C_NIC_TXASRL_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_TXASRH    0x1a09
+#define    RTL8367C_NIC_TXASRH_OFFSET    0
+#define    RTL8367C_NIC_TXASRH_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_RXCMDR    0x1a0c
+#define    RTL8367C_NIC_RXCMDR_OFFSET    0
+#define    RTL8367C_NIC_RXCMDR_MASK    0x1
+
+#define    RTL8367C_REG_NIC_TXCMDR    0x1a0d
+#define    RTL8367C_NIC_TXCMDR_OFFSET    0
+#define    RTL8367C_NIC_TXCMDR_MASK    0x1
+
+#define    RTL8367C_REG_NIC_IMS    0x1a0e
+#define    RTL8367C_NIC_RXIS_OFFSET    7
+#define    RTL8367C_NIC_RXIS_MASK    0x80
+#define    RTL8367C_NIC_TXIS_OFFSET    6
+#define    RTL8367C_NIC_TXIS_MASK    0x40
+#define    RTL8367C_NIC_TXES_OFFSET    5
+#define    RTL8367C_NIC_TXES_MASK    0x20
+#define    RTL8367C_NIC_IMS_DMY_OFFSET    4
+#define    RTL8367C_NIC_IMS_DMY_MASK    0x10
+#define    RTL8367C_NIC_RXBUS_OFFSET    3
+#define    RTL8367C_NIC_RXBUS_MASK    0x8
+#define    RTL8367C_NIC_TXBOS_OFFSET    2
+#define    RTL8367C_NIC_TXBOS_MASK    0x4
+#define    RTL8367C_NIC_RXMIS_OFFSET    1
+#define    RTL8367C_NIC_RXMIS_MASK    0x2
+#define    RTL8367C_NIC_TXNLS_OFFSET    0
+#define    RTL8367C_NIC_TXNLS_MASK    0x1
+
+#define    RTL8367C_REG_NIC_IMR    0x1a0f
+#define    RTL8367C_NIC_RXIE_OFFSET    7
+#define    RTL8367C_NIC_RXIE_MASK    0x80
+#define    RTL8367C_NIC_TXIE_OFFSET    6
+#define    RTL8367C_NIC_TXIE_MASK    0x40
+#define    RTL8367C_NIC_TXEE_OFFSET    5
+#define    RTL8367C_NIC_TXEE_MASK    0x20
+#define    RTL8367C_NIC_IMR_DMY_OFFSET    4
+#define    RTL8367C_NIC_IMR_DMY_MASK    0x10
+#define    RTL8367C_NIC_RXBUE_OFFSET    3
+#define    RTL8367C_NIC_RXBUE_MASK    0x8
+#define    RTL8367C_NIC_TXBOE_OFFSET    2
+#define    RTL8367C_NIC_TXBOE_MASK    0x4
+#define    RTL8367C_NIC_RXMIE_OFFSET    1
+#define    RTL8367C_NIC_RXMIE_MASK    0x2
+#define    RTL8367C_NIC_TXNLE_OFFSET    0
+#define    RTL8367C_NIC_TXNLE_MASK    0x1
+
+#define    RTL8367C_REG_NIC_RXCR0    0x1a14
+#define    RTL8367C_NIC_HFPPE_OFFSET    7
+#define    RTL8367C_NIC_HFPPE_MASK    0x80
+#define    RTL8367C_NIC_HFMPE_OFFSET    6
+#define    RTL8367C_NIC_HFMPE_MASK    0x40
+#define    RTL8367C_NIC_RXBPE_OFFSET    5
+#define    RTL8367C_NIC_RXBPE_MASK    0x20
+#define    RTL8367C_NIC_RXMPE_OFFSET    4
+#define    RTL8367C_NIC_RXMPE_MASK    0x10
+#define    RTL8367C_NIC_RXPPS_OFFSET    2
+#define    RTL8367C_NIC_RXPPS_MASK    0xC
+#define    RTL8367C_NIC_RXAPE_OFFSET    1
+#define    RTL8367C_NIC_RXAPE_MASK    0x2
+#define    RTL8367C_NIC_ARPPE_OFFSET    0
+#define    RTL8367C_NIC_ARPPE_MASK    0x1
+
+#define    RTL8367C_REG_NIC_RXCR1    0x1a15
+#define    RTL8367C_NIC_RL4CEPE_OFFSET    4
+#define    RTL8367C_NIC_RL4CEPE_MASK    0x10
+#define    RTL8367C_NIC_RL3CEPE_OFFSET    3
+#define    RTL8367C_NIC_RL3CEPE_MASK    0x8
+#define    RTL8367C_NIC_RCRCEPE_OFFSET    2
+#define    RTL8367C_NIC_RCRCEPE_MASK    0x4
+#define    RTL8367C_NIC_RMCRC_OFFSET    1
+#define    RTL8367C_NIC_RMCRC_MASK    0x2
+#define    RTL8367C_NIC_RXENABLE_OFFSET    0
+#define    RTL8367C_NIC_RXENABLE_MASK    0x1
+
+#define    RTL8367C_REG_NIC_TXCR    0x1a16
+#define    RTL8367C_NIC_LBE_OFFSET    2
+#define    RTL8367C_NIC_LBE_MASK    0x4
+#define    RTL8367C_NIC_TXMFM_OFFSET    1
+#define    RTL8367C_NIC_TXMFM_MASK    0x2
+#define    RTL8367C_NIC_TXENABLE_OFFSET    0
+#define    RTL8367C_NIC_TXENABLE_MASK    0x1
+
+#define    RTL8367C_REG_NIC_GCR    0x1a17
+#define    RTL8367C_DUMMY_7_6_OFFSET    6
+#define    RTL8367C_DUMMY_7_6_MASK    0xC0
+#define    RTL8367C_NIC_RXMTU_OFFSET    4
+#define    RTL8367C_NIC_RXMTU_MASK    0x30
+#define    RTL8367C_NIC_GCR_DUMMY_0_OFFSET    0
+#define    RTL8367C_NIC_GCR_DUMMY_0_MASK    0x1
+
+#define    RTL8367C_REG_NIC_MHR0    0x1a24
+#define    RTL8367C_NIC_MHR0_OFFSET    0
+#define    RTL8367C_NIC_MHR0_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_MHR1    0x1a25
+#define    RTL8367C_NIC_MHR1_OFFSET    0
+#define    RTL8367C_NIC_MHR1_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_MHR2    0x1a26
+#define    RTL8367C_NIC_MHR2_OFFSET    0
+#define    RTL8367C_NIC_MHR2_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_MHR3    0x1a27
+#define    RTL8367C_NIC_MHR3_OFFSET    0
+#define    RTL8367C_NIC_MHR3_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_MHR4    0x1a28
+#define    RTL8367C_NIC_MHR4_OFFSET    0
+#define    RTL8367C_NIC_MHR4_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_MHR5    0x1a29
+#define    RTL8367C_NIC_MHR5_OFFSET    0
+#define    RTL8367C_NIC_MHR5_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_MHR6    0x1a2a
+#define    RTL8367C_NIC_MHR6_OFFSET    0
+#define    RTL8367C_NIC_MHR6_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_MHR7    0x1a2b
+#define    RTL8367C_NIC_MHR7_OFFSET    0
+#define    RTL8367C_NIC_MHR7_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_PAHR0    0x1a2c
+#define    RTL8367C_NIC_PAHR0_OFFSET    0
+#define    RTL8367C_NIC_PAHR0_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_PAHR1    0x1a2d
+#define    RTL8367C_NIC_PAHR1_OFFSET    0
+#define    RTL8367C_NIC_PAHR1_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_PAHR2    0x1a2e
+#define    RTL8367C_NIC_PAHR2_OFFSET    0
+#define    RTL8367C_NIC_PAHR2_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_PAHR3    0x1a2f
+#define    RTL8367C_NIC_PAHR3_OFFSET    0
+#define    RTL8367C_NIC_PAHR3_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_PAHR4    0x1a30
+#define    RTL8367C_NIC_PAHR4_OFFSET    0
+#define    RTL8367C_NIC_PAHR4_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_PAHR5    0x1a31
+#define    RTL8367C_NIC_PAHR5_OFFSET    0
+#define    RTL8367C_NIC_PAHR5_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_PAHR6    0x1a32
+#define    RTL8367C_NIC_PAHR6_OFFSET    0
+#define    RTL8367C_NIC_PAHR6_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_PAHR7    0x1a33
+#define    RTL8367C_NIC_PAHR7_OFFSET    0
+#define    RTL8367C_NIC_PAHR7_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_TXSTOPRL    0x1a44
+#define    RTL8367C_NIC_TXSTOPRL_OFFSET    0
+#define    RTL8367C_NIC_TXSTOPRL_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_TXSTOPRH    0x1a45
+#define    RTL8367C_NIC_TXSTOPRH_OFFSET    0
+#define    RTL8367C_NIC_TXSTOPRH_MASK    0x3
+
+#define    RTL8367C_REG_NIC_RXSTOPRL    0x1a46
+#define    RTL8367C_NIC_RXSTOPRL_OFFSET    0
+#define    RTL8367C_NIC_RXSTOPRL_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_RXSTOPRH    0x1a47
+#define    RTL8367C_NIC_RXSTOPRH_OFFSET    0
+#define    RTL8367C_NIC_RXSTOPRH_MASK    0x3
+
+#define    RTL8367C_REG_NIC_RXFSTR    0x1a48
+#define    RTL8367C_NIC_RXFSTR_OFFSET    0
+#define    RTL8367C_NIC_RXFSTR_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_RXMBTRL    0x1a4c
+#define    RTL8367C_NIC_RXMBTRL_OFFSET    0
+#define    RTL8367C_NIC_RXMBTRL_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_RXMBTRH    0x1a4d
+#define    RTL8367C_NIC_RXMBTRH_OFFSET    0
+#define    RTL8367C_NIC_RXMBTRH_MASK    0x7F
+
+#define    RTL8367C_REG_NIC_RXMPTR    0x1a4e
+#define    RTL8367C_NIC_RXMPTR_OFFSET    0
+#define    RTL8367C_NIC_RXMPTR_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_T0TR    0x1a4f
+#define    RTL8367C_NIC_T0TR_OFFSET    0
+#define    RTL8367C_NIC_T0TR_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_CRXCPRL    0x1a50
+#define    RTL8367C_NIC_CRXCPRL_OFFSET    0
+#define    RTL8367C_NIC_CRXCPRL_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_CRXCPRH    0x1a51
+#define    RTL8367C_NIC_CRXCPRH_OFFSET    0
+#define    RTL8367C_NIC_CRXCPRH_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_CTXCPRL    0x1a52
+#define    RTL8367C_NIC_CTXCPRL_OFFSET    0
+#define    RTL8367C_NIC_CTXCPRL_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_CTXPCRH    0x1a53
+#define    RTL8367C_NIC_CTXPCRH_OFFSET    0
+#define    RTL8367C_NIC_CTXPCRH_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_SRXCURPKTRL    0x1a54
+#define    RTL8367C_NIC_SRXCURPKTRL_OFFSET    0
+#define    RTL8367C_NIC_SRXCURPKTRL_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_SRXCURPKTRH    0x1a55
+#define    RTL8367C_NIC_SRXCURPKTRH_OFFSET    0
+#define    RTL8367C_NIC_SRXCURPKTRH_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_STXCURPKTRL    0x1a56
+#define    RTL8367C_NIC_STXCURPKTRL_OFFSET    0
+#define    RTL8367C_NIC_STXCURPKTRL_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_STXCURPKTRH    0x1a57
+#define    RTL8367C_NIC_STXCURPKTRH_OFFSET    0
+#define    RTL8367C_NIC_STXCURPKTRH_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_STXPKTLENRL    0x1a58
+#define    RTL8367C_NIC_STXPKTLENRL_OFFSET    0
+#define    RTL8367C_NIC_STXPKTLENRL_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_STXPKTLENRH    0x1a59
+#define    RTL8367C_NIC_STXPKTLENRH_OFFSET    0
+#define    RTL8367C_NIC_STXPKTLENRH_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_STXCURUNITRL    0x1a5a
+#define    RTL8367C_NIC_STXCURUNITRL_OFFSET    0
+#define    RTL8367C_NIC_STXCURUNITRL_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_STXCURUNITRH    0x1a5b
+#define    RTL8367C_NIC_STXCURUNITRH_OFFSET    0
+#define    RTL8367C_NIC_STXCURUNITRH_MASK    0xFF
+
+#define    RTL8367C_REG_NIC_DROP_MODE    0x1a5c
+#define    RTL8367C_NIC_RXDV_MODE_OFFSET    1
+#define    RTL8367C_NIC_RXDV_MODE_MASK    0x2
+#define    RTL8367C_NIC_DROP_MODE_OFFSET    0
+#define    RTL8367C_NIC_DROP_MODE_MASK    0x1
+
+/* (16'h1b00)LED */
+
+#define    RTL8367C_REG_LED_SYS_CONFIG    0x1b00
+#define    RTL8367C_LED_SYS_CONFIG_DUMMY_15_OFFSET    15
+#define    RTL8367C_LED_SYS_CONFIG_DUMMY_15_MASK    0x8000
+#define    RTL8367C_LED_SERIAL_OUT_MODE_OFFSET    14
+#define    RTL8367C_LED_SERIAL_OUT_MODE_MASK    0x4000
+#define    RTL8367C_LED_EEE_LPI_MODE_OFFSET    13
+#define    RTL8367C_LED_EEE_LPI_MODE_MASK    0x2000
+#define    RTL8367C_LED_EEE_LPI_EN_OFFSET    12
+#define    RTL8367C_LED_EEE_LPI_EN_MASK    0x1000
+#define    RTL8367C_LED_EEE_LPI_10_OFFSET    11
+#define    RTL8367C_LED_EEE_LPI_10_MASK    0x800
+#define    RTL8367C_LED_EEE_CAP_10_OFFSET    10
+#define    RTL8367C_LED_EEE_CAP_10_MASK    0x400
+#define    RTL8367C_LED_LPI_SEL_OFFSET    8
+#define    RTL8367C_LED_LPI_SEL_MASK    0x300
+#define    RTL8367C_SERI_LED_ACT_LOW_OFFSET    7
+#define    RTL8367C_SERI_LED_ACT_LOW_MASK    0x80
+#define    RTL8367C_LED_POWERON_2_OFFSET    6
+#define    RTL8367C_LED_POWERON_2_MASK    0x40
+#define    RTL8367C_LED_POWERON_1_OFFSET    5
+#define    RTL8367C_LED_POWERON_1_MASK    0x20
+#define    RTL8367C_LED_POWERON_0_OFFSET    4
+#define    RTL8367C_LED_POWERON_0_MASK    0x10
+#define    RTL8367C_LED_IO_DISABLE_OFFSET    3
+#define    RTL8367C_LED_IO_DISABLE_MASK    0x8
+#define    RTL8367C_DUMMY_2_2_OFFSET    2
+#define    RTL8367C_DUMMY_2_2_MASK    0x4
+#define    RTL8367C_LED_SELECT_OFFSET    0
+#define    RTL8367C_LED_SELECT_MASK    0x3
+
+#define    RTL8367C_REG_LED_SYS_CONFIG2    0x1b01
+#define    RTL8367C_LED_SYS_CONFIG2_DUMMY_OFFSET    2
+#define    RTL8367C_LED_SYS_CONFIG2_DUMMY_MASK    0xFFFC
+#define    RTL8367C_GATE_LPTD_BYPASS_OFFSET    1
+#define    RTL8367C_GATE_LPTD_BYPASS_MASK    0x2
+#define    RTL8367C_LED_SPD_MODE_OFFSET    0
+#define    RTL8367C_LED_SPD_MODE_MASK    0x1
+
+#define    RTL8367C_REG_LED_MODE    0x1b02
+#define    RTL8367C_DLINK_TIME_OFFSET    15
+#define    RTL8367C_DLINK_TIME_MASK    0x8000
+#define    RTL8367C_LED_BUZZ_DUTY_OFFSET    14
+#define    RTL8367C_LED_BUZZ_DUTY_MASK    0x4000
+#define    RTL8367C_BUZZER_RATE_OFFSET    12
+#define    RTL8367C_BUZZER_RATE_MASK    0x3000
+#define    RTL8367C_LOOP_DETECT_MODE_OFFSET    11
+#define    RTL8367C_LOOP_DETECT_MODE_MASK    0x800
+#define    RTL8367C_SEL_PWRON_TIME_OFFSET    9
+#define    RTL8367C_SEL_PWRON_TIME_MASK    0x600
+#define    RTL8367C_EN_DLINK_LED_OFFSET    8
+#define    RTL8367C_EN_DLINK_LED_MASK    0x100
+#define    RTL8367C_LOOP_DETECT_RATE_OFFSET    6
+#define    RTL8367C_LOOP_DETECT_RATE_MASK    0xC0
+#define    RTL8367C_FORCE_RATE_OFFSET    4
+#define    RTL8367C_FORCE_RATE_MASK    0x30
+#define    RTL8367C_SEL_LEDRATE_OFFSET    1
+#define    RTL8367C_SEL_LEDRATE_MASK    0xE
+#define    RTL8367C_SPEED_UP_OFFSET    0
+#define    RTL8367C_SPEED_UP_MASK    0x1
+
+#define    RTL8367C_REG_LED_CONFIGURATION    0x1b03
+#define    RTL8367C_LED_CONFIGURATION_DUMMY_OFFSET    15
+#define    RTL8367C_LED_CONFIGURATION_DUMMY_MASK    0x8000
+#define    RTL8367C_LED_CONFIG_SEL_OFFSET    14
+#define    RTL8367C_LED_CONFIG_SEL_MASK    0x4000
+#define    RTL8367C_DATA_LED_OFFSET    12
+#define    RTL8367C_DATA_LED_MASK    0x3000
+#define    RTL8367C_LED2_CFG_OFFSET    8
+#define    RTL8367C_LED2_CFG_MASK    0xF00
+#define    RTL8367C_LED1_CFG_OFFSET    4
+#define    RTL8367C_LED1_CFG_MASK    0xF0
+#define    RTL8367C_LED0_CFG_OFFSET    0
+#define    RTL8367C_LED0_CFG_MASK    0xF
+
+#define    RTL8367C_REG_RTCT_RESULTS_CFG    0x1b04
+#define    RTL8367C_RTCT_2PAIR_FTT_OFFSET    15
+#define    RTL8367C_RTCT_2PAIR_FTT_MASK    0x8000
+#define    RTL8367C_RTCT_2PAIR_MODE_OFFSET    14
+#define    RTL8367C_RTCT_2PAIR_MODE_MASK    0x4000
+#define    RTL8367C_BLINK_EN_OFFSET    13
+#define    RTL8367C_BLINK_EN_MASK    0x2000
+#define    RTL8367C_TIMEOUT_OFFSET    12
+#define    RTL8367C_TIMEOUT_MASK    0x1000
+#define    RTL8367C_EN_CD_SAME_SHORT_OFFSET    11
+#define    RTL8367C_EN_CD_SAME_SHORT_MASK    0x800
+#define    RTL8367C_EN_CD_SAME_OPEN_OFFSET    10
+#define    RTL8367C_EN_CD_SAME_OPEN_MASK    0x400
+#define    RTL8367C_EN_CD_SAME_LINEDRIVER_OFFSET    9
+#define    RTL8367C_EN_CD_SAME_LINEDRIVER_MASK    0x200
+#define    RTL8367C_EN_CD_SAME_MISMATCH_OFFSET    8
+#define    RTL8367C_EN_CD_SAME_MISMATCH_MASK    0x100
+#define    RTL8367C_EN_CD_SHORT_OFFSET    7
+#define    RTL8367C_EN_CD_SHORT_MASK    0x80
+#define    RTL8367C_EN_AB_SHORT_OFFSET    6
+#define    RTL8367C_EN_AB_SHORT_MASK    0x40
+#define    RTL8367C_EN_CD_OPEN_OFFSET    5
+#define    RTL8367C_EN_CD_OPEN_MASK    0x20
+#define    RTL8367C_EN_AB_OPEN_OFFSET    4
+#define    RTL8367C_EN_AB_OPEN_MASK    0x10
+#define    RTL8367C_EN_CD_MISMATCH_OFFSET    3
+#define    RTL8367C_EN_CD_MISMATCH_MASK    0x8
+#define    RTL8367C_EN_AB_MISMATCH_OFFSET    2
+#define    RTL8367C_EN_AB_MISMATCH_MASK    0x4
+#define    RTL8367C_EN_CD_LINEDRIVER_OFFSET    1
+#define    RTL8367C_EN_CD_LINEDRIVER_MASK    0x2
+#define    RTL8367C_EN_AB_LINEDRIVER_OFFSET    0
+#define    RTL8367C_EN_AB_LINEDRIVER_MASK    0x1
+
+#define    RTL8367C_REG_RTCT_LED    0x1b05
+#define    RTL8367C_DUMMY_1b05a_OFFSET    12
+#define    RTL8367C_DUMMY_1b05a_MASK    0xF000
+#define    RTL8367C_RTCT_LED2_OFFSET    8
+#define    RTL8367C_RTCT_LED2_MASK    0xF00
+#define    RTL8367C_RTCT_LED1_OFFSET    4
+#define    RTL8367C_RTCT_LED1_MASK    0xF0
+#define    RTL8367C_RTCT_LED0_OFFSET    0
+#define    RTL8367C_RTCT_LED0_MASK    0xF
+
+#define    RTL8367C_REG_CPU_FORCE_LED_CFG    0x1b07
+#define    RTL8367C_DUMMY_1b07a_OFFSET    8
+#define    RTL8367C_DUMMY_1b07a_MASK    0xFF00
+#define    RTL8367C_LED_FORCE_MODE_OFFSET    2
+#define    RTL8367C_LED_FORCE_MODE_MASK    0xFC
+#define    RTL8367C_FORCE_MODE_OFFSET    0
+#define    RTL8367C_FORCE_MODE_MASK    0x3
+
+#define    RTL8367C_REG_CPU_FORCE_LED0_CFG0    0x1b08
+#define    RTL8367C_PORT7_LED0_MODE_OFFSET    14
+#define    RTL8367C_PORT7_LED0_MODE_MASK    0xC000
+#define    RTL8367C_PORT6_LED0_MODE_OFFSET    12
+#define    RTL8367C_PORT6_LED0_MODE_MASK    0x3000
+#define    RTL8367C_PORT5_LED0_MODE_OFFSET    10
+#define    RTL8367C_PORT5_LED0_MODE_MASK    0xC00
+#define    RTL8367C_PORT4_LED0_MODE_OFFSET    8
+#define    RTL8367C_PORT4_LED0_MODE_MASK    0x300
+#define    RTL8367C_PORT3_LED0_MODE_OFFSET    6
+#define    RTL8367C_PORT3_LED0_MODE_MASK    0xC0
+#define    RTL8367C_PORT2_LED0_MODE_OFFSET    4
+#define    RTL8367C_PORT2_LED0_MODE_MASK    0x30
+#define    RTL8367C_PORT1_LED0_MODE_OFFSET    2
+#define    RTL8367C_PORT1_LED0_MODE_MASK    0xC
+#define    RTL8367C_PORT0_LED0_MODE_OFFSET    0
+#define    RTL8367C_PORT0_LED0_MODE_MASK    0x3
+
+#define    RTL8367C_REG_CPU_FORCE_LED0_CFG1    0x1b09
+#define    RTL8367C_DUMMY_1b09a_OFFSET    4
+#define    RTL8367C_DUMMY_1b09a_MASK    0xFFF0
+#define    RTL8367C_PORT9_LED0_MODE_OFFSET    2
+#define    RTL8367C_PORT9_LED0_MODE_MASK    0xC
+#define    RTL8367C_PORT8_LED0_MODE_OFFSET    0
+#define    RTL8367C_PORT8_LED0_MODE_MASK    0x3
+
+#define    RTL8367C_REG_CPU_FORCE_LED1_CFG0    0x1b0a
+#define    RTL8367C_PORT7_LED1_MODE_OFFSET    14
+#define    RTL8367C_PORT7_LED1_MODE_MASK    0xC000
+#define    RTL8367C_PORT6_LED1_MODE_OFFSET    12
+#define    RTL8367C_PORT6_LED1_MODE_MASK    0x3000
+#define    RTL8367C_PORT5_LED1_MODE_OFFSET    10
+#define    RTL8367C_PORT5_LED1_MODE_MASK    0xC00
+#define    RTL8367C_PORT4_LED1_MODE_OFFSET    8
+#define    RTL8367C_PORT4_LED1_MODE_MASK    0x300
+#define    RTL8367C_PORT3_LED1_MODE_OFFSET    6
+#define    RTL8367C_PORT3_LED1_MODE_MASK    0xC0
+#define    RTL8367C_PORT2_LED1_MODE_OFFSET    4
+#define    RTL8367C_PORT2_LED1_MODE_MASK    0x30
+#define    RTL8367C_PORT1_LED1_MODE_OFFSET    2
+#define    RTL8367C_PORT1_LED1_MODE_MASK    0xC
+#define    RTL8367C_PORT0_LED1_MODE_OFFSET    0
+#define    RTL8367C_PORT0_LED1_MODE_MASK    0x3
+
+#define    RTL8367C_REG_CPU_FORCE_LED1_CFG1    0x1b0b
+#define    RTL8367C_DUMMY_1b0ba_OFFSET    4
+#define    RTL8367C_DUMMY_1b0ba_MASK    0xFFF0
+#define    RTL8367C_PORT9_LED1_MODE_OFFSET    2
+#define    RTL8367C_PORT9_LED1_MODE_MASK    0xC
+#define    RTL8367C_PORT8_LED1_MODE_OFFSET    0
+#define    RTL8367C_PORT8_LED1_MODE_MASK    0x3
+
+#define    RTL8367C_REG_CPU_FORCE_LED2_CFG0    0x1b0c
+#define    RTL8367C_PORT7_LED2_MODE_OFFSET    14
+#define    RTL8367C_PORT7_LED2_MODE_MASK    0xC000
+#define    RTL8367C_PORT6_LED2_MODE_OFFSET    12
+#define    RTL8367C_PORT6_LED2_MODE_MASK    0x3000
+#define    RTL8367C_PORT5_LED2_MODE_OFFSET    10
+#define    RTL8367C_PORT5_LED2_MODE_MASK    0xC00
+#define    RTL8367C_PORT4_LED2_MODE_OFFSET    8
+#define    RTL8367C_PORT4_LED2_MODE_MASK    0x300
+#define    RTL8367C_PORT3_LED2_MODE_OFFSET    6
+#define    RTL8367C_PORT3_LED2_MODE_MASK    0xC0
+#define    RTL8367C_PORT2_LED2_MODE_OFFSET    4
+#define    RTL8367C_PORT2_LED2_MODE_MASK    0x30
+#define    RTL8367C_PORT1_LED2_MODE_OFFSET    2
+#define    RTL8367C_PORT1_LED2_MODE_MASK    0xC
+#define    RTL8367C_PORT0_LED2_MODE_OFFSET    0
+#define    RTL8367C_PORT0_LED2_MODE_MASK    0x3
+
+#define    RTL8367C_REG_CPU_FORCE_LED2_CFG1    0x1b0d
+#define    RTL8367C_DUMMY_1b0da_OFFSET    4
+#define    RTL8367C_DUMMY_1b0da_MASK    0xFFF0
+#define    RTL8367C_PORT9_LED2_MODE_OFFSET    2
+#define    RTL8367C_PORT9_LED2_MODE_MASK    0xC
+#define    RTL8367C_PORT8_LED2_MODE_OFFSET    0
+#define    RTL8367C_PORT8_LED2_MODE_MASK    0x3
+
+#define    RTL8367C_REG_LED_ACTIVE_LOW_CFG0    0x1b0e
+#define    RTL8367C_LED_ACTIVE_LOW_CFG0_DUMMY_15_OFFSET    15
+#define    RTL8367C_LED_ACTIVE_LOW_CFG0_DUMMY_15_MASK    0x8000
+#define    RTL8367C_PORT3_LED_ACTIVE_LOW_OFFSET    12
+#define    RTL8367C_PORT3_LED_ACTIVE_LOW_MASK    0x7000
+#define    RTL8367C_LED_ACTIVE_LOW_CFG0_DUMMY_11_OFFSET    11
+#define    RTL8367C_LED_ACTIVE_LOW_CFG0_DUMMY_11_MASK    0x800
+#define    RTL8367C_PORT2_LED_ACTIVE_LOW_OFFSET    8
+#define    RTL8367C_PORT2_LED_ACTIVE_LOW_MASK    0x700
+#define    RTL8367C_DUMMY_7_OFFSET    7
+#define    RTL8367C_DUMMY_7_MASK    0x80
+#define    RTL8367C_PORT1_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367C_PORT1_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367C_DUMMY_3_OFFSET    3
+#define    RTL8367C_DUMMY_3_MASK    0x8
+#define    RTL8367C_PORT0_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367C_PORT0_LED_ACTIVE_LOW_MASK    0x7
+
+#define    RTL8367C_REG_LED_ACTIVE_LOW_CFG1    0x1b0f
+#define    RTL8367C_LED_ACTIVE_LOW_CFG1_DUMMY_15_OFFSET    15
+#define    RTL8367C_LED_ACTIVE_LOW_CFG1_DUMMY_15_MASK    0x8000
+#define    RTL8367C_PORT7_LED_ACTIVE_LOW_OFFSET    12
+#define    RTL8367C_PORT7_LED_ACTIVE_LOW_MASK    0x7000
+#define    RTL8367C_LED_ACTIVE_LOW_CFG1_DUMMY_11_OFFSET    11
+#define    RTL8367C_LED_ACTIVE_LOW_CFG1_DUMMY_11_MASK    0x800
+#define    RTL8367C_PORT6_LED_ACTIVE_LOW_OFFSET    8
+#define    RTL8367C_PORT6_LED_ACTIVE_LOW_MASK    0x700
+#define    RTL8367C_DUMMY_1b0f_b_OFFSET    7
+#define    RTL8367C_DUMMY_1b0f_b_MASK    0x80
+#define    RTL8367C_PORT5_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367C_PORT5_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367C_DUMMY_1b0f_a_OFFSET    3
+#define    RTL8367C_DUMMY_1b0f_a_MASK    0x8
+#define    RTL8367C_PORT4_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367C_PORT4_LED_ACTIVE_LOW_MASK    0x7
+
+#define    RTL8367C_REG_LED_ACTIVE_LOW_CFG2    0x1b10
+#define    RTL8367C_DUMMY_1b10_b_OFFSET    7
+#define    RTL8367C_DUMMY_1b10_b_MASK    0xFF80
+#define    RTL8367C_PORT9_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367C_PORT9_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367C_DUMMY_1b10_a_OFFSET    3
+#define    RTL8367C_DUMMY_1b10_a_MASK    0x8
+#define    RTL8367C_PORT8_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367C_PORT8_LED_ACTIVE_LOW_MASK    0x7
+
+#define    RTL8367C_REG_SEL_RTCT_PARA    0x1b21
+#define    RTL8367C_DO_RTCT_COMMAND_OFFSET    15
+#define    RTL8367C_DO_RTCT_COMMAND_MASK    0x8000
+#define    RTL8367C_SEL_RTCT_PARA_DUMMY_OFFSET    12
+#define    RTL8367C_SEL_RTCT_PARA_DUMMY_MASK    0x7000
+#define    RTL8367C_SEL_RTCT_RLSTLED_TIME_OFFSET    10
+#define    RTL8367C_SEL_RTCT_RLSTLED_TIME_MASK    0xC00
+#define    RTL8367C_SEL_RTCT_TEST_LED_TIME_OFFSET    8
+#define    RTL8367C_SEL_RTCT_TEST_LED_TIME_MASK    0x300
+#define    RTL8367C_EN_SCAN_RTCT_OFFSET    7
+#define    RTL8367C_EN_SCAN_RTCT_MASK    0x80
+#define    RTL8367C_EN_RTCT_TIMOUT_OFFSET    6
+#define    RTL8367C_EN_RTCT_TIMOUT_MASK    0x40
+#define    RTL8367C_EN_ALL_RTCT_OFFSET    5
+#define    RTL8367C_EN_ALL_RTCT_MASK    0x20
+#define    RTL8367C_SEL_RTCT_PLE_WID_OFFSET    0
+#define    RTL8367C_SEL_RTCT_PLE_WID_MASK    0x1F
+
+#define    RTL8367C_REG_RTCT_ENABLE    0x1b22
+#define    RTL8367C_RTCT_ENABLE_DUMMY_OFFSET    8
+#define    RTL8367C_RTCT_ENABLE_DUMMY_MASK    0xFF00
+#define    RTL8367C_RTCT_ENABLE_PORT_MASK_OFFSET    0
+#define    RTL8367C_RTCT_ENABLE_PORT_MASK_MASK    0xFF
+
+#define    RTL8367C_REG_RTCT_TIMEOUT    0x1b23
+
+#define    RTL8367C_REG_PARA_LED_IO_EN1    0x1b24
+#define    RTL8367C_LED1_PARA_P07_00_OFFSET    8
+#define    RTL8367C_LED1_PARA_P07_00_MASK    0xFF00
+#define    RTL8367C_LED0_PARA_P07_00_OFFSET    0
+#define    RTL8367C_LED0_PARA_P07_00_MASK    0xFF
+
+#define    RTL8367C_REG_PARA_LED_IO_EN2    0x1b25
+#define    RTL8367C_DUMMY_15_8_OFFSET    8
+#define    RTL8367C_DUMMY_15_8_MASK    0xFF00
+#define    RTL8367C_LED2_PARA_P07_00_OFFSET    0
+#define    RTL8367C_LED2_PARA_P07_00_MASK    0xFF
+
+#define    RTL8367C_REG_SCAN0_LED_IO_EN1    0x1b26
+#define    RTL8367C_SCAN0_LED_IO_EN1_DUMMY_OFFSET    3
+#define    RTL8367C_SCAN0_LED_IO_EN1_DUMMY_MASK    0xFFF8
+#define    RTL8367C_LED_LOOP_DET_BUZZER_EN_OFFSET    2
+#define    RTL8367C_LED_LOOP_DET_BUZZER_EN_MASK    0x4
+#define    RTL8367C_LED_SERI_DATA_EN_OFFSET    1
+#define    RTL8367C_LED_SERI_DATA_EN_MASK    0x2
+#define    RTL8367C_LED_SERI_CLK_EN_OFFSET    0
+#define    RTL8367C_LED_SERI_CLK_EN_MASK    0x1
+
+#define    RTL8367C_REG_SCAN1_LED_IO_EN2    0x1b27
+#define    RTL8367C_LED_SCAN1_BI_PORT_EN_OFFSET    8
+#define    RTL8367C_LED_SCAN1_BI_PORT_EN_MASK    0xFF00
+#define    RTL8367C_LED_SCAN1_BI_STA_EN_OFFSET    7
+#define    RTL8367C_LED_SCAN1_BI_STA_EN_MASK    0x80
+#define    RTL8367C_SCAN1_LED_IO_EN2_DUMMY_0_OFFSET    6
+#define    RTL8367C_SCAN1_LED_IO_EN2_DUMMY_0_MASK    0x40
+#define    RTL8367C_LED_SCAN1_SI_PORT_EN_OFFSET    2
+#define    RTL8367C_LED_SCAN1_SI_PORT_EN_MASK    0x3C
+#define    RTL8367C_LED_SCAN1_SI_STA_EN_OFFSET    0
+#define    RTL8367C_LED_SCAN1_SI_STA_EN_MASK    0x3
+
+#define    RTL8367C_REG_LPI_LED_OPT1    0x1b28
+#define    RTL8367C_LPI_TAG4_OFFSET    12
+#define    RTL8367C_LPI_TAG4_MASK    0xF000
+#define    RTL8367C_LPI_TAG3_OFFSET    8
+#define    RTL8367C_LPI_TAG3_MASK    0xF00
+#define    RTL8367C_LPI_TAG2_OFFSET    4
+#define    RTL8367C_LPI_TAG2_MASK    0xF0
+#define    RTL8367C_LPI_TAG1_OFFSET    0
+#define    RTL8367C_LPI_TAG1_MASK    0xF
+
+#define    RTL8367C_REG_LPI_LED_OPT2    0x1b29
+#define    RTL8367C_LPI_LED_OPT2_DUMMY_OFFSET    15
+#define    RTL8367C_LPI_LED_OPT2_DUMMY_MASK    0x8000
+#define    RTL8367C_LPI_LED2_WEAK_OFFSET    14
+#define    RTL8367C_LPI_LED2_WEAK_MASK    0x4000
+#define    RTL8367C_LPI_LED1_WEAK_OFFSET    13
+#define    RTL8367C_LPI_LED1_WEAK_MASK    0x2000
+#define    RTL8367C_LPI_LED0_WEAK_OFFSET    12
+#define    RTL8367C_LPI_LED0_WEAK_MASK    0x1000
+#define    RTL8367C_LPI_LED2_OFFSET    11
+#define    RTL8367C_LPI_LED2_MASK    0x800
+#define    RTL8367C_LPI_LED1_OFFSET    10
+#define    RTL8367C_LPI_LED1_MASK    0x400
+#define    RTL8367C_LPI_LED0_OFFSET    9
+#define    RTL8367C_LPI_LED0_MASK    0x200
+#define    RTL8367C_LPI_TAG8_OFFSET    8
+#define    RTL8367C_LPI_TAG8_MASK    0x100
+#define    RTL8367C_LPI_TAG7_OFFSET    6
+#define    RTL8367C_LPI_TAG7_MASK    0xC0
+#define    RTL8367C_LPI_TAG6_OFFSET    4
+#define    RTL8367C_LPI_TAG6_MASK    0x30
+#define    RTL8367C_LPI_TAG5_OFFSET    0
+#define    RTL8367C_LPI_TAG5_MASK    0xF
+
+#define    RTL8367C_REG_LPI_LED_OPT3    0x1b2a
+#define    RTL8367C_LPI_LED_OPT3_DUMMY_OFFSET    3
+#define    RTL8367C_LPI_LED_OPT3_DUMMY_MASK    0xFFF8
+#define    RTL8367C_RESTORE_LED_RATE_SEL_OFFSET    1
+#define    RTL8367C_RESTORE_LED_RATE_SEL_MASK    0x6
+#define    RTL8367C_RESTORE_LED_SEL_OFFSET    0
+#define    RTL8367C_RESTORE_LED_SEL_MASK    0x1
+
+#define    RTL8367C_REG_P0_LED_MUX    0x1b2b
+#define    RTL8367C_CFG_P0_LED2_MUX_OFFSET    10
+#define    RTL8367C_CFG_P0_LED2_MUX_MASK    0x7C00
+#define    RTL8367C_CFG_P0_LED1_MUX_OFFSET    5
+#define    RTL8367C_CFG_P0_LED1_MUX_MASK    0x3E0
+#define    RTL8367C_CFG_P0_LED0_MUX_OFFSET    0
+#define    RTL8367C_CFG_P0_LED0_MUX_MASK    0x1F
+
+#define    RTL8367C_REG_P1_LED_MUX    0x1b2c
+#define    RTL8367C_CFG_P1_LED2_MUX_OFFSET    10
+#define    RTL8367C_CFG_P1_LED2_MUX_MASK    0x7C00
+#define    RTL8367C_CFG_P1_LED1_MUX_OFFSET    5
+#define    RTL8367C_CFG_P1_LED1_MUX_MASK    0x3E0
+#define    RTL8367C_CFG_P1_LED0_MUX_OFFSET    0
+#define    RTL8367C_CFG_P1_LED0_MUX_MASK    0x1F
+
+#define    RTL8367C_REG_P2_LED_MUX    0x1b2d
+#define    RTL8367C_CFG_P2_LED2_MUX_OFFSET    10
+#define    RTL8367C_CFG_P2_LED2_MUX_MASK    0x7C00
+#define    RTL8367C_CFG_P2_LED1_MUX_OFFSET    5
+#define    RTL8367C_CFG_P2_LED1_MUX_MASK    0x3E0
+#define    RTL8367C_CFG_P2_LED0_MUX_OFFSET    0
+#define    RTL8367C_CFG_P2_LED0_MUX_MASK    0x1F
+
+#define    RTL8367C_REG_P3_LED_MUX    0x1b2e
+#define    RTL8367C_CFG_P3_LED2_MUX_OFFSET    10
+#define    RTL8367C_CFG_P3_LED2_MUX_MASK    0x7C00
+#define    RTL8367C_CFG_P3_LED1_MUX_OFFSET    5
+#define    RTL8367C_CFG_P3_LED1_MUX_MASK    0x3E0
+#define    RTL8367C_CFG_P3_LED0_MUX_OFFSET    0
+#define    RTL8367C_CFG_P3_LED0_MUX_MASK    0x1F
+
+#define    RTL8367C_REG_P4_LED_MUX    0x1b2f
+#define    RTL8367C_CFG_P4_LED2_MUX_OFFSET    10
+#define    RTL8367C_CFG_P4_LED2_MUX_MASK    0x7C00
+#define    RTL8367C_CFG_P4_LED1_MUX_OFFSET    5
+#define    RTL8367C_CFG_P4_LED1_MUX_MASK    0x3E0
+#define    RTL8367C_CFG_P4_LED0_MUX_OFFSET    0
+#define    RTL8367C_CFG_P4_LED0_MUX_MASK    0x1F
+
+#define    RTL8367C_REG_LED0_DATA_CTRL    0x1b30
+#define    RTL8367C_CFG_DATA_LED0_SEL_OFFSET    6
+#define    RTL8367C_CFG_DATA_LED0_SEL_MASK    0x40
+#define    RTL8367C_CFG_DATA_LED0_ACT_OFFSET    4
+#define    RTL8367C_CFG_DATA_LED0_ACT_MASK    0x30
+#define    RTL8367C_CFG_DATA_LED0_SPD_OFFSET    0
+#define    RTL8367C_CFG_DATA_LED0_SPD_MASK    0xF
+
+#define    RTL8367C_REG_LED1_DATA_CTRL    0x1b31
+#define    RTL8367C_CFG_DATA_LED1_SEL_OFFSET    6
+#define    RTL8367C_CFG_DATA_LED1_SEL_MASK    0x40
+#define    RTL8367C_CFG_DATA_LED1_ACT_OFFSET    4
+#define    RTL8367C_CFG_DATA_LED1_ACT_MASK    0x30
+#define    RTL8367C_CFG_DATA_LED1_SPD_OFFSET    0
+#define    RTL8367C_CFG_DATA_LED1_SPD_MASK    0xF
+
+#define    RTL8367C_REG_LED2_DATA_CTRL    0x1b32
+#define    RTL8367C_CFG_DATA_LED2_SEL_OFFSET    6
+#define    RTL8367C_CFG_DATA_LED2_SEL_MASK    0x40
+#define    RTL8367C_CFG_DATA_LED2_ACT_OFFSET    4
+#define    RTL8367C_CFG_DATA_LED2_ACT_MASK    0x30
+#define    RTL8367C_CFG_DATA_LED2_SPD_OFFSET    0
+#define    RTL8367C_CFG_DATA_LED2_SPD_MASK    0xF
+
+#define    RTL8367C_REG_PARA_LED_IO_EN3    0x1b33
+#define    RTL8367C_dummy_1b33a_OFFSET    6
+#define    RTL8367C_dummy_1b33a_MASK    0xFFC0
+#define    RTL8367C_LED2_PARA_P09_08_OFFSET    4
+#define    RTL8367C_LED2_PARA_P09_08_MASK    0x30
+#define    RTL8367C_LED1_PARA_P09_08_OFFSET    2
+#define    RTL8367C_LED1_PARA_P09_08_MASK    0xC
+#define    RTL8367C_LED0_PARA_P09_08_OFFSET    0
+#define    RTL8367C_LED0_PARA_P09_08_MASK    0x3
+
+#define    RTL8367C_REG_SCAN1_LED_IO_EN3    0x1b34
+#define    RTL8367C_dummy_1b34a_OFFSET    3
+#define    RTL8367C_dummy_1b34a_MASK    0xFFF8
+#define    RTL8367C_LED_SCAN1_BI_PORT9_8_EN_OFFSET    1
+#define    RTL8367C_LED_SCAN1_BI_PORT9_8_EN_MASK    0x6
+#define    RTL8367C_LED_SCAN1_SI_PORT9_8_EN_OFFSET    0
+#define    RTL8367C_LED_SCAN1_SI_PORT9_8_EN_MASK    0x1
+
+#define    RTL8367C_REG_P5_LED_MUX    0x1b35
+#define    RTL8367C_CFG_P5_LED2_MUX_OFFSET    10
+#define    RTL8367C_CFG_P5_LED2_MUX_MASK    0x7C00
+#define    RTL8367C_CFG_P5_LED1_MUX_OFFSET    5
+#define    RTL8367C_CFG_P5_LED1_MUX_MASK    0x3E0
+#define    RTL8367C_CFG_P5_LED0_MUX_OFFSET    0
+#define    RTL8367C_CFG_P5_LED0_MUX_MASK    0x1F
+
+#define    RTL8367C_REG_P6_LED_MUX    0x1b36
+#define    RTL8367C_CFG_P6_LED2_MUX_OFFSET    10
+#define    RTL8367C_CFG_P6_LED2_MUX_MASK    0x7C00
+#define    RTL8367C_CFG_P6_LED1_MUX_OFFSET    5
+#define    RTL8367C_CFG_P6_LED1_MUX_MASK    0x3E0
+#define    RTL8367C_CFG_P6_LED0_MUX_OFFSET    0
+#define    RTL8367C_CFG_P6_LED0_MUX_MASK    0x1F
+
+#define    RTL8367C_REG_P7_LED_MUX    0x1b37
+#define    RTL8367C_CFG_P7_LED2_MUX_OFFSET    10
+#define    RTL8367C_CFG_P7_LED2_MUX_MASK    0x7C00
+#define    RTL8367C_CFG_P7_LED1_MUX_OFFSET    5
+#define    RTL8367C_CFG_P7_LED1_MUX_MASK    0x3E0
+#define    RTL8367C_CFG_P7_LED0_MUX_OFFSET    0
+#define    RTL8367C_CFG_P7_LED0_MUX_MASK    0x1F
+
+#define    RTL8367C_REG_P8_LED_MUX    0x1b38
+#define    RTL8367C_CFG_P8_LED2_MUX_OFFSET    10
+#define    RTL8367C_CFG_P8_LED2_MUX_MASK    0x7C00
+#define    RTL8367C_CFG_P8_LED1_MUX_OFFSET    5
+#define    RTL8367C_CFG_P8_LED1_MUX_MASK    0x3E0
+#define    RTL8367C_CFG_P8_LED0_MUX_OFFSET    0
+#define    RTL8367C_CFG_P8_LED0_MUX_MASK    0x1F
+
+#define    RTL8367C_REG_P9_LED_MUX    0x1b39
+#define    RTL8367C_CFG_P9_LED2_MUX_OFFSET    10
+#define    RTL8367C_CFG_P9_LED2_MUX_MASK    0x7C00
+#define    RTL8367C_CFG_P9_LED1_MUX_OFFSET    5
+#define    RTL8367C_CFG_P9_LED1_MUX_MASK    0x3E0
+#define    RTL8367C_CFG_P9_LED0_MUX_OFFSET    0
+#define    RTL8367C_CFG_P9_LED0_MUX_MASK    0x1F
+
+#define    RTL8367C_REG_SERIAL_LED_CTRL    0x1b3a
+#define    RTL8367C_SERIAL_LED_SHIFT_SEQUENCE_OFFSET    13
+#define    RTL8367C_SERIAL_LED_SHIFT_SEQUENCE_MASK    0x6000
+#define    RTL8367C_SERIAL_LED_SHIFT_SEQUENCE_EN_OFFSET    12
+#define    RTL8367C_SERIAL_LED_SHIFT_SEQUENCE_EN_MASK    0x1000
+#define    RTL8367C_SERIAL_LED_GROUP_NUM_OFFSET    10
+#define    RTL8367C_SERIAL_LED_GROUP_NUM_MASK    0xC00
+#define    RTL8367C_SERIAL_LED_PORT_EN_OFFSET    0
+#define    RTL8367C_SERIAL_LED_PORT_EN_MASK    0x3FF
+
+/* (16'h1c00)IGMP_EAV */
+
+#define    RTL8367C_REG_IGMP_MLD_CFG0    0x1c00
+#define    RTL8367C_IGMP_MLD_PORTISO_LEAKY_OFFSET    15
+#define    RTL8367C_IGMP_MLD_PORTISO_LEAKY_MASK    0x8000
+#define    RTL8367C_IGMP_MLD_VLAN_LEAKY_OFFSET    14
+#define    RTL8367C_IGMP_MLD_VLAN_LEAKY_MASK    0x4000
+#define    RTL8367C_IGMP_MLD_DISCARD_STORM_FILTER_OFFSET    13
+#define    RTL8367C_IGMP_MLD_DISCARD_STORM_FILTER_MASK    0x2000
+#define    RTL8367C_REPORT_FORWARD_OFFSET    12
+#define    RTL8367C_REPORT_FORWARD_MASK    0x1000
+#define    RTL8367C_ROBURSTNESS_VAR_OFFSET    9
+#define    RTL8367C_ROBURSTNESS_VAR_MASK    0xE00
+#define    RTL8367C_LEAVE_SUPPRESSION_OFFSET    8
+#define    RTL8367C_LEAVE_SUPPRESSION_MASK    0x100
+#define    RTL8367C_REPORT_SUPPRESSION_OFFSET    7
+#define    RTL8367C_REPORT_SUPPRESSION_MASK    0x80
+#define    RTL8367C_LEAVE_TIMER_OFFSET    4
+#define    RTL8367C_LEAVE_TIMER_MASK    0x70
+#define    RTL8367C_FAST_LEAVE_EN_OFFSET    3
+#define    RTL8367C_FAST_LEAVE_EN_MASK    0x8
+#define    RTL8367C_CKS_ERR_OP_OFFSET    1
+#define    RTL8367C_CKS_ERR_OP_MASK    0x6
+#define    RTL8367C_IGMP_MLD_EN_OFFSET    0
+#define    RTL8367C_IGMP_MLD_EN_MASK    0x1
+
+#define    RTL8367C_REG_IGMP_MLD_CFG1    0x1c01
+#define    RTL8367C_DROP_LEAVE_ZERO_OFFSET    2
+#define    RTL8367C_DROP_LEAVE_ZERO_MASK    0x4
+#define    RTL8367C_TABLE_FULL_OP_OFFSET    0
+#define    RTL8367C_TABLE_FULL_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_MLD_CFG2    0x1c02
+
+#define    RTL8367C_REG_IGMP_DYNAMIC_ROUTER_PORT    0x1c03
+#define    RTL8367C_D_ROUTER_PORT_2_OFFSET    11
+#define    RTL8367C_D_ROUTER_PORT_2_MASK    0x7800
+#define    RTL8367C_D_ROUTER_PORT_TMR_2_OFFSET    8
+#define    RTL8367C_D_ROUTER_PORT_TMR_2_MASK    0x700
+#define    RTL8367C_D_ROUTER_PORT_1_OFFSET    3
+#define    RTL8367C_D_ROUTER_PORT_1_MASK    0x78
+#define    RTL8367C_D_ROUTER_PORT_TMR_1_OFFSET    0
+#define    RTL8367C_D_ROUTER_PORT_TMR_1_MASK    0x7
+
+#define    RTL8367C_REG_IGMP_STATIC_ROUTER_PORT    0x1c04
+#define    RTL8367C_IGMP_STATIC_ROUTER_PORT_OFFSET    0
+#define    RTL8367C_IGMP_STATIC_ROUTER_PORT_MASK    0x7FF
+
+#define    RTL8367C_REG_IGMP_PORT0_CONTROL    0x1c05
+#define    RTL8367C_IGMP_PORT0_CONTROL_ALLOW_QUERY_OFFSET    14
+#define    RTL8367C_IGMP_PORT0_CONTROL_ALLOW_QUERY_MASK    0x4000
+#define    RTL8367C_IGMP_PORT0_CONTROL_ALLOW_REPORT_OFFSET    13
+#define    RTL8367C_IGMP_PORT0_CONTROL_ALLOW_REPORT_MASK    0x2000
+#define    RTL8367C_IGMP_PORT0_CONTROL_ALLOW_LEAVE_OFFSET    12
+#define    RTL8367C_IGMP_PORT0_CONTROL_ALLOW_LEAVE_MASK    0x1000
+#define    RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MRP_OFFSET    11
+#define    RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MRP_MASK    0x800
+#define    RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MC_DATA_OFFSET    10
+#define    RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MC_DATA_MASK    0x400
+#define    RTL8367C_IGMP_PORT0_CONTROL_MLDv2_OP_OFFSET    8
+#define    RTL8367C_IGMP_PORT0_CONTROL_MLDv2_OP_MASK    0x300
+#define    RTL8367C_IGMP_PORT0_CONTROL_MLDv1_OP_OFFSET    6
+#define    RTL8367C_IGMP_PORT0_CONTROL_MLDv1_OP_MASK    0xC0
+#define    RTL8367C_IGMP_PORT0_CONTROL_IGMPV3_OP_OFFSET    4
+#define    RTL8367C_IGMP_PORT0_CONTROL_IGMPV3_OP_MASK    0x30
+#define    RTL8367C_IGMP_PORT0_CONTROL_IGMPV2_OP_OFFSET    2
+#define    RTL8367C_IGMP_PORT0_CONTROL_IGMPV2_OP_MASK    0xC
+#define    RTL8367C_IGMP_PORT0_CONTROL_IGMPV1_OP_OFFSET    0
+#define    RTL8367C_IGMP_PORT0_CONTROL_IGMPV1_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_PORT1_CONTROL    0x1c06
+#define    RTL8367C_IGMP_PORT1_CONTROL_ALLOW_QUERY_OFFSET    14
+#define    RTL8367C_IGMP_PORT1_CONTROL_ALLOW_QUERY_MASK    0x4000
+#define    RTL8367C_IGMP_PORT1_CONTROL_ALLOW_REPORT_OFFSET    13
+#define    RTL8367C_IGMP_PORT1_CONTROL_ALLOW_REPORT_MASK    0x2000
+#define    RTL8367C_IGMP_PORT1_CONTROL_ALLOW_LEAVE_OFFSET    12
+#define    RTL8367C_IGMP_PORT1_CONTROL_ALLOW_LEAVE_MASK    0x1000
+#define    RTL8367C_IGMP_PORT1_CONTROL_ALLOW_MRP_OFFSET    11
+#define    RTL8367C_IGMP_PORT1_CONTROL_ALLOW_MRP_MASK    0x800
+#define    RTL8367C_IGMP_PORT1_CONTROL_ALLOW_MC_DATA_OFFSET    10
+#define    RTL8367C_IGMP_PORT1_CONTROL_ALLOW_MC_DATA_MASK    0x400
+#define    RTL8367C_IGMP_PORT1_CONTROL_MLDv2_OP_OFFSET    8
+#define    RTL8367C_IGMP_PORT1_CONTROL_MLDv2_OP_MASK    0x300
+#define    RTL8367C_IGMP_PORT1_CONTROL_MLDv1_OP_OFFSET    6
+#define    RTL8367C_IGMP_PORT1_CONTROL_MLDv1_OP_MASK    0xC0
+#define    RTL8367C_IGMP_PORT1_CONTROL_IGMPV3_OP_OFFSET    4
+#define    RTL8367C_IGMP_PORT1_CONTROL_IGMPV3_OP_MASK    0x30
+#define    RTL8367C_IGMP_PORT1_CONTROL_IGMPV2_OP_OFFSET    2
+#define    RTL8367C_IGMP_PORT1_CONTROL_IGMPV2_OP_MASK    0xC
+#define    RTL8367C_IGMP_PORT1_CONTROL_IGMPV1_OP_OFFSET    0
+#define    RTL8367C_IGMP_PORT1_CONTROL_IGMPV1_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_PORT2_CONTROL    0x1c07
+#define    RTL8367C_IGMP_PORT2_CONTROL_ALLOW_QUERY_OFFSET    14
+#define    RTL8367C_IGMP_PORT2_CONTROL_ALLOW_QUERY_MASK    0x4000
+#define    RTL8367C_IGMP_PORT2_CONTROL_ALLOW_REPORT_OFFSET    13
+#define    RTL8367C_IGMP_PORT2_CONTROL_ALLOW_REPORT_MASK    0x2000
+#define    RTL8367C_IGMP_PORT2_CONTROL_ALLOW_LEAVE_OFFSET    12
+#define    RTL8367C_IGMP_PORT2_CONTROL_ALLOW_LEAVE_MASK    0x1000
+#define    RTL8367C_IGMP_PORT2_CONTROL_ALLOW_MRP_OFFSET    11
+#define    RTL8367C_IGMP_PORT2_CONTROL_ALLOW_MRP_MASK    0x800
+#define    RTL8367C_IGMP_PORT2_CONTROL_ALLOW_MC_DATA_OFFSET    10
+#define    RTL8367C_IGMP_PORT2_CONTROL_ALLOW_MC_DATA_MASK    0x400
+#define    RTL8367C_IGMP_PORT2_CONTROL_MLDv2_OP_OFFSET    8
+#define    RTL8367C_IGMP_PORT2_CONTROL_MLDv2_OP_MASK    0x300
+#define    RTL8367C_IGMP_PORT2_CONTROL_MLDv1_OP_OFFSET    6
+#define    RTL8367C_IGMP_PORT2_CONTROL_MLDv1_OP_MASK    0xC0
+#define    RTL8367C_IGMP_PORT2_CONTROL_IGMPV3_OP_OFFSET    4
+#define    RTL8367C_IGMP_PORT2_CONTROL_IGMPV3_OP_MASK    0x30
+#define    RTL8367C_IGMP_PORT2_CONTROL_IGMPV2_OP_OFFSET    2
+#define    RTL8367C_IGMP_PORT2_CONTROL_IGMPV2_OP_MASK    0xC
+#define    RTL8367C_IGMP_PORT2_CONTROL_IGMPV1_OP_OFFSET    0
+#define    RTL8367C_IGMP_PORT2_CONTROL_IGMPV1_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_PORT3_CONTROL    0x1c08
+#define    RTL8367C_IGMP_PORT3_CONTROL_ALLOW_QUERY_OFFSET    14
+#define    RTL8367C_IGMP_PORT3_CONTROL_ALLOW_QUERY_MASK    0x4000
+#define    RTL8367C_IGMP_PORT3_CONTROL_ALLOW_REPORT_OFFSET    13
+#define    RTL8367C_IGMP_PORT3_CONTROL_ALLOW_REPORT_MASK    0x2000
+#define    RTL8367C_IGMP_PORT3_CONTROL_ALLOW_LEAVE_OFFSET    12
+#define    RTL8367C_IGMP_PORT3_CONTROL_ALLOW_LEAVE_MASK    0x1000
+#define    RTL8367C_IGMP_PORT3_CONTROL_ALLOW_MRP_OFFSET    11
+#define    RTL8367C_IGMP_PORT3_CONTROL_ALLOW_MRP_MASK    0x800
+#define    RTL8367C_IGMP_PORT3_CONTROL_ALLOW_MC_DATA_OFFSET    10
+#define    RTL8367C_IGMP_PORT3_CONTROL_ALLOW_MC_DATA_MASK    0x400
+#define    RTL8367C_IGMP_PORT3_CONTROL_MLDv2_OP_OFFSET    8
+#define    RTL8367C_IGMP_PORT3_CONTROL_MLDv2_OP_MASK    0x300
+#define    RTL8367C_IGMP_PORT3_CONTROL_MLDv1_OP_OFFSET    6
+#define    RTL8367C_IGMP_PORT3_CONTROL_MLDv1_OP_MASK    0xC0
+#define    RTL8367C_IGMP_PORT3_CONTROL_IGMPV3_OP_OFFSET    4
+#define    RTL8367C_IGMP_PORT3_CONTROL_IGMPV3_OP_MASK    0x30
+#define    RTL8367C_IGMP_PORT3_CONTROL_IGMPV2_OP_OFFSET    2
+#define    RTL8367C_IGMP_PORT3_CONTROL_IGMPV2_OP_MASK    0xC
+#define    RTL8367C_IGMP_PORT3_CONTROL_IGMPV1_OP_OFFSET    0
+#define    RTL8367C_IGMP_PORT3_CONTROL_IGMPV1_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_PORT4_CONTROL    0x1c09
+#define    RTL8367C_IGMP_PORT4_CONTROL_ALLOW_QUERY_OFFSET    14
+#define    RTL8367C_IGMP_PORT4_CONTROL_ALLOW_QUERY_MASK    0x4000
+#define    RTL8367C_IGMP_PORT4_CONTROL_ALLOW_REPORT_OFFSET    13
+#define    RTL8367C_IGMP_PORT4_CONTROL_ALLOW_REPORT_MASK    0x2000
+#define    RTL8367C_IGMP_PORT4_CONTROL_ALLOW_LEAVE_OFFSET    12
+#define    RTL8367C_IGMP_PORT4_CONTROL_ALLOW_LEAVE_MASK    0x1000
+#define    RTL8367C_IGMP_PORT4_CONTROL_ALLOW_MRP_OFFSET    11
+#define    RTL8367C_IGMP_PORT4_CONTROL_ALLOW_MRP_MASK    0x800
+#define    RTL8367C_IGMP_PORT4_CONTROL_ALLOW_MC_DATA_OFFSET    10
+#define    RTL8367C_IGMP_PORT4_CONTROL_ALLOW_MC_DATA_MASK    0x400
+#define    RTL8367C_IGMP_PORT4_CONTROL_MLDv2_OP_OFFSET    8
+#define    RTL8367C_IGMP_PORT4_CONTROL_MLDv2_OP_MASK    0x300
+#define    RTL8367C_IGMP_PORT4_CONTROL_MLDv1_OP_OFFSET    6
+#define    RTL8367C_IGMP_PORT4_CONTROL_MLDv1_OP_MASK    0xC0
+#define    RTL8367C_IGMP_PORT4_CONTROL_IGMPV3_OP_OFFSET    4
+#define    RTL8367C_IGMP_PORT4_CONTROL_IGMPV3_OP_MASK    0x30
+#define    RTL8367C_IGMP_PORT4_CONTROL_IGMPV2_OP_OFFSET    2
+#define    RTL8367C_IGMP_PORT4_CONTROL_IGMPV2_OP_MASK    0xC
+#define    RTL8367C_IGMP_PORT4_CONTROL_IGMPV1_OP_OFFSET    0
+#define    RTL8367C_IGMP_PORT4_CONTROL_IGMPV1_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_PORT5_CONTROL    0x1c0a
+#define    RTL8367C_IGMP_PORT5_CONTROL_ALLOW_QUERY_OFFSET    14
+#define    RTL8367C_IGMP_PORT5_CONTROL_ALLOW_QUERY_MASK    0x4000
+#define    RTL8367C_IGMP_PORT5_CONTROL_ALLOW_REPORT_OFFSET    13
+#define    RTL8367C_IGMP_PORT5_CONTROL_ALLOW_REPORT_MASK    0x2000
+#define    RTL8367C_IGMP_PORT5_CONTROL_ALLOW_LEAVE_OFFSET    12
+#define    RTL8367C_IGMP_PORT5_CONTROL_ALLOW_LEAVE_MASK    0x1000
+#define    RTL8367C_IGMP_PORT5_CONTROL_ALLOW_MRP_OFFSET    11
+#define    RTL8367C_IGMP_PORT5_CONTROL_ALLOW_MRP_MASK    0x800
+#define    RTL8367C_IGMP_PORT5_CONTROL_ALLOW_MC_DATA_OFFSET    10
+#define    RTL8367C_IGMP_PORT5_CONTROL_ALLOW_MC_DATA_MASK    0x400
+#define    RTL8367C_IGMP_PORT5_CONTROL_MLDv2_OP_OFFSET    8
+#define    RTL8367C_IGMP_PORT5_CONTROL_MLDv2_OP_MASK    0x300
+#define    RTL8367C_IGMP_PORT5_CONTROL_MLDv1_OP_OFFSET    6
+#define    RTL8367C_IGMP_PORT5_CONTROL_MLDv1_OP_MASK    0xC0
+#define    RTL8367C_IGMP_PORT5_CONTROL_IGMPV3_OP_OFFSET    4
+#define    RTL8367C_IGMP_PORT5_CONTROL_IGMPV3_OP_MASK    0x30
+#define    RTL8367C_IGMP_PORT5_CONTROL_IGMPV2_OP_OFFSET    2
+#define    RTL8367C_IGMP_PORT5_CONTROL_IGMPV2_OP_MASK    0xC
+#define    RTL8367C_IGMP_PORT5_CONTROL_IGMPV1_OP_OFFSET    0
+#define    RTL8367C_IGMP_PORT5_CONTROL_IGMPV1_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_PORT6_CONTROL    0x1c0b
+#define    RTL8367C_IGMP_PORT6_CONTROL_ALLOW_QUERY_OFFSET    14
+#define    RTL8367C_IGMP_PORT6_CONTROL_ALLOW_QUERY_MASK    0x4000
+#define    RTL8367C_IGMP_PORT6_CONTROL_ALLOW_REPORT_OFFSET    13
+#define    RTL8367C_IGMP_PORT6_CONTROL_ALLOW_REPORT_MASK    0x2000
+#define    RTL8367C_IGMP_PORT6_CONTROL_ALLOW_LEAVE_OFFSET    12
+#define    RTL8367C_IGMP_PORT6_CONTROL_ALLOW_LEAVE_MASK    0x1000
+#define    RTL8367C_IGMP_PORT6_CONTROL_ALLOW_MRP_OFFSET    11
+#define    RTL8367C_IGMP_PORT6_CONTROL_ALLOW_MRP_MASK    0x800
+#define    RTL8367C_IGMP_PORT6_CONTROL_ALLOW_MC_DATA_OFFSET    10
+#define    RTL8367C_IGMP_PORT6_CONTROL_ALLOW_MC_DATA_MASK    0x400
+#define    RTL8367C_IGMP_PORT6_CONTROL_MLDv2_OP_OFFSET    8
+#define    RTL8367C_IGMP_PORT6_CONTROL_MLDv2_OP_MASK    0x300
+#define    RTL8367C_IGMP_PORT6_CONTROL_MLDv1_OP_OFFSET    6
+#define    RTL8367C_IGMP_PORT6_CONTROL_MLDv1_OP_MASK    0xC0
+#define    RTL8367C_IGMP_PORT6_CONTROL_IGMPV3_OP_OFFSET    4
+#define    RTL8367C_IGMP_PORT6_CONTROL_IGMPV3_OP_MASK    0x30
+#define    RTL8367C_IGMP_PORT6_CONTROL_IGMPV2_OP_OFFSET    2
+#define    RTL8367C_IGMP_PORT6_CONTROL_IGMPV2_OP_MASK    0xC
+#define    RTL8367C_IGMP_PORT6_CONTROL_IGMPV1_OP_OFFSET    0
+#define    RTL8367C_IGMP_PORT6_CONTROL_IGMPV1_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_PORT7_CONTROL    0x1c0c
+#define    RTL8367C_IGMP_PORT7_CONTROL_ALLOW_QUERY_OFFSET    14
+#define    RTL8367C_IGMP_PORT7_CONTROL_ALLOW_QUERY_MASK    0x4000
+#define    RTL8367C_IGMP_PORT7_CONTROL_ALLOW_REPORT_OFFSET    13
+#define    RTL8367C_IGMP_PORT7_CONTROL_ALLOW_REPORT_MASK    0x2000
+#define    RTL8367C_IGMP_PORT7_CONTROL_ALLOW_LEAVE_OFFSET    12
+#define    RTL8367C_IGMP_PORT7_CONTROL_ALLOW_LEAVE_MASK    0x1000
+#define    RTL8367C_IGMP_PORT7_CONTROL_ALLOW_MRP_OFFSET    11
+#define    RTL8367C_IGMP_PORT7_CONTROL_ALLOW_MRP_MASK    0x800
+#define    RTL8367C_IGMP_PORT7_CONTROL_ALLOW_MC_DATA_OFFSET    10
+#define    RTL8367C_IGMP_PORT7_CONTROL_ALLOW_MC_DATA_MASK    0x400
+#define    RTL8367C_IGMP_PORT7_CONTROL_MLDv2_OP_OFFSET    8
+#define    RTL8367C_IGMP_PORT7_CONTROL_MLDv2_OP_MASK    0x300
+#define    RTL8367C_IGMP_PORT7_CONTROL_MLDv1_OP_OFFSET    6
+#define    RTL8367C_IGMP_PORT7_CONTROL_MLDv1_OP_MASK    0xC0
+#define    RTL8367C_IGMP_PORT7_CONTROL_IGMPV3_OP_OFFSET    4
+#define    RTL8367C_IGMP_PORT7_CONTROL_IGMPV3_OP_MASK    0x30
+#define    RTL8367C_IGMP_PORT7_CONTROL_IGMPV2_OP_OFFSET    2
+#define    RTL8367C_IGMP_PORT7_CONTROL_IGMPV2_OP_MASK    0xC
+#define    RTL8367C_IGMP_PORT7_CONTROL_IGMPV1_OP_OFFSET    0
+#define    RTL8367C_IGMP_PORT7_CONTROL_IGMPV1_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_PORT01_MAX_GROUP    0x1c0d
+#define    RTL8367C_PORT1_MAX_GROUP_OFFSET    8
+#define    RTL8367C_PORT1_MAX_GROUP_MASK    0xFF00
+#define    RTL8367C_PORT0_MAX_GROUP_OFFSET    0
+#define    RTL8367C_PORT0_MAX_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_PORT23_MAX_GROUP    0x1c0e
+#define    RTL8367C_PORT3_MAX_GROUP_OFFSET    8
+#define    RTL8367C_PORT3_MAX_GROUP_MASK    0xFF00
+#define    RTL8367C_PORT2_MAX_GROUP_OFFSET    0
+#define    RTL8367C_PORT2_MAX_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_PORT45_MAX_GROUP    0x1c0f
+#define    RTL8367C_PORT5_MAX_GROUP_OFFSET    8
+#define    RTL8367C_PORT5_MAX_GROUP_MASK    0xFF00
+#define    RTL8367C_PORT4_MAX_GROUP_OFFSET    0
+#define    RTL8367C_PORT4_MAX_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_PORT67_MAX_GROUP    0x1c10
+#define    RTL8367C_PORT7_MAX_GROUP_OFFSET    8
+#define    RTL8367C_PORT7_MAX_GROUP_MASK    0xFF00
+#define    RTL8367C_PORT6_MAX_GROUP_OFFSET    0
+#define    RTL8367C_PORT6_MAX_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_PORT01_CURRENT_GROUP    0x1c11
+#define    RTL8367C_PORT1_CURRENT_GROUP_OFFSET    8
+#define    RTL8367C_PORT1_CURRENT_GROUP_MASK    0xFF00
+#define    RTL8367C_PORT0_CURRENT_GROUP_OFFSET    0
+#define    RTL8367C_PORT0_CURRENT_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_PORT23_CURRENT_GROUP    0x1c12
+#define    RTL8367C_PORT3_CURRENT_GROUP_OFFSET    8
+#define    RTL8367C_PORT3_CURRENT_GROUP_MASK    0xFF00
+#define    RTL8367C_PORT2_CURRENT_GROUP_OFFSET    0
+#define    RTL8367C_PORT2_CURRENT_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_PORT45_CURRENT_GROUP    0x1c13
+#define    RTL8367C_PORT5_CURRENT_GROUP_OFFSET    8
+#define    RTL8367C_PORT5_CURRENT_GROUP_MASK    0xFF00
+#define    RTL8367C_PORT4_CURRENT_GROUP_OFFSET    0
+#define    RTL8367C_PORT4_CURRENT_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_PORT67_CURRENT_GROUP    0x1c14
+#define    RTL8367C_PORT7_CURRENT_GROUP_OFFSET    8
+#define    RTL8367C_PORT7_CURRENT_GROUP_MASK    0xFF00
+#define    RTL8367C_PORT6_CURRENT_GROUP_OFFSET    0
+#define    RTL8367C_PORT6_CURRENT_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_MLD_CFG3    0x1c15
+#define    RTL8367C_IGMP_MLD_IP6_BYPASS_OFFSET    5
+#define    RTL8367C_IGMP_MLD_IP6_BYPASS_MASK    0x20
+#define    RTL8367C_IGMP_MLD_IP4_BYPASS_239_255_255_OFFSET    4
+#define    RTL8367C_IGMP_MLD_IP4_BYPASS_239_255_255_MASK    0x10
+#define    RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_1_OFFSET    3
+#define    RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_1_MASK    0x8
+#define    RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_0_OFFSET    2
+#define    RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_0_MASK    0x4
+#define    RTL8367C_REPORT_LEAVE_FORWARD_OFFSET    0
+#define    RTL8367C_REPORT_LEAVE_FORWARD_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_MLD_CFG4    0x1c16
+#define    RTL8367C_IGMP_MLD_CFG4_OFFSET    0
+#define    RTL8367C_IGMP_MLD_CFG4_MASK    0x7FF
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST0    0x1c20
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST1    0x1c21
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST2    0x1c22
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST3    0x1c23
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST4    0x1c24
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST5    0x1c25
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST6    0x1c26
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST7    0x1c27
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST8    0x1c28
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST9    0x1c29
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST10    0x1c2a
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST11    0x1c2b
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST12    0x1c2c
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST13    0x1c2d
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST14    0x1c2e
+
+#define    RTL8367C_REG_IGMP_GROUP_USAGE_LIST15    0x1c2f
+
+#define    RTL8367C_REG_EAV_CTRL0    0x1c30
+#define    RTL8367C_EAV_CTRL0_OFFSET    0
+#define    RTL8367C_EAV_CTRL0_MASK    0xFF
+
+#define    RTL8367C_REG_EAV_CTRL1    0x1c31
+#define    RTL8367C_REMAP_EAV_PRI3_REGEN_OFFSET    9
+#define    RTL8367C_REMAP_EAV_PRI3_REGEN_MASK    0xE00
+#define    RTL8367C_REMAP_EAV_PRI2_REGEN_OFFSET    6
+#define    RTL8367C_REMAP_EAV_PRI2_REGEN_MASK    0x1C0
+#define    RTL8367C_REMAP_EAV_PRI1_REGEN_OFFSET    3
+#define    RTL8367C_REMAP_EAV_PRI1_REGEN_MASK    0x38
+#define    RTL8367C_REMAP_EAV_PRI0_REGEN_OFFSET    0
+#define    RTL8367C_REMAP_EAV_PRI0_REGEN_MASK    0x7
+
+#define    RTL8367C_REG_EAV_CTRL2    0x1c32
+#define    RTL8367C_REMAP_EAV_PRI7_REGEN_OFFSET    9
+#define    RTL8367C_REMAP_EAV_PRI7_REGEN_MASK    0xE00
+#define    RTL8367C_REMAP_EAV_PRI6_REGEN_OFFSET    6
+#define    RTL8367C_REMAP_EAV_PRI6_REGEN_MASK    0x1C0
+#define    RTL8367C_REMAP_EAV_PRI5_REGEN_OFFSET    3
+#define    RTL8367C_REMAP_EAV_PRI5_REGEN_MASK    0x38
+#define    RTL8367C_REMAP_EAV_PRI4_REGEN_OFFSET    0
+#define    RTL8367C_REMAP_EAV_PRI4_REGEN_MASK    0x7
+
+#define    RTL8367C_REG_SYS_TIME_FREQ    0x1c43
+
+#define    RTL8367C_REG_SYS_TIME_OFFSET_L    0x1c44
+
+#define    RTL8367C_REG_SYS_TIME_OFFSET_H    0x1c45
+
+#define    RTL8367C_REG_SYS_TIME_OFFSET_512NS_L    0x1c46
+
+#define    RTL8367C_REG_SYS_TIME_OFFSET_512NS_H    0x1c47
+#define    RTL8367C_SYS_TIME_OFFSET_TUNE_OFFSET    5
+#define    RTL8367C_SYS_TIME_OFFSET_TUNE_MASK    0x20
+#define    RTL8367C_SYS_TIME_OFFSET_512NS_H_SYS_TIME_OFFSET_512NS_OFFSET    0
+#define    RTL8367C_SYS_TIME_OFFSET_512NS_H_SYS_TIME_OFFSET_512NS_MASK    0x1F
+
+#define    RTL8367C_REG_SYS_TIME_SEC_TRANSIT    0x1c48
+#define    RTL8367C_SYS_TIME_SEC_TRANSIT_OFFSET    0
+#define    RTL8367C_SYS_TIME_SEC_TRANSIT_MASK    0x1
+
+#define    RTL8367C_REG_SYS_TIME_SEC_HIGH_L    0x1c49
+
+#define    RTL8367C_REG_SYS_TIME_SEC_HIGH_H    0x1c4a
+
+#define    RTL8367C_REG_SYS_TIME_512NS_L    0x1c4b
+
+#define    RTL8367C_REG_SYS_TIME_512NS_H    0x1c4c
+#define    RTL8367C_SYS_TIME_512NS_H_OFFSET    0
+#define    RTL8367C_SYS_TIME_512NS_H_MASK    0x1F
+
+#define    RTL8367C_REG_FALLBACK_CTRL    0x1c70
+#define    RTL8367C_FALLBACK_PL_DEC_EN_OFFSET    15
+#define    RTL8367C_FALLBACK_PL_DEC_EN_MASK    0x8000
+#define    RTL8367C_FALLBACK_MONITOR_TIMEOUT_IGNORE_OFFSET    14
+#define    RTL8367C_FALLBACK_MONITOR_TIMEOUT_IGNORE_MASK    0x4000
+#define    RTL8367C_FALLBACK_ERROR_RATIO_THRESHOLD_OFFSET    11
+#define    RTL8367C_FALLBACK_ERROR_RATIO_THRESHOLD_MASK    0x3800
+#define    RTL8367C_FALLBACK_MONITORMAX_OFFSET    8
+#define    RTL8367C_FALLBACK_MONITORMAX_MASK    0x700
+#define    RTL8367C_FALLBACK_MONITOR_TIMEOUT_OFFSET    0
+#define    RTL8367C_FALLBACK_MONITOR_TIMEOUT_MASK    0xFF
+
+#define    RTL8367C_REG_FALLBACK_PORT0_CFG0    0x1c71
+#define    RTL8367C_FALLBACK_PORT0_CFG0_RESET_POWER_LEVEL_OFFSET    15
+#define    RTL8367C_FALLBACK_PORT0_CFG0_RESET_POWER_LEVEL_MASK    0x8000
+#define    RTL8367C_FALLBACK_PORT0_CFG0_ENABLE_OFFSET    14
+#define    RTL8367C_FALLBACK_PORT0_CFG0_ENABLE_MASK    0x4000
+
+#define    RTL8367C_REG_FALLBACK_PORT0_CFG1    0x1c72
+
+#define    RTL8367C_REG_FALLBACK_PORT0_CFG2    0x1c73
+#define    RTL8367C_FALLBACK_PORT0_CFG2_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT0_CFG2_MASK    0xFFF
+
+#define    RTL8367C_REG_FALLBACK_PORT0_CFG3    0x1c74
+#define    RTL8367C_FALLBACK_PORT0_CFG3_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT0_CFG3_MASK    0xFF
+
+#define    RTL8367C_REG_FALLBACK_PORT1_CFG0    0x1c75
+#define    RTL8367C_FALLBACK_PORT1_CFG0_RESET_POWER_LEVEL_OFFSET    15
+#define    RTL8367C_FALLBACK_PORT1_CFG0_RESET_POWER_LEVEL_MASK    0x8000
+#define    RTL8367C_FALLBACK_PORT1_CFG0_ENABLE_OFFSET    14
+#define    RTL8367C_FALLBACK_PORT1_CFG0_ENABLE_MASK    0x4000
+
+#define    RTL8367C_REG_FALLBACK_PORT1_CFG1    0x1c76
+
+#define    RTL8367C_REG_FALLBACK_PORT1_CFG2    0x1c77
+#define    RTL8367C_FALLBACK_PORT1_CFG2_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT1_CFG2_MASK    0xFFF
+
+#define    RTL8367C_REG_FALLBACK_PORT1_CFG3    0x1c78
+#define    RTL8367C_FALLBACK_PORT1_CFG3_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT1_CFG3_MASK    0xFF
+
+#define    RTL8367C_REG_FALLBACK_PORT2_CFG0    0x1c79
+#define    RTL8367C_FALLBACK_PORT2_CFG0_RESET_POWER_LEVEL_OFFSET    15
+#define    RTL8367C_FALLBACK_PORT2_CFG0_RESET_POWER_LEVEL_MASK    0x8000
+#define    RTL8367C_FALLBACK_PORT2_CFG0_ENABLE_OFFSET    14
+#define    RTL8367C_FALLBACK_PORT2_CFG0_ENABLE_MASK    0x4000
+
+#define    RTL8367C_REG_FALLBACK_PORT2_CFG1    0x1c7a
+
+#define    RTL8367C_REG_FALLBACK_PORT2_CFG2    0x1c7b
+#define    RTL8367C_FALLBACK_PORT2_CFG2_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT2_CFG2_MASK    0xFFF
+
+#define    RTL8367C_REG_FALLBACK_PORT2_CFG3    0x1c7c
+#define    RTL8367C_FALLBACK_PORT2_CFG3_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT2_CFG3_MASK    0xFF
+
+#define    RTL8367C_REG_FALLBACK_PORT3_CFG0    0x1c7d
+#define    RTL8367C_FALLBACK_PORT3_CFG0_RESET_POWER_LEVEL_OFFSET    15
+#define    RTL8367C_FALLBACK_PORT3_CFG0_RESET_POWER_LEVEL_MASK    0x8000
+#define    RTL8367C_FALLBACK_PORT3_CFG0_ENABLE_OFFSET    14
+#define    RTL8367C_FALLBACK_PORT3_CFG0_ENABLE_MASK    0x4000
+
+#define    RTL8367C_REG_FALLBACK_PORT3_CFG1    0x1c7e
+
+#define    RTL8367C_REG_FALLBACK_PORT3_CFG2    0x1c7f
+#define    RTL8367C_FALLBACK_PORT3_CFG2_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT3_CFG2_MASK    0xFFF
+
+#define    RTL8367C_REG_FALLBACK_PORT3_CFG3    0x1c80
+#define    RTL8367C_FALLBACK_PORT3_CFG3_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT3_CFG3_MASK    0xFF
+
+#define    RTL8367C_REG_FALLBACK_PORT4_CFG0    0x1c81
+#define    RTL8367C_FALLBACK_PORT4_CFG0_RESET_POWER_LEVEL_OFFSET    15
+#define    RTL8367C_FALLBACK_PORT4_CFG0_RESET_POWER_LEVEL_MASK    0x8000
+#define    RTL8367C_FALLBACK_PORT4_CFG0_ENABLE_OFFSET    14
+#define    RTL8367C_FALLBACK_PORT4_CFG0_ENABLE_MASK    0x4000
+
+#define    RTL8367C_REG_FALLBACK_PORT4_CFG1    0x1c82
+
+#define    RTL8367C_REG_FALLBACK_PORT4_CFG2    0x1c83
+#define    RTL8367C_FALLBACK_PORT4_CFG2_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT4_CFG2_MASK    0xFFF
+
+#define    RTL8367C_REG_FALLBACK_PORT4_CFG3    0x1c84
+#define    RTL8367C_FALLBACK_PORT4_CFG3_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT4_CFG3_MASK    0xFF
+
+#define    RTL8367C_REG_FALLBACK_CTRL1    0x1c85
+#define    RTL8367C_FALLBACK_VALIDFLOW_OFFSET    8
+#define    RTL8367C_FALLBACK_VALIDFLOW_MASK    0xFF00
+#define    RTL8367C_FALLBACK_STOP_TMR_OFFSET    0
+#define    RTL8367C_FALLBACK_STOP_TMR_MASK    0x1
+
+#define    RTL8367C_REG_FALLBACK_CPL    0x1c86
+#define    RTL8367C_PORT4_CPL_OFFSET    4
+#define    RTL8367C_PORT4_CPL_MASK    0x10
+#define    RTL8367C_PORT3_CPL_OFFSET    3
+#define    RTL8367C_PORT3_CPL_MASK    0x8
+#define    RTL8367C_PORT2_CPL_OFFSET    2
+#define    RTL8367C_PORT2_CPL_MASK    0x4
+#define    RTL8367C_PORT1_CPL_OFFSET    1
+#define    RTL8367C_PORT1_CPL_MASK    0x2
+#define    RTL8367C_PORT0_CPL_OFFSET    0
+#define    RTL8367C_PORT0_CPL_MASK    0x1
+
+#define    RTL8367C_REG_FALLBACK_PHY_PAGE    0x1c87
+#define    RTL8367C_FALLBACK_PHY_PAGE_OFFSET    0
+#define    RTL8367C_FALLBACK_PHY_PAGE_MASK    0xFFF
+
+#define    RTL8367C_REG_FALLBACK_PHY_REG    0x1c88
+#define    RTL8367C_FALLBACK_PHY_REG_OFFSET    0
+#define    RTL8367C_FALLBACK_PHY_REG_MASK    0x1F
+
+#define    RTL8367C_REG_AFBK_INFO_X0    0x1c89
+
+#define    RTL8367C_REG_AFBK_INFO_X1    0x1c8a
+
+#define    RTL8367C_REG_AFBK_INFO_X2    0x1c8b
+
+#define    RTL8367C_REG_AFBK_INFO_X3    0x1c8c
+
+#define    RTL8367C_REG_AFBK_INFO_X4    0x1c8d
+
+#define    RTL8367C_REG_AFBK_INFO_X5    0x1c8e
+
+#define    RTL8367C_REG_AFBK_INFO_X6    0x1c8f
+
+#define    RTL8367C_REG_AFBK_INFO_X7    0x1c90
+
+#define    RTL8367C_REG_AFBK_INFO_X8    0x1c91
+
+#define    RTL8367C_REG_AFBK_INFO_X9    0x1c92
+
+#define    RTL8367C_REG_AFBK_INFO_X10    0x1c93
+
+#define    RTL8367C_REG_AFBK_INFO_X11    0x1c94
+
+#define    RTL8367C_REG_FALLBACK_PORT5_CFG0    0x1ca0
+#define    RTL8367C_FALLBACK_PORT5_CFG0_RESET_POWER_LEVEL_OFFSET    15
+#define    RTL8367C_FALLBACK_PORT5_CFG0_RESET_POWER_LEVEL_MASK    0x8000
+#define    RTL8367C_FALLBACK_PORT5_CFG0_ENABLE_OFFSET    14
+#define    RTL8367C_FALLBACK_PORT5_CFG0_ENABLE_MASK    0x4000
+
+#define    RTL8367C_REG_FALLBACK_PORT5_CFG1    0x1ca1
+
+#define    RTL8367C_REG_FALLBACK_PORT5_CFG2    0x1ca2
+#define    RTL8367C_FALLBACK_PORT5_CFG2_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT5_CFG2_MASK    0xFFF
+
+#define    RTL8367C_REG_FALLBACK_PORT5_CFG3    0x1ca3
+#define    RTL8367C_FALLBACK_PORT5_CFG3_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT5_CFG3_MASK    0xFF
+
+#define    RTL8367C_REG_FALLBACK_PORT6_CFG0    0x1ca4
+#define    RTL8367C_FALLBACK_PORT6_CFG0_RESET_POWER_LEVEL_OFFSET    15
+#define    RTL8367C_FALLBACK_PORT6_CFG0_RESET_POWER_LEVEL_MASK    0x8000
+#define    RTL8367C_FALLBACK_PORT6_CFG0_ENABLE_OFFSET    14
+#define    RTL8367C_FALLBACK_PORT6_CFG0_ENABLE_MASK    0x4000
+
+#define    RTL8367C_REG_FALLBACK_PORT6_CFG1    0x1ca5
+
+#define    RTL8367C_REG_FALLBACK_PORT6_CFG2    0x1ca6
+#define    RTL8367C_FALLBACK_PORT6_CFG2_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT6_CFG2_MASK    0xFFF
+
+#define    RTL8367C_REG_FALLBACK_PORT6_CFG3    0x1ca7
+#define    RTL8367C_FALLBACK_PORT6_CFG3_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT6_CFG3_MASK    0xFF
+
+#define    RTL8367C_REG_FALLBACK_PORT7_CFG0    0x1ca8
+#define    RTL8367C_FALLBACK_PORT7_CFG0_RESET_POWER_LEVEL_OFFSET    15
+#define    RTL8367C_FALLBACK_PORT7_CFG0_RESET_POWER_LEVEL_MASK    0x8000
+#define    RTL8367C_FALLBACK_PORT7_CFG0_ENABLE_OFFSET    14
+#define    RTL8367C_FALLBACK_PORT7_CFG0_ENABLE_MASK    0x4000
+
+#define    RTL8367C_REG_FALLBACK_PORT7_CFG1    0x1ca9
+
+#define    RTL8367C_REG_FALLBACK_PORT7_CFG2    0x1caa
+#define    RTL8367C_FALLBACK_PORT7_CFG2_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT7_CFG2_MASK    0xFFF
+
+#define    RTL8367C_REG_FALLBACK_PORT7_CFG3    0x1cab
+#define    RTL8367C_FALLBACK_PORT7_CFG3_OFFSET    0
+#define    RTL8367C_FALLBACK_PORT7_CFG3_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_PORT8_CONTROL    0x1cb0
+#define    RTL8367C_IGMP_PORT8_CONTROL_ALLOW_QUERY_OFFSET    14
+#define    RTL8367C_IGMP_PORT8_CONTROL_ALLOW_QUERY_MASK    0x4000
+#define    RTL8367C_IGMP_PORT8_CONTROL_ALLOW_REPORT_OFFSET    13
+#define    RTL8367C_IGMP_PORT8_CONTROL_ALLOW_REPORT_MASK    0x2000
+#define    RTL8367C_IGMP_PORT8_CONTROL_ALLOW_LEAVE_OFFSET    12
+#define    RTL8367C_IGMP_PORT8_CONTROL_ALLOW_LEAVE_MASK    0x1000
+#define    RTL8367C_IGMP_PORT8_CONTROL_ALLOW_MRP_OFFSET    11
+#define    RTL8367C_IGMP_PORT8_CONTROL_ALLOW_MRP_MASK    0x800
+#define    RTL8367C_IGMP_PORT8_CONTROL_ALLOW_MC_DATA_OFFSET    10
+#define    RTL8367C_IGMP_PORT8_CONTROL_ALLOW_MC_DATA_MASK    0x400
+#define    RTL8367C_IGMP_PORT8_CONTROL_MLDv2_OP_OFFSET    8
+#define    RTL8367C_IGMP_PORT8_CONTROL_MLDv2_OP_MASK    0x300
+#define    RTL8367C_IGMP_PORT8_CONTROL_MLDv1_OP_OFFSET    6
+#define    RTL8367C_IGMP_PORT8_CONTROL_MLDv1_OP_MASK    0xC0
+#define    RTL8367C_IGMP_PORT8_CONTROL_IGMPV3_OP_OFFSET    4
+#define    RTL8367C_IGMP_PORT8_CONTROL_IGMPV3_OP_MASK    0x30
+#define    RTL8367C_IGMP_PORT8_CONTROL_IGMPV2_OP_OFFSET    2
+#define    RTL8367C_IGMP_PORT8_CONTROL_IGMPV2_OP_MASK    0xC
+#define    RTL8367C_IGMP_PORT8_CONTROL_IGMPV1_OP_OFFSET    0
+#define    RTL8367C_IGMP_PORT8_CONTROL_IGMPV1_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_PORT9_CONTROL    0x1cb1
+#define    RTL8367C_IGMP_PORT9_CONTROL_ALLOW_QUERY_OFFSET    14
+#define    RTL8367C_IGMP_PORT9_CONTROL_ALLOW_QUERY_MASK    0x4000
+#define    RTL8367C_IGMP_PORT9_CONTROL_ALLOW_REPORT_OFFSET    13
+#define    RTL8367C_IGMP_PORT9_CONTROL_ALLOW_REPORT_MASK    0x2000
+#define    RTL8367C_IGMP_PORT9_CONTROL_ALLOW_LEAVE_OFFSET    12
+#define    RTL8367C_IGMP_PORT9_CONTROL_ALLOW_LEAVE_MASK    0x1000
+#define    RTL8367C_IGMP_PORT9_CONTROL_ALLOW_MRP_OFFSET    11
+#define    RTL8367C_IGMP_PORT9_CONTROL_ALLOW_MRP_MASK    0x800
+#define    RTL8367C_IGMP_PORT9_CONTROL_ALLOW_MC_DATA_OFFSET    10
+#define    RTL8367C_IGMP_PORT9_CONTROL_ALLOW_MC_DATA_MASK    0x400
+#define    RTL8367C_IGMP_PORT9_CONTROL_MLDv2_OP_OFFSET    8
+#define    RTL8367C_IGMP_PORT9_CONTROL_MLDv2_OP_MASK    0x300
+#define    RTL8367C_IGMP_PORT9_CONTROL_MLDv1_OP_OFFSET    6
+#define    RTL8367C_IGMP_PORT9_CONTROL_MLDv1_OP_MASK    0xC0
+#define    RTL8367C_IGMP_PORT9_CONTROL_IGMPV3_OP_OFFSET    4
+#define    RTL8367C_IGMP_PORT9_CONTROL_IGMPV3_OP_MASK    0x30
+#define    RTL8367C_IGMP_PORT9_CONTROL_IGMPV2_OP_OFFSET    2
+#define    RTL8367C_IGMP_PORT9_CONTROL_IGMPV2_OP_MASK    0xC
+#define    RTL8367C_IGMP_PORT9_CONTROL_IGMPV1_OP_OFFSET    0
+#define    RTL8367C_IGMP_PORT9_CONTROL_IGMPV1_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_PORT10_CONTROL    0x1cb2
+#define    RTL8367C_IGMP_PORT10_CONTROL_ALLOW_QUERY_OFFSET    14
+#define    RTL8367C_IGMP_PORT10_CONTROL_ALLOW_QUERY_MASK    0x4000
+#define    RTL8367C_IGMP_PORT10_CONTROL_ALLOW_REPORT_OFFSET    13
+#define    RTL8367C_IGMP_PORT10_CONTROL_ALLOW_REPORT_MASK    0x2000
+#define    RTL8367C_IGMP_PORT10_CONTROL_ALLOW_LEAVE_OFFSET    12
+#define    RTL8367C_IGMP_PORT10_CONTROL_ALLOW_LEAVE_MASK    0x1000
+#define    RTL8367C_IGMP_PORT10_CONTROL_ALLOW_MRP_OFFSET    11
+#define    RTL8367C_IGMP_PORT10_CONTROL_ALLOW_MRP_MASK    0x800
+#define    RTL8367C_IGMP_PORT10_CONTROL_ALLOW_MC_DATA_OFFSET    10
+#define    RTL8367C_IGMP_PORT10_CONTROL_ALLOW_MC_DATA_MASK    0x400
+#define    RTL8367C_IGMP_PORT10_CONTROL_MLDv2_OP_OFFSET    8
+#define    RTL8367C_IGMP_PORT10_CONTROL_MLDv2_OP_MASK    0x300
+#define    RTL8367C_IGMP_PORT10_CONTROL_MLDv1_OP_OFFSET    6
+#define    RTL8367C_IGMP_PORT10_CONTROL_MLDv1_OP_MASK    0xC0
+#define    RTL8367C_IGMP_PORT10_CONTROL_IGMPV3_OP_OFFSET    4
+#define    RTL8367C_IGMP_PORT10_CONTROL_IGMPV3_OP_MASK    0x30
+#define    RTL8367C_IGMP_PORT10_CONTROL_IGMPV2_OP_OFFSET    2
+#define    RTL8367C_IGMP_PORT10_CONTROL_IGMPV2_OP_MASK    0xC
+#define    RTL8367C_IGMP_PORT10_CONTROL_IGMPV1_OP_OFFSET    0
+#define    RTL8367C_IGMP_PORT10_CONTROL_IGMPV1_OP_MASK    0x3
+
+#define    RTL8367C_REG_IGMP_PORT89_MAX_GROUP    0x1cb3
+#define    RTL8367C_PORT9_MAX_GROUP_OFFSET    8
+#define    RTL8367C_PORT9_MAX_GROUP_MASK    0xFF00
+#define    RTL8367C_PORT8_MAX_GROUP_OFFSET    0
+#define    RTL8367C_PORT8_MAX_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_PORT10_MAX_GROUP    0x1cb4
+#define    RTL8367C_IGMP_PORT10_MAX_GROUP_OFFSET    0
+#define    RTL8367C_IGMP_PORT10_MAX_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_PORT89_CURRENT_GROUP    0x1cb5
+#define    RTL8367C_PORT9_CURRENT_GROUP_OFFSET    8
+#define    RTL8367C_PORT9_CURRENT_GROUP_MASK    0xFF00
+#define    RTL8367C_PORT8_CURRENT_GROUP_OFFSET    0
+#define    RTL8367C_PORT8_CURRENT_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_PORT10_CURRENT_GROUP    0x1cb6
+#define    RTL8367C_IGMP_PORT10_CURRENT_GROUP_OFFSET    0
+#define    RTL8367C_IGMP_PORT10_CURRENT_GROUP_MASK    0xFF
+
+#define    RTL8367C_REG_IGMP_L3_CHECKSUM_CHECK    0x1cb7
+#define    RTL8367C_IGMP_L3_CHECKSUM_CHECK_OFFSET    0
+#define    RTL8367C_IGMP_L3_CHECKSUM_CHECK_MASK    0x1
+
+/* (16'h1d00)chip_70b_reg */
+
+#define    RTL8367C_REG_PCSXF_CFG    0x1d00
+#define    RTL8367C_PCSXF_CFG_Reserved_OFFSET    15
+#define    RTL8367C_PCSXF_CFG_Reserved_MASK    0x8000
+#define    RTL8367C_CFG_RST_RXFIFO_P7_5_OFFSET    12
+#define    RTL8367C_CFG_RST_RXFIFO_P7_5_MASK    0x7000
+#define    RTL8367C_CFG_PCSXF_OFFSET    8
+#define    RTL8367C_CFG_PCSXF_MASK    0xF00
+#define    RTL8367C_CFG_RST_RXFIFO_OFFSET    3
+#define    RTL8367C_CFG_RST_RXFIFO_MASK    0xF8
+#define    RTL8367C_CFG_COL2RXDV_OFFSET    2
+#define    RTL8367C_CFG_COL2RXDV_MASK    0x4
+#define    RTL8367C_CFG_PHY_SDET_OFFSET    0
+#define    RTL8367C_CFG_PHY_SDET_MASK    0x3
+
+#define    RTL8367C_REG_PHYID_CFG0    0x1d01
+#define    RTL8367C_CFG_PHY_BRD_MODE_P7_5_OFFSET    11
+#define    RTL8367C_CFG_PHY_BRD_MODE_P7_5_MASK    0x3800
+#define    RTL8367C_CFG_PHYAD_14C_OFFSET    10
+#define    RTL8367C_CFG_PHYAD_14C_MASK    0x400
+#define    RTL8367C_CFG_PHY_BRD_MODE_OFFSET    5
+#define    RTL8367C_CFG_PHY_BRD_MODE_MASK    0x3E0
+#define    RTL8367C_CFG_BRD_PHYAD_OFFSET    0
+#define    RTL8367C_CFG_BRD_PHYAD_MASK    0x1F
+
+#define    RTL8367C_REG_PHYID_CFG1    0x1d02
+#define    RTL8367C_CFG_MSK_MDI_OFFSET    5
+#define    RTL8367C_CFG_MSK_MDI_MASK    0x1FE0
+#define    RTL8367C_CFG_BASE_PHYAD_OFFSET    0
+#define    RTL8367C_CFG_BASE_PHYAD_MASK    0x1F
+
+#define    RTL8367C_REG_PHY_POLL_CFG0    0x1d03
+#define    RTL8367C_CFG_HOTCMD_PRD_EN_OFFSET    15
+#define    RTL8367C_CFG_HOTCMD_PRD_EN_MASK    0x8000
+#define    RTL8367C_CFG_HOTCMD_EN_OFFSET    12
+#define    RTL8367C_CFG_HOTCMD_EN_MASK    0x7000
+#define    RTL8367C_CFG_POLL_PERIOD_OFFSET    8
+#define    RTL8367C_CFG_POLL_PERIOD_MASK    0xF00
+#define    RTL8367C_CFG_PERI_CMDS_RD_OFFSET    4
+#define    RTL8367C_CFG_PERI_CMDS_RD_MASK    0xF0
+#define    RTL8367C_CFG_PERI_CMDS_WR_OFFSET    0
+#define    RTL8367C_CFG_PERI_CMDS_WR_MASK    0xF
+
+#define    RTL8367C_REG_PHY_POLL_CFG1    0x1d04
+
+#define    RTL8367C_REG_PHY_POLL_CFG2    0x1d05
+
+#define    RTL8367C_REG_PHY_POLL_CFG3    0x1d06
+
+#define    RTL8367C_REG_PHY_POLL_CFG4    0x1d07
+
+#define    RTL8367C_REG_PHY_POLL_CFG5    0x1d08
+
+#define    RTL8367C_REG_PHY_POLL_CFG6    0x1d09
+
+#define    RTL8367C_REG_PHY_POLL_CFG7    0x1d0a
+
+#define    RTL8367C_REG_PHY_POLL_CFG8    0x1d0b
+
+#define    RTL8367C_REG_PHY_POLL_CFG9    0x1d0c
+
+#define    RTL8367C_REG_PHY_POLL_CFG10    0x1d0d
+
+#define    RTL8367C_REG_PHY_POLL_CFG11    0x1d0e
+
+#define    RTL8367C_REG_PHY_POLL_CFG12    0x1d0f
+
+#define    RTL8367C_REG_EFUSE_MISC    0x1d10
+#define    RTL8367C_CFG_SA_SEL_OFFSET    5
+#define    RTL8367C_CFG_SA_SEL_MASK    0x20
+#define    RTL8367C_CFG_PHYAD00_OFFSET    0
+#define    RTL8367C_CFG_PHYAD00_MASK    0x1F
+
+#define    RTL8367C_REG_SDS_MISC    0x1d11
+#define    RTL8367C_CFG_SGMII_RXFC_OFFSET    14
+#define    RTL8367C_CFG_SGMII_RXFC_MASK    0x4000
+#define    RTL8367C_CFG_SGMII_TXFC_OFFSET    13
+#define    RTL8367C_CFG_SGMII_TXFC_MASK    0x2000
+#define    RTL8367C_INB_ARB_OFFSET    12
+#define    RTL8367C_INB_ARB_MASK    0x1000
+#define    RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET    11
+#define    RTL8367C_CFG_MAC8_SEL_HSGMII_MASK    0x800
+#define    RTL8367C_CFG_SGMII_FDUP_OFFSET    10
+#define    RTL8367C_CFG_SGMII_FDUP_MASK    0x400
+#define    RTL8367C_CFG_SGMII_LINK_OFFSET    9
+#define    RTL8367C_CFG_SGMII_LINK_MASK    0x200
+#define    RTL8367C_CFG_SGMII_SPD_OFFSET    7
+#define    RTL8367C_CFG_SGMII_SPD_MASK    0x180
+#define    RTL8367C_CFG_MAC8_SEL_SGMII_OFFSET    6
+#define    RTL8367C_CFG_MAC8_SEL_SGMII_MASK    0x40
+#define    RTL8367C_CFG_INB_SEL_OFFSET    3
+#define    RTL8367C_CFG_INB_SEL_MASK    0x38
+#define    RTL8367C_CFG_SDS_MODE_18C_OFFSET    0
+#define    RTL8367C_CFG_SDS_MODE_18C_MASK    0x7
+
+#define    RTL8367C_REG_FIFO_CTRL    0x1d12
+#define    RTL8367C_CFG_LINK_DOWN_CLR_FIFO_OFFSET    11
+#define    RTL8367C_CFG_LINK_DOWN_CLR_FIFO_MASK    0x800
+#define    RTL8367C_CFG_LPBK_OFFSET    10
+#define    RTL8367C_CFG_LPBK_MASK    0x400
+#define    RTL8367C_CFG_NOT_FF_OUT_OFFSET    9
+#define    RTL8367C_CFG_NOT_FF_OUT_MASK    0x200
+#define    RTL8367C_CFG_WATER_LEVEL_FD_OFFSET    6
+#define    RTL8367C_CFG_WATER_LEVEL_FD_MASK    0x1C0
+#define    RTL8367C_CFG_WATER_LEVEL_Y2X_OFFSET    3
+#define    RTL8367C_CFG_WATER_LEVEL_Y2X_MASK    0x38
+#define    RTL8367C_CFG_WATER_LEVEL_X2Y_OFFSET    0
+#define    RTL8367C_CFG_WATER_LEVEL_X2Y_MASK    0x7
+
+#define    RTL8367C_REG_BCAM_SETTING    0x1d13
+#define    RTL8367C_CFG_BCAM_MDS_OFFSET    3
+#define    RTL8367C_CFG_BCAM_MDS_MASK    0x18
+#define    RTL8367C_CFG_BCAM_RDS_OFFSET    0
+#define    RTL8367C_CFG_BCAM_RDS_MASK    0x7
+
+#define    RTL8367C_REG_GPHY_ACS_MISC    0x1d14
+#define    RTL8367C_CFG_SEL_GPHY_SMI_OFFSET    3
+#define    RTL8367C_CFG_SEL_GPHY_SMI_MASK    0x8
+#define    RTL8367C_CFG_BRD_PHYIDX_OFFSET    0
+#define    RTL8367C_CFG_BRD_PHYIDX_MASK    0x7
+
+#define    RTL8367C_REG_GPHY_OCP_MSB_0    0x1d15
+#define    RTL8367C_CFG_CPU_OCPADR_MSB_OFFSET    6
+#define    RTL8367C_CFG_CPU_OCPADR_MSB_MASK    0xFC0
+#define    RTL8367C_CFG_DW8051_OCPADR_MSB_OFFSET    0
+#define    RTL8367C_CFG_DW8051_OCPADR_MSB_MASK    0x3F
+
+#define    RTL8367C_REG_GPHY_OCP_MSB_1    0x1d16
+#define    RTL8367C_CFG_PATCH_OCPADR_MSB_OFFSET    6
+#define    RTL8367C_CFG_PATCH_OCPADR_MSB_MASK    0xFC0
+#define    RTL8367C_CFG_PHYSTS_OCPADR_MSB_OFFSET    0
+#define    RTL8367C_CFG_PHYSTS_OCPADR_MSB_MASK    0x3F
+
+#define    RTL8367C_REG_GPHY_OCP_MSB_2    0x1d17
+#define    RTL8367C_CFG_RRCP_OCPADR_MSB_OFFSET    6
+#define    RTL8367C_CFG_RRCP_OCPADR_MSB_MASK    0xFC0
+#define    RTL8367C_CFG_RTCT_OCPADR_MSB_OFFSET    0
+#define    RTL8367C_CFG_RTCT_OCPADR_MSB_MASK    0x3F
+
+#define    RTL8367C_REG_GPHY_OCP_MSB_3    0x1d18
+#define    RTL8367C_GPHY_OCP_MSB_3_OFFSET    0
+#define    RTL8367C_GPHY_OCP_MSB_3_MASK    0x3F
+
+#define    RTL8367C_REG_GPIO_67C_I_X0    0x1d19
+
+#define    RTL8367C_REG_GPIO_67C_I_X1    0x1d1a
+
+#define    RTL8367C_REG_GPIO_67C_I_X2    0x1d1b
+
+#define    RTL8367C_REG_GPIO_67C_I_X3    0x1d1c
+#define    RTL8367C_GPIO_67C_I_X3_OFFSET    0
+#define    RTL8367C_GPIO_67C_I_X3_MASK    0x3FFF
+
+#define    RTL8367C_REG_GPIO_67C_O_X0    0x1d1d
+
+#define    RTL8367C_REG_GPIO_67C_O_X1    0x1d1e
+
+#define    RTL8367C_REG_GPIO_67C_O_X2    0x1d1f
+
+#define    RTL8367C_REG_GPIO_67C_O_X3    0x1d20
+#define    RTL8367C_GPIO_67C_O_X3_OFFSET    0
+#define    RTL8367C_GPIO_67C_O_X3_MASK    0x3FFF
+
+#define    RTL8367C_REG_GPIO_67C_OE_X0    0x1d21
+
+#define    RTL8367C_REG_GPIO_67C_OE_X1    0x1d22
+
+#define    RTL8367C_REG_GPIO_67C_OE_X2    0x1d23
+
+#define    RTL8367C_REG_GPIO_67C_OE_X3    0x1d24
+#define    RTL8367C_GPIO_67C_OE_X3_OFFSET    0
+#define    RTL8367C_GPIO_67C_OE_X3_MASK    0x3FFF
+
+#define    RTL8367C_REG_GPIO_MODE_67C_X0    0x1d25
+
+#define    RTL8367C_REG_GPIO_MODE_67C_X1    0x1d26
+
+#define    RTL8367C_REG_GPIO_MODE_67C_X2    0x1d27
+
+#define    RTL8367C_REG_GPIO_MODE_67C_X3    0x1d28
+#define    RTL8367C_GPIO_MODE_67C_X3_OFFSET    0
+#define    RTL8367C_GPIO_MODE_67C_X3_MASK    0x3FFF
+
+#define    RTL8367C_REG_WGPHY_MISC_0    0x1d29
+#define    RTL8367C_CFG_INIPHY_DISGIGA_P7_5_OFFSET    13
+#define    RTL8367C_CFG_INIPHY_DISGIGA_P7_5_MASK    0xE000
+#define    RTL8367C_CFG_INIPHY_PWRUP_OFFSET    5
+#define    RTL8367C_CFG_INIPHY_PWRUP_MASK    0x1FE0
+#define    RTL8367C_CFG_INIPHY_DISGIGA_OFFSET    0
+#define    RTL8367C_CFG_INIPHY_DISGIGA_MASK    0x1F
+
+#define    RTL8367C_REG_WGPHY_MISC_1    0x1d2a
+#define    RTL8367C_WGPHY_MISC_1_OFFSET    0
+#define    RTL8367C_WGPHY_MISC_1_MASK    0xFF
+
+#define    RTL8367C_REG_WGPHY_MISC_2    0x1d2b
+#define    RTL8367C_WGPHY_MISC_2_OFFSET    0
+#define    RTL8367C_WGPHY_MISC_2_MASK    0x3FF
+
+#define    RTL8367C_REG_CFG_AFBK_GPHY_0    0x1d2c
+#define    RTL8367C_CFG_AFBK_GPHY_0_OFFSET    0
+#define    RTL8367C_CFG_AFBK_GPHY_0_MASK    0x1F
+
+#define    RTL8367C_REG_CFG_AFBK_GPHY_1    0x1d2d
+#define    RTL8367C_CFG_AFBK_GPHY_1_OFFSET    0
+#define    RTL8367C_CFG_AFBK_GPHY_1_MASK    0xFFF
+
+#define    RTL8367C_REG_EF_SLV_CTRL_0    0x1d2e
+#define    RTL8367C_EF_SLV_BUSY_OFFSET    11
+#define    RTL8367C_EF_SLV_BUSY_MASK    0x800
+#define    RTL8367C_EF_SLV_ACK_OFFSET    10
+#define    RTL8367C_EF_SLV_ACK_MASK    0x400
+#define    RTL8367C_EF_SLV_A_OFFSET    2
+#define    RTL8367C_EF_SLV_A_MASK    0x3FC
+#define    RTL8367C_EF_SLV_WE_OFFSET    1
+#define    RTL8367C_EF_SLV_WE_MASK    0x2
+#define    RTL8367C_EF_SLV_CE_OFFSET    0
+#define    RTL8367C_EF_SLV_CE_MASK    0x1
+
+#define    RTL8367C_REG_EF_SLV_CTRL_1    0x1d2f
+
+#define    RTL8367C_REG_EF_SLV_CTRL_2    0x1d30
+
+#define    RTL8367C_REG_EFUSE_MISC_1    0x1d31
+#define    RTL8367C_EF_EN_EFUSE_OFFSET    10
+#define    RTL8367C_EF_EN_EFUSE_MASK    0x400
+#define    RTL8367C_EF_MODEL_ID_OFFSET    6
+#define    RTL8367C_EF_MODEL_ID_MASK    0x3C0
+#define    RTL8367C_EF_RSVD_OFFSET    2
+#define    RTL8367C_EF_RSVD_MASK    0x3C
+#define    RTL8367C_EF_SYS_CLK_OFFSET    0
+#define    RTL8367C_EF_SYS_CLK_MASK    0x3
+
+#define    RTL8367C_REG_IO_MISC_FUNC    0x1d32
+#define    RTL8367C_TST_MODE_OFFSET    3
+#define    RTL8367C_TST_MODE_MASK    0x8
+#define    RTL8367C_UART_EN_OFFSET    2
+#define    RTL8367C_UART_EN_MASK    0x4
+#define    RTL8367C_INT_EN_OFFSET    1
+#define    RTL8367C_INT_EN_MASK    0x2
+#define    RTL8367C_BUZ_EN_OFFSET    0
+#define    RTL8367C_BUZ_EN_MASK    0x1
+
+#define    RTL8367C_REG_HTRAM_DVS    0x1d33
+#define    RTL8367C_HTRAM_DVS_OFFSET    0
+#define    RTL8367C_HTRAM_DVS_MASK    0x1
+
+#define    RTL8367C_REG_EF_SLV_CTRL_3    0x1d34
+#define    RTL8367C_EF_SLV_CTRL_3_OFFSET    0
+#define    RTL8367C_EF_SLV_CTRL_3_MASK    0x1
+
+#define    RTL8367C_REG_INBAND_EN14C    0x1d35
+#define    RTL8367C_INBAND_EN14C_OFFSET    0
+#define    RTL8367C_INBAND_EN14C_MASK    0x1
+
+#define    RTL8367C_REG_CFG_SWR_L    0x1d36
+#define    RTL8367C_ANARG_RDY_SWR_L_OFFSET    14
+#define    RTL8367C_ANARG_RDY_SWR_L_MASK    0x4000
+#define    RTL8367C_ANARG_VALID_SWR_L_OFFSET    13
+#define    RTL8367C_ANARG_VALID_SWR_L_MASK    0x2000
+#define    RTL8367C_SAW_SWR_L_OFFSET    9
+#define    RTL8367C_SAW_SWR_L_MASK    0x1E00
+#define    RTL8367C_SAW_VALID_SWR_L_OFFSET    8
+#define    RTL8367C_SAW_VALID_SWR_L_MASK    0x100
+#define    RTL8367C_UPS_DBGO_L_OFFSET    0
+#define    RTL8367C_UPS_DBGO_L_MASK    0xFF
+
+#define    RTL8367C_REG_BTCAM_CTRL    0x1d37
+#define    RTL8367C_TCAM_RDS_OFFSET    2
+#define    RTL8367C_TCAM_RDS_MASK    0x1C
+#define    RTL8367C_TCAM_MDS_OFFSET    0
+#define    RTL8367C_TCAM_MDS_MASK    0x3
+
+#define    RTL8367C_REG_PBRAM_BISR_CTRL    0x1d38
+#define    RTL8367C_HAS_HLDRMP_MD_OFFSET    9
+#define    RTL8367C_HAS_HLDRMP_MD_MASK    0x200
+#define    RTL8367C_PB_HLDRMP_MD_OFFSET    8
+#define    RTL8367C_PB_HLDRMP_MD_MASK    0x100
+#define    RTL8367C_HAS_BISR_BIRSTN_OFFSET    7
+#define    RTL8367C_HAS_BISR_BIRSTN_MASK    0x80
+#define    RTL8367C_SEC_RUN_HSA_OFFSET    6
+#define    RTL8367C_SEC_RUN_HSA_MASK    0x40
+#define    RTL8367C_HAS_HLDRMP_VAL_OFFSET    5
+#define    RTL8367C_HAS_HLDRMP_VAL_MASK    0x20
+#define    RTL8367C_HAS_BISR_PWRSTN_OFFSET    4
+#define    RTL8367C_HAS_BISR_PWRSTN_MASK    0x10
+#define    RTL8367C_SEC_RUN_PB_OFFSET    3
+#define    RTL8367C_SEC_RUN_PB_MASK    0x8
+#define    RTL8367C_PB_HLDRMP_VAL_OFFSET    2
+#define    RTL8367C_PB_HLDRMP_VAL_MASK    0x4
+#define    RTL8367C_PB_BISR_BIRSTN_OFFSET    1
+#define    RTL8367C_PB_BISR_BIRSTN_MASK    0x2
+#define    RTL8367C_PB_BISR_PWRSTN_OFFSET    0
+#define    RTL8367C_PB_BISR_PWRSTN_MASK    0x1
+
+#define    RTL8367C_REG_CVLANRAM_BISR_CTRL    0x1d39
+#define    RTL8367C_SEC_RUN_CVLAN_OFFSET    4
+#define    RTL8367C_SEC_RUN_CVLAN_MASK    0x10
+#define    RTL8367C_CVALN_HLDRMP_MD_OFFSET    3
+#define    RTL8367C_CVALN_HLDRMP_MD_MASK    0x8
+#define    RTL8367C_CVALN_HLDRMP_VAL_OFFSET    2
+#define    RTL8367C_CVALN_HLDRMP_VAL_MASK    0x4
+#define    RTL8367C_CVLAN_BISR_BIRSTN_OFFSET    1
+#define    RTL8367C_CVLAN_BISR_BIRSTN_MASK    0x2
+#define    RTL8367C_CVLAN_BISR_PWRSTN_OFFSET    0
+#define    RTL8367C_CVLAN_BISR_PWRSTN_MASK    0x1
+
+#define    RTL8367C_REG_CFG_1588_TIMER_EN_GPI    0x1d3a
+#define    RTL8367C_CFG_1588_TIMER_EN_GPI_OFFSET    0
+#define    RTL8367C_CFG_1588_TIMER_EN_GPI_MASK    0x1
+
+#define    RTL8367C_REG_MDIO_PRMB_SUPP    0x1d3b
+#define    RTL8367C_FIB_HIPRI_OFFSET    14
+#define    RTL8367C_FIB_HIPRI_MASK    0x4000
+#define    RTL8367C_SMT_EN_OFFSET    13
+#define    RTL8367C_SMT_EN_MASK    0x2000
+#define    RTL8367C_P4_FB_CPL_OFFSET    12
+#define    RTL8367C_P4_FB_CPL_MASK    0x1000
+#define    RTL8367C_P3_FB_CPL_OFFSET    11
+#define    RTL8367C_P3_FB_CPL_MASK    0x800
+#define    RTL8367C_P2_FB_CPL_OFFSET    10
+#define    RTL8367C_P2_FB_CPL_MASK    0x400
+#define    RTL8367C_P1_FB_CPL_OFFSET    9
+#define    RTL8367C_P1_FB_CPL_MASK    0x200
+#define    RTL8367C_P0_FB_CPL_OFFSET    8
+#define    RTL8367C_P0_FB_CPL_MASK    0x100
+#define    RTL8367C_DBG_PKG_8367N_OFFSET    7
+#define    RTL8367C_DBG_PKG_8367N_MASK    0x80
+#define    RTL8367C_DBG_PKG_8367VB_OFFSET    6
+#define    RTL8367C_DBG_PKG_8367VB_MASK    0x40
+#define    RTL8367C_CFG_DEBUG_EN_OFFSET    5
+#define    RTL8367C_CFG_DEBUG_EN_MASK    0x20
+#define    RTL8367C_CFG_TMR_ACK_OFFSET    1
+#define    RTL8367C_CFG_TMR_ACK_MASK    0x1E
+#define    RTL8367C_CFG_PRMB_SUPP_OFFSET    0
+#define    RTL8367C_CFG_PRMB_SUPP_MASK    0x1
+
+#define    RTL8367C_REG_BOND4READ    0x1d3c
+#define    RTL8367C_BOND_BOID0_OFFSET    8
+#define    RTL8367C_BOND_BOID0_MASK    0x100
+#define    RTL8367C_BOND_SYSCLK_OFFSET    7
+#define    RTL8367C_BOND_SYSCLK_MASK    0x80
+#define    RTL8367C_BOND_PHYMODE_OFFSET    6
+#define    RTL8367C_BOND_PHYMODE_MASK    0x40
+#define    RTL8367C_BOND_DIS_PON_BIST_OFFSET    5
+#define    RTL8367C_BOND_DIS_PON_BIST_MASK    0x20
+#define    RTL8367C_BOND_DIS_TABLE_INIT_OFFSET    4
+#define    RTL8367C_BOND_DIS_TABLE_INIT_MASK    0x10
+#define    RTL8367C_BOND_BYP_AFE_PLL_OFFSET    3
+#define    RTL8367C_BOND_BYP_AFE_PLL_MASK    0x8
+#define    RTL8367C_BOND_BYP_AFE_POR_OFFSET    2
+#define    RTL8367C_BOND_BYP_AFE_POR_MASK    0x4
+#define    RTL8367C_BOND_BISR_COND_OFFSET    1
+#define    RTL8367C_BOND_BISR_COND_MASK    0x2
+#define    RTL8367C_BOND_EF_EN_OFFSET    0
+#define    RTL8367C_BOND_EF_EN_MASK    0x1
+
+#define    RTL8367C_REG_REG_TO_ECO0    0x1d3d
+
+#define    RTL8367C_REG_REG_TO_ECO1    0x1d3e
+
+#define    RTL8367C_REG_REG_TO_ECO2    0x1d3f
+
+#define    RTL8367C_REG_REG_TO_ECO3    0x1d40
+
+#define    RTL8367C_REG_REG_TO_ECO4    0x1d41
+
+#define    RTL8367C_REG_PHYSTS_CTRL0    0x1d42
+#define    RTL8367C_MACRX_DUPDET_EN_OFFSET    5
+#define    RTL8367C_MACRX_DUPDET_EN_MASK    0x20
+#define    RTL8367C_LNKUP_DLY_EN_OFFSET    4
+#define    RTL8367C_LNKUP_DLY_EN_MASK    0x10
+#define    RTL8367C_GE_100M_LNKUP_DLY_OFFSET    2
+#define    RTL8367C_GE_100M_LNKUP_DLY_MASK    0xC
+#define    RTL8367C_PHYSTS_10M_LNKUP_DLY_OFFSET    0
+#define    RTL8367C_PHYSTS_10M_LNKUP_DLY_MASK    0x3
+
+#define    RTL8367C_REG_SSC_CTRL0_0    0x1d44
+#define    RTL8367C_SSC_CTRL0_0_SSC_TYPE_OFFSET    13
+#define    RTL8367C_SSC_CTRL0_0_SSC_TYPE_MASK    0x2000
+#define    RTL8367C_SSC_CTRL0_0_PHASE_LIM_SEL_OFFSET    5
+#define    RTL8367C_SSC_CTRL0_0_PHASE_LIM_SEL_MASK    0x1FE0
+#define    RTL8367C_SSC_CTRL0_0_PHASE_LIM_EN_OFFSET    4
+#define    RTL8367C_SSC_CTRL0_0_PHASE_LIM_EN_MASK    0x10
+#define    RTL8367C_SSC_CTRL0_0_DLL_MODE_OFFSET    2
+#define    RTL8367C_SSC_CTRL0_0_DLL_MODE_MASK    0xC
+#define    RTL8367C_SSC_CTRL0_0_SSC_EN_OFFSET    1
+#define    RTL8367C_SSC_CTRL0_0_SSC_EN_MASK    0x2
+#define    RTL8367C_SSC_CTRL0_0_SSC_MODE_OFFSET    0
+#define    RTL8367C_SSC_CTRL0_0_SSC_MODE_MASK    0x1
+
+#define    RTL8367C_REG_SSC_RDM_SEED    0x1d45
+
+#define    RTL8367C_REG_SSC_PN_POLY_SEL    0x1d46
+
+#define    RTL8367C_REG_SSC_CTRL0_3    0x1d47
+#define    RTL8367C_SSC_CTRL0_3_PHSFT_CNT_OFFSET    8
+#define    RTL8367C_SSC_CTRL0_3_PHSFT_CNT_MASK    0x7F00
+#define    RTL8367C_SSC_CTRL0_3_PHSFT_A_OFFSET    7
+#define    RTL8367C_SSC_CTRL0_3_PHSFT_A_MASK    0x80
+#define    RTL8367C_SSC_CTRL0_3_PHSFT_B_OFFSET    6
+#define    RTL8367C_SSC_CTRL0_3_PHSFT_B_MASK    0x40
+#define    RTL8367C_SSC_CTRL0_3_PHSFT_UPDN_OFFSET    5
+#define    RTL8367C_SSC_CTRL0_3_PHSFT_UPDN_MASK    0x20
+#define    RTL8367C_SSC_CTRL0_3_PHSFT_PRD_OFFSET    4
+#define    RTL8367C_SSC_CTRL0_3_PHSFT_PRD_MASK    0x10
+#define    RTL8367C_SSC_CTRL0_3_PN_POLY_DEG_OFFSET    0
+#define    RTL8367C_SSC_CTRL0_3_PN_POLY_DEG_MASK    0xF
+
+#define    RTL8367C_REG_SSC_CTRL0_4    0x1d48
+#define    RTL8367C_SSC_CTRL0_4_SSC_UP1DN0_OFFSET    15
+#define    RTL8367C_SSC_CTRL0_4_SSC_UP1DN0_MASK    0x8000
+#define    RTL8367C_SSC_CTRL0_4_SSC_PERIOD_OFFSET    8
+#define    RTL8367C_SSC_CTRL0_4_SSC_PERIOD_MASK    0x7F00
+#define    RTL8367C_SSC_CTRL0_4_SSC_OFFSET_OFFSET    0
+#define    RTL8367C_SSC_CTRL0_4_SSC_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_SSC_CTRL0_5    0x1d49
+#define    RTL8367C_SSC_CTRL0_5_PH_OFS_TOG_OFFSET    15
+#define    RTL8367C_SSC_CTRL0_5_PH_OFS_TOG_MASK    0x8000
+#define    RTL8367C_SSC_CTRL0_5_PH_OFS_OFFSET    10
+#define    RTL8367C_SSC_CTRL0_5_PH_OFS_MASK    0x7C00
+#define    RTL8367C_SSC_CTRL0_5_SSC_STEP_OFFSET    4
+#define    RTL8367C_SSC_CTRL0_5_SSC_STEP_MASK    0x3F0
+#define    RTL8367C_SSC_CTRL0_5_SSC_TEST_MODE_OFFSET    2
+#define    RTL8367C_SSC_CTRL0_5_SSC_TEST_MODE_MASK    0xC
+#define    RTL8367C_SSC_CTRL0_5_SSC_PH_CFG_OFFSET    0
+#define    RTL8367C_SSC_CTRL0_5_SSC_PH_CFG_MASK    0x3
+
+#define    RTL8367C_REG_SSC_STS0    0x1d4a
+#define    RTL8367C_SSC_STS0_OFS_BUSY_OFFSET    13
+#define    RTL8367C_SSC_STS0_OFS_BUSY_MASK    0x2000
+#define    RTL8367C_SSC_STS0_OFS_TOTAL_R_OFFSET    8
+#define    RTL8367C_SSC_STS0_OFS_TOTAL_R_MASK    0x1F00
+#define    RTL8367C_SSC_STS0_CNT_GRY0_OFFSET    4
+#define    RTL8367C_SSC_STS0_CNT_GRY0_MASK    0xF0
+#define    RTL8367C_SSC_STS0_OFS_GRY0_OFFSET    0
+#define    RTL8367C_SSC_STS0_OFS_GRY0_MASK    0xF
+
+#define    RTL8367C_REG_SSC_CTRL1_0    0x1d4b
+#define    RTL8367C_SSC_CTRL1_0_SSC_TYPE_OFFSET    13
+#define    RTL8367C_SSC_CTRL1_0_SSC_TYPE_MASK    0x2000
+#define    RTL8367C_SSC_CTRL1_0_PHASE_LIM_SEL_OFFSET    5
+#define    RTL8367C_SSC_CTRL1_0_PHASE_LIM_SEL_MASK    0x1FE0
+#define    RTL8367C_SSC_CTRL1_0_PHASE_LIM_EN_OFFSET    4
+#define    RTL8367C_SSC_CTRL1_0_PHASE_LIM_EN_MASK    0x10
+#define    RTL8367C_SSC_CTRL1_0_DLL_MODE_OFFSET    2
+#define    RTL8367C_SSC_CTRL1_0_DLL_MODE_MASK    0xC
+#define    RTL8367C_SSC_CTRL1_0_SSC_EN_OFFSET    1
+#define    RTL8367C_SSC_CTRL1_0_SSC_EN_MASK    0x2
+#define    RTL8367C_SSC_CTRL1_0_SSC_MODE_OFFSET    0
+#define    RTL8367C_SSC_CTRL1_0_SSC_MODE_MASK    0x1
+
+#define    RTL8367C_REG_SSC_RDM_SEED1    0x1d4c
+
+#define    RTL8367C_REG_SSC_PN_POLY_SEL1    0x1d4d
+
+#define    RTL8367C_REG_SSC_CTRL1_3    0x1d4e
+#define    RTL8367C_SSC_CTRL1_3_PHSFT_CNT_OFFSET    8
+#define    RTL8367C_SSC_CTRL1_3_PHSFT_CNT_MASK    0x7F00
+#define    RTL8367C_SSC_CTRL1_3_PHSFT_A_OFFSET    7
+#define    RTL8367C_SSC_CTRL1_3_PHSFT_A_MASK    0x80
+#define    RTL8367C_SSC_CTRL1_3_PHSFT_B_OFFSET    6
+#define    RTL8367C_SSC_CTRL1_3_PHSFT_B_MASK    0x40
+#define    RTL8367C_SSC_CTRL1_3_PHSFT_UPDN_OFFSET    5
+#define    RTL8367C_SSC_CTRL1_3_PHSFT_UPDN_MASK    0x20
+#define    RTL8367C_SSC_CTRL1_3_PHSFT_PRD_OFFSET    4
+#define    RTL8367C_SSC_CTRL1_3_PHSFT_PRD_MASK    0x10
+#define    RTL8367C_SSC_CTRL1_3_PN_POLY_DEG_OFFSET    0
+#define    RTL8367C_SSC_CTRL1_3_PN_POLY_DEG_MASK    0xF
+
+#define    RTL8367C_REG_SSC_CTRL1_4    0x1d4f
+#define    RTL8367C_SSC_CTRL1_4_SSC_UP1DN0_OFFSET    15
+#define    RTL8367C_SSC_CTRL1_4_SSC_UP1DN0_MASK    0x8000
+#define    RTL8367C_SSC_CTRL1_4_SSC_PERIOD_OFFSET    8
+#define    RTL8367C_SSC_CTRL1_4_SSC_PERIOD_MASK    0x7F00
+#define    RTL8367C_SSC_CTRL1_4_SSC_OFFSET_OFFSET    0
+#define    RTL8367C_SSC_CTRL1_4_SSC_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_SSC_CTRL1_5    0x1d50
+#define    RTL8367C_SSC_CTRL1_5_PH_OFS_TOG_OFFSET    15
+#define    RTL8367C_SSC_CTRL1_5_PH_OFS_TOG_MASK    0x8000
+#define    RTL8367C_SSC_CTRL1_5_PH_OFS_OFFSET    10
+#define    RTL8367C_SSC_CTRL1_5_PH_OFS_MASK    0x7C00
+#define    RTL8367C_SSC_CTRL1_5_SSC_STEP_OFFSET    4
+#define    RTL8367C_SSC_CTRL1_5_SSC_STEP_MASK    0x3F0
+#define    RTL8367C_SSC_CTRL1_5_SSC_TEST_MODE_OFFSET    2
+#define    RTL8367C_SSC_CTRL1_5_SSC_TEST_MODE_MASK    0xC
+#define    RTL8367C_SSC_CTRL1_5_SSC_PH_CFG_OFFSET    0
+#define    RTL8367C_SSC_CTRL1_5_SSC_PH_CFG_MASK    0x3
+
+#define    RTL8367C_REG_SSC_STS1    0x1d51
+#define    RTL8367C_SSC_STS1_OFS_BUSY_OFFSET    13
+#define    RTL8367C_SSC_STS1_OFS_BUSY_MASK    0x2000
+#define    RTL8367C_SSC_STS1_OFS_TOTAL_R_OFFSET    8
+#define    RTL8367C_SSC_STS1_OFS_TOTAL_R_MASK    0x1F00
+#define    RTL8367C_SSC_STS1_CNT_GRY0_OFFSET    4
+#define    RTL8367C_SSC_STS1_CNT_GRY0_MASK    0xF0
+#define    RTL8367C_SSC_STS1_OFS_GRY0_OFFSET    0
+#define    RTL8367C_SSC_STS1_OFS_GRY0_MASK    0xF
+
+#define    RTL8367C_REG_SSC_CTRL2_0    0x1d52
+#define    RTL8367C_SSC_CTRL2_0_SSC_TYPE_OFFSET    13
+#define    RTL8367C_SSC_CTRL2_0_SSC_TYPE_MASK    0x2000
+#define    RTL8367C_SSC_CTRL2_0_PHASE_LIM_SEL_OFFSET    5
+#define    RTL8367C_SSC_CTRL2_0_PHASE_LIM_SEL_MASK    0x1FE0
+#define    RTL8367C_SSC_CTRL2_0_PHASE_LIM_EN_OFFSET    4
+#define    RTL8367C_SSC_CTRL2_0_PHASE_LIM_EN_MASK    0x10
+#define    RTL8367C_SSC_CTRL2_0_DLL_MODE_OFFSET    2
+#define    RTL8367C_SSC_CTRL2_0_DLL_MODE_MASK    0xC
+#define    RTL8367C_SSC_CTRL2_0_SSC_EN_OFFSET    1
+#define    RTL8367C_SSC_CTRL2_0_SSC_EN_MASK    0x2
+#define    RTL8367C_SSC_CTRL2_0_SSC_MODE_OFFSET    0
+#define    RTL8367C_SSC_CTRL2_0_SSC_MODE_MASK    0x1
+
+#define    RTL8367C_REG_SSC_RDM_SEED2    0x1d53
+
+#define    RTL8367C_REG_SSC_PN_POLY_SEL2    0x1d54
+
+#define    RTL8367C_REG_SSC_CTRL2_3    0x1d55
+#define    RTL8367C_SSC_CTRL2_3_PHSFT_CNT_OFFSET    8
+#define    RTL8367C_SSC_CTRL2_3_PHSFT_CNT_MASK    0x7F00
+#define    RTL8367C_SSC_CTRL2_3_PHSFT_A_OFFSET    7
+#define    RTL8367C_SSC_CTRL2_3_PHSFT_A_MASK    0x80
+#define    RTL8367C_SSC_CTRL2_3_PHSFT_B_OFFSET    6
+#define    RTL8367C_SSC_CTRL2_3_PHSFT_B_MASK    0x40
+#define    RTL8367C_SSC_CTRL2_3_PHSFT_UPDN_OFFSET    5
+#define    RTL8367C_SSC_CTRL2_3_PHSFT_UPDN_MASK    0x20
+#define    RTL8367C_SSC_CTRL2_3_PHSFT_PRD_OFFSET    4
+#define    RTL8367C_SSC_CTRL2_3_PHSFT_PRD_MASK    0x10
+#define    RTL8367C_SSC_CTRL2_3_PN_POLY_DEG_OFFSET    0
+#define    RTL8367C_SSC_CTRL2_3_PN_POLY_DEG_MASK    0xF
+
+#define    RTL8367C_REG_SSC_CTRL2_4    0x1d56
+#define    RTL8367C_SSC_CTRL2_4_SSC_UP1DN0_OFFSET    15
+#define    RTL8367C_SSC_CTRL2_4_SSC_UP1DN0_MASK    0x8000
+#define    RTL8367C_SSC_CTRL2_4_SSC_PERIOD_OFFSET    8
+#define    RTL8367C_SSC_CTRL2_4_SSC_PERIOD_MASK    0x7F00
+#define    RTL8367C_SSC_CTRL2_4_SSC_OFFSET_OFFSET    0
+#define    RTL8367C_SSC_CTRL2_4_SSC_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_SSC_CTRL2_5    0x1d57
+#define    RTL8367C_SSC_CTRL2_5_PH_OFS_TOG_OFFSET    15
+#define    RTL8367C_SSC_CTRL2_5_PH_OFS_TOG_MASK    0x8000
+#define    RTL8367C_SSC_CTRL2_5_PH_OFS_OFFSET    10
+#define    RTL8367C_SSC_CTRL2_5_PH_OFS_MASK    0x7C00
+#define    RTL8367C_SSC_CTRL2_5_SSC_STEP_OFFSET    4
+#define    RTL8367C_SSC_CTRL2_5_SSC_STEP_MASK    0x3F0
+#define    RTL8367C_SSC_CTRL2_5_SSC_TEST_MODE_OFFSET    2
+#define    RTL8367C_SSC_CTRL2_5_SSC_TEST_MODE_MASK    0xC
+#define    RTL8367C_SSC_CTRL2_5_SSC_PH_CFG_OFFSET    0
+#define    RTL8367C_SSC_CTRL2_5_SSC_PH_CFG_MASK    0x3
+
+#define    RTL8367C_REG_SSC_STS2    0x1d58
+#define    RTL8367C_SSC_STS2_OFS_BUSY_OFFSET    13
+#define    RTL8367C_SSC_STS2_OFS_BUSY_MASK    0x2000
+#define    RTL8367C_SSC_STS2_OFS_TOTAL_R_OFFSET    8
+#define    RTL8367C_SSC_STS2_OFS_TOTAL_R_MASK    0x1F00
+#define    RTL8367C_SSC_STS2_CNT_GRY0_OFFSET    4
+#define    RTL8367C_SSC_STS2_CNT_GRY0_MASK    0xF0
+#define    RTL8367C_SSC_STS2_OFS_GRY0_OFFSET    0
+#define    RTL8367C_SSC_STS2_OFS_GRY0_MASK    0xF
+
+#define    RTL8367C_REG_SSC_CTRL3_0    0x1d59
+#define    RTL8367C_SSC_CTRL3_0_SSC_TYPE_OFFSET    13
+#define    RTL8367C_SSC_CTRL3_0_SSC_TYPE_MASK    0x2000
+#define    RTL8367C_SSC_CTRL3_0_PHASE_LIM_SEL_OFFSET    5
+#define    RTL8367C_SSC_CTRL3_0_PHASE_LIM_SEL_MASK    0x1FE0
+#define    RTL8367C_SSC_CTRL3_0_PHASE_LIM_EN_OFFSET    4
+#define    RTL8367C_SSC_CTRL3_0_PHASE_LIM_EN_MASK    0x10
+#define    RTL8367C_SSC_CTRL3_0_DLL_MODE_OFFSET    2
+#define    RTL8367C_SSC_CTRL3_0_DLL_MODE_MASK    0xC
+#define    RTL8367C_SSC_CTRL3_0_SSC_EN_OFFSET    1
+#define    RTL8367C_SSC_CTRL3_0_SSC_EN_MASK    0x2
+#define    RTL8367C_SSC_CTRL3_0_SSC_MODE_OFFSET    0
+#define    RTL8367C_SSC_CTRL3_0_SSC_MODE_MASK    0x1
+
+#define    RTL8367C_REG_SSC_RDM_SEED3    0x1d5a
+
+#define    RTL8367C_REG_SSC_PN_POLY_SEL3    0x1d5b
+
+#define    RTL8367C_REG_SSC_CTRL3_3    0x1d5c
+#define    RTL8367C_SSC_CTRL3_3_PHSFT_CNT_OFFSET    8
+#define    RTL8367C_SSC_CTRL3_3_PHSFT_CNT_MASK    0x7F00
+#define    RTL8367C_SSC_CTRL3_3_PHSFT_A_OFFSET    7
+#define    RTL8367C_SSC_CTRL3_3_PHSFT_A_MASK    0x80
+#define    RTL8367C_SSC_CTRL3_3_PHSFT_B_OFFSET    6
+#define    RTL8367C_SSC_CTRL3_3_PHSFT_B_MASK    0x40
+#define    RTL8367C_SSC_CTRL3_3_PHSFT_UPDN_OFFSET    5
+#define    RTL8367C_SSC_CTRL3_3_PHSFT_UPDN_MASK    0x20
+#define    RTL8367C_SSC_CTRL3_3_PHSFT_PRD_OFFSET    4
+#define    RTL8367C_SSC_CTRL3_3_PHSFT_PRD_MASK    0x10
+#define    RTL8367C_SSC_CTRL3_3_PN_POLY_DEG_OFFSET    0
+#define    RTL8367C_SSC_CTRL3_3_PN_POLY_DEG_MASK    0xF
+
+#define    RTL8367C_REG_SSC_CTRL3_4    0x1d5d
+#define    RTL8367C_SSC_CTRL3_4_SSC_UP1DN0_OFFSET    15
+#define    RTL8367C_SSC_CTRL3_4_SSC_UP1DN0_MASK    0x8000
+#define    RTL8367C_SSC_CTRL3_4_SSC_PERIOD_OFFSET    8
+#define    RTL8367C_SSC_CTRL3_4_SSC_PERIOD_MASK    0x7F00
+#define    RTL8367C_SSC_CTRL3_4_SSC_OFFSET_OFFSET    0
+#define    RTL8367C_SSC_CTRL3_4_SSC_OFFSET_MASK    0xFF
+
+#define    RTL8367C_REG_SSC_CTRL3_5    0x1d5e
+#define    RTL8367C_SSC_CTRL3_5_PH_OFS_TOG_OFFSET    15
+#define    RTL8367C_SSC_CTRL3_5_PH_OFS_TOG_MASK    0x8000
+#define    RTL8367C_SSC_CTRL3_5_PH_OFS_OFFSET    10
+#define    RTL8367C_SSC_CTRL3_5_PH_OFS_MASK    0x7C00
+#define    RTL8367C_SSC_CTRL3_5_SSC_STEP_OFFSET    4
+#define    RTL8367C_SSC_CTRL3_5_SSC_STEP_MASK    0x3F0
+#define    RTL8367C_SSC_CTRL3_5_SSC_TEST_MODE_OFFSET    2
+#define    RTL8367C_SSC_CTRL3_5_SSC_TEST_MODE_MASK    0xC
+#define    RTL8367C_SSC_CTRL3_5_SSC_PH_CFG_OFFSET    0
+#define    RTL8367C_SSC_CTRL3_5_SSC_PH_CFG_MASK    0x3
+
+#define    RTL8367C_REG_SSC_STS3    0x1d5f
+#define    RTL8367C_SSC_STS3_OFS_BUSY_OFFSET    13
+#define    RTL8367C_SSC_STS3_OFS_BUSY_MASK    0x2000
+#define    RTL8367C_SSC_STS3_OFS_TOTAL_R_OFFSET    8
+#define    RTL8367C_SSC_STS3_OFS_TOTAL_R_MASK    0x1F00
+#define    RTL8367C_SSC_STS3_CNT_GRY0_OFFSET    4
+#define    RTL8367C_SSC_STS3_CNT_GRY0_MASK    0xF0
+#define    RTL8367C_SSC_STS3_OFS_GRY0_OFFSET    0
+#define    RTL8367C_SSC_STS3_OFS_GRY0_MASK    0xF
+
+#define    RTL8367C_REG_PHY_POLL_CFG13    0x1d60
+
+#define    RTL8367C_REG_PHY_POLL_CFG14    0x1d61
+
+#define    RTL8367C_REG_FRC_SYS_CLK    0x1d62
+#define    RTL8367C_SYSCLK_FRC_MD_OFFSET    1
+#define    RTL8367C_SYSCLK_FRC_MD_MASK    0x2
+#define    RTL8367C_SYSCLK_FRC_VAL_OFFSET    0
+#define    RTL8367C_SYSCLK_FRC_VAL_MASK    0x1
+
+#define    RTL8367C_REG_AFE_SSC_CTRL    0x1d63
+#define    RTL8367C_PH_RSTB_TXD1_OFFSET    9
+#define    RTL8367C_PH_RSTB_TXD1_MASK    0x200
+#define    RTL8367C_PH_RSTB_TXC1_OFFSET    8
+#define    RTL8367C_PH_RSTB_TXC1_MASK    0x100
+#define    RTL8367C_PH_RSTB_TXD0_OFFSET    7
+#define    RTL8367C_PH_RSTB_TXD0_MASK    0x80
+#define    RTL8367C_PH_RSTB_TXC0_OFFSET    6
+#define    RTL8367C_PH_RSTB_TXC0_MASK    0x40
+#define    RTL8367C_PH_RSTBSYS_OFFSET    5
+#define    RTL8367C_PH_RSTBSYS_MASK    0x20
+#define    RTL8367C_PH_RSTB8051_OFFSET    4
+#define    RTL8367C_PH_RSTB8051_MASK    0x10
+#define    RTL8367C_OREG_SSC_OFFSET    0
+#define    RTL8367C_OREG_SSC_MASK    0xF
+
+#define    RTL8367C_REG_BUFF_RST_CTRL0    0x1d64
+#define    RTL8367C_BUFFRST_TXESD_EN_OFFSET    13
+#define    RTL8367C_BUFFRST_TXESD_EN_MASK    0x2000
+#define    RTL8367C_BUFF_RST_TIME_LONG_OFFSET    8
+#define    RTL8367C_BUFF_RST_TIME_LONG_MASK    0x1F00
+#define    RTL8367C_BUFF_RST_TIME_SHORT_OFFSET    3
+#define    RTL8367C_BUFF_RST_TIME_SHORT_MASK    0xF8
+#define    RTL8367C_SW_BUFF_RST_OFFSET    2
+#define    RTL8367C_SW_BUFF_RST_MASK    0x4
+#define    RTL8367C_IMS_BUFF_RST_OFFSET    1
+#define    RTL8367C_IMS_BUFF_RST_MASK    0x2
+#define    RTL8367C_IMR_BUFF_RST_OFFSET    0
+#define    RTL8367C_IMR_BUFF_RST_MASK    0x1
+
+#define    RTL8367C_REG_BUFF_RST_CTRL1    0x1d65
+#define    RTL8367C_BUFFRST_SYSOVER_EN_OFFSET    10
+#define    RTL8367C_BUFFRST_SYSOVER_EN_MASK    0x400
+#define    RTL8367C_BUFFRST_SYSOVER_THR_OFFSET    0
+#define    RTL8367C_BUFFRST_SYSOVER_THR_MASK    0x3FF
+
+#define    RTL8367C_REG_BUFF_RST_CTRL2    0x1d66
+#define    RTL8367C_BUFFRST_QOVER_EN_OFFSET    10
+#define    RTL8367C_BUFFRST_QOVER_EN_MASK    0x400
+#define    RTL8367C_BUFFRST_QOVER_THR_OFFSET    0
+#define    RTL8367C_BUFFRST_QOVER_THR_MASK    0x3FF
+
+#define    RTL8367C_REG_BUFF_RST_CTRL3    0x1d67
+#define    RTL8367C_DSC_TIMER_OFFSET    11
+#define    RTL8367C_DSC_TIMER_MASK    0x7800
+#define    RTL8367C_BUFFRST_DSCOVER_THR_OFFSET    1
+#define    RTL8367C_BUFFRST_DSCOVER_THR_MASK    0x7FE
+#define    RTL8367C_BUFFRST_DSCOVER_EN_OFFSET    0
+#define    RTL8367C_BUFFRST_DSCOVER_EN_MASK    0x1
+
+#define    RTL8367C_REG_BUFF_RST_CTRL4    0x1d68
+#define    RTL8367C_INDSC_TIMER_OFFSET    11
+#define    RTL8367C_INDSC_TIMER_MASK    0x7800
+#define    RTL8367C_BUFFRST_INDSCOVER_THR_OFFSET    1
+#define    RTL8367C_BUFFRST_INDSCOVER_THR_MASK    0x7FE
+#define    RTL8367C_BUFFRST_INDSCOVER_EN_OFFSET    0
+#define    RTL8367C_BUFFRST_INDSCOVER_EN_MASK    0x1
+
+#define    RTL8367C_REG_BUFF_RST_CTRL5    0x1d69
+#define    RTL8367C_TX_ESD_MODE_OFFSET    8
+#define    RTL8367C_TX_ESD_MODE_MASK    0x100
+#define    RTL8367C_TX_ESD_LVL_OFFSET    0
+#define    RTL8367C_TX_ESD_LVL_MASK    0xFF
+
+#define    RTL8367C_REG_TOP_CON0    0x1d70
+#define    RTL8367C_TOP_CON0_SDS_PWR_ISO_1_OFFSET    15
+#define    RTL8367C_TOP_CON0_SDS_PWR_ISO_1_MASK    0x8000
+#define    RTL8367C_OCP_TIMEOUT_P7_5_OFFSET    12
+#define    RTL8367C_OCP_TIMEOUT_P7_5_MASK    0x7000
+#define    RTL8367C_FIB_EEE_AB_OFFSET    11
+#define    RTL8367C_FIB_EEE_AB_MASK    0x800
+#define    RTL8367C_ADCCKIEN_OFFSET    10
+#define    RTL8367C_ADCCKIEN_MASK    0x400
+#define    RTL8367C_OCP_TIMEOUT_OFFSET    5
+#define    RTL8367C_OCP_TIMEOUT_MASK    0x3E0
+#define    RTL8367C_TOP_CON0_SDS_PWR_ISO_OFFSET    4
+#define    RTL8367C_TOP_CON0_SDS_PWR_ISO_MASK    0x10
+#define    RTL8367C_RG2_TXC_SEL_OFFSET    3
+#define    RTL8367C_RG2_TXC_SEL_MASK    0x8
+#define    RTL8367C_RG1TXC_SEL_OFFSET    2
+#define    RTL8367C_RG1TXC_SEL_MASK    0x4
+#define    RTL8367C_SYNC_1588_EN_OFFSET    1
+#define    RTL8367C_SYNC_1588_EN_MASK    0x2
+#define    RTL8367C_LS_MODE_OFFSET    0
+#define    RTL8367C_LS_MODE_MASK    0x1
+
+#define    RTL8367C_REG_TOP_CON1    0x1d71
+#define    RTL8367C_TA_CHK_EN_OFFSET    2
+#define    RTL8367C_TA_CHK_EN_MASK    0x4
+#define    RTL8367C_SLV_EG_SEL_OFFSET    1
+#define    RTL8367C_SLV_EG_SEL_MASK    0x2
+#define    RTL8367C_IIC_OP_DRAIN_OFFSET    0
+#define    RTL8367C_IIC_OP_DRAIN_MASK    0x1
+
+#define    RTL8367C_REG_SWR_FPWM    0x1d72
+#define    RTL8367C_SWR_FPWM_OFFSET    0
+#define    RTL8367C_SWR_FPWM_MASK    0x1
+
+#define    RTL8367C_REG_EEEP_CTRL_500M    0x1d73
+
+#define    RTL8367C_REG_SHORT_PRMB    0x1d74
+#define    RTL8367C_SHORT_PRMB_OFFSET    0
+#define    RTL8367C_SHORT_PRMB_MASK    0x1
+
+#define    RTL8367C_REG_INDSC_THR_CTRL    0x1d75
+#define    RTL8367C_INDSC_THR_CTRL_OFFSET    0
+#define    RTL8367C_INDSC_THR_CTRL_MASK    0x7FF
+
+#define    RTL8367C_REG_SET_PAD_CTRL_NEW    0x1d80
+#define    RTL8367C_SET_PAD_CTRL_NEW_OFFSET    0
+#define    RTL8367C_SET_PAD_CTRL_NEW_MASK    0x1
+
+#define    RTL8367C_REG_SET_PAD_DRI_0    0x1d81
+
+#define    RTL8367C_REG_SET_PAD_DRI_1    0x1d82
+
+#define    RTL8367C_REG_SET_PAD_DRI_2    0x1d83
+
+#define    RTL8367C_REG_SET_PAD_SLEW_0    0x1d84
+
+#define    RTL8367C_REG_SET_PAD_SLEW_1    0x1d85
+
+#define    RTL8367C_REG_SET_PAD_SLEW_2    0x1d86
+
+#define    RTL8367C_REG_SET_PAD_SMT_0    0x1d87
+
+#define    RTL8367C_REG_SET_PAD_SMT_1    0x1d88
+
+#define    RTL8367C_REG_SET_PAD_SMT_2    0x1d89
+
+#define    RTL8367C_REG_M_I2C_CTL_STA_REG    0x1d8a
+#define    RTL8367C_TX_RX_DATA_OFFSET    8
+#define    RTL8367C_TX_RX_DATA_MASK    0xFF00
+#define    RTL8367C_DUMB_RW_ERR_OFFSET    7
+#define    RTL8367C_DUMB_RW_ERR_MASK    0x80
+#define    RTL8367C_SLV_ACK_FLAG_OFFSET    6
+#define    RTL8367C_SLV_ACK_FLAG_MASK    0x40
+#define    RTL8367C_M_I2C_BUS_IDLE_OFFSET    5
+#define    RTL8367C_M_I2C_BUS_IDLE_MASK    0x20
+#define    RTL8367C_I2C_CMD_TYPE_OFFSET    1
+#define    RTL8367C_I2C_CMD_TYPE_MASK    0x1E
+#define    RTL8367C_I2C_CMD_EXEC_OFFSET    0
+#define    RTL8367C_I2C_CMD_EXEC_MASK    0x1
+
+#define    RTL8367C_REG_M_I2C_DUMB_RW_ADDR_0    0x1d8b
+
+#define    RTL8367C_REG_M_I2C_DUMB_RW_ADDR_1    0x1d8c
+
+#define    RTL8367C_REG_M_I2C_DUMB_RW_DATA_0    0x1d8d
+
+#define    RTL8367C_REG_M_I2C_DUMB_RW_DATA_1    0x1d8e
+
+#define    RTL8367C_REG_M_I2C_DUMB_RW_CTL    0x1d8f
+#define    RTL8367C_DUMB_I2C_CTL_CODE_OFFSET    8
+#define    RTL8367C_DUMB_I2C_CTL_CODE_MASK    0x7F00
+#define    RTL8367C_DUMB_RW_I2C_FORMAT_OFFSET    4
+#define    RTL8367C_DUMB_RW_I2C_FORMAT_MASK    0x10
+#define    RTL8367C_DUMB_RW_DATA_MODE_OFFSET    2
+#define    RTL8367C_DUMB_RW_DATA_MODE_MASK    0xC
+#define    RTL8367C_DUMB_RW_ADDR_MODE_OFFSET    0
+#define    RTL8367C_DUMB_RW_ADDR_MODE_MASK    0x3
+
+#define    RTL8367C_REG_M_I2C_SYS_CTL    0x1d90
+#define    RTL8367C_M_I2C_SCL_IO_MUX_OFFSET    12
+#define    RTL8367C_M_I2C_SCL_IO_MUX_MASK    0x3000
+#define    RTL8367C_M_I2C_SDA_IO_MUX_OFFSET    10
+#define    RTL8367C_M_I2C_SDA_IO_MUX_MASK    0xC00
+#define    RTL8367C_M_I2C_SDA_OD_EN_OFFSET    9
+#define    RTL8367C_M_I2C_SDA_OD_EN_MASK    0x200
+#define    RTL8367C_M_I2C_SCL_OD_EN_OFFSET    8
+#define    RTL8367C_M_I2C_SCL_OD_EN_MASK    0x100
+#define    RTL8367C_M_I2C_SCL_F_DIV_OFFSET    0
+#define    RTL8367C_M_I2C_SCL_F_DIV_MASK    0xFF
+
+#define    RTL8367C_REG_HT_PB_SRAM_CTRL    0x1da0
+#define    RTL8367C_HTPB_RW_OFFSET    2
+#define    RTL8367C_HTPB_RW_MASK    0x4
+#define    RTL8367C_HTPB_SEL_OFFSET    1
+#define    RTL8367C_HTPB_SEL_MASK    0x2
+#define    RTL8367C_HTPB_CE_OFFSET    0
+#define    RTL8367C_HTPB_CE_MASK    0x1
+
+#define    RTL8367C_REG_HT_PB_SRAM_ADDR    0x1da1
+
+#define    RTL8367C_REG_HT_PB_SRAM_DIN0    0x1da2
+
+#define    RTL8367C_REG_HT_PB_SRAM_DIN1    0x1da3
+
+#define    RTL8367C_REG_HT_PB_SRAM_DOUT0    0x1da4
+
+#define    RTL8367C_REG_HT_PB_SRAM_DOUT1    0x1da5
+
+#define    RTL8367C_REG_PHY_STAT_0    0x1db0
+
+#define    RTL8367C_REG_PHY_STAT_1    0x1db1
+
+#define    RTL8367C_REG_PHY_STAT_2    0x1db2
+
+#define    RTL8367C_REG_PHY_STAT_3    0x1db3
+
+#define    RTL8367C_REG_PHY_STAT_4    0x1db4
+
+#define    RTL8367C_REG_PHY_STAT_5    0x1db5
+
+#define    RTL8367C_REG_PHY_STAT_6    0x1db6
+
+#define    RTL8367C_REG_PHY_STAT_7    0x1db7
+
+#define    RTL8367C_REG_SDS_STAT_0    0x1db8
+
+#define    RTL8367C_REG_SDS_STAT_1    0x1db9
+
+#define    RTL8367C_REG_MAC_LINK_STAT_0    0x1dba
+#define    RTL8367C_MAC_LINK_STAT_CUR_0_OFFSET    8
+#define    RTL8367C_MAC_LINK_STAT_CUR_0_MASK    0xFF00
+#define    RTL8367C_MAC_LINK_STAT_LATCH_0_OFFSET    0
+#define    RTL8367C_MAC_LINK_STAT_LATCH_0_MASK    0xFF
+
+#define    RTL8367C_REG_MAC_LINK_STAT_1    0x1dbb
+#define    RTL8367C_MAC_LINK_STAT_1_Reserved_OFFSET    6
+#define    RTL8367C_MAC_LINK_STAT_1_Reserved_MASK    0xFFC0
+#define    RTL8367C_MAC_LINK_STAT_CUR_1_OFFSET    3
+#define    RTL8367C_MAC_LINK_STAT_CUR_1_MASK    0x38
+#define    RTL8367C_MAC_LINK_STAT_LATCH_1_OFFSET    0
+#define    RTL8367C_MAC_LINK_STAT_LATCH_1_MASK    0x7
+
+#define    RTL8367C_REG_MISC_CONTROL_1    0x1dc0
+#define    RTL8367C_P7_FB_CPL_OFFSET    2
+#define    RTL8367C_P7_FB_CPL_MASK    0x4
+#define    RTL8367C_P6_FB_CPL_OFFSET    1
+#define    RTL8367C_P6_FB_CPL_MASK    0x2
+#define    RTL8367C_P5_FB_CPL_OFFSET    0
+#define    RTL8367C_P5_FB_CPL_MASK    0x1
+
+#define    RTL8367C_REG_SDS_MISC_1    0x1dc1
+#define    RTL8367C_CFG_SGMII_RXFC_1_OFFSET    14
+#define    RTL8367C_CFG_SGMII_RXFC_1_MASK    0x4000
+#define    RTL8367C_CFG_SGMII_TXFC_1_OFFSET    13
+#define    RTL8367C_CFG_SGMII_TXFC_1_MASK    0x2000
+#define    RTL8367C_CFG_MAC9_SEL_HSGMII_OFFSET    11
+#define    RTL8367C_CFG_MAC9_SEL_HSGMII_MASK    0x800
+#define    RTL8367C_CFG_SGMII_FDUP_1_OFFSET    10
+#define    RTL8367C_CFG_SGMII_FDUP_1_MASK    0x400
+#define    RTL8367C_CFG_SGMII_LINK_1_OFFSET    9
+#define    RTL8367C_CFG_SGMII_LINK_1_MASK    0x200
+#define    RTL8367C_CFG_SGMII_SPD_1_OFFSET    7
+#define    RTL8367C_CFG_SGMII_SPD_1_MASK    0x180
+#define    RTL8367C_CFG_MAC9_SEL_SGMII_OFFSET    6
+#define    RTL8367C_CFG_MAC9_SEL_SGMII_MASK    0x40
+#define    RTL8367C_CFG_SDS_MODE_14C_1_OFFSET    0
+#define    RTL8367C_CFG_SDS_MODE_14C_1_MASK    0x7
+
+#define    RTL8367C_REG_FIBER_CFG_2_1    0x1dc2
+#define    RTL8367C_SDS_RX_DISABLE_1_OFFSET    6
+#define    RTL8367C_SDS_RX_DISABLE_1_MASK    0xC0
+#define    RTL8367C_SDS_TX_DISABLE_1_OFFSET    4
+#define    RTL8367C_SDS_TX_DISABLE_1_MASK    0x30
+#define    RTL8367C_FIBER_CFG_2_1_SDS_PWR_ISO_1_OFFSET    2
+#define    RTL8367C_FIBER_CFG_2_1_SDS_PWR_ISO_1_MASK    0xC
+#define    RTL8367C_SDS_FRC_LD_1_OFFSET    0
+#define    RTL8367C_SDS_FRC_LD_1_MASK    0x3
+
+#define    RTL8367C_REG_FIBER_CFG_1_1    0x1dc3
+#define    RTL8367C_SDS_FRC_REG4_1_OFFSET    12
+#define    RTL8367C_SDS_FRC_REG4_1_MASK    0x1000
+#define    RTL8367C_SDS_FRC_REG4_FIB100_1_OFFSET    11
+#define    RTL8367C_SDS_FRC_REG4_FIB100_1_MASK    0x800
+#define    RTL8367C_SDS_FRC_MODE_1_OFFSET    3
+#define    RTL8367C_SDS_FRC_MODE_1_MASK    0x8
+#define    RTL8367C_SDS_MODE_1_OFFSET    0
+#define    RTL8367C_SDS_MODE_1_MASK    0x7
+
+#define    RTL8367C_REG_PHYSTS_CTRL0_1    0x1dc4
+#define    RTL8367C_LNKUP_DLY_EN_EXT2_OFFSET    9
+#define    RTL8367C_LNKUP_DLY_EN_EXT2_MASK    0x200
+#define    RTL8367C_GE_100M_LNKUP_DLY_EXT2_OFFSET    7
+#define    RTL8367C_GE_100M_LNKUP_DLY_EXT2_MASK    0x180
+#define    RTL8367C_PHYSTS_10M_LNKUP_DLY_EXT2_OFFSET    5
+#define    RTL8367C_PHYSTS_10M_LNKUP_DLY_EXT2_MASK    0x60
+#define    RTL8367C_LNKUP_DLY_EN_EXT1_OFFSET    4
+#define    RTL8367C_LNKUP_DLY_EN_EXT1_MASK    0x10
+#define    RTL8367C_GE_100M_LNKUP_DLY_EXT1_OFFSET    2
+#define    RTL8367C_GE_100M_LNKUP_DLY_EXT1_MASK    0xC
+#define    RTL8367C_PHYSTS_10M_LNKUP_DLY_EXT1_OFFSET    0
+#define    RTL8367C_PHYSTS_10M_LNKUP_DLY_EXT1_MASK    0x3
+
+#define    RTL8367C_REG_FIBER_CFG_3_1    0x1dc5
+#define    RTL8367C_FIBER_CFG_3_1_OFFSET    0
+#define    RTL8367C_FIBER_CFG_3_1_MASK    0xFFF
+
+#define    RTL8367C_REG_FIBER_CFG_4_1    0x1dc6
+
+#define    RTL8367C_REG_BUFF_RST_CTRL2_2    0x1dc7
+#define    RTL8367C_Cfg_buffrst_sysover_thr_1_OFFSET    3
+#define    RTL8367C_Cfg_buffrst_sysover_thr_1_MASK    0x8
+#define    RTL8367C_Cfg_buffrst_qover_thr_OFFSET    2
+#define    RTL8367C_Cfg_buffrst_qover_thr_MASK    0x4
+#define    RTL8367C_Cfg_buffrst_indscover_thr_1_OFFSET    1
+#define    RTL8367C_Cfg_buffrst_indscover_thr_1_MASK    0x2
+#define    RTL8367C_Cfg_buffrst_dscover_thr_1_OFFSET    0
+#define    RTL8367C_Cfg_buffrst_dscover_thr_1_MASK    0x1
+
+#define    RTL8367C_REG_PHY_DEBUG_CNT_CTRL    0x1dc8
+#define    RTL8367C_PHY_MIB_RST_7_OFFSET    15
+#define    RTL8367C_PHY_MIB_RST_7_MASK    0x8000
+#define    RTL8367C_PHY_MIB_RST_6_OFFSET    14
+#define    RTL8367C_PHY_MIB_RST_6_MASK    0x4000
+#define    RTL8367C_PHY_MIB_RST_5_OFFSET    13
+#define    RTL8367C_PHY_MIB_RST_5_MASK    0x2000
+#define    RTL8367C_PHY_MIB_RST_4_OFFSET    12
+#define    RTL8367C_PHY_MIB_RST_4_MASK    0x1000
+#define    RTL8367C_PHY_MIB_RST_3_OFFSET    11
+#define    RTL8367C_PHY_MIB_RST_3_MASK    0x800
+#define    RTL8367C_PHY_MIB_RST_2_OFFSET    10
+#define    RTL8367C_PHY_MIB_RST_2_MASK    0x400
+#define    RTL8367C_PHY_MIB_RST_1_OFFSET    9
+#define    RTL8367C_PHY_MIB_RST_1_MASK    0x200
+#define    RTL8367C_PHY_MIB_RST_0_OFFSET    8
+#define    RTL8367C_PHY_MIB_RST_0_MASK    0x100
+#define    RTL8367C_PHY_MIB_EN_7_OFFSET    7
+#define    RTL8367C_PHY_MIB_EN_7_MASK    0x80
+#define    RTL8367C_PHY_MIB_EN_6_OFFSET    6
+#define    RTL8367C_PHY_MIB_EN_6_MASK    0x40
+#define    RTL8367C_PHY_MIB_EN_5_OFFSET    5
+#define    RTL8367C_PHY_MIB_EN_5_MASK    0x20
+#define    RTL8367C_PHY_MIB_EN_4_OFFSET    4
+#define    RTL8367C_PHY_MIB_EN_4_MASK    0x10
+#define    RTL8367C_PHY_MIB_EN_3_OFFSET    3
+#define    RTL8367C_PHY_MIB_EN_3_MASK    0x8
+#define    RTL8367C_PHY_MIB_EN_2_OFFSET    2
+#define    RTL8367C_PHY_MIB_EN_2_MASK    0x4
+#define    RTL8367C_PHY_MIB_EN_1_OFFSET    1
+#define    RTL8367C_PHY_MIB_EN_1_MASK    0x2
+#define    RTL8367C_PHY_MIB_EN_0_OFFSET    0
+#define    RTL8367C_PHY_MIB_EN_0_MASK    0x1
+
+#define    RTL8367C_REG_TXPKT_CNT_L_0    0x1dc9
+
+#define    RTL8367C_REG_TXPKT_CNT_H_0    0x1dca
+
+#define    RTL8367C_REG_RXPKT_CNT_L_0    0x1dcb
+
+#define    RTL8367C_REG_RXPKT_CNT_H_0    0x1dcc
+
+#define    RTL8367C_REG_TX_CRC_0    0x1dcd
+
+#define    RTL8367C_REG_RX_CRC_0    0x1dce
+
+#define    RTL8367C_REG_TXPKT_CNT_L_1    0x1dcf
+
+#define    RTL8367C_REG_TXPKT_CNT_H_1    0x1dd0
+
+#define    RTL8367C_REG_RXPKT_CNT_L_1    0x1dd1
+
+#define    RTL8367C_REG_RXPKT_CNT_H_1    0x1dd2
+
+#define    RTL8367C_REG_TX_CRC_1    0x1dd3
+
+#define    RTL8367C_REG_RX_CRC_1    0x1dd4
+
+#define    RTL8367C_REG_TXPKT_CNT_L_2    0x1dd5
+
+#define    RTL8367C_REG_TXPKT_CNT_H_2    0x1dd6
+
+#define    RTL8367C_REG_RXPKT_CNT_L_2    0x1dd7
+
+#define    RTL8367C_REG_RXPKT_CNT_H_2    0x1dd8
+
+#define    RTL8367C_REG_TX_CRC_2    0x1dd9
+
+#define    RTL8367C_REG_RX_CRC_2    0x1dda
+
+#define    RTL8367C_REG_TXPKT_CNT_L_3    0x1ddb
+
+#define    RTL8367C_REG_TXPKT_CNT_H_3    0x1ddc
+
+#define    RTL8367C_REG_RXPKT_CNT_L_3    0x1ddd
+
+#define    RTL8367C_REG_RXPKT_CNT_H_3    0x1dde
+
+#define    RTL8367C_REG_TX_CRC_3    0x1ddf
+
+#define    RTL8367C_REG_RX_CRC_3    0x1de0
+
+#define    RTL8367C_REG_TXPKT_CNT_L_4    0x1de1
+
+#define    RTL8367C_REG_TXPKT_CNT_H_4    0x1de2
+
+#define    RTL8367C_REG_RXPKT_CNT_L_4    0x1de3
+
+#define    RTL8367C_REG_RXPKT_CNT_H_4    0x1de4
+
+#define    RTL8367C_REG_TX_CRC_4    0x1de5
+
+#define    RTL8367C_REG_RX_CRC_4    0x1de6
+
+#define    RTL8367C_REG_TXPKT_CNT_L_5    0x1de7
+
+#define    RTL8367C_REG_TXPKT_CNT_H_5    0x1de8
+
+#define    RTL8367C_REG_RXPKT_CNT_L_5    0x1de9
+
+#define    RTL8367C_REG_RXPKT_CNT_H_5    0x1dea
+
+#define    RTL8367C_REG_TX_CRC_5    0x1deb
+
+#define    RTL8367C_REG_RX_CRC_5    0x1dec
+
+#define    RTL8367C_REG_TXPKT_CNT_L_6    0x1ded
+
+#define    RTL8367C_REG_TXPKT_CNT_H_6    0x1dee
+
+#define    RTL8367C_REG_RXPKT_CNT_L_6    0x1def
+
+#define    RTL8367C_REG_RXPKT_CNT_H_6    0x1df0
+
+#define    RTL8367C_REG_TX_CRC_6    0x1df1
+
+#define    RTL8367C_REG_RX_CRC_6    0x1df2
+
+#define    RTL8367C_REG_TXPKT_CNT_L_7    0x1df3
+
+#define    RTL8367C_REG_TXPKT_CNT_H_7    0x1df4
+
+#define    RTL8367C_REG_RXPKT_CNT_L_7    0x1df5
+
+#define    RTL8367C_REG_RXPKT_CNT_H_7    0x1df6
+
+#define    RTL8367C_REG_TX_CRC_7    0x1df7
+
+#define    RTL8367C_REG_RX_CRC_7    0x1df8
+
+#define    RTL8367C_REG_BOND_DBG_0    0x1df9
+
+#define    RTL8367C_REG_BOND_DBG_1    0x1dfa
+
+#define    RTL8367C_REG_STRP_DBG_0    0x1dfb
+
+#define    RTL8367C_REG_STRP_DBG_1    0x1dfc
+
+#define    RTL8367C_REG_STRP_DBG_2    0x1dfd
+
+/* (16'h1f00)patch_reg */
+
+#define    RTL8367C_REG_INDRECT_ACCESS_CTRL    0x1f00
+#define    RTL8367C_RW_OFFSET    1
+#define    RTL8367C_RW_MASK    0x2
+#define    RTL8367C_CMD_OFFSET    0
+#define    RTL8367C_CMD_MASK    0x1
+
+#define    RTL8367C_REG_INDRECT_ACCESS_STATUS    0x1f01
+#define    RTL8367C_INDRECT_ACCESS_STATUS_OFFSET    2
+#define    RTL8367C_INDRECT_ACCESS_STATUS_MASK    0x7
+
+#define    RTL8367C_REG_INDRECT_ACCESS_ADDRESS    0x1f02
+
+#define    RTL8367C_REG_INDRECT_ACCESS_WRITE_DATA    0x1f03
+
+#define    RTL8367C_REG_INDRECT_ACCESS_READ_DATA    0x1f04
+
+/* (16'h6200)fib_page */
+
+#define    RTL8367C_REG_FIB0_CFG00    0x6200
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_RST_OFFSET    15
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_RST_MASK    0x8000
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_LPK_OFFSET    14
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_LPK_MASK    0x4000
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_SPD_RD_0_OFFSET    13
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_SPD_RD_0_MASK    0x2000
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_ANEN_OFFSET    12
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_ANEN_MASK    0x1000
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_PDOWN_OFFSET    11
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_PDOWN_MASK    0x800
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_ISO_OFFSET    10
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_ISO_MASK    0x400
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_RESTART_OFFSET    9
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_RESTART_MASK    0x200
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_FULLDUP_OFFSET    8
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_FULLDUP_MASK    0x100
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_SPD_RD_1_OFFSET    6
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_SPD_RD_1_MASK    0x40
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_FRCTX_OFFSET    5
+#define    RTL8367C_FIB0_CFG00_CFG_FIB_FRCTX_MASK    0x20
+
+#define    RTL8367C_REG_FIB0_CFG01    0x6201
+#define    RTL8367C_FIB0_CFG01_CAPBILITY_OFFSET    6
+#define    RTL8367C_FIB0_CFG01_CAPBILITY_MASK    0xFFC0
+#define    RTL8367C_FIB0_CFG01_AN_COMPLETE_OFFSET    5
+#define    RTL8367C_FIB0_CFG01_AN_COMPLETE_MASK    0x20
+#define    RTL8367C_FIB0_CFG01_R_FAULT_OFFSET    4
+#define    RTL8367C_FIB0_CFG01_R_FAULT_MASK    0x10
+#define    RTL8367C_FIB0_CFG01_NWAY_ABILITY_OFFSET    3
+#define    RTL8367C_FIB0_CFG01_NWAY_ABILITY_MASK    0x8
+#define    RTL8367C_FIB0_CFG01_LINK_STATUS_OFFSET    2
+#define    RTL8367C_FIB0_CFG01_LINK_STATUS_MASK    0x4
+#define    RTL8367C_FIB0_CFG01_JABBER_DETECT_OFFSET    1
+#define    RTL8367C_FIB0_CFG01_JABBER_DETECT_MASK    0x2
+#define    RTL8367C_FIB0_CFG01_EXTENDED_CAPBILITY_OFFSET    0
+#define    RTL8367C_FIB0_CFG01_EXTENDED_CAPBILITY_MASK    0x1
+
+#define    RTL8367C_REG_FIB0_CFG02    0x6202
+
+#define    RTL8367C_REG_FIB0_CFG03    0x6203
+#define    RTL8367C_FIB0_CFG03_REALTEK_OUI5_0_OFFSET    10
+#define    RTL8367C_FIB0_CFG03_REALTEK_OUI5_0_MASK    0xFC00
+#define    RTL8367C_FIB0_CFG03_MODEL_NO_OFFSET    4
+#define    RTL8367C_FIB0_CFG03_MODEL_NO_MASK    0x3F0
+#define    RTL8367C_FIB0_CFG03_REVISION_NO_OFFSET    0
+#define    RTL8367C_FIB0_CFG03_REVISION_NO_MASK    0xF
+
+#define    RTL8367C_REG_FIB0_CFG04    0x6204
+
+#define    RTL8367C_REG_FIB0_CFG05    0x6205
+
+#define    RTL8367C_REG_FIB0_CFG06    0x6206
+#define    RTL8367C_FIB0_CFG06_FIB_NP_EN_OFFSET    2
+#define    RTL8367C_FIB0_CFG06_FIB_NP_EN_MASK    0x4
+#define    RTL8367C_FIB0_CFG06_RXPAGE_OFFSET    1
+#define    RTL8367C_FIB0_CFG06_RXPAGE_MASK    0x2
+
+#define    RTL8367C_REG_FIB0_CFG07    0x6207
+
+#define    RTL8367C_REG_FIB0_CFG08    0x6208
+
+#define    RTL8367C_REG_FIB0_CFG09    0x6209
+
+#define    RTL8367C_REG_FIB0_CFG10    0x620a
+
+#define    RTL8367C_REG_FIB0_CFG11    0x620b
+
+#define    RTL8367C_REG_FIB0_CFG12    0x620c
+
+#define    RTL8367C_REG_FIB0_CFG13    0x620d
+#define    RTL8367C_FIB0_CFG13_INDR_FUNC_OFFSET    14
+#define    RTL8367C_FIB0_CFG13_INDR_FUNC_MASK    0xC000
+#define    RTL8367C_FIB0_CFG13_DUMMY_OFFSET    5
+#define    RTL8367C_FIB0_CFG13_DUMMY_MASK    0x3FE0
+#define    RTL8367C_FIB0_CFG13_INDR_DEVAD_OFFSET    0
+#define    RTL8367C_FIB0_CFG13_INDR_DEVAD_MASK    0x1F
+
+#define    RTL8367C_REG_FIB0_CFG14    0x620e
+
+#define    RTL8367C_REG_FIB0_CFG15    0x620f
+
+#define    RTL8367C_REG_FIB1_CFG00    0x6210
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_RST_OFFSET    15
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_RST_MASK    0x8000
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_LPK_OFFSET    14
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_LPK_MASK    0x4000
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_SPD_RD_0_OFFSET    13
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_SPD_RD_0_MASK    0x2000
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_ANEN_OFFSET    12
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_ANEN_MASK    0x1000
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_PDOWN_OFFSET    11
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_PDOWN_MASK    0x800
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_ISO_OFFSET    10
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_ISO_MASK    0x400
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_RESTART_OFFSET    9
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_RESTART_MASK    0x200
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_FULLDUP_OFFSET    8
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_FULLDUP_MASK    0x100
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_SPD_RD_1_OFFSET    6
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_SPD_RD_1_MASK    0x40
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_FRCTX_OFFSET    5
+#define    RTL8367C_FIB1_CFG00_CFG_FIB_FRCTX_MASK    0x20
+
+#define    RTL8367C_REG_FIB1_CFG01    0x6211
+#define    RTL8367C_FIB1_CFG01_CAPBILITY_OFFSET    6
+#define    RTL8367C_FIB1_CFG01_CAPBILITY_MASK    0xFFC0
+#define    RTL8367C_FIB1_CFG01_AN_COMPLETE_OFFSET    5
+#define    RTL8367C_FIB1_CFG01_AN_COMPLETE_MASK    0x20
+#define    RTL8367C_FIB1_CFG01_R_FAULT_OFFSET    4
+#define    RTL8367C_FIB1_CFG01_R_FAULT_MASK    0x10
+#define    RTL8367C_FIB1_CFG01_NWAY_ABILITY_OFFSET    3
+#define    RTL8367C_FIB1_CFG01_NWAY_ABILITY_MASK    0x8
+#define    RTL8367C_FIB1_CFG01_LINK_STATUS_OFFSET    2
+#define    RTL8367C_FIB1_CFG01_LINK_STATUS_MASK    0x4
+#define    RTL8367C_FIB1_CFG01_JABBER_DETECT_OFFSET    1
+#define    RTL8367C_FIB1_CFG01_JABBER_DETECT_MASK    0x2
+#define    RTL8367C_FIB1_CFG01_EXTENDED_CAPBILITY_OFFSET    0
+#define    RTL8367C_FIB1_CFG01_EXTENDED_CAPBILITY_MASK    0x1
+
+#define    RTL8367C_REG_FIB1_CFG02    0x6212
+
+#define    RTL8367C_REG_FIB1_CFG03    0x6213
+#define    RTL8367C_FIB1_CFG03_REALTEK_OUI5_0_OFFSET    10
+#define    RTL8367C_FIB1_CFG03_REALTEK_OUI5_0_MASK    0xFC00
+#define    RTL8367C_FIB1_CFG03_MODEL_NO_OFFSET    4
+#define    RTL8367C_FIB1_CFG03_MODEL_NO_MASK    0x3F0
+#define    RTL8367C_FIB1_CFG03_REVISION_NO_OFFSET    0
+#define    RTL8367C_FIB1_CFG03_REVISION_NO_MASK    0xF
+
+#define    RTL8367C_REG_FIB1_CFG04    0x6214
+
+#define    RTL8367C_REG_FIB1_CFG05    0x6215
+
+#define    RTL8367C_REG_FIB1_CFG06    0x6216
+#define    RTL8367C_FIB1_CFG06_FIB_NP_EN_OFFSET    2
+#define    RTL8367C_FIB1_CFG06_FIB_NP_EN_MASK    0x4
+#define    RTL8367C_FIB1_CFG06_RXPAGE_OFFSET    1
+#define    RTL8367C_FIB1_CFG06_RXPAGE_MASK    0x2
+
+#define    RTL8367C_REG_FIB1_CFG07    0x6217
+
+#define    RTL8367C_REG_FIB1_CFG08    0x6218
+
+#define    RTL8367C_REG_FIB1_CFG09    0x6219
+
+#define    RTL8367C_REG_FIB1_CFG10    0x621a
+
+#define    RTL8367C_REG_FIB1_CFG11    0x621b
+
+#define    RTL8367C_REG_FIB1_CFG12    0x621c
+
+#define    RTL8367C_REG_FIB1_CFG13    0x621d
+#define    RTL8367C_FIB1_CFG13_INDR_FUNC_OFFSET    14
+#define    RTL8367C_FIB1_CFG13_INDR_FUNC_MASK    0xC000
+#define    RTL8367C_FIB1_CFG13_DUMMY_OFFSET    5
+#define    RTL8367C_FIB1_CFG13_DUMMY_MASK    0x3FE0
+#define    RTL8367C_FIB1_CFG13_INDR_DEVAD_OFFSET    0
+#define    RTL8367C_FIB1_CFG13_INDR_DEVAD_MASK    0x1F
+
+#define    RTL8367C_REG_FIB1_CFG14    0x621e
+
+#define    RTL8367C_REG_FIB1_CFG15    0x621f
+
+/* (16'h6400)timer_1588 */
+
+#define    RTL8367C_REG_PTP_TIME_NSEC_L_NSEC    0x6400
+
+#define    RTL8367C_REG_PTP_TIME_NSEC_H_NSEC    0x6401
+#define    RTL8367C_PTP_TIME_NSEC_H_EXEC_OFFSET    15
+#define    RTL8367C_PTP_TIME_NSEC_H_EXEC_MASK    0x8000
+#define    RTL8367C_PTP_TIME_NSEC_H_CMD_OFFSET    12
+#define    RTL8367C_PTP_TIME_NSEC_H_CMD_MASK    0x3000
+#define    RTL8367C_PTP_TIME_NSEC_H_NSEC_OFFSET    0
+#define    RTL8367C_PTP_TIME_NSEC_H_NSEC_MASK    0x7FF
+
+#define    RTL8367C_REG_PTP_TIME_SEC_L_SEC    0x6402
+
+#define    RTL8367C_REG_PTP_TIME_SEC_H_SEC    0x6403
+
+#define    RTL8367C_REG_PTP_TIME_CFG    0x6404
+#define    RTL8367C_CFG_TIMER_EN_FRC_OFFSET    2
+#define    RTL8367C_CFG_TIMER_EN_FRC_MASK    0x4
+#define    RTL8367C_CFG_TIMER_1588_EN_OFFSET    1
+#define    RTL8367C_CFG_TIMER_1588_EN_MASK    0x2
+#define    RTL8367C_CFG_CLK_SRC_OFFSET    0
+#define    RTL8367C_CFG_CLK_SRC_MASK    0x1
+
+#define    RTL8367C_REG_OTAG_TPID    0x6405
+
+#define    RTL8367C_REG_ITAG_TPID    0x6406
+
+#define    RTL8367C_REG_MAC_ADDR_L    0x6407
+
+#define    RTL8367C_REG_MAC_ADDR_M    0x6408
+
+#define    RTL8367C_REG_MAC_ADDR_H    0x6409
+
+#define    RTL8367C_REG_PTP_TIME_NSEC_L_NSEC_RD    0x640a
+
+#define    RTL8367C_REG_PTP_TIME_NSEC_H_NSEC_RD    0x640b
+#define    RTL8367C_PTP_TIME_NSEC_H_NSEC_RD_OFFSET    0
+#define    RTL8367C_PTP_TIME_NSEC_H_NSEC_RD_MASK    0x7FF
+
+#define    RTL8367C_REG_PTP_TIME_SEC_L_SEC_RD    0x640c
+
+#define    RTL8367C_REG_PTP_TIME_SEC_H_SEC_RD    0x640d
+
+#define    RTL8367C_REG_PTP_TIME_CFG2    0x640e
+#define    RTL8367C_CFG_EN_OFFLOAD_OFFSET    9
+#define    RTL8367C_CFG_EN_OFFLOAD_MASK    0x200
+#define    RTL8367C_CFG_SAVE_OFF_TS_OFFSET    8
+#define    RTL8367C_CFG_SAVE_OFF_TS_MASK    0x100
+#define    RTL8367C_CFG_IMR_OFFSET    0
+#define    RTL8367C_CFG_IMR_MASK    0xFF
+
+#define    RTL8367C_REG_PTP_INTERRUPT_CFG    0x640f
+#define    RTL8367C_P9_INTERRUPT_OFFSET    9
+#define    RTL8367C_P9_INTERRUPT_MASK    0x200
+#define    RTL8367C_P8_INTERRUPT_OFFSET    8
+#define    RTL8367C_P8_INTERRUPT_MASK    0x100
+#define    RTL8367C_P7_INTERRUPT_OFFSET    7
+#define    RTL8367C_P7_INTERRUPT_MASK    0x80
+#define    RTL8367C_P6_INTERRUPT_OFFSET    6
+#define    RTL8367C_P6_INTERRUPT_MASK    0x40
+#define    RTL8367C_P5_INTERRUPT_OFFSET    5
+#define    RTL8367C_P5_INTERRUPT_MASK    0x20
+#define    RTL8367C_P4_INTERRUPT_OFFSET    4
+#define    RTL8367C_P4_INTERRUPT_MASK    0x10
+#define    RTL8367C_P3_INTERRUPT_OFFSET    3
+#define    RTL8367C_P3_INTERRUPT_MASK    0x8
+#define    RTL8367C_P2_INTERRUPT_OFFSET    2
+#define    RTL8367C_P2_INTERRUPT_MASK    0x4
+#define    RTL8367C_P1_INTERRUPT_OFFSET    1
+#define    RTL8367C_P1_INTERRUPT_MASK    0x2
+#define    RTL8367C_P0_INTERRUPT_OFFSET    0
+#define    RTL8367C_P0_INTERRUPT_MASK    0x1
+
+#define    RTL8367C_REG_P0_TX_SYNC_SEQ_ID    0x6410
+
+#define    RTL8367C_REG_P0_TX_DELAY_REQ_SEQ_ID    0x6411
+
+#define    RTL8367C_REG_P0_TX_PDELAY_REQ_SEQ_ID    0x6412
+
+#define    RTL8367C_REG_P0_TX_PDELAY_RESP_SEQ_ID    0x6413
+
+#define    RTL8367C_REG_P0_RX_SYNC_SEQ_ID    0x6414
+
+#define    RTL8367C_REG_P0_RX_DELAY_REQ_SEQ_ID    0x6415
+
+#define    RTL8367C_REG_P0_RX_PDELAY_REQ_SEQ_ID    0x6416
+
+#define    RTL8367C_REG_P0_RX_PDELAY_RESP_SEQ_ID    0x6417
+
+#define    RTL8367C_REG_P0_PORT_NSEC_15_0    0x6418
+
+#define    RTL8367C_REG_P0_PORT_NSEC_26_16    0x6419
+#define    RTL8367C_P0_PORT_NSEC_26_16_OFFSET    0
+#define    RTL8367C_P0_PORT_NSEC_26_16_MASK    0x7FF
+
+#define    RTL8367C_REG_P0_PORT_SEC_15_0    0x641a
+
+#define    RTL8367C_REG_P0_PORT_SEC_31_16    0x641b
+
+#define    RTL8367C_REG_P0_EAV_CFG    0x641c
+#define    RTL8367C_P0_EAV_CFG_PTP_PHY_EN_EN_OFFSET    8
+#define    RTL8367C_P0_EAV_CFG_PTP_PHY_EN_EN_MASK    0x100
+#define    RTL8367C_P0_EAV_CFG_RX_PDELAY_RESP_OFFSET    7
+#define    RTL8367C_P0_EAV_CFG_RX_PDELAY_RESP_MASK    0x80
+#define    RTL8367C_P0_EAV_CFG_RX_PDELAY_REQ_OFFSET    6
+#define    RTL8367C_P0_EAV_CFG_RX_PDELAY_REQ_MASK    0x40
+#define    RTL8367C_P0_EAV_CFG_RX_DELAY_REQ_OFFSET    5
+#define    RTL8367C_P0_EAV_CFG_RX_DELAY_REQ_MASK    0x20
+#define    RTL8367C_P0_EAV_CFG_RX_SYNC_OFFSET    4
+#define    RTL8367C_P0_EAV_CFG_RX_SYNC_MASK    0x10
+#define    RTL8367C_P0_EAV_CFG_TX_PDELAY_RESP_OFFSET    3
+#define    RTL8367C_P0_EAV_CFG_TX_PDELAY_RESP_MASK    0x8
+#define    RTL8367C_P0_EAV_CFG_TX_PDELAY_REQ_OFFSET    2
+#define    RTL8367C_P0_EAV_CFG_TX_PDELAY_REQ_MASK    0x4
+#define    RTL8367C_P0_EAV_CFG_TX_DELAY_REQ_OFFSET    1
+#define    RTL8367C_P0_EAV_CFG_TX_DELAY_REQ_MASK    0x2
+#define    RTL8367C_P0_EAV_CFG_TX_SYNC_OFFSET    0
+#define    RTL8367C_P0_EAV_CFG_TX_SYNC_MASK    0x1
+
+#define    RTL8367C_REG_P1_TX_SYNC_SEQ_ID    0x6420
+
+#define    RTL8367C_REG_P1_TX_DELAY_REQ_SEQ_ID    0x6421
+
+#define    RTL8367C_REG_P1_TX_PDELAY_REQ_SEQ_ID    0x6422
+
+#define    RTL8367C_REG_P1_TX_PDELAY_RESP_SEQ_ID    0x6423
+
+#define    RTL8367C_REG_P1_RX_SYNC_SEQ_ID    0x6424
+
+#define    RTL8367C_REG_P1_RX_DELAY_REQ_SEQ_ID    0x6425
+
+#define    RTL8367C_REG_P1_RX_PDELAY_REQ_SEQ_ID    0x6426
+
+#define    RTL8367C_REG_P1_RX_PDELAY_RESP_SEQ_ID    0x6427
+
+#define    RTL8367C_REG_P1_PORT_NSEC_15_0    0x6428
+
+#define    RTL8367C_REG_P1_PORT_NSEC_26_16    0x6429
+#define    RTL8367C_P1_PORT_NSEC_26_16_OFFSET    0
+#define    RTL8367C_P1_PORT_NSEC_26_16_MASK    0x7FF
+
+#define    RTL8367C_REG_P1_PORT_SEC_15_0    0x642a
+
+#define    RTL8367C_REG_P1_PORT_SEC_31_16    0x642b
+
+#define    RTL8367C_REG_P1_EAV_CFG    0x642c
+#define    RTL8367C_P1_EAV_CFG_PTP_PHY_EN_EN_OFFSET    8
+#define    RTL8367C_P1_EAV_CFG_PTP_PHY_EN_EN_MASK    0x100
+#define    RTL8367C_P1_EAV_CFG_RX_PDELAY_RESP_OFFSET    7
+#define    RTL8367C_P1_EAV_CFG_RX_PDELAY_RESP_MASK    0x80
+#define    RTL8367C_P1_EAV_CFG_RX_PDELAY_REQ_OFFSET    6
+#define    RTL8367C_P1_EAV_CFG_RX_PDELAY_REQ_MASK    0x40
+#define    RTL8367C_P1_EAV_CFG_RX_DELAY_REQ_OFFSET    5
+#define    RTL8367C_P1_EAV_CFG_RX_DELAY_REQ_MASK    0x20
+#define    RTL8367C_P1_EAV_CFG_RX_SYNC_OFFSET    4
+#define    RTL8367C_P1_EAV_CFG_RX_SYNC_MASK    0x10
+#define    RTL8367C_P1_EAV_CFG_TX_PDELAY_RESP_OFFSET    3
+#define    RTL8367C_P1_EAV_CFG_TX_PDELAY_RESP_MASK    0x8
+#define    RTL8367C_P1_EAV_CFG_TX_PDELAY_REQ_OFFSET    2
+#define    RTL8367C_P1_EAV_CFG_TX_PDELAY_REQ_MASK    0x4
+#define    RTL8367C_P1_EAV_CFG_TX_DELAY_REQ_OFFSET    1
+#define    RTL8367C_P1_EAV_CFG_TX_DELAY_REQ_MASK    0x2
+#define    RTL8367C_P1_EAV_CFG_TX_SYNC_OFFSET    0
+#define    RTL8367C_P1_EAV_CFG_TX_SYNC_MASK    0x1
+
+#define    RTL8367C_REG_P2_TX_SYNC_SEQ_ID    0x6430
+
+#define    RTL8367C_REG_P2_TX_DELAY_REQ_SEQ_ID    0x6431
+
+#define    RTL8367C_REG_P2_TX_PDELAY_REQ_SEQ_ID    0x6432
+
+#define    RTL8367C_REG_P2_TX_PDELAY_RESP_SEQ_ID    0x6433
+
+#define    RTL8367C_REG_P2_RX_SYNC_SEQ_ID    0x6434
+
+#define    RTL8367C_REG_P2_RX_DELAY_REQ_SEQ_ID    0x6435
+
+#define    RTL8367C_REG_P2_RX_PDELAY_REQ_SEQ_ID    0x6436
+
+#define    RTL8367C_REG_P2_RX_PDELAY_RESP_SEQ_ID    0x6437
+
+#define    RTL8367C_REG_P2_PORT_NSEC_15_0    0x6438
+
+#define    RTL8367C_REG_P2_PORT_NSEC_26_16    0x6439
+#define    RTL8367C_P2_PORT_NSEC_26_16_OFFSET    0
+#define    RTL8367C_P2_PORT_NSEC_26_16_MASK    0x7FF
+
+#define    RTL8367C_REG_P2_PORT_SEC_15_0    0x643a
+
+#define    RTL8367C_REG_P2_PORT_SEC_31_16    0x643b
+
+#define    RTL8367C_REG_P2_EAV_CFG    0x643c
+#define    RTL8367C_P2_EAV_CFG_PTP_PHY_EN_EN_OFFSET    8
+#define    RTL8367C_P2_EAV_CFG_PTP_PHY_EN_EN_MASK    0x100
+#define    RTL8367C_P2_EAV_CFG_RX_PDELAY_RESP_OFFSET    7
+#define    RTL8367C_P2_EAV_CFG_RX_PDELAY_RESP_MASK    0x80
+#define    RTL8367C_P2_EAV_CFG_RX_PDELAY_REQ_OFFSET    6
+#define    RTL8367C_P2_EAV_CFG_RX_PDELAY_REQ_MASK    0x40
+#define    RTL8367C_P2_EAV_CFG_RX_DELAY_REQ_OFFSET    5
+#define    RTL8367C_P2_EAV_CFG_RX_DELAY_REQ_MASK    0x20
+#define    RTL8367C_P2_EAV_CFG_RX_SYNC_OFFSET    4
+#define    RTL8367C_P2_EAV_CFG_RX_SYNC_MASK    0x10
+#define    RTL8367C_P2_EAV_CFG_TX_PDELAY_RESP_OFFSET    3
+#define    RTL8367C_P2_EAV_CFG_TX_PDELAY_RESP_MASK    0x8
+#define    RTL8367C_P2_EAV_CFG_TX_PDELAY_REQ_OFFSET    2
+#define    RTL8367C_P2_EAV_CFG_TX_PDELAY_REQ_MASK    0x4
+#define    RTL8367C_P2_EAV_CFG_TX_DELAY_REQ_OFFSET    1
+#define    RTL8367C_P2_EAV_CFG_TX_DELAY_REQ_MASK    0x2
+#define    RTL8367C_P2_EAV_CFG_TX_SYNC_OFFSET    0
+#define    RTL8367C_P2_EAV_CFG_TX_SYNC_MASK    0x1
+
+#define    RTL8367C_REG_P3_TX_SYNC_SEQ_ID    0x6440
+
+#define    RTL8367C_REG_P3_TX_DELAY_REQ_SEQ_ID    0x6441
+
+#define    RTL8367C_REG_P3_TX_PDELAY_REQ_SEQ_ID    0x6442
+
+#define    RTL8367C_REG_P3_TX_PDELAY_RESP_SEQ_ID    0x6443
+
+#define    RTL8367C_REG_P3_RX_SYNC_SEQ_ID    0x6444
+
+#define    RTL8367C_REG_P3_RX_DELAY_REQ_SEQ_ID    0x6445
+
+#define    RTL8367C_REG_P3_RX_PDELAY_REQ_SEQ_ID    0x6446
+
+#define    RTL8367C_REG_P3_RX_PDELAY_RESP_SEQ_ID    0x6447
+
+#define    RTL8367C_REG_P3_PORT_NSEC_15_0    0x6448
+
+#define    RTL8367C_REG_P3_PORT_NSEC_26_16    0x6449
+#define    RTL8367C_P3_PORT_NSEC_26_16_OFFSET    0
+#define    RTL8367C_P3_PORT_NSEC_26_16_MASK    0x7FF
+
+#define    RTL8367C_REG_P3_PORT_SEC_15_0    0x644a
+
+#define    RTL8367C_REG_P3_PORT_SEC_31_16    0x644b
+
+#define    RTL8367C_REG_P3_EAV_CFG    0x644c
+#define    RTL8367C_P3_EAV_CFG_PTP_PHY_EN_EN_OFFSET    8
+#define    RTL8367C_P3_EAV_CFG_PTP_PHY_EN_EN_MASK    0x100
+#define    RTL8367C_P3_EAV_CFG_RX_PDELAY_RESP_OFFSET    7
+#define    RTL8367C_P3_EAV_CFG_RX_PDELAY_RESP_MASK    0x80
+#define    RTL8367C_P3_EAV_CFG_RX_PDELAY_REQ_OFFSET    6
+#define    RTL8367C_P3_EAV_CFG_RX_PDELAY_REQ_MASK    0x40
+#define    RTL8367C_P3_EAV_CFG_RX_DELAY_REQ_OFFSET    5
+#define    RTL8367C_P3_EAV_CFG_RX_DELAY_REQ_MASK    0x20
+#define    RTL8367C_P3_EAV_CFG_RX_SYNC_OFFSET    4
+#define    RTL8367C_P3_EAV_CFG_RX_SYNC_MASK    0x10
+#define    RTL8367C_P3_EAV_CFG_TX_PDELAY_RESP_OFFSET    3
+#define    RTL8367C_P3_EAV_CFG_TX_PDELAY_RESP_MASK    0x8
+#define    RTL8367C_P3_EAV_CFG_TX_PDELAY_REQ_OFFSET    2
+#define    RTL8367C_P3_EAV_CFG_TX_PDELAY_REQ_MASK    0x4
+#define    RTL8367C_P3_EAV_CFG_TX_DELAY_REQ_OFFSET    1
+#define    RTL8367C_P3_EAV_CFG_TX_DELAY_REQ_MASK    0x2
+#define    RTL8367C_P3_EAV_CFG_TX_SYNC_OFFSET    0
+#define    RTL8367C_P3_EAV_CFG_TX_SYNC_MASK    0x1
+
+#define    RTL8367C_REG_P4_TX_SYNC_SEQ_ID    0x6450
+
+#define    RTL8367C_REG_P4_TX_DELAY_REQ_SEQ_ID    0x6451
+
+#define    RTL8367C_REG_P4_TX_PDELAY_REQ_SEQ_ID    0x6452
+
+#define    RTL8367C_REG_P4_TX_PDELAY_RESP_SEQ_ID    0x6453
+
+#define    RTL8367C_REG_P4_RX_SYNC_SEQ_ID    0x6454
+
+#define    RTL8367C_REG_P4_RX_DELAY_REQ_SEQ_ID    0x6455
+
+#define    RTL8367C_REG_P4_RX_PDELAY_REQ_SEQ_ID    0x6456
+
+#define    RTL8367C_REG_P4_RX_PDELAY_RESP_SEQ_ID    0x6457
+
+#define    RTL8367C_REG_P4_PORT_NSEC_15_0    0x6458
+
+#define    RTL8367C_REG_P4_PORT_NSEC_26_16    0x6459
+#define    RTL8367C_P4_PORT_NSEC_26_16_OFFSET    0
+#define    RTL8367C_P4_PORT_NSEC_26_16_MASK    0x7FF
+
+#define    RTL8367C_REG_P4_PORT_SEC_15_0    0x645a
+
+#define    RTL8367C_REG_P4_PORT_SEC_31_16    0x645b
+
+#define    RTL8367C_REG_P4_EAV_CFG    0x645c
+#define    RTL8367C_P4_EAV_CFG_PTP_PHY_EN_EN_OFFSET    8
+#define    RTL8367C_P4_EAV_CFG_PTP_PHY_EN_EN_MASK    0x100
+#define    RTL8367C_P4_EAV_CFG_RX_PDELAY_RESP_OFFSET    7
+#define    RTL8367C_P4_EAV_CFG_RX_PDELAY_RESP_MASK    0x80
+#define    RTL8367C_P4_EAV_CFG_RX_PDELAY_REQ_OFFSET    6
+#define    RTL8367C_P4_EAV_CFG_RX_PDELAY_REQ_MASK    0x40
+#define    RTL8367C_P4_EAV_CFG_RX_DELAY_REQ_OFFSET    5
+#define    RTL8367C_P4_EAV_CFG_RX_DELAY_REQ_MASK    0x20
+#define    RTL8367C_P4_EAV_CFG_RX_SYNC_OFFSET    4
+#define    RTL8367C_P4_EAV_CFG_RX_SYNC_MASK    0x10
+#define    RTL8367C_P4_EAV_CFG_TX_PDELAY_RESP_OFFSET    3
+#define    RTL8367C_P4_EAV_CFG_TX_PDELAY_RESP_MASK    0x8
+#define    RTL8367C_P4_EAV_CFG_TX_PDELAY_REQ_OFFSET    2
+#define    RTL8367C_P4_EAV_CFG_TX_PDELAY_REQ_MASK    0x4
+#define    RTL8367C_P4_EAV_CFG_TX_DELAY_REQ_OFFSET    1
+#define    RTL8367C_P4_EAV_CFG_TX_DELAY_REQ_MASK    0x2
+#define    RTL8367C_P4_EAV_CFG_TX_SYNC_OFFSET    0
+#define    RTL8367C_P4_EAV_CFG_TX_SYNC_MASK    0x1
+
+#define    RTL8367C_REG_P6_TX_SYNC_SEQ_ID    0x6460
+
+#define    RTL8367C_REG_P6_TX_DELAY_REQ_SEQ_ID    0x6461
+
+#define    RTL8367C_REG_P6_TX_PDELAY_REQ_SEQ_ID    0x6462
+
+#define    RTL8367C_REG_P6_TX_PDELAY_RESP_SEQ_ID    0x6463
+
+#define    RTL8367C_REG_P6_RX_SYNC_SEQ_ID    0x6464
+
+#define    RTL8367C_REG_P6_RX_DELAY_REQ_SEQ_ID    0x6465
+
+#define    RTL8367C_REG_P6_RX_PDELAY_REQ_SEQ_ID    0x6466
+
+#define    RTL8367C_REG_P6_RX_PDELAY_RESP_SEQ_ID    0x6467
+
+#define    RTL8367C_REG_P6_PORT_NSEC_15_0    0x6468
+
+#define    RTL8367C_REG_P6_PORT_NSEC_26_16    0x6469
+#define    RTL8367C_P6_PORT_NSEC_26_16_OFFSET    0
+#define    RTL8367C_P6_PORT_NSEC_26_16_MASK    0x7FF
+
+#define    RTL8367C_REG_P6_PORT_SEC_15_0    0x646a
+
+#define    RTL8367C_REG_P6_PORT_SEC_31_16    0x646b
+
+#define    RTL8367C_REG_P6_EAV_CFG    0x646c
+#define    RTL8367C_P6_EAV_CFG_PTP_PHY_EN_EN_OFFSET    8
+#define    RTL8367C_P6_EAV_CFG_PTP_PHY_EN_EN_MASK    0x100
+#define    RTL8367C_P6_EAV_CFG_RX_PDELAY_RESP_OFFSET    7
+#define    RTL8367C_P6_EAV_CFG_RX_PDELAY_RESP_MASK    0x80
+#define    RTL8367C_P6_EAV_CFG_RX_PDELAY_REQ_OFFSET    6
+#define    RTL8367C_P6_EAV_CFG_RX_PDELAY_REQ_MASK    0x40
+#define    RTL8367C_P6_EAV_CFG_RX_DELAY_REQ_OFFSET    5
+#define    RTL8367C_P6_EAV_CFG_RX_DELAY_REQ_MASK    0x20
+#define    RTL8367C_P6_EAV_CFG_RX_SYNC_OFFSET    4
+#define    RTL8367C_P6_EAV_CFG_RX_SYNC_MASK    0x10
+#define    RTL8367C_P6_EAV_CFG_TX_PDELAY_RESP_OFFSET    3
+#define    RTL8367C_P6_EAV_CFG_TX_PDELAY_RESP_MASK    0x8
+#define    RTL8367C_P6_EAV_CFG_TX_PDELAY_REQ_OFFSET    2
+#define    RTL8367C_P6_EAV_CFG_TX_PDELAY_REQ_MASK    0x4
+#define    RTL8367C_P6_EAV_CFG_TX_DELAY_REQ_OFFSET    1
+#define    RTL8367C_P6_EAV_CFG_TX_DELAY_REQ_MASK    0x2
+#define    RTL8367C_P6_EAV_CFG_TX_SYNC_OFFSET    0
+#define    RTL8367C_P6_EAV_CFG_TX_SYNC_MASK    0x1
+
+#define    RTL8367C_REG_P7_TX_SYNC_SEQ_ID    0x6470
+
+#define    RTL8367C_REG_P7_TX_DELAY_REQ_SEQ_ID    0x6471
+
+#define    RTL8367C_REG_P7_TX_PDELAY_REQ_SEQ_ID    0x6472
+
+#define    RTL8367C_REG_P7_TX_PDELAY_RESP_SEQ_ID    0x6473
+
+#define    RTL8367C_REG_P7_RX_SYNC_SEQ_ID    0x6474
+
+#define    RTL8367C_REG_P7_RX_DELAY_REQ_SEQ_ID    0x6475
+
+#define    RTL8367C_REG_P7_RX_PDELAY_REQ_SEQ_ID    0x6476
+
+#define    RTL8367C_REG_P7_RX_PDELAY_RESP_SEQ_ID    0x6477
+
+#define    RTL8367C_REG_P7_PORT_NSEC_15_0    0x6478
+
+#define    RTL8367C_REG_P7_PORT_NSEC_26_16    0x6479
+#define    RTL8367C_P7_PORT_NSEC_26_16_OFFSET    0
+#define    RTL8367C_P7_PORT_NSEC_26_16_MASK    0x7FF
+
+#define    RTL8367C_REG_P7_PORT_SEC_15_0    0x647a
+
+#define    RTL8367C_REG_P7_PORT_SEC_31_16    0x647b
+
+#define    RTL8367C_REG_P7_EAV_CFG    0x647c
+#define    RTL8367C_P7_EAV_CFG_PTP_PHY_EN_EN_OFFSET    8
+#define    RTL8367C_P7_EAV_CFG_PTP_PHY_EN_EN_MASK    0x100
+#define    RTL8367C_P7_EAV_CFG_RX_PDELAY_RESP_OFFSET    7
+#define    RTL8367C_P7_EAV_CFG_RX_PDELAY_RESP_MASK    0x80
+#define    RTL8367C_P7_EAV_CFG_RX_PDELAY_REQ_OFFSET    6
+#define    RTL8367C_P7_EAV_CFG_RX_PDELAY_REQ_MASK    0x40
+#define    RTL8367C_P7_EAV_CFG_RX_DELAY_REQ_OFFSET    5
+#define    RTL8367C_P7_EAV_CFG_RX_DELAY_REQ_MASK    0x20
+#define    RTL8367C_P7_EAV_CFG_RX_SYNC_OFFSET    4
+#define    RTL8367C_P7_EAV_CFG_RX_SYNC_MASK    0x10
+#define    RTL8367C_P7_EAV_CFG_TX_PDELAY_RESP_OFFSET    3
+#define    RTL8367C_P7_EAV_CFG_TX_PDELAY_RESP_MASK    0x8
+#define    RTL8367C_P7_EAV_CFG_TX_PDELAY_REQ_OFFSET    2
+#define    RTL8367C_P7_EAV_CFG_TX_PDELAY_REQ_MASK    0x4
+#define    RTL8367C_P7_EAV_CFG_TX_DELAY_REQ_OFFSET    1
+#define    RTL8367C_P7_EAV_CFG_TX_DELAY_REQ_MASK    0x2
+#define    RTL8367C_P7_EAV_CFG_TX_SYNC_OFFSET    0
+#define    RTL8367C_P7_EAV_CFG_TX_SYNC_MASK    0x1
+
+#define    RTL8367C_REG_P5_TX_SYNC_SEQ_ID    0x6480
+
+#define    RTL8367C_REG_P5_TX_DELAY_REQ_SEQ_ID    0x6481
+
+#define    RTL8367C_REG_P5_TX_PDELAY_REQ_SEQ_ID    0x6482
+
+#define    RTL8367C_REG_P5_TX_PDELAY_RESP_SEQ_ID    0x6483
+
+#define    RTL8367C_REG_P5_RX_SYNC_SEQ_ID    0x6484
+
+#define    RTL8367C_REG_P5_RX_DELAY_REQ_SEQ_ID    0x6485
+
+#define    RTL8367C_REG_P5_RX_PDELAY_REQ_SEQ_ID    0x6486
+
+#define    RTL8367C_REG_P5_RX_PDELAY_RESP_SEQ_ID    0x6487
+
+#define    RTL8367C_REG_P5_PORT_NSEC_15_0    0x6488
+
+#define    RTL8367C_REG_P5_PORT_NSEC_26_16    0x6489
+#define    RTL8367C_P5_PORT_NSEC_26_16_OFFSET    0
+#define    RTL8367C_P5_PORT_NSEC_26_16_MASK    0x7FF
+
+#define    RTL8367C_REG_P5_PORT_SEC_15_0    0x648a
+
+#define    RTL8367C_REG_P5_PORT_SEC_31_16    0x648b
+
+#define    RTL8367C_REG_P5_EAV_CFG    0x648c
+#define    RTL8367C_P5_EAV_CFG_PTP_PHY_EN_EN_OFFSET    8
+#define    RTL8367C_P5_EAV_CFG_PTP_PHY_EN_EN_MASK    0x100
+#define    RTL8367C_P5_EAV_CFG_RX_PDELAY_RESP_OFFSET    7
+#define    RTL8367C_P5_EAV_CFG_RX_PDELAY_RESP_MASK    0x80
+#define    RTL8367C_P5_EAV_CFG_RX_PDELAY_REQ_OFFSET    6
+#define    RTL8367C_P5_EAV_CFG_RX_PDELAY_REQ_MASK    0x40
+#define    RTL8367C_P5_EAV_CFG_RX_DELAY_REQ_OFFSET    5
+#define    RTL8367C_P5_EAV_CFG_RX_DELAY_REQ_MASK    0x20
+#define    RTL8367C_P5_EAV_CFG_RX_SYNC_OFFSET    4
+#define    RTL8367C_P5_EAV_CFG_RX_SYNC_MASK    0x10
+#define    RTL8367C_P5_EAV_CFG_TX_PDELAY_RESP_OFFSET    3
+#define    RTL8367C_P5_EAV_CFG_TX_PDELAY_RESP_MASK    0x8
+#define    RTL8367C_P5_EAV_CFG_TX_PDELAY_REQ_OFFSET    2
+#define    RTL8367C_P5_EAV_CFG_TX_PDELAY_REQ_MASK    0x4
+#define    RTL8367C_P5_EAV_CFG_TX_DELAY_REQ_OFFSET    1
+#define    RTL8367C_P5_EAV_CFG_TX_DELAY_REQ_MASK    0x2
+#define    RTL8367C_P5_EAV_CFG_TX_SYNC_OFFSET    0
+#define    RTL8367C_P5_EAV_CFG_TX_SYNC_MASK    0x1
+
+#define    RTL8367C_REG_P8_TX_SYNC_SEQ_ID    0x6490
+
+#define    RTL8367C_REG_P8_TX_DELAY_REQ_SEQ_ID    0x6491
+
+#define    RTL8367C_REG_P8_TX_PDELAY_REQ_SEQ_ID    0x6492
+
+#define    RTL8367C_REG_P8_TX_PDELAY_RESP_SEQ_ID    0x6493
+
+#define    RTL8367C_REG_P8_RX_SYNC_SEQ_ID    0x6494
+
+#define    RTL8367C_REG_P8_RX_DELAY_REQ_SEQ_ID    0x6495
+
+#define    RTL8367C_REG_P8_RX_PDELAY_REQ_SEQ_ID    0x6496
+
+#define    RTL8367C_REG_P8_RX_PDELAY_RESP_SEQ_ID    0x6497
+
+#define    RTL8367C_REG_P8_PORT_NSEC_15_0    0x6498
+
+#define    RTL8367C_REG_P8_PORT_NSEC_26_16    0x6499
+#define    RTL8367C_P8_PORT_NSEC_26_16_OFFSET    0
+#define    RTL8367C_P8_PORT_NSEC_26_16_MASK    0x7FF
+
+#define    RTL8367C_REG_P8_PORT_SEC_15_0    0x649a
+
+#define    RTL8367C_REG_P8_PORT_SEC_31_16    0x649b
+
+#define    RTL8367C_REG_P8_EAV_CFG    0x649c
+#define    RTL8367C_P8_EAV_CFG_PTP_PHY_EN_EN_OFFSET    8
+#define    RTL8367C_P8_EAV_CFG_PTP_PHY_EN_EN_MASK    0x100
+#define    RTL8367C_P8_EAV_CFG_RX_PDELAY_RESP_OFFSET    7
+#define    RTL8367C_P8_EAV_CFG_RX_PDELAY_RESP_MASK    0x80
+#define    RTL8367C_P8_EAV_CFG_RX_PDELAY_REQ_OFFSET    6
+#define    RTL8367C_P8_EAV_CFG_RX_PDELAY_REQ_MASK    0x40
+#define    RTL8367C_P8_EAV_CFG_RX_DELAY_REQ_OFFSET    5
+#define    RTL8367C_P8_EAV_CFG_RX_DELAY_REQ_MASK    0x20
+#define    RTL8367C_P8_EAV_CFG_RX_SYNC_OFFSET    4
+#define    RTL8367C_P8_EAV_CFG_RX_SYNC_MASK    0x10
+#define    RTL8367C_P8_EAV_CFG_TX_PDELAY_RESP_OFFSET    3
+#define    RTL8367C_P8_EAV_CFG_TX_PDELAY_RESP_MASK    0x8
+#define    RTL8367C_P8_EAV_CFG_TX_PDELAY_REQ_OFFSET    2
+#define    RTL8367C_P8_EAV_CFG_TX_PDELAY_REQ_MASK    0x4
+#define    RTL8367C_P8_EAV_CFG_TX_DELAY_REQ_OFFSET    1
+#define    RTL8367C_P8_EAV_CFG_TX_DELAY_REQ_MASK    0x2
+#define    RTL8367C_P8_EAV_CFG_TX_SYNC_OFFSET    0
+#define    RTL8367C_P8_EAV_CFG_TX_SYNC_MASK    0x1
+
+#define    RTL8367C_REG_P9_TX_SYNC_SEQ_ID    0x64a0
+
+#define    RTL8367C_REG_P9_TX_DELAY_REQ_SEQ_ID    0x64a1
+
+#define    RTL8367C_REG_P9_TX_PDELAY_REQ_SEQ_ID    0x64a2
+
+#define    RTL8367C_REG_P9_TX_PDELAY_RESP_SEQ_ID    0x64a3
+
+#define    RTL8367C_REG_P9_RX_SYNC_SEQ_ID    0x64a4
+
+#define    RTL8367C_REG_P9_RX_DELAY_REQ_SEQ_ID    0x64a5
+
+#define    RTL8367C_REG_P9_RX_PDELAY_REQ_SEQ_ID    0x64a6
+
+#define    RTL8367C_REG_P9_RX_PDELAY_RESP_SEQ_ID    0x64a7
+
+#define    RTL8367C_REG_P9_PORT_NSEC_15_0    0x64a8
+
+#define    RTL8367C_REG_P9_PORT_NSEC_26_16    0x64a9
+#define    RTL8367C_P9_PORT_NSEC_26_16_OFFSET    0
+#define    RTL8367C_P9_PORT_NSEC_26_16_MASK    0x7FF
+
+#define    RTL8367C_REG_P9_PORT_SEC_15_0    0x64aa
+
+#define    RTL8367C_REG_P9_PORT_SEC_31_16    0x64ab
+
+#define    RTL8367C_REG_P9_EAV_CFG    0x64ac
+#define    RTL8367C_P9_EAV_CFG_PTP_PHY_EN_EN_OFFSET    8
+#define    RTL8367C_P9_EAV_CFG_PTP_PHY_EN_EN_MASK    0x100
+#define    RTL8367C_P9_EAV_CFG_RX_PDELAY_RESP_OFFSET    7
+#define    RTL8367C_P9_EAV_CFG_RX_PDELAY_RESP_MASK    0x80
+#define    RTL8367C_P9_EAV_CFG_RX_PDELAY_REQ_OFFSET    6
+#define    RTL8367C_P9_EAV_CFG_RX_PDELAY_REQ_MASK    0x40
+#define    RTL8367C_P9_EAV_CFG_RX_DELAY_REQ_OFFSET    5
+#define    RTL8367C_P9_EAV_CFG_RX_DELAY_REQ_MASK    0x20
+#define    RTL8367C_P9_EAV_CFG_RX_SYNC_OFFSET    4
+#define    RTL8367C_P9_EAV_CFG_RX_SYNC_MASK    0x10
+#define    RTL8367C_P9_EAV_CFG_TX_PDELAY_RESP_OFFSET    3
+#define    RTL8367C_P9_EAV_CFG_TX_PDELAY_RESP_MASK    0x8
+#define    RTL8367C_P9_EAV_CFG_TX_PDELAY_REQ_OFFSET    2
+#define    RTL8367C_P9_EAV_CFG_TX_PDELAY_REQ_MASK    0x4
+#define    RTL8367C_P9_EAV_CFG_TX_DELAY_REQ_OFFSET    1
+#define    RTL8367C_P9_EAV_CFG_TX_DELAY_REQ_MASK    0x2
+#define    RTL8367C_P9_EAV_CFG_TX_SYNC_OFFSET    0
+#define    RTL8367C_P9_EAV_CFG_TX_SYNC_MASK    0x1
+
+/* (16'h6600)sds_indacs_reg */
+
+#define    RTL8367C_REG_SDS_INDACS_CMD    0x6600
+#define    RTL8367C_SDS_CMD_BUSY_OFFSET    8
+#define    RTL8367C_SDS_CMD_BUSY_MASK    0x100
+#define    RTL8367C_SDS_CMD_OFFSET    7
+#define    RTL8367C_SDS_CMD_MASK    0x80
+#define    RTL8367C_SDS_RWOP_OFFSET    6
+#define    RTL8367C_SDS_RWOP_MASK    0x40
+#define    RTL8367C_SDS_INDEX_OFFSET    0
+#define    RTL8367C_SDS_INDEX_MASK    0x3F
+
+#define    RTL8367C_REG_SDS_INDACS_ADR    0x6601
+#define    RTL8367C_SDS_PAGE_OFFSET    5
+#define    RTL8367C_SDS_PAGE_MASK    0x7E0
+#define    RTL8367C_SDS_REGAD_OFFSET    0
+#define    RTL8367C_SDS_REGAD_MASK    0x1F
+
+#define    RTL8367C_REG_SDS_INDACS_DATA    0x6602
+
+
+#endif /*#ifndef _RTL8367C_REG_H_*/
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/smi.h b/drivers/net/phy/rtk/rtl8367c/include/smi.h
new file mode 100644
index 0000000000000..b77d7607113ee
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/smi.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367C switch low-level function for access register
+ * Feature : SMI related functions
+ *
+ */
+
+#ifndef __SMI_H__
+#define __SMI_H__
+
+#include <rtk_types.h>
+#include "rtk_error.h"
+
+#define MDC_MDIO_CTRL0_REG          31
+#define MDC_MDIO_START_REG          29
+#define MDC_MDIO_CTRL1_REG          21
+#define MDC_MDIO_ADDRESS_REG        23
+#define MDC_MDIO_DATA_WRITE_REG     24
+#define MDC_MDIO_DATA_READ_REG      25
+#define MDC_MDIO_PREAMBLE_LEN       32
+
+#define MDC_MDIO_START_OP          0xFFFF
+#define MDC_MDIO_ADDR_OP           0x000E
+#define MDC_MDIO_READ_OP           0x0001
+#define MDC_MDIO_WRITE_OP          0x0003
+
+#define SPI_READ_OP                 0x3
+#define SPI_WRITE_OP                0x2
+#define SPI_READ_OP_LEN             0x8
+#define SPI_WRITE_OP_LEN            0x8
+#define SPI_REG_LEN                 16
+#define SPI_DATA_LEN                16
+
+#define GPIO_DIR_IN                 1
+#define GPIO_DIR_OUT                0
+
+#define ack_timer                   5
+
+#define DELAY                        10000
+#define CLK_DURATION(clk)            { int i; for(i=0; i<clk; i++); }
+
+rtk_int32 smi_read(rtk_uint32 mAddrs, rtk_uint32 *rData);
+rtk_int32 smi_write(rtk_uint32 mAddrs, rtk_uint32 rData);
+
+#endif /* __SMI_H__ */
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/stat.h b/drivers/net/phy/rtk/rtl8367c/include/stat.h
new file mode 100644
index 0000000000000..1557be4caf935
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/stat.h
@@ -0,0 +1,433 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes MIB module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_STAT_H__
+#define __RTK_API_STAT_H__
+
+/*
+ * Data Type Declaration
+ */
+typedef rtk_u_long_t rtk_stat_counter_t;
+
+/* global statistic counter structure */
+typedef struct rtk_stat_global_cntr_s
+{
+    rtk_uint64 dot1dTpLearnedEntryDiscards;
+}rtk_stat_global_cntr_t;
+
+typedef enum rtk_stat_global_type_e
+{
+    DOT1D_TP_LEARNED_ENTRY_DISCARDS_INDEX = 58,
+    MIB_GLOBAL_CNTR_END
+}rtk_stat_global_type_t;
+
+/* port statistic counter structure */
+typedef struct rtk_stat_port_cntr_s
+{
+    rtk_uint64 ifInOctets;
+    rtk_uint32 dot3StatsFCSErrors;
+    rtk_uint32 dot3StatsSymbolErrors;
+    rtk_uint32 dot3InPauseFrames;
+    rtk_uint32 dot3ControlInUnknownOpcodes;
+    rtk_uint32 etherStatsFragments;
+    rtk_uint32 etherStatsJabbers;
+    rtk_uint32 ifInUcastPkts;
+    rtk_uint32 etherStatsDropEvents;
+    rtk_uint64 etherStatsOctets;
+    rtk_uint32 etherStatsUndersizePkts;
+    rtk_uint32 etherStatsOversizePkts;
+    rtk_uint32 etherStatsPkts64Octets;
+    rtk_uint32 etherStatsPkts65to127Octets;
+    rtk_uint32 etherStatsPkts128to255Octets;
+    rtk_uint32 etherStatsPkts256to511Octets;
+    rtk_uint32 etherStatsPkts512to1023Octets;
+    rtk_uint32 etherStatsPkts1024toMaxOctets;
+    rtk_uint32 etherStatsMcastPkts;
+    rtk_uint32 etherStatsBcastPkts;
+    rtk_uint64 ifOutOctets;
+    rtk_uint32 dot3StatsSingleCollisionFrames;
+    rtk_uint32 dot3StatsMultipleCollisionFrames;
+    rtk_uint32 dot3StatsDeferredTransmissions;
+    rtk_uint32 dot3StatsLateCollisions;
+    rtk_uint32 etherStatsCollisions;
+    rtk_uint32 dot3StatsExcessiveCollisions;
+    rtk_uint32 dot3OutPauseFrames;
+    rtk_uint32 dot1dBasePortDelayExceededDiscards;
+    rtk_uint32 dot1dTpPortInDiscards;
+    rtk_uint32 ifOutUcastPkts;
+    rtk_uint32 ifOutMulticastPkts;
+    rtk_uint32 ifOutBrocastPkts;
+    rtk_uint32 outOampduPkts;
+    rtk_uint32 inOampduPkts;
+    rtk_uint32 pktgenPkts;
+    rtk_uint32 inMldChecksumError;
+    rtk_uint32 inIgmpChecksumError;
+    rtk_uint32 inMldSpecificQuery;
+    rtk_uint32 inMldGeneralQuery;
+    rtk_uint32 inIgmpSpecificQuery;
+    rtk_uint32 inIgmpGeneralQuery;
+    rtk_uint32 inMldLeaves;
+    rtk_uint32 inIgmpLeaves;
+    rtk_uint32 inIgmpJoinsSuccess;
+    rtk_uint32 inIgmpJoinsFail;
+    rtk_uint32 inMldJoinsSuccess;
+    rtk_uint32 inMldJoinsFail;
+    rtk_uint32 inReportSuppressionDrop;
+    rtk_uint32 inLeaveSuppressionDrop;
+    rtk_uint32 outIgmpReports;
+    rtk_uint32 outIgmpLeaves;
+    rtk_uint32 outIgmpGeneralQuery;
+    rtk_uint32 outIgmpSpecificQuery;
+    rtk_uint32 outMldReports;
+    rtk_uint32 outMldLeaves;
+    rtk_uint32 outMldGeneralQuery;
+    rtk_uint32 outMldSpecificQuery;
+    rtk_uint32 inKnownMulticastPkts;
+    rtk_uint32 ifInMulticastPkts;
+    rtk_uint32 ifInBroadcastPkts;
+    rtk_uint32 ifOutDiscards;
+}rtk_stat_port_cntr_t;
+
+/* port statistic counter index */
+typedef enum rtk_stat_port_type_e
+{
+    STAT_IfInOctets = 0,
+    STAT_Dot3StatsFCSErrors,
+    STAT_Dot3StatsSymbolErrors,
+    STAT_Dot3InPauseFrames,
+    STAT_Dot3ControlInUnknownOpcodes,
+    STAT_EtherStatsFragments,
+    STAT_EtherStatsJabbers,
+    STAT_IfInUcastPkts,
+    STAT_EtherStatsDropEvents,
+    STAT_EtherStatsOctets,
+    STAT_EtherStatsUnderSizePkts,
+    STAT_EtherOversizeStats,
+    STAT_EtherStatsPkts64Octets,
+    STAT_EtherStatsPkts65to127Octets,
+    STAT_EtherStatsPkts128to255Octets,
+    STAT_EtherStatsPkts256to511Octets,
+    STAT_EtherStatsPkts512to1023Octets,
+    STAT_EtherStatsPkts1024to1518Octets,
+    STAT_EtherStatsMulticastPkts,
+    STAT_EtherStatsBroadcastPkts,
+    STAT_IfOutOctets,
+    STAT_Dot3StatsSingleCollisionFrames,
+    STAT_Dot3StatsMultipleCollisionFrames,
+    STAT_Dot3StatsDeferredTransmissions,
+    STAT_Dot3StatsLateCollisions,
+    STAT_EtherStatsCollisions,
+    STAT_Dot3StatsExcessiveCollisions,
+    STAT_Dot3OutPauseFrames,
+    STAT_Dot1dBasePortDelayExceededDiscards,
+    STAT_Dot1dTpPortInDiscards,
+    STAT_IfOutUcastPkts,
+    STAT_IfOutMulticastPkts,
+    STAT_IfOutBroadcastPkts,
+    STAT_OutOampduPkts,
+    STAT_InOampduPkts,
+    STAT_PktgenPkts,
+    STAT_InMldChecksumError,
+    STAT_InIgmpChecksumError,
+    STAT_InMldSpecificQuery,
+    STAT_InMldGeneralQuery,
+    STAT_InIgmpSpecificQuery,
+    STAT_InIgmpGeneralQuery,
+    STAT_InMldLeaves,
+    STAT_InIgmpInterfaceLeaves,
+    STAT_InIgmpJoinsSuccess,
+    STAT_InIgmpJoinsFail,
+    STAT_InMldJoinsSuccess,
+    STAT_InMldJoinsFail,
+    STAT_InReportSuppressionDrop,
+    STAT_InLeaveSuppressionDrop,
+    STAT_OutIgmpReports,
+    STAT_OutIgmpLeaves,
+    STAT_OutIgmpGeneralQuery,
+    STAT_OutIgmpSpecificQuery,
+    STAT_OutMldReports,
+    STAT_OutMldLeaves,
+    STAT_OutMldGeneralQuery,
+    STAT_OutMldSpecificQuery,
+    STAT_InKnownMulticastPkts,
+    STAT_IfInMulticastPkts,
+    STAT_IfInBroadcastPkts,
+    STAT_IfOutDiscards,
+    STAT_PORT_CNTR_END
+}rtk_stat_port_type_t;
+
+typedef enum rtk_logging_counter_mode_e
+{
+    LOGGING_MODE_32BIT = 0,
+    LOGGING_MODE_64BIT,
+    LOGGING_MODE_END
+}rtk_logging_counter_mode_t;
+
+typedef enum rtk_logging_counter_type_e
+{
+    LOGGING_TYPE_PACKET = 0,
+    LOGGING_TYPE_BYTE,
+    LOGGING_TYPE_END
+}rtk_logging_counter_type_t;
+
+typedef enum rtk_stat_lengthMode_e
+{
+    LENGTH_MODE_EXC_TAG = 0,
+    LENGTH_MODE_INC_TAG,
+    LENGTH_MODE_END
+}rtk_stat_lengthMode_t;
+
+
+
+/* Function Name:
+ *      rtk_stat_global_reset
+ * Description:
+ *      Reset global MIB counter.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      Reset MIB counter of ports. API will use global reset while port mask is all-ports.
+ */
+extern rtk_api_ret_t rtk_stat_global_reset(void);
+
+/* Function Name:
+ *      rtk_stat_port_reset
+ * Description:
+ *      Reset per port MIB counter by port.
+ * Input:
+ *      port - port id.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_stat_port_reset(rtk_port_t port);
+
+/* Function Name:
+ *      rtk_stat_queueManage_reset
+ * Description:
+ *      Reset queue manage MIB counter.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_stat_queueManage_reset(void);
+
+/* Function Name:
+ *      rtk_stat_global_get
+ * Description:
+ *      Get global MIB counter
+ * Input:
+ *      cntr_idx - global counter index.
+ * Output:
+ *      pCntr - global counter value.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      Get global MIB counter by index definition.
+ */
+extern rtk_api_ret_t rtk_stat_global_get(rtk_stat_global_type_t cntr_idx, rtk_stat_counter_t *pCntr);
+
+/* Function Name:
+ *      rtk_stat_global_getAll
+ * Description:
+ *      Get all global MIB counter
+ * Input:
+ *      None
+ * Output:
+ *      pGlobal_cntrs - global counter structure.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      Get all global MIB counter by index definition.
+ */
+extern rtk_api_ret_t rtk_stat_global_getAll(rtk_stat_global_cntr_t *pGlobal_cntrs);
+
+/* Function Name:
+ *      rtk_stat_port_get
+ * Description:
+ *      Get per port MIB counter by index
+ * Input:
+ *      port        - port id.
+ *      cntr_idx    - port counter index.
+ * Output:
+ *      pCntr - MIB retrived counter.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      Get per port MIB counter by index definition.
+ */
+extern rtk_api_ret_t rtk_stat_port_get(rtk_port_t port, rtk_stat_port_type_t cntr_idx, rtk_stat_counter_t *pCntr);
+
+/* Function Name:
+ *      rtk_stat_port_getAll
+ * Description:
+ *      Get all counters of one specified port in the specified device.
+ * Input:
+ *      port - port id.
+ * Output:
+ *      pPort_cntrs - buffer pointer of counter value.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      Get all MIB counters of one port.
+ */
+extern rtk_api_ret_t rtk_stat_port_getAll(rtk_port_t port, rtk_stat_port_cntr_t *pPort_cntrs);
+
+/* Function Name:
+ *      rtk_stat_logging_counterCfg_set
+ * Description:
+ *      Set the type and mode of Logging Counter
+ * Input:
+ *      idx     - The index of Logging Counter. Should be even number only.(0,2,4,6,8.....30)
+ *      mode    - 32 bits or 64 bits mode
+ *      type    - Packet counter or byte counter
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_OUT_OF_RANGE - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      Set the type and mode of Logging Counter.
+ */
+extern rtk_api_ret_t rtk_stat_logging_counterCfg_set(rtk_uint32 idx, rtk_logging_counter_mode_t mode, rtk_logging_counter_type_t type);
+
+/* Function Name:
+ *      rtk_stat_logging_counterCfg_get
+ * Description:
+ *      Get the type and mode of Logging Counter
+ * Input:
+ *      idx     - The index of Logging Counter. Should be even number only.(0,2,4,6,8.....30)
+ * Output:
+ *      pMode   - 32 bits or 64 bits mode
+ *      pType   - Packet counter or byte counter
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_OUT_OF_RANGE - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_NULL_POINTER - NULL Pointer
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      Get the type and mode of Logging Counter.
+ */
+extern rtk_api_ret_t rtk_stat_logging_counterCfg_get(rtk_uint32 idx, rtk_logging_counter_mode_t *pMode, rtk_logging_counter_type_t *pType);
+
+/* Function Name:
+ *      rtk_stat_logging_counter_reset
+ * Description:
+ *      Reset Logging Counter
+ * Input:
+ *      idx     - The index of Logging Counter. (0~31)
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_OUT_OF_RANGE - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      Reset Logging Counter.
+ */
+extern rtk_api_ret_t rtk_stat_logging_counter_reset(rtk_uint32 idx);
+
+/* Function Name:
+ *      rtk_stat_logging_counter_get
+ * Description:
+ *      Get Logging Counter
+ * Input:
+ *      idx     - The index of Logging Counter. (0~31)
+ * Output:
+ *      pCnt    - Logging counter value
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_OUT_OF_RANGE - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      Get Logging Counter.
+ */
+extern rtk_api_ret_t rtk_stat_logging_counter_get(rtk_uint32 idx, rtk_uint32 *pCnt);
+
+/* Function Name:
+ *      rtk_stat_lengthMode_set
+ * Description:
+ *      Set Legnth mode.
+ * Input:
+ *      txMode     - The length counting mode
+ *      rxMode     - The length counting mode
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_INPUT        - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_stat_lengthMode_set(rtk_stat_lengthMode_t txMode, rtk_stat_lengthMode_t rxMode);
+
+/* Function Name:
+ *      rtk_stat_lengthMode_get
+ * Description:
+ *      Get Legnth mode.
+ * Input:
+ *      None.
+ * Output:
+ *      pTxMode       - The length counting mode
+ *      pRxMode       - The length counting mode
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_INPUT        - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ */
+extern rtk_api_ret_t rtk_stat_lengthMode_get(rtk_stat_lengthMode_t *pTxMode, rtk_stat_lengthMode_t *pRxMode);
+
+#endif /* __RTK_API_STAT_H__ */
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/storm.h b/drivers/net/phy/rtk/rtl8367c/include/storm.h
new file mode 100644
index 0000000000000..92db33997bbfd
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/storm.h
@@ -0,0 +1,422 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes Storm module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_STORM_H__
+#define __RTK_API_STORM_H__
+
+#define STORM_UNUC_INDEX                            28
+#define STORM_UNMC_INDEX                            29
+#define STORM_MC_INDEX                              30
+#define STORM_BC_INDEX                              31
+
+typedef enum rtk_rate_storm_group_e
+{
+    STORM_GROUP_UNKNOWN_UNICAST = 0,
+    STORM_GROUP_UNKNOWN_MULTICAST,
+    STORM_GROUP_MULTICAST,
+    STORM_GROUP_BROADCAST,
+    STORM_GROUP_END
+} rtk_rate_storm_group_t;
+
+typedef enum rtk_storm_bypass_e
+{
+    BYPASS_BRG_GROUP = 0,
+    BYPASS_FD_PAUSE,
+    BYPASS_SP_MCAST,
+    BYPASS_1X_PAE,
+    BYPASS_UNDEF_BRG_04,
+    BYPASS_UNDEF_BRG_05,
+    BYPASS_UNDEF_BRG_06,
+    BYPASS_UNDEF_BRG_07,
+    BYPASS_PROVIDER_BRIDGE_GROUP_ADDRESS,
+    BYPASS_UNDEF_BRG_09,
+    BYPASS_UNDEF_BRG_0A,
+    BYPASS_UNDEF_BRG_0B,
+    BYPASS_UNDEF_BRG_0C,
+    BYPASS_PROVIDER_BRIDGE_GVRP_ADDRESS,
+    BYPASS_8021AB,
+    BYPASS_UNDEF_BRG_0F,
+    BYPASS_BRG_MNGEMENT,
+    BYPASS_UNDEFINED_11,
+    BYPASS_UNDEFINED_12,
+    BYPASS_UNDEFINED_13,
+    BYPASS_UNDEFINED_14,
+    BYPASS_UNDEFINED_15,
+    BYPASS_UNDEFINED_16,
+    BYPASS_UNDEFINED_17,
+    BYPASS_UNDEFINED_18,
+    BYPASS_UNDEFINED_19,
+    BYPASS_UNDEFINED_1A,
+    BYPASS_UNDEFINED_1B,
+    BYPASS_UNDEFINED_1C,
+    BYPASS_UNDEFINED_1D,
+    BYPASS_UNDEFINED_1E,
+    BYPASS_UNDEFINED_1F,
+    BYPASS_GMRP,
+    BYPASS_GVRP,
+    BYPASS_UNDEF_GARP_22,
+    BYPASS_UNDEF_GARP_23,
+    BYPASS_UNDEF_GARP_24,
+    BYPASS_UNDEF_GARP_25,
+    BYPASS_UNDEF_GARP_26,
+    BYPASS_UNDEF_GARP_27,
+    BYPASS_UNDEF_GARP_28,
+    BYPASS_UNDEF_GARP_29,
+    BYPASS_UNDEF_GARP_2A,
+    BYPASS_UNDEF_GARP_2B,
+    BYPASS_UNDEF_GARP_2C,
+    BYPASS_UNDEF_GARP_2D,
+    BYPASS_UNDEF_GARP_2E,
+    BYPASS_UNDEF_GARP_2F,
+    BYPASS_IGMP,
+    BYPASS_CDP,
+    BYPASS_CSSTP,
+    BYPASS_LLDP,
+    BYPASS_END,
+}rtk_storm_bypass_t;
+
+/* Function Name:
+ *      rtk_rate_stormControlMeterIdx_set
+ * Description:
+ *      Set the storm control meter index.
+ * Input:
+ *      port       - port id
+ *      storm_type - storm group type
+ *      index       - storm control meter index.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID - Invalid port id
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_rate_stormControlMeterIdx_set(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_uint32 index);
+
+/* Function Name:
+ *      rtk_rate_stormControlMeterIdx_get
+ * Description:
+ *      Get the storm control meter index.
+ * Input:
+ *      port       - port id
+ *      storm_type - storm group type
+ * Output:
+ *      pIndex     - storm control meter index.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID - Invalid port id
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_rate_stormControlMeterIdx_get(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_uint32 *pIndex);
+
+/* Function Name:
+ *      rtk_rate_stormControlPortEnable_set
+ * Description:
+ *      Set enable status of storm control on specified port.
+ * Input:
+ *      port       - port id
+ *      stormType  - storm group type
+ *      enable     - enable status of storm control
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_PORT_ID           - invalid port id
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_rate_stormControlPortEnable_set(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_rate_stormControlPortEnable_set
+ * Description:
+ *      Set enable status of storm control on specified port.
+ * Input:
+ *      port       - port id
+ *      stormType  - storm group type
+ * Output:
+ *      pEnable     - enable status of storm control
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_PORT_ID           - invalid port id
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_rate_stormControlPortEnable_get(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_storm_bypass_set
+ * Description:
+ *      Set bypass storm filter control configuration.
+ * Input:
+ *      type    - Bypass storm filter control type.
+ *      enable  - Bypass status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid IFG parameter
+ * Note:
+ *
+ *      This API can set per-port bypass stomr filter control frame type including RMA and igmp.
+ *      The bypass frame type is as following:
+ *      - BYPASS_BRG_GROUP,
+ *      - BYPASS_FD_PAUSE,
+ *      - BYPASS_SP_MCAST,
+ *      - BYPASS_1X_PAE,
+ *      - BYPASS_UNDEF_BRG_04,
+ *      - BYPASS_UNDEF_BRG_05,
+ *      - BYPASS_UNDEF_BRG_06,
+ *      - BYPASS_UNDEF_BRG_07,
+ *      - BYPASS_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - BYPASS_UNDEF_BRG_09,
+ *      - BYPASS_UNDEF_BRG_0A,
+ *      - BYPASS_UNDEF_BRG_0B,
+ *      - BYPASS_UNDEF_BRG_0C,
+ *      - BYPASS_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - BYPASS_8021AB,
+ *      - BYPASS_UNDEF_BRG_0F,
+ *      - BYPASS_BRG_MNGEMENT,
+ *      - BYPASS_UNDEFINED_11,
+ *      - BYPASS_UNDEFINED_12,
+ *      - BYPASS_UNDEFINED_13,
+ *      - BYPASS_UNDEFINED_14,
+ *      - BYPASS_UNDEFINED_15,
+ *      - BYPASS_UNDEFINED_16,
+ *      - BYPASS_UNDEFINED_17,
+ *      - BYPASS_UNDEFINED_18,
+ *      - BYPASS_UNDEFINED_19,
+ *      - BYPASS_UNDEFINED_1A,
+ *      - BYPASS_UNDEFINED_1B,
+ *      - BYPASS_UNDEFINED_1C,
+ *      - BYPASS_UNDEFINED_1D,
+ *      - BYPASS_UNDEFINED_1E,
+ *      - BYPASS_UNDEFINED_1F,
+ *      - BYPASS_GMRP,
+ *      - BYPASS_GVRP,
+ *      - BYPASS_UNDEF_GARP_22,
+ *      - BYPASS_UNDEF_GARP_23,
+ *      - BYPASS_UNDEF_GARP_24,
+ *      - BYPASS_UNDEF_GARP_25,
+ *      - BYPASS_UNDEF_GARP_26,
+ *      - BYPASS_UNDEF_GARP_27,
+ *      - BYPASS_UNDEF_GARP_28,
+ *      - BYPASS_UNDEF_GARP_29,
+ *      - BYPASS_UNDEF_GARP_2A,
+ *      - BYPASS_UNDEF_GARP_2B,
+ *      - BYPASS_UNDEF_GARP_2C,
+ *      - BYPASS_UNDEF_GARP_2D,
+ *      - BYPASS_UNDEF_GARP_2E,
+ *      - BYPASS_UNDEF_GARP_2F,
+ *      - BYPASS_IGMP.
+ */
+extern rtk_api_ret_t rtk_storm_bypass_set(rtk_storm_bypass_t type, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_storm_bypass_get
+ * Description:
+ *      Get bypass storm filter control configuration.
+ * Input:
+ *      type - Bypass storm filter control type.
+ * Output:
+ *      pEnable - Bypass status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get per-port bypass stomr filter control frame type including RMA and igmp.
+ *      The bypass frame type is as following:
+ *      - BYPASS_BRG_GROUP,
+ *      - BYPASS_FD_PAUSE,
+ *      - BYPASS_SP_MCAST,
+ *      - BYPASS_1X_PAE,
+ *      - BYPASS_UNDEF_BRG_04,
+ *      - BYPASS_UNDEF_BRG_05,
+ *      - BYPASS_UNDEF_BRG_06,
+ *      - BYPASS_UNDEF_BRG_07,
+ *      - BYPASS_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - BYPASS_UNDEF_BRG_09,
+ *      - BYPASS_UNDEF_BRG_0A,
+ *      - BYPASS_UNDEF_BRG_0B,
+ *      - BYPASS_UNDEF_BRG_0C,
+ *      - BYPASS_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - BYPASS_8021AB,
+ *      - BYPASS_UNDEF_BRG_0F,
+ *      - BYPASS_BRG_MNGEMENT,
+ *      - BYPASS_UNDEFINED_11,
+ *      - BYPASS_UNDEFINED_12,
+ *      - BYPASS_UNDEFINED_13,
+ *      - BYPASS_UNDEFINED_14,
+ *      - BYPASS_UNDEFINED_15,
+ *      - BYPASS_UNDEFINED_16,
+ *      - BYPASS_UNDEFINED_17,
+ *      - BYPASS_UNDEFINED_18,
+ *      - BYPASS_UNDEFINED_19,
+ *      - BYPASS_UNDEFINED_1A,
+ *      - BYPASS_UNDEFINED_1B,
+ *      - BYPASS_UNDEFINED_1C,
+ *      - BYPASS_UNDEFINED_1D,
+ *      - BYPASS_UNDEFINED_1E,
+ *      - BYPASS_UNDEFINED_1F,
+ *      - BYPASS_GMRP,
+ *      - BYPASS_GVRP,
+ *      - BYPASS_UNDEF_GARP_22,
+ *      - BYPASS_UNDEF_GARP_23,
+ *      - BYPASS_UNDEF_GARP_24,
+ *      - BYPASS_UNDEF_GARP_25,
+ *      - BYPASS_UNDEF_GARP_26,
+ *      - BYPASS_UNDEF_GARP_27,
+ *      - BYPASS_UNDEF_GARP_28,
+ *      - BYPASS_UNDEF_GARP_29,
+ *      - BYPASS_UNDEF_GARP_2A,
+ *      - BYPASS_UNDEF_GARP_2B,
+ *      - BYPASS_UNDEF_GARP_2C,
+ *      - BYPASS_UNDEF_GARP_2D,
+ *      - BYPASS_UNDEF_GARP_2E,
+ *      - BYPASS_UNDEF_GARP_2F,
+ *      - BYPASS_IGMP.
+ */
+extern rtk_api_ret_t rtk_storm_bypass_get(rtk_storm_bypass_t type, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_rate_stormControlExtPortmask_set
+ * Description:
+ *      Set externsion storm control port mask
+ * Input:
+ *      pPortmask  - port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_rate_stormControlExtPortmask_set(rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_rate_stormControlExtPortmask_get
+ * Description:
+ *      Set externsion storm control port mask
+ * Input:
+ *      None
+ * Output:
+ *      pPortmask  - port mask
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_rate_stormControlExtPortmask_get(rtk_portmask_t *pPortmask);
+
+/* Function Name:
+ *      rtk_rate_stormControlExtEnable_set
+ * Description:
+ *      Set externsion storm control state
+ * Input:
+ *      stormType   - storm group type
+ *      enable      - externsion storm control state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_rate_stormControlExtEnable_set(rtk_rate_storm_group_t stormType, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_rate_stormControlExtEnable_get
+ * Description:
+ *      Get externsion storm control state
+ * Input:
+ *      stormType   - storm group type
+ * Output:
+ *      pEnable     - externsion storm control state
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_rate_stormControlExtEnable_get(rtk_rate_storm_group_t stormType, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_rate_stormControlExtMeterIdx_set
+ * Description:
+ *      Set externsion storm control meter index
+ * Input:
+ *      stormType   - storm group type
+ *      index       - externsion storm control state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_rate_stormControlExtMeterIdx_set(rtk_rate_storm_group_t stormType, rtk_uint32 index);
+
+/* Function Name:
+ *      rtk_rate_stormControlExtMeterIdx_get
+ * Description:
+ *      Get externsion storm control meter index
+ * Input:
+ *      stormType   - storm group type
+ *      pIndex      - externsion storm control state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_rate_stormControlExtMeterIdx_get(rtk_rate_storm_group_t stormType, rtk_uint32 *pIndex);
+
+
+
+#endif /* __RTK_API_STORM_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/svlan.h b/drivers/net/phy/rtk/rtl8367c/include/svlan.h
new file mode 100644
index 0000000000000..32ebf3d705609
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/svlan.h
@@ -0,0 +1,896 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes SVLAN module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_SVLAN_H__
+#define __RTK_API_SVLAN_H__
+
+typedef rtk_uint32 rtk_svlan_index_t;
+
+typedef struct rtk_svlan_memberCfg_s{
+    rtk_uint32 svid;
+    rtk_portmask_t memberport;
+    rtk_portmask_t untagport;
+    rtk_uint32 fiden;
+    rtk_uint32 fid;
+    rtk_uint32 priority;
+    rtk_uint32 efiden;
+    rtk_uint32 efid;
+}rtk_svlan_memberCfg_t;
+
+typedef enum rtk_svlan_pri_ref_e
+{
+    REF_INTERNAL_PRI = 0,
+    REF_CTAG_PRI,
+    REF_SVLAN_PRI,
+    REF_PB_PRI,
+    REF_PRI_END
+} rtk_svlan_pri_ref_t;
+
+
+typedef rtk_uint32 rtk_svlan_tpid_t;
+
+typedef enum rtk_svlan_untag_action_e
+{
+    UNTAG_DROP = 0,
+    UNTAG_TRAP,
+    UNTAG_ASSIGN,
+    UNTAG_END
+} rtk_svlan_untag_action_t;
+
+typedef enum rtk_svlan_unmatch_action_e
+{
+    UNMATCH_DROP = 0,
+    UNMATCH_TRAP,
+    UNMATCH_ASSIGN,
+    UNMATCH_END
+} rtk_svlan_unmatch_action_t;
+
+typedef enum rtk_svlan_unassign_action_e
+{
+    UNASSIGN_PBSVID = 0,
+    UNASSIGN_TRAP,
+    UNASSIGN_END
+} rtk_svlan_unassign_action_t;
+
+
+typedef enum rtk_svlan_lookupType_e
+{
+    SVLAN_LOOKUP_S64MBRCGF  = 0,
+    SVLAN_LOOKUP_C4KVLAN,
+    SVLAN_LOOKUP_END,
+
+} rtk_svlan_lookupType_t;
+
+/* Function Name:
+ *      rtk_svlan_init
+ * Description:
+ *      Initialize SVLAN Configuration
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      Ether type of S-tag in 802.1ad is 0x88a8 and there are existed ether type 0x9100 and 0x9200 for Q-in-Q SLAN design.
+ *      User can set mathced ether type as service provider supported protocol.
+ */
+extern rtk_api_ret_t rtk_svlan_init(void);
+
+/* Function Name:
+ *      rtk_svlan_servicePort_add
+ * Description:
+ *      Add one service port in the specified device
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API is setting which port is connected to provider switch. All frames receiving from this port must
+ *      contain accept SVID in S-tag field.
+ */
+extern rtk_api_ret_t rtk_svlan_servicePort_add(rtk_port_t port);
+
+/* Function Name:
+ *      rtk_svlan_servicePort_get
+ * Description:
+ *      Get service ports in the specified device.
+ * Input:
+ *      None
+ * Output:
+ *      pSvlan_portmask - pointer buffer of svlan ports.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ * Note:
+ *      This API is setting which port is connected to provider switch. All frames receiving from this port must
+ *      contain accept SVID in S-tag field.
+ */
+extern rtk_api_ret_t rtk_svlan_servicePort_get(rtk_portmask_t *pSvlan_portmask);
+
+/* Function Name:
+ *      rtk_svlan_servicePort_del
+ * Description:
+ *      Delete one service port in the specified device
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API is removing SVLAN service port in the specified device.
+ */
+extern rtk_api_ret_t rtk_svlan_servicePort_del(rtk_port_t port);
+
+/* Function Name:
+ *      rtk_svlan_tpidEntry_set
+ * Description:
+ *      Configure accepted S-VLAN ether type.
+ * Input:
+ *      svlan_tag_id - Ether type of S-tag frame parsing in uplink ports.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      Ether type of S-tag in 802.1ad is 0x88a8 and there are existed ether type 0x9100 and 0x9200 for Q-in-Q SLAN design.
+ *      User can set mathced ether type as service provider supported protocol.
+ */
+extern rtk_api_ret_t rtk_svlan_tpidEntry_set(rtk_uint32 svlan_tag_id);
+
+/* Function Name:
+ *      rtk_svlan_tpidEntry_get
+ * Description:
+ *      Get accepted S-VLAN ether type setting.
+ * Input:
+ *      None
+ * Output:
+ *      pSvlan_tag_id -  Ether type of S-tag frame parsing in uplink ports.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      This API is setting which port is connected to provider switch. All frames receiving from this port must
+ *      contain accept SVID in S-tag field.
+ */
+extern rtk_api_ret_t rtk_svlan_tpidEntry_get(rtk_uint32 *pSvlan_tag_id);
+
+/* Function Name:
+ *      rtk_svlan_priorityRef_set
+ * Description:
+ *      Set S-VLAN upstream priority reference setting.
+ * Input:
+ *      ref - reference selection parameter.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      The API can set the upstream SVLAN tag priority reference source. The related priority
+ *      sources are as following:
+ *      - REF_INTERNAL_PRI,
+ *      - REF_CTAG_PRI,
+ *      - REF_SVLAN_PRI,
+ *      - REF_PB_PRI.
+ */
+extern rtk_api_ret_t rtk_svlan_priorityRef_set(rtk_svlan_pri_ref_t ref);
+
+/* Function Name:
+ *      rtk_svlan_priorityRef_get
+ * Description:
+ *      Get S-VLAN upstream priority reference setting.
+ * Input:
+ *      None
+ * Output:
+ *      pRef - reference selection parameter.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      The API can get the upstream SVLAN tag priority reference source. The related priority
+ *      sources are as following:
+ *      - REF_INTERNAL_PRI,
+ *      - REF_CTAG_PRI,
+ *      - REF_SVLAN_PRI,
+ *      - REF_PB_PRI
+ */
+extern rtk_api_ret_t rtk_svlan_priorityRef_get(rtk_svlan_pri_ref_t *pRef);
+
+/* Function Name:
+ *      rtk_svlan_memberPortEntry_set
+ * Description:
+ *      Configure system SVLAN member content
+ * Input:
+ *      svid - SVLAN id
+ *      psvlan_cfg - SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameter.
+ *      RT_ERR_SVLAN_VID        - Invalid SVLAN VID parameter.
+ *      RT_ERR_PORT_MASK        - Invalid portmask.
+ *      RT_ERR_SVLAN_TABLE_FULL - SVLAN configuration is full.
+ * Note:
+ *      The API can set system 64 accepted s-tag frame format. Only 64 SVID S-tag frame will be accpeted
+ *      to receiving from uplink ports. Other SVID S-tag frame or S-untagged frame will be droped by default setup.
+ *      - rtk_svlan_memberCfg_t->svid is SVID of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->memberport is member port mask of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->fid is filtering database of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->priority is priority of SVLAN member configuration.
+ */
+extern rtk_api_ret_t rtk_svlan_memberPortEntry_set(rtk_uint32 svid_idx, rtk_svlan_memberCfg_t *psvlan_cfg);
+
+/* Function Name:
+ *      rtk_svlan_memberPortEntry_get
+ * Description:
+ *      Get SVLAN member Configure.
+ * Input:
+ *      svid - SVLAN id
+ * Output:
+ *      pSvlan_cfg - SVLAN member configuration
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can get system 64 accepted s-tag frame format. Only 64 SVID S-tag frame will be accpeted
+ *      to receiving from uplink ports. Other SVID S-tag frame or S-untagged frame will be droped.
+ */
+extern rtk_api_ret_t rtk_svlan_memberPortEntry_get(rtk_uint32 svid_idx, rtk_svlan_memberCfg_t *pSvlan_cfg);
+
+/* Function Name:
+ *      rtk_svlan_memberPortEntry_adv_set
+ * Description:
+ *      Configure system SVLAN member by index
+ * Input:
+ *      idx         - Index (0 ~ 63)
+ *      psvlan_cfg  - SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameter.
+ *      RT_ERR_SVLAN_VID        - Invalid SVLAN VID parameter.
+ *      RT_ERR_PORT_MASK        - Invalid portmask.
+ *      RT_ERR_SVLAN_TABLE_FULL - SVLAN configuration is full.
+ * Note:
+ *      The API can set system 64 accepted s-tag frame format by index.
+ *      - rtk_svlan_memberCfg_t->svid is SVID of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->memberport is member port mask of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->fid is filtering database of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->priority is priority of SVLAN member configuration.
+ */
+extern rtk_api_ret_t rtk_svlan_memberPortEntry_adv_set(rtk_uint32 idx, rtk_svlan_memberCfg_t *pSvlan_cfg);
+
+/* Function Name:
+ *      rtk_svlan_memberPortEntry_adv_get
+ * Description:
+ *      Get SVLAN member Configure by index.
+ * Input:
+ *      idx         - Index (0 ~ 63)
+ * Output:
+ *      pSvlan_cfg  - SVLAN member configuration
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can get system 64 accepted s-tag frame format. Only 64 SVID S-tag frame will be accpeted
+ *      to receiving from uplink ports. Other SVID S-tag frame or S-untagged frame will be droped.
+ */
+extern rtk_api_ret_t rtk_svlan_memberPortEntry_adv_get(rtk_uint32 idx, rtk_svlan_memberCfg_t *pSvlan_cfg);
+
+/* Function Name:
+ *      rtk_svlan_defaultSvlan_set
+ * Description:
+ *      Configure default egress SVLAN.
+ * Input:
+ *      port - Source port
+ *      svid - SVLAN id
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_INPUT                    - Invalid input parameter.
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ * Note:
+ *      The API can set port n S-tag format index while receiving frame from port n
+ *      is transmit through uplink port with s-tag field
+ */
+extern rtk_api_ret_t rtk_svlan_defaultSvlan_set(rtk_port_t port, rtk_vlan_t svid);
+
+/* Function Name:
+ *      rtk_svlan_defaultSvlan_get
+ * Description:
+ *      Get the configure default egress SVLAN.
+ * Input:
+ *      port - Source port
+ * Output:
+ *      pSvid - SVLAN VID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get port n S-tag format index while receiving frame from port n
+ *      is transmit through uplink port with s-tag field
+ */
+extern rtk_api_ret_t rtk_svlan_defaultSvlan_get(rtk_port_t port, rtk_vlan_t *pSvid);
+
+/* Function Name:
+ *      rtk_svlan_c2s_add
+ * Description:
+ *      Configure SVLAN C2S table
+ * Input:
+ *      vid - VLAN ID
+ *      src_port - Ingress Port
+ *      svid - SVLAN VID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port ID.
+ *      RT_ERR_SVLAN_VID    - Invalid SVLAN VID parameter.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can set system C2S configuration. ASIC will check upstream's VID and assign related
+ *      SVID to mathed packet. There are 128 SVLAN C2S configurations.
+ */
+extern rtk_api_ret_t rtk_svlan_c2s_add(rtk_vlan_t vid, rtk_port_t src_port, rtk_vlan_t svid);
+
+/* Function Name:
+ *      rtk_svlan_c2s_del
+ * Description:
+ *      Delete one C2S entry
+ * Input:
+ *      vid - VLAN ID
+ *      src_port - Ingress Port
+ *      svid - SVLAN VID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_VLAN_VID         - Invalid VID parameter.
+ *      RT_ERR_PORT_ID          - Invalid port ID.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The API can delete system C2S configuration. There are 128 SVLAN C2S configurations.
+ */
+extern rtk_api_ret_t rtk_svlan_c2s_del(rtk_vlan_t vid, rtk_port_t src_port);
+
+/* Function Name:
+ *      rtk_svlan_c2s_get
+ * Description:
+ *      Get configure SVLAN C2S table
+ * Input:
+ *      vid - VLAN ID
+ *      src_port - Ingress Port
+ * Output:
+ *      pSvid - SVLAN ID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port ID.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ * Note:
+ *     The API can get system C2S configuration. There are 128 SVLAN C2S configurations.
+ */
+extern rtk_api_ret_t rtk_svlan_c2s_get(rtk_vlan_t vid, rtk_port_t src_port, rtk_vlan_t *pSvid);
+
+/* Function Name:
+ *      rtk_svlan_untag_action_set
+ * Description:
+ *      Configure Action of downstream Un-Stag packet
+ * Input:
+ *      action  - Action for UnStag
+ *      svid    - The SVID assigned to UnStag packet
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can configure action of downstream Un-Stag packet. A SVID assigned
+ *      to the un-stag is also supported by this API. The parameter of svid is
+ *      only referenced when the action is set to UNTAG_ASSIGN
+ */
+extern rtk_api_ret_t rtk_svlan_untag_action_set(rtk_svlan_untag_action_t action, rtk_vlan_t svid);
+
+/* Function Name:
+ *      rtk_svlan_untag_action_get
+ * Description:
+ *      Get Action of downstream Un-Stag packet
+ * Input:
+ *      None
+ * Output:
+ *      pAction  - Action for UnStag
+ *      pSvid    - The SVID assigned to UnStag packet
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can Get action of downstream Un-Stag packet. A SVID assigned
+ *      to the un-stag is also retrieved by this API. The parameter pSvid is
+ *      only refernced when the action is UNTAG_ASSIGN
+ */
+extern rtk_api_ret_t rtk_svlan_untag_action_get(rtk_svlan_untag_action_t *pAction, rtk_vlan_t *pSvid);
+
+/* Function Name:
+ *      rtk_svlan_unmatch_action_set
+ * Description:
+ *      Configure Action of downstream Unmatch packet
+ * Input:
+ *      action  - Action for Unmatch
+ *      svid    - The SVID assigned to Unmatch packet
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can configure action of downstream Un-match packet. A SVID assigned
+ *      to the un-match is also supported by this API. The parameter od svid is
+ *      only refernced when the action is set to UNMATCH_ASSIGN
+ */
+extern rtk_api_ret_t rtk_svlan_unmatch_action_set(rtk_svlan_unmatch_action_t action, rtk_vlan_t svid);
+
+/* Function Name:
+ *      rtk_svlan_unmatch_action_get
+ * Description:
+ *      Get Action of downstream Unmatch packet
+ * Input:
+ *      None
+ * Output:
+ *      pAction  - Action for Unmatch
+ *      pSvid    - The SVID assigned to Unmatch packet
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can Get action of downstream Un-match packet. A SVID assigned
+ *      to the un-match is also retrieved by this API. The parameter pSvid is
+ *      only refernced when the action is UNMATCH_ASSIGN
+ */
+extern rtk_api_ret_t rtk_svlan_unmatch_action_get(rtk_svlan_unmatch_action_t *pAction, rtk_vlan_t *pSvid);
+
+/* Function Name:
+ *      rtk_svlan_dmac_vidsel_set
+ * Description:
+ *      Set DMAC CVID selection
+ * Input:
+ *      port    - Port
+ *      enable  - state of DMAC CVID Selection
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      This API can set DMAC CVID Selection state
+ */
+extern rtk_api_ret_t rtk_svlan_dmac_vidsel_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_svlan_dmac_vidsel_get
+ * Description:
+ *      Get DMAC CVID selection
+ * Input:
+ *      port    - Port
+ * Output:
+ *      pEnable - state of DMAC CVID Selection
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      This API can get DMAC CVID Selection state
+ */
+extern rtk_api_ret_t rtk_svlan_dmac_vidsel_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_svlan_ipmc2s_add
+ * Description:
+ *      add ip multicast address to SVLAN
+ * Input:
+ *      svid    - SVLAN VID
+ *      ipmc    - ip multicast address
+ *      ipmcMsk - ip multicast mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can set IP mutlicast to SVID configuration. If upstream packet is IPv4 multicast
+ *      packet and DIP is matched MC2S configuration, ASIC will assign egress SVID to the packet.
+ *      There are 32 SVLAN multicast configurations for IP and L2 multicast.
+ */
+extern rtk_api_ret_t rtk_svlan_ipmc2s_add(ipaddr_t ipmc, ipaddr_t ipmcMsk, rtk_vlan_t svid);
+
+/* Function Name:
+ *      rtk_svlan_ipmc2s_del
+ * Description:
+ *      delete ip multicast address to SVLAN
+ * Input:
+ *      ipmc    - ip multicast address
+ *      ipmcMsk - ip multicast mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_SVLAN_VID        - Invalid SVLAN VID parameter.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The API can delete IP mutlicast to SVID configuration. There are 32 SVLAN multicast configurations for IP and L2 multicast.
+ */
+extern rtk_api_ret_t rtk_svlan_ipmc2s_del(ipaddr_t ipmc, ipaddr_t ipmcMsk);
+
+/* Function Name:
+ *      rtk_svlan_ipmc2s_get
+ * Description:
+ *      Get ip multicast address to SVLAN
+ * Input:
+ *      ipmc    - ip multicast address
+ *      ipmcMsk - ip multicast mask
+ * Output:
+ *      pSvid - SVLAN VID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ * Note:
+ *      The API can get IP mutlicast to SVID configuration. There are 32 SVLAN multicast configurations for IP and L2 multicast.
+ */
+extern rtk_api_ret_t rtk_svlan_ipmc2s_get(ipaddr_t ipmc, ipaddr_t ipmcMsk, rtk_vlan_t *pSvid);
+
+/* Function Name:
+ *      rtk_svlan_l2mc2s_add
+ * Description:
+ *      Add L2 multicast address to SVLAN
+ * Input:
+ *      mac     - L2 multicast address
+ *      macMsk  - L2 multicast address mask
+ *      svid    - SVLAN VID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can set L2 Mutlicast to SVID configuration. If upstream packet is L2 multicast
+ *      packet and DMAC is matched, ASIC will assign egress SVID to the packet. There are 32
+ *      SVLAN multicast configurations for IP and L2 multicast.
+ */
+extern rtk_api_ret_t rtk_svlan_l2mc2s_add(rtk_mac_t mac, rtk_mac_t macMsk, rtk_vlan_t svid);
+
+/* Function Name:
+ *      rtk_svlan_l2mc2s_del
+ * Description:
+ *      delete L2 multicast address to SVLAN
+ * Input:
+ *      mac     - L2 multicast address
+ *      macMsk  - L2 multicast address mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_SVLAN_VID        - Invalid SVLAN VID parameter.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The API can delete Mutlicast to SVID configuration. There are 32 SVLAN multicast configurations for IP and L2 multicast.
+ */
+extern rtk_api_ret_t rtk_svlan_l2mc2s_del(rtk_mac_t mac, rtk_mac_t macMsk);
+
+/* Function Name:
+ *      rtk_svlan_l2mc2s_get
+ * Description:
+ *      Get L2 multicast address to SVLAN
+ * Input:
+ *      mac     - L2 multicast address
+ *      macMsk  - L2 multicast address mask
+ * Output:
+ *      pSvid   - SVLAN VID
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The API can get L2 mutlicast to SVID configuration. There are 32 SVLAN multicast configurations for IP and L2 multicast.
+ */
+extern rtk_api_ret_t rtk_svlan_l2mc2s_get(rtk_mac_t mac, rtk_mac_t macMsk, rtk_vlan_t *pSvid);
+
+/* Function Name:
+ *      rtk_svlan_sp2c_add
+ * Description:
+ *      Add system SP2C configuration
+ * Input:
+ *      cvid        - VLAN ID
+ *      dst_port    - Destination port of SVLAN to CVLAN configuration
+ *      svid        - SVLAN VID
+ *
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_SVLAN_VID    - Invalid SVLAN VID parameter.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can add SVID & Destination Port to CVLAN configuration. The downstream frames with assigned
+ *      SVID will be add C-tag with assigned CVID if the output port is the assigned destination port.
+ *      There are 128 SP2C configurations.
+ */
+extern rtk_api_ret_t rtk_svlan_sp2c_add(rtk_vlan_t svid, rtk_port_t dst_port, rtk_vlan_t cvid);
+
+/* Function Name:
+ *      rtk_svlan_sp2c_get
+ * Description:
+ *      Get configure system SP2C content
+ * Input:
+ *      svid        - SVLAN VID
+ *      dst_port    - Destination port of SVLAN to CVLAN configuration
+ * Output:
+ *      pCvid - VLAN ID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_SVLAN_VID    - Invalid SVLAN VID parameter.
+ * Note:
+ *     The API can get SVID & Destination Port to CVLAN configuration. There are 128 SP2C configurations.
+ */
+extern rtk_api_ret_t rtk_svlan_sp2c_get(rtk_vlan_t svid, rtk_port_t dst_port, rtk_vlan_t *pCvid);
+
+/* Function Name:
+ *      rtk_svlan_sp2c_del
+ * Description:
+ *      Delete system SP2C configuration
+ * Input:
+ *      svid        - SVLAN VID
+ *      dst_port    - Destination port of SVLAN to CVLAN configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_SVLAN_VID    - Invalid SVLAN VID parameter.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ * Note:
+ *      The API can delete SVID & Destination Port to CVLAN configuration. There are 128 SP2C configurations.
+ */
+extern rtk_api_ret_t rtk_svlan_sp2c_del(rtk_vlan_t svid, rtk_port_t dst_port);
+
+
+/* Function Name:
+ *      rtk_svlan_lookupType_set
+ * Description:
+ *      Set lookup type of SVLAN
+ * Input:
+ *      type        - lookup type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ * Note:
+ *      none
+ */
+extern rtk_api_ret_t rtk_svlan_lookupType_set(rtk_svlan_lookupType_t type);
+
+/* Function Name:
+ *      rtk_svlan_lookupType_get
+ * Description:
+ *      Get lookup type of SVLAN
+ * Input:
+ *      pType       - lookup type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ * Note:
+ *      none
+ */
+extern rtk_api_ret_t rtk_svlan_lookupType_get(rtk_svlan_lookupType_t *pType);
+
+/* Function Name:
+ *      rtk_svlan_trapPri_set
+ * Description:
+ *      Set svlan trap priority
+ * Input:
+ *      priority - priority for trap packets
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_QOS_INT_PRIORITY
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_svlan_trapPri_set(rtk_pri_t priority);
+
+/* Function Name:
+ *      rtk_svlan_trapPri_get
+ * Description:
+ *      Get svlan trap priority
+ * Input:
+ *      None
+ * Output:
+ *      pPriority - priority for trap packets
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_svlan_trapPri_get(rtk_pri_t *pPriority);
+
+/* Function Name:
+ *      rtk_svlan_unassign_action_set
+ * Description:
+ *      Configure Action of upstream without svid assign action
+ * Input:
+ *      action  - Action for Un-assign
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can configure action of upstream Un-assign svid packet. If action is not
+ *      trap to CPU, the port-based SVID sure be assign as system need
+ */
+extern rtk_api_ret_t rtk_svlan_unassign_action_set(rtk_svlan_unassign_action_t action);
+
+/* Function Name:
+ *      rtk_svlan_unassign_action_get
+ * Description:
+ *      Get action of upstream without svid assignment
+ * Input:
+ *      None
+ * Output:
+ *      pAction  - Action for Un-assign
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ * Note:
+ *      None
+ */
+extern rtk_api_ret_t rtk_svlan_unassign_action_get(rtk_svlan_unassign_action_t *pAction);
+
+
+/* Function Name:
+ *      rtk_svlan_checkAndCreateMbr
+ * Description:
+ *      Check and create Member configuration and return index
+ * Input:
+ *      vid  - VLAN id.
+ * Output:
+ *      pIndex  - Member configuration index
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_VLAN_VID     - Invalid VLAN ID.
+ *      RT_ERR_TBL_FULL     - Member Configuration table full
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_svlan_checkAndCreateMbr(rtk_vlan_t vid, rtk_uint32 *pIndex);
+
+
+#endif /* __RTK_API_SVLAN_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/trap.h b/drivers/net/phy/rtk/rtl8367c/include/trap.h
new file mode 100644
index 0000000000000..a44ef909d6f5e
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/trap.h
@@ -0,0 +1,757 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes Trap module high-layer API defination
+ *
+ */
+
+#ifndef __RTK_API_TRAP_H__
+#define __RTK_API_TRAP_H__
+
+
+typedef enum rtk_trap_type_e
+{
+    TRAP_BRG_GROUP = 0,
+    TRAP_FD_PAUSE,
+    TRAP_SP_MCAST,
+    TRAP_1X_PAE,
+    TRAP_UNDEF_BRG_04,
+    TRAP_UNDEF_BRG_05,
+    TRAP_UNDEF_BRG_06,
+    TRAP_UNDEF_BRG_07,
+    TRAP_PROVIDER_BRIDGE_GROUP_ADDRESS,
+    TRAP_UNDEF_BRG_09,
+    TRAP_UNDEF_BRG_0A,
+    TRAP_UNDEF_BRG_0B,
+    TRAP_UNDEF_BRG_0C,
+    TRAP_PROVIDER_BRIDGE_GVRP_ADDRESS,
+    TRAP_8021AB,
+    TRAP_UNDEF_BRG_0F,
+    TRAP_BRG_MNGEMENT,
+    TRAP_UNDEFINED_11,
+    TRAP_UNDEFINED_12,
+    TRAP_UNDEFINED_13,
+    TRAP_UNDEFINED_14,
+    TRAP_UNDEFINED_15,
+    TRAP_UNDEFINED_16,
+    TRAP_UNDEFINED_17,
+    TRAP_UNDEFINED_18,
+    TRAP_UNDEFINED_19,
+    TRAP_UNDEFINED_1A,
+    TRAP_UNDEFINED_1B,
+    TRAP_UNDEFINED_1C,
+    TRAP_UNDEFINED_1D,
+    TRAP_UNDEFINED_1E,
+    TRAP_UNDEFINED_1F,
+    TRAP_GMRP,
+    TRAP_GVRP,
+    TRAP_UNDEF_GARP_22,
+    TRAP_UNDEF_GARP_23,
+    TRAP_UNDEF_GARP_24,
+    TRAP_UNDEF_GARP_25,
+    TRAP_UNDEF_GARP_26,
+    TRAP_UNDEF_GARP_27,
+    TRAP_UNDEF_GARP_28,
+    TRAP_UNDEF_GARP_29,
+    TRAP_UNDEF_GARP_2A,
+    TRAP_UNDEF_GARP_2B,
+    TRAP_UNDEF_GARP_2C,
+    TRAP_UNDEF_GARP_2D,
+    TRAP_UNDEF_GARP_2E,
+    TRAP_UNDEF_GARP_2F,
+    TRAP_CDP,
+    TRAP_CSSTP,
+    TRAP_LLDP,
+    TRAP_END,
+}rtk_trap_type_t;
+
+
+typedef enum rtk_mcast_type_e
+{
+    MCAST_L2 = 0,
+    MCAST_IPV4,
+    MCAST_IPV6,
+    MCAST_END
+} rtk_mcast_type_t;
+
+typedef enum rtk_trap_mcast_action_e
+{
+    MCAST_ACTION_FORWARD = 0,
+    MCAST_ACTION_DROP,
+    MCAST_ACTION_TRAP2CPU,
+    MCAST_ACTION_ROUTER_PORT,
+    MCAST_ACTION_DROP_EX_RMA,
+    MCAST_ACTION_END
+} rtk_trap_mcast_action_t;
+
+typedef enum rtk_trap_rma_action_e
+{
+    RMA_ACTION_FORWARD = 0,
+    RMA_ACTION_TRAP2CPU,
+    RMA_ACTION_DROP,
+    RMA_ACTION_FORWARD_EXCLUDE_CPU,
+    RMA_ACTION_END
+} rtk_trap_rma_action_t;
+
+typedef enum rtk_trap_ucast_action_e
+{
+    UCAST_ACTION_FORWARD_PMASK = 0,
+    UCAST_ACTION_DROP,
+    UCAST_ACTION_TRAP2CPU,
+    UCAST_ACTION_FLOODING,
+    UCAST_ACTION_END
+} rtk_trap_ucast_action_t;
+
+typedef enum rtk_trap_ucast_type_e
+{
+    UCAST_UNKNOWNDA = 0,
+    UCAST_UNKNOWNSA,
+    UCAST_UNMATCHSA,
+    UCAST_END
+} rtk_trap_ucast_type_t;
+
+typedef enum rtk_trap_reason_type_e
+{
+    TRAP_REASON_RMA = 0,
+    TRAP_REASON_OAM,
+    TRAP_REASON_1XUNAUTH,
+    TRAP_REASON_VLANSTACK,
+    TRAP_REASON_UNKNOWNMC,
+    TRAP_REASON_END,
+} rtk_trap_reason_type_t;
+
+
+/* Function Name:
+ *      rtk_trap_unknownUnicastPktAction_set
+ * Description:
+ *      Set unknown unicast packet action configuration.
+ * Input:
+ *      port            - ingress port ID for unknown unicast packet
+ *      ucast_action    - Unknown unicast action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ *      This API can set unknown unicast packet action configuration.
+ *      The unknown unicast action is as following:
+ *          - UCAST_ACTION_FORWARD_PMASK
+ *          - UCAST_ACTION_DROP
+ *          - UCAST_ACTION_TRAP2CPU
+ *          - UCAST_ACTION_FLOODING
+ */
+rtk_api_ret_t rtk_trap_unknownUnicastPktAction_set(rtk_port_t port, rtk_trap_ucast_action_t ucast_action);
+
+/* Function Name:
+ *      rtk_trap_unknownUnicastPktAction_get
+ * Description:
+ *      Get unknown unicast packet action configuration.
+ * Input:
+ *      port            - ingress port ID for unknown unicast packet
+ * Output:
+ *      pUcast_action   - Unknown unicast action.
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ *      RT_ERR_NULL_POINTER        - Null pointer
+ * Note:
+ *      This API can get unknown unicast packet action configuration.
+ *      The unknown unicast action is as following:
+ *          - UCAST_ACTION_FORWARD_PMASK
+ *          - UCAST_ACTION_DROP
+ *          - UCAST_ACTION_TRAP2CPU
+ *          - UCAST_ACTION_FLOODING
+ */
+rtk_api_ret_t rtk_trap_unknownUnicastPktAction_get(rtk_port_t port, rtk_trap_ucast_action_t *pUcast_action);
+
+/* Function Name:
+ *      rtk_trap_unknownMacPktAction_set
+ * Description:
+ *      Set unknown source MAC packet action configuration.
+ * Input:
+ *      ucast_action    - Unknown source MAC action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ *      This API can set unknown unicast packet action configuration.
+ *      The unknown unicast action is as following:
+ *          - UCAST_ACTION_FORWARD_PMASK
+ *          - UCAST_ACTION_DROP
+ *          - UCAST_ACTION_TRAP2CPU
+ */
+extern rtk_api_ret_t rtk_trap_unknownMacPktAction_set(rtk_trap_ucast_action_t ucast_action);
+
+/* Function Name:
+ *      rtk_trap_unknownMacPktAction_get
+ * Description:
+ *      Get unknown source MAC packet action configuration.
+ * Input:
+ *      None.
+ * Output:
+ *      pUcast_action   - Unknown source MAC action.
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NULL_POINTER        - Null Pointer.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_trap_unknownMacPktAction_get(rtk_trap_ucast_action_t *pUcast_action);
+
+/* Function Name:
+ *      rtk_trap_unmatchMacPktAction_set
+ * Description:
+ *      Set unmatch source MAC packet action configuration.
+ * Input:
+ *      ucast_action    - Unknown source MAC action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ *      This API can set unknown unicast packet action configuration.
+ *      The unknown unicast action is as following:
+ *          - UCAST_ACTION_FORWARD_PMASK
+ *          - UCAST_ACTION_DROP
+ *          - UCAST_ACTION_TRAP2CPU
+ */
+extern rtk_api_ret_t rtk_trap_unmatchMacPktAction_set(rtk_trap_ucast_action_t ucast_action);
+
+/* Function Name:
+ *      rtk_trap_unmatchMacPktAction_get
+ * Description:
+ *      Get unmatch source MAC packet action configuration.
+ * Input:
+ *      None.
+ * Output:
+ *      pUcast_action   - Unknown source MAC action.
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ *      This API can set unknown unicast packet action configuration.
+ *      The unknown unicast action is as following:
+ *          - UCAST_ACTION_FORWARD_PMASK
+ *          - UCAST_ACTION_DROP
+ *          - UCAST_ACTION_TRAP2CPU
+ */
+extern rtk_api_ret_t rtk_trap_unmatchMacPktAction_get(rtk_trap_ucast_action_t *pUcast_action);
+
+/* Function Name:
+ *      rtk_trap_unmatchMacMoving_set
+ * Description:
+ *      Set unmatch source MAC packet moving state.
+ * Input:
+ *      port        - Port ID.
+ *      enable      - ENABLED: allow SA moving, DISABLE: don't allow SA moving.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ */
+extern rtk_api_ret_t rtk_trap_unmatchMacMoving_set(rtk_port_t port, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_trap_unmatchMacMoving_get
+ * Description:
+ *      Set unmatch source MAC packet moving state.
+ * Input:
+ *      port        - Port ID.
+ * Output:
+ *      pEnable     - ENABLED: allow SA moving, DISABLE: don't allow SA moving.
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ */
+extern rtk_api_ret_t rtk_trap_unmatchMacMoving_get(rtk_port_t port, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_trap_unknownMcastPktAction_set
+ * Description:
+ *      Set behavior of unknown multicast
+ * Input:
+ *      port            - Port id.
+ *      type            - unknown multicast packet type.
+ *      mcast_action    - unknown multicast action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_NOT_ALLOWED  - Invalid action.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      When receives an unknown multicast packet, switch may trap, drop or flood this packet
+ *      (1) The unknown multicast packet type is as following:
+ *          - MCAST_L2
+ *          - MCAST_IPV4
+ *          - MCAST_IPV6
+ *      (2) The unknown multicast action is as following:
+ *          - MCAST_ACTION_FORWARD
+ *          - MCAST_ACTION_DROP
+ *          - MCAST_ACTION_TRAP2CPU
+ */
+extern rtk_api_ret_t rtk_trap_unknownMcastPktAction_set(rtk_port_t port, rtk_mcast_type_t type, rtk_trap_mcast_action_t mcast_action);
+
+/* Function Name:
+ *      rtk_trap_unknownMcastPktAction_get
+ * Description:
+ *      Get behavior of unknown multicast
+ * Input:
+ *      type - unknown multicast packet type.
+ * Output:
+ *      pMcast_action - unknown multicast action.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_NOT_ALLOWED      - Invalid operation.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      When receives an unknown multicast packet, switch may trap, drop or flood this packet
+ *      (1) The unknown multicast packet type is as following:
+ *          - MCAST_L2
+ *          - MCAST_IPV4
+ *          - MCAST_IPV6
+ *      (2) The unknown multicast action is as following:
+ *          - MCAST_ACTION_FORWARD
+ *          - MCAST_ACTION_DROP
+ *          - MCAST_ACTION_TRAP2CPU
+ */
+extern rtk_api_ret_t rtk_trap_unknownMcastPktAction_get(rtk_port_t port, rtk_mcast_type_t type, rtk_trap_mcast_action_t *pMcast_action);
+
+/* Function Name:
+ *      rtk_trap_lldpEnable_set
+ * Description:
+ *      Set LLDP enable.
+ * Input:
+ *      enabled - LLDP enable, 0: follow RMA, 1: use LLDP action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NOT_ALLOWED      - Invalid action.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      - DMAC                                                 Assignment
+ *      - 01:80:c2:00:00:0e ethertype = 0x88CC    LLDP
+ *      - 01:80:c2:00:00:03 ethertype = 0x88CC
+ *      - 01:80:c2:00:00:00 ethertype = 0x88CC
+
+ */
+extern rtk_api_ret_t rtk_trap_lldpEnable_set(rtk_enable_t enabled);
+
+/* Function Name:
+ *      rtk_trap_lldpEnable_get
+ * Description:
+ *      Get LLDP status.
+ * Input:
+ *      None
+ * Output:
+ *      pEnabled - LLDP enable, 0: follow RMA, 1: use LLDP action.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      LLDP is as following definition.
+ *      - DMAC                                                 Assignment
+ *      - 01:80:c2:00:00:0e ethertype = 0x88CC    LLDP
+ *      - 01:80:c2:00:00:03 ethertype = 0x88CC
+ *      - 01:80:c2:00:00:00 ethertype = 0x88CC
+ */
+extern rtk_api_ret_t rtk_trap_lldpEnable_get(rtk_enable_t *pEnabled);
+
+/* Function Name:
+ *      rtk_trap_reasonTrapToCpuPriority_set
+ * Description:
+ *      Set priority value of a packet that trapped to CPU port according to specific reason.
+ * Input:
+ *      type     - reason that trap to CPU port.
+ *      priority - internal priority that is going to be set for specific trap reason.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT - The module is not initial
+ *      RT_ERR_INPUT    - Invalid input parameter
+ * Note:
+ *      Currently the trap reason that supported are listed as follows:
+ *      - TRAP_REASON_RMA
+ *      - TRAP_REASON_OAM
+ *      - TRAP_REASON_1XUNAUTH
+ *      - TRAP_REASON_VLANSTACK
+ *      - TRAP_REASON_UNKNOWNMC
+ */
+extern rtk_api_ret_t rtk_trap_reasonTrapToCpuPriority_set(rtk_trap_reason_type_t type, rtk_pri_t priority);
+
+/* Function Name:
+ *      rtk_trap_reasonTrapToCpuPriority_get
+ * Description:
+ *      Get priority value of a packet that trapped to CPU port according to specific reason.
+ * Input:
+ *      type      - reason that trap to CPU port.
+ * Output:
+ *      pPriority - configured internal priority for such reason.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT     - The module is not initial
+ *      RT_ERR_INPUT        - Invalid input parameter
+ *      RT_ERR_NULL_POINTER - NULL pointer
+ * Note:
+ *      Currently the trap reason that supported are listed as follows:
+ *      - TRAP_REASON_RMA
+ *      - TRAP_REASON_OAM
+ *      - TRAP_REASON_1XUNAUTH
+ *      - TRAP_REASON_VLANSTACK
+ *      - TRAP_REASON_UNKNOWNMC
+ */
+extern rtk_api_ret_t rtk_trap_reasonTrapToCpuPriority_get(rtk_trap_reason_type_t type, rtk_pri_t *pPriority);
+
+/* Function Name:
+ *      rtk_trap_rmaAction_set
+ * Description:
+ *      Set Reserved multicast address action configuration.
+ * Input:
+ *      type    - rma type.
+ *      rma_action - RMA action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid IFG parameter
+ * Note:
+ *
+ *      There are 48 types of Reserved Multicast Address frame for application usage.
+ *      (1)They are as following definition.
+ *      - TRAP_BRG_GROUP,
+ *      - TRAP_FD_PAUSE,
+ *      - TRAP_SP_MCAST,
+ *      - TRAP_1X_PAE,
+ *      - TRAP_UNDEF_BRG_04,
+ *      - TRAP_UNDEF_BRG_05,
+ *      - TRAP_UNDEF_BRG_06,
+ *      - TRAP_UNDEF_BRG_07,
+ *      - TRAP_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - TRAP_UNDEF_BRG_09,
+ *      - TRAP_UNDEF_BRG_0A,
+ *      - TRAP_UNDEF_BRG_0B,
+ *      - TRAP_UNDEF_BRG_0C,
+ *      - TRAP_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - TRAP_8021AB,
+ *      - TRAP_UNDEF_BRG_0F,
+ *      - TRAP_BRG_MNGEMENT,
+ *      - TRAP_UNDEFINED_11,
+ *      - TRAP_UNDEFINED_12,
+ *      - TRAP_UNDEFINED_13,
+ *      - TRAP_UNDEFINED_14,
+ *      - TRAP_UNDEFINED_15,
+ *      - TRAP_UNDEFINED_16,
+ *      - TRAP_UNDEFINED_17,
+ *      - TRAP_UNDEFINED_18,
+ *      - TRAP_UNDEFINED_19,
+ *      - TRAP_UNDEFINED_1A,
+ *      - TRAP_UNDEFINED_1B,
+ *      - TRAP_UNDEFINED_1C,
+ *      - TRAP_UNDEFINED_1D,
+ *      - TRAP_UNDEFINED_1E,
+ *      - TRAP_UNDEFINED_1F,
+ *      - TRAP_GMRP,
+ *      - TRAP_GVRP,
+ *      - TRAP_UNDEF_GARP_22,
+ *      - TRAP_UNDEF_GARP_23,
+ *      - TRAP_UNDEF_GARP_24,
+ *      - TRAP_UNDEF_GARP_25,
+ *      - TRAP_UNDEF_GARP_26,
+ *      - TRAP_UNDEF_GARP_27,
+ *      - TRAP_UNDEF_GARP_28,
+ *      - TRAP_UNDEF_GARP_29,
+ *      - TRAP_UNDEF_GARP_2A,
+ *      - TRAP_UNDEF_GARP_2B,
+ *      - TRAP_UNDEF_GARP_2C,
+ *      - TRAP_UNDEF_GARP_2D,
+ *      - TRAP_UNDEF_GARP_2E,
+ *      - TRAP_UNDEF_GARP_2F,
+ *      - TRAP_CDP.
+ *      - TRAP_CSSTP.
+ *      - TRAP_LLDP.
+ *      (2) The RMA action is as following:
+ *      - RMA_ACTION_FORWARD
+ *      - RMA_ACTION_TRAP2CPU
+ *      - RMA_ACTION_DROP
+ *      - RMA_ACTION_FORWARD_EXCLUDE_CPU
+ */
+extern rtk_api_ret_t rtk_trap_rmaAction_set(rtk_trap_type_t type, rtk_trap_rma_action_t rma_action);
+
+/* Function Name:
+ *      rtk_trap_rmaAction_get
+ * Description:
+ *      Get Reserved multicast address action configuration.
+ * Input:
+ *      type - rma type.
+ * Output:
+ *      pRma_action - RMA action.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      There are 48 types of Reserved Multicast Address frame for application usage.
+ *      (1)They are as following definition.
+ *      - TRAP_BRG_GROUP,
+ *      - TRAP_FD_PAUSE,
+ *      - TRAP_SP_MCAST,
+ *      - TRAP_1X_PAE,
+ *      - TRAP_UNDEF_BRG_04,
+ *      - TRAP_UNDEF_BRG_05,
+ *      - TRAP_UNDEF_BRG_06,
+ *      - TRAP_UNDEF_BRG_07,
+ *      - TRAP_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - TRAP_UNDEF_BRG_09,
+ *      - TRAP_UNDEF_BRG_0A,
+ *      - TRAP_UNDEF_BRG_0B,
+ *      - TRAP_UNDEF_BRG_0C,
+ *      - TRAP_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - TRAP_8021AB,
+ *      - TRAP_UNDEF_BRG_0F,
+ *      - TRAP_BRG_MNGEMENT,
+ *      - TRAP_UNDEFINED_11,
+ *      - TRAP_UNDEFINED_12,
+ *      - TRAP_UNDEFINED_13,
+ *      - TRAP_UNDEFINED_14,
+ *      - TRAP_UNDEFINED_15,
+ *      - TRAP_UNDEFINED_16,
+ *      - TRAP_UNDEFINED_17,
+ *      - TRAP_UNDEFINED_18,
+ *      - TRAP_UNDEFINED_19,
+ *      - TRAP_UNDEFINED_1A,
+ *      - TRAP_UNDEFINED_1B,
+ *      - TRAP_UNDEFINED_1C,
+ *      - TRAP_UNDEFINED_1D,
+ *      - TRAP_UNDEFINED_1E,
+ *      - TRAP_UNDEFINED_1F,
+ *      - TRAP_GMRP,
+ *      - TRAP_GVRP,
+ *      - TRAP_UNDEF_GARP_22,
+ *      - TRAP_UNDEF_GARP_23,
+ *      - TRAP_UNDEF_GARP_24,
+ *      - TRAP_UNDEF_GARP_25,
+ *      - TRAP_UNDEF_GARP_26,
+ *      - TRAP_UNDEF_GARP_27,
+ *      - TRAP_UNDEF_GARP_28,
+ *      - TRAP_UNDEF_GARP_29,
+ *      - TRAP_UNDEF_GARP_2A,
+ *      - TRAP_UNDEF_GARP_2B,
+ *      - TRAP_UNDEF_GARP_2C,
+ *      - TRAP_UNDEF_GARP_2D,
+ *      - TRAP_UNDEF_GARP_2E,
+ *      - TRAP_UNDEF_GARP_2F,
+ *      - TRAP_CDP.
+ *      - TRAP_CSSTP.
+ *      - TRAP_LLDP.
+ *      (2) The RMA action is as following:
+ *      - RMA_ACTION_FORWARD
+ *      - RMA_ACTION_TRAP2CPU
+ *      - RMA_ACTION_DROP
+ *      - RMA_ACTION_FORWARD_EXCLUDE_CPU
+ */
+extern rtk_api_ret_t rtk_trap_rmaAction_get(rtk_trap_type_t type, rtk_trap_rma_action_t *pRma_action);
+
+/* Function Name:
+ *      rtk_trap_rmaKeepFormat_set
+ * Description:
+ *      Set Reserved multicast address keep format configuration.
+ * Input:
+ *      type    - rma type.
+ *      enable - enable keep format.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid IFG parameter
+ * Note:
+ *
+ *      There are 48 types of Reserved Multicast Address frame for application usage.
+ *      They are as following definition.
+ *      - TRAP_BRG_GROUP,
+ *      - TRAP_FD_PAUSE,
+ *      - TRAP_SP_MCAST,
+ *      - TRAP_1X_PAE,
+ *      - TRAP_UNDEF_BRG_04,
+ *      - TRAP_UNDEF_BRG_05,
+ *      - TRAP_UNDEF_BRG_06,
+ *      - TRAP_UNDEF_BRG_07,
+ *      - TRAP_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - TRAP_UNDEF_BRG_09,
+ *      - TRAP_UNDEF_BRG_0A,
+ *      - TRAP_UNDEF_BRG_0B,
+ *      - TRAP_UNDEF_BRG_0C,
+ *      - TRAP_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - TRAP_8021AB,
+ *      - TRAP_UNDEF_BRG_0F,
+ *      - TRAP_BRG_MNGEMENT,
+ *      - TRAP_UNDEFINED_11,
+ *      - TRAP_UNDEFINED_12,
+ *      - TRAP_UNDEFINED_13,
+ *      - TRAP_UNDEFINED_14,
+ *      - TRAP_UNDEFINED_15,
+ *      - TRAP_UNDEFINED_16,
+ *      - TRAP_UNDEFINED_17,
+ *      - TRAP_UNDEFINED_18,
+ *      - TRAP_UNDEFINED_19,
+ *      - TRAP_UNDEFINED_1A,
+ *      - TRAP_UNDEFINED_1B,
+ *      - TRAP_UNDEFINED_1C,
+ *      - TRAP_UNDEFINED_1D,
+ *      - TRAP_UNDEFINED_1E,
+ *      - TRAP_UNDEFINED_1F,
+ *      - TRAP_GMRP,
+ *      - TRAP_GVRP,
+ *      - TRAP_UNDEF_GARP_22,
+ *      - TRAP_UNDEF_GARP_23,
+ *      - TRAP_UNDEF_GARP_24,
+ *      - TRAP_UNDEF_GARP_25,
+ *      - TRAP_UNDEF_GARP_26,
+ *      - TRAP_UNDEF_GARP_27,
+ *      - TRAP_UNDEF_GARP_28,
+ *      - TRAP_UNDEF_GARP_29,
+ *      - TRAP_UNDEF_GARP_2A,
+ *      - TRAP_UNDEF_GARP_2B,
+ *      - TRAP_UNDEF_GARP_2C,
+ *      - TRAP_UNDEF_GARP_2D,
+ *      - TRAP_UNDEF_GARP_2E,
+ *      - TRAP_UNDEF_GARP_2F,
+ *      - TRAP_CDP.
+ *      - TRAP_CSSTP.
+ *      - TRAP_LLDP.
+ */
+extern rtk_api_ret_t rtk_trap_rmaKeepFormat_set(rtk_trap_type_t type, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_trap_rmaKeepFormat_get
+ * Description:
+ *      Get Reserved multicast address action configuration.
+ * Input:
+ *      type - rma type.
+ * Output:
+ *      pEnable - keep format status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      There are 48 types of Reserved Multicast Address frame for application usage.
+ *      They are as following definition.
+ *      - TRAP_BRG_GROUP,
+ *      - TRAP_FD_PAUSE,
+ *      - TRAP_SP_MCAST,
+ *      - TRAP_1X_PAE,
+ *      - TRAP_UNDEF_BRG_04,
+ *      - TRAP_UNDEF_BRG_05,
+ *      - TRAP_UNDEF_BRG_06,
+ *      - TRAP_UNDEF_BRG_07,
+ *      - TRAP_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - TRAP_UNDEF_BRG_09,
+ *      - TRAP_UNDEF_BRG_0A,
+ *      - TRAP_UNDEF_BRG_0B,
+ *      - TRAP_UNDEF_BRG_0C,
+ *      - TRAP_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - TRAP_8021AB,
+ *      - TRAP_UNDEF_BRG_0F,
+ *      - TRAP_BRG_MNGEMENT,
+ *      - TRAP_UNDEFINED_11,
+ *      - TRAP_UNDEFINED_12,
+ *      - TRAP_UNDEFINED_13,
+ *      - TRAP_UNDEFINED_14,
+ *      - TRAP_UNDEFINED_15,
+ *      - TRAP_UNDEFINED_16,
+ *      - TRAP_UNDEFINED_17,
+ *      - TRAP_UNDEFINED_18,
+ *      - TRAP_UNDEFINED_19,
+ *      - TRAP_UNDEFINED_1A,
+ *      - TRAP_UNDEFINED_1B,
+ *      - TRAP_UNDEFINED_1C,
+ *      - TRAP_UNDEFINED_1D,
+ *      - TRAP_UNDEFINED_1E,
+ *      - TRAP_UNDEFINED_1F,
+ *      - TRAP_GMRP,
+ *      - TRAP_GVRP,
+ *      - TRAP_UNDEF_GARP_22,
+ *      - TRAP_UNDEF_GARP_23,
+ *      - TRAP_UNDEF_GARP_24,
+ *      - TRAP_UNDEF_GARP_25,
+ *      - TRAP_UNDEF_GARP_26,
+ *      - TRAP_UNDEF_GARP_27,
+ *      - TRAP_UNDEF_GARP_28,
+ *      - TRAP_UNDEF_GARP_29,
+ *      - TRAP_UNDEF_GARP_2A,
+ *      - TRAP_UNDEF_GARP_2B,
+ *      - TRAP_UNDEF_GARP_2C,
+ *      - TRAP_UNDEF_GARP_2D,
+ *      - TRAP_UNDEF_GARP_2E,
+ *      - TRAP_UNDEF_GARP_2F,
+ *      - TRAP_CDP.
+ *      - TRAP_CSSTP.
+ *      - TRAP_LLDP.
+ */
+extern rtk_api_ret_t rtk_trap_rmaKeepFormat_get(rtk_trap_type_t type, rtk_enable_t *pEnable);
+
+
+#endif /* __RTK_API_TRAP_H__ */
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/include/trunk.h b/drivers/net/phy/rtk/rtl8367c/include/trunk.h
new file mode 100644
index 0000000000000..c51e11979a580
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/trunk.h
@@ -0,0 +1,328 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes Trunk module high-layer TRUNK defination
+ *
+ */
+
+#ifndef __RTK_API_TRUNK_H__
+#define __RTK_API_TRUNK_H__
+
+/*
+ * Data Type Declaration
+ */
+#define    RTK_TRUNK_DPORT_HASH_MASK     0x40
+#define    RTK_TRUNK_SPORT_HASH_MASK     0x20
+#define    RTK_TRUNK_DIP_HASH_MASK       0x10
+#define    RTK_TRUNK_SIP_HASH_MASK       0x8
+#define    RTK_TRUNK_DMAC_HASH_MASK      0x4
+#define    RTK_TRUNK_SMAC_HASH_MASK      0x2
+#define    RTK_TRUNK_SPA_HASH_MASK       0x1
+
+
+#define RTK_MAX_NUM_OF_TRUNK_HASH_VAL               16
+
+typedef struct  rtk_trunk_hashVal2Port_s
+{
+    rtk_uint8 value[RTK_MAX_NUM_OF_TRUNK_HASH_VAL];
+} rtk_trunk_hashVal2Port_t;
+
+typedef enum rtk_trunk_group_e
+{
+    TRUNK_GROUP0 = 0,
+    TRUNK_GROUP1,
+    TRUNK_GROUP2,
+    TRUNK_GROUP3,
+    TRUNK_GROUP_END
+} rtk_trunk_group_t;
+
+typedef enum rtk_trunk_separateType_e
+{
+    SEPARATE_NONE = 0,
+    SEPARATE_FLOOD,
+    SEPARATE_END
+
+} rtk_trunk_separateType_t;
+
+typedef enum rtk_trunk_mode_e
+{
+    TRUNK_MODE_NORMAL = 0,
+    TRUNK_MODE_DUMB,
+    TRUNK_MODE_END
+} rtk_trunk_mode_t;
+
+/* Function Name:
+ *      rtk_trunk_port_set
+ * Description:
+ *      Set trunking group available port mask
+ * Input:
+ *      trk_gid                 - trunk group id
+ *      pTrunk_member_portmask  - Logic trunking member port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_LA_TRUNK_ID  - Invalid trunking group
+ *      RT_ERR_PORT_MASK    - Invalid portmask.
+ * Note:
+ *      The API can set port trunking group port mask. Each port trunking group has max 4 ports.
+ *      If enabled port mask has less than 2 ports available setting, then this trunking group function is disabled.
+ */
+extern rtk_api_ret_t rtk_trunk_port_set(rtk_trunk_group_t trk_gid, rtk_portmask_t *pTrunk_member_portmask);
+
+/* Function Name:
+ *      rtk_trunk_port_get
+ * Description:
+ *      Get trunking group available port mask
+ * Input:
+ *      trk_gid - trunk group id
+ * Output:
+ *      pTrunk_member_portmask - Logic trunking member port mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_LA_TRUNK_ID  - Invalid trunking group
+ * Note:
+ *      The API can get 2 port trunking group.
+ */
+extern rtk_api_ret_t rtk_trunk_port_get(rtk_trunk_group_t trk_gid, rtk_portmask_t *pTrunk_member_portmask);
+
+/* Function Name:
+ *      rtk_trunk_distributionAlgorithm_set
+ * Description:
+ *      Set port trunking hash select sources
+ * Input:
+ *      trk_gid         - trunk group id
+ *      algo_bitmask    - Bitmask of the distribution algorithm
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_LA_TRUNK_ID  - Invalid trunking group
+ *      RT_ERR_LA_HASHMASK  - Hash algorithm selection error.
+ *      RT_ERR_PORT_MASK    - Invalid portmask.
+ * Note:
+ *      The API can set port trunking hash algorithm sources.
+ *      7 bits mask for link aggregation group0 hash parameter selection {DIP, SIP, DMAC, SMAC, SPA}
+ *      - 0b0000001: SPA
+ *      - 0b0000010: SMAC
+ *      - 0b0000100: DMAC
+ *      - 0b0001000: SIP
+ *      - 0b0010000: DIP
+ *      - 0b0100000: TCP/UDP Source Port
+ *      - 0b1000000: TCP/UDP Destination Port
+ *      Example:
+ *      - 0b0000011: SMAC & SPA
+ *      - Note that it could be an arbitrary combination or independent set
+ */
+extern rtk_api_ret_t rtk_trunk_distributionAlgorithm_set(rtk_trunk_group_t trk_gid, rtk_uint32 algo_bitmask);
+
+/* Function Name:
+ *      rtk_trunk_distributionAlgorithm_get
+ * Description:
+ *      Get port trunking hash select sources
+ * Input:
+ *      trk_gid - trunk group id
+ * Output:
+ *      pAlgo_bitmask -  Bitmask of the distribution algorithm
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_LA_TRUNK_ID  - Invalid trunking group
+ * Note:
+ *      The API can get port trunking hash algorithm sources.
+ */
+extern rtk_api_ret_t rtk_trunk_distributionAlgorithm_get(rtk_trunk_group_t trk_gid, rtk_uint32 *pAlgo_bitmask);
+
+/* Function Name:
+ *      rtk_trunk_trafficSeparate_set
+ * Description:
+ *      Set the traffic separation setting of a trunk group from the specified device.
+ * Input:
+ *      trk_gid      - trunk group id
+ *      separateType     - traffic separation setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID     - invalid unit id
+ *      RT_ERR_LA_TRUNK_ID - invalid trunk ID
+ *      RT_ERR_LA_HASHMASK - invalid hash mask
+ * Note:
+ *      SEPARATE_NONE: disable traffic separation
+ *      SEPARATE_FLOOD: trunk MSB link up port is dedicated to TX flooding (L2 lookup miss) traffic
+ */
+extern rtk_api_ret_t rtk_trunk_trafficSeparate_set(rtk_trunk_group_t trk_gid, rtk_trunk_separateType_t separateType);
+
+/* Function Name:
+ *      rtk_trunk_trafficSeparate_get
+ * Description:
+ *      Get the traffic separation setting of a trunk group from the specified device.
+ * Input:
+ *      trk_gid        - trunk group id
+ * Output:
+ *      pSeparateType   - pointer separated traffic type
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID      - invalid unit id
+ *      RT_ERR_LA_TRUNK_ID  - invalid trunk ID
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      SEPARATE_NONE: disable traffic separation
+ *      SEPARATE_FLOOD: trunk MSB link up port is dedicated to TX flooding (L2 lookup miss) traffic
+ */
+extern rtk_api_ret_t rtk_trunk_trafficSeparate_get(rtk_trunk_group_t trk_gid, rtk_trunk_separateType_t *pSeparateType);
+
+
+/* Function Name:
+ *      rtk_trunk_mode_set
+ * Description:
+ *      Set the trunk mode to the specified device.
+ * Input:
+ *      mode - trunk mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT   - invalid input parameter
+ * Note:
+ *      The enum of the trunk mode as following
+ *      - TRUNK_MODE_NORMAL
+ *      - TRUNK_MODE_DUMB
+ */
+extern rtk_api_ret_t rtk_trunk_mode_set(rtk_trunk_mode_t mode);
+
+/* Function Name:
+ *      rtk_trunk_mode_get
+ * Description:
+ *      Get the trunk mode from the specified device.
+ * Input:
+ *      None
+ * Output:
+ *      pMode - pointer buffer of trunk mode
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      The enum of the trunk mode as following
+ *      - TRUNK_MODE_NORMAL
+ *      - TRUNK_MODE_DUMB
+ */
+extern rtk_api_ret_t rtk_trunk_mode_get(rtk_trunk_mode_t *pMode);
+
+/* Function Name:
+ *      rtk_trunk_trafficPause_set
+ * Description:
+ *      Set the traffic pause setting of a trunk group.
+ * Input:
+ *      trk_gid      - trunk group id
+ *      enable       - traffic pause state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_LA_TRUNK_ID - invalid trunk ID
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_trunk_trafficPause_set(rtk_trunk_group_t trk_gid, rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_trunk_trafficPause_get
+ * Description:
+ *      Get the traffic pause setting of a trunk group.
+ * Input:
+ *      trk_gid        - trunk group id
+ * Output:
+ *      pEnable        - pointer of traffic pause state.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_LA_TRUNK_ID  - invalid trunk ID
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_trunk_trafficPause_get(rtk_trunk_group_t trk_gid, rtk_enable_t *pEnable);
+
+/* Function Name:
+ *      rtk_trunk_hashMappingTable_set
+ * Description:
+ *      Set hash value to port array in the trunk group id from the specified device.
+ * Input:
+ *      trk_gid          - trunk group id
+ *      pHash2Port_array - ports associate with the hash value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID            - invalid unit id
+ *      RT_ERR_LA_TRUNK_ID        - invalid trunk ID
+ *      RT_ERR_NULL_POINTER       - input parameter may be null pointer
+ *      RT_ERR_LA_TRUNK_NOT_EXIST - the trunk doesn't exist
+ *      RT_ERR_LA_NOT_MEMBER_PORT - the port is not a member port of the trunk
+ *      RT_ERR_LA_CPUPORT         - CPU port can not be aggregated port
+ * Note:
+ *      Trunk group 0 & 1 shares the same hash mapping table.
+ *      Trunk group 2 uses a independent table.
+ */
+extern rtk_api_ret_t rtk_trunk_hashMappingTable_set(rtk_trunk_group_t trk_gid, rtk_trunk_hashVal2Port_t *pHash2Port_array);
+
+/* Function Name:
+ *      rtk_trunk_hashMappingTable_get
+ * Description:
+ *      Get hash value to port array in the trunk group id from the specified device.
+ * Input:
+ *      trk_gid          - trunk group id
+ * Output:
+ *      pHash2Port_array - pointer buffer of ports associate with the hash value
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID      - invalid unit id
+ *      RT_ERR_LA_TRUNK_ID  - invalid trunk ID
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      Trunk group 0 & 1 shares the same hash mapping table.
+ *      Trunk group 2 uses a independent table.
+ */
+extern rtk_api_ret_t rtk_trunk_hashMappingTable_get(rtk_trunk_group_t trk_gid, rtk_trunk_hashVal2Port_t *pHash2Port_array);
+
+/* Function Name:
+ *      rtk_trunk_portQueueEmpty_get
+ * Description:
+ *      Get the port mask which all queues are empty.
+ * Input:
+ *      None.
+ * Output:
+ *      pEmpty_portmask   - pointer empty port mask
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_trunk_portQueueEmpty_get(rtk_portmask_t *pEmpty_portmask);
+
+#endif /* __RTK_API_TRUNK_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/include/vlan.h b/drivers/net/phy/rtk/rtl8367c/include/vlan.h
new file mode 100644
index 0000000000000..ddbcd7cafe7f9
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/include/vlan.h
@@ -0,0 +1,892 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367/RTL8367C switch high-level API
+ *
+ * Feature : The file includes Trap module high-layer VLAN defination
+ *
+ */
+
+#ifndef __RTK_API_VLAN_H__
+#define __RTK_API_VLAN_H__
+
+
+/*
+ * Data Type Declaration
+ */
+#define RTK_MAX_NUM_OF_PROTO_TYPE                   0xFFFF
+#define RTK_MAX_NUM_OF_MSTI                         0xF
+#define RTK_FID_MAX                                 0xF
+
+typedef struct  rtk_vlan_cfg_s
+{
+    rtk_portmask_t  mbr;
+    rtk_portmask_t  untag;
+    rtk_uint16      ivl_en;
+    rtk_uint16      fid_msti;
+    rtk_uint16      envlanpol;
+    rtk_uint16      meteridx;
+    rtk_uint16      vbpen;
+    rtk_uint16      vbpri;
+}rtk_vlan_cfg_t;
+
+typedef struct  rtk_vlan_mbrcfg_s
+{
+    rtk_uint16      evid;
+    rtk_portmask_t  mbr;
+    rtk_uint16      fid_msti;
+    rtk_uint16      envlanpol;
+    rtk_uint16      meteridx;
+    rtk_uint16      vbpen;
+    rtk_uint16      vbpri;
+}rtk_vlan_mbrcfg_t;
+
+typedef rtk_uint32  rtk_stp_msti_id_t;     /* MSTI ID  */
+
+typedef enum rtk_stp_state_e
+{
+    STP_STATE_DISABLED = 0,
+    STP_STATE_BLOCKING,
+    STP_STATE_LEARNING,
+    STP_STATE_FORWARDING,
+    STP_STATE_END
+} rtk_stp_state_t;
+
+typedef rtk_uint32  rtk_vlan_proto_type_t;     /* protocol and port based VLAN protocol type  */
+
+
+typedef enum rtk_vlan_acceptFrameType_e
+{
+    ACCEPT_FRAME_TYPE_ALL = 0,             /* untagged, priority-tagged and tagged */
+    ACCEPT_FRAME_TYPE_TAG_ONLY,         /* tagged */
+    ACCEPT_FRAME_TYPE_UNTAG_ONLY,     /* untagged and priority-tagged */
+    ACCEPT_FRAME_TYPE_END
+} rtk_vlan_acceptFrameType_t;
+
+
+/* frame type of protocol vlan - reference 802.1v standard */
+typedef enum rtk_vlan_protoVlan_frameType_e
+{
+    FRAME_TYPE_ETHERNET = 0,
+    FRAME_TYPE_LLCOTHER,
+    FRAME_TYPE_RFC1042,
+    FRAME_TYPE_END
+} rtk_vlan_protoVlan_frameType_t;
+
+/* Protocol-and-port-based Vlan structure */
+typedef struct rtk_vlan_protoAndPortInfo_s
+{
+    rtk_uint32                         proto_type;
+    rtk_vlan_protoVlan_frameType_t frame_type;
+    rtk_vlan_t                     cvid;
+    rtk_pri_t                     cpri;
+}rtk_vlan_protoAndPortInfo_t;
+
+/* tagged mode of VLAN - reference realtek private specification */
+typedef enum rtk_vlan_tagMode_e
+{
+    VLAN_TAG_MODE_ORIGINAL = 0,
+    VLAN_TAG_MODE_KEEP_FORMAT,
+    VLAN_TAG_MODE_PRI,
+    VLAN_TAG_MODE_REAL_KEEP_FORMAT,
+    VLAN_TAG_MODE_END
+} rtk_vlan_tagMode_t;
+
+typedef enum rtk_vlan_resVidAction_e
+{
+    RESVID_ACTION_UNTAG = 0,
+    RESVID_ACTION_TAG,
+    RESVID_ACTION_END
+}
+rtk_vlan_resVidAction_t;
+
+/* Function Name:
+ *      rtk_vlan_init
+ * Description:
+ *      Initialize VLAN.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      VLAN is disabled by default. User has to call this API to enable VLAN before
+ *      using it. And It will set a default VLAN(vid 1) including all ports and set
+ *      all ports PVID to the default VLAN.
+ */
+extern rtk_api_ret_t rtk_vlan_init(void);
+
+/* Function Name:
+ *      rtk_vlan_set
+ * Description:
+ *      Set a VLAN entry.
+ * Input:
+ *      vid - VLAN ID to configure.
+ *      pVlanCfg - VLAN Configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ *      RT_ERR_L2_FID               - Invalid FID.
+ *      RT_ERR_VLAN_PORT_MBR_EXIST  - Invalid member port mask.
+ *      RT_ERR_VLAN_VID             - Invalid VID parameter.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_vlan_set(rtk_vlan_t vid, rtk_vlan_cfg_t *pVlanCfg);
+
+/* Function Name:
+ *      rtk_vlan_get
+ * Description:
+ *      Get a VLAN entry.
+ * Input:
+ *      vid - VLAN ID to configure.
+ * Output:
+ *      pVlanCfg - VLAN Configuration
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_vlan_get(rtk_vlan_t vid, rtk_vlan_cfg_t *pVlanCfg);
+
+/* Function Name:
+ *      rtk_vlan_egrFilterEnable_set
+ * Description:
+ *      Set VLAN egress filter.
+ * Input:
+ *      egrFilter - Egress filtering
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid input parameters.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_vlan_egrFilterEnable_set(rtk_enable_t egrFilter);
+
+/* Function Name:
+ *      rtk_vlan_egrFilterEnable_get
+ * Description:
+ *      Get VLAN egress filter.
+ * Input:
+ *      pEgrFilter - Egress filtering
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - NULL Pointer.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_vlan_egrFilterEnable_get(rtk_enable_t *pEgrFilter);
+
+/* Function Name:
+ *      rtk_vlan_mbrCfg_set
+ * Description:
+ *      Set a VLAN Member Configuration entry by index.
+ * Input:
+ *      idx     - Index of VLAN Member Configuration.
+ *      pMbrcfg - VLAN member Configuration.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ * Note:
+ *     Set a VLAN Member Configuration entry by index.
+ */
+extern rtk_api_ret_t rtk_vlan_mbrCfg_set(rtk_uint32 idx, rtk_vlan_mbrcfg_t *pMbrcfg);
+
+/* Function Name:
+ *      rtk_vlan_mbrCfg_get
+ * Description:
+ *      Get a VLAN Member Configuration entry by index.
+ * Input:
+ *      idx - Index of VLAN Member Configuration.
+ * Output:
+ *      pMbrcfg - VLAN member Configuration.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ * Note:
+ *     Get a VLAN Member Configuration entry by index.
+ */
+extern rtk_api_ret_t rtk_vlan_mbrCfg_get(rtk_uint32 idx, rtk_vlan_mbrcfg_t *pMbrcfg);
+
+/* Function Name:
+ *     rtk_vlan_portPvid_set
+ * Description:
+ *      Set port to specified VLAN ID(PVID).
+ * Input:
+ *      port - Port id.
+ *      pvid - Specified VLAN ID.
+ *      priority - 802.1p priority for the PVID.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_VLAN_PRIORITY        - Invalid priority.
+ *      RT_ERR_VLAN_ENTRY_NOT_FOUND - VLAN entry not found.
+ *      RT_ERR_VLAN_VID             - Invalid VID parameter.
+ * Note:
+ *       The API is used for Port-based VLAN. The untagged frame received from the
+ *       port will be classified to the specified VLAN and assigned to the specified priority.
+ */
+extern rtk_api_ret_t rtk_vlan_portPvid_set(rtk_port_t port, rtk_vlan_t pvid, rtk_pri_t priority);
+
+/* Function Name:
+ *      rtk_vlan_portPvid_get
+ * Description:
+ *      Get VLAN ID(PVID) on specified port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPvid - Specified VLAN ID.
+ *      pPriority - 802.1p priority for the PVID.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *     The API can get the PVID and 802.1p priority for the PVID of Port-based VLAN.
+ */
+extern rtk_api_ret_t rtk_vlan_portPvid_get(rtk_port_t port, rtk_vlan_t *pPvid, rtk_pri_t *pPriority);
+
+/* Function Name:
+ *      rtk_vlan_portIgrFilterEnable_set
+ * Description:
+ *      Set VLAN ingress for each port.
+ * Input:
+ *      port - Port id.
+ *      igr_filter - VLAN ingress function enable status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      The status of vlan ingress filter is as following:
+ *      - DISABLED
+ *      - ENABLED
+ *      While VLAN function is enabled, ASIC will decide VLAN ID for each received frame and get belonged member
+ *      ports from VLAN table. If received port is not belonged to VLAN member ports, ASIC will drop received frame if VLAN ingress function is enabled.
+ */
+extern rtk_api_ret_t rtk_vlan_portIgrFilterEnable_set(rtk_port_t port, rtk_enable_t igr_filter);
+
+/* Function Name:
+ *      rtk_vlan_portIgrFilterEnable_get
+ * Description:
+ *      Get VLAN Ingress Filter
+ * Input:
+ *      port        - Port id.
+ * Output:
+ *      pIgr_filter - VLAN ingress function enable status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *     The API can Get the VLAN ingress filter status.
+ *     The status of vlan ingress filter is as following:
+ *     - DISABLED
+ *     - ENABLED
+ */
+extern rtk_api_ret_t rtk_vlan_portIgrFilterEnable_get(rtk_port_t port, rtk_enable_t *pIgr_filter);
+
+/* Function Name:
+ *      rtk_vlan_portAcceptFrameType_set
+ * Description:
+ *      Set VLAN accept_frame_type
+ * Input:
+ *      port                - Port id.
+ *      accept_frame_type   - accept frame type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_PORT_ID                  - Invalid port number.
+ *      RT_ERR_VLAN_ACCEPT_FRAME_TYPE   - Invalid frame type.
+ * Note:
+ *      The API is used for checking 802.1Q tagged frames.
+ *      The accept frame type as following:
+ *      - ACCEPT_FRAME_TYPE_ALL
+ *      - ACCEPT_FRAME_TYPE_TAG_ONLY
+ *      - ACCEPT_FRAME_TYPE_UNTAG_ONLY
+ */
+extern rtk_api_ret_t rtk_vlan_portAcceptFrameType_set(rtk_port_t port, rtk_vlan_acceptFrameType_t accept_frame_type);
+
+/* Function Name:
+ *      rtk_vlan_portAcceptFrameType_get
+ * Description:
+ *      Get VLAN accept_frame_type
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pAccept_frame_type - accept frame type
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *     The API can Get the VLAN ingress filter.
+ *     The accept frame type as following:
+ *     - ACCEPT_FRAME_TYPE_ALL
+ *     - ACCEPT_FRAME_TYPE_TAG_ONLY
+ *     - ACCEPT_FRAME_TYPE_UNTAG_ONLY
+ */
+extern rtk_api_ret_t rtk_vlan_portAcceptFrameType_get(rtk_port_t port, rtk_vlan_acceptFrameType_t *pAccept_frame_type);
+
+/* Function Name:
+ *      rtk_vlan_tagMode_set
+ * Description:
+ *      Set CVLAN egress tag mode
+ * Input:
+ *      port        - Port id.
+ *      tag_mode    - The egress tag mode.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      The API can set Egress tag mode. There are 4 mode for egress tag:
+ *      - VLAN_TAG_MODE_ORIGINAL,
+ *      - VLAN_TAG_MODE_KEEP_FORMAT,
+ *      - VLAN_TAG_MODE_PRI.
+ *      - VLAN_TAG_MODE_REAL_KEEP_FORMAT,
+ */
+extern rtk_api_ret_t rtk_vlan_tagMode_set(rtk_port_t port, rtk_vlan_tagMode_t tag_mode);
+
+/* Function Name:
+ *      rtk_vlan_tagMode_get
+ * Description:
+ *      Get CVLAN egress tag mode
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pTag_mode - The egress tag mode.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get Egress tag mode. There are 4 mode for egress tag:
+ *      - VLAN_TAG_MODE_ORIGINAL,
+ *      - VLAN_TAG_MODE_KEEP_FORMAT,
+ *      - VLAN_TAG_MODE_PRI.
+ *      - VLAN_TAG_MODE_REAL_KEEP_FORMAT,
+ */
+extern rtk_api_ret_t rtk_vlan_tagMode_get(rtk_port_t port, rtk_vlan_tagMode_t *pTag_mode);
+
+/* Function Name:
+ *      rtk_vlan_transparent_set
+ * Description:
+ *      Set VLAN transparent mode
+ * Input:
+ *      egr_port        - Egress Port id.
+ *      pIgr_pmask      - Ingress Port Mask.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_vlan_transparent_set(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask);
+
+/* Function Name:
+ *      rtk_vlan_transparent_get
+ * Description:
+ *      Get VLAN transparent mode
+ * Input:
+ *      egr_port        - Egress Port id.
+ * Output:
+ *      pIgr_pmask      - Ingress Port Mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_vlan_transparent_get(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask);
+
+/* Function Name:
+ *      rtk_vlan_keep_set
+ * Description:
+ *      Set VLAN egress keep mode
+ * Input:
+ *      egr_port        - Egress Port id.
+ *      pIgr_pmask      - Ingress Port Mask.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_vlan_keep_set(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask);
+
+/* Function Name:
+ *      rtk_vlan_keep_get
+ * Description:
+ *      Get VLAN egress keep mode
+ * Input:
+ *      egr_port        - Egress Port id.
+ * Output:
+ *      pIgr_pmask      - Ingress Port Mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      None.
+ */
+extern rtk_api_ret_t rtk_vlan_keep_get(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask);
+
+/* Function Name:
+ *      rtk_vlan_stg_set
+ * Description:
+ *      Set spanning tree group instance of the vlan to the specified device
+ * Input:
+ *      vid - Specified VLAN ID.
+ *      stg - spanning tree group instance.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_MSTI         - Invalid msti parameter
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ * Note:
+ *      The API can set spanning tree group instance of the vlan to the specified device.
+ */
+extern rtk_api_ret_t rtk_vlan_stg_set(rtk_vlan_t vid, rtk_stp_msti_id_t stg);
+
+/* Function Name:
+ *      rtk_vlan_stg_get
+ * Description:
+ *      Get spanning tree group instance of the vlan to the specified device
+ * Input:
+ *      vid - Specified VLAN ID.
+ * Output:
+ *      pStg - spanning tree group instance.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ * Note:
+ *      The API can get spanning tree group instance of the vlan to the specified device.
+ */
+extern rtk_api_ret_t rtk_vlan_stg_get(rtk_vlan_t vid, rtk_stp_msti_id_t *pStg);
+
+/* Function Name:
+ *      rtk_vlan_protoAndPortBasedVlan_add
+ * Description:
+ *      Add the protocol-and-port-based vlan to the specified port of device.
+ * Input:
+ *      port  - Port id.
+ *      pInfo - Protocol and port based VLAN configuration information.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_VLAN_VID         - Invalid VID parameter.
+ *      RT_ERR_VLAN_PRIORITY    - Invalid priority.
+ *      RT_ERR_TBL_FULL         - Table is full.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The incoming packet which match the protocol-and-port-based vlan will use the configure vid for ingress pipeline
+ *      The frame type is shown in the following:
+ *      - FRAME_TYPE_ETHERNET
+ *      - FRAME_TYPE_RFC1042
+ *      - FRAME_TYPE_LLCOTHER
+ */
+extern rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_add(rtk_port_t port, rtk_vlan_protoAndPortInfo_t *pInfo);
+
+/* Function Name:
+ *      rtk_vlan_protoAndPortBasedVlan_get
+ * Description:
+ *      Get the protocol-and-port-based vlan to the specified port of device.
+ * Input:
+ *      port - Port id.
+ *      proto_type - protocol-and-port-based vlan protocol type.
+ *      frame_type - protocol-and-port-based vlan frame type.
+ * Output:
+ *      pInfo - Protocol and port based VLAN configuration information.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ *      RT_ERR_TBL_FULL         - Table is full.
+ * Note:
+ *     The incoming packet which match the protocol-and-port-based vlan will use the configure vid for ingress pipeline
+ *     The frame type is shown in the following:
+ *      - FRAME_TYPE_ETHERNET
+ *      - FRAME_TYPE_RFC1042
+ *      - FRAME_TYPE_LLCOTHER
+ */
+extern rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_get(rtk_port_t port, rtk_vlan_proto_type_t proto_type, rtk_vlan_protoVlan_frameType_t frame_type, rtk_vlan_protoAndPortInfo_t *pInfo);
+
+/* Function Name:
+ *      rtk_vlan_protoAndPortBasedVlan_del
+ * Description:
+ *      Delete the protocol-and-port-based vlan from the specified port of device.
+ * Input:
+ *      port        - Port id.
+ *      proto_type  - protocol-and-port-based vlan protocol type.
+ *      frame_type  - protocol-and-port-based vlan frame type.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ *      RT_ERR_TBL_FULL         - Table is full.
+ * Note:
+ *     The incoming packet which match the protocol-and-port-based vlan will use the configure vid for ingress pipeline
+ *     The frame type is shown in the following:
+ *      - FRAME_TYPE_ETHERNET
+ *      - FRAME_TYPE_RFC1042
+ *      - FRAME_TYPE_LLCOTHER
+ */
+extern rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_del(rtk_port_t port, rtk_vlan_proto_type_t proto_type, rtk_vlan_protoVlan_frameType_t frame_type);
+
+/* Function Name:
+ *      rtk_vlan_protoAndPortBasedVlan_delAll
+ * Description:
+ *     Delete all protocol-and-port-based vlans from the specified port of device.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *     The incoming packet which match the protocol-and-port-based vlan will use the configure vid for ingress pipeline
+ *     Delete all flow table protocol-and-port-based vlan entries.
+ */
+extern rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_delAll(rtk_port_t port);
+
+/* Function Name:
+ *      rtk_vlan_portFid_set
+ * Description:
+ *      Set port-based filtering database
+ * Input:
+ *      port - Port id.
+ *      enable - ebable port-based FID
+ *      fid - Specified filtering database.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_L2_FID - Invalid fid.
+ *      RT_ERR_INPUT - Invalid input parameter.
+ *      RT_ERR_PORT_ID - Invalid port ID.
+ * Note:
+ *      The API can set port-based filtering database. If the function is enabled, all input
+ *      packets will be assigned to the port-based fid regardless vlan tag.
+ */
+extern rtk_api_ret_t rtk_vlan_portFid_set(rtk_port_t port, rtk_enable_t enable, rtk_fid_t fid);
+
+/* Function Name:
+ *      rtk_vlan_portFid_get
+ * Description:
+ *      Get port-based filtering database
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - ebable port-based FID
+ *      pFid - Specified filtering database.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT - Invalid input parameters.
+ *      RT_ERR_PORT_ID - Invalid port ID.
+ * Note:
+ *      The API can get port-based filtering database status. If the function is enabled, all input
+ *      packets will be assigned to the port-based fid regardless vlan tag.
+ */
+extern rtk_api_ret_t rtk_vlan_portFid_get(rtk_port_t port, rtk_enable_t *pEnable, rtk_fid_t *pFid);
+
+/* Function Name:
+ *      rtk_vlan_UntagDscpPriorityEnable_set
+ * Description:
+ *      Set Untag DSCP priority assign
+ * Input:
+ *      enable - state of Untag DSCP priority assign
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_ENABLE          - Invalid input parameters.
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_vlan_UntagDscpPriorityEnable_set(rtk_enable_t enable);
+
+/* Function Name:
+ *      rtk_vlan_UntagDscpPriorityEnable_get
+ * Description:
+ *      Get Untag DSCP priority assign
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - state of Untag DSCP priority assign
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_vlan_UntagDscpPriorityEnable_get(rtk_enable_t *pEnable);
+
+
+/*Spanning Tree*/
+/* Function Name:
+ *      rtk_stp_mstpState_set
+ * Description:
+ *      Configure spanning tree state per each port.
+ * Input:
+ *      port - Port id
+ *      msti - Multiple spanning tree instance.
+ *      stp_state - Spanning tree state for msti
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_MSTI         - Invalid msti parameter.
+ *      RT_ERR_MSTP_STATE   - Invalid STP state.
+ * Note:
+ *      System supports per-port multiple spanning tree state for each msti.
+ *      There are four states supported by ASIC.
+ *      - STP_STATE_DISABLED
+ *      - STP_STATE_BLOCKING
+ *      - STP_STATE_LEARNING
+ *      - STP_STATE_FORWARDING
+ */
+extern rtk_api_ret_t rtk_stp_mstpState_set(rtk_stp_msti_id_t msti, rtk_port_t port, rtk_stp_state_t stp_state);
+
+/* Function Name:
+ *      rtk_stp_mstpState_get
+ * Description:
+ *      Get spanning tree state per each port.
+ * Input:
+ *      port - Port id.
+ *      msti - Multiple spanning tree instance.
+ * Output:
+ *      pStp_state - Spanning tree state for msti
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_MSTI         - Invalid msti parameter.
+ * Note:
+ *      System supports per-port multiple spanning tree state for each msti.
+ *      There are four states supported by ASIC.
+ *      - STP_STATE_DISABLED
+ *      - STP_STATE_BLOCKING
+ *      - STP_STATE_LEARNING
+ *      - STP_STATE_FORWARDING
+ */
+extern rtk_api_ret_t rtk_stp_mstpState_get(rtk_stp_msti_id_t msti, rtk_port_t port, rtk_stp_state_t *pStp_state);
+
+/* Function Name:
+ *      rtk_vlan_checkAndCreateMbr
+ * Description:
+ *      Check and create Member configuration and return index
+ * Input:
+ *      vid  - VLAN id.
+ * Output:
+ *      pIndex  - Member configuration index
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_VLAN_VID     - Invalid VLAN ID.
+ *      RT_ERR_VLAN_ENTRY_NOT_FOUND - VLAN not found
+ *      RT_ERR_TBL_FULL     - Member Configuration table full
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_vlan_checkAndCreateMbr(rtk_vlan_t vid, rtk_uint32 *pIndex);
+
+/* Function Name:
+ *      rtk_vlan_reservedVidAction_set
+ * Description:
+ *      Set Action of VLAN ID = 0 & 4095 tagged packet
+ * Input:
+ *      action_vid0     - Action for VID 0.
+ *      action_vid4095  - Action for VID 4095.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_vlan_reservedVidAction_set(rtk_vlan_resVidAction_t action_vid0, rtk_vlan_resVidAction_t action_vid4095);
+
+/* Function Name:
+ *      rtk_vlan_reservedVidAction_get
+ * Description:
+ *      Get Action of VLAN ID = 0 & 4095 tagged packet
+ * Input:
+ *      pAction_vid0     - Action for VID 0.
+ *      pAction_vid4095  - Action for VID 4095.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - NULL Pointer
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_vlan_reservedVidAction_get(rtk_vlan_resVidAction_t *pAction_vid0, rtk_vlan_resVidAction_t *pAction_vid4095);
+
+/* Function Name:
+ *      rtk_vlan_realKeepRemarkEnable_set
+ * Description:
+ *      Set Real keep 1p remarking feature
+ * Input:
+ *      enabled     - State of 1p remarking at real keep packet
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_vlan_realKeepRemarkEnable_set(rtk_enable_t enabled);
+
+/* Function Name:
+ *      rtk_vlan_realKeepRemarkEnable_get
+ * Description:
+ *      Get Real keep 1p remarking feature
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled     - State of 1p remarking at real keep packet
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ *
+ */
+extern rtk_api_ret_t rtk_vlan_realKeepRemarkEnable_get(rtk_enable_t *pEnabled);
+
+/* Function Name:
+ *      rtk_vlan_reset
+ * Description:
+ *      Reset VLAN
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled     - State of 1p remarking at real keep packet
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_reset(void);
+
+#endif /* __RTK_API_VLAN_H__ */
diff --git a/drivers/net/phy/rtk/rtl8367c/interrupt.c b/drivers/net/phy/rtk/rtl8367c/interrupt.c
new file mode 100644
index 0000000000000..ca0f7d08f941c
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/interrupt.c
@@ -0,0 +1,434 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in Interrupt module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <interrupt.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_interrupt.h>
+
+/* Function Name:
+ *      rtk_int_polarity_set
+ * Description:
+ *      Set interrupt polarity configuration.
+ * Input:
+ *      type - Interruptpolarity type.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can set interrupt polarity configuration.
+ */
+rtk_api_ret_t rtk_int_polarity_set(rtk_int_polarity_t type)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(type >= INT_POLAR_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicInterruptPolarity(type)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_int_polarity_get
+ * Description:
+ *      Get interrupt polarity configuration.
+ * Input:
+ *      None
+ * Output:
+ *      pType - Interruptpolarity type.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      The API can get interrupt polarity configuration.
+ */
+rtk_api_ret_t rtk_int_polarity_get(rtk_int_polarity_t *pType)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pType)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicInterruptPolarity(pType)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_int_control_set
+ * Description:
+ *      Set interrupt trigger status configuration.
+ * Input:
+ *      type - Interrupt type.
+ *      enable - Interrupt status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      The API can set interrupt status configuration.
+ *      The interrupt trigger status is shown in the following:
+ *      - INT_TYPE_LINK_STATUS
+ *      - INT_TYPE_METER_EXCEED
+ *      - INT_TYPE_LEARN_LIMIT
+ *      - INT_TYPE_LINK_SPEED
+ *      - INT_TYPE_CONGEST
+ *      - INT_TYPE_GREEN_FEATURE
+ *      - INT_TYPE_LOOP_DETECT
+ *      - INT_TYPE_8051,
+ *      - INT_TYPE_CABLE_DIAG,
+ *      - INT_TYPE_ACL,
+ *      - INT_TYPE_SLIENT
+ */
+rtk_api_ret_t rtk_int_control_set(rtk_int_type_t type, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 mask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= INT_TYPE_END)
+        return RT_ERR_INPUT;
+
+    if (type == INT_TYPE_RESERVED)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_getAsicInterruptMask(&mask)) != RT_ERR_OK)
+        return retVal;
+
+    if (ENABLED == enable)
+        mask = mask | (1<<type);
+    else if (DISABLED == enable)
+        mask = mask & ~(1<<type);
+    else
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicInterruptMask(mask)) != RT_ERR_OK)
+        return retVal;
+
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_int_control_get
+ * Description:
+ *      Get interrupt trigger status configuration.
+ * Input:
+ *      type - Interrupt type.
+ * Output:
+ *      pEnable - Interrupt status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get interrupt status configuration.
+ *      The interrupt trigger status is shown in the following:
+ *      - INT_TYPE_LINK_STATUS
+ *      - INT_TYPE_METER_EXCEED
+ *      - INT_TYPE_LEARN_LIMIT
+ *      - INT_TYPE_LINK_SPEED
+ *      - INT_TYPE_CONGEST
+ *      - INT_TYPE_GREEN_FEATURE
+ *      - INT_TYPE_LOOP_DETECT
+ *      - INT_TYPE_8051,
+ *      - INT_TYPE_CABLE_DIAG,
+ *      - INT_TYPE_ACL,
+ *      - INT_TYPE_UPS,
+ *      - INT_TYPE_SLIENT
+ */
+rtk_api_ret_t rtk_int_control_get(rtk_int_type_t type, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 mask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicInterruptMask(&mask)) != RT_ERR_OK)
+        return retVal;
+
+    if (0 == (mask&(1<<type)))
+        *pEnable=DISABLED;
+    else
+        *pEnable=ENABLED;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_int_status_set
+ * Description:
+ *      Set interrupt trigger status to clean.
+ * Input:
+ *      None
+ * Output:
+ *      pStatusMask - Interrupt status bit mask.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT - Invalid input parameters.
+ * Note:
+ *      The API can clean interrupt trigger status when interrupt happened.
+ *      The interrupt trigger status is shown in the following:
+ *      - INT_TYPE_LINK_STATUS    (value[0] (Bit0))
+ *      - INT_TYPE_METER_EXCEED   (value[0] (Bit1))
+ *      - INT_TYPE_LEARN_LIMIT    (value[0] (Bit2))
+ *      - INT_TYPE_LINK_SPEED     (value[0] (Bit3))
+ *      - INT_TYPE_CONGEST        (value[0] (Bit4))
+ *      - INT_TYPE_GREEN_FEATURE  (value[0] (Bit5))
+ *      - INT_TYPE_LOOP_DETECT    (value[0] (Bit6))
+ *      - INT_TYPE_8051           (value[0] (Bit7))
+ *      - INT_TYPE_CABLE_DIAG     (value[0] (Bit8))
+ *      - INT_TYPE_ACL            (value[0] (Bit9))
+ *      - INT_TYPE_SLIENT         (value[0] (Bit11))
+ *      The status will be cleared after execute this API.
+ */
+rtk_api_ret_t rtk_int_status_set(rtk_int_status_t *pStatusMask)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pStatusMask)
+        return RT_ERR_NULL_POINTER;
+
+    if(pStatusMask->value[0] & (0x0001 << INT_TYPE_RESERVED))
+        return RT_ERR_INPUT;
+
+    if(pStatusMask->value[0] >= (0x0001 << INT_TYPE_END))
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicInterruptStatus((rtk_uint32)pStatusMask->value[0]))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_int_status_get
+ * Description:
+ *      Get interrupt trigger status.
+ * Input:
+ *      None
+ * Output:
+ *      pStatusMask - Interrupt status bit mask.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get interrupt trigger status when interrupt happened.
+ *      The interrupt trigger status is shown in the following:
+ *      - INT_TYPE_LINK_STATUS    (value[0] (Bit0))
+ *      - INT_TYPE_METER_EXCEED   (value[0] (Bit1))
+ *      - INT_TYPE_LEARN_LIMIT    (value[0] (Bit2))
+ *      - INT_TYPE_LINK_SPEED     (value[0] (Bit3))
+ *      - INT_TYPE_CONGEST        (value[0] (Bit4))
+ *      - INT_TYPE_GREEN_FEATURE  (value[0] (Bit5))
+ *      - INT_TYPE_LOOP_DETECT    (value[0] (Bit6))
+ *      - INT_TYPE_8051           (value[0] (Bit7))
+ *      - INT_TYPE_CABLE_DIAG     (value[0] (Bit8))
+ *      - INT_TYPE_ACL            (value[0] (Bit9))
+ *      - INT_TYPE_SLIENT         (value[0] (Bit11))
+ *
+ */
+rtk_api_ret_t rtk_int_status_get(rtk_int_status_t* pStatusMask)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32          ims_mask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pStatusMask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicInterruptStatus(&ims_mask)) != RT_ERR_OK)
+        return retVal;
+
+    pStatusMask->value[0] = (ims_mask & 0x00000FFF);
+    return RT_ERR_OK;
+}
+
+#define ADV_NOT_SUPPORT (0xFFFF)
+static rtk_api_ret_t _rtk_int_Advidx_get(rtk_int_advType_t adv_type, rtk_uint32 *pAsic_idx)
+{
+    rtk_uint32 asic_idx[ADV_END] =
+    {
+        INTRST_L2_LEARN,
+        INTRST_SPEED_CHANGE,
+        INTRST_SPECIAL_CONGESTION,
+        INTRST_PORT_LINKDOWN,
+        INTRST_PORT_LINKUP,
+        ADV_NOT_SUPPORT,
+        INTRST_RLDP_LOOPED,
+        INTRST_RLDP_RELEASED,
+    };
+
+    if(adv_type >= ADV_END)
+        return RT_ERR_INPUT;
+
+    if(asic_idx[adv_type] == ADV_NOT_SUPPORT)
+        return RT_ERR_CHIP_NOT_SUPPORTED;
+
+    *pAsic_idx = asic_idx[adv_type];
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_int_advanceInfo_get
+ * Description:
+ *      Get interrupt advanced information.
+ * Input:
+ *      adv_type - Advanced interrupt type.
+ * Output:
+ *      info - Information per type.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get advanced information when interrupt happened.
+ *      The status will be cleared after execute this API.
+ */
+rtk_api_ret_t rtk_int_advanceInfo_get(rtk_int_advType_t adv_type, rtk_int_info_t *pInfo)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      data;
+    rtk_uint32      intAdvType;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(adv_type >= ADV_END)
+        return RT_ERR_INPUT;
+
+    if(NULL == pInfo)
+        return RT_ERR_NULL_POINTER;
+
+    if(adv_type != ADV_METER_EXCEED_MASK)
+    {
+        if((retVal = _rtk_int_Advidx_get(adv_type, &intAdvType)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    switch(adv_type)
+    {
+        case ADV_L2_LEARN_PORT_MASK:
+            /* Get physical portmask */
+            if((retVal = rtl8367c_getAsicInterruptRelatedStatus(intAdvType, &data)) != RT_ERR_OK)
+                return retVal;
+
+            /* Clear Advanced Info */
+            if((retVal = rtl8367c_setAsicInterruptRelatedStatus(intAdvType, 0xFFFF)) != RT_ERR_OK)
+                return retVal;
+
+            /* Translate to logical portmask */
+            if((retVal = rtk_switch_portmask_P2L_get(data, &(pInfo->portMask))) != RT_ERR_OK)
+                return retVal;
+
+            /* Get system learn */
+            if((retVal = rtl8367c_getAsicInterruptRelatedStatus(INTRST_SYS_LEARN, &data)) != RT_ERR_OK)
+                return retVal;
+
+            /* Clear system learn */
+            if((retVal = rtl8367c_setAsicInterruptRelatedStatus(INTRST_SYS_LEARN, 0x0001)) != RT_ERR_OK)
+                return retVal;
+
+            pInfo->systemLearnOver = data;
+            break;
+        case ADV_SPEED_CHANGE_PORT_MASK:
+        case ADV_SPECIAL_CONGESTION_PORT_MASK:
+        case ADV_PORT_LINKDOWN_PORT_MASK:
+        case ADV_PORT_LINKUP_PORT_MASK:
+        case ADV_RLDP_LOOPED:
+        case ADV_RLDP_RELEASED:
+            /* Get physical portmask */
+            if((retVal = rtl8367c_getAsicInterruptRelatedStatus(intAdvType, &data)) != RT_ERR_OK)
+                return retVal;
+
+            /* Clear Advanced Info */
+            if((retVal = rtl8367c_setAsicInterruptRelatedStatus(intAdvType, 0xFFFF)) != RT_ERR_OK)
+                return retVal;
+
+            /* Translate to logical portmask */
+            if((retVal = rtk_switch_portmask_P2L_get(data, &(pInfo->portMask))) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        case ADV_METER_EXCEED_MASK:
+            /* Get Meter Mask */
+            if((retVal = rtl8367c_getAsicInterruptRelatedStatus(INTRST_METER0_15, &data)) != RT_ERR_OK)
+                return retVal;
+
+            /* Clear Advanced Info */
+            if((retVal = rtl8367c_setAsicInterruptRelatedStatus(INTRST_METER0_15, 0xFFFF)) != RT_ERR_OK)
+                return retVal;
+
+            pInfo->meterMask = data & 0xFFFF;
+
+            /* Get Meter Mask */
+            if((retVal = rtl8367c_getAsicInterruptRelatedStatus(INTRST_METER16_31, &data)) != RT_ERR_OK)
+                return retVal;
+
+            /* Clear Advanced Info */
+            if((retVal = rtl8367c_setAsicInterruptRelatedStatus(INTRST_METER16_31, 0xFFFF)) != RT_ERR_OK)
+                return retVal;
+
+            pInfo->meterMask = pInfo->meterMask | ((data << 16) & 0xFFFF0000);
+
+            break;
+        default:
+            return RT_ERR_INPUT;
+    }
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/l2.c b/drivers/net/phy/rtk/rtl8367c/l2.c
new file mode 100644
index 0000000000000..eb35ccaefd002
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/l2.c
@@ -0,0 +1,2911 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in L2 module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <l2.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_lut.h>
+#include <rtl8367c_asicdrv_port.h>
+
+/* Function Name:
+ *      rtk_l2_init
+ * Description:
+ *      Initialize l2 module of the specified device.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ * Note:
+ *      Initialize l2 module before calling any l2 APIs.
+ */
+rtk_api_ret_t rtk_l2_init(void)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_setAsicLutIpMulticastLookup(DISABLED)) != RT_ERR_OK)
+        return retVal;
+
+    /*Enable CAM Usage*/
+    if ((retVal = rtl8367c_setAsicLutCamTbUsage(ENABLED)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicLutAgeTimerSpeed(6,2)) != RT_ERR_OK)
+        return retVal;
+
+    RTK_SCAN_ALL_LOG_PORT(port)
+    {
+        if ((retVal = rtl8367c_setAsicLutLearnLimitNo(rtk_switch_port_L2P_get(port), rtk_switch_maxLutAddrNumber_get())) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_l2_addr_add
+ * Description:
+ *      Add LUT unicast entry.
+ * Input:
+ *      pMac - 6 bytes unicast(I/G bit is 0) mac address to be written into LUT.
+ *      pL2_data - Unicast entry parameter
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_MAC              - Invalid MAC address.
+ *      RT_ERR_L2_FID           - Invalid FID .
+ *      RT_ERR_L2_INDEXTBL_FULL - hashed index is full of entries.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      If the unicast mac address already existed in LUT, it will udpate the status of the entry.
+ *      Otherwise, it will find an empty or asic auto learned entry to write. If all the entries
+ *      with the same hash value can't be replaced, ASIC will return a RT_ERR_L2_INDEXTBL_FULL error.
+ */
+rtk_api_ret_t rtk_l2_addr_add(rtk_mac_t *pMac, rtk_l2_ucastAddr_t *pL2_data)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* must be unicast address */
+    if ((pMac == NULL) || (pMac->octet[0] & 0x1))
+        return RT_ERR_MAC;
+
+    if(pL2_data == NULL)
+        return RT_ERR_MAC;
+
+    RTK_CHK_PORT_VALID(pL2_data->port);
+
+    if (pL2_data->ivl >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (pL2_data->cvid > RTL8367C_VIDMAX)
+        return RT_ERR_L2_VID;
+
+    if (pL2_data->fid > RTL8367C_FIDMAX)
+        return RT_ERR_L2_FID;
+
+    if (pL2_data->is_static>= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (pL2_data->sa_block>= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (pL2_data->da_block>= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (pL2_data->auth>= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (pL2_data->efid> RTL8367C_EFIDMAX)
+        return RT_ERR_INPUT;
+
+    if (pL2_data->priority > RTL8367C_PRIMAX)
+        return RT_ERR_INPUT;
+
+    if (pL2_data->sa_pri_en >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (pL2_data->fwd_pri_en >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+
+    /* fill key (MAC,FID) to get L2 entry */
+    memcpy(l2Table.mac.octet, pMac->octet, ETHER_ADDR_LEN);
+    l2Table.ivl_svl     = pL2_data->ivl;
+    l2Table.fid         = pL2_data->fid;
+    l2Table.cvid_fid    = pL2_data->cvid;
+    l2Table.efid        = pL2_data->efid;
+    method = LUTREADMETHOD_MAC;
+    retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+    if (RT_ERR_OK == retVal )
+    {
+        memcpy(l2Table.mac.octet, pMac->octet, ETHER_ADDR_LEN);
+        l2Table.ivl_svl     = pL2_data->ivl;
+        l2Table.cvid_fid    = pL2_data->cvid;
+        l2Table.fid         = pL2_data->fid;
+        l2Table.efid        = pL2_data->efid;
+        l2Table.spa         = rtk_switch_port_L2P_get(pL2_data->port);
+        l2Table.nosalearn   = pL2_data->is_static;
+        l2Table.sa_block    = pL2_data->sa_block;
+        l2Table.da_block    = pL2_data->da_block;
+        l2Table.l3lookup    = 0;
+        l2Table.auth        = pL2_data->auth;
+        l2Table.age         = 6;
+        l2Table.lut_pri     = pL2_data->priority;
+        l2Table.sa_en       = pL2_data->sa_pri_en;
+        l2Table.fwd_en      = pL2_data->fwd_pri_en;
+        if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pL2_data->address = l2Table.address;
+        return RT_ERR_OK;
+    }
+    else if (RT_ERR_L2_ENTRY_NOTFOUND == retVal )
+    {
+        memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+        memcpy(l2Table.mac.octet, pMac->octet, ETHER_ADDR_LEN);
+        l2Table.ivl_svl     = pL2_data->ivl;
+        l2Table.cvid_fid    = pL2_data->cvid;
+        l2Table.fid         = pL2_data->fid;
+        l2Table.efid        = pL2_data->efid;
+        l2Table.spa         = rtk_switch_port_L2P_get(pL2_data->port);
+        l2Table.nosalearn   = pL2_data->is_static;
+        l2Table.sa_block    = pL2_data->sa_block;
+        l2Table.da_block    = pL2_data->da_block;
+        l2Table.l3lookup    = 0;
+        l2Table.auth        = pL2_data->auth;
+        l2Table.age         = 6;
+        l2Table.lut_pri     = pL2_data->priority;
+        l2Table.sa_en       = pL2_data->sa_pri_en;
+        l2Table.fwd_en      = pL2_data->fwd_pri_en;
+
+        if ((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pL2_data->address = l2Table.address;
+
+        method = LUTREADMETHOD_MAC;
+        retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+        if (RT_ERR_L2_ENTRY_NOTFOUND == retVal )
+            return RT_ERR_L2_INDEXTBL_FULL;
+        else
+            return retVal;
+    }
+    else
+        return retVal;
+
+}
+
+/* Function Name:
+ *      rtk_l2_addr_get
+ * Description:
+ *      Get LUT unicast entry.
+ * Input:
+ *      pMac    - 6 bytes unicast(I/G bit is 0) mac address to be written into LUT.
+ * Output:
+ *      pL2_data - Unicast entry parameter
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_MAC                  - Invalid MAC address.
+ *      RT_ERR_L2_FID               - Invalid FID .
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      If the unicast mac address existed in LUT, it will return the port and fid where
+ *      the mac is learned. Otherwise, it will return a RT_ERR_L2_ENTRY_NOTFOUND error.
+ */
+rtk_api_ret_t rtk_l2_addr_get(rtk_mac_t *pMac, rtk_l2_ucastAddr_t *pL2_data)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* must be unicast address */
+    if ((pMac == NULL) || (pMac->octet[0] & 0x1))
+        return RT_ERR_MAC;
+
+    if (pL2_data->fid > RTL8367C_FIDMAX || pL2_data->efid > RTL8367C_EFIDMAX)
+        return RT_ERR_L2_FID;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+
+    memcpy(l2Table.mac.octet, pMac->octet, ETHER_ADDR_LEN);
+    l2Table.ivl_svl     = pL2_data->ivl;
+    l2Table.cvid_fid    = pL2_data->cvid;
+    l2Table.fid         = pL2_data->fid;
+    l2Table.efid        = pL2_data->efid;
+    method = LUTREADMETHOD_MAC;
+
+    if ((retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table)) != RT_ERR_OK)
+        return retVal;
+
+    memcpy(pL2_data->mac.octet, pMac->octet,ETHER_ADDR_LEN);
+    pL2_data->port      = rtk_switch_port_P2L_get(l2Table.spa);
+    pL2_data->fid       = l2Table.fid;
+    pL2_data->efid      = l2Table.efid;
+    pL2_data->ivl       = l2Table.ivl_svl;
+    pL2_data->cvid      = l2Table.cvid_fid;
+    pL2_data->is_static = l2Table.nosalearn;
+    pL2_data->auth      = l2Table.auth;
+    pL2_data->sa_block  = l2Table.sa_block;
+    pL2_data->da_block  = l2Table.da_block;
+    pL2_data->priority  = l2Table.lut_pri;
+    pL2_data->sa_pri_en = l2Table.sa_en;
+    pL2_data->fwd_pri_en= l2Table.fwd_en;
+    pL2_data->address   = l2Table.address;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_addr_next_get
+ * Description:
+ *      Get Next LUT unicast entry.
+ * Input:
+ *      read_method     - The reading method.
+ *      port            - The port number if the read_metohd is READMETHOD_NEXT_L2UCSPA
+ *      pAddress        - The Address ID
+ * Output:
+ *      pL2_data - Unicast entry parameter
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_MAC                  - Invalid MAC address.
+ *      RT_ERR_L2_FID               - Invalid FID .
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      Get the next unicast entry after the current entry pointed by pAddress.
+ *      The address of next entry is returned by pAddress. User can use (address + 1)
+ *      as pAddress to call this API again for dumping all entries is LUT.
+ */
+rtk_api_ret_t rtk_l2_addr_next_get(rtk_l2_read_method_t read_method, rtk_port_t port, rtk_uint32 *pAddress, rtk_l2_ucastAddr_t *pL2_data)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      method;
+    rtl8367c_luttb  l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Error Checking */
+    if ((pL2_data == NULL) || (pAddress == NULL))
+        return RT_ERR_MAC;
+
+    if(read_method == READMETHOD_NEXT_L2UC)
+        method = LUTREADMETHOD_NEXT_L2UC;
+    else if(read_method == READMETHOD_NEXT_L2UCSPA)
+        method = LUTREADMETHOD_NEXT_L2UCSPA;
+    else
+        return RT_ERR_INPUT;
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(*pAddress > RTK_MAX_LUT_ADDR_ID )
+        return RT_ERR_L2_L2UNI_PARAM;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+    l2Table.address = *pAddress;
+
+    if(read_method == READMETHOD_NEXT_L2UCSPA)
+        l2Table.spa = rtk_switch_port_L2P_get(port);
+
+    if ((retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table)) != RT_ERR_OK)
+        return retVal;
+
+    if(l2Table.address < *pAddress)
+        return RT_ERR_L2_ENTRY_NOTFOUND;
+
+    memcpy(pL2_data->mac.octet, l2Table.mac.octet, ETHER_ADDR_LEN);
+    pL2_data->port      = rtk_switch_port_P2L_get(l2Table.spa);
+    pL2_data->fid       = l2Table.fid;
+    pL2_data->efid      = l2Table.efid;
+    pL2_data->ivl       = l2Table.ivl_svl;
+    pL2_data->cvid      = l2Table.cvid_fid;
+    pL2_data->is_static = l2Table.nosalearn;
+    pL2_data->auth      = l2Table.auth;
+    pL2_data->sa_block  = l2Table.sa_block;
+    pL2_data->da_block  = l2Table.da_block;
+    pL2_data->priority  = l2Table.lut_pri;
+    pL2_data->sa_pri_en = l2Table.sa_en;
+    pL2_data->fwd_pri_en= l2Table.fwd_en;
+    pL2_data->address   = l2Table.address;
+
+    *pAddress = l2Table.address;
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtk_l2_addr_del
+ * Description:
+ *      Delete LUT unicast entry.
+ * Input:
+ *      pMac - 6 bytes unicast(I/G bit is 0) mac address to be written into LUT.
+ *      fid - Filtering database
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_MAC                  - Invalid MAC address.
+ *      RT_ERR_L2_FID               - Invalid FID .
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      If the mac has existed in the LUT, it will be deleted. Otherwise, it will return RT_ERR_L2_ENTRY_NOTFOUND.
+ */
+rtk_api_ret_t rtk_l2_addr_del(rtk_mac_t *pMac, rtk_l2_ucastAddr_t *pL2_data)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* must be unicast address */
+    if ((pMac == NULL) || (pMac->octet[0] & 0x1))
+        return RT_ERR_MAC;
+
+    if (pL2_data->fid > RTL8367C_FIDMAX || pL2_data->efid > RTL8367C_EFIDMAX)
+        return RT_ERR_L2_FID;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+
+    /* fill key (MAC,FID) to get L2 entry */
+    memcpy(l2Table.mac.octet, pMac->octet, ETHER_ADDR_LEN);
+    l2Table.ivl_svl     = pL2_data->ivl;
+    l2Table.cvid_fid    = pL2_data->cvid;
+    l2Table.fid         = pL2_data->fid;
+    l2Table.efid        = pL2_data->efid;
+    method = LUTREADMETHOD_MAC;
+    retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+    if (RT_ERR_OK ==  retVal)
+    {
+        memcpy(l2Table.mac.octet, pMac->octet, ETHER_ADDR_LEN);
+        l2Table.ivl_svl     = pL2_data->ivl;
+        l2Table.cvid_fid    = pL2_data->cvid;
+        l2Table.fid = pL2_data->fid;
+        l2Table.efid = pL2_data->efid;
+        l2Table.spa = 0;
+        l2Table.nosalearn = 0;
+        l2Table.sa_block = 0;
+        l2Table.da_block = 0;
+        l2Table.auth = 0;
+        l2Table.age = 0;
+        l2Table.lut_pri = 0;
+        l2Table.sa_en = 0;
+        l2Table.fwd_en = 0;
+        if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pL2_data->address = l2Table.address;
+        return RT_ERR_OK;
+    }
+    else
+        return retVal;
+}
+
+/* Function Name:
+ *      rtk_l2_mcastAddr_add
+ * Description:
+ *      Add LUT multicast entry.
+ * Input:
+ *      pMcastAddr  - L2 multicast entry structure
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_MAC              - Invalid MAC address.
+ *      RT_ERR_L2_FID           - Invalid FID .
+ *      RT_ERR_L2_VID           - Invalid VID .
+ *      RT_ERR_L2_INDEXTBL_FULL - hashed index is full of entries.
+ *      RT_ERR_PORT_MASK        - Invalid portmask.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      If the multicast mac address already existed in the LUT, it will udpate the
+ *      port mask of the entry. Otherwise, it will find an empty or asic auto learned
+ *      entry to write. If all the entries with the same hash value can't be replaced,
+ *      ASIC will return a RT_ERR_L2_INDEXTBL_FULL error.
+ */
+rtk_api_ret_t rtk_l2_mcastAddr_add(rtk_l2_mcastAddr_t *pMcastAddr)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      method;
+    rtl8367c_luttb  l2Table;
+    rtk_uint32      pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pMcastAddr)
+        return RT_ERR_NULL_POINTER;
+
+    /* must be L2 multicast address */
+    if( (pMcastAddr->mac.octet[0] & 0x01) != 0x01)
+        return RT_ERR_MAC;
+
+    RTK_CHK_PORTMASK_VALID(&pMcastAddr->portmask);
+
+    if(pMcastAddr->ivl == 1)
+    {
+        if (pMcastAddr->vid > RTL8367C_VIDMAX)
+            return RT_ERR_L2_VID;
+    }
+    else if(pMcastAddr->ivl == 0)
+    {
+        if (pMcastAddr->fid > RTL8367C_FIDMAX)
+            return RT_ERR_L2_FID;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    if(pMcastAddr->fwd_pri_en >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if(pMcastAddr->priority > RTL8367C_PRIMAX)
+        return RT_ERR_INPUT;
+
+    /* Get physical port mask */
+    if ((retVal = rtk_switch_portmask_L2P_get(&pMcastAddr->portmask, &pmask)) != RT_ERR_OK)
+        return retVal;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+
+    /* fill key (MAC,FID) to get L2 entry */
+    memcpy(l2Table.mac.octet, pMcastAddr->mac.octet, ETHER_ADDR_LEN);
+    l2Table.ivl_svl     = pMcastAddr->ivl;
+
+    if(pMcastAddr->ivl)
+        l2Table.cvid_fid    = pMcastAddr->vid;
+    else
+        l2Table.cvid_fid    = pMcastAddr->fid;
+
+    method = LUTREADMETHOD_MAC;
+    retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+    if (RT_ERR_OK == retVal)
+    {
+        memcpy(l2Table.mac.octet, pMcastAddr->mac.octet, ETHER_ADDR_LEN);
+        l2Table.ivl_svl     = pMcastAddr->ivl;
+
+        if(pMcastAddr->ivl)
+            l2Table.cvid_fid    = pMcastAddr->vid;
+        else
+            l2Table.cvid_fid    = pMcastAddr->fid;
+
+        l2Table.mbr         = pmask;
+        l2Table.nosalearn   = 1;
+        l2Table.l3lookup    = 0;
+        l2Table.lut_pri     = pMcastAddr->priority;
+        l2Table.fwd_en      = pMcastAddr->fwd_pri_en;
+        if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pMcastAddr->address = l2Table.address;
+        return RT_ERR_OK;
+    }
+    else if (RT_ERR_L2_ENTRY_NOTFOUND == retVal)
+    {
+        memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+        memcpy(l2Table.mac.octet, pMcastAddr->mac.octet, ETHER_ADDR_LEN);
+        l2Table.ivl_svl     = pMcastAddr->ivl;
+        if(pMcastAddr->ivl)
+            l2Table.cvid_fid    = pMcastAddr->vid;
+        else
+            l2Table.cvid_fid    = pMcastAddr->fid;
+
+        l2Table.mbr         = pmask;
+        l2Table.nosalearn   = 1;
+        l2Table.l3lookup    = 0;
+        l2Table.lut_pri     = pMcastAddr->priority;
+        l2Table.fwd_en      = pMcastAddr->fwd_pri_en;
+        if ((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pMcastAddr->address = l2Table.address;
+
+        method = LUTREADMETHOD_MAC;
+        retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+        if (RT_ERR_L2_ENTRY_NOTFOUND == retVal)
+            return     RT_ERR_L2_INDEXTBL_FULL;
+        else
+            return retVal;
+    }
+    else
+        return retVal;
+
+}
+
+/* Function Name:
+ *      rtk_l2_mcastAddr_get
+ * Description:
+ *      Get LUT multicast entry.
+ * Input:
+ *      pMcastAddr  - L2 multicast entry structure
+ * Output:
+ *      pMcastAddr  - L2 multicast entry structure
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_MAC                  - Invalid MAC address.
+ *      RT_ERR_L2_FID               - Invalid FID .
+ *      RT_ERR_L2_VID               - Invalid VID .
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      If the multicast mac address existed in the LUT, it will return the port where
+ *      the mac is learned. Otherwise, it will return a RT_ERR_L2_ENTRY_NOTFOUND error.
+ */
+rtk_api_ret_t rtk_l2_mcastAddr_get(rtk_l2_mcastAddr_t *pMcastAddr)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pMcastAddr)
+        return RT_ERR_NULL_POINTER;
+
+    /* must be L2 multicast address */
+    if( (pMcastAddr->mac.octet[0] & 0x01) != 0x01)
+        return RT_ERR_MAC;
+
+    if(pMcastAddr->ivl == 1)
+    {
+        if (pMcastAddr->vid > RTL8367C_VIDMAX)
+            return RT_ERR_L2_VID;
+    }
+    else if(pMcastAddr->ivl == 0)
+    {
+        if (pMcastAddr->fid > RTL8367C_FIDMAX)
+            return RT_ERR_L2_FID;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+    memcpy(l2Table.mac.octet, pMcastAddr->mac.octet, ETHER_ADDR_LEN);
+    l2Table.ivl_svl     = pMcastAddr->ivl;
+
+    if(pMcastAddr->ivl)
+        l2Table.cvid_fid    = pMcastAddr->vid;
+    else
+        l2Table.cvid_fid    = pMcastAddr->fid;
+
+    method = LUTREADMETHOD_MAC;
+
+    if ((retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table)) != RT_ERR_OK)
+        return retVal;
+
+    pMcastAddr->priority    = l2Table.lut_pri;
+    pMcastAddr->fwd_pri_en  = l2Table.fwd_en;
+    pMcastAddr->igmp_asic   = l2Table.igmp_asic;
+    pMcastAddr->igmp_index  = l2Table.igmpidx;
+    pMcastAddr->address     = l2Table.address;
+
+    /* Get Logical port mask */
+    if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pMcastAddr->portmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_mcastAddr_next_get
+ * Description:
+ *      Get Next L2 Multicast entry.
+ * Input:
+ *      pAddress        - The Address ID
+ * Output:
+ *      pMcastAddr  - L2 multicast entry structure
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      Get the next L2 multicast entry after the current entry pointed by pAddress.
+ *      The address of next entry is returned by pAddress. User can use (address + 1)
+ *      as pAddress to call this API again for dumping all multicast entries is LUT.
+ */
+rtk_api_ret_t rtk_l2_mcastAddr_next_get(rtk_uint32 *pAddress, rtk_l2_mcastAddr_t *pMcastAddr)
+{
+    rtk_api_ret_t   retVal;
+    rtl8367c_luttb  l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Error Checking */
+    if ((pAddress == NULL) || (pMcastAddr == NULL))
+        return RT_ERR_INPUT;
+
+    if(*pAddress > RTK_MAX_LUT_ADDR_ID )
+        return RT_ERR_L2_L2UNI_PARAM;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+    l2Table.address = *pAddress;
+
+    if ((retVal = rtl8367c_getAsicL2LookupTb(LUTREADMETHOD_NEXT_L2MC, &l2Table)) != RT_ERR_OK)
+        return retVal;
+
+    if(l2Table.address < *pAddress)
+        return RT_ERR_L2_ENTRY_NOTFOUND;
+
+    memcpy(pMcastAddr->mac.octet, l2Table.mac.octet, ETHER_ADDR_LEN);
+    pMcastAddr->ivl     = l2Table.ivl_svl;
+
+    if(pMcastAddr->ivl)
+        pMcastAddr->vid = l2Table.cvid_fid;
+    else
+        pMcastAddr->fid = l2Table.cvid_fid;
+
+    pMcastAddr->priority    = l2Table.lut_pri;
+    pMcastAddr->fwd_pri_en  = l2Table.fwd_en;
+    pMcastAddr->igmp_asic   = l2Table.igmp_asic;
+    pMcastAddr->igmp_index  = l2Table.igmpidx;
+    pMcastAddr->address     = l2Table.address;
+
+    /* Get Logical port mask */
+    if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pMcastAddr->portmask)) != RT_ERR_OK)
+        return retVal;
+
+    *pAddress = l2Table.address;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_mcastAddr_del
+ * Description:
+ *      Delete LUT multicast entry.
+ * Input:
+ *      pMcastAddr  - L2 multicast entry structure
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_MAC                  - Invalid MAC address.
+ *      RT_ERR_L2_FID               - Invalid FID .
+ *      RT_ERR_L2_VID               - Invalid VID .
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      If the mac has existed in the LUT, it will be deleted. Otherwise, it will return RT_ERR_L2_ENTRY_NOTFOUND.
+ */
+rtk_api_ret_t rtk_l2_mcastAddr_del(rtk_l2_mcastAddr_t *pMcastAddr)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pMcastAddr)
+        return RT_ERR_NULL_POINTER;
+
+    /* must be L2 multicast address */
+    if( (pMcastAddr->mac.octet[0] & 0x01) != 0x01)
+        return RT_ERR_MAC;
+
+    if(pMcastAddr->ivl == 1)
+    {
+        if (pMcastAddr->vid > RTL8367C_VIDMAX)
+            return RT_ERR_L2_VID;
+    }
+    else if(pMcastAddr->ivl == 0)
+    {
+        if (pMcastAddr->fid > RTL8367C_FIDMAX)
+            return RT_ERR_L2_FID;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+
+    /* fill key (MAC,FID) to get L2 entry */
+    memcpy(l2Table.mac.octet, pMcastAddr->mac.octet, ETHER_ADDR_LEN);
+    l2Table.ivl_svl     = pMcastAddr->ivl;
+
+    if(pMcastAddr->ivl)
+        l2Table.cvid_fid    = pMcastAddr->vid;
+    else
+        l2Table.cvid_fid    = pMcastAddr->fid;
+
+    method = LUTREADMETHOD_MAC;
+    retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+    if (RT_ERR_OK == retVal)
+    {
+        memcpy(l2Table.mac.octet, pMcastAddr->mac.octet, ETHER_ADDR_LEN);
+        l2Table.ivl_svl     = pMcastAddr->ivl;
+
+        if(pMcastAddr->ivl)
+            l2Table.cvid_fid    = pMcastAddr->vid;
+        else
+            l2Table.cvid_fid    = pMcastAddr->fid;
+
+        l2Table.mbr         = 0;
+        l2Table.nosalearn   = 0;
+        l2Table.sa_block    = 0;
+        l2Table.l3lookup    = 0;
+        l2Table.lut_pri     = 0;
+        l2Table.fwd_en      = 0;
+        if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pMcastAddr->address = l2Table.address;
+        return RT_ERR_OK;
+    }
+    else
+        return retVal;
+}
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddr_add
+ * Description:
+ *      Add Lut IP multicast entry
+ * Input:
+ *      pIpMcastAddr    - IP Multicast entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_L2_INDEXTBL_FULL - hashed index is full of entries.
+ *      RT_ERR_PORT_MASK        - Invalid portmask.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      System supports L2 entry with IP multicast DIP/SIP to forward IP multicasting frame as user
+ *      desired. If this function is enabled, then system will be looked up L2 IP multicast entry to
+ *      forward IP multicast frame directly without flooding.
+ */
+rtk_api_ret_t rtk_l2_ipMcastAddr_add(rtk_l2_ipMcastAddr_t *pIpMcastAddr)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pIpMcastAddr)
+        return RT_ERR_NULL_POINTER;
+
+    /* check port mask */
+    RTK_CHK_PORTMASK_VALID(&pIpMcastAddr->portmask);
+
+    if( (pIpMcastAddr->dip & 0xF0000000) != 0xE0000000)
+        return RT_ERR_INPUT;
+
+    if(pIpMcastAddr->fwd_pri_en >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if(pIpMcastAddr->priority > RTL8367C_PRIMAX)
+        return RT_ERR_INPUT;
+
+    /* Get Physical port mask */
+    if ((retVal = rtk_switch_portmask_L2P_get(&pIpMcastAddr->portmask, &pmask)) != RT_ERR_OK)
+        return retVal;
+
+    memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
+    l2Table.sip = pIpMcastAddr->sip;
+    l2Table.dip = pIpMcastAddr->dip;
+    l2Table.l3lookup = 1;
+    l2Table.l3vidlookup = 0;
+    method = LUTREADMETHOD_MAC;
+    retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+    if (RT_ERR_OK == retVal)
+    {
+        l2Table.sip = pIpMcastAddr->sip;
+        l2Table.dip = pIpMcastAddr->dip;
+        l2Table.mbr = pmask;
+        l2Table.nosalearn = 1;
+        l2Table.l3lookup = 1;
+        l2Table.l3vidlookup = 0;
+        l2Table.lut_pri = pIpMcastAddr->priority;
+        l2Table.fwd_en  = pIpMcastAddr->fwd_pri_en;
+        if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pIpMcastAddr->address = l2Table.address;
+        return RT_ERR_OK;
+    }
+    else if (RT_ERR_L2_ENTRY_NOTFOUND == retVal)
+    {
+        memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+        l2Table.sip = pIpMcastAddr->sip;
+        l2Table.dip = pIpMcastAddr->dip;
+        l2Table.mbr = pmask;
+        l2Table.nosalearn = 1;
+        l2Table.l3lookup = 1;
+        l2Table.l3vidlookup = 0;
+        l2Table.lut_pri = pIpMcastAddr->priority;
+        l2Table.fwd_en  = pIpMcastAddr->fwd_pri_en;
+        if ((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pIpMcastAddr->address = l2Table.address;
+
+        method = LUTREADMETHOD_MAC;
+        retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+        if (RT_ERR_L2_ENTRY_NOTFOUND == retVal)
+            return     RT_ERR_L2_INDEXTBL_FULL;
+        else
+            return retVal;
+
+    }
+    else
+        return retVal;
+
+}
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddr_get
+ * Description:
+ *      Get LUT IP multicast entry.
+ * Input:
+ *      pIpMcastAddr    - IP Multicast entry
+ * Output:
+ *      pIpMcastAddr    - IP Multicast entry
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      The API can get Lut table of IP multicast entry.
+ */
+rtk_api_ret_t rtk_l2_ipMcastAddr_get(rtk_l2_ipMcastAddr_t *pIpMcastAddr)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pIpMcastAddr)
+        return RT_ERR_NULL_POINTER;
+
+    if( (pIpMcastAddr->dip & 0xF0000000) != 0xE0000000)
+        return RT_ERR_INPUT;
+
+    memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
+    l2Table.sip = pIpMcastAddr->sip;
+    l2Table.dip = pIpMcastAddr->dip;
+    l2Table.l3lookup = 1;
+    l2Table.l3vidlookup = 0;
+    method = LUTREADMETHOD_MAC;
+    if ((retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table)) != RT_ERR_OK)
+        return retVal;
+
+    /* Get Logical port mask */
+    if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pIpMcastAddr->portmask)) != RT_ERR_OK)
+        return retVal;
+
+    pIpMcastAddr->priority      = l2Table.lut_pri;
+    pIpMcastAddr->fwd_pri_en    = l2Table.fwd_en;
+    pIpMcastAddr->igmp_asic     = l2Table.igmp_asic;
+    pIpMcastAddr->igmp_index    = l2Table.igmpidx;
+    pIpMcastAddr->address       = l2Table.address;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddr_next_get
+ * Description:
+ *      Get Next IP Multicast entry.
+ * Input:
+ *      pAddress        - The Address ID
+ * Output:
+ *      pIpMcastAddr    - IP Multicast entry
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      Get the next IP multicast entry after the current entry pointed by pAddress.
+ *      The address of next entry is returned by pAddress. User can use (address + 1)
+ *      as pAddress to call this API again for dumping all IP multicast entries is LUT.
+ */
+rtk_api_ret_t rtk_l2_ipMcastAddr_next_get(rtk_uint32 *pAddress, rtk_l2_ipMcastAddr_t *pIpMcastAddr)
+{
+    rtk_api_ret_t   retVal;
+    rtl8367c_luttb  l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Error Checking */
+    if ((pAddress == NULL) || (pIpMcastAddr == NULL) )
+        return RT_ERR_INPUT;
+
+    if(*pAddress > RTK_MAX_LUT_ADDR_ID )
+        return RT_ERR_L2_L2UNI_PARAM;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+    l2Table.address = *pAddress;
+
+    do
+    {
+        if ((retVal = rtl8367c_getAsicL2LookupTb(LUTREADMETHOD_NEXT_L3MC, &l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        if(l2Table.address < *pAddress)
+            return RT_ERR_L2_ENTRY_NOTFOUND;
+
+    }while(l2Table.l3vidlookup == 1);
+
+    pIpMcastAddr->sip = l2Table.sip;
+    pIpMcastAddr->dip = l2Table.dip;
+
+    /* Get Logical port mask */
+    if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pIpMcastAddr->portmask)) != RT_ERR_OK)
+        return retVal;
+
+    pIpMcastAddr->priority      = l2Table.lut_pri;
+    pIpMcastAddr->fwd_pri_en    = l2Table.fwd_en;
+    pIpMcastAddr->igmp_asic     = l2Table.igmp_asic;
+    pIpMcastAddr->igmp_index    = l2Table.igmpidx;
+    pIpMcastAddr->address       = l2Table.address;
+    *pAddress = l2Table.address;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddr_del
+ * Description:
+ *      Delete a ip multicast address entry from the specified device.
+ * Input:
+ *      pIpMcastAddr    - IP Multicast entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      The API can delete a IP multicast address entry from the specified device.
+ */
+rtk_api_ret_t rtk_l2_ipMcastAddr_del(rtk_l2_ipMcastAddr_t *pIpMcastAddr)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Error Checking */
+    if (pIpMcastAddr == NULL)
+        return RT_ERR_INPUT;
+
+    if( (pIpMcastAddr->dip & 0xF0000000) != 0xE0000000)
+        return RT_ERR_INPUT;
+
+    memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
+    l2Table.sip = pIpMcastAddr->sip;
+    l2Table.dip = pIpMcastAddr->dip;
+    l2Table.l3lookup = 1;
+    l2Table.l3vidlookup = 0;
+    method = LUTREADMETHOD_MAC;
+    retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+    if (RT_ERR_OK == retVal)
+    {
+        l2Table.sip = pIpMcastAddr->sip;
+        l2Table.dip = pIpMcastAddr->dip;
+        l2Table.mbr = 0;
+        l2Table.nosalearn = 0;
+        l2Table.l3lookup = 1;
+        l2Table.l3vidlookup = 0;
+        l2Table.lut_pri = 0;
+        l2Table.fwd_en  = 0;
+        if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pIpMcastAddr->address = l2Table.address;
+        return RT_ERR_OK;
+    }
+    else
+        return retVal;
+}
+
+/* Function Name:
+ *      rtk_l2_ipVidMcastAddr_add
+ * Description:
+ *      Add Lut IP multicast+VID entry
+ * Input:
+ *      pIpVidMcastAddr - IP & VID multicast Entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_L2_INDEXTBL_FULL - hashed index is full of entries.
+ *      RT_ERR_PORT_MASK        - Invalid portmask.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_l2_ipVidMcastAddr_add(rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pIpVidMcastAddr)
+        return RT_ERR_NULL_POINTER;
+
+    /* check port mask */
+    RTK_CHK_PORTMASK_VALID(&pIpVidMcastAddr->portmask);
+
+    if (pIpVidMcastAddr->vid > RTL8367C_VIDMAX)
+        return RT_ERR_L2_VID;
+
+    if( (pIpVidMcastAddr->dip & 0xF0000000) != 0xE0000000)
+        return RT_ERR_INPUT;
+
+    /* Get Physical port mask */
+    if ((retVal = rtk_switch_portmask_L2P_get(&pIpVidMcastAddr->portmask, &pmask)) != RT_ERR_OK)
+        return retVal;
+
+    memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
+    l2Table.sip = pIpVidMcastAddr->sip;
+    l2Table.dip = pIpVidMcastAddr->dip;
+    l2Table.l3lookup = 1;
+    l2Table.l3vidlookup = 1;
+    l2Table.l3_vid = pIpVidMcastAddr->vid;
+    method = LUTREADMETHOD_MAC;
+    retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+    if (RT_ERR_OK == retVal)
+    {
+        l2Table.sip = pIpVidMcastAddr->sip;
+        l2Table.dip = pIpVidMcastAddr->dip;
+        l2Table.mbr = pmask;
+        l2Table.nosalearn = 1;
+        l2Table.l3lookup = 1;
+        l2Table.l3vidlookup = 1;
+        l2Table.l3_vid = pIpVidMcastAddr->vid;
+        if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pIpVidMcastAddr->address = l2Table.address;
+        return RT_ERR_OK;
+    }
+    else if (RT_ERR_L2_ENTRY_NOTFOUND == retVal)
+    {
+        memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+        l2Table.sip = pIpVidMcastAddr->sip;
+        l2Table.dip = pIpVidMcastAddr->dip;
+        l2Table.mbr = pmask;
+        l2Table.nosalearn = 1;
+        l2Table.l3lookup = 1;
+        l2Table.l3vidlookup = 1;
+        l2Table.l3_vid = pIpVidMcastAddr->vid;
+        if ((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pIpVidMcastAddr->address = l2Table.address;
+
+        method = LUTREADMETHOD_MAC;
+        retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+        if (RT_ERR_L2_ENTRY_NOTFOUND == retVal)
+            return     RT_ERR_L2_INDEXTBL_FULL;
+        else
+            return retVal;
+
+    }
+    else
+        return retVal;
+}
+
+/* Function Name:
+ *      rtk_l2_ipVidMcastAddr_get
+ * Description:
+ *      Get LUT IP multicast+VID entry.
+ * Input:
+ *      pIpVidMcastAddr - IP & VID multicast Entry
+ * Output:
+ *      pIpVidMcastAddr - IP & VID multicast Entry
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_l2_ipVidMcastAddr_get(rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pIpVidMcastAddr)
+        return RT_ERR_NULL_POINTER;
+
+    if (pIpVidMcastAddr->vid > RTL8367C_VIDMAX)
+        return RT_ERR_L2_VID;
+
+    if( (pIpVidMcastAddr->dip & 0xF0000000) != 0xE0000000)
+        return RT_ERR_INPUT;
+
+    memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
+    l2Table.sip = pIpVidMcastAddr->sip;
+    l2Table.dip = pIpVidMcastAddr->dip;
+    l2Table.l3lookup = 1;
+    l2Table.l3vidlookup = 1;
+    l2Table.l3_vid = pIpVidMcastAddr->vid;
+    method = LUTREADMETHOD_MAC;
+    if ((retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table)) != RT_ERR_OK)
+        return retVal;
+
+    pIpVidMcastAddr->address = l2Table.address;
+
+     /* Get Logical port mask */
+    if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pIpVidMcastAddr->portmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_ipVidMcastAddr_next_get
+ * Description:
+ *      Get Next IP Multicast+VID entry.
+ * Input:
+ *      pAddress        - The Address ID
+ * Output:
+ *      pIpVidMcastAddr - IP & VID multicast Entry
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *      Get the next IP multicast entry after the current entry pointed by pAddress.
+ *      The address of next entry is returned by pAddress. User can use (address + 1)
+ *      as pAddress to call this API again for dumping all IP multicast entries is LUT.
+ */
+rtk_api_ret_t rtk_l2_ipVidMcastAddr_next_get(rtk_uint32 *pAddress, rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr)
+{
+    rtk_api_ret_t   retVal;
+    rtl8367c_luttb  l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Error Checking */
+    if ((pAddress == NULL) || (pIpVidMcastAddr == NULL))
+        return RT_ERR_INPUT;
+
+    if(*pAddress > RTK_MAX_LUT_ADDR_ID )
+        return RT_ERR_L2_L2UNI_PARAM;
+
+    memset(&l2Table, 0, sizeof(rtl8367c_luttb));
+    l2Table.address = *pAddress;
+
+    do
+    {
+        if ((retVal = rtl8367c_getAsicL2LookupTb(LUTREADMETHOD_NEXT_L3MC, &l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        if(l2Table.address < *pAddress)
+            return RT_ERR_L2_ENTRY_NOTFOUND;
+
+    }while(l2Table.l3vidlookup == 0);
+
+    pIpVidMcastAddr->sip        = l2Table.sip;
+    pIpVidMcastAddr->dip        = l2Table.dip;
+    pIpVidMcastAddr->vid        = l2Table.l3_vid;
+    pIpVidMcastAddr->address    = l2Table.address;
+
+    /* Get Logical port mask */
+    if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &pIpVidMcastAddr->portmask)) != RT_ERR_OK)
+        return retVal;
+
+    *pAddress = l2Table.address;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_ipVidMcastAddr_del
+ * Description:
+ *      Delete a ip multicast+VID address entry from the specified device.
+ * Input:
+ *      pIpVidMcastAddr - IP & VID multicast Entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_L2_ENTRY_NOTFOUND    - No such LUT entry.
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_l2_ipVidMcastAddr_del(rtk_l2_ipVidMcastAddr_t *pIpVidMcastAddr)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pIpVidMcastAddr)
+        return RT_ERR_NULL_POINTER;
+
+    if (pIpVidMcastAddr->vid > RTL8367C_VIDMAX)
+        return RT_ERR_L2_VID;
+
+    if( (pIpVidMcastAddr->dip & 0xF0000000) != 0xE0000000)
+        return RT_ERR_INPUT;
+
+    memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
+    l2Table.sip = pIpVidMcastAddr->sip;
+    l2Table.dip = pIpVidMcastAddr->dip;
+    l2Table.l3lookup = 1;
+    l2Table.l3vidlookup = 1;
+    l2Table.l3_vid = pIpVidMcastAddr->vid;
+    method = LUTREADMETHOD_MAC;
+    retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table);
+    if (RT_ERR_OK == retVal)
+    {
+        l2Table.sip = pIpVidMcastAddr->sip;
+        l2Table.dip = pIpVidMcastAddr->dip;
+        l2Table.mbr= 0;
+        l2Table.nosalearn = 0;
+        l2Table.l3lookup = 1;
+        l2Table.l3vidlookup = 1;
+        l2Table.l3_vid = pIpVidMcastAddr->vid;
+        if((retVal = rtl8367c_setAsicL2LookupTb(&l2Table)) != RT_ERR_OK)
+            return retVal;
+
+        pIpVidMcastAddr->address = l2Table.address;
+        return RT_ERR_OK;
+    }
+    else
+        return retVal;
+}
+
+/* Function Name:
+ *      rtk_l2_ucastAddr_flush
+ * Description:
+ *      Flush L2 mac address by type in the specified device (both dynamic and static).
+ * Input:
+ *      pConfig - flush configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      flushByVid          - 1: Flush by VID, 0: Don't flush by VID
+ *      vid                 - VID (0 ~ 4095)
+ *      flushByFid          - 1: Flush by FID, 0: Don't flush by FID
+ *      fid                 - FID (0 ~ 15)
+ *      flushByPort         - 1: Flush by Port, 0: Don't flush by Port
+ *      port                - Port ID
+ *      flushByMac          - Not Supported
+ *      ucastAddr           - Not Supported
+ *      flushStaticAddr     - 1: Flush both Static and Dynamic entries, 0: Flush only Dynamic entries
+ *      flushAddrOnAllPorts - 1: Flush VID-matched entries at all ports, 0: Flush VID-matched entries per port.
+ */
+rtk_api_ret_t rtk_l2_ucastAddr_flush(rtk_l2_flushCfg_t *pConfig)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(pConfig == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if(pConfig->flushByVid >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if(pConfig->flushByFid >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if(pConfig->flushByPort >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if(pConfig->flushByMac >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if(pConfig->flushStaticAddr >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if(pConfig->flushAddrOnAllPorts >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if(pConfig->vid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    if(pConfig->fid > RTL8367C_FIDMAX)
+        return RT_ERR_INPUT;
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(pConfig->port);
+
+    if(pConfig->flushByVid == ENABLED)
+    {
+        if ((retVal = rtl8367c_setAsicLutFlushMode(FLUSHMDOE_VID)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicLutFlushVid(pConfig->vid)) != RT_ERR_OK)
+                return retVal;
+
+        if ((retVal = rtl8367c_setAsicLutFlushType((pConfig->flushStaticAddr == ENABLED) ? FLUSHTYPE_BOTH : FLUSHTYPE_DYNAMIC)) != RT_ERR_OK)
+            return retVal;
+
+        if(pConfig->flushAddrOnAllPorts == ENABLED)
+        {
+            if ((retVal = rtl8367c_setAsicLutForceFlush(RTL8367C_PORTMASK)) != RT_ERR_OK)
+                return retVal;
+        }
+        else if(pConfig->flushByPort == ENABLED)
+        {
+            if ((retVal = rtl8367c_setAsicLutForceFlush(1 << rtk_switch_port_L2P_get(pConfig->port))) != RT_ERR_OK)
+                return retVal;
+        }
+        else
+            return RT_ERR_INPUT;
+    }
+    else if(pConfig->flushByFid == ENABLED)
+    {
+        if ((retVal = rtl8367c_setAsicLutFlushMode(FLUSHMDOE_FID)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicLutFlushFid(pConfig->fid)) != RT_ERR_OK)
+                return retVal;
+
+        if ((retVal = rtl8367c_setAsicLutFlushType((pConfig->flushStaticAddr == ENABLED) ? FLUSHTYPE_BOTH : FLUSHTYPE_DYNAMIC)) != RT_ERR_OK)
+            return retVal;
+
+        if(pConfig->flushAddrOnAllPorts == ENABLED)
+        {
+            if ((retVal = rtl8367c_setAsicLutForceFlush(RTL8367C_PORTMASK)) != RT_ERR_OK)
+                return retVal;
+        }
+        else if(pConfig->flushByPort == ENABLED)
+        {
+            if ((retVal = rtl8367c_setAsicLutForceFlush(1 << rtk_switch_port_L2P_get(pConfig->port))) != RT_ERR_OK)
+                return retVal;
+        }
+        else
+            return RT_ERR_INPUT;
+    }
+    else if(pConfig->flushByPort == ENABLED)
+    {
+        if ((retVal = rtl8367c_setAsicLutFlushType((pConfig->flushStaticAddr == ENABLED) ? FLUSHTYPE_BOTH : FLUSHTYPE_DYNAMIC)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicLutFlushMode(FLUSHMDOE_PORT)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicLutForceFlush(1 << rtk_switch_port_L2P_get(pConfig->port))) != RT_ERR_OK)
+            return retVal;
+    }
+    else if(pConfig->flushByMac == ENABLED)
+    {
+        /* Should use API "rtk_l2_addr_del" to remove a specified entry*/
+        return RT_ERR_CHIP_NOT_SUPPORTED;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_table_clear
+ * Description:
+ *      Flush all static & dynamic entries in LUT.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_l2_table_clear(void)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_setAsicLutFlushAll()) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_table_clearStatus_get
+ * Description:
+ *      Get table clear status
+ * Input:
+ *      None
+ * Output:
+ *      pStatus - Clear status, 1:Busy, 0:finish
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_l2_table_clearStatus_get(rtk_l2_clearStatus_t *pStatus)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pStatus)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLutFlushAllStatus((rtk_uint32 *)pStatus)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_flushLinkDownPortAddrEnable_set
+ * Description:
+ *      Set HW flush linkdown port mac configuration of the specified device.
+ * Input:
+ *      port - Port id.
+ *      enable - link down flush status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      The status of flush linkdown port address is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+rtk_api_ret_t rtk_l2_flushLinkDownPortAddrEnable_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (port != RTK_WHOLE_SYSTEM)
+        return RT_ERR_PORT_ID;
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicLutLinkDownForceAging(enable)) != RT_ERR_OK)
+        return retVal;
+
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_flushLinkDownPortAddrEnable_get
+ * Description:
+ *      Get HW flush linkdown port mac configuration of the specified device.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - link down flush status
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The status of flush linkdown port address is as following:
+ *      - DISABLED
+ *      - ENABLED
+ */
+rtk_api_ret_t rtk_l2_flushLinkDownPortAddrEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (port != RTK_WHOLE_SYSTEM)
+        return RT_ERR_PORT_ID;
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLutLinkDownForceAging(pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_agingEnable_set
+ * Description:
+ *      Set L2 LUT aging status per port setting.
+ * Input:
+ *      port    - Port id.
+ *      enable  - Aging status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      This API can be used to set L2 LUT aging status per port.
+ */
+rtk_api_ret_t rtk_l2_agingEnable_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if(enable == 1)
+        enable = 0;
+    else
+        enable = 1;
+
+    if ((retVal = rtl8367c_setAsicLutDisableAging(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_agingEnable_get
+ * Description:
+ *      Get L2 LUT aging status per port setting.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - Aging status
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can be used to get L2 LUT aging function per port.
+ */
+rtk_api_ret_t rtk_l2_agingEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLutDisableAging(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    if(*pEnable == 1)
+        *pEnable = 0;
+    else
+        *pEnable = 1;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_limitLearningCnt_set
+ * Description:
+ *      Set per-Port auto learning limit number
+ * Input:
+ *      port    - Port id.
+ *      mac_cnt - Auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_LIMITED_L2ENTRY_NUM  - Invalid auto learning limit number
+ * Note:
+ *      The API can set per-port ASIC auto learning limit number from 0(disable learning)
+ *      to 2112.
+ */
+rtk_api_ret_t rtk_l2_limitLearningCnt_set(rtk_port_t port, rtk_mac_cnt_t mac_cnt)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (mac_cnt > rtk_switch_maxLutAddrNumber_get())
+        return RT_ERR_LIMITED_L2ENTRY_NUM;
+
+    if ((retVal = rtl8367c_setAsicLutLearnLimitNo(rtk_switch_port_L2P_get(port), mac_cnt)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_limitLearningCnt_get
+ * Description:
+ *      Get per-Port auto learning limit number
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pMac_cnt - Auto learning entries limit number
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get per-port ASIC auto learning limit number.
+ */
+rtk_api_ret_t rtk_l2_limitLearningCnt_get(rtk_port_t port, rtk_mac_cnt_t *pMac_cnt)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pMac_cnt)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLutLearnLimitNo(rtk_switch_port_L2P_get(port), pMac_cnt)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCnt_set
+ * Description:
+ *      Set System auto learning limit number
+ * Input:
+ *      mac_cnt - Auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_LIMITED_L2ENTRY_NUM  - Invalid auto learning limit number
+ * Note:
+ *      The API can set system ASIC auto learning limit number from 0(disable learning)
+ *      to 2112.
+ */
+rtk_api_ret_t rtk_l2_limitSystemLearningCnt_set(rtk_mac_cnt_t mac_cnt)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (mac_cnt > rtk_switch_maxLutAddrNumber_get())
+        return RT_ERR_LIMITED_L2ENTRY_NUM;
+
+    if ((retVal = rtl8367c_setAsicSystemLutLearnLimitNo(mac_cnt)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCnt_get
+ * Description:
+ *      Get System auto learning limit number
+ * Input:
+ *      None
+ * Output:
+ *      pMac_cnt - Auto learning entries limit number
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get system ASIC auto learning limit number.
+ */
+rtk_api_ret_t rtk_l2_limitSystemLearningCnt_get(rtk_mac_cnt_t *pMac_cnt)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pMac_cnt)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicSystemLutLearnLimitNo(pMac_cnt)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_limitLearningCntAction_set
+ * Description:
+ *      Configure auto learn over limit number action.
+ * Input:
+ *      port - Port id.
+ *      action - Auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_NOT_ALLOWED  - Invalid learn over action
+ * Note:
+ *      The API can set SA unknown packet action while auto learn limit number is over
+ *      The action symbol as following:
+ *      - LIMIT_LEARN_CNT_ACTION_DROP,
+ *      - LIMIT_LEARN_CNT_ACTION_FORWARD,
+ *      - LIMIT_LEARN_CNT_ACTION_TO_CPU,
+ */
+rtk_api_ret_t rtk_l2_limitLearningCntAction_set(rtk_port_t port, rtk_l2_limitLearnCntAction_t action)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 data;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (port != RTK_WHOLE_SYSTEM)
+        return RT_ERR_PORT_ID;
+
+    if ( LIMIT_LEARN_CNT_ACTION_DROP == action )
+        data = 1;
+    else if ( LIMIT_LEARN_CNT_ACTION_FORWARD == action )
+        data = 0;
+    else if ( LIMIT_LEARN_CNT_ACTION_TO_CPU == action )
+        data = 2;
+    else
+        return RT_ERR_NOT_ALLOWED;
+
+    if ((retVal = rtl8367c_setAsicLutLearnOverAct(data)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_limitLearningCntAction_get
+ * Description:
+ *      Get auto learn over limit number action.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pAction - Learn over action
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get SA unknown packet action while auto learn limit number is over
+ *      The action symbol as following:
+ *      - LIMIT_LEARN_CNT_ACTION_DROP,
+ *      - LIMIT_LEARN_CNT_ACTION_FORWARD,
+ *      - LIMIT_LEARN_CNT_ACTION_TO_CPU,
+ */
+rtk_api_ret_t rtk_l2_limitLearningCntAction_get(rtk_port_t port, rtk_l2_limitLearnCntAction_t *pAction)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 action;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (port != RTK_WHOLE_SYSTEM)
+        return RT_ERR_PORT_ID;
+
+    if(NULL == pAction)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLutLearnOverAct(&action)) != RT_ERR_OK)
+        return retVal;
+
+    if ( 1 == action )
+        *pAction = LIMIT_LEARN_CNT_ACTION_DROP;
+    else if ( 0 == action )
+        *pAction = LIMIT_LEARN_CNT_ACTION_FORWARD;
+    else if ( 2 == action )
+        *pAction = LIMIT_LEARN_CNT_ACTION_TO_CPU;
+    else
+    *pAction = action;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCntAction_set
+ * Description:
+ *      Configure system auto learn over limit number action.
+ * Input:
+ *      port - Port id.
+ *      action - Auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_NOT_ALLOWED  - Invalid learn over action
+ * Note:
+ *      The API can set SA unknown packet action while auto learn limit number is over
+ *      The action symbol as following:
+ *      - LIMIT_LEARN_CNT_ACTION_DROP,
+ *      - LIMIT_LEARN_CNT_ACTION_FORWARD,
+ *      - LIMIT_LEARN_CNT_ACTION_TO_CPU,
+ */
+rtk_api_ret_t rtk_l2_limitSystemLearningCntAction_set(rtk_l2_limitLearnCntAction_t action)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 data;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ( LIMIT_LEARN_CNT_ACTION_DROP == action )
+        data = 1;
+    else if ( LIMIT_LEARN_CNT_ACTION_FORWARD == action )
+        data = 0;
+    else if ( LIMIT_LEARN_CNT_ACTION_TO_CPU == action )
+        data = 2;
+    else
+        return RT_ERR_NOT_ALLOWED;
+
+    if ((retVal = rtl8367c_setAsicSystemLutLearnOverAct(data)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCntAction_get
+ * Description:
+ *      Get system auto learn over limit number action.
+ * Input:
+ *      None.
+ * Output:
+ *      pAction - Learn over action
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get SA unknown packet action while auto learn limit number is over
+ *      The action symbol as following:
+ *      - LIMIT_LEARN_CNT_ACTION_DROP,
+ *      - LIMIT_LEARN_CNT_ACTION_FORWARD,
+ *      - LIMIT_LEARN_CNT_ACTION_TO_CPU,
+ */
+rtk_api_ret_t rtk_l2_limitSystemLearningCntAction_get(rtk_l2_limitLearnCntAction_t *pAction)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 action;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pAction)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicSystemLutLearnOverAct(&action)) != RT_ERR_OK)
+        return retVal;
+
+    if ( 1 == action )
+        *pAction = LIMIT_LEARN_CNT_ACTION_DROP;
+    else if ( 0 == action )
+        *pAction = LIMIT_LEARN_CNT_ACTION_FORWARD;
+    else if ( 2 == action )
+        *pAction = LIMIT_LEARN_CNT_ACTION_TO_CPU;
+    else
+    *pAction = action;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCntPortMask_set
+ * Description:
+ *      Configure system auto learn portmask
+ * Input:
+ *      pPortmask - Port Mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid port mask.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_l2_limitSystemLearningCntPortMask_set(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port mask */
+    RTK_CHK_PORTMASK_VALID(pPortmask);
+
+    if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicSystemLutLearnPortMask(pmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_limitSystemLearningCntPortMask_get
+ * Description:
+ *      get system auto learn portmask
+ * Input:
+ *      None
+ * Output:
+ *      pPortmask - Port Mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - Null pointer.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_l2_limitSystemLearningCntPortMask_get(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicSystemLutLearnPortMask(&pmask)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_learningCnt_get
+ * Description:
+ *      Get per-Port current auto learning number
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pMac_cnt - ASIC auto learning entries number
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get per-port ASIC auto learning number
+ */
+rtk_api_ret_t rtk_l2_learningCnt_get(rtk_port_t port, rtk_mac_cnt_t *pMac_cnt)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pMac_cnt)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLutLearnNo(rtk_switch_port_L2P_get(port), pMac_cnt)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_floodPortMask_set
+ * Description:
+ *      Set flooding portmask
+ * Input:
+ *      type - flooding type.
+ *      pFlood_portmask - flooding porkmask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can set the flooding mask.
+ *      The flooding type is as following:
+ *      - FLOOD_UNKNOWNDA
+ *      - FLOOD_UNKNOWNMC
+ *      - FLOOD_BC
+ */
+rtk_api_ret_t rtk_l2_floodPortMask_set(rtk_l2_flood_type_t floood_type, rtk_portmask_t *pFlood_portmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (floood_type >= FLOOD_END)
+        return RT_ERR_INPUT;
+
+    /* check port valid */
+    RTK_CHK_PORTMASK_VALID(pFlood_portmask);
+
+    /* Get Physical port mask */
+    if ((retVal = rtk_switch_portmask_L2P_get(pFlood_portmask, &pmask))!=RT_ERR_OK)
+        return retVal;
+
+    switch (floood_type)
+    {
+        case FLOOD_UNKNOWNDA:
+            if ((retVal = rtl8367c_setAsicPortUnknownDaFloodingPortmask(pmask)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case FLOOD_UNKNOWNMC:
+            if ((retVal = rtl8367c_setAsicPortUnknownMulticastFloodingPortmask(pmask)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case FLOOD_BC:
+            if ((retVal = rtl8367c_setAsicPortBcastFloodingPortmask(pmask)) != RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtk_l2_floodPortMask_get
+ * Description:
+ *      Get flooding portmask
+ * Input:
+ *      type - flooding type.
+ * Output:
+ *      pFlood_portmask - flooding porkmask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can get the flooding mask.
+ *      The flooding type is as following:
+ *      - FLOOD_UNKNOWNDA
+ *      - FLOOD_UNKNOWNMC
+ *      - FLOOD_BC
+ */
+rtk_api_ret_t rtk_l2_floodPortMask_get(rtk_l2_flood_type_t floood_type, rtk_portmask_t *pFlood_portmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (floood_type >= FLOOD_END)
+        return RT_ERR_INPUT;
+
+    if(NULL == pFlood_portmask)
+        return RT_ERR_NULL_POINTER;
+
+    switch (floood_type)
+    {
+        case FLOOD_UNKNOWNDA:
+            if ((retVal = rtl8367c_getAsicPortUnknownDaFloodingPortmask(&pmask)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case FLOOD_UNKNOWNMC:
+            if ((retVal = rtl8367c_getAsicPortUnknownMulticastFloodingPortmask(&pmask)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case FLOOD_BC:
+            if ((retVal = rtl8367c_getAsicPortBcastFloodingPortmask(&pmask)) != RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    }
+
+    /* Get Logical port mask */
+    if ((retVal = rtk_switch_portmask_P2L_get(pmask, pFlood_portmask))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_localPktPermit_set
+ * Description:
+ *      Set permittion of frames if source port and destination port are the same.
+ * Input:
+ *      port - Port id.
+ *      permit - permittion status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid permit value.
+ * Note:
+ *      This API is setted to permit frame if its source port is equal to destination port.
+ */
+rtk_api_ret_t rtk_l2_localPktPermit_set(rtk_port_t port, rtk_enable_t permit)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (permit >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicPortBlockSpa(rtk_switch_port_L2P_get(port), permit)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_localPktPermit_get
+ * Description:
+ *      Get permittion of frames if source port and destination port are the same.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPermit - permittion status
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API is to get permittion status for frames if its source port is equal to destination port.
+ */
+rtk_api_ret_t rtk_l2_localPktPermit_get(rtk_port_t port, rtk_enable_t *pPermit)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pPermit)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortBlockSpa(rtk_switch_port_L2P_get(port), pPermit)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_aging_set
+ * Description:
+ *      Set LUT agging out speed
+ * Input:
+ *      aging_time - Agging out time.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The API can set LUT agging out period for each entry and the range is from 45s to 458s.
+ */
+rtk_api_ret_t rtk_l2_aging_set(rtk_l2_age_time_t aging_time)
+{
+    rtk_uint32 i;
+    CONST_T rtk_uint32 agePara[10][3] = {
+        {45, 0, 1}, {88, 0, 2}, {133, 0, 3}, {177, 0, 4}, {221, 0, 5}, {266, 0, 6}, {310, 0, 7},
+        {354, 2, 6}, {413, 2, 7}, {458, 3, 7}};
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (aging_time>agePara[9][0])
+        return RT_ERR_OUT_OF_RANGE;
+
+    for (i = 0; i<10; i++)
+    {
+        if (aging_time<=agePara[i][0])
+        {
+            return rtl8367c_setAsicLutAgeTimerSpeed(agePara[i][2], agePara[i][1]);
+        }
+    }
+
+    return RT_ERR_FAILED;
+}
+
+/* Function Name:
+ *      rtk_l2_aging_get
+ * Description:
+ *      Get LUT agging out time
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - Aging status
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get LUT agging out period for each entry.
+ */
+rtk_api_ret_t rtk_l2_aging_get(rtk_l2_age_time_t *pAging_time)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i,time, speed;
+    CONST_T rtk_uint32 agePara[10][3] = {
+        {45, 0, 1}, {88, 0, 2}, {133, 0, 3}, {177, 0, 4}, {221, 0, 5}, {266, 0, 6}, {310, 0, 7},
+        {354, 2, 6}, {413, 2, 7}, {458, 3, 7}};
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pAging_time)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLutAgeTimerSpeed(&time, &speed)) != RT_ERR_OK)
+        return retVal;
+
+    for (i = 0; i<10; i++)
+    {
+        if (time==agePara[i][2]&&speed==agePara[i][1])
+        {
+            *pAging_time = agePara[i][0];
+            return RT_ERR_OK;
+        }
+    }
+
+    return RT_ERR_FAILED;
+}
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddrLookup_set
+ * Description:
+ *      Set Lut IP multicast lookup function
+ * Input:
+ *      type - Lookup type for IPMC packet.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ * Note:
+ *      LOOKUP_MAC      - Lookup by MAC address
+ *      LOOKUP_IP       - Lookup by IP address
+ *      LOOKUP_IP_VID   - Lookup by IP address & VLAN ID
+ */
+rtk_api_ret_t rtk_l2_ipMcastAddrLookup_set(rtk_l2_ipmc_lookup_type_t type)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(type == LOOKUP_MAC)
+    {
+        if((retVal = rtl8367c_setAsicLutIpMulticastLookup(DISABLED)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if(type == LOOKUP_IP)
+    {
+        if((retVal = rtl8367c_setAsicLutIpMulticastLookup(ENABLED)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicLutIpMulticastVidLookup(DISABLED))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicLutIpLookupMethod(1))!=RT_ERR_OK)
+            return retVal;
+    }
+    else if(type == LOOKUP_IP_VID)
+    {
+        if((retVal = rtl8367c_setAsicLutIpMulticastLookup(ENABLED)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicLutIpMulticastVidLookup(ENABLED))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicLutIpLookupMethod(1))!=RT_ERR_OK)
+            return retVal;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_ipMcastAddrLookup_get
+ * Description:
+ *      Get Lut IP multicast lookup function
+ * Input:
+ *      None.
+ * Output:
+ *      pType - Lookup type for IPMC packet.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_l2_ipMcastAddrLookup_get(rtk_l2_ipmc_lookup_type_t *pType)
+{
+    rtk_api_ret_t       retVal;
+    rtk_uint32          enabled, vid_lookup;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pType)
+        return RT_ERR_NULL_POINTER;
+
+    if((retVal = rtl8367c_getAsicLutIpMulticastLookup(&enabled)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicLutIpMulticastVidLookup(&vid_lookup))!=RT_ERR_OK)
+        return retVal;
+
+    if(enabled == ENABLED)
+    {
+        if(vid_lookup == ENABLED)
+            *pType = LOOKUP_IP_VID;
+        else
+            *pType = LOOKUP_IP;
+    }
+    else
+        *pType = LOOKUP_MAC;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_ipMcastForwardRouterPort_set
+ * Description:
+ *      Set IPMC packet forward to rounter port also or not
+ * Input:
+ *      enabled - 1: Inlcude router port, 0, exclude router port
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_l2_ipMcastForwardRouterPort_set(rtk_enable_t enabled)
+{
+    rtk_api_ret_t       retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (enabled >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if((retVal = rtl8367c_setAsicLutIpmcFwdRouterPort(enabled)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_ipMcastForwardRouterPort_get
+ * Description:
+ *      Get IPMC packet forward to rounter port also or not
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled    - 1: Inlcude router port, 0, exclude router port
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_l2_ipMcastForwardRouterPort_get(rtk_enable_t *pEnabled)
+{
+    rtk_api_ret_t       retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (NULL == pEnabled)
+        return RT_ERR_NULL_POINTER;
+
+    if((retVal = rtl8367c_getAsicLutIpmcFwdRouterPort(pEnabled)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_ipMcastGroupEntry_add
+ * Description:
+ *      Add an IP Multicast entry to group table
+ * Input:
+ *      ip_addr     - IP address
+ *      vid         - VLAN ID
+ *      pPortmask   - portmask
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ *      RT_ERR_TBL_FULL    - Table Full
+ * Note:
+ *      Add an entry to IP Multicast Group table.
+ */
+rtk_api_ret_t rtk_l2_ipMcastGroupEntry_add(ipaddr_t ip_addr, rtk_uint32 vid, rtk_portmask_t *pPortmask)
+{
+    rtk_uint32      empty_idx = 0xFFFF;
+    rtk_int32       index;
+    ipaddr_t        group_addr;
+    rtk_uint32      group_vid;
+    rtk_uint32      pmask;
+    rtk_uint32      valid;
+    rtk_uint32      physicalPortmask;
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (vid > RTL8367C_VIDMAX)
+        return RT_ERR_L2_VID;
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    if((ip_addr & 0xF0000000) != 0xE0000000)
+        return RT_ERR_INPUT;
+
+    /* Get Physical port mask */
+    if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &physicalPortmask))!=RT_ERR_OK)
+        return retVal;
+
+    for(index = 0; index <= RTL8367C_LUT_IPMCGRP_TABLE_MAX; index++)
+    {
+        if ((retVal = rtl8367c_getAsicLutIPMCGroup((rtk_uint32)index, &group_addr, &group_vid, &pmask, &valid))!=RT_ERR_OK)
+            return retVal;
+
+        if( (valid == ENABLED) && (group_addr == ip_addr) && (group_vid == vid) )
+        {
+            if(pmask != physicalPortmask)
+            {
+                pmask = physicalPortmask;
+                if ((retVal = rtl8367c_setAsicLutIPMCGroup(index, ip_addr, vid, pmask, valid))!=RT_ERR_OK)
+                    return retVal;
+            }
+
+            return RT_ERR_OK;
+        }
+
+        if( (valid == DISABLED) && (empty_idx == 0xFFFF) ) /* Unused */
+            empty_idx = (rtk_uint32)index;
+    }
+
+    if(empty_idx == 0xFFFF)
+        return RT_ERR_TBL_FULL;
+
+    pmask = physicalPortmask;
+    if ((retVal = rtl8367c_setAsicLutIPMCGroup(empty_idx, ip_addr, vid, pmask, ENABLED))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_l2_ipMcastGroupEntry_del
+ * Description:
+ *      Delete an entry from IP Multicast group table
+ * Input:
+ *      ip_addr     - IP address
+ *      vid         - VLAN ID
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ *      RT_ERR_TBL_FULL    - Table Full
+ * Note:
+ *      Delete an entry from IP Multicast group table.
+ */
+rtk_api_ret_t rtk_l2_ipMcastGroupEntry_del(ipaddr_t ip_addr, rtk_uint32 vid)
+{
+    rtk_int32       index;
+    ipaddr_t        group_addr;
+    rtk_uint32      group_vid;
+    rtk_uint32      pmask;
+    rtk_uint32      valid;
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (vid > RTL8367C_VIDMAX)
+        return RT_ERR_L2_VID;
+
+    if((ip_addr & 0xF0000000) != 0xE0000000)
+        return RT_ERR_INPUT;
+
+    for(index = 0; index <= RTL8367C_LUT_IPMCGRP_TABLE_MAX; index++)
+    {
+        if ((retVal = rtl8367c_getAsicLutIPMCGroup((rtk_uint32)index, &group_addr, &group_vid, &pmask, &valid))!=RT_ERR_OK)
+            return retVal;
+
+        if( (valid == ENABLED) && (group_addr == ip_addr) && (group_vid == vid) )
+        {
+            group_addr = 0xE0000000;
+            group_vid = 0;
+            pmask = 0;
+            if ((retVal = rtl8367c_setAsicLutIPMCGroup(index, group_addr, group_vid, pmask, DISABLED))!=RT_ERR_OK)
+                return retVal;
+
+            return RT_ERR_OK;
+        }
+    }
+
+    return RT_ERR_FAILED;
+}
+
+/* Function Name:
+ *      rtk_l2_ipMcastGroupEntry_get
+ * Description:
+ *      get an entry from IP Multicast group table
+ * Input:
+ *      ip_addr     - IP address
+ *      vid         - VLAN ID
+ * Output:
+ *      pPortmask   - member port mask
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ *      RT_ERR_TBL_FULL    - Table Full
+ * Note:
+ *      Delete an entry from IP Multicast group table.
+ */
+rtk_api_ret_t rtk_l2_ipMcastGroupEntry_get(ipaddr_t ip_addr, rtk_uint32 vid, rtk_portmask_t *pPortmask)
+{
+    rtk_int32       index;
+    ipaddr_t        group_addr;
+    rtk_uint32      group_vid;
+    rtk_uint32      valid;
+    rtk_uint32      pmask;
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if((ip_addr & 0xF0000000) != 0xE0000000)
+        return RT_ERR_INPUT;
+
+    if (vid > RTL8367C_VIDMAX)
+        return RT_ERR_L2_VID;
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    for(index = 0; index <= RTL8367C_LUT_IPMCGRP_TABLE_MAX; index++)
+    {
+        if ((retVal = rtl8367c_getAsicLutIPMCGroup((rtk_uint32)index, &group_addr, &group_vid, &pmask, &valid))!=RT_ERR_OK)
+            return retVal;
+
+        if( (valid == ENABLED) && (group_addr == ip_addr) && (group_vid == vid) )
+        {
+            if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask))!=RT_ERR_OK)
+                return retVal;
+
+            return RT_ERR_OK;
+        }
+    }
+
+    return RT_ERR_FAILED;
+}
+
+/* Function Name:
+ *      rtk_l2_entry_get
+ * Description:
+ *      Get LUT unicast entry.
+ * Input:
+ *      pL2_entry - Index field in the structure.
+ * Output:
+ *      pL2_entry - other fields such as MAC, port, age...
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_L2_EMPTY_ENTRY   - Empty LUT entry.
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ * Note:
+ *      This API is used to get address by index from 0~2111.
+ */
+rtk_api_ret_t rtk_l2_entry_get(rtk_l2_addr_table_t *pL2_entry)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 method;
+    rtl8367c_luttb l2Table;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (pL2_entry->index >= rtk_switch_maxLutAddrNumber_get())
+        return RT_ERR_INPUT;
+
+    memset(&l2Table, 0x00, sizeof(rtl8367c_luttb));
+    l2Table.address= pL2_entry->index;
+    method = LUTREADMETHOD_ADDRESS;
+    if ((retVal = rtl8367c_getAsicL2LookupTb(method, &l2Table)) != RT_ERR_OK)
+        return retVal;
+
+    if ((pL2_entry->index>0x800)&&(l2Table.lookup_hit==0))
+         return RT_ERR_L2_EMPTY_ENTRY;
+
+    if(l2Table.l3lookup)
+    {
+        if(l2Table.l3vidlookup)
+        {
+            memset(&pL2_entry->mac, 0, sizeof(rtk_mac_t));
+            pL2_entry->is_ipmul  = l2Table.l3lookup;
+            pL2_entry->sip       = l2Table.sip;
+            pL2_entry->dip       = l2Table.dip;
+            pL2_entry->is_static = l2Table.nosalearn;
+
+            /* Get Logical port mask */
+            if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &(pL2_entry->portmask)))!=RT_ERR_OK)
+                return retVal;
+
+            pL2_entry->fid       = 0;
+            pL2_entry->age       = 0;
+            pL2_entry->auth      = 0;
+            pL2_entry->sa_block  = 0;
+            pL2_entry->is_ipvidmul = 1;
+            pL2_entry->l3_vid      = l2Table.l3_vid;
+        }
+        else
+        {
+            memset(&pL2_entry->mac, 0, sizeof(rtk_mac_t));
+            pL2_entry->is_ipmul  = l2Table.l3lookup;
+            pL2_entry->sip       = l2Table.sip;
+            pL2_entry->dip       = l2Table.dip;
+            pL2_entry->is_static = l2Table.nosalearn;
+
+            /* Get Logical port mask */
+            if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &(pL2_entry->portmask)))!=RT_ERR_OK)
+                return retVal;
+
+            pL2_entry->fid       = 0;
+            pL2_entry->age       = 0;
+            pL2_entry->auth      = 0;
+            pL2_entry->sa_block  = 0;
+            pL2_entry->is_ipvidmul = 0;
+            pL2_entry->l3_vid      = 0;
+        }
+    }
+    else if(l2Table.mac.octet[0]&0x01)
+    {
+        memset(&pL2_entry->sip, 0, sizeof(ipaddr_t));
+        memset(&pL2_entry->dip, 0, sizeof(ipaddr_t));
+        pL2_entry->mac.octet[0] = l2Table.mac.octet[0];
+        pL2_entry->mac.octet[1] = l2Table.mac.octet[1];
+        pL2_entry->mac.octet[2] = l2Table.mac.octet[2];
+        pL2_entry->mac.octet[3] = l2Table.mac.octet[3];
+        pL2_entry->mac.octet[4] = l2Table.mac.octet[4];
+        pL2_entry->mac.octet[5] = l2Table.mac.octet[5];
+        pL2_entry->is_ipmul  = l2Table.l3lookup;
+        pL2_entry->is_static = l2Table.nosalearn;
+
+        /* Get Logical port mask */
+        if ((retVal = rtk_switch_portmask_P2L_get(l2Table.mbr, &(pL2_entry->portmask)))!=RT_ERR_OK)
+            return retVal;
+
+        pL2_entry->ivl       = l2Table.ivl_svl;
+        if(l2Table.ivl_svl == 1) /* IVL */
+        {
+            pL2_entry->cvid      = l2Table.cvid_fid;
+            pL2_entry->fid       = 0;
+        }
+        else /* SVL*/
+        {
+            pL2_entry->cvid      = 0;
+            pL2_entry->fid       = l2Table.cvid_fid;
+        }
+        pL2_entry->auth      = l2Table.auth;
+        pL2_entry->sa_block  = l2Table.sa_block;
+        pL2_entry->age       = 0;
+        pL2_entry->is_ipvidmul = 0;
+        pL2_entry->l3_vid      = 0;
+    }
+    else if((l2Table.age != 0)||(l2Table.nosalearn == 1))
+    {
+        memset(&pL2_entry->sip, 0, sizeof(ipaddr_t));
+        memset(&pL2_entry->dip, 0, sizeof(ipaddr_t));
+        pL2_entry->mac.octet[0] = l2Table.mac.octet[0];
+        pL2_entry->mac.octet[1] = l2Table.mac.octet[1];
+        pL2_entry->mac.octet[2] = l2Table.mac.octet[2];
+        pL2_entry->mac.octet[3] = l2Table.mac.octet[3];
+        pL2_entry->mac.octet[4] = l2Table.mac.octet[4];
+        pL2_entry->mac.octet[5] = l2Table.mac.octet[5];
+        pL2_entry->is_ipmul  = l2Table.l3lookup;
+        pL2_entry->is_static = l2Table.nosalearn;
+
+        /* Get Logical port mask */
+        if ((retVal = rtk_switch_portmask_P2L_get(1<<(l2Table.spa), &(pL2_entry->portmask)))!=RT_ERR_OK)
+            return retVal;
+
+        pL2_entry->ivl       = l2Table.ivl_svl;
+        pL2_entry->cvid      = l2Table.cvid_fid;
+        pL2_entry->fid       = l2Table.fid;
+        pL2_entry->auth      = l2Table.auth;
+        pL2_entry->sa_block  = l2Table.sa_block;
+        pL2_entry->age       = l2Table.age;
+        pL2_entry->is_ipvidmul = 0;
+        pL2_entry->l3_vid      = 0;
+    }
+    else
+       return RT_ERR_L2_EMPTY_ENTRY;
+
+    return RT_ERR_OK;
+}
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/leaky.c b/drivers/net/phy/rtk/rtl8367c/leaky.c
new file mode 100644
index 0000000000000..da5a17f16da39
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/leaky.c
@@ -0,0 +1,590 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in Leaky module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <leaky.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_portIsolation.h>
+#include <rtl8367c_asicdrv_rma.h>
+#include <rtl8367c_asicdrv_igmp.h>
+
+
+/* Function Name:
+ *      rtk_leaky_vlan_set
+ * Description:
+ *      Set VLAN leaky.
+ * Input:
+ *      type - Packet type for VLAN leaky.
+ *      enable - Leaky status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      This API can set VLAN leaky for RMA ,IGMP/MLD, CDP, CSSTP, and LLDP packets.
+ *      The leaky frame types are as following:
+ *      - LEAKY_BRG_GROUP,
+ *      - LEAKY_FD_PAUSE,
+ *      - LEAKY_SP_MCAST,
+ *      - LEAKY_1X_PAE,
+ *      - LEAKY_UNDEF_BRG_04,
+ *      - LEAKY_UNDEF_BRG_05,
+ *      - LEAKY_UNDEF_BRG_06,
+ *      - LEAKY_UNDEF_BRG_07,
+ *      - LEAKY_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - LEAKY_UNDEF_BRG_09,
+ *      - LEAKY_UNDEF_BRG_0A,
+ *      - LEAKY_UNDEF_BRG_0B,
+ *      - LEAKY_UNDEF_BRG_0C,
+ *      - LEAKY_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - LEAKY_8021AB,
+ *      - LEAKY_UNDEF_BRG_0F,
+ *      - LEAKY_BRG_MNGEMENT,
+ *      - LEAKY_UNDEFINED_11,
+ *      - LEAKY_UNDEFINED_12,
+ *      - LEAKY_UNDEFINED_13,
+ *      - LEAKY_UNDEFINED_14,
+ *      - LEAKY_UNDEFINED_15,
+ *      - LEAKY_UNDEFINED_16,
+ *      - LEAKY_UNDEFINED_17,
+ *      - LEAKY_UNDEFINED_18,
+ *      - LEAKY_UNDEFINED_19,
+ *      - LEAKY_UNDEFINED_1A,
+ *      - LEAKY_UNDEFINED_1B,
+ *      - LEAKY_UNDEFINED_1C,
+ *      - LEAKY_UNDEFINED_1D,
+ *      - LEAKY_UNDEFINED_1E,
+ *      - LEAKY_UNDEFINED_1F,
+ *      - LEAKY_GMRP,
+ *      - LEAKY_GVRP,
+ *      - LEAKY_UNDEF_GARP_22,
+ *      - LEAKY_UNDEF_GARP_23,
+ *      - LEAKY_UNDEF_GARP_24,
+ *      - LEAKY_UNDEF_GARP_25,
+ *      - LEAKY_UNDEF_GARP_26,
+ *      - LEAKY_UNDEF_GARP_27,
+ *      - LEAKY_UNDEF_GARP_28,
+ *      - LEAKY_UNDEF_GARP_29,
+ *      - LEAKY_UNDEF_GARP_2A,
+ *      - LEAKY_UNDEF_GARP_2B,
+ *      - LEAKY_UNDEF_GARP_2C,
+ *      - LEAKY_UNDEF_GARP_2D,
+ *      - LEAKY_UNDEF_GARP_2E,
+ *      - LEAKY_UNDEF_GARP_2F,
+ *      - LEAKY_IGMP,
+ *      - LEAKY_IPMULTICAST.
+ *      - LEAKY_CDP,
+ *      - LEAKY_CSSTP,
+ *      - LEAKY_LLDP.
+ */
+rtk_api_ret_t rtk_leaky_vlan_set(rtk_leaky_type_t type, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 port;
+    rtl8367c_rma_t rmacfg;
+    rtk_uint32 tmp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= LEAKY_END)
+        return RT_ERR_INPUT;
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (type >= 0 && type <= LEAKY_UNDEF_GARP_2F)
+    {
+        if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.vlan_leaky = enable;
+
+        if ((retVal = rtl8367c_setAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (LEAKY_IPMULTICAST == type)
+    {
+        for (port = 0; port <= RTK_PORT_ID_MAX; port++)
+        {
+            if ((retVal = rtl8367c_setAsicIpMulticastVlanLeaky(port,enable)) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+    else if (LEAKY_IGMP == type)
+    {
+        if ((retVal = rtl8367c_setAsicIGMPVLANLeaky(enable)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (LEAKY_CDP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.vlan_leaky = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (LEAKY_CSSTP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.vlan_leaky = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (LEAKY_LLDP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaLldp(&tmp,&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.vlan_leaky = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaLldp(tmp, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_leaky_vlan_get
+ * Description:
+ *      Get VLAN leaky.
+ * Input:
+ *      type - Packet type for VLAN leaky.
+ * Output:
+ *      pEnable - Leaky status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get VLAN leaky status for RMA ,IGMP/MLD, CDP, CSSTP, and LLDP  packets.
+ *      The leaky frame types are as following:
+ *      - LEAKY_BRG_GROUP,
+ *      - LEAKY_FD_PAUSE,
+ *      - LEAKY_SP_MCAST,
+ *      - LEAKY_1X_PAE,
+ *      - LEAKY_UNDEF_BRG_04,
+ *      - LEAKY_UNDEF_BRG_05,
+ *      - LEAKY_UNDEF_BRG_06,
+ *      - LEAKY_UNDEF_BRG_07,
+ *      - LEAKY_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - LEAKY_UNDEF_BRG_09,
+ *      - LEAKY_UNDEF_BRG_0A,
+ *      - LEAKY_UNDEF_BRG_0B,
+ *      - LEAKY_UNDEF_BRG_0C,
+ *      - LEAKY_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - LEAKY_8021AB,
+ *      - LEAKY_UNDEF_BRG_0F,
+ *      - LEAKY_BRG_MNGEMENT,
+ *      - LEAKY_UNDEFINED_11,
+ *      - LEAKY_UNDEFINED_12,
+ *      - LEAKY_UNDEFINED_13,
+ *      - LEAKY_UNDEFINED_14,
+ *      - LEAKY_UNDEFINED_15,
+ *      - LEAKY_UNDEFINED_16,
+ *      - LEAKY_UNDEFINED_17,
+ *      - LEAKY_UNDEFINED_18,
+ *      - LEAKY_UNDEFINED_19,
+ *      - LEAKY_UNDEFINED_1A,
+ *      - LEAKY_UNDEFINED_1B,
+ *      - LEAKY_UNDEFINED_1C,
+ *      - LEAKY_UNDEFINED_1D,
+ *      - LEAKY_UNDEFINED_1E,
+ *      - LEAKY_UNDEFINED_1F,
+ *      - LEAKY_GMRP,
+ *      - LEAKY_GVRP,
+ *      - LEAKY_UNDEF_GARP_22,
+ *      - LEAKY_UNDEF_GARP_23,
+ *      - LEAKY_UNDEF_GARP_24,
+ *      - LEAKY_UNDEF_GARP_25,
+ *      - LEAKY_UNDEF_GARP_26,
+ *      - LEAKY_UNDEF_GARP_27,
+ *      - LEAKY_UNDEF_GARP_28,
+ *      - LEAKY_UNDEF_GARP_29,
+ *      - LEAKY_UNDEF_GARP_2A,
+ *      - LEAKY_UNDEF_GARP_2B,
+ *      - LEAKY_UNDEF_GARP_2C,
+ *      - LEAKY_UNDEF_GARP_2D,
+ *      - LEAKY_UNDEF_GARP_2E,
+ *      - LEAKY_UNDEF_GARP_2F,
+ *      - LEAKY_IGMP,
+ *      - LEAKY_IPMULTICAST.
+ *      - LEAKY_CDP,
+ *      - LEAKY_CSSTP,
+ *      - LEAKY_LLDP.
+ */
+rtk_api_ret_t rtk_leaky_vlan_get(rtk_leaky_type_t type, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 port,tmp;
+    rtl8367c_rma_t rmacfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= LEAKY_END)
+        return RT_ERR_INPUT;
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if (type >= 0 && type <= LEAKY_UNDEF_GARP_2F)
+    {
+        if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.vlan_leaky;
+
+    }
+    else if (LEAKY_IPMULTICAST == type)
+    {
+        for (port = 0; port <= RTK_PORT_ID_MAX; port++)
+        {
+            if ((retVal = rtl8367c_getAsicIpMulticastVlanLeaky(port, &tmp)) != RT_ERR_OK)
+                return retVal;
+            if (port>0&&(tmp!=*pEnable))
+                return RT_ERR_FAILED;
+            *pEnable = tmp;
+        }
+    }
+    else if (LEAKY_IGMP == type)
+    {
+        if ((retVal = rtl8367c_getAsicIGMPVLANLeaky(&tmp)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = tmp;
+    }
+    else if (LEAKY_CDP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.vlan_leaky;
+    }
+    else if (LEAKY_CSSTP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.vlan_leaky;
+    }
+    else if (LEAKY_LLDP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.vlan_leaky;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_leaky_portIsolation_set
+ * Description:
+ *      Set port isolation leaky.
+ * Input:
+ *      type - Packet type for port isolation leaky.
+ *      enable - Leaky status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      This API can set port isolation leaky for RMA ,IGMP/MLD, CDP, CSSTP, and LLDP  packets.
+ *      The leaky frame types are as following:
+ *      - LEAKY_BRG_GROUP,
+ *      - LEAKY_FD_PAUSE,
+ *      - LEAKY_SP_MCAST,
+ *      - LEAKY_1X_PAE,
+ *      - LEAKY_UNDEF_BRG_04,
+ *      - LEAKY_UNDEF_BRG_05,
+ *      - LEAKY_UNDEF_BRG_06,
+ *      - LEAKY_UNDEF_BRG_07,
+ *      - LEAKY_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - LEAKY_UNDEF_BRG_09,
+ *      - LEAKY_UNDEF_BRG_0A,
+ *      - LEAKY_UNDEF_BRG_0B,
+ *      - LEAKY_UNDEF_BRG_0C,
+ *      - LEAKY_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - LEAKY_8021AB,
+ *      - LEAKY_UNDEF_BRG_0F,
+ *      - LEAKY_BRG_MNGEMENT,
+ *      - LEAKY_UNDEFINED_11,
+ *      - LEAKY_UNDEFINED_12,
+ *      - LEAKY_UNDEFINED_13,
+ *      - LEAKY_UNDEFINED_14,
+ *      - LEAKY_UNDEFINED_15,
+ *      - LEAKY_UNDEFINED_16,
+ *      - LEAKY_UNDEFINED_17,
+ *      - LEAKY_UNDEFINED_18,
+ *      - LEAKY_UNDEFINED_19,
+ *      - LEAKY_UNDEFINED_1A,
+ *      - LEAKY_UNDEFINED_1B,
+ *      - LEAKY_UNDEFINED_1C,
+ *      - LEAKY_UNDEFINED_1D,
+ *      - LEAKY_UNDEFINED_1E,
+ *      - LEAKY_UNDEFINED_1F,
+ *      - LEAKY_GMRP,
+ *      - LEAKY_GVRP,
+ *      - LEAKY_UNDEF_GARP_22,
+ *      - LEAKY_UNDEF_GARP_23,
+ *      - LEAKY_UNDEF_GARP_24,
+ *      - LEAKY_UNDEF_GARP_25,
+ *      - LEAKY_UNDEF_GARP_26,
+ *      - LEAKY_UNDEF_GARP_27,
+ *      - LEAKY_UNDEF_GARP_28,
+ *      - LEAKY_UNDEF_GARP_29,
+ *      - LEAKY_UNDEF_GARP_2A,
+ *      - LEAKY_UNDEF_GARP_2B,
+ *      - LEAKY_UNDEF_GARP_2C,
+ *      - LEAKY_UNDEF_GARP_2D,
+ *      - LEAKY_UNDEF_GARP_2E,
+ *      - LEAKY_UNDEF_GARP_2F,
+ *      - LEAKY_IGMP,
+ *      - LEAKY_IPMULTICAST.
+ *      - LEAKY_CDP,
+ *      - LEAKY_CSSTP,
+ *      - LEAKY_LLDP.
+ */
+rtk_api_ret_t rtk_leaky_portIsolation_set(rtk_leaky_type_t type, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 port;
+    rtl8367c_rma_t rmacfg;
+    rtk_uint32 tmp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= LEAKY_END)
+        return RT_ERR_INPUT;
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (type >= 0 && type <= LEAKY_UNDEF_GARP_2F)
+    {
+        if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.portiso_leaky = enable;
+
+        if ((retVal = rtl8367c_setAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (LEAKY_IPMULTICAST == type)
+    {
+        for (port = 0; port < RTK_MAX_NUM_OF_PORT; port++)
+        {
+            if ((retVal = rtl8367c_setAsicIpMulticastPortIsoLeaky(port,enable)) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+    else if (LEAKY_IGMP == type)
+    {
+        if ((retVal = rtl8367c_setAsicIGMPIsoLeaky(enable)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (LEAKY_CDP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.portiso_leaky = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (LEAKY_CSSTP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.portiso_leaky = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (LEAKY_LLDP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.portiso_leaky = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaLldp(tmp, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_leaky_portIsolation_get
+ * Description:
+ *      Get port isolation leaky.
+ * Input:
+ *      type - Packet type for port isolation leaky.
+ * Output:
+ *      pEnable - Leaky status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get port isolation leaky status for RMA ,IGMP/MLD, CDP, CSSTP, and LLDP  packets.
+ *      The leaky frame types are as following:
+ *      - LEAKY_BRG_GROUP,
+ *      - LEAKY_FD_PAUSE,
+ *      - LEAKY_SP_MCAST,
+ *      - LEAKY_1X_PAE,
+ *      - LEAKY_UNDEF_BRG_04,
+ *      - LEAKY_UNDEF_BRG_05,
+ *      - LEAKY_UNDEF_BRG_06,
+ *      - LEAKY_UNDEF_BRG_07,
+ *      - LEAKY_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - LEAKY_UNDEF_BRG_09,
+ *      - LEAKY_UNDEF_BRG_0A,
+ *      - LEAKY_UNDEF_BRG_0B,
+ *      - LEAKY_UNDEF_BRG_0C,
+ *      - LEAKY_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - LEAKY_8021AB,
+ *      - LEAKY_UNDEF_BRG_0F,
+ *      - LEAKY_BRG_MNGEMENT,
+ *      - LEAKY_UNDEFINED_11,
+ *      - LEAKY_UNDEFINED_12,
+ *      - LEAKY_UNDEFINED_13,
+ *      - LEAKY_UNDEFINED_14,
+ *      - LEAKY_UNDEFINED_15,
+ *      - LEAKY_UNDEFINED_16,
+ *      - LEAKY_UNDEFINED_17,
+ *      - LEAKY_UNDEFINED_18,
+ *      - LEAKY_UNDEFINED_19,
+ *      - LEAKY_UNDEFINED_1A,
+ *      - LEAKY_UNDEFINED_1B,
+ *      - LEAKY_UNDEFINED_1C,
+ *      - LEAKY_UNDEFINED_1D,
+ *      - LEAKY_UNDEFINED_1E,
+ *      - LEAKY_UNDEFINED_1F,
+ *      - LEAKY_GMRP,
+ *      - LEAKY_GVRP,
+ *      - LEAKY_UNDEF_GARP_22,
+ *      - LEAKY_UNDEF_GARP_23,
+ *      - LEAKY_UNDEF_GARP_24,
+ *      - LEAKY_UNDEF_GARP_25,
+ *      - LEAKY_UNDEF_GARP_26,
+ *      - LEAKY_UNDEF_GARP_27,
+ *      - LEAKY_UNDEF_GARP_28,
+ *      - LEAKY_UNDEF_GARP_29,
+ *      - LEAKY_UNDEF_GARP_2A,
+ *      - LEAKY_UNDEF_GARP_2B,
+ *      - LEAKY_UNDEF_GARP_2C,
+ *      - LEAKY_UNDEF_GARP_2D,
+ *      - LEAKY_UNDEF_GARP_2E,
+ *      - LEAKY_UNDEF_GARP_2F,
+ *      - LEAKY_IGMP,
+ *      - LEAKY_IPMULTICAST.
+ *      - LEAKY_CDP,
+ *      - LEAKY_CSSTP,
+ *      - LEAKY_LLDP.
+ */
+rtk_api_ret_t rtk_leaky_portIsolation_get(rtk_leaky_type_t type, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 port, tmp;
+    rtl8367c_rma_t rmacfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= LEAKY_END)
+        return RT_ERR_INPUT;
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if (type >= 0 && type <= LEAKY_UNDEF_GARP_2F)
+    {
+        if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.portiso_leaky;
+
+    }
+    else if (LEAKY_IPMULTICAST == type)
+    {
+        for (port = 0; port < RTK_MAX_NUM_OF_PORT; port++)
+        {
+            if ((retVal = rtl8367c_getAsicIpMulticastPortIsoLeaky(port, &tmp)) != RT_ERR_OK)
+                return retVal;
+            if (port > 0 &&(tmp != *pEnable))
+                return RT_ERR_FAILED;
+            *pEnable = tmp;
+        }
+    }
+    else if (LEAKY_IGMP == type)
+    {
+        if ((retVal = rtl8367c_getAsicIGMPIsoLeaky(&tmp)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = tmp;
+    }
+    else if (LEAKY_CDP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.portiso_leaky;
+    }
+    else if (LEAKY_CSSTP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.portiso_leaky;
+    }
+    else if (LEAKY_LLDP == type)
+    {
+        if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.portiso_leaky;
+    }
+
+
+    return RT_ERR_OK;
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/led.c b/drivers/net/phy/rtk/rtl8367c/led.c
new file mode 100644
index 0000000000000..c37c0e7086292
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/led.c
@@ -0,0 +1,792 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in LED module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <led.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_led.h>
+
+
+/* Function Name:
+ *      rtk_led_enable_set
+ * Description:
+ *      Set Led enable congiuration
+ * Input:
+ *      group       - LED group id.
+ *      pPortmask   - LED enable port mask.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_MASK    - Error portmask
+ * Note:
+ *      The API can be used to enable LED per port per group.
+ */
+rtk_api_ret_t rtk_led_enable_set(rtk_led_group_t group, rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+    rtk_port_t port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (group >= LED_GROUP_END)
+        return RT_ERR_INPUT;
+
+    RTK_CHK_PORTMASK_VALID(pPortmask);
+
+    RTK_PORTMASK_SCAN((*pPortmask), port)
+    {
+        if(rtk_switch_isCPUPort(port) == RT_ERR_OK)
+            return RT_ERR_PORT_MASK;
+    }
+
+    if((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicLedGroupEnable(group, pmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_enable_get
+ * Description:
+ *      Get Led enable congiuration
+ * Input:
+ *      group - LED group id.
+ * Output:
+ *      pPortmask - LED enable port mask.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can be used to get LED enable status.
+ */
+rtk_api_ret_t rtk_led_enable_get(rtk_led_group_t group, rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (group >= LED_GROUP_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_getAsicLedGroupEnable(group, &pmask)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtk_led_operation_set
+ * Description:
+ *      Set Led operation mode
+ * Input:
+ *      mode - LED operation mode.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can set Led operation mode.
+ *      The modes that can be set are as following:
+ *      - LED_OP_SCAN,
+ *      - LED_OP_PARALLEL,
+ *      - LED_OP_SERIAL,
+ */
+rtk_api_ret_t rtk_led_operation_set(rtk_led_operation_t mode)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ( mode >= LED_OP_END)
+      return RT_ERR_INPUT;
+
+    switch (mode)
+    {
+        case LED_OP_PARALLEL:
+            regData = LEDOP_PARALLEL;
+            break;
+        case LED_OP_SERIAL:
+            regData = LEDOP_SERIAL;
+            break;
+        default:
+            return RT_ERR_CHIP_NOT_SUPPORTED;
+            break;
+    }
+
+    if ((retVal = rtl8367c_setAsicLedOperationMode(regData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_operation_get
+ * Description:
+ *      Get Led operation mode
+ * Input:
+ *      None
+ * Output:
+ *      pMode - Support LED operation mode.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get Led operation mode.
+ *      The modes that can be set are as following:
+ *      - LED_OP_SCAN,
+ *      - LED_OP_PARALLEL,
+ *      - LED_OP_SERIAL,
+ */
+rtk_api_ret_t rtk_led_operation_get(rtk_led_operation_t *pMode)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pMode)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLedOperationMode(&regData)) != RT_ERR_OK)
+        return retVal;
+
+    if (regData == LEDOP_SERIAL)
+        *pMode = LED_OP_SERIAL;
+    else if (regData ==LEDOP_PARALLEL)
+        *pMode = LED_OP_PARALLEL;
+    else
+       return RT_ERR_FAILED;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_modeForce_set
+ * Description:
+ *      Set Led group to congiuration force mode
+ * Input:
+ *      port    - port ID
+ *      group   - Support LED group id.
+ *      mode    - Support LED force mode.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Error Port ID
+ * Note:
+ *      The API can force to one force mode.
+ *      The force modes that can be set are as following:
+ *      - LED_FORCE_NORMAL,
+ *      - LED_FORCE_BLINK,
+ *      - LED_FORCE_OFF,
+ *      - LED_FORCE_ON.
+ */
+rtk_api_ret_t rtk_led_modeForce_set(rtk_port_t port, rtk_led_group_t group, rtk_led_force_mode_t mode)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    /* No LED for CPU port */
+    if(rtk_switch_isCPUPort(port) == RT_ERR_OK)
+        return RT_ERR_PORT_ID;
+
+    if (group >= LED_GROUP_END)
+        return RT_ERR_INPUT;
+
+    if (mode >= LED_FORCE_END)
+        return RT_ERR_NOT_ALLOWED;
+
+    if ((retVal = rtl8367c_setAsicForceLed(rtk_switch_port_L2P_get(port), group, mode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_modeForce_get
+ * Description:
+ *      Get Led group to congiuration force mode
+ * Input:
+ *      port  - port ID
+ *      group - Support LED group id.
+ *      pMode - Support LED force mode.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Error Port ID
+ * Note:
+ *      The API can get forced Led group mode.
+ *      The force modes that can be set are as following:
+ *      - LED_FORCE_NORMAL,
+ *      - LED_FORCE_BLINK,
+ *      - LED_FORCE_OFF,
+ *      - LED_FORCE_ON.
+ */
+rtk_api_ret_t rtk_led_modeForce_get(rtk_port_t port, rtk_led_group_t group, rtk_led_force_mode_t *pMode)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    /* No LED for CPU port */
+    if(rtk_switch_isCPUPort(port) == RT_ERR_OK)
+        return RT_ERR_PORT_ID;
+
+    if (group >= LED_GROUP_END)
+        return RT_ERR_INPUT;
+
+    if (NULL == pMode)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicForceLed(rtk_switch_port_L2P_get(port), group, pMode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_blinkRate_set
+ * Description:
+ *      Set LED blinking rate
+ * Input:
+ *      blinkRate - blinking rate.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      ASIC support 6 types of LED blinking rates at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms.
+ */
+rtk_api_ret_t rtk_led_blinkRate_set(rtk_led_blink_rate_t blinkRate)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (blinkRate >= LED_BLINKRATE_END)
+        return RT_ERR_FAILED;
+
+    if ((retVal = rtl8367c_setAsicLedBlinkRate(blinkRate)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_blinkRate_get
+ * Description:
+ *      Get LED blinking rate at mode 0 to mode 3
+ * Input:
+ *      None
+ * Output:
+ *      pBlinkRate - blinking rate.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      There are  6 types of LED blinking rates at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms.
+ */
+rtk_api_ret_t rtk_led_blinkRate_get(rtk_led_blink_rate_t *pBlinkRate)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pBlinkRate)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLedBlinkRate(pBlinkRate)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_groupConfig_set
+ * Description:
+ *      Set per group Led to congiuration mode
+ * Input:
+ *      group   - LED group.
+ *      config  - LED configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can set LED indicated information configuration for each LED group with 1 to 1 led mapping to each port.
+ *      - Definition  LED Statuses      Description
+ *      - 0000        LED_Off           LED pin Tri-State.
+ *      - 0001        Dup/Col           Collision, Full duplex Indicator.
+ *      - 0010        Link/Act          Link, Activity Indicator.
+ *      - 0011        Spd1000           1000Mb/s Speed Indicator.
+ *      - 0100        Spd100            100Mb/s Speed Indicator.
+ *      - 0101        Spd10             10Mb/s Speed Indicator.
+ *      - 0110        Spd1000/Act       1000Mb/s Speed/Activity Indicator.
+ *      - 0111        Spd100/Act        100Mb/s Speed/Activity Indicator.
+ *      - 1000        Spd10/Act         10Mb/s Speed/Activity Indicator.
+ *      - 1001        Spd100 (10)/Act   10/100Mb/s Speed/Activity Indicator.
+ *      - 1010        LoopDetect        LoopDetect Indicator.
+ *      - 1011        EEE               EEE Indicator.
+ *      - 1100        Link/Rx           Link, Activity Indicator.
+ *      - 1101        Link/Tx           Link, Activity Indicator.
+ *      - 1110        Master            Link on Master Indicator.
+ *      - 1111        Act               Activity Indicator. Low for link established.
+ */
+rtk_api_ret_t rtk_led_groupConfig_set(rtk_led_group_t group, rtk_led_congig_t config)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (LED_GROUP_END <= group)
+        return RT_ERR_FAILED;
+
+    if (LED_CONFIG_END <= config)
+        return RT_ERR_FAILED;
+
+    if ((retVal = rtl8367c_setAsicLedIndicateInfoConfig(group, config)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_groupConfig_get
+ * Description:
+ *      Get Led group congiuration mode
+ * Input:
+ *      group - LED group.
+ * Output:
+ *      pConfig - LED configuration.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *       The API can get LED indicated information configuration for each LED group.
+ */
+rtk_api_ret_t rtk_led_groupConfig_get(rtk_led_group_t group, rtk_led_congig_t *pConfig)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (LED_GROUP_END <= group)
+        return RT_ERR_FAILED;
+
+    if(NULL == pConfig)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLedIndicateInfoConfig(group, pConfig)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_groupAbility_set
+ * Description:
+ *      Configure per group Led ability
+ * Input:
+ *      group    - LED group.
+ *      pAbility - LED ability
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      None.
+ */
+
+rtk_api_ret_t rtk_led_groupAbility_set(rtk_led_group_t group, rtk_led_ability_t *pAbility)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (LED_GROUP_END <= group)
+        return RT_ERR_FAILED;
+
+    if(pAbility == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if( (pAbility->link_10m >= RTK_ENABLE_END) || (pAbility->link_100m >= RTK_ENABLE_END)||
+        (pAbility->link_500m >= RTK_ENABLE_END) || (pAbility->link_1000m >= RTK_ENABLE_END)||
+        (pAbility->act_rx >= RTK_ENABLE_END) || (pAbility->act_tx >= RTK_ENABLE_END) )
+    {
+        return RT_ERR_INPUT;
+    }
+
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_LED0_DATA_CTRL + (rtk_uint32)group, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if(pAbility->link_10m == ENABLED)
+        regData |= 0x0001;
+    else
+        regData &= ~0x0001;
+
+    if(pAbility->link_100m == ENABLED)
+        regData |= 0x0002;
+    else
+        regData &= ~0x0002;
+
+    if(pAbility->link_500m == ENABLED)
+        regData |= 0x0004;
+    else
+        regData &= ~0x0004;
+
+    if(pAbility->link_1000m == ENABLED)
+        regData |= 0x0008;
+    else
+        regData &= ~0x0008;
+
+    if(pAbility->act_rx == ENABLED)
+        regData |= 0x0010;
+    else
+        regData &= ~0x0010;
+
+    if(pAbility->act_tx == ENABLED)
+        regData |= 0x0020;
+    else
+        regData &= ~0x0020;
+
+    regData |= (0x0001 << 6);
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_LED0_DATA_CTRL + (rtk_uint32)group, regData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_groupAbility_get
+ * Description:
+ *      Get per group Led ability
+ * Input:
+ *      group    - LED group.
+ *      pAbility - LED ability
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      None.
+ */
+
+rtk_api_ret_t rtk_led_groupAbility_get(rtk_led_group_t group, rtk_led_ability_t *pAbility)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (LED_GROUP_END <= group)
+        return RT_ERR_FAILED;
+
+    if(pAbility == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_LED0_DATA_CTRL + (rtk_uint32)group, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    pAbility->link_10m = (regData & 0x0001) ? ENABLED : DISABLED;
+    pAbility->link_100m = (regData & 0x0002) ? ENABLED : DISABLED;
+    pAbility->link_500m = (regData & 0x0004) ? ENABLED : DISABLED;
+    pAbility->link_1000m = (regData & 0x0008) ? ENABLED : DISABLED;
+    pAbility->act_rx = (regData & 0x0010) ? ENABLED : DISABLED;
+    pAbility->act_tx = (regData & 0x0020) ? ENABLED : DISABLED;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_led_serialMode_set
+ * Description:
+ *      Set Led serial mode active congiuration
+ * Input:
+ *      active - LED group.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can set LED serial mode active congiuration.
+ */
+rtk_api_ret_t rtk_led_serialMode_set(rtk_led_active_t active)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ( active >= LED_ACTIVE_END)
+        return RT_ERR_INPUT;
+
+     if ((retVal = rtl8367c_setAsicLedSerialModeConfig(active,1))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_serialMode_get
+ * Description:
+ *      Get Led group congiuration mode
+ * Input:
+ *      group - LED group.
+ * Output:
+ *      pConfig - LED configuration.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *       The API can get LED serial mode active configuration.
+ */
+rtk_api_ret_t rtk_led_serialMode_get(rtk_led_active_t *pActive)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pActive)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLedSerialModeConfig(pActive,&regData))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_OutputEnable_set
+ * Description:
+ *      This API set LED I/O state.
+ * Input:
+ *      enabled     - LED I/O state
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set LED I/O state.
+ */
+rtk_api_ret_t rtk_led_OutputEnable_set(rtk_enable_t state)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (state >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicLedOutputEnable(state))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_OutputEnable_get
+ * Description:
+ *      This API get LED I/O state.
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled        - LED I/O state
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set current LED I/O  state.
+ */
+rtk_api_ret_t rtk_led_OutputEnable_get(rtk_enable_t *pState)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(pState == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLedOutputEnable(pState))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtk_led_serialModePortmask_set
+ * Description:
+ *      This API configure Serial LED output Group and portmask
+ * Input:
+ *      output          - output group
+ *      pPortmask       - output portmask
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_led_serialModePortmask_set(rtk_led_serialOutput_t output, rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(output >= SERIAL_LED_END)
+        return RT_ERR_INPUT;
+
+    if(pPortmask == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicLedSerialOutput((rtk_uint32)output, pmask))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_led_serialModePortmask_get
+ * Description:
+ *      This API get Serial LED output Group and portmask
+ * Input:
+ *      None.
+ * Output:
+ *      pOutput         - output group
+ *      pPortmask       - output portmask
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_led_serialModePortmask_get(rtk_led_serialOutput_t *pOutput, rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(pOutput == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if(pPortmask == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicLedSerialOutput((rtk_uint32 *)pOutput, &pmask))!=RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/mirror.c b/drivers/net/phy/rtk/rtl8367c/mirror.c
new file mode 100644
index 0000000000000..cfb1a0722c981
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/mirror.c
@@ -0,0 +1,548 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in Mirror module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <mirror.h>
+#include <string.h>
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_mirror.h>
+
+/* Function Name:
+ *      rtk_mirror_portBased_set
+ * Description:
+ *      Set port mirror function.
+ * Input:
+ *      mirroring_port          - Monitor port.
+ *      pMirrored_rx_portmask   - Rx mirror port mask.
+ *      pMirrored_tx_portmask   - Tx mirror port mask.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_PORT_MASK    - Invalid portmask.
+ * Note:
+ *      The API is to set mirror function of source port and mirror port.
+ *      The mirror port can only be set to one port and the TX and RX mirror ports
+ *      should be identical.
+ */
+rtk_api_ret_t rtk_mirror_portBased_set(rtk_port_t mirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_enable_t mirRx, mirTx;
+    rtk_uint32 i, pmask;
+    rtk_port_t source_port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(mirroring_port);
+
+    if(NULL == pMirrored_rx_portmask)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pMirrored_tx_portmask)
+        return RT_ERR_NULL_POINTER;
+
+    RTK_CHK_PORTMASK_VALID(pMirrored_rx_portmask);
+
+    RTK_CHK_PORTMASK_VALID(pMirrored_tx_portmask);
+
+    /*Mirror Sorce Port Mask Check*/
+    if (pMirrored_tx_portmask->bits[0]!=pMirrored_rx_portmask->bits[0]&&pMirrored_tx_portmask->bits[0]!=0&&pMirrored_rx_portmask->bits[0]!=0)
+        return RT_ERR_PORT_MASK;
+
+     /*mirror port != source port*/
+    if(RTK_PORTMASK_IS_PORT_SET((*pMirrored_tx_portmask), mirroring_port) || RTK_PORTMASK_IS_PORT_SET((*pMirrored_rx_portmask), mirroring_port))
+        return RT_ERR_PORT_MASK;
+
+    source_port = rtk_switch_maxLogicalPort_get();
+
+    RTK_SCAN_ALL_LOG_PORT(i)
+    {
+        if (pMirrored_tx_portmask->bits[0]&(1<<i))
+        {
+            source_port = i;
+            break;
+        }
+
+        if (pMirrored_rx_portmask->bits[0]&(1<<i))
+        {
+            source_port = i;
+            break;
+        }
+    }
+
+    if ((retVal = rtl8367c_setAsicPortMirror(rtk_switch_port_L2P_get(source_port), rtk_switch_port_L2P_get(mirroring_port))) != RT_ERR_OK)
+        return retVal;
+    if(pMirrored_rx_portmask->bits[0] != 0)
+    {
+        if ((retVal = rtk_switch_portmask_L2P_get(pMirrored_rx_portmask, &pmask)) != RT_ERR_OK)
+            return retVal;
+        if ((retVal = rtl8367c_setAsicPortMirrorMask(pmask)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        if ((retVal = rtk_switch_portmask_L2P_get(pMirrored_tx_portmask, &pmask)) != RT_ERR_OK)
+            return retVal;
+        if ((retVal = rtl8367c_setAsicPortMirrorMask(pmask)) != RT_ERR_OK)
+            return retVal;
+    }
+
+
+    if (pMirrored_rx_portmask->bits[0])
+        mirRx = ENABLED;
+    else
+        mirRx = DISABLED;
+
+    if ((retVal = rtl8367c_setAsicPortMirrorRxFunction(mirRx)) != RT_ERR_OK)
+        return retVal;
+
+    if (pMirrored_tx_portmask->bits[0])
+        mirTx = ENABLED;
+    else
+        mirTx = DISABLED;
+
+    if ((retVal = rtl8367c_setAsicPortMirrorTxFunction(mirTx)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtk_mirror_portBased_get
+ * Description:
+ *      Get port mirror function.
+ * Input:
+ *      None
+ * Output:
+ *      pMirroring_port         - Monitor port.
+ *      pMirrored_rx_portmask   - Rx mirror port mask.
+ *      pMirrored_tx_portmask   - Tx mirror port mask.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API is to get mirror function of source port and mirror port.
+ */
+rtk_api_ret_t rtk_mirror_portBased_get(rtk_port_t *pMirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_port_t source_port;
+    rtk_enable_t mirRx, mirTx;
+    rtk_uint32 sport, mport, pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pMirrored_rx_portmask)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pMirrored_tx_portmask)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pMirroring_port)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortMirror(&sport, &mport)) != RT_ERR_OK)
+        return retVal;
+    source_port = rtk_switch_port_P2L_get(sport);
+    *pMirroring_port = rtk_switch_port_P2L_get(mport);
+
+    if ((retVal = rtl8367c_getAsicPortMirrorRxFunction((rtk_uint32*)&mirRx)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPortMirrorTxFunction((rtk_uint32*)&mirTx)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPortMirrorMask(&pmask)) != RT_ERR_OK)
+        return retVal;
+
+    if (DISABLED == mirRx)
+        pMirrored_rx_portmask->bits[0]=0;
+    else
+    {
+        if ((retVal = rtk_switch_portmask_P2L_get(pmask, pMirrored_rx_portmask)) != RT_ERR_OK)
+            return retVal;
+        pMirrored_rx_portmask->bits[0] |= 1<<source_port;
+    }
+
+     if (DISABLED == mirTx)
+        pMirrored_tx_portmask->bits[0]=0;
+    else
+    {
+        if ((retVal = rtk_switch_portmask_P2L_get(pmask, pMirrored_tx_portmask)) != RT_ERR_OK)
+            return retVal;
+        pMirrored_tx_portmask->bits[0] |= 1<<source_port;
+    }
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtk_mirror_portIso_set
+ * Description:
+ *      Set mirror port isolation.
+ * Input:
+ *      enable |Mirror isolation status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      The API is to set mirror isolation function that prevent normal forwarding packets to miror port.
+ */
+rtk_api_ret_t rtk_mirror_portIso_set(rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicPortMirrorIsolation(enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_mirror_portIso_get
+ * Description:
+ *      Get mirror port isolation.
+ * Input:
+ *      None
+ * Output:
+ *      pEnable |Mirror isolation status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API is to get mirror isolation status.
+ */
+rtk_api_ret_t rtk_mirror_portIso_get(rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortMirrorIsolation(pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_mirror_vlanLeaky_set
+ * Description:
+ *      Set mirror VLAN leaky.
+ * Input:
+ *      txenable -TX leaky enable.
+ *      rxenable - RX leaky enable.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      The API is to set mirror VLAN leaky function forwarding packets to miror port.
+ */
+rtk_api_ret_t rtk_mirror_vlanLeaky_set(rtk_enable_t txenable, rtk_enable_t rxenable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((txenable >= RTK_ENABLE_END) ||(rxenable >= RTK_ENABLE_END))
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicPortMirrorVlanTxLeaky(txenable)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPortMirrorVlanRxLeaky(rxenable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_mirror_vlanLeaky_get
+ * Description:
+ *      Get mirror VLAN leaky.
+ * Input:
+ *      None
+ * Output:
+ *      pTxenable - TX leaky enable.
+ *      pRxenable - RX leaky enable.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API is to get mirror VLAN leaky status.
+ */
+rtk_api_ret_t rtk_mirror_vlanLeaky_get(rtk_enable_t *pTxenable, rtk_enable_t *pRxenable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if( (NULL == pTxenable) || (NULL == pRxenable) )
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortMirrorVlanTxLeaky(pTxenable)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPortMirrorVlanRxLeaky(pRxenable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_mirror_isolationLeaky_set
+ * Description:
+ *      Set mirror Isolation leaky.
+ * Input:
+ *      txenable -TX leaky enable.
+ *      rxenable - RX leaky enable.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      The API is to set mirror VLAN leaky function forwarding packets to miror port.
+ */
+rtk_api_ret_t rtk_mirror_isolationLeaky_set(rtk_enable_t txenable, rtk_enable_t rxenable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((txenable >= RTK_ENABLE_END) ||(rxenable >= RTK_ENABLE_END))
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicPortMirrorIsolationTxLeaky(txenable)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPortMirrorIsolationRxLeaky(rxenable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_mirror_isolationLeaky_get
+ * Description:
+ *      Get mirror isolation leaky.
+ * Input:
+ *      None
+ * Output:
+ *      pTxenable - TX leaky enable.
+ *      pRxenable - RX leaky enable.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API is to get mirror isolation leaky status.
+ */
+rtk_api_ret_t rtk_mirror_isolationLeaky_get(rtk_enable_t *pTxenable, rtk_enable_t *pRxenable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if( (NULL == pTxenable) || (NULL == pRxenable) )
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortMirrorIsolationTxLeaky(pTxenable)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPortMirrorIsolationRxLeaky(pRxenable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_mirror_keep_set
+ * Description:
+ *      Set mirror packet format keep.
+ * Input:
+ *      mode - -mirror keep mode.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      The API is to set  -mirror keep mode.
+ *      The mirror keep mode is as following:
+ *      - MIRROR_FOLLOW_VLAN
+ *      - MIRROR_KEEP_ORIGINAL
+ *      - MIRROR_KEEP_END
+ */
+rtk_api_ret_t rtk_mirror_keep_set(rtk_mirror_keep_t mode)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (mode >= MIRROR_KEEP_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicPortMirrorRealKeep(mode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_mirror_keep_get
+ * Description:
+ *      Get mirror packet format keep.
+ * Input:
+ *      None
+ * Output:
+ *      pMode -mirror keep mode.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API is to get mirror keep mode.
+  *      The mirror keep mode is as following:
+ *      - MIRROR_FOLLOW_VLAN
+ *      - MIRROR_KEEP_ORIGINAL
+ *      - MIRROR_KEEP_END
+ */
+rtk_api_ret_t rtk_mirror_keep_get(rtk_mirror_keep_t *pMode)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pMode)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortMirrorRealKeep(pMode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_mirror_override_set
+ * Description:
+ *      Set port mirror override function.
+ * Input:
+ *      rxMirror        - 1: output mirrored packet, 0: output normal forward packet
+ *      txMirror        - 1: output mirrored packet, 0: output normal forward packet
+ *      aclMirror       - 1: output mirrored packet, 0: output normal forward packet
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      The API is to set mirror override function.
+ *      This function control the output format when a port output
+ *      normal forward & mirrored packet at the same time.
+ */
+rtk_api_ret_t rtk_mirror_override_set(rtk_enable_t rxMirror, rtk_enable_t txMirror, rtk_enable_t aclMirror)
+{
+    rtk_api_ret_t retVal;
+
+    if( (rxMirror >= RTK_ENABLE_END) || (txMirror >= RTK_ENABLE_END) || (aclMirror >= RTK_ENABLE_END))
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicPortMirrorOverride((rtk_uint32)rxMirror, (rtk_uint32)txMirror, (rtk_uint32)aclMirror)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_mirror_override_get
+ * Description:
+ *      Get port mirror override function.
+ * Input:
+ *      None
+ * Output:
+ *      pRxMirror       - 1: output mirrored packet, 0: output normal forward packet
+ *      pTxMirror       - 1: output mirrored packet, 0: output normal forward packet
+ *      pAclMirror      - 1: output mirrored packet, 0: output normal forward packet
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - Null Pointer
+ * Note:
+ *      The API is to Get mirror override function.
+ *      This function control the output format when a port output
+ *      normal forward & mirrored packet at the same time.
+ */
+rtk_api_ret_t rtk_mirror_override_get(rtk_enable_t *pRxMirror, rtk_enable_t *pTxMirror, rtk_enable_t *pAclMirror)
+{
+    rtk_api_ret_t retVal;
+
+    if( (pRxMirror == NULL) || (pTxMirror == NULL) || (pAclMirror == NULL))
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_getAsicPortMirrorOverride((rtk_uint32 *)pRxMirror, (rtk_uint32 *)pTxMirror, (rtk_uint32 *)pAclMirror)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/oam.c b/drivers/net/phy/rtk/rtl8367c/oam.c
new file mode 100644
index 0000000000000..7cde71bbfcbe2
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/oam.c
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in OAM(802.3ah)  module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <oam.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_oam.h>
+
+
+/* Module Name : OAM */
+
+/* Function Name:
+ *      rtk_oam_init
+ * Description:
+ *      Initialize oam module.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ * Note:
+ *      Must initialize oam module before calling any oam APIs.
+ */
+rtk_api_ret_t rtk_oam_init(void)
+{
+    return RT_ERR_OK;
+} /* end of rtk_oam_init */
+
+
+/* Function Name:
+ *      rtk_oam_state_set
+ * Description:
+ *      This API set OAM state.
+ * Input:
+ *      enabled     -OAMstate
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set OAM state.
+ */
+rtk_api_ret_t rtk_oam_state_set(rtk_enable_t enabled)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (enabled >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicOamEnable(enabled))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_oam_state_get
+ * Description:
+ *      This API get OAM state.
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled        - H/W IGMP state
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT           - Error parameter
+ * Note:
+ *      This API set current OAM state.
+ */
+rtk_api_ret_t rtk_oam_state_get(rtk_enable_t *pEnabled)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_getAsicOamEnable(pEnabled))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+
+/* Function Name:
+ *      rtk_oam_parserAction_set
+ * Description:
+ *      Set OAM parser action
+ * Input:
+ *      port    - port id
+ *      action  - parser action
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID      - invalid port id
+ * Note:
+ *      None
+ */
+rtk_api_ret_t  rtk_oam_parserAction_set(rtk_port_t port, rtk_oam_parser_act_t action)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (action >= OAM_PARSER_ACTION_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicOamParser(rtk_switch_port_L2P_get(port), action))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_oam_parserAction_set
+ * Description:
+ *      Get OAM parser action
+ * Input:
+ *      port    - port id
+ * Output:
+ *      pAction  - parser action
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID      - invalid port id
+ * Note:
+ *      None
+ */
+rtk_api_ret_t  rtk_oam_parserAction_get(rtk_port_t port, rtk_oam_parser_act_t *pAction)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicOamParser(rtk_switch_port_L2P_get(port), pAction))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_oam_multiplexerAction_set
+ * Description:
+ *      Set OAM multiplexer action
+ * Input:
+ *      port    - port id
+ *      action  - parser action
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID      - invalid port id
+ * Note:
+ *      None
+ */
+rtk_api_ret_t  rtk_oam_multiplexerAction_set(rtk_port_t port, rtk_oam_multiplexer_act_t action)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (action >= OAM_MULTIPLEXER_ACTION_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicOamMultiplexer(rtk_switch_port_L2P_get(port), action))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_oam_parserAction_set
+ * Description:
+ *      Get OAM multiplexer action
+ * Input:
+ *      port    - port id
+ * Output:
+ *      pAction  - parser action
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID      - invalid port id
+ * Note:
+ *      None
+ */
+rtk_api_ret_t  rtk_oam_multiplexerAction_get(rtk_port_t port, rtk_oam_multiplexer_act_t *pAction)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicOamMultiplexer(rtk_switch_port_L2P_get(port), pAction))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/port.c b/drivers/net/phy/rtk/rtl8367c/port.c
new file mode 100644
index 0000000000000..fc2617afe7eb5
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/port.c
@@ -0,0 +1,2467 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in Port module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <port.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_port.h>
+#include <rtl8367c_asicdrv_misc.h>
+#include <rtl8367c_asicdrv_portIsolation.h>
+
+#define FIBER_INIT_SIZE 1507
+CONST_T rtk_uint8 Fiber[FIBER_INIT_SIZE] = {
+0x02,0x04,0x41,0xE4,0xF5,0xA8,0xD2,0xAF,
+0x22,0x00,0x00,0x02,0x05,0x2D,0xE4,0x90,
+0x06,0x2A,0xF0,0xFD,0x7C,0x01,0x7F,0x3F,
+0x7E,0x1D,0x12,0x05,0xAF,0x7D,0x40,0x12,
+0x02,0x5F,0xE4,0xFF,0xFE,0xFD,0x80,0x08,
+0x12,0x05,0x9E,0x50,0x0C,0x12,0x05,0x8B,
+0xFC,0x90,0x06,0x24,0x12,0x03,0x76,0x80,
+0xEF,0xE4,0xF5,0xA8,0xD2,0xAF,0x7D,0x1F,
+0xFC,0x7F,0x49,0x7E,0x13,0x12,0x05,0xAF,
+0x12,0x05,0xD6,0x7D,0xD7,0x12,0x02,0x1E,
+0x7D,0x80,0x12,0x01,0xCA,0x7D,0x94,0x7C,
+0xF9,0x12,0x02,0x3B,0x7D,0x81,0x12,0x01,
+0xCA,0x7D,0xA2,0x7C,0x31,0x12,0x02,0x3B,
+0x7D,0x82,0x12,0x01,0xDF,0x7D,0x60,0x7C,
+0x69,0x12,0x02,0x43,0x7D,0x83,0x12,0x01,
+0xDF,0x7D,0x28,0x7C,0x97,0x12,0x02,0x43,
+0x7D,0x84,0x12,0x01,0xF4,0x7D,0x85,0x7C,
+0x9D,0x12,0x02,0x57,0x7D,0x23,0x12,0x01,
+0xF4,0x7D,0x10,0x7C,0xD8,0x12,0x02,0x57,
+0x7D,0x24,0x7C,0x04,0x12,0x02,0x28,0x7D,
+0x00,0x12,0x02,0x1E,0x7D,0x2F,0x12,0x02,
+0x09,0x7D,0x20,0x7C,0x0F,0x7F,0x02,0x7E,
+0x66,0x12,0x05,0xAF,0x7D,0x01,0x12,0x02,
+0x09,0x7D,0x04,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x05,0xAF,0x7D,0x80,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x05,0xAF,0x7F,
+0x02,0x7E,0x66,0x12,0x02,0x4B,0x44,0x02,
+0xFF,0x90,0x06,0x28,0xEE,0xF0,0xA3,0xEF,
+0xF0,0x44,0x04,0xFF,0x90,0x06,0x28,0xEE,
+0xF0,0xFC,0xA3,0xEF,0xF0,0xFD,0x7F,0x02,
+0x7E,0x66,0x12,0x05,0xAF,0x7D,0x04,0x7C,
+0x00,0x12,0x02,0x28,0x7D,0xB9,0x7C,0x15,
+0x7F,0xEB,0x7E,0x13,0x12,0x05,0xAF,0x7D,
+0x07,0x7C,0x00,0x7F,0xE7,0x7E,0x13,0x12,
+0x05,0xAF,0x7D,0x40,0x7C,0x11,0x7F,0x00,
+0x7E,0x62,0x12,0x05,0xAF,0x12,0x03,0x82,
+0x7D,0x41,0x12,0x02,0x5F,0xE4,0xFF,0xFE,
+0xFD,0x80,0x08,0x12,0x05,0x9E,0x50,0x0C,
+0x12,0x05,0x8B,0xFC,0x90,0x06,0x24,0x12,
+0x03,0x76,0x80,0xEF,0xC2,0x00,0xC2,0x01,
+0xD2,0xA9,0xD2,0x8C,0x7F,0x01,0x7E,0x62,
+0x12,0x02,0x4B,0x30,0xE2,0x05,0xE4,0xA3,
+0xF0,0x80,0xF1,0x90,0x06,0x2A,0xE0,0x70,
+0x12,0x12,0x01,0x89,0x90,0x06,0x2A,0x74,
+0x01,0xF0,0xE4,0x90,0x06,0x2D,0xF0,0xA3,
+0xF0,0x80,0xD9,0xC3,0x90,0x06,0x2E,0xE0,
+0x94,0x64,0x90,0x06,0x2D,0xE0,0x94,0x00,
+0x40,0xCA,0xE4,0xF0,0xA3,0xF0,0x12,0x01,
+0x89,0x90,0x06,0x2A,0x74,0x01,0xF0,0x80,
+0xBB,0x7D,0x04,0xFC,0x7F,0x02,0x7E,0x66,
+0x12,0x05,0xAF,0x7D,0x00,0x7C,0x04,0x7F,
+0x01,0x7E,0x66,0x12,0x05,0xAF,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x05,
+0xAF,0xE4,0xFD,0xFC,0x7F,0x02,0x7E,0x66,
+0x12,0x05,0xAF,0x7D,0x00,0x7C,0x04,0x7F,
+0x01,0x7E,0x66,0x12,0x05,0xAF,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x05,
+0xAF,0x22,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x05,0xAF,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x05,0xAF,0x22,0x7C,
+0x04,0x7F,0x01,0x7E,0x66,0x12,0x05,0xAF,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x12,0x05,0xAF,0x22,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x05,0xAF,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x05,0xAF,
+0x22,0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,
+0x05,0xAF,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x05,0xAF,0x22,0x7C,0x04,
+0x7F,0x02,0x7E,0x66,0x12,0x05,0xAF,0x22,
+0x7F,0x01,0x7E,0x66,0x12,0x05,0xAF,0x7D,
+0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x05,0xAF,0x22,0x7F,0x02,0x7E,0x66,0x12,
+0x05,0xAF,0x22,0x7F,0x02,0x7E,0x66,0x12,
+0x05,0xAF,0x22,0x12,0x05,0x67,0x90,0x06,
+0x28,0xEE,0xF0,0xA3,0xEF,0xF0,0x22,0x7F,
+0x02,0x7E,0x66,0x12,0x05,0xAF,0x22,0x7C,
+0x00,0x7F,0x36,0x7E,0x13,0x12,0x05,0xAF,
+0x22,0xC5,0xF0,0xF8,0xA3,0xE0,0x28,0xF0,
+0xC5,0xF0,0xF8,0xE5,0x82,0x15,0x82,0x70,
+0x02,0x15,0x83,0xE0,0x38,0xF0,0x22,0x75,
+0xF0,0x08,0x75,0x82,0x00,0xEF,0x2F,0xFF,
+0xEE,0x33,0xFE,0xCD,0x33,0xCD,0xCC,0x33,
+0xCC,0xC5,0x82,0x33,0xC5,0x82,0x9B,0xED,
+0x9A,0xEC,0x99,0xE5,0x82,0x98,0x40,0x0C,
+0xF5,0x82,0xEE,0x9B,0xFE,0xED,0x9A,0xFD,
+0xEC,0x99,0xFC,0x0F,0xD5,0xF0,0xD6,0xE4,
+0xCE,0xFB,0xE4,0xCD,0xFA,0xE4,0xCC,0xF9,
+0xA8,0x82,0x22,0xB8,0x00,0xC1,0xB9,0x00,
+0x59,0xBA,0x00,0x2D,0xEC,0x8B,0xF0,0x84,
+0xCF,0xCE,0xCD,0xFC,0xE5,0xF0,0xCB,0xF9,
+0x78,0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xEC,0x33,0xFC,0xEB,0x33,
+0xFB,0x10,0xD7,0x03,0x99,0x40,0x04,0xEB,
+0x99,0xFB,0x0F,0xD8,0xE5,0xE4,0xF9,0xFA,
+0x22,0x78,0x18,0xEF,0x2F,0xFF,0xEE,0x33,
+0xFE,0xED,0x33,0xFD,0xEC,0x33,0xFC,0xC9,
+0x33,0xC9,0x10,0xD7,0x05,0x9B,0xE9,0x9A,
+0x40,0x07,0xEC,0x9B,0xFC,0xE9,0x9A,0xF9,
+0x0F,0xD8,0xE0,0xE4,0xC9,0xFA,0xE4,0xCC,
+0xFB,0x22,0x75,0xF0,0x10,0xEF,0x2F,0xFF,
+0xEE,0x33,0xFE,0xED,0x33,0xFD,0xCC,0x33,
+0xCC,0xC8,0x33,0xC8,0x10,0xD7,0x07,0x9B,
+0xEC,0x9A,0xE8,0x99,0x40,0x0A,0xED,0x9B,
+0xFD,0xEC,0x9A,0xFC,0xE8,0x99,0xF8,0x0F,
+0xD5,0xF0,0xDA,0xE4,0xCD,0xFB,0xE4,0xCC,
+0xFA,0xE4,0xC8,0xF9,0x22,0xEB,0x9F,0xF5,
+0xF0,0xEA,0x9E,0x42,0xF0,0xE9,0x9D,0x42,
+0xF0,0xE8,0x9C,0x45,0xF0,0x22,0xE0,0xFC,
+0xA3,0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,
+0xFF,0x22,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,
+0xE0,0xFA,0xA3,0xE0,0xFB,0x22,0xEC,0xF0,
+0xA3,0xED,0xF0,0xA3,0xEE,0xF0,0xA3,0xEF,
+0xF0,0x22,0x12,0x03,0xF8,0x12,0x04,0x1A,
+0x44,0x40,0x12,0x04,0x0F,0x7D,0x03,0x7C,
+0x00,0x12,0x04,0x23,0x12,0x05,0xAF,0x12,
+0x03,0xF8,0x12,0x04,0x1A,0x54,0xBF,0x12,
+0x04,0x0F,0x7D,0x03,0x7C,0x00,0x12,0x03,
+0xD0,0x7F,0x02,0x7E,0x66,0x12,0x05,0x67,
+0xEF,0x54,0xFD,0x54,0xFE,0x12,0x04,0x33,
+0x12,0x03,0xD0,0x7F,0x02,0x7E,0x66,0x12,
+0x05,0x67,0xEF,0x44,0x02,0x44,0x01,0x12,
+0x04,0x33,0x12,0x04,0x23,0x02,0x05,0xAF,
+0x7F,0x01,0x7E,0x66,0x12,0x05,0xAF,0x7D,
+0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x05,0xAF,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,
+0x66,0x12,0x05,0xAF,0x7D,0x80,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x05,0xAF,0x22,
+0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,0x66,
+0x12,0x05,0xAF,0x7D,0x80,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x05,0xAF,0x22,0xFD,
+0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,0x05,
+0xAF,0x22,0x7F,0x02,0x7E,0x66,0x12,0x05,
+0x67,0xEF,0x22,0x7F,0x01,0x7E,0x66,0x12,
+0x05,0xAF,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x22,0xFD,0xAC,0x06,0x7F,0x02,
+0x7E,0x66,0x12,0x05,0xAF,0xE4,0xFD,0xFC,
+0x22,0x78,0x7F,0xE4,0xF6,0xD8,0xFD,0x75,
+0x81,0x3C,0x02,0x04,0x88,0x02,0x00,0x0E,
+0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0x40,
+0x03,0xF6,0x80,0x01,0xF2,0x08,0xDF,0xF4,
+0x80,0x29,0xE4,0x93,0xA3,0xF8,0x54,0x07,
+0x24,0x0C,0xC8,0xC3,0x33,0xC4,0x54,0x0F,
+0x44,0x20,0xC8,0x83,0x40,0x04,0xF4,0x56,
+0x80,0x01,0x46,0xF6,0xDF,0xE4,0x80,0x0B,
+0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
+0x90,0x05,0xCB,0xE4,0x7E,0x01,0x93,0x60,
+0xBC,0xA3,0xFF,0x54,0x3F,0x30,0xE5,0x09,
+0x54,0x1F,0xFE,0xE4,0x93,0xA3,0x60,0x01,
+0x0E,0xCF,0x54,0xC0,0x25,0xE0,0x60,0xA8,
+0x40,0xB8,0xE4,0x93,0xA3,0xFA,0xE4,0x93,
+0xA3,0xF8,0xE4,0x93,0xA3,0xC8,0xC5,0x82,
+0xC8,0xCA,0xC5,0x83,0xCA,0xF0,0xA3,0xC8,
+0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xDF,
+0xE9,0xDE,0xE7,0x80,0xBE,0x75,0x0F,0x80,
+0x75,0x0E,0x7E,0x75,0x0D,0xAA,0x75,0x0C,
+0x83,0xE4,0xF5,0x10,0x75,0x0B,0xA0,0x75,
+0x0A,0xAC,0x75,0x09,0xB9,0x75,0x08,0x03,
+0x75,0x89,0x11,0x7B,0x60,0x7A,0x09,0xF9,
+0xF8,0xAF,0x0B,0xAE,0x0A,0xAD,0x09,0xAC,
+0x08,0x12,0x02,0xBB,0xAD,0x07,0xAC,0x06,
+0xC3,0xE4,0x9D,0xFD,0xE4,0x9C,0xFC,0x78,
+0x17,0xF6,0xAF,0x05,0xEF,0x08,0xF6,0x18,
+0xE6,0xF5,0x8C,0x08,0xE6,0xF5,0x8A,0x74,
+0x0D,0x2D,0xFD,0xE4,0x3C,0x18,0xF6,0xAF,
+0x05,0xEF,0x08,0xF6,0x75,0x88,0x10,0x53,
+0x8E,0xC7,0xD2,0xA9,0x22,0xC0,0xE0,0xC0,
+0xF0,0xC0,0x83,0xC0,0x82,0xC0,0xD0,0x75,
+0xD0,0x00,0xC0,0x00,0x78,0x17,0xE6,0xF5,
+0x8C,0x78,0x18,0xE6,0xF5,0x8A,0x90,0x06,
+0x2B,0xE4,0x75,0xF0,0x01,0x12,0x02,0x69,
+0x90,0x06,0x2D,0xE4,0x75,0xF0,0x01,0x12,
+0x02,0x69,0xD0,0x00,0xD0,0xD0,0xD0,0x82,
+0xD0,0x83,0xD0,0xF0,0xD0,0xE0,0x32,0xC2,
+0xAF,0xAD,0x07,0xAC,0x06,0x8C,0xA2,0x8D,
+0xA3,0x75,0xA0,0x01,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAE,
+0xA1,0xBE,0x00,0xF0,0xAE,0xA6,0xAF,0xA7,
+0xD2,0xAF,0x22,0x90,0x06,0x24,0x12,0x03,
+0x5E,0xEF,0x24,0x01,0xFF,0xE4,0x3E,0xFE,
+0xE4,0x3D,0xFD,0xE4,0x3C,0x22,0xE4,0x7F,
+0x20,0x7E,0x4E,0xFD,0xFC,0x90,0x06,0x24,
+0x12,0x03,0x6A,0xC3,0x02,0x03,0x4D,0xC2,
+0xAF,0xAB,0x07,0xAA,0x06,0x8A,0xA2,0x8B,
+0xA3,0x8C,0xA4,0x8D,0xA5,0x75,0xA0,0x03,
+0x00,0x00,0x00,0xAA,0xA1,0xBA,0x00,0xF8,
+0xD2,0xAF,0x22,0x42,0x06,0x2D,0x00,0x00,
+0x42,0x06,0x2B,0x00,0x00,0x00,0x12,0x05,
+0xDF,0x12,0x04,0xCD,0x02,0x00,0x03,0xE4,
+0xF5,0x8E,0x22};
+
+static rtk_api_ret_t _rtk_port_FiberModeAbility_set(rtk_port_t port, rtk_port_phy_ability_t *pAbility)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      regData;
+
+    /* Check Combo port or not */
+    RTK_CHK_PORT_IS_COMBO(port);
+
+    /* Flow Control */
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_FIB0_CFG04, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if (pAbility->AsyFC == 1)
+        regData |= (0x0001 << 8);
+    else
+        regData &= ~(0x0001 << 8);
+
+    if (pAbility->FC == 1)
+        regData |= (0x0001 << 7);
+    else
+        regData &= ~(0x0001 << 7);
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_FIB0_CFG04, regData)) != RT_ERR_OK)
+        return retVal;
+
+    /* Speed ability */
+    if( (pAbility->Full_1000 == 1) && (pAbility->Full_100 == 1) && (pAbility->AutoNegotiation == 1) )
+    {
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_FRC_MODE_OFFSET, 0)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_MODE_MASK, 7)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_FIB0_CFG00, 0x1140)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if(pAbility->Full_1000 == 1)
+    {
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_FRC_MODE_OFFSET, 1)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_MODE_MASK, 4)) != RT_ERR_OK)
+            return retVal;
+
+        if(pAbility->AutoNegotiation == 1)
+        {
+            if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_FIB0_CFG00, 0x1140)) != RT_ERR_OK)
+                return retVal;
+        }
+        else
+        {
+            if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_FIB0_CFG00, 0x0140)) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+    else if(pAbility->Full_100 == 1)
+    {
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_FRC_MODE_OFFSET, 1)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_MODE_MASK, 5)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_FIB0_CFG00, 0x2100)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /* Digital software reset */
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, 0x0003)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x0080)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_SDS_INDACS_DATA, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    regData |= (0x0001 << 6);
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, regData)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, 0x0003)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+        return retVal;
+
+    regData &= ~(0x0001 << 6);
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, regData)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, 0x0003)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+        return retVal;
+
+    /* CDR reset */
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0x1401))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, 0x0000))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0x1403))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, 0x0000))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+static rtk_api_ret_t _rtk_port_FiberModeAbility_get(rtk_port_t port, rtk_port_phy_ability_t *pAbility)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      data, regData;
+
+    /* Check Combo port or not */
+    RTK_CHK_PORT_IS_COMBO(port);
+
+    memset(pAbility, 0x00, sizeof(rtk_port_phy_ability_t));
+
+    /* Flow Control */
+    if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_FRC_REG4_OFFSET, 1)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_FRC_REG4_FIB100_OFFSET, 0)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, 0x0044)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x0080)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_SDS_INDACS_DATA, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if(regData & (0x0001 << 8))
+        pAbility->AsyFC = 1;
+
+    if(regData & (0x0001 << 7))
+        pAbility->FC = 1;
+
+    /* Speed ability */
+    if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_FRC_MODE_OFFSET, &data)) != RT_ERR_OK)
+            return retVal;
+
+    if(data == 0)
+    {
+        pAbility->AutoNegotiation = 1;
+        pAbility->Full_1000 = 1;
+        pAbility->Full_100 = 1;
+    }
+    else
+    {
+        if ((retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FIBER_CFG_1, RTL8367C_SDS_MODE_MASK, &data)) != RT_ERR_OK)
+            return retVal;
+
+        if(data == 4)
+        {
+            pAbility->Full_1000 = 1;
+
+            if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_FIB0_CFG00, &data)) != RT_ERR_OK)
+                return retVal;
+
+            if(data & 0x1000)
+                pAbility->AutoNegotiation = 1;
+            else
+                pAbility->AutoNegotiation = 0;
+        }
+        else if(data == 5)
+            pAbility->Full_100 = 1;
+        else
+            return RT_ERR_FAILED;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_phyAutoNegoAbility_set
+ * Description:
+ *      Set ethernet PHY auto-negotiation desired ability.
+ * Input:
+ *      port        - port id.
+ *      pAbility    - Ability structure
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      If Full_1000 bit is set to 1, the AutoNegotiation will be automatic set to 1. While both AutoNegotiation and Full_1000 are set to 0, the PHY speed and duplex selection will
+ *      be set as following 100F > 100H > 10F > 10H priority sequence.
+ */
+rtk_api_ret_t rtk_port_phyAutoNegoAbility_set(rtk_port_t port, rtk_port_phy_ability_t *pAbility)
+{
+    rtk_api_ret_t       retVal;
+    rtk_uint32          phyData;
+    rtk_uint32          phyEnMsk0;
+    rtk_uint32          phyEnMsk4;
+    rtk_uint32          phyEnMsk9;
+    rtk_port_media_t    media_type;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if(NULL == pAbility)
+        return RT_ERR_NULL_POINTER;
+
+    if (pAbility->Half_10 >= RTK_ENABLE_END || pAbility->Full_10 >= RTK_ENABLE_END ||
+       pAbility->Half_100 >= RTK_ENABLE_END || pAbility->Full_100 >= RTK_ENABLE_END ||
+       pAbility->Full_1000 >= RTK_ENABLE_END || pAbility->AutoNegotiation >= RTK_ENABLE_END ||
+       pAbility->AsyFC >= RTK_ENABLE_END || pAbility->FC >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (rtk_switch_isComboPort(port) == RT_ERR_OK)
+    {
+        if ((retVal = rtk_port_phyComboPortMedia_get(port, &media_type)) != RT_ERR_OK)
+            return retVal;
+
+        if(media_type == PORT_MEDIA_FIBER)
+        {
+            return _rtk_port_FiberModeAbility_set(port, pAbility);
+        }
+    }
+
+    /*for PHY auto mode setup*/
+    pAbility->AutoNegotiation = 1;
+
+    phyEnMsk0 = 0;
+    phyEnMsk4 = 0;
+    phyEnMsk9 = 0;
+
+    if (1 == pAbility->Half_10)
+    {
+        /*10BASE-TX half duplex capable in reg 4.5*/
+        phyEnMsk4 = phyEnMsk4 | (1 << 5);
+
+        /*Speed selection [1:0] */
+        /* 11=Reserved*/
+        /* 10= 1000Mpbs*/
+        /* 01= 100Mpbs*/
+        /* 00= 10Mpbs*/
+        phyEnMsk0 = phyEnMsk0 & (~(1 << 6));
+        phyEnMsk0 = phyEnMsk0 & (~(1 << 13));
+    }
+
+    if (1 == pAbility->Full_10)
+    {
+        /*10BASE-TX full duplex capable in reg 4.6*/
+        phyEnMsk4 = phyEnMsk4 | (1 << 6);
+        /*Speed selection [1:0] */
+        /* 11=Reserved*/
+        /* 10= 1000Mpbs*/
+        /* 01= 100Mpbs*/
+        /* 00= 10Mpbs*/
+        phyEnMsk0 = phyEnMsk0 & (~(1 << 6));
+        phyEnMsk0 = phyEnMsk0 & (~(1 << 13));
+
+        /*Full duplex mode in reg 0.8*/
+        phyEnMsk0 = phyEnMsk0 | (1 << 8);
+
+    }
+
+    if (1 == pAbility->Half_100)
+    {
+        /*100BASE-TX half duplex capable in reg 4.7*/
+        phyEnMsk4 = phyEnMsk4 | (1 << 7);
+        /*Speed selection [1:0] */
+        /* 11=Reserved*/
+        /* 10= 1000Mpbs*/
+        /* 01= 100Mpbs*/
+        /* 00= 10Mpbs*/
+        phyEnMsk0 = phyEnMsk0 & (~(1 << 6));
+        phyEnMsk0 = phyEnMsk0 | (1 << 13);
+    }
+
+
+    if (1 == pAbility->Full_100)
+    {
+        /*100BASE-TX full duplex capable in reg 4.8*/
+        phyEnMsk4 = phyEnMsk4 | (1 << 8);
+        /*Speed selection [1:0] */
+        /* 11=Reserved*/
+        /* 10= 1000Mpbs*/
+        /* 01= 100Mpbs*/
+        /* 00= 10Mpbs*/
+        phyEnMsk0 = phyEnMsk0 & (~(1 << 6));
+        phyEnMsk0 = phyEnMsk0 | (1 << 13);
+        /*Full duplex mode in reg 0.8*/
+        phyEnMsk0 = phyEnMsk0 | (1 << 8);
+    }
+
+
+    if (1 == pAbility->Full_1000)
+    {
+        /*1000 BASE-T FULL duplex capable setting in reg 9.9*/
+        phyEnMsk9 = phyEnMsk9 | (1 << 9);
+
+        /*Speed selection [1:0] */
+        /* 11=Reserved*/
+        /* 10= 1000Mpbs*/
+        /* 01= 100Mpbs*/
+        /* 00= 10Mpbs*/
+        phyEnMsk0 = phyEnMsk0 | (1 << 6);
+        phyEnMsk0 = phyEnMsk0 & (~(1 << 13));
+
+
+        /*Auto-Negotiation setting in reg 0.12*/
+        phyEnMsk0 = phyEnMsk0 | (1 << 12);
+
+     }
+
+    if (1 == pAbility->AutoNegotiation)
+    {
+        /*Auto-Negotiation setting in reg 0.12*/
+        phyEnMsk0 = phyEnMsk0 | (1 << 12);
+    }
+
+    if (1 == pAbility->AsyFC)
+    {
+        /*Asymetric flow control in reg 4.11*/
+        phyEnMsk4 = phyEnMsk4 | (1 << 11);
+    }
+    if (1 == pAbility->FC)
+    {
+        /*Flow control in reg 4.10*/
+        phyEnMsk4 = phyEnMsk4 | (1 << 10);
+    }
+
+    /*1000 BASE-T control register setting*/
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_1000_BASET_CONTROL_REG, &phyData)) != RT_ERR_OK)
+        return retVal;
+
+    phyData = (phyData & (~0x0200)) | phyEnMsk9 ;
+
+    if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_1000_BASET_CONTROL_REG, phyData)) != RT_ERR_OK)
+        return retVal;
+
+    /*Auto-Negotiation control register setting*/
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_AN_ADVERTISEMENT_REG, &phyData)) != RT_ERR_OK)
+        return retVal;
+
+    phyData = (phyData & (~0x0DE0)) | phyEnMsk4;
+    if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_AN_ADVERTISEMENT_REG, phyData)) != RT_ERR_OK)
+        return retVal;
+
+    /*Control register setting and restart auto*/
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, &phyData)) != RT_ERR_OK)
+        return retVal;
+
+    phyData = (phyData & (~0x3140)) | phyEnMsk0;
+    /*If have auto-negotiation capable, then restart auto negotiation*/
+    if (1 == pAbility->AutoNegotiation)
+    {
+        phyData = phyData | (1 << 9);
+    }
+
+    if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, phyData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_phyAutoNegoAbility_get
+ * Description:
+ *      Get PHY ability through PHY registers.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pAbility - Ability structure
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      Get the capablity of specified PHY.
+ */
+rtk_api_ret_t rtk_port_phyAutoNegoAbility_get(rtk_port_t port, rtk_port_phy_ability_t *pAbility)
+{
+    rtk_api_ret_t       retVal;
+    rtk_uint32          phyData0;
+    rtk_uint32          phyData4;
+    rtk_uint32          phyData9;
+    rtk_port_media_t    media_type;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if(NULL == pAbility)
+        return RT_ERR_NULL_POINTER;
+
+    if (rtk_switch_isComboPort(port) == RT_ERR_OK)
+    {
+        if ((retVal = rtk_port_phyComboPortMedia_get(port, &media_type)) != RT_ERR_OK)
+            return retVal;
+
+        if(media_type == PORT_MEDIA_FIBER)
+        {
+            return _rtk_port_FiberModeAbility_get(port, pAbility);
+        }
+    }
+
+    /*Control register setting and restart auto*/
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, &phyData0)) != RT_ERR_OK)
+        return retVal;
+
+    /*Auto-Negotiation control register setting*/
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_AN_ADVERTISEMENT_REG, &phyData4)) != RT_ERR_OK)
+        return retVal;
+
+    /*1000 BASE-T control register setting*/
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_1000_BASET_CONTROL_REG, &phyData9)) != RT_ERR_OK)
+        return retVal;
+
+    if (phyData9 & (1 << 9))
+        pAbility->Full_1000 = 1;
+    else
+        pAbility->Full_1000 = 0;
+
+    if (phyData4 & (1 << 11))
+        pAbility->AsyFC = 1;
+    else
+        pAbility->AsyFC = 0;
+
+    if (phyData4 & (1 << 10))
+        pAbility->FC = 1;
+    else
+        pAbility->FC = 0;
+
+
+    if (phyData4 & (1 << 8))
+        pAbility->Full_100 = 1;
+    else
+        pAbility->Full_100 = 0;
+
+    if (phyData4 & (1 << 7))
+        pAbility->Half_100 = 1;
+    else
+        pAbility->Half_100 = 0;
+
+    if (phyData4 & (1 << 6))
+        pAbility->Full_10 = 1;
+    else
+        pAbility->Full_10 = 0;
+
+    if (phyData4 & (1 << 5))
+        pAbility->Half_10 = 1;
+    else
+        pAbility->Half_10 = 0;
+
+
+    if (phyData0 & (1 << 12))
+        pAbility->AutoNegotiation = 1;
+    else
+        pAbility->AutoNegotiation = 0;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_phyForceModeAbility_set
+ * Description:
+ *      Set the port speed/duplex mode/pause/asy_pause in the PHY force mode.
+ * Input:
+ *      port        - port id.
+ *      pAbility    - Ability structure
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      While both AutoNegotiation and Full_1000 are set to 0, the PHY speed and duplex selection will
+ *      be set as following 100F > 100H > 10F > 10H priority sequence.
+ *      This API can be used to configure combo port in fiber mode.
+ *      The possible parameters in fiber mode are Full_1000 and Full 100.
+ *      All the other fields in rtk_port_phy_ability_t will be ignored in fiber port.
+ */
+rtk_api_ret_t rtk_port_phyForceModeAbility_set(rtk_port_t port, rtk_port_phy_ability_t *pAbility)
+{
+     rtk_api_ret_t      retVal;
+     rtk_uint32         phyData;
+     rtk_uint32         phyEnMsk0;
+     rtk_uint32         phyEnMsk4;
+     rtk_uint32         phyEnMsk9;
+     rtk_port_media_t   media_type;
+
+     /* Check initialization state */
+     RTK_CHK_INIT_STATE();
+
+     /* Check Port Valid */
+     RTK_CHK_PORT_IS_UTP(port);
+
+     if(NULL == pAbility)
+        return RT_ERR_NULL_POINTER;
+
+     if (pAbility->Half_10 >= RTK_ENABLE_END || pAbility->Full_10 >= RTK_ENABLE_END ||
+        pAbility->Half_100 >= RTK_ENABLE_END || pAbility->Full_100 >= RTK_ENABLE_END ||
+        pAbility->Full_1000 >= RTK_ENABLE_END || pAbility->AutoNegotiation >= RTK_ENABLE_END ||
+        pAbility->AsyFC >= RTK_ENABLE_END || pAbility->FC >= RTK_ENABLE_END)
+         return RT_ERR_INPUT;
+
+     if (rtk_switch_isComboPort(port) == RT_ERR_OK)
+     {
+         if ((retVal = rtk_port_phyComboPortMedia_get(port, &media_type)) != RT_ERR_OK)
+             return retVal;
+
+         if(media_type == PORT_MEDIA_FIBER)
+         {
+             return _rtk_port_FiberModeAbility_set(port, pAbility);
+         }
+     }
+
+     if (1 == pAbility->Full_1000)
+         return RT_ERR_INPUT;
+
+     /*for PHY force mode setup*/
+     pAbility->AutoNegotiation = 0;
+
+     phyEnMsk0 = 0;
+     phyEnMsk4 = 0;
+     phyEnMsk9 = 0;
+
+     if (1 == pAbility->Half_10)
+     {
+         /*10BASE-TX half duplex capable in reg 4.5*/
+         phyEnMsk4 = phyEnMsk4 | (1 << 5);
+
+         /*Speed selection [1:0] */
+         /* 11=Reserved*/
+         /* 10= 1000Mpbs*/
+         /* 01= 100Mpbs*/
+         /* 00= 10Mpbs*/
+         phyEnMsk0 = phyEnMsk0 & (~(1 << 6));
+         phyEnMsk0 = phyEnMsk0 & (~(1 << 13));
+     }
+
+     if (1 == pAbility->Full_10)
+     {
+         /*10BASE-TX full duplex capable in reg 4.6*/
+         phyEnMsk4 = phyEnMsk4 | (1 << 6);
+         /*Speed selection [1:0] */
+         /* 11=Reserved*/
+         /* 10= 1000Mpbs*/
+         /* 01= 100Mpbs*/
+         /* 00= 10Mpbs*/
+         phyEnMsk0 = phyEnMsk0 & (~(1 << 6));
+         phyEnMsk0 = phyEnMsk0 & (~(1 << 13));
+
+         /*Full duplex mode in reg 0.8*/
+         phyEnMsk0 = phyEnMsk0 | (1 << 8);
+
+     }
+
+     if (1 == pAbility->Half_100)
+     {
+         /*100BASE-TX half duplex capable in reg 4.7*/
+         phyEnMsk4 = phyEnMsk4 | (1 << 7);
+         /*Speed selection [1:0] */
+         /* 11=Reserved*/
+         /* 10= 1000Mpbs*/
+         /* 01= 100Mpbs*/
+         /* 00= 10Mpbs*/
+         phyEnMsk0 = phyEnMsk0 & (~(1 << 6));
+         phyEnMsk0 = phyEnMsk0 | (1 << 13);
+     }
+
+
+     if (1 == pAbility->Full_100)
+     {
+         /*100BASE-TX full duplex capable in reg 4.8*/
+         phyEnMsk4 = phyEnMsk4 | (1 << 8);
+         /*Speed selection [1:0] */
+         /* 11=Reserved*/
+         /* 10= 1000Mpbs*/
+         /* 01= 100Mpbs*/
+         /* 00= 10Mpbs*/
+         phyEnMsk0 = phyEnMsk0 & (~(1 << 6));
+         phyEnMsk0 = phyEnMsk0 | (1 << 13);
+         /*Full duplex mode in reg 0.8*/
+         phyEnMsk0 = phyEnMsk0 | (1 << 8);
+     }
+
+     if (1 == pAbility->AsyFC)
+     {
+         /*Asymetric flow control in reg 4.11*/
+         phyEnMsk4 = phyEnMsk4 | (1 << 11);
+     }
+     if (1 == pAbility->FC)
+     {
+         /*Flow control in reg 4.10*/
+         phyEnMsk4 = phyEnMsk4 | ((1 << 10));
+     }
+
+     /*1000 BASE-T control register setting*/
+     if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_1000_BASET_CONTROL_REG, &phyData)) != RT_ERR_OK)
+         return retVal;
+
+     phyData = (phyData & (~0x0200)) | phyEnMsk9 ;
+
+     if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_1000_BASET_CONTROL_REG, phyData)) != RT_ERR_OK)
+         return retVal;
+
+     /*Auto-Negotiation control register setting*/
+     if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_AN_ADVERTISEMENT_REG, &phyData)) != RT_ERR_OK)
+         return retVal;
+
+     phyData = (phyData & (~0x0DE0)) | phyEnMsk4;
+     if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_AN_ADVERTISEMENT_REG, phyData)) != RT_ERR_OK)
+         return retVal;
+
+     /*Control register setting and power off/on*/
+     phyData = phyEnMsk0 & (~(1 << 12));
+     phyData |= (1 << 11);   /* power down PHY, bit 11 should be set to 1 */
+     if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, phyData)) != RT_ERR_OK)
+         return retVal;
+
+     phyData = phyData & (~(1 << 11));   /* power on PHY, bit 11 should be set to 0*/
+     if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, phyData)) != RT_ERR_OK)
+         return retVal;
+
+     return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_phyForceModeAbility_get
+ * Description:
+ *      Get PHY ability through PHY registers.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pAbility - Ability structure
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      Get the capablity of specified PHY.
+ */
+rtk_api_ret_t rtk_port_phyForceModeAbility_get(rtk_port_t port, rtk_port_phy_ability_t *pAbility)
+{
+    rtk_api_ret_t       retVal;
+    rtk_uint32          phyData0;
+    rtk_uint32          phyData4;
+    rtk_uint32          phyData9;
+    rtk_port_media_t    media_type;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+     RTK_CHK_PORT_IS_UTP(port);
+
+     if(NULL == pAbility)
+        return RT_ERR_NULL_POINTER;
+
+     if (rtk_switch_isComboPort(port) == RT_ERR_OK)
+     {
+         if ((retVal = rtk_port_phyComboPortMedia_get(port, &media_type)) != RT_ERR_OK)
+             return retVal;
+
+         if(media_type == PORT_MEDIA_FIBER)
+         {
+             return _rtk_port_FiberModeAbility_get(port, pAbility);
+         }
+     }
+
+    /*Control register setting and restart auto*/
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, &phyData0)) != RT_ERR_OK)
+        return retVal;
+
+    /*Auto-Negotiation control register setting*/
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_AN_ADVERTISEMENT_REG, &phyData4)) != RT_ERR_OK)
+        return retVal;
+
+    /*1000 BASE-T control register setting*/
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_1000_BASET_CONTROL_REG, &phyData9)) != RT_ERR_OK)
+        return retVal;
+
+    if (phyData9 & (1 << 9))
+        pAbility->Full_1000 = 1;
+    else
+        pAbility->Full_1000 = 0;
+
+    if (phyData4 & (1 << 11))
+        pAbility->AsyFC = 1;
+    else
+        pAbility->AsyFC = 0;
+
+    if (phyData4 & ((1 << 10)))
+        pAbility->FC = 1;
+    else
+        pAbility->FC = 0;
+
+
+    if (phyData4 & (1 << 8))
+        pAbility->Full_100 = 1;
+    else
+        pAbility->Full_100 = 0;
+
+    if (phyData4 & (1 << 7))
+        pAbility->Half_100 = 1;
+    else
+        pAbility->Half_100 = 0;
+
+    if (phyData4 & (1 << 6))
+        pAbility->Full_10 = 1;
+    else
+        pAbility->Full_10 = 0;
+
+    if (phyData4 & (1 << 5))
+        pAbility->Half_10 = 1;
+    else
+        pAbility->Half_10 = 0;
+
+
+    if (phyData0 & (1 << 12))
+        pAbility->AutoNegotiation = 1;
+    else
+        pAbility->AutoNegotiation = 0;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_phyStatus_get
+ * Description:
+ *      Get ethernet PHY linking status
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      linkStatus  - PHY link status
+ *      speed       - PHY link speed
+ *      duplex      - PHY duplex mode
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      API will return auto negotiation status of phy.
+ */
+rtk_api_ret_t rtk_port_phyStatus_get(rtk_port_t port, rtk_port_linkStatus_t *pLinkStatus, rtk_port_speed_t *pSpeed, rtk_port_duplex_t *pDuplex)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 phyData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if( (NULL == pLinkStatus) || (NULL == pSpeed) || (NULL == pDuplex) )
+        return RT_ERR_NULL_POINTER;
+
+    /*Get PHY resolved register*/
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_RESOLVED_REG, &phyData)) != RT_ERR_OK)
+        return retVal;
+
+    /*check link status*/
+    if (phyData & (1<<2))
+    {
+        *pLinkStatus = 1;
+
+        /*check link speed*/
+        *pSpeed = (phyData&0x0030) >> 4;
+
+        /*check link duplex*/
+        *pDuplex = (phyData&0x0008) >> 3;
+    }
+    else
+    {
+        *pLinkStatus = 0;
+        *pSpeed = 0;
+        *pDuplex = 0;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_macForceLink_set
+ * Description:
+ *      Set port force linking configuration.
+ * Input:
+ *      port            - port id.
+ *      pPortability    - port ability configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can set Port/MAC force mode properties.
+ */
+rtk_api_ret_t rtk_port_macForceLink_set(rtk_port_t port, rtk_port_mac_ability_t *pPortability)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_port_ability_t ability;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if(NULL == pPortability)
+        return RT_ERR_NULL_POINTER;
+
+    if (pPortability->forcemode >1|| pPortability->speed > 2 || pPortability->duplex > 1 ||
+       pPortability->link > 1 || pPortability->nway > 1 || pPortability->txpause > 1 || pPortability->rxpause > 1)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_getAsicPortForceLink(rtk_switch_port_L2P_get(port), &ability)) != RT_ERR_OK)
+        return retVal;
+
+    ability.forcemode = pPortability->forcemode;
+    ability.speed     = pPortability->speed;
+    ability.duplex    = pPortability->duplex;
+    ability.link      = pPortability->link;
+    ability.nway      = pPortability->nway;
+    ability.txpause   = pPortability->txpause;
+    ability.rxpause   = pPortability->rxpause;
+
+    if ((retVal = rtl8367c_setAsicPortForceLink(rtk_switch_port_L2P_get(port), &ability)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_macForceLink_get
+ * Description:
+ *      Get port force linking configuration.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPortability - port ability configuration
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get Port/MAC force mode properties.
+ */
+rtk_api_ret_t rtk_port_macForceLink_get(rtk_port_t port, rtk_port_mac_ability_t *pPortability)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_port_ability_t ability;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if(NULL == pPortability)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortForceLink(rtk_switch_port_L2P_get(port), &ability)) != RT_ERR_OK)
+        return retVal;
+
+    pPortability->forcemode = ability.forcemode;
+    pPortability->speed     = ability.speed;
+    pPortability->duplex    = ability.duplex;
+    pPortability->link      = ability.link;
+    pPortability->nway      = ability.nway;
+    pPortability->txpause   = ability.txpause;
+    pPortability->rxpause   = ability.rxpause;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_macForceLinkExt_set
+ * Description:
+ *      Set external interface force linking configuration.
+ * Input:
+ *      port            - external port ID
+ *      mode            - external interface mode
+ *      pPortability    - port ability configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can set external interface force mode properties.
+ *      The external interface can be set to:
+ *      - MODE_EXT_DISABLE,
+ *      - MODE_EXT_RGMII,
+ *      - MODE_EXT_MII_MAC,
+ *      - MODE_EXT_MII_PHY,
+ *      - MODE_EXT_TMII_MAC,
+ *      - MODE_EXT_TMII_PHY,
+ *      - MODE_EXT_GMII,
+ *      - MODE_EXT_RMII_MAC,
+ *      - MODE_EXT_RMII_PHY,
+ *      - MODE_EXT_SGMII,
+ *      - MODE_EXT_HSGMII,
+ *      - MODE_EXT_1000X_100FX,
+ *      - MODE_EXT_1000X,
+ *      - MODE_EXT_100FX,
+ */
+rtk_api_ret_t rtk_port_macForceLinkExt_set(rtk_port_t port, rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_port_ability_t ability;
+    rtk_uint32 ext_id;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_EXT(port);
+
+    if(NULL == pPortability)
+        return RT_ERR_NULL_POINTER;
+
+    if (mode >=MODE_EXT_END)
+        return RT_ERR_INPUT;
+
+    if(mode == MODE_EXT_HSGMII)
+    {
+        if (pPortability->forcemode > 1 || pPortability->speed != PORT_SPEED_2500M || pPortability->duplex != PORT_FULL_DUPLEX ||
+           pPortability->link >= PORT_LINKSTATUS_END || pPortability->nway > 1 || pPortability->txpause > 1 || pPortability->rxpause > 1)
+            return RT_ERR_INPUT;
+
+        if(rtk_switch_isHsgPort(port) != RT_ERR_OK)
+            return RT_ERR_PORT_ID;
+    }
+    else
+    {
+        if (pPortability->forcemode > 1 || pPortability->speed > PORT_SPEED_1000M || pPortability->duplex >= PORT_DUPLEX_END ||
+           pPortability->link >= PORT_LINKSTATUS_END || pPortability->nway > 1 || pPortability->txpause > 1 || pPortability->rxpause > 1)
+            return RT_ERR_INPUT;
+    }
+
+    ext_id = port - 15;
+
+    if(mode == MODE_EXT_DISABLE)
+    {
+        memset(&ability, 0x00, sizeof(rtl8367c_port_ability_t));
+        if ((retVal = rtl8367c_setAsicPortForceLinkExt(ext_id, &ability)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicPortExtMode(ext_id, mode)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        if ((retVal = rtl8367c_setAsicPortExtMode(ext_id, mode)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_getAsicPortForceLinkExt(ext_id, &ability)) != RT_ERR_OK)
+            return retVal;
+
+        ability.forcemode = pPortability->forcemode;
+        ability.speed     = (mode == MODE_EXT_HSGMII) ? PORT_SPEED_1000M : pPortability->speed;
+        ability.duplex    = pPortability->duplex;
+        ability.link      = pPortability->link;
+        ability.nway      = pPortability->nway;
+        ability.txpause   = pPortability->txpause;
+        ability.rxpause   = pPortability->rxpause;
+
+        if ((retVal = rtl8367c_setAsicPortForceLinkExt(ext_id, &ability)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_macForceLinkExt_get
+ * Description:
+ *      Set external interface force linking configuration.
+ * Input:
+ *      port            - external port ID
+ * Output:
+ *      pMode           - external interface mode
+ *      pPortability    - port ability configuration
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get external interface force mode properties.
+ */
+rtk_api_ret_t rtk_port_macForceLinkExt_get(rtk_port_t port, rtk_mode_ext_t *pMode, rtk_port_mac_ability_t *pPortability)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_port_ability_t ability;
+    rtk_uint32 ext_id;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_EXT(port);
+
+    if(NULL == pMode)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pPortability)
+        return RT_ERR_NULL_POINTER;
+
+    ext_id = port - 15;
+
+    if ((retVal = rtl8367c_getAsicPortExtMode(ext_id, (rtk_uint32 *)pMode)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPortForceLinkExt(ext_id, &ability)) != RT_ERR_OK)
+        return retVal;
+
+    pPortability->forcemode = ability.forcemode;
+    pPortability->speed     = (*pMode == MODE_EXT_HSGMII) ? PORT_SPEED_2500M : ability.speed;
+    pPortability->duplex    = ability.duplex;
+    pPortability->link      = ability.link;
+    pPortability->nway      = ability.nway;
+    pPortability->txpause   = ability.txpause;
+    pPortability->rxpause   = ability.rxpause;
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtk_port_macStatus_get
+ * Description:
+ *      Get port link status.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPortstatus - port ability configuration
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can get Port/PHY properties.
+ */
+rtk_api_ret_t rtk_port_macStatus_get(rtk_port_t port, rtk_port_mac_ability_t *pPortstatus)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_port_status_t status;
+    rtk_uint32 hsgsel;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pPortstatus)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortStatus(rtk_switch_port_L2P_get(port), &status)) != RT_ERR_OK)
+        return retVal;
+
+
+    pPortstatus->duplex    = status.duplex;
+    pPortstatus->link      = status.link;
+    pPortstatus->nway      = status.nway;
+    pPortstatus->txpause   = status.txpause;
+    pPortstatus->rxpause   = status.rxpause;
+
+    if( (retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET, &hsgsel)) != RT_ERR_OK)
+            return retVal;
+
+    if( (rtk_switch_isHsgPort(port) == RT_ERR_OK) && (hsgsel == 1) )
+        pPortstatus->speed = PORT_SPEED_2500M;
+    else
+        pPortstatus->speed = status.speed;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_macLocalLoopbackEnable_set
+ * Description:
+ *      Set Port Local Loopback. (Redirect TX to RX.)
+ * Input:
+ *      port    - Port id.
+ *      enable  - Loopback state, 0:disable, 1:enable
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can enable/disable Local loopback in MAC.
+ *      For UTP port, This API will also enable the digital
+ *      loopback bit in PHY register for sync of speed between
+ *      PHY and MAC. For EXT port, users need to force the
+ *      link state by themself.
+ */
+rtk_api_ret_t rtk_port_macLocalLoopbackEnable_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      data;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicPortLoopback(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
+        return retVal;
+
+    if(rtk_switch_isUtpPort(port) == RT_ERR_OK)
+    {
+        if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, &data)) != RT_ERR_OK)
+            return retVal;
+
+        if(enable == ENABLED)
+            data |= (0x0001 << 14);
+        else
+            data &= ~(0x0001 << 14);
+
+        if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), PHY_CONTROL_REG, data)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_macLocalLoopbackEnable_get
+ * Description:
+ *      Get Port Local Loopback. (Redirect TX to RX.)
+ * Input:
+ *      port    - Port id.
+ * Output:
+ *      pEnable  - Loopback state, 0:disable, 1:enable
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_port_macLocalLoopbackEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortLoopback(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_phyReg_set
+ * Description:
+ *      Set PHY register data of the specific port.
+ * Input:
+ *      port    - port id.
+ *      reg     - Register id
+ *      regData - Register data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      This API can set PHY register data of the specific port.
+ */
+rtk_api_ret_t rtk_port_phyReg_set(rtk_port_t port, rtk_port_phy_reg_t reg, rtk_port_phy_data_t regData)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), reg, regData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_phyReg_get
+ * Description:
+ *      Get PHY register data of the specific port.
+ * Input:
+ *      port    - Port id.
+ *      reg     - Register id
+ * Output:
+ *      pData   - Register data
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_PHY_REG_ID       - Invalid PHY address
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      This API can get PHY register data of the specific port.
+ */
+rtk_api_ret_t rtk_port_phyReg_get(rtk_port_t port, rtk_port_phy_reg_t reg, rtk_port_phy_data_t *pData)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), reg, pData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_backpressureEnable_set
+ * Description:
+ *      Set the half duplex backpressure enable status of the specific port.
+ * Input:
+ *      port    - port id.
+ *      enable  - Back pressure status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      This API can set the half duplex backpressure enable status of the specific port.
+ *      The half duplex backpressure enable status of the port is as following:
+ *      - DISABLE(Defer)
+ *      - ENABLE (Backpressure)
+ */
+rtk_api_ret_t rtk_port_backpressureEnable_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (port != RTK_WHOLE_SYSTEM)
+        return RT_ERR_PORT_ID;
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicPortJamMode(!enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_backpressureEnable_get
+ * Description:
+ *      Get the half duplex backpressure enable status of the specific port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - Back pressure status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can get the half duplex backpressure enable status of the specific port.
+ *      The half duplex backpressure enable status of the port is as following:
+ *      - DISABLE(Defer)
+ *      - ENABLE (Backpressure)
+ */
+rtk_api_ret_t rtk_port_backpressureEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (port != RTK_WHOLE_SYSTEM)
+        return RT_ERR_PORT_ID;
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortJamMode(&regData)) != RT_ERR_OK)
+        return retVal;
+
+    *pEnable = !regData;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_adminEnable_set
+ * Description:
+ *      Set port admin configuration of the specific port.
+ * Input:
+ *      port    - port id.
+ *      enable  - Back pressure status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      This API can set port admin configuration of the specific port.
+ *      The port admin configuration of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+rtk_api_ret_t rtk_port_adminEnable_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32      data;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtk_port_phyReg_get(port, PHY_CONTROL_REG, &data)) != RT_ERR_OK)
+        return retVal;
+
+    if (ENABLED == enable)
+    {
+        data &= 0xF7FF;
+        data |= 0x0200;
+    }
+    else if (DISABLED == enable)
+    {
+        data |= 0x0800;
+    }
+
+    if ((retVal = rtk_port_phyReg_set(port, PHY_CONTROL_REG, data)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_adminEnable_get
+ * Description:
+ *      Get port admin configurationof the specific port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - Back pressure status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API can get port admin configuration of the specific port.
+ *      The port admin configuration of the port is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+rtk_api_ret_t rtk_port_adminEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32      data;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtk_port_phyReg_get(port, PHY_CONTROL_REG, &data)) != RT_ERR_OK)
+        return retVal;
+
+    if ( (data & 0x0800) == 0x0800)
+    {
+        *pEnable = DISABLED;
+    }
+    else
+    {
+        *pEnable = ENABLED;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_isolation_set
+ * Description:
+ *      Set permitted port isolation portmask
+ * Input:
+ *      port         - port id.
+ *      pPortmask    - Permit port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_PORT_MASK    - Invalid portmask.
+ * Note:
+ *      This API set the port mask that a port can trasmit packet to of each port
+ *      A port can only transmit packet to ports included in permitted portmask
+ */
+rtk_api_ret_t rtk_port_isolation_set(rtk_port_t port, rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    /* check port mask */
+    RTK_CHK_PORTMASK_VALID(pPortmask);
+
+    if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPortIsolationPermittedPortmask(rtk_switch_port_L2P_get(port), pmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_isolation_get
+ * Description:
+ *      Get permitted port isolation portmask
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPortmask - Permit port mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API get the port mask that a port can trasmit packet to of each port
+ *      A port can only transmit packet to ports included in permitted portmask
+ */
+rtk_api_ret_t rtk_port_isolation_get(rtk_port_t port, rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortIsolationPermittedPortmask(rtk_switch_port_L2P_get(port), &pmask)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_rgmiiDelayExt_set
+ * Description:
+ *      Set RGMII interface delay value for TX and RX.
+ * Input:
+ *      txDelay - TX delay value, 1 for delay 2ns and 0 for no-delay
+ *      rxDelay - RX delay value, 0~7 for delay setup.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can set external interface 2 RGMII delay.
+ *      In TX delay, there are 2 selection: no-delay and 2ns delay.
+ *      In RX dekay, there are 8 steps for delay tunning. 0 for no-delay, and 7 for maximum delay.
+ */
+rtk_api_ret_t rtk_port_rgmiiDelayExt_set(rtk_port_t port, rtk_data_t txDelay, rtk_data_t rxDelay)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regAddr, regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_EXT(port);
+
+    if ((txDelay > 1) || (rxDelay > 7))
+        return RT_ERR_INPUT;
+
+    if(port == EXT_PORT0)
+        regAddr = RTL8367C_REG_EXT1_RGMXF;
+    else if(port == EXT_PORT1)
+        regAddr = RTL8367C_REG_EXT2_RGMXF;
+    else
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    regData = (regData & 0xFFF0) | ((txDelay << 3) & 0x0008) | (rxDelay & 0x0007);
+
+    if ((retVal = rtl8367c_setAsicReg(regAddr, regData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_rgmiiDelayExt_get
+ * Description:
+ *      Get RGMII interface delay value for TX and RX.
+ * Input:
+ *      None
+ * Output:
+ *      pTxDelay - TX delay value
+ *      pRxDelay - RX delay value
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can set external interface 2 RGMII delay.
+ *      In TX delay, there are 2 selection: no-delay and 2ns delay.
+ *      In RX dekay, there are 8 steps for delay tunning. 0 for n0-delay, and 7 for maximum delay.
+ */
+rtk_api_ret_t rtk_port_rgmiiDelayExt_get(rtk_port_t port, rtk_data_t *pTxDelay, rtk_data_t *pRxDelay)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regAddr, regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_EXT(port);
+
+    if( (NULL == pTxDelay) || (NULL == pRxDelay) )
+        return RT_ERR_NULL_POINTER;
+
+    if(port == EXT_PORT0)
+        regAddr = RTL8367C_REG_EXT1_RGMXF;
+    else if(port == EXT_PORT1)
+        regAddr = RTL8367C_REG_EXT2_RGMXF;
+    else
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    *pTxDelay = (regData & 0x0008) >> 3;
+    *pRxDelay = regData & 0x0007;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_phyEnableAll_set
+ * Description:
+ *      Set all PHY enable status.
+ * Input:
+ *      enable - PHY Enable State.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      This API can set all PHY status.
+ *      The configuration of all PHY is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+rtk_api_ret_t rtk_port_phyEnableAll_set(rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 data;
+    rtk_uint32 port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicPortEnableAll(enable)) != RT_ERR_OK)
+        return retVal;
+
+    RTK_SCAN_ALL_LOG_PORT(port)
+    {
+        if(rtk_switch_isUtpPort(port) == RT_ERR_OK)
+        {
+            if ((retVal = rtk_port_phyReg_get(port, PHY_CONTROL_REG, &data)) != RT_ERR_OK)
+                return retVal;
+
+            if (ENABLED == enable)
+            {
+                data &= 0xF7FF;
+                data |= 0x0200;
+            }
+            else
+            {
+                data |= 0x0800;
+            }
+
+            if ((retVal = rtk_port_phyReg_set(port, PHY_CONTROL_REG, data)) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtk_port_phyEnableAll_get
+ * Description:
+ *      Get all PHY enable status.
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - PHY Enable State.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      This API can set all PHY status.
+ *      The configuration of all PHY is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+rtk_api_ret_t rtk_port_phyEnableAll_get(rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortEnableAll(pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_efid_set
+ * Description:
+ *      Set port-based enhanced filtering database
+ * Input:
+ *      port - Port id.
+ *      efid - Specified enhanced filtering database.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_L2_FID - Invalid fid.
+ *      RT_ERR_INPUT - Invalid input parameter.
+ *      RT_ERR_PORT_ID - Invalid port ID.
+ * Note:
+ *      The API can set port-based enhanced filtering database.
+ */
+rtk_api_ret_t rtk_port_efid_set(rtk_port_t port, rtk_data_t efid)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    /* efid must be 0~7 */
+    if (efid > RTK_EFID_MAX)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicPortIsolationEfid(rtk_switch_port_L2P_get(port), efid))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_efid_get
+ * Description:
+ *      Get port-based enhanced filtering database
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEfid - Specified enhanced filtering database.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT - Invalid input parameters.
+ *      RT_ERR_PORT_ID - Invalid port ID.
+ * Note:
+ *      The API can get port-based enhanced filtering database status.
+ */
+rtk_api_ret_t rtk_port_efid_get(rtk_port_t port, rtk_data_t *pEfid)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pEfid)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortIsolationEfid(rtk_switch_port_L2P_get(port), pEfid))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_phyComboPortMedia_set
+ * Description:
+ *      Set Combo port media type
+ * Input:
+ *      port    - Port id.
+ *      media   - Media (COPPER or FIBER)
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_PORT_ID          - Invalid port ID.
+ * Note:
+ *      The API can Set Combo port media type.
+ */
+rtk_api_ret_t rtk_port_phyComboPortMedia_set(rtk_port_t port, rtk_port_media_t media)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint32 idx;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    /* Check Combo Port ID */
+    RTK_CHK_PORT_IS_COMBO(port);
+
+    if (media >= PORT_MEDIA_END)
+        return RT_ERR_INPUT;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    if(regData != 0x6367)
+        return RT_ERR_CHIP_NOT_SUPPORTED;
+
+    if(media == PORT_MEDIA_FIBER)
+    {
+        /* software init */
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_CHIP_RESET, RTL8367C_DW8051_RST_OFFSET, 1)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MISCELLANEOUS_CONFIGURE0, RTL8367C_DW8051_EN_OFFSET, 1)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_ACS_IROM_ENABLE_OFFSET, 1)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_IROM_MSB_OFFSET, 0)) != RT_ERR_OK)
+            return retVal;
+
+        for(idx = 0; idx < FIBER_INIT_SIZE; idx++)
+        {
+            if ((retVal = rtl8367c_setAsicReg(0xE000 + idx, (rtk_uint32)Fiber[idx])) != RT_ERR_OK)
+                return retVal;
+        }
+
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_IROM_MSB_OFFSET, 0)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_ACS_IROM_ENABLE_OFFSET, 0)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_CHIP_RESET, RTL8367C_DW8051_RST_OFFSET, 0)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_UTP_FIB_DET, RTL8367C_UTP_FIRST_OFFSET, 1))!=RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_DW8051_READY_OFFSET, 0)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_phyComboPortMedia_get
+ * Description:
+ *      Get Combo port media type
+ * Input:
+ *      port    - Port id.
+ * Output:
+ *      pMedia  - Media (COPPER or FIBER)
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_PORT_ID          - Invalid port ID.
+ * Note:
+ *      The API can Set Combo port media type.
+ */
+rtk_api_ret_t rtk_port_phyComboPortMedia_get(rtk_port_t port, rtk_port_media_t *pMedia)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      regData;
+    rtk_uint32      data;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    /* Check Combo Port ID */
+    RTK_CHK_PORT_IS_COMBO(port);
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    if(regData != 0x6367)
+    {
+        *pMedia = PORT_MEDIA_COPPER;
+    }
+    else
+    {
+        if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_UTP_FIB_DET, RTL8367C_UTP_FIRST_OFFSET, &data))!=RT_ERR_OK)
+                return retVal;
+
+        if(data == 1)
+            *pMedia = PORT_MEDIA_COPPER;
+        else
+            *pMedia = PORT_MEDIA_FIBER;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_rtctEnable_set
+ * Description:
+ *      Enable RTCT test
+ * Input:
+ *      pPortmask    - Port mask of RTCT enabled port
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_MASK        - Invalid port mask.
+ * Note:
+ *      The API can enable RTCT Test
+ */
+rtk_api_ret_t rtk_port_rtctEnable_set(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Mask Valid */
+    RTK_CHK_PORTMASK_VALID_ONLY_UTP(pPortmask);
+
+    if ((retVal = rtl8367c_setAsicPortRTCTEnable(pPortmask->bits[0]))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_rtctDisable_set
+ * Description:
+ *      Disable RTCT test
+ * Input:
+ *      pPortmask    - Port mask of RTCT disabled port
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_MASK        - Invalid port mask.
+ * Note:
+ *      The API can disable RTCT Test
+ */
+rtk_api_ret_t rtk_port_rtctDisable_set(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Mask Valid */
+    RTK_CHK_PORTMASK_VALID_ONLY_UTP(pPortmask);
+
+    if ((retVal = rtl8367c_setAsicPortRTCTDisable(pPortmask->bits[0]))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_port_rtctResult_get
+ * Description:
+ *      Get the result of RTCT test
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      pRtctResult - The result of RTCT result
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port ID.
+ *      RT_ERR_PHY_RTCT_NOT_FINISH  - Testing does not finish.
+ * Note:
+ *      The API can get RTCT test result.
+ *      RTCT test may takes 4.8 seconds to finish its test at most.
+ *      Thus, if this API return RT_ERR_PHY_RTCT_NOT_FINISH or
+ *      other error code, the result can not be referenced and
+ *      user should call this API again until this API returns
+ *      a RT_ERR_OK.
+ *      The result is stored at pRtctResult->ge_result
+ *      pRtctResult->linkType is unused.
+ *      The unit of channel length is 2.5cm. Ex. 300 means 300 * 2.5 = 750cm = 7.5M
+ */
+rtk_api_ret_t rtk_port_rtctResult_get(rtk_port_t port, rtk_rtctResult_t *pRtctResult)
+{
+    rtk_api_ret_t               retVal;
+    rtl8367c_port_rtct_result_t result;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_IS_UTP(port);
+
+    memset(pRtctResult, 0x00, sizeof(rtk_rtctResult_t));
+    if ((retVal = rtl8367c_getAsicPortRTCTResult(port, &result))!=RT_ERR_OK)
+        return retVal;
+
+    pRtctResult->result.ge_result.channelALen = result.channelALen;
+    pRtctResult->result.ge_result.channelBLen = result.channelBLen;
+    pRtctResult->result.ge_result.channelCLen = result.channelCLen;
+    pRtctResult->result.ge_result.channelDLen = result.channelDLen;
+
+    pRtctResult->result.ge_result.channelALinedriver = result.channelALinedriver;
+    pRtctResult->result.ge_result.channelBLinedriver = result.channelBLinedriver;
+    pRtctResult->result.ge_result.channelCLinedriver = result.channelCLinedriver;
+    pRtctResult->result.ge_result.channelDLinedriver = result.channelDLinedriver;
+
+    pRtctResult->result.ge_result.channelAMismatch = result.channelAMismatch;
+    pRtctResult->result.ge_result.channelBMismatch = result.channelBMismatch;
+    pRtctResult->result.ge_result.channelCMismatch = result.channelCMismatch;
+    pRtctResult->result.ge_result.channelDMismatch = result.channelDMismatch;
+
+    pRtctResult->result.ge_result.channelAOpen = result.channelAOpen;
+    pRtctResult->result.ge_result.channelBOpen = result.channelBOpen;
+    pRtctResult->result.ge_result.channelCOpen = result.channelCOpen;
+    pRtctResult->result.ge_result.channelDOpen = result.channelDOpen;
+
+    pRtctResult->result.ge_result.channelAShort = result.channelAShort;
+    pRtctResult->result.ge_result.channelBShort = result.channelBShort;
+    pRtctResult->result.ge_result.channelCShort = result.channelCShort;
+    pRtctResult->result.ge_result.channelDShort = result.channelDShort;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_port_sds_reset
+ * Description:
+ *      Reset Serdes
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port ID.
+ * Note:
+ *      The API can reset Serdes
+ */
+rtk_api_ret_t rtk_port_sds_reset(rtk_port_t port)
+{
+    rtk_uint32 ext_id;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    if(rtk_switch_isSgmiiPort(port) != RT_ERR_OK)
+        return RT_ERR_PORT_ID;
+
+    ext_id = port - 15;
+    return rtl8367c_sdsReset(ext_id);
+}
+
+/* Function Name:
+ *      rtk_port_sgmiiLinkStatus_get
+ * Description:
+ *      Get SGMII status
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      pSignalDetect   - Signal detect
+ *      pSync           - Sync
+ *      pLink           - Link
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port ID.
+ * Note:
+ *      The API can reset Serdes
+ */
+rtk_api_ret_t rtk_port_sgmiiLinkStatus_get(rtk_port_t port, rtk_data_t *pSignalDetect, rtk_data_t *pSync, rtk_port_linkStatus_t *pLink)
+{
+    rtk_uint32 ext_id;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    if(rtk_switch_isSgmiiPort(port) != RT_ERR_OK)
+        return RT_ERR_PORT_ID;
+
+    if(NULL == pSignalDetect)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pSync)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pLink)
+        return RT_ERR_NULL_POINTER;
+
+    ext_id = port - 15;
+    return rtl8367c_getSdsLinkStatus(ext_id, (rtk_uint32 *)pSignalDetect, (rtk_uint32 *)pSync, (rtk_uint32 *)pLink);
+}
+
+/* Function Name:
+ *      rtk_port_sgmiiNway_set
+ * Description:
+ *      Configure SGMII/HSGMII port Nway state
+ * Input:
+ *      port        - Port ID
+ *      state       - Nway state
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port ID.
+ * Note:
+ *      The API configure SGMII/HSGMII port Nway state
+ */
+rtk_api_ret_t rtk_port_sgmiiNway_set(rtk_port_t port, rtk_enable_t state)
+{
+    rtk_uint32 ext_id;
+
+     /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    if(rtk_switch_isSgmiiPort(port) != RT_ERR_OK)
+        return RT_ERR_PORT_ID;
+
+    if(state >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    ext_id = port - 15;
+    return rtl8367c_setSgmiiNway(ext_id, (rtk_uint32)state);
+}
+
+/* Function Name:
+ *      rtk_port_sgmiiNway_get
+ * Description:
+ *      Get SGMII/HSGMII port Nway state
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      pState      - Nway state
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port ID.
+ * Note:
+ *      The API can get SGMII/HSGMII port Nway state
+ */
+rtk_api_ret_t rtk_port_sgmiiNway_get(rtk_port_t port, rtk_enable_t *pState)
+{
+    rtk_uint32 ext_id;
+
+     /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    if(rtk_switch_isSgmiiPort(port) != RT_ERR_OK)
+        return RT_ERR_PORT_ID;
+
+    if(NULL == pState)
+        return RT_ERR_NULL_POINTER;
+
+    ext_id = port - 15;
+    return rtl8367c_getSgmiiNway(ext_id, (rtk_uint32 *)pState);
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/ptp.c b/drivers/net/phy/rtk/rtl8367c/ptp.c
new file mode 100644
index 0000000000000..7a803fe0ec8c3
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/ptp.c
@@ -0,0 +1,759 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 39583 $
+ * $Date: 2013-05-20 16:59:23 +0800 (星期一, 20 五月 2013) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in time module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <ptp.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_eav.h>
+
+/* Function Name:
+ *      rtk_ptp_init
+ * Description:
+ *      PTP function initialization.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API is used to initialize PTP status.
+ */
+rtk_api_ret_t rtk_ptp_init(void)
+{
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_mac_set
+ * Description:
+ *      Configure PTP mac address.
+ * Input:
+ *      mac - mac address to parser PTP packets.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_mac_set(rtk_mac_t mac)
+{
+    rtk_api_ret_t retVal;
+    ether_addr_t sw_mac;
+
+    memcpy(sw_mac.octet, mac.octet, ETHER_ADDR_LEN);
+
+    if((retVal=rtl8367c_setAsicEavMacAddress(sw_mac))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_mac_get
+ * Description:
+ *      Get PTP mac address.
+ * Input:
+ *      None
+ * Output:
+ *      pMac - mac address to parser PTP packets.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_mac_get(rtk_mac_t *pMac)
+{
+    rtk_api_ret_t retVal;
+    ether_addr_t sw_mac;
+
+    if((retVal=rtl8367c_getAsicEavMacAddress(&sw_mac))!=RT_ERR_OK)
+        return retVal;
+
+    memcpy(pMac->octet, sw_mac.octet, ETHER_ADDR_LEN);
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_tpid_set
+ * Description:
+ *      Configure PTP accepted outer & inner tag TPID.
+ * Input:
+ *      outerId - Ether type of S-tag frame parsing in PTP ports.
+ *      innerId - Ether type of C-tag frame parsing in PTP ports.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_tpid_set(rtk_ptp_tpid_t outerId, rtk_ptp_tpid_t innerId)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((outerId>RTK_MAX_NUM_OF_TPID) ||(innerId>RTK_MAX_NUM_OF_TPID))
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicEavTpid(outerId, innerId)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_tpid_get
+ * Description:
+ *      Get PTP accepted outer & inner tag TPID.
+ * Input:
+ *      None
+ * Output:
+ *      pOuterId - Ether type of S-tag frame parsing in PTP ports.
+ *      pInnerId - Ether type of C-tag frame parsing in PTP ports.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_tpid_get(rtk_ptp_tpid_t *pOuterId, rtk_ptp_tpid_t *pInnerId)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_getAsicEavTpid(pOuterId, pInnerId)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_refTime_set
+ * Description:
+ *      Set the reference time of the specified device.
+ * Input:
+ *      timeStamp - reference timestamp value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT    - invalid input parameter
+ * Applicable:
+ *      8390, 8380
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_refTime_set(rtk_ptp_timeStamp_t timeStamp)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (timeStamp.nsec > RTK_MAX_NUM_OF_NANO_SECOND)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicEavSysTime(timeStamp.sec, timeStamp.nsec))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_refTime_get
+ * Description:
+ *      Get the reference time of the specified device.
+ * Input:
+ * Output:
+ *      pTimeStamp - pointer buffer of the reference time
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID      - invalid unit id
+ *      RT_ERR_NOT_INIT     - The module is not initial
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Applicable:
+ *      8390, 8380
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_refTime_get(rtk_ptp_timeStamp_t *pTimeStamp)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_getAsicEavSysTime(&pTimeStamp->sec, &pTimeStamp->nsec))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_refTimeAdjust_set
+ * Description:
+ *      Adjust the reference time.
+ * Input:
+ *      unit      - unit id
+ *      sign      - significant
+ *      timeStamp - reference timestamp value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID  - invalid unit id
+ *      RT_ERR_NOT_INIT - The module is not initial
+ *      RT_ERR_INPUT    - invalid input parameter
+ * Note:
+ *      sign=0 for positive adjustment, sign=1 for negative adjustment.
+ */
+rtk_api_ret_t rtk_ptp_refTimeAdjust_set(rtk_ptp_sys_adjust_t sign, rtk_ptp_timeStamp_t timeStamp)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (timeStamp.nsec > RTK_MAX_NUM_OF_NANO_SECOND)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicEavSysTimeAdjust(sign, timeStamp.sec, timeStamp.nsec))!=RT_ERR_OK)
+        return retVal;
+
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_refTimeEnable_set
+ * Description:
+ *      Set the enable state of reference time of the specified device.
+ * Input:
+ *      enable - status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT    - invalid input parameter
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_refTimeEnable_set(rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicEavSysTimeCtrl(enable))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_refTimeEnable_get
+ * Description:
+ *      Get the enable state of reference time of the specified device.
+ * Input:
+ * Output:
+ *      pEnable - status
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID      - invalid unit id
+ *      RT_ERR_NOT_INIT     - The module is not initial
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Applicable:
+ *      8390, 8380
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_refTimeEnable_get(rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_getAsicEavSysTimeCtrl(pEnable))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_portEnable_set
+ * Description:
+ *      Set PTP status of the specified port.
+ * Input:
+ *      port   - port id
+ *      enable - status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT     - invalid port id
+ *      RT_ERR_INPUT    - invalid input parameter
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_portEnable_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port is PTP port */
+    RTK_CHK_PORT_IS_PTP(port);
+
+    if (enable>=RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicEavPortEnable(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_portEnable_get
+ * Description:
+ *      Get PTP status of the specified port.
+ * Input:
+ *      port    - port id
+ * Output:
+ *      pEnable - status
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT         - invalid port id
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_portEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port is PTP port */
+    RTK_CHK_PORT_IS_PTP(port);
+
+    if ((retVal = rtl8367c_getAsicEavPortEnable(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_ptp_portTimestamp_get
+ * Description:
+ *      Get PTP timstamp according to the PTP identifier on the dedicated port from the specified device.
+ * Input:
+ *      unit       - unit id
+ *      port       - port id
+ *      type       - PTP message type
+ * Output:
+ *      pInfo      - pointer buffer of sequence ID and timestamp
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID      - invalid port id
+ *      RT_ERR_INPUT        - invalid input parameter
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Applicable:
+ *      8390, 8380
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_portTimestamp_get( rtk_port_t port, rtk_ptp_msgType_t type, rtk_ptp_info_t *pInfo)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_ptp_time_stamp_t time;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port is PTP port */
+    RTK_CHK_PORT_IS_PTP(port);
+
+    if ((retVal = rtl8367c_getAsicEavPortTimeStamp(rtk_switch_port_L2P_get(port), type, &time)) != RT_ERR_OK)
+        return retVal;
+
+    pInfo->sequenceId = time.sequence_id;
+    pInfo->timeStamp.sec = time.second;
+    pInfo->timeStamp.nsec = time.nano_second;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_intControl_set
+ * Description:
+ *      Set PTP interrupt trigger status configuration.
+ * Input:
+ *      type - Interrupt type.
+ *      enable - Interrupt status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      The API can set PTP interrupt status configuration.
+ *      The interrupt trigger status is shown in the following:
+ *          PTP_INT_TYPE_TX_SYNC = 0,
+ *          PTP_INT_TYPE_TX_DELAY_REQ,
+ *          PTP_INT_TYPE_TX_PDELAY_REQ,
+ *          PTP_INT_TYPE_TX_PDELAY_RESP,
+ *          PTP_INT_TYPE_RX_SYNC,
+ *          PTP_INT_TYPE_RX_DELAY_REQ,
+ *          PTP_INT_TYPE_RX_PDELAY_REQ,
+ *          PTP_INT_TYPE_RX_PDELAY_RESP,
+ *          PTP_INT_TYPE_ALL,
+ */
+rtk_api_ret_t rtk_ptp_intControl_set(rtk_ptp_intType_t type, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 mask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type>=PTP_INT_TYPE_END)
+        return RT_ERR_INPUT;
+
+    if (PTP_INT_TYPE_ALL!=type)
+    {
+        if ((retVal = rtl8367c_getAsicEavInterruptMask(&mask)) != RT_ERR_OK)
+            return retVal;
+
+        if (ENABLED == enable)
+            mask = mask | (1<<type);
+        else if (DISABLED == enable)
+            mask = mask & ~(1<<type);
+        else
+            return RT_ERR_INPUT;
+
+        if ((retVal = rtl8367c_setAsicEavInterruptMask(mask)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        if (ENABLED == enable)
+            mask = RTK_PTP_INTR_MASK;
+        else if (DISABLED == enable)
+            mask = 0;
+        else
+            return RT_ERR_INPUT;
+
+        if ((retVal = rtl8367c_setAsicEavInterruptMask(mask)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_intControl_get
+ * Description:
+ *      Get PTP interrupt trigger status configuration.
+ * Input:
+ *      type - Interrupt type.
+ * Output:
+ *      pEnable - Interrupt status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get interrupt status configuration.
+ *      The interrupt trigger status is shown in the following:
+ *          PTP_INT_TYPE_TX_SYNC = 0,
+ *          PTP_INT_TYPE_TX_DELAY_REQ,
+ *          PTP_INT_TYPE_TX_PDELAY_REQ,
+ *          PTP_INT_TYPE_TX_PDELAY_RESP,
+ *          PTP_INT_TYPE_RX_SYNC,
+ *          PTP_INT_TYPE_RX_DELAY_REQ,
+ *          PTP_INT_TYPE_RX_PDELAY_REQ,
+ *          PTP_INT_TYPE_RX_PDELAY_RESP,
+ */
+rtk_api_ret_t rtk_ptp_intControl_get(rtk_ptp_intType_t type, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 mask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type>=PTP_INT_TYPE_ALL)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_getAsicEavInterruptMask(&mask)) != RT_ERR_OK)
+        return retVal;
+
+    if (0 == (mask&(1<<type)))
+        *pEnable=DISABLED;
+    else
+        *pEnable=ENABLED;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_intStatus_get
+ * Description:
+ *      Get PTP port interrupt trigger status.
+ * Input:
+ *      port           - physical port
+ * Output:
+ *      pStatusMask - Interrupt status bit mask.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get interrupt trigger status when interrupt happened.
+ *      The interrupt trigger status is shown in the following:
+ *      - PORT 0  INT    (value[0] (Bit0))
+ *      - PORT 1  INT    (value[0] (Bit1))
+ *      - PORT 2  INT    (value[0] (Bit2))
+ *      - PORT 3  INT    (value[0] (Bit3))
+ *      - PORT 4  INT   (value[0] (Bit4))
+
+ *
+ */
+rtk_api_ret_t rtk_ptp_intStatus_get(rtk_ptp_intStatus_t *pStatusMask)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pStatusMask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicEavInterruptStatus(pStatusMask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+
+/* Function Name:
+ *      rtk_ptp_portIntStatus_set
+ * Description:
+ *      Set PTP port interrupt trigger status to clean.
+ * Input:
+ *      port           - physical port
+ *      statusMask - Interrupt status bit mask.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT - Invalid input parameters.
+ * Note:
+ *      The API can clean interrupt trigger status when interrupt happened.
+ *      The interrupt trigger status is shown in the following:
+ *      - PTP_INT_TYPE_TX_SYNC              (value[0] (Bit0))
+ *      - PTP_INT_TYPE_TX_DELAY_REQ      (value[0] (Bit1))
+ *      - PTP_INT_TYPE_TX_PDELAY_REQ    (value[0] (Bit2))
+ *      - PTP_INT_TYPE_TX_PDELAY_RESP   (value[0] (Bit3))
+ *      - PTP_INT_TYPE_RX_SYNC              (value[0] (Bit4))
+ *      - PTP_INT_TYPE_RX_DELAY_REQ      (value[0] (Bit5))
+ *      - PTP_INT_TYPE_RX_PDELAY_REQ    (value[0] (Bit6))
+ *      - PTP_INT_TYPE_RX_PDELAY_RESP   (value[0] (Bit7))
+ *      The status will be cleared after execute this API.
+ */
+rtk_api_ret_t rtk_ptp_portIntStatus_set(rtk_port_t port, rtk_ptp_intStatus_t statusMask)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port is PTP port */
+    RTK_CHK_PORT_IS_PTP(port);
+
+    if ((retVal = rtl8367c_setAsicEavPortInterruptStatus(rtk_switch_port_L2P_get(port), statusMask))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_portIntStatus_get
+ * Description:
+ *      Get PTP port interrupt trigger status.
+ * Input:
+ *      port           - physical port
+ * Output:
+ *      pStatusMask - Interrupt status bit mask.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get interrupt trigger status when interrupt happened.
+ *      The interrupt trigger status is shown in the following:
+ *      - PTP_INT_TYPE_TX_SYNC              (value[0] (Bit0))
+ *      - PTP_INT_TYPE_TX_DELAY_REQ      (value[0] (Bit1))
+ *      - PTP_INT_TYPE_TX_PDELAY_REQ    (value[0] (Bit2))
+ *      - PTP_INT_TYPE_TX_PDELAY_RESP   (value[0] (Bit3))
+ *      - PTP_INT_TYPE_RX_SYNC              (value[0] (Bit4))
+ *      - PTP_INT_TYPE_RX_DELAY_REQ      (value[0] (Bit5))
+ *      - PTP_INT_TYPE_RX_PDELAY_REQ    (value[0] (Bit6))
+ *      - PTP_INT_TYPE_RX_PDELAY_RESP   (value[0] (Bit7))
+ *
+ */
+rtk_api_ret_t rtk_ptp_portIntStatus_get(rtk_port_t port, rtk_ptp_intStatus_t *pStatusMask)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port is PTP port */
+    RTK_CHK_PORT_IS_PTP(port);
+
+    if(NULL == pStatusMask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicEavPortInterruptStatus(rtk_switch_port_L2P_get(port), pStatusMask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_portPtpTrap_set
+ * Description:
+ *      Set PTP packet trap of the specified port.
+ * Input:
+ *      port   - port id
+ *      enable - status
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT     - invalid port id
+ *      RT_ERR_INPUT    - invalid input parameter
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_portTrap_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (enable>=RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicEavTrap(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_ptp_portPtpEnable_get
+ * Description:
+ *      Get PTP packet trap of the specified port.
+ * Input:
+ *      port    - port id
+ * Output:
+ *      pEnable - status
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT         - invalid port id
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_ptp_portTrap_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicEavTrap(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/qos.c b/drivers/net/phy/rtk/rtl8367c/qos.c
new file mode 100644
index 0000000000000..84e6f6764c397
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/qos.c
@@ -0,0 +1,1452 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in QoS module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <qos.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_qos.h>
+#include <rtl8367c_asicdrv_fc.h>
+#include <rtl8367c_asicdrv_scheduling.h>
+
+/* Function Name:
+ *      rtk_qos_init
+ * Description:
+ *      Configure Qos default settings with queue number assigment to each port.
+ * Input:
+ *      queueNum - Queue number of each port.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_QUEUE_NUM    - Invalid queue number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API will initialize related Qos setting with queue number assigment.
+ *      The queue number is from 1 to 8.
+ */
+rtk_api_ret_t rtk_qos_init(rtk_queue_num_t queueNum)
+{
+    CONST_T rtk_uint16 g_prioritytToQid[8][8]= {
+            {0, 0,0,0,0,0,0,0},
+            {0, 0,0,0,7,7,7,7},
+            {0, 0,0,0,1,1,7,7},
+            {0, 0,1,1,2,2,7,7},
+            {0, 0,1,1,2,3,7,7},
+            {0, 0,1,2,3,4,7,7},
+            {0, 0,1,2,3,4,5,7},
+            {0,1,2,3,4,5,6,7}
+    };
+
+    CONST_T rtk_uint32 g_priorityDecision[8] = {0x01, 0x80,0x04,0x02,0x20,0x40,0x10,0x08};
+    CONST_T rtk_uint32 g_prioritytRemap[8] = {0,1,2,3,4,5,6,7};
+
+    rtk_api_ret_t retVal;
+    rtk_uint32 qmapidx;
+    rtk_uint32 priority;
+    rtk_uint32 priDec;
+    rtk_uint32 port;
+    rtk_uint32 dscp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (queueNum <= 0 || queueNum > RTK_MAX_NUM_OF_QUEUE)
+        return RT_ERR_QUEUE_NUM;
+
+    /*Set Output Queue Number*/
+    if (RTK_MAX_NUM_OF_QUEUE == queueNum)
+        qmapidx = 0;
+    else
+        qmapidx = queueNum;
+
+    RTK_SCAN_ALL_PHY_PORTMASK(port)
+    {
+        if ((retVal = rtl8367c_setAsicOutputQueueMappingIndex(port, qmapidx)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /*Set Priority to Qid*/
+    for (priority = 0; priority <= RTK_PRIMAX; priority++)
+    {
+        if ((retVal = rtl8367c_setAsicPriorityToQIDMappingTable(queueNum - 1, priority, g_prioritytToQid[queueNum - 1][priority])) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /*Set Flow Control Type to Ingress Flow Control*/
+    if ((retVal = rtl8367c_setAsicFlowControlSelect(FC_INGRESS)) != RT_ERR_OK)
+        return retVal;
+
+
+    /*Priority Decision Order*/
+    for (priDec = 0;priDec < PRIDEC_END;priDec++)
+    {
+        if ((retVal = rtl8367c_setAsicPriorityDecision(PRIDECTBL_IDX0, priDec, g_priorityDecision[priDec])) != RT_ERR_OK)
+            return retVal;
+        if ((retVal = rtl8367c_setAsicPriorityDecision(PRIDECTBL_IDX1, priDec, g_priorityDecision[priDec])) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /*Set Port-based Priority to 0*/
+    RTK_SCAN_ALL_PHY_PORTMASK(port)
+    {
+        if ((retVal = rtl8367c_setAsicPriorityPortBased(port, 0)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /*Disable 1p Remarking*/
+    RTK_SCAN_ALL_PHY_PORTMASK(port)
+    {
+        if ((retVal = rtl8367c_setAsicRemarkingDot1pAbility(port, DISABLED)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /*Disable DSCP Remarking*/
+    if ((retVal = rtl8367c_setAsicRemarkingDscpAbility(DISABLED)) != RT_ERR_OK)
+        return retVal;
+
+    /*Set 1p & DSCP  Priority Remapping & Remarking*/
+    for (priority = 0; priority <= RTL8367C_PRIMAX; priority++)
+    {
+        if ((retVal = rtl8367c_setAsicPriorityDot1qRemapping(priority, g_prioritytRemap[priority])) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicRemarkingDot1pParameter(priority, 0)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_setAsicRemarkingDscpParameter(priority, 0)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /*Set DSCP Priority*/
+    for (dscp = 0; dscp <= 63; dscp++)
+    {
+        if ((retVal = rtl8367c_setAsicPriorityDscpBased(dscp, 0)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /* Finetune B/T value */
+    if((retVal = rtl8367c_setAsicReg(0x1722, 0x1158)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_priSel_set
+ * Description:
+ *      Configure the priority order among different priority mechanism.
+ * Input:
+ *      index - Priority decision table index (0~1)
+ *      pPriDec - Priority assign for port, dscp, 802.1p, cvlan, svlan, acl based priority decision.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_QOS_SEL_PRI_SOURCE   - Invalid priority decision source parameter.
+ * Note:
+ *      ASIC will follow user priority setting of mechanisms to select mapped queue priority for receiving frame.
+ *      If two priority mechanisms are the same, the ASIC will chose the highest priority from mechanisms to
+ *      assign queue priority to receiving frame.
+ *      The priority sources are:
+ *      - PRIDEC_PORT
+ *      - PRIDEC_ACL
+ *      - PRIDEC_DSCP
+ *      - PRIDEC_1Q
+ *      - PRIDEC_1AD
+ *      - PRIDEC_CVLAN
+ *      - PRIDEC_DA
+ *      - PRIDEC_SA
+ */
+rtk_api_ret_t rtk_qos_priSel_set(rtk_qos_priDecTbl_t index, rtk_priority_select_t *pPriDec)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 port_pow;
+    rtk_uint32 dot1q_pow;
+    rtk_uint32 dscp_pow;
+    rtk_uint32 acl_pow;
+    rtk_uint32 svlan_pow;
+    rtk_uint32 cvlan_pow;
+    rtk_uint32 smac_pow;
+    rtk_uint32 dmac_pow;
+    rtk_uint32 i;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (index < 0 || index >= PRIDECTBL_END)
+        return RT_ERR_ENTRY_INDEX;
+
+    if (pPriDec->port_pri >= 8 || pPriDec->dot1q_pri >= 8 || pPriDec->acl_pri >= 8 || pPriDec->dscp_pri >= 8 ||
+       pPriDec->cvlan_pri >= 8 || pPriDec->svlan_pri >= 8 || pPriDec->dmac_pri >= 8 || pPriDec->smac_pri >= 8)
+        return RT_ERR_QOS_SEL_PRI_SOURCE;
+
+    port_pow = 1;
+    for (i = pPriDec->port_pri; i > 0; i--)
+        port_pow = (port_pow)*2;
+
+    dot1q_pow = 1;
+    for (i = pPriDec->dot1q_pri; i > 0; i--)
+        dot1q_pow = (dot1q_pow)*2;
+
+    acl_pow = 1;
+    for (i = pPriDec->acl_pri; i > 0; i--)
+        acl_pow = (acl_pow)*2;
+
+    dscp_pow = 1;
+    for (i = pPriDec->dscp_pri; i > 0; i--)
+        dscp_pow = (dscp_pow)*2;
+
+    svlan_pow = 1;
+    for (i = pPriDec->svlan_pri; i > 0; i--)
+        svlan_pow = (svlan_pow)*2;
+
+    cvlan_pow = 1;
+    for (i = pPriDec->cvlan_pri; i > 0; i--)
+        cvlan_pow = (cvlan_pow)*2;
+
+    dmac_pow = 1;
+    for (i = pPriDec->dmac_pri; i > 0; i--)
+        dmac_pow = (dmac_pow)*2;
+
+    smac_pow = 1;
+    for (i = pPriDec->smac_pri; i > 0; i--)
+        smac_pow = (smac_pow)*2;
+
+    if ((retVal = rtl8367c_setAsicPriorityDecision(index, PRIDEC_PORT, port_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPriorityDecision(index, PRIDEC_ACL, acl_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPriorityDecision(index, PRIDEC_DSCP, dscp_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPriorityDecision(index, PRIDEC_1Q, dot1q_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPriorityDecision(index, PRIDEC_1AD, svlan_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPriorityDecision(index, PRIDEC_CVLAN, cvlan_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPriorityDecision(index, PRIDEC_DA, dmac_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPriorityDecision(index, PRIDEC_SA, smac_pow)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_priSel_get
+ * Description:
+ *      Get the priority order configuration among different priority mechanism.
+ * Input:
+ *      index - Priority decision table index (0~1)
+ * Output:
+ *      pPriDec - Priority assign for port, dscp, 802.1p, cvlan, svlan, acl based priority decision .
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      ASIC will follow user priority setting of mechanisms to select mapped queue priority for receiving frame.
+ *      If two priority mechanisms are the same, the ASIC will chose the highest priority from mechanisms to
+ *      assign queue priority to receiving frame.
+ *      The priority sources are:
+ *      - PRIDEC_PORT,
+ *      - PRIDEC_ACL,
+ *      - PRIDEC_DSCP,
+ *      - PRIDEC_1Q,
+ *      - PRIDEC_1AD,
+ *      - PRIDEC_CVLAN,
+ *      - PRIDEC_DA,
+ *      - PRIDEC_SA,
+ */
+rtk_api_ret_t rtk_qos_priSel_get(rtk_qos_priDecTbl_t index, rtk_priority_select_t *pPriDec)
+{
+
+    rtk_api_ret_t retVal;
+    rtk_int32 i;
+    rtk_uint32 port_pow;
+    rtk_uint32 dot1q_pow;
+    rtk_uint32 dscp_pow;
+    rtk_uint32 acl_pow;
+    rtk_uint32 svlan_pow;
+    rtk_uint32 cvlan_pow;
+    rtk_uint32 smac_pow;
+    rtk_uint32 dmac_pow;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (index < 0 || index >= PRIDECTBL_END)
+        return RT_ERR_ENTRY_INDEX;
+
+    if ((retVal = rtl8367c_getAsicPriorityDecision(index, PRIDEC_PORT, &port_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPriorityDecision(index, PRIDEC_ACL, &acl_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPriorityDecision(index, PRIDEC_DSCP, &dscp_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPriorityDecision(index, PRIDEC_1Q, &dot1q_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPriorityDecision(index, PRIDEC_1AD, &svlan_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPriorityDecision(index, PRIDEC_CVLAN, &cvlan_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPriorityDecision(index, PRIDEC_DA, &dmac_pow)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPriorityDecision(index, PRIDEC_SA, &smac_pow)) != RT_ERR_OK)
+        return retVal;
+
+    for (i = 31; i >= 0; i--)
+    {
+        if (port_pow & (1 << i))
+        {
+            pPriDec->port_pri = i;
+            break;
+        }
+    }
+
+    for (i = 31; i >= 0; i--)
+    {
+        if (dot1q_pow & (1 << i))
+        {
+            pPriDec->dot1q_pri = i;
+            break;
+        }
+    }
+
+    for (i = 31; i >= 0; i--)
+    {
+        if (acl_pow & (1 << i))
+        {
+            pPriDec->acl_pri = i;
+            break;
+        }
+    }
+
+    for (i = 31; i >= 0; i--)
+    {
+        if (dscp_pow & (1 << i))
+        {
+            pPriDec->dscp_pri = i;
+            break;
+        }
+    }
+
+    for (i = 31; i >= 0; i--)
+    {
+        if (svlan_pow & (1 << i))
+        {
+            pPriDec->svlan_pri = i;
+            break;
+        }
+    }
+
+    for (i = 31;i  >= 0; i--)
+    {
+        if (cvlan_pow & (1 << i))
+        {
+            pPriDec->cvlan_pri = i;
+            break;
+        }
+    }
+
+    for (i = 31; i >= 0; i--)
+    {
+        if (dmac_pow&(1<<i))
+        {
+            pPriDec->dmac_pri = i;
+            break;
+        }
+    }
+
+    for (i = 31; i >= 0; i--)
+    {
+        if (smac_pow & (1 << i))
+        {
+            pPriDec->smac_pri = i;
+            break;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_1pPriRemap_set
+ * Description:
+ *      Configure 1Q priorities mapping to internal absolute priority.
+ * Input:
+ *      dot1p_pri   - 802.1p priority value.
+ *      int_pri     - internal priority value.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_VLAN_PRIORITY    - Invalid 1p priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      Priority of 802.1Q assignment for internal asic priority, and it is used for queue usage and packet scheduling.
+ */
+rtk_api_ret_t rtk_qos_1pPriRemap_set(rtk_pri_t dot1p_pri, rtk_pri_t int_pri)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (dot1p_pri > RTL8367C_PRIMAX || int_pri > RTL8367C_PRIMAX)
+        return  RT_ERR_VLAN_PRIORITY;
+
+    if ((retVal = rtl8367c_setAsicPriorityDot1qRemapping(dot1p_pri, int_pri)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_1pPriRemap_get
+ * Description:
+ *      Get 1Q priorities mapping to internal absolute priority.
+ * Input:
+ *      dot1p_pri - 802.1p priority value .
+ * Output:
+ *      pInt_pri - internal priority value.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_VLAN_PRIORITY    - Invalid priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      Priority of 802.1Q assigment for internal asic priority, and it is uesed for queue usage and packet scheduling.
+ */
+rtk_api_ret_t rtk_qos_1pPriRemap_get(rtk_pri_t dot1p_pri, rtk_pri_t *pInt_pri)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (dot1p_pri > RTL8367C_PRIMAX)
+        return  RT_ERR_QOS_INT_PRIORITY;
+
+    if ((retVal = rtl8367c_getAsicPriorityDot1qRemapping(dot1p_pri, pInt_pri)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_dscpPriRemap_set
+ * Description:
+ *      Map dscp value to internal priority.
+ * Input:
+ *      dscp    - Dscp value of receiving frame
+ *      int_pri - internal priority value .
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid DSCP value.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      The Differentiated Service Code Point is a selector for router's per-hop behaviors. As a selector, there is no implication that a numerically
+ *      greater DSCP implies a better network service. As can be seen, the DSCP totally overlaps the old precedence field of TOS. So if values of
+ *      DSCP are carefully chosen then backward compatibility can be achieved.
+ */
+rtk_api_ret_t rtk_qos_dscpPriRemap_set(rtk_dscp_t dscp, rtk_pri_t int_pri)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (int_pri > RTL8367C_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if (dscp > RTL8367C_DSCPMAX)
+        return RT_ERR_QOS_DSCP_VALUE;
+
+    if ((retVal = rtl8367c_setAsicPriorityDscpBased(dscp, int_pri)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_dscpPriRemap_get
+ * Description:
+ *      Get dscp value to internal priority.
+ * Input:
+ *      dscp - Dscp value of receiving frame
+ * Output:
+ *      pInt_pri - internal priority value.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid DSCP value.
+ * Note:
+ *      The Differentiated Service Code Point is a selector for router's per-hop behaviors. As a selector, there is no implication that a numerically
+ *      greater DSCP implies a better network service. As can be seen, the DSCP totally overlaps the old precedence field of TOS. So if values of
+ *      DSCP are carefully chosen then backward compatibility can be achieved.
+ */
+rtk_api_ret_t rtk_qos_dscpPriRemap_get(rtk_dscp_t dscp, rtk_pri_t *pInt_pri)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (dscp > RTL8367C_DSCPMAX)
+        return RT_ERR_QOS_DSCP_VALUE;
+
+    if ((retVal = rtl8367c_getAsicPriorityDscpBased(dscp, pInt_pri)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_portPri_set
+ * Description:
+ *      Configure priority usage to each port.
+ * Input:
+ *      port - Port id.
+ *      int_pri - internal priority value.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_QOS_SEL_PORT_PRI - Invalid port priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      The API can set priority of port assignments for queue usage and packet scheduling.
+ */
+rtk_api_ret_t rtk_qos_portPri_set(rtk_port_t port, rtk_pri_t int_pri)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (int_pri > RTL8367C_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if ((retVal = rtl8367c_setAsicPriorityPortBased(rtk_switch_port_L2P_get(port), int_pri)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_portPri_get
+ * Description:
+ *      Get priority usage to each port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pInt_pri - internal priority value.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get priority of port assignments for queue usage and packet scheduling.
+ */
+rtk_api_ret_t rtk_qos_portPri_get(rtk_port_t port, rtk_pri_t *pInt_pri)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicPriorityPortBased(rtk_switch_port_L2P_get(port), pInt_pri)) != RT_ERR_OK)
+        return retVal;
+
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_queueNum_set
+ * Description:
+ *      Set output queue number for each port.
+ * Input:
+ *      port    - Port id.
+ *      index   - Mapping queue number (1~8)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_QUEUE_NUM    - Invalid queue number.
+ * Note:
+ *      The API can set the output queue number of the specified port. The queue number is from 1 to 8.
+ */
+rtk_api_ret_t rtk_qos_queueNum_set(rtk_port_t port, rtk_queue_num_t queue_num)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((0 == queue_num) || (queue_num > RTK_MAX_NUM_OF_QUEUE))
+        return RT_ERR_FAILED;
+
+    if (RTK_MAX_NUM_OF_QUEUE == queue_num)
+        queue_num = 0;
+
+    if ((retVal = rtl8367c_setAsicOutputQueueMappingIndex(rtk_switch_port_L2P_get(port), queue_num)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_queueNum_get
+ * Description:
+ *      Get output queue number.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pQueue_num - Mapping queue number
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API will return the output queue number of the specified port. The queue number is from 1 to 8.
+ */
+rtk_api_ret_t rtk_qos_queueNum_get(rtk_port_t port, rtk_queue_num_t *pQueue_num)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 qidx;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicOutputQueueMappingIndex(rtk_switch_port_L2P_get(port), &qidx)) != RT_ERR_OK)
+        return retVal;
+
+    if (0 == qidx)
+        *pQueue_num = 8;
+    else
+        *pQueue_num = qidx;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_priMap_set
+ * Description:
+ *      Set output queue number for each port.
+ * Input:
+ *      queue_num   - Queue number usage.
+ *      pPri2qid    - Priority mapping to queue ID.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_QUEUE_NUM        - Invalid queue number.
+ *      RT_ERR_QUEUE_ID         - Invalid queue id.
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      ASIC supports priority mapping to queue with different queue number from 1 to 8.
+ *      For different queue numbers usage, ASIC supports different internal available queue IDs.
+ */
+rtk_api_ret_t rtk_qos_priMap_set(rtk_queue_num_t queue_num, rtk_qos_pri2queue_t *pPri2qid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pri;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((0 == queue_num) || (queue_num > RTK_MAX_NUM_OF_QUEUE))
+        return RT_ERR_QUEUE_NUM;
+
+    for (pri = 0; pri <= RTK_PRIMAX; pri++)
+    {
+        if (pPri2qid->pri2queue[pri] > RTK_QIDMAX)
+            return RT_ERR_QUEUE_ID;
+
+        if ((retVal = rtl8367c_setAsicPriorityToQIDMappingTable(queue_num - 1, pri, pPri2qid->pri2queue[pri])) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_priMap_get
+ * Description:
+ *      Get priority to queue ID mapping table parameters.
+ * Input:
+ *      queue_num - Queue number usage.
+ * Output:
+ *      pPri2qid - Priority mapping to queue ID.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_QUEUE_NUM    - Invalid queue number.
+ * Note:
+ *      The API can return the mapping queue id of the specified priority and queue number.
+ *      The queue number is from 1 to 8.
+ */
+rtk_api_ret_t rtk_qos_priMap_get(rtk_queue_num_t queue_num, rtk_qos_pri2queue_t *pPri2qid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pri;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((0 == queue_num) || (queue_num > RTK_MAX_NUM_OF_QUEUE))
+        return RT_ERR_QUEUE_NUM;
+
+    for (pri = 0; pri <= RTK_PRIMAX; pri++)
+    {
+        if ((retVal = rtl8367c_getAsicPriorityToQIDMappingTable(queue_num-1, pri, &pPri2qid->pri2queue[pri])) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_schedulingQueue_set
+ * Description:
+ *      Set weight and type of queues in dedicated port.
+ * Input:
+ *      port        - Port id.
+ *      pQweights   - The array of weights for WRR/WFQ queue (0 for STRICT_PRIORITY queue).
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_QOS_QUEUE_WEIGHT - Invalid queue weight.
+ * Note:
+ *      The API can set weight and type, strict priority or weight fair queue (WFQ) for
+ *      dedicated port for using queues. If queue id is not included in queue usage,
+ *      then its type and weight setting in dummy for setting. There are priorities
+ *      as queue id in strict queues. It means strict queue id 5 carrying higher priority
+ *      than strict queue id 4. The WFQ queue weight is from 1 to 127, and weight 0 is
+ *      for strict priority queue type.
+ */
+rtk_api_ret_t rtk_qos_schedulingQueue_set(rtk_port_t port, rtk_qos_queue_weights_t *pQweights)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 qid;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    for (qid = 0; qid < RTL8367C_QUEUENO; qid ++)
+    {
+
+        if (pQweights->weights[qid] > QOS_WEIGHT_MAX)
+            return RT_ERR_QOS_QUEUE_WEIGHT;
+
+        if (0 == pQweights->weights[qid])
+        {
+            if ((retVal = rtl8367c_setAsicQueueType(rtk_switch_port_L2P_get(port), qid, QTYPE_STRICT)) != RT_ERR_OK)
+                return retVal;
+        }
+        else
+        {
+            if ((retVal = rtl8367c_setAsicQueueType(rtk_switch_port_L2P_get(port), qid, QTYPE_WFQ)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicWFQWeight(rtk_switch_port_L2P_get(port),qid, pQweights->weights[qid])) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_schedulingQueue_get
+ * Description:
+ *      Get weight and type of queues in dedicated port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pQweights - The array of weights for WRR/WFQ queue (0 for STRICT_PRIORITY queue).
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get weight and type, strict priority or weight fair queue (WFQ) for dedicated port for using queues.
+ *      The WFQ queue weight is from 1 to 127, and weight 0 is for strict priority queue type.
+ */
+rtk_api_ret_t rtk_qos_schedulingQueue_get(rtk_port_t port, rtk_qos_queue_weights_t *pQweights)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 qid,qtype,qweight;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    for (qid = 0; qid < RTL8367C_QUEUENO; qid++)
+    {
+        if ((retVal = rtl8367c_getAsicQueueType(rtk_switch_port_L2P_get(port), qid, &qtype)) != RT_ERR_OK)
+            return retVal;
+
+        if (QTYPE_STRICT == qtype)
+        {
+            pQweights->weights[qid] = 0;
+        }
+        else if (QTYPE_WFQ == qtype)
+        {
+            if ((retVal = rtl8367c_getAsicWFQWeight(rtk_switch_port_L2P_get(port), qid, &qweight)) != RT_ERR_OK)
+                return retVal;
+            pQweights->weights[qid] = qweight;
+        }
+    }
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_1pRemarkEnable_set
+ * Description:
+ *      Set 1p Remarking state
+ * Input:
+ *      port        - Port id.
+ *      enable      - State of per-port 1p Remarking
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid enable parameter.
+ * Note:
+ *      The API can enable or disable 802.1p remarking ability for whole system.
+ *      The status of 802.1p remark:
+ *      - DISABLED
+ *      - ENABLED
+ */
+rtk_api_ret_t rtk_qos_1pRemarkEnable_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicRemarkingDot1pAbility(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_1pRemarkEnable_get
+ * Description:
+ *      Get 802.1p remarking ability.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - Status of 802.1p remark.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get 802.1p remarking ability.
+ *      The status of 802.1p remark:
+ *      - DISABLED
+ *      - ENABLED
+ */
+rtk_api_ret_t rtk_qos_1pRemarkEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicRemarkingDot1pAbility(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_1pRemark_set
+ * Description:
+ *      Set 802.1p remarking parameter.
+ * Input:
+ *      int_pri     - Internal priority value.
+ *      dot1p_pri   - 802.1p priority value.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_VLAN_PRIORITY    - Invalid 1p priority.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      The API can set 802.1p parameters source priority and new priority.
+ */
+rtk_api_ret_t rtk_qos_1pRemark_set(rtk_pri_t int_pri, rtk_pri_t dot1p_pri)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (int_pri > RTL8367C_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if (dot1p_pri > RTL8367C_PRIMAX)
+        return RT_ERR_VLAN_PRIORITY;
+
+    if ((retVal = rtl8367c_setAsicRemarkingDot1pParameter(int_pri, dot1p_pri)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_1pRemark_get
+ * Description:
+ *      Get 802.1p remarking parameter.
+ * Input:
+ *      int_pri - Internal priority value.
+ * Output:
+ *      pDot1p_pri - 802.1p priority value.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      The API can get 802.1p remarking parameters. It would return new priority of ingress priority.
+ */
+rtk_api_ret_t rtk_qos_1pRemark_get(rtk_pri_t int_pri, rtk_pri_t *pDot1p_pri)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (int_pri > RTL8367C_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if ((retVal = rtl8367c_getAsicRemarkingDot1pParameter(int_pri, pDot1p_pri)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_1pRemarkSrcSel_set
+ * Description:
+ *      Set remarking source of 802.1p remarking.
+ * Input:
+ *      type      - remarking source
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID  - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+
+ * Note:
+ *      The API can configure 802.1p remark functionality to map original 802.1p value or internal
+ *      priority to TX DSCP value.
+ */
+rtk_api_ret_t rtk_qos_1pRemarkSrcSel_set(rtk_qos_1pRmkSrc_t type)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= DOT1P_RMK_SRC_END )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if ((retVal = rtl8367c_setAsicRemarkingDot1pSrc(type)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_1pRemarkSrcSel_get
+ * Description:
+ *      Get remarking source of 802.1p remarking.
+ * Input:
+ *      none
+ * Output:
+ *      pType      - remarking source
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+ *      RT_ERR_NULL_POINTER     - input parameter may be null pointer
+
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_qos_1pRemarkSrcSel_get(rtk_qos_1pRmkSrc_t *pType)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_getAsicRemarkingDot1pSrc(pType)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_qos_dscpRemarkEnable_set
+ * Description:
+ *      Set DSCP remarking ability.
+ * Input:
+ *      port    - Port id.
+ *      enable  - status of DSCP remark.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ *      RT_ERR_ENABLE           - Invalid enable parameter.
+ * Note:
+ *      The API can enable or disable DSCP remarking ability for whole system.
+ *      The status of DSCP remark:
+ *      - DISABLED
+ *      - ENABLED
+ */
+rtk_api_ret_t rtk_qos_dscpRemarkEnable_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /*for whole system function, the port value should be 0xFF*/
+    if (port != RTK_WHOLE_SYSTEM)
+        return RT_ERR_PORT_ID;
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicRemarkingDscpAbility(enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_dscpRemarkEnable_get
+ * Description:
+ *      Get DSCP remarking ability.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - status of DSCP remarking.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get DSCP remarking ability.
+ *      The status of DSCP remark:
+ *      - DISABLED
+ *      - ENABLED
+ */
+rtk_api_ret_t rtk_qos_dscpRemarkEnable_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /*for whole system function, the port value should be 0xFF*/
+    if (port != RTK_WHOLE_SYSTEM)
+        return RT_ERR_PORT_ID;
+
+    if ((retVal = rtl8367c_getAsicRemarkingDscpAbility(pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_dscpRemark_set
+ * Description:
+ *      Set DSCP remarking parameter.
+ * Input:
+ *      int_pri - Internal priority value.
+ *      dscp    - DSCP value.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid DSCP value.
+ * Note:
+ *      The API can set DSCP value and mapping priority.
+ */
+rtk_api_ret_t rtk_qos_dscpRemark_set(rtk_pri_t int_pri, rtk_dscp_t dscp)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (int_pri > RTK_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if (dscp > RTK_DSCPMAX)
+        return RT_ERR_QOS_DSCP_VALUE;
+
+    if ((retVal = rtl8367c_setAsicRemarkingDscpParameter(int_pri, dscp)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_qos_dscpRemark_get
+ * Description:
+ *      Get DSCP remarking parameter.
+ * Input:
+ *      int_pri - Internal priority value.
+ * Output:
+ *      Dscp - DSCP value.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority.
+ * Note:
+ *      The API can get DSCP parameters. It would return DSCP value for mapping priority.
+ */
+rtk_api_ret_t rtk_qos_dscpRemark_get(rtk_pri_t int_pri, rtk_dscp_t *pDscp)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (int_pri > RTK_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if ((retVal = rtl8367c_getAsicRemarkingDscpParameter(int_pri, pDscp)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_dscpRemarkSrcSel_set
+ * Description:
+ *      Set remarking source of DSCP remarking.
+ * Input:
+ *      type      - remarking source
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID  - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+
+ * Note:
+ *      The API can configure DSCP remark functionality to map original DSCP value or internal
+ *      priority to TX DSCP value.
+ */
+rtk_api_ret_t rtk_qos_dscpRemarkSrcSel_set(rtk_qos_dscpRmkSrc_t type)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= DSCP_RMK_SRC_END )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if ((retVal = rtl8367c_setAsicRemarkingDscpSrc(type)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_dcpRemarkSrcSel_get
+ * Description:
+ *      Get remarking source of DSCP remarking.
+ * Input:
+ *      none
+ * Output:
+ *      pType      - remarking source
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+ *      RT_ERR_NULL_POINTER     - input parameter may be null pointer
+
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_qos_dscpRemarkSrcSel_get(rtk_qos_dscpRmkSrc_t *pType)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_getAsicRemarkingDscpSrc(pType)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_dscpRemark2Dscp_set
+ * Description:
+ *      Set DSCP to remarked DSCP mapping.
+ * Input:
+ *      dscp    - DSCP value
+ *      rmkDscp - remarked DSCP value
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid dscp value
+ * Note:
+ *      dscp parameter can be DSCP value or internal priority according to configuration of API
+ *      dal_apollomp_qos_dscpRemarkSrcSel_set(), because DSCP remark functionality can map original DSCP
+ *      value or internal priority to TX DSCP value.
+ */
+rtk_api_ret_t rtk_qos_dscpRemark2Dscp_set(rtk_dscp_t dscp, rtk_dscp_t rmkDscp)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((dscp > RTK_DSCPMAX) || (rmkDscp > RTK_DSCPMAX))
+        return RT_ERR_QOS_DSCP_VALUE;
+
+    if ((retVal = rtl8367c_setAsicRemarkingDscp2Dscp(dscp, rmkDscp)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_dscpRemark2Dscp_get
+ * Description:
+ *      Get DSCP to remarked DSCP mapping.
+ * Input:
+ *      dscp    - DSCP value
+ * Output:
+ *      pDscp   - remarked DSCP value
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid dscp value
+ *      RT_ERR_NULL_POINTER     - NULL pointer
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_qos_dscpRemark2Dscp_get(rtk_dscp_t dscp, rtk_dscp_t *pDscp)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (dscp > RTK_DSCPMAX)
+        return RT_ERR_QOS_DSCP_VALUE;
+
+    if ((retVal = rtl8367c_getAsicRemarkingDscp2Dscp(dscp, pDscp)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_portPriSelIndex_set
+ * Description:
+ *      Configure priority decision index to each port.
+ * Input:
+ *      port - Port id.
+ *      index - priority decision index.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_ENTRY_INDEX - Invalid entry index.
+ * Note:
+ *      The API can set priority of port assignments for queue usage and packet scheduling.
+ */
+rtk_api_ret_t rtk_qos_portPriSelIndex_set(rtk_port_t port, rtk_qos_priDecTbl_t index)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (index >= PRIDECTBL_END )
+        return RT_ERR_ENTRY_INDEX;
+
+    if ((retVal = rtl8367c_setAsicPortPriorityDecisionIndex(rtk_switch_port_L2P_get(port), index)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_qos_portPriSelIndex_get
+ * Description:
+ *      Get priority decision index from each port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pIndex - priority decision index.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get priority of port assignments for queue usage and packet scheduling.
+ */
+rtk_api_ret_t rtk_qos_portPriSelIndex_get(rtk_port_t port, rtk_qos_priDecTbl_t *pIndex)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicPortPriorityDecisionIndex(rtk_switch_port_L2P_get(port), pIndex)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rate.c b/drivers/net/phy/rtk/rtl8367c/rate.c
new file mode 100644
index 0000000000000..542b48a79fab5
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rate.c
@@ -0,0 +1,607 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in rate module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <rate.h>
+#include <qos.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_meter.h>
+#include <rtl8367c_asicdrv_inbwctrl.h>
+#include <rtl8367c_asicdrv_scheduling.h>
+
+/* Function Name:
+ *      rtk_rate_shareMeter_set
+ * Description:
+ *      Set meter configuration
+ * Input:
+ *      index       - shared meter index
+ *      type        - shared meter type
+ *      rate        - rate of share meter
+ *      ifg_include - include IFG or not, ENABLE:include DISABLE:exclude
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ *      RT_ERR_RATE             - Invalid rate
+ *      RT_ERR_INPUT            - Invalid input parameters
+ * Note:
+ *      The API can set shared meter rate and ifg include for each meter.
+ *      The rate unit is 1 kbps and the range is from 8k to 1048568k if type is METER_TYPE_KBPS and
+ *      the granularity of rate is 8 kbps.
+ *      The rate unit is packets per second and the range is 1 ~ 0x1FFF if type is METER_TYPE_PPS.
+ *      The ifg_include parameter is used
+ *      for rate calculation with/without inter-frame-gap and preamble.
+ */
+rtk_api_ret_t rtk_rate_shareMeter_set(rtk_meter_id_t index, rtk_meter_type_t type, rtk_rate_t rate, rtk_enable_t ifg_include)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (index > RTK_MAX_METER_ID)
+        return RT_ERR_FILTER_METER_ID;
+
+    if (type >= METER_TYPE_END)
+        return RT_ERR_INPUT;
+
+    if (ifg_include >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    switch (type)
+    {
+        case METER_TYPE_KBPS:
+            if (rate > RTL8367C_QOS_RATE_INPUT_MAX_HSG || rate < RTL8367C_QOS_RATE_INPUT_MIN)
+                return RT_ERR_RATE ;
+
+            if ((retVal = rtl8367c_setAsicShareMeter(index, rate >> 3, ifg_include)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        case METER_TYPE_PPS:
+            if (rate > RTL8367C_QOS_PPS_INPUT_MAX || rate < RTL8367C_QOS_PPS_INPUT_MIN)
+                return RT_ERR_RATE ;
+
+            if ((retVal = rtl8367c_setAsicShareMeter(index, rate, ifg_include)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        default:
+            return RT_ERR_INPUT;
+    }
+
+    /* Set Type */
+    if ((retVal = rtl8367c_setAsicShareMeterType(index, (rtk_uint32)type)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_shareMeter_get
+ * Description:
+ *      Get meter configuration
+ * Input:
+ *      index        - shared meter index
+ * Output:
+ *      pType        - Meter Type
+ *      pRate        - pointer of rate of share meter
+ *      pIfg_include - include IFG or not, ENABLE:include DISABLE:exclude
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_shareMeter_get(rtk_meter_id_t index, rtk_meter_type_t *pType, rtk_rate_t *pRate, rtk_enable_t *pIfg_include)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (index > RTK_MAX_METER_ID)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(NULL == pType)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pRate)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pIfg_include)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicShareMeter(index, &regData, pIfg_include)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicShareMeterType(index, (rtk_uint32 *)pType)) != RT_ERR_OK)
+        return retVal;
+
+    if(*pType == METER_TYPE_KBPS)
+        *pRate = regData<<3;
+    else
+        *pRate = regData;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_shareMeterBucket_set
+ * Description:
+ *      Set meter Bucket Size
+ * Input:
+ *      index        - shared meter index
+ *      bucket_size  - Bucket Size
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_INPUT            - Error Input
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      The API can set shared meter bucket size.
+ */
+rtk_api_ret_t rtk_rate_shareMeterBucket_set(rtk_meter_id_t index, rtk_uint32 bucket_size)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (index > RTK_MAX_METER_ID)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(bucket_size > RTL8367C_METERBUCKETSIZEMAX)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicShareMeterBucketSize(index, bucket_size)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_shareMeterBucket_get
+ * Description:
+ *      Get meter Bucket Size
+ * Input:
+ *      index        - shared meter index
+ * Output:
+ *      pBucket_size - Bucket Size
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      The API can get shared meter bucket size.
+ */
+rtk_api_ret_t rtk_rate_shareMeterBucket_get(rtk_meter_id_t index, rtk_uint32 *pBucket_size)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (index > RTK_MAX_METER_ID)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(NULL == pBucket_size)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicShareMeterBucketSize(index, pBucket_size)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_igrBandwidthCtrlRate_set
+ * Description:
+ *      Set port ingress bandwidth control
+ * Input:
+ *      port        - Port id
+ *      rate        - Rate of share meter
+ *      ifg_include - include IFG or not, ENABLE:include DISABLE:exclude
+ *      fc_enable   - enable flow control or not, ENABLE:use flow control DISABLE:drop
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_ENABLE       - Invalid IFG parameter.
+ *      RT_ERR_INBW_RATE    - Invalid ingress rate parameter.
+ * Note:
+ *      The rate unit is 1 kbps and the range is from 8k to 1048568k. The granularity of rate is 8 kbps.
+ *      The ifg_include parameter is used for rate calculation with/without inter-frame-gap and preamble.
+ */
+rtk_api_ret_t rtk_rate_igrBandwidthCtrlRate_set(rtk_port_t port, rtk_rate_t rate, rtk_enable_t ifg_include, rtk_enable_t fc_enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(ifg_include >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if(fc_enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if(rtk_switch_isHsgPort(port) == RT_ERR_OK)
+    {
+        if ((rate > RTL8367C_QOS_RATE_INPUT_MAX_HSG) || (rate < RTL8367C_QOS_RATE_INPUT_MIN))
+            return RT_ERR_QOS_EBW_RATE ;
+    }
+    else
+    {
+        if ((rate > RTL8367C_QOS_RATE_INPUT_MAX) || (rate < RTL8367C_QOS_RATE_INPUT_MIN))
+            return RT_ERR_QOS_EBW_RATE ;
+    }
+
+    if ((retVal = rtl8367c_setAsicPortIngressBandwidth(rtk_switch_port_L2P_get(port), rate>>3, ifg_include,fc_enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_igrBandwidthCtrlRate_get
+ * Description:
+ *      Get port ingress bandwidth control
+ * Input:
+ *      port - Port id
+ * Output:
+ *      pRate           - Rate of share meter
+ *      pIfg_include    - Rate's calculation including IFG, ENABLE:include DISABLE:exclude
+ *      pFc_enable      - enable flow control or not, ENABLE:use flow control DISABLE:drop
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *     The rate unit is 1 kbps and the range is from 8k to 1048568k. The granularity of rate is 8 kbps.
+ *     The ifg_include parameter is used for rate calculation with/without inter-frame-gap and preamble.
+ */
+rtk_api_ret_t rtk_rate_igrBandwidthCtrlRate_get(rtk_port_t port, rtk_rate_t *pRate, rtk_enable_t *pIfg_include, rtk_enable_t *pFc_enable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pIfg_include)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pFc_enable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortIngressBandwidth(rtk_switch_port_L2P_get(port), &regData, pIfg_include, pFc_enable)) != RT_ERR_OK)
+        return retVal;
+
+    *pRate = regData<<3;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_egrBandwidthCtrlRate_set
+ * Description:
+ *      Set port egress bandwidth control
+ * Input:
+ *      port        - Port id
+ *      rate        - Rate of egress bandwidth
+ *      ifg_include - include IFG or not, ENABLE:include DISABLE:exclude
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_QOS_EBW_RATE - Invalid egress bandwidth/rate
+ * Note:
+ *     The rate unit is 1 kbps and the range is from 8k to 1048568k. The granularity of rate is 8 kbps.
+ *     The ifg_include parameter is used for rate calculation with/without inter-frame-gap and preamble.
+ */
+rtk_api_ret_t rtk_rate_egrBandwidthCtrlRate_set( rtk_port_t port, rtk_rate_t rate,  rtk_enable_t ifg_include)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(rtk_switch_isHsgPort(port) == RT_ERR_OK)
+    {
+        if ((rate > RTL8367C_QOS_RATE_INPUT_MAX_HSG) || (rate < RTL8367C_QOS_RATE_INPUT_MIN))
+            return RT_ERR_QOS_EBW_RATE ;
+    }
+    else
+    {
+        if ((rate > RTL8367C_QOS_RATE_INPUT_MAX) || (rate < RTL8367C_QOS_RATE_INPUT_MIN))
+            return RT_ERR_QOS_EBW_RATE ;
+    }
+
+    if (ifg_include >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicPortEgressRate(rtk_switch_port_L2P_get(port), rate>>3)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPortEgressRateIfg(ifg_include)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_egrBandwidthCtrlRate_get
+ * Description:
+ *      Get port egress bandwidth control
+ * Input:
+ *      port - Port id
+ * Output:
+ *      pRate           - Rate of egress bandwidth
+ *      pIfg_include    - Rate's calculation including IFG, ENABLE:include DISABLE:exclude
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *     The rate unit is 1 kbps and the range is from 8k to 1048568k. The granularity of rate is 8 kbps.
+ *     The ifg_include parameter is used for rate calculation with/without inter-frame-gap and preamble.
+ */
+rtk_api_ret_t rtk_rate_egrBandwidthCtrlRate_get(rtk_port_t port, rtk_rate_t *pRate, rtk_enable_t *pIfg_include)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 regData;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pRate)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pIfg_include)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortEgressRate(rtk_switch_port_L2P_get(port), &regData)) != RT_ERR_OK)
+        return retVal;
+
+    *pRate = regData << 3;
+
+    if ((retVal = rtl8367c_getAsicPortEgressRateIfg((rtk_uint32*)pIfg_include)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_rate_egrQueueBwCtrlEnable_get
+ * Description:
+ *      Get enable status of egress bandwidth control on specified queue.
+ * Input:
+ *      unit    - unit id
+ *      port    - port id
+ *      queue   - queue id
+ * Output:
+ *      pEnable - Pointer to enable status of egress queue bandwidth control
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_QUEUE_ID         - invalid queue id
+ *      RT_ERR_NULL_POINTER     - input parameter may be null pointer
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_rate_egrQueueBwCtrlEnable_get(rtk_port_t port, rtk_qid_t queue, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    /*for whole port function, the queue value should be 0xFF*/
+    if (queue != RTK_WHOLE_SYSTEM)
+        return RT_ERR_QUEUE_ID;
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicAprEnable(rtk_switch_port_L2P_get(port),pEnable))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_egrQueueBwCtrlEnable_set
+ * Description:
+ *      Set enable status of egress bandwidth control on specified queue.
+ * Input:
+ *      port   - port id
+ *      queue  - queue id
+ *      enable - enable status of egress queue bandwidth control
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_QUEUE_ID         - invalid queue id
+ *      RT_ERR_INPUT            - invalid input parameter
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_rate_egrQueueBwCtrlEnable_set(rtk_port_t port, rtk_qid_t queue, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    /*for whole port function, the queue value should be 0xFF*/
+    if (queue != RTK_WHOLE_SYSTEM)
+        return RT_ERR_QUEUE_ID;
+
+    if (enable>=RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicAprEnable(rtk_switch_port_L2P_get(port), enable))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_egrQueueBwCtrlRate_get
+ * Description:
+ *      Get rate of egress bandwidth control on specified queue.
+ * Input:
+ *      port  - port id
+ *      queue - queue id
+ *      pIndex - shared meter index
+ * Output:
+ *      pRate - pointer to rate of egress queue bandwidth control
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_QUEUE_ID         - invalid queue id
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter id
+ * Note:
+ *    The actual rate control is set in shared meters.
+ *    The unit of granularity is 8Kbps.
+ */
+rtk_api_ret_t rtk_rate_egrQueueBwCtrlRate_get(rtk_port_t port, rtk_qid_t queue, rtk_meter_id_t *pIndex)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 offset_idx;
+    rtk_uint32 phy_port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (queue >= RTK_MAX_NUM_OF_QUEUE)
+        return RT_ERR_QUEUE_ID;
+
+    if(NULL == pIndex)
+        return RT_ERR_NULL_POINTER;
+
+    phy_port = rtk_switch_port_L2P_get(port);
+    if ((retVal=rtl8367c_getAsicAprMeter(phy_port, queue,&offset_idx))!=RT_ERR_OK)
+        return retVal;
+
+    *pIndex = offset_idx + ((phy_port%4)*8);
+
+     return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_rate_egrQueueBwCtrlRate_set
+ * Description:
+ *      Set rate of egress bandwidth control on specified queue.
+ * Input:
+ *      port  - port id
+ *      queue - queue id
+ *      index - shared meter index
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_QUEUE_ID         - invalid queue id
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter id
+ * Note:
+ *    The actual rate control is set in shared meters.
+ *    The unit of granularity is 8Kbps.
+ */
+rtk_api_ret_t rtk_rate_egrQueueBwCtrlRate_set(rtk_port_t port, rtk_qid_t queue, rtk_meter_id_t index)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 offset_idx;
+    rtk_uint32 phy_port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (queue >= RTK_MAX_NUM_OF_QUEUE)
+        return RT_ERR_QUEUE_ID;
+
+    if (index > RTK_MAX_METER_ID)
+        return RT_ERR_FILTER_METER_ID;
+
+    phy_port = rtk_switch_port_L2P_get(port);
+    if (index < ((phy_port%4)*8) ||  index > (7 + (phy_port%4)*8))
+        return RT_ERR_FILTER_METER_ID;
+
+    offset_idx = index - ((phy_port%4)*8);
+
+    if ((retVal=rtl8367c_setAsicAprMeter(phy_port,queue,offset_idx))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rldp.c b/drivers/net/phy/rtk/rtl8367c/rldp.c
new file mode 100644
index 0000000000000..680e3a9871015
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rldp.c
@@ -0,0 +1,468 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (gT, 08 T 2017) $
+ *
+ * Purpose : Declaration of RLDP and RLPP API
+ *
+ * Feature : The file have include the following module and sub-modules
+ *           1) RLDP and RLPP configuration and status
+ *
+ */
+
+
+/*
+ * Include Files
+ */
+#include <rtk_switch.h>
+#include <rtk_error.h>
+//#include <rtk_types.h>
+#include <rldp.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_rldp.h>
+
+/*
+ * Symbol Definition
+ */
+
+
+/*
+ * Data Declaration
+ */
+
+
+/*
+ * Macro Declaration
+ */
+
+
+/*
+ * Function Declaration
+ */
+
+/* Module Name : RLDP */
+
+/* Function Name:
+ *      rtk_rldp_config_set
+ * Description:
+ *      Set RLDP module configuration
+ * Input:
+ *      pConfig - configuration structure of RLDP
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_rldp_config_set(rtk_rldp_config_t *pConfig)
+{
+    rtk_api_ret_t retVal;
+    ether_addr_t magic;
+    rtk_uint32 pmsk;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (pConfig->rldp_enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (pConfig->trigger_mode >= RTK_RLDP_TRIGGER_END)
+        return RT_ERR_INPUT;
+
+    if (pConfig->compare_type >= RTK_RLDP_CMPTYPE_END)
+        return RT_ERR_INPUT;
+
+    if (pConfig->num_check >= RTK_RLDP_NUM_MAX)
+        return RT_ERR_INPUT;
+
+    if (pConfig->interval_check >= RTK_RLDP_INTERVAL_MAX)
+        return RT_ERR_INPUT;
+
+    if (pConfig->num_loop >= RTK_RLDP_NUM_MAX)
+        return RT_ERR_INPUT;
+
+    if (pConfig->interval_loop >= RTK_RLDP_INTERVAL_MAX)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_getAsicRldpTxPortmask(&pmsk))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRldpTxPortmask(0x00))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRldpTxPortmask(pmsk))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRldp(pConfig->rldp_enable))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRldpTriggerMode(pConfig->trigger_mode))!=RT_ERR_OK)
+        return retVal;
+
+    memcpy(&magic, &pConfig->magic, sizeof(ether_addr_t));
+    if ((retVal = rtl8367c_setAsicRldpMagicNum(magic))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRldpCompareRandomNumber(pConfig->compare_type))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRldpCompareRandomNumber(pConfig->compare_type))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRldpCheckingStatePara(pConfig->num_check, pConfig->interval_check))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRldpLoopStatePara(pConfig->num_loop, pConfig->interval_loop))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_rldp_config_get
+ * Description:
+ *      Get RLDP module configuration
+ * Input:
+ *      None
+ * Output:
+ *      pConfig - configuration structure of RLDP
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_rldp_config_get(rtk_rldp_config_t *pConfig)
+{
+    rtk_api_ret_t retVal;
+    ether_addr_t magic;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_getAsicRldp(&pConfig->rldp_enable))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicRldpTriggerMode(&pConfig->trigger_mode))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicRldpMagicNum(&magic))!=RT_ERR_OK)
+        return retVal;
+    memcpy(&pConfig->magic, &magic, sizeof(ether_addr_t));
+
+    if ((retVal = rtl8367c_getAsicRldpCompareRandomNumber(&pConfig->compare_type))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicRldpCompareRandomNumber(&pConfig->compare_type))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicRldpCheckingStatePara(&pConfig->num_check, &pConfig->interval_check))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicRldpLoopStatePara(&pConfig->num_loop, &pConfig->interval_loop))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_rldp_portConfig_set
+ * Description:
+ *      Set per port RLDP module configuration
+ * Input:
+ *      port   - port number to be configured
+ *      pPortConfig - per port configuration structure of RLDP
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_rldp_portConfig_set(rtk_port_t port, rtk_rldp_portConfig_t *pPortConfig)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmsk;
+    rtk_uint32 phy_port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (pPortConfig->tx_enable>= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    phy_port = rtk_switch_port_L2P_get(port);
+
+    if ((retVal = rtl8367c_getAsicRldpTxPortmask(&pmsk))!=RT_ERR_OK)
+        return retVal;
+
+    if (pPortConfig->tx_enable)
+    {
+         pmsk |=(1<<phy_port);
+    }
+    else
+    {
+         pmsk &= ~(1<<phy_port);
+    }
+
+    if ((retVal = rtl8367c_setAsicRldpTxPortmask(pmsk))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+
+} /* end of rtk_rldp_portConfig_set */
+
+
+/* Function Name:
+ *      rtk_rldp_portConfig_get
+ * Description:
+ *      Get per port RLDP module configuration
+ * Input:
+ *      port    - port number to be get
+ * Output:
+ *      pPortConfig - per port configuration structure of RLDP
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_rldp_portConfig_get(rtk_port_t port, rtk_rldp_portConfig_t *pPortConfig)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmsk;
+    rtk_portmask_t logicalPmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicRldpTxPortmask(&pmsk))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtk_switch_portmask_P2L_get(pmsk, &logicalPmask)) != RT_ERR_OK)
+        return retVal;
+
+
+    if (logicalPmask.bits[0] & (1<<port))
+    {
+         pPortConfig->tx_enable = ENABLED;
+    }
+    else
+    {
+         pPortConfig->tx_enable = DISABLED;
+    }
+
+    return RT_ERR_OK;
+} /* end of rtk_rldp_portConfig_get */
+
+
+/* Function Name:
+ *      rtk_rldp_status_get
+ * Description:
+ *      Get RLDP module status
+ * Input:
+ *      None
+ * Output:
+ *      pStatus - status structure of RLDP
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_rldp_status_get(rtk_rldp_status_t *pStatus)
+{
+    rtk_api_ret_t retVal;
+    ether_addr_t seed;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_getAsicRldpRandomNumber(&seed))!=RT_ERR_OK)
+        return retVal;
+    memcpy(&pStatus->id, &seed, sizeof(ether_addr_t));
+
+    return RT_ERR_OK;
+} /* end of rtk_rldp_status_get */
+
+
+/* Function Name:
+ *      rtk_rldp_portStatus_get
+ * Description:
+ *      Get RLDP module status
+ * Input:
+ *      port    - port number to be get
+ * Output:
+ *      pPortStatus - per port status structure of RLDP
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_rldp_portStatus_get(rtk_port_t port, rtk_rldp_portStatus_t *pPortStatus)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmsk;
+    rtk_portmask_t logicalPmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicRldpLoopedPortmask(&pmsk))!=RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtk_switch_portmask_P2L_get(pmsk, &logicalPmask)) != RT_ERR_OK)
+        return retVal;
+
+    if (logicalPmask.bits[0] & (1<<port))
+    {
+         pPortStatus->loop_status = RTK_RLDP_LOOPSTS_LOOPING;
+    }
+    else
+    {
+         pPortStatus->loop_status  = RTK_RLDP_LOOPSTS_NONE;
+    }
+
+    if ((retVal = rtl8367c_getAsicRldpEnterLoopedPortmask(&pmsk))!=RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtk_switch_portmask_P2L_get(pmsk, &logicalPmask)) != RT_ERR_OK)
+        return retVal;
+
+    if (logicalPmask.bits[0] & (1<<port))
+    {
+         pPortStatus->loop_enter = RTK_RLDP_LOOPSTS_LOOPING;
+    }
+    else
+    {
+         pPortStatus->loop_enter  = RTK_RLDP_LOOPSTS_NONE;
+    }
+
+    if ((retVal = rtl8367c_getAsicRldpLeaveLoopedPortmask(&pmsk))!=RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtk_switch_portmask_P2L_get(pmsk, &logicalPmask)) != RT_ERR_OK)
+        return retVal;
+
+    if (logicalPmask.bits[0] & (1<<port))
+    {
+         pPortStatus->loop_leave = RTK_RLDP_LOOPSTS_LOOPING;
+    }
+    else
+    {
+         pPortStatus->loop_leave  = RTK_RLDP_LOOPSTS_NONE;
+    }
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_rldp_portStatus_clear
+ * Description:
+ *      Clear RLDP module status
+ * Input:
+ *      port    - port number to be clear
+ *      pPortStatus - per port status structure of RLDP
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      Clear operation effect loop_enter and loop_leave only, other field in
+ *      the structure are don't care. Loop status cab't be clean.
+ */
+rtk_api_ret_t rtk_rldp_portStatus_set(rtk_port_t port, rtk_rldp_portStatus_t *pPortStatus)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmsk;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    pmsk = (pPortStatus->loop_enter)<<rtk_switch_port_L2P_get(port);
+    if ((retVal = rtl8367c_setAsicRldpEnterLoopedPortmask(pmsk))!=RT_ERR_OK)
+        return retVal;
+
+    pmsk = (pPortStatus->loop_leave)<<rtk_switch_port_L2P_get(port);
+    if ((retVal = rtl8367c_setAsicRldpLeaveLoopedPortmask(pmsk))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rldp_portLoopPair_get
+ * Description:
+ *      Get RLDP port loop pairs
+ * Input:
+ *      port    - port number to be get
+ * Output:
+ *      pPortmask - per port related loop ports
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT
+ *      RT_ERR_NULL_POINTER
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_rldp_portLoopPair_get(rtk_port_t port, rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmsk;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicRldpLoopedPortPair(rtk_switch_port_L2P_get(port), &pmsk))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtk_switch_portmask_P2L_get(pmsk, pPortmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtk_hal.c b/drivers/net/phy/rtk/rtl8367c/rtk_hal.c
new file mode 100644
index 0000000000000..b9373492cb5f3
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtk_hal.c
@@ -0,0 +1,839 @@
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include  "./include/rtk_switch.h"
+#include  "./include/vlan.h"
+#include  "./include/port.h"
+#include  "./include/rate.h"
+#include  "./include/rtk_hal.h"
+#include  "./include/l2.h"
+#include  "./include/stat.h"
+#include  "./include/igmp.h"
+#include  "./include/trap.h"
+#include  "./include/leaky.h"
+#include  "./include/mirror.h"
+#include  "./include/rtl8367c_asicdrv_port.h"
+#include  "./include/rtl8367c_asicdrv_mib.h"
+#include  "./include/smi.h"
+#include  "./include/qos.h"
+#include  "./include/trunk.h"
+
+void rtk_hal_switch_init(void)
+{
+	if(rtk_switch_init() != 0)
+        printk("rtk_switch_init failed\n");
+	mdelay(500);
+	/*vlan init */
+	if (rtk_vlan_init() != 0)
+        printk("rtk_vlan_init failed\n");
+}
+
+void rtk_hal_dump_full_mib(void)
+{
+	rtk_port_t port;
+	rtk_stat_counter_t Cntr;
+	rtk_stat_port_type_t cntr_idx;
+
+	for (port = UTP_PORT0; port < (UTP_PORT0 + 5); port++) {
+		printk("\nPort%d\n", port);
+		for (cntr_idx = STAT_IfInOctets; cntr_idx < STAT_PORT_CNTR_END; cntr_idx ++) {
+			rtk_stat_port_get(port, cntr_idx, &Cntr);
+			printk("%8llu ", Cntr);
+			if (((cntr_idx%10) == 9))
+				printk("\n");
+		}
+	}
+
+	for (port = EXT_PORT0; port < (EXT_PORT0 + 2); port++) {
+		printk("\nPort%d\n", port);
+		for (cntr_idx = STAT_IfInOctets; cntr_idx < STAT_PORT_CNTR_END; cntr_idx ++) {
+			rtk_stat_port_get(port, cntr_idx, &Cntr);
+			printk("%8llu ", Cntr);
+			if (((cntr_idx%10) == 9))
+				printk("\n");
+		}
+	}
+	rtk_stat_global_reset();
+}
+void rtk_dump_mib_type(rtk_stat_port_type_t cntr_idx)
+{
+	rtk_port_t port;
+	rtk_stat_counter_t Cntr;
+
+	for (port = UTP_PORT0; port < (UTP_PORT0 + 5); port++) {
+		rtk_stat_port_get(port, cntr_idx, &Cntr);
+		printk("%8llu", Cntr);
+	}
+	for (port = EXT_PORT0; port < (EXT_PORT0 + 2); port++) {
+		rtk_stat_port_get(port, cntr_idx, &Cntr);
+		printk("%8llu", Cntr);
+	}
+	printk("\n");
+}
+
+void rtk_hal_dump_mib(void)
+{
+
+	printk("==================%8s%8s%8s%8s%8s%8s%8s\n", "Port0", "Port1",
+	       "Port2", "Port3", "Port4", "Port16", "Port17");
+	/* Get TX Unicast Pkts */
+	printk("TX Unicast Pkts  :");
+	rtk_dump_mib_type(STAT_IfOutUcastPkts);
+	/* Get TX Multicast Pkts */
+	printk("TX Multicast Pkts:");
+	rtk_dump_mib_type(STAT_IfOutMulticastPkts);
+	/* Get TX BroadCast Pkts */
+	printk("TX BroadCast Pkts:");
+	rtk_dump_mib_type(STAT_IfOutBroadcastPkts);
+	/* Get TX Collisions */
+	/* Get TX Puase Frames */
+	printk("TX Pause Frames  :");
+	rtk_dump_mib_type(STAT_Dot3OutPauseFrames);
+	/* Get TX Drop Events */
+	/* Get RX Unicast Pkts */
+	printk("RX Unicast Pkts  :");
+	rtk_dump_mib_type(STAT_IfInUcastPkts);
+	/* Get RX Multicast Pkts */
+	printk("RX Multicast Pkts:");
+	rtk_dump_mib_type(STAT_IfInMulticastPkts);
+	/* Get RX Broadcast Pkts */
+	printk("RX Broadcast Pkts:");
+	rtk_dump_mib_type(STAT_IfInBroadcastPkts);
+	/* Get RX FCS Erros */
+	printk("RX FCS Errors    :");
+	rtk_dump_mib_type(STAT_Dot3StatsFCSErrors);
+	/* Get RX Undersize Pkts */
+	printk("RX Undersize Pkts:");
+	rtk_dump_mib_type(STAT_EtherStatsUnderSizePkts);
+	/* Get RX Discard Pkts */
+	printk("RX Discard Pkts  :");
+	rtk_dump_mib_type(STAT_Dot1dTpPortInDiscards);
+	/* Get RX Fragments */
+	printk("RX Fragments     :");
+	rtk_dump_mib_type(STAT_EtherStatsFragments);
+	/* Get RX Oversize Pkts */
+	printk("RX Oversize Pkts :");
+	rtk_dump_mib_type(STAT_EtherOversizeStats);
+	/* Get RX Jabbers */
+	printk("RX Jabbers       :");
+	rtk_dump_mib_type(STAT_EtherStatsJabbers);
+	/* Get RX Pause Frames */
+	printk("RX Pause Frames  :");
+	rtk_dump_mib_type(STAT_Dot3InPauseFrames);
+	/* clear MIB */
+	rtk_stat_global_reset();
+}
+EXPORT_SYMBOL(rtk_hal_dump_mib);
+
+int rtk_hal_dump_vlan(void)
+{
+	rtk_vlan_cfg_t vlan;
+	int i;
+
+	printk("vid    portmap\n");
+	for (i = 0; i < RTK_SW_VID_RANGE; i++) {
+		rtk_vlan_get(i, &vlan);
+		printk("%3d    ", i);
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+						UTP_PORT0) ? '1' : '-');
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+						UTP_PORT1) ? '1' : '-');
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+						UTP_PORT2) ? '1' : '-');
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+						UTP_PORT3) ? '1' : '-');
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+						UTP_PORT4) ? '1' : '-');
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+						EXT_PORT0) ? '1' : '-');
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+						EXT_PORT1) ? '1' : '-');
+		printk("\n");
+	}
+	return 0;
+}
+
+void rtk_hal_clear_vlan(void)
+{
+	rtk_api_ret_t ret;
+
+	ret =  rtk_vlan_reset();
+    if (ret != RT_ERR_OK)
+        printk("rtk_vlan_reset failed\n");
+}
+
+int rtk_hal_set_vlan(struct ra_switch_ioctl_data *data)
+{
+	rtk_vlan_cfg_t vlan;
+	rtk_api_ret_t ret;
+	int i;
+
+	/* clear vlan entry first */
+	memset(&vlan, 0x00, sizeof(rtk_vlan_cfg_t));
+	RTK_PORTMASK_CLEAR(vlan.mbr);
+	RTK_PORTMASK_CLEAR(vlan.untag);
+	rtk_vlan_set(data->vid, &vlan);
+
+	memset(&vlan, 0x00, sizeof(rtk_vlan_cfg_t));
+	for (i = 0; i < 5; i++) {
+		if (data->port_map & (1 << i)) {
+			RTK_PORTMASK_PORT_SET(vlan.mbr, i);
+			RTK_PORTMASK_PORT_SET(vlan.untag, i);
+			rtk_vlan_portPvid_set(i, data->vid, 0);
+		}
+	}
+	for (i = 0; i < 2; i++) {
+		if (data->port_map & (1 << (i + 5))) {
+			RTK_PORTMASK_PORT_SET(vlan.mbr, (i + EXT_PORT0));
+			RTK_PORTMASK_PORT_SET(vlan.untag, (i + EXT_PORT0));
+			rtk_vlan_portPvid_set((i + EXT_PORT0), data->vid, 0);
+		}
+	}
+	vlan.ivl_en = 1;
+	ret = rtk_vlan_set(data->vid, &vlan);
+
+	return 0;
+}
+
+void rtk_hal_vlan_portpvid_set(rtk_port_t port, rtk_vlan_t pvid, rtk_pri_t priority)
+{
+	rtk_vlan_portPvid_set(port, pvid, priority);
+}
+
+int rtk_hal_set_ingress_rate(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+
+	if (data->on_off == 1)
+		ret =
+		    rtk_rate_igrBandwidthCtrlRate_set(data->port, data->bw, 0,
+						      1);
+	else
+		ret =
+		    rtk_rate_igrBandwidthCtrlRate_set(data->port, 1048568, 0,
+						      1);
+
+	return ret;
+}
+
+int rtk_hal_set_egress_rate(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+
+	if (data->on_off == 1)
+		ret =
+		    rtk_rate_egrBandwidthCtrlRate_set(data->port, data->bw, 1);
+	else
+		ret = rtk_rate_egrBandwidthCtrlRate_set(data->port, 1048568, 1);
+
+	return ret;
+}
+
+void rtk_hal_dump_table(void)
+{
+	rtk_uint32 i;
+	rtk_uint32 address = 0;
+	rtk_l2_ucastAddr_t l2_data;
+	rtk_l2_ipMcastAddr_t ipMcastAddr;
+
+	printk("hash  port(0:17)   fid   vid  mac-address\n");
+	while (1) {
+		if (rtk_l2_addr_next_get(READMETHOD_NEXT_L2UC, UTP_PORT0, &address, &l2_data) != RT_ERR_OK) {
+			break;
+		} else {
+			printk("%03x   ", l2_data.address);
+			for (i = 0; i < 5; i++)
+				if ( l2_data.port == i)
+					printk("1");
+				else
+					printk("-");
+			for (i = 16; i < 18; i++)
+				if ( l2_data.port == i)
+					printk("1");
+				else
+					printk("-");
+
+			printk("      %2d", l2_data.fid);
+			printk("  %4d", l2_data.cvid);
+			printk("  %02x%02x%02x%02x%02x%02x\n", l2_data.mac.octet[0],
+			l2_data.mac.octet[1], l2_data.mac.octet[2], l2_data.mac.octet[3], 
+			l2_data.mac.octet[4], l2_data.mac.octet[5]);
+			address ++;
+			}
+	}
+
+	address = 0;
+	while (1) {
+        if (rtk_l2_ipMcastAddr_next_get(&address, &ipMcastAddr) != RT_ERR_OK) {
+            break;
+        } else {
+            printk("%03x   ", ipMcastAddr.address);
+            for (i = 0; i < 5; i++)
+                printk("%c", RTK_PORTMASK_IS_PORT_SET(ipMcastAddr.portmask, i) ? '1' : '-');
+            for (i = 16; i < 18; i++)
+                printk("%c", RTK_PORTMASK_IS_PORT_SET(ipMcastAddr.portmask, i) ? '1' : '-');
+			printk("                ");
+			printk("01005E%06x\n", (ipMcastAddr.dip & 0xefffff));
+            address ++;
+            }
+    }
+}
+
+void rtk_hal_clear_table(void)
+{
+	rtk_api_ret_t ret;
+
+	ret = rtk_l2_table_clear();
+	if (ret != RT_ERR_OK)
+		printk("rtk_l2_table_clear failed\n");
+}
+
+void rtk_hal_add_table(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	rtk_l2_ucastAddr_t l2_entry;
+	rtk_mac_t mac;
+
+	mac.octet[0] =data->mac[0];
+	mac.octet[1] =data->mac[1];
+	mac.octet[2] =data->mac[2];
+	mac.octet[3] =data->mac[3];
+	mac.octet[4] =data->mac[4];
+	mac.octet[5] =data->mac[5];
+
+	memset(&l2_entry, 0x00, sizeof(rtk_l2_ucastAddr_t));
+	l2_entry.port = data->port;
+	l2_entry.ivl = 1;
+	l2_entry.cvid = data->vid;
+	l2_entry.fid = 0;
+	l2_entry.efid = 0;
+	l2_entry.is_static = 1;
+	ret = rtk_l2_addr_add(&mac, &l2_entry);
+	if (ret != RT_ERR_OK)
+		printk("rtk_hal_add_table failed\n");
+}
+
+void rtk_hal_del_table(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	rtk_l2_ucastAddr_t l2_entry;
+	rtk_mac_t mac;
+
+	mac.octet[0] =data->mac[0];
+	mac.octet[1] =data->mac[1];
+	mac.octet[2] =data->mac[2];
+	mac.octet[3] =data->mac[3];
+	mac.octet[4] =data->mac[4];
+	mac.octet[5] =data->mac[5];
+
+	memset(&l2_entry, 0x00, sizeof(rtk_l2_ucastAddr_t));
+	l2_entry.port = data->port;
+	l2_entry.ivl = 1;
+	l2_entry.cvid = data->vid;
+	l2_entry.fid = 0;
+	l2_entry.efid = 0;
+	ret = rtk_l2_addr_del(&mac, &l2_entry);
+	if (ret != RT_ERR_OK)
+		printk("rtk_hal_add_table failed\n");
+}
+void rtk_hal_get_phy_status(struct ra_switch_ioctl_data *data)
+{
+	rtk_port_linkStatus_t linkStatus;
+	rtk_port_speed_t speed;
+	rtk_port_duplex_t duplex;
+
+    rtk_port_phyStatus_get(data->port, &linkStatus, &speed, &duplex);
+    printk("Port%d Status:\n", data->port);
+	if (linkStatus == 1) {
+        printk("Link Up");
+        if (speed == 0)
+			printk(" 10M");
+		else if (speed == 1)
+			printk(" 100M");
+		else if (speed == 2)
+            printk(" 1000M");
+        if (duplex == 0)
+			printk(" Half Duplex\n");
+		else
+			printk(" Full Duplex\n");
+	} else
+		printk("Link Down\n");
+
+}
+
+void rtk_hal_set_port_mirror(struct ra_switch_ioctl_data *data)
+{
+	rtk_portmask_t rx_portmask;
+	rtk_portmask_t tx_portmask;
+	rtk_api_ret_t ret;
+	int i;
+
+	rtk_mirror_portIso_set(ENABLED);
+	RTK_PORTMASK_CLEAR(rx_portmask);
+	RTK_PORTMASK_CLEAR(tx_portmask);
+    for (i = 0; i < 5; i++)
+		if (data->rx_port_map & (1 << i))
+			RTK_PORTMASK_PORT_SET(rx_portmask, i);
+	for (i = 0; i < 2; i++)
+		if (data->rx_port_map & (1 << (i + 5)))
+			RTK_PORTMASK_PORT_SET(rx_portmask, (i + EXT_PORT0));
+
+	RTK_PORTMASK_CLEAR(tx_portmask);
+    for (i = 0; i < 5; i++)
+        if (data->tx_port_map & (1 << i))
+            RTK_PORTMASK_PORT_SET(tx_portmask, i);
+    for (i = 0; i < 2; i++)
+        if (data->tx_port_map & (1 << (i + 5)))
+            RTK_PORTMASK_PORT_SET(tx_portmask, (i + EXT_PORT0));
+
+    ret = rtk_mirror_portBased_set(data->port, &rx_portmask, &tx_portmask);
+	if (!ret)
+		printk("rtk_mirror_portBased_set success\n");
+}
+
+void rtk_hal_read_reg(struct ra_switch_ioctl_data *data)
+{
+	ret_t retVal;
+
+	retVal = smi_read(data->reg_addr, &data->reg_val);
+	if(retVal != RT_ERR_OK)
+		printk("switch reg read failed\n");
+	else
+		printk("reg0x%x = 0x%x\n", data->reg_addr, data->reg_val);
+}
+
+void rtk_hal_write_reg(struct ra_switch_ioctl_data *data)
+{
+	ret_t retVal;
+
+    retVal = smi_write(data->reg_addr, data->reg_val);
+    if(retVal != RT_ERR_OK)
+        printk("switch reg write failed\n");
+    else
+        printk("write switch reg0x%x 0x%x success\n", data->reg_addr, data->reg_val);
+}
+
+void rtk_hal_get_phy_reg(struct ra_switch_ioctl_data *data)
+{
+	ret_t retVal;
+	rtk_port_phy_data_t Data;
+
+	retVal = rtk_port_phyReg_get(data->port, data->reg_addr, &Data);
+	if (retVal == RT_ERR_OK)
+		printk("Get: phy[%d].reg[%d] = 0x%04x\n", data->port, data->reg_addr, Data);
+	else
+		printk("read phy reg failed\n");
+}
+
+void rtk_hal_set_phy_reg(struct ra_switch_ioctl_data *data)
+{
+	ret_t retVal;
+
+	retVal = rtk_port_phyReg_set(data->port, data->reg_addr, data->reg_val);
+	if (retVal == RT_ERR_OK)
+		printk("Set: phy[%d].reg[%d] = 0x%04x\n", data->port, data->reg_addr, data->reg_val);
+	else
+		printk("write phy reg failed\n");
+}
+void rtk_hal_qos_en(struct ra_switch_ioctl_data *data)
+{
+
+	if (data->on_off == 1) {
+		if (rtk_qos_init(8) != 0)
+			printk("rtk_qos_init(8) failed\n");
+	}
+	else {
+		if (rtk_qos_init(1) != 0)
+            printk("rtk_qos_init(1) failed\n");
+	}
+}
+
+void rtk_hal_qos_set_table2type(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	rtk_priority_select_t PriDec;
+
+	/* write all pri to 0 */
+	PriDec.port_pri = 0;
+    PriDec.dot1q_pri = 0;
+    PriDec.acl_pri = 0;
+    PriDec.cvlan_pri = 0;
+    PriDec.svlan_pri = 0;
+    PriDec.dscp_pri = 0;
+    PriDec.dmac_pri = 0;
+    PriDec.smac_pri = 0;
+
+	if (data->qos_type == 0)
+		PriDec.port_pri = 1;
+	else if (data->qos_type == 1)
+		PriDec.dot1q_pri = 1;
+	else if (data->qos_type == 2)
+		PriDec.acl_pri = 1;
+	else if (data->qos_type == 3)
+		PriDec.dscp_pri = 1;
+	else if (data->qos_type == 4)
+		PriDec.cvlan_pri = 1;
+	else if (data->qos_type == 5)
+		PriDec.svlan_pri = 1;
+	else if (data->qos_type == 6)
+		PriDec.dmac_pri = 1;
+	else if (data->qos_type == 7)
+		PriDec.smac_pri = 1;
+
+	if (data->qos_table_idx == 0)
+		ret = rtk_qos_priSel_set(PRIDECTBL_IDX0, &PriDec);
+	else
+		ret = rtk_qos_priSel_set(PRIDECTBL_IDX1, &PriDec);
+
+	if (ret != 0)
+		printk("rtk_qos_priSel_set failed\n");
+
+}
+
+void rtk_hal_qos_get_table2type(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	rtk_priority_select_t PriDec;
+
+	if (data->qos_table_idx == 0)
+        ret = rtk_qos_priSel_get(PRIDECTBL_IDX0, &PriDec);
+    else
+        ret = rtk_qos_priSel_get(PRIDECTBL_IDX1, &PriDec);
+
+	if (ret != 0)
+        printk("rtk_qos_priSel_set failed\n");
+    else {
+		printk("port_pri  = %d\n", PriDec.port_pri);
+		printk("dot1q_pri = %d\n", PriDec.dot1q_pri);
+		printk("acl_pri   = %d\n", PriDec.acl_pri);
+		printk("dscp_pri  = %d\n", PriDec.dscp_pri);
+		printk("cvlan_pri = %d\n", PriDec.cvlan_pri);
+		printk("svlan_pri = %d\n", PriDec.svlan_pri);
+		printk("dmac_pri  = %d\n", PriDec.dmac_pri);
+		printk("smac_pri  = %d\n", PriDec.smac_pri);
+	}
+}
+
+void rtk_hal_qos_set_port2table(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	
+	ret = rtk_qos_portPriSelIndex_set(data->port, data->qos_table_idx);
+	if (ret != 0)
+		printk("rtk_qos_portPriSelIndex_set failed\n");
+}
+
+void rtk_hal_qos_get_port2table(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	rtk_qos_priDecTbl_t Index;
+	
+	ret = rtk_qos_portPriSelIndex_get(data->port, &Index);
+	if (ret != 0)
+		printk("rtk_qos_portPriSelIndex_set failed\n");
+	else
+		printk("port%d belongs to table%d\n", data->port, Index);
+}
+
+void rtk_hal_qos_set_port2pri(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+
+	ret = rtk_qos_portPri_set(data->port, data->qos_pri);
+	if (ret != 0)
+		printk("rtk_qos_portPri_set failed\n");
+}
+
+void rtk_hal_qos_get_port2pri(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	rtk_pri_t Int_pri;
+
+	ret = rtk_qos_portPri_get(data->port, &Int_pri);
+	if (ret != 0)
+		printk("rtk_qos_portPri_set failed\n");
+	else
+		printk("port%d priority = %d\n", data->port, Int_pri);
+}
+
+void rtk_hal_qos_set_dscp2pri(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+
+	ret = rtk_qos_dscpPriRemap_set(data->qos_dscp, data->qos_pri);
+	if (ret != 0)
+		printk("rtk_qos_dscpPriRemap_set failed\n");
+}
+
+void rtk_hal_qos_get_dscp2pri(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	rtk_pri_t Int_pri;
+
+	ret = rtk_qos_dscpPriRemap_get(data->qos_dscp, &Int_pri);
+	if (ret != 0)
+		printk("rtk_qos_dscpPriRemap_set failed\n");
+	else
+		printk("dscp%d priority is %d\n", data->qos_dscp, Int_pri);
+}
+
+void rtk_hal_qos_set_pri2queue(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	rtk_qos_pri2queue_t pri2qid;
+
+	ret = rtk_qos_priMap_get(8, &pri2qid);
+	pri2qid.pri2queue[data->qos_queue_num] = data->qos_pri;
+	ret = rtk_qos_priMap_set(8, &pri2qid);
+	if (ret != 0)
+		printk("rtk_qos_priMap_set failed\n");
+}
+
+void rtk_hal_qos_get_pri2queue(struct ra_switch_ioctl_data *data)
+{
+	int i;
+	rtk_api_ret_t ret;
+	rtk_qos_pri2queue_t pri2qid;
+
+	ret = rtk_qos_priMap_get(8, &pri2qid);
+	if (ret != 0)
+		printk("rtk_qos_priMap_get failed\n");
+	else {
+		for (i = 0; i < 8; i++)
+			printk("pri2qid.pri2queue[%d] = %d\n", i, pri2qid.pri2queue[i]);
+	}
+}
+
+void rtk_hal_qos_set_queue_weight(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	rtk_qos_queue_weights_t qweights;
+
+	ret = rtk_qos_schedulingQueue_get(data->port, &qweights);
+	qweights.weights[data->qos_queue_num] = data->qos_weight;
+	ret = rtk_qos_schedulingQueue_set(data->port, &qweights);
+	if (ret != 0)
+		printk("rtk_qos_schedulingQueue_set failed\n");
+}
+
+void rtk_hal_qos_get_queue_weight(struct ra_switch_ioctl_data *data)
+{
+	int i;
+	rtk_api_ret_t ret;
+	rtk_qos_queue_weights_t qweights;
+
+	ret = rtk_qos_schedulingQueue_get(data->port, &qweights);
+	if (ret != 0)
+		printk("rtk_qos_schedulingQueue_get failed\n");
+	else {
+		printk("=== Port%d queue weight ===\n", data->port);
+		for (i = 0; i < 8; i++)
+			printk("qweights.weights[%d] = %d\n",i ,qweights.weights[i]);
+	}
+}
+
+void rtk_hal_enable_igmpsnoop(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	rtk_portmask_t pmask;
+	
+
+	ret = rtk_igmp_init();
+	if (data->on_off == 1) {
+		RTK_PORTMASK_CLEAR(pmask);
+		RTK_PORTMASK_PORT_SET(pmask, EXT_PORT0);
+		ret |= rtk_igmp_static_router_port_set(&pmask);
+		ret |= rtk_igmp_protocol_set(UTP_PORT4, PROTOCOL_IGMPv1, IGMP_ACTION_FORWARD);
+		ret |= rtk_igmp_protocol_set(UTP_PORT4, PROTOCOL_IGMPv2, IGMP_ACTION_FORWARD);
+		ret |= rtk_igmp_protocol_set(UTP_PORT4, PROTOCOL_MLDv1, IGMP_ACTION_FORWARD);
+		ret |= rtk_igmp_protocol_set(EXT_PORT1, PROTOCOL_IGMPv1, IGMP_ACTION_FORWARD);
+		ret |= rtk_igmp_protocol_set(EXT_PORT1, PROTOCOL_IGMPv2, IGMP_ACTION_FORWARD);
+		ret |= rtk_igmp_protocol_set(EXT_PORT1, PROTOCOL_MLDv1, IGMP_ACTION_FORWARD);
+		ret |= rtk_igmp_protocol_set(UTP_PORT0, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
+		ret |= rtk_igmp_protocol_set(UTP_PORT1, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
+		ret |= rtk_igmp_protocol_set(UTP_PORT2, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
+		ret |= rtk_igmp_protocol_set(UTP_PORT3, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
+		ret |= rtk_igmp_protocol_set(EXT_PORT0, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
+
+		ret |= rtk_leaky_vlan_set(LEAKY_IPMULTICAST, ENABLED);
+		ret |= rtk_l2_ipMcastForwardRouterPort_set(DISABLED);
+		/* drop unknown multicast packets*/
+		/* ret |= rtk_trap_unknownMcastPktAction_set(UTP_PORT4, MCAST_IPV4, MCAST_ACTION_DROP);*/
+	} else {
+		RTK_PORTMASK_CLEAR(pmask);
+        RTK_PORTMASK_PORT_SET(pmask, EXT_PORT0);
+        RTK_PORTMASK_PORT_SET(pmask, EXT_PORT1);
+		ret |= rtk_igmp_protocol_set(UTP_PORT0, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
+		ret |= rtk_igmp_protocol_set(UTP_PORT1, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
+		ret |= rtk_igmp_protocol_set(UTP_PORT2, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
+		ret |= rtk_igmp_protocol_set(UTP_PORT3, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
+		ret |= rtk_igmp_protocol_set(EXT_PORT0, PROTOCOL_IGMPv3, IGMP_ACTION_ASIC);
+
+		ret |= rtk_igmp_static_router_port_set(&pmask);
+	}
+	if(ret != RT_ERR_OK)
+		printk("enable switch igmpsnoop failed\n");
+}
+
+void rtk_hal_disable_igmpsnoop(void)
+{
+	if (rtk_igmp_state_set(DISABLED) != RT_ERR_OK)
+		printk("Disable IGMP SNOOPING failed\n");
+}
+
+rtk_api_ret_t rtk_port_phyTestMode_set(rtk_port_t port, rtk_port_phy_test_mode_t mode)
+{
+    rtk_uint32          data, regData, i;
+    rtk_api_ret_t       retVal;
+
+    RTK_CHK_PORT_IS_UTP(port);
+
+    if(mode >= PHY_TEST_MODE_END)
+        return RT_ERR_INPUT;
+
+    if( (mode == PHY_TEST_MODE_2) || (mode == PHY_TEST_MODE_3) )
+        return RT_ERR_INPUT;
+
+    if (PHY_TEST_MODE_NORMAL != mode)
+    {
+        /* Other port should be Normal mode */
+        RTK_SCAN_ALL_LOG_PORT(i)
+        {
+            if(rtk_switch_isUtpPort(i) == RT_ERR_OK)
+            {
+                if(i != port)
+                {
+                    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(i), 9, &data)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((data & 0xE000) != 0)
+                        return RT_ERR_NOT_ALLOWED;
+                }
+            }
+        }
+    }
+
+    if ((retVal = rtl8367c_getAsicPHYReg(rtk_switch_port_L2P_get(port), 9, &data)) != RT_ERR_OK)
+        return retVal;
+
+    data &= ~0xE000;
+    data |= (mode << 13);
+    if ((retVal = rtl8367c_setAsicPHYReg(rtk_switch_port_L2P_get(port), 9, data)) != RT_ERR_OK)
+        return retVal;
+
+    if (PHY_TEST_MODE_4 == mode)
+    {
+        if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367c_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        if( (regData == 0x0276) || (regData == 0x0597) )
+        {
+            if ((retVal = rtl8367c_setAsicPHYOCPReg(rtk_switch_port_L2P_get(port), 0xbcc2, 0xF4F4)) != RT_ERR_OK)
+                return retVal;
+        }
+
+        if( (regData == 0x6367) )
+        {
+            if ((retVal = rtl8367c_setAsicPHYOCPReg(rtk_switch_port_L2P_get(port), 0xa436, 0x80c1)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicPHYOCPReg(rtk_switch_port_L2P_get(port), 0xa438, 0xfe00)) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+void rtk_hal_set_phy_test_mode(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+
+    ret = rtk_port_phyTestMode_set(data->port, data->mode);
+	if (ret != RT_ERR_OK)
+		printk("rtk_port_phyTestMode_set failed\n");
+	else
+		printk("set port%d in test mode %d.\n", data->port, data->mode);
+}
+
+void rtk_hal_set_port_trunk(struct ra_switch_ioctl_data *data)
+{
+
+	rtk_api_ret_t ret;
+	rtk_portmask_t member;
+	int i;
+
+	RTK_PORTMASK_CLEAR(member);
+	for (i = 0; i < 4; i++) {
+		if (data->port_map & (1 << i))
+			RTK_PORTMASK_PORT_SET(member, i);
+    }
+
+	ret = rtk_trunk_port_set(TRUNK_GROUP0, &member);
+	if (ret != RT_ERR_OK)
+		printk("rtk_trunk_port_set failed\n");
+
+	ret = rtk_trunk_distributionAlgorithm_set(RTK_WHOLE_SYSTEM, 0x7F);
+	if (ret != RT_ERR_OK)
+		printk("rtk_trunk_distributionAlgorithm_set failed\n");
+}
+
+void rtk_hal_vlan_tag(struct ra_switch_ioctl_data *data)
+{
+	rtk_api_ret_t ret;
+	rtk_vlan_cfg_t vlan;
+
+    ret = rtk_vlan_get(data->vid, &vlan);
+	if (ret != RT_ERR_OK)
+		printk("rtk_vlan_get failed\n");
+	else {
+		if (data->on_off == 0)
+			RTK_PORTMASK_PORT_SET(vlan.untag, data->port);
+		else
+			RTK_PORTMASK_PORT_CLEAR(vlan.untag, data->port);
+		
+		ret = rtk_vlan_set(data->vid, &vlan);
+		if (ret != RT_ERR_OK)
+			printk("rtk_vlan_set failed\n");
+	}
+}
+
+void rtk_hal_vlan_mode(struct ra_switch_ioctl_data *data)
+{
+	rtk_vlan_cfg_t vlan1, vlan2;
+	rtk_api_ret_t ret;
+
+	ret = rtk_vlan_get(1, &vlan1);
+	if (ret != RT_ERR_OK)
+		printk("rtk_vlan_get failed\n");
+
+	ret = rtk_vlan_get(2, &vlan2);
+	if (ret != RT_ERR_OK)
+		printk("rtk_vlan_get failed\n");
+
+	if (data->mode == 0) { //ivl
+		vlan1.ivl_en = 1;
+		vlan1.fid_msti = 0;
+		rtk_vlan_set(1, &vlan1);
+		vlan2.ivl_en = 1;
+		vlan2.fid_msti = 0;
+		rtk_vlan_set(2, &vlan2);
+	} else if(data->mode == 1) {//svl
+		vlan1.ivl_en = 0;
+		vlan1.fid_msti = 0;
+		rtk_vlan_set(1, &vlan1);
+		vlan2.ivl_en = 0;
+		vlan2.fid_msti = 1;
+		rtk_vlan_set(2, &vlan2);
+	} else
+		printk("mode not supported\n");
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/rtk_switch.c b/drivers/net/phy/rtk/rtl8367c/rtk_switch.c
new file mode 100644
index 0000000000000..74e2521e0aaa5
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtk_switch.c
@@ -0,0 +1,1796 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76336 $
+ * $Date: 2017-03-09 10:41:21 +0800 (週四, 09 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API
+ * Feature : Here is a list of all functions and variables in this module.
+ *
+ */
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <string.h>
+
+#include <rate.h>
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_misc.h>
+#include <rtl8367c_asicdrv_green.h>
+#include <rtl8367c_asicdrv_lut.h>
+#include <rtl8367c_asicdrv_rma.h>
+#include <rtl8367c_asicdrv_mirror.h>
+
+#if defined(FORCE_PROBE_RTL8367C)
+static init_state_t    init_state = INIT_COMPLETED;
+#elif defined(FORCE_PROBE_RTL8370B)
+static init_state_t    init_state = INIT_COMPLETED;
+#elif defined(FORCE_PROBE_RTL8364B)
+static init_state_t    init_state = INIT_COMPLETED;
+#elif defined(FORCE_PROBE_RTL8363SC_VB)
+static init_state_t    init_state = INIT_COMPLETED;
+#else
+static init_state_t    init_state = INIT_NOT_COMPLETED;
+#endif
+
+#define AUTO_PROBE (!defined(FORCE_PROBE_RTL8367C) && !defined(FORCE_PROBE_RTL8370B) && !defined(FORCE_PROBE_RTL8364B) && !defined(FORCE_PROBE_RTL8363SC_VB))
+
+#if (AUTO_PROBE || defined(FORCE_PROBE_RTL8367C))
+static rtk_switch_halCtrl_t rtl8367c_hal_Ctrl =
+{
+    /* Switch Chip */
+    CHIP_RTL8367C,
+
+    /* Logical to Physical */
+    {0, 1, 2, 3, 4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     6, 7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
+
+    /* Physical to Logical */
+    {UTP_PORT0, UTP_PORT1, UTP_PORT2, UTP_PORT3, UTP_PORT4, UNDEFINE_PORT, EXT_PORT0, EXT_PORT1,
+     UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT,
+     UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT,
+     UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT},
+
+    /* Port Type */
+    {UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT,
+     UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT,
+     EXT_PORT, EXT_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT,
+     UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT},
+
+    /* PTP port */
+    {1, 1, 1, 1, 1, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0 },
+
+    /* Valid port mask */
+    ( (0x1 << UTP_PORT0) | (0x1 << UTP_PORT1) | (0x1 << UTP_PORT2) | (0x1 << UTP_PORT3) | (0x1 << UTP_PORT4) | (0x1 << EXT_PORT0) | (0x1 << EXT_PORT1) ),
+
+    /* Valid UTP port mask */
+    ( (0x1 << UTP_PORT0) | (0x1 << UTP_PORT1) | (0x1 << UTP_PORT2) | (0x1 << UTP_PORT3) | (0x1 << UTP_PORT4) ),
+
+    /* Valid EXT port mask */
+    ( (0x1 << EXT_PORT0) | (0x1 << EXT_PORT1) ),
+
+    /* Valid CPU port mask */
+    0x00,
+
+    /* Minimum physical port number */
+    0,
+
+    /* Maxmum physical port number */
+    7,
+
+    /* Physical port mask */
+    0xDF,
+
+    /* Combo Logical port ID */
+    4,
+
+    /* HSG Logical port ID */
+    EXT_PORT0,
+
+    /* SGMII Logical portmask */
+    (0x1 << EXT_PORT0),
+
+    /* Max Meter ID */
+    31,
+
+    /* MAX LUT Address Number */
+    2112,
+
+    /* Trunk Group Mask */
+    0x03
+};
+#endif
+
+#if (AUTO_PROBE || defined(FORCE_PROBE_RTL8370B))
+static rtk_switch_halCtrl_t rtl8370b_hal_Ctrl =
+{
+    /* Switch Chip */
+    CHIP_RTL8370B,
+
+    /* Logical to Physical */
+    {0, 1, 2, 3, 4, 5, 6, 7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     8, 9, 10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
+
+    /* Physical to Logical */
+    {UTP_PORT0, UTP_PORT1, UTP_PORT2, UTP_PORT3, UTP_PORT4, UTP_PORT5, UTP_PORT6, UTP_PORT7,
+     EXT_PORT0, EXT_PORT1, EXT_PORT2, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT,
+     UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT,
+     UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT},
+
+    /* Port Type */
+    {UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT, UTP_PORT,
+     UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT,
+     EXT_PORT, EXT_PORT, EXT_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT,
+     UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT},
+
+    /* PTP port */
+    {1, 1, 1, 1, 1, 1, 1, 1,
+     0, 0, 0, 0, 0, 0, 0, 0,
+     1, 1, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0 },
+
+    /* Valid port mask */
+    ( (0x1 << UTP_PORT0) | (0x1 << UTP_PORT1) | (0x1 << UTP_PORT2) | (0x1 << UTP_PORT3) | (0x1 << UTP_PORT4) | (0x1 << UTP_PORT5) | (0x1 << UTP_PORT6) | (0x1 << UTP_PORT7) | (0x1 << EXT_PORT0) | (0x1 << EXT_PORT1) | (0x1 << EXT_PORT2) ),
+
+    /* Valid UTP port mask */
+    ( (0x1 << UTP_PORT0) | (0x1 << UTP_PORT1) | (0x1 << UTP_PORT2) | (0x1 << UTP_PORT3) | (0x1 << UTP_PORT4) | (0x1 << UTP_PORT5) | (0x1 << UTP_PORT6) | (0x1 << UTP_PORT7) ),
+
+    /* Valid EXT port mask */
+    ( (0x1 << EXT_PORT0) | (0x1 << EXT_PORT1) | (0x1 << EXT_PORT2) ),
+
+    /* Valid CPU port mask */
+    (0x1 << EXT_PORT2),
+
+    /* Minimum physical port number */
+    0,
+
+    /* Maxmum physical port number */
+    10,
+
+    /* Physical port mask */
+    0x7FF,
+
+    /* Combo Logical port ID */
+    7,
+
+    /* HSG Logical port ID */
+    EXT_PORT1,
+
+    /* SGMII Logical portmask */
+    ( (0x1 << EXT_PORT0) | (0x1 << EXT_PORT1) ),
+
+    /* Max Meter ID */
+    63,
+
+    /* MAX LUT Address Number 4096 + 64*/
+    4160,
+
+    /* Trunk Group Mask */
+    0x07
+};
+#endif
+
+#if (AUTO_PROBE || defined(FORCE_PROBE_RTL8364B))
+static rtk_switch_halCtrl_t rtl8364b_hal_Ctrl =
+{
+    /* Switch Chip */
+    CHIP_RTL8364B,
+
+    /* Logical to Physical */
+    {0xFF, 1, 0xFF, 3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     6, 7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
+
+    /* Physical to Logical */
+    {UNDEFINE_PORT, UTP_PORT1, UNDEFINE_PORT, UTP_PORT3, UNDEFINE_PORT, UNDEFINE_PORT, EXT_PORT0, EXT_PORT1,
+     UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT,
+     UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT,
+     UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT},
+
+    /* Port Type */
+    {UNKNOWN_PORT, UTP_PORT, UNKNOWN_PORT, UTP_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT,
+     UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT,
+     EXT_PORT, EXT_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT,
+     UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT},
+
+    /* PTP port */
+    {0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0 },
+
+    /* Valid port mask */
+    ( (0x1 << UTP_PORT1) | (0x1 << UTP_PORT3) | (0x1 << EXT_PORT0) | (0x1 << EXT_PORT1) ),
+
+    /* Valid UTP port mask */
+    ( (0x1 << UTP_PORT1) | (0x1 << UTP_PORT3) ),
+
+    /* Valid EXT port mask */
+    ( (0x1 << EXT_PORT0) | (0x1 << EXT_PORT1) ),
+
+    /* Valid CPU port mask */
+    0x00,
+
+    /* Minimum physical port number */
+    0,
+
+    /* Maxmum physical port number */
+    7,
+
+    /* Physical port mask */
+    0xCA,
+
+    /* Combo Logical port ID */
+    4,
+
+    /* HSG Logical port ID */
+    EXT_PORT0,
+
+    /* SGMII Logical portmask */
+    ( (0x1 << EXT_PORT0) | (0x1 << EXT_PORT1) ),
+
+    /* Max Meter ID */
+    32,
+
+    /* MAX LUT Address Number */
+    2112,
+
+    /* Trunk Group Mask */
+    0x01
+};
+#endif
+
+#if (AUTO_PROBE || defined(FORCE_PROBE_RTL8363SC_VB))
+static rtk_switch_halCtrl_t rtl8363sc_vb_hal_Ctrl =
+{
+    /* Switch Chip */
+    CHIP_RTL8363SC_VB,
+
+    /* Logical to Physical */
+    {0xFF, 0xFF, 1, 3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     6, 7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
+
+    /* Physical to Logical */
+    {UNDEFINE_PORT, UTP_PORT2, UNDEFINE_PORT, UTP_PORT3, UNDEFINE_PORT, UNDEFINE_PORT, EXT_PORT0, EXT_PORT1,
+     UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT,
+     UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT,
+     UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT, UNDEFINE_PORT},
+
+    /* Port Type */
+    {UNKNOWN_PORT, UNKNOWN_PORT, UTP_PORT, UTP_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT,
+     UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT,
+     EXT_PORT, EXT_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT,
+     UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT, UNKNOWN_PORT},
+
+    /* PTP port */
+    {0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0 },
+
+    /* Valid port mask */
+    ( (0x1 << UTP_PORT2) | (0x1 << UTP_PORT3) | (0x1 << EXT_PORT0) | (0x1 << EXT_PORT1) ),
+
+    /* Valid UTP port mask */
+    ( (0x1 << UTP_PORT2) | (0x1 << UTP_PORT3) ),
+
+    /* Valid EXT port mask */
+    ( (0x1 << EXT_PORT0) | (0x1 << EXT_PORT1) ),
+
+    /* Valid CPU port mask */
+    0x00,
+
+    /* Minimum physical port number */
+    0,
+
+    /* Maxmum physical port number */
+    7,
+
+    /* Physical port mask */
+    0xCA,
+
+    /* Combo Logical port ID */
+    4,
+
+    /* HSG Logical port ID */
+    EXT_PORT0,
+
+    /* SGMII Logical portmask */
+    ( (0x1 << EXT_PORT0) | (0x1 << EXT_PORT1) ),
+
+    /* Max Meter ID */
+    32,
+
+    /* MAX LUT Address Number */
+    2112,
+
+    /* Trunk Group Mask */
+    0x01
+};
+#endif
+
+#if defined(FORCE_PROBE_RTL8367C)
+static rtk_switch_halCtrl_t *halCtrl = &rtl8367c_hal_Ctrl;
+#elif defined(FORCE_PROBE_RTL8370B)
+static rtk_switch_halCtrl_t *halCtrl = &rtl8370b_hal_Ctrl;
+#elif defined(FORCE_PROBE_RTL8364B)
+static rtk_switch_halCtrl_t *halCtrl = &rtl8364b_hal_Ctrl;
+#elif defined(FORCE_PROBE_RTL8363SC_VB)
+static rtk_switch_halCtrl_t *halCtrl = &rtl8363sc_vb_hal_Ctrl;
+#else
+static rtk_switch_halCtrl_t *halCtrl = NULL;
+#endif
+
+static rtk_uint32 PatchChipData[210][2] =
+{
+        {0xa436, 0x8028}, {0xa438, 0x6800}, {0xb82e, 0x0001}, {0xa436, 0xb820}, {0xa438, 0x0090}, {0xa436, 0xa012}, {0xa438, 0x0000}, {0xa436, 0xa014}, {0xa438, 0x2c04}, {0xa438, 0x2c6c},
+        {0xa438, 0x2c75}, {0xa438, 0x2c77}, {0xa438, 0x1414}, {0xa438, 0x1579}, {0xa438, 0x1536}, {0xa438, 0xc432}, {0xa438, 0x32c0}, {0xa438, 0x42d6}, {0xa438, 0x32b5}, {0xa438, 0x003e},
+        {0xa438, 0x614c}, {0xa438, 0x1569}, {0xa438, 0xd705}, {0xa438, 0x318c}, {0xa438, 0x42d6}, {0xa438, 0xd702}, {0xa438, 0x31ef}, {0xa438, 0x42d6}, {0xa438, 0x629c}, {0xa438, 0x2c04},
+        {0xa438, 0x653c}, {0xa438, 0x422a}, {0xa438, 0x5d83}, {0xa438, 0xd06a}, {0xa438, 0xd1b0}, {0xa438, 0x1536}, {0xa438, 0xc43a}, {0xa438, 0x32c0}, {0xa438, 0x42d6}, {0xa438, 0x32b5},
+        {0xa438, 0x003e}, {0xa438, 0x314a}, {0xa438, 0x42fe}, {0xa438, 0x337b}, {0xa438, 0x02d6}, {0xa438, 0x3063}, {0xa438, 0x0c1b}, {0xa438, 0x22fe}, {0xa438, 0xc435}, {0xa438, 0xd0be},
+        {0xa438, 0xd1f7}, {0xa438, 0xe0f0}, {0xa438, 0x1a40}, {0xa438, 0xa320}, {0xa438, 0xd702}, {0xa438, 0x154a}, {0xa438, 0xc434}, {0xa438, 0x32c0}, {0xa438, 0x42d6}, {0xa438, 0x32b5},
+        {0xa438, 0x003e}, {0xa438, 0x60ec}, {0xa438, 0x1569}, {0xa438, 0xd705}, {0xa438, 0x619f}, {0xa438, 0xd702}, {0xa438, 0x414f}, {0xa438, 0x2c2e}, {0xa438, 0x610a}, {0xa438, 0xd705},
+        {0xa438, 0x5e1f}, {0xa438, 0xc43f}, {0xa438, 0xc88b}, {0xa438, 0xd702}, {0xa438, 0x7fe0}, {0xa438, 0x22f3}, {0xa438, 0xd0a0}, {0xa438, 0xd1b2}, {0xa438, 0xd0c3}, {0xa438, 0xd1c3},
+        {0xa438, 0x8d01}, {0xa438, 0x1536}, {0xa438, 0xc438}, {0xa438, 0xe0f0}, {0xa438, 0x1a80}, {0xa438, 0xd706}, {0xa438, 0x60c0}, {0xa438, 0xd710}, {0xa438, 0x409e}, {0xa438, 0xa804},
+        {0xa438, 0xad01}, {0xa438, 0x8804}, {0xa438, 0xd702}, {0xa438, 0x32c0}, {0xa438, 0x42d6}, {0xa438, 0x32b5}, {0xa438, 0x003e}, {0xa438, 0x405b}, {0xa438, 0x1576}, {0xa438, 0x7c9c},
+        {0xa438, 0x60ec}, {0xa438, 0x1569}, {0xa438, 0xd702}, {0xa438, 0x5d43}, {0xa438, 0x31ef}, {0xa438, 0x02fe}, {0xa438, 0x22d6}, {0xa438, 0x590a}, {0xa438, 0xd706}, {0xa438, 0x5c80},
+        {0xa438, 0xd702}, {0xa438, 0x5c44}, {0xa438, 0x3063}, {0xa438, 0x02d6}, {0xa438, 0x5be2}, {0xa438, 0x22fb}, {0xa438, 0xa240}, {0xa438, 0xa104}, {0xa438, 0x8c03}, {0xa438, 0x8178},
+        {0xa438, 0xd701}, {0xa438, 0x31ad}, {0xa438, 0x4917}, {0xa438, 0x8102}, {0xa438, 0x2917}, {0xa438, 0xc302}, {0xa438, 0x268a}, {0xa436, 0xA01A}, {0xa438, 0x0000}, {0xa436, 0xA006},
+        {0xa438, 0x0fff}, {0xa436, 0xA004}, {0xa438, 0x0689}, {0xa436, 0xA002}, {0xa438, 0x0911}, {0xa436, 0xA000}, {0xa438, 0x7302}, {0xa436, 0xB820}, {0xa438, 0x0010}, {0xa436, 0x8412},
+        {0xa438, 0xaf84}, {0xa438, 0x1eaf}, {0xa438, 0x8427}, {0xa438, 0xaf84}, {0xa438, 0x27af}, {0xa438, 0x8427}, {0xa438, 0x0251}, {0xa438, 0x6802}, {0xa438, 0x8427}, {0xa438, 0xaf04},
+        {0xa438, 0x0af8}, {0xa438, 0xf9bf}, {0xa438, 0x5581}, {0xa438, 0x0255}, {0xa438, 0x27ef}, {0xa438, 0x310d}, {0xa438, 0x345b}, {0xa438, 0x0fa3}, {0xa438, 0x032a}, {0xa438, 0xe087},
+        {0xa438, 0xffac}, {0xa438, 0x2040}, {0xa438, 0xbf56}, {0xa438, 0x7402}, {0xa438, 0x5527}, {0xa438, 0xef31}, {0xa438, 0xef20}, {0xa438, 0xe787}, {0xa438, 0xfee6}, {0xa438, 0x87fd},
+        {0xa438, 0xd488}, {0xa438, 0x88bf}, {0xa438, 0x5674}, {0xa438, 0x0254}, {0xa438, 0xe3e0}, {0xa438, 0x87ff}, {0xa438, 0xf720}, {0xa438, 0xe487}, {0xa438, 0xffaf}, {0xa438, 0x847e},
+        {0xa438, 0xe087}, {0xa438, 0xffad}, {0xa438, 0x2016}, {0xa438, 0xe387}, {0xa438, 0xfee2}, {0xa438, 0x87fd}, {0xa438, 0xef45}, {0xa438, 0xbf56}, {0xa438, 0x7402}, {0xa438, 0x54e3},
+        {0xa438, 0xe087}, {0xa438, 0xfff6}, {0xa438, 0x20e4}, {0xa438, 0x87ff}, {0xa438, 0xfdfc}, {0xa438, 0x0400}, {0xa436, 0xb818}, {0xa438, 0x0407}, {0xa436, 0xb81a}, {0xa438, 0xfffd},
+        {0xa436, 0xb81c}, {0xa438, 0xfffd}, {0xa436, 0xb81e}, {0xa438, 0xfffd}, {0xa436, 0xb832}, {0xa438, 0x0001}, {0xb820, 0x0000}, {0xb82e, 0x0000}, {0xa436, 0x8028}, {0xa438, 0x0000}
+};
+
+static rtk_api_ret_t _rtk_switch_init_8367c(void)
+{
+    rtk_port_t port;
+    rtk_uint32 retVal;
+    rtk_uint32 regData;
+    rtk_uint32 regValue;
+
+    if( (retVal = rtl8367c_setAsicReg(0x13c2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if( (retVal = rtl8367c_getAsicReg(0x1301, &regValue)) != RT_ERR_OK)
+        return retVal;
+
+    if( (retVal = rtl8367c_setAsicReg(0x13c2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    RTK_SCAN_ALL_LOG_PORT(port)
+    {
+         if(rtk_switch_isUtpPort(port) == RT_ERR_OK)
+         {
+             if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_PORT0_EEECFG + (0x20 * port), RTL8367C_PORT0_EEECFG_EEE_100M_OFFSET, 1)) != RT_ERR_OK)
+                 return retVal;
+
+             if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_PORT0_EEECFG + (0x20 * port), RTL8367C_PORT0_EEECFG_EEE_GIGA_500M_OFFSET, 1)) != RT_ERR_OK)
+                 return retVal;
+
+             if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_PORT0_EEECFG + (0x20 * port), RTL8367C_PORT0_EEECFG_EEE_TX_OFFSET, 1)) != RT_ERR_OK)
+                 return retVal;
+
+             if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_PORT0_EEECFG + (0x20 * port), RTL8367C_PORT0_EEECFG_EEE_RX_OFFSET, 1)) != RT_ERR_OK)
+                 return retVal;
+
+             if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xA428, &regData)) != RT_ERR_OK)
+                return retVal;
+
+             regData &= ~(0x0200);
+             if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xA428, regData)) != RT_ERR_OK)
+                 return retVal;
+
+             if((regValue & 0x00F0) == 0x00A0)
+             {
+                 if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xA5D0, &regData)) != RT_ERR_OK)
+                     return retVal;
+
+                 regData |= 0x0006;
+                 if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xA5D0, regData)) != RT_ERR_OK)
+                     return retVal;
+             }
+         }
+    }
+
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_UTP_FIB_DET, 0x15BB)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x1303, 0x06D6)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x1304, 0x0700)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13E2, 0x003F)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13F9, 0x0090)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x121e, 0x03CA)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x1233, 0x0352)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x1237, 0x00a0)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x123a, 0x0030)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x1239, 0x0084)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x0301, 0x1000)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x1349, 0x001F)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicRegBit(0x18e0, 0, 0)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicRegBit(0x122b, 14, 1)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicRegBits(0x1305, 0xC000, 3)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+static rtk_api_ret_t _rtk_switch_init_8370b(void)
+{
+    ret_t retVal;
+    rtk_uint32 regData, tmp = 0;
+    rtk_uint32 i, prf, counter;
+    rtk_uint32 long_link[8] = {0x0210, 0x03e8, 0x0218, 0x03f0, 0x0220, 0x03f8, 0x0208, 0x03e0 };
+
+    if((retVal = rtl8367c_setAsicRegBits(0x1205, 0x0300, 3)) != RT_ERR_OK)
+        return retVal;
+
+
+    for(i=0; i<8; i++)
+    {
+      if ((retVal = rtl8367c_getAsicPHYOCPReg(i, 0xa420, &regData)) != RT_ERR_OK)
+          return retVal;
+        tmp = regData & 0x7 ;
+       if(tmp == 0x3)
+       {
+           prf = 1;
+           if((retVal = rtl8367c_setAsicPHYOCPReg(i, 0xb83e, 0x6fa9)) != RT_ERR_OK)
+              return retVal;
+           if((retVal = rtl8367c_setAsicPHYOCPReg(i, 0xb840, 0xa9)) != RT_ERR_OK)
+               return retVal;
+           for(counter = 0; counter < 10000; counter++); //delay
+
+           if ((retVal = rtl8367c_getAsicPHYOCPReg(i, 0xb820, &regData)) != RT_ERR_OK)
+               return retVal;
+           tmp = regData | 0x10;
+           if ((retVal = rtl8367c_setAsicPHYOCPReg(i, 0xb820, tmp)) != RT_ERR_OK)
+               return retVal;
+           for(counter = 0; counter < 10000; counter++); //delay
+           counter = 0;
+           do{
+              counter = counter + 1;
+              if ((retVal = rtl8367c_getAsicPHYOCPReg(i, 0xb800, &regData)) != RT_ERR_OK)
+                   return retVal;
+              tmp = regData & 0x40;
+              if(tmp != 0)
+                break;
+           } while (counter < 20);   //Wait for patch ready = 1...
+       }
+   }
+    if ((retVal = rtl8367c_getAsicReg(0x1d01, &regData)) != RT_ERR_OK)
+        return retVal;
+    tmp = regData;
+    tmp = tmp | 0x3BE0; /*Broadcast port enable*/
+    tmp = tmp & 0xFFE0; /*Phy_id = 0 */
+    if((retVal = rtl8367c_setAsicReg(0x1d01, tmp)) != RT_ERR_OK)
+        return retVal;
+
+    for(i=0;i < 210; i++)
+    {
+        if((retVal = rtl8367c_setAsicPHYOCPReg(0, PatchChipData[i][0], PatchChipData[i][1])) != RT_ERR_OK)
+             return retVal;
+    }
+
+   if((retVal = rtl8367c_setAsicReg(0x1d01, regData)) != RT_ERR_OK)
+        return retVal;
+
+    for(i=0; i < 8; i++)
+    {
+        if((retVal = rtl8367c_setAsicPHYOCPReg(i, 0xa4b4, long_link[i])) != RT_ERR_OK)
+             return retVal;
+    }
+
+  if (prf == 0x1)
+     {
+        for(i=0; i<8; i++)
+        {
+         if ((retVal = rtl8367c_getAsicPHYOCPReg(i, 0xb820, &regData)) != RT_ERR_OK)
+             return retVal;
+       tmp = regData & 0xFFEF;
+       if ((retVal = rtl8367c_setAsicPHYOCPReg(i, 0xb820, tmp)) != RT_ERR_OK)
+             return retVal;
+
+       for(counter = 0; counter < 10000; counter++); //delay
+
+       counter = 0;
+       do{
+            counter = counter + 1;
+            if ((retVal = rtl8367c_getAsicPHYOCPReg(i, 0xb800, &regData)) != RT_ERR_OK)
+              return retVal;
+            tmp = regData & 0x40;
+            if( tmp == 0 )
+               break;
+       } while (counter < 20);   //Wait for patch ready = 1...
+      if ((retVal = rtl8367c_setAsicPHYOCPReg(i, 0xb83e, 0x6f48)) != RT_ERR_OK)
+          return retVal;
+      if ((retVal = rtl8367c_setAsicPHYOCPReg(i, 0xb840, 0xfa)) != RT_ERR_OK)
+          return retVal;
+          }
+   }
+
+    /*Check phy link status*/
+    for(i=0; i<8; i++)
+    {
+      if ((retVal = rtl8367c_getAsicPHYOCPReg(i, 0xa400, &regData)) != RT_ERR_OK)
+          return retVal;
+      tmp = regData & 0x800;
+        if(tmp == 0x0)
+            {
+              tmp = regData | 0x200;
+          if ((retVal = rtl8367c_setAsicPHYOCPReg(i, 0xa400, tmp)) != RT_ERR_OK)
+             return retVal;
+            }
+    }
+
+  for(counter = 0; counter < 10000; counter++); //delay
+
+  return RT_ERR_OK;
+}
+
+static rtk_api_ret_t _rtk_switch_init_8364b(void)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    /*enable EEE, include mac & phy*/
+
+    if ((retVal = rtl8367c_setAsicRegBits(0x38, 0x300, 3)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0x78, 0x300, 3)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0xd8, 0x300, 0)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0xf8, 0x300, 0)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPHYOCPReg(1, 0xa5d0, 6)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicPHYOCPReg(3, 0xa5d0, 6)) != RT_ERR_OK)
+        return retVal;
+
+    /*PAD para*/
+
+    /*EXT1 PAD Para*/
+    if ((retVal = rtl8367c_getAsicReg(0x1303, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData &= 0xFFFFFFFE;
+    regData |= 0x250;
+    if((retVal = rtl8367c_setAsicReg(0x1303, regData)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRegBits(0x1304, 0x7000, 0)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0x1304, 0x700, 7)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0x13f9, 0x38, 0)) != RT_ERR_OK)
+        return retVal;
+
+    /*EXT2 PAD Para*/
+    if ((retVal = rtl8367c_setAsicRegBit(0x1303, 10, 1)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0x13E2, 0x1ff, 0x26)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0x13f9, 0x1c0, 0)) != RT_ERR_OK)
+        return retVal;
+
+
+    /*SDS PATCH*/
+    /*SP_CFG_EN_LINK_FIB1G*/
+    if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData |= 0x4;
+    if((retVal = rtl8367c_setAsicSdsReg(0,4,0, regData)) != RT_ERR_OK)
+        return retVal;
+
+    /*FIB100 Down-speed*/
+    if((retVal = rtl8367c_getAsicSdsReg(0, 1, 0, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData |= 0x20;
+    if((retVal = rtl8367c_setAsicSdsReg(0,1,0, regData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+static rtk_api_ret_t _rtk_switch_init_8363sc_vb(void)
+{
+
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    /*enable EEE, include mac & phy*/
+
+    if ((retVal = rtl8367c_setAsicRegBits(0x38, 0x300, 3)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0x78, 0x300, 3)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0xd8, 0x300, 0)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0xf8, 0x300, 0)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPHYOCPReg(1, 0xa5d0, 6)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicPHYOCPReg(3, 0xa5d0, 6)) != RT_ERR_OK)
+        return retVal;
+
+    /*PAD para*/
+
+    /*EXT1 PAD Para*/
+    if ((retVal = rtl8367c_getAsicReg(0x1303, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData &= 0xFFFFFFFE;
+    regData |= 0x250;
+    if((retVal = rtl8367c_setAsicReg(0x1303, regData)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRegBits(0x1304, 0x7000, 0)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0x1304, 0x700, 7)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0x13f9, 0x38, 0)) != RT_ERR_OK)
+        return retVal;
+
+    /*EXT2 PAD Para*/
+    if ((retVal = rtl8367c_setAsicRegBit(0x1303, 10, 1)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0x13E2, 0x1ff, 0x26)) != RT_ERR_OK)
+        return retVal;
+    if ((retVal = rtl8367c_setAsicRegBits(0x13f9, 0x1c0, 0)) != RT_ERR_OK)
+        return retVal;
+
+
+    /*SDS PATCH*/
+    /*SP_CFG_EN_LINK_FIB1G*/
+    if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData |= 0x4;
+    if((retVal = rtl8367c_setAsicSdsReg(0,4,0, regData)) != RT_ERR_OK)
+        return retVal;
+
+    /*FIB100 Down-speed*/
+    if((retVal = rtl8367c_getAsicSdsReg(0, 1, 0, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData |= 0x20;
+    if((retVal = rtl8367c_setAsicSdsReg(0,1,0, regData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_probe
+ * Description:
+ *      Probe switch
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Switch probed
+ *      RT_ERR_FAILED   - Switch Unprobed.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_probe(switch_chip_t *pSwitchChip)
+{
+#if defined(FORCE_PROBE_RTL8367C)
+
+    *pSwitchChip = CHIP_RTL8367C;
+    halCtrl = &rtl8367c_hal_Ctrl;
+
+#elif defined(FORCE_PROBE_RTL8370B)
+
+    *pSwitchChip = CHIP_RTL8370B;
+    halCtrl = &rtl8370b_hal_Ctrl;
+
+#elif defined(FORCE_PROBE_RTL8364B)
+
+    *pSwitchChip = CHIP_RTL8364B;
+    halCtrl = &rtl8364b_hal_Ctrl;
+
+#elif defined(FORCE_PROBE_RTL8363SC_VB)
+
+    *pSwitchChip = CHIP_RTL8363SC_VB;
+    halCtrl = &rtl8363sc_vb_hal_Ctrl;
+
+#else
+    rtk_uint32 retVal;
+    rtk_uint32 data, regValue;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &data)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1301, &regValue)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    switch (data)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            *pSwitchChip = CHIP_RTL8367C;
+            halCtrl = &rtl8367c_hal_Ctrl;
+            break;
+        case 0x0652:
+        case 0x6368:
+            *pSwitchChip = CHIP_RTL8370B;
+            halCtrl = &rtl8370b_hal_Ctrl;
+            break;
+        case 0x0801:
+        case 0x6511:
+            if( (regValue & 0x00F0) == 0x0080)
+            {
+                *pSwitchChip = CHIP_RTL8363SC_VB;
+                halCtrl = &rtl8363sc_vb_hal_Ctrl;
+            }
+            else
+            {
+                *pSwitchChip = CHIP_RTL8364B;
+                halCtrl = &rtl8364b_hal_Ctrl;
+            }
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+#endif
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_initialState_set
+ * Description:
+ *      Set initial status
+ * Input:
+ *      state   - Initial state;
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Initialized
+ *      RT_ERR_FAILED   - Uninitialized
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_initialState_set(init_state_t state)
+{
+    if(state >= INIT_STATE_END)
+        return RT_ERR_FAILED;
+
+    init_state = state;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_initialState_get
+ * Description:
+ *      Get initial status
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      INIT_COMPLETED     - Initialized
+ *      INIT_NOT_COMPLETED - Uninitialized
+ * Note:
+ *
+ */
+init_state_t rtk_switch_initialState_get(void)
+{
+    return init_state;
+}
+
+/* Function Name:
+ *      rtk_switch_logicalPortCheck
+ * Description:
+ *      Check logical port ID.
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is correct
+ *      RT_ERR_FAILED   - Port ID is not correct
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_logicalPortCheck(rtk_port_t logicalPort)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(logicalPort >= RTK_SWITCH_PORT_NUM)
+        return RT_ERR_FAILED;
+
+    if(halCtrl->l2p_port[logicalPort] == 0xFF)
+        return RT_ERR_FAILED;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_isUtpPort
+ * Description:
+ *      Check is logical port a UTP port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a UTP port
+ *      RT_ERR_FAILED   - Port ID is not a UTP port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_isUtpPort(rtk_port_t logicalPort)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(logicalPort >= RTK_SWITCH_PORT_NUM)
+        return RT_ERR_FAILED;
+
+    if(halCtrl->log_port_type[logicalPort] == UTP_PORT)
+        return RT_ERR_OK;
+    else
+        return RT_ERR_FAILED;
+}
+
+/* Function Name:
+ *      rtk_switch_isExtPort
+ * Description:
+ *      Check is logical port a Extension port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a EXT port
+ *      RT_ERR_FAILED   - Port ID is not a EXT port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_isExtPort(rtk_port_t logicalPort)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(logicalPort >= RTK_SWITCH_PORT_NUM)
+        return RT_ERR_FAILED;
+
+    if(halCtrl->log_port_type[logicalPort] == EXT_PORT)
+        return RT_ERR_OK;
+    else
+        return RT_ERR_FAILED;
+}
+
+
+/* Function Name:
+ *      rtk_switch_isHsgPort
+ * Description:
+ *      Check is logical port a HSG port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a HSG port
+ *      RT_ERR_FAILED   - Port ID is not a HSG port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_isHsgPort(rtk_port_t logicalPort)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(logicalPort >= RTK_SWITCH_PORT_NUM)
+        return RT_ERR_FAILED;
+
+    if(logicalPort == halCtrl->hsg_logical_port)
+        return RT_ERR_OK;
+    else
+        return RT_ERR_FAILED;
+}
+
+/* Function Name:
+ *      rtk_switch_isSgmiiPort
+ * Description:
+ *      Check is logical port a SGMII port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a SGMII port
+ *      RT_ERR_FAILED   - Port ID is not a SGMII port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_isSgmiiPort(rtk_port_t logicalPort)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(logicalPort >= RTK_SWITCH_PORT_NUM)
+        return RT_ERR_FAILED;
+
+    if( ((0x01 << logicalPort) & halCtrl->sg_logical_portmask) != 0)
+        return RT_ERR_OK;
+    else
+        return RT_ERR_FAILED;
+}
+
+/* Function Name:
+ *      rtk_switch_isCPUPort
+ * Description:
+ *      Check is logical port a CPU port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a CPU port
+ *      RT_ERR_FAILED   - Port ID is not a CPU port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_isCPUPort(rtk_port_t logicalPort)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(logicalPort >= RTK_SWITCH_PORT_NUM)
+        return RT_ERR_FAILED;
+
+    if( ((0x01 << logicalPort) & halCtrl->valid_cpu_portmask) != 0)
+        return RT_ERR_OK;
+    else
+        return RT_ERR_FAILED;
+}
+
+/* Function Name:
+ *      rtk_switch_isComboPort
+ * Description:
+ *      Check is logical port a Combo port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a combo port
+ *      RT_ERR_FAILED   - Port ID is not a combo port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_isComboPort(rtk_port_t logicalPort)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(logicalPort >= RTK_SWITCH_PORT_NUM)
+        return RT_ERR_FAILED;
+
+    if(halCtrl->combo_logical_port == logicalPort)
+        return RT_ERR_OK;
+    else
+        return RT_ERR_FAILED;
+}
+
+/* Function Name:
+ *      rtk_switch_ComboPort_get
+ * Description:
+ *      Get Combo port ID
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      Port ID of combo port
+ * Note:
+ *
+ */
+rtk_uint32 rtk_switch_ComboPort_get(void)
+{
+    return halCtrl->combo_logical_port;
+}
+
+/* Function Name:
+ *      rtk_switch_isPtpPort
+ * Description:
+ *      Check is logical port a PTP port
+ * Input:
+ *      logicalPort     - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Port ID is a PTP port
+ *      RT_ERR_FAILED   - Port ID is not a PTP port
+ *      RT_ERR_NOT_INIT - Not Initialize
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_isPtpPort(rtk_port_t logicalPort)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(logicalPort >= RTK_SWITCH_PORT_NUM)
+        return RT_ERR_FAILED;
+
+    if(halCtrl->ptp_port[logicalPort] == 1)
+        return RT_ERR_OK;
+    else
+        return RT_ERR_FAILED;
+}
+
+/* Function Name:
+ *      rtk_switch_port_L2P_get
+ * Description:
+ *      Get physical port ID
+ * Input:
+ *      logicalPort       - logical port ID
+ * Output:
+ *      None
+ * Return:
+ *      Physical port ID
+ * Note:
+ *
+ */
+rtk_uint32 rtk_switch_port_L2P_get(rtk_port_t logicalPort)
+{
+    if(init_state != INIT_COMPLETED)
+        return UNDEFINE_PHY_PORT;
+
+    if(logicalPort >= RTK_SWITCH_PORT_NUM)
+        return UNDEFINE_PHY_PORT;
+
+    return (halCtrl->l2p_port[logicalPort]);
+}
+
+/* Function Name:
+ *      rtk_switch_port_P2L_get
+ * Description:
+ *      Get logical port ID
+ * Input:
+ *      physicalPort       - physical port ID
+ * Output:
+ *      None
+ * Return:
+ *      logical port ID
+ * Note:
+ *
+ */
+rtk_port_t rtk_switch_port_P2L_get(rtk_uint32 physicalPort)
+{
+    if(init_state != INIT_COMPLETED)
+        return UNDEFINE_PORT;
+
+    if(physicalPort >= RTK_SWITCH_PORT_NUM)
+        return UNDEFINE_PORT;
+
+    return (halCtrl->p2l_port[physicalPort]);
+}
+
+/* Function Name:
+ *      rtk_switch_isPortMaskValid
+ * Description:
+ *      Check portmask is valid or not
+ * Input:
+ *      pPmask       - logical port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - port mask is valid
+ *      RT_ERR_FAILED       - port mask is not valid
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_isPortMaskValid(rtk_portmask_t *pPmask)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(NULL == pPmask)
+        return RT_ERR_NULL_POINTER;
+
+    if( (pPmask->bits[0] | halCtrl->valid_portmask) != halCtrl->valid_portmask )
+        return RT_ERR_FAILED;
+    else
+        return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_isPortMaskUtp
+ * Description:
+ *      Check all ports in portmask are only UTP port
+ * Input:
+ *      pPmask       - logical port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Only UTP port in port mask
+ *      RT_ERR_FAILED       - Not only UTP port in port mask
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_isPortMaskUtp(rtk_portmask_t *pPmask)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(NULL == pPmask)
+        return RT_ERR_NULL_POINTER;
+
+    if( (pPmask->bits[0] | halCtrl->valid_utp_portmask) != halCtrl->valid_utp_portmask )
+        return RT_ERR_FAILED;
+    else
+        return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_isPortMaskExt
+ * Description:
+ *      Check all ports in portmask are only EXT port
+ * Input:
+ *      pPmask       - logical port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Only EXT port in port mask
+ *      RT_ERR_FAILED       - Not only EXT port in port mask
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_isPortMaskExt(rtk_portmask_t *pPmask)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(NULL == pPmask)
+        return RT_ERR_NULL_POINTER;
+
+    if( (pPmask->bits[0] | halCtrl->valid_ext_portmask) != halCtrl->valid_ext_portmask )
+        return RT_ERR_FAILED;
+    else
+        return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_portmask_L2P_get
+ * Description:
+ *      Get physicl portmask from logical portmask
+ * Input:
+ *      pLogicalPmask       - logical port mask
+ * Output:
+ *      pPhysicalPortmask   - physical port mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ *      RT_ERR_PORT_MASK    - Error port mask
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_portmask_L2P_get(rtk_portmask_t *pLogicalPmask, rtk_uint32 *pPhysicalPortmask)
+{
+    rtk_uint32 log_port, phy_port;
+
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(NULL == pLogicalPmask)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pPhysicalPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    if(rtk_switch_isPortMaskValid(pLogicalPmask) != RT_ERR_OK)
+        return RT_ERR_PORT_MASK;
+
+    /* reset physical port mask */
+    *pPhysicalPortmask = 0;
+
+    RTK_PORTMASK_SCAN((*pLogicalPmask), log_port)
+    {
+        phy_port = rtk_switch_port_L2P_get((rtk_port_t)log_port);
+        *pPhysicalPortmask |= (0x0001 << phy_port);
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_portmask_P2L_get
+ * Description:
+ *      Get logical portmask from physical portmask
+ * Input:
+ *      physicalPortmask    - physical port mask
+ * Output:
+ *      pLogicalPmask       - logical port mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ *      RT_ERR_PORT_MASK    - Error port mask
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_portmask_P2L_get(rtk_uint32 physicalPortmask, rtk_portmask_t *pLogicalPmask)
+{
+    rtk_uint32 log_port, phy_port;
+
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_NOT_INIT;
+
+    if(NULL == pLogicalPmask)
+        return RT_ERR_NULL_POINTER;
+
+    RTK_PORTMASK_CLEAR(*pLogicalPmask);
+
+    for(phy_port = halCtrl->min_phy_port; phy_port <= halCtrl->max_phy_port; phy_port++)
+    {
+        if(physicalPortmask & (0x0001 << phy_port))
+        {
+            log_port = rtk_switch_port_P2L_get(phy_port);
+            if(log_port != UNDEFINE_PORT)
+            {
+                RTK_PORTMASK_PORT_SET(*pLogicalPmask, log_port);
+            }
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_phyPortMask_get
+ * Description:
+ *      Get physical portmask
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      0x00                - Not Initialize
+ *      Other value         - Physical port mask
+ * Note:
+ *
+ */
+rtk_uint32 rtk_switch_phyPortMask_get(void)
+{
+    if(init_state != INIT_COMPLETED)
+        return 0x00; /* No port in portmask */
+
+    return (halCtrl->phy_portmask);
+}
+
+/* Function Name:
+ *      rtk_switch_logPortMask_get
+ * Description:
+ *      Get Logical portmask
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_NOT_INIT     - Not Initialize
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_switch_logPortMask_get(rtk_portmask_t *pPortmask)
+{
+    if(init_state != INIT_COMPLETED)
+        return RT_ERR_FAILED;
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    pPortmask->bits[0] = halCtrl->valid_portmask;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_init
+ * Description:
+ *      Set chip to default configuration enviroment
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      The API can set chip registers to default configuration for different release chip model.
+ */
+rtk_api_ret_t rtk_switch_init(void)
+{
+    rtk_uint32  retVal;
+    rtl8367c_rma_t rmaCfg;
+    switch_chip_t   switchChip;
+
+    /* probe switch */
+    if((retVal = rtk_switch_probe(&switchChip)) != RT_ERR_OK)
+        return retVal;
+
+    /* Set initial state */
+
+    if((retVal = rtk_switch_initialState_set(INIT_COMPLETED)) != RT_ERR_OK)
+        return retVal;
+
+    /* Initial */
+    switch(switchChip)
+    {
+        case CHIP_RTL8367C:
+            if((retVal = _rtk_switch_init_8367c()) != RT_ERR_OK)
+                return retVal;
+            break;
+        case CHIP_RTL8370B:
+            if((retVal = _rtk_switch_init_8370b()) != RT_ERR_OK)
+                return retVal;
+            break;
+        case CHIP_RTL8364B:
+            if((retVal = _rtk_switch_init_8364b()) != RT_ERR_OK)
+                return retVal;
+            break;
+        case CHIP_RTL8363SC_VB:
+            if((retVal = _rtk_switch_init_8363sc_vb()) != RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            return RT_ERR_CHIP_NOT_FOUND;
+    }
+
+    /* Set Old max packet length to 16K */
+    if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_MAX_LENGTH_LIMINT_IPG, RTL8367C_MAX_LENTH_CTRL_MASK, 3)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_MAX_LEN_RX_TX, RTL8367C_MAX_LEN_RX_TX_MASK, 3)) != RT_ERR_OK)
+        return retVal;
+
+    /* ACL Mode */
+    if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_ACL_ACCESS_MODE, RTL8367C_ACL_ACCESS_MODE_MASK, 1)) != RT_ERR_OK)
+        return retVal;
+
+    /* Max rate */
+    if((retVal = rtk_rate_igrBandwidthCtrlRate_set(halCtrl->hsg_logical_port, RTL8367C_QOS_RATE_INPUT_MAX_HSG, DISABLED, ENABLED)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtk_rate_egrBandwidthCtrlRate_set(halCtrl->hsg_logical_port, RTL8367C_QOS_RATE_INPUT_MAX_HSG, ENABLED)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x03fa, 0x0007)) != RT_ERR_OK)
+        return retVal;
+
+    /* Change unknown DA to per port setting */
+    if((retVal = rtl8367c_setAsicRegBits(RTL8367C_PORT_SECURIT_CTRL_REG, RTL8367C_UNKNOWN_UNICAST_DA_BEHAVE_MASK, 3)) != RT_ERR_OK)
+        return retVal;
+
+    /* LUT lookup OP = 1 */
+    if ((retVal = rtl8367c_setAsicLutIpLookupMethod(1))!=RT_ERR_OK)
+        return retVal;
+
+    /* Set RMA */
+    rmaCfg.portiso_leaky = 0;
+    rmaCfg.vlan_leaky = 0;
+    rmaCfg.keep_format = 0;
+    rmaCfg.trap_priority = 0;
+    rmaCfg.discard_storm_filter = 0;
+    rmaCfg.operation = 0;
+    if ((retVal = rtl8367c_setAsicRma(2, &rmaCfg))!=RT_ERR_OK)
+        return retVal;
+
+    /* Enable TX Mirror isolation leaky */
+    if ((retVal = rtl8367c_setAsicPortMirrorIsolationTxLeaky(ENABLED)) != RT_ERR_OK)
+        return retVal;
+
+    /* INT EN */
+    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IO_MISC_FUNC, RTL8367C_INT_EN_OFFSET, 1)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_portMaxPktLen_set
+ * Description:
+ *      Set Max packet length
+ * Input:
+ *      port    - Port ID
+ *      speed   - Speed
+ *      cfgId   - Configuration ID
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ */
+rtk_api_ret_t rtk_switch_portMaxPktLen_set(rtk_port_t port, rtk_switch_maxPktLen_linkSpeed_t speed, rtk_uint32 cfgId)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(speed >= MAXPKTLEN_LINK_SPEED_END)
+        return RT_ERR_INPUT;
+
+    if(cfgId > MAXPKTLEN_CFG_ID_MAX)
+        return RT_ERR_INPUT;
+
+    if((retVal = rtl8367c_setAsicMaxLength(rtk_switch_port_L2P_get(port), (rtk_uint32)speed, cfgId)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_portMaxPktLen_get
+ * Description:
+ *      Get Max packet length
+ * Input:
+ *      port    - Port ID
+ *      speed   - Speed
+ * Output:
+ *      pCfgId  - Configuration ID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ */
+rtk_api_ret_t rtk_switch_portMaxPktLen_get(rtk_port_t port, rtk_switch_maxPktLen_linkSpeed_t speed, rtk_uint32 *pCfgId)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(speed >= MAXPKTLEN_LINK_SPEED_END)
+        return RT_ERR_INPUT;
+
+    if(NULL == pCfgId)
+        return RT_ERR_NULL_POINTER;
+
+    if((retVal = rtl8367c_getAsicMaxLength(rtk_switch_port_L2P_get(port), (rtk_uint32)speed, pCfgId)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_maxPktLenCfg_set
+ * Description:
+ *      Set Max packet length configuration
+ * Input:
+ *      cfgId   - Configuration ID
+ *      pktLen  - Max packet length
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ */
+rtk_api_ret_t rtk_switch_maxPktLenCfg_set(rtk_uint32 cfgId, rtk_uint32 pktLen)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(cfgId > MAXPKTLEN_CFG_ID_MAX)
+        return RT_ERR_INPUT;
+
+    if(pktLen > RTK_SWITCH_MAX_PKTLEN)
+        return RT_ERR_INPUT;
+
+    if((retVal = rtl8367c_setAsicMaxLengthCfg(cfgId, pktLen)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_maxPktLenCfg_get
+ * Description:
+ *      Get Max packet length configuration
+ * Input:
+ *      cfgId   - Configuration ID
+ *      pPktLen - Max packet length
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ */
+rtk_api_ret_t rtk_switch_maxPktLenCfg_get(rtk_uint32 cfgId, rtk_uint32 *pPktLen)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(cfgId > MAXPKTLEN_CFG_ID_MAX)
+        return RT_ERR_INPUT;
+
+    if(NULL == pPktLen)
+        return RT_ERR_NULL_POINTER;
+
+    if((retVal = rtl8367c_getAsicMaxLengthCfg(cfgId, pPktLen)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_greenEthernet_set
+ * Description:
+ *      Set all Ports Green Ethernet state.
+ * Input:
+ *      enable - Green Ethernet state.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - OK
+ *      RT_ERR_FAILED   - Failed
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_ENABLE   - Invalid enable input.
+ * Note:
+ *      This API can set all Ports Green Ethernet state.
+ *      The configuration is as following:
+ *      - DISABLE
+ *      - ENABLE
+ */
+rtk_api_ret_t rtk_switch_greenEthernet_set(rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    RTK_SCAN_ALL_LOG_PORT(port)
+    {
+        if(rtk_switch_isUtpPort(port) == RT_ERR_OK)
+        {
+            if ((retVal = rtl8367c_setAsicPowerSaving(rtk_switch_port_L2P_get(port),enable))!=RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicGreenEthernet(rtk_switch_port_L2P_get(port), enable))!=RT_ERR_OK)
+                return retVal;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_greenEthernet_get
+ * Description:
+ *      Get all Ports Green Ethernet state.
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - Green Ethernet state.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ * Note:
+ *      This API can get Green Ethernet state.
+ */
+rtk_api_ret_t rtk_switch_greenEthernet_get(rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 port;
+    rtk_uint32 state;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    RTK_SCAN_ALL_LOG_PORT(port)
+    {
+        if(rtk_switch_isUtpPort(port) == RT_ERR_OK)
+        {
+            if ((retVal = rtl8367c_getAsicPowerSaving(rtk_switch_port_L2P_get(port), &state))!=RT_ERR_OK)
+                return retVal;
+
+            if(state == DISABLED)
+            {
+                *pEnable = DISABLED;
+                return RT_ERR_OK;
+            }
+
+            if ((retVal = rtl8367c_getAsicGreenEthernet(rtk_switch_port_L2P_get(port), &state))!=RT_ERR_OK)
+                return retVal;
+
+            if(state == DISABLED)
+            {
+                *pEnable = DISABLED;
+                return RT_ERR_OK;
+            }
+        }
+    }
+
+    *pEnable = ENABLED;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_switch_maxLogicalPort_get
+ * Description:
+ *      Get Max logical port ID
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      Max logical port
+ * Note:
+ *      This API can get max logical port
+ */
+rtk_port_t rtk_switch_maxLogicalPort_get(void)
+{
+    rtk_port_t port, maxLogicalPort = 0;
+
+    /* Check initialization state */
+    if(rtk_switch_initialState_get() != INIT_COMPLETED)
+    {
+        return UNDEFINE_PORT;
+    }
+
+    for(port = 0; port < RTK_SWITCH_PORT_NUM; port++)
+    {
+        if( (halCtrl->log_port_type[port] == UTP_PORT) || (halCtrl->log_port_type[port] == EXT_PORT) )
+            maxLogicalPort = port;
+    }
+
+    return maxLogicalPort;
+}
+
+/* Function Name:
+ *      rtk_switch_maxMeterId_get
+ * Description:
+ *      Get Max Meter ID
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      0x00                - Not Initialize
+ *      Other value         - Max Meter ID
+ * Note:
+ *
+ */
+rtk_uint32 rtk_switch_maxMeterId_get(void)
+{
+    if(init_state != INIT_COMPLETED)
+        return 0x00;
+
+    return (halCtrl->max_meter_id);
+}
+
+/* Function Name:
+ *      rtk_switch_maxLutAddrNumber_get
+ * Description:
+ *      Get Max LUT Address number
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      0x00                - Not Initialize
+ *      Other value         - Max LUT Address number
+ * Note:
+ *
+ */
+rtk_uint32 rtk_switch_maxLutAddrNumber_get(void)
+{
+    if(init_state != INIT_COMPLETED)
+        return 0x00;
+
+    return (halCtrl->max_lut_addr_num);
+}
+
+/* Function Name:
+ *      rtk_switch_isValidTrunkGrpId
+ * Description:
+ *      Check if trunk group is valid or not
+ * Input:
+ *      grpId       - Group ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Trunk Group ID is valid
+ *      RT_ERR_LA_TRUNK_ID  - Trunk Group ID is not valid
+ * Note:
+ *
+ */
+rtk_uint32 rtk_switch_isValidTrunkGrpId(rtk_uint32 grpId)
+{
+    if(init_state != INIT_COMPLETED)
+        return 0x00;
+
+    if( (halCtrl->trunk_group_mask & (0x01 << grpId) ) != 0)
+        return RT_ERR_OK;
+    else
+        return RT_ERR_LA_TRUNK_ID;
+
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv.c
new file mode 100644
index 0000000000000..7858edcf530af
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv.c
@@ -0,0 +1,639 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature :
+ *
+ */
+
+#include <rtl8367c_asicdrv.h>
+
+#if defined(RTK_X86_ASICDRV)
+#include <I2Clib.h>
+#else
+#include <smi.h>
+#endif
+
+/*for driver verify testing only*/
+#ifdef CONFIG_RTL8367C_ASICDRV_TEST
+#define CLE_VIRTUAL_REG_SIZE        0x10000
+rtk_uint16 CleVirtualReg[CLE_VIRTUAL_REG_SIZE];
+#endif
+
+#if defined(CONFIG_RTL865X_CLE) || defined (RTK_X86_CLE)
+rtk_uint32 cleDebuggingDisplay;
+#endif
+
+#ifdef EMBEDDED_SUPPORT
+extern void setReg(rtk_uint16, rtk_uint16);
+extern rtk_uint16 getReg(rtk_uint16);
+#endif
+
+/* Function Name:
+ *      rtl8367c_setAsicRegBit
+ * Description:
+ *      Set a bit value of a specified register
+ * Input:
+ *      reg     - register's address
+ *      bit     - bit location
+ *      value   - value to set. It can be value 0 or 1.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Invalid input parameter
+ * Note:
+ *      Set a bit of a specified register to 1 or 0.
+ */
+ret_t rtl8367c_setAsicRegBit(rtk_uint32 reg, rtk_uint32 bit, rtk_uint32 value)
+{
+
+#if defined(RTK_X86_ASICDRV)
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    if(bit >= RTL8367C_REGBITLENGTH)
+        return RT_ERR_INPUT;
+
+    retVal = Access_Read(reg, 2, &regData);
+    if(TRUE != retVal)
+        return RT_ERR_SMI;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
+
+    if(value)
+        regData = regData | (1 << bit);
+    else
+        regData = regData & (~(1 << bit));
+
+    retVal = Access_Write(reg,2, regData);
+    if(TRUE != retVal)
+        return RT_ERR_SMI;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("W[0x%4.4x]=0x%4.4x\n", reg, regData);
+
+
+#elif defined(CONFIG_RTL8367C_ASICDRV_TEST)
+
+    if(bit >= RTL8367C_REGBITLENGTH)
+        return RT_ERR_INPUT;
+
+    else if(reg >= CLE_VIRTUAL_REG_SIZE)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(value)
+    {
+        CleVirtualReg[reg] =  CleVirtualReg[reg] | (1 << bit);
+    }
+    else
+    {
+        CleVirtualReg[reg] =  CleVirtualReg[reg] & (~(1 << bit));
+    }
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("W[0x%4.4x]=0x%4.4x\n", reg, CleVirtualReg[reg]);
+
+#elif defined(EMBEDDED_SUPPORT)
+    rtk_uint16 tmp;
+
+    if(reg > RTL8367C_REGDATAMAX || value > 1)
+        return RT_ERR_INPUT;
+
+    tmp = getReg(reg);
+    tmp &= (1 << bitIdx);
+    tmp |= (value << bitIdx);
+    setReg(reg, tmp);
+
+#else
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    if(bit >= RTL8367C_REGBITLENGTH)
+        return RT_ERR_INPUT;
+
+    retVal = smi_read(reg, &regData);
+    if(retVal != RT_ERR_OK)
+        return RT_ERR_SMI;
+
+  #ifdef CONFIG_RTL865X_CLE
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
+  #endif
+    if(value)
+        regData = regData | (1 << bit);
+    else
+        regData = regData & (~(1 << bit));
+
+    retVal = smi_write(reg, regData);
+    if(retVal != RT_ERR_OK)
+        return RT_ERR_SMI;
+
+  #ifdef CONFIG_RTL865X_CLE
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("W[0x%4.4x]=0x%4.4x\n", reg, regData);
+  #endif
+
+#endif
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicRegBit
+ * Description:
+ *      Get a bit value of a specified register
+ * Input:
+ *      reg     - register's address
+ *      bit     - bit location
+ *      value   - value to get.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Invalid input parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRegBit(rtk_uint32 reg, rtk_uint32 bit, rtk_uint32 *pValue)
+{
+
+#if defined(RTK_X86_ASICDRV)
+
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    if(bit >= RTL8367C_REGBITLENGTH)
+        return RT_ERR_INPUT;
+
+    retVal = Access_Read(reg, 2, &regData);
+    if(TRUE != retVal)
+        return RT_ERR_SMI;
+
+    *pValue = (regData & (0x1 << bit)) >> bit;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
+
+#elif defined(CONFIG_RTL8367C_ASICDRV_TEST)
+
+    if(bit >= RTL8367C_REGBITLENGTH)
+        return RT_ERR_INPUT;
+
+    if(reg >= CLE_VIRTUAL_REG_SIZE)
+        return RT_ERR_OUT_OF_RANGE;
+
+    *pValue = (CleVirtualReg[reg] & (0x1 << bit)) >> bit;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, CleVirtualReg[reg]);
+
+#elif defined(EMBEDDED_SUPPORT)
+    rtk_uint16 tmp;
+
+    if(reg > RTL8367C_REGDATAMAX )
+        return RT_ERR_INPUT;
+
+    tmp = getReg(reg);
+    tmp = tmp >> bitIdx;
+    tmp &= 1;
+    *value = tmp;
+#else
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    retVal = smi_read(reg, &regData);
+    if(retVal != RT_ERR_OK)
+        return RT_ERR_SMI;
+
+  #ifdef CONFIG_RTL865X_CLE
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
+  #endif
+
+    *pValue = (regData & (0x1 << bit)) >> bit;
+
+#endif
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicRegBits
+ * Description:
+ *      Set bits value of a specified register
+ * Input:
+ *      reg     - register's address
+ *      bits    - bits mask for setting
+ *      value   - bits value for setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Invalid input parameter
+ * Note:
+ *      Set bits of a specified register to value. Both bits and value are be treated as bit-mask
+ */
+ret_t rtl8367c_setAsicRegBits(rtk_uint32 reg, rtk_uint32 bits, rtk_uint32 value)
+{
+
+#if defined(RTK_X86_ASICDRV)
+
+    rtk_uint32 regData;
+    ret_t retVal;
+    rtk_uint32 bitsShift;
+    rtk_uint32 valueShifted;
+
+    if(bits >= (1 << RTL8367C_REGBITLENGTH) )
+        return RT_ERR_INPUT;
+
+    bitsShift = 0;
+    while(!(bits & (1 << bitsShift)))
+    {
+        bitsShift++;
+        if(bitsShift >= RTL8367C_REGBITLENGTH)
+            return RT_ERR_INPUT;
+    }
+
+    valueShifted = value << bitsShift;
+    if(valueShifted > RTL8367C_REGDATAMAX)
+        return RT_ERR_INPUT;
+
+    retVal = Access_Read(reg, 2, &regData);
+    if(TRUE != retVal)
+        return RT_ERR_SMI;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
+
+    regData = regData & (~bits);
+    regData = regData | (valueShifted & bits);
+
+    retVal = Access_Write(reg,2, regData);
+    if(TRUE != retVal)
+        return RT_ERR_SMI;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("W[0x%4.4x]=0x%4.4x\n", reg, regData);
+
+#elif defined(CONFIG_RTL8367C_ASICDRV_TEST)
+    rtk_uint32 regData;
+    rtk_uint32 bitsShift;
+    rtk_uint32 valueShifted;
+
+    if(bits >= (1 << RTL8367C_REGBITLENGTH) )
+        return RT_ERR_INPUT;
+
+    bitsShift = 0;
+    while(!(bits & (1 << bitsShift)))
+    {
+        bitsShift++;
+        if(bitsShift >= RTL8367C_REGBITLENGTH)
+            return RT_ERR_INPUT;
+    }
+    valueShifted = value << bitsShift;
+
+    if(valueShifted > RTL8367C_REGDATAMAX)
+        return RT_ERR_INPUT;
+
+    if(reg >= CLE_VIRTUAL_REG_SIZE)
+        return RT_ERR_OUT_OF_RANGE;
+
+    regData = CleVirtualReg[reg] & (~bits);
+    regData = regData | (valueShifted & bits);
+
+    CleVirtualReg[reg] = regData;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("W[0x%4.4x]=0x%4.4x\n", reg, regData);
+
+#elif defined(EMBEDDED_SUPPORT)
+    rtk_uint32 regData;
+    rtk_uint32 bitsShift;
+    rtk_uint32 valueShifted;
+
+    if(reg > RTL8367C_REGDATAMAX )
+        return RT_ERR_INPUT;
+
+    if(bits >= (1 << RTL8367C_REGBITLENGTH) )
+        return RT_ERR_INPUT;
+
+    bitsShift = 0;
+    while(!(bits & (1 << bitsShift)))
+    {
+        bitsShift++;
+        if(bitsShift >= RTL8367C_REGBITLENGTH)
+            return RT_ERR_INPUT;
+    }
+
+    valueShifted = value << bitsShift;
+    if(valueShifted > RTL8367C_REGDATAMAX)
+        return RT_ERR_INPUT;
+
+    regData = getReg(reg);
+    regData = regData & (~bits);
+    regData = regData | (valueShifted & bits);
+
+    setReg(reg, regData);
+
+#else
+    rtk_uint32 regData;
+    ret_t retVal;
+    rtk_uint32 bitsShift;
+    rtk_uint32 valueShifted;
+
+    if(bits >= (1 << RTL8367C_REGBITLENGTH) )
+        return RT_ERR_INPUT;
+
+    bitsShift = 0;
+    while(!(bits & (1 << bitsShift)))
+    {
+        bitsShift++;
+        if(bitsShift >= RTL8367C_REGBITLENGTH)
+            return RT_ERR_INPUT;
+    }
+    valueShifted = value << bitsShift;
+
+    if(valueShifted > RTL8367C_REGDATAMAX)
+        return RT_ERR_INPUT;
+
+    retVal = smi_read(reg, &regData);
+    if(retVal != RT_ERR_OK)
+        return RT_ERR_SMI;
+  #ifdef CONFIG_RTL865X_CLE
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
+  #endif
+
+    regData = regData & (~bits);
+    regData = regData | (valueShifted & bits);
+
+    retVal = smi_write(reg, regData);
+    if(retVal != RT_ERR_OK)
+        return RT_ERR_SMI;
+  #ifdef CONFIG_RTL865X_CLE
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("W[0x%4.4x]=0x%4.4x\n", reg, regData);
+  #endif
+#endif
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicRegBits
+ * Description:
+ *      Get bits value of a specified register
+ * Input:
+ *      reg     - register's address
+ *      bits    - bits mask for setting
+ *      value   - bits value for setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Invalid input parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRegBits(rtk_uint32 reg, rtk_uint32 bits, rtk_uint32 *pValue)
+{
+
+#if defined(RTK_X86_ASICDRV)
+
+    rtk_uint32 regData;
+    ret_t retVal;
+    rtk_uint32 bitsShift;
+
+    if(bits >= (1 << RTL8367C_REGBITLENGTH) )
+        return RT_ERR_INPUT;
+
+    bitsShift = 0;
+    while(!(bits & (1 << bitsShift)))
+    {
+        bitsShift++;
+        if(bitsShift >= RTL8367C_REGBITLENGTH)
+            return RT_ERR_INPUT;
+    }
+
+    retVal = Access_Read(reg, 2, &regData);
+    if(TRUE != retVal)
+        return RT_ERR_SMI;
+
+    *pValue = (regData & bits) >> bitsShift;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
+
+#elif defined(CONFIG_RTL8367C_ASICDRV_TEST)
+    rtk_uint32 bitsShift;
+
+    if(bits >= (1 << RTL8367C_REGBITLENGTH) )
+        return RT_ERR_INPUT;
+
+    bitsShift = 0;
+    while(!(bits & (1 << bitsShift)))
+    {
+        bitsShift++;
+        if(bitsShift >= RTL8367C_REGBITLENGTH)
+            return RT_ERR_INPUT;
+    }
+
+    if(reg >= CLE_VIRTUAL_REG_SIZE)
+        return RT_ERR_OUT_OF_RANGE;
+
+     *pValue = (CleVirtualReg[reg] & bits) >> bitsShift;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, CleVirtualReg[reg]);
+
+#elif defined(EMBEDDED_SUPPORT)
+    rtk_uint32 regData;
+    rtk_uint32 bitsShift;
+
+    if(reg > RTL8367C_REGDATAMAX )
+        return RT_ERR_INPUT;
+
+    if(bits >= (1UL << RTL8367C_REGBITLENGTH) )
+        return RT_ERR_INPUT;
+
+    bitsShift = 0;
+    while(!(bits & (1UL << bitsShift)))
+    {
+        bitsShift++;
+        if(bitsShift >= RTL8367C_REGBITLENGTH)
+            return RT_ERR_INPUT;
+    }
+
+    regData = getReg(reg);
+    *value = (regData & bits) >> bitsShift;
+
+#else
+    rtk_uint32 regData;
+    ret_t retVal;
+    rtk_uint32 bitsShift;
+
+    if(bits>= (1<<RTL8367C_REGBITLENGTH) )
+        return RT_ERR_INPUT;
+
+    bitsShift = 0;
+    while(!(bits & (1 << bitsShift)))
+    {
+        bitsShift++;
+        if(bitsShift >= RTL8367C_REGBITLENGTH)
+            return RT_ERR_INPUT;
+    }
+
+    retVal = smi_read(reg, &regData);
+    if(retVal != RT_ERR_OK) return RT_ERR_SMI;
+
+    *pValue = (regData & bits) >> bitsShift;
+  #ifdef CONFIG_RTL865X_CLE
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n",reg, regData);
+  #endif
+
+#endif
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicReg
+ * Description:
+ *      Set content of asic register
+ * Input:
+ *      reg     - register's address
+ *      value   - Value setting to register
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      The value will be set to ASIC mapping address only and it is always return RT_ERR_OK while setting un-mapping address registers
+ */
+ret_t rtl8367c_setAsicReg(rtk_uint32 reg, rtk_uint32 value)
+{
+#if defined(RTK_X86_ASICDRV)/*RTK-CNSD2-NickWu-20061222: for x86 compile*/
+
+    ret_t retVal;
+
+    retVal = Access_Write(reg,2,value);
+    if(TRUE != retVal) return RT_ERR_SMI;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("W[0x%4.4x]=0x%4.4x\n",reg,value);
+
+#elif defined(CONFIG_RTL8367C_ASICDRV_TEST)
+
+    /*MIBs emulating*/
+    if(reg == RTL8367C_REG_MIB_ADDRESS)
+    {
+        CleVirtualReg[RTL8367C_MIB_COUNTER_BASE_REG] = 0x1;
+        CleVirtualReg[RTL8367C_MIB_COUNTER_BASE_REG+1] = 0x2;
+        CleVirtualReg[RTL8367C_MIB_COUNTER_BASE_REG+2] = 0x3;
+        CleVirtualReg[RTL8367C_MIB_COUNTER_BASE_REG+3] = 0x4;
+    }
+
+    if(reg >= CLE_VIRTUAL_REG_SIZE)
+        return RT_ERR_OUT_OF_RANGE;
+
+    CleVirtualReg[reg] = value;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("W[0x%4.4x]=0x%4.4x\n",reg,CleVirtualReg[reg]);
+
+#elif defined(EMBEDDED_SUPPORT)
+    if(reg > RTL8367C_REGDATAMAX || value > RTL8367C_REGDATAMAX )
+        return RT_ERR_INPUT;
+
+    setReg(reg, value);
+
+#else
+    ret_t retVal;
+
+    retVal = smi_write(reg, value);
+    if(retVal != RT_ERR_OK)
+        return RT_ERR_SMI;
+  #ifdef CONFIG_RTL865X_CLE
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("W[0x%4.4x]=0x%4.4x\n",reg,value);
+  #endif
+
+#endif
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicReg
+ * Description:
+ *      Get content of asic register
+ * Input:
+ *      reg     - register's address
+ *      value   - Value setting to register
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      Value 0x0000 will be returned for ASIC un-mapping address
+ */
+ret_t rtl8367c_getAsicReg(rtk_uint32 reg, rtk_uint32 *pValue)
+{
+
+#if defined(RTK_X86_ASICDRV)
+
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    retVal = Access_Read(reg, 2, &regData);
+    if(TRUE != retVal)
+        return RT_ERR_SMI;
+
+    *pValue = regData;
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
+
+#elif defined(CONFIG_RTL8367C_ASICDRV_TEST)
+    if(reg >= CLE_VIRTUAL_REG_SIZE)
+        return RT_ERR_OUT_OF_RANGE;
+
+    *pValue = CleVirtualReg[reg];
+
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, CleVirtualReg[reg]);
+
+#elif defined(EMBEDDED_SUPPORT)
+    if(reg > RTL8367C_REGDATAMAX  )
+        return RT_ERR_INPUT;
+
+    *value = getReg(reg);
+
+#else
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    retVal = smi_read(reg, &regData);
+    if(retVal != RT_ERR_OK)
+        return RT_ERR_SMI;
+
+    *pValue = regData;
+  #ifdef CONFIG_RTL865X_CLE
+    if(0x8367B == cleDebuggingDisplay)
+        PRINT("R[0x%4.4x]=0x%4.4x\n", reg, regData);
+  #endif
+
+#endif
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_acl.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_acl.c
new file mode 100644
index 0000000000000..d9ccd97118c45
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_acl.c
@@ -0,0 +1,1173 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : ACL related function drivers
+ *
+ */
+#include <rtl8367c_asicdrv_acl.h>
+
+#include <string.h>
+
+#if defined(CONFIG_RTL8367C_ASICDRV_TEST)
+rtl8367c_aclrulesmi Rtl8370sVirtualAclRuleTable[RTL8367C_ACLRULENO];
+rtk_uint16 Rtl8370sVirtualAclActTable[RTL8367C_ACLRULENO][RTL8367C_ACL_ACT_TABLE_LEN];
+#endif
+
+/*
+    Exchange structure type define with MMI and SMI
+*/
+static void _rtl8367c_aclRuleStSmi2User( rtl8367c_aclrule *pAclUser, rtl8367c_aclrulesmi *pAclSmi)
+{
+    rtk_uint8 *care_ptr, *data_ptr;
+    rtk_uint8 care_tmp, data_tmp;
+    rtk_uint32 i;
+
+    pAclUser->data_bits.active_portmsk = (((pAclSmi->data_bits_ext.rule_info >> 1) & 0x0007) << 8) | ((pAclSmi->data_bits.rule_info >> 8) & 0x00FF);
+    pAclUser->data_bits.type = (pAclSmi->data_bits.rule_info & 0x0007);
+    pAclUser->data_bits.tag_exist = (pAclSmi->data_bits.rule_info & 0x00F8) >> 3;
+
+    care_ptr = (rtk_uint8*)&pAclSmi->care_bits;
+    data_ptr = (rtk_uint8*)&pAclSmi->data_bits;
+
+    for ( i = 0; i < sizeof(struct acl_rule_smi_st); i++)
+    {
+        care_tmp = *(care_ptr + i) ^ (*(data_ptr + i));
+        data_tmp = *(data_ptr + i);
+
+        *(care_ptr + i) = care_tmp;
+        *(data_ptr + i) = data_tmp;
+    }
+
+    care_ptr = (rtk_uint8*)&pAclSmi->care_bits_ext;
+    data_ptr = (rtk_uint8*)&pAclSmi->data_bits_ext;
+    care_tmp = (*care_ptr) ^ (*data_ptr);
+    data_tmp = (*data_ptr);
+    *care_ptr = care_tmp;
+    *data_ptr = data_tmp;
+
+    for(i = 0; i < RTL8367C_ACLRULEFIELDNO; i++)
+        pAclUser->data_bits.field[i] = pAclSmi->data_bits.field[i];
+
+    pAclUser->valid = pAclSmi->valid;
+
+    pAclUser->care_bits.active_portmsk = (((pAclSmi->care_bits_ext.rule_info >> 1) & 0x0007) << 8) | ((pAclSmi->care_bits.rule_info >> 8) & 0x00FF);
+    pAclUser->care_bits.type = (pAclSmi->care_bits.rule_info & 0x0007);
+    pAclUser->care_bits.tag_exist = (pAclSmi->care_bits.rule_info & 0x00F8) >> 3;
+
+    for(i = 0; i < RTL8367C_ACLRULEFIELDNO; i++)
+        pAclUser->care_bits.field[i] = pAclSmi->care_bits.field[i];
+}
+
+/*
+    Exchange structure type define with MMI and SMI
+*/
+static void _rtl8367c_aclRuleStUser2Smi(rtl8367c_aclrule *pAclUser, rtl8367c_aclrulesmi *pAclSmi)
+{
+    rtk_uint8 *care_ptr, *data_ptr;
+    rtk_uint8 care_tmp, data_tmp;
+    rtk_uint32 i;
+
+    pAclSmi->data_bits_ext.rule_info = ((pAclUser->data_bits.active_portmsk >> 8) & 0x7) << 1;
+    pAclSmi->data_bits.rule_info = ((pAclUser->data_bits.active_portmsk & 0xff) << 8) | ((pAclUser->data_bits.tag_exist & 0x1F) << 3) | (pAclUser->data_bits.type & 0x07);
+
+    for(i = 0;i < RTL8367C_ACLRULEFIELDNO; i++)
+        pAclSmi->data_bits.field[i] = pAclUser->data_bits.field[i];
+
+    pAclSmi->valid = pAclUser->valid;
+
+    pAclSmi->care_bits_ext.rule_info = ((pAclUser->care_bits.active_portmsk >> 8) & 0x7) << 1;
+    pAclSmi->care_bits.rule_info = ((pAclUser->care_bits.active_portmsk & 0xff) << 8) | ((pAclUser->care_bits.tag_exist & 0x1F) << 3) | (pAclUser->care_bits.type & 0x07);
+
+    for(i = 0; i < RTL8367C_ACLRULEFIELDNO; i++)
+        pAclSmi->care_bits.field[i] = pAclUser->care_bits.field[i];
+
+    care_ptr = (rtk_uint8*)&pAclSmi->care_bits;
+    data_ptr = (rtk_uint8*)&pAclSmi->data_bits;
+
+    for ( i = 0; i < sizeof(struct acl_rule_smi_st); i++)
+    {
+        care_tmp = *(care_ptr + i) & ~(*(data_ptr + i));
+        data_tmp = *(care_ptr + i) & *(data_ptr + i);
+
+        *(care_ptr + i) = care_tmp;
+        *(data_ptr + i) = data_tmp;
+    }
+
+    care_ptr = (rtk_uint8*)&pAclSmi->care_bits_ext;
+    data_ptr = (rtk_uint8*)&pAclSmi->data_bits_ext;
+    care_tmp = *care_ptr & ~(*data_ptr);
+    data_tmp = *care_ptr & *data_ptr;
+
+    *care_ptr = care_tmp;
+    *data_ptr = data_tmp;
+}
+
+/*
+    Exchange structure type define with MMI and SMI
+*/
+static void _rtl8367c_aclActStSmi2User(rtl8367c_acl_act_t *pAclUser, rtk_uint16 *pAclSmi)
+{
+    pAclUser->cact = (pAclSmi[0] & 0x00C0) >> 6;
+    pAclUser->cvidx_cact = (pAclSmi[0] & 0x003F) | (((pAclSmi[3] & 0x0008) >> 3) << 6);
+
+    pAclUser->sact = (pAclSmi[0] & 0xC000) >> 14;
+    pAclUser->svidx_sact = ((pAclSmi[0] & 0x3F00) >> 8) | (((pAclSmi[3] & 0x0010) >> 4) << 6);
+
+    pAclUser->aclmeteridx = (pAclSmi[1] & 0x003F) | (((pAclSmi[3] & 0x0020) >> 5) << 6);
+
+    pAclUser->fwdact = (pAclSmi[1] & 0xC000) >> 14;
+    pAclUser->fwdpmask = ((pAclSmi[1] & 0x3FC0) >> 6) | (((pAclSmi[3] & 0x01C0) >> 6) << 8);
+
+    pAclUser->priact = (pAclSmi[2] & 0x00C0) >> 6;
+    pAclUser->pridx = (pAclSmi[2] & 0x003F) | (((pAclSmi[3] & 0x0200) >> 9) << 6);
+
+    pAclUser->aclint = (pAclSmi[2] & 0x2000) >> 13;
+    pAclUser->gpio_en = (pAclSmi[2] & 0x1000) >> 12;
+    pAclUser->gpio_pin = (pAclSmi[2] & 0x0F00) >> 8;
+
+    pAclUser->cact_ext = (pAclSmi[2] & 0xC000) >> 14;
+    pAclUser->tag_fmt = (pAclSmi[3] & 0x0003);
+    pAclUser->fwdact_ext = (pAclSmi[3] & 0x0004) >> 2;
+}
+
+/*
+    Exchange structure type define with MMI and SMI
+*/
+static void _rtl8367c_aclActStUser2Smi(rtl8367c_acl_act_t *pAclUser, rtk_uint16 *pAclSmi)
+{
+    pAclSmi[0] |= (pAclUser->cvidx_cact & 0x003F);
+    pAclSmi[0] |= (pAclUser->cact & 0x0003) << 6;
+    pAclSmi[0] |= (pAclUser->svidx_sact & 0x003F) << 8;
+    pAclSmi[0] |= (pAclUser->sact & 0x0003) << 14;
+
+    pAclSmi[1] |= (pAclUser->aclmeteridx & 0x003F);
+    pAclSmi[1] |= (pAclUser->fwdpmask & 0x00FF) << 6;
+    pAclSmi[1] |= (pAclUser->fwdact & 0x0003) << 14;
+
+    pAclSmi[2] |= (pAclUser->pridx & 0x003F);
+    pAclSmi[2] |= (pAclUser->priact & 0x0003) << 6;
+    pAclSmi[2] |= (pAclUser->gpio_pin & 0x000F) << 8;
+    pAclSmi[2] |= (pAclUser->gpio_en & 0x0001) << 12;
+    pAclSmi[2] |= (pAclUser->aclint & 0x0001) << 13;
+    pAclSmi[2] |= (pAclUser->cact_ext & 0x0003) << 14;
+
+    pAclSmi[3] |= (pAclUser->tag_fmt & 0x0003);
+    pAclSmi[3] |= (pAclUser->fwdact_ext & 0x0001) << 2;
+    pAclSmi[3] |= ((pAclUser->cvidx_cact & 0x0040) >> 6) << 3;
+    pAclSmi[3] |= ((pAclUser->svidx_sact & 0x0040) >> 6) << 4;
+    pAclSmi[3] |= ((pAclUser->aclmeteridx & 0x0040) >> 6) << 5;
+    pAclSmi[3] |= ((pAclUser->fwdpmask & 0x0700) >> 8) << 6;
+    pAclSmi[3] |= ((pAclUser->pridx & 0x0040) >> 6) << 9;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicAcl
+ * Description:
+ *      Set port acl function enable/disable
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicAcl(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_ACL_ENABLE_REG, port, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicAcl
+ * Description:
+ *      Get port acl function enable/disable
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAcl(rtk_uint32 port, rtk_uint32* pEnabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_ACL_ENABLE_REG, port, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicAclUnmatchedPermit
+ * Description:
+ *      Set port acl function unmatched permit action
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicAclUnmatchedPermit(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_ACL_UNMATCH_PERMIT_REG, port, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicAclUnmatchedPermit
+ * Description:
+ *      Get port acl function unmatched permit action
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAclUnmatchedPermit(rtk_uint32 port, rtk_uint32* pEnabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_ACL_UNMATCH_PERMIT_REG, port, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicAclRule
+ * Description:
+ *      Set acl rule content
+ * Input:
+ *      index   - ACL rule index (0-95) of 96 ACL rules
+ *      pAclRule - ACL rule stucture for setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL rule index (0-95)
+ * Note:
+ *      System supported 95 shared 289-bit ACL ingress rule. Index was available at range 0-95 only.
+ *      If software want to modify ACL rule, the ACL function should be disable at first or unspecify
+ *      acl action will be executed.
+ *      One ACL rule structure has three parts setting:
+ *      Bit 0-147       Data Bits of this Rule
+ *      Bit 148     Valid Bit
+ *      Bit 149-296 Care Bits of this Rule
+ *      There are four kinds of field in Data Bits and Care Bits: Active Portmask, Type, Tag Exist, and 8 fields
+ */
+ret_t rtl8367c_setAsicAclRule(rtk_uint32 index, rtl8367c_aclrule* pAclRule)
+{
+    rtl8367c_aclrulesmi aclRuleSmi;
+    rtk_uint16* tableAddr;
+    rtk_uint32 regAddr;
+    rtk_uint32  regData;
+    rtk_uint32 i;
+    ret_t retVal;
+
+    if(index > RTL8367C_ACLRULEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    memset(&aclRuleSmi, 0x00, sizeof(rtl8367c_aclrulesmi));
+
+    _rtl8367c_aclRuleStUser2Smi(pAclRule, &aclRuleSmi);
+
+    /* Write valid bit = 0 */
+    regAddr = RTL8367C_TABLE_ACCESS_ADDR_REG;
+    if(index >= 64)
+        regData = RTL8367C_ACLRULETBADDR2(DATABITS, index);
+    else
+        regData = RTL8367C_ACLRULETBADDR(DATABITS, index);
+    retVal = rtl8367c_setAsicReg(regAddr,regData);
+    if(retVal !=RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_TABLE_ACCESS_WRDATA_REG(RTL8367C_ACLRULETBLEN), 0x1, 0);
+    if(retVal !=RT_ERR_OK)
+        return retVal;
+
+    regAddr = RTL8367C_TABLE_ACCESS_CTRL_REG;
+    regData = RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_WRITE, TB_TARGET_ACLRULE);
+    retVal = rtl8367c_setAsicReg(regAddr, regData);
+    if(retVal !=RT_ERR_OK)
+        return retVal;
+
+
+
+    /* Write ACS_ADR register */
+    regAddr = RTL8367C_TABLE_ACCESS_ADDR_REG;
+    if(index >= 64)
+        regData = RTL8367C_ACLRULETBADDR2(CAREBITS, index);
+    else
+        regData = RTL8367C_ACLRULETBADDR(CAREBITS, index);
+    retVal = rtl8367c_setAsicReg(regAddr, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Write Care Bits to ACS_DATA registers */
+     tableAddr = (rtk_uint16*)&aclRuleSmi.care_bits;
+     regAddr = RTL8367C_TABLE_ACCESS_WRDATA_BASE;
+
+    for(i = 0; i < RTL8367C_ACLRULETBLEN; i++)
+    {
+        regData = *tableAddr;
+        retVal = rtl8367c_setAsicReg(regAddr, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        regAddr++;
+        tableAddr++;
+    }
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_TABLE_ACCESS_WRDATA_REG(RTL8367C_ACLRULETBLEN), (0x0007 << 1), (aclRuleSmi.care_bits_ext.rule_info >> 1) & 0x0007);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Write ACS_CMD register */
+    regAddr = RTL8367C_TABLE_ACCESS_CTRL_REG;
+    regData = RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_WRITE, TB_TARGET_ACLRULE);
+    retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK,regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+
+
+    /* Write ACS_ADR register for data bits */
+    regAddr = RTL8367C_TABLE_ACCESS_ADDR_REG;
+    if(index >= 64)
+        regData = RTL8367C_ACLRULETBADDR2(DATABITS, index);
+    else
+        regData = RTL8367C_ACLRULETBADDR(DATABITS, index);
+
+    retVal = rtl8367c_setAsicReg(regAddr, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Write Data Bits to ACS_DATA registers */
+     tableAddr = (rtk_uint16*)&aclRuleSmi.data_bits;
+     regAddr = RTL8367C_TABLE_ACCESS_WRDATA_BASE;
+
+    for(i = 0; i < RTL8367C_ACLRULETBLEN; i++)
+    {
+        regData = *tableAddr;
+        retVal = rtl8367c_setAsicReg(regAddr, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        regAddr++;
+        tableAddr++;
+    }
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_TABLE_ACCESS_WRDATA_REG(RTL8367C_ACLRULETBLEN), 0, aclRuleSmi.valid);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_TABLE_ACCESS_WRDATA_REG(RTL8367C_ACLRULETBLEN), (0x0007 << 1), (aclRuleSmi.data_bits_ext.rule_info >> 1) & 0x0007);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Write ACS_CMD register for care bits*/
+    regAddr = RTL8367C_TABLE_ACCESS_CTRL_REG;
+    regData = RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_WRITE, TB_TARGET_ACLRULE);
+    retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+#ifdef CONFIG_RTL8367C_ASICDRV_TEST
+    memcpy(&Rtl8370sVirtualAclRuleTable[index], &aclRuleSmi, sizeof(rtl8367c_aclrulesmi));
+#endif
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicAclRule
+ * Description:
+ *      Get acl rule content
+ * Input:
+ *      index   - ACL rule index (0-63) of 64 ACL rules
+ *      pAclRule - ACL rule stucture for setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL rule index (0-63)
+  * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAclRule(rtk_uint32 index, rtl8367c_aclrule *pAclRule)
+{
+    rtl8367c_aclrulesmi aclRuleSmi;
+    rtk_uint32 regAddr, regData;
+    ret_t retVal;
+    rtk_uint16* tableAddr;
+    rtk_uint32 i;
+
+    if(index > RTL8367C_ACLRULEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    memset(&aclRuleSmi, 0x00, sizeof(rtl8367c_aclrulesmi));
+
+    /* Write ACS_ADR register for data bits */
+    regAddr = RTL8367C_TABLE_ACCESS_ADDR_REG;
+    if(index >= 64)
+        regData = RTL8367C_ACLRULETBADDR2(DATABITS, index);
+    else
+        regData = RTL8367C_ACLRULETBADDR(DATABITS, index);
+
+    retVal = rtl8367c_setAsicReg(regAddr, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+
+    /* Write ACS_CMD register */
+    regAddr = RTL8367C_TABLE_ACCESS_CTRL_REG;
+    regData = RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_READ, TB_TARGET_ACLRULE);
+    retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Read Data Bits */
+    regAddr = RTL8367C_TABLE_ACCESS_RDDATA_BASE;
+    tableAddr = (rtk_uint16*)&aclRuleSmi.data_bits;
+    for(i = 0; i < RTL8367C_ACLRULETBLEN; i++)
+    {
+        retVal = rtl8367c_getAsicReg(regAddr, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *tableAddr = regData;
+
+        regAddr ++;
+        tableAddr ++;
+    }
+
+    /* Read Valid Bit */
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_TABLE_ACCESS_RDDATA_REG(RTL8367C_ACLRULETBLEN), 0, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    aclRuleSmi.valid = regData & 0x1;
+    /* Read active_portmsk_ext Bits */
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_TABLE_ACCESS_RDDATA_REG(RTL8367C_ACLRULETBLEN), 0x7<<1, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    aclRuleSmi.data_bits_ext.rule_info = (regData % 0x0007) << 1;
+
+
+    /* Write ACS_ADR register for carebits*/
+    regAddr = RTL8367C_TABLE_ACCESS_ADDR_REG;
+    if(index >= 64)
+        regData = RTL8367C_ACLRULETBADDR2(CAREBITS, index);
+    else
+        regData = RTL8367C_ACLRULETBADDR(CAREBITS, index);
+
+    retVal = rtl8367c_setAsicReg(regAddr, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Write ACS_CMD register */
+    regAddr = RTL8367C_TABLE_ACCESS_CTRL_REG;
+    regData = RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_READ, TB_TARGET_ACLRULE);
+    retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Read Care Bits */
+    regAddr = RTL8367C_TABLE_ACCESS_RDDATA_BASE;
+    tableAddr = (rtk_uint16*)&aclRuleSmi.care_bits;
+    for(i = 0; i < RTL8367C_ACLRULETBLEN; i++)
+    {
+        retVal = rtl8367c_getAsicReg(regAddr, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *tableAddr = regData;
+
+        regAddr ++;
+        tableAddr ++;
+    }
+    /* Read active_portmsk_ext care Bits */
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_TABLE_ACCESS_RDDATA_REG(RTL8367C_ACLRULETBLEN), 0x7<<1, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    aclRuleSmi.care_bits_ext.rule_info = (regData & 0x0007) << 1;
+
+#ifdef CONFIG_RTL8367C_ASICDRV_TEST
+    memcpy(&aclRuleSmi,&Rtl8370sVirtualAclRuleTable[index], sizeof(rtl8367c_aclrulesmi));
+#endif
+
+     _rtl8367c_aclRuleStSmi2User(pAclRule, &aclRuleSmi);
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicAclNot
+ * Description:
+ *      Set rule comparison result inversion / no inversion
+ * Input:
+ *      index   - ACL rule index (0-95) of 96 ACL rules
+ *      not     - 1: inverse, 0: don't inverse
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL rule index (0-95)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicAclNot(rtk_uint32 index, rtk_uint32 not)
+{
+    if(index > RTL8367C_ACLRULEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(index < 64)
+        return rtl8367c_setAsicRegBit(RTL8367C_ACL_ACTION_CTRL_REG(index), RTL8367C_ACL_OP_NOT_OFFSET(index), not);
+    else
+        return rtl8367c_setAsicRegBit(RTL8367C_ACL_ACTION_CTRL2_REG(index), RTL8367C_ACL_OP_NOT_OFFSET(index), not);
+
+}
+/* Function Name:
+ *      rtl8367c_getAsicAcl
+ * Description:
+ *      Get rule comparison result inversion / no inversion
+ * Input:
+ *      index   - ACL rule index (0-95) of 95 ACL rules
+ *      pNot    - 1: inverse, 0: don't inverse
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL rule index (0-95)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAclNot(rtk_uint32 index, rtk_uint32* pNot)
+{
+    if(index > RTL8367C_ACLRULEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(index < 64)
+        return rtl8367c_getAsicRegBit(RTL8367C_ACL_ACTION_CTRL_REG(index), RTL8367C_ACL_OP_NOT_OFFSET(index), pNot);
+    else
+        return rtl8367c_getAsicRegBit(RTL8367C_ACL_ACTION_CTRL2_REG(index), RTL8367C_ACL_OP_NOT_OFFSET(index), pNot);
+
+}
+/* Function Name:
+ *      rtl8367c_setAsicAclTemplate
+ * Description:
+ *      Set fields of a ACL Template
+ * Input:
+ *      index   - ACL template index(0~4)
+ *      pAclType - ACL type stucture for setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL template index(0~4)
+ * Note:
+ *      The API can set type field of the 5 ACL rule templates.
+ *      Each type has 8 fields. One field means what data in one field of a ACL rule means
+ *      8 fields of ACL rule 0~95 is descripted by one type in ACL group
+ */
+ret_t rtl8367c_setAsicAclTemplate(rtk_uint32 index, rtl8367c_acltemplate_t* pAclType)
+{
+    ret_t retVal;
+    rtk_uint32 i;
+    rtk_uint32 regAddr, regData;
+
+    if(index >= RTL8367C_ACLTEMPLATENO)
+        return RT_ERR_OUT_OF_RANGE;
+
+    regAddr = RTL8367C_ACL_RULE_TEMPLATE_CTRL_REG(index);
+
+    for(i = 0; i < (RTL8367C_ACLRULEFIELDNO/2); i++)
+    {
+        regData = pAclType->field[i*2+1];
+        regData = regData << 8 | pAclType->field[i*2];
+
+        retVal = rtl8367c_setAsicReg(regAddr + i, regData);
+
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicAclTemplate
+ * Description:
+ *      Get fields of a ACL Template
+ * Input:
+ *      index   - ACL template index(0~4)
+ *      pAclType - ACL type stucture for setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL template index(0~4)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAclTemplate(rtk_uint32 index, rtl8367c_acltemplate_t *pAclType)
+{
+    ret_t retVal;
+    rtk_uint32 i;
+    rtk_uint32 regData, regAddr;
+
+    if(index >= RTL8367C_ACLTEMPLATENO)
+        return RT_ERR_OUT_OF_RANGE;
+
+    regAddr = RTL8367C_ACL_RULE_TEMPLATE_CTRL_REG(index);
+
+    for(i = 0; i < (RTL8367C_ACLRULEFIELDNO/2); i++)
+    {
+        retVal = rtl8367c_getAsicReg(regAddr + i,&regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        pAclType->field[i*2] = regData & 0xFF;
+        pAclType->field[i*2 + 1] = (regData >> 8) & 0xFF;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicAclAct
+ * Description:
+ *      Set ACL rule matched Action
+ * Input:
+ *      index   - ACL rule index (0-95) of 96 ACL rules
+ *      pAclAct     - ACL action stucture for setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL rule index (0-95)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicAclAct(rtk_uint32 index, rtl8367c_acl_act_t* pAclAct)
+{
+    rtk_uint16 aclActSmi[RTL8367C_ACL_ACT_TABLE_LEN];
+    ret_t retVal;
+    rtk_uint32 regAddr, regData;
+    rtk_uint16* tableAddr;
+    rtk_uint32 i;
+
+    if(index > RTL8367C_ACLRULEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    memset(aclActSmi, 0x00, sizeof(rtk_uint16) * RTL8367C_ACL_ACT_TABLE_LEN);
+     _rtl8367c_aclActStUser2Smi(pAclAct, aclActSmi);
+
+    /* Write ACS_ADR register for data bits */
+    regAddr = RTL8367C_TABLE_ACCESS_ADDR_REG;
+    regData = index;
+    retVal = rtl8367c_setAsicReg(regAddr, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Write Data Bits to ACS_DATA registers */
+     tableAddr = aclActSmi;
+     regAddr = RTL8367C_TABLE_ACCESS_WRDATA_BASE;
+
+    for(i = 0; i < RTL8367C_ACLACTTBLEN; i++)
+    {
+        regData = *tableAddr;
+        retVal = rtl8367c_setAsicReg(regAddr, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        regAddr++;
+        tableAddr++;
+    }
+
+    /* Write ACS_CMD register for care bits*/
+    regAddr = RTL8367C_TABLE_ACCESS_CTRL_REG;
+    regData = RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_WRITE, TB_TARGET_ACLACT);
+    retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+#ifdef CONFIG_RTL8367C_ASICDRV_TEST
+    memcpy(&Rtl8370sVirtualAclActTable[index][0], aclActSmi, sizeof(rtk_uint16) * RTL8367C_ACL_ACT_TABLE_LEN);
+#endif
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicAclAct
+ * Description:
+ *      Get ACL rule matched Action
+ * Input:
+ *      index   - ACL rule index (0-95) of 96 ACL rules
+ *      pAclAct     - ACL action stucture for setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL rule index (0-95)
+  * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAclAct(rtk_uint32 index, rtl8367c_acl_act_t *pAclAct)
+{
+    rtk_uint16 aclActSmi[RTL8367C_ACL_ACT_TABLE_LEN];
+    ret_t retVal;
+    rtk_uint32 regAddr, regData;
+    rtk_uint16 *tableAddr;
+    rtk_uint32 i;
+
+    if(index > RTL8367C_ACLRULEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    memset(aclActSmi, 0x00, sizeof(rtk_uint16) * RTL8367C_ACL_ACT_TABLE_LEN);
+
+    /* Write ACS_ADR register for data bits */
+    regAddr = RTL8367C_TABLE_ACCESS_ADDR_REG;
+    regData = index;
+    retVal = rtl8367c_setAsicReg(regAddr, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Write ACS_CMD register */
+    regAddr = RTL8367C_TABLE_ACCESS_CTRL_REG;
+    regData = RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_READ, TB_TARGET_ACLACT);
+    retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Read Data Bits */
+    regAddr = RTL8367C_TABLE_ACCESS_RDDATA_BASE;
+    tableAddr = aclActSmi;
+    for(i = 0; i < RTL8367C_ACLACTTBLEN; i++)
+    {
+        retVal = rtl8367c_getAsicReg(regAddr, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *tableAddr = regData;
+
+        regAddr ++;
+        tableAddr ++;
+    }
+
+#ifdef CONFIG_RTL8367C_ASICDRV_TEST
+    memcpy(aclActSmi, &Rtl8370sVirtualAclActTable[index][0], sizeof(rtk_uint16) * RTL8367C_ACL_ACT_TABLE_LEN);
+#endif
+
+     _rtl8367c_aclActStSmi2User(pAclAct, aclActSmi);
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicAclActCtrl
+ * Description:
+ *      Set ACL rule matched Action Control Bits
+ * Input:
+ *      index       - ACL rule index (0-95) of 96 ACL rules
+ *      aclActCtrl  - 6 ACL Control Bits
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL rule index (0-95)
+ * Note:
+ *      ACL Action Control Bits Indicate which actions will be take when a rule matches
+ */
+ret_t rtl8367c_setAsicAclActCtrl(rtk_uint32 index, rtk_uint32 aclActCtrl)
+{
+    ret_t retVal;
+
+    if(index > RTL8367C_ACLRULEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(index >= 64)
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_ACL_ACTION_CTRL2_REG(index), RTL8367C_ACL_OP_ACTION_MASK(index), aclActCtrl);
+    else
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_ACL_ACTION_CTRL_REG(index), RTL8367C_ACL_OP_ACTION_MASK(index), aclActCtrl);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicAclActCtrl
+ * Description:
+ *      Get ACL rule matched Action Control Bits
+ * Input:
+ *      index       - ACL rule index (0-95) of 96 ACL rules
+ *      pAclActCtrl     - 6 ACL Control Bits
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL rule index (0-95)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAclActCtrl(rtk_uint32 index, rtk_uint32 *pAclActCtrl)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    if(index > RTL8367C_ACLRULEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(index >= 64)
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_ACL_ACTION_CTRL2_REG(index), RTL8367C_ACL_OP_ACTION_MASK(index), &regData);
+    else
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_ACL_ACTION_CTRL_REG(index), RTL8367C_ACL_OP_ACTION_MASK(index), &regData);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pAclActCtrl = regData;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicAclPortRange
+ * Description:
+ *      Set ACL TCP/UDP range check
+ * Input:
+ *      index       - TCP/UDP port range check table index
+ *      type        - Range check type
+ *      upperPort   - TCP/UDP port range upper bound
+ *      lowerPort   - TCP/UDP port range lower bound
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid TCP/UDP port range check table index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicAclPortRange(rtk_uint32 index, rtk_uint32 type, rtk_uint32 upperPort, rtk_uint32 lowerPort)
+{
+    ret_t retVal;
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL2 + index*3, RTL8367C_ACL_SDPORT_RANGE_ENTRY0_CTRL2_MASK, type);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL1 + index*3, upperPort);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL0 + index*3, lowerPort);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicAclPortRange
+ * Description:
+ *      Get ACL TCP/UDP range check
+ * Input:
+ *      index       - TCP/UDP port range check table index
+ *      pType       - Range check type
+ *      pUpperPort  - TCP/UDP port range upper bound
+ *      pLowerPort  - TCP/UDP port range lower bound
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid TCP/UDP port range check table index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAclPortRange(rtk_uint32 index, rtk_uint32* pType, rtk_uint32* pUpperPort, rtk_uint32* pLowerPort)
+{
+    ret_t retVal;
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL2 + index*3, RTL8367C_ACL_SDPORT_RANGE_ENTRY0_CTRL2_MASK, pType);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL1 + index*3, pUpperPort);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_SDPORT_RANGE_ENTRY0_CTRL0 + index*3, pLowerPort);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicAclVidRange
+ * Description:
+ *      Set ACL VID range check
+ * Input:
+ *      index       - ACL VID range check index(0~15)
+ *      type        - Range check type
+ *      upperVid    - VID range upper bound
+ *      lowerVid    - VID range lower bound
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL  VID range check index(0~15)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicAclVidRange(rtk_uint32 index, rtk_uint32 type, rtk_uint32 upperVid, rtk_uint32 lowerVid)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    regData = ((type << RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_TYPE_OFFSET) & RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_TYPE_MASK) |
+                (upperVid & RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_HIGH_MASK);
+
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_VID_RANGE_ENTRY0_CTRL1 + index*2, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_VID_RANGE_ENTRY0_CTRL0 + index*2, lowerVid);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicAclVidRange
+ * Description:
+ *      Get ACL VID range check
+ * Input:
+ *      index       - ACL VID range check index(0~15)
+ *      pType       - Range check type
+ *      pUpperVid   - VID range upper bound
+ *      pLowerVid   - VID range lower bound
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL VID range check index(0~15)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAclVidRange(rtk_uint32 index, rtk_uint32* pType, rtk_uint32* pUpperVid, rtk_uint32* pLowerVid)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_VID_RANGE_ENTRY0_CTRL1 + index*2, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pType = (regData & RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_TYPE_MASK) >> RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_TYPE_OFFSET;
+    *pUpperVid = regData & RTL8367C_ACL_VID_RANGE_ENTRY0_CTRL1_CHECK0_HIGH_MASK;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_VID_RANGE_ENTRY0_CTRL0 + index*2, pLowerVid);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicAclIpRange
+ * Description:
+ *      Set ACL IP range check
+ * Input:
+ *      index       - ACL IP range check index(0~15)
+ *      type        - Range check type
+ *      upperIp     - IP range upper bound
+ *      lowerIp     - IP range lower bound
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL IP range check index(0~15)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicAclIpRange(rtk_uint32 index, rtk_uint32 type, ipaddr_t upperIp, ipaddr_t lowerIp)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    ipaddr_t ipData;
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL4 + index*5, RTL8367C_ACL_IP_RANGE_ENTRY0_CTRL4_MASK, type);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    ipData = upperIp;
+
+    regData = ipData & 0xFFFF;
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL2 + index*5, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regData = (ipData>>16) & 0xFFFF;
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL3 + index*5, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    ipData = lowerIp;
+
+    regData = ipData & 0xFFFF;
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL0 + index*5, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regData = (ipData>>16) & 0xFFFF;
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL1 + index*5, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicAclIpRange
+ * Description:
+ *      Get ACL IP range check
+ * Input:
+ *      index       - ACL IP range check index(0~15)
+ *      pType       - Range check type
+ *      pUpperIp    - IP range upper bound
+ *      pLowerIp    - IP range lower bound
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Invalid ACL IP range check index(0~15)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAclIpRange(rtk_uint32 index, rtk_uint32* pType, ipaddr_t* pUpperIp, ipaddr_t* pLowerIp)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    ipaddr_t ipData;
+
+    if(index > RTL8367C_ACLRANGEMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL4 + index*5, RTL8367C_ACL_IP_RANGE_ENTRY0_CTRL4_MASK, pType);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL2 + index*5, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    ipData = regData;
+
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL3 + index*5, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    ipData = (regData <<16) | ipData;
+    *pUpperIp = ipData;
+
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL0 + index*5, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    ipData = regData;
+
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_ACL_IP_RANGE_ENTRY0_CTRL1 + index*5, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    ipData = (regData << 16) | ipData;
+    *pLowerIp = ipData;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicAclGpioPolarity
+ * Description:
+ *      Set ACL Goip control palarity
+ * Input:
+ *      polarity - 1: High, 0: Low
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      none
+ */
+ret_t rtl8367c_setAsicAclGpioPolarity(rtk_uint32 polarity)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_ACL_GPIO_POLARITY, RTL8367C_ACL_GPIO_POLARITY_OFFSET, polarity);
+}
+/* Function Name:
+ *      rtl8367c_getAsicAclGpioPolarity
+ * Description:
+ *      Get ACL Goip control palarity
+ * Input:
+ *      pPolarity - 1: High, 0: Low
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      none
+ */
+ret_t rtl8367c_getAsicAclGpioPolarity(rtk_uint32* pPolarity)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_ACL_GPIO_POLARITY, RTL8367C_ACL_GPIO_POLARITY_OFFSET, pPolarity);
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_cputag.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_cputag.c
new file mode 100644
index 0000000000000..d22bf65eaa10a
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_cputag.c
@@ -0,0 +1,369 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Proprietary CPU-tag related function drivers
+ *
+ */
+#include <rtl8367c_asicdrv_cputag.h>
+/* Function Name:
+ *      rtl8367c_setAsicCputagEnable
+ * Description:
+ *      Set cpu tag function enable/disable
+ * Input:
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_ENABLE   - Invalid enable/disable input
+ * Note:
+ *      If CPU tag function is disabled, CPU tag will not be added to frame
+ *      forwarded to CPU port, and all ports cannot parse CPU tag.
+ */
+ret_t rtl8367c_setAsicCputagEnable(rtk_uint32 enabled)
+{
+    if(enabled > 1)
+        return RT_ERR_ENABLE;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_EN_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicCputagEnable
+ * Description:
+ *      Get cpu tag function enable/disable
+ * Input:
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicCputagEnable(rtk_uint32 *pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_EN_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicCputagTrapPort
+ * Description:
+ *      Set cpu tag trap port
+ * Input:
+ *      port - port number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *     API can set destination port of trapping frame
+ */
+ret_t rtl8367c_setAsicCputagTrapPort(rtk_uint32 port)
+{
+    ret_t retVal;
+
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TRAP_PORT_MASK, port & 7);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TRAP_PORT_EXT_MASK, (port>>3) & 1);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicCputagTrapPort
+ * Description:
+ *      Get cpu tag trap port
+ * Input:
+ *      pPort - port number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *     None
+ */
+ret_t rtl8367c_getAsicCputagTrapPort(rtk_uint32 *pPort)
+{
+    ret_t retVal;
+    rtk_uint32 tmpPort;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TRAP_PORT_MASK, &tmpPort);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    *pPort = tmpPort;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TRAP_PORT_EXT_MASK, &tmpPort);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    *pPort |= (tmpPort & 1) << 3;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicCputagPortmask
+ * Description:
+ *      Set ports that can parse CPU tag
+ * Input:
+ *      portmask - port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask
+ * Note:
+ *     None
+ */
+ret_t rtl8367c_setAsicCputagPortmask(rtk_uint32 portmask)
+{
+    if(portmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    return rtl8367c_setAsicReg(RTL8367C_CPU_PORT_MASK_REG, portmask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicCputagPortmask
+ * Description:
+ *      Get ports that can parse CPU tag
+ * Input:
+ *      pPortmask - port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *     None
+ */
+ret_t rtl8367c_getAsicCputagPortmask(rtk_uint32 *pPortmask)
+{
+    return rtl8367c_getAsicReg(RTL8367C_CPU_PORT_MASK_REG, pPortmask);
+}
+/* Function Name:
+ *      rtl8367c_setAsicCputagInsertMode
+ * Description:
+ *      Set CPU-tag insert mode
+ * Input:
+ *      mode - 0: insert to all packets; 1: insert to trapped packets; 2: don't insert
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NOT_ALLOWED  - Actions not allowed by the function
+ * Note:
+ *     None
+ */
+ret_t rtl8367c_setAsicCputagInsertMode(rtk_uint32 mode)
+{
+    if(mode >= CPUTAG_INSERT_END)
+        return RT_ERR_NOT_ALLOWED;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_INSERTMODE_MASK, mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicCputagInsertMode
+ * Description:
+ *      Get CPU-tag insert mode
+ * Input:
+ *      pMode - 0: insert to all packets; 1: insert to trapped packets; 2: don't insert
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *     None
+ */
+ret_t rtl8367c_getAsicCputagInsertMode(rtk_uint32 *pMode)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_INSERTMODE_MASK, pMode);
+}
+/* Function Name:
+ *      rtl8367c_setAsicCputagPriorityRemapping
+ * Description:
+ *      Set queue assignment of CPU port
+ * Input:
+ *      srcPri - internal priority (0~7)
+ *      newPri - internal priority after remapping (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY     - Invalid priority
+ * Note:
+ *     None
+ */
+ret_t rtl8367c_setAsicCputagPriorityRemapping(rtk_uint32 srcPri, rtk_uint32 newPri)
+{
+    if((srcPri > RTL8367C_PRIMAX) || (newPri > RTL8367C_PRIMAX))
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_REG(srcPri), RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_MASK(srcPri), newPri);
+}
+/* Function Name:
+ *      rtl8367c_getAsicCputagPriorityRemapping
+ * Description:
+ *      Get queue assignment of CPU port
+ * Input:
+ *      srcPri - internal priority (0~7)
+ *      pNewPri - internal priority after remapping (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY     - Invalid priority
+ * Note:
+ *     None
+ */
+ret_t rtl8367c_getAsicCputagPriorityRemapping(rtk_uint32 srcPri, rtk_uint32 *pNewPri)
+{
+    if(srcPri > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_REG(srcPri), RTL8367C_QOS_PRIPORITY_REMAPPING_IN_CPU_MASK(srcPri), pNewPri);
+}
+/* Function Name:
+ *      rtl8367c_setAsicCputagPosition
+ * Description:
+ *      Set cpu tag insert position
+ * Input:
+ *      postion - 1: After entire packet(before CRC field), 0: After MAC_SA (Default)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ * Note:
+ *     None
+ */
+ret_t rtl8367c_setAsicCputagPosition(rtk_uint32 postion)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_POSITION_OFFSET, postion);
+}
+/* Function Name:
+ *      rtl8367c_getAsicCputagPosition
+ * Description:
+ *      Get cpu tag insert position
+ * Input:
+ *      pPostion - 1: After entire packet(before CRC field), 0: After MAC_SA (Default)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ * Note:
+ *     None
+ */
+ret_t rtl8367c_getAsicCputagPosition(rtk_uint32* pPostion)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_POSITION_OFFSET, pPostion);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicCputagMode
+ * Description:
+ *      Set cpu tag mode
+ * Input:
+ *      mode - 1: 4bytes mode, 0: 8bytes mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Invalid input parameters
+ * Note:
+ *      If CPU tag function is disabled, CPU tag will not be added to frame
+ *      forwarded to CPU port, and all ports cannot parse CPU tag.
+ */
+ret_t rtl8367c_setAsicCputagMode(rtk_uint32 mode)
+{
+    if(mode > 1)
+        return RT_ERR_INPUT;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_FORMAT_OFFSET, mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicCputagMode
+ * Description:
+ *      Get cpu tag mode
+ * Input:
+ *      pMode - 1: 4bytes mode, 0: 8bytes mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicCputagMode(rtk_uint32 *pMode)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_FORMAT_OFFSET, pMode);
+}
+/* Function Name:
+ *      rtl8367c_setAsicCputagRxMinLength
+ * Description:
+ *      Set cpu tag mode
+ * Input:
+ *      mode - 1: 64bytes, 0: 72bytes
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Invalid input parameters
+ * Note:
+ *      If CPU tag function is disabled, CPU tag will not be added to frame
+ *      forwarded to CPU port, and all ports cannot parse CPU tag.
+ */
+ret_t rtl8367c_setAsicCputagRxMinLength(rtk_uint32 mode)
+{
+    if(mode > 1)
+        return RT_ERR_INPUT;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_RXBYTECOUNT_OFFSET, mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicCputagRxMinLength
+ * Description:
+ *      Get cpu tag mode
+ * Input:
+ *      pMode - 1: 64bytes, 0: 72bytes
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicCputagRxMinLength(rtk_uint32 *pMode)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_CPU_CTRL, RTL8367C_CPU_TAG_RXBYTECOUNT_OFFSET, pMode);
+}
+
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_dot1x.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_dot1x.c
new file mode 100644
index 0000000000000..73153e177ee9b
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_dot1x.c
@@ -0,0 +1,415 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : 802.1X related functions
+ *
+ */
+#include <rtl8367c_asicdrv_dot1x.h>
+/* Function Name:
+ *      rtl8367c_setAsic1xPBEnConfig
+ * Description:
+ *      Set 802.1x port-based port enable configuration
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsic1xPBEnConfig(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_PORT_ENABLE_REG, port, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsic1xPBEnConfig
+ * Description:
+ *      Get 802.1x port-based port enable configuration
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsic1xPBEnConfig(rtk_uint32 port, rtk_uint32 *pEnabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_PORT_ENABLE_REG, port, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsic1xPBAuthConfig
+ * Description:
+ *      Set 802.1x port-based authorised port configuration
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      auth    - 1: authorised, 0: non-authorised
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsic1xPBAuthConfig(rtk_uint32 port, rtk_uint32 auth)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_PORT_AUTH_REG, port, auth);
+}
+/* Function Name:
+ *      rtl8367c_getAsic1xPBAuthConfig
+ * Description:
+ *      Get 802.1x port-based authorised port configuration
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pAuth   - 1: authorised, 0: non-authorised
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsic1xPBAuthConfig(rtk_uint32 port, rtk_uint32 *pAuth)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_PORT_AUTH_REG, port, pAuth);
+}
+/* Function Name:
+ *      rtl8367c_setAsic1xPBOpdirConfig
+ * Description:
+ *      Set 802.1x port-based operational direction
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      opdir   - Operation direction 1: IN, 0:BOTH
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsic1xPBOpdirConfig(rtk_uint32 port, rtk_uint32 opdir)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_PORT_OPDIR_REG, port, opdir);
+}
+/* Function Name:
+ *      rtl8367c_getAsic1xPBOpdirConfig
+ * Description:
+ *      Get 802.1x port-based operational direction
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pOpdir  - Operation direction 1: IN, 0:BOTH
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsic1xPBOpdirConfig(rtk_uint32 port, rtk_uint32* pOpdir)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_PORT_OPDIR_REG, port, pOpdir);
+}
+/* Function Name:
+ *      rtl8367c_setAsic1xMBEnConfig
+ * Description:
+ *      Set 802.1x mac-based port enable configuration
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsic1xMBEnConfig(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_MAC_ENABLE_REG, port, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsic1xMBEnConfig
+ * Description:
+ *      Get 802.1x mac-based port enable configuration
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsic1xMBEnConfig(rtk_uint32 port, rtk_uint32 *pEnabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_MAC_ENABLE_REG, port, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsic1xMBOpdirConfig
+ * Description:
+ *      Set 802.1x mac-based operational direction
+ * Input:
+ *      opdir       - Operation direction 1: IN, 0:BOTH
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsic1xMBOpdirConfig(rtk_uint32 opdir)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_MAC_OPDIR_OFFSET, opdir);
+}
+/* Function Name:
+ *      rtl8367c_getAsic1xMBOpdirConfig
+ * Description:
+ *      Get 802.1x mac-based operational direction
+ * Input:
+ *      pOpdir      - Operation direction 1: IN, 0:BOTH
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsic1xMBOpdirConfig(rtk_uint32 *pOpdir)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_MAC_OPDIR_OFFSET, pOpdir);
+}
+/* Function Name:
+ *      rtl8367c_setAsic1xProcConfig
+ * Description:
+ *      Set 802.1x unauth. behavior configuration
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      proc    - 802.1x unauth. behavior configuration 0:drop 1:trap to CPU 2:Guest VLAN
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_DOT1X_PROC   - Unauthorized behavior error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsic1xProcConfig(rtk_uint32 port, rtk_uint32 proc)
+{
+
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(proc >= DOT1X_UNAUTH_END)
+        return RT_ERR_DOT1X_PROC;
+
+    if(port < 8)
+    {
+        return rtl8367c_setAsicRegBits(RTL8367C_DOT1X_UNAUTH_ACT_BASE, RTL8367C_DOT1X_UNAUTH_ACT_MASK(port),proc);
+    }
+    else
+    {
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_DOT1X_UNAUTH_ACT_W1, RTL8367C_DOT1X_UNAUTH_ACT_MASK(port),proc);
+    }
+}
+/* Function Name:
+ *      rtl8367c_getAsic1xProcConfig
+ * Description:
+ *      Get 802.1x unauth. behavior configuration
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pProc   - 802.1x unauth. behavior configuration 0:drop 1:trap to CPU 2:Guest VLAN
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsic1xProcConfig(rtk_uint32 port, rtk_uint32* pProc)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+    return rtl8367c_getAsicRegBits(RTL8367C_DOT1X_UNAUTH_ACT_BASE, RTL8367C_DOT1X_UNAUTH_ACT_MASK(port),pProc);
+    else
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_DOT1X_UNAUTH_ACT_W1, RTL8367C_DOT1X_UNAUTH_ACT_MASK(port),pProc);
+}
+/* Function Name:
+ *      rtl8367c_setAsic1xGuestVidx
+ * Description:
+ *      Set 802.1x guest vlan index
+ * Input:
+ *      index   - 802.1x guest vlan index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_DOT1X_GVLANIDX   - Invalid cvid index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsic1xGuestVidx(rtk_uint32 index)
+{
+    if(index >= RTL8367C_CVIDXNO)
+        return RT_ERR_DOT1X_GVLANIDX;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_GVIDX_MASK, index);
+}
+/* Function Name:
+ *      rtl8367c_getAsic1xGuestVidx
+ * Description:
+ *      Get 802.1x guest vlan index
+ * Input:
+ *      pIndex  - 802.1x guest vlan index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsic1xGuestVidx(rtk_uint32 *pIndex)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_GVIDX_MASK, pIndex);
+}
+/* Function Name:
+ *      rtl8367c_setAsic1xGVOpdir
+ * Description:
+ *      Set 802.1x guest vlan talk to auth. DA
+ * Input:
+ *      enabled     - 0:disable 1:enable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsic1xGVOpdir(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_GVOPDIR_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsic1xGVOpdir
+ * Description:
+ *      Get 802.1x guest vlan talk to auth. DA
+ * Input:
+ *      pEnabled        - 0:disable 1:enable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsic1xGVOpdir(rtk_uint32 *pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_DOT1X_CFG_REG, RTL8367C_DOT1X_GVOPDIR_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsic1xTrapPriority
+ * Description:
+ *      Set 802.1x Trap priority
+ * Input:
+ *      priority    - priority (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsic1xTrapPriority(rtk_uint32 priority)
+{
+    if(priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_DOT1X_PRIORTY_MASK,priority);
+}
+/* Function Name:
+ *      rtl8367c_getAsic1xTrapPriority
+ * Description:
+ *      Get 802.1x Trap priority
+ * Input:
+ *      pPriority   - priority (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsic1xTrapPriority(rtk_uint32 *pPriority)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_DOT1X_PRIORTY_MASK, pPriority);
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_eav.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_eav.c
new file mode 100644
index 0000000000000..370b7c6f3a8b0
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_eav.c
@@ -0,0 +1,877 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Ethernet AV related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_eav.h>
+/* Function Name:
+ *      rtl8367c_setAsicEavMacAddress
+ * Description:
+ *      Set PTP MAC address
+ * Input:
+ *      mac     - PTP mac
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicEavMacAddress(ether_addr_t mac)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint8 *accessPtr;
+    rtk_uint32 i;
+
+    accessPtr =  (rtk_uint8*)&mac;
+
+    regData = *accessPtr;
+    accessPtr ++;
+    regData = (regData << 8) | *accessPtr;
+    accessPtr ++;
+    for(i = 0; i <=2; i++)
+    {
+        retVal = rtl8367c_setAsicReg(RTL8367C_REG_MAC_ADDR_H - i, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        regData = *accessPtr;
+        accessPtr ++;
+        regData = (regData << 8) | *accessPtr;
+        accessPtr ++;
+    }
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicEavMacAddress
+ * Description:
+ *      Get PTP MAC address
+ * Input:
+ *      None
+ * Output:
+ *      pMac     - PTP  mac
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEavMacAddress(ether_addr_t *pMac)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint8 *accessPtr;
+    rtk_uint32 i;
+
+    accessPtr = (rtk_uint8*)pMac;
+
+    for(i = 0; i <= 2; i++)
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_REG_MAC_ADDR_H - i, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *accessPtr = (regData & 0xFF00) >> 8;
+        accessPtr ++;
+        *accessPtr = regData & 0xFF;
+        accessPtr ++;
+    }
+
+    return retVal;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicEavTpid
+ * Description:
+ *      Set PTP parser tag TPID.
+ * Input:
+ *       outerTag - outter tag TPID
+ *       innerTag  - inner tag TPID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *     None
+ */
+ret_t rtl8367c_setAsicEavTpid(rtk_uint32 outerTag, rtk_uint32 innerTag)
+{
+    ret_t retVal;
+
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_OTAG_TPID, outerTag)) != RT_ERR_OK)
+        return retVal;
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_ITAG_TPID, innerTag)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicEavTpid
+ * Description:
+ *      Get PTP parser tag TPID.
+ * Input:
+ *      None
+ * Output:
+ *       pOuterTag - outter tag TPID
+ *       pInnerTag  - inner tag TPID
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEavTpid(rtk_uint32* pOuterTag, rtk_uint32* pInnerTag)
+{
+    ret_t retVal;
+
+    if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_OTAG_TPID, pOuterTag)) != RT_ERR_OK)
+        return retVal;
+    if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_ITAG_TPID, pInnerTag)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicEavSysTime
+ * Description:
+ *      Set PTP system time
+ * Input:
+ *      second - seconds
+ *      nanoSecond - nano seconds
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      The time granuality is 8 nano seconds.
+ */
+ret_t rtl8367c_setAsicEavSysTime(rtk_uint32 second, rtk_uint32 nanoSecond)
+{
+    ret_t retVal;
+    rtk_uint32 sec_h, sec_l, nsec8_h, nsec8_l;
+    rtk_uint32 nano_second_8;
+    rtk_uint32 regData, busyFlag, count;
+
+    if(nanoSecond > RTL8367C_EAV_NANOSECONDMAX)
+        return RT_ERR_INPUT;
+
+    regData = 0;
+    sec_h = second >>16;
+    sec_l = second & 0xFFFF;
+    nano_second_8 = nanoSecond >> 3;
+    nsec8_h = (nano_second_8 >>16) & RTL8367C_PTP_TIME_NSEC_H_NSEC_MASK;
+    nsec8_l = nano_second_8 &0xFFFF;
+
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_SEC_H_SEC, sec_h)) != RT_ERR_OK)
+        return retVal;
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_SEC_L_SEC, sec_l)) != RT_ERR_OK)
+        return retVal;
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_NSEC_L_NSEC, nsec8_l)) != RT_ERR_OK)
+        return retVal;
+
+    regData = nsec8_h | (PTP_TIME_WRITE<<RTL8367C_PTP_TIME_NSEC_H_CMD_OFFSET) | RTL8367C_PTP_TIME_NSEC_H_EXEC_MASK;
+
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, regData)) != RT_ERR_OK)
+        return retVal;
+
+    count = 0;
+    do {
+        if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, RTL8367C_PTP_TIME_NSEC_H_EXEC_OFFSET, &busyFlag)) != RT_ERR_OK)
+            return retVal;
+        count++;
+    } while ((busyFlag != 0)&&(count<5));
+
+    if (busyFlag != 0)
+        return RT_ERR_BUSYWAIT_TIMEOUT;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicEavSysTime
+ * Description:
+ *      Get PTP system time
+ * Input:
+ *      None
+ * Output:
+ *      second - seconds
+ *      nanoSecond - nano seconds
+ * Return:
+ *      RT_ERR_OK     - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      The time granuality is 8 nano seconds.
+ */
+ret_t rtl8367c_getAsicEavSysTime(rtk_uint32* pSecond, rtk_uint32* pNanoSecond)
+{
+    ret_t retVal;
+    rtk_uint32 sec_h, sec_l, nsec8_h, nsec8_l;
+    rtk_uint32 nano_second_8;
+    rtk_uint32 regData, busyFlag, count;
+
+    regData = 0;
+    regData = (PTP_TIME_READ<<RTL8367C_PTP_TIME_NSEC_H_CMD_OFFSET) | RTL8367C_PTP_TIME_NSEC_H_EXEC_MASK;
+
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, regData)) != RT_ERR_OK)
+        return retVal;
+
+    count = 0;
+    do {
+        if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, RTL8367C_PTP_TIME_NSEC_H_EXEC_OFFSET, &busyFlag)) != RT_ERR_OK)
+            return retVal;
+        count++;
+    } while ((busyFlag != 0)&&(count<5));
+
+    if (busyFlag != 0)
+        return RT_ERR_BUSYWAIT_TIMEOUT;
+
+    if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_PTP_TIME_SEC_H_SEC_RD, &sec_h)) != RT_ERR_OK)
+        return retVal;
+    if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_PTP_TIME_SEC_L_SEC_RD, &sec_l)) != RT_ERR_OK)
+        return retVal;
+    if((retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC_RD, RTL8367C_PTP_TIME_NSEC_H_NSEC_RD_MASK,&nsec8_h)) != RT_ERR_OK)
+        return retVal;
+    if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_PTP_TIME_NSEC_L_NSEC_RD, &nsec8_l)) != RT_ERR_OK)
+        return retVal;
+
+    *pSecond = (sec_h<<16) | sec_l;
+    nano_second_8 = (nsec8_h<<16) | nsec8_l;
+    *pNanoSecond = nano_second_8<<3;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicEavSysTimeAdjust
+ * Description:
+ *      Set PTP system time adjust
+ * Input:
+ *      type - incresae or decrease
+ *      second - seconds
+ *      nanoSecond - nano seconds
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      Ethernet AV second offset of timer for tuning
+ */
+ret_t rtl8367c_setAsicEavSysTimeAdjust(rtk_uint32 type, rtk_uint32 second, rtk_uint32 nanoSecond)
+{
+    ret_t retVal;
+    rtk_uint32 sec_h, sec_l, nsec8_h, nsec8_l;
+    rtk_uint32 nano_second_8;
+    rtk_uint32 regData, busyFlag, count;
+
+    if (type >= PTP_TIME_ADJ_END)
+        return RT_ERR_INPUT;
+    if(nanoSecond > RTL8367C_EAV_NANOSECONDMAX)
+        return RT_ERR_INPUT;
+
+    regData = 0;
+    sec_h = second >>16;
+    sec_l = second & 0xFFFF;
+    nano_second_8 = nanoSecond >> 3;
+    nsec8_h = (nano_second_8 >>16) & RTL8367C_PTP_TIME_NSEC_H_NSEC_MASK;
+    nsec8_l = nano_second_8 &0xFFFF;
+
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_SEC_H_SEC, sec_h)) != RT_ERR_OK)
+        return retVal;
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_SEC_L_SEC, sec_l)) != RT_ERR_OK)
+        return retVal;
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_NSEC_L_NSEC, nsec8_l)) != RT_ERR_OK)
+        return retVal;
+
+    if (PTP_TIME_ADJ_INC == type)
+        regData = nsec8_h | (PTP_TIME_INC<<RTL8367C_PTP_TIME_NSEC_H_CMD_OFFSET) | RTL8367C_PTP_TIME_NSEC_H_EXEC_MASK;
+    else
+        regData = nsec8_h | (PTP_TIME_DEC<<RTL8367C_PTP_TIME_NSEC_H_CMD_OFFSET) | RTL8367C_PTP_TIME_NSEC_H_EXEC_MASK;
+
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, regData)) != RT_ERR_OK)
+        return retVal;
+
+    count = 0;
+    do {
+        if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_PTP_TIME_NSEC_H_NSEC, RTL8367C_PTP_TIME_NSEC_H_EXEC_OFFSET, &busyFlag)) != RT_ERR_OK)
+            return retVal;
+        count++;
+    } while ((busyFlag != 0)&&(count<5));
+
+    if (busyFlag != 0)
+        return RT_ERR_BUSYWAIT_TIMEOUT;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicEavSysTimeCtrl
+ * Description:
+ *      Set PTP system time control
+ * Input:
+ *      command - start or stop
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicEavSysTimeCtrl(rtk_uint32 control)
+{
+    ret_t  retVal;
+    rtk_uint32 regData;
+
+    if (control>=PTP_TIME_CTRL_END)
+         return RT_ERR_INPUT;
+
+    regData = 0;
+    if (PTP_TIME_CTRL_START == control)
+            regData = RTL8367C_CFG_TIMER_EN_FRC_MASK | RTL8367C_CFG_TIMER_1588_EN_MASK;
+    else
+        regData = 0;
+
+    if((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PTP_TIME_CFG, regData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicEavSysTimeCtrl
+ * Description:
+ *      Get PTP system time control
+ * Input:
+ *      None
+ * Output:
+ *      pControl - start or stop
+ * Return:
+ *      RT_ERR_OK     - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEavSysTimeCtrl(rtk_uint32* pControl)
+{
+    ret_t  retVal;
+    rtk_uint32 regData;
+    rtk_uint32 mask;
+
+    mask = RTL8367C_CFG_TIMER_EN_FRC_MASK | RTL8367C_CFG_TIMER_1588_EN_MASK;
+
+    if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_PTP_TIME_CFG, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if( (regData & mask) == mask)
+        *pControl = PTP_TIME_CTRL_START;
+    else if( (regData & mask) == 0)
+        *pControl = PTP_TIME_CTRL_STOP;
+    else
+        return RT_ERR_NOT_ALLOWED;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicEavInterruptMask
+ * Description:
+ *      Set PTP interrupt enable mask
+ * Input:
+ *      imr     - Interrupt mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      [0]:TX_SYNC,
+ *      [1]:TX_DELAY,
+ *      [2]:TX_PDELAY_REQ,
+ *      [3]:TX_PDELAY_RESP,
+ *      [4]:RX_SYNC,
+ *      [5]:RX_DELAY,
+ *      [6]:RX_PDELAY_REQ,
+ *      [7]:RX_PDELAY_RESP,
+ */
+ret_t rtl8367c_setAsicEavInterruptMask(rtk_uint32 imr)
+{
+    if ((imr&(RTL8367C_PTP_INTR_MASK<<8))>0)
+         return RT_ERR_INPUT;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_PTP_TIME_CFG2, RTL8367C_PTP_INTR_MASK, imr);
+}
+/* Function Name:
+ *      rtl8367c_getAsicEavInterruptMask
+ * Description:
+ *      Get PTP interrupt enable mask
+ * Input:
+ *      pImr    - Interrupt mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      [0]:TX_SYNC,
+ *      [1]:TX_DELAY,
+ *      [2]:TX_PDELAY_REQ,
+ *      [3]:TX_PDELAY_RESP,
+ *      [4]:RX_SYNC,
+ *      [5]:RX_DELAY,
+ *      [6]:RX_PDELAY_REQ,
+ *      [7]:RX_PDELAY_RESP,
+ */
+ret_t rtl8367c_getAsicEavInterruptMask(rtk_uint32* pImr)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_PTP_TIME_CFG2, RTL8367C_PTP_INTR_MASK, pImr);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicEavInterruptStatus
+ * Description:
+ *      Get PTP interrupt port status mask
+ * Input:
+ *      pIms    - Interrupt mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      [0]:p0 interrupt,
+ *      [1]:p1 interrupt,
+ *      [2]:p2 interrupt,
+ *      [3]:p3 interrupt,
+ *      [4]:p4 interrupt,
+ */
+ret_t rtl8367c_getAsicEavInterruptStatus(rtk_uint32* pIms)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_PTP_INTERRUPT_CFG, RTL8367C_PTP_PORT_MASK, pIms);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicInterruptMask
+ * Description:
+ *      Clear interrupt enable mask
+ * Input:
+ *      ims     - Interrupt status mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      This API can be used to clear ASIC interrupt status and register will be cleared by writting 1.
+ *      [0]:TX_SYNC,
+ *      [1]:TX_DELAY,
+ *      [2]:TX_PDELAY_REQ,
+ *      [3]:TX_PDELAY_RESP,
+ *      [4]:RX_SYNC,
+ *      [5]:RX_DELAY,
+ *      [6]:RX_PDELAY_REQ,
+ *      [7]:RX_PDELAY_RESP,
+ */
+ret_t rtl8367c_setAsicEavPortInterruptStatus(rtk_uint32 port, rtk_uint32 ims)
+{
+
+    if(port > RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(port < 5)
+        return rtl8367c_setAsicRegBits(RTL8367C_EAV_PORT_CFG_REG(port), RTL8367C_PTP_INTR_MASK,ims);
+    else if(port == 5)
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_P5_EAV_CFG, RTL8367C_PTP_INTR_MASK,ims);
+    else if(port == 6)
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_P6_EAV_CFG, RTL8367C_PTP_INTR_MASK,ims);
+    else if(port == 7)
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_P7_EAV_CFG, RTL8367C_PTP_INTR_MASK,ims);
+    else if(port == 8)
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_P8_EAV_CFG, RTL8367C_PTP_INTR_MASK,ims);
+    else if(port == 9)
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_P9_EAV_CFG, RTL8367C_PTP_INTR_MASK,ims);
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicInterruptStatus
+ * Description:
+ *      Get interrupt enable mask
+ * Input:
+ *      pIms    - Interrupt status mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      [0]:TX_SYNC,
+ *      [1]:TX_DELAY,
+ *      [2]:TX_PDELAY_REQ,
+ *      [3]:TX_PDELAY_RESP,
+ *      [4]:RX_SYNC,
+ *      [5]:RX_DELAY,
+ *      [6]:RX_PDELAY_REQ,
+ *      [7]:RX_PDELAY_RESP,
+ */
+ret_t rtl8367c_getAsicEavPortInterruptStatus(rtk_uint32 port, rtk_uint32* pIms)
+{
+
+    if(port > RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+    if(port < 5)
+        return rtl8367c_getAsicRegBits(RTL8367C_EAV_PORT_CFG_REG(port), RTL8367C_PTP_INTR_MASK, pIms);
+    else if(port == 5)
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_P5_EAV_CFG, RTL8367C_PTP_INTR_MASK, pIms);
+    else if(port == 6)
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_P6_EAV_CFG, RTL8367C_PTP_INTR_MASK,pIms);
+    else if(port == 7)
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_P7_EAV_CFG, RTL8367C_PTP_INTR_MASK,pIms);
+    else if(port == 8)
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_P8_EAV_CFG, RTL8367C_PTP_INTR_MASK,pIms);
+    else if(port == 9)
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_P9_EAV_CFG, RTL8367C_PTP_INTR_MASK,pIms);
+
+    return RT_ERR_OK;
+
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicEavPortEnable
+ * Description:
+ *      Set per-port EAV function enable/disable
+ * Input:
+ *      port         - Physical port number (0~9)
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      If EAV function is enabled, PTP event messgae packet will be attached PTP timestamp for trapping
+ */
+ret_t rtl8367c_setAsicEavPortEnable(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port > RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(port < 5)
+        return rtl8367c_setAsicRegBit(RTL8367C_EAV_PORT_CFG_REG(port), RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);
+    else if(port == 5)
+        return rtl8367c_setAsicRegBit(RTL8367C_REG_P5_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);
+    else if(port == 6)
+        return rtl8367c_setAsicRegBit(RTL8367C_REG_P6_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);
+    else if(port == 7)
+        return rtl8367c_setAsicRegBit(RTL8367C_REG_P7_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);
+    else if(port == 8)
+        return rtl8367c_setAsicRegBit(RTL8367C_REG_P8_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);
+    else if(port == 9)
+        return rtl8367c_setAsicRegBit(RTL8367C_REG_P9_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, enabled);
+
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicEavPortEnable
+ * Description:
+ *      Get per-port EAV function enable/disable
+ * Input:
+ *      port         - Physical port number (0~9)
+ *      pEnabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEavPortEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
+{
+    if(port > RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+
+
+    if(port < 5)
+        return rtl8367c_getAsicRegBit(RTL8367C_EAV_PORT_CFG_REG(port), RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);
+    else if(port == 5)
+        return rtl8367c_getAsicRegBit(RTL8367C_REG_P5_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);
+    else if(port == 6)
+        return rtl8367c_getAsicRegBit(RTL8367C_REG_P6_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);
+    else if(port == 7)
+        return rtl8367c_getAsicRegBit(RTL8367C_REG_P7_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);
+    else if(port == 8)
+        return rtl8367c_getAsicRegBit(RTL8367C_REG_P8_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);
+    else if(port == 9)
+        return rtl8367c_getAsicRegBit(RTL8367C_REG_P9_EAV_CFG, RTL8367C_EAV_CFG_PTP_PHY_EN_EN_OFFSET, pEnabled);
+
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicEavPortTimeStamp
+ * Description:
+ *      Get PTP port time stamp
+ * Input:
+ *      port         - Physical port number (0~9)
+ *      type     -  PTP packet type
+ * Output:
+ *      timeStamp - seconds
+ * Return:
+ *      RT_ERR_OK     - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      The time granuality is 8 nano seconds.
+ */
+ret_t rtl8367c_getAsicEavPortTimeStamp(rtk_uint32 port, rtk_uint32 type, rtl8367c_ptp_time_stamp_t* timeStamp)
+{
+    ret_t retVal;
+    rtk_uint32 sec_h, sec_l, nsec8_h, nsec8_l;
+    rtk_uint32 nano_second_8;
+
+    if(port > 9)
+        return RT_ERR_PORT_ID;
+    if(type >= PTP_PKT_TYPE_END)
+        return RT_ERR_INPUT;
+
+    if(port < 5){
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_SEQ_ID(port, type), &timeStamp->sequence_id))!=  RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_PORT_SEC_H(port) , &sec_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_PORT_SEC_L(port), &sec_l)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_NSEC_H(port) , RTL8367C_PORT_NSEC_H_MASK,&nsec8_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_PORT_NSEC_L(port) , &nsec8_l)) != RT_ERR_OK)
+           return retVal;
+    }else if(port == 5){
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P5_TX_SYNC_SEQ_ID+type, &timeStamp->sequence_id))!=  RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P5_PORT_SEC_31_16, &sec_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P5_PORT_SEC_15_0, &sec_l)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_P5_PORT_NSEC_26_16 , RTL8367C_PORT_NSEC_H_MASK,&nsec8_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P5_PORT_NSEC_15_0, &nsec8_l)) != RT_ERR_OK)
+           return retVal;
+    }else if(port == 6){
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P6_TX_SYNC_SEQ_ID+type, &timeStamp->sequence_id))!=  RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P6_PORT_SEC_31_16, &sec_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P6_PORT_SEC_15_0, &sec_l)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_P6_PORT_NSEC_26_16 , RTL8367C_PORT_NSEC_H_MASK,&nsec8_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P6_PORT_NSEC_15_0, &nsec8_l)) != RT_ERR_OK)
+           return retVal;
+    }else if(port == 7){
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P7_TX_SYNC_SEQ_ID+type, &timeStamp->sequence_id))!=  RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P7_PORT_SEC_31_16, &sec_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P7_PORT_SEC_15_0, &sec_l)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_P7_PORT_NSEC_26_16 , RTL8367C_PORT_NSEC_H_MASK,&nsec8_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P7_PORT_NSEC_15_0, &nsec8_l)) != RT_ERR_OK)
+           return retVal;
+    }else if(port == 8){
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P8_TX_SYNC_SEQ_ID+type, &timeStamp->sequence_id))!=  RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P8_PORT_SEC_31_16, &sec_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P8_PORT_SEC_15_0, &sec_l)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_P8_PORT_NSEC_26_16 , RTL8367C_PORT_NSEC_H_MASK,&nsec8_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P8_PORT_NSEC_15_0, &nsec8_l)) != RT_ERR_OK)
+           return retVal;
+    }else if(port == 9){
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P9_TX_SYNC_SEQ_ID+type, &timeStamp->sequence_id))!=  RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P9_PORT_SEC_31_16, &sec_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P9_PORT_SEC_15_0, &sec_l)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_P9_PORT_NSEC_26_16 , RTL8367C_PORT_NSEC_H_MASK,&nsec8_h)) != RT_ERR_OK)
+           return retVal;
+        if((retVal = rtl8367c_getAsicReg(RTL8367C_REG_P9_PORT_NSEC_15_0, &nsec8_l)) != RT_ERR_OK)
+           return retVal;
+    }
+
+    timeStamp->second = (sec_h<<16) | sec_l;
+    nano_second_8 = (nsec8_h<<16) | nsec8_l;
+    timeStamp->nano_second = nano_second_8<<3;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicEavTrap
+ * Description:
+ *      Set per-port PTP packet trap to CPU
+ * Input:
+ *      port         - Physical port number (0~5)
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      If EAV trap enabled, switch will trap PTP packet to CPU
+ */
+ret_t rtl8367c_setAsicEavTrap(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port > RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_PTP_PORT0_CFG1 + (port * 0x20), RTL8367C_PTP_PORT0_CFG1_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicEavTimeSyncEn
+ * Description:
+ *      Get per-port EPTP packet trap to CPU
+ * Input:
+ *      port         - Physical port number (0~5)
+ *      pEnabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEavTrap(rtk_uint32 port, rtk_uint32 *pEnabled)
+{
+    if(port > RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_PTP_PORT0_CFG1 + (port * 0x20), RTL8367C_PTP_PORT0_CFG1_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicEavEnable
+ * Description:
+ *      Set per-port EAV function enable/disable
+ * Input:
+ *      port         - Physical port number (0~5)
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      If EAV function is enabled, PTP event messgae packet will be attached PTP timestamp for trapping
+ */
+ret_t rtl8367c_setAsicEavEnable(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port > RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_EAV_CTRL0, port, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicEavEnable
+ * Description:
+ *      Get per-port EAV function enable/disable
+ * Input:
+ *      port         - Physical port number (0~5)
+ *      pEnabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEavEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
+{
+    if(port > RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_EAV_CTRL0, port, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicEavPriRemapping
+ * Description:
+ *      Set non-EAV streaming priority remapping
+ * Input:
+ *      srcpriority - Priority value
+ *      priority     - Absolute priority value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                     - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY      - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicEavPriRemapping(rtk_uint32 srcpriority, rtk_uint32 priority)
+{
+    if(srcpriority > RTL8367C_PRIMAX || priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_EAV_PRIORITY_REMAPPING_REG(srcpriority), RTL8367C_EAV_PRIORITY_REMAPPING_MASK(srcpriority),priority);
+}
+/* Function Name:
+ *      rtl8367c_getAsicEavPriRemapping
+ * Description:
+ *      Get non-EAV streaming priority remapping
+ * Input:
+ *      srcpriority - Priority value
+ *      pPriority     - Absolute priority value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                     - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY      - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEavPriRemapping(rtk_uint32 srcpriority, rtk_uint32 *pPriority)
+{
+    if(srcpriority > RTL8367C_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_EAV_PRIORITY_REMAPPING_REG(srcpriority), RTL8367C_EAV_PRIORITY_REMAPPING_MASK(srcpriority),pPriority);
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_eee.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_eee.c
new file mode 100644
index 0000000000000..214446ac4983f
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_eee.c
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 48989 $
+ * $Date: 2014-07-01 15:45:24 +0800 (週二, 01 七月 2014) $
+ *
+ * Purpose : RTL8370 switch high-level API for RTL8367C
+ * Feature :
+ *
+ */
+
+#include <rtl8367c_asicdrv_eee.h>
+#include <rtl8367c_asicdrv_phy.h>
+
+/*
+@func ret_t | rtl8367c_setAsicEee100M | Set eee force mode function enable/disable.
+@parm rtk_uint32 | port | The port number.
+@parm rtk_uint32 | enabled | 1: enabled, 0: disabled.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_INPUT | Invalid input parameter.
+@comm
+    This API set the 100M EEE enable function.
+
+*/
+ret_t rtl8367c_setAsicEee100M(rtk_uint32 port, rtk_uint32 enable)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      regData;
+
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if (enable > 1)
+        return RT_ERR_INPUT;
+
+    if((retVal = rtl8367c_getAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if(enable)
+        regData |= (0x0001 << 1);
+    else
+        regData &= ~(0x0001 << 1);
+
+    if((retVal = rtl8367c_setAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, regData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/*
+@func ret_t | rtl8367c_getAsicEee100M | Get 100M eee enable/disable.
+@parm rtk_uint32 | port | The port number.
+@parm rtk_uint32* | enabled | 1: enabled, 0: disabled.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_INPUT | Invalid input parameter.
+@comm
+    This API get the 100M EEE function.
+*/
+ret_t rtl8367c_getAsicEee100M(rtk_uint32 port, rtk_uint32 *enable)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      regData;
+
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if((retVal = rtl8367c_getAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    *enable = (regData & (0x0001 << 1)) ? ENABLED : DISABLED;
+    return RT_ERR_OK;
+}
+
+/*
+@func ret_t | rtl8367c_setAsicEeeGiga | Set eee force mode function enable/disable.
+@parm rtk_uint32 | port | The port number.
+@parm rtk_uint32 | enabled | 1: enabled, 0: disabled.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_INPUT | Invalid input parameter.
+@comm
+    This API set the 100M EEE enable function.
+
+*/
+ret_t rtl8367c_setAsicEeeGiga(rtk_uint32 port, rtk_uint32 enable)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      regData;
+
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if (enable > 1)
+        return RT_ERR_INPUT;
+
+    if((retVal = rtl8367c_getAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if(enable)
+        regData |= (0x0001 << 2);
+    else
+        regData &= ~(0x0001 << 2);
+
+    if((retVal = rtl8367c_setAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, regData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/*
+@func ret_t | rtl8367c_getAsicEeeGiga | Get 100M eee enable/disable.
+@parm rtk_uint32 | port | The port number.
+@parm rtk_uint32* | enabled | 1: enabled, 0: disabled.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_INPUT | Invalid input parameter.
+@comm
+    This API get the 100M EEE function.
+*/
+ret_t rtl8367c_getAsicEeeGiga(rtk_uint32 port, rtk_uint32 *enable)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      regData;
+
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if((retVal = rtl8367c_getAsicPHYOCPReg(port, EEE_OCP_PHY_ADDR, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    *enable = (regData & (0x0001 << 2)) ? ENABLED : DISABLED;
+    return RT_ERR_OK;
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_fc.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_fc.c
new file mode 100644
index 0000000000000..28f49b1ba7508
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_fc.c
@@ -0,0 +1,1354 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Flow control related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_fc.h>
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlSelect
+ * Description:
+ *      Set system flow control type
+ * Input:
+ *      select      - System flow control type 1: Ingress flow control 0:Egress flow control
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlSelect(rtk_uint32 select)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_FLOWCTRL_CTRL0, RTL8367C_FLOWCTRL_TYPE_OFFSET, select);
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlSelect
+ * Description:
+ *      Get system flow control type
+ * Input:
+ *      pSelect         - System flow control type 1: Ingress flow control 0:Egress flow control
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlSelect(rtk_uint32 *pSelect)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_FLOWCTRL_CTRL0, RTL8367C_FLOWCTRL_TYPE_OFFSET, pSelect);
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlJumboMode
+ * Description:
+ *      Set Jumbo threhsold for flow control
+ * Input:
+ *      enabled         - Jumbo mode flow control 1: Enable 0:Disable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlJumboMode(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_FLOWCTRL_JUMBO_SIZE, RTL8367C_JUMBO_MODE_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlJumboMode
+ * Description:
+ *      Get Jumbo threhsold for flow control
+ * Input:
+ *      pEnabled        - Jumbo mode flow control 1: Enable 0:Disable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlJumboMode(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_FLOWCTRL_JUMBO_SIZE, RTL8367C_JUMBO_MODE_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlJumboModeSize
+ * Description:
+ *      Set Jumbo size for Jumbo mode flow control
+ * Input:
+ *      size        - Jumbo size 0:3Kbytes 1:4Kbytes 2:6Kbytes 3:9Kbytes
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlJumboModeSize(rtk_uint32 size)
+{
+    if(size >= FC_JUMBO_SIZE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SIZE, RTL8367C_JUMBO_SIZE_MASK, size);
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlJumboModeSize
+ * Description:
+ *      Get Jumbo size for Jumbo mode flow control
+ * Input:
+ *      pSize       - Jumbo size 0:3Kbytes 1:4Kbytes 2:6Kbytes 3:9Kbytes
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlJumboModeSize(rtk_uint32* pSize)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SIZE, RTL8367C_JUMBO_SIZE_MASK, pSize);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlQueueEgressEnable
+ * Description:
+ *      Set flow control ability for each queue
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      qid     - Queue id
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ *      RT_ERR_QUEUE_ID - Invalid queue id
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlQueueEgressEnable(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 enabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(qid > RTL8367C_QIDMAX)
+        return RT_ERR_QUEUE_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG(port), RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG_OFFSET(port)+ qid, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlQueueEgressEnable
+ * Description:
+ *      Get flow control ability for each queue
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      qid     - Queue id
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ *      RT_ERR_QUEUE_ID - Invalid queue id
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlQueueEgressEnable(rtk_uint32 port, rtk_uint32 qid, rtk_uint32* pEnabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(qid > RTL8367C_QIDMAX)
+        return RT_ERR_QUEUE_ID;
+
+    return  rtl8367c_getAsicRegBit(RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG(port), RTL8367C_FLOWCRTL_EGRESS_QUEUE_ENABLE_REG_OFFSET(port)+ qid, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlDropAll
+ * Description:
+ *      Set system-based drop parameters
+ * Input:
+ *      dropall     - Whole system drop threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlDropAll(rtk_uint32 dropall)
+{
+    if(dropall >= RTL8367C_PAGE_NUMBER)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_CTRL0, RTL8367C_DROP_ALL_THRESHOLD_MASK, dropall);
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlDropAll
+ * Description:
+ *      Get system-based drop parameters
+ * Input:
+ *      pDropall    - Whole system drop threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlDropAll(rtk_uint32* pDropall)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_CTRL0, RTL8367C_DROP_ALL_THRESHOLD_MASK, pDropall);
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlPauseAll
+ * Description:
+ *      Set system-based all ports enable flow control parameters
+ * Input:
+ *      threshold   - Whole system pause all threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlPauseAllThreshold(rtk_uint32 threshold)
+{
+    if(threshold >= RTL8367C_PAGE_NUMBER)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_ALL_ON, RTL8367C_FLOWCTRL_ALL_ON_THRESHOLD_MASK, threshold);
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlPauseAllThreshold
+ * Description:
+ *      Get system-based all ports enable flow control parameters
+ * Input:
+ *      pThreshold  - Whole system pause all threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlPauseAllThreshold(rtk_uint32 *pThreshold)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_ALL_ON, RTL8367C_FLOWCTRL_ALL_ON_THRESHOLD_MASK, pThreshold);
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlSystemThreshold
+ * Description:
+ *      Set system-based flow control parameters
+ * Input:
+ *      onThreshold     - Flow control turn ON threshold
+ *      offThreshold    - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlSystemThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_SYS_OFF, RTL8367C_FLOWCTRL_SYS_OFF_MASK, offThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_SYS_ON, RTL8367C_FLOWCTRL_SYS_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlSystemThreshold
+ * Description:
+ *      Get system-based flow control parameters
+ * Input:
+ *      pOnThreshold    - Flow control turn ON threshold
+ *      pOffThreshold   - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlSystemThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_SYS_OFF, RTL8367C_FLOWCTRL_SYS_OFF_MASK, pOffThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_SYS_ON, RTL8367C_FLOWCTRL_SYS_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlSharedThreshold
+ * Description:
+ *      Set share-based flow control parameters
+ * Input:
+ *      onThreshold     - Flow control turn ON threshold
+ *      offThreshold    - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlSharedThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_SHARE_OFF, RTL8367C_FLOWCTRL_SHARE_OFF_MASK, offThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_SHARE_ON, RTL8367C_FLOWCTRL_SHARE_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlSharedThreshold
+ * Description:
+ *      Get share-based flow control parameters
+ * Input:
+ *      pOnThreshold    - Flow control turn ON threshold
+ *      pOffThreshold   - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlSharedThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_SHARE_OFF, RTL8367C_FLOWCTRL_SHARE_OFF_MASK, pOffThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_SHARE_ON, RTL8367C_FLOWCTRL_SHARE_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlPortThreshold
+ * Description:
+ *      Set Port-based flow control parameters
+ * Input:
+ *      onThreshold     - Flow control turn ON threshold
+ *      offThreshold    - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlPortThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_OFF, RTL8367C_FLOWCTRL_PORT_OFF_MASK, offThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_ON, RTL8367C_FLOWCTRL_PORT_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlPortThreshold
+ * Description:
+ *      Get Port-based flow control parameters
+ * Input:
+ *      pOnThreshold    - Flow control turn ON threshold
+ *      pOffThreshold   - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlPortThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_OFF, RTL8367C_FLOWCTRL_PORT_OFF_MASK, pOffThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_ON, RTL8367C_FLOWCTRL_PORT_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlPortPrivateThreshold
+ * Description:
+ *      Set Port-private-based flow control parameters
+ * Input:
+ *      onThreshold     - Flow control turn ON threshold
+ *      offThreshold    - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlPortPrivateThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_PORT_PRIVATE_OFF_MASK, offThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_PORT_PRIVATE_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlPortPrivateThreshold
+ * Description:
+ *      Get Port-private-based flow control parameters
+ * Input:
+ *      pOnThreshold    - Flow control turn ON threshold
+ *      pOffThreshold   - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlPortPrivateThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_PORT_PRIVATE_OFF_MASK, pOffThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_PORT_PRIVATE_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlSystemDropThreshold
+ * Description:
+ *      Set system-based drop parameters
+ * Input:
+ *      onThreshold     - Drop turn ON threshold
+ *      offThreshold    - Drop turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlSystemDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SYS_OFF, RTL8367C_FLOWCTRL_FCOFF_SYS_OFF_MASK, offThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SYS_ON, RTL8367C_FLOWCTRL_FCOFF_SYS_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlSystemDropThreshold
+ * Description:
+ *      Get system-based drop parameters
+ * Input:
+ *      pOnThreshold    - Drop turn ON threshold
+ *      pOffThreshold   - Drop turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlSystemDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SYS_OFF, RTL8367C_FLOWCTRL_FCOFF_SYS_OFF_MASK, pOffThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SYS_ON, RTL8367C_FLOWCTRL_FCOFF_SYS_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlSharedDropThreshold
+ * Description:
+ *      Set share-based fdrop parameters
+ * Input:
+ *      onThreshold     - Drop turn ON threshold
+ *      offThreshold    - Drop turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlSharedDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SHARE_OFF, RTL8367C_FLOWCTRL_FCOFF_SHARE_OFF_MASK, offThreshold);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SHARE_ON, RTL8367C_FLOWCTRL_FCOFF_SHARE_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlSharedDropThreshold
+ * Description:
+ *      Get share-based fdrop parameters
+ * Input:
+ *      pOnThreshold    - Drop turn ON threshold
+ *      pOffThreshold   - Drop turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlSharedDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SHARE_OFF, RTL8367C_FLOWCTRL_FCOFF_SHARE_OFF_MASK, pOffThreshold);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_SHARE_ON, RTL8367C_FLOWCTRL_FCOFF_SHARE_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlPortDropThreshold
+ * Description:
+ *      Set Port-based drop parameters
+ * Input:
+ *      onThreshold     - Drop turn ON threshold
+ *      offThreshold    - Drop turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlPortDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_OFF, RTL8367C_FLOWCTRL_FCOFF_PORT_OFF_MASK, offThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_ON, RTL8367C_FLOWCTRL_FCOFF_PORT_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlPortDropThreshold
+ * Description:
+ *      Get Port-based drop parameters
+ * Input:
+ *      pOnThreshold    - Drop turn ON threshold
+ *      pOffThreshold   - Drop turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlPortDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_OFF, RTL8367C_FLOWCTRL_FCOFF_PORT_OFF_MASK, pOffThreshold);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_ON, RTL8367C_FLOWCTRL_FCOFF_PORT_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlPortPrivateDropThreshold
+ * Description:
+ *      Set Port-private-based drop parameters
+ * Input:
+ *      onThreshold     - Drop turn ON threshold
+ *      offThreshold    - Drop turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlPortPrivateDropThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_OFF_MASK, offThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlPortPrivateDropThreshold
+ * Description:
+ *      Get Port-private-based drop parameters
+ * Input:
+ *      pOnThreshold    - Drop turn ON threshold
+ *      pOffThreshold   - Drop turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlPortPrivateDropThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_OFF_MASK, pOffThreshold);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_FCOFF_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_FCOFF_PORT_PRIVATE_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlSystemJumboThreshold
+ * Description:
+ *      Set Jumbo system-based flow control parameters
+ * Input:
+ *      onThreshold     - Flow control turn ON threshold
+ *      offThreshold    - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlSystemJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SYS_OFF, RTL8367C_FLOWCTRL_JUMBO_SYS_OFF_MASK, offThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SYS_ON, RTL8367C_FLOWCTRL_JUMBO_SYS_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlSystemJumboThreshold
+ * Description:
+ *      Get Jumbo system-based flow control parameters
+ * Input:
+ *      pOnThreshold    - Flow control turn ON threshold
+ *      pOffThreshold   - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlSystemJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SYS_OFF, RTL8367C_FLOWCTRL_JUMBO_SYS_OFF_MASK, pOffThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SYS_ON, RTL8367C_FLOWCTRL_JUMBO_SYS_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlSharedJumboThreshold
+ * Description:
+ *      Set Jumbo share-based flow control parameters
+ * Input:
+ *      onThreshold     - Flow control turn ON threshold
+ *      offThreshold    - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlSharedJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SHARE_OFF, RTL8367C_FLOWCTRL_JUMBO_SHARE_OFF_MASK, offThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SHARE_ON, RTL8367C_FLOWCTRL_JUMBO_SHARE_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlSharedJumboThreshold
+ * Description:
+ *      Get Jumbo share-based flow control parameters
+ * Input:
+ *      pOnThreshold    - Flow control turn ON threshold
+ *      pOffThreshold   - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlSharedJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SHARE_OFF, RTL8367C_FLOWCTRL_JUMBO_SHARE_OFF_MASK, pOffThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_SHARE_ON, RTL8367C_FLOWCTRL_JUMBO_SHARE_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlPortJumboThreshold
+ * Description:
+ *      Set Jumbo Port-based flow control parameters
+ * Input:
+ *      onThreshold     - Flow control turn ON threshold
+ *      offThreshold    - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlPortJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_OFF, RTL8367C_FLOWCTRL_JUMBO_PORT_OFF_MASK, offThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_ON, RTL8367C_FLOWCTRL_JUMBO_PORT_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlPortJumboThreshold
+ * Description:
+ *      Get Jumbo Port-based flow control parameters
+ * Input:
+ *      pOnThreshold    - Flow control turn ON threshold
+ *      pOffThreshold   - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlPortJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_OFF, RTL8367C_FLOWCTRL_JUMBO_PORT_OFF_MASK, pOffThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_ON, RTL8367C_FLOWCTRL_JUMBO_PORT_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlPortPrivateJumboThreshold
+ * Description:
+ *      Set Jumbo Port-private-based flow control parameters
+ * Input:
+ *      onThreshold     - Flow control turn ON threshold
+ *      offThreshold    - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlPortPrivateJumboThreshold(rtk_uint32 onThreshold, rtk_uint32 offThreshold)
+{
+    ret_t retVal;
+
+    if((onThreshold >= RTL8367C_PAGE_NUMBER) || (offThreshold >= RTL8367C_PAGE_NUMBER))
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_OFF_MASK, offThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_ON_MASK, onThreshold);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlPortPrivateJumboThreshold
+ * Description:
+ *      Get Jumbo Port-private-based flow control parameters
+ * Input:
+ *      pOnThreshold    - Flow control turn ON threshold
+ *      pOffThreshold   - Flow control turn OFF threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlPortPrivateJumboThreshold(rtk_uint32 *pOnThreshold, rtk_uint32 *pOffThreshold)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_PRIVATE_OFF, RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_OFF_MASK, pOffThreshold);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_JUMBO_PORT_PRIVATE_ON, RTL8367C_FLOWCTRL_JUMBO_PORT_PRIVATE_ON_MASK, pOnThreshold);
+
+    return retVal;
+}
+
+
+
+/* Function Name:
+ *      rtl8367c_setAsicEgressFlowControlQueueDropThreshold
+ * Description:
+ *      Set Queue-based egress flow control turn on or ingress flow control drop on threshold
+ * Input:
+ *      qid         - The queue id
+ *      threshold   - Queue-based flown control/drop turn ON threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ *      RT_ERR_QUEUE_ID     - Invalid queue id
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicEgressFlowControlQueueDropThreshold(rtk_uint32 qid, rtk_uint32 threshold)
+{
+    if( threshold >= RTL8367C_PAGE_NUMBER)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(qid > RTL8367C_QIDMAX)
+        return RT_ERR_QUEUE_ID;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_FLOWCTRL_QUEUE_DROP_ON_REG(qid), RTL8367C_FLOWCTRL_QUEUE_DROP_ON_MASK, threshold);
+}
+/* Function Name:
+ *      rtl8367c_getAsicEgressFlowControlQueueDropThreshold
+ * Description:
+ *      Get Queue-based egress flow control turn on or ingress flow control drop on threshold
+ * Input:
+ *      qid         - The queue id
+ *      pThreshold  - Queue-based flown control/drop turn ON threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_QUEUE_ID     - Invalid queue id
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEgressFlowControlQueueDropThreshold(rtk_uint32 qid, rtk_uint32 *pThreshold)
+{
+    if(qid > RTL8367C_QIDMAX)
+      return RT_ERR_QUEUE_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_FLOWCTRL_QUEUE_DROP_ON_REG(qid), RTL8367C_FLOWCTRL_QUEUE_DROP_ON_MASK, pThreshold);
+}
+/* Function Name:
+ *      rtl8367c_setAsicEgressFlowControlPortDropThreshold
+ * Description:
+ *      Set port-based egress flow control turn on or ingress flow control drop on threshold
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      threshold   - Queue-based flown control/drop turn ON threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicEgressFlowControlPortDropThreshold(rtk_uint32 port, rtk_uint32 threshold)
+{
+    if(port > RTL8367C_PORTIDMAX)
+      return RT_ERR_PORT_ID;
+
+    if(threshold >= RTL8367C_PAGE_NUMBER)
+      return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_FLOWCTRL_PORT_DROP_ON_REG(port), RTL8367C_FLOWCTRL_PORT_DROP_ON_MASK, threshold);
+}
+/* Function Name:
+ *      rtl8367c_setAsicEgressFlowControlPortDropThreshold
+ * Description:
+ *      Set port-based egress flow control turn on or ingress flow control drop on threshold
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      pThreshold  - Queue-based flown control/drop turn ON threshold
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEgressFlowControlPortDropThreshold(rtk_uint32 port, rtk_uint32 *pThreshold)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_FLOWCTRL_PORT_DROP_ON_REG(port), RTL8367C_FLOWCTRL_PORT_DROP_ON_MASK, pThreshold);
+}
+/* Function Name:
+ *      rtl8367c_setAsicEgressFlowControlPortDropGap
+ * Description:
+ *      Set port-based egress flow control turn off or ingress flow control drop off gap
+ * Input:
+ *      gap     - Flow control/drop turn OFF threshold = turn ON threshold - gap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicEgressFlowControlPortDropGap(rtk_uint32 gap)
+{
+    if(gap >= RTL8367C_PAGE_NUMBER)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_GAP, RTL8367C_FLOWCTRL_PORT_GAP_MASK, gap);
+}
+/* Function Name:
+ *      rtl8367c_getAsicEgressFlowControlPortDropGap
+ * Description:
+ *      Get port-based egress flow control turn off or ingress flow control drop off gap
+ * Input:
+ *      pGap    - Flow control/drop turn OFF threshold = turn ON threshold - gap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEgressFlowControlPortDropGap(rtk_uint32 *pGap)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT_GAP, RTL8367C_FLOWCTRL_PORT_GAP_MASK, pGap);
+}
+/* Function Name:
+ *      rtl8367c_setAsicEgressFlowControlQueueDropGap
+ * Description:
+ *      Set Queue-based egress flow control turn off or ingress flow control drop off gap
+ * Input:
+ *      gap     - Flow control/drop turn OFF threshold = turn ON threshold - gap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicEgressFlowControlQueueDropGap(rtk_uint32 gap)
+{
+    if(gap >= RTL8367C_PAGE_NUMBER)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_FLOWCTRL_QUEUE_GAP, RTL8367C_FLOWCTRL_QUEUE_GAP_MASK, gap);
+}
+/* Function Name:
+ *      rtl8367c_getAsicEgressFlowControlQueueDropGap
+ * Description:
+ *      Get Queue-based egress flow control turn off or ingress flow control drop off gap
+ * Input:
+ *      pGap    - Flow control/drop turn OFF threshold = turn ON threshold - gap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEgressFlowControlQueueDropGap(rtk_uint32 *pGap)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_QUEUE_GAP, RTL8367C_FLOWCTRL_QUEUE_GAP_MASK, pGap);
+}
+/* Function Name:
+ *      rtl8367c_getAsicEgressQueueEmptyPortMask
+ * Description:
+ *      Get queue empty port mask
+ * Input:
+ *      pPortmask   -  Queue empty port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicEgressQueueEmptyPortMask(rtk_uint32 *pPortmask)
+{
+    return rtl8367c_getAsicReg(RTL8367C_REG_PORT_QEMPTY, pPortmask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicTotalPage
+ * Description:
+ *      Get system total page usage number
+ * Input:
+ *      pPageCount  -  page usage number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicTotalPage(rtk_uint32 *pPageCount)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_TOTAL_PAGE_COUNTER, RTL8367C_FLOWCTRL_TOTAL_PAGE_COUNTER_MASK, pPageCount);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPulbicPage
+ * Description:
+ *      Get system public page usage number
+ * Input:
+ *      pPageCount  -  page usage number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPulbicPage(rtk_uint32 *pPageCount)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PUBLIC_PAGE_COUNTER, RTL8367C_FLOWCTRL_PUBLIC_PAGE_COUNTER_MASK, pPageCount);
+}
+/* Function Name:
+ *      rtl8367c_getAsicMaxTotalPage
+ * Description:
+ *      Get system total page max usage number
+ * Input:
+ *      pPageCount  -  page usage number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMaxTotalPage(rtk_uint32 *pPageCount)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_TOTAL_PAGE_MAX, RTL8367C_FLOWCTRL_TOTAL_PAGE_MAX_MASK, pPageCount);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPulbicPage
+ * Description:
+ *      Get system public page max usage number
+ * Input:
+ *      pPageCount  -  page usage number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMaxPulbicPage(rtk_uint32 *pPageCount)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PUBLIC_PAGE_MAX, RTL8367C_FLOWCTRL_PUBLIC_PAGE_MAX_MASK, pPageCount);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortPage
+ * Description:
+ *      Get per-port page usage number
+ * Input:
+ *      port        -  Physical port number (0~7)
+ *      pPageCount  -  page usage number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortPage(rtk_uint32 port, rtk_uint32 *pPageCount)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+        return rtl8367c_getAsicRegBits(RTL8367C_FLOWCTRL_PORT_PAGE_COUNTER_REG(port), RTL8367C_FLOWCTRL_PORT_PAGE_COUNTER_MASK, pPageCount);
+    else
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT8_PAGE_COUNTER+port - 8, RTL8367C_FLOWCTRL_PORT_PAGE_COUNTER_MASK, pPageCount);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortPage
+ * Description:
+ *      Get per-port page max usage number
+ * Input:
+ *      port        -  Physical port number (0~7)
+ *      pPageCount  -  page usage number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortPageMax(rtk_uint32 port, rtk_uint32 *pPageCount)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+    if(port < 8)
+        return rtl8367c_getAsicRegBits(RTL8367C_FLOWCTRL_PORT_PAGE_MAX_REG(port), RTL8367C_FLOWCTRL_PORT_PAGE_MAX_MASK, pPageCount);
+    else
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_FLOWCTRL_PORT0_PAGE_MAX+port-8, RTL8367C_FLOWCTRL_PORT_PAGE_MAX_MASK, pPageCount);
+
+
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicFlowControlEgressPortIndep
+ * Description:
+ *      Set per-port egress flow control independent
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      enabled     - Egress port flow control usage 1:enable 0:disable.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicFlowControlEgressPortIndep(rtk_uint32 port, rtk_uint32 enable)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_PORT0_MISC_CFG + (port *0x20), RTL8367C_PORT0_MISC_CFG_FLOWCTRL_INDEP_OFFSET,enable);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicFlowControlEgressPortIndep
+ * Description:
+ *      Get per-port egress flow control independent
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      enabled     - Egress port flow control usage 1:enable 0:disable.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFlowControlEgressPortIndep(rtk_uint32 port, rtk_uint32 *pEnable)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_PORT0_MISC_CFG + (port *0x20),RTL8367C_PORT0_MISC_CFG_FLOWCTRL_INDEP_OFFSET,pEnable);
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_green.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_green.c
new file mode 100644
index 0000000000000..a38623850b602
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_green.c
@@ -0,0 +1,445 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Green ethernet related functions
+ *
+ */
+#include <rtl8367c_asicdrv_green.h>
+
+/* Function Name:
+ *      rtl8367c_getAsicGreenPortPage
+ * Description:
+ *      Get per-Port ingress page usage per second
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pPage   - page number of ingress packet occuping per second
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      Ingress traffic occuping page number per second for high layer green feature usage
+ */
+ret_t rtl8367c_getAsicGreenPortPage(rtk_uint32 port, rtk_uint32* pPage)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint32 pageMeter;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_PAGEMETER_PORT_REG(port), &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+   pageMeter = regData;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_PAGEMETER_PORT_REG(port) + 1, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pageMeter = pageMeter + (regData << 16);
+
+    *pPage = pageMeter;
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicGreenTrafficType
+ * Description:
+ *      Set traffic type for each priority
+ * Input:
+ *      priority    - internal priority (0~7)
+ *      traffictype - high/low traffic type, 1:high priority traffic type, 0:low priority traffic type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicGreenTrafficType(rtk_uint32 priority, rtk_uint32 traffictype)
+{
+
+    if(priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_HIGHPRI_CFG, priority, (traffictype?1:0));
+}
+/* Function Name:
+ *      rtl8367c_getAsicGreenTrafficType
+ * Description:
+ *      Get traffic type for each priority
+ * Input:
+ *      priority    - internal priority (0~7)
+ *      pTraffictype - high/low traffic type, 1:high priority traffic type, 0:low priority traffic type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicGreenTrafficType(rtk_uint32 priority, rtk_uint32* pTraffictype)
+{
+    if(priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_HIGHPRI_CFG, priority, pTraffictype);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicGreenHighPriorityTraffic
+ * Description:
+ *      Set indicator which ASIC had received high priority traffic
+ * Input:
+ *      port            - Physical port number (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicGreenHighPriorityTraffic(rtk_uint32 port)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_HIGHPRI_INDICATOR, port, 1);
+}
+
+
+/* Function Name:
+ *      rtl8367c_getAsicGreenHighPriorityTraffic
+ * Description:
+ *      Get indicator which ASIC had received high priority traffic or not
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      pIndicator  - Have received high priority traffic indicator. If 1 means ASCI had received high priority in 1second checking priod
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicGreenHighPriorityTraffic(rtk_uint32 port, rtk_uint32* pIndicator)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_HIGHPRI_INDICATOR, port, pIndicator);
+}
+
+/*
+@func rtk_int32 | rtl8367c_setAsicGreenEthernet | Set green ethernet function.
+@parm rtk_uint32 | green | Green feature function usage 1:enable 0:disable.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@comm
+    The API can set Green Ethernet function to reduce power consumption. While green feature is enabled, ASIC will automatic
+ detect the cable length and then select different power mode for best performance with minimums power consumption. Link down
+ ports will enter power savining mode in 10 seconds after the cable disconnected if power saving function is enabled.
+*/
+ret_t rtl8367c_setAsicGreenEthernet(rtk_uint32 port, rtk_uint32 green)
+{
+    ret_t retVal;
+    rtk_uint32 checkCounter;
+    rtk_uint32 regData;
+    rtk_uint32 phy_status;
+    rtk_uint32 patchData[6][2] = { {0x809A, 0x8911}, {0x80A3, 0x9233}, {0x80AC, 0xA444}, {0x809F, 0x6B20}, {0x80A8, 0x6B22}, {0x80B1, 0x6B23} };
+    rtk_uint32 idx;
+    rtk_uint32 data;
+
+    if (green > 1)
+        return RT_ERR_INPUT;
+
+    /* 0xa420[2:0] */
+    if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xA420, &regData)) != RT_ERR_OK)
+        return retVal;
+    phy_status = (regData & 0x0007);
+
+    if(phy_status == 3)
+    {
+        /* 0xb820[4] = 1 */
+        if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xB820, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        regData |= (0x0001 << 4);
+
+        if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xB820, regData)) != RT_ERR_OK)
+            return retVal;
+
+        /* wait 0xb800[6] = 1 */
+        checkCounter = 100;
+        while(checkCounter)
+        {
+            retVal = rtl8367c_getAsicPHYOCPReg(port, 0xB800, &regData);
+            if( (retVal != RT_ERR_OK) || ((regData & 0x0040) != 0x0040) )
+            {
+                checkCounter --;
+                if(0 == checkCounter)
+                    return RT_ERR_BUSYWAIT_TIMEOUT;
+            }
+            else
+                checkCounter = 0;
+        }
+    }
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &data)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    switch (data)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            if(green)
+            {
+                for(idx = 0; idx < 6; idx++ )
+                {
+                    if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xA436, patchData[idx][0])) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xA438, patchData[idx][1])) != RT_ERR_OK)
+                        return retVal;
+                }
+            }
+            break;
+        default:
+            break;;
+    }
+
+
+
+    /* 0xa436 = 0x8011 */
+    if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xA436, 0x8011)) != RT_ERR_OK)
+        return retVal;
+
+    /* wr 0xa438[15] = 0: disable, 1: enable */
+    if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xA438, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if(green)
+        regData |= 0x8000;
+    else
+        regData &= 0x7FFF;
+
+    if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xA438, regData)) != RT_ERR_OK)
+        return retVal;
+
+    if(phy_status == 3)
+    {
+        /* 0xb820[4] = 0  */
+        if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xB820, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        regData &= ~(0x0001 << 4);
+
+        if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xB820, regData)) != RT_ERR_OK)
+            return retVal;
+
+        /* wait 0xb800[6] = 0 */
+        checkCounter = 100;
+        while(checkCounter)
+        {
+            retVal = rtl8367c_getAsicPHYOCPReg(port, 0xB800, &regData);
+            if( (retVal != RT_ERR_OK) || ((regData & 0x0040) != 0x0000) )
+            {
+                checkCounter --;
+                if(0 == checkCounter)
+                    return RT_ERR_BUSYWAIT_TIMEOUT;
+            }
+            else
+                checkCounter = 0;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/*
+@func rtk_int32 | rtl8367c_getAsicGreenEthernet | Get green ethernet function.
+@parm rtk_uint32 | *green | Green feature function usage 1:enable 0:disable.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@comm
+    The API can set Green Ethernet function to reduce power consumption. While green feature is enabled, ASIC will automatic
+ detect the cable length and then select different power mode for best performance with minimums power consumption. Link down
+ ports will enter power savining mode in 10 seconds after the cable disconnected if power saving function is enabled.
+*/
+ret_t rtl8367c_getAsicGreenEthernet(rtk_uint32 port, rtk_uint32* green)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    /* 0xa436 = 0x8011 */
+    if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xA436, 0x8011)) != RT_ERR_OK)
+        return retVal;
+
+    /* wr 0xa438[15] = 0: disable, 1: enable */
+    if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xA438, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if(regData & 0x8000)
+        *green = ENABLED;
+    else
+        *green = DISABLED;
+
+    return RT_ERR_OK;
+}
+
+
+/*
+@func ret_t | rtl8367c_setAsicPowerSaving | Set power saving mode
+@parm rtk_uint32 | phy | phy number
+@parm rtk_uint32 | enable | enable power saving mode.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_PORT_ID | Invalid port number.
+@comm
+    The API can set power saving mode per phy.
+*/
+ret_t rtl8367c_setAsicPowerSaving(rtk_uint32 phy, rtk_uint32 enable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 phyData;
+    rtk_uint32 regData;
+    rtk_uint32 phy_status;
+    rtk_uint32 checkCounter;
+
+    if (enable > 1)
+        return RT_ERR_INPUT;
+
+    /* 0xa420[2:0] */
+    if((retVal = rtl8367c_getAsicPHYOCPReg(phy, 0xA420, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    phy_status = (regData & 0x0007);
+
+    if(phy_status == 3)
+    {
+        /* 0xb820[4] = 1 */
+        if((retVal = rtl8367c_getAsicPHYOCPReg(phy, 0xB820, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        regData |= (0x0001 << 4);
+
+        if((retVal = rtl8367c_setAsicPHYOCPReg(phy, 0xB820, regData)) != RT_ERR_OK)
+            return retVal;
+
+        /* wait 0xb800[6] = 1 */
+        checkCounter = 100;
+        while(checkCounter)
+        {
+            retVal = rtl8367c_getAsicPHYOCPReg(phy, 0xB800, &regData);
+            if( (retVal != RT_ERR_OK) || ((regData & 0x0040) != 0x0040) )
+            {
+                checkCounter --;
+                if(0 == checkCounter)
+                {
+                     return RT_ERR_BUSYWAIT_TIMEOUT;
+                }
+            }
+            else
+                checkCounter = 0;
+        }
+    }
+
+    if ((retVal = rtl8367c_getAsicPHYReg(phy,PHY_POWERSAVING_REG,&phyData))!=RT_ERR_OK)
+        return retVal;
+
+    phyData = phyData & ~(0x0001 << 2);
+    phyData = phyData | (enable << 2);
+
+    if ((retVal = rtl8367c_setAsicPHYReg(phy,PHY_POWERSAVING_REG,phyData))!=RT_ERR_OK)
+        return retVal;
+
+    if(phy_status == 3)
+    {
+        /* 0xb820[4] = 0  */
+        if((retVal = rtl8367c_getAsicPHYOCPReg(phy, 0xB820, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        regData &= ~(0x0001 << 4);
+
+        if((retVal = rtl8367c_setAsicPHYOCPReg(phy, 0xB820, regData)) != RT_ERR_OK)
+            return retVal;
+
+        /* wait 0xb800[6] = 0 */
+        checkCounter = 100;
+        while(checkCounter)
+        {
+            retVal = rtl8367c_getAsicPHYOCPReg(phy, 0xB800, &regData);
+            if( (retVal != RT_ERR_OK) || ((regData & 0x0040) != 0x0000) )
+            {
+                checkCounter --;
+                if(0 == checkCounter)
+                {
+                    return RT_ERR_BUSYWAIT_TIMEOUT;
+                }
+            }
+            else
+                checkCounter = 0;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/*
+@func ret_t | rtl8367c_getAsicPowerSaving | Get power saving mode
+@parm rtk_uint32 | port | The port number
+@parm rtk_uint32* | enable | enable power saving mode.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_PORT_ID | Invalid port number.
+@comm
+    The API can get power saving mode per phy.
+*/
+ret_t rtl8367c_getAsicPowerSaving(rtk_uint32 phy, rtk_uint32* enable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 phyData;
+
+    if(NULL == enable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPHYReg(phy,PHY_POWERSAVING_REG,&phyData))!=RT_ERR_OK)
+        return retVal;
+
+    if ((phyData & 0x0004) > 0)
+        *enable = 1;
+    else
+        *enable = 0;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_hsb.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_hsb.c
new file mode 100644
index 0000000000000..435368d51b8af
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_hsb.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Field selector related functions
+ *
+ */
+#include <rtl8367c_asicdrv_hsb.h>
+/* Function Name:
+ *      rtl8367c_setAsicFieldSelector
+ * Description:
+ *      Set user defined field selectors in HSB
+ * Input:
+ *      index       - index of field selector 0-15
+ *      format      - Format of field selector
+ *      offset      - Retrieving data offset
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      System support 16 user defined field selctors.
+ *      Each selector can be enabled or disable. User can defined retrieving 16-bits in many predefiend
+ *      standard l2/l3/l4 payload.
+ */
+ret_t rtl8367c_setAsicFieldSelector(rtk_uint32 index, rtk_uint32 format, rtk_uint32 offset)
+{
+    rtk_uint32 regData;
+
+    if(index > RTL8367C_FIELDSEL_FORMAT_NUMBER)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(format >= FIELDSEL_FORMAT_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    regData = (((format << RTL8367C_FIELD_SELECTOR_FORMAT_OFFSET) & RTL8367C_FIELD_SELECTOR_FORMAT_MASK ) |
+               ((offset << RTL8367C_FIELD_SELECTOR_OFFSET_OFFSET) & RTL8367C_FIELD_SELECTOR_OFFSET_MASK ));
+
+    return rtl8367c_setAsicReg(RTL8367C_FIELD_SELECTOR_REG(index), regData);
+}
+/* Function Name:
+ *      rtl8367c_getAsicFieldSelector
+ * Description:
+ *      Get user defined field selectors in HSB
+ * Input:
+ *      index       - index of field selector 0-15
+ *      pFormat     - Format of field selector
+ *      pOffset     - Retrieving data offset
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicFieldSelector(rtk_uint32 index, rtk_uint32* pFormat, rtk_uint32* pOffset)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_FIELD_SELECTOR_REG(index), &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pFormat    = ((regData & RTL8367C_FIELD_SELECTOR_FORMAT_MASK) >> RTL8367C_FIELD_SELECTOR_FORMAT_OFFSET);
+    *pOffset    = ((regData & RTL8367C_FIELD_SELECTOR_OFFSET_MASK) >> RTL8367C_FIELD_SELECTOR_OFFSET_OFFSET);
+
+    return RT_ERR_OK;
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_i2c.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_i2c.c
new file mode 100644
index 0000000000000..69f20a0188b5a
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_i2c.c
@@ -0,0 +1,474 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 38651 $
+ * $Date: 2016-02-27 14:32:56 +0800 (周三, 17 四月 2016) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : I2C related functions
+ *
+ */
+
+
+#include <rtl8367c_asicdrv_i2c.h>
+#include <rtk_error.h>
+#include <rtk_types.h>
+
+
+
+/* Function Name:
+ *      rtl8367c_setAsicI2C_checkBusIdle
+ * Description:
+ *      Check i2c bus status idle or not
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                - Success
+ *      RT_ERR_BUSYWAIT_TIMEOUT  - i2c bus is busy
+ * Note:
+ *      This API can check i2c bus status.
+ */
+ret_t rtl8367c_setAsicI2C_checkBusIdle(void)
+{
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_M_I2C_BUS_IDLE_OFFSET, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if(regData == 0x0001)
+        return RT_ERR_OK; /*i2c is idle*/
+    else
+        return RT_ERR_BUSYWAIT_TIMEOUT; /*i2c is busy*/
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicI2CStartCmd
+ * Description:
+ *      Set I2C start command
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                - Success
+ * Note:
+ *      This API can set i2c start command ,start a i2c traffic  .
+ */
+ret_t rtl8367c_setAsicI2CStartCmd(void)
+{
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    /* Bits [4-1] = 0b0000, Start Command; Bit [0] = 1, Trigger the Command */
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData &= 0xFFE0;
+    regData |= 0x0001;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
+        return retVal;
+
+    /* wait for command finished */
+    do{
+       if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
+            return retVal;
+    }while( regData != 0x0);
+
+    return RT_ERR_OK ;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicI2CStopCmd
+ * Description:
+ *      Set I2C stop command
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                - Success
+ * Note:
+ *      This API can set i2c stop command ,stop a i2c traffic.
+ */
+ret_t rtl8367c_setAsicI2CStopCmd(void)
+{
+
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    /* Bits [4-1] = 0b0001, Stop Command; Bit [0] = 1, Trigger the Command */
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData &= 0xFFE0;
+    regData |= 0x0003;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
+        return retVal;
+
+
+    /* wait for command finished */
+    do{
+       if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
+            return retVal;
+    }while( regData != 0x0);
+
+    return RT_ERR_OK ;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicI2CTxOneCharCmd
+ * Description:
+ *      Set I2C Tx a char command, with a 8-bit data
+ * Input:
+ *      oneChar - 8-bit data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                - Success
+ * Note:
+ *      This API can set i2c Tx command and with a 8-bit data.
+ */
+ret_t rtl8367c_setAsicI2CTxOneCharCmd(rtk_uint8 oneChar)
+{
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    /* Bits [4-1] = 0b0010, tx one char; Bit [0] = 1, Trigger the Command */
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    regData &= 0xFFE0;
+    regData |= 0x0005;
+    regData &= 0x00FF;
+    regData |= (rtk_uint16) (oneChar << 8);
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
+        return retVal;
+
+
+   /* wait for command finished */
+    do{
+       if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
+            return retVal;
+    }while( regData != 0x0);
+
+    return RT_ERR_OK ;
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicI2CcheckRxAck
+ * Description:
+ *      Check if rx an Ack
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                - Success
+ * Note:
+ *      This API can check if rx an ack from i2c slave.
+ */
+ret_t rtl8367c_setAsicI2CcheckRxAck(void)
+{
+    rtk_uint32 regData;
+    ret_t retVal;
+    rtk_uint32 count = 0;
+
+    do{
+         count++;
+         if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_SLV_ACK_FLAG_OFFSET, &regData)) != RT_ERR_OK)
+            return retVal;
+    }while( (regData != 0x1) && (count < TIMEROUT_FOR_MICROSEMI) );
+
+    if(regData != 0x1)
+        return RT_ERR_FAILED;
+    else
+        return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicI2CRxOneCharCmd
+ * Description:
+ *      Set I2C Rx command and get 8-bit data
+ * Input:
+ *      None
+ * Output:
+ *      pValue - 8bit-data
+ * Return:
+ *      RT_ERR_OK                - Success
+ * Note:
+ *      This API can set I2C Rx command and get 8-bit data.
+ */
+ret_t rtl8367c_setAsicI2CRxOneCharCmd(rtk_uint8 *pValue)
+{
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    /* Bits [4-1] = 0b0011, Rx one char; Bit [0] = 1, Trigger the Command */
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData &= 0xFFE0;
+    regData |= 0x0007;
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
+        return retVal;
+
+    /* wait for command finished */
+     do{
+        if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
+             return retVal;
+     }while( (regData & 0x1) != 0x0);
+
+    *pValue = (rtk_uint8)(regData >> 8);
+     return RT_ERR_OK ;
+
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicI2CTxAckCmd
+ * Description:
+ *      Set I2C Tx ACK command
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                - Success
+ * Note:
+ *      This API can set I2C Tx ack command.
+ */
+ret_t rtl8367c_setAsicI2CTxAckCmd(void)
+{
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    /* Bits [4-1] = 0b0100, tx ACK Command; Bit [0] = 1, Trigger the Command */
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData &= 0xFFE0;
+    regData |= 0x0009;
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
+        return retVal;
+
+     /* wait for command finished */
+    do{
+       if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
+            return retVal;
+    }while( regData != 0x0);
+
+    return RT_ERR_OK ;
+
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicI2CTxNoAckCmd
+ * Description:
+ *      Set I2C master Tx noACK command
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                - Success
+ * Note:
+ *      This API can set I2C master Tx noACK command.
+ */
+ret_t rtl8367c_setAsicI2CTxNoAckCmd(void)
+{
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    /* Bits [4-1] = 0b0101, tx noACK Command; Bit [0] = 1, Trigger the Command */
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData &= 0xFFE0;
+    regData |= 0x000b;
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
+        return retVal;
+
+     /* wait for command finished */
+    do{
+       if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
+            return retVal;
+    }while( regData != 0x0);
+
+    return RT_ERR_OK ;
+
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicI2CSoftRSTseqCmd
+ * Description:
+ *      set I2C master tx soft reset command
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                - Success
+ * Note:
+ *      This API can set I2C master tx soft reset command.
+ */
+ret_t rtl8367c_setAsicI2CSoftRSTseqCmd(void)
+{
+
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    /*Bits [4-1] = 0b0110, tx soft reset Command;  Bit [0] = 1, Trigger the Command */
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData &= 0xFFE0;
+    regData |= 0x000d;
+
+    if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_CTL_STA_REG, regData)) != RT_ERR_OK)
+        return retVal;
+
+
+    /* wait for command finished */
+    do{
+       if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_M_I2C_CTL_STA_REG, RTL8367C_I2C_CMD_EXEC_OFFSET, &regData)) != RT_ERR_OK)
+            return retVal;
+    }while( regData != 0x0);
+
+    return RT_ERR_OK ;
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicI2CGpioPinGroup
+ * Description:
+ *      set I2C function used gpio pins
+ * Input:
+ *      pinGroup_ID - gpio pins group
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                - Success
+ *      RT_ERR_INPUT             _ Invalid input parameter
+ * Note:
+ *      This API can set I2C function used gpio pins.
+ *      There are three group gpio pins
+ */
+ret_t rtl8367c_setAsicI2CGpioPinGroup(rtk_uint32 pinGroup_ID)
+{
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, &regData)) != RT_ERR_OK)
+         return retVal;
+    if( pinGroup_ID==0 )
+    {
+        regData &= 0x0FFF;
+        regData |= 0x5000;
+
+        if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, regData)) != RT_ERR_OK)
+             return retVal;
+    }
+
+    else if( pinGroup_ID==1 )
+    {
+        regData &= 0x0FFF;
+        regData |= 0xA000;
+
+        if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, regData)) != RT_ERR_OK)
+             return retVal;
+    }
+
+    else if( pinGroup_ID==2 )
+    {
+        regData &= 0x0FFF;
+        regData |= 0xF000;
+
+        if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, regData)) != RT_ERR_OK)
+             return retVal;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    return RT_ERR_OK ;
+
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicI2CGpioPinGroup
+ * Description:
+ *      set I2C function used gpio pins
+ * Input:
+ *      pinGroup_ID - gpio pins group
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                - Success
+ *      RT_ERR_INPUT             _ Invalid input parameter
+ * Note:
+ *      This API can set I2C function used gpio pins.
+ *      There are three group gpio pins
+ */
+ret_t rtl8367c_getAsicI2CGpioPinGroup(rtk_uint32 * pPinGroup_ID)
+{
+
+    rtk_uint32 regData;
+    ret_t retVal;
+    if( (retVal = rtl8367c_getAsicReg(RTL8367C_REG_M_I2C_SYS_CTL, &regData)) != RT_ERR_OK)
+        return retVal;
+    regData &= 0xF000 ;
+    regData = (regData >> 12);
+
+    if( regData == 0x5 )
+        *pPinGroup_ID = 0;
+    else if(regData == 0xA)
+        *pPinGroup_ID = 1;
+    else if(regData == 0xF)
+        *pPinGroup_ID = 2;
+    else
+       return RT_ERR_FAILED;
+    return RT_ERR_OK ;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_igmp.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_igmp.c
new file mode 100644
index 0000000000000..e0e734d61edac
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_igmp.c
@@ -0,0 +1,2109 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : IGMP related functions
+ *
+ */
+#include <rtl8367c_asicdrv_igmp.h>
+/* Function Name:
+ *      rtl8367c_setAsicIgmp
+ * Description:
+ *      Set IGMP/MLD state
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIgmp(rtk_uint32 enabled)
+{
+    ret_t retVal;
+
+    /* Enable/Disable H/W IGMP/MLD */
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_EN_OFFSET, enabled);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicIgmp
+ * Description:
+ *      Get IGMP/MLD state
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIgmp(rtk_uint32 *ptr_enabled)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_EN_OFFSET, ptr_enabled);
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicIpMulticastVlanLeaky
+ * Description:
+ *      Set IP multicast VLAN Leaky function
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      When enabling this function,
+ *      if the lookup result(forwarding portmap) of IP Multicast packet is over VLAN boundary,
+ *      the packet can be forwarded across VLAN
+ */
+ret_t rtl8367c_setAsicIpMulticastVlanLeaky(rtk_uint32 port, rtk_uint32 enabled)
+{
+    ret_t  retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IPMCAST_VLAN_LEAKY, port, enabled);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicIpMulticastVlanLeaky
+ * Description:
+ *      Get IP multicast VLAN Leaky function
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIpMulticastVlanLeaky(rtk_uint32 port, rtk_uint32 *ptr_enabled)
+{
+    ret_t  retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IPMCAST_VLAN_LEAKY, port, ptr_enabled);
+
+    return retVal;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPTableFullOP
+ * Description:
+ *      Set Table Full operation
+ * Input:
+ *      operation   - The operation should be taken when the IGMP table is full.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter is out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPTableFullOP(rtk_uint32 operation)
+{
+    ret_t  retVal;
+
+    if(operation >= TABLE_FULL_OP_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    /* Table full Operation */
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG1, RTL8367C_TABLE_FULL_OP_MASK, operation);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPTableFullOP
+ * Description:
+ *      Get Table Full operation
+ * Input:
+ *      None
+ * Output:
+ *      poperation  - The operation should be taken when the IGMP table is full.
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPTableFullOP(rtk_uint32 *poperation)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    /* Table full Operation */
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG1, RTL8367C_TABLE_FULL_OP_MASK, &value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *poperation = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPCRCErrOP
+ * Description:
+ *      Set the operation when ASIC receive a Checksum error packet
+ * Input:
+ *      operation   -The operation when ASIC receive a Checksum error packet
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter is out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPCRCErrOP(rtk_uint32 operation)
+{
+    ret_t  retVal;
+
+    if(operation >= CRC_ERR_OP_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    /* CRC Error Operation */
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_CKS_ERR_OP_MASK, operation);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPCRCErrOP
+ * Description:
+ *      Get the operation when ASIC receive a Checksum error packet
+ * Input:
+ *      None
+ * Output:
+ *      poperation  - The operation of Checksum error packet
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPCRCErrOP(rtk_uint32 *poperation)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    /* CRC Error Operation */
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_CKS_ERR_OP_MASK, &value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *poperation = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPFastLeaveEn
+ * Description:
+ *      Enable/Disable Fast Leave
+ * Input:
+ *      enabled - 1:enable Fast Leave; 0:disable Fast Leave
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPFastLeaveEn(rtk_uint32 enabled)
+{
+    ret_t  retVal;
+
+    /* Fast Leave */
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_FAST_LEAVE_EN_MASK, (enabled >= 1) ? 1 : 0);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPFastLeaveEn
+ * Description:
+ *      Get Fast Leave state
+ * Input:
+ *      None
+ * Output:
+ *      penabled        - 1:enable Fast Leave; 0:disable Fast Leave
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPFastLeaveEn(rtk_uint32 *penabled)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    /* Fast Leave */
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_FAST_LEAVE_EN_MASK, &value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *penabled = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPLeaveTimer
+ * Description:
+ *      Set the Leave timer of IGMP/MLD
+ * Input:
+ *      leave_timer     - Leave timer
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter is out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPLeaveTimer(rtk_uint32 leave_timer)
+{
+    ret_t  retVal;
+
+    if(leave_timer > RTL8367C_MAX_LEAVE_TIMER)
+        return RT_ERR_OUT_OF_RANGE;
+
+    /* Leave timer */
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_LEAVE_TIMER_MASK, leave_timer);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPLeaveTimer
+ * Description:
+ *      Get the Leave timer of IGMP/MLD
+ * Input:
+ *      None
+ * Output:
+ *      pleave_timer    - Leave timer
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPLeaveTimer(rtk_uint32 *pleave_timer)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    /* Leave timer */
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_LEAVE_TIMER_MASK, &value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pleave_timer = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPQueryInterval
+ * Description:
+ *      Set Query Interval of IGMP/MLD
+ * Input:
+ *      interval    - Query Interval
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter is out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPQueryInterval(rtk_uint32 interval)
+{
+    ret_t  retVal;
+
+    if(interval > RTL8367C_MAX_QUERY_INT)
+        return RT_ERR_OUT_OF_RANGE;
+
+    /* Query Interval */
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_IGMP_MLD_CFG2, interval);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPQueryInterval
+ * Description:
+ *      Get Query Interval of IGMP/MLD
+ * Input:
+ *      None
+ * Output:
+ *      pinterval       - Query Interval
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPQueryInterval(rtk_uint32 *pinterval)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    /* Query Interval */
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_IGMP_MLD_CFG2, &value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pinterval = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPRobVar
+ * Description:
+ *      Set Robustness Variable of IGMP/MLD
+ * Input:
+ *      rob_var     - Robustness Variable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter is out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPRobVar(rtk_uint32 rob_var)
+{
+    ret_t  retVal;
+
+    if(rob_var > RTL8367C_MAX_ROB_VAR)
+        return RT_ERR_OUT_OF_RANGE;
+
+    /* Bourstness variable */
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_ROBURSTNESS_VAR_MASK, rob_var);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPRobVar
+ * Description:
+ *      Get Robustness Variable of IGMP/MLD
+ * Input:
+ *      none
+ * Output:
+ *      prob_var     - Robustness Variable
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPRobVar(rtk_uint32 *prob_var)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    /* Bourstness variable */
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_ROBURSTNESS_VAR_MASK, &value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *prob_var = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPStaticRouterPort
+ * Description:
+ *      Set IGMP static router port mask
+ * Input:
+ *      pmsk    - Static portmask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid port mask
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPStaticRouterPort(rtk_uint32 pmsk)
+{
+    if(pmsk > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_STATIC_ROUTER_PORT, RTL8367C_IGMP_STATIC_ROUTER_PORT_MASK, pmsk);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPStaticRouterPort
+ * Description:
+ *      Get IGMP static router port mask
+ * Input:
+ *      pmsk    - Static portmask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPStaticRouterPort(rtk_uint32 *pmsk)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_STATIC_ROUTER_PORT, RTL8367C_IGMP_STATIC_ROUTER_PORT_MASK, pmsk);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPAllowDynamicRouterPort
+ * Description:
+ *      Set IGMP dynamic router port allow mask
+ * Input:
+ *      pmsk    - Allow dynamic router port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid port mask
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPAllowDynamicRouterPort(rtk_uint32 pmsk)
+{
+    return rtl8367c_setAsicReg(RTL8367C_REG_IGMP_MLD_CFG4, pmsk);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPAllowDynamicRouterPort
+ * Description:
+ *      Get IGMP dynamic router port allow mask
+ * Input:
+ *      None.
+ * Output:
+ *      pPmsk   - Allow dynamic router port mask
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid port mask
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPAllowDynamicRouterPort(rtk_uint32 *pPmsk)
+{
+    return rtl8367c_getAsicReg(RTL8367C_REG_IGMP_MLD_CFG4, pPmsk);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPdynamicRouterPort1
+ * Description:
+ *      Get 1st dynamic router port and timer
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      timer   - router port timer
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPdynamicRouterPort1(rtk_uint32 *port, rtk_uint32 *timer)
+{
+    ret_t   retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_DYNAMIC_ROUTER_PORT, RTL8367C_D_ROUTER_PORT_1_MASK, port);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_DYNAMIC_ROUTER_PORT, RTL8367C_D_ROUTER_PORT_TMR_1_MASK, timer);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPdynamicRouterPort2
+ * Description:
+ *      Get 2nd dynamic router port and timer
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      timer   - router port timer
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPdynamicRouterPort2(rtk_uint32 *port, rtk_uint32 *timer)
+{
+    ret_t   retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_DYNAMIC_ROUTER_PORT, RTL8367C_D_ROUTER_PORT_2_MASK, port);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_DYNAMIC_ROUTER_PORT, RTL8367C_D_ROUTER_PORT_TMR_2_MASK, timer);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPSuppression
+ * Description:
+ *      Set the suppression function
+ * Input:
+ *      report_supp_enabled     - Report suppression, 1:Enable, 0:disable
+ *      leave_supp_enabled      - Leave suppression, 1:Enable, 0:disable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPSuppression(rtk_uint32 report_supp_enabled, rtk_uint32 leave_supp_enabled)
+{
+    ret_t   retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_REPORT_SUPPRESSION_MASK, report_supp_enabled);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_LEAVE_SUPPRESSION_MASK, leave_supp_enabled);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPSuppression
+ * Description:
+ *      Get the suppression function
+ * Input:
+ *      report_supp_enabled     - Report suppression, 1:Enable, 0:disable
+ *      leave_supp_enabled      - Leave suppression, 1:Enable, 0:disable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPSuppression(rtk_uint32 *report_supp_enabled, rtk_uint32 *leave_supp_enabled)
+{
+    ret_t   retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_REPORT_SUPPRESSION_MASK, report_supp_enabled);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_LEAVE_SUPPRESSION_MASK, leave_supp_enabled);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPQueryRX
+ * Description:
+ *      Set port-based Query packet RX allowance
+ * Input:
+ *      port            - port number
+ *      allow_query     - allowance of Query packet RX, 1:Allow, 0:Drop
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPQueryRX(rtk_uint32 port, rtk_uint32 allow_query)
+{
+    ret_t   retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    /* Allow Query */
+    if (port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_QUERY_MASK, allow_query);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_QUERY_MASK, allow_query);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPQueryRX
+ * Description:
+ *      Get port-based Query packet RX allowance
+ * Input:
+ *      port            - port number
+ * Output:
+ *      allow_query     - allowance of Query packet RX, 1:Allow, 0:Drop
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPQueryRX(rtk_uint32 port, rtk_uint32 *allow_query)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    /* Allow Query */
+    if (port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_QUERY_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_QUERY_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    *allow_query = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPReportRX
+ * Description:
+ *      Set port-based Report packet RX allowance
+ * Input:
+ *      port            - port number
+ *      allow_report    - allowance of Report packet RX, 1:Allow, 0:Drop
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPReportRX(rtk_uint32 port, rtk_uint32 allow_report)
+{
+    ret_t   retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+    {
+    /* Allow Report */
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_REPORT_MASK, allow_report);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_REPORT_MASK, allow_report);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPReportRX
+ * Description:
+ *      Get port-based Report packet RX allowance
+ * Input:
+ *      port            - port number
+ * Output:
+ *      allow_report    - allowance of Report packet RX, 1:Allow, 0:Drop
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPReportRX(rtk_uint32 port, rtk_uint32 *allow_report)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+    {
+        /* Allow Report */
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_REPORT_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_REPORT_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    *allow_report = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPLeaveRX
+ * Description:
+ *      Set port-based Leave packet RX allowance
+ * Input:
+ *      port            - port number
+ *      allow_leave     - allowance of Leave packet RX, 1:Allow, 0:Drop
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPLeaveRX(rtk_uint32 port, rtk_uint32 allow_leave)
+{
+    ret_t   retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+    {
+        /* Allow Leave */
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_LEAVE_MASK, allow_leave);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_LEAVE_MASK, allow_leave);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPLeaveRX
+ * Description:
+ *      Get port-based Leave packet RX allowance
+ * Input:
+ *      port            - port number
+ * Output:
+ *      allow_leave     - allowance of Leave packet RX, 1:Allow, 0:Drop
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPLeaveRX(rtk_uint32 port, rtk_uint32 *allow_leave)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+    {
+    /* Allow Leave */
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_LEAVE_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_LEAVE_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    *allow_leave = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPMRPRX
+ * Description:
+ *      Set port-based Multicast Routing Protocol packet RX allowance
+ * Input:
+ *      port            - port number
+ *      allow_mrp       - allowance of Multicast Routing Protocol packet RX, 1:Allow, 0:Drop
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPMRPRX(rtk_uint32 port, rtk_uint32 allow_mrp)
+{
+    ret_t   retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+    {
+    /* Allow Multicast Routing Protocol */
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MRP_MASK, allow_mrp);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MRP_MASK, allow_mrp);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPMRPRX
+ * Description:
+ *      Get port-based Multicast Routing Protocol packet RX allowance
+ * Input:
+ *      port            - port number
+ * Output:
+ *      allow_mrp       - allowance of Multicast Routing Protocol packet RX, 1:Allow, 0:Drop
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPMRPRX(rtk_uint32 port, rtk_uint32 *allow_mrp)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    /* Allow Multicast Routing Protocol */
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MRP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MRP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    *allow_mrp = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPMcDataRX
+ * Description:
+ *      Set port-based Multicast data packet RX allowance
+ * Input:
+ *      port            - port number
+ *      allow_mcdata    - allowance of Multicast data packet RX, 1:Allow, 0:Drop
+ * Output:
+ *      none
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPMcDataRX(rtk_uint32 port, rtk_uint32 allow_mcdata)
+{
+    ret_t   retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    /* Allow Multicast Data */
+    if(port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MC_DATA_MASK, allow_mcdata);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MC_DATA_MASK, allow_mcdata);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPMcDataRX
+ * Description:
+ *      Get port-based Multicast data packet RX allowance
+ * Input:
+ *      port            - port number
+ * Output:
+ *      allow_mcdata    - allowance of Multicast data packet RX, 1:Allow, 0:Drop
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPMcDataRX(rtk_uint32 port, rtk_uint32 *allow_mcdata)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    /* Allow Multicast data */
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MC_DATA_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_ALLOW_MC_DATA_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    *allow_mcdata = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPv1Opeartion
+ * Description:
+ *      Set port-based IGMPv1 Control packet action
+ * Input:
+ *      port            - port number
+ *      igmpv1_op       - IGMPv1 control packet action
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPv1Opeartion(rtk_uint32 port, rtk_uint32 igmpv1_op)
+{
+    ret_t   retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(igmpv1_op >= PROTOCOL_OP_END)
+        return RT_ERR_INPUT;
+
+    /* IGMPv1 operation */
+    if(port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV1_OP_MASK, igmpv1_op);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV1_OP_MASK, igmpv1_op);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPv1Opeartion
+ * Description:
+ *      Get port-based IGMPv1 Control packet action
+ * Input:
+ *      port            - port number
+ * Output:
+ *      igmpv1_op       - IGMPv1 control packet action
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPv1Opeartion(rtk_uint32 port, rtk_uint32 *igmpv1_op)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    /* IGMPv1 operation */
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV1_OP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV1_OP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    *igmpv1_op = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPv2Opeartion
+ * Description:
+ *      Set port-based IGMPv2 Control packet action
+ * Input:
+ *      port            - port number
+ *      igmpv2_op       - IGMPv2 control packet action
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPv2Opeartion(rtk_uint32 port, rtk_uint32 igmpv2_op)
+{
+    ret_t   retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(igmpv2_op >= PROTOCOL_OP_END)
+        return RT_ERR_INPUT;
+
+    /* IGMPv2 operation */
+    if(port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV2_OP_MASK, igmpv2_op);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV2_OP_MASK, igmpv2_op);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPv2Opeartion
+ * Description:
+ *      Get port-based IGMPv2 Control packet action
+ * Input:
+ *      port            - port number
+ * Output:
+ *      igmpv2_op       - IGMPv2 control packet action
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPv2Opeartion(rtk_uint32 port, rtk_uint32 *igmpv2_op)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    /* IGMPv2 operation */
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV2_OP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV2_OP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    *igmpv2_op = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPv3Opeartion
+ * Description:
+ *      Set port-based IGMPv3 Control packet action
+ * Input:
+ *      port            - port number
+ *      igmpv3_op       - IGMPv3 control packet action
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPv3Opeartion(rtk_uint32 port, rtk_uint32 igmpv3_op)
+{
+    ret_t   retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(igmpv3_op >= PROTOCOL_OP_END)
+        return RT_ERR_INPUT;
+
+    /* IGMPv3 operation */
+    if(port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV3_OP_MASK, igmpv3_op);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV3_OP_MASK, igmpv3_op);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPv3Opeartion
+ * Description:
+ *      Get port-based IGMPv3 Control packet action
+ * Input:
+ *      port            - port number
+ * Output:
+ *      igmpv3_op       - IGMPv3 control packet action
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPv3Opeartion(rtk_uint32 port, rtk_uint32 *igmpv3_op)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    /* IGMPv3 operation */
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_IGMPV3_OP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_IGMPV3_OP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    *igmpv3_op = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicMLDv1Opeartion
+ * Description:
+ *      Set port-based MLDv1 Control packet action
+ * Input:
+ *      port            - port number
+ *      mldv1_op        - MLDv1 control packet action
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMLDv1Opeartion(rtk_uint32 port, rtk_uint32 mldv1_op)
+{
+    ret_t   retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(mldv1_op >= PROTOCOL_OP_END)
+        return RT_ERR_INPUT;
+
+    /* MLDv1 operation */
+    if(port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_MLDv1_OP_MASK, mldv1_op);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_MLDv1_OP_MASK, mldv1_op);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicMLDv1Opeartion
+ * Description:
+ *      Get port-based MLDv1 Control packet action
+ * Input:
+ *      port            - port number
+ * Output:
+ *      mldv1_op        - MLDv1 control packet action
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMLDv1Opeartion(rtk_uint32 port, rtk_uint32 *mldv1_op)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    /* MLDv1 operation */
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_MLDv1_OP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_MLDv1_OP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    *mldv1_op = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicMLDv2Opeartion
+ * Description:
+ *      Set port-based MLDv2 Control packet action
+ * Input:
+ *      port            - port number
+ *      mldv2_op        - MLDv2 control packet action
+ * Output:
+ *      none
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMLDv2Opeartion(rtk_uint32 port, rtk_uint32 mldv2_op)
+{
+    ret_t   retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(mldv2_op >= PROTOCOL_OP_END)
+        return RT_ERR_INPUT;
+
+    /* MLDv2 operation */
+    if(port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_MLDv2_OP_MASK, mldv2_op);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_MLDv2_OP_MASK, mldv2_op);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicMLDv2Opeartion
+ * Description:
+ *      Get port-based MLDv2 Control packet action
+ * Input:
+ *      port            - port number
+ * Output:
+ *      mldv2_op        - MLDv2 control packet action
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_PORT_ID  - Error PORT ID
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMLDv2Opeartion(rtk_uint32 port, rtk_uint32 *mldv2_op)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    /* MLDv2 operation */
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT0_CONTROL + port, RTL8367C_IGMP_PORT0_CONTROL_MLDv2_OP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT8_CONTROL + port - 8, RTL8367C_IGMP_PORT0_CONTROL_MLDv2_OP_MASK, &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    *mldv2_op = value;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPPortMAXGroup
+ * Description:
+ *      Set per-port Max group number
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      max_group   - max IGMP group
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPPortMAXGroup(rtk_uint32 port, rtk_uint32 max_group)
+{
+    ret_t retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(max_group > RTL8367C_IGMP_MAX_GOUP)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT01_MAX_GROUP + (port/2), RTL8367C_PORT0_MAX_GROUP_MASK << (RTL8367C_PORT1_MAX_GROUP_OFFSET * (port%2)), max_group);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_PORT89_MAX_GROUP + (port/2), RTL8367C_PORT0_MAX_GROUP_MASK << (RTL8367C_PORT1_MAX_GROUP_OFFSET * (port%2)), max_group);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicIGMPPortMAXGroup
+ * Description:
+ *      Get per-port Max group number
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      max_group   - max IGMP group
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPPortMAXGroup(rtk_uint32 port, rtk_uint32 *max_group)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT01_MAX_GROUP + (port/2), RTL8367C_PORT0_MAX_GROUP_MASK << (RTL8367C_PORT1_MAX_GROUP_OFFSET * (port%2)), &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT89_MAX_GROUP + (port/2), RTL8367C_PORT0_MAX_GROUP_MASK << (RTL8367C_PORT1_MAX_GROUP_OFFSET * (port%2)), &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    *max_group = value;
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicIGMPPortCurrentGroup
+ * Description:
+ *      Get per-port current group number
+ * Input:
+ *      port            - Physical port number (0~7)
+ *      current_group   - current IGMP group
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPPortCurrentGroup(rtk_uint32 port, rtk_uint32 *current_group)
+{
+    ret_t   retVal;
+    rtk_uint32  value;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT01_CURRENT_GROUP + (port/2), RTL8367C_PORT0_CURRENT_GROUP_MASK << (RTL8367C_PORT1_CURRENT_GROUP_OFFSET * (port%2)), &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_PORT89_CURRENT_GROUP + ((port - 8)/2), RTL8367C_PORT0_CURRENT_GROUP_MASK << (RTL8367C_PORT1_CURRENT_GROUP_OFFSET * (port%2)), &value);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    *current_group = value;
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicIGMPGroup
+ * Description:
+ *      Get IGMP group
+ * Input:
+ *      idx     - Group index (0~255)
+ *      valid   - valid bit
+ *      grp     - IGMP group
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - Group index is out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPGroup(rtk_uint32 idx, rtk_uint32 *valid, rtl8367c_igmpgroup *grp)
+{
+    ret_t   retVal;
+    rtk_uint32  regAddr, regData;
+    rtk_uint32  i;
+    rtk_uint32  groupInfo = 0;
+
+    if(idx > RTL8367C_IGMP_MAX_GOUP)
+        return RT_ERR_OUT_OF_RANGE;
+
+    /* Write ACS_ADR register for data bits */
+    regAddr = RTL8367C_TABLE_ACCESS_ADDR_REG;
+    regData = idx;
+    retVal = rtl8367c_setAsicReg(regAddr, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Write ACS_CMD register */
+    regAddr = RTL8367C_TABLE_ACCESS_CTRL_REG;
+    regData = RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_READ, TB_TARGET_IGMP_GROUP);
+    retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Read Data Bits */
+    regAddr = RTL8367C_TABLE_ACCESS_RDDATA_BASE;
+    for(i = 0 ;i <= 1; i++)
+    {
+        retVal = rtl8367c_getAsicReg(regAddr, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        groupInfo |= ((regData & 0xFFFF) << (i * 16));
+        regAddr ++;
+    }
+
+    grp->p0_timer = groupInfo & 0x00000007;
+    grp->p1_timer = (groupInfo >> 3) & 0x00000007;
+    grp->p2_timer = (groupInfo >> 6) & 0x00000007;
+    grp->p3_timer = (groupInfo >> 9) & 0x00000007;
+    grp->p4_timer = (groupInfo >> 12) & 0x00000007;
+    grp->p5_timer = (groupInfo >> 15) & 0x00000007;
+    grp->p6_timer = (groupInfo >> 18) & 0x00000007;
+    grp->p7_timer = (groupInfo >> 21) & 0x00000007;
+    grp->report_supp_flag = (groupInfo >> 24) & 0x00000001;
+    grp->p8_timer = (groupInfo >> 25) & 0x00000007;
+    grp->p9_timer = (groupInfo >> 28) & 0x00000007;
+    grp->p10_timer = (groupInfo >> 31) & 0x00000001;
+
+    regAddr = RTL8367C_TABLE_ACCESS_RDDATA_BASE + 2;
+    retVal = rtl8367c_getAsicReg(regAddr, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    grp->p10_timer |= (regData & 0x00000003) << 1;
+
+    /* Valid bit */
+    retVal = rtl8367c_getAsicReg(RTL8367C_IGMP_GROUP_USAGE_REG(idx), &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *valid = ((regData & (0x0001 << (idx %16))) != 0) ? 1 : 0;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicIpMulticastPortIsoLeaky
+ * Description:
+ *      Set IP multicast Port Isolation leaky
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIpMulticastPortIsoLeaky(rtk_uint32 port, rtk_uint32 enabled)
+{
+    ret_t   retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_IPMCAST_PORTISO_LEAKY_REG, (0x0001 << port), enabled);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIpMulticastPortIsoLeaky
+ * Description:
+ *      Get IP multicast Port Isolation leaky
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIpMulticastPortIsoLeaky(rtk_uint32 port, rtk_uint32 *enabled)
+{
+    ret_t   retVal;
+    rtk_uint32  regData;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_IPMCAST_PORTISO_LEAKY_REG, (0x0001 << port), &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *enabled = regData;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPReportLeaveFlood
+ * Description:
+ *      Set IGMP/MLD Report/Leave flood
+ * Input:
+ *      flood   - 0: Reserved, 1: flooding to router ports, 2: flooding to all ports, 3: flooding to router port or to all ports if there is no router port
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPReportLeaveFlood(rtk_uint32 flood)
+{
+    ret_t   retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG3, RTL8367C_REPORT_LEAVE_FORWARD_MASK, flood);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPReportLeaveFlood
+ * Description:
+ *      Get IGMP/MLD Report/Leave flood
+ * Input:
+ *      None
+ * Output:
+ *      pflood  - 0: Reserved, 1: flooding to router ports, 2: flooding to all ports, 3: flooding to router port or to all ports if there is no router port
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPReportLeaveFlood(rtk_uint32 *pFlood)
+{
+    ret_t   retVal;
+    rtk_uint32  regData;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_IGMP_MLD_CFG3, RTL8367C_REPORT_LEAVE_FORWARD_MASK, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pFlood = regData;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPDropLeaveZero
+ * Description:
+ *      Set the function of droppping Leave packet with group IP = 0.0.0.0
+ * Input:
+ *      drop    - 1: Drop, 0:Bypass
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPDropLeaveZero(rtk_uint32 drop)
+{
+    ret_t   retVal;
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG1, RTL8367C_DROP_LEAVE_ZERO_OFFSET, drop);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPDropLeaveZero
+ * Description:
+ *      Get the function of droppping Leave packet with group IP = 0.0.0.0
+ * Input:
+ *      None
+ * Output:
+ *      pDrop    - 1: Drop, 0:Bypass
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPDropLeaveZero(rtk_uint32 *pDrop)
+{
+    ret_t   retVal;
+    rtk_uint32  regData;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG1, RTL8367C_DROP_LEAVE_ZERO_OFFSET, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pDrop = regData;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPBypassStormCTRL
+ * Description:
+ *      Set the function of bypass strom control for IGMP/MLD packet
+ * Input:
+ *      bypass    - 1: Bypass, 0:not bypass
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPBypassStormCTRL(rtk_uint32 bypass)
+{
+    ret_t   retVal;
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_DISCARD_STORM_FILTER_OFFSET, bypass);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPBypassStormCTRL
+ * Description:
+ *      Set the function of bypass strom control for IGMP/MLD packet
+ * Input:
+ *      None
+ * Output:
+ *      pBypass    - 1: Bypass, 0:not bypass
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPBypassStormCTRL(rtk_uint32 *pBypass)
+{
+    ret_t   retVal;
+    rtk_uint32  regData;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_DISCARD_STORM_FILTER_OFFSET, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pBypass = regData;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPIsoLeaky
+ * Description:
+ *      Set Port Isolation leaky for IGMP/MLD packet
+ * Input:
+ *      leaky    - 1: Leaky, 0:not leaky
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPIsoLeaky(rtk_uint32 leaky)
+{
+    ret_t   retVal;
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_PORTISO_LEAKY_OFFSET, leaky);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPIsoLeaky
+ * Description:
+ *      Get Port Isolation leaky for IGMP/MLD packet
+ * Input:
+ *      Noen
+ * Output:
+ *      pLeaky    - 1: Leaky, 0:not leaky
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPIsoLeaky(rtk_uint32 *pLeaky)
+{
+    ret_t   retVal;
+    rtk_uint32  regData;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_PORTISO_LEAKY_OFFSET, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pLeaky = regData;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPVLANLeaky
+ * Description:
+ *      Set VLAN leaky for IGMP/MLD packet
+ * Input:
+ *      leaky    - 1: Leaky, 0:not leaky
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPVLANLeaky(rtk_uint32 leaky)
+{
+    ret_t   retVal;
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_VLAN_LEAKY_OFFSET, leaky);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPVLANLeaky
+ * Description:
+ *      Get VLAN leaky for IGMP/MLD packet
+ * Input:
+ *      Noen
+ * Output:
+ *      pLeaky    - 1: Leaky, 0:not leaky
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPVLANLeaky(rtk_uint32 *pLeaky)
+{
+    ret_t   retVal;
+    rtk_uint32  regData;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG0, RTL8367C_IGMP_MLD_VLAN_LEAKY_OFFSET, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pLeaky = regData;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicIGMPBypassGroup
+ * Description:
+ *      Set IGMP/MLD Bypass group
+ * Input:
+ *      bypassType  - Bypass type
+ *      enabled     - enabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicIGMPBypassGroup(rtk_uint32 bypassType, rtk_uint32 enabled)
+{
+    ret_t   retVal;
+    rtk_uint32 offset;
+
+    switch(bypassType)
+    {
+        case BYPASS_224_0_0_X:
+            offset = RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_0_OFFSET;
+            break;
+        case BYPASS_224_0_1_X:
+            offset = RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_1_OFFSET;
+            break;
+        case BYPASS_239_255_255_X:
+            offset = RTL8367C_IGMP_MLD_IP4_BYPASS_239_255_255_OFFSET;
+            break;
+        case BYPASS_IPV6_00XX:
+            offset = RTL8367C_IGMP_MLD_IP6_BYPASS_OFFSET;
+            break;
+        default:
+            return RT_ERR_INPUT;
+    }
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG3, offset, enabled);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicIGMPBypassGroup
+ * Description:
+ *      Get IGMP/MLD Bypass group
+ * Input:
+ *      bypassType  - Bypass type
+ * Output:
+ *      pEnabled    - enabled
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicIGMPBypassGroup(rtk_uint32 bypassType, rtk_uint32 *pEnabled)
+{
+    ret_t   retVal;
+    rtk_uint32 offset;
+
+    switch(bypassType)
+    {
+        case BYPASS_224_0_0_X:
+            offset = RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_0_OFFSET;
+            break;
+        case BYPASS_224_0_1_X:
+            offset = RTL8367C_IGMP_MLD_IP4_BYPASS_224_0_1_OFFSET;
+            break;
+        case BYPASS_239_255_255_X:
+            offset = RTL8367C_IGMP_MLD_IP4_BYPASS_239_255_255_OFFSET;
+            break;
+        case BYPASS_IPV6_00XX:
+            offset = RTL8367C_IGMP_MLD_IP6_BYPASS_OFFSET;
+            break;
+        default:
+            return RT_ERR_INPUT;
+    }
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_IGMP_MLD_CFG3, offset, pEnabled);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_inbwctrl.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_inbwctrl.c
new file mode 100644
index 0000000000000..abb36bec2dc5e
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_inbwctrl.c
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Ingress bandwidth control related functions
+ *
+ */
+#include <rtl8367c_asicdrv_inbwctrl.h>
+/* Function Name:
+ *      rtl8367c_setAsicPortIngressBandwidth
+ * Description:
+ *      Set per-port total ingress bandwidth
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      bandwidth   - The total ingress bandwidth (unit: 8Kbps), 0x1FFFF:disable
+ *      preifg      - Include preamble and IFG, 0:Exclude, 1:Include
+ *      enableFC    - Action when input rate exceeds. 0: Drop   1: Flow Control
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortIngressBandwidth(rtk_uint32 port, rtk_uint32 bandwidth, rtk_uint32 preifg, rtk_uint32 enableFC)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint32 regAddr;
+
+    /* Invalid input parameter */
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(bandwidth > RTL8367C_QOS_GRANULARTY_MAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    regAddr = RTL8367C_INGRESSBW_PORT_RATE_LSB_REG(port);
+    regData = bandwidth & RTL8367C_QOS_GRANULARTY_LSB_MASK;
+    retVal = rtl8367c_setAsicReg(regAddr, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regAddr += 1;
+    regData = (bandwidth & RTL8367C_QOS_GRANULARTY_MSB_MASK) >> RTL8367C_QOS_GRANULARTY_MSB_OFFSET;
+    retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_INGRESSBW_PORT0_RATE_CTRL1_INGRESSBW_RATE16_MASK, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regAddr = RTL8367C_PORT_MISC_CFG_REG(port);
+    retVal = rtl8367c_setAsicRegBit(regAddr, RTL8367C_PORT0_MISC_CFG_INGRESSBW_IFG_OFFSET, preifg);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regAddr = RTL8367C_PORT_MISC_CFG_REG(port);
+    retVal = rtl8367c_setAsicRegBit(regAddr, RTL8367C_PORT0_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET, enableFC);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortIngressBandwidth
+ * Description:
+ *      Get per-port total ingress bandwidth
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      pBandwidth  - The total ingress bandwidth (unit: 8Kbps), 0x1FFFF:disable
+ *      pPreifg         - Include preamble and IFG, 0:Exclude, 1:Include
+ *      pEnableFC   - Action when input rate exceeds. 0: Drop   1: Flow Control
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortIngressBandwidth(rtk_uint32 port, rtk_uint32* pBandwidth, rtk_uint32* pPreifg, rtk_uint32* pEnableFC)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint32 regAddr;
+
+    /* Invalid input parameter */
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    regAddr = RTL8367C_INGRESSBW_PORT_RATE_LSB_REG(port);
+    retVal = rtl8367c_getAsicReg(regAddr, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pBandwidth = regData;
+
+    regAddr += 1;
+    retVal = rtl8367c_getAsicRegBits(regAddr, RTL8367C_INGRESSBW_PORT0_RATE_CTRL1_INGRESSBW_RATE16_MASK, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pBandwidth |= (regData << RTL8367C_QOS_GRANULARTY_MSB_OFFSET);
+
+    regAddr = RTL8367C_PORT_MISC_CFG_REG(port);
+    retVal = rtl8367c_getAsicRegBit(regAddr, RTL8367C_PORT0_MISC_CFG_INGRESSBW_IFG_OFFSET, pPreifg);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regAddr = RTL8367C_PORT_MISC_CFG_REG(port);
+    retVal = rtl8367c_getAsicRegBit(regAddr, RTL8367C_PORT0_MISC_CFG_INGRESSBW_FLOWCTRL_OFFSET, pEnableFC);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortIngressBandwidthBypass
+ * Description:
+ *      Set ingress bandwidth control bypasss 8899, RMA 01-80-C2-00-00-xx and IGMP
+ * Input:
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortIngressBandwidthBypass(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_SW_DUMMY0, RTL8367C_INGRESSBW_BYPASS_EN_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortIngressBandwidthBypass
+ * Description:
+ *      Set ingress bandwidth control bypasss 8899, RMA 01-80-C2-00-00-xx and IGMP
+ * Input:
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortIngressBandwidthBypass(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_SW_DUMMY0, RTL8367C_INGRESSBW_BYPASS_EN_OFFSET, pEnabled);
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_interrupt.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_interrupt.c
new file mode 100644
index 0000000000000..fb6cbcdf1f380
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_interrupt.c
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Interrupt related functions
+ *
+ */
+#include <rtl8367c_asicdrv_interrupt.h>
+/* Function Name:
+ *      rtl8367c_setAsicInterruptPolarity
+ * Description:
+ *      Set interrupt trigger polarity
+ * Input:
+ *      polarity    - 0:pull high 1: pull low
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicInterruptPolarity(rtk_uint32 polarity)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_INTR_CTRL, RTL8367C_INTR_CTRL_OFFSET, polarity);
+}
+/* Function Name:
+ *      rtl8367c_getAsicInterruptPolarity
+ * Description:
+ *      Get interrupt trigger polarity
+ * Input:
+ *      pPolarity   - 0:pull high 1: pull low
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicInterruptPolarity(rtk_uint32* pPolarity)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_INTR_CTRL, RTL8367C_INTR_CTRL_OFFSET, pPolarity);
+}
+/* Function Name:
+ *      rtl8367c_setAsicInterruptMask
+ * Description:
+ *      Set interrupt enable mask
+ * Input:
+ *      imr     - Interrupt mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicInterruptMask(rtk_uint32 imr)
+{
+    return rtl8367c_setAsicReg(RTL8367C_REG_INTR_IMR, imr);
+}
+/* Function Name:
+ *      rtl8367c_getAsicInterruptMask
+ * Description:
+ *      Get interrupt enable mask
+ * Input:
+ *      pImr    - Interrupt mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicInterruptMask(rtk_uint32* pImr)
+{
+    return rtl8367c_getAsicReg(RTL8367C_REG_INTR_IMR, pImr);
+}
+/* Function Name:
+ *      rtl8367c_setAsicInterruptMask
+ * Description:
+ *      Clear interrupt enable mask
+ * Input:
+ *      ims     - Interrupt status mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      This API can be used to clear ASIC interrupt status and register will be cleared by writting 1.
+ *      [0]:Link change,
+ *      [1]:Share meter exceed,
+ *      [2]:Learn number overed,
+ *      [3]:Speed Change,
+ *      [4]:Tx special congestion
+ *      [5]:1 second green feature
+ *      [6]:loop detection
+ *      [7]:interrupt from 8051
+ *      [8]:Cable diagnostic finish
+ *      [9]:ACL action interrupt trigger
+ *      [11]: Silent Start
+ */
+ret_t rtl8367c_setAsicInterruptStatus(rtk_uint32 ims)
+{
+    return rtl8367c_setAsicReg(RTL8367C_REG_INTR_IMS, ims);
+}
+/* Function Name:
+ *      rtl8367c_getAsicInterruptStatus
+ * Description:
+ *      Get interrupt enable mask
+ * Input:
+ *      pIms    - Interrupt status mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicInterruptStatus(rtk_uint32* pIms)
+{
+    return rtl8367c_getAsicReg(RTL8367C_REG_INTR_IMS, pIms);
+}
+/* Function Name:
+ *      rtl8367c_setAsicInterruptRelatedStatus
+ * Description:
+ *      Clear interrupt status
+ * Input:
+ *      type    - per port Learn over, per-port speed change, per-port special congest, share meter exceed status
+ *      status  - exceed status, write 1 to clear
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicInterruptRelatedStatus(rtk_uint32 type, rtk_uint32 status)
+{
+    CONST rtk_uint32 indicatorAddress[INTRST_END] = {RTL8367C_REG_LEARN_OVER_INDICATOR,
+                                                    RTL8367C_REG_SPEED_CHANGE_INDICATOR,
+                                                    RTL8367C_REG_SPECIAL_CONGEST_INDICATOR,
+                                                    RTL8367C_REG_PORT_LINKDOWN_INDICATOR,
+                                                    RTL8367C_REG_PORT_LINKUP_INDICATOR,
+                                                    RTL8367C_REG_METER_OVERRATE_INDICATOR0,
+                                                    RTL8367C_REG_METER_OVERRATE_INDICATOR1,
+                                                    RTL8367C_REG_RLDP_LOOPED_INDICATOR,
+                                                    RTL8367C_REG_RLDP_RELEASED_INDICATOR,
+                                                    RTL8367C_REG_SYSTEM_LEARN_OVER_INDICATOR};
+
+    if(type >= INTRST_END )
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicReg(indicatorAddress[type], status);
+}
+/* Function Name:
+ *      rtl8367c_getAsicInterruptRelatedStatus
+ * Description:
+ *      Get interrupt status
+ * Input:
+ *      type    - per port Learn over, per-port speed change, per-port special congest, share meter exceed status
+ *      pStatus     - exceed status, write 1 to clear
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicInterruptRelatedStatus(rtk_uint32 type, rtk_uint32* pStatus)
+{
+    CONST rtk_uint32 indicatorAddress[INTRST_END] = {RTL8367C_REG_LEARN_OVER_INDICATOR,
+                                                    RTL8367C_REG_SPEED_CHANGE_INDICATOR,
+                                                    RTL8367C_REG_SPECIAL_CONGEST_INDICATOR,
+                                                    RTL8367C_REG_PORT_LINKDOWN_INDICATOR,
+                                                    RTL8367C_REG_PORT_LINKUP_INDICATOR,
+                                                    RTL8367C_REG_METER_OVERRATE_INDICATOR0,
+                                                    RTL8367C_REG_METER_OVERRATE_INDICATOR1,
+                                                    RTL8367C_REG_RLDP_LOOPED_INDICATOR,
+                                                    RTL8367C_REG_RLDP_RELEASED_INDICATOR,
+                                                    RTL8367C_REG_SYSTEM_LEARN_OVER_INDICATOR};
+
+    if(type >= INTRST_END )
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_getAsicReg(indicatorAddress[type], pStatus);
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_led.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_led.c
new file mode 100644
index 0000000000000..1189028161fdc
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_led.c
@@ -0,0 +1,727 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : LED related functions
+ *
+ */
+#include <rtl8367c_asicdrv_led.h>
+/* Function Name:
+ *      rtl8367c_setAsicLedIndicateInfoConfig
+ * Description:
+ *      Set Leds indicated information mode
+ * Input:
+ *      ledno   - LED group number. There are 1 to 1 led mapping to each port in each led group
+ *      config  - Support 16 types configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      The API can set LED indicated information configuration for each LED group with 1 to 1 led mapping to each port.
+ *      Definition        LED Statuses            Description
+ *      0000        LED_Off                LED pin Tri-State.
+ *      0001        Dup/Col                Collision, Full duplex Indicator. Blinking every 43ms when collision happens. Low for full duplex, and high for half duplex mode.
+ *      0010        Link/Act               Link, Activity Indicator. Low for link established. Link/Act Blinks every 43ms when the corresponding port is transmitting or receiving.
+ *      0011        Spd1000                1000Mb/s Speed Indicator. Low for 1000Mb/s.
+ *      0100        Spd100                 100Mb/s Speed Indicator. Low for 100Mb/s.
+ *      0101        Spd10                  10Mb/s Speed Indicator. Low for 10Mb/s.
+ *      0110        Spd1000/Act            1000Mb/s Speed/Activity Indicator. Low for 1000Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
+ *      0111        Spd100/Act             100Mb/s Speed/Activity Indicator. Low for 100Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
+ *      1000        Spd10/Act              10Mb/s Speed/Activity Indicator. Low for 10Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
+ *      1001        Spd100 (10)/Act        10/100Mb/s Speed/Activity Indicator. Low for 10/100Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
+ *      1010        Fiber                  Fiber link Indicator. Low for Fiber.
+ *      1011        Fault                  Auto-negotiation     Fault Indicator. Low for Fault.
+ *      1100        Link/Rx                Link, Activity Indicator. Low for link established. Link/Rx Blinks every 43ms when the corresponding port is transmitting.
+ *      1101        Link/Tx                Link, Activity Indicator. Low for link established. Link/Tx Blinks every 43ms when the corresponding port is receiving.
+ *      1110        Master                 Link on Master Indicator. Low for link Master established.
+ *      1111        LED_Force              Force LED output, LED output value reference
+ */
+ret_t rtl8367c_setAsicLedIndicateInfoConfig(rtk_uint32 ledno, rtk_uint32 config)
+{
+    ret_t   retVal;
+    CONST rtk_uint16 bits[RTL8367C_LEDGROUPNO] = {RTL8367C_LED0_CFG_MASK, RTL8367C_LED1_CFG_MASK, RTL8367C_LED2_CFG_MASK};
+
+    if(ledno >= RTL8367C_LEDGROUPNO)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(config >= LEDCONF_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_CONFIGURATION, RTL8367C_LED_CONFIG_SEL_OFFSET, 0);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_LED_CONFIGURATION, bits[ledno], config);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLedIndicateInfoConfig
+ * Description:
+ *      Get Leds indicated information mode
+ * Input:
+ *      ledno   - LED group number. There are 1 to 1 led mapping to each port in each led group
+ *      pConfig     - Support 16 types configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLedIndicateInfoConfig(rtk_uint32 ledno, rtk_uint32* pConfig)
+{
+    CONST rtk_uint16 bits[RTL8367C_LEDGROUPNO]= {RTL8367C_LED0_CFG_MASK, RTL8367C_LED1_CFG_MASK, RTL8367C_LED2_CFG_MASK};
+
+    if(ledno >= RTL8367C_LEDGROUPNO)
+        return RT_ERR_OUT_OF_RANGE;
+
+    /* Get register value */
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_LED_CONFIGURATION, bits[ledno], pConfig);
+}
+/* Function Name:
+ *      rtl8367c_setAsicLedGroupMode
+ * Description:
+ *      Set Led Group mode
+ * Input:
+ *      mode    - LED mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLedGroupMode(rtk_uint32 mode)
+{
+    ret_t retVal;
+
+    /* Invalid input parameter */
+    if(mode >= RTL8367C_LED_MODE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_CONFIGURATION, RTL8367C_LED_CONFIG_SEL_OFFSET, 1);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_LED_CONFIGURATION, RTL8367C_DATA_LED_MASK, mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLedGroupMode
+ * Description:
+ *      Get Led Group mode
+ * Input:
+ *      pMode   - LED mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLedGroupMode(rtk_uint32* pMode)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LED_CONFIGURATION, RTL8367C_LED_CONFIG_SEL_OFFSET, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    if(regData!=1)
+        return RT_ERR_FAILED;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_LED_CONFIGURATION, RTL8367C_DATA_LED_MASK, pMode);
+}
+/* Function Name:
+ *      rtl8367c_setAsicForceLeds
+ * Description:
+ *      Set group LED mode
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      group   - LED group number
+ *      mode    - LED mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicForceLed(rtk_uint32 port, rtk_uint32 group, rtk_uint32 mode)
+{
+    rtk_uint16 regAddr;
+    ret_t retVal;
+
+    /* Invalid input parameter */
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(group >= RTL8367C_LEDGROUPNO)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(mode >= LEDFORCEMODE_END)
+        return RT_ERR_OUT_OF_RANGE;
+    /* Set Related Registers */
+    if(port < 8){
+        regAddr = RTL8367C_LED_FORCE_MODE_BASE + (group << 1);
+        if((retVal = rtl8367c_setAsicRegBits(regAddr, 0x3 << (port * 2), mode)) != RT_ERR_OK)
+            return retVal;
+    }else if(port >= 8){
+        regAddr = RTL8367C_REG_CPU_FORCE_LED0_CFG1 + (group << 1);
+        if((retVal = rtl8367c_setAsicRegBits(regAddr, 0x3 << ((port-8) * 2), mode)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicForceLed
+ * Description:
+ *      Get group LED mode
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      group   - LED group number
+ *      pMode   - LED mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicForceLed(rtk_uint32 port, rtk_uint32 group, rtk_uint32* pMode)
+{
+    rtk_uint16 regAddr;
+    ret_t retVal;
+
+    /* Invalid input parameter */
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(group >= RTL8367C_LEDGROUPNO)
+        return RT_ERR_INPUT;
+
+    /* Get Related Registers */
+    if(port < 8){
+        regAddr = RTL8367C_LED_FORCE_MODE_BASE + (group << 1);
+        if((retVal = rtl8367c_getAsicRegBits(regAddr, 0x3 << (port * 2), pMode)) != RT_ERR_OK)
+            return retVal;
+    }else if(port >= 8){
+        regAddr = RTL8367C_REG_CPU_FORCE_LED0_CFG1 + (group << 1);
+        if((retVal = rtl8367c_getAsicRegBits(regAddr, 0x3 << ((port-8) * 2), pMode)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicForceGroupLed
+ * Description:
+ *      Turn on/off Led of all ports
+ * Input:
+ *      group   - LED group number
+ *      mode    - 0b00:normal mode, 0b01:force blink, 0b10:force off, 0b11:force on
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicForceGroupLed(rtk_uint32 groupmask, rtk_uint32 mode)
+{
+    ret_t retVal;
+    rtk_uint32 i,bitmask;
+    CONST rtk_uint16 bits[3]= {0x0004,0x0010,0x0040};
+
+    /* Invalid input parameter */
+    if(groupmask > RTL8367C_LEDGROUPMASK)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(mode >= LEDFORCEMODE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    bitmask = 0;
+    for(i = 0; i <  RTL8367C_LEDGROUPNO; i++)
+    {
+        if(groupmask & (1 << i))
+        {
+            bitmask = bitmask | bits[i];
+        }
+
+    }
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_LED_FORCE_CTRL, RTL8367C_LED_FORCE_MODE_MASK, bitmask);
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_LED_FORCE_CTRL, RTL8367C_FORCE_MODE_MASK, mode);
+
+    if(LEDFORCEMODE_NORMAL == mode)
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_LED_FORCE_CTRL, RTL8367C_LED_FORCE_MODE_MASK, 0);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicForceGroupLed
+ * Description:
+ *      Turn on/off Led of all ports
+ * Input:
+ *      group   - LED group number
+ *      pMode   - 0b00:normal mode, 0b01:force blink, 0b10:force off, 0b11:force on
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicForceGroupLed(rtk_uint32* groupmask, rtk_uint32* pMode)
+{
+    ret_t retVal;
+    rtk_uint32 i,regData;
+    CONST rtk_uint16 bits[3] = {0x0004,0x0010,0x0040};
+
+    /* Get Related Registers */
+    if((retVal = rtl8367c_getAsicRegBits(RTL8367C_LED_FORCE_CTRL, RTL8367C_LED_FORCE_MODE_MASK, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    for(i = 0; i< RTL8367C_LEDGROUPNO; i++)
+    {
+        if((regData & bits[i]) == bits[i])
+        {
+            *groupmask = *groupmask | (1 << i);
+        }
+    }
+
+    return rtl8367c_getAsicRegBits(RTL8367C_LED_FORCE_CTRL, RTL8367C_FORCE_MODE_MASK, pMode);
+}
+/* Function Name:
+ *      rtl8367c_setAsicLedBlinkRate
+ * Description:
+ *      Set led blinking rate at mode 0 to mode 3
+ * Input:
+ *      blinkRate   - Support 6 blink rates
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      LED blink rate can be at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms
+ */
+ret_t rtl8367c_setAsicLedBlinkRate(rtk_uint32 blinkRate)
+{
+    if(blinkRate >= LEDBLINKRATE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_LED_MODE, RTL8367C_SEL_LEDRATE_MASK, blinkRate);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLedBlinkRate
+ * Description:
+ *      Get led blinking rate at mode 0 to mode 3
+ * Input:
+ *      pBlinkRate  - Support 6 blink rates
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLedBlinkRate(rtk_uint32* pBlinkRate)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_LED_MODE, RTL8367C_SEL_LEDRATE_MASK, pBlinkRate);
+}
+/* Function Name:
+ *      rtl8367c_setAsicLedForceBlinkRate
+ * Description:
+ *      Set LEd blinking rate for force mode led
+ * Input:
+ *      blinkRate   - Support 6 blink rates
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLedForceBlinkRate(rtk_uint32 blinkRate)
+{
+    if(blinkRate >= LEDFORCERATE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_LED_MODE, RTL8367C_FORCE_RATE_MASK, blinkRate);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLedForceBlinkRate
+ * Description:
+ *      Get LED blinking rate for force mode led
+ * Input:
+ *      pBlinkRate  - Support 6 blink rates
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLedForceBlinkRate(rtk_uint32* pBlinkRate)
+{
+     return rtl8367c_getAsicRegBits(RTL8367C_REG_LED_MODE, RTL8367C_FORCE_RATE_MASK, pBlinkRate);
+}
+
+/*
+@func ret_t | rtl8367c_setAsicLedGroupEnable | Turn on/off Led of all system ports
+@parm rtk_uint32 | group | LED group id.
+@parm rtk_uint32 | portmask | LED port mask.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_PORT_ID | Invalid port number.
+@rvalue RT_ERR_INPUT | Invalid input value.
+@comm
+    The API can turn on/off leds of dedicated port while indicated information configuration of LED group is set to force mode.
+ */
+ret_t rtl8367c_setAsicLedGroupEnable(rtk_uint32 group, rtk_uint32 portmask)
+{
+    ret_t retVal;
+    rtk_uint32 regAddr;
+    rtk_uint32 regDataMask;
+
+    if ( group >= RTL8367C_LEDGROUPNO )
+        return RT_ERR_INPUT;
+
+    regAddr = RTL8367C_REG_PARA_LED_IO_EN1 + group/2;
+    regDataMask = 0xFF << ((group%2)*8);
+    retVal = rtl8367c_setAsicRegBits(regAddr, regDataMask, portmask&0xff);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regAddr = RTL8367C_REG_PARA_LED_IO_EN3;
+    regDataMask = 0x3 << (group*2);
+    retVal = rtl8367c_setAsicRegBits(regAddr, regDataMask, (portmask>>8)&0x7);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+
+    return RT_ERR_OK;
+}
+
+/*
+@func ret_t | rtl8367c_getAsicLedGroupEnable | Get on/off status of Led of all system ports
+@parm rtk_uint32 | group | LED group id.
+@parm rtk_uint32 | *portmask | LED port mask.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_PORT_ID | Invalid port number.
+@rvalue RT_ERR_INPUT | Invalid input value.
+@comm
+    The API can turn on/off leds of dedicated port while indicated information configuration of LED group is set to force mode.
+ */
+ret_t rtl8367c_getAsicLedGroupEnable(rtk_uint32 group, rtk_uint32 *portmask)
+{
+    ret_t retVal;
+    rtk_uint32 regAddr;
+    rtk_uint32 regDataMask,regData;
+
+    if ( group >= RTL8367C_LEDGROUPNO )
+        return RT_ERR_INPUT;
+
+    regAddr = RTL8367C_REG_PARA_LED_IO_EN1 + group/2;
+    regDataMask = 0xFF << ((group%2)*8);
+    retVal = rtl8367c_getAsicRegBits(regAddr, regDataMask, portmask);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+
+    regAddr = RTL8367C_REG_PARA_LED_IO_EN3;
+    regDataMask = 0x3 << (group*2);
+    retVal = rtl8367c_getAsicRegBits(regAddr, regDataMask, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *portmask = (regData << 8) | *portmask;
+
+    return RT_ERR_OK;
+}
+
+/*
+@func ret_t | rtl8367c_setAsicLedOperationMode | Set LED operation mode
+@parm rtk_uint32 | mode | LED mode. 1:scan mode 1, 2:parallel mode, 3:mdx mode (serial mode)
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_INPUT | Invalid input value.
+@comm
+    The API can turn on/off led serial mode and set signal to active high/low.
+ */
+ret_t rtl8367c_setAsicLedOperationMode(rtk_uint32 mode)
+{
+    ret_t retVal;
+
+    /* Invalid input parameter */
+    if( mode >= LEDOP_END)
+        return RT_ERR_INPUT;
+
+    switch(mode)
+    {
+        case LEDOP_PARALLEL:
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_LED_SELECT_OFFSET, 0))!=  RT_ERR_OK)
+                return retVal;
+            /*Disable serial CLK mode*/
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SCAN0_LED_IO_EN1,RTL8367C_LED_SERI_CLK_EN_OFFSET, 0))!=  RT_ERR_OK)
+                return retVal;
+            /*Disable serial DATA mode*/
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SCAN0_LED_IO_EN1,RTL8367C_LED_SERI_DATA_EN_OFFSET, 0))!=  RT_ERR_OK)
+                return retVal;
+            break;
+        case LEDOP_SERIAL:
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_LED_SELECT_OFFSET, 1))!=  RT_ERR_OK)
+                return retVal;
+            /*Enable serial CLK mode*/
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SCAN0_LED_IO_EN1,RTL8367C_LED_SERI_CLK_EN_OFFSET, 1))!=  RT_ERR_OK)
+                return retVal;
+            /*Enable serial DATA mode*/
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SCAN0_LED_IO_EN1,RTL8367C_LED_SERI_DATA_EN_OFFSET, 1))!=  RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            return RT_ERR_INPUT;
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+
+
+/*
+@func ret_t | rtl8367c_getAsicLedOperationMode | Get LED OP mode setup
+@parm rtk_uint32*| mode | LED mode. 1:scan mode 1, 2:parallel mode, 3:mdx mode (serial mode)
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_INPUT | Invalid input value.
+@comm
+    The API can get LED serial mode setup and get signal active high/low.
+ */
+ret_t rtl8367c_getAsicLedOperationMode(rtk_uint32 *mode)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_LED_SELECT_OFFSET, &regData))!=  RT_ERR_OK)
+        return retVal;
+
+    if (regData == 1)
+        *mode = LEDOP_SERIAL;
+    else if (regData == 0)
+        *mode = LEDOP_PARALLEL;
+    else
+        return RT_ERR_FAILED;
+
+    return RT_ERR_OK;
+}
+
+/*
+@func ret_t | rtl8367c_setAsicLedSerialModeConfig | Set LED serial mode
+@parm rtk_uint32 | active | Active High or Low.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_INPUT | Invalid input value.
+@comm
+    The API can turn on/off led serial mode and set signal to active high/low.
+ */
+ret_t rtl8367c_setAsicLedSerialModeConfig(rtk_uint32 active, rtk_uint32 serimode)
+{
+    ret_t retVal;
+
+    /* Invalid input parameter */
+    if( active >= LEDSERACT_MAX)
+        return RT_ERR_INPUT;
+    if( serimode >= LEDSER_MAX)
+        return RT_ERR_INPUT;
+
+    /* Set Active High or Low */
+    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_SERI_LED_ACT_LOW_OFFSET, active)) !=  RT_ERR_OK)
+        return retVal;
+
+    /*set to 8G mode (not 16G mode)*/
+    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_MODE, RTL8367C_DLINK_TIME_OFFSET, serimode))!=  RT_ERR_OK)
+        return retVal;
+
+
+    return RT_ERR_OK;
+}
+
+
+/*
+@func ret_t | rtl8367c_getAsicLedSerialModeConfig | Get LED serial mode setup
+@parm rtk_uint32*| active | Active High or Low.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_INPUT | Invalid input value.
+@comm
+    The API can get LED serial mode setup and get signal active high/low.
+ */
+ret_t rtl8367c_getAsicLedSerialModeConfig(rtk_uint32 *active, rtk_uint32 *serimode)
+{
+    ret_t retVal;
+
+    if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_SERI_LED_ACT_LOW_OFFSET, active))!=  RT_ERR_OK)
+        return retVal;
+
+    /*get to 8G mode (not 16G mode)*/
+    if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LED_MODE, RTL8367C_DLINK_TIME_OFFSET, serimode))!=  RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/*
+@func ret_t | rtl8367c_setAsicLedOutputEnable | Set LED output enable
+@parm rtk_uint32 | enabled | enable or disalbe.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_INPUT | Invalid input value.
+@comm
+    The API can turn on/off LED output Enable
+ */
+ret_t rtl8367c_setAsicLedOutputEnable(rtk_uint32 enabled)
+{
+    ret_t retVal;
+    rtk_uint32 regdata;
+
+    if (enabled == 1)
+        regdata = 0;
+    else
+        regdata = 1;
+
+    /* Enable/Disable H/W IGMP/MLD */
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_LED_IO_DISABLE_OFFSET, regdata);
+
+    return retVal;
+}
+
+
+/*
+@func ret_t | rtl8367c_getAsicLedOutputEnable | Get LED serial mode setup
+@parm rtk_uint32*| active | Active High or Low.
+@rvalue RT_ERR_OK | Success.
+@rvalue RT_ERR_SMI | SMI access error.
+@rvalue RT_ERR_INPUT | Invalid input value.
+@comm
+    The API can get LED serial mode setup and get signal active high/low.
+ */
+ret_t rtl8367c_getAsicLedOutputEnable(rtk_uint32 *ptr_enabled)
+{
+    ret_t retVal;
+    rtk_uint32 regdata;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LED_SYS_CONFIG, RTL8367C_LED_IO_DISABLE_OFFSET, &regdata);
+    if (retVal != RT_ERR_OK)
+        return retVal;
+
+    if (regdata == 1)
+        *ptr_enabled = 0;
+    else
+        *ptr_enabled = 1;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicLedSerialOutput
+ * Description:
+ *      Set serial LED output group and portmask.
+ * Input:
+ *      output      - Serial LED output group
+ *      pmask       - Serial LED output portmask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLedSerialOutput(rtk_uint32 output, rtk_uint32 pmask)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SERIAL_LED_CTRL, RTL8367C_SERIAL_LED_GROUP_NUM_MASK, output);
+    if (retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SERIAL_LED_CTRL, RTL8367C_SERIAL_LED_PORT_EN_MASK, pmask);
+    if (retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicLedSerialOutput
+ * Description:
+ *      Get serial LED output group and portmask.
+ * Input:
+ *      None
+ * Output:
+ *      pOutput      - Serial LED output group
+ *      pPmask       - Serial LED output portmask
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLedSerialOutput(rtk_uint32 *pOutput, rtk_uint32 *pPmask)
+{
+    ret_t retVal;
+
+    if(pOutput == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if(pPmask == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SERIAL_LED_CTRL, RTL8367C_SERIAL_LED_GROUP_NUM_MASK, pOutput);
+    if (retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SERIAL_LED_CTRL, RTL8367C_SERIAL_LED_PORT_EN_MASK, pPmask);
+    if (retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_lut.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_lut.c
new file mode 100644
index 0000000000000..343a6f159c641
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_lut.c
@@ -0,0 +1,1549 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : LUT related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_lut.h>
+
+#include <string.h>
+
+static void _rtl8367c_fdbStUser2Smi( rtl8367c_luttb *pLutSt, rtk_uint16 *pFdbSmi)
+{
+    /* L3 lookup */
+    if(pLutSt->l3lookup)
+    {
+        if(pLutSt->l3vidlookup)
+        {
+            pFdbSmi[0] = (pLutSt->sip & 0x0000FFFF);
+            pFdbSmi[1] = (pLutSt->sip & 0xFFFF0000) >> 16;
+
+            pFdbSmi[2] = (pLutSt->dip & 0x0000FFFF);
+            pFdbSmi[3] = (pLutSt->dip & 0x0FFF0000) >> 16;
+
+            pFdbSmi[3] |= (pLutSt->l3lookup & 0x0001) << 12;
+            pFdbSmi[3] |= (pLutSt->l3vidlookup & 0x0001) << 13;
+            pFdbSmi[3] |= ((pLutSt->mbr & 0x0300) >> 8) << 14;
+
+            pFdbSmi[4] |= (pLutSt->mbr & 0x00FF);
+            pFdbSmi[4] |= (pLutSt->l3_vid & 0x00FF) << 8;
+
+            pFdbSmi[5] |= ((pLutSt->l3_vid & 0x0F00) >> 8);
+            pFdbSmi[5] |= (pLutSt->nosalearn & 0x0001) << 5;
+            pFdbSmi[5] |= ((pLutSt->mbr & 0x0400) >> 10) << 7;
+        }
+        else
+        {
+            pFdbSmi[0] = (pLutSt->sip & 0x0000FFFF);
+            pFdbSmi[1] = (pLutSt->sip & 0xFFFF0000) >> 16;
+
+            pFdbSmi[2] = (pLutSt->dip & 0x0000FFFF);
+            pFdbSmi[3] = (pLutSt->dip & 0x0FFF0000) >> 16;
+
+            pFdbSmi[3] |= (pLutSt->l3lookup & 0x0001) << 12;
+            pFdbSmi[3] |= (pLutSt->l3vidlookup & 0x0001) << 13;
+            pFdbSmi[3] |= ((pLutSt->mbr & 0x0300) >> 8) << 14;
+
+            pFdbSmi[4] |= (pLutSt->mbr & 0x00FF);
+            pFdbSmi[4] |= (pLutSt->igmpidx & 0x00FF) << 8;
+
+            pFdbSmi[5] |= (pLutSt->igmp_asic & 0x0001);
+            pFdbSmi[5] |= (pLutSt->lut_pri & 0x0007) << 1;
+            pFdbSmi[5] |= (pLutSt->fwd_en & 0x0001) << 4;
+            pFdbSmi[5] |= (pLutSt->nosalearn & 0x0001) << 5;
+            pFdbSmi[5] |= ((pLutSt->mbr & 0x0400) >> 10) << 7;
+        }
+    }
+    else if(pLutSt->mac.octet[0] & 0x01) /*Multicast L2 Lookup*/
+    {
+        pFdbSmi[0] |= pLutSt->mac.octet[5];
+        pFdbSmi[0] |= pLutSt->mac.octet[4] << 8;
+
+        pFdbSmi[1] |= pLutSt->mac.octet[3];
+        pFdbSmi[1] |= pLutSt->mac.octet[2] << 8;
+
+        pFdbSmi[2] |= pLutSt->mac.octet[1];
+        pFdbSmi[2] |= pLutSt->mac.octet[0] << 8;
+
+        pFdbSmi[3] |= pLutSt->cvid_fid;
+        pFdbSmi[3] |= (pLutSt->l3lookup & 0x0001) << 12;
+        pFdbSmi[3] |= (pLutSt->ivl_svl & 0x0001) << 13;
+        pFdbSmi[3] |= ((pLutSt->mbr & 0x0300) >> 8) << 14;
+
+        pFdbSmi[4] |= (pLutSt->mbr & 0x00FF);
+        pFdbSmi[4] |= (pLutSt->igmpidx & 0x00FF) << 8;
+
+        pFdbSmi[5] |= pLutSt->igmp_asic;
+        pFdbSmi[5] |= (pLutSt->lut_pri & 0x0007) << 1;
+        pFdbSmi[5] |= (pLutSt->fwd_en & 0x0001) << 4;
+        pFdbSmi[5] |= (pLutSt->nosalearn & 0x0001) << 5;
+        pFdbSmi[5] |= ((pLutSt->mbr & 0x0400) >> 10) << 7;
+    }
+    else /*Asic auto-learning*/
+    {
+        pFdbSmi[0] |= pLutSt->mac.octet[5];
+        pFdbSmi[0] |= pLutSt->mac.octet[4] << 8;
+
+        pFdbSmi[1] |= pLutSt->mac.octet[3];
+        pFdbSmi[1] |= pLutSt->mac.octet[2] << 8;
+
+        pFdbSmi[2] |= pLutSt->mac.octet[1];
+        pFdbSmi[2] |= pLutSt->mac.octet[0] << 8;
+
+        pFdbSmi[3] |= pLutSt->cvid_fid;
+        pFdbSmi[3] |= (pLutSt->l3lookup & 0x0001) << 12;
+        pFdbSmi[3] |= (pLutSt->ivl_svl & 0x0001) << 13;
+        pFdbSmi[3] |= ((pLutSt->spa & 0x0008) >> 3) << 15;
+
+        pFdbSmi[4] |= pLutSt->efid;
+        pFdbSmi[4] |= (pLutSt->fid & 0x000F) << 3;
+        pFdbSmi[4] |= (pLutSt->sa_en & 0x0001) << 7;
+        pFdbSmi[4] |= (pLutSt->spa & 0x0007) << 8;
+        pFdbSmi[4] |= (pLutSt->age & 0x0007) << 11;
+        pFdbSmi[4] |= (pLutSt->auth & 0x0001) << 14;
+        pFdbSmi[4] |= (pLutSt->sa_block & 0x0001) << 15;
+
+        pFdbSmi[5] |= pLutSt->da_block;
+        pFdbSmi[5] |= (pLutSt->lut_pri & 0x0007) << 1;
+        pFdbSmi[5] |= (pLutSt->fwd_en & 0x0001) << 4;
+        pFdbSmi[5] |= (pLutSt->nosalearn & 0x0001) << 5;
+    }
+}
+
+
+static void _rtl8367c_fdbStSmi2User( rtl8367c_luttb *pLutSt, rtk_uint16 *pFdbSmi)
+{
+    /*L3 lookup*/
+    if(pFdbSmi[3] & 0x1000)
+    {
+        if(pFdbSmi[3] & 0x2000)
+        {
+            pLutSt->sip             = pFdbSmi[0] | (pFdbSmi[1] << 16);
+            pLutSt->dip             = pFdbSmi[2] | ((pFdbSmi[3] & 0x0FFF) << 16);
+
+            pLutSt->mbr             = (pFdbSmi[4] & 0x00FF) | (((pFdbSmi[3] & 0xC000) >> 14) << 8) | (((pFdbSmi[5] & 0x0080) >> 7) << 10);
+            pLutSt->l3_vid          = ((pFdbSmi[4] & 0xFF00) >> 8) | (pFdbSmi[5] & 0x000F);
+
+            pLutSt->l3lookup        = (pFdbSmi[3] & 0x1000) >> 12;
+            pLutSt->l3vidlookup     = (pFdbSmi[3] & 0x2000) >> 13;
+            pLutSt->nosalearn       = (pFdbSmi[5] & 0x0020) >> 5;
+        }
+        else
+        {
+            pLutSt->sip             = pFdbSmi[0] | (pFdbSmi[1] << 16);
+            pLutSt->dip             = pFdbSmi[2] | ((pFdbSmi[3] & 0x0FFF) << 16);
+
+            pLutSt->lut_pri         = (pFdbSmi[5] & 0x000E) >> 1;
+            pLutSt->fwd_en          = (pFdbSmi[5] & 0x0010) >> 4;
+
+            pLutSt->mbr             = (pFdbSmi[4] & 0x00FF) | (((pFdbSmi[3] & 0xC000) >> 14) << 8) | (((pFdbSmi[5] & 0x0080) >> 7) << 10);
+            pLutSt->igmpidx         = (pFdbSmi[4] & 0xFF00) >> 8;
+
+            pLutSt->igmp_asic       = (pFdbSmi[5] & 0x0001);
+            pLutSt->l3lookup        = (pFdbSmi[3] & 0x1000) >> 12;
+            pLutSt->nosalearn       = (pFdbSmi[5] & 0x0020) >> 5;
+        }
+    }
+    else if(pFdbSmi[2] & 0x0100) /*Multicast L2 Lookup*/
+    {
+        pLutSt->mac.octet[0]    = (pFdbSmi[2] & 0xFF00) >> 8;
+        pLutSt->mac.octet[1]    = (pFdbSmi[2] & 0x00FF);
+        pLutSt->mac.octet[2]    = (pFdbSmi[1] & 0xFF00) >> 8;
+        pLutSt->mac.octet[3]    = (pFdbSmi[1] & 0x00FF);
+        pLutSt->mac.octet[4]    = (pFdbSmi[0] & 0xFF00) >> 8;
+        pLutSt->mac.octet[5]    = (pFdbSmi[0] & 0x00FF);
+
+        pLutSt->cvid_fid        = pFdbSmi[3] & 0x0FFF;
+        pLutSt->lut_pri         = (pFdbSmi[5] & 0x000E) >> 1;
+        pLutSt->fwd_en          = (pFdbSmi[5] & 0x0010) >> 4;
+
+        pLutSt->mbr             = (pFdbSmi[4] & 0x00FF) | (((pFdbSmi[3] & 0xC000) >> 14) << 8) | (((pFdbSmi[5] & 0x0080) >> 7) << 10);
+        pLutSt->igmpidx         = (pFdbSmi[4] & 0xFF00) >> 8;
+
+        pLutSt->igmp_asic       = (pFdbSmi[5] & 0x0001);
+        pLutSt->l3lookup        = (pFdbSmi[3] & 0x1000) >> 12;
+        pLutSt->ivl_svl         = (pFdbSmi[3] & 0x2000) >> 13;
+        pLutSt->nosalearn       = (pFdbSmi[5] & 0x0020) >> 5;
+    }
+    else /*Asic auto-learning*/
+    {
+        pLutSt->mac.octet[0]    = (pFdbSmi[2] & 0xFF00) >> 8;
+        pLutSt->mac.octet[1]    = (pFdbSmi[2] & 0x00FF);
+        pLutSt->mac.octet[2]    = (pFdbSmi[1] & 0xFF00) >> 8;
+        pLutSt->mac.octet[3]    = (pFdbSmi[1] & 0x00FF);
+        pLutSt->mac.octet[4]    = (pFdbSmi[0] & 0xFF00) >> 8;
+        pLutSt->mac.octet[5]    = (pFdbSmi[0] & 0x00FF);
+
+        pLutSt->cvid_fid        = pFdbSmi[3] & 0x0FFF;
+        pLutSt->lut_pri         = (pFdbSmi[5] & 0x000E) >> 1;
+        pLutSt->fwd_en          = (pFdbSmi[5] & 0x0010) >> 4;
+
+        pLutSt->sa_en           = (pFdbSmi[4] & 0x0080) >> 7;
+        pLutSt->auth            = (pFdbSmi[4] & 0x4000) >> 14;
+        pLutSt->spa             = ((pFdbSmi[4] & 0x0700) >> 8) | (((pFdbSmi[3] & 0x8000) >> 15) << 3);
+        pLutSt->age             = (pFdbSmi[4] & 0x3800) >> 11;
+        pLutSt->fid             = (pFdbSmi[4] & 0x0078) >> 3;
+        pLutSt->efid            = (pFdbSmi[4] & 0x0007);
+        pLutSt->sa_block        = (pFdbSmi[4] & 0x8000) >> 15;
+
+        pLutSt->da_block        = (pFdbSmi[5] & 0x0001);
+        pLutSt->l3lookup        = (pFdbSmi[3] & 0x1000) >> 12;
+        pLutSt->ivl_svl         = (pFdbSmi[3] & 0x2000) >> 13;
+        pLutSt->nosalearn       = (pFdbSmi[3] & 0x0020) >> 5;
+    }
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicLutIpMulticastLookup
+ * Description:
+ *      Set Lut IP multicast lookup function
+ * Input:
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutIpMulticastLookup(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LUT_IPMC_HASH_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutIpMulticastLookup
+ * Description:
+ *      Get Lut IP multicast lookup function
+ * Input:
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutIpMulticastLookup(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LUT_IPMC_HASH_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicLutIpMulticastLookup
+ * Description:
+ *      Set Lut IP multicast + VID lookup function
+ * Input:
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutIpMulticastVidLookup(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG2, RTL8367C_LUT_IPMC_VID_HASH_OFFSET, enabled);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicLutIpMulticastVidLookup
+ * Description:
+ *      Get Lut IP multicast lookup function
+ * Input:
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutIpMulticastVidLookup(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG2, RTL8367C_LUT_IPMC_VID_HASH_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicLutIpLookupMethod
+ * Description:
+ *      Set Lut IP lookup hash with DIP or {DIP,SIP} pair
+ * Input:
+ *      type - 1: When DIP can be found in IPMC_GROUP_TABLE, use DIP+SIP Hash, otherwise, use DIP+(SIP=0.0.0.0) Hash.
+ *             0: When DIP can be found in IPMC_GROUP_TABLE, use DIP+(SIP=0.0.0.0) Hash, otherwise use DIP+SIP Hash.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutIpLookupMethod(rtk_uint32 type)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LUT_IPMC_LOOKUP_OP_OFFSET, type);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutIpLookupMethod
+ * Description:
+ *      Get Lut IP lookup hash with DIP or {DIP,SIP} pair
+ * Input:
+ *      pType - 1: When DIP can be found in IPMC_GROUP_TABLE, use DIP+SIP Hash, otherwise, use DIP+(SIP=0.0.0.0) Hash.
+ *              0: When DIP can be found in IPMC_GROUP_TABLE, use DIP+(SIP=0.0.0.0) Hash, otherwise use DIP+SIP Hash.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutIpLookupMethod(rtk_uint32* pType)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LUT_IPMC_LOOKUP_OP_OFFSET, pType);
+}
+/* Function Name:
+ *      rtl8367c_setAsicLutAgeTimerSpeed
+ * Description:
+ *      Set LUT agging out speed
+ * Input:
+ *      timer - Agging out timer 0:Has been aged out
+ *      speed - Agging out speed 0-fastest 3-slowest
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutAgeTimerSpeed(rtk_uint32 timer, rtk_uint32 speed)
+{
+    if(timer>RTL8367C_LUT_AGETIMERMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(speed >RTL8367C_LUT_AGESPEEDMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_LUT_CFG, RTL8367C_AGE_TIMER_MASK | RTL8367C_AGE_SPEED_MASK, (timer << RTL8367C_AGE_TIMER_OFFSET) | (speed << RTL8367C_AGE_SPEED_OFFSET));
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutAgeTimerSpeed
+ * Description:
+ *      Get LUT agging out speed
+ * Input:
+ *      pTimer - Agging out timer 0:Has been aged out
+ *      pSpeed - Agging out speed 0-fastest 3-slowest
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutAgeTimerSpeed(rtk_uint32* pTimer, rtk_uint32* pSpeed)
+{
+    rtk_uint32 regData;
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_LUT_CFG, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pTimer =  (regData & RTL8367C_AGE_TIMER_MASK) >> RTL8367C_AGE_TIMER_OFFSET;
+
+    *pSpeed =  (regData & RTL8367C_AGE_SPEED_MASK) >> RTL8367C_AGE_SPEED_OFFSET;
+
+    return RT_ERR_OK;
+
+}
+/* Function Name:
+ *      rtl8367c_setAsicLutCamTbUsage
+ * Description:
+ *      Configure Lut CAM table usage
+ * Input:
+ *      enabled - L2 CAM table usage 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutCamTbUsage(rtk_uint32 enabled)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_BCAM_DISABLE_OFFSET, enabled ? 0 : 1);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutCamTbUsage
+ * Description:
+ *      Get Lut CAM table usage
+ * Input:
+ *      pEnabled - L2 CAM table usage 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutCamTbUsage(rtk_uint32* pEnabled)
+{
+    ret_t       retVal;
+    rtk_uint32  regData;
+
+    if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_BCAM_DISABLE_OFFSET, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    *pEnabled = regData ? 0 : 1;
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicLutLearnLimitNo
+ * Description:
+ *      Set per-Port auto learning limit number
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      number  - ASIC auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number
+ *      RT_ERR_LIMITED_L2ENTRY_NUM  - Invalid auto learning limit number
+ * Note:
+ *      None
+ */
+   /*޸: RTL8367C_PORTIDMAX, RTL8367C_LUT_LEARNLIMITMAX, RTL8367C_LUT_PORT_LEARN_LIMITNO_REG*/
+ret_t rtl8367c_setAsicLutLearnLimitNo(rtk_uint32 port, rtk_uint32 number)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(number > RTL8367C_LUT_LEARNLIMITMAX)
+        return RT_ERR_LIMITED_L2ENTRY_NUM;
+
+    if(port < 8)
+     return rtl8367c_setAsicReg(RTL8367C_LUT_PORT_LEARN_LIMITNO_REG(port), number);
+    else
+        return rtl8367c_setAsicReg(RTL8367C_REG_LUT_PORT8_LEARN_LIMITNO+port-8, number);
+
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutLearnLimitNo
+ * Description:
+ *      Get per-Port auto learning limit number
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pNumber     - ASIC auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+  /*޸: RTL8367C_PORTIDMAX, RTL8367C_LUT_PORT_LEARN_LIMITNO_REG*/
+ret_t rtl8367c_getAsicLutLearnLimitNo(rtk_uint32 port, rtk_uint32* pNumber)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+     return rtl8367c_getAsicReg(RTL8367C_LUT_PORT_LEARN_LIMITNO_REG(port), pNumber);
+    else
+        return rtl8367c_getAsicReg(RTL8367C_REG_LUT_PORT8_LEARN_LIMITNO+port-8, pNumber);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicSystemLutLearnLimitNo
+ * Description:
+ *      Set system auto learning limit number
+ * Input:
+ *      number  - ASIC auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number
+ *      RT_ERR_LIMITED_L2ENTRY_NUM  - Invalid auto learning limit number
+ * Note:
+ *      None
+ */
+  /*޸: RTL8367C_LUT_LEARNLIMITMAX*/
+ret_t rtl8367c_setAsicSystemLutLearnLimitNo(rtk_uint32 number)
+{
+    if(number > RTL8367C_LUT_LEARNLIMITMAX)
+        return RT_ERR_LIMITED_L2ENTRY_NUM;
+
+    return rtl8367c_setAsicReg(RTL8367C_REG_LUT_SYS_LEARN_LIMITNO, number);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicSystemLutLearnLimitNo
+ * Description:
+ *      Get system auto learning limit number
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pNumber     - ASIC auto learning entries limit number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSystemLutLearnLimitNo(rtk_uint32 *pNumber)
+{
+    if(NULL == pNumber)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicReg(RTL8367C_REG_LUT_SYS_LEARN_LIMITNO, pNumber);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicLutLearnOverAct
+ * Description:
+ *      Set auto learn over limit number action
+ * Input:
+ *      action  - Learn over action 0:normal, 1:drop 2:trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NOT_ALLOWED  - Invalid learn over action
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutLearnOverAct(rtk_uint32 action)
+{
+    if(action >= LRNOVERACT_END)
+        return RT_ERR_NOT_ALLOWED;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_SECURITY_CTRL, RTL8367C_LUT_LEARN_OVER_ACT_MASK, action);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutLearnOverAct
+ * Description:
+ *      Get auto learn over limit number action
+ * Input:
+ *      pAction     - Learn over action 0:normal, 1:drop 2:trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutLearnOverAct(rtk_uint32* pAction)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_SECURITY_CTRL, RTL8367C_LUT_LEARN_OVER_ACT_MASK, pAction);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicSystemLutLearnOverAct
+ * Description:
+ *      Set system auto learn over limit number action
+ * Input:
+ *      action  - Learn over action 0:normal, 1:drop, 2:trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NOT_ALLOWED  - Invalid learn over action
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSystemLutLearnOverAct(rtk_uint32 action)
+{
+    if(action >= LRNOVERACT_END)
+        return RT_ERR_NOT_ALLOWED;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_OVER_ACT_MASK, action);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicSystemLutLearnOverAct
+ * Description:
+ *      Get system auto learn over limit number action
+ * Input:
+ *      pAction     - Learn over action 0:normal, 1:drop 2:trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSystemLutLearnOverAct(rtk_uint32 *pAction)
+{
+    if(NULL == pAction)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_OVER_ACT_MASK, pAction);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicSystemLutLearnPortMask
+ * Description:
+ *      Set system auto learn limit port mask
+ * Input:
+ *      portmask    - port mask of system learning limit
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Error port mask
+ * Note:
+ *      None
+ */
+  /*޸: RTL8367C_LUT_SYSTEM_LEARN_PMASK_MASK*/
+ret_t rtl8367c_setAsicSystemLutLearnPortMask(rtk_uint32 portmask)
+{
+    ret_t retVal;
+
+    if(portmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_PMASK_MASK, portmask & 0xff);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_PMASK1_MASK, (portmask>>8) & 0x7);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicSystemLutLearnPortMask
+ * Description:
+ *      Get system auto learn limit port mask
+ * Input:
+ *      None
+ * Output:
+ *      pPortmask   - port mask of system learning limit
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - NULL pointer
+ * Note:
+ *      None
+ */
+ /*޸: RTL8367C_LUT_SYSTEM_LEARN_PMASK_MASK*/
+ret_t rtl8367c_getAsicSystemLutLearnPortMask(rtk_uint32 *pPortmask)
+{
+    rtk_uint32 tmpmask;
+    ret_t retVal;
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_PMASK_MASK, &tmpmask);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    *pPortmask = tmpmask & 0xff;
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_LUT_LRN_SYS_LMT_CTRL, RTL8367C_LUT_SYSTEM_LEARN_PMASK1_MASK, &tmpmask);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    *pPortmask |= (tmpmask & 0x7) << 8;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicL2LookupTb
+ * Description:
+ *      Set filtering database entry
+ * Input:
+ *      pL2Table    - L2 table entry writing to 8K+64 filtering database
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicL2LookupTb(rtl8367c_luttb *pL2Table)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint16 *accessPtr;
+    rtk_uint32 i;
+    rtk_uint16 smil2Table[RTL8367C_LUT_TABLE_SIZE];
+    rtk_uint32 tblCmd;
+    rtk_uint32 busyCounter;
+
+    memset(smil2Table, 0x00, sizeof(rtk_uint16) * RTL8367C_LUT_TABLE_SIZE);
+    _rtl8367c_fdbStUser2Smi(pL2Table, smil2Table);
+
+    if(pL2Table->wait_time == 0)
+        busyCounter = RTL8367C_LUT_BUSY_CHECK_NO;
+    else
+        busyCounter = pL2Table->wait_time;
+
+    while(busyCounter)
+    {
+        retVal = rtl8367c_getAsicRegBit(RTL8367C_TABLE_ACCESS_STATUS_REG, RTL8367C_TABLE_LUT_ADDR_BUSY_FLAG_OFFSET,&regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        pL2Table->lookup_busy = regData;
+        if(!regData)
+            break;
+
+        busyCounter --;
+        if(busyCounter == 0)
+            return RT_ERR_BUSYWAIT_TIMEOUT;
+    }
+
+    accessPtr = smil2Table;
+    regData = *accessPtr;
+    for(i = 0; i < RTL8367C_LUT_ENTRY_SIZE; i++)
+    {
+        retVal = rtl8367c_setAsicReg(RTL8367C_TABLE_ACCESS_WRDATA_BASE + i, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        accessPtr ++;
+        regData = *accessPtr;
+
+    }
+
+    tblCmd = (RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_WRITE,TB_TARGET_L2)) & (RTL8367C_TABLE_TYPE_MASK  | RTL8367C_COMMAND_TYPE_MASK);
+    /* Write Command */
+    retVal = rtl8367c_setAsicReg(RTL8367C_TABLE_ACCESS_CTRL_REG, tblCmd);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    if(pL2Table->wait_time == 0)
+        busyCounter = RTL8367C_LUT_BUSY_CHECK_NO;
+    else
+        busyCounter = pL2Table->wait_time;
+
+    while(busyCounter)
+    {
+        retVal = rtl8367c_getAsicRegBit(RTL8367C_TABLE_ACCESS_STATUS_REG, RTL8367C_TABLE_LUT_ADDR_BUSY_FLAG_OFFSET,&regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        pL2Table->lookup_busy = regData;
+        if(!regData)
+            break;
+
+        busyCounter --;
+        if(busyCounter == 0)
+            return RT_ERR_BUSYWAIT_TIMEOUT;
+    }
+
+    /*Read access status*/
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_TABLE_ACCESS_STATUS_REG, RTL8367C_HIT_STATUS_OFFSET, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pL2Table->lookup_hit = regData;
+    if(!pL2Table->lookup_hit)
+        return RT_ERR_FAILED;
+
+    /*Read access address*/
+    /*
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_TABLE_ACCESS_STATUS_REG, RTL8367C_TABLE_LUT_ADDR_TYPE_MASK | RTL8367C_TABLE_LUT_ADDR_ADDRESS_MASK,&regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pL2Table->address = regData;*/
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_TABLE_ACCESS_STATUS_REG, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pL2Table->address = (regData & 0x7ff) | ((regData & 0x4000) >> 3) | ((regData & 0x800) << 1);
+    pL2Table->lookup_busy = 0;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicL2LookupTb
+ * Description:
+ *      Get filtering database entry
+ * Input:
+ *      pL2Table    - L2 table entry writing to 2K+64 filtering database
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameter
+ *      RT_ERR_BUSYWAIT_TIMEOUT - LUT is busy at retrieving
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicL2LookupTb(rtk_uint32 method, rtl8367c_luttb *pL2Table)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint16* accessPtr;
+    rtk_uint32 i;
+    rtk_uint16 smil2Table[RTL8367C_LUT_TABLE_SIZE];
+    rtk_uint32 busyCounter;
+    rtk_uint32 tblCmd;
+
+    if(pL2Table->wait_time == 0)
+        busyCounter = RTL8367C_LUT_BUSY_CHECK_NO;
+    else
+        busyCounter = pL2Table->wait_time;
+
+    while(busyCounter)
+    {
+        retVal = rtl8367c_getAsicRegBit(RTL8367C_TABLE_ACCESS_STATUS_REG, RTL8367C_TABLE_LUT_ADDR_BUSY_FLAG_OFFSET,&regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        pL2Table->lookup_busy = regData;
+        if(!pL2Table->lookup_busy)
+            break;
+
+        busyCounter --;
+        if(busyCounter == 0)
+            return RT_ERR_BUSYWAIT_TIMEOUT;
+    }
+
+
+    tblCmd = (method << RTL8367C_ACCESS_METHOD_OFFSET) & RTL8367C_ACCESS_METHOD_MASK;
+
+    switch(method)
+    {
+        case LUTREADMETHOD_ADDRESS:
+        case LUTREADMETHOD_NEXT_ADDRESS:
+        case LUTREADMETHOD_NEXT_L2UC:
+        case LUTREADMETHOD_NEXT_L2MC:
+        case LUTREADMETHOD_NEXT_L3MC:
+        case LUTREADMETHOD_NEXT_L2L3MC:
+            retVal = rtl8367c_setAsicReg(RTL8367C_TABLE_ACCESS_ADDR_REG, pL2Table->address);
+            if(retVal != RT_ERR_OK)
+                return retVal;
+            break;
+        case LUTREADMETHOD_MAC:
+            memset(smil2Table, 0x00, sizeof(rtk_uint16) * RTL8367C_LUT_TABLE_SIZE);
+            _rtl8367c_fdbStUser2Smi(pL2Table, smil2Table);
+
+            accessPtr = smil2Table;
+            regData = *accessPtr;
+            for(i=0; i<RTL8367C_LUT_ENTRY_SIZE; i++)
+            {
+                retVal = rtl8367c_setAsicReg(RTL8367C_TABLE_ACCESS_WRDATA_BASE + i, regData);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+
+                accessPtr ++;
+                regData = *accessPtr;
+
+            }
+            break;
+        case LUTREADMETHOD_NEXT_L2UCSPA:
+            retVal = rtl8367c_setAsicReg(RTL8367C_TABLE_ACCESS_ADDR_REG, pL2Table->address);
+            if(retVal != RT_ERR_OK)
+                return retVal;
+
+            tblCmd = tblCmd | ((pL2Table->spa << RTL8367C_TABLE_ACCESS_CTRL_SPA_OFFSET) & RTL8367C_TABLE_ACCESS_CTRL_SPA_MASK);
+
+            break;
+        default:
+            return RT_ERR_INPUT;
+    }
+
+    tblCmd = tblCmd | ((RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_READ,TB_TARGET_L2)) & (RTL8367C_TABLE_TYPE_MASK  | RTL8367C_COMMAND_TYPE_MASK));
+    /* Read Command */
+    retVal = rtl8367c_setAsicReg(RTL8367C_TABLE_ACCESS_CTRL_REG, tblCmd);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    if(pL2Table->wait_time == 0)
+        busyCounter = RTL8367C_LUT_BUSY_CHECK_NO;
+    else
+        busyCounter = pL2Table->wait_time;
+
+    while(busyCounter)
+    {
+        retVal = rtl8367c_getAsicRegBit(RTL8367C_TABLE_ACCESS_STATUS_REG, RTL8367C_TABLE_LUT_ADDR_BUSY_FLAG_OFFSET,&regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        pL2Table->lookup_busy = regData;
+        if(!pL2Table->lookup_busy)
+            break;
+
+        busyCounter --;
+        if(busyCounter == 0)
+            return RT_ERR_BUSYWAIT_TIMEOUT;
+    }
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_TABLE_ACCESS_STATUS_REG, RTL8367C_HIT_STATUS_OFFSET,&regData);
+    if(retVal != RT_ERR_OK)
+            return retVal;
+    pL2Table->lookup_hit = regData;
+    if(!pL2Table->lookup_hit)
+        return RT_ERR_L2_ENTRY_NOTFOUND;
+
+    /*Read access address*/
+    //retVal = rtl8367c_getAsicRegBits(RTL8367C_TABLE_ACCESS_STATUS_REG, RTL8367C_TABLE_LUT_ADDR_TYPE_MASK | RTL8367C_TABLE_LUT_ADDR_ADDRESS_MASK,&regData);
+    retVal = rtl8367c_getAsicReg(RTL8367C_TABLE_ACCESS_STATUS_REG, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pL2Table->address = (regData & 0x7ff) | ((regData & 0x4000) >> 3) | ((regData & 0x800) << 1);
+
+    /*read L2 entry */
+    memset(smil2Table, 0x00, sizeof(rtk_uint16) * RTL8367C_LUT_TABLE_SIZE);
+
+    accessPtr = smil2Table;
+
+    for(i = 0; i < RTL8367C_LUT_ENTRY_SIZE; i++)
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_TABLE_ACCESS_RDDATA_BASE + i, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *accessPtr = regData;
+
+        accessPtr ++;
+    }
+
+    _rtl8367c_fdbStSmi2User(pL2Table, smil2Table);
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutLearnNo
+ * Description:
+ *      Get per-Port auto learning number
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pNumber     - ASIC auto learning entries number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ /*޸RTL8367C_PORTIDMAX, RTL8367C_REG_L2_LRN_CNT_REG, port10 reg is not contnious, wait for updating of base.h*/
+ret_t rtl8367c_getAsicLutLearnNo(rtk_uint32 port, rtk_uint32* pNumber)
+{
+    ret_t retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 10)
+    {
+     retVal = rtl8367c_getAsicReg(RTL8367C_REG_L2_LRN_CNT_REG(port), pNumber);
+        if (retVal != RT_ERR_OK)
+         return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_REG_L2_LRN_CNT_CTRL10, pNumber);
+        if (retVal != RT_ERR_OK)
+         return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicLutFlushAll
+ * Description:
+ *      Flush all entries in LUT. Includes static & dynamic entries
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutFlushAll(void)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_L2_FLUSH_CTRL3, RTL8367C_L2_FLUSH_CTRL3_OFFSET, 1);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicLutFlushAllStatus
+ * Description:
+ *      Get Flush all status, 1:Busy, 0 normal
+ * Input:
+ *      None
+ * Output:
+ *      pBusyStatus - Busy state
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutFlushAllStatus(rtk_uint32 *pBusyStatus)
+{
+    if(NULL == pBusyStatus)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_L2_FLUSH_CTRL3, RTL8367C_L2_FLUSH_CTRL3_OFFSET, pBusyStatus);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicLutForceFlush
+ * Description:
+ *      Set per port force flush setting
+ * Input:
+ *      portmask    - portmask(0~0xFF)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask
+ * Note:
+ *      None
+ */
+ /*port8~port10һregister, wait for updating of base.h, reg.h*/
+ret_t rtl8367c_setAsicLutForceFlush(rtk_uint32 portmask)
+{
+    ret_t retVal;
+
+    if(portmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_FORCE_FLUSH_REG, RTL8367C_FORCE_FLUSH_PORTMASK_MASK, portmask & 0xff);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_FORCE_FLUSH1, RTL8367C_PORTMASK1_MASK, (portmask >> 8) & 0x7);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutForceFlushStatus
+ * Description:
+ *      Get per port force flush status
+ * Input:
+ *      pPortmask   - portmask(0~0xFF)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ /*port8~port10һregister, wait for updating of base.h, reg.h*/
+ret_t rtl8367c_getAsicLutForceFlushStatus(rtk_uint32 *pPortmask)
+{
+    rtk_uint32 tmpMask;
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_FORCE_FLUSH_REG, RTL8367C_BUSY_STATUS_MASK,&tmpMask);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    *pPortmask = tmpMask & 0xff;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_FORCE_FLUSH1, RTL8367C_BUSY_STATUS1_MASK,&tmpMask);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    *pPortmask |= (tmpMask & 7) << 8;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicLutFlushMode
+ * Description:
+ *      Set user force L2 pLutSt table flush mode
+ * Input:
+ *      mode    - 0:Port based 1: Port + VLAN based 2:Port + FID/MSTI based
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NOT_ALLOWED  - Actions not allowed by the function
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutFlushMode(rtk_uint32 mode)
+{
+    if( mode >= FLUSHMDOE_END )
+        return RT_ERR_NOT_ALLOWED;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL2, RTL8367C_LUT_FLUSH_MODE_MASK, mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutFlushMode
+ * Description:
+ *      Get user force L2 pLutSt table flush mode
+ * Input:
+ *      pMode   - 0:Port based 1: Port + VLAN based 2:Port + FID/MSTI based
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutFlushMode(rtk_uint32* pMode)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL2, RTL8367C_LUT_FLUSH_MODE_MASK, pMode);
+}
+/* Function Name:
+ *      rtl8367c_setAsicLutFlushType
+ * Description:
+ *      Get L2 LUT flush type
+ * Input:
+ *      type    - 0: dynamice unicast; 1: both dynamic and static unicast entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutFlushType(rtk_uint32 type)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_L2_FLUSH_CTRL2, RTL8367C_LUT_FLUSH_TYPE_OFFSET,type);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutFlushType
+ * Description:
+ *      Set L2 LUT flush type
+ * Input:
+ *      pType   - 0: dynamice unicast; 1: both dynamic and static unicast entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutFlushType(rtk_uint32* pType)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_L2_FLUSH_CTRL2, RTL8367C_LUT_FLUSH_TYPE_OFFSET,pType);
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicLutFlushVid
+ * Description:
+ *      Set VID of Port + VID pLutSt flush mode
+ * Input:
+ *      vid     - Vid (0~4095)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_VLAN_VID - Invalid VID parameter (0~4095)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutFlushVid(rtk_uint32 vid)
+{
+    if( vid > RTL8367C_VIDMAX )
+        return RT_ERR_VLAN_VID;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL1, RTL8367C_LUT_FLUSH_VID_MASK, vid);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutFlushVid
+ * Description:
+ *      Get VID of Port + VID pLutSt flush mode
+ * Input:
+ *      pVid    - Vid (0~4095)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutFlushVid(rtk_uint32* pVid)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL1, RTL8367C_LUT_FLUSH_VID_MASK, pVid);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortFlusdFid
+ * Description:
+ *      Set FID of Port + FID pLutSt flush mode
+ * Input:
+ *      fid     - FID/MSTI for force flush
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_L2_FID   - Invalid FID (0~15)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutFlushFid(rtk_uint32 fid)
+{
+    if( fid > RTL8367C_FIDMAX )
+        return RT_ERR_L2_FID;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL1, RTL8367C_LUT_FLUSH_FID_MASK, fid);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutFlushFid
+ * Description:
+ *      Get FID of Port + FID pLutSt flush mode
+ * Input:
+ *      pFid    - FID/MSTI for force flush
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutFlushFid(rtk_uint32* pFid)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_L2_FLUSH_CTRL1, RTL8367C_LUT_FLUSH_FID_MASK, pFid);
+}
+/* Function Name:
+ *      rtl8367c_setAsicLutDisableAging
+ * Description:
+ *      Set L2 LUT aging per port setting
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      disabled    - 0: enable aging; 1: disabling aging
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ /*޸RTL8367C_PORTIDMAX*/
+ret_t rtl8367c_setAsicLutDisableAging(rtk_uint32 port, rtk_uint32 disabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_LUT_AGEOUT_CTRL_REG, port, disabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicLutDisableAging
+ * Description:
+ *      Get L2 LUT aging per port setting
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pDisabled - 0: enable aging; 1: disabling aging
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ /*޸RTL8367C_PORTIDMAX*/
+ret_t rtl8367c_getAsicLutDisableAging(rtk_uint32 port, rtk_uint32 *pDisabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_LUT_AGEOUT_CTRL_REG, port, pDisabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicLutIPMCGroup
+ * Description:
+ *      Set IPMC Group Table
+ * Input:
+ *      index       - the entry index in table (0 ~ 63)
+ *      group_addr  - the multicast group address (224.0.0.0 ~ 239.255.255.255)
+ *      vid         - VLAN ID
+ *      pmask       - portmask
+ *      valid       - valid bit
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Invalid parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutIPMCGroup(rtk_uint32 index, ipaddr_t group_addr, rtk_uint32 vid, rtk_uint32 pmask, rtk_uint32 valid)
+{
+    rtk_uint32  regAddr, regData, bitoffset;
+    ipaddr_t    ipData;
+    ret_t       retVal;
+
+    if(index > RTL8367C_LUT_IPMCGRP_TABLE_MAX)
+        return RT_ERR_INPUT;
+
+    if (vid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    ipData = group_addr;
+
+    if( (ipData & 0xF0000000) != 0xE0000000)    /* not in 224.0.0.0 ~ 239.255.255.255 */
+        return RT_ERR_INPUT;
+
+    /* Group Address */
+    regAddr = RTL8367C_REG_IPMC_GROUP_ENTRY0_H + (index * 2);
+    regData = ((ipData & 0x0FFFFFFF) >> 16);
+
+    if( (retVal = rtl8367c_setAsicReg(regAddr, regData)) != RT_ERR_OK)
+        return retVal;
+
+    regAddr++;
+    regData = (ipData & 0x0000FFFF);
+
+    if( (retVal = rtl8367c_setAsicReg(regAddr, regData)) != RT_ERR_OK)
+        return retVal;
+
+    /* VID */
+    regAddr = RTL8367C_REG_IPMC_GROUP_VID_00 + index;
+    regData = vid;
+
+    if( (retVal = rtl8367c_setAsicReg(regAddr, regData)) != RT_ERR_OK)
+        return retVal;
+
+    /* portmask */
+    regAddr = RTL8367C_REG_IPMC_GROUP_PMSK_00 + index;
+    regData = pmask;
+
+    if( (retVal = rtl8367c_setAsicReg(regAddr, regData)) != RT_ERR_OK)
+        return retVal;
+
+    /* valid */
+    regAddr = RTL8367C_REG_IPMC_GROUP_VALID_15_0 + (index / 16);
+    bitoffset = index % 16;
+    if( (retVal = rtl8367c_setAsicRegBit(regAddr, bitoffset, valid)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicLutIPMCGroup
+ * Description:
+ *      Set IPMC Group Table
+ * Input:
+ *      index       - the entry index in table (0 ~ 63)
+ * Output:
+ *      pGroup_addr - the multicast group address (224.0.0.0 ~ 239.255.255.255)
+ *      pVid        - VLAN ID
+ *      pPmask      - portmask
+ *      pValid      - Valid bit
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Invalid parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutIPMCGroup(rtk_uint32 index, ipaddr_t *pGroup_addr, rtk_uint32 *pVid, rtk_uint32 *pPmask, rtk_uint32 *pValid)
+{
+    rtk_uint32      regAddr, regData, bitoffset;
+    ipaddr_t    ipData;
+    ret_t       retVal;
+
+    if(index > RTL8367C_LUT_IPMCGRP_TABLE_MAX)
+        return RT_ERR_INPUT;
+
+    if (NULL == pGroup_addr)
+        return RT_ERR_NULL_POINTER;
+
+    if (NULL == pVid)
+        return RT_ERR_NULL_POINTER;
+
+    if (NULL == pPmask)
+        return RT_ERR_NULL_POINTER;
+
+    /* Group address */
+    regAddr = RTL8367C_REG_IPMC_GROUP_ENTRY0_H + (index * 2);
+    if( (retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    *pGroup_addr = (((regData & 0x00000FFF) << 16) | 0xE0000000);
+
+    regAddr++;
+    if( (retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    ipData = (*pGroup_addr | (regData & 0x0000FFFF));
+    *pGroup_addr = ipData;
+
+    /* VID */
+    regAddr = RTL8367C_REG_IPMC_GROUP_VID_00 + index;
+    if( (retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    *pVid = regData;
+
+    /* portmask */
+    regAddr = RTL8367C_REG_IPMC_GROUP_PMSK_00 + index;
+    if( (retVal = rtl8367c_getAsicReg(regAddr, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    *pPmask = regData;
+
+    /* valid */
+    regAddr = RTL8367C_REG_IPMC_GROUP_VALID_15_0 + (index / 16);
+    bitoffset = index % 16;
+    if( (retVal = rtl8367c_getAsicRegBit(regAddr, bitoffset, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    *pValid = regData;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicLutLinkDownForceAging
+ * Description:
+ *       Set LUT link down aging setting.
+ * Input:
+ *      enable      - link down aging setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_ENABLE    - Invalid parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutLinkDownForceAging(rtk_uint32 enable)
+{
+    if(enable > 1)
+        return RT_ERR_ENABLE;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LINKDOWN_AGEOUT_OFFSET, enable ? 0 : 1);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicLutLinkDownForceAging
+ * Description:
+ *       Get LUT link down aging setting.
+ * Input:
+ *      pEnable         - link down aging setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_ENABLE    - Invalid parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutLinkDownForceAging(rtk_uint32 *pEnable)
+{
+    rtk_uint32  value;
+    ret_t   retVal;
+
+    if ((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG, RTL8367C_LINKDOWN_AGEOUT_OFFSET, &value)) != RT_ERR_OK)
+        return retVal;
+
+    *pEnable = value ? 0 : 1;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicLutIpmcFwdRouterPort
+ * Description:
+ *       Set IPMC packet forward to rounter port also or not
+ * Input:
+ *      enable      - 1: Inlcude router port, 0, exclude router port
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_ENABLE     Invalid parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLutIpmcFwdRouterPort(rtk_uint32 enable)
+{
+    if(enable > 1)
+        return RT_ERR_ENABLE;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_LUT_CFG2, RTL8367C_LUT_IPMC_FWD_RPORT_OFFSET, enable);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicLutIpmcFwdRouterPort
+ * Description:
+ *       Get IPMC packet forward to rounter port also or not
+ * Input:
+ *      None
+ * Output:
+ *      pEnable         - 1: Inlcude router port, 0, exclude router port
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Null pointer
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLutIpmcFwdRouterPort(rtk_uint32 *pEnable)
+{
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_LUT_CFG2, RTL8367C_LUT_IPMC_FWD_RPORT_OFFSET, pEnable);
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_meter.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_meter.c
new file mode 100644
index 0000000000000..5412591a82452
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_meter.c
@@ -0,0 +1,305 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Shared meter related functions
+ *
+ */
+#include <rtl8367c_asicdrv_meter.h>
+/* Function Name:
+ *      rtl8367c_setAsicShareMeter
+ * Description:
+ *      Set meter configuration
+ * Input:
+ *      index   - hared meter index (0-31)
+ *      rate    - 17-bits rate of share meter, unit is 8Kpbs
+ *      ifg     - Including IFG in rate calculation, 1:include 0:exclude
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicShareMeter(rtk_uint32 index, rtk_uint32 rate, rtk_uint32 ifg)
+{
+    ret_t retVal;
+
+    if(index > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(index < 32)
+    {
+    /*19-bits Rate*/
+        retVal = rtl8367c_setAsicReg(RTL8367C_METER_RATE_REG(index), rate&0xFFFF);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        retVal = rtl8367c_setAsicReg(RTL8367C_METER_RATE_REG(index) + 1, (rate &0x70000) >> 16);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        retVal = rtl8367c_setAsicRegBit(RTL8367C_METER_IFG_CTRL_REG(index), RTL8367C_METER_IFG_OFFSET(index), ifg);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+    /*19-bits Rate*/
+        retVal = rtl8367c_setAsicReg(RTL8367C_REG_METER32_RATE_CTRL0 + ((index-32) << 1), rate&0xFFFF);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        retVal = rtl8367c_setAsicReg(RTL8367C_REG_METER32_RATE_CTRL0 + ((index-32) << 1) + 1, (rate &0x70000) >> 16);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_METER_IFG_CTRL2 + ((index-32) >> 4), RTL8367C_METER_IFG_OFFSET(index), ifg);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicShareMeter
+ * Description:
+ *      Get meter configuration
+ * Input:
+ *      index   - hared meter index (0-31)
+ *      pRate   - 17-bits rate of share meter, unit is 8Kpbs
+ *      pIfg    - Including IFG in rate calculation, 1:include 0:exclude
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicShareMeter(rtk_uint32 index, rtk_uint32 *pRate, rtk_uint32 *pIfg)
+{
+    rtk_uint32 regData;
+    rtk_uint32 regData2;
+    ret_t retVal;
+
+    if(index > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(index < 32)
+    {
+    /*17-bits Rate*/
+     retVal = rtl8367c_getAsicReg(RTL8367C_METER_RATE_REG(index), &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+     retVal = rtl8367c_getAsicReg(RTL8367C_METER_RATE_REG(index) + 1, &regData2);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+    *pRate = ((regData2 << 16) & 0x70000) | regData;
+    /*IFG*/
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_METER_IFG_CTRL_REG(index), RTL8367C_METER_IFG_OFFSET(index), pIfg);
+
+    return retVal;
+    }
+    else
+    {
+    /*17-bits Rate*/
+     retVal = rtl8367c_getAsicReg(RTL8367C_REG_METER32_RATE_CTRL0 + ((index-32) << 1), &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+     retVal = rtl8367c_getAsicReg(RTL8367C_REG_METER32_RATE_CTRL0 + ((index-32) << 1) + 1, &regData2);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+    *pRate = ((regData2 << 16) & 0x70000) | regData;
+    /*IFG*/
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_METER_IFG_CTRL2 + ((index-32) >> 4), RTL8367C_METER_IFG_OFFSET(index), pIfg);
+
+    return retVal;
+    }
+}
+/* Function Name:
+ *      rtl8367c_setAsicShareMeterBucketSize
+ * Description:
+ *      Set meter related leaky bucket threshold
+ * Input:
+ *      index       - hared meter index (0-31)
+ *      lbthreshold - Leaky bucket threshold of meter
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicShareMeterBucketSize(rtk_uint32 index, rtk_uint32 lbthreshold)
+{
+
+    if(index > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(index < 32)
+    return rtl8367c_setAsicReg(RTL8367C_METER_BUCKET_SIZE_REG(index), lbthreshold);
+    else
+       return rtl8367c_setAsicReg(RTL8367C_REG_METER32_BUCKET_SIZE + index - 32, lbthreshold);
+}
+/* Function Name:
+ *      rtl8367c_getAsicShareMeterBucketSize
+ * Description:
+ *      Get meter related leaky bucket threshold
+ * Input:
+ *      index       - hared meter index (0-31)
+ *      pLbthreshold - Leaky bucket threshold of meter
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicShareMeterBucketSize(rtk_uint32 index, rtk_uint32 *pLbthreshold)
+{
+    if(index > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(index < 32)
+    return rtl8367c_getAsicReg(RTL8367C_METER_BUCKET_SIZE_REG(index), pLbthreshold);
+    else
+       return rtl8367c_getAsicReg(RTL8367C_REG_METER32_BUCKET_SIZE + index - 32, pLbthreshold);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicShareMeterType
+ * Description:
+ *      Set meter Type
+ * Input:
+ *      index       - shared meter index (0-31)
+ *      Type        - 0: kbps, 1: pps
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicShareMeterType(rtk_uint32 index, rtk_uint32 type)
+{
+    rtk_uint32 reg;
+
+    if(index > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(index < 32)
+        reg = RTL8367C_REG_METER_MODE_SETTING0 + (index / 16);
+    else
+        reg = RTL8367C_REG_METER_MODE_SETTING2 + ((index - 32) / 16);
+    return rtl8367c_setAsicRegBit(reg, index % 16, type);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicShareMeterType
+ * Description:
+ *      Get meter Type
+ * Input:
+ *      index       - shared meter index (0-31)
+ * Output:
+ *      pType       - 0: kbps, 1: pps
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicShareMeterType(rtk_uint32 index, rtk_uint32 *pType)
+{
+    rtk_uint32 reg;
+
+    if(index > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(NULL == pType)
+        return RT_ERR_NULL_POINTER;
+
+    if(index < 32)
+        reg = RTL8367C_REG_METER_MODE_SETTING0 + (index / 16);
+    else
+        reg = RTL8367C_REG_METER_MODE_SETTING2 + ((index - 32) / 16);
+    return rtl8367c_getAsicRegBit(reg, index % 16, pType);
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicMeterExceedStatus
+ * Description:
+ *      Clear shared meter status
+ * Input:
+ *      index       - hared meter index (0-31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMeterExceedStatus(rtk_uint32 index)
+{
+    if(index > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(index < 32)
+        return rtl8367c_setAsicRegBit(RTL8367C_METER_OVERRATE_INDICATOR_REG(index), RTL8367C_METER_EXCEED_OFFSET(index), 1);
+    else
+        return rtl8367c_setAsicRegBit(RTL8367C_REG_METER_OVERRATE_INDICATOR2 + ((index - 32) >> 4), RTL8367C_METER_EXCEED_OFFSET(index), 1);
+
+}
+/* Function Name:
+ *      rtl8367c_getAsicMeterExceedStatus
+ * Description:
+ *      Get shared meter status
+ * Input:
+ *      index   - hared meter index (0-31)
+ *      pStatus     - 0: rate doesn't exceed    1: rate exceeds
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      If rate is over rate*8Kbps of a meter, the state bit of this meter is set to 1.
+ */
+ret_t rtl8367c_getAsicMeterExceedStatus(rtk_uint32 index, rtk_uint32* pStatus)
+{
+    if(index > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(index < 32)
+        return rtl8367c_getAsicRegBit(RTL8367C_METER_OVERRATE_INDICATOR_REG(index), RTL8367C_METER_EXCEED_OFFSET(index), pStatus);
+    else
+        return rtl8367c_getAsicRegBit(RTL8367C_REG_METER_OVERRATE_INDICATOR2 + ((index - 32) >> 4), RTL8367C_METER_EXCEED_OFFSET(index), pStatus);
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_mib.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_mib.c
new file mode 100644
index 0000000000000..c9aaa01d3e2ec
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_mib.c
@@ -0,0 +1,570 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : MIB related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_mib.h>
+/* Function Name:
+ *      rtl8367c_setAsicMIBsCounterReset
+ * Description:
+ *      Reset global/queue manage or per-port MIB counter
+ * Input:
+ *      greset  - Global reset
+ *      qmreset - Queue maganement reset
+ *      portmask    - Port reset mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMIBsCounterReset(rtk_uint32 greset, rtk_uint32 qmreset, rtk_uint32 portmask)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint32 regBits;
+
+    regBits = RTL8367C_GLOBAL_RESET_MASK |
+                RTL8367C_QM_RESET_MASK |
+                    RTL8367C_MIB_PORT07_MASK |
+                    ((rtk_uint32)0x7 << 13);
+    regData = ((greset << RTL8367C_GLOBAL_RESET_OFFSET) & RTL8367C_GLOBAL_RESET_MASK) |
+                ((qmreset << RTL8367C_QM_RESET_OFFSET) & RTL8367C_QM_RESET_MASK) |
+                (((portmask & 0xFF) << RTL8367C_PORT0_RESET_OFFSET) & RTL8367C_MIB_PORT07_MASK) |
+                (((portmask >> 8)&0x7) << 13);
+
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_MIB_CTRL0, regBits, (regData >> RTL8367C_PORT0_RESET_OFFSET));
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicMIBsCounter
+ * Description:
+ *      Get MIBs counter
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      mibIdx      - MIB counter index
+ *      pCounter    - MIB retrived counter
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number
+ *      RT_ERR_BUSYWAIT_TIMEOUT - MIB is busy at retrieving
+ *      RT_ERR_STAT_CNTR_FAIL   - MIB is resetting
+ * Note:
+ *      Before MIBs counter retrieving, writting accessing address to ASIC at first and check the MIB
+ *      control register status. If busy bit of MIB control is set, that means MIB counter have been
+ *      waiting for preparing, then software must wait atfer this busy flag reset by ASIC. This driver
+ *      did not recycle reading user desired counter. Software must use driver again to get MIB counter
+ *      if return value is not RT_ERR_OK.
+ */
+ret_t rtl8367c_getAsicMIBsCounter(rtk_uint32 port, RTL8367C_MIBCOUNTER mibIdx, rtk_uint64* pCounter)
+{
+    ret_t retVal;
+    rtk_uint32 regAddr;
+    rtk_uint32 regData;
+    rtk_uint32 mibAddr;
+    rtk_uint32 mibOff=0;
+
+    /* address offset to MIBs counter */
+    CONST rtk_uint16 mibLength[RTL8367C_MIBS_NUMBER]= {
+        4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+        4,2,2,2,2,2,2,2,2,
+        4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2};
+
+    rtk_uint16 i;
+    rtk_uint64 mibCounter;
+
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(mibIdx >= RTL8367C_MIBS_NUMBER)
+        return RT_ERR_STAT_INVALID_CNTR;
+
+    if(dot1dTpLearnedEntryDiscards == mibIdx)
+    {
+        mibAddr = RTL8367C_MIB_LEARNENTRYDISCARD_OFFSET;
+    }
+    else
+    {
+        i = 0;
+        mibOff = RTL8367C_MIB_PORT_OFFSET * port;
+
+        if(port > 7)
+            mibOff = mibOff + 68;
+
+        while(i < mibIdx)
+        {
+            mibOff += mibLength[i];
+            i++;
+        }
+
+        mibAddr = mibOff;
+    }
+
+
+    /*writing access counter address first*/
+    /*This address is SRAM address, and SRAM address = MIB register address >> 2*/
+    /*then ASIC will prepare 64bits counter wait for being retrived*/
+    /*Write Mib related address to access control register*/
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_MIB_ADDRESS, (mibAddr >> 2));
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+
+
+    /* polling busy flag */
+    i = 100;
+    while(i > 0)
+    {
+        /*read MIB control register*/
+        retVal = rtl8367c_getAsicReg(RTL8367C_MIB_CTRL_REG,&regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        if((regData & RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK) == 0)
+        {
+            break;
+        }
+
+        i--;
+    }
+
+    if(regData & RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK)
+        return RT_ERR_BUSYWAIT_TIMEOUT;
+
+    if(regData & RTL8367C_RESET_FLAG_MASK)
+        return RT_ERR_STAT_CNTR_FAIL;
+
+    mibCounter = 0;
+    i = mibLength[mibIdx];
+    if(4 == i)
+        regAddr = RTL8367C_MIB_COUNTER_BASE_REG + 3;
+    else
+        regAddr = RTL8367C_MIB_COUNTER_BASE_REG + ((mibOff + 1) % 4);
+
+    while(i)
+    {
+        retVal = rtl8367c_getAsicReg(regAddr, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        mibCounter = (mibCounter << 16) | (regData & 0xFFFF);
+
+        regAddr --;
+        i --;
+
+    }
+
+    *pCounter = mibCounter;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicMIBsLogCounter
+ * Description:
+ *      Get MIBs Loggin counter
+ * Input:
+ *      index       - The index of 32 logging counter (0 ~ 31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_ENTRY_INDEX      - Wrong index
+ *      RT_ERR_BUSYWAIT_TIMEOUT - MIB is busy at retrieving
+ *      RT_ERR_STAT_CNTR_FAIL   - MIB is resetting
+ * Note:
+ *      This API get 32 logging counter
+ */
+ret_t rtl8367c_getAsicMIBsLogCounter(rtk_uint32 index, rtk_uint32 *pCounter)
+{
+    ret_t retVal;
+    rtk_uint32 regAddr;
+    rtk_uint32 regData;
+    rtk_uint32 mibAddr;
+    rtk_uint16 i;
+    rtk_uint64 mibCounter;
+
+    if(index > RTL8367C_MIB_MAX_LOG_CNT_IDX)
+        return RT_ERR_ENTRY_INDEX;
+
+    mibAddr = RTL8367C_MIB_LOG_CNT_OFFSET + ((index / 2) * 4);
+
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_MIB_ADDRESS, (mibAddr >> 2));
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /*read MIB control register*/
+    retVal = rtl8367c_getAsicReg(RTL8367C_MIB_CTRL_REG, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    if(regData & RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK)
+        return RT_ERR_BUSYWAIT_TIMEOUT;
+
+    if(regData & RTL8367C_RESET_FLAG_MASK)
+        return RT_ERR_STAT_CNTR_FAIL;
+
+    mibCounter = 0;
+    if((index % 2) == 1)
+        regAddr = RTL8367C_MIB_COUNTER_BASE_REG + 3;
+    else
+        regAddr = RTL8367C_MIB_COUNTER_BASE_REG + 1;
+
+    for(i = 0; i <= 1; i++)
+    {
+        retVal = rtl8367c_getAsicReg(regAddr, &regData);
+
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        mibCounter = (mibCounter << 16) | (regData & 0xFFFF);
+
+        regAddr --;
+    }
+
+    *pCounter = mibCounter;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicMIBsControl
+ * Description:
+ *      Get MIB control register
+ * Input:
+ *      pMask       - MIB control status mask bit[0]-busy bit[1]
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ * Note:
+ *      Software need to check this control register atfer doing port resetting or global resetting
+ */
+ret_t rtl8367c_getAsicMIBsControl(rtk_uint32* pMask)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_MIB_CTRL_REG, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pMask = regData & (RTL8367C_MIB_CTRL0_BUSY_FLAG_MASK | RTL8367C_RESET_FLAG_MASK);
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicMIBsResetValue
+ * Description:
+ *      Reset all counter to 0 or 1
+ * Input:
+ *      value           - Reset to value 0 or 1
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMIBsResetValue(rtk_uint32 value)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_CTRL0, RTL8367C_RESET_VALUE_OFFSET, value);
+}
+/* Function Name:
+ *      rtl8367c_getAsicMIBsResetValue
+ * Description:
+ *      Reset all counter to 0 or 1
+ * Input:
+ *      value           - Reset to value 0 or 1
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMIBsResetValue(rtk_uint32* value)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_CTRL0, RTL8367C_RESET_VALUE_OFFSET, value);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicMIBsUsageMode
+ * Description:
+ *      MIB update mode
+ * Input:
+ *      mode            - 1: latch all MIBs by timer 0:normal free run counting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMIBsUsageMode(rtk_uint32 mode)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_CTRL4, RTL8367C_MIB_USAGE_MODE_OFFSET, mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicMIBsUsageMode
+ * Description:
+ *      MIB update mode
+ * Input:
+ *      pMode           - 1: latch all MIBs by timer 0:normal free run counting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMIBsUsageMode(rtk_uint32* pMode)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_CTRL4, RTL8367C_MIB_USAGE_MODE_OFFSET, pMode);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicMIBsTimer
+ * Description:
+ *      MIB latching timer
+ * Input:
+ *      timer           - latch timer, unit 1 second
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMIBsTimer(rtk_uint32 timer)
+{
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_MIB_CTRL4, RTL8367C_MIB_TIMER_MASK, timer);
+}
+/* Function Name:
+ *      rtl8367c_getAsicMIBsTimer
+ * Description:
+ *      MIB latching timer
+ * Input:
+ *      pTimer          - latch timer, unit 1 second
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMIBsTimer(rtk_uint32* pTimer)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_MIB_CTRL4, RTL8367C_MIB_TIMER_MASK, pTimer);
+}
+/* Function Name:
+ *      rtl8367c_setAsicMIBsLoggingMode
+ * Description:
+ *      MIB logging counter mode
+ * Input:
+ *      index   - logging counter mode index (0~15)
+ *      mode    - 0:32-bits mode 1:64-bits mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMIBsLoggingMode(rtk_uint32 index, rtk_uint32 mode)
+{
+    if(index > RTL8367C_MIB_MAX_LOG_MODE_IDX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_CTRL3, index,mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicMIBsLoggingMode
+ * Description:
+ *      MIB logging counter mode
+ * Input:
+ *      index   - logging counter mode index (0~15)
+ *      pMode   - 0:32-bits mode 1:64-bits mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMIBsLoggingMode(rtk_uint32 index, rtk_uint32* pMode)
+{
+    if(index > RTL8367C_MIB_MAX_LOG_MODE_IDX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_CTRL3, index,pMode);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicMIBsLoggingType
+ * Description:
+ *      MIB logging counter type
+ * Input:
+ *      index   - logging counter mode index (0~15)
+ *      type    - 0:Packet count 1:Byte count
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMIBsLoggingType(rtk_uint32 index, rtk_uint32 type)
+{
+    if(index > RTL8367C_MIB_MAX_LOG_MODE_IDX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_CTRL5, index,type);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicMIBsLoggingType
+ * Description:
+ *      MIB logging counter type
+ * Input:
+ *      index   - logging counter mode index (0~15)
+ *      pType   - 0:Packet count 1:Byte count
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMIBsLoggingType(rtk_uint32 index, rtk_uint32* pType)
+{
+    if(index > RTL8367C_MIB_MAX_LOG_MODE_IDX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_CTRL5, index,pType);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicMIBsResetLoggingCounter
+ * Description:
+ *      MIB logging counter type
+ * Input:
+ *      index   - logging counter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMIBsResetLoggingCounter(rtk_uint32 index)
+{
+    ret_t retVal;
+
+    if(index > RTL8367C_MIB_MAX_LOG_CNT_IDX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(index < 16)
+        retVal = rtl8367c_setAsicReg(RTL8367C_REG_MIB_CTRL1, 1<<index);
+    else
+        retVal = rtl8367c_setAsicReg(RTL8367C_REG_MIB_CTRL2, 1<<(index-16));
+
+    return retVal;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicMIBsLength
+ * Description:
+ *      Set MIB length couting mode
+ * Input:
+ *      txLengthMode    - 0: tag length doesn't be counted. 1: tag length is counted.
+ *      rxLengthMode    - 0: tag length doesn't be counted. 1: tag length is counted.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMIBsLength(rtk_uint32 txLengthMode, rtk_uint32 rxLengthMode)
+{
+    ret_t retVal;
+
+    if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_RMON_LEN_CTRL, RTL8367C_TX_LENGTH_CTRL_OFFSET, txLengthMode)) != RT_ERR_OK)
+        return retVal;
+
+    if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MIB_RMON_LEN_CTRL, RTL8367C_RX_LENGTH_CTRL_OFFSET, rxLengthMode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicMIBsLength
+ * Description:
+ *      Set MIB length couting mode
+ * Input:
+ *      None.
+ * Output:
+ *      pTxLengthMode - 0: tag length doesn't be counted. 1: tag length is counted.
+ *      pRxLengthMode - 0: tag length doesn't be counted. 1: tag length is counted.
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_OUT_OF_RANGE     - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMIBsLength(rtk_uint32 *pTxLengthMode, rtk_uint32 *pRxLengthMode)
+{
+    ret_t retVal;
+
+    if( (retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_RMON_LEN_CTRL, RTL8367C_TX_LENGTH_CTRL_OFFSET, pTxLengthMode)) != RT_ERR_OK)
+        return retVal;
+
+    if( (retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MIB_RMON_LEN_CTRL, RTL8367C_RX_LENGTH_CTRL_OFFSET, pRxLengthMode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_mirror.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_mirror.c
new file mode 100644
index 0000000000000..de945ff6761d6
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_mirror.c
@@ -0,0 +1,472 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Port mirror related functions
+ *
+ */
+#include <rtl8367c_asicdrv_mirror.h>
+/* Function Name:
+ *      rtl8367c_setAsicPortMirror
+ * Description:
+ *      Set port mirror function
+ * Input:
+ *      source  - Source port
+ *      monitor - Monitor (destination) port
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortMirror(rtk_uint32 source, rtk_uint32 monitor)
+{
+    ret_t retVal;
+
+    if((source > RTL8367C_PORTIDMAX) || (monitor > RTL8367C_PORTIDMAX))
+        return RT_ERR_PORT_ID;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_SOURCE_PORT_MASK, source);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+
+    return rtl8367c_setAsicRegBits(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_MONITOR_PORT_MASK, monitor);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortMirror
+ * Description:
+ *      Get port mirror function
+ * Input:
+ *      pSource     - Source port
+ *      pMonitor - Monitor (destination) port
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortMirror(rtk_uint32 *pSource, rtk_uint32 *pMonitor)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_SOURCE_PORT_MASK, pSource);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_MONITOR_PORT_MASK, pMonitor);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortMirrorRxFunction
+ * Description:
+ *      Set the mirror function on RX of the mirrored
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortMirrorRxFunction(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_RX_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortMirrorRxFunction
+ * Description:
+ *      Get the mirror function on RX of the mirrored
+ * Input:
+ *      pEnabled    - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortMirrorRxFunction(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_RX_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortMirrorTxFunction
+ * Description:
+ *      Set the mirror function on TX of the mirrored
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortMirrorTxFunction(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_TX_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortMirrorTxFunction
+ * Description:
+ *      Get the mirror function on TX of the mirrored
+ * Input:
+ *      pEnabled    - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortMirrorTxFunction(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_TX_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortMirrorIsolation
+ * Description:
+ *      Set the traffic isolation on monitor port
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortMirrorIsolation(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_ISO_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortMirrorIsolation
+ * Description:
+ *      Get the traffic isolation on monitor port
+ * Input:
+ *      pEnabled    - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortMirrorIsolation(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_MIRROR_CTRL_REG, RTL8367C_MIRROR_ISO_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortMirrorMask
+ * Description:
+ *      Set mirror source port mask
+ * Input:
+ *      SourcePortmask  - Source Portmask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_MASK- Port Mask Error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortMirrorMask(rtk_uint32 SourcePortmask)
+{
+    if( SourcePortmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_MIRROR_SRC_PMSK, RTL8367C_MIRROR_SRC_PMSK_MASK, SourcePortmask);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicPortMirrorMask
+ * Description:
+ *      Get mirror source port mask
+ * Input:
+ *      None
+ * Output:
+ *      pSourcePortmask     - Source Portmask
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_MASK- Port Mask Error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortMirrorMask(rtk_uint32 *pSourcePortmask)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_MIRROR_SRC_PMSK, RTL8367C_MIRROR_SRC_PMSK_MASK, pSourcePortmask);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortMirrorVlanRxLeaky
+ * Description:
+ *      Set the mirror function of VLAN RX leaky
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortMirrorVlanRxLeaky(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_RX_VLAN_LEAKY_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortMirrorVlanRxLeaky
+ * Description:
+ *      Get the mirror function of VLAN RX leaky
+ * Input:
+ *      pEnabled    - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortMirrorVlanRxLeaky(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_RX_VLAN_LEAKY_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortMirrorVlanTxLeaky
+ * Description:
+ *      Set the mirror function of VLAN TX leaky
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortMirrorVlanTxLeaky(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_TX_VLAN_LEAKY_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortMirrorVlanTxLeaky
+ * Description:
+ *      Get the mirror function of VLAN TX leaky
+ * Input:
+ *      pEnabled    - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortMirrorVlanTxLeaky(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_TX_VLAN_LEAKY_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortMirrorIsolationRxLeaky
+ * Description:
+ *      Set the mirror function of  Isolation RX leaky
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortMirrorIsolationRxLeaky(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_RX_ISOLATION_LEAKY_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortMirrorIsolationRxLeaky
+ * Description:
+ *      Get the mirror function of VLAN RX leaky
+ * Input:
+ *      pEnabled    - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortMirrorIsolationRxLeaky(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_RX_ISOLATION_LEAKY_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortMirrorIsolationTxLeaky
+ * Description:
+ *      Set the mirror function of Isolation TX leaky
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortMirrorIsolationTxLeaky(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_TX_ISOLATION_LEAKY_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortMirrorIsolationTxLeaky
+ * Description:
+ *      Get the mirror function of VLAN TX leaky
+ * Input:
+ *      pEnabled    - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortMirrorIsolationTxLeaky(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_TX_ISOLATION_LEAKY_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortMirrorRealKeep
+ * Description:
+ *      Set the mirror function of keep format
+ * Input:
+ *      mode    - 1: keep original format, 0: follow VLAN config
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortMirrorRealKeep(rtk_uint32 mode)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_REALKEEP_EN_OFFSET, mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortMirrorRealKeep
+ * Description:
+ *      Get the mirror function of keep format
+ * Input:
+ *      pMode   - 1: keep original format, 0: follow VLAN config
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortMirrorRealKeep(rtk_uint32* pMode)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL2, RTL8367C_MIRROR_REALKEEP_EN_OFFSET, pMode);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortMirrorOverride
+ * Description:
+ *      Set the mirror function of override
+ * Input:
+ *      rxMirror    - 1: output rx Mirror format, 0: output forward format
+ *      txMirror    - 1: output tx Mirror format, 0: output forward format
+ *      aclMirror   - 1: output ACL Mirror format, 0: output forward format
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortMirrorOverride(rtk_uint32 rxMirror, rtk_uint32 txMirror, rtk_uint32 aclMirror)
+{
+    ret_t retVal;
+
+    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_RX_OVERRIDE_EN_OFFSET, rxMirror)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_TX_OVERRIDE_EN_OFFSET, txMirror)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_ACL_OVERRIDE_EN_OFFSET, aclMirror)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicPortMirrorOverride
+ * Description:
+ *      Get the mirror function of override
+ * Input:
+ *      None
+ * Output:
+ *      pRxMirror   - 1: output rx Mirror format, 0: output forward format
+ *      pTxMirror   - 1: output tx Mirror format, 0: output forward format
+ *      pAclMirror  - 1: output ACL Mirror format, 0: output forward format
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortMirrorOverride(rtk_uint32 *pRxMirror, rtk_uint32 *pTxMirror, rtk_uint32 *pAclMirror)
+{
+    ret_t retVal;
+
+    if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_RX_OVERRIDE_EN_OFFSET, pRxMirror)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_TX_OVERRIDE_EN_OFFSET, pTxMirror)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MIRROR_CTRL3, RTL8367C_MIRROR_ACL_OVERRIDE_EN_OFFSET, pAclMirror)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_misc.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_misc.c
new file mode 100644
index 0000000000000..2189b151c3872
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_misc.c
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Miscellaneous functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_misc.h>
+/* Function Name:
+ *      rtl8367c_setAsicMacAddress
+ * Description:
+ *      Set switch MAC address
+ * Input:
+ *      mac     - switch mac
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMacAddress(ether_addr_t mac)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint8 *accessPtr;
+    rtk_uint32 i;
+
+    accessPtr =  (rtk_uint8*)&mac;
+
+    regData = *accessPtr;
+    accessPtr ++;
+    regData = (regData << 8) | *accessPtr;
+    accessPtr ++;
+    for(i = 0; i <=2; i++)
+    {
+        retVal = rtl8367c_setAsicReg(RTL8367C_REG_SWITCH_MAC2 - i, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        regData = *accessPtr;
+        accessPtr ++;
+        regData = (regData << 8) | *accessPtr;
+        accessPtr ++;
+    }
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicMacAddress
+ * Description:
+ *      Get switch MAC address
+ * Input:
+ *      pMac    - switch mac
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMacAddress(ether_addr_t *pMac)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint8 *accessPtr;
+    rtk_uint32 i;
+
+
+    accessPtr = (rtk_uint8*)pMac;
+
+    for(i = 0; i <= 2; i++)
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_REG_SWITCH_MAC2 - i, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *accessPtr = (regData & 0xFF00) >> 8;
+        accessPtr ++;
+        *accessPtr = regData & 0xFF;
+        accessPtr ++;
+    }
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicDebugInfo
+ * Description:
+ *      Get per-port packet forward debugging information
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      pDebugifo   - per-port packet trap/drop/forward reason
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicDebugInfo(rtk_uint32 port, rtk_uint32 *pDebugifo)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_DEBUG_INFO_REG(port), RTL8367C_DEBUG_INFO_MASK(port), pDebugifo);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortJamMode
+ * Description:
+ *      Set half duplex flow control setting
+ * Input:
+ *      mode    - 0: Back-Pressure 1: DEFER
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortJamMode(rtk_uint32 mode)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_CFG_BACKPRESSURE, RTL8367C_LONGTXE_OFFSET,mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortJamMode
+ * Description:
+ *      Get half duplex flow control setting
+ * Input:
+ *      pMode   - 0: Back-Pressure 1: DEFER
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortJamMode(rtk_uint32* pMode)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_CFG_BACKPRESSURE, RTL8367C_LONGTXE_OFFSET, pMode);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicMaxLengthCfg
+ * Description:
+ *      Set Max packet length configuration
+ * Input:
+ *      cfgId       - Configuration ID
+ *      maxLength   - Max Length
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMaxLengthCfg(rtk_uint32 cfgId, rtk_uint32 maxLength)
+{
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_MAX_LEN_RX_TX_CFG0 + cfgId, RTL8367C_MAX_LEN_RX_TX_CFG0_MASK, maxLength);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicMaxLengthCfg
+ * Description:
+ *      Get Max packet length configuration
+ * Input:
+ *      cfgId       - Configuration ID
+ *      maxLength   - Max Length
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMaxLengthCfg(rtk_uint32 cfgId, rtk_uint32 *pMaxLength)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_MAX_LEN_RX_TX_CFG0 + cfgId, RTL8367C_MAX_LEN_RX_TX_CFG0_MASK, pMaxLength);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicMaxLength
+ * Description:
+ *      Set Max packet length
+ * Input:
+ *      port        - port ID
+ *      type        - 0: 10M/100M speed, 1: giga speed
+ *      cfgId       - Configuration ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicMaxLength(rtk_uint32 port, rtk_uint32 type, rtk_uint32 cfgId)
+{
+    ret_t retVal;
+
+    if(port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MAX_LENGTH_CFG, (type * 8) + port, cfgId);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MAX_LENGTH_CFG_EXT, (type * 3) + port - 8, cfgId);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicMaxLength
+ * Description:
+ *      Get Max packet length
+ * Input:
+ *      port        - port ID
+ *      type        - 0: 10M/100M speed, 1: giga speed
+ *      cfgId       - Configuration ID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicMaxLength(rtk_uint32 port, rtk_uint32 type, rtk_uint32 *pCfgId)
+{
+    ret_t retVal;
+
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MAX_LENGTH_CFG, (type * 8) + port, pCfgId);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_MAX_LENGTH_CFG_EXT, (type * 3) + port - 8, pCfgId);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_oam.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_oam.c
new file mode 100644
index 0000000000000..1556f4500d40c
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_oam.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 42321 $
+ * $Date: 2013-08-26 13:51:29 +0800 (週一, 26 八月 2013) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : OAM related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_oam.h>
+/* Function Name:
+ *      rtl8367c_setAsicOamParser
+ * Description:
+ *      Set OAM parser state
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      parser  - Per-Port OAM parser state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_NOT_ALLOWED  - Invalid paser state
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicOamParser(rtk_uint32 port, rtk_uint32 parser)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(parser > OAM_PARFWDCPU)
+        return RT_ERR_NOT_ALLOWED;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_OAM_PARSER_CTRL0 + port/8, RTL8367C_OAM_PARSER_MASK(port % 8), parser);
+}
+/* Function Name:
+ *      rtl8367c_getAsicOamParser
+ * Description:
+ *      Get OAM parser state
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pParser     - Per-Port OAM parser state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicOamParser(rtk_uint32 port, rtk_uint32* pParser)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_OAM_PARSER_CTRL0 + port/8, RTL8367C_OAM_PARSER_MASK(port%8), pParser);
+}
+/* Function Name:
+ *      rtl8367c_setAsicOamMultiplexer
+ * Description:
+ *      Set OAM multiplexer state
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      multiplexer - Per-Port OAM multiplexer state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_NOT_ALLOWED  - Invalid multiplexer state
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicOamMultiplexer(rtk_uint32 port, rtk_uint32 multiplexer)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(multiplexer > OAM_MULCPU)
+        return RT_ERR_NOT_ALLOWED;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_OAM_MULTIPLEXER_CTRL0 + port/8, RTL8367C_OAM_MULTIPLEXER_MASK(port%8), multiplexer);
+}
+/* Function Name:
+ *      rtl8367c_getAsicOamMultiplexer
+ * Description:
+ *      Get OAM multiplexer state
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      pMultiplexer - Per-Port OAM multiplexer state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicOamMultiplexer(rtk_uint32 port, rtk_uint32* pMultiplexer)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_OAM_MULTIPLEXER_CTRL0 + port/8, RTL8367C_OAM_MULTIPLEXER_MASK(port%8), pMultiplexer);
+}
+/* Function Name:
+ *      rtl8367c_setAsicOamCpuPri
+ * Description:
+ *      Set trap priority for OAM packet
+ * Input:
+ *      priority    - priority (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY     - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicOamCpuPri(rtk_uint32 priority)
+{
+    if(priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_OAM_PRIOIRTY_MASK, priority);
+}
+/* Function Name:
+ *      rtl8367c_getAsicOamCpuPri
+ * Description:
+ *      Get trap priority for OAM packet
+ * Input:
+ *      pPriority   - priority (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicOamCpuPri(rtk_uint32 *pPriority)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_OAM_PRIOIRTY_MASK, pPriority);
+}
+/* Function Name:
+ *      rtl8367c_setAsicOamEnable
+ * Description:
+ *      Set OAM function state
+ * Input:
+ *      enabled     - OAM function usage 1:enable, 0:disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicOamEnable(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_OAM_CTRL, RTL8367C_OAM_CTRL_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicOamEnable
+ * Description:
+ *      Get OAM function state
+ * Input:
+ *      pEnabled    - OAM function usage 1:enable, 0:disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicOamEnable(rtk_uint32 *pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_OAM_CTRL, RTL8367C_OAM_CTRL_OFFSET, pEnabled);
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_phy.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_phy.c
new file mode 100644
index 0000000000000..fb4db113a9870
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_phy.c
@@ -0,0 +1,394 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : PHY related functions
+ *
+ */
+#include <rtl8367c_asicdrv_phy.h>
+
+#if defined(MDC_MDIO_OPERATION)
+/* Function Name:
+ *      rtl8367c_setAsicPHYOCPReg
+ * Description:
+ *      Set PHY OCP registers
+ * Input:
+ *      phyNo   - Physical port number (0~7)
+ *      ocpAddr - OCP address
+ *      ocpData - Writing data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PHY_REG_ID       - invalid PHY address
+ *      RT_ERR_PHY_ID           - invalid PHY no
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 ocpData )
+{
+    ret_t retVal;
+    rtk_uint32 regAddr;
+    rtk_uint32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;
+
+    /* OCP prefix */
+    ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
+    if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_GPHY_OCP_MSB_0, RTL8367C_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix)) != RT_ERR_OK)
+        return retVal;
+
+    /*prepare access address*/
+    ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
+    ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
+    regAddr = RTL8367C_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367C_PHY_OFFSET) | ocpAddr5_1;
+    if((retVal = rtl8367c_setAsicReg(regAddr, ocpData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicPHYOCPReg
+ * Description:
+ *      Get PHY OCP registers
+ * Input:
+ *      phyNo   - Physical port number (0~7)
+ *      ocpAddr - PHY address
+ *      pRegData - read data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PHY_REG_ID       - invalid PHY address
+ *      RT_ERR_PHY_ID           - invalid PHY no
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 *pRegData )
+{
+    ret_t retVal;
+    rtk_uint32 regAddr;
+    rtk_uint32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;
+    /* OCP prefix */
+    ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
+    if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_GPHY_OCP_MSB_0, RTL8367C_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix)) != RT_ERR_OK)
+        return retVal;
+
+    /*prepare access address*/
+    ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
+    ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
+    regAddr = RTL8367C_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367C_PHY_OFFSET) | ocpAddr5_1;
+    if((retVal = rtl8367c_getAsicReg(regAddr, pRegData)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+#else
+
+/* Function Name:
+ *      rtl8367c_setAsicPHYOCPReg
+ * Description:
+ *      Set PHY OCP registers
+ * Input:
+ *      phyNo   - Physical port number (0~7)
+ *      ocpAddr - OCP address
+ *      ocpData - Writing data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PHY_REG_ID       - invalid PHY address
+ *      RT_ERR_PHY_ID           - invalid PHY no
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 ocpData )
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint32 busyFlag, checkCounter;
+    rtk_uint32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;
+
+    /*Check internal phy access busy or not*/
+    /*retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_INDRECT_ACCESS_STATUS, RTL8367C_INDRECT_ACCESS_STATUS_OFFSET,&busyFlag);*/
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_INDRECT_ACCESS_STATUS,&busyFlag);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    if(busyFlag)
+        return RT_ERR_BUSYWAIT_TIMEOUT;
+
+    /* OCP prefix */
+    ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
+    if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_GPHY_OCP_MSB_0, RTL8367C_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix)) != RT_ERR_OK)
+        return retVal;
+
+    /*prepare access data*/
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_INDRECT_ACCESS_WRITE_DATA, ocpData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /*prepare access address*/
+    ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
+    ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
+    regData = RTL8367C_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367C_PHY_OFFSET) | ocpAddr5_1;
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_INDRECT_ACCESS_ADDRESS, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /*Set WRITE Command*/
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_INDRECT_ACCESS_CTRL, RTL8367C_CMD_MASK | RTL8367C_RW_MASK);
+
+    checkCounter = 100;
+    while(checkCounter)
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_REG_INDRECT_ACCESS_STATUS,&busyFlag);
+        if((retVal != RT_ERR_OK) || busyFlag)
+        {
+            checkCounter --;
+            if(0 == checkCounter)
+                return RT_ERR_BUSYWAIT_TIMEOUT;
+        }
+        else
+        {
+            checkCounter = 0;
+        }
+    }
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicPHYOCPReg
+ * Description:
+ *      Get PHY OCP registers
+ * Input:
+ *      phyNo   - Physical port number (0~7)
+ *      ocpAddr - PHY address
+ *      pRegData - read data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PHY_REG_ID       - invalid PHY address
+ *      RT_ERR_PHY_ID           - invalid PHY no
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPHYOCPReg(rtk_uint32 phyNo, rtk_uint32 ocpAddr, rtk_uint32 *pRegData )
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint32 busyFlag,checkCounter;
+    rtk_uint32 ocpAddrPrefix, ocpAddr9_6, ocpAddr5_1;
+    /*Check internal phy access busy or not*/
+    /*retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_INDRECT_ACCESS_STATUS, RTL8367C_INDRECT_ACCESS_STATUS_OFFSET,&busyFlag);*/
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_INDRECT_ACCESS_STATUS,&busyFlag);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    if(busyFlag)
+        return RT_ERR_BUSYWAIT_TIMEOUT;
+
+    /* OCP prefix */
+    ocpAddrPrefix = ((ocpAddr & 0xFC00) >> 10);
+    if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_GPHY_OCP_MSB_0, RTL8367C_CFG_CPU_OCPADR_MSB_MASK, ocpAddrPrefix)) != RT_ERR_OK)
+        return retVal;
+
+    /*prepare access address*/
+    ocpAddr9_6 = ((ocpAddr >> 6) & 0x000F);
+    ocpAddr5_1 = ((ocpAddr >> 1) & 0x001F);
+    regData = RTL8367C_PHY_BASE | (ocpAddr9_6 << 8) | (phyNo << RTL8367C_PHY_OFFSET) | ocpAddr5_1;
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_INDRECT_ACCESS_ADDRESS, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /*Set READ Command*/
+    retVal = rtl8367c_setAsicReg(RTL8367C_REG_INDRECT_ACCESS_CTRL, RTL8367C_CMD_MASK );
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    checkCounter = 100;
+    while(checkCounter)
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_REG_INDRECT_ACCESS_STATUS,&busyFlag);
+        if((retVal != RT_ERR_OK) || busyFlag)
+        {
+            checkCounter --;
+            if(0 == checkCounter)
+                return RT_ERR_FAILED;
+        }
+        else
+        {
+            checkCounter = 0;
+        }
+    }
+
+    /*get PHY register*/
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_INDRECT_ACCESS_READ_DATA, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *pRegData = regData;
+
+    return RT_ERR_OK;
+}
+
+#endif
+
+/* Function Name:
+ *      rtl8367c_setAsicPHYReg
+ * Description:
+ *      Set PHY registers
+ * Input:
+ *      phyNo   - Physical port number (0~7)
+ *      phyAddr - PHY address (0~31)
+ *      phyData - Writing data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PHY_REG_ID       - invalid PHY address
+ *      RT_ERR_PHY_ID           - invalid PHY no
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPHYReg(rtk_uint32 phyNo, rtk_uint32 phyAddr, rtk_uint32 phyData )
+{
+    rtk_uint32 ocp_addr;
+
+    if(phyAddr > RTL8367C_PHY_REGNOMAX)
+        return RT_ERR_PHY_REG_ID;
+
+    ocp_addr = 0xa400 + phyAddr*2;
+
+    return rtl8367c_setAsicPHYOCPReg(phyNo, ocp_addr, phyData);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPHYReg
+ * Description:
+ *      Get PHY registers
+ * Input:
+ *      phyNo   - Physical port number (0~7)
+ *      phyAddr - PHY address (0~31)
+ *      pRegData - Writing data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PHY_REG_ID       - invalid PHY address
+ *      RT_ERR_PHY_ID           - invalid PHY no
+ *      RT_ERR_BUSYWAIT_TIMEOUT - PHY access busy
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPHYReg(rtk_uint32 phyNo, rtk_uint32 phyAddr, rtk_uint32 *pRegData )
+{
+    rtk_uint32 ocp_addr;
+
+    if(phyAddr > RTL8367C_PHY_REGNOMAX)
+        return RT_ERR_PHY_REG_ID;
+
+    ocp_addr = 0xa400 + phyAddr*2;
+
+    return rtl8367c_getAsicPHYOCPReg(phyNo, ocp_addr, pRegData);
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicSdsReg
+ * Description:
+ *      Set Serdes registers
+ * Input:
+ *      sdsId   - sdsid (0~1)
+ *      sdsReg - reg address (0~31)
+ *      sdsPage - Writing data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+
+ * Note:
+ *      None
+ */
+
+ret_t rtl8367c_setAsicSdsReg(rtk_uint32 sdsId, rtk_uint32 sdsReg, rtk_uint32 sdsPage,  rtk_uint32 value)
+{
+    rtk_uint32 retVal;
+
+    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, value)) != RT_ERR_OK)
+        return retVal;
+
+    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (sdsPage<<5) | sdsReg)) != RT_ERR_OK)
+        return retVal;
+
+    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0|sdsId)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtl8367c_getAiscSdsReg
+ * Description:
+ *      Get Serdes registers
+ * Input:
+ *      sdsId   - sdsid (0~1)
+ *      sdsReg - reg address (0~31)
+ *      sdsPage - Writing data
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSdsReg(rtk_uint32 sdsId, rtk_uint32 sdsReg, rtk_uint32 sdsPage, rtk_uint32 *value)
+{
+    rtk_uint32 retVal, busy;
+
+    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (sdsPage<<5) | sdsReg)) != RT_ERR_OK)
+        return retVal;
+
+    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x0080|sdsId)) != RT_ERR_OK)
+        return retVal;
+
+    while(1)
+    {
+        if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_SDS_INDACS_CMD, &busy))!=RT_ERR_OK)
+            return retVal;
+
+        if ((busy & 0x100) == 0)
+            break;
+    }
+
+    if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_SDS_INDACS_DATA, value))!=RT_ERR_OK)
+            return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_port.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_port.c
new file mode 100644
index 0000000000000..78e80a0b20f64
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_port.c
@@ -0,0 +1,5752 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76333 $
+ * $Date: 2017-03-09 09:33:15 +0800 (週四, 09 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Port security related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_port.h>
+
+#include <string.h>
+
+
+#define FIBER2_AUTO_INIT_SIZE 2038
+rtk_uint8 Fiber2_Auto[FIBER2_AUTO_INIT_SIZE] = {
+0x02,0x05,0x8F,0xE4,0xF5,0xA8,0xD2,0xAF,
+0x22,0x00,0x00,0x02,0x07,0x2C,0xC5,0xF0,
+0xF8,0xA3,0xE0,0x28,0xF0,0xC5,0xF0,0xF8,
+0xE5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,
+0xE0,0x38,0xF0,0x22,0x75,0xF0,0x08,0x75,
+0x82,0x00,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xCD,0x33,0xCD,0xCC,0x33,0xCC,0xC5,0x82,
+0x33,0xC5,0x82,0x9B,0xED,0x9A,0xEC,0x99,
+0xE5,0x82,0x98,0x40,0x0C,0xF5,0x82,0xEE,
+0x9B,0xFE,0xED,0x9A,0xFD,0xEC,0x99,0xFC,
+0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,0xFB,0xE4,
+0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,0x82,0x22,
+0xB8,0x00,0xC1,0xB9,0x00,0x59,0xBA,0x00,
+0x2D,0xEC,0x8B,0xF0,0x84,0xCF,0xCE,0xCD,
+0xFC,0xE5,0xF0,0xCB,0xF9,0x78,0x18,0xEF,
+0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,0xFD,
+0xEC,0x33,0xFC,0xEB,0x33,0xFB,0x10,0xD7,
+0x03,0x99,0x40,0x04,0xEB,0x99,0xFB,0x0F,
+0xD8,0xE5,0xE4,0xF9,0xFA,0x22,0x78,0x18,
+0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,
+0xFD,0xEC,0x33,0xFC,0xC9,0x33,0xC9,0x10,
+0xD7,0x05,0x9B,0xE9,0x9A,0x40,0x07,0xEC,
+0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,0xD8,0xE0,
+0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,0x22,0x75,
+0xF0,0x10,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xCC,0x33,0xCC,0xC8,0x33,
+0xC8,0x10,0xD7,0x07,0x9B,0xEC,0x9A,0xE8,
+0x99,0x40,0x0A,0xED,0x9B,0xFD,0xEC,0x9A,
+0xFC,0xE8,0x99,0xF8,0x0F,0xD5,0xF0,0xDA,
+0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,0xE4,0xC8,
+0xF9,0x22,0xEB,0x9F,0xF5,0xF0,0xEA,0x9E,
+0x42,0xF0,0xE9,0x9D,0x42,0xF0,0xE8,0x9C,
+0x45,0xF0,0x22,0xE0,0xFC,0xA3,0xE0,0xFD,
+0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x22,0xE0,
+0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,
+0xE0,0xFB,0x22,0xEC,0xF0,0xA3,0xED,0xF0,
+0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,0x22,0x7D,
+0xD7,0x7C,0x04,0x7F,0x02,0x7E,0x66,0x12,
+0x07,0xAB,0x7D,0x80,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x07,0xAB,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x07,0xAB,
+0x7D,0x94,0x7C,0xF9,0x7F,0x02,0x7E,0x66,
+0x12,0x07,0xAB,0x7D,0x81,0x7C,0x04,0x7F,
+0x01,0x7E,0x66,0x12,0x07,0xAB,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x07,
+0xAB,0x7D,0xA2,0x7C,0x31,0x7F,0x02,0x7E,
+0x66,0x12,0x07,0xAB,0x7D,0x82,0x7C,0x04,
+0x7F,0x01,0x7E,0x66,0x12,0x07,0xAB,0x7D,
+0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x07,0xAB,0x7D,0x60,0x7C,0x69,0x7F,0x02,
+0x7E,0x66,0x12,0x07,0xAB,0x7D,0x83,0x7C,
+0x04,0x7F,0x01,0x7E,0x66,0x12,0x07,0xAB,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x12,0x07,0xAB,0x7D,0x28,0x7C,0x97,0x7F,
+0x02,0x7E,0x66,0x12,0x07,0xAB,0x7D,0x84,
+0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0xAB,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0xAB,0x7D,0x85,0x7C,0x9D,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0xAB,0x7D,
+0x23,0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xAB,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0xAB,0x7D,0x10,0x7C,
+0xD8,0x7F,0x02,0x7E,0x66,0x12,0x07,0xAB,
+0x7D,0x24,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x07,0xAB,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x07,0xAB,0x7D,0x00,
+0x7C,0x04,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xAB,0x7D,0x2F,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xAB,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x02,0x07,0xAB,0x7D,
+0x03,0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xAB,0x7D,0x80,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0xAB,0x7F,0x02,0x7E,
+0x66,0x12,0x07,0x66,0xEF,0x44,0x40,0xFD,
+0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xAB,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xAB,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xAB,0x7D,
+0x03,0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xAB,0x7D,0x80,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0xAB,0x7F,0x02,0x7E,
+0x66,0x12,0x07,0x66,0xEF,0x54,0xBF,0xFD,
+0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xAB,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xAB,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xAB,0xE4,
+0xFD,0xFC,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0xAB,0x7D,0x80,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0xAB,0x7F,0x02,0x7E,0x66,
+0x12,0x07,0x66,0xEF,0x54,0xFD,0x54,0xFE,
+0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,
+0x07,0xAB,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xAB,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xAB,0xE4,
+0xFD,0xFC,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0xAB,0x7D,0x80,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0xAB,0x7F,0x02,0x7E,0x66,
+0x12,0x07,0x66,0xEF,0x44,0x02,0x44,0x01,
+0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,
+0x07,0xAB,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xAB,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x02,0x07,0xAB,0xE4,
+0x90,0x06,0x2C,0xF0,0xFD,0x7C,0x01,0x7F,
+0x3F,0x7E,0x1D,0x12,0x07,0xAB,0x7D,0x40,
+0x7C,0x00,0x7F,0x36,0x7E,0x13,0x12,0x07,
+0xAB,0xE4,0xFF,0xFE,0xFD,0x80,0x25,0xE4,
+0x7F,0xFF,0x7E,0xFF,0xFD,0xFC,0x90,0x06,
+0x24,0x12,0x01,0x0F,0xC3,0x12,0x00,0xF2,
+0x50,0x1B,0x90,0x06,0x24,0x12,0x01,0x03,
+0xEF,0x24,0x01,0xFF,0xE4,0x3E,0xFE,0xE4,
+0x3D,0xFD,0xE4,0x3C,0xFC,0x90,0x06,0x24,
+0x12,0x01,0x1B,0x80,0xD2,0xE4,0xF5,0xA8,
+0xD2,0xAF,0x7D,0x1F,0xFC,0x7F,0x49,0x7E,
+0x13,0x12,0x07,0xAB,0x12,0x07,0xDB,0x12,
+0x01,0x27,0x12,0x06,0x1B,0x12,0x07,0x8A,
+0x12,0x06,0xEA,0x7D,0x41,0x7C,0x00,0x7F,
+0x36,0x7E,0x13,0x12,0x07,0xAB,0xE4,0xFF,
+0xFE,0xFD,0x80,0x26,0x7F,0xFF,0x7E,0xFF,
+0x7D,0x05,0x7C,0x00,0x90,0x06,0x24,0x12,
+0x01,0x0F,0xC3,0x12,0x00,0xF2,0x50,0x1B,
+0x90,0x06,0x24,0x12,0x01,0x03,0xEF,0x24,
+0x01,0xFF,0xE4,0x3E,0xFE,0xE4,0x3D,0xFD,
+0xE4,0x3C,0xFC,0x90,0x06,0x24,0x12,0x01,
+0x1B,0x80,0xD1,0xC2,0x00,0xC2,0x01,0xD2,
+0xA9,0xD2,0x8C,0x7F,0x01,0x7E,0x62,0x12,
+0x07,0x66,0xEF,0x30,0xE2,0x07,0xE4,0x90,
+0x06,0x2C,0xF0,0x80,0xEE,0x90,0x06,0x2C,
+0xE0,0x70,0x12,0x12,0x04,0xF0,0x90,0x06,
+0x2C,0x74,0x01,0xF0,0xE4,0x90,0x06,0x33,
+0xF0,0xA3,0xF0,0x80,0xD6,0xC3,0x90,0x06,
+0x34,0xE0,0x94,0x62,0x90,0x06,0x33,0xE0,
+0x94,0x00,0x40,0xC7,0xE4,0xF0,0xA3,0xF0,
+0x12,0x04,0xF0,0x90,0x06,0x2C,0x74,0x01,
+0xF0,0x80,0xB8,0x75,0x0F,0x80,0x75,0x0E,
+0x7E,0x75,0x0D,0xAA,0x75,0x0C,0x83,0xE4,
+0xF5,0x10,0x7F,0x36,0x7E,0x13,0x12,0x07,
+0x66,0xEE,0xC4,0xF8,0x54,0xF0,0xC8,0xEF,
+0xC4,0x54,0x0F,0x48,0x54,0x07,0xFB,0x7A,
+0x00,0xEA,0x70,0x4A,0xEB,0x14,0x60,0x1C,
+0x14,0x60,0x27,0x24,0xFE,0x60,0x31,0x14,
+0x60,0x3C,0x24,0x05,0x70,0x38,0x75,0x0B,
+0x00,0x75,0x0A,0xC2,0x75,0x09,0xEB,0x75,
+0x08,0x0B,0x80,0x36,0x75,0x0B,0x40,0x75,
+0x0A,0x59,0x75,0x09,0x73,0x75,0x08,0x07,
+0x80,0x28,0x75,0x0B,0x00,0x75,0x0A,0xE1,
+0x75,0x09,0xF5,0x75,0x08,0x05,0x80,0x1A,
+0x75,0x0B,0xA0,0x75,0x0A,0xAC,0x75,0x09,
+0xB9,0x75,0x08,0x03,0x80,0x0C,0x75,0x0B,
+0x00,0x75,0x0A,0x62,0x75,0x09,0x3D,0x75,
+0x08,0x01,0x75,0x89,0x11,0xE4,0x7B,0x60,
+0x7A,0x09,0xF9,0xF8,0xAF,0x0B,0xAE,0x0A,
+0xAD,0x09,0xAC,0x08,0x12,0x00,0x60,0xAA,
+0x06,0xAB,0x07,0xC3,0xE4,0x9B,0xFB,0xE4,
+0x9A,0xFA,0x78,0x17,0xF6,0xAF,0x03,0xEF,
+0x08,0xF6,0x18,0xE6,0xF5,0x8C,0x08,0xE6,
+0xF5,0x8A,0x74,0x0D,0x2B,0xFB,0xE4,0x3A,
+0x18,0xF6,0xAF,0x03,0xEF,0x08,0xF6,0x75,
+0x88,0x10,0x53,0x8E,0xC7,0xD2,0xA9,0x22,
+0x7F,0x10,0x7E,0x13,0x12,0x07,0x66,0x90,
+0x06,0x2D,0xEE,0xF0,0xA3,0xEF,0xF0,0xEE,
+0x44,0x10,0xFE,0x90,0x06,0x2D,0xF0,0xA3,
+0xEF,0xF0,0x54,0xEF,0xFF,0x90,0x06,0x2D,
+0xEE,0xF0,0xFC,0xA3,0xEF,0xF0,0xFD,0x7F,
+0x10,0x7E,0x13,0x12,0x07,0xAB,0xE4,0xFF,
+0xFE,0x0F,0xBF,0x00,0x01,0x0E,0xEF,0x64,
+0x64,0x4E,0x70,0xF5,0x7D,0x04,0x7C,0x00,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0xAB,0x7D,
+0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xAB,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0xAB,0xE4,0xFD,0xFC,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0xAB,0x7D,
+0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xAB,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0xAB,0x7F,0x10,0x7E,
+0x13,0x12,0x07,0x66,0x90,0x06,0x2D,0xEE,
+0xF0,0xA3,0xEF,0xF0,0xEE,0x54,0xEF,0x90,
+0x06,0x2D,0xF0,0xFC,0xA3,0xEF,0xF0,0xFD,
+0x7F,0x10,0x7E,0x13,0x02,0x07,0xAB,0x78,
+0x7F,0xE4,0xF6,0xD8,0xFD,0x75,0x81,0x3C,
+0x02,0x05,0xD6,0x02,0x03,0x2F,0xE4,0x93,
+0xA3,0xF8,0xE4,0x93,0xA3,0x40,0x03,0xF6,
+0x80,0x01,0xF2,0x08,0xDF,0xF4,0x80,0x29,
+0xE4,0x93,0xA3,0xF8,0x54,0x07,0x24,0x0C,
+0xC8,0xC3,0x33,0xC4,0x54,0x0F,0x44,0x20,
+0xC8,0x83,0x40,0x04,0xF4,0x56,0x80,0x01,
+0x46,0xF6,0xDF,0xE4,0x80,0x0B,0x01,0x02,
+0x04,0x08,0x10,0x20,0x40,0x80,0x90,0x07,
+0xE7,0xE4,0x7E,0x01,0x93,0x60,0xBC,0xA3,
+0xFF,0x54,0x3F,0x30,0xE5,0x09,0x54,0x1F,
+0xFE,0xE4,0x93,0xA3,0x60,0x01,0x0E,0xCF,
+0x54,0xC0,0x25,0xE0,0x60,0xA8,0x40,0xB8,
+0xE4,0x93,0xA3,0xFA,0xE4,0x93,0xA3,0xF8,
+0xE4,0x93,0xA3,0xC8,0xC5,0x82,0xC8,0xCA,
+0xC5,0x83,0xCA,0xF0,0xA3,0xC8,0xC5,0x82,
+0xC8,0xCA,0xC5,0x83,0xCA,0xDF,0xE9,0xDE,
+0xE7,0x80,0xBE,0x7D,0x40,0x7C,0x17,0x7F,
+0x11,0x7E,0x1D,0x12,0x07,0xAB,0x7F,0x41,
+0x7E,0x1D,0x12,0x07,0x66,0xEF,0x44,0x20,
+0x44,0x80,0xFD,0xAC,0x06,0x7F,0x41,0x7E,
+0x1D,0x12,0x07,0xAB,0x7D,0xBB,0x7C,0x15,
+0x7F,0xEB,0x7E,0x13,0x12,0x07,0xAB,0x7D,
+0x07,0x7C,0x00,0x7F,0xE7,0x7E,0x13,0x12,
+0x07,0xAB,0x7D,0x40,0x7C,0x11,0x7F,0x00,
+0x7E,0x62,0x12,0x07,0xAB,0x02,0x02,0x2F,
+0x7D,0xC0,0x7C,0x16,0x7F,0x11,0x7E,0x1D,
+0x12,0x07,0xAB,0x7D,0xBB,0x7C,0x15,0x7F,
+0xEB,0x7E,0x13,0x12,0x07,0xAB,0x7D,0x0D,
+0x7C,0x00,0x7F,0xE7,0x7E,0x13,0x12,0x07,
+0xAB,0x7F,0x41,0x7E,0x1D,0x12,0x07,0x66,
+0xEF,0x44,0x20,0x44,0x80,0xFD,0xAC,0x06,
+0x7F,0x41,0x7E,0x1D,0x12,0x07,0xAB,0x7D,
+0x00,0x7C,0x21,0x7F,0x00,0x7E,0x62,0x12,
+0x07,0xAB,0x02,0x02,0x2F,0x7D,0x40,0x7C,
+0x17,0x7F,0x11,0x7E,0x1D,0x12,0x07,0xAB,
+0x7D,0xBB,0x7C,0x15,0x7F,0xEB,0x7E,0x13,
+0x12,0x07,0xAB,0x7D,0x0C,0x7C,0x00,0x7F,
+0xE7,0x7E,0x13,0x12,0x07,0xAB,0x7F,0x41,
+0x7E,0x1D,0x12,0x07,0x66,0xEF,0x44,0x20,
+0x44,0x80,0xFD,0xAC,0x06,0x7F,0x41,0x7E,
+0x1D,0x12,0x07,0xAB,0x7D,0x40,0x7C,0x11,
+0x7F,0x00,0x7E,0x62,0x12,0x07,0xAB,0x02,
+0x02,0x2F,0x7D,0x04,0x7C,0x00,0x7F,0x01,
+0x7E,0x66,0x12,0x07,0xAB,0x7D,0x80,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x07,0xAB,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0x66,0xEF,
+0x44,0x02,0x44,0x04,0xFD,0xAC,0x06,0x7F,
+0x02,0x7E,0x66,0x12,0x07,0xAB,0x7D,0x04,
+0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0xAB,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x02,0x07,0xAB,0xC0,0xE0,0xC0,0xF0,
+0xC0,0x83,0xC0,0x82,0xC0,0xD0,0x75,0xD0,
+0x00,0xC0,0x00,0x78,0x17,0xE6,0xF5,0x8C,
+0x78,0x18,0xE6,0xF5,0x8A,0x90,0x06,0x31,
+0xE4,0x75,0xF0,0x01,0x12,0x00,0x0E,0x90,
+0x06,0x33,0xE4,0x75,0xF0,0x01,0x12,0x00,
+0x0E,0xD0,0x00,0xD0,0xD0,0xD0,0x82,0xD0,
+0x83,0xD0,0xF0,0xD0,0xE0,0x32,0xC2,0xAF,
+0xAD,0x07,0xAC,0x06,0x8C,0xA2,0x8D,0xA3,
+0x75,0xA0,0x01,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0xAE,0xA1,
+0xBE,0x00,0xF0,0xAE,0xA6,0xAF,0xA7,0xD2,
+0xAF,0x22,0x7D,0x20,0x7C,0x0F,0x7F,0x02,
+0x7E,0x66,0x12,0x07,0xAB,0x7D,0x01,0x7C,
+0x00,0x7F,0x01,0x7E,0x66,0x12,0x07,0xAB,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x02,0x07,0xAB,0xC2,0xAF,0xAB,0x07,0xAA,
+0x06,0x8A,0xA2,0x8B,0xA3,0x8C,0xA4,0x8D,
+0xA5,0x75,0xA0,0x03,0x00,0x00,0x00,0xAA,
+0xA1,0xBA,0x00,0xF8,0xD2,0xAF,0x22,0x7F,
+0x0C,0x7E,0x13,0x12,0x07,0x66,0xEF,0x44,
+0x50,0xFD,0xAC,0x06,0x7F,0x0C,0x7E,0x13,
+0x02,0x07,0xAB,0x12,0x07,0xC7,0x12,0x07,
+0xF2,0x12,0x04,0x2B,0x02,0x00,0x03,0x42,
+0x06,0x33,0x00,0x00,0x42,0x06,0x31,0x00,
+0x00,0x00,0xE4,0xF5,0x8E,0x22,};
+
+#define FIBER2_1G_INIT_SIZE 2032
+rtk_uint8 Fiber2_1G[FIBER2_1G_INIT_SIZE] = {
+0x02,0x05,0x89,0xE4,0xF5,0xA8,0xD2,0xAF,
+0x22,0x00,0x00,0x02,0x07,0x26,0xC5,0xF0,
+0xF8,0xA3,0xE0,0x28,0xF0,0xC5,0xF0,0xF8,
+0xE5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,
+0xE0,0x38,0xF0,0x22,0x75,0xF0,0x08,0x75,
+0x82,0x00,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xCD,0x33,0xCD,0xCC,0x33,0xCC,0xC5,0x82,
+0x33,0xC5,0x82,0x9B,0xED,0x9A,0xEC,0x99,
+0xE5,0x82,0x98,0x40,0x0C,0xF5,0x82,0xEE,
+0x9B,0xFE,0xED,0x9A,0xFD,0xEC,0x99,0xFC,
+0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,0xFB,0xE4,
+0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,0x82,0x22,
+0xB8,0x00,0xC1,0xB9,0x00,0x59,0xBA,0x00,
+0x2D,0xEC,0x8B,0xF0,0x84,0xCF,0xCE,0xCD,
+0xFC,0xE5,0xF0,0xCB,0xF9,0x78,0x18,0xEF,
+0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,0xFD,
+0xEC,0x33,0xFC,0xEB,0x33,0xFB,0x10,0xD7,
+0x03,0x99,0x40,0x04,0xEB,0x99,0xFB,0x0F,
+0xD8,0xE5,0xE4,0xF9,0xFA,0x22,0x78,0x18,
+0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,
+0xFD,0xEC,0x33,0xFC,0xC9,0x33,0xC9,0x10,
+0xD7,0x05,0x9B,0xE9,0x9A,0x40,0x07,0xEC,
+0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,0xD8,0xE0,
+0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,0x22,0x75,
+0xF0,0x10,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xCC,0x33,0xCC,0xC8,0x33,
+0xC8,0x10,0xD7,0x07,0x9B,0xEC,0x9A,0xE8,
+0x99,0x40,0x0A,0xED,0x9B,0xFD,0xEC,0x9A,
+0xFC,0xE8,0x99,0xF8,0x0F,0xD5,0xF0,0xDA,
+0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,0xE4,0xC8,
+0xF9,0x22,0xEB,0x9F,0xF5,0xF0,0xEA,0x9E,
+0x42,0xF0,0xE9,0x9D,0x42,0xF0,0xE8,0x9C,
+0x45,0xF0,0x22,0xE0,0xFC,0xA3,0xE0,0xFD,
+0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x22,0xE0,
+0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,
+0xE0,0xFB,0x22,0xEC,0xF0,0xA3,0xED,0xF0,
+0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,0x22,0x7D,
+0xD7,0x7C,0x04,0x7F,0x02,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0x80,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,
+0x7D,0x94,0x7C,0xF9,0x7F,0x02,0x7E,0x66,
+0x12,0x07,0xA5,0x7D,0x81,0x7C,0x04,0x7F,
+0x01,0x7E,0x66,0x12,0x07,0xA5,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0xA2,0x7C,0x31,0x7F,0x02,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0x82,0x7C,0x04,
+0x7F,0x01,0x7E,0x66,0x12,0x07,0xA5,0x7D,
+0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0x60,0x7C,0x69,0x7F,0x02,
+0x7E,0x66,0x12,0x07,0xA5,0x7D,0x83,0x7C,
+0x04,0x7F,0x01,0x7E,0x66,0x12,0x07,0xA5,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x12,0x07,0xA5,0x7D,0x28,0x7C,0x97,0x7F,
+0x02,0x7E,0x66,0x12,0x07,0xA5,0x7D,0x84,
+0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0x85,0x7C,0x9D,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0xA5,0x7D,
+0x23,0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0xA5,0x7D,0x10,0x7C,
+0xD8,0x7F,0x02,0x7E,0x66,0x12,0x07,0xA5,
+0x7D,0x24,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x07,0xA5,0x7D,0x00,
+0x7C,0x04,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x2F,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x02,0x07,0xA5,0x7D,
+0x03,0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0x80,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0xA5,0x7F,0x02,0x7E,
+0x66,0x12,0x07,0x60,0xEF,0x44,0x40,0xFD,
+0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,0x7D,
+0x03,0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0x80,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0xA5,0x7F,0x02,0x7E,
+0x66,0x12,0x07,0x60,0xEF,0x54,0xBF,0xFD,
+0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,0xE4,
+0xFD,0xFC,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x80,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0xA5,0x7F,0x02,0x7E,0x66,
+0x12,0x07,0x60,0xEF,0x54,0xFD,0x54,0xFE,
+0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,
+0x07,0xA5,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,0xE4,
+0xFD,0xFC,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x80,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0xA5,0x7F,0x02,0x7E,0x66,
+0x12,0x07,0x60,0xEF,0x44,0x02,0x44,0x01,
+0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,
+0x07,0xA5,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x02,0x07,0xA5,0xE4,
+0x90,0x06,0x2C,0xF0,0xFD,0x7C,0x01,0x7F,
+0x3F,0x7E,0x1D,0x12,0x07,0xA5,0x7D,0x40,
+0x7C,0x00,0x7F,0x36,0x7E,0x13,0x12,0x07,
+0xA5,0xE4,0xFF,0xFE,0xFD,0x80,0x25,0xE4,
+0x7F,0xFF,0x7E,0xFF,0xFD,0xFC,0x90,0x06,
+0x24,0x12,0x01,0x0F,0xC3,0x12,0x00,0xF2,
+0x50,0x1B,0x90,0x06,0x24,0x12,0x01,0x03,
+0xEF,0x24,0x01,0xFF,0xE4,0x3E,0xFE,0xE4,
+0x3D,0xFD,0xE4,0x3C,0xFC,0x90,0x06,0x24,
+0x12,0x01,0x1B,0x80,0xD2,0xE4,0xF5,0xA8,
+0xD2,0xAF,0x7D,0x1F,0xFC,0x7F,0x49,0x7E,
+0x13,0x12,0x07,0xA5,0x12,0x07,0xD5,0x12,
+0x01,0x27,0x12,0x06,0x9F,0x7D,0x41,0x7C,
+0x00,0x7F,0x36,0x7E,0x13,0x12,0x07,0xA5,
+0xE4,0xFF,0xFE,0xFD,0x80,0x26,0x7F,0xFF,
+0x7E,0xFF,0x7D,0x05,0x7C,0x00,0x90,0x06,
+0x24,0x12,0x01,0x0F,0xC3,0x12,0x00,0xF2,
+0x50,0x1B,0x90,0x06,0x24,0x12,0x01,0x03,
+0xEF,0x24,0x01,0xFF,0xE4,0x3E,0xFE,0xE4,
+0x3D,0xFD,0xE4,0x3C,0xFC,0x90,0x06,0x24,
+0x12,0x01,0x1B,0x80,0xD1,0xC2,0x00,0xC2,
+0x01,0xD2,0xA9,0xD2,0x8C,0x7F,0x01,0x7E,
+0x62,0x12,0x07,0x60,0xEF,0x30,0xE2,0x07,
+0xE4,0x90,0x06,0x2C,0xF0,0x80,0xEE,0x90,
+0x06,0x2C,0xE0,0x70,0x12,0x12,0x04,0xEA,
+0x90,0x06,0x2C,0x74,0x01,0xF0,0xE4,0x90,
+0x06,0x33,0xF0,0xA3,0xF0,0x80,0xD6,0xC3,
+0x90,0x06,0x34,0xE0,0x94,0x62,0x90,0x06,
+0x33,0xE0,0x94,0x00,0x40,0xC7,0xE4,0xF0,
+0xA3,0xF0,0x12,0x04,0xEA,0x90,0x06,0x2C,
+0x74,0x01,0xF0,0x80,0xB8,0x75,0x0F,0x80,
+0x75,0x0E,0x7E,0x75,0x0D,0xAA,0x75,0x0C,
+0x83,0xE4,0xF5,0x10,0x7F,0x36,0x7E,0x13,
+0x12,0x07,0x60,0xEE,0xC4,0xF8,0x54,0xF0,
+0xC8,0xEF,0xC4,0x54,0x0F,0x48,0x54,0x07,
+0xFB,0x7A,0x00,0xEA,0x70,0x4A,0xEB,0x14,
+0x60,0x1C,0x14,0x60,0x27,0x24,0xFE,0x60,
+0x31,0x14,0x60,0x3C,0x24,0x05,0x70,0x38,
+0x75,0x0B,0x00,0x75,0x0A,0xC2,0x75,0x09,
+0xEB,0x75,0x08,0x0B,0x80,0x36,0x75,0x0B,
+0x40,0x75,0x0A,0x59,0x75,0x09,0x73,0x75,
+0x08,0x07,0x80,0x28,0x75,0x0B,0x00,0x75,
+0x0A,0xE1,0x75,0x09,0xF5,0x75,0x08,0x05,
+0x80,0x1A,0x75,0x0B,0xA0,0x75,0x0A,0xAC,
+0x75,0x09,0xB9,0x75,0x08,0x03,0x80,0x0C,
+0x75,0x0B,0x00,0x75,0x0A,0x62,0x75,0x09,
+0x3D,0x75,0x08,0x01,0x75,0x89,0x11,0xE4,
+0x7B,0x60,0x7A,0x09,0xF9,0xF8,0xAF,0x0B,
+0xAE,0x0A,0xAD,0x09,0xAC,0x08,0x12,0x00,
+0x60,0xAA,0x06,0xAB,0x07,0xC3,0xE4,0x9B,
+0xFB,0xE4,0x9A,0xFA,0x78,0x17,0xF6,0xAF,
+0x03,0xEF,0x08,0xF6,0x18,0xE6,0xF5,0x8C,
+0x08,0xE6,0xF5,0x8A,0x74,0x0D,0x2B,0xFB,
+0xE4,0x3A,0x18,0xF6,0xAF,0x03,0xEF,0x08,
+0xF6,0x75,0x88,0x10,0x53,0x8E,0xC7,0xD2,
+0xA9,0x22,0x7F,0x10,0x7E,0x13,0x12,0x07,
+0x60,0x90,0x06,0x2D,0xEE,0xF0,0xA3,0xEF,
+0xF0,0xEE,0x44,0x10,0xFE,0x90,0x06,0x2D,
+0xF0,0xA3,0xEF,0xF0,0x54,0xEF,0xFF,0x90,
+0x06,0x2D,0xEE,0xF0,0xFC,0xA3,0xEF,0xF0,
+0xFD,0x7F,0x10,0x7E,0x13,0x12,0x07,0xA5,
+0xE4,0xFF,0xFE,0x0F,0xBF,0x00,0x01,0x0E,
+0xEF,0x64,0x64,0x4E,0x70,0xF5,0x7D,0x04,
+0x7C,0x00,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,0xE4,
+0xFD,0xFC,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,0x7F,
+0x10,0x7E,0x13,0x12,0x07,0x60,0x90,0x06,
+0x2D,0xEE,0xF0,0xA3,0xEF,0xF0,0xEE,0x54,
+0xEF,0x90,0x06,0x2D,0xF0,0xFC,0xA3,0xEF,
+0xF0,0xFD,0x7F,0x10,0x7E,0x13,0x02,0x07,
+0xA5,0x78,0x7F,0xE4,0xF6,0xD8,0xFD,0x75,
+0x81,0x3C,0x02,0x05,0xD0,0x02,0x03,0x2F,
+0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0x40,
+0x03,0xF6,0x80,0x01,0xF2,0x08,0xDF,0xF4,
+0x80,0x29,0xE4,0x93,0xA3,0xF8,0x54,0x07,
+0x24,0x0C,0xC8,0xC3,0x33,0xC4,0x54,0x0F,
+0x44,0x20,0xC8,0x83,0x40,0x04,0xF4,0x56,
+0x80,0x01,0x46,0xF6,0xDF,0xE4,0x80,0x0B,
+0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
+0x90,0x07,0xE1,0xE4,0x7E,0x01,0x93,0x60,
+0xBC,0xA3,0xFF,0x54,0x3F,0x30,0xE5,0x09,
+0x54,0x1F,0xFE,0xE4,0x93,0xA3,0x60,0x01,
+0x0E,0xCF,0x54,0xC0,0x25,0xE0,0x60,0xA8,
+0x40,0xB8,0xE4,0x93,0xA3,0xFA,0xE4,0x93,
+0xA3,0xF8,0xE4,0x93,0xA3,0xC8,0xC5,0x82,
+0xC8,0xCA,0xC5,0x83,0xCA,0xF0,0xA3,0xC8,
+0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xDF,
+0xE9,0xDE,0xE7,0x80,0xBE,0x7D,0x40,0x7C,
+0x17,0x7F,0x11,0x7E,0x1D,0x12,0x07,0xA5,
+0x7F,0x41,0x7E,0x1D,0x12,0x07,0x60,0xEF,
+0x44,0x20,0x44,0x80,0xFD,0xAC,0x06,0x7F,
+0x41,0x7E,0x1D,0x12,0x07,0xA5,0x7D,0xBB,
+0x7C,0x15,0x7F,0xEB,0x7E,0x13,0x12,0x07,
+0xA5,0x7D,0x07,0x7C,0x00,0x7F,0xE7,0x7E,
+0x13,0x12,0x07,0xA5,0x7D,0x40,0x7C,0x11,
+0x7F,0x00,0x7E,0x62,0x12,0x07,0xA5,0x02,
+0x02,0x2F,0x7D,0xC0,0x7C,0x16,0x7F,0x11,
+0x7E,0x1D,0x12,0x07,0xA5,0x7D,0xBB,0x7C,
+0x15,0x7F,0xEB,0x7E,0x13,0x12,0x07,0xA5,
+0x7D,0x0D,0x7C,0x00,0x7F,0xE7,0x7E,0x13,
+0x12,0x07,0xA5,0x7F,0x41,0x7E,0x1D,0x12,
+0x07,0x60,0xEF,0x44,0x20,0x44,0x80,0xFD,
+0xAC,0x06,0x7F,0x41,0x7E,0x1D,0x12,0x07,
+0xA5,0x7D,0x00,0x7C,0x21,0x7F,0x00,0x7E,
+0x62,0x12,0x07,0xA5,0x02,0x02,0x2F,0x7D,
+0x40,0x7C,0x17,0x7F,0x11,0x7E,0x1D,0x12,
+0x07,0xA5,0x7D,0xBB,0x7C,0x15,0x7F,0xEB,
+0x7E,0x13,0x12,0x07,0xA5,0x7D,0x0C,0x7C,
+0x00,0x7F,0xE7,0x7E,0x13,0x12,0x07,0xA5,
+0x7F,0x41,0x7E,0x1D,0x12,0x07,0x60,0xEF,
+0x44,0x20,0x44,0x80,0xFD,0xAC,0x06,0x7F,
+0x41,0x7E,0x1D,0x12,0x07,0xA5,0x7D,0x40,
+0x7C,0x11,0x7F,0x00,0x7E,0x62,0x12,0x07,
+0xA5,0x02,0x02,0x2F,0x7D,0x04,0x7C,0x00,
+0x7F,0x01,0x7E,0x66,0x12,0x07,0xA5,0x7D,
+0x80,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x07,0xA5,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0x60,0xEF,0x44,0x02,0x44,0x04,0xFD,0xAC,
+0x06,0x7F,0x02,0x7E,0x66,0x12,0x07,0xA5,
+0x7D,0x04,0x7C,0x00,0x7F,0x01,0x7E,0x66,
+0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x02,0x07,0xA5,0xC0,0xE0,
+0xC0,0xF0,0xC0,0x83,0xC0,0x82,0xC0,0xD0,
+0x75,0xD0,0x00,0xC0,0x00,0x78,0x17,0xE6,
+0xF5,0x8C,0x78,0x18,0xE6,0xF5,0x8A,0x90,
+0x06,0x31,0xE4,0x75,0xF0,0x01,0x12,0x00,
+0x0E,0x90,0x06,0x33,0xE4,0x75,0xF0,0x01,
+0x12,0x00,0x0E,0xD0,0x00,0xD0,0xD0,0xD0,
+0x82,0xD0,0x83,0xD0,0xF0,0xD0,0xE0,0x32,
+0xC2,0xAF,0xAD,0x07,0xAC,0x06,0x8C,0xA2,
+0x8D,0xA3,0x75,0xA0,0x01,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0xAE,0xA1,0xBE,0x00,0xF0,0xAE,0xA6,0xAF,
+0xA7,0xD2,0xAF,0x22,0x7D,0x20,0x7C,0x0F,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0xA5,0x7D,
+0x01,0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x02,0x07,0xA5,0xC2,0xAF,0xAB,
+0x07,0xAA,0x06,0x8A,0xA2,0x8B,0xA3,0x8C,
+0xA4,0x8D,0xA5,0x75,0xA0,0x03,0x00,0x00,
+0x00,0xAA,0xA1,0xBA,0x00,0xF8,0xD2,0xAF,
+0x22,0x7F,0x0C,0x7E,0x13,0x12,0x07,0x60,
+0xEF,0x44,0x50,0xFD,0xAC,0x06,0x7F,0x0C,
+0x7E,0x13,0x02,0x07,0xA5,0x12,0x07,0xC1,
+0x12,0x07,0xEC,0x12,0x04,0x25,0x02,0x00,
+0x03,0x42,0x06,0x33,0x00,0x00,0x42,0x06,
+0x31,0x00,0x00,0x00,0xE4,0xF5,0x8E,0x22,};
+
+#define FIBER2_100M_INIT_SIZE 2032
+rtk_uint8 Fiber2_100M[FIBER2_100M_INIT_SIZE] = {
+0x02,0x05,0x89,0xE4,0xF5,0xA8,0xD2,0xAF,
+0x22,0x00,0x00,0x02,0x07,0x26,0xC5,0xF0,
+0xF8,0xA3,0xE0,0x28,0xF0,0xC5,0xF0,0xF8,
+0xE5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,
+0xE0,0x38,0xF0,0x22,0x75,0xF0,0x08,0x75,
+0x82,0x00,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xCD,0x33,0xCD,0xCC,0x33,0xCC,0xC5,0x82,
+0x33,0xC5,0x82,0x9B,0xED,0x9A,0xEC,0x99,
+0xE5,0x82,0x98,0x40,0x0C,0xF5,0x82,0xEE,
+0x9B,0xFE,0xED,0x9A,0xFD,0xEC,0x99,0xFC,
+0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,0xFB,0xE4,
+0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,0x82,0x22,
+0xB8,0x00,0xC1,0xB9,0x00,0x59,0xBA,0x00,
+0x2D,0xEC,0x8B,0xF0,0x84,0xCF,0xCE,0xCD,
+0xFC,0xE5,0xF0,0xCB,0xF9,0x78,0x18,0xEF,
+0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,0xFD,
+0xEC,0x33,0xFC,0xEB,0x33,0xFB,0x10,0xD7,
+0x03,0x99,0x40,0x04,0xEB,0x99,0xFB,0x0F,
+0xD8,0xE5,0xE4,0xF9,0xFA,0x22,0x78,0x18,
+0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,
+0xFD,0xEC,0x33,0xFC,0xC9,0x33,0xC9,0x10,
+0xD7,0x05,0x9B,0xE9,0x9A,0x40,0x07,0xEC,
+0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,0xD8,0xE0,
+0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,0x22,0x75,
+0xF0,0x10,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xCC,0x33,0xCC,0xC8,0x33,
+0xC8,0x10,0xD7,0x07,0x9B,0xEC,0x9A,0xE8,
+0x99,0x40,0x0A,0xED,0x9B,0xFD,0xEC,0x9A,
+0xFC,0xE8,0x99,0xF8,0x0F,0xD5,0xF0,0xDA,
+0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,0xE4,0xC8,
+0xF9,0x22,0xEB,0x9F,0xF5,0xF0,0xEA,0x9E,
+0x42,0xF0,0xE9,0x9D,0x42,0xF0,0xE8,0x9C,
+0x45,0xF0,0x22,0xE0,0xFC,0xA3,0xE0,0xFD,
+0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x22,0xE0,
+0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,
+0xE0,0xFB,0x22,0xEC,0xF0,0xA3,0xED,0xF0,
+0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,0x22,0x7D,
+0xD7,0x7C,0x04,0x7F,0x02,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0x80,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,
+0x7D,0x94,0x7C,0xF9,0x7F,0x02,0x7E,0x66,
+0x12,0x07,0xA5,0x7D,0x81,0x7C,0x04,0x7F,
+0x01,0x7E,0x66,0x12,0x07,0xA5,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0xA2,0x7C,0x31,0x7F,0x02,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0x82,0x7C,0x04,
+0x7F,0x01,0x7E,0x66,0x12,0x07,0xA5,0x7D,
+0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0x60,0x7C,0x69,0x7F,0x02,
+0x7E,0x66,0x12,0x07,0xA5,0x7D,0x83,0x7C,
+0x04,0x7F,0x01,0x7E,0x66,0x12,0x07,0xA5,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x12,0x07,0xA5,0x7D,0x28,0x7C,0x97,0x7F,
+0x02,0x7E,0x66,0x12,0x07,0xA5,0x7D,0x84,
+0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0x85,0x7C,0x9D,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0xA5,0x7D,
+0x23,0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0xA5,0x7D,0x10,0x7C,
+0xD8,0x7F,0x02,0x7E,0x66,0x12,0x07,0xA5,
+0x7D,0x24,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x07,0xA5,0x7D,0x00,
+0x7C,0x04,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x2F,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x02,0x07,0xA5,0x7D,
+0x03,0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0x80,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0xA5,0x7F,0x02,0x7E,
+0x66,0x12,0x07,0x60,0xEF,0x44,0x40,0xFD,
+0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,0x7D,
+0x03,0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0x80,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x07,0xA5,0x7F,0x02,0x7E,
+0x66,0x12,0x07,0x60,0xEF,0x54,0xBF,0xFD,
+0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,0xE4,
+0xFD,0xFC,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x80,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0xA5,0x7F,0x02,0x7E,0x66,
+0x12,0x07,0x60,0xEF,0x54,0xFD,0x54,0xFE,
+0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,
+0x07,0xA5,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,0xE4,
+0xFD,0xFC,0x7F,0x01,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x80,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x07,0xA5,0x7F,0x02,0x7E,0x66,
+0x12,0x07,0x60,0xEF,0x44,0x02,0x44,0x01,
+0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,0x12,
+0x07,0xA5,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x02,0x07,0xA5,0xE4,
+0x90,0x06,0x2C,0xF0,0xFD,0x7C,0x01,0x7F,
+0x3F,0x7E,0x1D,0x12,0x07,0xA5,0x7D,0x40,
+0x7C,0x00,0x7F,0x36,0x7E,0x13,0x12,0x07,
+0xA5,0xE4,0xFF,0xFE,0xFD,0x80,0x25,0xE4,
+0x7F,0xFF,0x7E,0xFF,0xFD,0xFC,0x90,0x06,
+0x24,0x12,0x01,0x0F,0xC3,0x12,0x00,0xF2,
+0x50,0x1B,0x90,0x06,0x24,0x12,0x01,0x03,
+0xEF,0x24,0x01,0xFF,0xE4,0x3E,0xFE,0xE4,
+0x3D,0xFD,0xE4,0x3C,0xFC,0x90,0x06,0x24,
+0x12,0x01,0x1B,0x80,0xD2,0xE4,0xF5,0xA8,
+0xD2,0xAF,0x7D,0x1F,0xFC,0x7F,0x49,0x7E,
+0x13,0x12,0x07,0xA5,0x12,0x07,0xD5,0x12,
+0x01,0x27,0x12,0x06,0x5A,0x7D,0x41,0x7C,
+0x00,0x7F,0x36,0x7E,0x13,0x12,0x07,0xA5,
+0xE4,0xFF,0xFE,0xFD,0x80,0x26,0x7F,0xFF,
+0x7E,0xFF,0x7D,0x05,0x7C,0x00,0x90,0x06,
+0x24,0x12,0x01,0x0F,0xC3,0x12,0x00,0xF2,
+0x50,0x1B,0x90,0x06,0x24,0x12,0x01,0x03,
+0xEF,0x24,0x01,0xFF,0xE4,0x3E,0xFE,0xE4,
+0x3D,0xFD,0xE4,0x3C,0xFC,0x90,0x06,0x24,
+0x12,0x01,0x1B,0x80,0xD1,0xC2,0x00,0xC2,
+0x01,0xD2,0xA9,0xD2,0x8C,0x7F,0x01,0x7E,
+0x62,0x12,0x07,0x60,0xEF,0x30,0xE2,0x07,
+0xE4,0x90,0x06,0x2C,0xF0,0x80,0xEE,0x90,
+0x06,0x2C,0xE0,0x70,0x12,0x12,0x04,0xEA,
+0x90,0x06,0x2C,0x74,0x01,0xF0,0xE4,0x90,
+0x06,0x33,0xF0,0xA3,0xF0,0x80,0xD6,0xC3,
+0x90,0x06,0x34,0xE0,0x94,0x62,0x90,0x06,
+0x33,0xE0,0x94,0x00,0x40,0xC7,0xE4,0xF0,
+0xA3,0xF0,0x12,0x04,0xEA,0x90,0x06,0x2C,
+0x74,0x01,0xF0,0x80,0xB8,0x75,0x0F,0x80,
+0x75,0x0E,0x7E,0x75,0x0D,0xAA,0x75,0x0C,
+0x83,0xE4,0xF5,0x10,0x7F,0x36,0x7E,0x13,
+0x12,0x07,0x60,0xEE,0xC4,0xF8,0x54,0xF0,
+0xC8,0xEF,0xC4,0x54,0x0F,0x48,0x54,0x07,
+0xFB,0x7A,0x00,0xEA,0x70,0x4A,0xEB,0x14,
+0x60,0x1C,0x14,0x60,0x27,0x24,0xFE,0x60,
+0x31,0x14,0x60,0x3C,0x24,0x05,0x70,0x38,
+0x75,0x0B,0x00,0x75,0x0A,0xC2,0x75,0x09,
+0xEB,0x75,0x08,0x0B,0x80,0x36,0x75,0x0B,
+0x40,0x75,0x0A,0x59,0x75,0x09,0x73,0x75,
+0x08,0x07,0x80,0x28,0x75,0x0B,0x00,0x75,
+0x0A,0xE1,0x75,0x09,0xF5,0x75,0x08,0x05,
+0x80,0x1A,0x75,0x0B,0xA0,0x75,0x0A,0xAC,
+0x75,0x09,0xB9,0x75,0x08,0x03,0x80,0x0C,
+0x75,0x0B,0x00,0x75,0x0A,0x62,0x75,0x09,
+0x3D,0x75,0x08,0x01,0x75,0x89,0x11,0xE4,
+0x7B,0x60,0x7A,0x09,0xF9,0xF8,0xAF,0x0B,
+0xAE,0x0A,0xAD,0x09,0xAC,0x08,0x12,0x00,
+0x60,0xAA,0x06,0xAB,0x07,0xC3,0xE4,0x9B,
+0xFB,0xE4,0x9A,0xFA,0x78,0x17,0xF6,0xAF,
+0x03,0xEF,0x08,0xF6,0x18,0xE6,0xF5,0x8C,
+0x08,0xE6,0xF5,0x8A,0x74,0x0D,0x2B,0xFB,
+0xE4,0x3A,0x18,0xF6,0xAF,0x03,0xEF,0x08,
+0xF6,0x75,0x88,0x10,0x53,0x8E,0xC7,0xD2,
+0xA9,0x22,0x7F,0x10,0x7E,0x13,0x12,0x07,
+0x60,0x90,0x06,0x2D,0xEE,0xF0,0xA3,0xEF,
+0xF0,0xEE,0x44,0x10,0xFE,0x90,0x06,0x2D,
+0xF0,0xA3,0xEF,0xF0,0x54,0xEF,0xFF,0x90,
+0x06,0x2D,0xEE,0xF0,0xFC,0xA3,0xEF,0xF0,
+0xFD,0x7F,0x10,0x7E,0x13,0x12,0x07,0xA5,
+0xE4,0xFF,0xFE,0x0F,0xBF,0x00,0x01,0x0E,
+0xEF,0x64,0x64,0x4E,0x70,0xF5,0x7D,0x04,
+0x7C,0x00,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,0xE4,
+0xFD,0xFC,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0xA5,0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,
+0x66,0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x07,0xA5,0x7F,
+0x10,0x7E,0x13,0x12,0x07,0x60,0x90,0x06,
+0x2D,0xEE,0xF0,0xA3,0xEF,0xF0,0xEE,0x54,
+0xEF,0x90,0x06,0x2D,0xF0,0xFC,0xA3,0xEF,
+0xF0,0xFD,0x7F,0x10,0x7E,0x13,0x02,0x07,
+0xA5,0x78,0x7F,0xE4,0xF6,0xD8,0xFD,0x75,
+0x81,0x3C,0x02,0x05,0xD0,0x02,0x03,0x2F,
+0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0x40,
+0x03,0xF6,0x80,0x01,0xF2,0x08,0xDF,0xF4,
+0x80,0x29,0xE4,0x93,0xA3,0xF8,0x54,0x07,
+0x24,0x0C,0xC8,0xC3,0x33,0xC4,0x54,0x0F,
+0x44,0x20,0xC8,0x83,0x40,0x04,0xF4,0x56,
+0x80,0x01,0x46,0xF6,0xDF,0xE4,0x80,0x0B,
+0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
+0x90,0x07,0xE1,0xE4,0x7E,0x01,0x93,0x60,
+0xBC,0xA3,0xFF,0x54,0x3F,0x30,0xE5,0x09,
+0x54,0x1F,0xFE,0xE4,0x93,0xA3,0x60,0x01,
+0x0E,0xCF,0x54,0xC0,0x25,0xE0,0x60,0xA8,
+0x40,0xB8,0xE4,0x93,0xA3,0xFA,0xE4,0x93,
+0xA3,0xF8,0xE4,0x93,0xA3,0xC8,0xC5,0x82,
+0xC8,0xCA,0xC5,0x83,0xCA,0xF0,0xA3,0xC8,
+0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xDF,
+0xE9,0xDE,0xE7,0x80,0xBE,0x7D,0x40,0x7C,
+0x17,0x7F,0x11,0x7E,0x1D,0x12,0x07,0xA5,
+0x7F,0x41,0x7E,0x1D,0x12,0x07,0x60,0xEF,
+0x44,0x20,0x44,0x80,0xFD,0xAC,0x06,0x7F,
+0x41,0x7E,0x1D,0x12,0x07,0xA5,0x7D,0xBB,
+0x7C,0x15,0x7F,0xEB,0x7E,0x13,0x12,0x07,
+0xA5,0x7D,0x07,0x7C,0x00,0x7F,0xE7,0x7E,
+0x13,0x12,0x07,0xA5,0x7D,0x40,0x7C,0x11,
+0x7F,0x00,0x7E,0x62,0x12,0x07,0xA5,0x02,
+0x02,0x2F,0x7D,0xC0,0x7C,0x16,0x7F,0x11,
+0x7E,0x1D,0x12,0x07,0xA5,0x7D,0xBB,0x7C,
+0x15,0x7F,0xEB,0x7E,0x13,0x12,0x07,0xA5,
+0x7D,0x0D,0x7C,0x00,0x7F,0xE7,0x7E,0x13,
+0x12,0x07,0xA5,0x7F,0x41,0x7E,0x1D,0x12,
+0x07,0x60,0xEF,0x44,0x20,0x44,0x80,0xFD,
+0xAC,0x06,0x7F,0x41,0x7E,0x1D,0x12,0x07,
+0xA5,0x7D,0x00,0x7C,0x21,0x7F,0x00,0x7E,
+0x62,0x12,0x07,0xA5,0x02,0x02,0x2F,0x7D,
+0x40,0x7C,0x17,0x7F,0x11,0x7E,0x1D,0x12,
+0x07,0xA5,0x7D,0xBB,0x7C,0x15,0x7F,0xEB,
+0x7E,0x13,0x12,0x07,0xA5,0x7D,0x0C,0x7C,
+0x00,0x7F,0xE7,0x7E,0x13,0x12,0x07,0xA5,
+0x7F,0x41,0x7E,0x1D,0x12,0x07,0x60,0xEF,
+0x44,0x20,0x44,0x80,0xFD,0xAC,0x06,0x7F,
+0x41,0x7E,0x1D,0x12,0x07,0xA5,0x7D,0x40,
+0x7C,0x11,0x7F,0x00,0x7E,0x62,0x12,0x07,
+0xA5,0x02,0x02,0x2F,0x7D,0x04,0x7C,0x00,
+0x7F,0x01,0x7E,0x66,0x12,0x07,0xA5,0x7D,
+0x80,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x07,0xA5,0x7F,0x02,0x7E,0x66,0x12,0x07,
+0x60,0xEF,0x44,0x02,0x44,0x04,0xFD,0xAC,
+0x06,0x7F,0x02,0x7E,0x66,0x12,0x07,0xA5,
+0x7D,0x04,0x7C,0x00,0x7F,0x01,0x7E,0x66,
+0x12,0x07,0xA5,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x02,0x07,0xA5,0xC0,0xE0,
+0xC0,0xF0,0xC0,0x83,0xC0,0x82,0xC0,0xD0,
+0x75,0xD0,0x00,0xC0,0x00,0x78,0x17,0xE6,
+0xF5,0x8C,0x78,0x18,0xE6,0xF5,0x8A,0x90,
+0x06,0x31,0xE4,0x75,0xF0,0x01,0x12,0x00,
+0x0E,0x90,0x06,0x33,0xE4,0x75,0xF0,0x01,
+0x12,0x00,0x0E,0xD0,0x00,0xD0,0xD0,0xD0,
+0x82,0xD0,0x83,0xD0,0xF0,0xD0,0xE0,0x32,
+0xC2,0xAF,0xAD,0x07,0xAC,0x06,0x8C,0xA2,
+0x8D,0xA3,0x75,0xA0,0x01,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0xAE,0xA1,0xBE,0x00,0xF0,0xAE,0xA6,0xAF,
+0xA7,0xD2,0xAF,0x22,0x7D,0x20,0x7C,0x0F,
+0x7F,0x02,0x7E,0x66,0x12,0x07,0xA5,0x7D,
+0x01,0x7C,0x00,0x7F,0x01,0x7E,0x66,0x12,
+0x07,0xA5,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x02,0x07,0xA5,0xC2,0xAF,0xAB,
+0x07,0xAA,0x06,0x8A,0xA2,0x8B,0xA3,0x8C,
+0xA4,0x8D,0xA5,0x75,0xA0,0x03,0x00,0x00,
+0x00,0xAA,0xA1,0xBA,0x00,0xF8,0xD2,0xAF,
+0x22,0x7F,0x0C,0x7E,0x13,0x12,0x07,0x60,
+0xEF,0x44,0x50,0xFD,0xAC,0x06,0x7F,0x0C,
+0x7E,0x13,0x02,0x07,0xA5,0x12,0x07,0xC1,
+0x12,0x07,0xEC,0x12,0x04,0x25,0x02,0x00,
+0x03,0x42,0x06,0x33,0x00,0x00,0x42,0x06,
+0x31,0x00,0x00,0x00,0xE4,0xF5,0x8E,0x22,};
+
+
+#define SGMII_INIT_SIZE 1183
+rtk_uint8 Sgmii_Init[SGMII_INIT_SIZE] = {
+0x02,0x03,0x81,0xE4,0xF5,0xA8,0xD2,0xAF,
+0x22,0x00,0x00,0x02,0x04,0x0D,0xC5,0xF0,
+0xF8,0xA3,0xE0,0x28,0xF0,0xC5,0xF0,0xF8,
+0xE5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,
+0xE0,0x38,0xF0,0x22,0x75,0xF0,0x08,0x75,
+0x82,0x00,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xCD,0x33,0xCD,0xCC,0x33,0xCC,0xC5,0x82,
+0x33,0xC5,0x82,0x9B,0xED,0x9A,0xEC,0x99,
+0xE5,0x82,0x98,0x40,0x0C,0xF5,0x82,0xEE,
+0x9B,0xFE,0xED,0x9A,0xFD,0xEC,0x99,0xFC,
+0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,0xFB,0xE4,
+0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,0x82,0x22,
+0xB8,0x00,0xC1,0xB9,0x00,0x59,0xBA,0x00,
+0x2D,0xEC,0x8B,0xF0,0x84,0xCF,0xCE,0xCD,
+0xFC,0xE5,0xF0,0xCB,0xF9,0x78,0x18,0xEF,
+0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,0xFD,
+0xEC,0x33,0xFC,0xEB,0x33,0xFB,0x10,0xD7,
+0x03,0x99,0x40,0x04,0xEB,0x99,0xFB,0x0F,
+0xD8,0xE5,0xE4,0xF9,0xFA,0x22,0x78,0x18,
+0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,
+0xFD,0xEC,0x33,0xFC,0xC9,0x33,0xC9,0x10,
+0xD7,0x05,0x9B,0xE9,0x9A,0x40,0x07,0xEC,
+0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,0xD8,0xE0,
+0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,0x22,0x75,
+0xF0,0x10,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xCC,0x33,0xCC,0xC8,0x33,
+0xC8,0x10,0xD7,0x07,0x9B,0xEC,0x9A,0xE8,
+0x99,0x40,0x0A,0xED,0x9B,0xFD,0xEC,0x9A,
+0xFC,0xE8,0x99,0xF8,0x0F,0xD5,0xF0,0xDA,
+0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,0xE4,0xC8,
+0xF9,0x22,0xEB,0x9F,0xF5,0xF0,0xEA,0x9E,
+0x42,0xF0,0xE9,0x9D,0x42,0xF0,0xE8,0x9C,
+0x45,0xF0,0x22,0xE0,0xFC,0xA3,0xE0,0xFD,
+0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x22,0xE0,
+0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,
+0xE0,0xFB,0x22,0xEC,0xF0,0xA3,0xED,0xF0,
+0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,0x22,0xE4,
+0x90,0x06,0x2C,0xF0,0xFD,0x7C,0x01,0x7F,
+0x3F,0x7E,0x1D,0x12,0x04,0x6B,0x7D,0x40,
+0x7C,0x00,0x7F,0x36,0x7E,0x13,0x12,0x04,
+0x6B,0xE4,0xFF,0xFE,0xFD,0x80,0x25,0xE4,
+0x7F,0xFF,0x7E,0xFF,0xFD,0xFC,0x90,0x06,
+0x24,0x12,0x01,0x0F,0xC3,0x12,0x00,0xF2,
+0x50,0x1B,0x90,0x06,0x24,0x12,0x01,0x03,
+0xEF,0x24,0x01,0xFF,0xE4,0x3E,0xFE,0xE4,
+0x3D,0xFD,0xE4,0x3C,0xFC,0x90,0x06,0x24,
+0x12,0x01,0x1B,0x80,0xD2,0xE4,0xF5,0xA8,
+0xD2,0xAF,0x7D,0x1F,0xFC,0x7F,0x49,0x7E,
+0x13,0x12,0x04,0x6B,0x12,0x04,0x92,0x7D,
+0x41,0x7C,0x00,0x7F,0x36,0x7E,0x13,0x12,
+0x04,0x6B,0xE4,0xFF,0xFE,0xFD,0x80,0x25,
+0xE4,0x7F,0x20,0x7E,0x4E,0xFD,0xFC,0x90,
+0x06,0x24,0x12,0x01,0x0F,0xC3,0x12,0x00,
+0xF2,0x50,0x1B,0x90,0x06,0x24,0x12,0x01,
+0x03,0xEF,0x24,0x01,0xFF,0xE4,0x3E,0xFE,
+0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,0x06,
+0x24,0x12,0x01,0x1B,0x80,0xD2,0xC2,0x00,
+0xC2,0x01,0xD2,0xA9,0xD2,0x8C,0x7F,0x01,
+0x7E,0x62,0x12,0x04,0x47,0xEF,0x30,0xE2,
+0x07,0xE4,0x90,0x06,0x2C,0xF0,0x80,0xEE,
+0x90,0x06,0x2C,0xE0,0x70,0x12,0x12,0x02,
+0xDB,0x90,0x06,0x2C,0x74,0x01,0xF0,0xE4,
+0x90,0x06,0x2F,0xF0,0xA3,0xF0,0x80,0xD6,
+0xC3,0x90,0x06,0x30,0xE0,0x94,0x62,0x90,
+0x06,0x2F,0xE0,0x94,0x00,0x40,0xC7,0xE4,
+0xF0,0xA3,0xF0,0x12,0x02,0xDB,0x90,0x06,
+0x2C,0x74,0x01,0xF0,0x80,0xB8,0x75,0x0F,
+0x80,0x75,0x0E,0x7E,0x75,0x0D,0xAA,0x75,
+0x0C,0x83,0xE4,0xF5,0x10,0x7F,0x36,0x7E,
+0x13,0x12,0x04,0x47,0xEE,0xC4,0xF8,0x54,
+0xF0,0xC8,0xEF,0xC4,0x54,0x0F,0x48,0x54,
+0x07,0xFB,0x7A,0x00,0xEA,0x70,0x4A,0xEB,
+0x14,0x60,0x1C,0x14,0x60,0x27,0x24,0xFE,
+0x60,0x31,0x14,0x60,0x3C,0x24,0x05,0x70,
+0x38,0x75,0x0B,0x00,0x75,0x0A,0xC2,0x75,
+0x09,0xEB,0x75,0x08,0x0B,0x80,0x36,0x75,
+0x0B,0x40,0x75,0x0A,0x59,0x75,0x09,0x73,
+0x75,0x08,0x07,0x80,0x28,0x75,0x0B,0x00,
+0x75,0x0A,0xE1,0x75,0x09,0xF5,0x75,0x08,
+0x05,0x80,0x1A,0x75,0x0B,0xA0,0x75,0x0A,
+0xAC,0x75,0x09,0xB9,0x75,0x08,0x03,0x80,
+0x0C,0x75,0x0B,0x00,0x75,0x0A,0x62,0x75,
+0x09,0x3D,0x75,0x08,0x01,0x75,0x89,0x11,
+0xE4,0x7B,0x60,0x7A,0x09,0xF9,0xF8,0xAF,
+0x0B,0xAE,0x0A,0xAD,0x09,0xAC,0x08,0x12,
+0x00,0x60,0xAA,0x06,0xAB,0x07,0xC3,0xE4,
+0x9B,0xFB,0xE4,0x9A,0xFA,0x78,0x17,0xF6,
+0xAF,0x03,0xEF,0x08,0xF6,0x18,0xE6,0xF5,
+0x8C,0x08,0xE6,0xF5,0x8A,0x74,0x0D,0x2B,
+0xFB,0xE4,0x3A,0x18,0xF6,0xAF,0x03,0xEF,
+0x08,0xF6,0x75,0x88,0x10,0x53,0x8E,0xC7,
+0xD2,0xA9,0x22,0x7D,0x02,0x7C,0x00,0x7F,
+0x4A,0x7E,0x13,0x12,0x04,0x6B,0x7D,0x46,
+0x7C,0x71,0x7F,0x02,0x7E,0x66,0x12,0x04,
+0x6B,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x04,0x6B,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x04,0x6B,0xE4,
+0xFF,0xFE,0x0F,0xBF,0x00,0x01,0x0E,0xEF,
+0x64,0x64,0x4E,0x70,0xF5,0x7D,0x04,0x7C,
+0x00,0x7F,0x02,0x7E,0x66,0x12,0x04,0x6B,
+0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x04,0x6B,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x04,0x6B,0xE4,0xFD,
+0xFC,0x7F,0x02,0x7E,0x66,0x12,0x04,0x6B,
+0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x04,0x6B,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x04,0x6B,0xE4,0xFD,
+0xFC,0x7F,0x4A,0x7E,0x13,0x12,0x04,0x6B,
+0x7D,0x06,0x7C,0x71,0x7F,0x02,0x7E,0x66,
+0x12,0x04,0x6B,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x04,0x6B,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x04,
+0x6B,0x78,0x7F,0xE4,0xF6,0xD8,0xFD,0x75,
+0x81,0x3C,0x02,0x03,0xC8,0x02,0x01,0x27,
+0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0x40,
+0x03,0xF6,0x80,0x01,0xF2,0x08,0xDF,0xF4,
+0x80,0x29,0xE4,0x93,0xA3,0xF8,0x54,0x07,
+0x24,0x0C,0xC8,0xC3,0x33,0xC4,0x54,0x0F,
+0x44,0x20,0xC8,0x83,0x40,0x04,0xF4,0x56,
+0x80,0x01,0x46,0xF6,0xDF,0xE4,0x80,0x0B,
+0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
+0x90,0x04,0x87,0xE4,0x7E,0x01,0x93,0x60,
+0xBC,0xA3,0xFF,0x54,0x3F,0x30,0xE5,0x09,
+0x54,0x1F,0xFE,0xE4,0x93,0xA3,0x60,0x01,
+0x0E,0xCF,0x54,0xC0,0x25,0xE0,0x60,0xA8,
+0x40,0xB8,0xE4,0x93,0xA3,0xFA,0xE4,0x93,
+0xA3,0xF8,0xE4,0x93,0xA3,0xC8,0xC5,0x82,
+0xC8,0xCA,0xC5,0x83,0xCA,0xF0,0xA3,0xC8,
+0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xDF,
+0xE9,0xDE,0xE7,0x80,0xBE,0xC0,0xE0,0xC0,
+0xF0,0xC0,0x83,0xC0,0x82,0xC0,0xD0,0x75,
+0xD0,0x00,0xC0,0x00,0x78,0x17,0xE6,0xF5,
+0x8C,0x78,0x18,0xE6,0xF5,0x8A,0x90,0x06,
+0x2D,0xE4,0x75,0xF0,0x01,0x12,0x00,0x0E,
+0x90,0x06,0x2F,0xE4,0x75,0xF0,0x01,0x12,
+0x00,0x0E,0xD0,0x00,0xD0,0xD0,0xD0,0x82,
+0xD0,0x83,0xD0,0xF0,0xD0,0xE0,0x32,0xC2,
+0xAF,0xAD,0x07,0xAC,0x06,0x8C,0xA2,0x8D,
+0xA3,0x75,0xA0,0x01,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAE,
+0xA1,0xBE,0x00,0xF0,0xAE,0xA6,0xAF,0xA7,
+0xD2,0xAF,0x22,0xC2,0xAF,0xAB,0x07,0xAA,
+0x06,0x8A,0xA2,0x8B,0xA3,0x8C,0xA4,0x8D,
+0xA5,0x75,0xA0,0x03,0x00,0x00,0x00,0xAA,
+0xA1,0xBA,0x00,0xF8,0xD2,0xAF,0x22,0x42,
+0x06,0x2F,0x00,0x00,0x42,0x06,0x2D,0x00,
+0x00,0x00,0x12,0x04,0x9B,0x12,0x02,0x16,
+0x02,0x00,0x03,0xE4,0xF5,0x8E,0x22,};
+
+
+/* Function Name:
+ *      rtl8367c_setAsicPortUnknownDaBehavior
+ * Description:
+ *      Set UNDA behavior
+ * Input:
+ *      port        - port ID
+ *      behavior    - 0: flooding to unknwon DA portmask; 1: drop; 2:trap; 3: flooding
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NOT_ALLOWED  - Invalid behavior
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortUnknownDaBehavior(rtk_uint32 port, rtk_uint32 behavior)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(behavior >= L2_UNDA_BEHAVE_END)
+        return RT_ERR_NOT_ALLOWED;
+
+    if(port < 8)
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_UNKNOWN_UNICAST_DA_PORT_BEHAVE, RTL8367C_Port0_ACTION_MASK << (port * 2), behavior);
+    else
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_UNKNOWN_UNICAST_DA_PORT_BEHAVE_EXT, RTL8367C_PORT8_ACTION_MASK << ((port-8) * 2), behavior);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortUnknownDaBehavior
+ * Description:
+ *      Get UNDA behavior
+ * Input:
+ *      port        - port ID
+ * Output:
+ *      pBehavior   - 0: flooding to unknwon DA portmask; 1: drop; 2:trap; 3: flooding
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortUnknownDaBehavior(rtk_uint32 port, rtk_uint32 *pBehavior)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_UNKNOWN_UNICAST_DA_PORT_BEHAVE, RTL8367C_Port0_ACTION_MASK << (port * 2), pBehavior);
+    else
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_UNKNOWN_UNICAST_DA_PORT_BEHAVE_EXT, RTL8367C_PORT8_ACTION_MASK << ((port-8) * 2), pBehavior);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortUnknownSaBehavior
+ * Description:
+ *      Set UNSA behavior
+ * Input:
+ *      behavior    - 0: flooding; 1: drop; 2:trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NOT_ALLOWED  - Invalid behavior
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortUnknownSaBehavior(rtk_uint32 behavior)
+{
+    if(behavior >= L2_BEHAVE_SA_END)
+        return RT_ERR_NOT_ALLOWED;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_PORT_SECURIT_CTRL_REG, RTL8367C_UNKNOWN_SA_BEHAVE_MASK, behavior);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortUnknownSaBehavior
+ * Description:
+ *      Get UNSA behavior
+ * Input:
+ *      pBehavior   - 0: flooding; 1: drop; 2:trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortUnknownSaBehavior(rtk_uint32 *pBehavior)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_PORT_SECURIT_CTRL_REG, RTL8367C_UNKNOWN_SA_BEHAVE_MASK, pBehavior);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortUnmatchedSaBehavior
+ * Description:
+ *      Set Unmatched SA behavior
+ * Input:
+ *      behavior    - 0: flooding; 1: drop; 2:trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NOT_ALLOWED  - Invalid behavior
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortUnmatchedSaBehavior(rtk_uint32 behavior)
+{
+    if(behavior >= L2_BEHAVE_SA_END)
+        return RT_ERR_NOT_ALLOWED;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_PORT_SECURIT_CTRL_REG, RTL8367C_UNMATCHED_SA_BEHAVE_MASK, behavior);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortUnmatchedSaBehavior
+ * Description:
+ *      Get Unmatched SA behavior
+ * Input:
+ *      pBehavior   - 0: flooding; 1: drop; 2:trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortUnmatchedSaBehavior(rtk_uint32 *pBehavior)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_PORT_SECURIT_CTRL_REG, RTL8367C_UNMATCHED_SA_BEHAVE_MASK, pBehavior);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortUnmatchedSaMoving
+ * Description:
+ *      Set Unmatched SA moving state
+ * Input:
+ *      port        - Port ID
+ *      enabled     - 0: can't move to new port; 1: can move to new port
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Error Port ID
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortUnmatchedSaMoving(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_L2_SA_MOVING_FORBID, port, (enabled == 1) ? 0 : 1);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicPortUnmatchedSaMoving
+ * Description:
+ *      Get Unmatched SA moving state
+ * Input:
+ *      port        - Port ID
+ * Output:
+ *      pEnabled    - 0: can't move to new port; 1: can move to new port
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Error Port ID
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortUnmatchedSaMoving(rtk_uint32 port, rtk_uint32 *pEnabled)
+{
+    rtk_uint32 data;
+    ret_t retVal;
+
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_L2_SA_MOVING_FORBID, port, &data)) != RT_ERR_OK)
+        return retVal;
+
+    *pEnabled = (data == 1) ? 0 : 1;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortUnknownDaFloodingPortmask
+ * Description:
+ *      Set UNDA flooding portmask
+ * Input:
+ *      portmask    - portmask(0~0xFF)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortUnknownDaFloodingPortmask(rtk_uint32 portmask)
+{
+    if(portmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    return rtl8367c_setAsicReg(RTL8367C_UNUCAST_FLOADING_PMSK_REG, portmask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortUnknownDaFloodingPortmask
+ * Description:
+ *      Get UNDA flooding portmask
+ * Input:
+ *      pPortmask   - portmask(0~0xFF)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortUnknownDaFloodingPortmask(rtk_uint32 *pPortmask)
+{
+    return rtl8367c_getAsicReg(RTL8367C_UNUCAST_FLOADING_PMSK_REG, pPortmask);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortUnknownMulticastFloodingPortmask
+ * Description:
+ *      Set UNMC flooding portmask
+ * Input:
+ *      portmask    - portmask(0~0xFF)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortUnknownMulticastFloodingPortmask(rtk_uint32 portmask)
+{
+    if(portmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    return rtl8367c_setAsicReg(RTL8367C_UNMCAST_FLOADING_PMSK_REG, portmask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortUnknownMulticastFloodingPortmask
+ * Description:
+ *      Get UNMC flooding portmask
+ * Input:
+ *      pPortmask   - portmask(0~0xFF)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortUnknownMulticastFloodingPortmask(rtk_uint32 *pPortmask)
+{
+    return rtl8367c_getAsicReg(RTL8367C_UNMCAST_FLOADING_PMSK_REG, pPortmask);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortBcastFloodingPortmask
+ * Description:
+ *      Set Bcast flooding portmask
+ * Input:
+ *      portmask    - portmask(0~0xFF)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortBcastFloodingPortmask(rtk_uint32 portmask)
+{
+    if(portmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    return rtl8367c_setAsicReg(RTL8367C_BCAST_FLOADING_PMSK_REG, portmask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortBcastFloodingPortmask
+ * Description:
+ *      Get Bcast flooding portmask
+ * Input:
+ *      pPortmask   - portmask(0~0xFF)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortBcastFloodingPortmask(rtk_uint32 *pPortmask)
+{
+    return rtl8367c_getAsicReg(RTL8367C_BCAST_FLOADING_PMSK_REG, pPortmask);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortBlockSpa
+ * Description:
+ *      Set disabling blocking frame if source port and destination port are the same
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      permit  - 0: block; 1: permit
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortBlockSpa(rtk_uint32 port, rtk_uint32 permit)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_SOURCE_PORT_BLOCK_REG, port, permit);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortBlockSpa
+ * Description:
+ *      Get disabling blocking frame if source port and destination port are the same
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pPermit     - 0: block; 1: permit
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortBlockSpa(rtk_uint32 port, rtk_uint32* pPermit)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_SOURCE_PORT_BLOCK_REG, port, pPermit);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortDos
+ * Description:
+ *      Set DOS function
+ * Input:
+ *      type    - DOS type
+ *      drop    - 0: permit; 1: drop
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - Invalid payload index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortDos(rtk_uint32 type, rtk_uint32 drop)
+{
+    if(type >= DOS_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_DOS_CFG, RTL8367C_DROP_DAEQSA_OFFSET + type, drop);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortDos
+ * Description:
+ *      Get DOS function
+ * Input:
+ *      type    - DOS type
+ *      pDrop   - 0: permit; 1: drop
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - Invalid payload index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortDos(rtk_uint32 type, rtk_uint32* pDrop)
+{
+    if(type >= DOS_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_DOS_CFG, RTL8367C_DROP_DAEQSA_OFFSET + type,pDrop);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortForceLink
+ * Description:
+ *      Set port force linking configuration
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      pPortAbility - port ability configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortForceLink(rtk_uint32 port, rtl8367c_port_ability_t *pPortAbility)
+{
+    rtk_uint32 regData = 0;
+
+    /* Invalid input parameter */
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    regData |= pPortAbility->forcemode << 12;
+    regData |= pPortAbility->mstfault << 9;
+    regData |= pPortAbility->mstmode << 8;
+    regData |= pPortAbility->nway << 7;
+    regData |= pPortAbility->txpause << 6;
+    regData |= pPortAbility->rxpause << 5;
+    regData |= pPortAbility->link << 4;
+    regData |= pPortAbility->duplex << 2;
+    regData |= pPortAbility->speed;
+
+    return rtl8367c_setAsicReg(RTL8367C_REG_MAC0_FORCE_SELECT+port, regData);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortForceLink
+ * Description:
+ *      Get port force linking configuration
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      pPortAbility - port ability configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortForceLink(rtk_uint32 port, rtl8367c_port_ability_t *pPortAbility)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    /* Invalid input parameter */
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_MAC0_FORCE_SELECT + port, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pPortAbility->forcemode = (regData >> 12) & 0x0001;
+    pPortAbility->mstfault  = (regData >> 9) & 0x0001;
+    pPortAbility->mstmode   = (regData >> 8) & 0x0001;
+    pPortAbility->nway      = (regData >> 7) & 0x0001;
+    pPortAbility->txpause   = (regData >> 6) & 0x0001;
+    pPortAbility->rxpause   = (regData >> 5) & 0x0001;
+    pPortAbility->link      = (regData >> 4) & 0x0001;
+    pPortAbility->duplex    = (regData >> 2) & 0x0001;
+    pPortAbility->speed     = regData & 0x0003;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortStatus
+ * Description:
+ *      Get port link status
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      pPortAbility - port ability configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortStatus(rtk_uint32 port, rtl8367c_port_status_t *pPortStatus)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    /* Invalid input parameter */
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_PORT0_STATUS+port,&regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pPortStatus->lpi1000  = (regData >> 11) & 0x0001;
+    pPortStatus->lpi100   = (regData >> 10) & 0x0001;
+    pPortStatus->mstfault = (regData >> 9) & 0x0001;
+    pPortStatus->mstmode  = (regData >> 8) & 0x0001;
+    pPortStatus->nway     = (regData >> 7) & 0x0001;
+    pPortStatus->txpause  = (regData >> 6) & 0x0001;
+    pPortStatus->rxpause  = (regData >> 5) & 0x0001;
+    pPortStatus->link     = (regData >> 4) & 0x0001;
+    pPortStatus->duplex   = (regData >> 2) & 0x0001;
+    pPortStatus->speed    = regData  & 0x0003;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortForceLinkExt
+ * Description:
+ *      Set external interface force linking configuration
+ * Input:
+ *      id          - external interface id (0~2)
+ *      portAbility - port ability configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortForceLinkExt(rtk_uint32 id, rtl8367c_port_ability_t *pPortAbility)
+{
+    rtk_uint32 retVal, regValue, regValue2, type, sgmiibit, hisgmiibit;
+    rtk_uint32 reg_data = 0;
+    rtk_uint32 i = 0;
+
+    /* Invalid input parameter */
+    if(id >= RTL8367C_EXTNO)
+        return RT_ERR_OUT_OF_RANGE;
+
+    reg_data |= pPortAbility->forcemode << 12;
+    reg_data |= pPortAbility->mstfault << 9;
+    reg_data |= pPortAbility->mstmode << 8;
+    reg_data |= pPortAbility->nway << 7;
+    reg_data |= pPortAbility->txpause << 6;
+    reg_data |= pPortAbility->rxpause << 5;
+    reg_data |= pPortAbility->link << 4;
+    reg_data |= pPortAbility->duplex << 2;
+    reg_data |= pPortAbility->speed;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+    /*get chip ID */
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regValue)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    type = 0;
+
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            type = 1;
+            break;
+        case 0x0652:
+        case 0x6368:
+            type = 2;
+            break;
+        case 0x0801:
+        case 0x6511:
+            type = 3;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+
+    if (1 == type)
+    {
+        if(1 == id)
+        {
+            if ((retVal = rtl8367c_getAsicReg(RTL8367C_REG_REG_TO_ECO4, &regValue)) != RT_ERR_OK)
+                return retVal;
+
+            if((regValue & (0x0001 << 5)) && (regValue & (0x0001 << 7)))
+            {
+                return RT_ERR_OK;
+            }
+
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_FDUP_OFFSET, pPortAbility->duplex)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_SPD_MASK, pPortAbility->speed)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_LINK_OFFSET, pPortAbility->link)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_TXFC_OFFSET, pPortAbility->txpause)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_RXFC_OFFSET, pPortAbility->rxpause)) != RT_ERR_OK)
+                return retVal;
+        }
+
+        if(0 == id || 1 == id)
+            return rtl8367c_setAsicReg(RTL8367C_REG_DIGITAL_INTERFACE0_FORCE + id, reg_data);
+        else
+            return rtl8367c_setAsicReg(RTL8367C_REG_DIGITAL_INTERFACE2_FORCE, reg_data);
+    }
+    else if (2 == type)
+    {
+        if (1 == id)
+        {
+             if((retVal = rtl8367c_setAsicRegBit(0x1311, 2, pPortAbility->duplex)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBits(0x1311, 0x3, pPortAbility->speed)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(0x1311, 4, pPortAbility->link)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(0x1311, 6, pPortAbility->txpause)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(0x1311, 5, pPortAbility->rxpause)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(0x1311, 12, pPortAbility->forcemode)) != RT_ERR_OK)
+                return retVal;
+
+            if (pPortAbility->link == 1)
+            {
+                if((retVal = rtl8367c_setAsicRegBit(0x1311, 4, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if((retVal = rtl8367c_setAsicRegBit(0x1311, 4, 1)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else
+            {
+                if((retVal = rtl8367c_setAsicRegBits(0x1311, 0x3, 2)) != RT_ERR_OK)
+                    return retVal;
+            }
+
+
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_FDUP_OFFSET, pPortAbility->duplex)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_SPD_MASK, pPortAbility->speed)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_LINK_OFFSET, pPortAbility->link)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_TXFC_OFFSET, pPortAbility->txpause)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_RXFC_OFFSET, pPortAbility->rxpause)) != RT_ERR_OK)
+                return retVal;
+        }
+        else if (2 == id)
+        {
+            if((retVal = rtl8367c_setAsicRegBit(0x13c4, 2, pPortAbility->duplex)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBits(0x13c4, 0x3, pPortAbility->speed)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(0x13c4, 4, pPortAbility->link)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(0x13c4, 6, pPortAbility->txpause)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(0x13c4, 5, pPortAbility->rxpause)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(0x13c4, 12, pPortAbility->forcemode)) != RT_ERR_OK)
+                return retVal;
+
+            if (pPortAbility->link == 1)
+            {
+                if((retVal = rtl8367c_setAsicRegBit(0x13c4, 4, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if((retVal = rtl8367c_setAsicRegBit(0x13c4, 4, 1)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else
+            {
+                if((retVal = rtl8367c_setAsicRegBits(0x13c4, 0x3, 2)) != RT_ERR_OK)
+                    return retVal;
+            }
+
+            if((retVal = rtl8367c_setAsicRegBit(0x1dc1, RTL8367C_CFG_SGMII_FDUP_OFFSET, pPortAbility->duplex)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBits(0x1dc1, RTL8367C_CFG_SGMII_SPD_MASK, pPortAbility->speed)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(0x1dc1, RTL8367C_CFG_SGMII_LINK_OFFSET, pPortAbility->link)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(0x1dc1, RTL8367C_CFG_SGMII_TXFC_OFFSET, pPortAbility->txpause)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(0x1dc1, RTL8367C_CFG_SGMII_RXFC_OFFSET, pPortAbility->rxpause)) != RT_ERR_OK)
+                return retVal;
+        }
+
+    }
+    else if(3 == type)
+    {
+        if(1 == id)
+        {
+            if((retVal = rtl8367c_getAsicRegBit(0x1d11, 6, &sgmiibit)) != RT_ERR_OK)
+                return retVal;
+            if((retVal = rtl8367c_getAsicRegBit(0x1d11, 11, &hisgmiibit)) != RT_ERR_OK)
+                return retVal;
+
+            if ((sgmiibit == 1) || (hisgmiibit == 1))
+            {
+                /*for 1000x/100fx/1000x_100fx, param has to be set to serdes registers*/
+                if((retVal = rtl8367c_getAsicReg(0x1d41, &regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit5: cfg_mac6_fib =1,  bit7: cfg_mac6_fib2=1*/
+                if((regValue & 0xa0) == 0xa0)
+                {
+                     /* new_cfg_sds_mode */
+                    if((retVal = rtl8367c_getAsicRegBits(0x1d95, 0x1f00, &regValue2)) != RT_ERR_OK)
+                        return retVal;
+
+                     /*1000X*/
+                    if(regValue2 == 0x4)
+                    {
+#if 0
+                        /* new_cfg_sds_mode:reset mode */
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                            return retVal;
+#endif
+                        /* Enable new sds mode config */
+                        if((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 0  bit 12  set 1,  bit15~13 = 4*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFF0FFF;
+                        reg_data |= 0x9000;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 0 2  bit 6  set 1,  bit13 set to 0, bit12 nway_en*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 0, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFDFFF;
+                        reg_data |= 0x40;
+                        if(pPortAbility->forcemode)
+                            reg_data &= 0xffffefff;
+                        else
+                            reg_data |= 0x1000;
+
+                        if((retVal = rtl8367c_setAsicSdsReg(0,0,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 2  bit 8  rx pause,  bit7 tx pause*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        if (pPortAbility->txpause)
+                            reg_data |= 0x80;
+                        else
+                            reg_data &= (~0x80);
+
+                        if (pPortAbility->rxpause)
+                            reg_data |= 0x100;
+                        else
+                            reg_data &= (~0x100);
+
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                         /* 0 4 0  bit 12  set 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFEFFF;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /*new_cfg_sds_mode=1000x*/
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x4)) != RT_ERR_OK)
+                            return retVal;
+
+                    }
+                    else if(regValue2 == 0x5)
+                    {
+#if 0
+                        /*100FX*/
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                            return retVal;
+#endif
+                        /*cfg_sds_mode_sel_new=1  */
+                        if((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 0  bit 12  set 1,  bit15~13 = 5*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFF0FFF;
+                        reg_data |= 0xB000;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 0 2  bit 6  set 0,  bit13 set to 1, bit12 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 0, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFFFBF;
+                        reg_data |= 0x2000;
+                        reg_data &= 0xffffefff;
+
+                        if((retVal = rtl8367c_setAsicSdsReg(0,0,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 2  bit 8  rx pause,  bit7 tx pause*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        if (pPortAbility->txpause)
+                            reg_data |= 0x80;
+                        else
+                            reg_data &= (~0x80);
+                        if (pPortAbility->rxpause)
+                            reg_data |= 0x100;
+                        else
+                            reg_data &= (~0x100);
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                         /* 0 4 0  bit 12  set 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFEFFF;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+                       /* new_cfg_sds_mode=1000x */
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x5)) != RT_ERR_OK)
+                            return retVal;
+
+                    }
+                    else if(regValue2 == 0x7)
+                    {
+#if 0
+                        /*100FX*/
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                            return retVal;
+#endif
+                        if((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 0  bit 12  set 1,  bit15~13 = 4*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFF0FFF;
+                        reg_data |= 0x9000;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 0 2  bit 6  set 1,  bit13 set to 0, bit12 nway_en*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 0, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFDFFF;
+                        reg_data |= 0x40;
+                        if(pPortAbility->forcemode)
+                            reg_data &= 0xffffefff;
+                        else
+                            reg_data |= 0x1000;
+
+                        if((retVal = rtl8367c_setAsicSdsReg(0,0,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 2  bit 8  rx pause,  bit7 tx pause*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        if (pPortAbility->txpause)
+                            reg_data |= 0x80;
+                        else
+                            reg_data &= (~0x80);
+                        if (pPortAbility->rxpause)
+                            reg_data |= 0x100;
+                        else
+                            reg_data &=(~0x100);
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                         /* 0 4 0  bit 12  set 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFEFFF;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 0  bit 12  set 1,  bit15~13 = 5*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFF0FFF;
+                        reg_data |= 0xB000;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 0 2  bit 6  set 0,  bit13 set to 1, bit12 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 0, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFFFBF;
+                        reg_data |= 0x2000;
+                        reg_data &= 0xffffefff;
+
+                        if((retVal = rtl8367c_setAsicSdsReg(0,0,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 2  bit 8  rx pause,  bit7 tx pause*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        if (pPortAbility->txpause)
+                            reg_data |= 0x80;
+                        else
+                            reg_data &= 0xffffff7f;
+                        if (pPortAbility->rxpause)
+                            reg_data |= 0x100;
+                        else
+                            reg_data &= 0xfffffeff;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                         /* 0 4 0  bit 12  set 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFEFFF;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        /*sds_mode:*/
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x7)) != RT_ERR_OK)
+                            return retVal;
+
+                    }
+
+                    /*disable force ability   ---      */
+                    if((retVal = rtl8367c_setAsicRegBit(0x137c, 12, 0)) != RT_ERR_OK)
+                        return retVal;
+                    return RT_ERR_OK;
+
+                }
+
+                /* new_cfg_sds_mode */
+                if((retVal = rtl8367c_getAsicRegBits(0x1d95, 0x1f00, &regValue2)) != RT_ERR_OK)
+                    return retVal;
+                if(regValue2 == 0x2)
+                {
+#if 0
+                    /*SGMII*/
+                    if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                        return retVal;
+#endif
+                    if((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                        return retVal;
+
+                    for(i=0;i<0xfff; i++);
+
+                    /* 0 2 0  bit 8-9  nway*/
+                    if((retVal = rtl8367c_getAsicSdsReg(0, 2, 0, &reg_data)) != RT_ERR_OK)
+                        return retVal;
+                    reg_data &= 0xfffffcff;
+                    if (pPortAbility->nway)
+                        reg_data &= 0xfffffcff;
+                    else
+                        reg_data |= 0x100;
+                    if((retVal = rtl8367c_setAsicSdsReg(0,2,0, reg_data)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x2)) != RT_ERR_OK)
+                        return retVal;
+
+                    for(i=0;i<0xfff; i++);
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_FDUP_OFFSET, pPortAbility->duplex)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_SPD_MASK, pPortAbility->speed)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_TXFC_OFFSET, pPortAbility->txpause)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_RXFC_OFFSET, pPortAbility->rxpause)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_LINK_OFFSET, pPortAbility->link)) != RT_ERR_OK)
+                        return retVal;
+
+                    /*disable force ability   ---      */
+                    if((retVal = rtl8367c_setAsicRegBit(0x137c, 12, 0)) != RT_ERR_OK)
+                        return retVal;
+                    return RT_ERR_OK;
+                }
+                else if(regValue2 == 0x12)
+                {
+#if 0
+                    /*HiSGMII*/
+                    if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                        return retVal;
+#endif
+                    if((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                        return retVal;
+
+                    for(i=0;i<0xfff; i++);
+
+                    /* 0 2 0  bit 8-9  nway*/
+                    if((retVal = rtl8367c_getAsicSdsReg(0, 2, 0, &reg_data)) != RT_ERR_OK)
+                        return retVal;
+                    reg_data &= 0xfffffcff;
+                    if (pPortAbility->nway)
+                        reg_data &= 0xfffffcff;
+                    else
+                        reg_data |= 0x100;
+                    if((retVal = rtl8367c_setAsicSdsReg(0,2,0, reg_data)) != RT_ERR_OK)
+                        return retVal;
+
+
+                    if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x12)) != RT_ERR_OK)
+                        return retVal;
+
+                    for(i=0;i<0xfff; i++);
+
+                    if((retVal = rtl8367c_setAsicRegBit(0x1d11, 11, 0x1)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_FDUP_OFFSET, pPortAbility->duplex)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_SPD_MASK, pPortAbility->speed)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_TXFC_OFFSET, pPortAbility->txpause)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_RXFC_OFFSET, pPortAbility->rxpause)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_LINK_OFFSET, pPortAbility->link)) != RT_ERR_OK)
+                        return retVal;
+
+                    /*disable force ability   ---      */
+                    if((retVal = rtl8367c_setAsicRegBit(0x137c, 12, 0)) != RT_ERR_OK)
+                        return retVal;
+                    return RT_ERR_OK;
+
+                }
+            }
+            else
+            {
+                if((retVal = rtl8367c_getAsicRegBits(0x1d3d, 10, &regValue2)) != RT_ERR_OK)
+                    return retVal;
+                if (regValue2 == 0)
+                {
+                    /*ext1_force_ablty*/
+                    if((retVal = rtl8367c_setAsicRegBit(0x1311, 2, pPortAbility->duplex)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBits(0x1311, 0x3, pPortAbility->speed)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(0x1311, 4, pPortAbility->link)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(0x1311, 6, pPortAbility->txpause)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(0x1311, 5, pPortAbility->rxpause)) != RT_ERR_OK)
+                        return retVal;
+
+                    /*force mode for ext1*/
+                    if((retVal = rtl8367c_setAsicRegBit(0x1311, 12, pPortAbility->forcemode)) != RT_ERR_OK)
+                        return retVal;
+
+                    if (pPortAbility->link == 1)
+                    {
+                        if((retVal = rtl8367c_setAsicRegBit(0x1311, 4, 0)) != RT_ERR_OK)
+                            return retVal;
+
+                        if((retVal = rtl8367c_setAsicRegBit(0x1311, 4, 1)) != RT_ERR_OK)
+                            return retVal;
+                    }
+                    else
+                    {
+                        if((retVal = rtl8367c_setAsicRegBits(0x1311, 0x3, 2)) != RT_ERR_OK)
+                            return retVal;
+                    }
+
+                    /*disable force ability   ---      */
+                    if((retVal = rtl8367c_setAsicRegBit(0x137c, 12, 0)) != RT_ERR_OK)
+                        return retVal;
+                    return RT_ERR_OK;
+                }
+            }
+
+
+        }
+        else if (2 == id)
+        {
+
+            if((retVal = rtl8367c_getAsicRegBit(0x1d95, 0, &sgmiibit)) != RT_ERR_OK)
+                    return retVal;
+            if (sgmiibit == 1)
+            {
+                /*for 1000x/100fx/1000x_100fx, param has to bet set to serdes registers*/
+                if((retVal = rtl8367c_getAsicReg(0x1d95, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                /*cfg_mac7_sel_sgmii=1 & cfg_mac7_fib =1*/
+                if((regValue & 0x3) == 0x3)
+                {
+                    if((retVal = rtl8367c_getAsicRegBits(0x1d95, 0x1f00, &regValue2)) != RT_ERR_OK)
+                        return retVal;
+
+                    if(regValue2 == 0x4)
+                    {
+                        /*1000X*/
+#if 0
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                            return retVal;
+#endif
+                        if((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 0  bit 12  set 1,  bit15~13 = 4*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFF0FFF;
+                        reg_data |= 0x9000;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 0 2  bit 6  set 1,  bit13 set to 0, bit12 nway_en*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 0, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFDFFF;
+                        reg_data |= 0x40;
+                        if(pPortAbility->forcemode)
+                            reg_data &= 0xffffefff;
+                        else
+                            reg_data |= 0x1000;
+
+                        if((retVal = rtl8367c_setAsicSdsReg(0,0,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 2  bit 8  rx pause,  bit7 tx pause*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        if (pPortAbility->txpause)
+                            reg_data |= 0x80;
+                        else
+                            reg_data &= 0xffffff7f;
+                        if (pPortAbility->rxpause)
+                            reg_data |= 0x100;
+                        else
+                            reg_data &= 0xfffffeff;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                         /* 0 4 0  bit 12  set 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFEFFF;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x4)) != RT_ERR_OK)
+                            return retVal;
+
+                    }
+                    else if(regValue2 == 0x5)
+                    {
+                        /*100FX*/
+#if 0
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                            return retVal;
+#endif
+                        if((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 0  bit 12  set 1,  bit15~13 = 5*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFF0FFF;
+                        reg_data |= 0xB000;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 0 2  bit 6  set 0,  bit13 set to 1, bit12 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 0, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFFFBF;
+                        reg_data |= 0x2000;
+                        reg_data &= 0xffffefff;
+
+                        if((retVal = rtl8367c_setAsicSdsReg(0,0,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 2  bit 8  rx pause,  bit7 tx pause*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        if (pPortAbility->txpause)
+                            reg_data |= 0x80;
+                        else
+                            reg_data &= 0xffffff7f;
+                        if (pPortAbility->rxpause)
+                            reg_data |= 0x100;
+                        else
+                            reg_data &= 0xfffffeff;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                         /* 0 4 0  bit 12  set 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFEFFF;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x5)) != RT_ERR_OK)
+                            return retVal;
+
+                    }
+                    else if(regValue2 == 0x7)
+                    {
+                        /*100FX*/
+#if 0
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                            return retVal;
+#endif
+                        if((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 0  bit 12  set 1,  bit15~13 = 4*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFF0FFF;
+                        reg_data |= 0x9000;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 0 2  bit 6  set 1,  bit13 set to 0, bit12 nway_en*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 0, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFDFFF;
+                        reg_data |= 0x40;
+                        if(pPortAbility->forcemode)
+                            reg_data &= 0xffffefff;
+                        else
+                            reg_data |= 0x1000;
+
+                        if((retVal = rtl8367c_setAsicSdsReg(0,0,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 2  bit 8  rx pause,  bit7 tx pause*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        if (pPortAbility->txpause)
+                            reg_data |= 0x80;
+                        else
+                            reg_data &= 0xffffff7f;
+                        if (pPortAbility->rxpause)
+                            reg_data |= 0x100;
+                        else
+                            reg_data &= 0xfffffeff;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                         /* 0 4 0  bit 12  set 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFEFFF;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 0  bit 12  set 1,  bit15~13 = 5*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFF0FFF;
+                        reg_data |= 0xB000;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 0 2  bit 6  set 0,  bit13 set to 1, bit12 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 0, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFFFBF;
+                        reg_data |= 0x2000;
+                        reg_data &= 0xffffefff;
+
+                        if((retVal = rtl8367c_setAsicSdsReg(0,0,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* 0 4 2  bit 8  rx pause,  bit7 tx pause*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 2, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        if (pPortAbility->txpause)
+                            reg_data |= 0x80;
+                        else
+                            reg_data  &= 0xffffff7f;
+                        if (pPortAbility->rxpause)
+                            reg_data |= 0x100;
+                        else
+                            reg_data &= 0xfffffeff;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,2, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                         /* 0 4 0  bit 12  set 0*/
+                        if((retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &reg_data)) != RT_ERR_OK)
+                            return retVal;
+                        reg_data &= 0xFFFFEFFF;
+                        if((retVal = rtl8367c_setAsicSdsReg(0,4,0, reg_data)) != RT_ERR_OK)
+                            return retVal;
+
+                        if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x7)) != RT_ERR_OK)
+                            return retVal;
+
+                    }
+
+                    if((retVal = rtl8367c_setAsicRegBit(0x137d, 12, 0)) != RT_ERR_OK)
+                        return retVal;
+                    return RT_ERR_OK;
+
+                }
+                /* new_cfg_sds_mode */
+                if((retVal = rtl8367c_getAsicRegBits(0x1d95, 0x1f00, &regValue2)) != RT_ERR_OK)
+                        return retVal;
+                if(regValue2 == 0x2)
+                {
+                    /*SGMII*/
+#if 0
+                    if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                        return retVal;
+#endif
+                    if((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                        return retVal;
+
+                    for(i=0;i<0xfff; i++);
+
+                    /* 0 2 0  bit 8-9  nway*/
+                    if((retVal = rtl8367c_getAsicSdsReg(0, 2, 0, &reg_data)) != RT_ERR_OK)
+                        return retVal;
+                    reg_data &= 0xfffffcff;
+                    if (pPortAbility->nway)
+                        reg_data &= 0xfffffcff;
+                    else
+                        reg_data |= 0x100;
+                    if((retVal = rtl8367c_setAsicSdsReg(0,2,0, reg_data)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x2)) != RT_ERR_OK)
+                        return retVal;
+
+                    for(i=0;i<0xfff; i++);
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_FDUP_OFFSET, pPortAbility->duplex)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_SPD_MASK, pPortAbility->speed)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_TXFC_OFFSET, pPortAbility->txpause)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_RXFC_OFFSET, pPortAbility->rxpause)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_LINK_OFFSET, pPortAbility->link)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(0x137d, 12, 0)) != RT_ERR_OK)
+                        return retVal;
+                    return RT_ERR_OK;
+                }
+            }
+            else
+            {
+
+                /*ext2_force_ablty*/
+                if((retVal = rtl8367c_setAsicRegBit(0x13c4, 2, pPortAbility->duplex)) != RT_ERR_OK)
+                    return retVal;
+
+                if((retVal = rtl8367c_setAsicRegBits(0x13c4, 0x3, pPortAbility->speed)) != RT_ERR_OK)
+                    return retVal;
+
+                if((retVal = rtl8367c_setAsicRegBit(0x13c4, 4, pPortAbility->link)) != RT_ERR_OK)
+                    return retVal;
+
+                if((retVal = rtl8367c_setAsicRegBit(0x13c4, 6, pPortAbility->txpause)) != RT_ERR_OK)
+                    return retVal;
+
+                if((retVal = rtl8367c_setAsicRegBit(0x13c4, 5, pPortAbility->rxpause)) != RT_ERR_OK)
+                    return retVal;
+
+                /*force mode for ext2*/
+                if((retVal = rtl8367c_setAsicRegBit(0x13c4, 12, pPortAbility->forcemode)) != RT_ERR_OK)
+                    return retVal;
+
+                if (pPortAbility->link == 1)
+                {
+                    if((retVal = rtl8367c_setAsicRegBit(0x13c4, 4, 0)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(0x13c4, 4, 1)) != RT_ERR_OK)
+                        return retVal;
+                }
+                else
+                {
+                    if((retVal = rtl8367c_setAsicRegBits(0x13c4, 0x3, 2)) != RT_ERR_OK)
+                        return retVal;
+                }
+
+
+                if((retVal = rtl8367c_getAsicRegBit(0x1d3d, 10, &reg_data)) != RT_ERR_OK)
+                        return retVal;
+                if(reg_data == 1)
+                {
+                if((retVal = rtl8367c_setAsicRegBit(0x1311, 2, pPortAbility->duplex)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBits(0x1311, 0x3, pPortAbility->speed)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(0x1311, 4, pPortAbility->link)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(0x1311, 6, pPortAbility->txpause)) != RT_ERR_OK)
+                        return retVal;
+
+                    if((retVal = rtl8367c_setAsicRegBit(0x1311, 5, pPortAbility->rxpause)) != RT_ERR_OK)
+                        return retVal;
+
+                    /*force mode for ext1*/
+                    if((retVal = rtl8367c_setAsicRegBit(0x1311, 12, pPortAbility->forcemode)) != RT_ERR_OK)
+                        return retVal;
+
+                    if (pPortAbility->link == 1)
+                    {
+                        if((retVal = rtl8367c_setAsicRegBit(0x1311, 4, 0)) != RT_ERR_OK)
+                            return retVal;
+
+                        if((retVal = rtl8367c_setAsicRegBit(0x1311, 4, 1)) != RT_ERR_OK)
+                            return retVal;
+                    }
+                    else
+                    {
+                        if((retVal = rtl8367c_setAsicRegBits(0x1311, 0x3, 2)) != RT_ERR_OK)
+                            return retVal;
+                    }
+                }
+
+
+            }
+
+            /*disable force ability   ---      */
+            if((retVal = rtl8367c_setAsicRegBit(0x137d, 12, 0)) != RT_ERR_OK)
+                return retVal;
+        }
+#if 0
+        if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_FDUP_OFFSET, pPortAbility->duplex)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_SPD_MASK, pPortAbility->speed)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_TXFC_OFFSET, pPortAbility->txpause)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_RXFC_OFFSET, pPortAbility->rxpause)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_LINK_OFFSET, pPortAbility->link)) != RT_ERR_OK)
+            return retVal;
+#endif
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortForceLinkExt
+ * Description:
+ *      Get external interface force linking configuration
+ * Input:
+ *      id          - external interface id (0~1)
+ *      pPortAbility - port ability configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortForceLinkExt(rtk_uint32 id, rtl8367c_port_ability_t *pPortAbility)
+{
+    rtk_uint32  reg_data, regValue, type;
+    rtk_uint32  sgmiiSel;
+    rtk_uint32  hsgmiiSel;
+    ret_t       retVal;
+
+    /* Invalid input parameter */
+    if(id >= RTL8367C_EXTNO)
+        return RT_ERR_OUT_OF_RANGE;
+    /*cfg_magic_id  &  get chip_id*/
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regValue)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    type = 0;
+
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            type = 1;
+            break;
+        case 0x0652:
+        case 0x6368:
+            type = 2;
+            break;
+        case 0x0801:
+        case 0x6511:
+            type = 3;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+
+    if (1 == type)
+    {
+        if(1 == id)
+        {
+            if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_SGMII_OFFSET, &sgmiiSel)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET, &hsgmiiSel)) != RT_ERR_OK)
+                return retVal;
+
+            if( (sgmiiSel == 1) || (hsgmiiSel == 1) )
+            {
+                memset(pPortAbility, 0x00, sizeof(rtl8367c_port_ability_t));
+                pPortAbility->forcemode = 1;
+
+                if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_FDUP_OFFSET, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+
+                pPortAbility->duplex = reg_data;
+
+                if((retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_SPD_MASK, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+
+                pPortAbility->speed = reg_data;
+
+                if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_LINK_OFFSET, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+
+                pPortAbility->link = reg_data;
+
+                if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_TXFC_OFFSET, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+
+                pPortAbility->txpause = reg_data;
+
+                if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_SGMII_RXFC_OFFSET, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+
+                pPortAbility->rxpause = reg_data;
+
+                return RT_ERR_OK;
+            }
+        }
+
+        if(0 == id || 1 == id)
+            retVal = rtl8367c_getAsicReg(RTL8367C_REG_DIGITAL_INTERFACE0_FORCE+id, &reg_data);
+        else
+            retVal = rtl8367c_getAsicReg(RTL8367C_REG_DIGITAL_INTERFACE2_FORCE, &reg_data);
+
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        pPortAbility->forcemode = (reg_data >> 12) & 0x0001;
+        pPortAbility->mstfault  = (reg_data >> 9) & 0x0001;
+        pPortAbility->mstmode   = (reg_data >> 8) & 0x0001;
+        pPortAbility->nway      = (reg_data >> 7) & 0x0001;
+        pPortAbility->txpause   = (reg_data >> 6) & 0x0001;
+        pPortAbility->rxpause   = (reg_data >> 5) & 0x0001;
+        pPortAbility->link      = (reg_data >> 4) & 0x0001;
+        pPortAbility->duplex    = (reg_data >> 2) & 0x0001;
+        pPortAbility->speed     = reg_data & 0x0003;
+    }
+    else if (2 == type)
+    {
+        if (id == 1)
+        {
+            if ((retVal = rtl8367c_getAsicReg(0x1311, &reg_data))!=RT_ERR_OK)
+                return retVal;
+
+            pPortAbility->forcemode = (reg_data >> 12) & 1;
+            pPortAbility->duplex = (reg_data >> 2) & 1;
+            pPortAbility->link = (reg_data >> 4) & 1;
+            pPortAbility->speed = reg_data & 3;
+            pPortAbility->rxpause = (reg_data >> 5) & 1;
+            pPortAbility->txpause = (reg_data >> 6) & 1;
+        }
+        else if (2 == id)
+        {
+            if ((retVal = rtl8367c_getAsicReg(0x13c4, &reg_data))!=RT_ERR_OK)
+                return retVal;
+
+            pPortAbility->forcemode = (reg_data >> 12) & 1;
+            pPortAbility->duplex = (reg_data >> 2) & 1;
+            pPortAbility->link = (reg_data >> 4) & 1;
+            pPortAbility->speed = reg_data & 3;
+            pPortAbility->rxpause = (reg_data >> 5) & 1;
+            pPortAbility->txpause = (reg_data >> 6) & 1;
+        }
+    }
+    else if (3 == type)
+    {
+        if (id == 1)
+        {
+            if ((retVal = rtl8367c_getAsicReg(0x1311, &reg_data))!=RT_ERR_OK)
+                return retVal;
+
+            pPortAbility->forcemode = (reg_data >> 12) & 1;
+            pPortAbility->duplex = (reg_data >> 2) & 1;
+            pPortAbility->link = (reg_data >> 4) & 1;
+            pPortAbility->speed = reg_data & 3;
+            pPortAbility->rxpause = (reg_data >> 5) & 1;
+            pPortAbility->txpause = (reg_data >> 6) & 1;
+        }
+        else if (2 == id)
+        {
+            if ((retVal = rtl8367c_getAsicReg(0x13c4, &reg_data))!=RT_ERR_OK)
+                return retVal;
+
+            pPortAbility->forcemode = (reg_data >> 12) & 1;
+            pPortAbility->duplex = (reg_data >> 2) & 1;
+            pPortAbility->link = (reg_data >> 4) & 1;
+            pPortAbility->speed = reg_data & 3;
+            pPortAbility->rxpause = (reg_data >> 5) & 1;
+            pPortAbility->txpause = (reg_data >> 6) & 1;
+        }
+    }
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortExtMode
+ * Description:
+ *      Set external interface mode configuration
+ * Input:
+ *      id      - external interface id (0~2)
+ *      mode    - external interface mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortExtMode(rtk_uint32 id, rtk_uint32 mode)
+{
+    ret_t   retVal;
+    rtk_uint32 i, regValue, type, option,reg_data;
+    rtk_uint32 idx;
+    rtk_uint32 redData[][2] =   { {0x04D7, 0x0480}, {0xF994, 0x0481}, {0x21A2, 0x0482}, {0x6960, 0x0483}, {0x9728, 0x0484}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x83F2, 0x002E} };
+    rtk_uint32 redDataSB[][2] = { {0x04D7, 0x0480}, {0xF994, 0x0481}, {0x31A2, 0x0482}, {0x6960, 0x0483}, {0x9728, 0x0484}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x83F2, 0x002E} };
+    rtk_uint32 redData1[][2] =  { {0x82F1, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    rtk_uint32 redData5[][2] =  { {0x82F1, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    rtk_uint32 redData6[][2] =  { {0x82F1, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    rtk_uint32 redData8[][2] =  { {0x82F1, 0x0500}, {0xF995, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    rtk_uint32 redData9[][2] =  { {0x82F1, 0x0500}, {0xF995, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    rtk_uint32 redDataHB[][2] = { {0x82F0, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x7960, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+
+    if(id >= RTL8367C_EXTNO)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(mode >= EXT_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    /* magic number*/
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+    /* Chip num */
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regValue)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    type = 0;
+
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            type = 1;
+            break;
+        case 0x0652:
+        case 0x6368:
+            type = 2;
+            break;
+        case 0x0801:
+        case 0x6511:
+            type = 3;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+
+
+    if (1==type)
+    {
+        if((mode == EXT_1000X_100FX) || (mode == EXT_1000X) || (mode == EXT_100FX))
+        {
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_REG_TO_ECO4, 5, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_REG_TO_ECO4, 7, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_CHIP_RESET, RTL8367C_DW8051_RST_OFFSET, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MISCELLANEOUS_CONFIGURE0, RTL8367C_DW8051_EN_OFFSET, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_ACS_IROM_ENABLE_OFFSET, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_IROM_MSB_OFFSET, 0)) != RT_ERR_OK)
+                return retVal;
+
+            if(mode == EXT_1000X_100FX)
+            {
+                for(idx = 0; idx < FIBER2_AUTO_INIT_SIZE; idx++)
+                {
+                    if ((retVal = rtl8367c_setAsicReg(0xE000 + idx, (rtk_uint32)Fiber2_Auto[idx])) != RT_ERR_OK)
+                        return retVal;
+                }
+            }
+
+            if(mode == EXT_1000X)
+            {
+                for(idx = 0; idx < FIBER2_1G_INIT_SIZE; idx++)
+                {
+                    if ((retVal = rtl8367c_setAsicReg(0xE000 + idx, (rtk_uint32)Fiber2_1G[idx])) != RT_ERR_OK)
+                        return retVal;
+                }
+            }
+
+            if(mode == EXT_100FX)
+            {
+                for(idx = 0; idx < FIBER2_100M_INIT_SIZE; idx++)
+                {
+                    if ((retVal = rtl8367c_setAsicReg(0xE000 + idx, (rtk_uint32)Fiber2_100M[idx])) != RT_ERR_OK)
+                        return retVal;
+                }
+            }
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_IROM_MSB_OFFSET, 0)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_ACS_IROM_ENABLE_OFFSET, 0)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_CHIP_RESET, RTL8367C_DW8051_RST_OFFSET, 0)) != RT_ERR_OK)
+                return retVal;
+        }
+
+        if(mode == EXT_GMII)
+        {
+            if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_EXT0_RGMXF, RTL8367C_EXT0_RGTX_INV_OFFSET, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_EXT1_RGMXF, RTL8367C_EXT1_RGTX_INV_OFFSET, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if( (retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_EXT_TXC_DLY, RTL8367C_EXT1_GMII_TX_DELAY_MASK, 5)) != RT_ERR_OK)
+                return retVal;
+
+            if( (retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_EXT_TXC_DLY, RTL8367C_EXT0_GMII_TX_DELAY_MASK, 6)) != RT_ERR_OK)
+                return retVal;
+        }
+
+        /* Serdes reset */
+        if( (mode == EXT_TMII_MAC) || (mode == EXT_TMII_PHY) )
+        {
+            if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_BYPASS_LINE_RATE, id, 1)) != RT_ERR_OK)
+                return retVal;
+        }
+        else
+        {
+            if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_BYPASS_LINE_RATE, id, 0)) != RT_ERR_OK)
+                return retVal;
+        }
+
+        if( (mode == EXT_SGMII) || (mode == EXT_HSGMII) )
+        {
+            if(id != 1)
+                return RT_ERR_PORT_ID;
+
+            if((retVal = rtl8367c_setAsicReg(0x13C0, 0x0249)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicReg(0x13C1, &option)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicReg(0x13C0, 0x0000)) != RT_ERR_OK)
+                return retVal;
+        }
+
+        if(mode == EXT_SGMII)
+        {
+            if(option == 0)
+            {
+                for(i = 0; i <= 7; i++)
+                {
+                    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, redData[i][0])) != RT_ERR_OK)
+                        return retVal;
+
+                    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, redData[i][1])) != RT_ERR_OK)
+                        return retVal;
+
+                    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                        return retVal;
+                }
+            }
+            else
+            {
+                for(i = 0; i <= 7; i++)
+                {
+                    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, redDataSB[i][0])) != RT_ERR_OK)
+                        return retVal;
+
+                    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, redDataSB[i][1])) != RT_ERR_OK)
+                        return retVal;
+
+                    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                        return retVal;
+                }
+            }
+        }
+
+        if(mode == EXT_HSGMII)
+        {
+            if(option == 0)
+            {
+                if( (retVal = rtl8367c_setAsicReg(0x13c2, 0x0249)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_getAsicReg(0x1301, &regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(0x13c2, 0x0000)) != RT_ERR_OK)
+                    return retVal;
+
+                if ( ((regValue & 0x00F0) >> 4) == 0x0001)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, redData1[i][0])) != RT_ERR_OK)
+                            return retVal;
+
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, redData1[i][1])) != RT_ERR_OK)
+                            return retVal;
+
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                            return retVal;
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0005)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, redData5[i][0])) != RT_ERR_OK)
+                            return retVal;
+
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, redData5[i][1])) != RT_ERR_OK)
+                            return retVal;
+
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                            return retVal;
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0006)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, redData6[i][0])) != RT_ERR_OK)
+                            return retVal;
+
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, redData6[i][1])) != RT_ERR_OK)
+                            return retVal;
+
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                            return retVal;
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0008)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, redData8[i][0])) != RT_ERR_OK)
+                            return retVal;
+
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, redData8[i][1])) != RT_ERR_OK)
+                            return retVal;
+
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                            return retVal;
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0009)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, redData9[i][0])) != RT_ERR_OK)
+                            return retVal;
+
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, redData9[i][1])) != RT_ERR_OK)
+                            return retVal;
+
+                        if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                            return retVal;
+                    }
+                }
+            }
+            else
+            {
+                for(i = 0; i <= 8; i++)
+                {
+                    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, redDataHB[i][0])) != RT_ERR_OK)
+                        return retVal;
+
+                    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, redDataHB[i][1])) != RT_ERR_OK)
+                        return retVal;
+
+                    if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                        return retVal;
+                }
+            }
+        }
+
+        /* Only one ext port should care SGMII setting */
+        if(id == 1)
+        {
+
+            if(mode == EXT_SGMII)
+            {
+                if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_SGMII_OFFSET, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET, 0)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if(mode == EXT_HSGMII)
+            {
+                if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_SGMII_OFFSET, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET, 1)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else
+            {
+
+                if((mode != EXT_1000X_100FX) && (mode != EXT_1000X) && (mode != EXT_100FX))
+                {
+                    if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_SGMII_OFFSET, 0)) != RT_ERR_OK)
+                        return retVal;
+
+                    if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET, 0)) != RT_ERR_OK)
+                        return retVal;
+                }
+            }
+        }
+
+        if(0 == id || 1 == id)
+        {
+            if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_DIGITAL_INTERFACE_SELECT, RTL8367C_SELECT_GMII_0_MASK << (id * RTL8367C_SELECT_GMII_1_OFFSET), mode)) != RT_ERR_OK)
+                return retVal;
+        }
+        else
+        {
+            if((retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_DIGITAL_INTERFACE_SELECT_1, RTL8367C_SELECT_GMII_2_MASK, mode)) != RT_ERR_OK)
+                return retVal;
+        }
+
+        /* Serdes not reset */
+        if( (mode == EXT_SGMII) || (mode == EXT_HSGMII) )
+        {
+            if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0x7106)) != RT_ERR_OK)
+                return retVal;
+
+            if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, 0x0003)) != RT_ERR_OK)
+                return retVal;
+
+            if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                return retVal;
+        }
+
+        if( (mode == EXT_SGMII) || (mode == EXT_HSGMII) )
+        {
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_CHIP_RESET, RTL8367C_DW8051_RST_OFFSET, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_MISCELLANEOUS_CONFIGURE0, RTL8367C_DW8051_EN_OFFSET, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_ACS_IROM_ENABLE_OFFSET, 1)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_IROM_MSB_OFFSET, 0)) != RT_ERR_OK)
+                return retVal;
+
+            for(idx = 0; idx < SGMII_INIT_SIZE; idx++)
+            {
+                if ((retVal = rtl8367c_setAsicReg(0xE000 + idx, (rtk_uint32)Sgmii_Init[idx])) != RT_ERR_OK)
+                    return retVal;
+            }
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_IROM_MSB_OFFSET, 0)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_DW8051_RDY, RTL8367C_ACS_IROM_ENABLE_OFFSET, 0)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_CHIP_RESET, RTL8367C_DW8051_RST_OFFSET, 0)) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+    else if (2 == type)
+    {
+        /* Serdes reset */
+        if( (mode == EXT_TMII_MAC) || (mode == EXT_TMII_PHY) )
+        {
+            if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_BYPASS_LINE_RATE, id+2, 1)) != RT_ERR_OK)
+                return retVal;
+        }
+        else
+        {
+            if( (retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_BYPASS_LINE_RATE, id+2, 0)) != RT_ERR_OK)
+                return retVal;
+        }
+
+        /*set MAC mode*/
+        if (id == 1)
+        {
+            if(mode == EXT_HSGMII)
+                return RT_ERR_PORT_ID;
+
+            if (mode == EXT_SGMII)
+            {
+                /*cfg port8 with MII mac mode*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*enable port8 SGMII*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d92, 14, 1)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if (mode == EXT_1000X || mode == EXT_100FX || mode == EXT_1000X_100FX)
+            {
+                /*cfg port8 with MII mac mode*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*disable port8 SGMII*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d92, 14, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*set fiber link up*/
+                if((retVal = rtl8367c_setAsicRegBit(0x6210, 11, 0)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else
+            {
+                /*cfg port8 with MII mac mode*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, mode)) != RT_ERR_OK)
+                    return retVal;
+
+                /*disable port8 SGMII*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d92, 14, 0)) != RT_ERR_OK)
+                    return retVal;
+            }
+            /*disable SDS 1*/
+            if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f00, 0x1f)) != RT_ERR_OK)
+                return retVal;
+        }
+        else if(id == 2)
+        {
+            if (mode == EXT_HSGMII)
+            {
+                if ((retVal = rtl8367c_setAsicReg(0x130, 7)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicReg(0x39f, 7)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicReg(0x3fa, 7)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else
+            {
+                if ((retVal = rtl8367c_setAsicReg(0x130, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicReg(0x39f, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicReg(0x3fa, 4)) != RT_ERR_OK)
+                    return retVal;
+
+            }
+
+
+            if (mode == EXT_SGMII)
+            {
+                /*cfg port9 with MII mac mode*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13c3, 0xf, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*enable port9 SGMII*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d92, 6, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*disable port9 HSGMII*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d92, 7, 0)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if (mode == EXT_HSGMII)
+            {
+                /*cfg port9 with MII mac mode*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13c3, 0xf, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*disable port9 SGMII*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d92, 6, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*enable port9 HSGMII*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d92, 7, 1)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if (mode == EXT_1000X || mode == EXT_100FX || mode == EXT_1000X_100FX)
+            {
+                /*cfg port9 with MII mac mode*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13c3, 0xf, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*disable port9 SGMII*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d92, 6, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*disable port9 HSGMII*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d92, 7, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*set fiber link up*/
+                if((retVal = rtl8367c_setAsicRegBit(0x6200, 11, 0)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else
+            {
+                /*cfg port9 with MII mac mode*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13c3, 0xf, mode)) != RT_ERR_OK)
+                    return retVal;
+
+                /*disable port9 SGMII*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d92, 6, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*disable port9 HSGMII*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d92, 7, 0)) != RT_ERR_OK)
+                    return retVal;
+            }
+            /*disable SDS 0*/
+            if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f, 0x1f)) != RT_ERR_OK)
+                return retVal;
+        }
+
+        /*SET TO RGMII MODE*/
+        if (mode == EXT_RGMII)
+        {
+            /*disable paral led pad*/
+            if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PARA_LED_IO_EN3, 0)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PARA_LED_IO_EN1, 0)) != RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_setAsicReg(RTL8367C_REG_PARA_LED_IO_EN2, 0)) != RT_ERR_OK)
+                return retVal;
+
+            /*set MAC8 mode*/
+            if (id == 1)
+            {
+                /*1: RGMII1 bias work at 3.3V, 0: RGMII1 bias work at 2.5V*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1303, 9, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*drving 1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1303, 6, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*drving 1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1303, 4, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*show rate = 0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1303, 1, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*EXT1 RGMII TXC delay 2ns*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1307, 3, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_Ext1_rgtxc_dly = 0*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13f9, 0x38, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*RXDLY = 0*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1307, 0x7, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_rg1_dn = 4*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1304, 0x7000, 4)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_rg1_dp = 4*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13f9, 0x700, 4)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if (id == 2)
+            {
+                /*1: RGMII1 bias work at 3.3V, 0: RGMII1 bias work at 2.5V*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1303, 10, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*drving 1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x13e2, 2, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*drving 1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x13e2, 1, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*show rate = 0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x13e2, 0, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*EXT1 RGMII TXC delay 2ns*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x13c5, 3, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_Ext1_rgtxc_dly = 0*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13f9, 0x1c0, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*RXDLY = 0*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13c5, 0x7, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_rg1_dn = 4*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13e2, 0x1c0, 4)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_rg1_dp = 4*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13e2, 0x38, 4)) != RT_ERR_OK)
+                    return retVal;
+            }
+        }
+        else if (mode == EXT_SGMII)
+        {
+            if (id == 1)
+            {
+                /*sds 1     reg 1    page 0x21     write value  0xec91*/
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0xec91)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (0x21<<5) | 1)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*sds 1     reg 5    page 0x24     write value  0x5825*/
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0x5825)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (0x24<<5) | 5)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C1)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f00, 2)) != RT_ERR_OK)
+                    return retVal;
+
+                /*?????????????????*/
+
+            }
+            else if (id == 2)
+            {
+                /*sds 0     reg 0    page 0x28     write value  0x942c*/
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0x942c)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (0x28<<5) | 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*sds 0     reg 0    page 0x24     write value  0x942c*/
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0x942c)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (0x24<<5) | 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*sds 0     reg 5    page 0x21     write value  0x8dc3*/
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0x8dc3)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (0x21<<5) | 5)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f, 2)) != RT_ERR_OK)
+                    return retVal;
+
+                /*?????????????????*/
+            }
+        }
+        else if (mode == EXT_HSGMII)
+        {
+            if (id == 2)
+            {
+                /*sds 0     reg 0    page 0x28     write value  0x942c*/
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0x942c)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (0x28<<5) | 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*sds 0     reg 0    page 0x24     write value  0x942c*/
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0x942c)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (0x24<<5) | 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*sds 0     reg 5    page 0x21     write value  0x8dc3*/
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0x8dc3)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (0x21<<5) | 5)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                    return retVal;
+
+
+                /* optimizing HISGMII performance while RGMII used & */
+                /*sds 0     reg 9     page 0x21     write value 0x3931*/
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_DATA, 0x3931)) != RT_ERR_OK)
+                        return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_ADR, (0x21<<5)|9) ) != RT_ERR_OK)
+                        return retVal;
+
+                if( (retVal = rtl8367c_setAsicReg(RTL8367C_REG_SDS_INDACS_CMD, 0x00C0)) != RT_ERR_OK)
+                        return retVal;
+
+
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f, 0x12)) != RT_ERR_OK)
+                    return retVal;
+
+                /*?????????????????*/
+            }
+        }
+        else if (mode == EXT_1000X)
+        {
+            if (id == 1)
+            {
+
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 1, 0x21, 0xec91)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 5, 0x24, 0x5825)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f00, 4)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f00, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+
+                /*patch speed change sds1 1000M*/
+                if( (retVal = rtl8367c_getAsicSdsReg(1, 4, 0, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFF0FFF;
+                regValue |= 0x9000;
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 4, 0, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_getAsicSdsReg(1, 0, 2, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFFdFFF;
+                regValue |= 0x40;
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 0, 2, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+
+                if( (retVal = rtl8367c_getAsicSdsReg(1, 4, 0, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFFEFFF;
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 4, 0, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f00, 4)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x6000, 0)) != RT_ERR_OK)
+                    return retVal;
+
+            }
+            else if (id == 2)
+            {
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 0, 0x28, 0x942c)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 0, 0x24, 0x942c)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 5, 0x21, 0x8dc3)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f, 4)) != RT_ERR_OK)
+                    return retVal;
+
+                /*patch speed change sds0 1000M*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFF0FFF;
+                regValue |= 0x9000;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 4, 0, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_getAsicSdsReg(0, 0, 2, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFFDFFF;
+                regValue |= 0x40;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 0, 2, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFFEFFF;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 4, 0, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f, 4)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0xe0, 0)) != RT_ERR_OK)
+                    return retVal;
+
+            }
+        }
+        else if (mode == EXT_100FX)
+        {
+            if (id == 1)
+            {
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 1, 0x21, 0xec91)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 5, 0x24, 0x5825)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f00, 5)) != RT_ERR_OK)
+                    return retVal;
+
+                /*patch speed change sds1 100M*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f00, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_getAsicSdsReg(1, 4, 0, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFF0FFF;
+                regValue |= 0xb000;
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 4, 0, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_getAsicSdsReg(1, 0, 2, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFFFFBF;
+                regValue |= 0x2000;
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 0, 2, regValue)) != RT_ERR_OK)
+                    return retVal;
+#if 0
+                if( (retVal = rtl8367c_setAsicReg(0x6214, 0x1a0)) != RT_ERR_OK)
+                    return retVal;
+#endif
+                if( (retVal = rtl8367c_getAsicSdsReg(1, 4, 0, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFFEFFF;
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 4, 0, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f00, 5)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x6000, 0)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if (id == 2)
+            {
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 0, 0x28, 0x942c)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 0, 0x24, 0x942c)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 5, 0x21, 0x8dc3)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f, 5)) != RT_ERR_OK)
+                    return retVal;
+
+                /*patch speed change sds0 100M*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFF0FFF;
+                regValue |= 0xb000;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 4, 0, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_getAsicSdsReg(0, 0, 2, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFFFFBF;
+                regValue |= 0x2000;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 0, 2, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                if( (retVal = rtl8367c_getAsicSdsReg(0, 4, 0, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue &= 0xFFFFEFFF;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 4, 0, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f, 5)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0xe0, 0)) != RT_ERR_OK)
+                    return retVal;
+            }
+        }
+        else if (mode == EXT_1000X_100FX)
+        {
+            if (id == 1)
+            {
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 1, 0x21, 0xec91)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 5, 0x24, 0x5825)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 13, 0, 0x4616)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(1, 1, 0, 0xf20)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f00, 7)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if (id == 2)
+            {
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 0, 0x28, 0x942c)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 0, 0x24, 0x942c)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 5, 0x21, 0x8dc3)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 13, 0, 0x4616)) != RT_ERR_OK)
+                    return retVal;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 1, 0, 0xf20)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d92, 0x1f, 7)) != RT_ERR_OK)
+                    return retVal;
+            }
+        }
+
+    }
+    else if (3 == type)
+    {
+
+        /*restore patch, by designer. patch Tx FIFO issue, when not HSGMII 2.5G mode
+         #sds0, page 1, reg 1, bit4=0*/
+        if( (retVal = rtl8367c_getAsicSdsReg(0, 1, 1, &regValue)) != RT_ERR_OK)
+            return retVal;
+        regValue &= 0xFFFFFFEF;
+        if( (retVal = rtl8367c_setAsicSdsReg(0, 1, 1, regValue)) != RT_ERR_OK)
+            return retVal;
+
+        /*set for mac 6*/
+        if (1 == id)
+        {
+            /*force port6 linkdown*/
+            if ((retVal = rtl8367c_setAsicReg(0x137c, 0x1000)) != RT_ERR_OK)
+                    return retVal;
+
+            if ((retVal = rtl8367c_getAsicRegBit(0x1d9d, 6, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+            while(reg_data == 0)
+            {
+                if ((retVal = rtl8367c_getAsicRegBit(0x1d9d, 6, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+            }
+
+            if (mode == EXT_SGMII)
+            {
+                /* disable mac6 mode_ext1  mode*/
+                if ((retVal = rtl8367c_getAsicRegBit(0x1d3d, 10, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                if(reg_data == 0)
+                {
+                    if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, 0)) != RT_ERR_OK)
+                        return retVal;
+                }
+                /*cfg_bypass_line_rate[1]=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 1, 0)) != RT_ERR_OK)
+                    return retVal;
+
+
+
+                /*bit5: cfg_mac6_fib=0    &   bit7: cfg_mac6_fib2=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 5, 0)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 7, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac7_fib=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 1, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac7_sel_sgmii= 0: MAC7 is not SGMII mode*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 0, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*#cfg_sgmii_link=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 9, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_hsgmii=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 11, 0)) != RT_ERR_OK)
+                    return retVal;
+
+
+                /*bit13: cfg_sds_mode_sel_new=1 :Enable new sds mode config method*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*  bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                    new_cfg_sds_mode=0x1F (reset mode) */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_sgmii= 1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 6, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /* bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                   new_cfg_sds_mode=0x12  */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x2)) != RT_ERR_OK)
+                    return retVal;
+
+                /* MAC link source*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 2, 0)) != RT_ERR_OK)
+                    return retVal;
+
+
+            }
+            else if (mode == EXT_HSGMII)
+            {
+
+                /*restore patch, by designer. patch Tx FIFO issue, when  HSGMII 2.5G mode
+                 #sds0, page 1, reg 1, bit4=1*/
+                if( (retVal = rtl8367c_getAsicSdsReg(0, 1, 1, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                regValue |= 0x10;
+                if( (retVal = rtl8367c_setAsicSdsReg(0, 1, 1, regValue)) != RT_ERR_OK)
+                    return retVal;
+
+                 /* mode_ext1 = disable*/
+                /* disable mac6 mode_ext1  mode*/
+                if ((retVal = rtl8367c_getAsicRegBit(0x1d3d, 10, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                if(reg_data == 0)
+                {
+                    if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, 0)) != RT_ERR_OK)
+                        return retVal;
+                }
+
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 1, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit5: cfg_mac6_fib=0   &   bit7: cfg_mac6_fib2=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 5, 0)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 7, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac7_fib=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 1, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac7_sel_sgmii= 0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 0, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_sgmii=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 9, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_hsgmii=1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 11, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_sgmii= 0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 6, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicReg(0xd0,7)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicReg(0x399, 7)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicReg(0x3fa, 7)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit13: cfg_sds_mode_sel_new=1 :Enable new sds mode config method*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                    return retVal;
+                /* bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                   new_cfg_sds_mode=0x12  */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x12)) != RT_ERR_OK)
+                    return retVal;
+                /*
+                1: MAC link = SGMII SerDes link
+                0: MAC link = SGMII config link cfg_sgmii_link
+                */
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 2, 0)) != RT_ERR_OK)
+                    return retVal;
+
+            }
+            else if(mode == EXT_1000X)
+            {
+                /* 0 2 0  bit 8~9  set 0, force n-way*/
+                if((retVal = rtl8367c_getAsicSdsReg(0, 2, 0, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                reg_data &= 0xFFFFFCFF;
+                if((retVal = rtl8367c_setAsicSdsReg(0,2,0, reg_data)) != RT_ERR_OK)
+                        return retVal;
+
+                /* disable mac6 mode_ext1  mode*/
+                if ((retVal = rtl8367c_getAsicRegBit(0x1d3d, 10, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                if(reg_data == 0)
+                {
+                    if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, 0)) != RT_ERR_OK)
+                        return retVal;
+                }
+
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 1, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicReg(0x1d11, 0x1500)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit13: cfg_sds_mode_sel_new=1 :Enable new sds mode config method
+                  bit[1:0]:cfg_mac7_fib= 0  &  cfg_mac7_sel_sgmii=0
+                */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 3, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /* bit0 :UTP/Fiber auto detect function enable or not, cfg_dis_det=1:disable
+                   bit3:Force UTP/Fiber auto detect function enable or not, cfg_force_auto-detect=1 */
+                if ((retVal = rtl8367c_setAsicReg(0x13eb, 0x15bb)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit3:  Serdes force mode:cfg_sds_frc_mode=1
+                  bit[2:0]: Serdes chip mode, cfg_sds_mode=3b'100 (force sds FIB1G mode) */
+                if ((retVal = rtl8367c_setAsicReg(0x13e7, 0xc)) != RT_ERR_OK)
+                    return retVal;
+
+
+                /*bit5: cfg_mac6_fib=1 & bit7: cfg_mac6_fib2=1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 5, 1)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 7, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_hsgmii=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 11, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_sgmii= 1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 6, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /* bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                   new_cfg_sds_mode=0x4  */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x4)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if(mode == EXT_100FX)
+            {
+                /* 0 2 0  bit 8~9  set 0, force n-way*/
+                if((retVal = rtl8367c_getAsicSdsReg(0, 2, 0, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                reg_data &= 0xFFFFFCFF;
+                if((retVal = rtl8367c_setAsicSdsReg(0,2,0, reg_data)) != RT_ERR_OK)
+                        return retVal;
+
+                /* disable mac6 mode_ext1  mode*/
+                if ((retVal = rtl8367c_getAsicRegBit(0x1d3d, 10, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                if(reg_data == 0)
+                {
+                    if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, 0)) != RT_ERR_OK)
+                        return retVal;
+                }
+
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 1, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicReg(0x1d11, 0x1500)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit13: cfg_sds_mode_sel_new=1 :Enable new sds mode config method
+                  bit[1:0]:cfg_mac7_fib= 0  &  cfg_mac7_sel_sgmii=0
+                */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 3, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /* bit0 :UTP/Fiber auto detect function enable or not, cfg_dis_det=1:disable
+                   bit3:Force UTP/Fiber auto detect function enable or not, cfg_force_auto-detect=1 */
+                if ((retVal = rtl8367c_setAsicReg(0x13eb, 0x15bb)) != RT_ERR_OK)
+                    return retVal;
+
+                /*!!!!! cfg_sds_frc_mode=1 &  cfg_sds_mode=3b'101 (force sds fib100M mode)*/
+                if ((retVal = rtl8367c_setAsicReg(0x13e7, 0xc)) != RT_ERR_OK)
+                    return retVal;
+
+
+                /*bit5: cfg_mac6_fib=1 & bit7: cfg_mac6_fib2=1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 5, 1)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 7, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_hsgmii=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 11, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_sgmii= 1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 6, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*  bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                    new_cfg_sds_mode=0x5 */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x5)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if(mode == EXT_1000X_100FX)
+            {
+                /* 0 2 0  bit 8~9  set 0, force n-way*/
+                if((retVal = rtl8367c_getAsicSdsReg(0, 2, 0, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                reg_data &= 0xFFFFFCFF;
+                if((retVal = rtl8367c_setAsicSdsReg(0,2,0, reg_data)) != RT_ERR_OK)
+                        return retVal;
+
+                /* disable mac6 mode_ext1  mode*/
+                if ((retVal = rtl8367c_getAsicRegBit(0x1d3d, 10, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                if(reg_data == 0)
+                {
+                    if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, 0)) != RT_ERR_OK)
+                        return retVal;
+                }
+
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 1, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicReg(0x1d11, 0x1500)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit13: cfg_sds_mode_sel_new=1 :Enable new sds mode config method
+                  bit[1:0]:cfg_mac7_fib= 0  &  cfg_mac7_sel_sgmii=0
+                */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 0)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 3, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /* bit0 :UTP/Fiber auto detect function enable or not, cfg_dis_det=1:disable
+                   bit3:Force UTP/Fiber auto detect function enable or not, cfg_force_auto-detect=1 */
+                if ((retVal = rtl8367c_setAsicReg(0x13eb, 0x15bb)) != RT_ERR_OK)
+                    return retVal;
+
+                /*!!!!!! cfg_sds_frc_mode=1 &  cfg_sds_mode=3'b111: Fib1G/Fib100M auto detect */
+                if ((retVal = rtl8367c_setAsicReg(0x13e7, 0xc)) != RT_ERR_OK)
+                    return retVal;
+
+
+                /*bit5: cfg_mac6_fib=1 & bit7: cfg_mac6_fib2=1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 5, 1)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 7, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_hsgmii=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 11, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_sgmii= 1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 6, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*  bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                    new_cfg_sds_mode=0x7 */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x7)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if(mode < EXT_SGMII)
+            {
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d3d, 10, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 1, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /* keep default setting, disable mac6 sel SerDes mode,*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 11, 0)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 6, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit5: cfg_mac6_fib=0       &        bit7: cfg_mac6_fib2=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 5, 0)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 7, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if (mode < EXT_GMII)
+                {
+                    /* set mac6 mode*/
+                    if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, mode)) != RT_ERR_OK)
+                        return retVal;
+                }
+                else if(mode == EXT_RMII_MAC)
+                {
+                    /*!!!!!!*/
+                    if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, 7)) != RT_ERR_OK)
+                        return retVal;
+                }
+                else if(mode == EXT_RMII_PHY)
+                {
+                    if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, 8)) != RT_ERR_OK)
+                        return retVal;
+                }
+
+                if ((mode == EXT_TMII_MAC) || (mode == EXT_TMII_PHY))
+                {
+                    if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 1, 1)) != RT_ERR_OK)
+                        return retVal;
+                }
+            }
+
+        }
+        else if (2 == id)
+        {
+
+            /*force port7 linkdown*/
+            if ((retVal = rtl8367c_setAsicReg(0x137d, 0x1000)) != RT_ERR_OK)
+                    return retVal;
+
+            if ((retVal = rtl8367c_getAsicRegBit(0x1d9d, 7, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+            while(reg_data == 0)
+            {
+                if ((retVal = rtl8367c_getAsicRegBit(0x1d9d, 7, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+            }
+
+            if (mode == EXT_SGMII)
+            {
+                /*disable mac7 sel ext2 xMII mode*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13c3, 0xf,0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*restore ext2 ability*/
+                if ((retVal = rtl8367c_setAsicReg(0x13c4, 0)) != RT_ERR_OK)
+                    return retVal;
+                /*  disable mac7  mode_ext2  */
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 2, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit5: cfg_mac6_fib=0 & bit7: cfg_mac6_fib2=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 5, 0)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 7, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*
+                   bit0:cfg_mac7_sel_sgmii=0,MAC7 is not SGMII mode
+                   bit1:cfg_mac7_fib= 0  */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 3, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_hsgmii=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 11, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac6_sel_sgmii= 1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 6, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*Enable new sds mode config method, cfg_sds_mode_sel_new=1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*  bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                    new_cfg_sds_mode=0x1F (reset mode) */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac7_sel_sgmii= 1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 0, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*  bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                    new_cfg_sds_mode=0x2 (SGMII mode)*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x2)) != RT_ERR_OK)
+                    return retVal;
+
+                /*select MAC link source when port6/7 be set sgmii mode cfg_sgmii_link*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 2, 0)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if (mode == EXT_1000X)
+            {
+                /*  disable mac7 MII/TMM/RMII/GMII/RGMII mode, mode_ext2 = disable */
+                if ((retVal = rtl8367c_setAsicRegBits(0x13c3, 0xf, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*restore ext2 ability*/
+                if ((retVal = rtl8367c_setAsicReg(0x13c4, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /* 0 2 0  bit 8~9  set 0, force n-way*/
+                if((retVal = rtl8367c_getAsicSdsReg(0, 2, 0, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                reg_data &= 0xFFFFFCFF;
+                if((retVal = rtl8367c_setAsicSdsReg(0,2,0, reg_data)) != RT_ERR_OK)
+                        return retVal;
+
+                /*restore ext2 ability*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 2, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*  keep default setting, disable mac6 sel serdes*/
+                if ((retVal = rtl8367c_setAsicReg(0x1d11, 0x1500)) != RT_ERR_OK)
+                    return retVal;
+
+                /*Enable new sds mode config method, cfg_sds_mode_sel_new=1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*  bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                    new_cfg_sds_mode=0x1F (reset mode) */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit5: cfg_mac6_fib=0         &        bit7: cfg_mac6_fib2=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 5, 0)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 7, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac7_sel_sgmii= 1 & cfg_mac7_fib=1*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 3, 3)) != RT_ERR_OK)
+                    return retVal;
+
+                /*new_cfg_sds_mode=0x4 (FIB1000 mode)*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x4)) != RT_ERR_OK)
+                    return retVal;
+
+            }
+            else if (mode == EXT_100FX)
+            {
+                /*  disable mac7 MII/TMM/RMII/GMII/RGMII mode, mode_ext2 = disable  */
+                if ((retVal = rtl8367c_setAsicRegBits(0x13c3, 0xf, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*restore ext2 ability*/
+                if ((retVal = rtl8367c_setAsicReg(0x13c4, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /* 0 2 0  bit 8~9  set 0, force n-way*/
+                if((retVal = rtl8367c_getAsicSdsReg(0, 2, 0, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                reg_data &= 0xFFFFFCFF;
+                if((retVal = rtl8367c_setAsicSdsReg(0,2,0, reg_data)) != RT_ERR_OK)
+                        return retVal;
+
+                /*restore ext2 ability*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 2, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /* keep default setting, disable mac6 sel serdes*/
+                if ((retVal = rtl8367c_setAsicReg(0x1d11, 0x1500)) != RT_ERR_OK)
+                    return retVal;
+
+                /*Enable new sds mode config method, cfg_sds_mode_sel_new=1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*  bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                    new_cfg_sds_mode=0x1F (reset mode) */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit5: cfg_mac6_fib=0       &       bit7: cfg_mac6_fib2=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 5, 0)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 7, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac7_sel_sgmii= 1 & cfg_mac7_fib=1*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 3, 3)) != RT_ERR_OK)
+                    return retVal;
+
+                /*  bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                    new_cfg_sds_mode=0x5  */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x5)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if (mode == EXT_1000X_100FX)
+            {
+                /*  disable mac7 MII/TMM/RMII/GMII/RGMII mode, mode_ext2 = disable  */
+                if ((retVal = rtl8367c_setAsicRegBits(0x13c3, 0xf, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*restore ext2 ability*/
+                if ((retVal = rtl8367c_setAsicReg(0x13c4, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /* 0 2 0  bit 8~9  set 0, force n-way*/
+                if((retVal = rtl8367c_getAsicSdsReg(0, 2, 0, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                reg_data &= 0xFFFFFCFF;
+                if((retVal = rtl8367c_setAsicSdsReg(0,2,0, reg_data)) != RT_ERR_OK)
+                        return retVal;
+
+                /*restore ext2 ability*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 2, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /* keep default setting, disable mac6 sel serdes*/
+                if ((retVal = rtl8367c_setAsicReg(0x1d11, 0x1500)) != RT_ERR_OK)
+                    return retVal;
+
+                /*Enable new sds mode config method, cfg_sds_mode_sel_new=1*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d95, 13, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                /*  bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                    new_cfg_sds_mode=0x1F (reset mode) */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x1f)) != RT_ERR_OK)
+                    return retVal;
+
+                /*bit5: cfg_mac6_fib=0    &    bit7: cfg_mac6_fib2=0*/
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 5, 0)) != RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d41, 7, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac7_sel_sgmii= 1 & cfg_mac7_fib=1*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 3, 3)) != RT_ERR_OK)
+                    return retVal;
+
+                /*  bit[12:8]: Only valid when cfg_sds_mode_sel_new=1
+                    new_cfg_sds_mode=0x7  */
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 0x1f00, 0x7)) != RT_ERR_OK)
+                    return retVal;
+            }
+            else if (mode < EXT_SGMII)
+            {
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d3d, 10, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 2, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /* keep default setting, disable mac7 sel SerDes mode*/
+                if ((retVal = rtl8367c_setAsicReg(0x1d95, 0x1f00)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac7_sel_sgmii= 0 & cfg_mac7_fib=0*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 3, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /* set port7 mode*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x13c3, 0xf, mode)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((mode == EXT_TMII_MAC) || (mode == EXT_TMII_PHY))
+                {
+                    if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 2, 1)) != RT_ERR_OK)
+                        return retVal;
+                }
+
+            }
+            else if ((mode < EXT_END) && (mode > EXT_100FX))
+            {
+                if ((retVal = rtl8367c_setAsicRegBits(0x13C3, 0xf, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 2, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                /*cfg_mac7_sel_sgmii= 0 & cfg_mac7_fib=0*/
+                if ((retVal = rtl8367c_setAsicRegBits(0x1d95, 3, 0)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_setAsicRegBit(0x1d3d, 10, 1)) != RT_ERR_OK)
+                    return retVal;
+
+                if ((retVal = rtl8367c_getAsicRegBit(0x1d11, 11, &reg_data)) != RT_ERR_OK)
+                    return retVal;
+                if(reg_data == 0)
+                {
+                    if ((retVal = rtl8367c_setAsicRegBit(0x1d11, 6, 1)) != RT_ERR_OK)
+                        return retVal;
+                }
+
+                /* set port7 mode*/
+                if (mode < EXT_RMII_MAC_2)
+                {
+                    if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, (mode-13))) != RT_ERR_OK)
+                        return retVal;
+                }
+                else
+                {
+                    if ((retVal = rtl8367c_setAsicRegBits(0x1305, 0xf0, (mode-12))) != RT_ERR_OK)
+                        return retVal;
+                }
+
+                if ((mode == EXT_TMII_MAC_2) || (mode == EXT_TMII_PHY_2))
+                {
+                    if ((retVal = rtl8367c_setAsicRegBit(0x3f7, 2, 1)) != RT_ERR_OK)
+                        return retVal;
+                }
+            }
+
+        }
+
+    }
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortExtMode
+ * Description:
+ *      Get external interface mode configuration
+ * Input:
+ *      id      - external interface id (0~1)
+ *      pMode   - external interface mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortExtMode(rtk_uint32 id, rtk_uint32 *pMode)
+{
+    ret_t   retVal;
+    rtk_uint32 regData, regValue, type;
+
+    if(id >= RTL8367C_EXTNO)
+        return RT_ERR_OUT_OF_RANGE;
+    /*cfg_magic_id  &  get chip_id*/
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regValue)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    type = 0;
+
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            type = 1;
+            break;
+        case 0x0652:
+        case 0x6368:
+            type = 2;
+            break;
+        case 0x0801:
+        case 0x6511:
+            type = 3;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+
+
+    if (1 == type)
+    {
+
+        if (1 == id)
+        {
+            if( (retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_SGMII_OFFSET, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            if(1 == regData)
+            {
+                *pMode = EXT_SGMII;
+                return RT_ERR_OK;
+            }
+
+            if( (retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SDS_MISC, RTL8367C_CFG_MAC8_SEL_HSGMII_OFFSET, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            if(1 == regData)
+            {
+                *pMode = EXT_HSGMII;
+                return RT_ERR_OK;
+            }
+        }
+
+        if(0 == id || 1 == id)
+            return rtl8367c_getAsicRegBits(RTL8367C_REG_DIGITAL_INTERFACE_SELECT, RTL8367C_SELECT_GMII_0_MASK << (id * RTL8367C_SELECT_GMII_1_OFFSET), pMode);
+        else
+           return rtl8367c_getAsicRegBits(RTL8367C_REG_DIGITAL_INTERFACE_SELECT_1, RTL8367C_SELECT_GMII_2_MASK, pMode);
+
+    }
+    else if (2 == type)
+    {
+        if (1 == id)
+        {
+            if ((retVal = rtl8367c_getAsicReg(0x1d92, &regData))!=RT_ERR_OK)
+                return retVal;
+
+            if (regData & 0x4000)
+            {
+                *pMode = EXT_SGMII;
+                return RT_ERR_OK;
+            }
+
+            else if (((regData >> 8) & 0x1f) == 4)
+            {
+                *pMode = EXT_1000X;
+                return RT_ERR_OK;
+            }
+            else if (((regData >> 8) & 0x1f) == 5)
+            {
+                *pMode = EXT_100FX;
+                return RT_ERR_OK;
+            }
+            else if (((regData >> 8) & 0x1f) == 7)
+            {
+                *pMode = EXT_1000X_100FX;
+                return RT_ERR_OK;
+            }
+
+            return rtl8367c_getAsicRegBits(0x1305, 0xf0, pMode);
+        }
+        else if (2 == id)
+        {
+#if 0
+            if ((retVal = rtl8367c_getAsicRegBit(0x1d92, 6, &regData))!=RT_ERR_OK)
+                return retVal;
+
+            if (regData == 1)
+            {
+                *pMode = EXT_SGMII;
+                return RT_ERR_OK;
+            }
+
+            if ((retVal = rtl8367c_getAsicRegBit(0x1d92, 7, &regData))!=RT_ERR_OK)
+                return retVal;
+
+            if (regData == 1)
+            {
+                *pMode = EXT_HSGMII;
+                return RT_ERR_OK;
+            }
+#endif
+            if ((retVal = rtl8367c_getAsicReg(0x1d92, &regData))!=RT_ERR_OK)
+                return retVal;
+
+            if (regData & 0x40)
+            {
+                *pMode = EXT_SGMII;
+                return RT_ERR_OK;
+            }
+            else if (regData & 0x80)
+            {
+                *pMode = EXT_HSGMII;
+                return RT_ERR_OK;
+            }
+            else if ((regData & 0x1f) == 4)
+            {
+                *pMode = EXT_1000X;
+                return RT_ERR_OK;
+            }
+            else if ((regData & 0x1f) == 5)
+            {
+                *pMode = EXT_100FX;
+                return RT_ERR_OK;
+            }
+            else if ((regData & 0x1f) == 7)
+            {
+                *pMode = EXT_1000X_100FX;
+                return RT_ERR_OK;
+            }
+
+            return rtl8367c_getAsicRegBits(0x1305, 0xf, pMode);
+        }
+    }
+    else if(3 == type)
+    {
+        if (1 == id)
+        {
+            /* SDS_CFG_NEW */
+            if ((retVal = rtl8367c_getAsicReg(0x1d95, &regData))!=RT_ERR_OK)
+                return retVal;
+
+            if ((retVal = rtl8367c_getAsicReg(0x1d41, &regValue))!=RT_ERR_OK)
+                return retVal;
+
+            /* bit5: cfg_mac6_fib=1  &&  bit7: cfg_mac6_fib2 =1 */
+            if((regValue & 0xa0)  == 0xa0 )
+            {
+                /* new_cfg_sds_mode */
+                regData = regData >> 8;
+                if((regData & 0x1f) == 4)
+                {
+                    *pMode = EXT_1000X;
+                     return RT_ERR_OK;
+                }
+                else if((regData & 0x1f) == 5)
+                {
+                    *pMode = EXT_100FX;
+                     return RT_ERR_OK;
+                }
+                else if((regData & 0x1f) == 7)
+                {
+                    *pMode = EXT_1000X_100FX;
+                     return RT_ERR_OK;
+                }
+
+            }
+
+
+            if ((retVal = rtl8367c_getAsicReg(0x1d11, &regData))!=RT_ERR_OK)
+                return retVal;
+
+            /* check cfg_mac6_sel_sgmii */
+            if((regData >> 6) & 1)
+            {
+                *pMode = EXT_SGMII;
+                return RT_ERR_OK;
+            }
+            else if((regData >> 11) & 1)
+            {
+                *pMode = EXT_HSGMII;
+                return RT_ERR_OK;
+            }
+            else
+            {
+                /* check port6 MAC mode */
+                if ((retVal = rtl8367c_getAsicRegBits(0x1305, 0xf0, &regData))!=RT_ERR_OK)
+                    return retVal;
+
+                if(regData < 6)
+                    *pMode = regData;
+                else if(regData == 6)
+                    *pMode = EXT_RMII_MAC;
+                else if(regData == 7)
+                    *pMode = EXT_RMII_PHY;
+
+                return RT_ERR_OK;
+            }
+        }
+        else if (2 == id)
+        {
+            if ((retVal = rtl8367c_getAsicReg(0x1d95, &regData))!=RT_ERR_OK)
+                return retVal;
+
+            /* bit0: cfg_mac7_sel_sgmii
+               bit1: cfg_mac7_fib
+               bit[12:8]: new_cfg_sds_mode*/
+            if(((regData & 0x3) == 3) && (((regData >> 8) & 0x1f) == 0x4))
+            {
+                *pMode = EXT_1000X;
+                    return RT_ERR_OK;
+            }
+            else if (((regData & 0x3) == 3) && (((regData >> 8) & 0x1f) == 0x5))
+            {
+                *pMode = EXT_100FX;
+                    return RT_ERR_OK;
+            }
+            else if (((regData & 0x3) == 3) && (((regData >> 8) & 0x1f) == 0x7))
+            {
+                *pMode = EXT_1000X_100FX;
+                    return RT_ERR_OK;
+            }
+            else if(regData & 1)
+            {
+                *pMode = EXT_SGMII;
+                return RT_ERR_OK;
+            }
+            else
+            {
+            /* check port7 MAC mode */
+                if ((retVal = rtl8367c_getAsicRegBits(0x13c3, 0xf, &regData))!=RT_ERR_OK)
+                    return retVal;
+
+                *pMode = regData;
+
+                return RT_ERR_OK;
+            }
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8370_setAsicPortEnableAll
+ * Description:
+ *      Set ALL ports enable.
+ * Input:
+ *      enable - enable all ports.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortEnableAll(rtk_uint32 enable)
+{
+    if(enable >= 2)
+        return RT_ERR_INPUT;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_PHY_AD, RTL8367C_PDNPHY_OFFSET, !enable);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicPortEnableAll
+ * Description:
+ *      Set ALL ports enable.
+ * Input:
+ *      enable - enable all ports.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortEnableAll(rtk_uint32 *pEnable)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_PHY_AD, RTL8367C_PDNPHY_OFFSET, &regData);
+    if(retVal !=  RT_ERR_OK)
+        return retVal;
+
+    if (regData==0)
+        *pEnable = 1;
+    else
+        *pEnable = 0;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortSmallIpg
+ * Description:
+ *      Set small ipg egress mode
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      enable  - 0: normal, 1: small
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortSmallIpg(rtk_uint32 port, rtk_uint32 enable)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_PORT_SMALL_IPG_REG(port), RTL8367C_PORT0_MISC_CFG_SMALL_TAG_IPG_OFFSET, enable);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicPortSmallIpg
+ * Description:
+ *      Get small ipg egress mode
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pEnable     - 0: normal, 1: small
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortSmallIpg(rtk_uint32 port, rtk_uint32* pEnable)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_PORT_SMALL_IPG_REG(port), RTL8367C_PORT0_MISC_CFG_SMALL_TAG_IPG_OFFSET, pEnable);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortLoopback
+ * Description:
+ *      Set MAC loopback
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      enable  - 0: Disable, 1: enable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortLoopback(rtk_uint32 port, rtk_uint32 enable)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_PORT0_MISC_CFG_MAC_LOOPBACK_OFFSET, enable);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicPortLoopback
+ * Description:
+ *      Set MAC loopback
+ * Input:
+ *      port    - Physical port number (0~7)
+ * Output:
+ *      pEnable - 0: Disable, 1: enable
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortLoopback(rtk_uint32 port, rtk_uint32 *pEnable)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_PORT0_MISC_CFG_MAC_LOOPBACK_OFFSET, pEnable);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortRTCTEnable
+ * Description:
+ *      Set RTCT Enable echo response mode
+ * Input:
+ *      portmask    - Port mask of RTCT enabled (0-4)
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid port mask
+ * Note:
+ *      RTCT test takes 4.8 seconds at most.
+ */
+ret_t rtl8367c_setAsicPortRTCTEnable(rtk_uint32 portmask)
+{
+    ret_t       retVal;
+    rtk_uint32  regData;
+    rtk_uint32  port;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if( (regData == 0x0276) || (regData == 0x0597) )
+        return RT_ERR_CHIP_NOT_SUPPORTED;
+
+    for(port = 0; port <= 10 ; port++)
+    {
+        if(portmask & (0x0001 << port))
+        {
+             if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa422, &regData)) != RT_ERR_OK)
+                 return retVal;
+
+             regData &= 0x7FFF;
+             if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
+                 return retVal;
+
+             regData |= 0x00F2;/*RTCT set to  echo response mode*/
+             if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
+                 return retVal;
+
+             regData |= 0x0001;
+             if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
+                 return retVal;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortRTCTDisable
+ * Description:
+ *      Set RTCT Disable
+ * Input:
+ *      portmask    - Port mask of RTCT enabled (0-4)
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid port mask
+ * Note:
+ *      RTCT test takes 4.8 seconds at most.
+ */
+ret_t rtl8367c_setAsicPortRTCTDisable(rtk_uint32 portmask)
+{
+    ret_t       retVal;
+    rtk_uint32  regData;
+    rtk_uint32  port;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if( (regData == 0x0276) || (regData == 0x0597) )
+        return RT_ERR_CHIP_NOT_SUPPORTED;
+
+    for(port = 0; port <= 10 ; port++)
+    {
+        if(portmask & (0x0001 << port))
+        {
+             if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa422, &regData)) != RT_ERR_OK)
+                 return retVal;
+
+             regData &= 0x7FFF;
+             if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
+                 return retVal;
+
+             regData |= 0x00F0;
+             if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
+                 return retVal;
+
+             regData &= ~0x0001;
+             if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa422, regData)) != RT_ERR_OK)
+                 return retVal;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtl8367c_getAsicPortRTCTResult
+ * Description:
+ *      Get RTCT result
+ * Input:
+ *      port    - Port ID of RTCT result
+ * Output:
+ *      pResult - The result of port ID
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_MASK            - Invalid port mask
+ *      RT_ERR_PHY_RTCT_NOT_FINISH  - RTCT test doesn't finish.
+ * Note:
+ *      RTCT test takes 4.8 seconds at most.
+ *      If this API returns RT_ERR_PHY_RTCT_NOT_FINISH,
+ *      users should wait a whole then read it again.
+ */
+ret_t rtl8367c_getAsicPortRTCTResult(rtk_uint32 port, rtl8367c_port_rtct_result_t *pResult)
+{
+    ret_t       retVal;
+    rtk_uint32  regData, finish = 1;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    if( (regData == 0x6367) )
+    {
+        if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa422, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        if((regData & 0x8000) == 0x8000)
+        {
+            /* Channel A */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x802a)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelAOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelAShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelAMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelALinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel B */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x802e)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelBOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelBShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelBMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelBLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel C */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8032)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelCOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelCShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelCMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelCLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel D */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8036)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelDOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelDShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelDMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelDLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel A Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x802c)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelALen = (regData / 2);
+
+            /* Channel B Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8030)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelBLen = (regData / 2);
+
+            /* Channel C Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8034)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelCLen = (regData / 2);
+
+            /* Channel D Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8038)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelDLen = (regData / 2);
+        }
+        else
+            finish = 0;
+    }
+    else if(regData == 0x6368)
+    {
+        if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa422, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        if((regData & 0x8000) == 0x8000)
+        {
+            /* Channel A */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x802b)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelAOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelAShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelAMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelALinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel B */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x802f)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelBOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelBShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelBMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelBLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel C */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8033)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelCOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelCShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelCMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelCLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel D */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8037)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelDOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelDShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelDMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelDLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel A Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x802d)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelALen = (regData / 2);
+
+            /* Channel B Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8031)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelBLen = (regData / 2);
+
+            /* Channel C Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8035)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelCLen = (regData / 2);
+
+            /* Channel D Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8039)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelDLen = (regData / 2);
+        }
+        else
+            finish = 0;
+
+    }
+    else if((regData == 0x6511) || (regData == 0x0801))
+    {
+        if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa422, &regData)) != RT_ERR_OK)
+            return retVal;
+
+        if((regData & 0x8000) == 0x8000)
+        {
+            /* Channel A */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x802a)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelAOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelAShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelAMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelALinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel B */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x802e)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelBOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelBShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelBMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelBLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel C */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8032)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelCOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelCShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelCMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelCLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel D */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8036)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelDOpen       = (regData == 0x0048) ? 1 : 0;
+            pResult->channelDShort      = (regData == 0x0050) ? 1 : 0;
+            pResult->channelDMismatch   = ((regData == 0x0042) || (regData == 0x0044)) ? 1 : 0;
+            pResult->channelDLinedriver = (regData == 0x0041) ? 1 : 0;
+
+            /* Channel A Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x802c)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelALen = (regData / 2);
+
+            /* Channel B Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8030)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelBLen = (regData / 2);
+
+            /* Channel C Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8034)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelCLen = (regData / 2);
+
+            /* Channel D Length */
+            if((retVal = rtl8367c_setAsicPHYOCPReg(port, 0xa436, 0x8038)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_getAsicPHYOCPReg(port, 0xa438, &regData)) != RT_ERR_OK)
+                return retVal;
+
+            pResult->channelDLen = (regData / 2);
+        }
+        else
+            finish = 0;
+
+    }
+    else
+        return RT_ERR_CHIP_NOT_SUPPORTED;
+
+    if(finish == 0)
+        return RT_ERR_PHY_RTCT_NOT_FINISH;
+    else
+        return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_sdsReset
+ * Description:
+ *      Reset Serdes
+ * Input:
+ *      id  - EXT ID
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ * Note:
+ *      None.
+ */
+ret_t rtl8367c_sdsReset(rtk_uint32 id)
+{
+    rtk_uint32 retVal, regValue, state, i, option, running = 0, retVal2;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regValue)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            option = 0;
+            break;
+        case 0x0652:
+        case 0x6368:
+            option = 1;
+            break;
+        case 0x0801:
+        case 0x6511:
+            option = 2;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+
+    if(option == 0)
+    {
+        if (1 == id)
+        {
+            if ((retVal = rtl8367c_getAsicRegBit(0x130c, 5, &running))!=RT_ERR_OK)
+                return retVal;
+
+            if(running == 1)
+            {
+                if ((retVal = rtl8367c_setAsicRegBit(0x130c, 5, 0))!=RT_ERR_OK)
+                    return retVal;
+            }
+
+            retVal = rtl8367c_setAsicReg(0x6601, 0x0000);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_setAsicReg(0x6602, 0x1401);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_setAsicReg(0x6600, 0x00C0);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_setAsicReg(0x6601, 0x0000);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_setAsicReg(0x6602, 0x1403);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_setAsicReg(0x6600, 0x00C0);
+
+            if(running == 1)
+            {
+                if ((retVal2 = rtl8367c_setAsicRegBit(0x130c, 5, 1))!=RT_ERR_OK)
+                    return retVal2;
+            }
+
+            if(retVal != RT_ERR_OK)
+                return retVal;
+        }
+        else
+            return RT_ERR_PORT_ID;
+    }
+    else if(option == 1)
+    {
+        if (1 == id)
+        {
+            if((retVal = rtl8367c_getAsicReg(0x1311, &state)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicReg(0x1311, 0x66)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicReg(0x1311, 0x1066)) != RT_ERR_OK)
+                return retVal;
+
+            while(1)
+            {
+                if((retVal = rtl8367c_getAsicReg(0x1d9d, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                if((regValue >> 8) & 1)
+                    break;
+            }
+
+            for (i=0; i<0xffff; i++);
+
+            if((retVal = rtl8367c_setAsicReg(0x133d, 0x2)) != RT_ERR_OK)
+                return retVal;
+
+            for (i=0; i<0xffff; i++);
+
+            if((retVal = rtl8367c_setAsicReg(0x6601, 0x0)) != RT_ERR_OK)
+                return retVal;
+            if((retVal = rtl8367c_setAsicReg(0x6602, 0x1401)) != RT_ERR_OK)
+                return retVal;
+            if((retVal = rtl8367c_setAsicReg(0x6600, 0xc1)) != RT_ERR_OK)
+                return retVal;
+            if((retVal = rtl8367c_setAsicReg(0x6601, 0x0)) != RT_ERR_OK)
+                return retVal;
+            if((retVal = rtl8367c_setAsicReg(0x6602, 0x1403)) != RT_ERR_OK)
+                return retVal;
+            if((retVal = rtl8367c_setAsicReg(0x6600, 0xc1)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicReg(0x133d, 0x0)) != RT_ERR_OK)
+                return retVal;
+
+            for (i=0; i<0xffff; i++);
+
+            if((retVal = rtl8367c_setAsicReg(0x1311, state)) != RT_ERR_OK)
+                return retVal;
+
+
+        }
+        else if (2== id)
+        {
+            if((retVal = rtl8367c_getAsicReg(0x13c4, &state)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicReg(0x13c4, 0x66)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicReg(0x13c4, 0x1066)) != RT_ERR_OK)
+                return retVal;
+
+            while(1)
+            {
+                if((retVal = rtl8367c_getAsicReg(0x1d9d, &regValue)) != RT_ERR_OK)
+                    return retVal;
+                if((regValue >> 9) & 1)
+                    break;
+            }
+
+            for (i=0; i<0xffff; i++);
+
+            if((retVal = rtl8367c_setAsicReg(0x133d, 0x2)) != RT_ERR_OK)
+                return retVal;
+
+            for (i=0; i<0xffff; i++);
+
+            if((retVal = rtl8367c_setAsicReg(0x6601, 0x0)) != RT_ERR_OK)
+                return retVal;
+            if((retVal = rtl8367c_setAsicReg(0x6602, 0x1401)) != RT_ERR_OK)
+                return retVal;
+            if((retVal = rtl8367c_setAsicReg(0x6600, 0xc0)) != RT_ERR_OK)
+                return retVal;
+            if((retVal = rtl8367c_setAsicReg(0x6601, 0x0)) != RT_ERR_OK)
+                return retVal;
+            if((retVal = rtl8367c_setAsicReg(0x6602, 0x1403)) != RT_ERR_OK)
+                return retVal;
+            if((retVal = rtl8367c_setAsicReg(0x6600, 0xc0)) != RT_ERR_OK)
+                return retVal;
+
+            if((retVal = rtl8367c_setAsicReg(0x133d, 0x0)) != RT_ERR_OK)
+                return retVal;
+
+            for (i=0; i<0xffff; i++);
+
+            if((retVal = rtl8367c_setAsicReg(0x13c4, state)) != RT_ERR_OK)
+                return retVal;
+        }
+        else
+            return RT_ERR_PORT_ID;
+    }
+    else if(option == 2)
+    {
+        if ((retVal = rtl8367c_getAsicSdsReg(0, 3, 0, &regValue))!=RT_ERR_OK)
+                  return retVal;
+              regValue |= 0x40;
+              if ((retVal = rtl8367c_setAsicSdsReg(0, 3, 0, regValue))!=RT_ERR_OK)
+                  return retVal;
+
+              for (i=0; i<0xffff; i++);
+
+              regValue &= ~(0x40);
+              if ((retVal = rtl8367c_setAsicSdsReg(0, 3, 0, regValue))!=RT_ERR_OK)
+                  return retVal;
+
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getSdsLinkStatus
+ * Description:
+ *      Get SGMII status
+ * Input:
+ *      id  - EXT ID
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ * Note:
+ *      None.
+ */
+ret_t rtl8367c_getSdsLinkStatus(rtk_uint32 ext_id, rtk_uint32 *pSignalDetect, rtk_uint32 *pSync, rtk_uint32 *pLink)
+{
+    rtk_uint32 retVal, regValue, type, running = 0, retVal2;
+
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regValue)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            type = 0;
+            break;
+        case 0x0652:
+        case 0x6368:
+            type = 1;
+            break;
+        case 0x0801:
+        case 0x6511:
+            type = 2;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+
+    if(type == 0)
+    {
+        if (1 == ext_id)
+        {
+            if ((retVal = rtl8367c_getAsicRegBit(0x130c, 5, &running))!=RT_ERR_OK)
+                return retVal;
+
+            if(running == 1)
+            {
+                if ((retVal = rtl8367c_setAsicRegBit(0x130c, 5, 0))!=RT_ERR_OK)
+                    return retVal;
+            }
+
+            retVal = rtl8367c_setAsicReg(0x6601, 0x003D);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_setAsicReg(0x6600, 0x0080);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_getAsicReg(0x6602, &regValue);
+
+            if(running == 1)
+            {
+                if ((retVal2 = rtl8367c_setAsicRegBit(0x130c, 5, 1))!=RT_ERR_OK)
+                    return retVal2;
+            }
+
+            if(retVal != RT_ERR_OK)
+                return retVal;
+
+            *pSignalDetect = (regValue & 0x0100) ? 1 : 0;
+            *pSync = (regValue & 0x0001) ? 1 : 0;
+            *pLink = (regValue & 0x0010) ? 1 : 0;
+        }
+        else
+            return RT_ERR_PORT_ID;
+    }
+    else if(type == 1)
+    {
+        if (1 == ext_id)
+        {
+            if ((retVal = rtl8367c_setAsicReg(0x6601, 0x003D))!=RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367c_setAsicReg(0x6600, 0x0081))!=RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367c_getAsicReg(0x6602, &regValue))!=RT_ERR_OK)
+                return retVal;
+
+            *pSignalDetect = (regValue & 0x0100) ? 1 : 0;
+            *pSync = (regValue & 0x0001) ? 1 : 0;
+            *pLink = (regValue & 0x0010) ? 1 : 0;
+        }
+        else if (2 == ext_id)
+        {
+            if ((retVal = rtl8367c_setAsicReg(0x6601, 0x003D))!=RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367c_setAsicReg(0x6600, 0x0080))!=RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367c_getAsicReg(0x6602, &regValue))!=RT_ERR_OK)
+                return retVal;
+
+            *pSignalDetect = (regValue & 0x0100) ? 1 : 0;
+            *pSync = (regValue & 0x0001) ? 1 : 0;
+            *pLink = (regValue & 0x0010) ? 1 : 0;
+        }
+        else
+            return RT_ERR_PORT_ID;
+    }
+    else if(type == 2)
+    {
+        if((retVal = rtl8367c_getAsicSdsReg(0, 30, 1, &regValue)) != RT_ERR_OK)
+            return retVal;
+        if((retVal = rtl8367c_getAsicSdsReg(0, 30, 1, &regValue)) != RT_ERR_OK)
+            return retVal;
+
+        *pSignalDetect = (regValue & 0x0100) ? 1 : 0;
+        *pSync = (regValue & 0x0001) ? 1 : 0;
+        *pLink = (regValue & 0x0010) ? 1 : 0;
+
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setSgmiiNway
+ * Description:
+ *      Set SGMII Nway
+ * Input:
+ *      ext_id      - EXT ID
+ *      state       - SGMII Nway state
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ * Note:
+ *      None.
+ */
+ret_t rtl8367c_setSgmiiNway(rtk_uint32 ext_id, rtk_uint32 state)
+{
+    rtk_uint32 retVal, regValue, type, running = 0, retVal2;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regValue)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            type = 0;
+            break;
+        case 0x0652:
+        case 0x6368:
+            type = 1;
+            break;
+        case 0x0801:
+        case 0x6511:
+            type = 2;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+
+    if(type == 0)
+    {
+        if (1 == ext_id)
+        {
+            if ((retVal = rtl8367c_getAsicRegBit(0x130c, 5, &running))!=RT_ERR_OK)
+                return retVal;
+
+            if(running == 1)
+            {
+                if ((retVal = rtl8367c_setAsicRegBit(0x130c, 5, 0))!=RT_ERR_OK)
+                    return retVal;
+            }
+
+            retVal = rtl8367c_setAsicReg(0x6601, 0x0002);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_setAsicReg(0x6600, 0x0080);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_getAsicReg(0x6602, &regValue);
+
+            if(retVal == RT_ERR_OK)
+            {
+                if(state)
+                      regValue |= 0x0200;
+                else
+                      regValue &= ~0x0200;
+
+                regValue |= 0x0100;
+            }
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_setAsicReg(0x6602, regValue);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_setAsicReg(0x6601, 0x0002);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_setAsicReg(0x6600, 0x00C0);
+
+            if(running == 1)
+            {
+                if ((retVal2 = rtl8367c_setAsicRegBit(0x130c, 5, 1))!=RT_ERR_OK)
+                    return retVal2;
+            }
+
+            if(retVal != RT_ERR_OK)
+                return retVal;
+        }
+        else
+            return RT_ERR_PORT_ID;
+    }
+    else if(type == 1)
+    {
+        if (1 == ext_id)
+        {
+            if ((retVal = rtl8367c_setAsicReg(0x6601, 0x0002))!=RT_ERR_OK)
+                   return retVal;
+            if ((retVal = rtl8367c_setAsicReg(0x6600, 0x0081))!=RT_ERR_OK)
+                   return retVal;
+            if ((retVal = rtl8367c_getAsicReg(0x6602, &regValue))!=RT_ERR_OK)
+                   return retVal;
+
+            if(state)
+                  regValue |= 0x0200;
+            else
+                  regValue &= ~0x0200;
+
+            regValue |= 0x0100;
+
+            if ((retVal = rtl8367c_setAsicReg(0x6602, regValue))!=RT_ERR_OK)
+                   return retVal;
+            if ((retVal = rtl8367c_setAsicReg(0x6601, 0x0002))!=RT_ERR_OK)
+                   return retVal;
+            if ((retVal = rtl8367c_setAsicReg(0x6600, 0x00C1))!=RT_ERR_OK)
+                   return retVal;
+        }
+        else if (2 == ext_id)
+        {
+            if ((retVal = rtl8367c_setAsicReg(0x6601, 0x0002))!=RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367c_setAsicReg(0x6600, 0x0080))!=RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367c_getAsicReg(0x6602, &regValue))!=RT_ERR_OK)
+                return retVal;
+
+            if(state)
+                regValue |= 0x0200;
+            else
+                regValue &= ~0x0200;
+
+            regValue |= 0x0100;
+
+            if ((retVal = rtl8367c_setAsicReg(0x6602, regValue))!=RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367c_setAsicReg(0x6601, 0x0002))!=RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367c_setAsicReg(0x6600, 0x00C0))!=RT_ERR_OK)
+                return retVal;
+        }
+        else
+            return RT_ERR_PORT_ID;
+    }
+    else if(type == 2)
+    {
+        if ((retVal = rtl8367c_getAsicSdsReg(0, 2, 0, &regValue))!=RT_ERR_OK)
+            return retVal;
+
+        if(state & 1)
+            regValue &= ~0x100;
+        else
+            regValue |= 0x100;
+
+        if ((retVal = rtl8367c_setAsicSdsReg(0, 2, 0, regValue))!=RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getSgmiiNway
+ * Description:
+ *      Get SGMII Nway
+ * Input:
+ *      ext_id      - EXT ID
+ *      state       - SGMII Nway state
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ * Note:
+ *      None.
+ */
+ret_t rtl8367c_getSgmiiNway(rtk_uint32 ext_id, rtk_uint32 *pState)
+{
+    rtk_uint32 retVal, regValue, type, running = 0, retVal2;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regValue)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            type = 0;
+            break;
+        case 0x0652:
+        case 0x6368:
+            type = 1;
+            break;
+        case 0x0801:
+        case 0x6511:
+            type = 2;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+
+    if(type == 0)
+    {
+        if (1 == ext_id)
+        {
+            if ((retVal = rtl8367c_getAsicRegBit(0x130c, 5, &running))!=RT_ERR_OK)
+                return retVal;
+
+            if(running == 1)
+            {
+                if ((retVal = rtl8367c_setAsicRegBit(0x130c, 5, 0))!=RT_ERR_OK)
+                    return retVal;
+            }
+
+            retVal = rtl8367c_setAsicReg(0x6601, 0x0002);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_setAsicReg(0x6600, 0x0080);
+
+            if(retVal == RT_ERR_OK)
+                retVal = rtl8367c_getAsicReg(0x6602, &regValue);
+
+            if(running == 1)
+            {
+                if ((retVal2 = rtl8367c_setAsicRegBit(0x130c, 5, 1))!=RT_ERR_OK)
+                    return retVal2;
+            }
+
+            if(retVal != RT_ERR_OK)
+                return retVal;
+
+            if(regValue & 0x0200)
+                *pState = 1;
+            else
+                *pState = 0;
+        }
+        else
+            return RT_ERR_PORT_ID;
+    }
+    else if(type == 1)
+    {
+        if (1 == ext_id)
+        {
+                if ((retVal = rtl8367c_setAsicReg(0x6601, 0x0002))!=RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_setAsicReg(0x6600, 0x0081))!=RT_ERR_OK)
+                    return retVal;
+                if ((retVal = rtl8367c_getAsicReg(0x6602, &regValue))!=RT_ERR_OK)
+                    return retVal;
+
+                if(regValue & 0x0200)
+                    *pState = 1;
+                else
+                    *pState = 0;
+        }
+        else if (2 == ext_id)
+        {
+            if ((retVal = rtl8367c_setAsicReg(0x6601, 0x0002))!=RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367c_setAsicReg(0x6600, 0x0080))!=RT_ERR_OK)
+                return retVal;
+            if ((retVal = rtl8367c_getAsicReg(0x6602, &regValue))!=RT_ERR_OK)
+                return retVal;
+
+            if(regValue & 0x0200)
+                *pState = 1;
+            else
+                *pState = 0;
+        }
+        else
+            return RT_ERR_PORT_ID;
+    }
+    else if(type == 2)
+    {
+        if ((retVal = rtl8367c_getAsicSdsReg(0, 2, 0, &regValue))!=RT_ERR_OK)
+            return retVal;
+
+        if(regValue & 0x100)
+            *pState = 0;
+        else
+            *pState = 1;
+    }
+
+    return RT_ERR_OK;
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_portIsolation.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_portIsolation.c
new file mode 100644
index 0000000000000..e0b9db4bfbebd
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_portIsolation.c
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Port isolation related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_portIsolation.h>
+/* Function Name:
+ *      rtl8367c_setAsicPortIsolationPermittedPortmask
+ * Description:
+ *      Set permitted port isolation portmask
+ * Input:
+ *      port            - Physical port number (0~10)
+ *      permitPortmask  - port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_PORT_MASK    - Invalid portmask
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortIsolationPermittedPortmask(rtk_uint32 port, rtk_uint32 permitPortmask)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if( permitPortmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    return rtl8367c_setAsicReg(RTL8367C_PORT_ISOLATION_PORT_MASK_REG(port), permitPortmask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortIsolationPermittedPortmask
+ * Description:
+ *      Get permitted port isolation portmask
+ * Input:
+ *      port                - Physical port number (0~10)
+ *      pPermitPortmask     - port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortIsolationPermittedPortmask(rtk_uint32 port, rtk_uint32 *pPermitPortmask)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicReg(RTL8367C_PORT_ISOLATION_PORT_MASK_REG(port), pPermitPortmask);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortIsolationEfid
+ * Description:
+ *      Set port isolation EFID
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      efid    - EFID (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_OUT_OF_RANGE - Input parameter out of range
+ * Note:
+ *      EFID is used in individual learning in filtering database
+ */
+ret_t rtl8367c_setAsicPortIsolationEfid(rtk_uint32 port, rtk_uint32 efid)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if( efid > RTL8367C_EFIDMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_PORT_EFID_REG(port), RTL8367C_PORT_EFID_MASK(port), efid);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortIsolationEfid
+ * Description:
+ *      Get port isolation EFID
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      pEfid   - EFID (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortIsolationEfid(rtk_uint32 port, rtk_uint32 *pEfid)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_PORT_EFID_REG(port), RTL8367C_PORT_EFID_MASK(port), pEfid);
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_qos.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_qos.c
new file mode 100644
index 0000000000000..89c3c3e02e887
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_qos.c
@@ -0,0 +1,778 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Qos related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_qos.h>
+/* Function Name:
+ *      rtl8367c_setAsicPriorityDot1qRemapping
+ * Description:
+ *      Set 802.1Q absolutely priority
+ * Input:
+ *      srcpriority - Priority value
+ *      priority     - Absolute priority value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                 - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY    - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPriorityDot1qRemapping(rtk_uint32 srcpriority, rtk_uint32 priority )
+{
+    if((srcpriority > RTL8367C_PRIMAX) || (priority > RTL8367C_PRIMAX))
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_QOS_1Q_PRIORITY_REMAPPING_REG(srcpriority), RTL8367C_QOS_1Q_PRIORITY_REMAPPING_MASK(srcpriority),priority);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPriorityDot1qRemapping
+ * Description:
+ *      Get 802.1Q absolutely priority
+ * Input:
+ *      srcpriority - Priority value
+ *      pPriority     - Absolute priority value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPriorityDot1qRemapping(rtk_uint32 srcpriority, rtk_uint32 *pPriority )
+{
+    if(srcpriority > RTL8367C_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_QOS_1Q_PRIORITY_REMAPPING_REG(srcpriority), RTL8367C_QOS_1Q_PRIORITY_REMAPPING_MASK(srcpriority), pPriority);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPriorityPortBased
+ * Description:
+ *      Set port based priority
+ * Input:
+ *      port         - Physical port number (0~7)
+ *      priority     - Priority value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                 - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number
+ *      RT_ERR_QOS_INT_PRIORITY    - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPriorityPortBased(rtk_uint32 port, rtk_uint32 priority )
+{
+    ret_t retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(priority > RTL8367C_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if(port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_QOS_PORTBASED_PRIORITY_REG(port), RTL8367C_QOS_PORTBASED_PRIORITY_MASK(port), priority);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_QOS_PORTBASED_PRIORITY_CTRL2, 0x7 << ((port - 8) << 2), priority);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicPriorityPortBased
+ * Description:
+ *      Get port based priority
+ * Input:
+ *      port         - Physical port number (0~7)
+ *      pPriority     - Priority value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPriorityPortBased(rtk_uint32 port, rtk_uint32 *pPriority )
+{
+    ret_t retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_QOS_PORTBASED_PRIORITY_REG(port), RTL8367C_QOS_PORTBASED_PRIORITY_MASK(port), pPriority);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_QOS_PORTBASED_PRIORITY_CTRL2, 0x7 << ((port - 8) << 2), pPriority);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicPriorityDscpBased
+ * Description:
+ *      Set DSCP-based priority
+ * Input:
+ *      dscp         - DSCP value
+ *      priority     - Priority value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                 - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_DSCP_VALUE    - Invalid DSCP value
+ *      RT_ERR_QOS_INT_PRIORITY    - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPriorityDscpBased(rtk_uint32 dscp, rtk_uint32 priority )
+{
+    if(priority > RTL8367C_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if(dscp > RTL8367C_DSCPMAX)
+        return RT_ERR_QOS_DSCP_VALUE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_QOS_DSCP_TO_PRIORITY_REG(dscp), RTL8367C_QOS_DSCP_TO_PRIORITY_MASK(dscp), priority);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPriorityDscpBased
+ * Description:
+ *      Get DSCP-based priority
+ * Input:
+ *      dscp         - DSCP value
+ *      pPriority     - Priority value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                 - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY    - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPriorityDscpBased(rtk_uint32 dscp, rtk_uint32 *pPriority )
+{
+    if(dscp > RTL8367C_DSCPMAX)
+        return RT_ERR_QOS_DSCP_VALUE;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_QOS_DSCP_TO_PRIORITY_REG(dscp), RTL8367C_QOS_DSCP_TO_PRIORITY_MASK(dscp), pPriority);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPriorityDecision
+ * Description:
+ *      Set priority decision table
+ * Input:
+ *      prisrc         - Priority decision source
+ *      decisionPri - Decision priority assignment
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                     - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY        - Invalid priority
+ *      RT_ERR_QOS_SEL_PRI_SOURCE    - Invalid priority decision source parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPriorityDecision(rtk_uint32 index, rtk_uint32 prisrc, rtk_uint32 decisionPri)
+{
+    ret_t retVal;
+
+    if(index >= PRIDEC_IDX_END )
+        return RT_ERR_ENTRY_INDEX;
+
+    if(prisrc >= PRIDEC_END )
+        return RT_ERR_QOS_SEL_PRI_SOURCE;
+
+    if(decisionPri > RTL8367C_DECISIONPRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    switch(index)
+    {
+        case PRIDEC_IDX0:
+            if((retVal = rtl8367c_setAsicRegBits(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_REG(prisrc), RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_MASK(prisrc), decisionPri))!=  RT_ERR_OK)
+                return retVal;
+            break;
+        case PRIDEC_IDX1:
+            if((retVal = rtl8367c_setAsicRegBits(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_REG(prisrc), RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_MASK(prisrc), decisionPri))!=  RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    };
+
+    return RT_ERR_OK;
+
+
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicPriorityDecision
+ * Description:
+ *      Get priority decision table
+ * Input:
+ *      prisrc         - Priority decision source
+ *      pDecisionPri - Decision priority assignment
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                     - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_QOS_SEL_PRI_SOURCE    - Invalid priority decision source parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPriorityDecision(rtk_uint32 index, rtk_uint32 prisrc, rtk_uint32* pDecisionPri)
+{
+    ret_t retVal;
+
+    if(index >= PRIDEC_IDX_END )
+        return RT_ERR_ENTRY_INDEX;
+
+    if(prisrc >= PRIDEC_END )
+        return RT_ERR_QOS_SEL_PRI_SOURCE;
+
+    switch(index)
+    {
+        case PRIDEC_IDX0:
+            if((retVal = rtl8367c_getAsicRegBits(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_REG(prisrc), RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_MASK(prisrc), pDecisionPri))!=  RT_ERR_OK)
+                return retVal;
+            break;
+        case PRIDEC_IDX1:
+            if((retVal = rtl8367c_getAsicRegBits(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_REG(prisrc), RTL8367C_QOS_INTERNAL_PRIORITY_DECISION2_MASK(prisrc), pDecisionPri))!=  RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    };
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicPortPriorityDecisionIndex
+ * Description:
+ *      Set priority decision index for each port
+ * Input:
+ *      port     - Physical port number (0~7)
+ *      index     - Table index
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK             - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_QUEUE_NUM      - Invalid queue number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortPriorityDecisionIndex(rtk_uint32 port, rtk_uint32 index )
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(index >= PRIDEC_IDX_END)
+        return RT_ERR_ENTRY_INDEX;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_IDX_CTRL, port, index);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortPriorityDecisionIndex
+ * Description:
+ *      Get priority decision index  for each port
+ * Input:
+ *      port     - Physical port number (0~7)
+ *      pIndex     - Table index
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK             - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortPriorityDecisionIndex(rtk_uint32 port, rtk_uint32 *pIndex )
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_QOS_INTERNAL_PRIORITY_DECISION_IDX_CTRL, port, pIndex);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicOutputQueueMappingIndex
+ * Description:
+ *      Set output queue number for each port
+ * Input:
+ *      port     - Physical port number (0~7)
+ *      index     - Mapping table index
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK             - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_QUEUE_NUM      - Invalid queue number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicOutputQueueMappingIndex(rtk_uint32 port, rtk_uint32 index )
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(index >= RTL8367C_QUEUENO)
+        return RT_ERR_QUEUE_NUM;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_QOS_PORT_QUEUE_NUMBER_REG(port), RTL8367C_QOS_PORT_QUEUE_NUMBER_MASK(port), index);
+}
+/* Function Name:
+ *      rtl8367c_getAsicOutputQueueMappingIndex
+ * Description:
+ *      Get output queue number for each port
+ * Input:
+ *      port     - Physical port number (0~7)
+ *      pIndex     - Mapping table index
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK             - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicOutputQueueMappingIndex(rtk_uint32 port, rtk_uint32 *pIndex )
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_QOS_PORT_QUEUE_NUMBER_REG(port), RTL8367C_QOS_PORT_QUEUE_NUMBER_MASK(port), pIndex);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPriorityToQIDMappingTable
+ * Description:
+ *      Set priority to QID mapping table parameters
+ * Input:
+ *      index         - Mapping table index
+ *      priority     - The priority value
+ *      qid         - Queue id
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                 - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QUEUE_ID          - Invalid queue id
+ *      RT_ERR_QUEUE_NUM          - Invalid queue number
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPriorityToQIDMappingTable(rtk_uint32 index, rtk_uint32 priority, rtk_uint32 qid )
+{
+    if(index >= RTL8367C_QUEUENO)
+        return RT_ERR_QUEUE_NUM;
+
+    if(priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if(qid > RTL8367C_QIDMAX)
+        return RT_ERR_QUEUE_ID;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_QOS_1Q_PRIORITY_TO_QID_REG(index, priority), RTL8367C_QOS_1Q_PRIORITY_TO_QID_MASK(priority), qid);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPriorityToQIDMappingTable
+ * Description:
+ *      Get priority to QID mapping table parameters
+ * Input:
+ *      index         - Mapping table index
+ *      priority     - The priority value
+ *      pQid         - Queue id
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                 - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QUEUE_NUM          - Invalid queue number
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPriorityToQIDMappingTable(rtk_uint32 index, rtk_uint32 priority, rtk_uint32* pQid)
+{
+    if(index >= RTL8367C_QUEUENO)
+        return RT_ERR_QUEUE_NUM;
+
+    if(priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_QOS_1Q_PRIORITY_TO_QID_REG(index, priority), RTL8367C_QOS_1Q_PRIORITY_TO_QID_MASK(priority), pQid);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRemarkingDot1pAbility
+ * Description:
+ *      Set 802.1p remarking ability
+ * Input:
+ *      port     - Physical port number (0~7)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK             - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRemarkingDot1pAbility(rtk_uint32 port, rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_1QREMARK_ENABLE_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRemarkingDot1pAbility
+ * Description:
+ *      Get 802.1p remarking ability
+ * Input:
+ *      port     - Physical port number (0~7)
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRemarkingDot1pAbility(rtk_uint32 port, rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_1QREMARK_ENABLE_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRemarkingDot1pParameter
+ * Description:
+ *      Set 802.1p remarking parameter
+ * Input:
+ *      priority     - Priority value
+ *      newPriority - New priority value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                 - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRemarkingDot1pParameter(rtk_uint32 priority, rtk_uint32 newPriority )
+{
+    if(priority > RTL8367C_PRIMAX || newPriority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_QOS_1Q_REMARK_REG(priority), RTL8367C_QOS_1Q_REMARK_MASK(priority), newPriority);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRemarkingDot1pParameter
+ * Description:
+ *      Get 802.1p remarking parameter
+ * Input:
+ *      priority     - Priority value
+ *      pNewPriority - New priority value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                 - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRemarkingDot1pParameter(rtk_uint32 priority, rtk_uint32 *pNewPriority )
+{
+    if(priority > RTL8367C_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_QOS_1Q_REMARK_REG(priority), RTL8367C_QOS_1Q_REMARK_MASK(priority), pNewPriority);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicRemarkingDot1pSrc
+ * Description:
+ *      Set remarking source of 802.1p remarking.
+ * Input:
+ *      type      - remarking source
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID  - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+
+ * Note:
+ *      The API can configure 802.1p remark functionality to map original DSCP value or internal
+ *      priority to TX DSCP value.
+ */
+ret_t rtl8367c_setAsicRemarkingDot1pSrc(rtk_uint32 type)
+{
+
+    if(type >= DOT1P_PRISEL_END )
+        return RT_ERR_QOS_SEL_PRI_SOURCE;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_RMK_CFG_SEL_CTRL, RTL8367C_RMK_1Q_CFG_SEL_OFFSET, type);
+}
+
+
+/* Function Name:
+ *      rtl8367c_getAsicRemarkingDot1pSrc
+ * Description:
+ *      Get remarking source of 802.1p remarking.
+ * Output:
+ *      pType      - remarking source
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+ *      RT_ERR_NULL_POINTER     - input parameter may be null pointer
+
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRemarkingDot1pSrc(rtk_uint32 *pType)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_RMK_CFG_SEL_CTRL, RTL8367C_RMK_1Q_CFG_SEL_OFFSET, pType);
+}
+
+
+
+
+
+/* Function Name:
+ *      rtl8367c_setAsicRemarkingDscpAbility
+ * Description:
+ *      Set DSCP remarking ability
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRemarkingDscpAbility(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REMARKING_CTRL_REG, RTL8367C_REMARKING_DSCP_ENABLE_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRemarkingDscpAbility
+ * Description:
+ *      Get DSCP remarking ability
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK     - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRemarkingDscpAbility(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REMARKING_CTRL_REG, RTL8367C_REMARKING_DSCP_ENABLE_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRemarkingDscpParameter
+ * Description:
+ *      Set DSCP remarking parameter
+ * Input:
+ *      priority     - Priority value
+ *      newDscp     - New DSCP value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                 - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_DSCP_VALUE    - Invalid DSCP value
+ *      RT_ERR_QOS_INT_PRIORITY    - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRemarkingDscpParameter(rtk_uint32 priority, rtk_uint32 newDscp )
+{
+    if(priority > RTL8367C_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    if(newDscp > RTL8367C_DSCPMAX)
+        return RT_ERR_QOS_DSCP_VALUE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_QOS_DSCP_REMARK_REG(priority), RTL8367C_QOS_DSCP_REMARK_MASK(priority), newDscp);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRemarkingDscpParameter
+ * Description:
+ *      Get DSCP remarking parameter
+ * Input:
+ *      priority     - Priority value
+ *      pNewDscp     - New DSCP value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                 - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY    - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRemarkingDscpParameter(rtk_uint32 priority, rtk_uint32* pNewDscp )
+{
+    if(priority > RTL8367C_PRIMAX )
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_QOS_DSCP_REMARK_REG(priority), RTL8367C_QOS_DSCP_REMARK_MASK(priority), pNewDscp);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicRemarkingDscpSrc
+ * Description:
+ *      Set remarking source of DSCP remarking.
+ * Input:
+ *      type      - remarking source
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID  - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+
+ * Note:
+ *      The API can configure DSCP remark functionality to map original DSCP value or internal
+ *      priority to TX DSCP value.
+ */
+ret_t rtl8367c_setAsicRemarkingDscpSrc(rtk_uint32 type)
+{
+
+    if(type >= DSCP_PRISEL_END )
+        return RT_ERR_QOS_SEL_PRI_SOURCE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_RMK_CFG_SEL_CTRL, RTL8367C_RMK_DSCP_CFG_SEL_MASK, type);
+}
+
+
+/* Function Name:
+ *      rtl8367c_getAsicRemarkingDscpSrc
+ * Description:
+ *      Get remarking source of DSCP remarking.
+ * Output:
+ *      pType      - remarking source
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT         - The module is not initial
+ *      RT_ERR_PORT_ID          - invalid port id
+ *      RT_ERR_INPUT            - invalid input parameter
+ *      RT_ERR_NULL_POINTER     - input parameter may be null pointer
+
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRemarkingDscpSrc(rtk_uint32 *pType)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_RMK_CFG_SEL_CTRL, RTL8367C_RMK_DSCP_CFG_SEL_MASK, pType);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicRemarkingDscp2Dscp
+ * Description:
+ *      Set DSCP to remarked DSCP mapping.
+ * Input:
+ *      dscp    - DSCP value
+ *      rmkDscp - remarked DSCP value
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID          - Invalid unit id
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid dscp value
+ * Note:
+ *      dscp parameter can be DSCP value or internal priority according to configuration of API
+ *      dal_apollomp_qos_dscpRemarkSrcSel_set(), because DSCP remark functionality can map original DSCP
+ *      value or internal priority to TX DSCP value.
+ */
+ret_t rtl8367c_setAsicRemarkingDscp2Dscp(rtk_uint32 dscp, rtk_uint32 rmkDscp)
+{
+    if((dscp > RTL8367C_DSCPMAX ) || (rmkDscp > RTL8367C_DSCPMAX))
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_QOS_DSCP_TO_DSCP_REG(dscp), RTL8367C_QOS_DSCP_TO_DSCP_MASK(dscp), rmkDscp);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicRemarkingDscp2Dscp
+ * Description:
+ *      Get DSCP to remarked DSCP mapping.
+ * Input:
+ *      dscp    - DSCP value
+ * Output:
+ *      pRmkDscp   - remarked DSCP value
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_QOS_DSCP_VALUE   - Invalid dscp value
+ *      RT_ERR_NULL_POINTER     - NULL pointer
+ * Note:
+ *      None.
+ */
+ret_t rtl8367c_getAsicRemarkingDscp2Dscp(rtk_uint32 dscp, rtk_uint32 *pRmkDscp)
+{
+    if(dscp > RTL8367C_DSCPMAX)
+        return RT_ERR_QOS_DSCP_VALUE;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_QOS_DSCP_TO_DSCP_REG(dscp), RTL8367C_QOS_DSCP_TO_DSCP_MASK(dscp), pRmkDscp);
+
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_rldp.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_rldp.c
new file mode 100644
index 0000000000000..0309689d39b95
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_rldp.c
@@ -0,0 +1,674 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 42321 $
+ * $Date: 2013-08-26 13:51:29 +0800 (週一, 26 八月 2013) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : RLDP related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_rldp.h>
+/* Function Name:
+ *      rtl8367c_setAsicRldp
+ * Description:
+ *      Set RLDP function enable/disable
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldp(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_ENABLE_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldp
+ * Description:
+ *      Get RLDP function enable/disable
+ * Input:
+ *      pEnabled    - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldp(rtk_uint32 *pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_ENABLE_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRldpEnable8051
+ * Description:
+ *      Set RLDP function handled by ASIC or 8051
+ * Input:
+ *      enabled     - 1: enabled 8051, 0: disabled 8051 (RLDP is handled by ASIC)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldpEnable8051(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_8051_ENABLE_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRldrtl8367c_getAsicRldpEnable8051pEnable8051
+ * Description:
+ *      Get RLDP function handled by ASIC or 8051
+ * Input:
+ *      pEnabled    - 1: enabled 8051, 0: disabled 8051 (RLDP is handled by ASIC)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpEnable8051(rtk_uint32 *pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_8051_ENABLE_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRldpCompareRandomNumber
+ * Description:
+ *      Set enable compare the random number field and seed field of RLDP frame
+ * Input:
+ *      enabled     - 1: enabled comparing random number, 0: disabled comparing random number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldpCompareRandomNumber(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_COMP_ID_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldpCompareRandomNumber
+ * Description:
+ *      Get enable compare the random number field and seed field of RLDP frame
+ * Input:
+ *      pEnabled    - 1: enabled comparing random number, 0: disabled comparing random number
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpCompareRandomNumber(rtk_uint32 *pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_COMP_ID_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRldpIndicatorSource
+ * Description:
+ *      Set buzzer and LED source when detecting a loop
+ * Input:
+ *      src     - 0: ASIC, 1: 8051
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldpIndicatorSource(rtk_uint32 src)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_INDICATOR_SOURCE_OFFSET, src);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldpIndicatorSource
+ * Description:
+ *      Get buzzer and LED source when detecting a loop
+ * Input:
+ *      pSrc    - 0: ASIC, 1: 8051
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpIndicatorSource(rtk_uint32 *pSrc)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_INDICATOR_SOURCE_OFFSET, pSrc);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRldpCheckingStatePara
+ * Description:
+ *      Set retry count and retry period of checking state
+ * Input:
+ *      retryCount  - 0~0xFF (times)
+ *      retryPeriod - 0~0xFFFF (ms)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldpCheckingStatePara(rtk_uint32 retryCount, rtk_uint32 retryPeriod)
+{
+    ret_t retVal;
+
+    if(retryCount > 0xFF)
+        return RT_ERR_OUT_OF_RANGE;
+    if(retryPeriod > RTL8367C_REGDATAMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_RLDP_RETRY_COUNT_REG, RTL8367C_RLDP_RETRY_COUNT_CHKSTATE_MASK, retryCount);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_setAsicReg(RTL8367C_RLDP_RETRY_PERIOD_CHKSTATE_REG, retryPeriod);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldpCheckingStatePara
+ * Description:
+ *      Get retry count and retry period of checking state
+ * Input:
+ *      pRetryCount     - 0~0xFF (times)
+ *      pRetryPeriod    - 0~0xFFFF (ms)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpCheckingStatePara(rtk_uint32 *pRetryCount, rtk_uint32 *pRetryPeriod)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_RLDP_RETRY_COUNT_REG, RTL8367C_RLDP_RETRY_COUNT_CHKSTATE_MASK, pRetryCount);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_getAsicReg(RTL8367C_RLDP_RETRY_PERIOD_CHKSTATE_REG, pRetryPeriod);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRldpLoopStatePara
+ * Description:
+ *      Set retry count and retry period of loop state
+ * Input:
+ *      retryCount  - 0~0xFF (times)
+ *      retryPeriod - 0~0xFFFF (ms)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldpLoopStatePara(rtk_uint32 retryCount, rtk_uint32 retryPeriod)
+{
+    ret_t retVal;
+
+    if(retryCount > 0xFF)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(retryPeriod > RTL8367C_REGDATAMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_RLDP_RETRY_COUNT_REG, RTL8367C_RLDP_RETRY_COUNT_LOOPSTATE_MASK, retryCount);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_setAsicReg(RTL8367C_RLDP_RETRY_PERIOD_LOOPSTATE_REG, retryPeriod);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldpLoopStatePara
+ * Description:
+ *      Get retry count and retry period of loop state
+ * Input:
+ *      pRetryCount     - 0~0xFF (times)
+ *      pRetryPeriod    - 0~0xFFFF (ms)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - input parameter out of range
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpLoopStatePara(rtk_uint32 *pRetryCount, rtk_uint32 *pRetryPeriod)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_RLDP_RETRY_COUNT_REG, RTL8367C_RLDP_RETRY_COUNT_LOOPSTATE_MASK, pRetryCount);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_getAsicReg(RTL8367C_RLDP_RETRY_PERIOD_LOOPSTATE_REG, pRetryPeriod);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRldpTxPortmask
+ * Description:
+ *      Set portmask that send/forward RLDP frame
+ * Input:
+ *      portmask    - 0~0xFF
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldpTxPortmask(rtk_uint32 portmask)
+{
+    if(portmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    return rtl8367c_setAsicReg(RTL8367C_RLDP_TX_PMSK_REG, portmask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldpTxPortmask
+ * Description:
+ *      Get portmask that send/forward RLDP frame
+ * Input:
+ *      pPortmask   - 0~0xFF
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpTxPortmask(rtk_uint32 *pPortmask)
+{
+    return rtl8367c_getAsicReg(RTL8367C_RLDP_TX_PMSK_REG, pPortmask);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRldpMagicNum
+ * Description:
+ *      Set Random seed of RLDP
+ * Input:
+ *      seed    - MAC
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldpMagicNum(ether_addr_t seed)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint16 *accessPtr;
+    rtk_uint32 i;
+
+    accessPtr = (rtk_uint16*)&seed;
+
+    for (i = 0; i < 3; i++)
+    {
+        regData = *accessPtr;
+        retVal = rtl8367c_setAsicReg(RTL8367C_RLDP_MAGIC_NUM_REG_BASE + i, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        accessPtr++;
+    }
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldpMagicNum
+ * Description:
+ *      Get Random seed of RLDP
+ * Input:
+ *      pSeed   - MAC
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpMagicNum(ether_addr_t *pSeed)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint16 *accessPtr;
+    rtk_uint32 i;
+
+    accessPtr = (rtk_uint16*)pSeed;
+
+    for(i = 0; i < 3; i++)
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_RLDP_MAGIC_NUM_REG_BASE + i, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *accessPtr = regData;
+        accessPtr++;
+    }
+
+    return retVal;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicRldpLoopedPortmask
+ * Description:
+ *      Get looped portmask
+ * Input:
+ *      pPortmask   - 0~0xFF
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpLoopedPortmask(rtk_uint32 *pPortmask)
+{
+    return rtl8367c_getAsicReg(RTL8367C_RLDP_LOOP_PMSK_REG, pPortmask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldpRandomNumber
+ * Description:
+ *      Get Random number of RLDP
+ * Input:
+ *      pRandNumber     - MAC
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpRandomNumber(ether_addr_t *pRandNumber)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_int16 accessPtr[3];
+    rtk_uint32 i;
+
+    for(i = 0; i < 3; i++)
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_RLDP_RAND_NUM_REG_BASE+ i, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        accessPtr[i] = regData;
+    }
+
+    memcpy(pRandNumber, accessPtr, 6);
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldpLoopedPortmask
+ * Description:
+ *      Get port number of looped pair
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      pLoopedPair     - port (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpLoopedPortPair(rtk_uint32 port, rtk_uint32 *pLoopedPair)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+        return rtl8367c_getAsicRegBits(RTL8367C_RLDP_LOOP_PORT_REG(port), RTL8367C_RLDP_LOOP_PORT_MASK(port), pLoopedPair);
+    else
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_RLDP_LOOP_PORT_REG4 + ((port - 8) >> 1), RTL8367C_RLDP_LOOP_PORT_MASK(port), pLoopedPair);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRlppTrap8051
+ * Description:
+ *      Set trap RLPP packet to 8051
+ * Input:
+ *      enabled     - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRlppTrap8051(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLPP_8051_TRAP_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRlppTrap8051
+ * Description:
+ *      Get trap RLPP packet to 8051
+ * Input:
+ *      pEnabled    - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRlppTrap8051(rtk_uint32 *pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLPP_8051_TRAP_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRldpLeaveLoopedPortmask
+ * Description:
+ *      Clear leaved looped portmask
+ * Input:
+ *      portmask    - 0~0xFF
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldpLeaveLoopedPortmask(rtk_uint32 portmask)
+{
+    return rtl8367c_setAsicReg(RTL8367C_REG_RLDP_RELEASED_INDICATOR, portmask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldpLeaveLoopedPortmask
+ * Description:
+ *      Get leaved looped portmask
+ * Input:
+ *      pPortmask   - 0~0xFF
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpLeaveLoopedPortmask(rtk_uint32 *pPortmask)
+{
+    return rtl8367c_getAsicReg(RTL8367C_REG_RLDP_RELEASED_INDICATOR, pPortmask);
+}
+/* Function Name:
+ *      rtl8367c_setAsicRldpEnterLoopedPortmask
+ * Description:
+ *      Clear enter loop portmask
+ * Input:
+ *      portmask    - 0~0xFF
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldpEnterLoopedPortmask(rtk_uint32 portmask)
+{
+    return rtl8367c_setAsicReg(RTL8367C_REG_RLDP_LOOPED_INDICATOR, portmask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldpEnterLoopedPortmask
+ * Description:
+ *      Get enter loop portmask
+ * Input:
+ *      pPortmask   - 0~0xFF
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpEnterLoopedPortmask(rtk_uint32 *pPortmask)
+{
+    return rtl8367c_getAsicReg(RTL8367C_REG_RLDP_LOOPED_INDICATOR, pPortmask);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicRldpTriggerMode
+ * Description:
+ *      Set trigger RLDP mode
+ * Input:
+ *      mode    - 1: Periodically, 0: SA moving
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldpTriggerMode(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_TRIGGER_MODE_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldpTriggerMode
+ * Description:
+ *      Get trigger RLDP mode
+ * Input:
+ *      pMode   - - 1: Periodically, 0: SA moving
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldpTriggerMode(rtk_uint32 *pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_RLDP_CTRL0, RTL8367C_RLDP_TRIGGER_MODE_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicRldp8051Portmask
+ * Description:
+ *      Set 8051/CPU configured looped portmask
+ * Input:
+ *      portmask    - 0~0xFF
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRldp8051Portmask(rtk_uint32 portmask)
+{
+    ret_t retVal;
+    if(portmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_RLDP_CTRL0_REG,RTL8367C_RLDP_8051_LOOP_PORTMSK_MASK,portmask & 0xff);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_RLDP_CTRL5,RTL8367C_RLDP_CTRL5_MASK,(portmask >> 8) & 7);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicRldp8051Portmask
+ * Description:
+ *      Get 8051/CPU configured looped portmask
+ * Input:
+ *      pPortmask   - 0~0xFF
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRldp8051Portmask(rtk_uint32 *pPortmask)
+{
+    rtk_uint32 tmpPmsk;
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_RLDP_CTRL0_REG,RTL8367C_RLDP_8051_LOOP_PORTMSK_MASK,&tmpPmsk);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    *pPortmask = tmpPmsk & 0xff;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_RLDP_CTRL5,RTL8367C_RLDP_CTRL5_MASK,&tmpPmsk);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    *pPortmask |= (tmpPmsk & 7) <<8;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_rma.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_rma.c
new file mode 100644
index 0000000000000..f297defa78aca
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_rma.c
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 64716 $
+ * $Date: 2015-12-31 16:31:55 +0800 (週四, 31 十二月 2015) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : RMA related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_rma.h>
+/* Function Name:
+ *      rtl8367c_setAsicRma
+ * Description:
+ *      Set reserved multicast address for CPU trapping
+ * Input:
+ *      index     - reserved multicast LSB byte, 0x00~0x2F is available value
+ *      pRmacfg     - type of RMA for trapping frame type setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_RMA_ADDR - Invalid RMA address index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRma(rtk_uint32 index, rtl8367c_rma_t* pRmacfg)
+{
+    rtk_uint32 regData = 0;
+    ret_t retVal;
+
+    if(index > RTL8367C_RMAMAX)
+        return RT_ERR_RMA_ADDR;
+
+    regData |= (pRmacfg->portiso_leaky & 0x0001);
+    regData |= ((pRmacfg->vlan_leaky & 0x0001) << 1);
+    regData |= ((pRmacfg->keep_format & 0x0001) << 2);
+    regData |= ((pRmacfg->trap_priority & 0x0007) << 3);
+    regData |= ((pRmacfg->discard_storm_filter & 0x0001) << 6);
+    regData |= ((pRmacfg->operation & 0x0003) << 7);
+
+    if( (index >= 0x4 && index <= 0x7) || (index >= 0x9 && index <= 0x0C) || (0x0F == index))
+        index = 0x04;
+    else if((index >= 0x13 && index <= 0x17) || (0x19 == index) || (index >= 0x1B && index <= 0x1f))
+        index = 0x13;
+    else if(index >= 0x22 && index <= 0x2F)
+        index = 0x22;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, pRmacfg->trap_priority);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_setAsicReg(RTL8367C_REG_RMA_CTRL00+index, regData);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRma
+ * Description:
+ *      Get reserved multicast address for CPU trapping
+ * Input:
+ *      index     - reserved multicast LSB byte, 0x00~0x2F is available value
+ *      rmacfg     - type of RMA for trapping frame type setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_RMA_ADDR - Invalid RMA address index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRma(rtk_uint32 index, rtl8367c_rma_t* pRmacfg)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    if(index > RTL8367C_RMAMAX)
+        return RT_ERR_RMA_ADDR;
+
+    if( (index >= 0x4 && index <= 0x7) || (index >= 0x9 && index <= 0x0C) || (0x0F == index))
+        index = 0x04;
+    else if((index >= 0x13 && index <= 0x17) || (0x19 == index) || (index >= 0x1B && index <= 0x1f))
+        index = 0x13;
+    else if(index >= 0x22 && index <= 0x2F)
+        index = 0x22;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_RMA_CTRL00+index, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pRmacfg->operation = ((regData >> 7) & 0x0003);
+    pRmacfg->discard_storm_filter = ((regData >> 6) & 0x0001);
+    pRmacfg->trap_priority = ((regData >> 3) & 0x0007);
+    pRmacfg->keep_format = ((regData >> 2) & 0x0001);
+    pRmacfg->vlan_leaky = ((regData >> 1) & 0x0001);
+    pRmacfg->portiso_leaky = (regData & 0x0001);
+
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pRmacfg->trap_priority = regData;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicRmaCdp
+ * Description:
+ *      Set CDP(Cisco Discovery Protocol) for CPU trapping
+ * Input:
+ *      pRmacfg     - type of RMA for trapping frame type setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_RMA_ADDR - Invalid RMA address index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRmaCdp(rtl8367c_rma_t* pRmacfg)
+{
+    rtk_uint32 regData = 0;
+    ret_t retVal;
+
+    if(pRmacfg->operation >= RMAOP_END)
+        return RT_ERR_RMA_ACTION;
+
+    if(pRmacfg->trap_priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    regData |= (pRmacfg->portiso_leaky & 0x0001);
+    regData |= ((pRmacfg->vlan_leaky & 0x0001) << 1);
+    regData |= ((pRmacfg->keep_format & 0x0001) << 2);
+    regData |= ((pRmacfg->trap_priority & 0x0007) << 3);
+    regData |= ((pRmacfg->discard_storm_filter & 0x0001) << 6);
+    regData |= ((pRmacfg->operation & 0x0003) << 7);
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, pRmacfg->trap_priority);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_setAsicReg(RTL8367C_REG_RMA_CTRL_CDP, regData);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRmaCdp
+ * Description:
+ *      Get CDP(Cisco Discovery Protocol) for CPU trapping
+ * Input:
+ *      None
+ * Output:
+ *      pRmacfg     - type of RMA for trapping frame type setting
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_RMA_ADDR - Invalid RMA address index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRmaCdp(rtl8367c_rma_t* pRmacfg)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_RMA_CTRL_CDP, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pRmacfg->operation = ((regData >> 7) & 0x0003);
+    pRmacfg->discard_storm_filter = ((regData >> 6) & 0x0001);
+    pRmacfg->trap_priority = ((regData >> 3) & 0x0007);
+    pRmacfg->keep_format = ((regData >> 2) & 0x0001);
+    pRmacfg->vlan_leaky = ((regData >> 1) & 0x0001);
+    pRmacfg->portiso_leaky = (regData & 0x0001);
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pRmacfg->trap_priority = regData;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicRmaCsstp
+ * Description:
+ *      Set CSSTP(Cisco Shared Spanning Tree Protocol) for CPU trapping
+ * Input:
+ *      pRmacfg     - type of RMA for trapping frame type setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_RMA_ADDR - Invalid RMA address index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRmaCsstp(rtl8367c_rma_t* pRmacfg)
+{
+    rtk_uint32 regData = 0;
+    ret_t retVal;
+
+    if(pRmacfg->operation >= RMAOP_END)
+        return RT_ERR_RMA_ACTION;
+
+    if(pRmacfg->trap_priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    regData |= (pRmacfg->portiso_leaky & 0x0001);
+    regData |= ((pRmacfg->vlan_leaky & 0x0001) << 1);
+    regData |= ((pRmacfg->keep_format & 0x0001) << 2);
+    regData |= ((pRmacfg->trap_priority & 0x0007) << 3);
+    regData |= ((pRmacfg->discard_storm_filter & 0x0001) << 6);
+    regData |= ((pRmacfg->operation & 0x0003) << 7);
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, pRmacfg->trap_priority);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_setAsicReg(RTL8367C_REG_RMA_CTRL_CSSTP, regData);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRmaCsstp
+ * Description:
+ *      Get CSSTP(Cisco Shared Spanning Tree Protocol) for CPU trapping
+ * Input:
+ *      None
+ * Output:
+ *      pRmacfg     - type of RMA for trapping frame type setting
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_RMA_ADDR - Invalid RMA address index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRmaCsstp(rtl8367c_rma_t* pRmacfg)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_RMA_CTRL_CSSTP, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pRmacfg->operation = ((regData >> 7) & 0x0003);
+    pRmacfg->discard_storm_filter = ((regData >> 6) & 0x0001);
+    pRmacfg->trap_priority = ((regData >> 3) & 0x0007);
+    pRmacfg->keep_format = ((regData >> 2) & 0x0001);
+    pRmacfg->vlan_leaky = ((regData >> 1) & 0x0001);
+    pRmacfg->portiso_leaky = (regData & 0x0001);
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pRmacfg->trap_priority = regData;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicRmaLldp
+ * Description:
+ *      Set LLDP for CPU trapping
+ * Input:
+ *      pRmacfg     - type of RMA for trapping frame type setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_RMA_ADDR - Invalid RMA address index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicRmaLldp(rtk_uint32 enabled, rtl8367c_rma_t* pRmacfg)
+{
+    rtk_uint32 regData = 0;
+    ret_t retVal;
+
+    if(enabled > 1)
+        return RT_ERR_ENABLE;
+
+    if(pRmacfg->operation >= RMAOP_END)
+        return RT_ERR_RMA_ACTION;
+
+    if(pRmacfg->trap_priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_RMA_LLDP_EN, RTL8367C_RMA_LLDP_EN_OFFSET,enabled);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regData |= (pRmacfg->portiso_leaky & 0x0001);
+    regData |= ((pRmacfg->vlan_leaky & 0x0001) << 1);
+    regData |= ((pRmacfg->keep_format & 0x0001) << 2);
+    regData |= ((pRmacfg->trap_priority & 0x0007) << 3);
+    regData |= ((pRmacfg->discard_storm_filter & 0x0001) << 6);
+    regData |= ((pRmacfg->operation & 0x0003) << 7);
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, pRmacfg->trap_priority);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_setAsicReg(RTL8367C_REG_RMA_CTRL_LLDP, regData);
+}
+/* Function Name:
+ *      rtl8367c_getAsicRmaLldp
+ * Description:
+ *      Get LLDP for CPU trapping
+ * Input:
+ *      None
+ * Output:
+ *      pRmacfg     - type of RMA for trapping frame type setting
+ * Return:
+ *      RT_ERR_OK         - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_RMA_ADDR - Invalid RMA address index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicRmaLldp(rtk_uint32 *pEnabled, rtl8367c_rma_t* pRmacfg)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_RMA_LLDP_EN, RTL8367C_RMA_LLDP_EN_OFFSET,pEnabled);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_REG_RMA_CTRL_LLDP, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pRmacfg->operation = ((regData >> 7) & 0x0003);
+    pRmacfg->discard_storm_filter = ((regData >> 6) & 0x0001);
+    pRmacfg->trap_priority = ((regData >> 3) & 0x0007);
+    pRmacfg->keep_format = ((regData >> 2) & 0x0001);
+    pRmacfg->vlan_leaky = ((regData >> 1) & 0x0001);
+    pRmacfg->portiso_leaky = (regData & 0x0001);
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_RMA_CTRL00, RTL8367C_TRAP_PRIORITY_MASK, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pRmacfg->trap_priority = regData;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_scheduling.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_scheduling.c
new file mode 100644
index 0000000000000..8ebd6796dc9f2
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_scheduling.c
@@ -0,0 +1,525 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Packet Scheduling related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_scheduling.h>
+/* Function Name:
+ *      rtl8367c_setAsicLeakyBucketParameter
+ * Description:
+ *      Set Leaky Bucket Paramters
+ * Input:
+ *      tick    - Tick is used for time slot size unit
+ *      token   - Token is used for adding budget in each time slot
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_TICK     - Invalid TICK
+ *      RT_ERR_TOKEN    - Invalid TOKEN
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicLeakyBucketParameter(rtk_uint32 tick, rtk_uint32 token)
+{
+    ret_t retVal;
+
+    if(tick > 0xFF)
+        return RT_ERR_TICK;
+
+    if(token > 0xFF)
+        return RT_ERR_TOKEN;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_LEAKY_BUCKET_TICK_REG, RTL8367C_LEAKY_BUCKET_TICK_MASK, tick);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_LEAKY_BUCKET_TOKEN_REG, RTL8367C_LEAKY_BUCKET_TOKEN_MASK, token);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicLeakyBucketParameter
+ * Description:
+ *      Get Leaky Bucket Paramters
+ * Input:
+ *      tick    - Tick is used for time slot size unit
+ *      token   - Token is used for adding budget in each time slot
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicLeakyBucketParameter(rtk_uint32 *tick, rtk_uint32 *token)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_LEAKY_BUCKET_TICK_REG, RTL8367C_LEAKY_BUCKET_TICK_MASK, tick);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_LEAKY_BUCKET_TOKEN_REG, RTL8367C_LEAKY_BUCKET_TOKEN_MASK, token);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicAprMeter
+ * Description:
+ *      Set per-port per-queue APR shared meter index
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      qid     - Queue id
+ *      apridx  - dedicated shared meter index for APR (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number
+ *      RT_ERR_QUEUE_ID         - Invalid queue id
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicAprMeter(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 apridx)
+{
+    ret_t retVal;
+    rtk_uint32 regAddr;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(qid > RTL8367C_QIDMAX)
+        return RT_ERR_QUEUE_ID;
+
+    if(apridx > RTL8367C_PORT_QUEUE_METER_INDEX_MAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(port < 8)
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_SCHEDULE_PORT_APR_METER_REG(port, qid), RTL8367C_SCHEDULE_PORT_APR_METER_MASK(qid), apridx);
+    else {
+        regAddr = RTL8367C_REG_SCHEDULE_PORT8_APR_METER_CTRL0 + ((port-8) << 1) + (qid / 5);
+        retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_SCHEDULE_PORT_APR_METER_MASK(qid), apridx);
+    }
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicAprMeter
+ * Description:
+ *      Get per-port per-queue APR shared meter index
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      qid     - Queue id
+ *      apridx  - dedicated shared meter index for APR (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ *      RT_ERR_QUEUE_ID - Invalid queue id
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAprMeter(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 *apridx)
+{
+    ret_t retVal;
+    rtk_uint32 regAddr;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(qid > RTL8367C_QIDMAX)
+        return RT_ERR_QUEUE_ID;
+
+    if(port < 8)
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_SCHEDULE_PORT_APR_METER_REG(port, qid), RTL8367C_SCHEDULE_PORT_APR_METER_MASK(qid), apridx);
+    else {
+        regAddr = RTL8367C_REG_SCHEDULE_PORT8_APR_METER_CTRL0 + ((port-8) << 1) + (qid / 5);
+        retVal = rtl8367c_getAsicRegBits(regAddr, RTL8367C_SCHEDULE_PORT_APR_METER_MASK(qid), apridx);
+    }
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicAprEnable
+ * Description:
+ *      Set per-port APR enable
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      aprEnable   - APR enable seting 1:enable 0:disable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicAprEnable(rtk_uint32 port, rtk_uint32 aprEnable)
+{
+    ret_t retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_SCHEDULE_APR_CTRL_REG, RTL8367C_SCHEDULE_APR_CTRL_OFFSET(port), aprEnable);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicAprEnable
+ * Description:
+ *      Get per-port APR enable
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      aprEnable   - APR enable seting 1:enable 0:disable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicAprEnable(rtk_uint32 port, rtk_uint32 *aprEnable)
+{
+    ret_t retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_SCHEDULE_APR_CTRL_REG, RTL8367C_SCHEDULE_APR_CTRL_OFFSET(port), aprEnable);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicWFQWeight
+ * Description:
+ *      Set weight  of a queue
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      qid     - The queue ID wanted to set
+ *      qWeight - The weight value wanted to set (valid:0~127)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number
+ *      RT_ERR_QUEUE_ID         - Invalid queue id
+ *      RT_ERR_QOS_QUEUE_WEIGHT - Invalid queue weight
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicWFQWeight(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 qWeight)
+{
+    ret_t retVal;
+
+    /* Invalid input parameter */
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(qid > RTL8367C_QIDMAX)
+        return RT_ERR_QUEUE_ID;
+
+    if(qWeight > RTL8367C_QWEIGHTMAX && qid > 0)
+        return RT_ERR_QOS_QUEUE_WEIGHT;
+
+    retVal = rtl8367c_setAsicReg(RTL8367C_SCHEDULE_PORT_QUEUE_WFQ_WEIGHT_REG(port, qid), qWeight);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicWFQWeight
+ * Description:
+ *      Get weight  of a queue
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      qid     - The queue ID wanted to set
+ *      qWeight - The weight value wanted to set (valid:0~127)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number
+ *      RT_ERR_QUEUE_ID         - Invalid queue id
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicWFQWeight(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 *qWeight)
+{
+    ret_t retVal;
+
+
+    /* Invalid input parameter */
+    if(port  > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(qid > RTL8367C_QIDMAX)
+        return RT_ERR_QUEUE_ID;
+
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_SCHEDULE_PORT_QUEUE_WFQ_WEIGHT_REG(port, qid), qWeight);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicWFQBurstSize
+ * Description:
+ *      Set WFQ leaky bucket burst size
+ * Input:
+ *      burstsize   - Leaky bucket burst size, unit byte
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicWFQBurstSize(rtk_uint32 burstsize)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_setAsicReg(RTL8367C_SCHEDULE_WFQ_BURST_SIZE_REG, burstsize);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicWFQBurstSize
+ * Description:
+ *      Get WFQ leaky bucket burst size
+ * Input:
+ *      burstsize   - Leaky bucket burst size, unit byte
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicWFQBurstSize(rtk_uint32 *burstsize)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_SCHEDULE_WFQ_BURST_SIZE_REG, burstsize);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicQueueType
+ * Description:
+ *      Set type of a queue
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      qid         - The queue ID wanted to set
+ *      queueType   - The specified queue type. 0b0: Strict priority, 0b1: WFQ
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ *      RT_ERR_QUEUE_ID - Invalid queue id
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicQueueType(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 queueType)
+{
+    ret_t retVal;
+
+    /* Invalid input parameter */
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(qid > RTL8367C_QIDMAX)
+        return RT_ERR_QUEUE_ID;
+
+    /* Set Related Registers */
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_SCHEDULE_QUEUE_TYPE_REG(port), RTL8367C_SCHEDULE_QUEUE_TYPE_OFFSET(port, qid),queueType);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicQueueType
+ * Description:
+ *      Get type of a queue
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      qid         - The queue ID wanted to set
+ *      queueType   - The specified queue type. 0b0: Strict priority, 0b1: WFQ
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ *      RT_ERR_QUEUE_ID - Invalid queue id
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicQueueType(rtk_uint32 port, rtk_uint32 qid, rtk_uint32 *queueType)
+{
+    ret_t retVal;
+
+    /* Invalid input parameter */
+    if(port  > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(qid > RTL8367C_QIDMAX)
+        return RT_ERR_QUEUE_ID;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_SCHEDULE_QUEUE_TYPE_REG(port), RTL8367C_SCHEDULE_QUEUE_TYPE_OFFSET(port, qid),queueType);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortEgressRate
+ * Description:
+ *      Set per-port egress rate
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      rate        - Egress rate
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_QOS_EBW_RATE - Invalid bandwidth/rate
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortEgressRate(rtk_uint32 port, rtk_uint32 rate)
+{
+    ret_t retVal;
+    rtk_uint32 regAddr, regData;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(rate > RTL8367C_QOS_GRANULARTY_MAX)
+        return RT_ERR_QOS_EBW_RATE;
+
+    regAddr = RTL8367C_PORT_EGRESSBW_LSB_REG(port);
+    regData = RTL8367C_QOS_GRANULARTY_LSB_MASK & rate;
+
+    retVal = rtl8367c_setAsicReg(regAddr, regData);
+
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regAddr = RTL8367C_PORT_EGRESSBW_MSB_REG(port);
+    regData = (RTL8367C_QOS_GRANULARTY_MSB_MASK & rate) >> RTL8367C_QOS_GRANULARTY_MSB_OFFSET;
+
+    retVal = rtl8367c_setAsicRegBits(regAddr, RTL8367C_PORT6_EGRESSBW_CTRL1_MASK, regData);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortEgressRate
+ * Description:
+ *      Get per-port egress rate
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      rate        - Egress rate
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortEgressRate(rtk_uint32 port, rtk_uint32 *rate)
+{
+    ret_t retVal;
+    rtk_uint32 regAddr, regData,regData2;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    regAddr = RTL8367C_PORT_EGRESSBW_LSB_REG(port);
+
+    retVal = rtl8367c_getAsicReg(regAddr, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regAddr = RTL8367C_PORT_EGRESSBW_MSB_REG(port);
+    retVal = rtl8367c_getAsicRegBits(regAddr, RTL8367C_PORT6_EGRESSBW_CTRL1_MASK, &regData2);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *rate = regData | (regData2 << RTL8367C_QOS_GRANULARTY_MSB_OFFSET);
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortEgressRateIfg
+ * Description:
+ *      Set per-port egress rate calculate include/exclude IFG
+ * Input:
+ *      ifg     - 1:include IFG 0:exclude IFG
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortEgressRateIfg(rtk_uint32 ifg)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_SCHEDULE_WFQ_CTRL, RTL8367C_SCHEDULE_WFQ_CTRL_OFFSET, ifg);
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortEgressRateIfg
+ * Description:
+ *      Get per-port egress rate calculate include/exclude IFG
+ * Input:
+ *      ifg     - 1:include IFG 0:exclude IFG
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortEgressRateIfg(rtk_uint32 *ifg)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_SCHEDULE_WFQ_CTRL, RTL8367C_SCHEDULE_WFQ_CTRL_OFFSET, ifg);
+
+    return retVal;
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_storm.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_storm.c
new file mode 100644
index 0000000000000..a29f64769d655
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_storm.c
@@ -0,0 +1,851 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Storm control filtering related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_storm.h>
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterBroadcastEnable
+ * Description:
+ *      Set per-port broadcast storm filter enable/disable
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterBroadcastEnable(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_STORM_BCAST_REG, port, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterBroadcastEnable
+ * Description:
+ *      Get per-port broadcast storm filter enable/disable
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterBroadcastEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_STORM_BCAST_REG, port, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterBroadcastMeter
+ * Description:
+ *      Set per-port broadcast storm filter meter
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      meter   - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterBroadcastMeter(rtk_uint32 port, rtk_uint32 meter)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(meter > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_STORM_BCAST_METER_CTRL_REG(port), RTL8367C_STORM_BCAST_METER_CTRL_MASK(port), meter);
+}
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterBroadcastMeter
+ * Description:
+ *      Get per-port broadcast storm filter meter
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pMeter  - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterBroadcastMeter(rtk_uint32 port, rtk_uint32 *pMeter)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_STORM_BCAST_METER_CTRL_REG(port), RTL8367C_STORM_BCAST_METER_CTRL_MASK(port), pMeter);
+}
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterMulticastEnable
+ * Description:
+ *      Set per-port multicast storm filter enable/disable
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterMulticastEnable(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_STORM_MCAST_REG, port, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterMulticastEnable
+ * Description:
+ *      Get per-port multicast storm filter enable/disable
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterMulticastEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_STORM_MCAST_REG, port, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterMulticastMeter
+ * Description:
+ *      Set per-port multicast storm filter meter
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      meter   - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterMulticastMeter(rtk_uint32 port, rtk_uint32 meter)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(meter > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_STORM_MCAST_METER_CTRL_REG(port), RTL8367C_STORM_MCAST_METER_CTRL_MASK(port), meter);
+}
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterMulticastMeter
+ * Description:
+ *      Get per-port multicast storm filter meter
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pMeter  - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterMulticastMeter(rtk_uint32 port, rtk_uint32 *pMeter)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_STORM_MCAST_METER_CTRL_REG(port), RTL8367C_STORM_MCAST_METER_CTRL_MASK(port), pMeter);
+}
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterUnknownMulticastEnable
+ * Description:
+ *      Set per-port unknown multicast storm filter enable/disable
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterUnknownMulticastEnable(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_STORM_UNKNOWN_MCAST_REG, port, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterUnknownMulticastEnable
+ * Description:
+ *      Get per-port unknown multicast storm filter enable/disable
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterUnknownMulticastEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_STORM_UNKNOWN_MCAST_REG, port, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterUnknownMulticastMeter
+ * Description:
+ *      Set per-port unknown multicast storm filter meter
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      meter   - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterUnknownMulticastMeter(rtk_uint32 port, rtk_uint32 meter)
+{
+    ret_t retVal;
+
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(meter > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_STORM_UNMC_METER_CTRL_REG(port), RTL8367C_STORM_UNMC_METER_CTRL_MASK(port), meter);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_UNMC_METER_CTRL4 + ((port - 8) >> 1), RTL8367C_STORM_UNMC_METER_CTRL_MASK(port), meter);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterUnknownMulticastMeter
+ * Description:
+ *      Get per-port unknown multicast storm filter meter
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pMeter  - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterUnknownMulticastMeter(rtk_uint32 port, rtk_uint32 *pMeter)
+{
+    ret_t retVal;
+
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_STORM_UNMC_METER_CTRL_REG(port), RTL8367C_STORM_UNMC_METER_CTRL_MASK(port), pMeter);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_UNMC_METER_CTRL4 + ((port - 8) >> 1), RTL8367C_STORM_UNMC_METER_CTRL_MASK(port), pMeter);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterUnknownUnicastEnable
+ * Description:
+ *      Set per-port unknown unicast storm filter enable/disable
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterUnknownUnicastEnable(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_STORM_UNKNOWN_UCAST_REG, port, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterUnknownUnicastEnable
+ * Description:
+ *      get per-port unknown unicast storm filter enable/disable
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterUnknownUnicastEnable(rtk_uint32 port, rtk_uint32 *pEnabled)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_STORM_UNKNOWN_UCAST_REG, port, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterUnknownUnicastMeter
+ * Description:
+ *      Set per-port unknown unicast storm filter meter
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      meter   - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterUnknownUnicastMeter(rtk_uint32 port, rtk_uint32 meter)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(meter > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_STORM_UNDA_METER_CTRL_REG(port), RTL8367C_STORM_UNDA_METER_CTRL_MASK(port), meter);
+}
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterUnknownUnicastMeter
+ * Description:
+ *      Get per-port unknown unicast storm filter meter
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pMeter  - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterUnknownUnicastMeter(rtk_uint32 port, rtk_uint32 *pMeter)
+{
+    if(port >= RTL8367C_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_STORM_UNDA_METER_CTRL_REG(port), RTL8367C_STORM_UNDA_METER_CTRL_MASK(port), pMeter);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterExtBroadcastMeter
+ * Description:
+ *      Set extension broadcast storm filter meter
+ * Input:
+ *      meter   - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterExtBroadcastMeter(rtk_uint32 meter)
+{
+    if(meter > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG0, RTL8367C_BC_STORM_EXT_METERIDX_MASK, meter);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterExtBroadcastMeter
+ * Description:
+ *      get extension broadcast storm filter meter
+ * Input:
+ *      None
+ * Output:
+ *      pMeter  - meter index (0~31)
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterExtBroadcastMeter(rtk_uint32 *pMeter)
+{
+    if(NULL == pMeter)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG0, RTL8367C_BC_STORM_EXT_METERIDX_MASK, pMeter);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterExtMulticastMeter
+ * Description:
+ *      Set extension multicast storm filter meter
+ * Input:
+ *      meter   - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterExtMulticastMeter(rtk_uint32 meter)
+{
+    if(meter > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG0, RTL8367C_MC_STORM_EXT_METERIDX_MASK, meter);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterExtMulticastMeter
+ * Description:
+ *      get extension multicast storm filter meter
+ * Input:
+ *      None
+ * Output:
+ *      pMeter  - meter index (0~31)
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterExtMulticastMeter(rtk_uint32 *pMeter)
+{
+    if(NULL == pMeter)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG0, RTL8367C_MC_STORM_EXT_METERIDX_MASK, pMeter);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterExtUnknownMulticastMeter
+ * Description:
+ *      Set extension unknown multicast storm filter meter
+ * Input:
+ *      meter   - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterExtUnknownMulticastMeter(rtk_uint32 meter)
+{
+    if(meter > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG1, RTL8367C_UNMC_STORM_EXT_METERIDX_MASK, meter);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterExtUnknownMulticastMeter
+ * Description:
+ *      get extension unknown multicast storm filter meter
+ * Input:
+ *      None
+ * Output:
+ *      pMeter  - meter index (0~31)
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterExtUnknownMulticastMeter(rtk_uint32 *pMeter)
+{
+    if(NULL == pMeter)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG1, RTL8367C_UNMC_STORM_EXT_METERIDX_MASK, pMeter);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterExtUnknownUnicastMeter
+ * Description:
+ *      Set extension unknown unicast storm filter meter
+ * Input:
+ *      meter   - meter index (0~31)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterExtUnknownUnicastMeter(rtk_uint32 meter)
+{
+    if(meter > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG1, RTL8367C_UNUC_STORM_EXT_METERIDX_MASK, meter);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterExtUnknownUnicastMeter
+ * Description:
+ *      get extension unknown unicast storm filter meter
+ * Input:
+ *      None
+ * Output:
+ *      pMeter  - meter index (0~31)
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Invalid meter index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterExtUnknownUnicastMeter(rtk_uint32 *pMeter)
+{
+    if(NULL == pMeter)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_MTRIDX_CFG1, RTL8367C_UNUC_STORM_EXT_METERIDX_MASK, pMeter);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterExtBroadcastEnable
+ * Description:
+ *      Set extension broadcast storm filter state
+ * Input:
+ *      enabled     - state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterExtBroadcastEnable(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_BCAST_EXT_EN_OFFSET, enabled);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterExtBroadcastEnable
+ * Description:
+ *      Get extension broadcast storm filter state
+ * Input:
+ *      None
+ * Output:
+ *      pEnabled    - state
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Null pointer
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterExtBroadcastEnable(rtk_uint32 *pEnabled)
+{
+    if(NULL == pEnabled)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_BCAST_EXT_EN_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterExtMulticastEnable
+ * Description:
+ *      Set extension multicast storm filter state
+ * Input:
+ *      enabled     - state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterExtMulticastEnable(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_MCAST_EXT_EN_OFFSET, enabled);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterExtMulticastEnable
+ * Description:
+ *      Get extension multicast storm filter state
+ * Input:
+ *      None
+ * Output:
+ *      pEnabled    - state
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Null pointer
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterExtMulticastEnable(rtk_uint32 *pEnabled)
+{
+    if(NULL == pEnabled)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_MCAST_EXT_EN_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterExtUnknownMulticastEnable
+ * Description:
+ *      Set extension unknown multicast storm filter state
+ * Input:
+ *      enabled     - state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterExtUnknownMulticastEnable(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_UNKNOWN_MCAST_EXT_EN_OFFSET, enabled);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterExtUnknownMulticastEnable
+ * Description:
+ *      Get extension unknown multicast storm filter state
+ * Input:
+ *      None
+ * Output:
+ *      pEnabled    - state
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Null pointer
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterExtUnknownMulticastEnable(rtk_uint32 *pEnabled)
+{
+    if(NULL == pEnabled)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_UNKNOWN_MCAST_EXT_EN_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterExtUnknownUnicastEnable
+ * Description:
+ *      Set extension unknown unicast storm filter state
+ * Input:
+ *      enabled     - state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterExtUnknownUnicastEnable(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_UNKNOWN_UCAST_EXT_EN_OFFSET, enabled);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterExtUnknownUnicastEnable
+ * Description:
+ *      Get extension unknown unicast storm filter state
+ * Input:
+ *      None
+ * Output:
+ *      pEnabled    - state
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Null pointer
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterExtUnknownUnicastEnable(rtk_uint32 *pEnabled)
+{
+    if(NULL == pEnabled)
+        return RT_ERR_NULL_POINTER;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_UNKNOWN_UCAST_EXT_EN_OFFSET, pEnabled);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicStormFilterExtEnablePortMask
+ * Description:
+ *      Set extension storm filter port mask
+ * Input:
+ *      portmask    - port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicStormFilterExtEnablePortMask(rtk_uint32 portmask)
+{
+    ret_t retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_EXT_EN_PORTMASK_MASK, portmask & 0x3FF);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_EXT_EN_PORTMASK_EXT_MASK, (portmask >> 10)&1);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicStormFilterExtEnablePortMask
+ * Description:
+ *      Get extension storm filter port mask
+ * Input:
+ *      portmask    - port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_NULL_POINTER     - Null pointer
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicStormFilterExtEnablePortMask(rtk_uint32 *pPortmask)
+{
+    rtk_uint32 tmpPmsk;
+    ret_t retVal;
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_EXT_EN_PORTMASK_MASK, &tmpPmsk);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    *pPortmask = tmpPmsk & 0x3ff;
+
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_STORM_EXT_CFG, RTL8367C_STORM_EXT_EN_PORTMASK_EXT_MASK, &tmpPmsk);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+    *pPortmask |= (tmpPmsk & 1) << 10;
+
+    return RT_ERR_OK;
+}
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_svlan.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_svlan.c
new file mode 100644
index 0000000000000..f19ceba5a994f
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_svlan.c
@@ -0,0 +1,1003 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : SVLAN related functions
+ *
+ */
+#include <rtl8367c_asicdrv_svlan.h>
+
+#include <string.h>
+
+static void _rtl8367c_svlanConfStUser2Smi( rtl8367c_svlan_memconf_t *pUserSt, rtk_uint16 *pSmiSt)
+{
+    pSmiSt[0] |= (pUserSt->vs_member & 0x00FF);
+    pSmiSt[0] |= (pUserSt->vs_untag & 0x00FF) << 8;
+
+    pSmiSt[1] |= (pUserSt->vs_fid_msti & 0x000F);
+    pSmiSt[1] |= (pUserSt->vs_priority & 0x0007) << 4;
+    pSmiSt[1] |= (pUserSt->vs_force_fid & 0x0001) << 7;
+
+    pSmiSt[2] |= (pUserSt->vs_svid & 0x0FFF);
+    pSmiSt[2] |= (pUserSt->vs_efiden & 0x0001) << 12;
+    pSmiSt[2] |= (pUserSt->vs_efid & 0x0007) << 13;
+
+    pSmiSt[3] |= ((pUserSt->vs_member & 0x0700) >> 8);
+    pSmiSt[3] |= ((pUserSt->vs_untag & 0x0700) >> 8) << 3;
+}
+
+static void _rtl8367c_svlanConfStSmi2User( rtl8367c_svlan_memconf_t *pUserSt, rtk_uint16 *pSmiSt)
+{
+
+    pUserSt->vs_member = (pSmiSt[0] & 0x00FF) | ((pSmiSt[3] & 0x0007) << 8);
+    pUserSt->vs_untag = ((pSmiSt[0] & 0xFF00) >> 8) | (((pSmiSt[3] & 0x0038) >> 3) << 8);
+
+    pUserSt->vs_fid_msti = (pSmiSt[1] & 0x000F);
+    pUserSt->vs_priority = (pSmiSt[1] & 0x0070) >> 4;
+    pUserSt->vs_force_fid = (pSmiSt[1] & 0x0080) >> 7;
+
+    pUserSt->vs_svid = (pSmiSt[2] & 0x0FFF);
+    pUserSt->vs_efiden = (pSmiSt[2] & 0x1000) >> 12;
+    pUserSt->vs_efid = (pSmiSt[2] & 0xE000) >> 13;
+}
+
+static void _rtl8367c_svlanMc2sStUser2Smi(rtl8367c_svlan_mc2s_t *pUserSt, rtk_uint16 *pSmiSt)
+{
+    pSmiSt[0] |= (pUserSt->svidx & 0x003F);
+    pSmiSt[0] |= (pUserSt->format & 0x0001) << 6;
+    pSmiSt[0] |= (pUserSt->valid & 0x0001) << 7;
+
+    pSmiSt[1] = (rtk_uint16)(pUserSt->smask & 0x0000FFFF);
+    pSmiSt[2] = (rtk_uint16)((pUserSt->smask & 0xFFFF0000) >> 16);
+
+    pSmiSt[3] = (rtk_uint16)(pUserSt->sdata & 0x0000FFFF);
+    pSmiSt[4] = (rtk_uint16)((pUserSt->sdata & 0xFFFF0000) >> 16);
+}
+
+static void _rtl8367c_svlanMc2sStSmi2User(rtl8367c_svlan_mc2s_t *pUserSt, rtk_uint16 *pSmiSt)
+{
+    pUserSt->svidx = (pSmiSt[0] & 0x003F);
+    pUserSt->format = (pSmiSt[0] & 0x0040) >> 6;
+    pUserSt->valid = (pSmiSt[0] & 0x0080) >> 7;
+
+    pUserSt->smask = pSmiSt[1] | (pSmiSt[2] << 16);
+    pUserSt->sdata = pSmiSt[3] | (pSmiSt[4] << 16);
+}
+
+static void _rtl8367c_svlanSp2cStUser2Smi(rtl8367c_svlan_s2c_t *pUserSt, rtk_uint16 *pSmiSt)
+{
+    pSmiSt[0] |= (pUserSt->dstport & 0x0007);
+    pSmiSt[0] |= (pUserSt->svidx & 0x003F) << 3;
+    pSmiSt[0] |= ((pUserSt->dstport & 0x0008) >> 3) << 9;
+
+    pSmiSt[1] |= (pUserSt->vid & 0x0FFF);
+    pSmiSt[1] |= (pUserSt->valid & 0x0001) << 12;
+}
+
+static void _rtl8367c_svlanSp2cStSmi2User(rtl8367c_svlan_s2c_t *pUserSt, rtk_uint16 *pSmiSt)
+{
+    pUserSt->dstport = (((pSmiSt[0] & 0x0200) >> 9) << 3) | (pSmiSt[0] & 0x0007);
+    pUserSt->svidx   = (pSmiSt[0] & 0x01F8) >> 3;
+    pUserSt->vid     = (pSmiSt[1] & 0x0FFF);
+    pUserSt->valid   = (pSmiSt[1] & 0x1000) >> 12;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicSvlanUplinkPortMask
+ * Description:
+ *      Set uplink ports mask
+ * Input:
+ *      portMask    - Uplink port mask setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanUplinkPortMask(rtk_uint32 portMask)
+{
+    return rtl8367c_setAsicReg(RTL8367C_REG_SVLAN_UPLINK_PORTMASK, portMask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanUplinkPortMask
+ * Description:
+ *      Get uplink ports mask
+ * Input:
+ *      pPortmask   - Uplink port mask setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanUplinkPortMask(rtk_uint32* pPortmask)
+{
+    return rtl8367c_getAsicReg(RTL8367C_REG_SVLAN_UPLINK_PORTMASK, pPortmask);
+}
+/* Function Name:
+ *      rtl8367c_setAsicSvlanTpid
+ * Description:
+ *      Set accepted S-VLAN ether type. The default ether type of S-VLAN is 0x88a8
+ * Input:
+ *      protocolType    - Ether type of S-tag frame parsing in uplink ports
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      Ether type of S-tag in 802.1ad is 0x88a8 and there are existed ether type 0x9100 and 0x9200
+ *      for Q-in-Q SLAN design. User can set mathced ether type as service provider supported protocol
+ */
+ret_t rtl8367c_setAsicSvlanTpid(rtk_uint32 protocolType)
+{
+    return rtl8367c_setAsicReg(RTL8367C_REG_VS_TPID, protocolType);
+}
+/* Function Name:
+ *      rtl8367c_getAsicReg
+ * Description:
+ *      Get accepted S-VLAN ether type. The default ether type of S-VLAN is 0x88a8
+ * Input:
+ *      pProtocolType   - Ether type of S-tag frame parsing in uplink ports
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanTpid(rtk_uint32* pProtocolType)
+{
+    return rtl8367c_getAsicReg(RTL8367C_REG_VS_TPID, pProtocolType);
+}
+/* Function Name:
+ *      rtl8367c_setAsicSvlanPrioritySel
+ * Description:
+ *      Set SVLAN priority field setting
+ * Input:
+ *      priSel  - S-priority assignment method, 0:internal priority 1:C-tag priority 2:using Svlan member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Invalid input parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanPrioritySel(rtk_uint32 priSel)
+{
+    if(priSel >= SPRISEL_END)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_SPRISEL_MASK, priSel);
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanPrioritySel
+ * Description:
+ *      Get SVLAN priority field setting
+ * Input:
+ *      pPriSel     - S-priority assignment method, 0:internal priority 1:C-tag priority 2:using Svlan member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanPrioritySel(rtk_uint32* pPriSel)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_SPRISEL_MASK, pPriSel);
+}
+/* Function Name:
+ *      rtl8367c_setAsicSvlanTrapPriority
+ * Description:
+ *      Set trap to CPU priority assignment
+ * Input:
+ *      priority    - Priority assignment
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanTrapPriority(rtk_uint32 priority)
+{
+    if(priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_SVLAN_PRIOIRTY_MASK, priority);
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanTrapPriority
+ * Description:
+ *      Get trap to CPU priority assignment
+ * Input:
+ *      pPriority   - Priority assignment
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanTrapPriority(rtk_uint32* pPriority)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_QOS_TRAP_PRIORITY0, RTL8367C_SVLAN_PRIOIRTY_MASK, pPriority);
+}
+/* Function Name:
+ *      rtl8367c_setAsicSvlanDefaultVlan
+ * Description:
+ *      Set default egress SVLAN
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      index   - index SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number
+ *      RT_ERR_SVLAN_ENTRY_INDEX    - Invalid SVLAN index parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanDefaultVlan(rtk_uint32 port, rtk_uint32 index)
+{
+    ret_t retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(index > RTL8367C_SVIDXMAX)
+        return RT_ERR_SVLAN_ENTRY_INDEX;
+
+    if(port < 8){
+        if(port & 1)
+            retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL0 + (port >> 1), RTL8367C_VS_PORT1_SVIDX_MASK,index);
+        else
+            retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL0 + (port >> 1), RTL8367C_VS_PORT0_SVIDX_MASK,index);
+    }else{
+        switch(port){
+            case 8:
+                retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL4, RTL8367C_VS_PORT8_SVIDX_MASK,index);
+                break;
+
+            case 9:
+                retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL4, RTL8367C_VS_PORT9_SVIDX_MASK,index);
+                break;
+
+            case 10:
+                retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL5, RTL8367C_SVLAN_PORTBASED_SVIDX_CTRL5_MASK,index);
+                break;
+        }
+    }
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanDefaultVlan
+ * Description:
+ *      Get default egress SVLAN
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pIndex  - index SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanDefaultVlan(rtk_uint32 port, rtk_uint32* pIndex)
+{
+    ret_t retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8){
+        if(port & 1)
+            retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL0 + (port >> 1), RTL8367C_VS_PORT1_SVIDX_MASK,pIndex);
+        else
+            retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL0 + (port >> 1), RTL8367C_VS_PORT0_SVIDX_MASK,pIndex);
+    }else{
+        switch(port){
+            case 8:
+                retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL4, RTL8367C_VS_PORT8_SVIDX_MASK,pIndex);
+                break;
+
+            case 9:
+                retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL4, RTL8367C_VS_PORT9_SVIDX_MASK,pIndex);
+                break;
+
+            case 10:
+                retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_PORTBASED_SVIDX_CTRL5, RTL8367C_SVLAN_PORTBASED_SVIDX_CTRL5_MASK,pIndex);
+                break;
+        }
+    }
+
+    return retVal;
+
+}
+/* Function Name:
+ *      rtl8367c_setAsicSvlanIngressUntag
+ * Description:
+ *      Set action received un-Stag frame from unplink port
+ * Input:
+ *      mode        - 0:Drop 1:Trap 2:Assign SVLAN
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanIngressUntag(rtk_uint32 mode)
+{
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UNTAG_MASK, mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanIngressUntag
+ * Description:
+ *      Get action received un-Stag frame from unplink port
+ * Input:
+ *      pMode       - 0:Drop 1:Trap 2:Assign SVLAN
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanIngressUntag(rtk_uint32* pMode)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UNTAG_MASK, pMode);
+}
+/* Function Name:
+ *      rtl8367c_setAsicSvlanIngressUnmatch
+ * Description:
+ *      Set action received unmatched Stag frame from unplink port
+ * Input:
+ *      mode        - 0:Drop 1:Trap 2:Assign SVLAN
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanIngressUnmatch(rtk_uint32 mode)
+{
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UNMAT_MASK, mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanIngressUnmatch
+ * Description:
+ *      Get action received unmatched Stag frame from unplink port
+ * Input:
+ *      pMode       - 0:Drop 1:Trap 2:Assign SVLAN
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanIngressUnmatch(rtk_uint32* pMode)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UNMAT_MASK, pMode);
+
+}
+/* Function Name:
+ *      rtl8367c_setAsicSvlanEgressUnassign
+ * Description:
+ *      Set unplink stream without egress SVID action
+ * Input:
+ *      enabled     - 1:Trap egress unassigned frames to CPU, 0: Use SVLAN setup in VS_CPSVIDX as egress SVID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanEgressUnassign(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UIFSEG_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanEgressUnassign
+ * Description:
+ *      Get unplink stream without egress SVID action
+ * Input:
+ *      pEnabled    - 1:Trap egress unassigned frames to CPU, 0: Use SVLAN setup in VS_CPSVIDX as egress SVID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanEgressUnassign(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_UIFSEG_OFFSET, pEnabled);
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicSvlanMemberConfiguration
+ * Description:
+ *      Set system 64 S-tag content
+ * Input:
+ *      index           - index of 64 s-tag configuration
+ *      pSvlanMemCfg    - SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_SVLAN_ENTRY_INDEX    - Invalid SVLAN index parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanMemberConfiguration(rtk_uint32 index, rtl8367c_svlan_memconf_t* pSvlanMemCfg)
+{
+    ret_t retVal;
+    rtk_uint32 regAddr, regData;
+    rtk_uint16 *accessPtr;
+    rtk_uint32 i;
+    rtk_uint16 smiSvlanMemConf[RTL8367C_SVLAN_MEMCONF_LEN];
+
+    if(index > RTL8367C_SVIDXMAX)
+        return RT_ERR_SVLAN_ENTRY_INDEX;
+
+    memset(smiSvlanMemConf, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_MEMCONF_LEN);
+    _rtl8367c_svlanConfStUser2Smi(pSvlanMemCfg, smiSvlanMemConf);
+
+    accessPtr = smiSvlanMemConf;
+
+    regData = *accessPtr;
+    for(i = 0; i < 3; i++)
+    {
+        retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_MEMBERCFG_BASE_REG(index) + i, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        accessPtr ++;
+        regData = *accessPtr;
+    }
+
+    if(index < 63)
+        regAddr = RTL8367C_REG_SVLAN_MEMBERCFG0_CTRL4+index;
+    else if(index == 63)
+        regAddr = RTL8367C_REG_SVLAN_MEMBERCFG63_CTRL4;
+
+    retVal = rtl8367c_setAsicReg(regAddr, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanMemberConfiguration
+ * Description:
+ *      Get system 64 S-tag content
+ * Input:
+ *      index           - index of 64 s-tag configuration
+ *      pSvlanMemCfg    - SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_SVLAN_ENTRY_INDEX    - Invalid SVLAN index parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanMemberConfiguration(rtk_uint32 index,rtl8367c_svlan_memconf_t* pSvlanMemCfg)
+{
+    ret_t retVal;
+    rtk_uint32 regAddr,regData;
+    rtk_uint16 *accessPtr;
+    rtk_uint32 i;
+    rtk_uint16 smiSvlanMemConf[RTL8367C_SVLAN_MEMCONF_LEN];
+
+    if(index > RTL8367C_SVIDXMAX)
+        return RT_ERR_SVLAN_ENTRY_INDEX;
+
+    memset(smiSvlanMemConf, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_MEMCONF_LEN);
+
+    accessPtr = smiSvlanMemConf;
+
+    for(i = 0; i < 3; i++)
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_MEMBERCFG_BASE_REG(index) + i, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *accessPtr = regData;
+
+        accessPtr ++;
+    }
+
+    if(index < 63)
+        regAddr = RTL8367C_REG_SVLAN_MEMBERCFG0_CTRL4+index;
+    else if(index == 63)
+        regAddr = RTL8367C_REG_SVLAN_MEMBERCFG63_CTRL4;
+
+    retVal = rtl8367c_getAsicReg(regAddr, &regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    *accessPtr = regData;
+
+    _rtl8367c_svlanConfStSmi2User(pSvlanMemCfg, smiSvlanMemConf);
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicSvlanC2SConf
+ * Description:
+ *      Set SVLAN C2S table
+ * Input:
+ *      index   - index of 128 Svlan C2S configuration
+ *      evid    - Enhanced VID
+ *      portmask    - available c2s port mask
+ *      svidx   - index of 64 Svlan member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENTRY_INDEX  - Invalid entry index
+ * Note:
+ *      ASIC will check upstream's VID and assign related SVID to mathed packet
+ */
+ret_t rtl8367c_setAsicSvlanC2SConf(rtk_uint32 index, rtk_uint32 evid, rtk_uint32 portmask, rtk_uint32 svidx)
+{
+    ret_t retVal;
+
+    if(index > RTL8367C_C2SIDXMAX)
+        return RT_ERR_ENTRY_INDEX;
+
+    retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index), svidx);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index) + 1, portmask);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index) + 2, evid);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanC2SConf
+ * Description:
+ *      Get SVLAN C2S table
+ * Input:
+ *      index   - index of 128 Svlan C2S configuration
+ *      pEvid   - Enhanced VID
+ *      pPortmask   - available c2s port mask
+ *      pSvidx  - index of 64 Svlan member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENTRY_INDEX  - Invalid entry index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanC2SConf(rtk_uint32 index, rtk_uint32* pEvid, rtk_uint32* pPortmask, rtk_uint32* pSvidx)
+{
+    ret_t retVal;
+
+    if(index > RTL8367C_C2SIDXMAX)
+        return RT_ERR_ENTRY_INDEX;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index), pSvidx);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index) + 1, pPortmask);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_C2SCFG_BASE_REG(index) + 2, pEvid);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicSvlanMC2SConf
+ * Description:
+ *      Set system MC2S content
+ * Input:
+ *      index           - index of 32 SVLAN 32 MC2S configuration
+ *      pSvlanMc2sCfg   - SVLAN Multicast to SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENTRY_INDEX  - Invalid entry index
+ * Note:
+ *      If upstream packet is L2 multicast or IPv4 multicast packet and DMAC/DIP is matched MC2S
+ *      configuration, ASIC will assign egress SVID to the packet
+ */
+ret_t rtl8367c_setAsicSvlanMC2SConf(rtk_uint32 index,rtl8367c_svlan_mc2s_t* pSvlanMc2sCfg)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint16 *accessPtr;
+    rtk_uint32 i;
+    rtk_uint16 smiSvlanMC2S[RTL8367C_SVLAN_MC2S_LEN];
+
+    if(index > RTL8367C_MC2SIDXMAX)
+        return RT_ERR_ENTRY_INDEX;
+
+    memset(smiSvlanMC2S, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_MC2S_LEN);
+    _rtl8367c_svlanMc2sStUser2Smi(pSvlanMc2sCfg, smiSvlanMC2S);
+
+    accessPtr = smiSvlanMC2S;
+
+    regData = *accessPtr;
+    for(i = 0; i < 5; i++)
+    {
+        retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_MCAST2S_ENTRY_BASE_REG(index) + i, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        accessPtr ++;
+        regData = *accessPtr;
+    }
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanMC2SConf
+ * Description:
+ *      Get system MC2S content
+ * Input:
+ *      index           - index of 32 SVLAN 32 MC2S configuration
+ *      pSvlanMc2sCfg   - SVLAN Multicast to SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENTRY_INDEX  - Invalid entry index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanMC2SConf(rtk_uint32 index, rtl8367c_svlan_mc2s_t* pSvlanMc2sCfg)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint16 *accessPtr;
+    rtk_uint32 i;
+    rtk_uint16 smiSvlanMC2S[RTL8367C_SVLAN_MC2S_LEN];
+
+    if(index > RTL8367C_MC2SIDXMAX)
+        return RT_ERR_ENTRY_INDEX;
+
+    memset(smiSvlanMC2S, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_MC2S_LEN);
+
+    accessPtr = smiSvlanMC2S;
+
+    for(i = 0; i < 5; i++)
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_MCAST2S_ENTRY_BASE_REG(index) + i, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *accessPtr = regData;
+        accessPtr ++;
+    }
+
+
+    _rtl8367c_svlanMc2sStSmi2User(pSvlanMc2sCfg, smiSvlanMC2S);
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicSvlanSP2CConf
+ * Description:
+ *      Set system 128 SP2C content
+ * Input:
+ *      index           - index of 128 SVLAN & Port to CVLAN configuration
+ *      pSvlanSp2cCfg   - SVLAN & Port to CVLAN configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENTRY_INDEX  - Invalid entry index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanSP2CConf(rtk_uint32 index, rtl8367c_svlan_s2c_t* pSvlanSp2cCfg)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint16 *accessPtr;
+    rtk_uint32 i;
+    rtk_uint16 smiSvlanSP2C[RTL8367C_SVLAN_SP2C_LEN];
+
+    if(index > RTL8367C_SP2CMAX)
+        return RT_ERR_ENTRY_INDEX;
+
+    memset(smiSvlanSP2C, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_SP2C_LEN);
+    _rtl8367c_svlanSp2cStUser2Smi(pSvlanSp2cCfg,smiSvlanSP2C);
+
+    accessPtr = smiSvlanSP2C;
+
+    regData = *accessPtr;
+    for(i = 0; i < 2; i++)
+    {
+        retVal = rtl8367c_setAsicReg(RTL8367C_SVLAN_S2C_ENTRY_BASE_REG(index) + i, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        accessPtr ++;
+        regData = *accessPtr;
+    }
+
+    return retVal;
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanSP2CConf
+ * Description:
+ *      Get system 128 SP2C content
+ * Input:
+ *      index           - index of 128 SVLAN & Port to CVLAN configuration
+ *      pSvlanSp2cCfg   - SVLAN & Port to CVLAN configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENTRY_INDEX  - Invalid entry index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanSP2CConf(rtk_uint32 index,rtl8367c_svlan_s2c_t* pSvlanSp2cCfg)
+{
+    ret_t retVal;
+    rtk_uint32 regData;
+    rtk_uint16 *accessPtr;
+    rtk_uint32 i;
+    rtk_uint16 smiSvlanSP2C[RTL8367C_SVLAN_SP2C_LEN];
+
+    if(index > RTL8367C_SP2CMAX)
+        return RT_ERR_ENTRY_INDEX;
+
+    memset(smiSvlanSP2C, 0x00, sizeof(rtk_uint16) * RTL8367C_SVLAN_SP2C_LEN);
+
+    accessPtr = smiSvlanSP2C;
+
+    for(i = 0; i < 2; i++)
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_SVLAN_S2C_ENTRY_BASE_REG(index) + i, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *accessPtr = regData;
+
+        accessPtr ++;
+    }
+
+    _rtl8367c_svlanSp2cStSmi2User(pSvlanSp2cCfg, smiSvlanSP2C);
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicSvlanDmacCvidSel
+ * Description:
+ *      Set downstream CVID decision by DMAC
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      enabled     - 0:disabled, 1:enabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanDmacCvidSel(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+        return rtl8367c_setAsicRegBit(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_PORT0_DMACVIDSEL_OFFSET + port, enabled);
+    else
+        return rtl8367c_setAsicRegBit(RTL8367C_REG_SVLAN_CFG_EXT, RTL8367C_VS_PORT8_DMACVIDSEL_OFFSET + (port-8), enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanDmacCvidSel
+ * Description:
+ *      Get downstream CVID decision by DMAC
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      pEnabled    - 0:disabled, 1:enabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanDmacCvidSel(rtk_uint32 port, rtk_uint32* pEnabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+        return rtl8367c_getAsicRegBit(RTL8367C_REG_SVLAN_CFG, RTL8367C_VS_PORT0_DMACVIDSEL_OFFSET + port, pEnabled);
+    else
+        return rtl8367c_getAsicRegBit(RTL8367C_REG_SVLAN_CFG_EXT, RTL8367C_VS_PORT8_DMACVIDSEL_OFFSET + (port-8), pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicSvlanUntagVlan
+ * Description:
+ *      Set default ingress untag SVLAN
+ * Input:
+ *      index   - index SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_SVLAN_ENTRY_INDEX    - Invalid SVLAN index parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanUntagVlan(rtk_uint32 index)
+{
+    if(index > RTL8367C_SVIDXMAX)
+        return RT_ERR_SVLAN_ENTRY_INDEX;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_UNTAG_UNMAT_CFG, RTL8367C_VS_UNTAG_SVIDX_MASK, index);
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanUntagVlan
+ * Description:
+ *      Get default ingress untag SVLAN
+ * Input:
+ *      pIndex  - index SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanUntagVlan(rtk_uint32* pIndex)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_UNTAG_UNMAT_CFG, RTL8367C_VS_UNTAG_SVIDX_MASK, pIndex);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicSvlanUnmatchVlan
+ * Description:
+ *      Set default ingress unmatch SVLAN
+ * Input:
+ *      index   - index SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_SVLAN_ENTRY_INDEX    - Invalid SVLAN index parameter
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanUnmatchVlan(rtk_uint32 index)
+{
+    if(index > RTL8367C_SVIDXMAX)
+        return RT_ERR_SVLAN_ENTRY_INDEX;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_SVLAN_UNTAG_UNMAT_CFG, RTL8367C_VS_UNMAT_SVIDX_MASK, index);
+}
+/* Function Name:
+ *      rtl8367c_getAsicSvlanUnmatchVlan
+ * Description:
+ *      Get default ingress unmatch SVLAN
+ * Input:
+ *      pIndex  - index SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanUnmatchVlan(rtk_uint32* pIndex)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_SVLAN_UNTAG_UNMAT_CFG, RTL8367C_VS_UNMAT_SVIDX_MASK, pIndex);
+}
+
+
+/* Function Name:
+ *      rtl8367c_setAsicSvlanLookupType
+ * Description:
+ *      Set svlan lookup table selection
+ * Input:
+ *      type    - lookup type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSvlanLookupType(rtk_uint32 type)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_SVLAN_LOOKUP_TYPE, RTL8367C_SVLAN_LOOKUP_TYPE_OFFSET, type);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicSvlanLookupType
+ * Description:
+ *      Get svlan lookup table selection
+ * Input:
+ *      pType   - lookup type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSvlanLookupType(rtk_uint32* pType)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_SVLAN_LOOKUP_TYPE, RTL8367C_SVLAN_LOOKUP_TYPE_OFFSET, pType);
+}
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_trunking.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_trunking.c
new file mode 100644
index 0000000000000..26d4c29b83b98
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_trunking.c
@@ -0,0 +1,356 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Port trunking related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_trunking.h>
+/* Function Name:
+ *      rtl8367c_setAsicTrunkingMode
+ * Description:
+ *      Set port trunking mode
+ * Input:
+ *      mode    - 1:dumb 0:user defined
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicTrunkingMode(rtk_uint32 mode)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_DUMB_OFFSET, mode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicTrunkingMode
+ * Description:
+ *      Get port trunking mode
+ * Input:
+ *      pMode   - 1:dumb 0:user defined
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicTrunkingMode(rtk_uint32* pMode)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_DUMB_OFFSET, pMode);
+}
+/* Function Name:
+ *      rtl8367c_setAsicTrunkingFc
+ * Description:
+ *      Set port trunking flow control
+ * Input:
+ *      group       - Trunk Group ID
+ *      enabled     - 0:disable, 1:enable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicTrunkingFc(rtk_uint32 group, rtk_uint32 enabled)
+{
+    ret_t       retVal;
+
+    if(group > RTL8367C_MAX_TRUNK_GID)
+        return RT_ERR_LA_TRUNK_ID;
+
+    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_PORT_TRUNK_DROP_CTRL, RTL8367C_PORT_TRUNK_DROP_CTRL_OFFSET, ENABLED)) != RT_ERR_OK)
+        return retVal;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_PORT_TRUNK_FLOWCTRL, (RTL8367C_EN_FLOWCTRL_TG0_OFFSET + group), enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicTrunkingFc
+ * Description:
+ *      Get port trunking flow control
+ * Input:
+ *      group       - Trunk Group ID
+ *      pEnabled    - 0:disable, 1:enable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicTrunkingFc(rtk_uint32 group, rtk_uint32* pEnabled)
+{
+    if(group > RTL8367C_MAX_TRUNK_GID)
+        return RT_ERR_LA_TRUNK_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_PORT_TRUNK_FLOWCTRL, (RTL8367C_EN_FLOWCTRL_TG0_OFFSET + group), pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicTrunkingGroup
+ * Description:
+ *      Set trunking group available port mask
+ * Input:
+ *      group       - Trunk Group ID
+ *      portmask    - Logic trunking enable port mask, max 4 ports
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicTrunkingGroup(rtk_uint32 group, rtk_uint32 portmask)
+{
+    if(group > RTL8367C_MAX_TRUNK_GID)
+        return RT_ERR_LA_TRUNK_ID;
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_GROUP_MASK, RTL8367C_PORT_TRUNK_GROUP0_MASK_MASK << (group * 4), portmask);
+}
+/* Function Name:
+ *      rtl8367c_getAsicTrunkingGroup
+ * Description:
+ *      Get trunking group available port mask
+ * Input:
+ *      group       - Trunk Group ID
+ * Output:
+ *      pPortmask   - Logic trunking enable port mask, max 4 ports
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicTrunkingGroup(rtk_uint32 group, rtk_uint32* pPortmask)
+{
+    if(group > RTL8367C_MAX_TRUNK_GID)
+        return RT_ERR_LA_TRUNK_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_GROUP_MASK, RTL8367C_PORT_TRUNK_GROUP0_MASK_MASK << (group * 4), pPortmask);
+}
+/* Function Name:
+ *      rtl8367c_setAsicTrunkingFlood
+ * Description:
+ *      Set port trunking flood function
+ * Input:
+ *      enabled     - Port trunking flooding function 0:disable 1:enable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicTrunkingFlood(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_FLOOD_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicTrunkingFlood
+ * Description:
+ *      Get port trunking flood function
+ * Input:
+ *      pEnabled    - Port trunking flooding function 0:disable 1:enable
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicTrunkingFlood(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_FLOOD_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicTrunkingHashSelect
+ * Description:
+ *      Set port trunking hash select sources
+ * Input:
+ *      hashsel     - hash sources mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      7 bits mask for link aggregation group0 hash parameter selection {DIP, SIP, DMAC, SMAC, SPA}
+ *      0b0000001: SPA
+ *      0b0000010: SMAC
+ *      0b0000100: DMAC
+ *      0b0001000: SIP
+ *      0b0010000: DIP
+ *      0b0100000: TCP/UDP Source Port
+ *      0b1000000: TCP/UDP Destination Port
+ */
+ret_t rtl8367c_setAsicTrunkingHashSelect(rtk_uint32 hashsel)
+{
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_HASH_MASK, hashsel);
+}
+/* Function Name:
+ *      rtl8367c_getAsicTrunkingHashSelect
+ * Description:
+ *      Get port trunking hash select sources
+ * Input:
+ *      pHashsel    - hash sources mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicTrunkingHashSelect(rtk_uint32* pHashsel)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_CTRL, RTL8367C_PORT_TRUNK_HASH_MASK, pHashsel);
+}
+/* Function Name:
+ *      rtl8367c_getAsicQeueuEmptyStatus
+ * Description:
+ *      Get current output queue if empty status
+ * Input:
+ *      portmask    - queue empty port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicQeueuEmptyStatus(rtk_uint32* portmask)
+{
+    return rtl8367c_getAsicReg(RTL8367C_REG_PORT_QEMPTY, portmask);
+}
+/* Function Name:
+ *      rtl8367c_setAsicTrunkingHashTable
+ * Description:
+ *      Set port trunking hash value mapping table
+ * Input:
+ *      hashval     - hashing value 0-15
+ *      portId      - trunking port id 0-3
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_OUT_OF_RANGE - Invalid hashing value (0-15)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicTrunkingHashTable(rtk_uint32 hashval, rtk_uint32 portId)
+{
+    if(hashval > RTL8367C_TRUNKING_HASHVALUE_MAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(portId >= RTL8367C_TRUNKING_PORTNO)
+        return RT_ERR_PORT_ID;
+
+    if(hashval >= 8)
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL1, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH8_MASK<<((hashval-8)*2), portId);
+    else
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL0, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH0_MASK<<(hashval*2), portId);
+}
+/* Function Name:
+ *      rtl8367c_getAsicTrunkingHashTable
+ * Description:
+ *      Get port trunking hash value mapping table
+ * Input:
+ *      hashval     - hashing value 0-15
+ *      pPortId         - trunking port id 0-3
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - Invalid hashing value (0-15)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicTrunkingHashTable(rtk_uint32 hashval, rtk_uint32* pPortId)
+{
+    if(hashval > RTL8367C_TRUNKING_HASHVALUE_MAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(hashval >= 8)
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL1, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL1_HASH8_MASK<<((hashval-8)*2), pPortId);
+    else
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL0, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL0_HASH0_MASK<<(hashval*2), pPortId);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicTrunkingHashTable1
+ * Description:
+ *      Set port trunking hash value mapping table
+ * Input:
+ *      hashval     - hashing value 0-15
+ *      portId      - trunking port id 0-3
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_OUT_OF_RANGE - Invalid hashing value (0-15)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicTrunkingHashTable1(rtk_uint32 hashval, rtk_uint32 portId)
+{
+    if(hashval > RTL8367C_TRUNKING_HASHVALUE_MAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(portId >= RTL8367C_TRUNKING1_PORTN0)
+        return RT_ERR_PORT_ID;
+
+    if(hashval >= 8)
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL3, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH8_MASK<<((hashval-8)*2), portId);
+    else
+        return rtl8367c_setAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL2, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH0_MASK<<(hashval*2), portId);
+}
+/* Function Name:
+ *      rtl8367c_getAsicTrunkingHashTable1
+ * Description:
+ *      Get port trunking hash value mapping table
+ * Input:
+ *      hashval     - hashing value 0-15
+ *      pPortId         - trunking port id 0-3
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_OUT_OF_RANGE - Invalid hashing value (0-15)
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicTrunkingHashTable1(rtk_uint32 hashval, rtk_uint32* pPortId)
+{
+    if(hashval > RTL8367C_TRUNKING_HASHVALUE_MAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(hashval >= 8)
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL3, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL3_HASH8_MASK<<((hashval-8)*2), pPortId);
+    else
+        return rtl8367c_getAsicRegBits(RTL8367C_REG_PORT_TRUNK_HASH_MAPPING_CTRL2, RTL8367C_PORT_TRUNK_HASH_MAPPING_CTRL2_HASH0_MASK<<(hashval*2), pPortId);
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_unknownMulticast.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_unknownMulticast.c
new file mode 100644
index 0000000000000..fcebd1b7f7c7d
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_unknownMulticast.c
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : Unkown multicast related functions
+ *
+ */
+
+#include <rtl8367c_asicdrv_unknownMulticast.h>
+
+/* Function Name:
+ *      rtl8367c_setAsicUnknownL2MulticastBehavior
+ * Description:
+ *      Set behavior of L2 multicast
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      behave  - 0: flooding, 1: drop, 2: trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_NOT_ALLOWED  - Invalid operation
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicUnknownL2MulticastBehavior(rtk_uint32 port, rtk_uint32 behave)
+{
+    ret_t retVal;
+
+    if(port >  RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(behave >= L2_UNKOWN_MULTICAST_END)
+        return RT_ERR_NOT_ALLOWED;
+    if(port < 8)
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_UNKNOWN_L2_MULTICAST_REG(port), RTL8367C_UNKNOWN_L2_MULTICAST_MASK(port), behave);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_UNKNOWN_L2_MULTICAST_CTRL1, 3 << ((port - 8) << 1), behave);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicUnknownL2MulticastBehavior
+ * Description:
+ *      Get behavior of L2 multicast
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pBehave     - 0: flooding, 1: drop, 2: trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicUnknownL2MulticastBehavior(rtk_uint32 port, rtk_uint32 *pBehave)
+{
+    ret_t retVal;
+
+    if(port >  RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_UNKNOWN_L2_MULTICAST_REG(port), RTL8367C_UNKNOWN_L2_MULTICAST_MASK(port), pBehave);
+        if (retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_UNKNOWN_L2_MULTICAST_CTRL1, 3 << ((port - 8) << 1), pBehave);
+        if (retVal != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicUnknownIPv4MulticastBehavior
+ * Description:
+ *      Set behavior of IPv4 multicast
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      behave  - 0: flooding, 1: drop, 2: trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_NOT_ALLOWED  - Invalid operation
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicUnknownIPv4MulticastBehavior(rtk_uint32 port, rtk_uint32 behave)
+{
+    if(port >  RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(behave >= L3_UNKOWN_MULTICAST_END)
+        return RT_ERR_NOT_ALLOWED;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_UNKNOWN_IPV4_MULTICAST_REG(port), RTL8367C_UNKNOWN_IPV4_MULTICAST_MASK(port), behave);
+}
+/* Function Name:
+ *      rtl8367c_getAsicUnknownIPv4MulticastBehavior
+ * Description:
+ *      Get behavior of IPv4 multicast
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pBehave     - 0: flooding, 1: drop, 2: trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicUnknownIPv4MulticastBehavior(rtk_uint32 port, rtk_uint32 *pBehave)
+{
+    if(port >  RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_UNKNOWN_IPV4_MULTICAST_REG(port), RTL8367C_UNKNOWN_IPV4_MULTICAST_MASK(port), pBehave);
+}
+/* Function Name:
+ *      rtl8367c_setAsicUnknownIPv6MulticastBehavior
+ * Description:
+ *      Set behavior of IPv6 multicast
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      behave  - 0: flooding, 1: drop, 2: trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_NOT_ALLOWED  - Invalid operation
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicUnknownIPv6MulticastBehavior(rtk_uint32 port, rtk_uint32 behave)
+{
+    if(port >  RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(behave >= L3_UNKOWN_MULTICAST_END)
+        return RT_ERR_NOT_ALLOWED;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_UNKNOWN_IPV6_MULTICAST_REG(port), RTL8367C_UNKNOWN_IPV6_MULTICAST_MASK(port), behave);
+}
+/* Function Name:
+ *      rtl8367c_getAsicUnknownIPv6MulticastBehavior
+ * Description:
+ *      Get behavior of IPv6 multicast
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pBehave     - 0: flooding, 1: drop, 2: trap
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicUnknownIPv6MulticastBehavior(rtk_uint32 port, rtk_uint32 *pBehave)
+{
+    if(port >  RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_UNKNOWN_IPV6_MULTICAST_REG(port), RTL8367C_UNKNOWN_IPV6_MULTICAST_MASK(port), pBehave);
+}
+/* Function Name:
+ *      rtl8367c_setAsicUnknownMulticastTrapPriority
+ * Description:
+ *      Set trap priority of unknown multicast frame
+ * Input:
+ *      priority    - priority (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_QOS_INT_PRIORITY - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicUnknownMulticastTrapPriority(rtk_uint32 priority)
+{
+    if(priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_QOS_TRAP_PRIORITY_CTRL0_REG, RTL8367C_UNKNOWN_MC_PRIORTY_MASK, priority);
+}
+/* Function Name:
+ *      rtl8367c_getAsicUnknownMulticastTrapPriority
+ * Description:
+ *      Get trap priority of unknown multicast frame
+ * Input:
+ *      pPriority   - priority (0~7)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK   - Success
+ *      RT_ERR_SMI  - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicUnknownMulticastTrapPriority(rtk_uint32 *pPriority)
+{
+    return rtl8367c_getAsicRegBits(RTL8367C_QOS_TRAP_PRIORITY_CTRL0_REG, RTL8367C_UNKNOWN_MC_PRIORTY_MASK, pPriority);
+}
diff --git a/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_vlan.c b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_vlan.c
new file mode 100644
index 0000000000000..1e283e7432c04
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/rtl8367c_asicdrv_vlan.c
@@ -0,0 +1,1505 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTL8367C switch high-level API for RTL8367C
+ * Feature : VLAN related functions
+ *
+ */
+#include <rtl8367c_asicdrv_vlan.h>
+
+#include <string.h>
+
+#if defined(CONFIG_RTL8367C_ASICDRV_TEST)
+rtl8367c_user_vlan4kentry Rtl8370sVirtualVlanTable[RTL8367C_VIDMAX + 1];
+#endif
+
+static void _rtl8367c_VlanMCStUser2Smi(rtl8367c_vlanconfiguser *pVlanCg, rtk_uint16 *pSmiVlanCfg)
+{
+    pSmiVlanCfg[0] |= pVlanCg->mbr & 0x07FF;
+
+    pSmiVlanCfg[1] |= pVlanCg->fid_msti & 0x000F;
+
+    pSmiVlanCfg[2] |= pVlanCg->vbpen & 0x0001;
+    pSmiVlanCfg[2] |= (pVlanCg->vbpri & 0x0007) << 1;
+    pSmiVlanCfg[2] |= (pVlanCg->envlanpol & 0x0001) << 4;
+    pSmiVlanCfg[2] |= (pVlanCg->meteridx & 0x003F) << 5;
+
+    pSmiVlanCfg[3] |= pVlanCg->evid & 0x1FFF;
+}
+
+static void _rtl8367c_VlanMCStSmi2User(rtk_uint16 *pSmiVlanCfg, rtl8367c_vlanconfiguser *pVlanCg)
+{
+    pVlanCg->mbr            = pSmiVlanCfg[0] & 0x07FF;
+    pVlanCg->fid_msti       = pSmiVlanCfg[1] & 0x000F;
+    pVlanCg->meteridx       = (pSmiVlanCfg[2] >> 5) & 0x003F;
+    pVlanCg->envlanpol      = (pSmiVlanCfg[2] >> 4) & 0x0001;
+    pVlanCg->vbpri          = (pSmiVlanCfg[2] >> 1) & 0x0007;
+    pVlanCg->vbpen          = pSmiVlanCfg[2] & 0x0001;
+    pVlanCg->evid           = pSmiVlanCfg[3] & 0x1FFF;
+}
+
+static void _rtl8367c_Vlan4kStUser2Smi(rtl8367c_user_vlan4kentry *pUserVlan4kEntry, rtk_uint16 *pSmiVlan4kEntry)
+{
+    pSmiVlan4kEntry[0] |= (pUserVlan4kEntry->mbr & 0x00FF);
+    pSmiVlan4kEntry[0] |= (pUserVlan4kEntry->untag & 0x00FF) << 8;
+
+    pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->fid_msti & 0x000F);
+    pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->vbpen & 0x0001) << 4;
+    pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->vbpri & 0x0007) << 5;
+    pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->envlanpol & 0x0001) << 8;
+    pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->meteridx & 0x001F) << 9;
+    pSmiVlan4kEntry[1] |= (pUserVlan4kEntry->ivl_svl & 0x0001) << 14;
+
+    pSmiVlan4kEntry[2] |= ((pUserVlan4kEntry->mbr & 0x0700) >> 8);
+    pSmiVlan4kEntry[2] |= ((pUserVlan4kEntry->untag & 0x0700) >> 8) << 3;
+    pSmiVlan4kEntry[2] |= ((pUserVlan4kEntry->meteridx & 0x0020) >> 5) << 6;
+}
+
+
+static void _rtl8367c_Vlan4kStSmi2User(rtk_uint16 *pSmiVlan4kEntry, rtl8367c_user_vlan4kentry *pUserVlan4kEntry)
+{
+    pUserVlan4kEntry->mbr = (pSmiVlan4kEntry[0] & 0x00FF) | ((pSmiVlan4kEntry[2] & 0x0007) << 8);
+    pUserVlan4kEntry->untag = ((pSmiVlan4kEntry[0] & 0xFF00) >> 8) | (((pSmiVlan4kEntry[2] & 0x0038) >> 3) << 8);
+    pUserVlan4kEntry->fid_msti = pSmiVlan4kEntry[1] & 0x000F;
+    pUserVlan4kEntry->vbpen = (pSmiVlan4kEntry[1] & 0x0010) >> 4;
+    pUserVlan4kEntry->vbpri = (pSmiVlan4kEntry[1] & 0x00E0) >> 5;
+    pUserVlan4kEntry->envlanpol = (pSmiVlan4kEntry[1] & 0x0100) >> 8;
+    pUserVlan4kEntry->meteridx = ((pSmiVlan4kEntry[1] & 0x3E00) >> 9) | (((pSmiVlan4kEntry[2] & 0x0040) >> 6) << 5);
+    pUserVlan4kEntry->ivl_svl = (pSmiVlan4kEntry[1] & 0x4000) >> 14;
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicVlanMemberConfig
+ * Description:
+ *      Set 32 VLAN member configurations
+ * Input:
+ *      index       - VLAN member configuration index (0~31)
+ *      pVlanCg - VLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_INPUT                - Invalid input parameter
+ *      RT_ERR_L2_FID               - Invalid FID
+ *      RT_ERR_PORT_MASK            - Invalid portmask
+ *      RT_ERR_FILTER_METER_ID      - Invalid meter
+ *      RT_ERR_QOS_INT_PRIORITY     - Invalid priority
+ *      RT_ERR_VLAN_ENTRY_NOT_FOUND - Invalid VLAN member configuration index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlanMemberConfig(rtk_uint32 index, rtl8367c_vlanconfiguser *pVlanCg)
+{
+    ret_t  retVal;
+    rtk_uint32 regAddr;
+    rtk_uint32 regData;
+    rtk_uint16 *tableAddr;
+    rtk_uint32 page_idx;
+    rtk_uint16 smi_vlancfg[RTL8367C_VLAN_MBRCFG_LEN];
+
+    /* Error Checking  */
+    if(index > RTL8367C_CVIDXMAX)
+        return RT_ERR_VLAN_ENTRY_NOT_FOUND;
+
+    if(pVlanCg->evid > RTL8367C_EVIDMAX)
+        return RT_ERR_INPUT;
+
+
+    if(pVlanCg->mbr > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    if(pVlanCg->fid_msti > RTL8367C_FIDMAX)
+        return RT_ERR_L2_FID;
+
+    if(pVlanCg->meteridx > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(pVlanCg->vbpri > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    memset(smi_vlancfg, 0x00, sizeof(rtk_uint16) * RTL8367C_VLAN_MBRCFG_LEN);
+    _rtl8367c_VlanMCStUser2Smi(pVlanCg, smi_vlancfg);
+    tableAddr = smi_vlancfg;
+
+    for(page_idx = 0; page_idx < 4; page_idx++)  /* 4 pages per VLAN Member Config */
+    {
+        regAddr = RTL8367C_VLAN_MEMBER_CONFIGURATION_BASE + (index * 4) + page_idx;
+        regData = *tableAddr;
+
+        retVal = rtl8367c_setAsicReg(regAddr, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        tableAddr++;
+    }
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicVlanMemberConfig
+ * Description:
+ *      Get 32 VLAN member configurations
+ * Input:
+ *      index       - VLAN member configuration index (0~31)
+ *      pVlanCg - VLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_INPUT                - Invalid input parameter
+ *      RT_ERR_VLAN_ENTRY_NOT_FOUND - Invalid VLAN member configuration index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlanMemberConfig(rtk_uint32 index, rtl8367c_vlanconfiguser *pVlanCg)
+{
+    ret_t  retVal;
+    rtk_uint32 page_idx;
+    rtk_uint32 regAddr;
+    rtk_uint32 regData;
+    rtk_uint16 *tableAddr;
+    rtk_uint16 smi_vlancfg[RTL8367C_VLAN_MBRCFG_LEN];
+
+    if(index > RTL8367C_CVIDXMAX)
+        return RT_ERR_VLAN_ENTRY_NOT_FOUND;
+
+    memset(smi_vlancfg, 0x00, sizeof(rtk_uint16) * RTL8367C_VLAN_MBRCFG_LEN);
+    tableAddr  = smi_vlancfg;
+
+    for(page_idx = 0; page_idx < 4; page_idx++)  /* 4 pages per VLAN Member Config */
+    {
+        regAddr = RTL8367C_VLAN_MEMBER_CONFIGURATION_BASE + (index * 4) + page_idx;
+
+        retVal = rtl8367c_getAsicReg(regAddr, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *tableAddr = (rtk_uint16)regData;
+        tableAddr++;
+    }
+
+    _rtl8367c_VlanMCStSmi2User(smi_vlancfg, pVlanCg);
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicVlan4kEntry
+ * Description:
+ *      Set VID mapped entry to 4K VLAN table
+ * Input:
+ *      pVlan4kEntry - 4K VLAN configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_INPUT                - Invalid input parameter
+ *      RT_ERR_L2_FID               - Invalid FID
+ *      RT_ERR_VLAN_VID             - Invalid VID parameter (0~4095)
+ *      RT_ERR_PORT_MASK            - Invalid portmask
+ *      RT_ERR_FILTER_METER_ID      - Invalid meter
+ *      RT_ERR_QOS_INT_PRIORITY     - Invalid priority
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlan4kEntry(rtl8367c_user_vlan4kentry *pVlan4kEntry )
+{
+    rtk_uint16              vlan_4k_entry[RTL8367C_VLAN_4KTABLE_LEN];
+    rtk_uint32                  page_idx;
+    rtk_uint16                  *tableAddr;
+    ret_t                   retVal;
+    rtk_uint32                  regData;
+
+    if(pVlan4kEntry->vid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    if(pVlan4kEntry->mbr > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    if(pVlan4kEntry->untag > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    if(pVlan4kEntry->fid_msti > RTL8367C_FIDMAX)
+        return RT_ERR_L2_FID;
+
+    if(pVlan4kEntry->meteridx > RTL8367C_METERMAX)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(pVlan4kEntry->vbpri > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    memset(vlan_4k_entry, 0x00, sizeof(rtk_uint16) * RTL8367C_VLAN_4KTABLE_LEN);
+    _rtl8367c_Vlan4kStUser2Smi(pVlan4kEntry, vlan_4k_entry);
+
+    /* Prepare Data */
+    tableAddr = vlan_4k_entry;
+    for(page_idx = 0; page_idx < RTL8367C_VLAN_4KTABLE_LEN; page_idx++)
+    {
+        regData = *tableAddr;
+        retVal = rtl8367c_setAsicReg(RTL8367C_TABLE_ACCESS_WRDATA_BASE + page_idx, regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        tableAddr++;
+    }
+
+    /* Write Address (VLAN_ID) */
+    regData = pVlan4kEntry->vid;
+    retVal = rtl8367c_setAsicReg(RTL8367C_TABLE_ACCESS_ADDR_REG, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Write Command */
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_TABLE_ACCESS_CTRL_REG, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK,RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_WRITE,TB_TARGET_CVLAN));
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+#if defined(CONFIG_RTL8367C_ASICDRV_TEST)
+    memcpy(&Rtl8370sVirtualVlanTable[pVlan4kEntry->vid], pVlan4kEntry, sizeof(rtl8367c_user_vlan4kentry));
+#endif
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicVlan4kEntry
+ * Description:
+ *      Get VID mapped entry to 4K VLAN table
+ * Input:
+ *      pVlan4kEntry - 4K VLAN configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - Success
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_VLAN_VID         - Invalid VID parameter (0~4095)
+ *      RT_ERR_BUSYWAIT_TIMEOUT - LUT is busy at retrieving
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlan4kEntry(rtl8367c_user_vlan4kentry *pVlan4kEntry )
+{
+    rtk_uint16                  vlan_4k_entry[RTL8367C_VLAN_4KTABLE_LEN];
+    rtk_uint32                  page_idx;
+    rtk_uint16                  *tableAddr;
+    ret_t                       retVal;
+    rtk_uint32                  regData;
+    rtk_uint32                  busyCounter;
+
+    if(pVlan4kEntry->vid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    /* Polling status */
+    busyCounter = RTL8367C_VLAN_BUSY_CHECK_NO;
+    while(busyCounter)
+    {
+        retVal = rtl8367c_getAsicRegBit(RTL8367C_TABLE_ACCESS_STATUS_REG, RTL8367C_TABLE_LUT_ADDR_BUSY_FLAG_OFFSET,&regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        if(regData == 0)
+            break;
+
+        busyCounter --;
+        if(busyCounter == 0)
+            return RT_ERR_BUSYWAIT_TIMEOUT;
+    }
+
+    /* Write Address (VLAN_ID) */
+    regData = pVlan4kEntry->vid;
+    retVal = rtl8367c_setAsicReg(RTL8367C_TABLE_ACCESS_ADDR_REG, regData);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Read Command */
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_TABLE_ACCESS_CTRL_REG, RTL8367C_TABLE_TYPE_MASK | RTL8367C_COMMAND_TYPE_MASK, RTL8367C_TABLE_ACCESS_REG_DATA(TB_OP_READ,TB_TARGET_CVLAN));
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Polling status */
+    busyCounter = RTL8367C_VLAN_BUSY_CHECK_NO;
+    while(busyCounter)
+    {
+        retVal = rtl8367c_getAsicRegBit(RTL8367C_TABLE_ACCESS_STATUS_REG, RTL8367C_TABLE_LUT_ADDR_BUSY_FLAG_OFFSET,&regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        if(regData == 0)
+            break;
+
+        busyCounter --;
+        if(busyCounter == 0)
+            return RT_ERR_BUSYWAIT_TIMEOUT;
+    }
+
+    /* Read VLAN data from register */
+    tableAddr = vlan_4k_entry;
+    for(page_idx = 0; page_idx < RTL8367C_VLAN_4KTABLE_LEN; page_idx++)
+    {
+        retVal = rtl8367c_getAsicReg(RTL8367C_TABLE_ACCESS_RDDATA_BASE + page_idx, &regData);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+
+        *tableAddr = regData;
+        tableAddr++;
+    }
+
+    _rtl8367c_Vlan4kStSmi2User(vlan_4k_entry, pVlan4kEntry);
+
+#if defined(CONFIG_RTL8367C_ASICDRV_TEST)
+    memcpy(pVlan4kEntry, &Rtl8370sVirtualVlanTable[pVlan4kEntry->vid], sizeof(rtl8367c_user_vlan4kentry));
+#endif
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicVlanAccpetFrameType
+ * Description:
+ *      Set per-port acceptable frame type
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      frameType   - The acceptable frame type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - Success
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_PORT_ID                  - Invalid port number
+ *      RT_ERR_VLAN_ACCEPT_FRAME_TYPE   - Invalid frame type
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlanAccpetFrameType(rtk_uint32 port, rtl8367c_accframetype frameType)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(frameType >= FRAME_TYPE_MAX_BOUND)
+        return RT_ERR_VLAN_ACCEPT_FRAME_TYPE;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_VLAN_ACCEPT_FRAME_TYPE_REG(port), RTL8367C_VLAN_ACCEPT_FRAME_TYPE_MASK(port), frameType);
+}
+/* Function Name:
+ *      rtl8367c_getAsicVlanAccpetFrameType
+ * Description:
+ *      Get per-port acceptable frame type
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      pFrameType  - The acceptable frame type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - Success
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_PORT_ID                  - Invalid port number
+ *      RT_ERR_VLAN_ACCEPT_FRAME_TYPE   - Invalid frame type
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlanAccpetFrameType(rtk_uint32 port, rtl8367c_accframetype *pFrameType)
+{
+    rtk_uint32 regData;
+    ret_t  retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if((retVal = rtl8367c_getAsicRegBits(RTL8367C_VLAN_ACCEPT_FRAME_TYPE_REG(port), RTL8367C_VLAN_ACCEPT_FRAME_TYPE_MASK(port), &regData)) != RT_ERR_OK)
+        return retVal;
+
+    *pFrameType = (rtl8367c_accframetype)regData;
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicVlanIngressFilter
+ * Description:
+ *      Set VLAN Ingress Filter
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      enabled     - Enable or disable Ingress filter
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlanIngressFilter(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_VLAN_INGRESS_REG, port, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicVlanIngressFilter
+ * Description:
+ *      Get VLAN Ingress Filter
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      pEnable     - Enable or disable Ingress filter
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlanIngressFilter(rtk_uint32 port, rtk_uint32 *pEnable)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_VLAN_INGRESS_REG, port, pEnable);
+}
+/* Function Name:
+ *      rtl8367c_setAsicVlanEgressTagMode
+ * Description:
+ *      Set CVLAN egress tag mode
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      tagMode     - The egress tag mode. Including Original mode, Keep tag mode and Priority tag mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Invalid input parameter
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlanEgressTagMode(rtk_uint32 port, rtl8367c_egtagmode tagMode)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(tagMode >= EG_TAG_MODE_END)
+        return RT_ERR_INPUT;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_VLAN_EGRESS_MDOE_MASK, tagMode);
+}
+/* Function Name:
+ *      rtl8367c_getAsicVlanEgressTagMode
+ * Description:
+ *      Get CVLAN egress tag mode
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      pTagMode    - The egress tag mode. Including Original mode, Keep tag mode and Priority tag mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlanEgressTagMode(rtk_uint32 port, rtl8367c_egtagmode *pTagMode)
+{
+    rtk_uint32 regData;
+    ret_t  retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if((retVal = rtl8367c_getAsicRegBits(RTL8367C_PORT_MISC_CFG_REG(port), RTL8367C_VLAN_EGRESS_MDOE_MASK, &regData)) != RT_ERR_OK)
+        return retVal;
+
+    *pTagMode = (rtl8367c_egtagmode)regData;
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicVlanPortBasedVID
+ * Description:
+ *      Set port based VID which is indexed to 32 VLAN member configurations
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      index   - Index to VLAN member configuration
+ *      pri     - 1Q Port based VLAN priority
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number
+ *      RT_ERR_QOS_INT_PRIORITY     - Invalid priority
+ *      RT_ERR_VLAN_ENTRY_NOT_FOUND - Invalid VLAN member configuration index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlanPortBasedVID(rtk_uint32 port, rtk_uint32 index, rtk_uint32 pri)
+{
+    rtk_uint32 regAddr, bit_mask;
+    ret_t  retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(index > RTL8367C_CVIDXMAX)
+        return RT_ERR_VLAN_ENTRY_NOT_FOUND;
+
+    if(pri > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    regAddr = RTL8367C_VLAN_PVID_CTRL_REG(port);
+    bit_mask = RTL8367C_PORT_VIDX_MASK(port);
+    retVal = rtl8367c_setAsicRegBits(regAddr, bit_mask, index);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regAddr = RTL8367C_VLAN_PORTBASED_PRIORITY_REG(port);
+    bit_mask = RTL8367C_VLAN_PORTBASED_PRIORITY_MASK(port);
+    retVal = rtl8367c_setAsicRegBits(regAddr, bit_mask, pri);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicVlanPortBasedVID
+ * Description:
+ *      Get port based VID which is indexed to 32 VLAN member configurations
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      pIndex  - Index to VLAN member configuration
+ *      pPri    - 1Q Port based VLAN priority
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlanPortBasedVID(rtk_uint32 port, rtk_uint32 *pIndex, rtk_uint32 *pPri)
+{
+    rtk_uint32 regAddr,bit_mask;
+    ret_t  retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    regAddr = RTL8367C_VLAN_PVID_CTRL_REG(port);
+    bit_mask = RTL8367C_PORT_VIDX_MASK(port);
+    retVal = rtl8367c_getAsicRegBits(regAddr, bit_mask, pIndex);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    regAddr = RTL8367C_VLAN_PORTBASED_PRIORITY_REG(port);
+    bit_mask = RTL8367C_VLAN_PORTBASED_PRIORITY_MASK(port);
+    retVal = rtl8367c_getAsicRegBits(regAddr, bit_mask, pPri);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicVlanProtocolBasedGroupData
+ * Description:
+ *      Set protocol and port based group database
+ * Input:
+ *      index       - Index to VLAN member configuration
+ *      pPbCfg  - Protocol and port based group database entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_INPUT                - Invalid input parameter
+ *      RT_ERR_VLAN_PROTO_AND_PORT  - Invalid protocol base group database index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlanProtocolBasedGroupData(rtk_uint32 index, rtl8367c_protocolgdatacfg *pPbCfg)
+{
+    rtk_uint32  frameType;
+    rtk_uint32  etherType;
+    ret_t   retVal;
+
+    /* Error Checking */
+    if(index > RTL8367C_PROTOVLAN_GIDX_MAX)
+        return RT_ERR_VLAN_PROTO_AND_PORT;
+
+    if(pPbCfg->frameType >= PPVLAN_FRAME_TYPE_END )
+        return RT_ERR_INPUT;
+
+    frameType = pPbCfg->frameType;
+    etherType = pPbCfg->etherType;
+
+    /* Frame type */
+    retVal = rtl8367c_setAsicRegBits(RTL8367C_VLAN_PPB_FRAMETYPE_REG(index), RTL8367C_VLAN_PPB_FRAMETYPE_MASK, frameType);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Ether type */
+    retVal = rtl8367c_setAsicReg(RTL8367C_VLAN_PPB_ETHERTYPR_REG(index), etherType);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicVlanProtocolBasedGroupData
+ * Description:
+ *      Get protocol and port based group database
+ * Input:
+ *      index       - Index to VLAN member configuration
+ *      pPbCfg  - Protocol and port based group database entry
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_INPUT                - Invalid input parameter
+ *      RT_ERR_VLAN_PROTO_AND_PORT  - Invalid protocol base group database index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlanProtocolBasedGroupData(rtk_uint32 index, rtl8367c_protocolgdatacfg *pPbCfg)
+{
+    rtk_uint32  frameType;
+    rtk_uint32  etherType;
+    ret_t   retVal;
+
+    /* Error Checking */
+    if(index > RTL8367C_PROTOVLAN_GIDX_MAX)
+        return RT_ERR_VLAN_PROTO_AND_PORT;
+
+    /* Read Frame type */
+    retVal = rtl8367c_getAsicRegBits(RTL8367C_VLAN_PPB_FRAMETYPE_REG(index), RTL8367C_VLAN_PPB_FRAMETYPE_MASK, &frameType);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Read Ether type */
+    retVal = rtl8367c_getAsicReg(RTL8367C_VLAN_PPB_ETHERTYPR_REG(index), &etherType);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+
+    pPbCfg->frameType = frameType;
+    pPbCfg->etherType = etherType;
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicVlanPortAndProtocolBased
+ * Description:
+ *      Set protocol and port based VLAN configuration
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      index       - Index of protocol and port based database index
+ *      pPpbCfg     - Protocol and port based VLAN configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_INPUT                - Invalid input parameter
+ *      RT_ERR_PORT_ID              - Invalid port number
+ *      RT_ERR_QOS_INT_PRIORITY     - Invalid priority
+ *      RT_ERR_VLAN_PROTO_AND_PORT  - Invalid protocol base group database index
+ *      RT_ERR_VLAN_ENTRY_NOT_FOUND - Invalid VLAN member configuration index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlanPortAndProtocolBased(rtk_uint32 port, rtk_uint32 index, rtl8367c_protocolvlancfg *pPpbCfg)
+{
+    rtk_uint32  reg_addr, bit_mask, bit_value;
+    ret_t   retVal;
+
+    /* Error Checking */
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(index > RTL8367C_PROTOVLAN_GIDX_MAX)
+        return RT_ERR_VLAN_PROTO_AND_PORT;
+
+    if( (pPpbCfg->valid != FALSE) && (pPpbCfg->valid != TRUE) )
+        return RT_ERR_INPUT;
+
+    if(pPpbCfg->vlan_idx > RTL8367C_CVIDXMAX)
+        return RT_ERR_VLAN_ENTRY_NOT_FOUND;
+
+    if(pPpbCfg->priority > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    /* Valid bit */
+    reg_addr  = RTL8367C_VLAN_PPB_VALID_REG(index);
+    bit_mask  = 0x0001 << port;
+    bit_value = ((TRUE == pPpbCfg->valid) ? 0x1 : 0x0);
+    retVal    = rtl8367c_setAsicRegBits(reg_addr, bit_mask, bit_value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* Calculate the actual register address for CVLAN index*/
+    if(port < 8)
+    {
+        reg_addr = RTL8367C_VLAN_PPB_CTRL_REG(index, port);
+        bit_mask = RTL8367C_VLAN_PPB_CTRL_MASK(port);
+    }
+    else if(port == 8)
+    {
+        reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
+        bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT8_INDEX_MASK;
+    }
+    else if(port == 9)
+    {
+        reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
+        bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT9_INDEX_MASK;
+    }
+    else if(port == 10)
+    {
+        reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
+        bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT10_INDEX_MASK;
+    }
+
+    bit_value = pPpbCfg->vlan_idx;
+    retVal  = rtl8367c_setAsicRegBits(reg_addr, bit_mask, bit_value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    /* write priority */
+    reg_addr  = RTL8367C_VLAN_PPB_PRIORITY_ITEM_REG(port, index);
+    bit_mask  = RTL8367C_VLAN_PPB_PRIORITY_ITEM_MASK(port);
+    bit_value = pPpbCfg->priority;
+    retVal    = rtl8367c_setAsicRegBits(reg_addr, bit_mask, bit_value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_getAsicVlanPortAndProtocolBased
+ * Description:
+ *      Get protocol and port based VLAN configuration
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      index       - Index of protocol and port based database index
+ *      pPpbCfg     - Protocol and port based VLAN configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - Success
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_INPUT                - Invalid input parameter
+ *      RT_ERR_PORT_ID              - Invalid port number
+ *      RT_ERR_VLAN_PROTO_AND_PORT  - Invalid protocol base group database index
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlanPortAndProtocolBased(rtk_uint32 port, rtk_uint32 index, rtl8367c_protocolvlancfg *pPpbCfg)
+{
+    rtk_uint32  reg_addr, bit_mask, bit_value;
+    ret_t   retVal;
+
+    /* Error Checking */
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(index > RTL8367C_PROTOVLAN_GIDX_MAX)
+        return RT_ERR_VLAN_PROTO_AND_PORT;
+
+    if(pPpbCfg == NULL)
+        return RT_ERR_INPUT;
+
+    /* Valid bit */
+    reg_addr  = RTL8367C_VLAN_PPB_VALID_REG(index);
+    bit_mask  = 0x0001 << port;
+    retVal    = rtl8367c_getAsicRegBits(reg_addr, bit_mask, &bit_value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pPpbCfg->valid = bit_value;
+
+    /* CVLAN index */
+    if(port < 8)
+    {
+        reg_addr = RTL8367C_VLAN_PPB_CTRL_REG(index, port);
+        bit_mask = RTL8367C_VLAN_PPB_CTRL_MASK(port);
+    }
+    else if(port == 8)
+    {
+        reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
+        bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT8_INDEX_MASK;
+    }
+    else if(port == 9)
+    {
+        reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
+        bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT9_INDEX_MASK;
+    }
+    else if(port == 10)
+    {
+        reg_addr = RTL8367C_REG_VLAN_PPB0_CTRL4;
+        bit_mask = RTL8367C_VLAN_PPB0_CTRL4_PORT10_INDEX_MASK;
+    }
+
+    retVal = rtl8367c_getAsicRegBits(reg_addr, bit_mask, &bit_value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pPpbCfg->vlan_idx = bit_value;
+
+
+    /* priority */
+    reg_addr = RTL8367C_VLAN_PPB_PRIORITY_ITEM_REG(port,index);
+    bit_mask = RTL8367C_VLAN_PPB_PRIORITY_ITEM_MASK(port);
+    retVal = rtl8367c_getAsicRegBits(reg_addr, bit_mask, &bit_value);
+    if(retVal != RT_ERR_OK)
+        return retVal;
+
+    pPpbCfg->priority = bit_value;
+    return RT_ERR_OK;
+}
+/* Function Name:
+ *      rtl8367c_setAsicVlanFilter
+ * Description:
+ *      Set enable CVLAN filtering function
+ * Input:
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlanFilter(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_VLAN_CTRL, RTL8367C_VLAN_CTRL_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicVlanFilter
+ * Description:
+ *      Get enable CVLAN filtering function
+ * Input:
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlanFilter(rtk_uint32* pEnabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_VLAN_CTRL, RTL8367C_VLAN_CTRL_OFFSET, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicVlanUntagDscpPriorityEn
+ * Description:
+ *      Set enable Dscp to untag 1Q priority
+ * Input:
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlanUntagDscpPriorityEn(rtk_uint32 enabled)
+{
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_UNTAG_DSCP_PRI_CFG, RTL8367C_UNTAG_DSCP_PRI_CFG_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicVlanUntagDscpPriorityEn
+ * Description:
+ *      Get enable Dscp to untag 1Q priority
+ * Input:
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlanUntagDscpPriorityEn(rtk_uint32* enabled)
+{
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_UNTAG_DSCP_PRI_CFG, RTL8367C_UNTAG_DSCP_PRI_CFG_OFFSET, enabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortBasedFid
+ * Description:
+ *      Set port based FID
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      fid     - Port based fid
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_L2_FID   - Invalid FID
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortBasedFid(rtk_uint32 port, rtk_uint32 fid)
+{
+    rtk_uint32  reg_addr;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(fid > RTL8367C_FIDMAX)
+        return RT_ERR_L2_FID;
+
+    if(port < 8)
+        return rtl8367c_setAsicReg(RTL8367C_PORT_PBFID_REG(port),fid);
+    else {
+        reg_addr = RTL8367C_REG_PORT8_PBFID + port-8;
+        return rtl8367c_setAsicReg(reg_addr, fid);
+    }
+
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortBasedFid
+ * Description:
+ *      Get port based FID
+ * Input:
+ *      port    - Physical port number (0~7)
+ *      pFid    - Port based fid
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortBasedFid(rtk_uint32 port, rtk_uint32* pFid)
+{
+    rtk_uint32  reg_addr;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8)
+        return rtl8367c_getAsicReg(RTL8367C_PORT_PBFID_REG(port), pFid);
+    else{
+        reg_addr = RTL8367C_REG_PORT8_PBFID + port-8;
+        return rtl8367c_getAsicReg(reg_addr, pFid);
+    }
+}
+/* Function Name:
+ *      rtl8367c_setAsicPortBasedFidEn
+ * Description:
+ *      Set port based FID selection enable
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      enabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicPortBasedFidEn(rtk_uint32 port, rtk_uint32 enabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_setAsicRegBit(RTL8367C_REG_PORT_PBFIDEN,port, enabled);
+}
+/* Function Name:
+ *      rtl8367c_getAsicPortBasedFidEn
+ * Description:
+ *      Get port based FID selection enable
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      pEnabled - 1: enabled, 0: disabled
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicPortBasedFidEn(rtk_uint32 port, rtk_uint32* pEnabled)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBit(RTL8367C_REG_PORT_PBFIDEN,port, pEnabled);
+}
+/* Function Name:
+ *      rtl8367c_setAsicSpanningTreeStatus
+ * Description:
+ *      Set spanning tree state per each port
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      msti    - Multiple spanning tree instance
+ *      state   - Spanning tree state for msti
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_MSTI         - Invalid msti parameter
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_MSTP_STATE   - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicSpanningTreeStatus(rtk_uint32 port, rtk_uint32 msti, rtk_uint32 state)
+{
+    rtk_uint32  reg_addr,bits_msk;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(msti > RTL8367C_MSTIMAX)
+        return RT_ERR_MSTI;
+
+    if(state > STPST_FORWARDING)
+        return RT_ERR_MSTP_STATE;
+
+    if(port < 8)
+        return rtl8367c_setAsicRegBits(RTL8367C_VLAN_MSTI_REG(msti,port), RTL8367C_VLAN_MSTI_MASK(port),state);
+    else{
+        reg_addr = RTL8367C_VLAN_MSTI_REG(msti,port);
+        switch(port){
+            case 8: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT8_STATE_MASK;break;
+            case 9: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT9_STATE_MASK;break;
+            case 10: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT10_STATE_MASK;break;
+        }
+        return rtl8367c_setAsicRegBits(reg_addr, bits_msk,state);
+    }
+}
+/* Function Name:
+ *      rtl8367c_getAsicSpanningTreeStatus
+ * Description:
+ *      Set spanning tree state per each port
+ * Input:
+ *      port    - Physical port number (0~10)
+ *      msti    - Multiple spanning tree instance
+ *      pState  - Spanning tree state for msti
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_MSTI         - Invalid msti parameter
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicSpanningTreeStatus(rtk_uint32 port, rtk_uint32 msti, rtk_uint32* pState)
+{
+    rtk_uint32  reg_addr,bits_msk;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(msti > RTL8367C_MSTIMAX)
+        return RT_ERR_MSTI;
+
+    if(port < 8)
+        return rtl8367c_getAsicRegBits(RTL8367C_VLAN_MSTI_REG(msti,port), RTL8367C_VLAN_MSTI_MASK(port), pState);
+    else{
+        reg_addr = RTL8367C_VLAN_MSTI_REG(msti,port);
+        switch(port){
+            case 8: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT8_STATE_MASK;break;
+            case 9: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT9_STATE_MASK;break;
+            case 10: bits_msk = RTL8367C_VLAN_MSTI0_CTRL1_PORT10_STATE_MASK;break;
+        }
+        return rtl8367c_getAsicRegBits(reg_addr, bits_msk, pState);
+    }
+
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicVlanTransparent
+ * Description:
+ *      Set VLAN transparent
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      portmask    - portmask(0~0xFF)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlanTransparent(rtk_uint32 port, rtk_uint32 portmask)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(portmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    return rtl8367c_setAsicRegBits(RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL0 + port, RTL8367C_VLAN_EGRESS_TRANS_CTRL0_MASK, portmask);
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicVlanTransparent
+ * Description:
+ *      Get VLAN transparent
+ * Input:
+ *      port        - Physical port number (0~10)
+ * Output:
+ *      pPortmask   - Ingress port mask
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlanTransparent(rtk_uint32 port, rtk_uint32 *pPortmask)
+{
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    return rtl8367c_getAsicRegBits(RTL8367C_REG_VLAN_EGRESS_TRANS_CTRL0 + port, RTL8367C_VLAN_EGRESS_TRANS_CTRL0_MASK, pPortmask);
+}
+
+/* Function Name:
+ *      rtl8367c_setAsicVlanEgressKeep
+ * Description:
+ *      Set per egress port VLAN keep mode
+ * Input:
+ *      port        - Physical port number (0~10)
+ *      portmask    - portmask(0~0xFF)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_MASK    - Invalid portmask
+ *      RT_ERR_PORT_ID      - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setAsicVlanEgressKeep(rtk_uint32 port, rtk_uint32 portmask)
+{
+    rtk_uint32 regAddr, bit_mask;
+    ret_t  retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(portmask > RTL8367C_PORTMASK)
+        return RT_ERR_PORT_MASK;
+
+    if(port < 8){
+        retVal = rtl8367c_setAsicRegBits(RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL0 + (port>>1),RTL8367C_PORT0_VLAN_KEEP_MASK_MASK<<((port&1)*8),portmask & 0xff);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+        regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL0_EXT + (port>>1);
+        bit_mask = RTL8367C_PORT0_VLAN_KEEP_MASK_EXT_MASK;
+        bit_mask <<= (port&1)*3;
+        retVal = rtl8367c_setAsicRegBits(regAddr, bit_mask, (portmask>>8)&0x7);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+    }
+    else{
+        switch(port){
+            case 8:
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL4;
+                bit_mask = RTL8367C_PORT8_VLAN_KEEP_MASK_MASK;
+                retVal = rtl8367c_setAsicRegBits(regAddr, bit_mask, portmask & 0xff);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL4_EXT;
+                bit_mask = RTL8367C_PORT8_VLAN_KEEP_MASK_EXT_MASK;
+                retVal = rtl8367c_setAsicRegBits(regAddr, bit_mask, (portmask>>8)&0x7);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+                break;
+
+            case 9:
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL4;
+                bit_mask = RTL8367C_PORT9_VLAN_KEEP_MASK_MASK;
+                retVal = rtl8367c_setAsicRegBits(regAddr, bit_mask, portmask & 0xff);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL4_EXT;
+                bit_mask = RTL8367C_PORT9_VLAN_KEEP_MASK_EXT_MASK;
+                retVal = rtl8367c_setAsicRegBits(regAddr, bit_mask, (portmask>>8)&0x7);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+                break;
+
+            case 10:
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL5;
+                bit_mask = RTL8367C_VLAN_EGRESS_KEEP_CTRL5_MASK;
+                retVal = rtl8367c_setAsicRegBits(regAddr, bit_mask, portmask & 0xff);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL5_EXT;
+                bit_mask = RTL8367C_VLAN_EGRESS_KEEP_CTRL5_EXT_MASK;
+                retVal = rtl8367c_setAsicRegBits(regAddr, bit_mask, (portmask>>8)&0x7);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+                break;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getAsicVlanEgressKeep
+ * Description:
+ *      Get per egress port VLAN keep mode
+ * Input:
+ *      port        - Physical port number (0~7)
+ *      pPortmask   - portmask(0~0xFF)
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_PORT_ID  - Invalid port number
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getAsicVlanEgressKeep(rtk_uint32 port, rtk_uint32* pPortmask)
+{
+    rtk_uint32 regAddr, bit_mask, regval_l, regval_h;
+    ret_t  retVal;
+
+    if(port > RTL8367C_PORTIDMAX)
+        return RT_ERR_PORT_ID;
+
+    if(port < 8){
+        retVal = rtl8367c_getAsicRegBits(RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL0 + (port>>1),RTL8367C_PORT0_VLAN_KEEP_MASK_MASK<<((port&1)*8),&regval_l);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+        regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL0_EXT + (port>>1);
+        bit_mask = RTL8367C_PORT0_VLAN_KEEP_MASK_EXT_MASK;
+        bit_mask <<= (port&1)*3;
+        retVal = rtl8367c_getAsicRegBits(regAddr, bit_mask, &regval_h);
+        if(retVal != RT_ERR_OK)
+            return retVal;
+        *pPortmask = (regval_h << 8) | regval_l;
+    }
+    else{
+        switch(port){
+            case 8:
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL4;
+                bit_mask = RTL8367C_PORT8_VLAN_KEEP_MASK_MASK;
+                retVal = rtl8367c_getAsicRegBits(regAddr, bit_mask, &regval_l);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL4_EXT;
+                bit_mask = RTL8367C_PORT8_VLAN_KEEP_MASK_EXT_MASK;
+                retVal = rtl8367c_getAsicRegBits(regAddr, bit_mask, &regval_h);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+
+                *pPortmask = (regval_h << 8) | regval_l;
+                break;
+
+            case 9:
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL4;
+                bit_mask = RTL8367C_PORT9_VLAN_KEEP_MASK_MASK;
+                retVal = rtl8367c_getAsicRegBits(regAddr, bit_mask, &regval_l);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL4_EXT;
+                bit_mask = RTL8367C_PORT9_VLAN_KEEP_MASK_EXT_MASK;
+                retVal = rtl8367c_getAsicRegBits(regAddr, bit_mask, &regval_h);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+
+                *pPortmask = (regval_h << 8) | regval_l;
+                break;
+
+            case 10:
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL5;
+                bit_mask = RTL8367C_VLAN_EGRESS_KEEP_CTRL5_MASK;
+                retVal = rtl8367c_getAsicRegBits(regAddr, bit_mask, &regval_l);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+                regAddr = RTL8367C_REG_VLAN_EGRESS_KEEP_CTRL5_EXT;
+                bit_mask = RTL8367C_VLAN_EGRESS_KEEP_CTRL5_EXT_MASK;
+                retVal = rtl8367c_getAsicRegBits(regAddr, bit_mask, &regval_h);
+                if(retVal != RT_ERR_OK)
+                    return retVal;
+
+                *pPortmask = (regval_h << 8) | regval_l;
+                break;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_setReservedVidAction
+ * Description:
+ *      Set reserved VID action
+ * Input:
+ *      vid0Action      - VID 0 action
+ *      vid4095Action   - VID 4095 action
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Error input
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setReservedVidAction(rtk_uint32 vid0Action, rtk_uint32 vid4095Action)
+{
+    ret_t   retVal;
+
+    if(vid0Action >= RES_VID_ACT_END)
+        return RT_ERR_INPUT;
+
+    if(vid4095Action >= RES_VID_ACT_END)
+        return RT_ERR_INPUT;
+
+    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_VID0_TYPE_OFFSET, vid0Action)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_VID4095_TYPE_OFFSET, vid4095Action)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getReservedVidAction
+ * Description:
+ *      Get reserved VID action
+ * Input:
+ *      pVid0Action     - VID 0 action
+ *      pVid4095Action  - VID 4095 action
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - Success
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - Null pointer
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getReservedVidAction(rtk_uint32 *pVid0Action, rtk_uint32 *pVid4095Action)
+{
+    ret_t   retVal;
+
+    if(pVid0Action == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if(pVid4095Action == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_VID0_TYPE_OFFSET, pVid0Action)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_VID4095_TYPE_OFFSET, pVid4095Action)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtl8367c_setRealKeepRemarkEn
+ * Description:
+ *      Set Real Keep Remark
+ * Input:
+ *      enabled         - 0: 1P remarking is forbidden at real keep packet, 1: 1P remarking is enabled at real keep packet
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Error input
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_setRealKeepRemarkEn(rtk_uint32 enabled)
+{
+    ret_t   retVal;
+
+    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_1P_REMARK_BYPASS_REALKEEP_OFFSET, enabled)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_getRealKeepRemarkEn
+ * Description:
+ *      Get Real Keep Remark
+ * Input:
+ *      None
+ * Output:
+ *      pEnabled        - 0: 1P remarking is forbidden at real keep packet, 1: 1P remarking is enabled at real keep packet
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ *      RT_ERR_INPUT    - Error input
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_getRealKeepRemarkEn(rtk_uint32 *pEnabled)
+{
+    ret_t   retVal;
+
+    if((retVal = rtl8367c_getAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL, RTL8367C_VLAN_1P_REMARK_BYPASS_REALKEEP_OFFSET, pEnabled)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtl8367c_resetVlan
+ * Description:
+ *      Reset VLAN table
+ * Input:
+ *      None.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK       - Success
+ *      RT_ERR_SMI      - SMI access error
+ * Note:
+ *      None
+ */
+ret_t rtl8367c_resetVlan(void)
+{
+    ret_t   retVal;
+
+    if((retVal = rtl8367c_setAsicRegBit(RTL8367C_REG_VLAN_EXT_CTRL2, RTL8367C_VLAN_EXT_CTRL2_OFFSET, 1)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/smi.c b/drivers/net/phy/rtk/rtl8367c/smi.c
new file mode 100644
index 0000000000000..c272cad48e955
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/smi.c
@@ -0,0 +1,444 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * Purpose : RTL8367C switch low-level function for access register
+ * Feature : SMI related functions
+ *
+ */
+
+
+#include <rtk_types.h>
+#include <smi.h>
+#include "rtk_error.h"
+
+
+#if defined(MDC_MDIO_OPERATION)
+/*******************************************************************************/
+/*  MDC/MDIO porting                                                           */
+/*******************************************************************************/
+/* define the PHY ID currently used */
+/* carlos */
+#if 0
+#define MDC_MDIO_PHY_ID     0  /* PHY ID 0 or 29 */
+#else
+#define MDC_MDIO_PHY_ID     29  /* PHY ID 0 or 29 */
+#endif
+
+/* MDC/MDIO, redefine/implement the following Macro */ /*carlos*/
+#if 0
+#define MDC_MDIO_WRITE(preamableLength, phyID, regID, data)
+#define MDC_MDIO_READ(preamableLength, phyID, regID, pData)
+#else
+#define u32      unsigned int
+extern u32 mii_mgr_read(u32 phy_addr, u32 phy_register, u32 *read_data);
+extern u32 mii_mgr_write(u32 phy_addr, u32 phy_register, u32 write_data);
+
+#define MDC_MDIO_WRITE(preamableLength, phyID, regID, data) mii_mgr_write(phyID, regID, data)
+#define MDC_MDIO_READ(preamableLength, phyID, regID, pData) mii_mgr_read(phyID, regID, pData)
+#endif
+
+
+
+
+
+#elif defined(SPI_OPERATION)
+/*******************************************************************************/
+/*  SPI porting                                                                */
+/*******************************************************************************/
+/* SPI, redefine/implement the following Macro */
+#define SPI_WRITE(data, length)
+#define SPI_READ(pData, length)
+
+
+
+
+
+#else
+/*******************************************************************************/
+/*  I2C porting                                                                */
+/*******************************************************************************/
+/* Define the GPIO ID for SCK & SDA */
+rtk_uint32  smi_SCK = 1;    /* GPIO used for SMI Clock Generation */
+rtk_uint32  smi_SDA = 2;    /* GPIO used for SMI Data signal */
+
+/* I2C, redefine/implement the following Macro */
+#define GPIO_DIRECTION_SET(gpioID, direction)
+#define GPIO_DATA_SET(gpioID, data)
+#define GPIO_DATA_GET(gpioID, pData)
+
+
+
+
+
+#endif
+
+static void rtlglue_drvMutexLock(void)
+{
+    /* It is empty currently. Implement this function if Lock/Unlock function is needed */
+    return;
+}
+
+static void rtlglue_drvMutexUnlock(void)
+{
+    /* It is empty currently. Implement this function if Lock/Unlock function is needed */
+    return;
+}
+
+
+
+#if defined(MDC_MDIO_OPERATION) || defined(SPI_OPERATION)
+    /* No local function in MDC/MDIO & SPI mode */
+#else
+static void _smi_start(void)
+{
+
+    /* change GPIO pin to Output only */
+    GPIO_DIRECTION_SET(smi_SCK, GPIO_DIR_OUT);
+    GPIO_DIRECTION_SET(smi_SDA, GPIO_DIR_OUT);
+
+    /* Initial state: SCK: 0, SDA: 1 */
+    GPIO_DATA_SET(smi_SCK, 0);
+    GPIO_DATA_SET(smi_SDA, 1);
+    CLK_DURATION(DELAY);
+
+    /* CLK 1: 0 -> 1, 1 -> 0 */
+    GPIO_DATA_SET(smi_SCK, 1);
+    CLK_DURATION(DELAY);
+    GPIO_DATA_SET(smi_SCK, 0);
+    CLK_DURATION(DELAY);
+
+    /* CLK 2: */
+    GPIO_DATA_SET(smi_SCK, 1);
+    CLK_DURATION(DELAY);
+    GPIO_DATA_SET(smi_SDA, 0);
+    CLK_DURATION(DELAY);
+    GPIO_DATA_SET(smi_SCK, 0);
+    CLK_DURATION(DELAY);
+    GPIO_DATA_SET(smi_SDA, 1);
+
+}
+
+
+
+static void _smi_writeBit(rtk_uint16 signal, rtk_uint32 bitLen)
+{
+    for( ; bitLen > 0; bitLen--)
+    {
+        CLK_DURATION(DELAY);
+
+        /* prepare data */
+        if ( signal & (1<<(bitLen-1)) )
+        {
+            GPIO_DATA_SET(smi_SDA, 1);
+        }
+        else
+        {
+            GPIO_DATA_SET(smi_SDA, 0);
+        }
+        CLK_DURATION(DELAY);
+
+        /* clocking */
+        GPIO_DATA_SET(smi_SCK, 1);
+        CLK_DURATION(DELAY);
+        GPIO_DATA_SET(smi_SCK, 0);
+    }
+}
+
+
+
+static void _smi_readBit(rtk_uint32 bitLen, rtk_uint32 *rData)
+{
+    rtk_uint32 u = 0;
+
+    /* change GPIO pin to Input only */
+    GPIO_DIRECTION_SET(smi_SDA, GPIO_DIR_IN);
+
+    for (*rData = 0; bitLen > 0; bitLen--)
+    {
+        CLK_DURATION(DELAY);
+
+        /* clocking */
+        GPIO_DATA_SET(smi_SCK, 1);
+        CLK_DURATION(DELAY);
+        GPIO_DATA_GET(smi_SDA, &u);
+        GPIO_DATA_SET(smi_SCK, 0);
+
+        *rData |= (u << (bitLen - 1));
+    }
+
+    /* change GPIO pin to Output only */
+    GPIO_DIRECTION_SET(smi_SDA, GPIO_DIR_OUT);
+}
+
+
+
+static void _smi_stop(void)
+{
+
+    CLK_DURATION(DELAY);
+    GPIO_DATA_SET(smi_SDA, 0);
+    GPIO_DATA_SET(smi_SCK, 1);
+    CLK_DURATION(DELAY);
+    GPIO_DATA_SET(smi_SDA, 1);
+    CLK_DURATION(DELAY);
+    GPIO_DATA_SET(smi_SCK, 1);
+    CLK_DURATION(DELAY);
+    GPIO_DATA_SET(smi_SCK, 0);
+    CLK_DURATION(DELAY);
+    GPIO_DATA_SET(smi_SCK, 1);
+
+    /* add a click */
+    CLK_DURATION(DELAY);
+    GPIO_DATA_SET(smi_SCK, 0);
+    CLK_DURATION(DELAY);
+    GPIO_DATA_SET(smi_SCK, 1);
+
+
+    /* change GPIO pin to Input only */
+    GPIO_DIRECTION_SET(smi_SDA, GPIO_DIR_IN);
+    GPIO_DIRECTION_SET(smi_SCK, GPIO_DIR_IN);
+}
+
+#endif /* End of #if defined(MDC_MDIO_OPERATION) || defined(SPI_OPERATION) */
+
+rtk_int32 smi_read(rtk_uint32 mAddrs, rtk_uint32 *rData)
+{
+#if (!defined(MDC_MDIO_OPERATION) && !defined(SPI_OPERATION))
+    rtk_uint32 rawData=0, ACK;
+    rtk_uint8  con;
+    rtk_uint32 ret = RT_ERR_OK;
+#endif
+
+    if(mAddrs > 0xFFFF)
+        return RT_ERR_INPUT;
+
+    if(rData == NULL)
+        return RT_ERR_NULL_POINTER;
+
+#if defined(MDC_MDIO_OPERATION)
+
+    /* Lock */
+    rtlglue_drvMutexLock();
+
+    /* Write address control code to register 31 */
+    MDC_MDIO_WRITE(MDC_MDIO_PREAMBLE_LEN, MDC_MDIO_PHY_ID, MDC_MDIO_CTRL0_REG, MDC_MDIO_ADDR_OP);
+
+    /* Write address to register 23 */
+    MDC_MDIO_WRITE(MDC_MDIO_PREAMBLE_LEN, MDC_MDIO_PHY_ID, MDC_MDIO_ADDRESS_REG, mAddrs);
+
+    /* Write read control code to register 21 */
+    MDC_MDIO_WRITE(MDC_MDIO_PREAMBLE_LEN, MDC_MDIO_PHY_ID, MDC_MDIO_CTRL1_REG, MDC_MDIO_READ_OP);
+
+    /* Read data from register 25 */
+    MDC_MDIO_READ(MDC_MDIO_PREAMBLE_LEN, MDC_MDIO_PHY_ID, MDC_MDIO_DATA_READ_REG, rData);
+
+    /* Unlock */
+    rtlglue_drvMutexUnlock();
+
+    return RT_ERR_OK;
+
+#elif defined(SPI_OPERATION)
+
+    /* Lock */
+    rtlglue_drvMutexLock();
+
+    /* Write 8 bits READ OP_CODE */
+    SPI_WRITE(SPI_READ_OP, SPI_READ_OP_LEN);
+
+    /* Write 16 bits register address */
+    SPI_WRITE(mAddrs, SPI_REG_LEN);
+
+    /* Read 16 bits data */
+    SPI_READ(rData, SPI_DATA_LEN);
+
+    /* Unlock */
+    rtlglue_drvMutexUnlock();
+
+    return RT_ERR_OK;
+
+#else
+
+    /*Disable CPU interrupt to ensure that the SMI operation is atomic.
+      The API is based on RTL865X, rewrite the API if porting to other platform.*/
+    rtlglue_drvMutexLock();
+
+    _smi_start();                                /* Start SMI */
+
+    _smi_writeBit(0x0b, 4);                     /* CTRL code: 4'b1011 for RTL8370 */
+
+    _smi_writeBit(0x4, 3);                        /* CTRL code: 3'b100 */
+
+    _smi_writeBit(0x1, 1);                        /* 1: issue READ command */
+
+    con = 0;
+    do {
+        con++;
+        _smi_readBit(1, &ACK);                    /* ACK for issuing READ command*/
+    } while ((ACK != 0) && (con < ack_timer));
+
+    if (ACK != 0) ret = RT_ERR_FAILED;
+
+    _smi_writeBit((mAddrs&0xff), 8);             /* Set reg_addr[7:0] */
+
+    con = 0;
+    do {
+        con++;
+        _smi_readBit(1, &ACK);                    /* ACK for setting reg_addr[7:0] */
+    } while ((ACK != 0) && (con < ack_timer));
+
+    if (ACK != 0) ret = RT_ERR_FAILED;
+
+    _smi_writeBit((mAddrs>>8), 8);                 /* Set reg_addr[15:8] */
+
+    con = 0;
+    do {
+        con++;
+        _smi_readBit(1, &ACK);                    /* ACK by RTL8369 */
+    } while ((ACK != 0) && (con < ack_timer));
+    if (ACK != 0) ret = RT_ERR_FAILED;
+
+    _smi_readBit(8, &rawData);                    /* Read DATA [7:0] */
+    *rData = rawData&0xff;
+
+    _smi_writeBit(0x00, 1);                        /* ACK by CPU */
+
+    _smi_readBit(8, &rawData);                    /* Read DATA [15: 8] */
+
+    _smi_writeBit(0x01, 1);                        /* ACK by CPU */
+    *rData |= (rawData<<8);
+
+    _smi_stop();
+
+    rtlglue_drvMutexUnlock();/*enable CPU interrupt*/
+
+    return ret;
+#endif /* end of #if defined(MDC_MDIO_OPERATION) */
+}
+
+
+
+rtk_int32 smi_write(rtk_uint32 mAddrs, rtk_uint32 rData)
+{
+#if (!defined(MDC_MDIO_OPERATION) && !defined(SPI_OPERATION))
+    rtk_int8 con;
+    rtk_uint32 ACK;
+    rtk_uint32 ret = RT_ERR_OK;
+#endif
+
+    if(mAddrs > 0xFFFF)
+        return RT_ERR_INPUT;
+
+    if(rData > 0xFFFF)
+        return RT_ERR_INPUT;
+
+#if defined(MDC_MDIO_OPERATION)
+
+    /* Lock */
+    rtlglue_drvMutexLock();
+
+    /* Write address control code to register 31 */
+    MDC_MDIO_WRITE(MDC_MDIO_PREAMBLE_LEN, MDC_MDIO_PHY_ID, MDC_MDIO_CTRL0_REG, MDC_MDIO_ADDR_OP);
+
+    /* Write address to register 23 */
+    MDC_MDIO_WRITE(MDC_MDIO_PREAMBLE_LEN, MDC_MDIO_PHY_ID, MDC_MDIO_ADDRESS_REG, mAddrs);
+
+    /* Write data to register 24 */
+    MDC_MDIO_WRITE(MDC_MDIO_PREAMBLE_LEN, MDC_MDIO_PHY_ID, MDC_MDIO_DATA_WRITE_REG, rData);
+
+    /* Write data control code to register 21 */
+    MDC_MDIO_WRITE(MDC_MDIO_PREAMBLE_LEN, MDC_MDIO_PHY_ID, MDC_MDIO_CTRL1_REG, MDC_MDIO_WRITE_OP);
+
+    /* Unlock */
+    rtlglue_drvMutexUnlock();
+
+    return RT_ERR_OK;
+
+#elif defined(SPI_OPERATION)
+
+    /* Lock */
+    rtlglue_drvMutexLock();
+
+    /* Write 8 bits WRITE OP_CODE */
+    SPI_WRITE(SPI_WRITE_OP, SPI_WRITE_OP_LEN);
+
+    /* Write 16 bits register address */
+    SPI_WRITE(mAddrs, SPI_REG_LEN);
+
+    /* Write 16 bits data */
+    SPI_WRITE(rData, SPI_DATA_LEN);
+
+    /* Unlock */
+    rtlglue_drvMutexUnlock();
+
+    return RT_ERR_OK;
+#else
+
+    /*Disable CPU interrupt to ensure that the SMI operation is atomic.
+      The API is based on RTL865X, rewrite the API if porting to other platform.*/
+    rtlglue_drvMutexLock();
+
+    _smi_start();                                /* Start SMI */
+
+    _smi_writeBit(0x0b, 4);                     /* CTRL code: 4'b1011 for RTL8370*/
+
+    _smi_writeBit(0x4, 3);                        /* CTRL code: 3'b100 */
+
+    _smi_writeBit(0x0, 1);                        /* 0: issue WRITE command */
+
+    con = 0;
+    do {
+        con++;
+        _smi_readBit(1, &ACK);                    /* ACK for issuing WRITE command*/
+    } while ((ACK != 0) && (con < ack_timer));
+    if (ACK != 0) ret = RT_ERR_FAILED;
+
+    _smi_writeBit((mAddrs&0xff), 8);             /* Set reg_addr[7:0] */
+
+    con = 0;
+    do {
+        con++;
+        _smi_readBit(1, &ACK);                    /* ACK for setting reg_addr[7:0] */
+    } while ((ACK != 0) && (con < ack_timer));
+    if (ACK != 0) ret = RT_ERR_FAILED;
+
+    _smi_writeBit((mAddrs>>8), 8);                 /* Set reg_addr[15:8] */
+
+    con = 0;
+    do {
+        con++;
+        _smi_readBit(1, &ACK);                    /* ACK for setting reg_addr[15:8] */
+    } while ((ACK != 0) && (con < ack_timer));
+    if (ACK != 0) ret = RT_ERR_FAILED;
+
+    _smi_writeBit(rData&0xff, 8);                /* Write Data [7:0] out */
+
+    con = 0;
+    do {
+        con++;
+        _smi_readBit(1, &ACK);                    /* ACK for writting data [7:0] */
+    } while ((ACK != 0) && (con < ack_timer));
+    if (ACK != 0) ret = RT_ERR_FAILED;
+
+    _smi_writeBit(rData>>8, 8);                    /* Write Data [15:8] out */
+
+    con = 0;
+    do {
+        con++;
+        _smi_readBit(1, &ACK);                        /* ACK for writting data [15:8] */
+    } while ((ACK != 0) && (con < ack_timer));
+    if (ACK != 0) ret = RT_ERR_FAILED;
+
+    _smi_stop();
+
+    rtlglue_drvMutexUnlock();/*enable CPU interrupt*/
+
+    return ret;
+#endif /* end of #if defined(MDC_MDIO_OPERATION) */
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/stat.c b/drivers/net/phy/rtk/rtl8367c/stat.c
new file mode 100644
index 0000000000000..125c5eaf37ff9
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/stat.c
@@ -0,0 +1,626 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in MIB module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <stat.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_mib.h>
+
+/* Function Name:
+ *      rtk_stat_global_reset
+ * Description:
+ *      Reset global MIB counter.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      Reset MIB counter of ports. API will use global reset while port mask is all-ports.
+ */
+rtk_api_ret_t rtk_stat_global_reset(void)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_setAsicMIBsCounterReset(TRUE,FALSE, 0)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stat_port_reset
+ * Description:
+ *      Reset per port MIB counter by port.
+ * Input:
+ *      port - port id.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_stat_port_reset(rtk_port_t port)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_setAsicMIBsCounterReset(FALSE,FALSE,1 << rtk_switch_port_L2P_get(port))) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stat_queueManage_reset
+ * Description:
+ *      Reset queue manage MIB counter.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_stat_queueManage_reset(void)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_setAsicMIBsCounterReset(FALSE,TRUE,0)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_stat_global_get
+ * Description:
+ *      Get global MIB counter
+ * Input:
+ *      cntr_idx - global counter index.
+ * Output:
+ *      pCntr - global counter value.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      Get global MIB counter by index definition.
+ */
+rtk_api_ret_t rtk_stat_global_get(rtk_stat_global_type_t cntr_idx, rtk_stat_counter_t *pCntr)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pCntr)
+        return RT_ERR_NULL_POINTER;
+
+    if (cntr_idx!=DOT1D_TP_LEARNED_ENTRY_DISCARDS_INDEX)
+        return RT_ERR_STAT_INVALID_GLOBAL_CNTR;
+
+    if ((retVal = rtl8367c_getAsicMIBsCounter(0, cntr_idx, pCntr)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stat_global_getAll
+ * Description:
+ *      Get all global MIB counter
+ * Input:
+ *      None
+ * Output:
+ *      pGlobal_cntrs - global counter structure.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      Get all global MIB counter by index definition.
+ */
+rtk_api_ret_t rtk_stat_global_getAll(rtk_stat_global_cntr_t *pGlobal_cntrs)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pGlobal_cntrs)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicMIBsCounter(0,DOT1D_TP_LEARNED_ENTRY_DISCARDS_INDEX, &pGlobal_cntrs->dot1dTpLearnedEntryDiscards)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+#define MIB_NOT_SUPPORT     (0xFFFF)
+static rtk_api_ret_t _get_asic_mib_idx(rtk_stat_port_type_t cnt_idx, RTL8367C_MIBCOUNTER *pMib_idx)
+{
+    RTL8367C_MIBCOUNTER mib_asic_idx[STAT_PORT_CNTR_END]=
+    {
+        ifInOctets,                     /* STAT_IfInOctets */
+        dot3StatsFCSErrors,             /* STAT_Dot3StatsFCSErrors */
+        dot3StatsSymbolErrors,          /* STAT_Dot3StatsSymbolErrors */
+        dot3InPauseFrames,              /* STAT_Dot3InPauseFrames */
+        dot3ControlInUnknownOpcodes,    /* STAT_Dot3ControlInUnknownOpcodes */
+        etherStatsFragments,            /* STAT_EtherStatsFragments */
+        etherStatsJabbers,              /* STAT_EtherStatsJabbers */
+        ifInUcastPkts,                  /* STAT_IfInUcastPkts */
+        etherStatsDropEvents,           /* STAT_EtherStatsDropEvents */
+        etherStatsOctets,               /* STAT_EtherStatsOctets */
+        etherStatsUnderSizePkts,        /* STAT_EtherStatsUnderSizePkts */
+        etherOversizeStats,             /* STAT_EtherOversizeStats */
+        etherStatsPkts64Octets,         /* STAT_EtherStatsPkts64Octets */
+        etherStatsPkts65to127Octets,    /* STAT_EtherStatsPkts65to127Octets */
+        etherStatsPkts128to255Octets,   /* STAT_EtherStatsPkts128to255Octets */
+        etherStatsPkts256to511Octets,   /* STAT_EtherStatsPkts256to511Octets */
+        etherStatsPkts512to1023Octets,  /* STAT_EtherStatsPkts512to1023Octets */
+        etherStatsPkts1024to1518Octets, /* STAT_EtherStatsPkts1024to1518Octets */
+        ifInMulticastPkts,              /* STAT_EtherStatsMulticastPkts */
+        ifInBroadcastPkts,              /* STAT_EtherStatsBroadcastPkts */
+        ifOutOctets,                    /* STAT_IfOutOctets */
+        dot3StatsSingleCollisionFrames, /* STAT_Dot3StatsSingleCollisionFrames */
+        dot3StatMultipleCollisionFrames,/* STAT_Dot3StatsMultipleCollisionFrames */
+        dot3sDeferredTransmissions,     /* STAT_Dot3StatsDeferredTransmissions */
+        dot3StatsLateCollisions,        /* STAT_Dot3StatsLateCollisions */
+        etherStatsCollisions,           /* STAT_EtherStatsCollisions */
+        dot3StatsExcessiveCollisions,   /* STAT_Dot3StatsExcessiveCollisions */
+        dot3OutPauseFrames,             /* STAT_Dot3OutPauseFrames */
+        MIB_NOT_SUPPORT,                /* STAT_Dot1dBasePortDelayExceededDiscards */
+        dot1dTpPortInDiscards,          /* STAT_Dot1dTpPortInDiscards */
+        ifOutUcastPkts,                 /* STAT_IfOutUcastPkts */
+        ifOutMulticastPkts,             /* STAT_IfOutMulticastPkts */
+        ifOutBroadcastPkts,             /* STAT_IfOutBroadcastPkts */
+        outOampduPkts,                  /* STAT_OutOampduPkts */
+        inOampduPkts,                   /* STAT_InOampduPkts */
+        MIB_NOT_SUPPORT,                /* STAT_PktgenPkts */
+        inMldChecksumError,             /* STAT_InMldChecksumError */
+        inIgmpChecksumError,            /* STAT_InIgmpChecksumError */
+        inMldSpecificQuery,             /* STAT_InMldSpecificQuery */
+        inMldGeneralQuery,              /* STAT_InMldGeneralQuery */
+        inIgmpSpecificQuery,            /* STAT_InIgmpSpecificQuery */
+        inIgmpGeneralQuery,             /* STAT_InIgmpGeneralQuery */
+        inMldLeaves,                    /* STAT_InMldLeaves */
+        inIgmpLeaves,                   /* STAT_InIgmpInterfaceLeaves */
+        inIgmpJoinsSuccess,             /* STAT_InIgmpJoinsSuccess */
+        inIgmpJoinsFail,                /* STAT_InIgmpJoinsFail */
+        inMldJoinsSuccess,              /* STAT_InMldJoinsSuccess */
+        inMldJoinsFail,                 /* STAT_InMldJoinsFail */
+        inReportSuppressionDrop,        /* STAT_InReportSuppressionDrop */
+        inLeaveSuppressionDrop,         /* STAT_InLeaveSuppressionDrop */
+        outIgmpReports,                 /* STAT_OutIgmpReports */
+        outIgmpLeaves,                  /* STAT_OutIgmpLeaves */
+        outIgmpGeneralQuery,            /* STAT_OutIgmpGeneralQuery */
+        outIgmpSpecificQuery,           /* STAT_OutIgmpSpecificQuery */
+        outMldReports,                  /* STAT_OutMldReports */
+        outMldLeaves,                   /* STAT_OutMldLeaves */
+        outMldGeneralQuery,             /* STAT_OutMldGeneralQuery */
+        outMldSpecificQuery,            /* STAT_OutMldSpecificQuery */
+        inKnownMulticastPkts,           /* STAT_InKnownMulticastPkts */
+        ifInMulticastPkts,              /* STAT_IfInMulticastPkts */
+        ifInBroadcastPkts,              /* STAT_IfInBroadcastPkts */
+        ifOutDiscards                   /* STAT_IfOutDiscards */
+    };
+
+    if(cnt_idx >= STAT_PORT_CNTR_END)
+        return RT_ERR_STAT_INVALID_PORT_CNTR;
+
+    if(mib_asic_idx[cnt_idx] == MIB_NOT_SUPPORT)
+        return RT_ERR_CHIP_NOT_SUPPORTED;
+
+    *pMib_idx = mib_asic_idx[cnt_idx];
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stat_port_get
+ * Description:
+ *      Get per port MIB counter by index
+ * Input:
+ *      port        - port id.
+ *      cntr_idx    - port counter index.
+ * Output:
+ *      pCntr - MIB retrived counter.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      Get per port MIB counter by index definition.
+ */
+rtk_api_ret_t rtk_stat_port_get(rtk_port_t port, rtk_stat_port_type_t cntr_idx, rtk_stat_counter_t *pCntr)
+{
+    rtk_api_ret_t       retVal;
+    RTL8367C_MIBCOUNTER mib_idx;
+    rtk_stat_counter_t  second_cnt;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pCntr)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (cntr_idx>=STAT_PORT_CNTR_END)
+        return RT_ERR_STAT_INVALID_PORT_CNTR;
+
+    if((retVal = _get_asic_mib_idx(cntr_idx, &mib_idx)) != RT_ERR_OK)
+        return retVal;
+
+    if(mib_idx == MIB_NOT_SUPPORT)
+        return RT_ERR_CHIP_NOT_SUPPORTED;
+
+    if ((retVal = rtl8367c_getAsicMIBsCounter(rtk_switch_port_L2P_get(port), mib_idx, pCntr)) != RT_ERR_OK)
+        return retVal;
+
+    if(cntr_idx == STAT_EtherStatsMulticastPkts)
+    {
+        if((retVal = _get_asic_mib_idx(STAT_IfOutMulticastPkts, &mib_idx)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367c_getAsicMIBsCounter(rtk_switch_port_L2P_get(port), mib_idx, &second_cnt)) != RT_ERR_OK)
+            return retVal;
+
+        *pCntr += second_cnt;
+    }
+
+    if(cntr_idx == STAT_EtherStatsBroadcastPkts)
+    {
+        if((retVal = _get_asic_mib_idx(STAT_IfOutBroadcastPkts, &mib_idx)) != RT_ERR_OK)
+            return retVal;
+
+        if((retVal = rtl8367c_getAsicMIBsCounter(rtk_switch_port_L2P_get(port), mib_idx, &second_cnt)) != RT_ERR_OK)
+            return retVal;
+
+        *pCntr += second_cnt;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stat_port_getAll
+ * Description:
+ *      Get all counters of one specified port in the specified device.
+ * Input:
+ *      port - port id.
+ * Output:
+ *      pPort_cntrs - buffer pointer of counter value.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      Get all MIB counters of one port.
+ */
+rtk_api_ret_t rtk_stat_port_getAll(rtk_port_t port, rtk_stat_port_cntr_t *pPort_cntrs)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 mibIndex;
+    rtk_uint64 mibCounter;
+    rtk_uint32 *accessPtr;
+    /* address offset to MIBs counter */
+    CONST_T rtk_uint16 mibLength[STAT_PORT_CNTR_END]= {
+        2,1,1,1,1,1,1,1,1,
+        2,1,1,1,1,1,1,1,1,1,1,
+        2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPort_cntrs)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    accessPtr = (rtk_uint32*)pPort_cntrs;
+    for (mibIndex=0;mibIndex<STAT_PORT_CNTR_END;mibIndex++)
+    {
+        if ((retVal = rtk_stat_port_get(port, mibIndex, &mibCounter)) != RT_ERR_OK)
+        {
+            if (retVal == RT_ERR_CHIP_NOT_SUPPORTED)
+                mibCounter = 0;
+            else
+                return retVal;
+        }
+
+        if (2 == mibLength[mibIndex])
+            *(rtk_uint64*)accessPtr = mibCounter;
+        else if (1 == mibLength[mibIndex])
+            *accessPtr = mibCounter;
+        else
+            return RT_ERR_FAILED;
+
+        accessPtr+=mibLength[mibIndex];
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stat_logging_counterCfg_set
+ * Description:
+ *      Set the type and mode of Logging Counter
+ * Input:
+ *      idx     - The index of Logging Counter. Should be even number only.(0,2,4,6,8.....30)
+ *      mode    - 32 bits or 64 bits mode
+ *      type    - Packet counter or byte counter
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_OUT_OF_RANGE - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      Set the type and mode of Logging Counter.
+ */
+rtk_api_ret_t rtk_stat_logging_counterCfg_set(rtk_uint32 idx, rtk_logging_counter_mode_t mode, rtk_logging_counter_type_t type)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(idx > RTL8367C_MIB_MAX_LOG_CNT_IDX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((idx % 2) == 1)
+        return RT_ERR_INPUT;
+
+    if(mode >= LOGGING_MODE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(type >= LOGGING_TYPE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((retVal = rtl8367c_setAsicMIBsLoggingType((idx / 2), (rtk_uint32)type)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicMIBsLoggingMode((idx / 2), (rtk_uint32)mode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stat_logging_counterCfg_get
+ * Description:
+ *      Get the type and mode of Logging Counter
+ * Input:
+ *      idx     - The index of Logging Counter. Should be even number only.(0,2,4,6,8.....30)
+ * Output:
+ *      pMode   - 32 bits or 64 bits mode
+ *      pType   - Packet counter or byte counter
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_OUT_OF_RANGE - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_NULL_POINTER - NULL Pointer
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      Get the type and mode of Logging Counter.
+ */
+rtk_api_ret_t rtk_stat_logging_counterCfg_get(rtk_uint32 idx, rtk_logging_counter_mode_t *pMode, rtk_logging_counter_type_t *pType)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      type, mode;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(idx > RTL8367C_MIB_MAX_LOG_CNT_IDX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((idx % 2) == 1)
+        return RT_ERR_INPUT;
+
+    if(pMode == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if(pType == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if((retVal = rtl8367c_getAsicMIBsLoggingType((idx / 2), &type)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicMIBsLoggingMode((idx / 2), &mode)) != RT_ERR_OK)
+        return retVal;
+
+    *pMode = (rtk_logging_counter_mode_t)mode;
+    *pType = (rtk_logging_counter_type_t)type;
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_stat_logging_counter_reset
+ * Description:
+ *      Reset Logging Counter
+ * Input:
+ *      idx     - The index of Logging Counter. (0~31)
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_OUT_OF_RANGE - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      Reset Logging Counter.
+ */
+rtk_api_ret_t rtk_stat_logging_counter_reset(rtk_uint32 idx)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(idx > RTL8367C_MIB_MAX_LOG_CNT_IDX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((retVal = rtl8367c_setAsicMIBsResetLoggingCounter(idx)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stat_logging_counter_get
+ * Description:
+ *      Get Logging Counter
+ * Input:
+ *      idx     - The index of Logging Counter. (0~31)
+ * Output:
+ *      pCnt    - Logging counter value
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_OUT_OF_RANGE - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      Get Logging Counter.
+ */
+rtk_api_ret_t rtk_stat_logging_counter_get(rtk_uint32 idx, rtk_uint32 *pCnt)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pCnt)
+        return RT_ERR_NULL_POINTER;
+
+    if(idx > RTL8367C_MIB_MAX_LOG_CNT_IDX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if((retVal = rtl8367c_getAsicMIBsLogCounter(idx, pCnt)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stat_lengthMode_set
+ * Description:
+ *      Set Legnth mode.
+ * Input:
+ *      txMode     - The length counting mode
+ *      rxMode     - The length counting mode
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_INPUT        - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_stat_lengthMode_set(rtk_stat_lengthMode_t txMode, rtk_stat_lengthMode_t rxMode)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(txMode >= LENGTH_MODE_END)
+        return RT_ERR_INPUT;
+
+    if(rxMode >= LENGTH_MODE_END)
+        return RT_ERR_INPUT;
+
+    if((retVal = rtl8367c_setAsicMIBsLength((rtk_uint32)txMode, (rtk_uint32)rxMode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stat_lengthMode_get
+ * Description:
+ *      Get Legnth mode.
+ * Input:
+ *      None.
+ * Output:
+ *      pTxMode       - The length counting mode
+ *      pRxMode       - The length counting mode
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_INPUT        - Out of range.
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ */
+rtk_api_ret_t rtk_stat_lengthMode_get(rtk_stat_lengthMode_t *pTxMode, rtk_stat_lengthMode_t *pRxMode)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pTxMode)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pRxMode)
+        return RT_ERR_NULL_POINTER;
+
+    if((retVal = rtl8367c_getAsicMIBsLength((rtk_uint32 *)pTxMode, (rtk_uint32 *)pRxMode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/storm.c b/drivers/net/phy/rtk/rtl8367c/storm.c
new file mode 100644
index 0000000000000..1b2efbb4f0029
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/storm.c
@@ -0,0 +1,816 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in Storm module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <storm.h>
+#include <rate.h>
+#include <string.h>
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_storm.h>
+#include <rtl8367c_asicdrv_meter.h>
+#include <rtl8367c_asicdrv_rma.h>
+#include <rtl8367c_asicdrv_igmp.h>
+
+/* Function Name:
+ *      rtk_rate_stormControlMeterIdx_set
+ * Description:
+ *      Set the storm control meter index.
+ * Input:
+ *      port       - port id
+ *      storm_type - storm group type
+ *      index       - storm control meter index.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID - Invalid port id
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_stormControlMeterIdx_set(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_uint32 index)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (stormType >= STORM_GROUP_END)
+        return RT_ERR_SFC_UNKNOWN_GROUP;
+
+    if (index > RTK_MAX_METER_ID)
+        return RT_ERR_FILTER_METER_ID;
+
+    switch (stormType)
+    {
+        case STORM_GROUP_UNKNOWN_UNICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterUnknownUnicastMeter(rtk_switch_port_L2P_get(port), index))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_UNKNOWN_MULTICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterUnknownMulticastMeter(rtk_switch_port_L2P_get(port), index))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_MULTICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterMulticastMeter(rtk_switch_port_L2P_get(port), index))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_BROADCAST:
+            if ((retVal = rtl8367c_setAsicStormFilterBroadcastMeter(rtk_switch_port_L2P_get(port), index))!=RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_stormControlMeterIdx_get
+ * Description:
+ *      Get the storm control meter index.
+ * Input:
+ *      port       - port id
+ *      storm_type - storm group type
+ * Output:
+ *      pIndex     - storm control meter index.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_PORT_ID - Invalid port id
+ *      RT_ERR_FILTER_METER_ID  - Invalid meter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_stormControlMeterIdx_get(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_uint32 *pIndex)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (stormType >= STORM_GROUP_END)
+        return RT_ERR_SFC_UNKNOWN_GROUP;
+
+    if (NULL == pIndex )
+        return RT_ERR_NULL_POINTER;
+
+    switch (stormType)
+    {
+        case STORM_GROUP_UNKNOWN_UNICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterUnknownUnicastMeter(rtk_switch_port_L2P_get(port), pIndex))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_UNKNOWN_MULTICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterUnknownMulticastMeter(rtk_switch_port_L2P_get(port), pIndex))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_MULTICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterMulticastMeter(rtk_switch_port_L2P_get(port), pIndex))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_BROADCAST:
+            if ((retVal = rtl8367c_getAsicStormFilterBroadcastMeter(rtk_switch_port_L2P_get(port), pIndex))!=RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_stormControlPortEnable_set
+ * Description:
+ *      Set enable status of storm control on specified port.
+ * Input:
+ *      port       - port id
+ *      stormType  - storm group type
+ *      enable     - enable status of storm control
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_PORT_ID           - invalid port id
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_stormControlPortEnable_set(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (stormType >= STORM_GROUP_END)
+        return RT_ERR_SFC_UNKNOWN_GROUP;
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    switch (stormType)
+    {
+        case STORM_GROUP_UNKNOWN_UNICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterUnknownUnicastEnable(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_UNKNOWN_MULTICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterUnknownMulticastEnable(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_MULTICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterMulticastEnable(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_BROADCAST:
+            if ((retVal = rtl8367c_setAsicStormFilterBroadcastEnable(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_stormControlPortEnable_set
+ * Description:
+ *      Set enable status of storm control on specified port.
+ * Input:
+ *      port       - port id
+ *      stormType  - storm group type
+ * Output:
+ *      pEnable     - enable status of storm control
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_PORT_ID           - invalid port id
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_stormControlPortEnable_get(rtk_port_t port, rtk_rate_storm_group_t stormType, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (stormType >= STORM_GROUP_END)
+        return RT_ERR_SFC_UNKNOWN_GROUP;
+
+    if (NULL == pEnable)
+        return RT_ERR_ENABLE;
+
+    switch (stormType)
+    {
+        case STORM_GROUP_UNKNOWN_UNICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterUnknownUnicastEnable(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_UNKNOWN_MULTICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterUnknownMulticastEnable(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_MULTICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterMulticastEnable(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_BROADCAST:
+            if ((retVal = rtl8367c_getAsicStormFilterBroadcastEnable(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_storm_bypass_set
+ * Description:
+ *      Set bypass storm filter control configuration.
+ * Input:
+ *      type    - Bypass storm filter control type.
+ *      enable  - Bypass status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid IFG parameter
+ * Note:
+ *
+ *      This API can set per-port bypass stomr filter control frame type including RMA and igmp.
+ *      The bypass frame type is as following:
+ *      - BYPASS_BRG_GROUP,
+ *      - BYPASS_FD_PAUSE,
+ *      - BYPASS_SP_MCAST,
+ *      - BYPASS_1X_PAE,
+ *      - BYPASS_UNDEF_BRG_04,
+ *      - BYPASS_UNDEF_BRG_05,
+ *      - BYPASS_UNDEF_BRG_06,
+ *      - BYPASS_UNDEF_BRG_07,
+ *      - BYPASS_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - BYPASS_UNDEF_BRG_09,
+ *      - BYPASS_UNDEF_BRG_0A,
+ *      - BYPASS_UNDEF_BRG_0B,
+ *      - BYPASS_UNDEF_BRG_0C,
+ *      - BYPASS_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - BYPASS_8021AB,
+ *      - BYPASS_UNDEF_BRG_0F,
+ *      - BYPASS_BRG_MNGEMENT,
+ *      - BYPASS_UNDEFINED_11,
+ *      - BYPASS_UNDEFINED_12,
+ *      - BYPASS_UNDEFINED_13,
+ *      - BYPASS_UNDEFINED_14,
+ *      - BYPASS_UNDEFINED_15,
+ *      - BYPASS_UNDEFINED_16,
+ *      - BYPASS_UNDEFINED_17,
+ *      - BYPASS_UNDEFINED_18,
+ *      - BYPASS_UNDEFINED_19,
+ *      - BYPASS_UNDEFINED_1A,
+ *      - BYPASS_UNDEFINED_1B,
+ *      - BYPASS_UNDEFINED_1C,
+ *      - BYPASS_UNDEFINED_1D,
+ *      - BYPASS_UNDEFINED_1E,
+ *      - BYPASS_UNDEFINED_1F,
+ *      - BYPASS_GMRP,
+ *      - BYPASS_GVRP,
+ *      - BYPASS_UNDEF_GARP_22,
+ *      - BYPASS_UNDEF_GARP_23,
+ *      - BYPASS_UNDEF_GARP_24,
+ *      - BYPASS_UNDEF_GARP_25,
+ *      - BYPASS_UNDEF_GARP_26,
+ *      - BYPASS_UNDEF_GARP_27,
+ *      - BYPASS_UNDEF_GARP_28,
+ *      - BYPASS_UNDEF_GARP_29,
+ *      - BYPASS_UNDEF_GARP_2A,
+ *      - BYPASS_UNDEF_GARP_2B,
+ *      - BYPASS_UNDEF_GARP_2C,
+ *      - BYPASS_UNDEF_GARP_2D,
+ *      - BYPASS_UNDEF_GARP_2E,
+ *      - BYPASS_UNDEF_GARP_2F,
+ *      - BYPASS_IGMP.
+ *      - BYPASS_CDP.
+ *      - BYPASS_CSSTP.
+ *      - BYPASS_LLDP.
+ */
+rtk_api_ret_t rtk_storm_bypass_set(rtk_storm_bypass_t type, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+    rtk_uint32 tmp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= BYPASS_END)
+        return RT_ERR_INPUT;
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (type >= 0 && type <= BYPASS_UNDEF_GARP_2F)
+    {
+        if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.discard_storm_filter = enable;
+
+        if ((retVal = rtl8367c_setAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if(type == BYPASS_IGMP)
+    {
+        if ((retVal = rtl8367c_setAsicIGMPBypassStormCTRL(enable)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (type == BYPASS_CDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.discard_storm_filter = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (type  == BYPASS_CSSTP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.discard_storm_filter = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (type  == BYPASS_LLDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.discard_storm_filter = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaLldp(tmp, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_storm_bypass_get
+ * Description:
+ *      Get bypass storm filter control configuration.
+ * Input:
+ *      type - Bypass storm filter control type.
+ * Output:
+ *      pEnable - Bypass status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API can get per-port bypass stomr filter control frame type including RMA and igmp.
+ *      The bypass frame type is as following:
+ *      - BYPASS_BRG_GROUP,
+ *      - BYPASS_FD_PAUSE,
+ *      - BYPASS_SP_MCAST,
+ *      - BYPASS_1X_PAE,
+ *      - BYPASS_UNDEF_BRG_04,
+ *      - BYPASS_UNDEF_BRG_05,
+ *      - BYPASS_UNDEF_BRG_06,
+ *      - BYPASS_UNDEF_BRG_07,
+ *      - BYPASS_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - BYPASS_UNDEF_BRG_09,
+ *      - BYPASS_UNDEF_BRG_0A,
+ *      - BYPASS_UNDEF_BRG_0B,
+ *      - BYPASS_UNDEF_BRG_0C,
+ *      - BYPASS_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - BYPASS_8021AB,
+ *      - BYPASS_UNDEF_BRG_0F,
+ *      - BYPASS_BRG_MNGEMENT,
+ *      - BYPASS_UNDEFINED_11,
+ *      - BYPASS_UNDEFINED_12,
+ *      - BYPASS_UNDEFINED_13,
+ *      - BYPASS_UNDEFINED_14,
+ *      - BYPASS_UNDEFINED_15,
+ *      - BYPASS_UNDEFINED_16,
+ *      - BYPASS_UNDEFINED_17,
+ *      - BYPASS_UNDEFINED_18,
+ *      - BYPASS_UNDEFINED_19,
+ *      - BYPASS_UNDEFINED_1A,
+ *      - BYPASS_UNDEFINED_1B,
+ *      - BYPASS_UNDEFINED_1C,
+ *      - BYPASS_UNDEFINED_1D,
+ *      - BYPASS_UNDEFINED_1E,
+ *      - BYPASS_UNDEFINED_1F,
+ *      - BYPASS_GMRP,
+ *      - BYPASS_GVRP,
+ *      - BYPASS_UNDEF_GARP_22,
+ *      - BYPASS_UNDEF_GARP_23,
+ *      - BYPASS_UNDEF_GARP_24,
+ *      - BYPASS_UNDEF_GARP_25,
+ *      - BYPASS_UNDEF_GARP_26,
+ *      - BYPASS_UNDEF_GARP_27,
+ *      - BYPASS_UNDEF_GARP_28,
+ *      - BYPASS_UNDEF_GARP_29,
+ *      - BYPASS_UNDEF_GARP_2A,
+ *      - BYPASS_UNDEF_GARP_2B,
+ *      - BYPASS_UNDEF_GARP_2C,
+ *      - BYPASS_UNDEF_GARP_2D,
+ *      - BYPASS_UNDEF_GARP_2E,
+ *      - BYPASS_UNDEF_GARP_2F,
+ *      - BYPASS_IGMP.
+ *      - BYPASS_CDP.
+ *      - BYPASS_CSSTP.
+ *      - BYPASS_LLDP.
+ */
+rtk_api_ret_t rtk_storm_bypass_get(rtk_storm_bypass_t type, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+    rtk_uint32 tmp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= BYPASS_END)
+        return RT_ERR_INPUT;
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if (type >= 0 && type <= BYPASS_UNDEF_GARP_2F)
+    {
+        if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.discard_storm_filter;
+    }
+    else if(type == BYPASS_IGMP)
+    {
+        if ((retVal = rtl8367c_getAsicIGMPBypassStormCTRL(pEnable)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (type == BYPASS_CDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.discard_storm_filter;
+    }
+    else if (type == BYPASS_CSSTP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.discard_storm_filter;
+    }
+    else if (type == BYPASS_LLDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaLldp(&tmp,&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.discard_storm_filter;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_stormControlExtPortmask_set
+ * Description:
+ *      Set externsion storm control port mask
+ * Input:
+ *      pPortmask  - port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_stormControlExtPortmask_set(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtk_switch_portmask_L2P_get(pPortmask, &pmask)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicStormFilterExtEnablePortMask(pmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_stormControlExtPortmask_get
+ * Description:
+ *      Set externsion storm control port mask
+ * Input:
+ *      None
+ * Output:
+ *      pPortmask  - port mask
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_stormControlExtPortmask_get(rtk_portmask_t *pPortmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPortmask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicStormFilterExtEnablePortMask(&pmask)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtk_switch_portmask_P2L_get(pmask, pPortmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_stormControlExtEnable_set
+ * Description:
+ *      Set externsion storm control state
+ * Input:
+ *      stormType   - storm group type
+ *      enable      - externsion storm control state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_stormControlExtEnable_set(rtk_rate_storm_group_t stormType, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (stormType >= STORM_GROUP_END)
+        return RT_ERR_SFC_UNKNOWN_GROUP;
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    switch (stormType)
+    {
+        case STORM_GROUP_UNKNOWN_UNICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterExtUnknownUnicastEnable(enable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_UNKNOWN_MULTICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterExtUnknownMulticastEnable(enable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_MULTICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterExtMulticastEnable(enable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_BROADCAST:
+            if ((retVal = rtl8367c_setAsicStormFilterExtBroadcastEnable(enable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_stormControlExtEnable_get
+ * Description:
+ *      Get externsion storm control state
+ * Input:
+ *      stormType   - storm group type
+ * Output:
+ *      pEnable     - externsion storm control state
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_stormControlExtEnable_get(rtk_rate_storm_group_t stormType, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (stormType >= STORM_GROUP_END)
+        return RT_ERR_SFC_UNKNOWN_GROUP;
+
+    if (NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    switch (stormType)
+    {
+        case STORM_GROUP_UNKNOWN_UNICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterExtUnknownUnicastEnable((rtk_uint32 *)pEnable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_UNKNOWN_MULTICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterExtUnknownMulticastEnable((rtk_uint32 *)pEnable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_MULTICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterExtMulticastEnable((rtk_uint32 *)pEnable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_BROADCAST:
+            if ((retVal = rtl8367c_getAsicStormFilterExtBroadcastEnable((rtk_uint32 *)pEnable)) != RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_stormControlExtMeterIdx_set
+ * Description:
+ *      Set externsion storm control meter index
+ * Input:
+ *      stormType   - storm group type
+ *      index       - externsion storm control state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_stormControlExtMeterIdx_set(rtk_rate_storm_group_t stormType, rtk_uint32 index)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (stormType >= STORM_GROUP_END)
+        return RT_ERR_SFC_UNKNOWN_GROUP;
+
+    if (index > RTK_MAX_METER_ID)
+        return RT_ERR_FILTER_METER_ID;
+
+    switch (stormType)
+    {
+        case STORM_GROUP_UNKNOWN_UNICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterExtUnknownUnicastMeter(index))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_UNKNOWN_MULTICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterExtUnknownMulticastMeter(index))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_MULTICAST:
+            if ((retVal = rtl8367c_setAsicStormFilterExtMulticastMeter(index))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_BROADCAST:
+            if ((retVal = rtl8367c_setAsicStormFilterExtBroadcastMeter(index))!=RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_rate_stormControlExtMeterIdx_get
+ * Description:
+ *      Get externsion storm control meter index
+ * Input:
+ *      stormType   - storm group type
+ *      pIndex      - externsion storm control state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT          - The module is not initial
+ *      RT_ERR_INPUT             - invalid input parameter
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_rate_stormControlExtMeterIdx_get(rtk_rate_storm_group_t stormType, rtk_uint32 *pIndex)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (stormType >= STORM_GROUP_END)
+        return RT_ERR_SFC_UNKNOWN_GROUP;
+
+    if(NULL == pIndex)
+        return RT_ERR_NULL_POINTER;
+
+    switch (stormType)
+    {
+        case STORM_GROUP_UNKNOWN_UNICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterExtUnknownUnicastMeter(pIndex))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_UNKNOWN_MULTICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterExtUnknownMulticastMeter(pIndex))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_MULTICAST:
+            if ((retVal = rtl8367c_getAsicStormFilterExtMulticastMeter(pIndex))!=RT_ERR_OK)
+                return retVal;
+            break;
+        case STORM_GROUP_BROADCAST:
+            if ((retVal = rtl8367c_getAsicStormFilterExtBroadcastMeter(pIndex))!=RT_ERR_OK)
+                return retVal;
+            break;
+        default:
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/svlan.c b/drivers/net/phy/rtk/rtl8367c/svlan.c
new file mode 100644
index 0000000000000..fd168686a06ea
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/svlan.c
@@ -0,0 +1,2415 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in SVLAN module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <svlan.h>
+#include <vlan.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_svlan.h>
+
+rtk_uint8               svlan_mbrCfgUsage[RTL8367C_SVIDXNO];
+rtk_uint16              svlan_mbrCfgVid[RTL8367C_SVIDXNO];
+rtk_svlan_lookupType_t  svlan_lookupType;
+/* Function Name:
+ *      rtk_svlan_init
+ * Description:
+ *      Initialize SVLAN Configuration
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      Ether type of S-tag in 802.1ad is 0x88a8 and there are existed ether type 0x9100 and 0x9200 for Q-in-Q SLAN design.
+ *      User can set mathced ether type as service provider supported protocol.
+ */
+rtk_api_ret_t rtk_svlan_init(void)
+{
+    rtk_uint32 i;
+    rtk_api_ret_t retVal;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtl8367c_svlan_s2c_t svlanSP2CConf;
+    rtl8367c_svlan_mc2s_t svlanMC2SConf;
+    rtk_uint32 svidx;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /*default use C-priority*/
+    if ((retVal = rtl8367c_setAsicSvlanPrioritySel(SPRISEL_CTAGPRI)) != RT_ERR_OK)
+        return retVal;
+
+    /*Drop SVLAN untag frame*/
+    if ((retVal = rtl8367c_setAsicSvlanIngressUntag(UNTAG_DROP)) != RT_ERR_OK)
+        return retVal;
+
+    /*Drop SVLAN unmatch frame*/
+    if ((retVal = rtl8367c_setAsicSvlanIngressUnmatch(UNMATCH_DROP)) != RT_ERR_OK)
+        return retVal;
+
+    /*Set TPID to 0x88a8*/
+    if ((retVal = rtl8367c_setAsicSvlanTpid(0x88a8)) != RT_ERR_OK)
+        return retVal;
+
+    /*Clean Uplink Port Mask to none*/
+    if ((retVal = rtl8367c_setAsicSvlanUplinkPortMask(0)) != RT_ERR_OK)
+        return retVal;
+
+    /*Clean SVLAN Member Configuration*/
+    for (i=0; i<= RTL8367C_SVIDXMAX; i++)
+    {
+        memset(&svlanMemConf, 0, sizeof(rtl8367c_svlan_memconf_t));
+        if ((retVal = rtl8367c_setAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /*Clean C2S Configuration*/
+    for (i=0; i<= RTL8367C_C2SIDXMAX; i++)
+    {
+        if ((retVal = rtl8367c_setAsicSvlanC2SConf(i, 0,0,0)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /*Clean SP2C Configuration*/
+    for (i=0; i <= RTL8367C_SP2CMAX ; i++)
+    {
+        memset(&svlanSP2CConf, 0, sizeof(rtl8367c_svlan_s2c_t));
+        if ((retVal = rtl8367c_setAsicSvlanSP2CConf(i, &svlanSP2CConf)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /*Clean MC2S Configuration*/
+    for (i=0 ; i<= RTL8367C_MC2SIDXMAX; i++)
+    {
+        memset(&svlanMC2SConf, 0, sizeof(rtl8367c_svlan_mc2s_t));
+        if ((retVal = rtl8367c_setAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
+            return retVal;
+    }
+
+
+    if ((retVal = rtk_svlan_lookupType_set(SVLAN_LOOKUP_S64MBRCGF)) != RT_ERR_OK)
+        return retVal;
+
+
+    for (svidx = 0; svidx <= RTL8367C_SVIDXMAX; svidx++)
+    {
+        svlan_mbrCfgUsage[svidx] = FALSE;
+    }
+
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_servicePort_add
+ * Description:
+ *      Add one service port in the specified device
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      This API is setting which port is connected to provider switch. All frames receiving from this port must
+ *      contain accept SVID in S-tag field.
+ */
+rtk_api_ret_t rtk_svlan_servicePort_add(rtk_port_t port)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmsk;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicSvlanUplinkPortMask(&pmsk)) != RT_ERR_OK)
+        return retVal;
+
+    pmsk = pmsk | (1<<rtk_switch_port_L2P_get(port));
+
+    if ((retVal = rtl8367c_setAsicSvlanUplinkPortMask(pmsk)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_servicePort_get
+ * Description:
+ *      Get service ports in the specified device.
+ * Input:
+ *      None
+ * Output:
+ *      pSvlan_portmask - pointer buffer of svlan ports.
+ * Return:
+ *      RT_ERR_OK          - OK
+ *      RT_ERR_FAILED      - Failed
+ *      RT_ERR_SMI         - SMI access error
+ * Note:
+ *      This API is setting which port is connected to provider switch. All frames receiving from this port must
+ *      contain accept SVID in S-tag field.
+ */
+rtk_api_ret_t rtk_svlan_servicePort_get(rtk_portmask_t *pSvlan_portmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 phyMbrPmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pSvlan_portmask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicSvlanUplinkPortMask(&phyMbrPmask)) != RT_ERR_OK)
+        return retVal;
+
+    if(rtk_switch_portmask_P2L_get(phyMbrPmask, pSvlan_portmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_servicePort_del
+ * Description:
+ *      Delete one service port in the specified device
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      This API is removing SVLAN service port in the specified device.
+ */
+rtk_api_ret_t rtk_svlan_servicePort_del(rtk_port_t port)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmsk;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicSvlanUplinkPortMask(&pmsk)) != RT_ERR_OK)
+        return retVal;
+
+    pmsk = pmsk & ~(1<<rtk_switch_port_L2P_get(port));
+
+    if ((retVal = rtl8367c_setAsicSvlanUplinkPortMask(pmsk)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_tpidEntry_set
+ * Description:
+ *      Configure accepted S-VLAN ether type.
+ * Input:
+ *      svlan_tag_id - Ether type of S-tag frame parsing in uplink ports.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      Ether type of S-tag in 802.1ad is 0x88a8 and there are existed ether type 0x9100 and 0x9200 for Q-in-Q SLAN design.
+ *      User can set mathced ether type as service provider supported protocol.
+ */
+rtk_api_ret_t rtk_svlan_tpidEntry_set(rtk_svlan_tpid_t svlan_tag_id)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (svlan_tag_id>RTK_MAX_NUM_OF_PROTO_TYPE)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicSvlanTpid(svlan_tag_id)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_tpidEntry_get
+ * Description:
+ *      Get accepted S-VLAN ether type setting.
+ * Input:
+ *      None
+ * Output:
+ *      pSvlan_tag_id -  Ether type of S-tag frame parsing in uplink ports.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      This API is setting which port is connected to provider switch. All frames receiving from this port must
+ *      contain accept SVID in S-tag field.
+ */
+rtk_api_ret_t rtk_svlan_tpidEntry_get(rtk_svlan_tpid_t *pSvlan_tag_id)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pSvlan_tag_id)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicSvlanTpid(pSvlan_tag_id)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_priorityRef_set
+ * Description:
+ *      Set S-VLAN upstream priority reference setting.
+ * Input:
+ *      ref - reference selection parameter.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ * Note:
+ *      The API can set the upstream SVLAN tag priority reference source. The related priority
+ *      sources are as following:
+ *      - REF_INTERNAL_PRI,
+ *      - REF_CTAG_PRI,
+ *      - REF_SVLAN_PRI,
+ *      - REF_PB_PRI.
+ */
+rtk_api_ret_t rtk_svlan_priorityRef_set(rtk_svlan_pri_ref_t ref)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (ref >= REF_PRI_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicSvlanPrioritySel(ref)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_priorityRef_get
+ * Description:
+ *      Get S-VLAN upstream priority reference setting.
+ * Input:
+ *      None
+ * Output:
+ *      pRef - reference selection parameter.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      The API can get the upstream SVLAN tag priority reference source. The related priority
+ *      sources are as following:
+ *      - REF_INTERNAL_PRI,
+ *      - REF_CTAG_PRI,
+ *      - REF_SVLAN_PRI,
+ *      - REF_PB_PRI
+ */
+rtk_api_ret_t rtk_svlan_priorityRef_get(rtk_svlan_pri_ref_t *pRef)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pRef)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicSvlanPrioritySel(pRef)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_memberPortEntry_set
+ * Description:
+ *      Configure system SVLAN member content
+ * Input:
+ *      svid - SVLAN id
+ *      psvlan_cfg - SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameter.
+ *      RT_ERR_SVLAN_VID        - Invalid SVLAN VID parameter.
+ *      RT_ERR_PORT_MASK        - Invalid portmask.
+ *      RT_ERR_SVLAN_TABLE_FULL - SVLAN configuration is full.
+ * Note:
+ *      The API can set system 64 accepted s-tag frame format. Only 64 SVID S-tag frame will be accpeted
+ *      to receiving from uplink ports. Other SVID S-tag frame or S-untagged frame will be droped by default setup.
+ *      - rtk_svlan_memberCfg_t->svid is SVID of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->memberport is member port mask of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->fid is filtering database of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->priority is priority of SVLAN member configuration.
+ */
+rtk_api_ret_t rtk_svlan_memberPortEntry_set(rtk_vlan_t svid, rtk_svlan_memberCfg_t *pSvlan_cfg)
+{
+    rtk_api_ret_t retVal;
+    rtk_int32 i;
+    rtk_uint32 empty_idx;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtk_uint32 phyMbrPmask;
+    rtk_vlan_cfg_t vlanCfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pSvlan_cfg)
+        return RT_ERR_NULL_POINTER;
+
+    if(svid > RTL8367C_VIDMAX)
+        return RT_ERR_SVLAN_VID;
+
+    RTK_CHK_PORTMASK_VALID(&(pSvlan_cfg->memberport));
+
+    RTK_CHK_PORTMASK_VALID(&(pSvlan_cfg->untagport));
+
+    if (pSvlan_cfg->fiden > ENABLED)
+        return RT_ERR_ENABLE;
+
+    if (pSvlan_cfg->fid > RTL8367C_FIDMAX)
+        return RT_ERR_L2_FID;
+
+    if (pSvlan_cfg->priority > RTL8367C_PRIMAX)
+        return RT_ERR_VLAN_PRIORITY;
+
+    if (pSvlan_cfg->efiden > ENABLED)
+        return RT_ERR_ENABLE;
+
+    if (pSvlan_cfg->efid > RTL8367C_EFIDMAX)
+        return RT_ERR_L2_FID;
+
+    if(SVLAN_LOOKUP_C4KVLAN == svlan_lookupType)
+    {
+        if ((retVal = rtk_vlan_get(svid, &vlanCfg)) != RT_ERR_OK)
+            return retVal;
+
+        vlanCfg.mbr = pSvlan_cfg->memberport;
+        vlanCfg.untag = pSvlan_cfg->untagport;
+
+        if ((retVal = rtk_vlan_set(svid, &vlanCfg)) != RT_ERR_OK)
+            return retVal;
+
+        empty_idx = 0xFF;
+
+        for (i = 0; i<= RTL8367C_SVIDXMAX; i++)
+        {
+            if (svid == svlan_mbrCfgVid[i] && TRUE == svlan_mbrCfgUsage[i])
+            {
+                memset(&svlanMemConf, 0, sizeof(rtl8367c_svlan_memconf_t));
+                svlanMemConf.vs_svid        = svid;
+                svlanMemConf.vs_efiden      = pSvlan_cfg->efiden;
+                svlanMemConf.vs_efid        = pSvlan_cfg->efid;
+                svlanMemConf.vs_priority    = pSvlan_cfg->priority;
+
+                /*for create check*/
+                if(0 == svlanMemConf.vs_efiden && 0 == svlanMemConf.vs_efid)
+                    svlanMemConf.vs_efid = 1;
+
+                if ((retVal = rtl8367c_setAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+                    return retVal;
+
+                return RT_ERR_OK;
+            }
+            else if (FALSE == svlan_mbrCfgUsage[i] && 0xFF == empty_idx)
+            {
+                empty_idx = i;
+            }
+        }
+
+        if (empty_idx != 0xFF)
+        {
+            svlan_mbrCfgUsage[empty_idx] = TRUE;
+            svlan_mbrCfgVid[empty_idx] = svid;
+
+            memset(&svlanMemConf, 0, sizeof(rtl8367c_svlan_memconf_t));
+            svlanMemConf.vs_svid        = svid;
+            svlanMemConf.vs_efiden      = pSvlan_cfg->efiden;
+            svlanMemConf.vs_efid        = pSvlan_cfg->efid;
+            svlanMemConf.vs_priority    = pSvlan_cfg->priority;
+
+            /*for create check*/
+            if(0 == svlanMemConf.vs_efiden && 0 == svlanMemConf.vs_efid)
+                svlanMemConf.vs_efid = 1;
+
+            if ((retVal = rtl8367c_setAsicSvlanMemberConfiguration(empty_idx, &svlanMemConf)) != RT_ERR_OK)
+                return retVal;
+
+        }
+
+        return RT_ERR_OK;
+    }
+
+
+    empty_idx = 0xFF;
+
+    for (i = 0; i<= RTL8367C_SVIDXMAX; i++)
+    {
+        /*
+        if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+        */
+        if (svid == svlan_mbrCfgVid[i] && TRUE == svlan_mbrCfgUsage[i])
+        {
+            svlanMemConf.vs_svid = svid;
+
+            if(rtk_switch_portmask_L2P_get(&(pSvlan_cfg->memberport), &phyMbrPmask) != RT_ERR_OK)
+                return RT_ERR_FAILED;
+
+            svlanMemConf.vs_member = phyMbrPmask;
+
+            if(rtk_switch_portmask_L2P_get(&(pSvlan_cfg->untagport), &phyMbrPmask) != RT_ERR_OK)
+                return RT_ERR_FAILED;
+
+            svlanMemConf.vs_untag = phyMbrPmask;
+
+            svlanMemConf.vs_force_fid   = pSvlan_cfg->fiden;
+            svlanMemConf.vs_fid_msti    = pSvlan_cfg->fid;
+            svlanMemConf.vs_priority    = pSvlan_cfg->priority;
+            svlanMemConf.vs_efiden      = pSvlan_cfg->efiden;
+            svlanMemConf.vs_efid        = pSvlan_cfg->efid;
+
+            /*all items are reset means deleting*/
+            if( 0 == svlanMemConf.vs_member &&
+                0 == svlanMemConf.vs_untag &&
+                0 == svlanMemConf.vs_force_fid &&
+                0 == svlanMemConf.vs_fid_msti &&
+                0 == svlanMemConf.vs_priority &&
+                0 == svlanMemConf.vs_efiden &&
+                0 == svlanMemConf.vs_efid)
+            {
+                svlan_mbrCfgUsage[i] = FALSE;
+                svlan_mbrCfgVid[i] = 0;
+
+                /* Clear SVID also */
+                svlanMemConf.vs_svid = 0;
+            }
+            else
+            {
+                svlan_mbrCfgUsage[i] = TRUE;
+                svlan_mbrCfgVid[i] = svlanMemConf.vs_svid;
+
+                if(0 == svlanMemConf.vs_svid)
+                {
+                    /*for create check*/
+                    if(0 == svlanMemConf.vs_efiden && 0 == svlanMemConf.vs_efid)
+                    {
+                        svlanMemConf.vs_efid = 1;
+                    }
+                }
+            }
+
+            if ((retVal = rtl8367c_setAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+                return retVal;
+
+            return RT_ERR_OK;
+        }
+        else if (FALSE == svlan_mbrCfgUsage[i] && 0xFF == empty_idx)
+        {
+            empty_idx = i;
+        }
+    }
+
+    if (empty_idx != 0xFF)
+    {
+        memset(&svlanMemConf, 0, sizeof(rtl8367c_svlan_memconf_t));
+        svlanMemConf.vs_svid = svid;
+
+        if(rtk_switch_portmask_L2P_get(&(pSvlan_cfg->memberport), &phyMbrPmask) != RT_ERR_OK)
+            return RT_ERR_FAILED;
+
+        svlanMemConf.vs_member = phyMbrPmask;
+
+        if(rtk_switch_portmask_L2P_get(&(pSvlan_cfg->untagport), &phyMbrPmask) != RT_ERR_OK)
+            return RT_ERR_FAILED;
+
+        svlanMemConf.vs_untag = phyMbrPmask;
+
+        svlanMemConf.vs_force_fid   = pSvlan_cfg->fiden;
+        svlanMemConf.vs_fid_msti    = pSvlan_cfg->fid;
+        svlanMemConf.vs_priority    = pSvlan_cfg->priority;
+
+        svlanMemConf.vs_efiden      = pSvlan_cfg->efiden;
+        svlanMemConf.vs_efid        = pSvlan_cfg->efid;
+
+        /*change efid for empty svid 0*/
+        if(0 == svlanMemConf.vs_svid)
+        {   /*for create check*/
+            if(0 == svlanMemConf.vs_efiden && 0 == svlanMemConf.vs_efid)
+            {
+                svlanMemConf.vs_efid = 1;
+            }
+        }
+
+        svlan_mbrCfgUsage[empty_idx] = TRUE;
+        svlan_mbrCfgVid[empty_idx] = svlanMemConf.vs_svid;
+
+        if ((retVal = rtl8367c_setAsicSvlanMemberConfiguration(empty_idx, &svlanMemConf)) != RT_ERR_OK)
+        {
+            return retVal;
+        }
+
+        return RT_ERR_OK;
+    }
+
+    return RT_ERR_SVLAN_TABLE_FULL;
+}
+
+/* Function Name:
+ *      rtk_svlan_memberPortEntry_get
+ * Description:
+ *      Get SVLAN member Configure.
+ * Input:
+ *      svid - SVLAN id
+ * Output:
+ *      pSvlan_cfg - SVLAN member configuration
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can get system 64 accepted s-tag frame format. Only 64 SVID S-tag frame will be accpeted
+ *      to receiving from uplink ports. Other SVID S-tag frame or S-untagged frame will be droped.
+ */
+rtk_api_ret_t rtk_svlan_memberPortEntry_get(rtk_vlan_t svid, rtk_svlan_memberCfg_t *pSvlan_cfg)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pSvlan_cfg)
+        return RT_ERR_NULL_POINTER;
+
+    if (svid > RTL8367C_VIDMAX)
+        return RT_ERR_SVLAN_VID;
+
+
+    for (i = 0; i<= RTL8367C_SVIDXMAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (svid == svlanMemConf.vs_svid)
+        {
+            pSvlan_cfg->svid        = svlanMemConf.vs_svid;
+
+            if(rtk_switch_portmask_P2L_get(svlanMemConf.vs_member,&(pSvlan_cfg->memberport)) != RT_ERR_OK)
+                return RT_ERR_FAILED;
+
+            if(rtk_switch_portmask_P2L_get(svlanMemConf.vs_untag,&(pSvlan_cfg->untagport)) != RT_ERR_OK)
+                return RT_ERR_FAILED;
+
+            pSvlan_cfg->fiden       = svlanMemConf.vs_force_fid;
+            pSvlan_cfg->fid         = svlanMemConf.vs_fid_msti;
+            pSvlan_cfg->priority    = svlanMemConf.vs_priority;
+            pSvlan_cfg->efiden      = svlanMemConf.vs_efiden;
+            pSvlan_cfg->efid        = svlanMemConf.vs_efid;
+
+            return RT_ERR_OK;
+        }
+    }
+
+    return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
+
+}
+
+/* Function Name:
+ *      rtk_svlan_memberPortEntry_adv_set
+ * Description:
+ *      Configure system SVLAN member by index
+ * Input:
+ *      idx         - Index (0 ~ 63)
+ *      psvlan_cfg  - SVLAN member configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameter.
+ *      RT_ERR_SVLAN_VID        - Invalid SVLAN VID parameter.
+ *      RT_ERR_PORT_MASK        - Invalid portmask.
+ *      RT_ERR_SVLAN_TABLE_FULL - SVLAN configuration is full.
+ * Note:
+ *      The API can set system 64 accepted s-tag frame format by index.
+ *      - rtk_svlan_memberCfg_t->svid is SVID of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->memberport is member port mask of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->fid is filtering database of SVLAN member configuration.
+ *      - rtk_svlan_memberCfg_t->priority is priority of SVLAN member configuration.
+ */
+rtk_api_ret_t rtk_svlan_memberPortEntry_adv_set(rtk_uint32 idx, rtk_svlan_memberCfg_t *pSvlan_cfg)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtk_uint32 phyMbrPmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pSvlan_cfg)
+        return RT_ERR_NULL_POINTER;
+
+    if (idx > RTL8367C_SVIDXMAX)
+        return RT_ERR_SVLAN_ENTRY_INDEX;
+
+    if (pSvlan_cfg->svid>RTL8367C_VIDMAX)
+        return RT_ERR_SVLAN_VID;
+
+    RTK_CHK_PORTMASK_VALID(&(pSvlan_cfg->memberport));
+
+    RTK_CHK_PORTMASK_VALID(&(pSvlan_cfg->untagport));
+
+    if (pSvlan_cfg->fiden > ENABLED)
+        return RT_ERR_ENABLE;
+
+    if (pSvlan_cfg->fid > RTL8367C_FIDMAX)
+        return RT_ERR_L2_FID;
+
+    if (pSvlan_cfg->priority > RTL8367C_PRIMAX)
+        return RT_ERR_VLAN_PRIORITY;
+
+    if (pSvlan_cfg->efiden > ENABLED)
+        return RT_ERR_ENABLE;
+
+    if (pSvlan_cfg->efid > RTL8367C_EFIDMAX)
+        return RT_ERR_L2_FID;
+
+    memset(&svlanMemConf, 0, sizeof(rtl8367c_svlan_memconf_t));
+    svlanMemConf.vs_svid        = pSvlan_cfg->svid;
+    if(rtk_switch_portmask_L2P_get(&(pSvlan_cfg->memberport), &phyMbrPmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    svlanMemConf.vs_member = phyMbrPmask;
+
+    if(rtk_switch_portmask_L2P_get(&(pSvlan_cfg->untagport), &phyMbrPmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    svlanMemConf.vs_untag = phyMbrPmask;
+
+
+    svlanMemConf.vs_force_fid   = pSvlan_cfg->fiden;
+    svlanMemConf.vs_fid_msti    = pSvlan_cfg->fid;
+    svlanMemConf.vs_priority    = pSvlan_cfg->priority;
+    svlanMemConf.vs_efiden      = pSvlan_cfg->efiden;
+    svlanMemConf.vs_efid        = pSvlan_cfg->efid;
+
+    if(0 == svlanMemConf.vs_svid &&
+        0 == svlanMemConf.vs_member &&
+        0 == svlanMemConf.vs_untag &&
+        0 == svlanMemConf.vs_force_fid &&
+        0 == svlanMemConf.vs_fid_msti &&
+        0 == svlanMemConf.vs_priority &&
+        0 == svlanMemConf.vs_efiden &&
+        0 == svlanMemConf.vs_efid)
+    {
+        svlan_mbrCfgUsage[idx] = FALSE;
+        svlan_mbrCfgVid[idx] = 0;
+    }
+    else
+    {
+        svlan_mbrCfgUsage[idx] = TRUE;
+        svlan_mbrCfgVid[idx] = svlanMemConf.vs_svid;
+    }
+
+    if ((retVal = rtl8367c_setAsicSvlanMemberConfiguration(idx, &svlanMemConf)) != RT_ERR_OK)
+        return retVal;
+
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_memberPortEntry_adv_get
+ * Description:
+ *      Get SVLAN member Configure by index.
+ * Input:
+ *      idx         - Index (0 ~ 63)
+ * Output:
+ *      pSvlan_cfg  - SVLAN member configuration
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can get system 64 accepted s-tag frame format. Only 64 SVID S-tag frame will be accpeted
+ *      to receiving from uplink ports. Other SVID S-tag frame or S-untagged frame will be droped.
+ */
+rtk_api_ret_t rtk_svlan_memberPortEntry_adv_get(rtk_uint32 idx, rtk_svlan_memberCfg_t *pSvlan_cfg)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pSvlan_cfg)
+        return RT_ERR_NULL_POINTER;
+
+    if (idx > RTL8367C_SVIDXMAX)
+        return RT_ERR_SVLAN_ENTRY_INDEX;
+
+    if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(idx, &svlanMemConf)) != RT_ERR_OK)
+        return retVal;
+
+    pSvlan_cfg->svid        = svlanMemConf.vs_svid;
+    if(rtk_switch_portmask_P2L_get(svlanMemConf.vs_member,&(pSvlan_cfg->memberport)) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    if(rtk_switch_portmask_P2L_get(svlanMemConf.vs_untag,&(pSvlan_cfg->untagport)) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    pSvlan_cfg->fiden       = svlanMemConf.vs_force_fid;
+    pSvlan_cfg->fid         = svlanMemConf.vs_fid_msti;
+    pSvlan_cfg->priority    = svlanMemConf.vs_priority;
+    pSvlan_cfg->efiden      = svlanMemConf.vs_efiden;
+    pSvlan_cfg->efid        = svlanMemConf.vs_efid;
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtk_svlan_defaultSvlan_set
+ * Description:
+ *      Configure default egress SVLAN.
+ * Input:
+ *      port - Source port
+ *      svid - SVLAN id
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_INPUT                    - Invalid input parameter.
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ * Note:
+ *      The API can set port n S-tag format index while receiving frame from port n
+ *      is transmit through uplink port with s-tag field
+ */
+rtk_api_ret_t rtk_svlan_defaultSvlan_set(rtk_port_t port, rtk_vlan_t svid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    /* svid must be 0~4095 */
+    if (svid > RTL8367C_VIDMAX)
+        return RT_ERR_SVLAN_VID;
+
+    for (i = 0; i < RTL8367C_SVIDXNO; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (svid == svlanMemConf.vs_svid)
+        {
+            if ((retVal = rtl8367c_setAsicSvlanDefaultVlan(rtk_switch_port_L2P_get(port), i)) != RT_ERR_OK)
+                return retVal;
+
+            return RT_ERR_OK;
+        }
+    }
+
+    return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
+}
+
+/* Function Name:
+ *      rtk_svlan_defaultSvlan_get
+ * Description:
+ *      Get the configure default egress SVLAN.
+ * Input:
+ *      port - Source port
+ * Output:
+ *      pSvid - SVLAN VID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can get port n S-tag format index while receiving frame from port n
+ *      is transmit through uplink port with s-tag field
+ */
+rtk_api_ret_t rtk_svlan_defaultSvlan_get(rtk_port_t port, rtk_vlan_t *pSvid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 idx;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pSvid)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicSvlanDefaultVlan(rtk_switch_port_L2P_get(port), &idx)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(idx, &svlanMemConf)) != RT_ERR_OK)
+        return retVal;
+
+    *pSvid = svlanMemConf.vs_svid;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_c2s_add
+ * Description:
+ *      Configure SVLAN C2S table
+ * Input:
+ *      vid - VLAN ID
+ *      src_port - Ingress Port
+ *      svid - SVLAN VID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port ID.
+ *      RT_ERR_SVLAN_VID    - Invalid SVLAN VID parameter.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can set system C2S configuration. ASIC will check upstream's VID and assign related
+ *      SVID to mathed packet. There are 128 SVLAN C2S configurations.
+ */
+rtk_api_ret_t rtk_svlan_c2s_add(rtk_vlan_t vid, rtk_port_t src_port, rtk_vlan_t svid)
+{
+    rtk_api_ret_t retVal, i;
+    rtk_uint32 empty_idx;
+    rtk_uint32 evid, pmsk, svidx, c2s_svidx;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtk_port_t phyPort;
+    rtk_uint16 doneFlag;
+
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+
+    if (vid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    if (svid > RTL8367C_VIDMAX)
+        return RT_ERR_SVLAN_VID;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(src_port);
+
+    phyPort = rtk_switch_port_L2P_get(src_port);
+
+    empty_idx = 0xFFFF;
+    svidx = 0xFFFF;
+    doneFlag = FALSE;
+
+    for (i = 0; i<= RTL8367C_SVIDXMAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (svid == svlanMemConf.vs_svid)
+        {
+            svidx = i;
+            break;
+        }
+    }
+
+    if (0xFFFF == svidx)
+        return RT_ERR_SVLAN_VID;
+
+    for (i=RTL8367C_C2SIDXMAX; i>=0; i--)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanC2SConf(i, &evid, &pmsk, &c2s_svidx)) != RT_ERR_OK)
+                return retVal;
+
+        if (evid == vid)
+        {
+            /* Check Src_port */
+            if(pmsk & (1 << phyPort))
+            {
+                /* Check SVIDX */
+                if(c2s_svidx == svidx)
+                {
+                    /* All the same, do nothing */
+                }
+                else
+                {
+                    /* New svidx, remove src_port and find a new slot to add a new enrty */
+                    pmsk = pmsk & ~(1 << phyPort);
+                    if(pmsk == 0)
+                        c2s_svidx = 0;
+
+                    if ((retVal = rtl8367c_setAsicSvlanC2SConf(i, vid, pmsk, c2s_svidx)) != RT_ERR_OK)
+                        return retVal;
+                }
+            }
+            else
+            {
+                if(c2s_svidx == svidx && doneFlag == FALSE)
+                {
+                    pmsk = pmsk | (1 << phyPort);
+                    if ((retVal = rtl8367c_setAsicSvlanC2SConf(i, vid, pmsk, svidx)) != RT_ERR_OK)
+                        return retVal;
+
+                    doneFlag = TRUE;
+                }
+            }
+        }
+        else if (evid==0&&pmsk==0)
+        {
+            empty_idx = i;
+        }
+    }
+
+    if (0xFFFF != empty_idx && doneFlag ==FALSE)
+    {
+       if ((retVal = rtl8367c_setAsicSvlanC2SConf(empty_idx, vid, (1<<phyPort), svidx)) != RT_ERR_OK)
+           return retVal;
+
+       return RT_ERR_OK;
+    }
+    else if(doneFlag == TRUE)
+    {
+        return RT_ERR_OK;
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+}
+
+/* Function Name:
+ *      rtk_svlan_c2s_del
+ * Description:
+ *      Delete one C2S entry
+ * Input:
+ *      vid - VLAN ID
+ *      src_port - Ingress Port
+ *      svid - SVLAN VID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_VLAN_VID         - Invalid VID parameter.
+ *      RT_ERR_PORT_ID          - Invalid port ID.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The API can delete system C2S configuration. There are 128 SVLAN C2S configurations.
+ */
+rtk_api_ret_t rtk_svlan_c2s_del(rtk_vlan_t vid, rtk_port_t src_port)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i;
+    rtk_uint32 evid, pmsk, svidx;
+    rtk_port_t phyPort;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (vid > RTL8367C_EVIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(src_port);
+    phyPort = rtk_switch_port_L2P_get(src_port);
+
+    for (i = 0; i <= RTL8367C_C2SIDXMAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanC2SConf(i, &evid, &pmsk, &svidx)) != RT_ERR_OK)
+            return retVal;
+
+        if (evid == vid)
+        {
+            if(pmsk & (1 << phyPort))
+            {
+                pmsk = pmsk & ~(1 << phyPort);
+                if(pmsk == 0)
+                {
+                    vid = 0;
+                    svidx = 0;
+                }
+
+                if ((retVal = rtl8367c_setAsicSvlanC2SConf(i, vid, pmsk, svidx)) != RT_ERR_OK)
+                    return retVal;
+
+                return RT_ERR_OK;
+            }
+        }
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+}
+
+/* Function Name:
+ *      rtk_svlan_c2s_get
+ * Description:
+ *      Get configure SVLAN C2S table
+ * Input:
+ *      vid - VLAN ID
+ *      src_port - Ingress Port
+ * Output:
+ *      pSvid - SVLAN ID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port ID.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ * Note:
+ *     The API can get system C2S configuration. There are 128 SVLAN C2S configurations.
+ */
+rtk_api_ret_t rtk_svlan_c2s_get(rtk_vlan_t vid, rtk_port_t src_port, rtk_vlan_t *pSvid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i;
+    rtk_uint32 evid, pmsk, svidx;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtk_port_t phyPort;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pSvid)
+        return RT_ERR_NULL_POINTER;
+
+    if (vid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(src_port);
+    phyPort = rtk_switch_port_L2P_get(src_port);
+
+    for (i = 0; i <= RTL8367C_C2SIDXMAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanC2SConf(i, &evid, &pmsk, &svidx)) != RT_ERR_OK)
+            return retVal;
+
+        if (evid == vid)
+        {
+            if(pmsk & (1 << phyPort))
+            {
+                if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(svidx, &svlanMemConf)) != RT_ERR_OK)
+                    return retVal;
+
+                *pSvid = svlanMemConf.vs_svid;
+                return RT_ERR_OK;
+            }
+        }
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+}
+
+/* Function Name:
+ *      rtk_svlan_untag_action_set
+ * Description:
+ *      Configure Action of downstream UnStag packet
+ * Input:
+ *      action  - Action for UnStag
+ *      svid    - The SVID assigned to UnStag packet
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can configure action of downstream Un-Stag packet. A SVID assigned
+ *      to the un-stag is also supported by this API. The parameter of svid is
+ *      only referenced when the action is set to UNTAG_ASSIGN
+ */
+rtk_api_ret_t rtk_svlan_untag_action_set(rtk_svlan_untag_action_t action, rtk_vlan_t svid)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      i;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (action >= UNTAG_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if(action == UNTAG_ASSIGN)
+    {
+        if (svid > RTL8367C_VIDMAX)
+            return RT_ERR_SVLAN_VID;
+    }
+
+    if ((retVal = rtl8367c_setAsicSvlanIngressUntag((rtk_uint32)action)) != RT_ERR_OK)
+        return retVal;
+
+    if(action == UNTAG_ASSIGN)
+    {
+        for (i = 0; i < RTL8367C_SVIDXNO; i++)
+        {
+            if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+                return retVal;
+
+            if (svid == svlanMemConf.vs_svid)
+            {
+                if ((retVal = rtl8367c_setAsicSvlanUntagVlan(i)) != RT_ERR_OK)
+                    return retVal;
+
+                return RT_ERR_OK;
+            }
+        }
+
+        return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_untag_action_get
+ * Description:
+ *      Get Action of downstream UnStag packet
+ * Input:
+ *      None
+ * Output:
+ *      pAction  - Action for UnStag
+ *      pSvid    - The SVID assigned to UnStag packet
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can Get action of downstream Un-Stag packet. A SVID assigned
+ *      to the un-stag is also retrieved by this API. The parameter pSvid is
+ *      only refernced when the action is UNTAG_ASSIGN
+ */
+rtk_api_ret_t rtk_svlan_untag_action_get(rtk_svlan_untag_action_t *pAction, rtk_vlan_t *pSvid)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      svidx;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pAction || NULL == pSvid)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicSvlanIngressUntag(pAction)) != RT_ERR_OK)
+        return retVal;
+
+    if(*pAction == UNTAG_ASSIGN)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanUntagVlan(&svidx)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(svidx, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+
+        *pSvid = svlanMemConf.vs_svid;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_unmatch_action_set
+ * Description:
+ *      Configure Action of downstream Unmatch packet
+ * Input:
+ *      action  - Action for Unmatch
+ *      svid    - The SVID assigned to Unmatch packet
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can configure action of downstream Un-match packet. A SVID assigned
+ *      to the un-match is also supported by this API. The parameter od svid is
+ *      only refernced when the action is set to UNMATCH_ASSIGN
+ */
+rtk_api_ret_t rtk_svlan_unmatch_action_set(rtk_svlan_unmatch_action_t action, rtk_vlan_t svid)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      i;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (action >= UNMATCH_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if (action == UNMATCH_ASSIGN)
+    {
+        if (svid > RTL8367C_VIDMAX)
+            return RT_ERR_SVLAN_VID;
+    }
+
+    if ((retVal = rtl8367c_setAsicSvlanIngressUnmatch((rtk_uint32)action)) != RT_ERR_OK)
+        return retVal;
+
+    if(action == UNMATCH_ASSIGN)
+    {
+        for (i = 0; i < RTL8367C_SVIDXNO; i++)
+        {
+            if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+                return retVal;
+
+            if (svid == svlanMemConf.vs_svid)
+            {
+                if ((retVal = rtl8367c_setAsicSvlanUnmatchVlan(i)) != RT_ERR_OK)
+                    return retVal;
+
+                return RT_ERR_OK;
+            }
+        }
+
+        return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_unmatch_action_get
+ * Description:
+ *      Get Action of downstream Unmatch packet
+ * Input:
+ *      None
+ * Output:
+ *      pAction  - Action for Unmatch
+ *      pSvid    - The SVID assigned to Unmatch packet
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can Get action of downstream Un-match packet. A SVID assigned
+ *      to the un-match is also retrieved by this API. The parameter pSvid is
+ *      only refernced when the action is UNMATCH_ASSIGN
+ */
+rtk_api_ret_t rtk_svlan_unmatch_action_get(rtk_svlan_unmatch_action_t *pAction, rtk_vlan_t *pSvid)
+{
+    rtk_api_ret_t   retVal;
+    rtk_uint32      svidx;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pAction || NULL == pSvid)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicSvlanIngressUnmatch(pAction)) != RT_ERR_OK)
+        return retVal;
+
+    if(*pAction == UNMATCH_ASSIGN)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanUnmatchVlan(&svidx)) != RT_ERR_OK)
+            return retVal;
+
+        if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(svidx, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+
+        *pSvid = svlanMemConf.vs_svid;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_unassign_action_set
+ * Description:
+ *      Configure Action of upstream without svid assign action
+ * Input:
+ *      action  - Action for Un-assign
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can configure action of upstream Un-assign svid packet. If action is not
+ *      trap to CPU, the port-based SVID sure be assign as system need
+ */
+rtk_api_ret_t rtk_svlan_unassign_action_set(rtk_svlan_unassign_action_t action)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (action >= UNASSIGN_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicSvlanEgressUnassign((rtk_uint32)action);
+
+    return retVal;
+}
+
+/* Function Name:
+ *      rtk_svlan_unassign_action_get
+ * Description:
+ *      Get action of upstream without svid assignment
+ * Input:
+ *      None
+ * Output:
+ *      pAction  - Action for Un-assign
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_svlan_unassign_action_get(rtk_svlan_unassign_action_t *pAction)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pAction)
+        return RT_ERR_NULL_POINTER;
+
+    retVal = rtl8367c_getAsicSvlanEgressUnassign(pAction);
+
+    return retVal;
+}
+
+/* Function Name:
+ *      rtk_svlan_dmac_vidsel_set
+ * Description:
+ *      Set DMAC CVID selection
+ * Input:
+ *      port    - Port
+ *      enable  - state of DMAC CVID Selection
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      This API can set DMAC CVID Selection state
+ */
+rtk_api_ret_t rtk_svlan_dmac_vidsel_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicSvlanDmacCvidSel(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
+            return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_dmac_vidsel_get
+ * Description:
+ *      Get DMAC CVID selection
+ * Input:
+ *      port    - Port
+ * Output:
+ *      pEnable - state of DMAC CVID Selection
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      This API can get DMAC CVID Selection state
+ */
+rtk_api_ret_t rtk_svlan_dmac_vidsel_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if ((retVal = rtl8367c_getAsicSvlanDmacCvidSel(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+            return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_svlan_ipmc2s_add
+ * Description:
+ *      add ip multicast address to SVLAN
+ * Input:
+ *      svid    - SVLAN VID
+ *      ipmc    - ip multicast address
+ *      ipmcMsk - ip multicast mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can set IP mutlicast to SVID configuration. If upstream packet is IPv4 multicast
+ *      packet and DIP is matched MC2S configuration, ASIC will assign egress SVID to the packet.
+ *      There are 32 SVLAN multicast configurations for IP and L2 multicast.
+ */
+rtk_api_ret_t rtk_svlan_ipmc2s_add(ipaddr_t ipmc, ipaddr_t ipmcMsk,rtk_vlan_t svid)
+{
+    rtk_api_ret_t retVal, i;
+    rtk_uint32 empty_idx;
+    rtk_uint32 svidx;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtl8367c_svlan_mc2s_t svlanMC2SConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (svid > RTL8367C_VIDMAX)
+        return RT_ERR_SVLAN_VID;
+
+    if ((ipmc&0xF0000000)!=0xE0000000)
+        return RT_ERR_INPUT;
+
+    svidx = 0xFFFF;
+
+    for (i = 0; i < RTL8367C_SVIDXNO; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (svid == svlanMemConf.vs_svid)
+        {
+            svidx = i;
+            break;
+        }
+    }
+
+    if (0xFFFF == svidx)
+            return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
+
+
+    empty_idx = 0xFFFF;
+
+    for (i = RTL8367C_MC2SIDXMAX; i >= 0; i--)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (TRUE == svlanMC2SConf.valid)
+        {
+            if (svlanMC2SConf.format == SVLAN_MC2S_MODE_IP &&
+                svlanMC2SConf.sdata==ipmc&&
+                svlanMC2SConf.smask==ipmcMsk)
+            {
+                svlanMC2SConf.svidx = svidx;
+                if ((retVal = rtl8367c_setAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
+                    return retVal;
+            }
+        }
+        else
+        {
+            empty_idx = i;
+        }
+    }
+
+    if (empty_idx!=0xFFFF)
+    {
+        svlanMC2SConf.valid = TRUE;
+        svlanMC2SConf.svidx = svidx;
+        svlanMC2SConf.format = SVLAN_MC2S_MODE_IP;
+        svlanMC2SConf.sdata = ipmc;
+        svlanMC2SConf.smask = ipmcMsk;
+        if ((retVal = rtl8367c_setAsicSvlanMC2SConf(empty_idx, &svlanMC2SConf)) != RT_ERR_OK)
+            return retVal;
+        return RT_ERR_OK;
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+
+}
+
+/* Function Name:
+ *      rtk_svlan_ipmc2s_del
+ * Description:
+ *      delete ip multicast address to SVLAN
+ * Input:
+ *      ipmc    - ip multicast address
+ *      ipmcMsk - ip multicast mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_SVLAN_VID        - Invalid SVLAN VID parameter.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The API can delete IP mutlicast to SVID configuration. There are 32 SVLAN multicast configurations for IP and L2 multicast.
+ */
+rtk_api_ret_t rtk_svlan_ipmc2s_del(ipaddr_t ipmc, ipaddr_t ipmcMsk)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i;
+    rtl8367c_svlan_mc2s_t svlanMC2SConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((ipmc&0xF0000000)!=0xE0000000)
+        return RT_ERR_INPUT;
+
+    for (i = 0; i <= RTL8367C_MC2SIDXMAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (TRUE == svlanMC2SConf.valid)
+        {
+            if (svlanMC2SConf.format == SVLAN_MC2S_MODE_IP &&
+                svlanMC2SConf.sdata==ipmc&&
+                svlanMC2SConf.smask==ipmcMsk)
+            {
+                memset(&svlanMC2SConf, 0, sizeof(rtl8367c_svlan_mc2s_t));
+                if ((retVal = rtl8367c_setAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
+                    return retVal;
+                return RT_ERR_OK;
+            }
+        }
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+}
+
+/* Function Name:
+ *      rtk_svlan_ipmc2s_get
+ * Description:
+ *      Get ip multicast address to SVLAN
+ * Input:
+ *      ipmc    - ip multicast address
+ *      ipmcMsk - ip multicast mask
+ * Output:
+ *      pSvid - SVLAN VID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ * Note:
+ *      The API can get IP mutlicast to SVID configuration. There are 32 SVLAN multicast configurations for IP and L2 multicast.
+ */
+rtk_api_ret_t rtk_svlan_ipmc2s_get(ipaddr_t ipmc, ipaddr_t ipmcMsk, rtk_vlan_t *pSvid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtl8367c_svlan_mc2s_t svlanMC2SConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pSvid)
+        return RT_ERR_NULL_POINTER;
+
+    if ((ipmc&0xF0000000)!=0xE0000000)
+        return RT_ERR_INPUT;
+
+    for (i = 0; i <= RTL8367C_MC2SIDXMAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (TRUE == svlanMC2SConf.valid &&
+            svlanMC2SConf.format == SVLAN_MC2S_MODE_IP &&
+            svlanMC2SConf.sdata == ipmc &&
+            svlanMC2SConf.smask == ipmcMsk)
+        {
+            if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(svlanMC2SConf.svidx, &svlanMemConf)) != RT_ERR_OK)
+                return retVal;
+            *pSvid = svlanMemConf.vs_svid;
+            return RT_ERR_OK;
+        }
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+}
+
+/* Function Name:
+ *      rtk_svlan_l2mc2s_add
+ * Description:
+ *      Add L2 multicast address to SVLAN
+ * Input:
+ *      mac     - L2 multicast address
+ *      macMsk  - L2 multicast address mask
+ *      svid    - SVLAN VID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_SVLAN_VID                - Invalid SVLAN VID parameter.
+ *      RT_ERR_SVLAN_ENTRY_NOT_FOUND    - specified svlan entry not found.
+ *      RT_ERR_OUT_OF_RANGE             - input out of range.
+ *      RT_ERR_INPUT                    - Invalid input parameters.
+ * Note:
+ *      The API can set L2 Mutlicast to SVID configuration. If upstream packet is L2 multicast
+ *      packet and DMAC is matched, ASIC will assign egress SVID to the packet. There are 32
+ *      SVLAN multicast configurations for IP and L2 multicast.
+ */
+rtk_api_ret_t rtk_svlan_l2mc2s_add(rtk_mac_t mac, rtk_mac_t macMsk, rtk_vlan_t svid)
+{
+    rtk_api_ret_t retVal, i;
+    rtk_uint32 empty_idx;
+    rtk_uint32 svidx, l2add, l2Mask;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtl8367c_svlan_mc2s_t svlanMC2SConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (svid > RTL8367C_VIDMAX)
+        return RT_ERR_SVLAN_VID;
+
+    if (mac.octet[0]!= 1&&mac.octet[1]!=0)
+        return RT_ERR_INPUT;
+
+    l2add = (mac.octet[2] << 24) | (mac.octet[3] << 16) | (mac.octet[4] << 8) | mac.octet[5];
+    l2Mask = (macMsk.octet[2] << 24) | (macMsk.octet[3] << 16) | (macMsk.octet[4] << 8) | macMsk.octet[5];
+
+    svidx = 0xFFFF;
+
+    for (i = 0; i < RTL8367C_SVIDXNO; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (svid == svlanMemConf.vs_svid)
+        {
+            svidx = i;
+            break;
+        }
+    }
+
+    if (0xFFFF == svidx)
+        return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
+
+    empty_idx = 0xFFFF;
+
+    for (i = RTL8367C_MC2SIDXMAX; i >=0; i--)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (TRUE == svlanMC2SConf.valid)
+        {
+            if (svlanMC2SConf.format == SVLAN_MC2S_MODE_MAC &&
+                svlanMC2SConf.sdata==l2add&&
+                svlanMC2SConf.smask==l2Mask)
+            {
+                svlanMC2SConf.svidx = svidx;
+                if ((retVal = rtl8367c_setAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
+                    return retVal;
+            }
+        }
+        else
+        {
+            empty_idx = i;
+        }
+    }
+
+    if (empty_idx!=0xFFFF)
+    {
+        svlanMC2SConf.valid = TRUE;
+        svlanMC2SConf.svidx = svidx;
+        svlanMC2SConf.format = SVLAN_MC2S_MODE_MAC;
+        svlanMC2SConf.sdata = l2add;
+        svlanMC2SConf.smask = l2Mask;
+
+        if ((retVal = rtl8367c_setAsicSvlanMC2SConf(empty_idx, &svlanMC2SConf)) != RT_ERR_OK)
+            return retVal;
+        return RT_ERR_OK;
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+}
+
+/* Function Name:
+ *      rtk_svlan_l2mc2s_del
+ * Description:
+ *      delete L2 multicast address to SVLAN
+ * Input:
+ *      mac     - L2 multicast address
+ *      macMsk  - L2 multicast address mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_SVLAN_VID        - Invalid SVLAN VID parameter.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The API can delete Mutlicast to SVID configuration. There are 32 SVLAN multicast configurations for IP and L2 multicast.
+ */
+rtk_api_ret_t rtk_svlan_l2mc2s_del(rtk_mac_t mac, rtk_mac_t macMsk)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i;
+    rtk_uint32 l2add, l2Mask;
+    rtl8367c_svlan_mc2s_t svlanMC2SConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (mac.octet[0]!= 1&&mac.octet[1]!=0)
+        return RT_ERR_INPUT;
+
+    l2add = (mac.octet[2] << 24) | (mac.octet[3] << 16) | (mac.octet[4] << 8) | mac.octet[5];
+    l2Mask = (macMsk.octet[2] << 24) | (macMsk.octet[3] << 16) | (macMsk.octet[4] << 8) | macMsk.octet[5];
+
+    for (i = 0; i <= RTL8367C_MC2SIDXMAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (TRUE == svlanMC2SConf.valid)
+        {
+            if (svlanMC2SConf.format == SVLAN_MC2S_MODE_MAC &&
+                svlanMC2SConf.sdata==l2add&&
+                svlanMC2SConf.smask==l2Mask)
+            {
+                memset(&svlanMC2SConf, 0, sizeof(rtl8367c_svlan_mc2s_t));
+                if ((retVal = rtl8367c_setAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
+                    return retVal;
+                return RT_ERR_OK;
+            }
+        }
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+}
+
+/* Function Name:
+ *      rtk_svlan_l2mc2s_get
+ * Description:
+ *      Get L2 multicast address to SVLAN
+ * Input:
+ *      mac     - L2 multicast address
+ *      macMsk  - L2 multicast address mask
+ * Output:
+ *      pSvid - SVLAN VID
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_INPUT            - Invalid input parameters.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The API can get L2 mutlicast to SVID configuration. There are 32 SVLAN multicast configurations for IP and L2 multicast.
+ */
+rtk_api_ret_t rtk_svlan_l2mc2s_get(rtk_mac_t mac, rtk_mac_t macMsk, rtk_vlan_t *pSvid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i;
+    rtk_uint32 l2add,l2Mask;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtl8367c_svlan_mc2s_t svlanMC2SConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pSvid)
+        return RT_ERR_NULL_POINTER;
+
+    if (mac.octet[0]!= 1&&mac.octet[1]!=0)
+        return RT_ERR_INPUT;
+
+    l2add = (mac.octet[2] << 24) | (mac.octet[3] << 16) | (mac.octet[4] << 8) | mac.octet[5];
+    l2Mask = (macMsk.octet[2] << 24) | (macMsk.octet[3] << 16) | (macMsk.octet[4] << 8) | macMsk.octet[5];
+
+    for (i = 0; i <= RTL8367C_MC2SIDXMAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMC2SConf(i, &svlanMC2SConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (TRUE == svlanMC2SConf.valid)
+        {
+            if (svlanMC2SConf.format == SVLAN_MC2S_MODE_MAC &&
+                svlanMC2SConf.sdata==l2add&&
+                svlanMC2SConf.smask==l2Mask)
+            {
+                if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(svlanMC2SConf.svidx, &svlanMemConf)) != RT_ERR_OK)
+                    return retVal;
+                *pSvid = svlanMemConf.vs_svid;
+
+                return RT_ERR_OK;
+            }
+        }
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+}
+
+/* Function Name:
+ *      rtk_svlan_sp2c_add
+ * Description:
+ *      Add system SP2C configuration
+ * Input:
+ *      cvid        - VLAN ID
+ *      dst_port    - Destination port of SVLAN to CVLAN configuration
+ *      svid        - SVLAN VID
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_SVLAN_VID    - Invalid SVLAN VID parameter.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      The API can add SVID & Destination Port to CVLAN configuration. The downstream frames with assigned
+ *      SVID will be add C-tag with assigned CVID if the output port is the assigned destination port.
+ *      There are 128 SP2C configurations.
+ */
+rtk_api_ret_t rtk_svlan_sp2c_add(rtk_vlan_t svid, rtk_port_t dst_port, rtk_vlan_t cvid)
+{
+    rtk_api_ret_t retVal, i;
+    rtk_uint32 empty_idx, svidx;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtl8367c_svlan_s2c_t svlanSP2CConf;
+    rtk_port_t port;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (svid > RTL8367C_VIDMAX)
+        return RT_ERR_SVLAN_VID;
+
+    if (cvid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(dst_port);
+    port = rtk_switch_port_L2P_get(dst_port);
+
+    svidx = 0xFFFF;
+
+    for (i = 0; i < RTL8367C_SVIDXNO; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (svid == svlanMemConf.vs_svid)
+        {
+            svidx = i;
+            break;
+        }
+    }
+
+    if (0xFFFF == svidx)
+        return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
+
+    empty_idx = 0xFFFF;
+
+    for (i=RTL8367C_SP2CMAX; i >=0 ; i--)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanSP2CConf(i, &svlanSP2CConf)) != RT_ERR_OK)
+            return retVal;
+
+        if ( (svlanSP2CConf.svidx == svidx) && (svlanSP2CConf.dstport == port) && (svlanSP2CConf.valid == 1))
+        {
+            empty_idx = i;
+            break;
+        }
+        else if (svlanSP2CConf.valid == 0)
+        {
+            empty_idx = i;
+        }
+    }
+
+    if (empty_idx!=0xFFFF)
+    {
+        svlanSP2CConf.valid     = 1;
+        svlanSP2CConf.vid       = cvid;
+        svlanSP2CConf.svidx     = svidx;
+        svlanSP2CConf.dstport   = port;
+
+        if ((retVal = rtl8367c_setAsicSvlanSP2CConf(empty_idx, &svlanSP2CConf)) != RT_ERR_OK)
+            return retVal;
+        return RT_ERR_OK;
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+
+}
+
+/* Function Name:
+ *      rtk_svlan_sp2c_get
+ * Description:
+ *      Get configure system SP2C content
+ * Input:
+ *      svid        - SVLAN VID
+ *      dst_port    - Destination port of SVLAN to CVLAN configuration
+ * Output:
+ *      pCvid - VLAN ID
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_SVLAN_VID    - Invalid SVLAN VID parameter.
+ * Note:
+ *     The API can get SVID & Destination Port to CVLAN configuration. There are 128 SP2C configurations.
+ */
+rtk_api_ret_t rtk_svlan_sp2c_get(rtk_vlan_t svid, rtk_port_t dst_port, rtk_vlan_t *pCvid)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i, svidx;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtl8367c_svlan_s2c_t svlanSP2CConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pCvid)
+        return RT_ERR_NULL_POINTER;
+
+    if (svid > RTL8367C_VIDMAX)
+        return RT_ERR_SVLAN_VID;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(dst_port);
+    dst_port = rtk_switch_port_L2P_get(dst_port);
+
+    svidx = 0xFFFF;
+
+    for (i = 0; i < RTL8367C_SVIDXNO; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (svid == svlanMemConf.vs_svid)
+        {
+            svidx = i;
+            break;
+        }
+    }
+
+    if (0xFFFF == svidx)
+        return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
+
+    for (i = 0; i <= RTL8367C_SP2CMAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanSP2CConf(i, &svlanSP2CConf)) != RT_ERR_OK)
+            return retVal;
+
+        if ( (svlanSP2CConf.svidx == svidx) && (svlanSP2CConf.dstport == dst_port) && (svlanSP2CConf.valid == 1) )
+        {
+            *pCvid = svlanSP2CConf.vid;
+            return RT_ERR_OK;
+        }
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+}
+
+/* Function Name:
+ *      rtk_svlan_sp2c_del
+ * Description:
+ *      Delete system SP2C configuration
+ * Input:
+ *      svid        - SVLAN VID
+ *      dst_port    - Destination port of SVLAN to CVLAN configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_SVLAN_VID    - Invalid SVLAN VID parameter.
+ *      RT_ERR_OUT_OF_RANGE - input out of range.
+ * Note:
+ *      The API can delete SVID & Destination Port to CVLAN configuration. There are 128 SP2C configurations.
+ */
+rtk_api_ret_t rtk_svlan_sp2c_del(rtk_vlan_t svid, rtk_port_t dst_port)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i, svidx;
+    rtl8367c_svlan_memconf_t svlanMemConf;
+    rtl8367c_svlan_s2c_t svlanSP2CConf;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (svid > RTL8367C_VIDMAX)
+        return RT_ERR_SVLAN_VID;
+
+    /* Check port Valid */
+    RTK_CHK_PORT_VALID(dst_port);
+    dst_port = rtk_switch_port_L2P_get(dst_port);
+
+    svidx = 0xFFFF;
+
+    for (i = 0; i < RTL8367C_SVIDXNO; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanMemberConfiguration(i, &svlanMemConf)) != RT_ERR_OK)
+            return retVal;
+
+        if (svid == svlanMemConf.vs_svid)
+        {
+            svidx = i;
+            break;
+        }
+    }
+
+    if (0xFFFF == svidx)
+        return RT_ERR_SVLAN_ENTRY_NOT_FOUND;
+
+    for (i = 0; i <= RTL8367C_SP2CMAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicSvlanSP2CConf(i, &svlanSP2CConf)) != RT_ERR_OK)
+            return retVal;
+
+        if ( (svlanSP2CConf.svidx == svidx) && (svlanSP2CConf.dstport == dst_port) && (svlanSP2CConf.valid == 1) )
+        {
+            svlanSP2CConf.valid     = 0;
+            svlanSP2CConf.vid       = 0;
+            svlanSP2CConf.svidx     = 0;
+            svlanSP2CConf.dstport   = 0;
+
+            if ((retVal = rtl8367c_setAsicSvlanSP2CConf(i, &svlanSP2CConf)) != RT_ERR_OK)
+                return retVal;
+            return RT_ERR_OK;
+        }
+
+    }
+
+    return RT_ERR_OUT_OF_RANGE;
+}
+
+/* Function Name:
+ *      rtk_svlan_lookupType_set
+ * Description:
+ *      Set lookup type of SVLAN
+ * Input:
+ *      type        - lookup type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ * Note:
+ *      none
+ */
+rtk_api_ret_t rtk_svlan_lookupType_set(rtk_svlan_lookupType_t type)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= SVLAN_LOOKUP_END)
+        return RT_ERR_CHIP_NOT_SUPPORTED;
+
+
+    svlan_lookupType = type;
+
+    retVal = rtl8367c_setAsicSvlanLookupType((rtk_uint32)type);
+
+    return retVal;
+}
+
+/* Function Name:
+ *      rtk_svlan_lookupType_get
+ * Description:
+ *      Get lookup type of SVLAN
+ * Input:
+ *      pType       - lookup type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ * Note:
+ *      none
+ */
+rtk_api_ret_t rtk_svlan_lookupType_get(rtk_svlan_lookupType_t *pType)
+{
+    rtk_api_ret_t   retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pType)
+        return RT_ERR_NULL_POINTER;
+
+    retVal = rtl8367c_getAsicSvlanLookupType(pType);
+
+    svlan_lookupType = *pType;
+
+    return retVal;
+}
+
+/* Function Name:
+ *      rtk_svlan_trapPri_set
+ * Description:
+ *      Set svlan trap priority
+ * Input:
+ *      priority - priority for trap packets
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_QOS_INT_PRIORITY
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_svlan_trapPri_set(rtk_pri_t priority)
+{
+    rtk_api_ret_t   retVal;
+
+    RTK_CHK_INIT_STATE();
+
+    if(priority > RTL8367C_PRIMAX)
+        return RT_ERR_OUT_OF_RANGE;
+
+    retVal = rtl8367c_setAsicSvlanTrapPriority(priority);
+
+    return retVal;
+}   /* end of rtk_svlan_trapPri_set */
+
+/* Function Name:
+ *      rtk_svlan_trapPri_get
+ * Description:
+ *      Get svlan trap priority
+ * Input:
+ *      None
+ * Output:
+ *      pPriority - priority for trap packets
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      None
+ */
+rtk_api_ret_t rtk_svlan_trapPri_get(rtk_pri_t *pPriority)
+{
+    rtk_api_ret_t   retVal;
+
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pPriority)
+        return RT_ERR_NULL_POINTER;
+
+    retVal = rtl8367c_getAsicSvlanTrapPriority(pPriority);
+
+    return retVal;
+}   /* end of rtk_svlan_trapPri_get */
+
+
+/* Function Name:
+ *      rtk_svlan_checkAndCreateMbr
+ * Description:
+ *      Check and create Member configuration and return index
+ * Input:
+ *      vid  - VLAN id.
+ * Output:
+ *      pIndex  - Member configuration index
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_VLAN_VID     - Invalid VLAN ID.
+ *      RT_ERR_TBL_FULL     - Member Configuration table full
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_svlan_checkAndCreateMbr(rtk_vlan_t vid, rtk_uint32 *pIndex)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 svidx;
+    rtk_uint32 empty_idx = 0xFFFF;
+    rtl8367c_svlan_memconf_t svlan_cfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* vid must be 0~4095 */
+    if (vid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    /* Null pointer check */
+    if(NULL == pIndex)
+        return RT_ERR_NULL_POINTER;
+
+    /* Search exist entry */
+    for (svidx = 0; svidx <= RTL8367C_SVIDXMAX; svidx++)
+    {
+        if(svlan_mbrCfgUsage[svidx] == TRUE)
+        {
+            if(svlan_mbrCfgVid[svidx] == vid)
+            {
+                /* Found! return index */
+                *pIndex = svidx;
+                return RT_ERR_OK;
+            }
+        }
+        else if(empty_idx == 0xFFFF)
+        {
+            empty_idx = svidx;
+        }
+
+    }
+
+    if(empty_idx == 0xFFFF)
+    {
+        /* No empty index */
+        return RT_ERR_TBL_FULL;
+    }
+
+    svlan_mbrCfgUsage[empty_idx] = TRUE;
+    svlan_mbrCfgVid[empty_idx] = vid;
+
+    memset(&svlan_cfg, 0, sizeof(rtl8367c_svlan_memconf_t));
+
+    svlan_cfg.vs_svid = vid;
+    /*for create check*/
+    if(vid == 0)
+    {
+        svlan_cfg.vs_efid = 1;
+    }
+
+    if((retVal = rtl8367c_setAsicSvlanMemberConfiguration(empty_idx, &svlan_cfg)) != RT_ERR_OK)
+        return retVal;
+
+    *pIndex = empty_idx;
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/trap.c b/drivers/net/phy/rtk/rtl8367c/trap.c
new file mode 100644
index 0000000000000..5ab6078e50f3d
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/trap.c
@@ -0,0 +1,1229 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in Trap module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <trap.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_port.h>
+#include <rtl8367c_asicdrv_igmp.h>
+#include <rtl8367c_asicdrv_rma.h>
+#include <rtl8367c_asicdrv_eav.h>
+#include <rtl8367c_asicdrv_oam.h>
+#include <rtl8367c_asicdrv_svlan.h>
+#include <rtl8367c_asicdrv_unknownMulticast.h>
+#include <rtl8367c_asicdrv_dot1x.h>
+
+/* Function Name:
+ *      rtk_trap_unknownUnicastPktAction_set
+ * Description:
+ *      Set unknown unicast packet action configuration.
+ * Input:
+ *      port            - ingress port ID for unknown unicast packet
+ *      ucast_action    - Unknown unicast action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ *      This API can set unknown unicast packet action configuration.
+ *      The unknown unicast action is as following:
+ *          - UCAST_ACTION_FORWARD_PMASK
+ *          - UCAST_ACTION_DROP
+ *          - UCAST_ACTION_TRAP2CPU
+ *          - UCAST_ACTION_FLOODING
+ */
+rtk_api_ret_t rtk_trap_unknownUnicastPktAction_set(rtk_port_t port, rtk_trap_ucast_action_t ucast_action)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (ucast_action >= UCAST_ACTION_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicPortUnknownDaBehavior(rtk_switch_port_L2P_get(port), ucast_action)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_unknownUnicastPktAction_get
+ * Description:
+ *      Get unknown unicast packet action configuration.
+ * Input:
+ *      port            - ingress port ID for unknown unicast packet
+ * Output:
+ *      pUcast_action   - Unknown unicast action.
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ *      RT_ERR_NULL_POINTER        - Null pointer
+ * Note:
+ *      This API can get unknown unicast packet action configuration.
+ *      The unknown unicast action is as following:
+ *          - UCAST_ACTION_FORWARD_PMASK
+ *          - UCAST_ACTION_DROP
+ *          - UCAST_ACTION_TRAP2CPU
+ *          - UCAST_ACTION_FLOODING
+ */
+rtk_api_ret_t rtk_trap_unknownUnicastPktAction_get(rtk_port_t port, rtk_trap_ucast_action_t *pUcast_action)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (NULL == pUcast_action)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortUnknownDaBehavior(rtk_switch_port_L2P_get(port), pUcast_action)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_unknownMacPktAction_set
+ * Description:
+ *      Set unknown source MAC packet action configuration.
+ * Input:
+ *      ucast_action    - Unknown source MAC action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ *      This API can set unknown unicast packet action configuration.
+ *      The unknown unicast action is as following:
+ *          - UCAST_ACTION_FORWARD_PMASK
+ *          - UCAST_ACTION_DROP
+ *          - UCAST_ACTION_TRAP2CPU
+ */
+rtk_api_ret_t rtk_trap_unknownMacPktAction_set(rtk_trap_ucast_action_t ucast_action)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (ucast_action >= UCAST_ACTION_FLOODING)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicPortUnknownSaBehavior(ucast_action)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_unknownMacPktAction_get
+ * Description:
+ *      Get unknown source MAC packet action configuration.
+ * Input:
+ *      None.
+ * Output:
+ *      pUcast_action   - Unknown source MAC action.
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NULL_POINTER        - Null Pointer.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_trap_unknownMacPktAction_get(rtk_trap_ucast_action_t *pUcast_action)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pUcast_action)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortUnknownSaBehavior(pUcast_action)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_unmatchMacPktAction_set
+ * Description:
+ *      Set unmatch source MAC packet action configuration.
+ * Input:
+ *      ucast_action    - Unknown source MAC action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ *      This API can set unknown unicast packet action configuration.
+ *      The unknown unicast action is as following:
+ *          - UCAST_ACTION_FORWARD_PMASK
+ *          - UCAST_ACTION_DROP
+ *          - UCAST_ACTION_TRAP2CPU
+ */
+rtk_api_ret_t rtk_trap_unmatchMacPktAction_set(rtk_trap_ucast_action_t ucast_action)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (ucast_action >= UCAST_ACTION_FLOODING)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicPortUnmatchedSaBehavior(ucast_action)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_unmatchMacPktAction_get
+ * Description:
+ *      Get unmatch source MAC packet action configuration.
+ * Input:
+ *      None.
+ * Output:
+ *      pUcast_action   - Unknown source MAC action.
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ *      This API can set unknown unicast packet action configuration.
+ *      The unknown unicast action is as following:
+ *          - UCAST_ACTION_FORWARD_PMASK
+ *          - UCAST_ACTION_DROP
+ *          - UCAST_ACTION_TRAP2CPU
+ */
+rtk_api_ret_t rtk_trap_unmatchMacPktAction_get(rtk_trap_ucast_action_t *pUcast_action)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pUcast_action)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortUnmatchedSaBehavior(pUcast_action)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_unmatchMacMoving_set
+ * Description:
+ *      Set unmatch source MAC packet moving state.
+ * Input:
+ *      port        - Port ID.
+ *      enable      - ENABLED: allow SA moving, DISABLE: don't allow SA moving.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ */
+rtk_api_ret_t rtk_trap_unmatchMacMoving_set(rtk_port_t port, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicPortUnmatchedSaMoving(rtk_switch_port_L2P_get(port), enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_unmatchMacMoving_get
+ * Description:
+ *      Set unmatch source MAC packet moving state.
+ * Input:
+ *      port        - Port ID.
+ * Output:
+ *      pEnable     - ENABLED: allow SA moving, DISABLE: don't allow SA moving.
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT               - Invalid input parameters.
+ * Note:
+ */
+rtk_api_ret_t rtk_trap_unmatchMacMoving_get(rtk_port_t port, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* check port valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortUnmatchedSaMoving(rtk_switch_port_L2P_get(port), pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_unknownMcastPktAction_set
+ * Description:
+ *      Set behavior of unknown multicast
+ * Input:
+ *      port            - Port id.
+ *      type            - unknown multicast packet type.
+ *      mcast_action    - unknown multicast action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID         - Invalid port number.
+ *      RT_ERR_NOT_ALLOWED     - Invalid action.
+ *      RT_ERR_INPUT         - Invalid input parameters.
+ * Note:
+ *      When receives an unknown multicast packet, switch may trap, drop or flood this packet
+ *      (1) The unknown multicast packet type is as following:
+ *          - MCAST_L2
+ *          - MCAST_IPV4
+ *          - MCAST_IPV6
+ *      (2) The unknown multicast action is as following:
+ *          - MCAST_ACTION_FORWARD
+ *          - MCAST_ACTION_DROP
+ *          - MCAST_ACTION_TRAP2CPU
+ */
+rtk_api_ret_t rtk_trap_unknownMcastPktAction_set(rtk_port_t port, rtk_mcast_type_t type, rtk_trap_mcast_action_t mcast_action)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 rawAction;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (type >= MCAST_END)
+        return RT_ERR_INPUT;
+
+    if (mcast_action >= MCAST_ACTION_END)
+        return RT_ERR_INPUT;
+
+
+    switch (type)
+    {
+        case MCAST_L2:
+            if (MCAST_ACTION_ROUTER_PORT == mcast_action)
+                return RT_ERR_INPUT;
+            else if(MCAST_ACTION_DROP_EX_RMA == mcast_action)
+                rawAction = L2_UNKOWN_MULTICAST_DROP_EXCLUDE_RMA;
+            else
+                rawAction = (rtk_uint32)mcast_action;
+
+            if ((retVal = rtl8367c_setAsicUnknownL2MulticastBehavior(rtk_switch_port_L2P_get(port), rawAction)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        case MCAST_IPV4:
+            if (MCAST_ACTION_DROP_EX_RMA == mcast_action)
+                return RT_ERR_INPUT;
+            else
+                rawAction = (rtk_uint32)mcast_action;
+
+            if ((retVal = rtl8367c_setAsicUnknownIPv4MulticastBehavior(rtk_switch_port_L2P_get(port), rawAction)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        case MCAST_IPV6:
+            if (MCAST_ACTION_DROP_EX_RMA == mcast_action)
+                return RT_ERR_INPUT;
+            else
+                rawAction = (rtk_uint32)mcast_action;
+
+            if ((retVal = rtl8367c_setAsicUnknownIPv6MulticastBehavior(rtk_switch_port_L2P_get(port), rawAction)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        default:
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_unknownMcastPktAction_get
+ * Description:
+ *      Get behavior of unknown multicast
+ * Input:
+ *      type - unknown multicast packet type.
+ * Output:
+ *      pMcast_action - unknown multicast action.
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_PORT_ID             - Invalid port number.
+ *      RT_ERR_NOT_ALLOWED         - Invalid operation.
+ *      RT_ERR_INPUT             - Invalid input parameters.
+ * Note:
+ *      When receives an unknown multicast packet, switch may trap, drop or flood this packet
+ *      (1) The unknown multicast packet type is as following:
+ *          - MCAST_L2
+ *          - MCAST_IPV4
+ *          - MCAST_IPV6
+ *      (2) The unknown multicast action is as following:
+ *          - MCAST_ACTION_FORWARD
+ *          - MCAST_ACTION_DROP
+ *          - MCAST_ACTION_TRAP2CPU
+ */
+rtk_api_ret_t rtk_trap_unknownMcastPktAction_get(rtk_port_t port, rtk_mcast_type_t type, rtk_trap_mcast_action_t *pMcast_action)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 rawAction;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (type >= MCAST_END)
+        return RT_ERR_INPUT;
+
+    if(NULL == pMcast_action)
+        return RT_ERR_NULL_POINTER;
+
+    switch (type)
+    {
+        case MCAST_L2:
+            if ((retVal = rtl8367c_getAsicUnknownL2MulticastBehavior(rtk_switch_port_L2P_get(port), &rawAction)) != RT_ERR_OK)
+                return retVal;
+
+            if(L2_UNKOWN_MULTICAST_DROP_EXCLUDE_RMA == rawAction)
+                *pMcast_action = MCAST_ACTION_DROP_EX_RMA;
+            else
+                *pMcast_action = (rtk_trap_mcast_action_t)rawAction;
+
+            break;
+        case MCAST_IPV4:
+            if ((retVal = rtl8367c_getAsicUnknownIPv4MulticastBehavior(rtk_switch_port_L2P_get(port), &rawAction)) != RT_ERR_OK)
+                return retVal;
+
+            *pMcast_action = (rtk_trap_mcast_action_t)rawAction;
+            break;
+        case MCAST_IPV6:
+            if ((retVal = rtl8367c_getAsicUnknownIPv6MulticastBehavior(rtk_switch_port_L2P_get(port), &rawAction)) != RT_ERR_OK)
+                return retVal;
+
+            *pMcast_action = (rtk_trap_mcast_action_t)rawAction;
+            break;
+        default:
+            break;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_lldpEnable_set
+ * Description:
+ *      Set LLDP enable.
+ * Input:
+ *      enabled - LLDP enable, 0: follow RMA, 1: use LLDP action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                  - OK
+ *      RT_ERR_FAILED              - Failed
+ *      RT_ERR_SMI                 - SMI access error
+ *      RT_ERR_NOT_ALLOWED         - Invalid action.
+ *      RT_ERR_INPUT             - Invalid input parameters.
+ * Note:
+ *      - DMAC                                                 Assignment
+ *      - 01:80:c2:00:00:0e ethertype = 0x88CC    LLDP
+ *      - 01:80:c2:00:00:03 ethertype = 0x88CC
+ *      - 01:80:c2:00:00:00 ethertype = 0x88CC
+
+ */
+rtk_api_ret_t rtk_trap_lldpEnable_set(rtk_enable_t enabled)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+    rtk_enable_t tmp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (enabled >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicRmaLldp(enabled, &rmacfg)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_lldpEnable_get
+ * Description:
+ *      Get LLDP status.
+ * Input:
+ *      None
+ * Output:
+ *      pEnabled - LLDP enable, 0: follow RMA, 1: use LLDP action.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT         - Invalid input parameters.
+ * Note:
+ *      LLDP is as following definition.
+ *      - DMAC                                                 Assignment
+ *      - 01:80:c2:00:00:0e ethertype = 0x88CC    LLDP
+ *      - 01:80:c2:00:00:03 ethertype = 0x88CC
+ *      - 01:80:c2:00:00:00 ethertype = 0x88CC
+ */
+rtk_api_ret_t rtk_trap_lldpEnable_get(rtk_enable_t *pEnabled)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnabled)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicRmaLldp(pEnabled, &rmacfg)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_reasonTrapToCpuPriority_set
+ * Description:
+ *      Set priority value of a packet that trapped to CPU port according to specific reason.
+ * Input:
+ *      type     - reason that trap to CPU port.
+ *      priority - internal priority that is going to be set for specific trap reason.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT - The module is not initial
+ *      RT_ERR_INPUT    - Invalid input parameter
+ * Note:
+ *      Currently the trap reason that supported are listed as follows:
+ *      - TRAP_REASON_RMA
+ *      - TRAP_REASON_OAM
+ *      - TRAP_REASON_1XUNAUTH
+ *      - TRAP_REASON_VLANSTACK
+ *      - TRAP_REASON_UNKNOWNMC
+ */
+rtk_api_ret_t rtk_trap_reasonTrapToCpuPriority_set(rtk_trap_reason_type_t type, rtk_pri_t priority)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= TRAP_REASON_END)
+        return RT_ERR_INPUT;
+
+    if (priority > RTL8367C_PRIMAX)
+        return  RT_ERR_QOS_INT_PRIORITY;
+
+    switch (type)
+    {
+        case TRAP_REASON_RMA:
+            if ((retVal = rtl8367c_getAsicRma(0, &rmacfg)) != RT_ERR_OK)
+                return retVal;
+            rmacfg.trap_priority= priority;
+            if ((retVal = rtl8367c_setAsicRma(0, &rmacfg)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        case TRAP_REASON_OAM:
+            if ((retVal = rtl8367c_setAsicOamCpuPri(priority)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        case TRAP_REASON_1XUNAUTH:
+            if ((retVal = rtl8367c_setAsic1xTrapPriority(priority)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        case TRAP_REASON_VLANSTACK:
+            if ((retVal = rtl8367c_setAsicSvlanTrapPriority(priority)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        case TRAP_REASON_UNKNOWNMC:
+            if ((retVal = rtl8367c_setAsicUnknownMulticastTrapPriority(priority)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        default:
+            return RT_ERR_CHIP_NOT_SUPPORTED;
+    }
+
+
+    return RT_ERR_OK;
+}
+
+
+/* Function Name:
+ *      rtk_trap_reasonTrapToCpuPriority_get
+ * Description:
+ *      Get priority value of a packet that trapped to CPU port according to specific reason.
+ * Input:
+ *      type      - reason that trap to CPU port.
+ * Output:
+ *      pPriority - configured internal priority for such reason.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NOT_INIT     - The module is not initial
+ *      RT_ERR_INPUT        - Invalid input parameter
+ *      RT_ERR_NULL_POINTER - NULL pointer
+ * Note:
+ *      Currently the trap reason that supported are listed as follows:
+ *      - TRAP_REASON_RMA
+ *      - TRAP_REASON_OAM
+ *      - TRAP_REASON_1XUNAUTH
+ *      - TRAP_REASON_VLANSTACK
+ *      - TRAP_REASON_UNKNOWNMC
+ */
+rtk_api_ret_t rtk_trap_reasonTrapToCpuPriority_get(rtk_trap_reason_type_t type, rtk_pri_t *pPriority)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= TRAP_REASON_END)
+        return RT_ERR_INPUT;
+
+    if(NULL == pPriority)
+        return RT_ERR_NULL_POINTER;
+
+    switch (type)
+    {
+        case TRAP_REASON_RMA:
+            if ((retVal = rtl8367c_getAsicRma(0, &rmacfg)) != RT_ERR_OK)
+                return retVal;
+            *pPriority = rmacfg.trap_priority;
+
+            break;
+        case TRAP_REASON_OAM:
+            if ((retVal = rtl8367c_getAsicOamCpuPri(pPriority)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        case TRAP_REASON_1XUNAUTH:
+            if ((retVal = rtl8367c_getAsic1xTrapPriority(pPriority)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        case TRAP_REASON_VLANSTACK:
+            if ((retVal = rtl8367c_getAsicSvlanTrapPriority(pPriority)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        case TRAP_REASON_UNKNOWNMC:
+            if ((retVal = rtl8367c_getAsicUnknownMulticastTrapPriority(pPriority)) != RT_ERR_OK)
+                return retVal;
+
+            break;
+        default:
+            return RT_ERR_CHIP_NOT_SUPPORTED;
+
+    }
+
+    return RT_ERR_OK;
+}
+
+
+
+/* Function Name:
+ *      rtk_trap_rmaAction_set
+ * Description:
+ *      Set Reserved multicast address action configuration.
+ * Input:
+ *      type    - rma type.
+ *      rma_action - RMA action.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *
+ *      There are 48 types of Reserved Multicast Address frame for application usage.
+ *      (1)They are as following definition.
+ *      - TRAP_BRG_GROUP,
+ *      - TRAP_FD_PAUSE,
+ *      - TRAP_SP_MCAST,
+ *      - TRAP_1X_PAE,
+ *      - TRAP_UNDEF_BRG_04,
+ *      - TRAP_UNDEF_BRG_05,
+ *      - TRAP_UNDEF_BRG_06,
+ *      - TRAP_UNDEF_BRG_07,
+ *      - TRAP_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - TRAP_UNDEF_BRG_09,
+ *      - TRAP_UNDEF_BRG_0A,
+ *      - TRAP_UNDEF_BRG_0B,
+ *      - TRAP_UNDEF_BRG_0C,
+ *      - TRAP_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - TRAP_8021AB,
+ *      - TRAP_UNDEF_BRG_0F,
+ *      - TRAP_BRG_MNGEMENT,
+ *      - TRAP_UNDEFINED_11,
+ *      - TRAP_UNDEFINED_12,
+ *      - TRAP_UNDEFINED_13,
+ *      - TRAP_UNDEFINED_14,
+ *      - TRAP_UNDEFINED_15,
+ *      - TRAP_UNDEFINED_16,
+ *      - TRAP_UNDEFINED_17,
+ *      - TRAP_UNDEFINED_18,
+ *      - TRAP_UNDEFINED_19,
+ *      - TRAP_UNDEFINED_1A,
+ *      - TRAP_UNDEFINED_1B,
+ *      - TRAP_UNDEFINED_1C,
+ *      - TRAP_UNDEFINED_1D,
+ *      - TRAP_UNDEFINED_1E,
+ *      - TRAP_UNDEFINED_1F,
+ *      - TRAP_GMRP,
+ *      - TRAP_GVRP,
+ *      - TRAP_UNDEF_GARP_22,
+ *      - TRAP_UNDEF_GARP_23,
+ *      - TRAP_UNDEF_GARP_24,
+ *      - TRAP_UNDEF_GARP_25,
+ *      - TRAP_UNDEF_GARP_26,
+ *      - TRAP_UNDEF_GARP_27,
+ *      - TRAP_UNDEF_GARP_28,
+ *      - TRAP_UNDEF_GARP_29,
+ *      - TRAP_UNDEF_GARP_2A,
+ *      - TRAP_UNDEF_GARP_2B,
+ *      - TRAP_UNDEF_GARP_2C,
+ *      - TRAP_UNDEF_GARP_2D,
+ *      - TRAP_UNDEF_GARP_2E,
+ *      - TRAP_UNDEF_GARP_2F,
+ *      - TRAP_CDP.
+ *      - TRAP_CSSTP.
+ *      - TRAP_LLDP.
+ *      (2) The RMA action is as following:
+ *      - RMA_ACTION_FORWARD
+ *      - RMA_ACTION_TRAP2CPU
+ *      - RMA_ACTION_DROP
+ *      - RMA_ACTION_FORWARD_EXCLUDE_CPU
+ */
+rtk_api_ret_t rtk_trap_rmaAction_set(rtk_trap_type_t type, rtk_trap_rma_action_t rma_action)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+    rtk_uint32 tmp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= TRAP_END)
+        return RT_ERR_INPUT;
+
+    if (rma_action >= RMA_ACTION_END)
+        return RT_ERR_RMA_ACTION;
+
+    if (type >= 0 && type <= TRAP_UNDEF_GARP_2F)
+    {
+        if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.operation = rma_action;
+
+        if ((retVal = rtl8367c_setAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (type == TRAP_CDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.operation = rma_action;
+
+        if ((retVal = rtl8367c_setAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (type  == TRAP_CSSTP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.operation = rma_action;
+
+        if ((retVal = rtl8367c_setAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (type  == TRAP_LLDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.operation = rma_action;
+
+        if ((retVal = rtl8367c_setAsicRmaLldp(tmp, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_rmaAction_get
+ * Description:
+ *      Get Reserved multicast address action configuration.
+ * Input:
+ *      type - rma type.
+ * Output:
+ *      pRma_action - RMA action.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      There are 48 types of Reserved Multicast Address frame for application usage.
+ *      (1)They are as following definition.
+ *      - TRAP_BRG_GROUP,
+ *      - TRAP_FD_PAUSE,
+ *      - TRAP_SP_MCAST,
+ *      - TRAP_1X_PAE,
+ *      - TRAP_UNDEF_BRG_04,
+ *      - TRAP_UNDEF_BRG_05,
+ *      - TRAP_UNDEF_BRG_06,
+ *      - TRAP_UNDEF_BRG_07,
+ *      - TRAP_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - TRAP_UNDEF_BRG_09,
+ *      - TRAP_UNDEF_BRG_0A,
+ *      - TRAP_UNDEF_BRG_0B,
+ *      - TRAP_UNDEF_BRG_0C,
+ *      - TRAP_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - TRAP_8021AB,
+ *      - TRAP_UNDEF_BRG_0F,
+ *      - TRAP_BRG_MNGEMENT,
+ *      - TRAP_UNDEFINED_11,
+ *      - TRAP_UNDEFINED_12,
+ *      - TRAP_UNDEFINED_13,
+ *      - TRAP_UNDEFINED_14,
+ *      - TRAP_UNDEFINED_15,
+ *      - TRAP_UNDEFINED_16,
+ *      - TRAP_UNDEFINED_17,
+ *      - TRAP_UNDEFINED_18,
+ *      - TRAP_UNDEFINED_19,
+ *      - TRAP_UNDEFINED_1A,
+ *      - TRAP_UNDEFINED_1B,
+ *      - TRAP_UNDEFINED_1C,
+ *      - TRAP_UNDEFINED_1D,
+ *      - TRAP_UNDEFINED_1E,
+ *      - TRAP_UNDEFINED_1F,
+ *      - TRAP_GMRP,
+ *      - TRAP_GVRP,
+ *      - TRAP_UNDEF_GARP_22,
+ *      - TRAP_UNDEF_GARP_23,
+ *      - TRAP_UNDEF_GARP_24,
+ *      - TRAP_UNDEF_GARP_25,
+ *      - TRAP_UNDEF_GARP_26,
+ *      - TRAP_UNDEF_GARP_27,
+ *      - TRAP_UNDEF_GARP_28,
+ *      - TRAP_UNDEF_GARP_29,
+ *      - TRAP_UNDEF_GARP_2A,
+ *      - TRAP_UNDEF_GARP_2B,
+ *      - TRAP_UNDEF_GARP_2C,
+ *      - TRAP_UNDEF_GARP_2D,
+ *      - TRAP_UNDEF_GARP_2E,
+ *      - TRAP_UNDEF_GARP_2F,
+ *      - TRAP_CDP.
+ *      - TRAP_CSSTP.
+ *      - TRAP_LLDP.
+ *      (2) The RMA action is as following:
+ *      - RMA_ACTION_FORWARD
+ *      - RMA_ACTION_TRAP2CPU
+ *      - RMA_ACTION_DROP
+ *      - RMA_ACTION_FORWARD_EXCLUDE_CPU
+ */
+rtk_api_ret_t rtk_trap_rmaAction_get(rtk_trap_type_t type, rtk_trap_rma_action_t *pRma_action)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+    rtk_uint32 tmp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= TRAP_END)
+        return RT_ERR_INPUT;
+
+    if(NULL == pRma_action)
+        return RT_ERR_NULL_POINTER;
+
+    if (type >= 0 && type <= TRAP_UNDEF_GARP_2F)
+    {
+        if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pRma_action = rmacfg.operation;
+    }
+    else if (type == TRAP_CDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pRma_action = rmacfg.operation;
+    }
+    else if (type == TRAP_CSSTP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pRma_action = rmacfg.operation;
+    }
+    else if (type == TRAP_LLDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaLldp(&tmp,&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pRma_action = rmacfg.operation;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_rmaKeepFormat_set
+ * Description:
+ *      Set Reserved multicast address keep format configuration.
+ * Input:
+ *      type    - rma type.
+ *      enable - enable keep format.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_ENABLE       - Invalid IFG parameter
+ * Note:
+ *
+ *      There are 48 types of Reserved Multicast Address frame for application usage.
+ *      They are as following definition.
+ *      - TRAP_BRG_GROUP,
+ *      - TRAP_FD_PAUSE,
+ *      - TRAP_SP_MCAST,
+ *      - TRAP_1X_PAE,
+ *      - TRAP_UNDEF_BRG_04,
+ *      - TRAP_UNDEF_BRG_05,
+ *      - TRAP_UNDEF_BRG_06,
+ *      - TRAP_UNDEF_BRG_07,
+ *      - TRAP_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - TRAP_UNDEF_BRG_09,
+ *      - TRAP_UNDEF_BRG_0A,
+ *      - TRAP_UNDEF_BRG_0B,
+ *      - TRAP_UNDEF_BRG_0C,
+ *      - TRAP_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - TRAP_8021AB,
+ *      - TRAP_UNDEF_BRG_0F,
+ *      - TRAP_BRG_MNGEMENT,
+ *      - TRAP_UNDEFINED_11,
+ *      - TRAP_UNDEFINED_12,
+ *      - TRAP_UNDEFINED_13,
+ *      - TRAP_UNDEFINED_14,
+ *      - TRAP_UNDEFINED_15,
+ *      - TRAP_UNDEFINED_16,
+ *      - TRAP_UNDEFINED_17,
+ *      - TRAP_UNDEFINED_18,
+ *      - TRAP_UNDEFINED_19,
+ *      - TRAP_UNDEFINED_1A,
+ *      - TRAP_UNDEFINED_1B,
+ *      - TRAP_UNDEFINED_1C,
+ *      - TRAP_UNDEFINED_1D,
+ *      - TRAP_UNDEFINED_1E,
+ *      - TRAP_UNDEFINED_1F,
+ *      - TRAP_GMRP,
+ *      - TRAP_GVRP,
+ *      - TRAP_UNDEF_GARP_22,
+ *      - TRAP_UNDEF_GARP_23,
+ *      - TRAP_UNDEF_GARP_24,
+ *      - TRAP_UNDEF_GARP_25,
+ *      - TRAP_UNDEF_GARP_26,
+ *      - TRAP_UNDEF_GARP_27,
+ *      - TRAP_UNDEF_GARP_28,
+ *      - TRAP_UNDEF_GARP_29,
+ *      - TRAP_UNDEF_GARP_2A,
+ *      - TRAP_UNDEF_GARP_2B,
+ *      - TRAP_UNDEF_GARP_2C,
+ *      - TRAP_UNDEF_GARP_2D,
+ *      - TRAP_UNDEF_GARP_2E,
+ *      - TRAP_UNDEF_GARP_2F,
+ *      - TRAP_CDP.
+ *      - TRAP_CSSTP.
+ *      - TRAP_LLDP.
+ */
+rtk_api_ret_t rtk_trap_rmaKeepFormat_set(rtk_trap_type_t type, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+    rtk_uint32 tmp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= TRAP_END)
+        return RT_ERR_INPUT;
+
+    if (enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if (type >= 0 && type <= TRAP_UNDEF_GARP_2F)
+    {
+        if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.keep_format = enable;
+
+        if ((retVal = rtl8367c_setAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (type == TRAP_CDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.keep_format = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (type  == TRAP_CSSTP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.keep_format = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else if (type  == TRAP_LLDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaLldp(&tmp, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        rmacfg.keep_format = enable;
+
+        if ((retVal = rtl8367c_setAsicRmaLldp(tmp, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trap_rmaKeepFormat_get
+ * Description:
+ *      Get Reserved multicast address action configuration.
+ * Input:
+ *      type - rma type.
+ * Output:
+ *      pEnable - keep format status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ * Note:
+ *      There are 48 types of Reserved Multicast Address frame for application usage.
+ *      They are as following definition.
+ *      - TRAP_BRG_GROUP,
+ *      - TRAP_FD_PAUSE,
+ *      - TRAP_SP_MCAST,
+ *      - TRAP_1X_PAE,
+ *      - TRAP_UNDEF_BRG_04,
+ *      - TRAP_UNDEF_BRG_05,
+ *      - TRAP_UNDEF_BRG_06,
+ *      - TRAP_UNDEF_BRG_07,
+ *      - TRAP_PROVIDER_BRIDGE_GROUP_ADDRESS,
+ *      - TRAP_UNDEF_BRG_09,
+ *      - TRAP_UNDEF_BRG_0A,
+ *      - TRAP_UNDEF_BRG_0B,
+ *      - TRAP_UNDEF_BRG_0C,
+ *      - TRAP_PROVIDER_BRIDGE_GVRP_ADDRESS,
+ *      - TRAP_8021AB,
+ *      - TRAP_UNDEF_BRG_0F,
+ *      - TRAP_BRG_MNGEMENT,
+ *      - TRAP_UNDEFINED_11,
+ *      - TRAP_UNDEFINED_12,
+ *      - TRAP_UNDEFINED_13,
+ *      - TRAP_UNDEFINED_14,
+ *      - TRAP_UNDEFINED_15,
+ *      - TRAP_UNDEFINED_16,
+ *      - TRAP_UNDEFINED_17,
+ *      - TRAP_UNDEFINED_18,
+ *      - TRAP_UNDEFINED_19,
+ *      - TRAP_UNDEFINED_1A,
+ *      - TRAP_UNDEFINED_1B,
+ *      - TRAP_UNDEFINED_1C,
+ *      - TRAP_UNDEFINED_1D,
+ *      - TRAP_UNDEFINED_1E,
+ *      - TRAP_UNDEFINED_1F,
+ *      - TRAP_GMRP,
+ *      - TRAP_GVRP,
+ *      - TRAP_UNDEF_GARP_22,
+ *      - TRAP_UNDEF_GARP_23,
+ *      - TRAP_UNDEF_GARP_24,
+ *      - TRAP_UNDEF_GARP_25,
+ *      - TRAP_UNDEF_GARP_26,
+ *      - TRAP_UNDEF_GARP_27,
+ *      - TRAP_UNDEF_GARP_28,
+ *      - TRAP_UNDEF_GARP_29,
+ *      - TRAP_UNDEF_GARP_2A,
+ *      - TRAP_UNDEF_GARP_2B,
+ *      - TRAP_UNDEF_GARP_2C,
+ *      - TRAP_UNDEF_GARP_2D,
+ *      - TRAP_UNDEF_GARP_2E,
+ *      - TRAP_UNDEF_GARP_2F,
+ *      - TRAP_CDP.
+ *      - TRAP_CSSTP.
+ *      - TRAP_LLDP.
+ */
+rtk_api_ret_t rtk_trap_rmaKeepFormat_get(rtk_trap_type_t type, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_rma_t rmacfg;
+    rtk_uint32 tmp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (type >= TRAP_END)
+        return RT_ERR_INPUT;
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if (type >= 0 && type <= TRAP_UNDEF_GARP_2F)
+    {
+        if ((retVal = rtl8367c_getAsicRma(type, &rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.keep_format;
+    }
+    else if (type == TRAP_CDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCdp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.keep_format;
+    }
+    else if (type == TRAP_CSSTP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaCsstp(&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.keep_format;
+    }
+    else if (type == TRAP_LLDP)
+    {
+        if ((retVal = rtl8367c_getAsicRmaLldp(&tmp,&rmacfg)) != RT_ERR_OK)
+            return retVal;
+
+        *pEnable = rmacfg.keep_format;
+    }
+    else
+        return RT_ERR_INPUT;
+
+    return RT_ERR_OK;
+}
+
+
+
diff --git a/drivers/net/phy/rtk/rtl8367c/trunk.c b/drivers/net/phy/rtk/rtl8367c/trunk.c
new file mode 100644
index 0000000000000..09e934888162e
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/trunk.c
@@ -0,0 +1,605 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in Trunk module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <trunk.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_trunking.h>
+
+/* Function Name:
+ *      rtk_trunk_port_set
+ * Description:
+ *      Set trunking group available port mask
+ * Input:
+ *      trk_gid                 - trunk group id
+ *      pTrunk_member_portmask  - Logic trunking member port mask
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_LA_TRUNK_ID  - Invalid trunking group
+ *      RT_ERR_PORT_MASK    - Invalid portmask.
+ * Note:
+ *      The API can set port trunking group port mask. Each port trunking group has max 4 ports.
+ *      If enabled port mask has less than 2 ports available setting, then this trunking group function is disabled.
+ */
+rtk_api_ret_t rtk_trunk_port_set(rtk_trunk_group_t trk_gid, rtk_portmask_t *pTrunk_member_portmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmsk;
+    rtk_uint32 regValue, type, tmp;
+
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0249)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_getAsicReg(0x1300, &regValue)) != RT_ERR_OK)
+        return retVal;
+
+    if((retVal = rtl8367c_setAsicReg(0x13C2, 0x0000)) != RT_ERR_OK)
+        return retVal;
+
+    switch (regValue)
+    {
+        case 0x0276:
+        case 0x0597:
+        case 0x6367:
+            type = 0;
+            break;
+        case 0x0652:
+        case 0x6368:
+            type = 1;
+            break;
+        case 0x0801:
+        case 0x6511:
+            type = 2;
+            break;
+        default:
+            return RT_ERR_FAILED;
+    }
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Trunk Group Valid */
+    RTK_CHK_TRUNK_GROUP_VALID(trk_gid);
+
+    if(NULL == pTrunk_member_portmask)
+        return RT_ERR_NULL_POINTER;
+
+    RTK_CHK_PORTMASK_VALID(pTrunk_member_portmask);
+
+    if((retVal = rtk_switch_portmask_L2P_get(pTrunk_member_portmask, &pmsk)) != RT_ERR_OK)
+        return retVal;
+
+    if((type == 0) || (type == 1))
+    {
+        if ((pmsk | RTL8367C_PORT_TRUNK_GROUP_MASK_MASK(trk_gid)) != (rtk_uint32)RTL8367C_PORT_TRUNK_GROUP_MASK_MASK(trk_gid))
+            return RT_ERR_PORT_MASK;
+
+        pmsk = (pmsk & RTL8367C_PORT_TRUNK_GROUP_MASK_MASK(trk_gid)) >> RTL8367C_PORT_TRUNK_GROUP_MASK_OFFSET(trk_gid);
+    }
+    else if(type == 2)
+    {
+        tmp = 0;
+
+        if(pmsk & 0x2)
+            tmp |= 1;
+        if(pmsk & 0x8)
+            tmp |=2;
+        if(pmsk & 0x80)
+            tmp |=8;
+
+        pmsk = tmp;
+    }
+
+    if ((retVal = rtl8367c_setAsicTrunkingGroup(trk_gid, pmsk)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_port_get
+ * Description:
+ *      Get trunking group available port mask
+ * Input:
+ *      trk_gid - trunk group id
+ * Output:
+ *      pTrunk_member_portmask - Logic trunking member port mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_LA_TRUNK_ID  - Invalid trunking group
+ * Note:
+ *      The API can get 2 port trunking group.
+ */
+rtk_api_ret_t rtk_trunk_port_get(rtk_trunk_group_t trk_gid, rtk_portmask_t *pTrunk_member_portmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmsk;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Trunk Group Valid */
+    RTK_CHK_TRUNK_GROUP_VALID(trk_gid);
+
+    if ((retVal = rtl8367c_getAsicTrunkingGroup(trk_gid, &pmsk)) != RT_ERR_OK)
+        return retVal;
+
+    pmsk = pmsk << RTL8367C_PORT_TRUNK_GROUP_MASK_OFFSET(trk_gid);
+
+    if((retVal = rtk_switch_portmask_P2L_get(pmsk, pTrunk_member_portmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_distributionAlgorithm_set
+ * Description:
+ *      Set port trunking hash select sources
+ * Input:
+ *      trk_gid         - trunk group id
+ *      algo_bitmask   - Bitmask of the distribution algorithm
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_LA_TRUNK_ID  - Invalid trunking group
+ *      RT_ERR_LA_HASHMASK  - Hash algorithm selection error.
+ *      RT_ERR_PORT_MASK    - Invalid portmask.
+ * Note:
+ *      The API can set port trunking hash algorithm sources.
+ *      7 bits mask for link aggregation group0 hash parameter selection {DIP, SIP, DMAC, SMAC, SPA}
+ *      - 0b0000001: SPA
+ *      - 0b0000010: SMAC
+ *      - 0b0000100: DMAC
+ *      - 0b0001000: SIP
+ *      - 0b0010000: DIP
+ *      - 0b0100000: TCP/UDP Source Port
+ *      - 0b1000000: TCP/UDP Destination Port
+ *      Example:
+ *      - 0b0000011: SMAC & SPA
+ *      - Note that it could be an arbitrary combination or independent set
+ */
+rtk_api_ret_t rtk_trunk_distributionAlgorithm_set(rtk_trunk_group_t trk_gid, rtk_uint32 algo_bitmask)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (trk_gid != RTK_WHOLE_SYSTEM)
+        return RT_ERR_LA_TRUNK_ID;
+
+    if (algo_bitmask >= 128)
+        return RT_ERR_LA_HASHMASK;
+
+    if ((retVal = rtl8367c_setAsicTrunkingHashSelect(algo_bitmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_distributionAlgorithm_get
+ * Description:
+ *      Get port trunking hash select sources
+ * Input:
+ *      trk_gid - trunk group id
+ * Output:
+ *      pAlgo_bitmask -  Bitmask of the distribution algorithm
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_LA_TRUNK_ID  - Invalid trunking group
+ * Note:
+ *      The API can get port trunking hash algorithm sources.
+ */
+rtk_api_ret_t rtk_trunk_distributionAlgorithm_get(rtk_trunk_group_t trk_gid, rtk_uint32 *pAlgo_bitmask)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (trk_gid != RTK_WHOLE_SYSTEM)
+        return RT_ERR_LA_TRUNK_ID;
+
+    if(NULL == pAlgo_bitmask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicTrunkingHashSelect((rtk_uint32 *)pAlgo_bitmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_trafficSeparate_set
+ * Description:
+ *      Set the traffic separation setting of a trunk group from the specified device.
+ * Input:
+ *      trk_gid      - trunk group id
+ *      separateType     - traffic separation setting
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID     - invalid unit id
+ *      RT_ERR_LA_TRUNK_ID - invalid trunk ID
+ *      RT_ERR_LA_HASHMASK - invalid hash mask
+ * Note:
+ *      SEPARATE_NONE: disable traffic separation
+ *      SEPARATE_FLOOD: trunk MSB link up port is dedicated to TX flooding (L2 lookup miss) traffic
+ */
+rtk_api_ret_t rtk_trunk_trafficSeparate_set(rtk_trunk_group_t trk_gid, rtk_trunk_separateType_t separateType)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 enabled;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (trk_gid != RTK_WHOLE_SYSTEM)
+        return RT_ERR_LA_TRUNK_ID;
+
+    if(separateType >= SEPARATE_END)
+        return RT_ERR_INPUT;
+
+    enabled = (separateType == SEPARATE_FLOOD) ? ENABLED : DISABLED;
+    if ((retVal = rtl8367c_setAsicTrunkingFlood(enabled)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_trafficSeparate_get
+ * Description:
+ *      Get the traffic separation setting of a trunk group from the specified device.
+ * Input:
+ *      trk_gid        - trunk group id
+ * Output:
+ *      pSeparateType   - pointer separated traffic type
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID      - invalid unit id
+ *      RT_ERR_LA_TRUNK_ID  - invalid trunk ID
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      SEPARATE_NONE: disable traffic separation
+ *      SEPARATE_FLOOD: trunk MSB link up port is dedicated to TX flooding (L2 lookup miss) traffic
+ */
+rtk_api_ret_t rtk_trunk_trafficSeparate_get(rtk_trunk_group_t trk_gid, rtk_trunk_separateType_t *pSeparateType)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 enabled;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if (trk_gid != RTK_WHOLE_SYSTEM)
+        return RT_ERR_LA_TRUNK_ID;
+
+    if(NULL == pSeparateType)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicTrunkingFlood(&enabled)) != RT_ERR_OK)
+        return retVal;
+
+    *pSeparateType = (enabled == ENABLED) ? SEPARATE_FLOOD : SEPARATE_NONE;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_mode_set
+ * Description:
+ *      Set the trunk mode to the specified device.
+ * Input:
+ *      mode - trunk mode
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_INPUT   - invalid input parameter
+ * Note:
+ *      The enum of the trunk mode as following
+ *      - TRUNK_MODE_NORMAL
+ *      - TRUNK_MODE_DUMB
+ */
+rtk_api_ret_t rtk_trunk_mode_set(rtk_trunk_mode_t mode)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(mode >= TRUNK_MODE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicTrunkingMode((rtk_uint32)mode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_mode_get
+ * Description:
+ *      Get the trunk mode from the specified device.
+ * Input:
+ *      None
+ * Output:
+ *      pMode - pointer buffer of trunk mode
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      The enum of the trunk mode as following
+ *      - TRUNK_MODE_NORMAL
+ *      - TRUNK_MODE_DUMB
+ */
+rtk_api_ret_t rtk_trunk_mode_get(rtk_trunk_mode_t *pMode)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pMode)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicTrunkingMode((rtk_uint32 *)pMode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_trafficPause_set
+ * Description:
+ *      Set the traffic pause setting of a trunk group.
+ * Input:
+ *      trk_gid      - trunk group id
+ *      enable       - traffic pause state
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_LA_TRUNK_ID - invalid trunk ID
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_trunk_trafficPause_set(rtk_trunk_group_t trk_gid, rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Trunk Group Valid */
+    RTK_CHK_TRUNK_GROUP_VALID(trk_gid);
+
+    if(enable >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setAsicTrunkingFc((rtk_uint32)trk_gid, (rtk_uint32)enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_trafficPause_get
+ * Description:
+ *      Get the traffic pause setting of a trunk group.
+ * Input:
+ *      trk_gid        - trunk group id
+ * Output:
+ *      pEnable        - pointer of traffic pause state.
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_LA_TRUNK_ID  - invalid trunk ID
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_trunk_trafficPause_get(rtk_trunk_group_t trk_gid, rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Trunk Group Valid */
+    RTK_CHK_TRUNK_GROUP_VALID(trk_gid);
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicTrunkingFc((rtk_uint32)trk_gid, (rtk_uint32 *)pEnable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_hashMappingTable_set
+ * Description:
+ *      Set hash value to port array in the trunk group id from the specified device.
+ * Input:
+ *      trk_gid          - trunk group id
+ *      pHash2Port_array - ports associate with the hash value
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID            - invalid unit id
+ *      RT_ERR_LA_TRUNK_ID        - invalid trunk ID
+ *      RT_ERR_NULL_POINTER       - input parameter may be null pointer
+ *      RT_ERR_LA_TRUNK_NOT_EXIST - the trunk doesn't exist
+ *      RT_ERR_LA_NOT_MEMBER_PORT - the port is not a member port of the trunk
+ *      RT_ERR_LA_CPUPORT         - CPU port can not be aggregated port
+ * Note:
+ *      Trunk group 0 & 1 shares the same hash mapping table.
+ *      Trunk group 2 uses a independent table.
+ */
+rtk_api_ret_t rtk_trunk_hashMappingTable_set(rtk_trunk_group_t trk_gid, rtk_trunk_hashVal2Port_t *pHash2Port_array)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 hashValue;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Trunk Group Valid */
+    RTK_CHK_TRUNK_GROUP_VALID(trk_gid);
+
+    if(NULL == pHash2Port_array)
+        return RT_ERR_NULL_POINTER;
+
+    if(trk_gid <= TRUNK_GROUP1)
+    {
+        for(hashValue = 0; hashValue < RTK_MAX_NUM_OF_TRUNK_HASH_VAL; hashValue++)
+        {
+            if ((retVal = rtl8367c_setAsicTrunkingHashTable(hashValue, pHash2Port_array->value[hashValue])) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+    else
+    {
+        for(hashValue = 0; hashValue < RTK_MAX_NUM_OF_TRUNK_HASH_VAL; hashValue++)
+        {
+            if ((retVal = rtl8367c_setAsicTrunkingHashTable1(hashValue, pHash2Port_array->value[hashValue])) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_hashMappingTable_get
+ * Description:
+ *      Get hash value to port array in the trunk group id from the specified device.
+ * Input:
+ *      trk_gid          - trunk group id
+ * Output:
+ *      pHash2Port_array - pointer buffer of ports associate with the hash value
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_UNIT_ID      - invalid unit id
+ *      RT_ERR_LA_TRUNK_ID  - invalid trunk ID
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      Trunk group 0 & 1 shares the same hash mapping table.
+ *      Trunk group 2 uses a independent table.
+ */
+rtk_api_ret_t rtk_trunk_hashMappingTable_get(rtk_trunk_group_t trk_gid, rtk_trunk_hashVal2Port_t *pHash2Port_array)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 hashValue;
+    rtk_uint32 hashPort;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Trunk Group Valid */
+    RTK_CHK_TRUNK_GROUP_VALID(trk_gid);
+
+    if(NULL == pHash2Port_array)
+        return RT_ERR_NULL_POINTER;
+
+    if(trk_gid <= TRUNK_GROUP1)
+    {
+        for(hashValue = 0; hashValue < RTK_MAX_NUM_OF_TRUNK_HASH_VAL; hashValue++)
+        {
+            if ((retVal = rtl8367c_getAsicTrunkingHashTable(hashValue, &hashPort)) != RT_ERR_OK)
+                return retVal;
+
+            pHash2Port_array->value[hashValue] = hashPort;
+        }
+    }
+    else
+    {
+        for(hashValue = 0; hashValue < RTK_MAX_NUM_OF_TRUNK_HASH_VAL; hashValue++)
+        {
+            if ((retVal = rtl8367c_getAsicTrunkingHashTable1(hashValue, &hashPort)) != RT_ERR_OK)
+                return retVal;
+
+            pHash2Port_array->value[hashValue] = hashPort;
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_trunk_portQueueEmpty_get
+ * Description:
+ *      Get the port mask which all queues are empty.
+ * Input:
+ *      None.
+ * Output:
+ *      pEmpty_portmask   - pointer empty port mask
+ * Return:
+ *      RT_ERR_OK
+ *      RT_ERR_FAILED
+ *      RT_ERR_NULL_POINTER - input parameter may be null pointer
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_trunk_portQueueEmpty_get(rtk_portmask_t *pEmpty_portmask)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 pmask;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEmpty_portmask)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicQeueuEmptyStatus(&pmask)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtk_switch_portmask_P2L_get(pmask, pEmpty_portmask)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367c/vlan.c b/drivers/net/phy/rtk/rtl8367c/vlan.c
new file mode 100644
index 0000000000000..f2a4c8ecb5213
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367c/vlan.c
@@ -0,0 +1,2124 @@
+/*
+ * Copyright (C) 2013 Realtek Semiconductor Corp.
+ * All Rights Reserved.
+ *
+ * Unless you and Realtek execute a separate written software license
+ * agreement governing use of this software, this software is licensed
+ * to you under the terms of the GNU General Public License version 2,
+ * available at https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
+ *
+ * $Revision: 76306 $
+ * $Date: 2017-03-08 15:13:58 +0800 (週三, 08 三月 2017) $
+ *
+ * Purpose : RTK switch high-level API for RTL8367/RTL8367C
+ * Feature : Here is a list of all functions and variables in VLAN module.
+ *
+ */
+
+#include <rtk_switch.h>
+#include <rtk_error.h>
+#include <vlan.h>
+#include <rate.h>
+#include <string.h>
+
+#include <rtl8367c_asicdrv.h>
+#include <rtl8367c_asicdrv_vlan.h>
+#include <rtl8367c_asicdrv_dot1x.h>
+
+typedef enum vlan_mbrCfgType_e
+{
+    MBRCFG_UNUSED = 0,
+    MBRCFG_USED_BY_VLAN,
+    MBRCFG_END
+}vlan_mbrCfgType_t;
+
+static rtk_vlan_t           vlan_mbrCfgVid[RTL8367C_CVIDXNO];
+static vlan_mbrCfgType_t    vlan_mbrCfgUsage[RTL8367C_CVIDXNO];
+
+/* Function Name:
+ *      rtk_vlan_init
+ * Description:
+ *      Initialize VLAN.
+ * Input:
+ *      None
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ * Note:
+ *      VLAN is disabled by default. User has to call this API to enable VLAN before
+ *      using it. And It will set a default VLAN(vid 1) including all ports and set
+ *      all ports PVID to the default VLAN.
+ */
+rtk_api_ret_t rtk_vlan_init(void)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i;
+    rtl8367c_user_vlan4kentry vlan4K;
+    rtl8367c_vlanconfiguser vlanMC;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Clean Database */
+    memset(vlan_mbrCfgVid, 0x00, sizeof(rtk_vlan_t) * RTL8367C_CVIDXNO);
+    memset(vlan_mbrCfgUsage, 0x00, sizeof(vlan_mbrCfgType_t) * RTL8367C_CVIDXNO);
+
+    /* clean 32 VLAN member configuration */
+    for (i = 0; i <= RTL8367C_CVIDXMAX; i++)
+    {
+        vlanMC.evid = 0;
+        vlanMC.mbr = 0;
+        vlanMC.fid_msti = 0;
+        vlanMC.envlanpol = 0;
+        vlanMC.meteridx = 0;
+        vlanMC.vbpen = 0;
+        vlanMC.vbpri = 0;
+        if ((retVal = rtl8367c_setAsicVlanMemberConfig(i, &vlanMC)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /* Set a default VLAN with vid 1 to 4K table for all ports */
+    memset(&vlan4K, 0, sizeof(rtl8367c_user_vlan4kentry));
+    vlan4K.vid = 1;
+    vlan4K.mbr = RTK_PHY_PORTMASK_ALL;
+    vlan4K.untag = RTK_PHY_PORTMASK_ALL;
+    vlan4K.fid_msti = 0;
+    if ((retVal = rtl8367c_setAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
+        return retVal;
+
+    /* Also set the default VLAN to 32 member configuration index 0 */
+    memset(&vlanMC, 0, sizeof(rtl8367c_vlanconfiguser));
+    vlanMC.evid = 1;
+    vlanMC.mbr = RTK_PHY_PORTMASK_ALL;
+    vlanMC.fid_msti = 0;
+    if ((retVal = rtl8367c_setAsicVlanMemberConfig(0, &vlanMC)) != RT_ERR_OK)
+            return retVal;
+
+    /* Set all ports PVID to default VLAN and tag-mode to original */
+    RTK_SCAN_ALL_PHY_PORTMASK(i)
+    {
+        if ((retVal = rtl8367c_setAsicVlanPortBasedVID(i, 0, 0)) != RT_ERR_OK)
+            return retVal;
+        if ((retVal = rtl8367c_setAsicVlanEgressTagMode(i, EG_TAG_MODE_ORI)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /* Updata Databse */
+    vlan_mbrCfgUsage[0] = MBRCFG_USED_BY_VLAN;
+    vlan_mbrCfgVid[0] = 1;
+
+    /* Enable Ingress filter */
+    RTK_SCAN_ALL_PHY_PORTMASK(i)
+    {
+        if ((retVal = rtl8367c_setAsicVlanIngressFilter(i, ENABLED)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /* enable VLAN */
+    if ((retVal = rtl8367c_setAsicVlanFilter(ENABLED)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_set
+ * Description:
+ *      Set a VLAN entry.
+ * Input:
+ *      vid - VLAN ID to configure.
+ *      pVlanCfg - VLAN Configuration
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_INPUT                - Invalid input parameters.
+ *      RT_ERR_L2_FID               - Invalid FID.
+ *      RT_ERR_VLAN_PORT_MBR_EXIST  - Invalid member port mask.
+ *      RT_ERR_VLAN_VID             - Invalid VID parameter.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_set(rtk_vlan_t vid, rtk_vlan_cfg_t *pVlanCfg)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 phyMbrPmask;
+    rtk_uint32 phyUntagPmask;
+    rtl8367c_user_vlan4kentry vlan4K;
+    rtl8367c_vlanconfiguser vlanMC;
+    rtk_uint32 idx;
+    rtk_uint32 empty_index = 0xffff;
+    rtk_uint32 update_evid = 0;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* vid must be 0~8191 */
+    if (vid > RTL8367C_EVIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    /* Null pointer check */
+    if(NULL == pVlanCfg)
+        return RT_ERR_NULL_POINTER;
+
+    /* Check port mask valid */
+    RTK_CHK_PORTMASK_VALID(&(pVlanCfg->mbr));
+
+    if (vid <= RTL8367C_VIDMAX)
+    {
+        /* Check untag port mask valid */
+        RTK_CHK_PORTMASK_VALID(&(pVlanCfg->untag));
+    }
+
+    /* IVL_EN */
+    if(pVlanCfg->ivl_en >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    /* fid must be 0~15 */
+    if(pVlanCfg->fid_msti > RTL8367C_FIDMAX)
+        return RT_ERR_L2_FID;
+
+    /* Policing */
+    if(pVlanCfg->envlanpol >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    /* Meter ID */
+    if(pVlanCfg->meteridx > RTK_MAX_METER_ID)
+        return RT_ERR_INPUT;
+
+    /* VLAN based priority */
+    if(pVlanCfg->vbpen >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    /* Priority */
+    if(pVlanCfg->vbpri > RTL8367C_PRIMAX)
+        return RT_ERR_INPUT;
+
+    /* Get physical port mask */
+    if(rtk_switch_portmask_L2P_get(&(pVlanCfg->mbr), &phyMbrPmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    if(rtk_switch_portmask_L2P_get(&(pVlanCfg->untag), &phyUntagPmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    if (vid <= RTL8367C_VIDMAX)
+    {
+        /* update 4K table */
+        memset(&vlan4K, 0, sizeof(rtl8367c_user_vlan4kentry));
+        vlan4K.vid = vid;
+
+        vlan4K.mbr    = (phyMbrPmask & 0xFFFF);
+        vlan4K.untag  = (phyUntagPmask & 0xFFFF);
+
+        vlan4K.ivl_svl      = pVlanCfg->ivl_en;
+        vlan4K.fid_msti     = pVlanCfg->fid_msti;
+        vlan4K.envlanpol    = pVlanCfg->envlanpol;
+        vlan4K.meteridx     = pVlanCfg->meteridx;
+        vlan4K.vbpen        = pVlanCfg->vbpen;
+        vlan4K.vbpri        = pVlanCfg->vbpri;
+
+        if ((retVal = rtl8367c_setAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
+            return retVal;
+
+        /* Update Member configuration if exist */
+        for (idx = 0; idx <= RTL8367C_CVIDXMAX; idx++)
+        {
+            if(vlan_mbrCfgUsage[idx] == MBRCFG_USED_BY_VLAN)
+            {
+                if(vlan_mbrCfgVid[idx] == vid)
+                {
+                    /* Found! Update */
+                    if(phyMbrPmask == 0x00)
+                    {
+                        /* Member port = 0x00, delete this VLAN from Member Configuration */
+                        memset(&vlanMC, 0x00, sizeof(rtl8367c_vlanconfiguser));
+                        if ((retVal = rtl8367c_setAsicVlanMemberConfig(idx, &vlanMC)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* Clear Database */
+                        vlan_mbrCfgUsage[idx] = MBRCFG_UNUSED;
+                        vlan_mbrCfgVid[idx]   = 0;
+                    }
+                    else
+                    {
+                        /* Normal VLAN config, update to member configuration */
+                        vlanMC.evid = vid;
+                        vlanMC.mbr = vlan4K.mbr;
+                        vlanMC.fid_msti = vlan4K.fid_msti;
+                        vlanMC.meteridx = vlan4K.meteridx;
+                        vlanMC.envlanpol= vlan4K.envlanpol;
+                        vlanMC.vbpen = vlan4K.vbpen;
+                        vlanMC.vbpri = vlan4K.vbpri;
+                        if ((retVal = rtl8367c_setAsicVlanMemberConfig(idx, &vlanMC)) != RT_ERR_OK)
+                            return retVal;
+                    }
+
+                    break;
+                }
+            }
+        }
+    }
+    else
+    {
+        /* vid > 4095 */
+        for (idx = 0; idx <= RTL8367C_CVIDXMAX; idx++)
+        {
+            if(vlan_mbrCfgUsage[idx] == MBRCFG_USED_BY_VLAN)
+            {
+                if(vlan_mbrCfgVid[idx] == vid)
+                {
+                    /* Found! Update */
+                    if(phyMbrPmask == 0x00)
+                    {
+                        /* Member port = 0x00, delete this VLAN from Member Configuration */
+                        memset(&vlanMC, 0x00, sizeof(rtl8367c_vlanconfiguser));
+                        if ((retVal = rtl8367c_setAsicVlanMemberConfig(idx, &vlanMC)) != RT_ERR_OK)
+                            return retVal;
+
+                        /* Clear Database */
+                        vlan_mbrCfgUsage[idx] = MBRCFG_UNUSED;
+                        vlan_mbrCfgVid[idx]   = 0;
+                    }
+                    else
+                    {
+                        /* Normal VLAN config, update to member configuration */
+                        vlanMC.evid = vid;
+                        vlanMC.mbr = phyMbrPmask;
+                        vlanMC.fid_msti = pVlanCfg->fid_msti;
+                        vlanMC.meteridx = pVlanCfg->meteridx;
+                        vlanMC.envlanpol= pVlanCfg->envlanpol;
+                        vlanMC.vbpen = pVlanCfg->vbpen;
+                        vlanMC.vbpri = pVlanCfg->vbpri;
+                        if ((retVal = rtl8367c_setAsicVlanMemberConfig(idx, &vlanMC)) != RT_ERR_OK)
+                            return retVal;
+
+                        break;
+                    }
+
+                    update_evid = 1;
+                }
+            }
+
+            if(vlan_mbrCfgUsage[idx] == MBRCFG_UNUSED)
+            {
+                if(0xffff == empty_index)
+                    empty_index = idx;
+            }
+        }
+
+        /* doesn't find out same EVID entry and there is empty index in member configuration */
+        if( (phyMbrPmask != 0x00) && (update_evid == 0) && (empty_index != 0xFFFF) )
+        {
+            vlanMC.evid = vid;
+            vlanMC.mbr = phyMbrPmask;
+            vlanMC.fid_msti = pVlanCfg->fid_msti;
+            vlanMC.meteridx = pVlanCfg->meteridx;
+            vlanMC.envlanpol= pVlanCfg->envlanpol;
+            vlanMC.vbpen = pVlanCfg->vbpen;
+            vlanMC.vbpri = pVlanCfg->vbpri;
+            if ((retVal = rtl8367c_setAsicVlanMemberConfig(empty_index, &vlanMC)) != RT_ERR_OK)
+                return retVal;
+
+            vlan_mbrCfgUsage[empty_index] = MBRCFG_USED_BY_VLAN;
+            vlan_mbrCfgVid[empty_index] = vid;
+
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_get
+ * Description:
+ *      Get a VLAN entry.
+ * Input:
+ *      vid - VLAN ID to configure.
+ * Output:
+ *      pVlanCfg - VLAN Configuration
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_get(rtk_vlan_t vid, rtk_vlan_cfg_t *pVlanCfg)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 phyMbrPmask;
+    rtk_uint32 phyUntagPmask;
+    rtl8367c_user_vlan4kentry vlan4K;
+    rtl8367c_vlanconfiguser vlanMC;
+    rtk_uint32 idx;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* vid must be 0~8191 */
+    if (vid > RTL8367C_EVIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    /* Null pointer check */
+    if(NULL == pVlanCfg)
+        return RT_ERR_NULL_POINTER;
+
+    if (vid <= RTL8367C_VIDMAX)
+    {
+        vlan4K.vid = vid;
+
+        if ((retVal = rtl8367c_getAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
+            return retVal;
+
+        phyMbrPmask   = vlan4K.mbr;
+        phyUntagPmask = vlan4K.untag;
+        if(rtk_switch_portmask_P2L_get(phyMbrPmask, &(pVlanCfg->mbr)) != RT_ERR_OK)
+            return RT_ERR_FAILED;
+
+        if(rtk_switch_portmask_P2L_get(phyUntagPmask, &(pVlanCfg->untag)) != RT_ERR_OK)
+            return RT_ERR_FAILED;
+
+        pVlanCfg->ivl_en    = vlan4K.ivl_svl;
+        pVlanCfg->fid_msti  = vlan4K.fid_msti;
+        pVlanCfg->envlanpol = vlan4K.envlanpol;
+        pVlanCfg->meteridx  = vlan4K.meteridx;
+        pVlanCfg->vbpen     = vlan4K.vbpen;
+        pVlanCfg->vbpri     = vlan4K.vbpri;
+    }
+    else
+    {
+        for (idx = 0; idx <= RTL8367C_CVIDXMAX; idx++)
+        {
+            if(vlan_mbrCfgUsage[idx] == MBRCFG_USED_BY_VLAN)
+            {
+                if(vlan_mbrCfgVid[idx] == vid)
+                {
+                    if ((retVal = rtl8367c_getAsicVlanMemberConfig(idx, &vlanMC)) != RT_ERR_OK)
+                        return retVal;
+
+                    phyMbrPmask   = vlanMC.mbr;
+                    if(rtk_switch_portmask_P2L_get(phyMbrPmask, &(pVlanCfg->mbr)) != RT_ERR_OK)
+                        return RT_ERR_FAILED;
+
+                    pVlanCfg->untag.bits[0] = 0;
+                    pVlanCfg->ivl_en    = 0;
+                    pVlanCfg->fid_msti  = vlanMC.fid_msti;
+                    pVlanCfg->envlanpol = vlanMC.envlanpol;
+                    pVlanCfg->meteridx  = vlanMC.meteridx;
+                    pVlanCfg->vbpen     = vlanMC.vbpen;
+                    pVlanCfg->vbpri     = vlanMC.vbpri;
+                }
+            }
+        }
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_egrFilterEnable_set
+ * Description:
+ *      Set VLAN egress filter.
+ * Input:
+ *      egrFilter - Egress filtering
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_ENABLE       - Invalid input parameters.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_egrFilterEnable_set(rtk_enable_t egrFilter)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(egrFilter >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    /* enable VLAN */
+    if ((retVal = rtl8367c_setAsicVlanFilter((rtk_uint32)egrFilter)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_egrFilterEnable_get
+ * Description:
+ *      Get VLAN egress filter.
+ * Input:
+ *      pEgrFilter - Egress filtering
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - NULL Pointer.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_egrFilterEnable_get(rtk_enable_t *pEgrFilter)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 state;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEgrFilter)
+        return RT_ERR_NULL_POINTER;
+
+    /* enable VLAN */
+    if ((retVal = rtl8367c_getAsicVlanFilter(&state)) != RT_ERR_OK)
+        return retVal;
+
+    *pEgrFilter = (rtk_enable_t)state;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_mbrCfg_set
+ * Description:
+ *      Set a VLAN Member Configuration entry by index.
+ * Input:
+ *      idx     - Index of VLAN Member Configuration.
+ *      pMbrcfg - VLAN member Configuration.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ * Note:
+ *     Set a VLAN Member Configuration entry by index.
+ */
+rtk_api_ret_t rtk_vlan_mbrCfg_set(rtk_uint32 idx, rtk_vlan_mbrcfg_t *pMbrcfg)
+{
+    rtk_api_ret_t           retVal;
+    rtk_uint32              phyMbrPmask;
+    rtl8367c_vlanconfiguser mbrCfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Error check */
+    if(pMbrcfg == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if(idx > RTL8367C_CVIDXMAX)
+        return RT_ERR_INPUT;
+
+    if(pMbrcfg->evid > RTL8367C_EVIDMAX)
+        return RT_ERR_INPUT;
+
+    if(pMbrcfg->fid_msti > RTL8367C_FIDMAX)
+        return RT_ERR_L2_FID;
+
+    if(pMbrcfg->envlanpol >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if(pMbrcfg->meteridx > RTK_MAX_METER_ID)
+        return RT_ERR_FILTER_METER_ID;
+
+    if(pMbrcfg->vbpen >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if(pMbrcfg->vbpri > RTL8367C_PRIMAX)
+        return RT_ERR_QOS_INT_PRIORITY;
+
+    /* Check port mask valid */
+    RTK_CHK_PORTMASK_VALID(&(pMbrcfg->mbr));
+
+    mbrCfg.evid         = pMbrcfg->evid;
+    mbrCfg.fid_msti     = pMbrcfg->fid_msti;
+    mbrCfg.envlanpol    = pMbrcfg->envlanpol;
+    mbrCfg.meteridx     = pMbrcfg->meteridx;
+    mbrCfg.vbpen        = pMbrcfg->vbpen;
+    mbrCfg.vbpri        = pMbrcfg->vbpri;
+
+    if(rtk_switch_portmask_L2P_get(&(pMbrcfg->mbr), &phyMbrPmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    mbrCfg.mbr = phyMbrPmask;
+
+    if ((retVal = rtl8367c_setAsicVlanMemberConfig(idx, &mbrCfg)) != RT_ERR_OK)
+        return retVal;
+
+    /* Update Database */
+    if( (mbrCfg.evid == 0) && (mbrCfg.mbr == 0) )
+    {
+        vlan_mbrCfgUsage[idx] = MBRCFG_UNUSED;
+        vlan_mbrCfgVid[idx] = 0;
+    }
+    else
+    {
+        vlan_mbrCfgUsage[idx] = MBRCFG_USED_BY_VLAN;
+        vlan_mbrCfgVid[idx] = mbrCfg.evid;
+    }
+
+    return RT_ERR_OK;
+
+}
+
+/* Function Name:
+ *      rtk_vlan_mbrCfg_get
+ * Description:
+ *      Get a VLAN Member Configuration entry by index.
+ * Input:
+ *      idx - Index of VLAN Member Configuration.
+ * Output:
+ *      pMbrcfg - VLAN member Configuration.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ * Note:
+ *     Get a VLAN Member Configuration entry by index.
+ */
+rtk_api_ret_t rtk_vlan_mbrCfg_get(rtk_uint32 idx, rtk_vlan_mbrcfg_t *pMbrcfg)
+{
+    rtk_api_ret_t           retVal;
+    rtk_uint32              phyMbrPmask;
+    rtl8367c_vlanconfiguser mbrCfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Error check */
+    if(pMbrcfg == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if(idx > RTL8367C_CVIDXMAX)
+        return RT_ERR_INPUT;
+
+    memset(&mbrCfg, 0x00, sizeof(rtl8367c_vlanconfiguser));
+    if ((retVal = rtl8367c_getAsicVlanMemberConfig(idx, &mbrCfg)) != RT_ERR_OK)
+        return retVal;
+
+    pMbrcfg->evid       = mbrCfg.evid;
+    pMbrcfg->fid_msti   = mbrCfg.fid_msti;
+    pMbrcfg->envlanpol  = mbrCfg.envlanpol;
+    pMbrcfg->meteridx   = mbrCfg.meteridx;
+    pMbrcfg->vbpen      = mbrCfg.vbpen;
+    pMbrcfg->vbpri      = mbrCfg.vbpri;
+
+    phyMbrPmask = mbrCfg.mbr;
+    if(rtk_switch_portmask_P2L_get(phyMbrPmask, &(pMbrcfg->mbr)) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *     rtk_vlan_portPvid_set
+ * Description:
+ *      Set port to specified VLAN ID(PVID).
+ * Input:
+ *      port - Port id.
+ *      pvid - Specified VLAN ID.
+ *      priority - 802.1p priority for the PVID.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                   - OK
+ *      RT_ERR_FAILED               - Failed
+ *      RT_ERR_SMI                  - SMI access error
+ *      RT_ERR_PORT_ID              - Invalid port number.
+ *      RT_ERR_VLAN_PRIORITY        - Invalid priority.
+ *      RT_ERR_VLAN_ENTRY_NOT_FOUND - VLAN entry not found.
+ *      RT_ERR_VLAN_VID             - Invalid VID parameter.
+ * Note:
+ *       The API is used for Port-based VLAN. The untagged frame received from the
+ *       port will be classified to the specified VLAN and assigned to the specified priority.
+ */
+rtk_api_ret_t rtk_vlan_portPvid_set(rtk_port_t port, rtk_vlan_t pvid, rtk_pri_t priority)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 index;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    /* vid must be 0~8191 */
+    if (pvid > RTL8367C_EVIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    /* priority must be 0~7 */
+    if (priority > RTL8367C_PRIMAX)
+        return RT_ERR_VLAN_PRIORITY;
+
+    if((retVal = rtk_vlan_checkAndCreateMbr(pvid, &index)) != RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicVlanPortBasedVID(rtk_switch_port_L2P_get(port), index, priority)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_portPvid_get
+ * Description:
+ *      Get VLAN ID(PVID) on specified port.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pPvid - Specified VLAN ID.
+ *      pPriority - 802.1p priority for the PVID.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *     The API can get the PVID and 802.1p priority for the PVID of Port-based VLAN.
+ */
+rtk_api_ret_t rtk_vlan_portPvid_get(rtk_port_t port, rtk_vlan_t *pPvid, rtk_pri_t *pPriority)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 index, pri;
+    rtl8367c_vlanconfiguser mbrCfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pPvid)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pPriority)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicVlanPortBasedVID(rtk_switch_port_L2P_get(port), &index, &pri)) != RT_ERR_OK)
+        return retVal;
+
+    memset(&mbrCfg, 0x00, sizeof(rtl8367c_vlanconfiguser));
+    if ((retVal = rtl8367c_getAsicVlanMemberConfig(index, &mbrCfg)) != RT_ERR_OK)
+        return retVal;
+
+    *pPvid = mbrCfg.evid;
+    *pPriority = pri;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_portIgrFilterEnable_set
+ * Description:
+ *      Set VLAN ingress for each port.
+ * Input:
+ *      port - Port id.
+ *      igr_filter - VLAN ingress function enable status.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number
+ *      RT_ERR_ENABLE       - Invalid enable input
+ * Note:
+ *      The status of vlan ingress filter is as following:
+ *      - DISABLED
+ *      - ENABLED
+ *      While VLAN function is enabled, ASIC will decide VLAN ID for each received frame and get belonged member
+ *      ports from VLAN table. If received port is not belonged to VLAN member ports, ASIC will drop received frame if VLAN ingress function is enabled.
+ */
+rtk_api_ret_t rtk_vlan_portIgrFilterEnable_set(rtk_port_t port, rtk_enable_t igr_filter)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (igr_filter >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicVlanIngressFilter(rtk_switch_port_L2P_get(port), igr_filter)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_portIgrFilterEnable_get
+ * Description:
+ *      Get VLAN Ingress Filter
+ * Input:
+ *      port        - Port id.
+ * Output:
+ *      pIgr_filter - VLAN ingress function enable status.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *     The API can Get the VLAN ingress filter status.
+ *     The status of vlan ingress filter is as following:
+ *     - DISABLED
+ *     - ENABLED
+ */
+rtk_api_ret_t rtk_vlan_portIgrFilterEnable_get(rtk_port_t port, rtk_enable_t *pIgr_filter)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pIgr_filter)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicVlanIngressFilter(rtk_switch_port_L2P_get(port), pIgr_filter)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_portAcceptFrameType_set
+ * Description:
+ *      Set VLAN accept_frame_type
+ * Input:
+ *      port                - Port id.
+ *      accept_frame_type   - accept frame type
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK                       - OK
+ *      RT_ERR_FAILED                   - Failed
+ *      RT_ERR_SMI                      - SMI access error
+ *      RT_ERR_PORT_ID                  - Invalid port number.
+ *      RT_ERR_VLAN_ACCEPT_FRAME_TYPE   - Invalid frame type.
+ * Note:
+ *      The API is used for checking 802.1Q tagged frames.
+ *      The accept frame type as following:
+ *      - ACCEPT_FRAME_TYPE_ALL
+ *      - ACCEPT_FRAME_TYPE_TAG_ONLY
+ *      - ACCEPT_FRAME_TYPE_UNTAG_ONLY
+ */
+rtk_api_ret_t rtk_vlan_portAcceptFrameType_set(rtk_port_t port, rtk_vlan_acceptFrameType_t accept_frame_type)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (accept_frame_type >= ACCEPT_FRAME_TYPE_END)
+        return RT_ERR_VLAN_ACCEPT_FRAME_TYPE;
+
+    if ((retVal = rtl8367c_setAsicVlanAccpetFrameType(rtk_switch_port_L2P_get(port), (rtl8367c_accframetype)accept_frame_type)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_portAcceptFrameType_get
+ * Description:
+ *      Get VLAN accept_frame_type
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pAccept_frame_type - accept frame type
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *     The API can Get the VLAN ingress filter.
+ *     The accept frame type as following:
+ *     - ACCEPT_FRAME_TYPE_ALL
+ *     - ACCEPT_FRAME_TYPE_TAG_ONLY
+ *     - ACCEPT_FRAME_TYPE_UNTAG_ONLY
+ */
+rtk_api_ret_t rtk_vlan_portAcceptFrameType_get(rtk_port_t port, rtk_vlan_acceptFrameType_t *pAccept_frame_type)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_accframetype   acc_frm_type;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pAccept_frame_type)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicVlanAccpetFrameType(rtk_switch_port_L2P_get(port), &acc_frm_type)) != RT_ERR_OK)
+        return retVal;
+
+    *pAccept_frame_type = (rtk_vlan_acceptFrameType_t)acc_frm_type;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_protoAndPortBasedVlan_add
+ * Description:
+ *      Add the protocol-and-port-based vlan to the specified port of device.
+ * Input:
+ *      port  - Port id.
+ *      pInfo - Protocol and port based VLAN configuration information.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_VLAN_VID         - Invalid VID parameter.
+ *      RT_ERR_VLAN_PRIORITY    - Invalid priority.
+ *      RT_ERR_TBL_FULL         - Table is full.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *      The incoming packet which match the protocol-and-port-based vlan will use the configure vid for ingress pipeline
+ *      The frame type is shown in the following:
+ *      - FRAME_TYPE_ETHERNET
+ *      - FRAME_TYPE_RFC1042
+ *      - FRAME_TYPE_LLCOTHER
+ */
+rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_add(rtk_port_t port, rtk_vlan_protoAndPortInfo_t *pInfo)
+{
+    rtk_api_ret_t retVal, i;
+    rtk_uint32 exist, empty, used, index;
+    rtl8367c_protocolgdatacfg ppb_data_cfg;
+    rtl8367c_protocolvlancfg ppb_vlan_cfg;
+    rtl8367c_provlan_frametype tmp;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pInfo)
+        return RT_ERR_NULL_POINTER;
+
+    if (pInfo->proto_type > RTK_MAX_NUM_OF_PROTO_TYPE)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if (pInfo->frame_type >= FRAME_TYPE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if (pInfo->cvid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    if (pInfo->cpri > RTL8367C_PRIMAX)
+        return RT_ERR_VLAN_PRIORITY;
+
+    exist = 0xFF;
+    empty = 0xFF;
+    for (i = RTL8367C_PROTOVLAN_GIDX_MAX; i >= 0; i--)
+    {
+        if ((retVal = rtl8367c_getAsicVlanProtocolBasedGroupData(i, &ppb_data_cfg)) != RT_ERR_OK)
+            return retVal;
+        tmp = pInfo->frame_type;
+        if (ppb_data_cfg.etherType == pInfo->proto_type && ppb_data_cfg.frameType == tmp)
+        {
+            /*Already exist*/
+            exist = i;
+            break;
+        }
+        else if (ppb_data_cfg.etherType == 0 && ppb_data_cfg.frameType == 0)
+        {
+            /*find empty index*/
+            empty = i;
+        }
+    }
+
+    used = 0xFF;
+    /*No empty and exist index*/
+    if (0xFF == exist && 0xFF == empty)
+        return RT_ERR_TBL_FULL;
+    else if (exist<RTL8367C_PROTOVLAN_GROUPNO)
+    {
+       /*exist index*/
+       used = exist;
+    }
+    else if (empty<RTL8367C_PROTOVLAN_GROUPNO)
+    {
+        /*No exist index, but have empty index*/
+        ppb_data_cfg.frameType = pInfo->frame_type;
+        ppb_data_cfg.etherType = pInfo->proto_type;
+        if ((retVal = rtl8367c_setAsicVlanProtocolBasedGroupData(empty, &ppb_data_cfg)) != RT_ERR_OK)
+            return retVal;
+        used = empty;
+    }
+    else
+        return RT_ERR_FAILED;
+
+    if((retVal = rtk_vlan_checkAndCreateMbr(pInfo->cvid, &index)) != RT_ERR_OK)
+        return retVal;
+
+    ppb_vlan_cfg.vlan_idx = index;
+    ppb_vlan_cfg.valid = TRUE;
+    ppb_vlan_cfg.priority = pInfo->cpri;
+    if ((retVal = rtl8367c_setAsicVlanPortAndProtocolBased(rtk_switch_port_L2P_get(port), used, &ppb_vlan_cfg)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_protoAndPortBasedVlan_get
+ * Description:
+ *      Get the protocol-and-port-based vlan to the specified port of device.
+ * Input:
+ *      port - Port id.
+ *      proto_type - protocol-and-port-based vlan protocol type.
+ *      frame_type - protocol-and-port-based vlan frame type.
+ * Output:
+ *      pInfo - Protocol and port based VLAN configuration information.
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ *      RT_ERR_TBL_FULL         - Table is full.
+ * Note:
+ *     The incoming packet which match the protocol-and-port-based vlan will use the configure vid for ingress pipeline
+ *     The frame type is shown in the following:
+ *      - FRAME_TYPE_ETHERNET
+ *      - FRAME_TYPE_RFC1042
+ *      - FRAME_TYPE_LLCOTHER
+ */
+rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_get(rtk_port_t port, rtk_vlan_proto_type_t proto_type, rtk_vlan_protoVlan_frameType_t frame_type, rtk_vlan_protoAndPortInfo_t *pInfo)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i;
+    rtk_uint32 ppb_idx;
+    rtl8367c_protocolgdatacfg ppb_data_cfg;
+    rtl8367c_protocolvlancfg ppb_vlan_cfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (proto_type > RTK_MAX_NUM_OF_PROTO_TYPE)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if (frame_type >= FRAME_TYPE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+   ppb_idx = 0;
+
+    for (i = 0; i<= RTL8367C_PROTOVLAN_GIDX_MAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicVlanProtocolBasedGroupData(i, &ppb_data_cfg)) != RT_ERR_OK)
+            return retVal;
+
+        if ( (ppb_data_cfg.frameType == (rtl8367c_provlan_frametype)frame_type) && (ppb_data_cfg.etherType == proto_type) )
+        {
+            ppb_idx = i;
+            break;
+        }
+        else if (RTL8367C_PROTOVLAN_GIDX_MAX == i)
+            return RT_ERR_TBL_FULL;
+    }
+
+    if ((retVal = rtl8367c_getAsicVlanPortAndProtocolBased(rtk_switch_port_L2P_get(port), ppb_idx, &ppb_vlan_cfg)) != RT_ERR_OK)
+        return retVal;
+
+    if (FALSE == ppb_vlan_cfg.valid)
+        return RT_ERR_FAILED;
+
+    pInfo->frame_type = frame_type;
+    pInfo->proto_type = proto_type;
+    pInfo->cvid = vlan_mbrCfgVid[ppb_vlan_cfg.vlan_idx];
+    pInfo->cpri = ppb_vlan_cfg.priority;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_protoAndPortBasedVlan_del
+ * Description:
+ *      Delete the protocol-and-port-based vlan from the specified port of device.
+ * Input:
+ *      port        - Port id.
+ *      proto_type  - protocol-and-port-based vlan protocol type.
+ *      frame_type  - protocol-and-port-based vlan frame type.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ *      RT_ERR_TBL_FULL         - Table is full.
+ * Note:
+ *     The incoming packet which match the protocol-and-port-based vlan will use the configure vid for ingress pipeline
+ *     The frame type is shown in the following:
+ *      - FRAME_TYPE_ETHERNET
+ *      - FRAME_TYPE_RFC1042
+ *      - FRAME_TYPE_LLCOTHER
+ */
+rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_del(rtk_port_t port, rtk_vlan_proto_type_t proto_type, rtk_vlan_protoVlan_frameType_t frame_type)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i, bUsed;
+    rtk_uint32 ppb_idx;
+    rtl8367c_protocolgdatacfg ppb_data_cfg;
+    rtl8367c_protocolvlancfg ppb_vlan_cfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (proto_type > RTK_MAX_NUM_OF_PROTO_TYPE)
+        return RT_ERR_OUT_OF_RANGE;
+
+    if (frame_type >= FRAME_TYPE_END)
+        return RT_ERR_OUT_OF_RANGE;
+
+   ppb_idx = 0;
+
+    for (i = 0; i<= RTL8367C_PROTOVLAN_GIDX_MAX; i++)
+    {
+        if ((retVal = rtl8367c_getAsicVlanProtocolBasedGroupData(i, &ppb_data_cfg)) != RT_ERR_OK)
+            return retVal;
+
+        if ( (ppb_data_cfg.frameType == (rtl8367c_provlan_frametype)frame_type) && (ppb_data_cfg.etherType == proto_type) )
+        {
+            ppb_idx = i;
+            ppb_vlan_cfg.valid = FALSE;
+            ppb_vlan_cfg.vlan_idx = 0;
+            ppb_vlan_cfg.priority = 0;
+            if ((retVal = rtl8367c_setAsicVlanPortAndProtocolBased(rtk_switch_port_L2P_get(port), ppb_idx, &ppb_vlan_cfg)) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+
+    bUsed = FALSE;
+    RTK_SCAN_ALL_PHY_PORTMASK(i)
+    {
+        if ((retVal = rtl8367c_getAsicVlanPortAndProtocolBased(i, ppb_idx, &ppb_vlan_cfg)) != RT_ERR_OK)
+            return retVal;
+
+        if (TRUE == ppb_vlan_cfg.valid)
+        {
+            bUsed = TRUE;
+                break;
+        }
+    }
+
+    if (FALSE == bUsed) /*No Port use this PPB Index, Delete it*/
+    {
+        ppb_data_cfg.etherType=0;
+        ppb_data_cfg.frameType=0;
+        if ((retVal = rtl8367c_setAsicVlanProtocolBasedGroupData(ppb_idx, &ppb_data_cfg)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_protoAndPortBasedVlan_delAll
+ * Description:
+ *     Delete all protocol-and-port-based vlans from the specified port of device.
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK               - OK
+ *      RT_ERR_FAILED           - Failed
+ *      RT_ERR_SMI              - SMI access error
+ *      RT_ERR_PORT_ID          - Invalid port number.
+ *      RT_ERR_OUT_OF_RANGE     - input out of range.
+ * Note:
+ *     The incoming packet which match the protocol-and-port-based vlan will use the configure vid for ingress pipeline
+ *     Delete all flow table protocol-and-port-based vlan entries.
+ */
+rtk_api_ret_t rtk_vlan_protoAndPortBasedVlan_delAll(rtk_port_t port)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32 i, j, bUsed[4];
+    rtl8367c_protocolgdatacfg ppb_data_cfg;
+    rtl8367c_protocolvlancfg ppb_vlan_cfg;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    for (i = 0; i<= RTL8367C_PROTOVLAN_GIDX_MAX; i++)
+    {
+        ppb_vlan_cfg.valid = FALSE;
+        ppb_vlan_cfg.vlan_idx = 0;
+        ppb_vlan_cfg.priority = 0;
+        if ((retVal = rtl8367c_setAsicVlanPortAndProtocolBased(rtk_switch_port_L2P_get(port), i, &ppb_vlan_cfg)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    bUsed[0] = FALSE;
+    bUsed[1] = FALSE;
+    bUsed[2] = FALSE;
+    bUsed[3] = FALSE;
+    RTK_SCAN_ALL_PHY_PORTMASK(i)
+    {
+        for (j = 0; j <= RTL8367C_PROTOVLAN_GIDX_MAX; j++)
+        {
+            if ((retVal = rtl8367c_getAsicVlanPortAndProtocolBased(i,j, &ppb_vlan_cfg)) != RT_ERR_OK)
+                return retVal;
+
+            if (TRUE == ppb_vlan_cfg.valid)
+            {
+                bUsed[j] = TRUE;
+            }
+        }
+    }
+
+    for (i = 0; i<= RTL8367C_PROTOVLAN_GIDX_MAX; i++)
+    {
+        if (FALSE == bUsed[i]) /*No Port use this PPB Index, Delete it*/
+        {
+            ppb_data_cfg.etherType=0;
+            ppb_data_cfg.frameType=0;
+            if ((retVal = rtl8367c_setAsicVlanProtocolBasedGroupData(i, &ppb_data_cfg)) != RT_ERR_OK)
+                return retVal;
+        }
+    }
+
+
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_tagMode_set
+ * Description:
+ *      Set CVLAN egress tag mode
+ * Input:
+ *      port        - Port id.
+ *      tag_mode    - The egress tag mode.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ *      RT_ERR_ENABLE       - Invalid enable input.
+ * Note:
+ *      The API can set Egress tag mode. There are 4 mode for egress tag:
+ *      - VLAN_TAG_MODE_ORIGINAL,
+ *      - VLAN_TAG_MODE_KEEP_FORMAT,
+ *      - VLAN_TAG_MODE_PRI.
+ *      - VLAN_TAG_MODE_REAL_KEEP_FORMAT,
+ */
+rtk_api_ret_t rtk_vlan_tagMode_set(rtk_port_t port, rtk_vlan_tagMode_t tag_mode)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (tag_mode >= VLAN_TAG_MODE_END)
+        return RT_ERR_PORT_ID;
+
+    if ((retVal = rtl8367c_setAsicVlanEgressTagMode(rtk_switch_port_L2P_get(port), tag_mode)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_tagMode_get
+ * Description:
+ *      Get CVLAN egress tag mode
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pTag_mode - The egress tag mode.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      The API can get Egress tag mode. There are 4 mode for egress tag:
+ *      - VLAN_TAG_MODE_ORIGINAL,
+ *      - VLAN_TAG_MODE_KEEP_FORMAT,
+ *      - VLAN_TAG_MODE_PRI.
+ *      - VLAN_TAG_MODE_REAL_KEEP_FORMAT,
+ */
+rtk_api_ret_t rtk_vlan_tagMode_get(rtk_port_t port, rtk_vlan_tagMode_t *pTag_mode)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_egtagmode  mode;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pTag_mode)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicVlanEgressTagMode(rtk_switch_port_L2P_get(port), &mode)) != RT_ERR_OK)
+        return retVal;
+
+    *pTag_mode = (rtk_vlan_tagMode_t)mode;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_transparent_set
+ * Description:
+ *      Set VLAN transparent mode
+ * Input:
+ *      egr_port        - Egress Port id.
+ *      pIgr_pmask      - Ingress Port Mask.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_vlan_transparent_set(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask)
+{
+     rtk_api_ret_t retVal;
+     rtk_uint32    pmask;
+
+     /* Check initialization state */
+     RTK_CHK_INIT_STATE();
+
+     /* Check Port Valid */
+     RTK_CHK_PORT_VALID(egr_port);
+
+     if(NULL == pIgr_pmask)
+        return RT_ERR_NULL_POINTER;
+
+     RTK_CHK_PORTMASK_VALID(pIgr_pmask);
+
+     if(rtk_switch_portmask_L2P_get(pIgr_pmask, &pmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+     if ((retVal = rtl8367c_setAsicVlanTransparent(rtk_switch_port_L2P_get(egr_port), pmask)) != RT_ERR_OK)
+         return retVal;
+
+     return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_transparent_get
+ * Description:
+ *      Get VLAN transparent mode
+ * Input:
+ *      egr_port        - Egress Port id.
+ * Output:
+ *      pIgr_pmask      - Ingress Port Mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_vlan_transparent_get(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask)
+{
+     rtk_api_ret_t retVal;
+     rtk_uint32    pmask;
+
+     /* Check initialization state */
+     RTK_CHK_INIT_STATE();
+
+     /* Check Port Valid */
+     RTK_CHK_PORT_VALID(egr_port);
+
+     if(NULL == pIgr_pmask)
+        return RT_ERR_NULL_POINTER;
+
+     if ((retVal = rtl8367c_getAsicVlanTransparent(rtk_switch_port_L2P_get(egr_port), &pmask)) != RT_ERR_OK)
+         return retVal;
+
+     if(rtk_switch_portmask_P2L_get(pmask, pIgr_pmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+     return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_keep_set
+ * Description:
+ *      Set VLAN egress keep mode
+ * Input:
+ *      egr_port        - Egress Port id.
+ *      pIgr_pmask      - Ingress Port Mask.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_vlan_keep_set(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask)
+{
+     rtk_api_ret_t retVal;
+     rtk_uint32    pmask;
+
+     /* Check initialization state */
+     RTK_CHK_INIT_STATE();
+
+     /* Check Port Valid */
+     RTK_CHK_PORT_VALID(egr_port);
+
+     if(NULL == pIgr_pmask)
+        return RT_ERR_NULL_POINTER;
+
+     RTK_CHK_PORTMASK_VALID(pIgr_pmask);
+
+     if(rtk_switch_portmask_L2P_get(pIgr_pmask, &pmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+     if ((retVal = rtl8367c_setAsicVlanEgressKeep(rtk_switch_port_L2P_get(egr_port), pmask)) != RT_ERR_OK)
+         return retVal;
+
+     return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_keep_get
+ * Description:
+ *      Get VLAN egress keep mode
+ * Input:
+ *      egr_port        - Egress Port id.
+ * Output:
+ *      pIgr_pmask      - Ingress Port Mask
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ * Note:
+ *      None.
+ */
+rtk_api_ret_t rtk_vlan_keep_get(rtk_port_t egr_port, rtk_portmask_t *pIgr_pmask)
+{
+     rtk_api_ret_t retVal;
+     rtk_uint32    pmask;
+
+     /* Check initialization state */
+     RTK_CHK_INIT_STATE();
+
+     /* Check Port Valid */
+     RTK_CHK_PORT_VALID(egr_port);
+
+     if(NULL == pIgr_pmask)
+        return RT_ERR_NULL_POINTER;
+
+     if ((retVal = rtl8367c_getAsicVlanEgressKeep(rtk_switch_port_L2P_get(egr_port), &pmask)) != RT_ERR_OK)
+         return retVal;
+
+     if(rtk_switch_portmask_P2L_get(pmask, pIgr_pmask) != RT_ERR_OK)
+        return RT_ERR_FAILED;
+
+     return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_stg_set
+ * Description:
+ *      Set spanning tree group instance of the vlan to the specified device
+ * Input:
+ *      vid - Specified VLAN ID.
+ *      stg - spanning tree group instance.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_MSTI         - Invalid msti parameter
+ *      RT_ERR_INPUT        - Invalid input parameter.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ * Note:
+ *      The API can set spanning tree group instance of the vlan to the specified device.
+ */
+rtk_api_ret_t rtk_vlan_stg_set(rtk_vlan_t vid, rtk_stp_msti_id_t stg)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_user_vlan4kentry vlan4K;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* vid must be 0~4095 */
+    if (vid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    /* priority must be 0~15 */
+    if (stg > RTL8367C_MSTIMAX)
+        return RT_ERR_MSTI;
+
+    /* update 4K table */
+    vlan4K.vid = vid;
+    if ((retVal = rtl8367c_getAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
+        return retVal;
+
+    vlan4K.fid_msti= stg;
+    if ((retVal = rtl8367c_setAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_stg_get
+ * Description:
+ *      Get spanning tree group instance of the vlan to the specified device
+ * Input:
+ *      vid - Specified VLAN ID.
+ * Output:
+ *      pStg - spanning tree group instance.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Invalid input parameters.
+ *      RT_ERR_VLAN_VID     - Invalid VID parameter.
+ * Note:
+ *      The API can get spanning tree group instance of the vlan to the specified device.
+ */
+rtk_api_ret_t rtk_vlan_stg_get(rtk_vlan_t vid, rtk_stp_msti_id_t *pStg)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_user_vlan4kentry vlan4K;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* vid must be 0~4095 */
+    if (vid > RTL8367C_VIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    if(NULL == pStg)
+        return RT_ERR_NULL_POINTER;
+
+    /* update 4K table */
+    vlan4K.vid = vid;
+    if ((retVal = rtl8367c_getAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
+        return retVal;
+
+    *pStg = vlan4K.fid_msti;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_portFid_set
+ * Description:
+ *      Set port-based filtering database
+ * Input:
+ *      port - Port id.
+ *      enable - ebable port-based FID
+ *      fid - Specified filtering database.
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_L2_FID - Invalid fid.
+ *      RT_ERR_INPUT - Invalid input parameter.
+ *      RT_ERR_PORT_ID - Invalid port ID.
+ * Note:
+ *      The API can set port-based filtering database. If the function is enabled, all input
+ *      packets will be assigned to the port-based fid regardless vlan tag.
+ */
+rtk_api_ret_t rtk_vlan_portFid_set(rtk_port_t port, rtk_enable_t enable, rtk_fid_t fid)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (enable>=RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    /* fid must be 0~4095 */
+    if (fid > RTK_FID_MAX)
+        return RT_ERR_L2_FID;
+
+    if ((retVal = rtl8367c_setAsicPortBasedFidEn(rtk_switch_port_L2P_get(port), enable))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_setAsicPortBasedFid(rtk_switch_port_L2P_get(port), fid))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_portFid_get
+ * Description:
+ *      Get port-based filtering database
+ * Input:
+ *      port - Port id.
+ * Output:
+ *      pEnable - ebable port-based FID
+ *      pFid - Specified filtering database.
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_INPUT - Invalid input parameters.
+ *      RT_ERR_PORT_ID - Invalid port ID.
+ * Note:
+ *      The API can get port-based filtering database status. If the function is enabled, all input
+ *      packets will be assigned to the port-based fid regardless vlan tag.
+ */
+rtk_api_ret_t rtk_vlan_portFid_get(rtk_port_t port, rtk_enable_t *pEnable, rtk_fid_t *pFid)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if(NULL == pFid)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicPortBasedFidEn(rtk_switch_port_L2P_get(port), pEnable))!=RT_ERR_OK)
+        return retVal;
+
+    if ((retVal = rtl8367c_getAsicPortBasedFid(rtk_switch_port_L2P_get(port), pFid))!=RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_UntagDscpPriorityEnable_set
+ * Description:
+ *      Set Untag DSCP priority assign
+ * Input:
+ *      enable - state of Untag DSCP priority assign
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_ENABLE          - Invalid input parameters.
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_UntagDscpPriorityEnable_set(rtk_enable_t enable)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(enable >= RTK_ENABLE_END)
+        return RT_ERR_ENABLE;
+
+    if ((retVal = rtl8367c_setAsicVlanUntagDscpPriorityEn((rtk_uint32)enable)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_UntagDscpPriorityEnable_get
+ * Description:
+ *      Get Untag DSCP priority assign
+ * Input:
+ *      None
+ * Output:
+ *      pEnable - state of Untag DSCP priority assign
+ * Return:
+ *      RT_ERR_OK              - OK
+ *      RT_ERR_FAILED          - Failed
+ *      RT_ERR_SMI             - SMI access error
+ *      RT_ERR_NULL_POINTER    - Null pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_UntagDscpPriorityEnable_get(rtk_enable_t *pEnable)
+{
+    rtk_api_ret_t retVal;
+    rtk_uint32  value;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnable)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicVlanUntagDscpPriorityEn(&value)) != RT_ERR_OK)
+        return retVal;
+
+    *pEnable = (rtk_enable_t)value;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stp_mstpState_set
+ * Description:
+ *      Configure spanning tree state per each port.
+ * Input:
+ *      port - Port id
+ *      msti - Multiple spanning tree instance.
+ *      stp_state - Spanning tree state for msti
+ * Output:
+ *      None
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_MSTI         - Invalid msti parameter.
+ *      RT_ERR_MSTP_STATE   - Invalid STP state.
+ * Note:
+ *      System supports per-port multiple spanning tree state for each msti.
+ *      There are four states supported by ASIC.
+ *      - STP_STATE_DISABLED
+ *      - STP_STATE_BLOCKING
+ *      - STP_STATE_LEARNING
+ *      - STP_STATE_FORWARDING
+ */
+rtk_api_ret_t rtk_stp_mstpState_set(rtk_stp_msti_id_t msti, rtk_port_t port, rtk_stp_state_t stp_state)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (msti > RTK_MAX_NUM_OF_MSTI)
+        return RT_ERR_MSTI;
+
+    if (stp_state >= STP_STATE_END)
+        return RT_ERR_MSTP_STATE;
+
+    if ((retVal = rtl8367c_setAsicSpanningTreeStatus(rtk_switch_port_L2P_get(port), msti, stp_state)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_stp_mstpState_get
+ * Description:
+ *      Get spanning tree state per each port.
+ * Input:
+ *      port - Port id.
+ *      msti - Multiple spanning tree instance.
+ * Output:
+ *      pStp_state - Spanning tree state for msti
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_PORT_ID      - Invalid port number.
+ *      RT_ERR_MSTI         - Invalid msti parameter.
+ * Note:
+ *      System supports per-port multiple spanning tree state for each msti.
+ *      There are four states supported by ASIC.
+ *      - STP_STATE_DISABLED
+ *      - STP_STATE_BLOCKING
+ *      - STP_STATE_LEARNING
+ *      - STP_STATE_FORWARDING
+ */
+rtk_api_ret_t rtk_stp_mstpState_get(rtk_stp_msti_id_t msti, rtk_port_t port, rtk_stp_state_t *pStp_state)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* Check Port Valid */
+    RTK_CHK_PORT_VALID(port);
+
+    if (msti > RTK_MAX_NUM_OF_MSTI)
+        return RT_ERR_MSTI;
+
+    if(NULL == pStp_state)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getAsicSpanningTreeStatus(rtk_switch_port_L2P_get(port), msti, pStp_state)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_checkAndCreateMbr
+ * Description:
+ *      Check and create Member configuration and return index
+ * Input:
+ *      vid  - VLAN id.
+ * Output:
+ *      pIndex  - Member configuration index
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_VLAN_VID     - Invalid VLAN ID.
+ *      RT_ERR_VLAN_ENTRY_NOT_FOUND - VLAN not found
+ *      RT_ERR_TBL_FULL     - Member Configuration table full
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_checkAndCreateMbr(rtk_vlan_t vid, rtk_uint32 *pIndex)
+{
+    rtk_api_ret_t retVal;
+    rtl8367c_user_vlan4kentry vlan4K;
+    rtl8367c_vlanconfiguser vlanMC;
+    rtk_uint32 idx;
+    rtk_uint32 empty_idx = 0xFFFF;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    /* vid must be 0~8191 */
+    if (vid > RTL8367C_EVIDMAX)
+        return RT_ERR_VLAN_VID;
+
+    /* Null pointer check */
+    if(NULL == pIndex)
+        return RT_ERR_NULL_POINTER;
+
+    /* Get 4K VLAN */
+    if (vid <= RTL8367C_VIDMAX)
+    {
+        memset(&vlan4K, 0x00, sizeof(rtl8367c_user_vlan4kentry));
+        vlan4K.vid = vid;
+        if ((retVal = rtl8367c_getAsicVlan4kEntry(&vlan4K)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /* Search exist entry */
+    for (idx = 0; idx <= RTL8367C_CVIDXMAX; idx++)
+    {
+        if(vlan_mbrCfgUsage[idx] == MBRCFG_USED_BY_VLAN)
+        {
+            if(vlan_mbrCfgVid[idx] == vid)
+            {
+                /* Found! return index */
+                *pIndex = idx;
+                return RT_ERR_OK;
+            }
+        }
+    }
+
+    /* Not found, Read H/W Member Configuration table to update database */
+    for (idx = 0; idx <= RTL8367C_CVIDXMAX; idx++)
+    {
+        if ((retVal = rtl8367c_getAsicVlanMemberConfig(idx, &vlanMC)) != RT_ERR_OK)
+            return retVal;
+
+        if( (vlanMC.evid == 0) && (vlanMC.mbr == 0x00))
+        {
+            vlan_mbrCfgUsage[idx]   = MBRCFG_UNUSED;
+            vlan_mbrCfgVid[idx]     = 0;
+        }
+        else
+        {
+            vlan_mbrCfgUsage[idx]   = MBRCFG_USED_BY_VLAN;
+            vlan_mbrCfgVid[idx]     = vlanMC.evid;
+        }
+    }
+
+    /* Search exist entry again */
+    for (idx = 0; idx <= RTL8367C_CVIDXMAX; idx++)
+    {
+        if(vlan_mbrCfgUsage[idx] == MBRCFG_USED_BY_VLAN)
+        {
+            if(vlan_mbrCfgVid[idx] == vid)
+            {
+                /* Found! return index */
+                *pIndex = idx;
+                return RT_ERR_OK;
+            }
+        }
+    }
+
+    /* try to look up an empty index */
+    for (idx = 0; idx <= RTL8367C_CVIDXMAX; idx++)
+    {
+        if(vlan_mbrCfgUsage[idx] == MBRCFG_UNUSED)
+        {
+            empty_idx = idx;
+            break;
+        }
+    }
+
+    if(empty_idx == 0xFFFF)
+    {
+        /* No empty index */
+        return RT_ERR_TBL_FULL;
+    }
+
+    if (vid > RTL8367C_VIDMAX)
+    {
+        /* > 4K, there is no 4K entry, create on member configuration directly */
+        memset(&vlanMC, 0x00, sizeof(rtl8367c_vlanconfiguser));
+        vlanMC.evid = vid;
+        if ((retVal = rtl8367c_setAsicVlanMemberConfig(empty_idx, &vlanMC)) != RT_ERR_OK)
+            return retVal;
+    }
+    else
+    {
+        /* Copy from 4K table */
+        vlanMC.evid = vid;
+        vlanMC.mbr = vlan4K.mbr;
+        vlanMC.fid_msti = vlan4K.fid_msti;
+        vlanMC.meteridx= vlan4K.meteridx;
+        vlanMC.envlanpol= vlan4K.envlanpol;
+        vlanMC.vbpen = vlan4K.vbpen;
+        vlanMC.vbpri = vlan4K.vbpri;
+        if ((retVal = rtl8367c_setAsicVlanMemberConfig(empty_idx, &vlanMC)) != RT_ERR_OK)
+            return retVal;
+    }
+
+    /* Update Database */
+    vlan_mbrCfgUsage[empty_idx] = MBRCFG_USED_BY_VLAN;
+    vlan_mbrCfgVid[empty_idx] = vid;
+
+    *pIndex = empty_idx;
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_reservedVidAction_set
+ * Description:
+ *      Set Action of VLAN ID = 0 & 4095 tagged packet
+ * Input:
+ *      action_vid0     - Action for VID 0.
+ *      action_vid4095  - Action for VID 4095.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_reservedVidAction_set(rtk_vlan_resVidAction_t action_vid0, rtk_vlan_resVidAction_t action_vid4095)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(action_vid0 >= RESVID_ACTION_END)
+        return RT_ERR_INPUT;
+
+    if(action_vid4095 >= RESVID_ACTION_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setReservedVidAction((rtk_uint32)action_vid0, (rtk_uint32)action_vid4095)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_reservedVidAction_get
+ * Description:
+ *      Get Action of VLAN ID = 0 & 4095 tagged packet
+ * Input:
+ *      pAction_vid0     - Action for VID 0.
+ *      pAction_vid4095  - Action for VID 4095.
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_NULL_POINTER - NULL Pointer
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_reservedVidAction_get(rtk_vlan_resVidAction_t *pAction_vid0, rtk_vlan_resVidAction_t *pAction_vid4095)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(pAction_vid0 == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if(pAction_vid4095 == NULL)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getReservedVidAction((rtk_uint32 *)pAction_vid0, (rtk_uint32 *)pAction_vid4095)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_realKeepRemarkEnable_set
+ * Description:
+ *      Set Real keep 1p remarking feature
+ * Input:
+ *      enabled     - State of 1p remarking at real keep packet
+ * Output:
+ *      None.
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_realKeepRemarkEnable_set(rtk_enable_t enabled)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(enabled >= RTK_ENABLE_END)
+        return RT_ERR_INPUT;
+
+    if ((retVal = rtl8367c_setRealKeepRemarkEn((rtk_uint32)enabled)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_realKeepRemarkEnable_get
+ * Description:
+ *      Get Real keep 1p remarking feature
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled     - State of 1p remarking at real keep packet
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_realKeepRemarkEnable_get(rtk_enable_t *pEnabled)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if(NULL == pEnabled)
+        return RT_ERR_NULL_POINTER;
+
+    if ((retVal = rtl8367c_getRealKeepRemarkEn((rtk_uint32 *)pEnabled)) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
+/* Function Name:
+ *      rtk_vlan_reset
+ * Description:
+ *      Reset VLAN
+ * Input:
+ *      None.
+ * Output:
+ *      pEnabled     - State of 1p remarking at real keep packet
+ * Return:
+ *      RT_ERR_OK           - OK
+ *      RT_ERR_FAILED       - Failed
+ *      RT_ERR_SMI          - SMI access error
+ *      RT_ERR_INPUT        - Error Input
+ * Note:
+ *
+ */
+rtk_api_ret_t rtk_vlan_reset(void)
+{
+    rtk_api_ret_t retVal;
+
+    /* Check initialization state */
+    RTK_CHK_INIT_STATE();
+
+    if ((retVal = rtl8367c_resetVlan()) != RT_ERR_OK)
+        return retVal;
+
+    return RT_ERR_OK;
+}
+
diff --git a/drivers/net/phy/rtk/rtl8367s.c b/drivers/net/phy/rtk/rtl8367s.c
new file mode 100755
index 0000000000000..8f27216c51fcd
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367s.c
@@ -0,0 +1,580 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
+#include <linux/switch.h>
+
+//include from rtl8367c dir
+#include  "./rtl8367c/include/rtk_switch.h"
+#include  "./rtl8367c/include/vlan.h"
+#include  "./rtl8367c/include/stat.h"
+#include  "./rtl8367c/include/port.h"
+
+#define RTL8367C_SW_CPU_PORT    6
+
+ //RTL8367C_PHY_PORT_NUM + ext0 + ext1
+#define RTL8367C_NUM_PORTS 7 
+#define RTL8367C_NUM_VIDS  4096   
+
+struct rtl8367_priv {
+	struct switch_dev	swdev;
+	bool			global_vlan_enable;
+};
+
+struct rtl8367_mib_counter {	
+	const char *name;
+};
+
+struct rtl8367_vlan_info {
+	unsigned short	vid;
+	unsigned int	untag;
+	unsigned int	member;
+	unsigned char		fid;
+};
+
+struct rtl8367_priv  rtl8367_priv_data;
+
+unsigned int rtl8367c_port_id[RTL8367C_NUM_PORTS]={0,1,2,3,4,EXT_PORT1,EXT_PORT0};
+
+void (*rtl8367_switch_reset_func)(void)=NULL;
+
+static  struct rtl8367_mib_counter  rtl8367c_mib_counters[] = {
+	{"ifInOctets"},
+	{"dot3StatsFCSErrors"},
+	{"dot3StatsSymbolErrors"},
+	{"dot3InPauseFrames"},
+	{"dot3ControlInUnknownOpcodes"},
+	{"etherStatsFragments"},
+	{"etherStatsJabbers"},
+	{"ifInUcastPkts"},
+	{"etherStatsDropEvents"},
+	{"etherStatsOctets"},
+	{"etherStatsUndersizePkts"},
+	{"etherStatsOversizePkts"},
+	{"etherStatsPkts64Octets"},
+	{"etherStatsPkts65to127Octets"},
+	{"etherStatsPkts128to255Octets"},
+	{"etherStatsPkts256to511Octets"},
+	{"etherStatsPkts512to1023Octets"},
+	{"etherStatsPkts1024toMaxOctets"},
+	{"etherStatsMcastPkts"}, 
+	{"etherStatsBcastPkts"},
+	{"ifOutOctets"},
+	{"dot3StatsSingleCollisionFrames"},
+	{"dot3StatsMultipleCollisionFrames"},
+	{"dot3StatsDeferredTransmissions"},
+	{"dot3StatsLateCollisions"}, 
+	{"etherStatsCollisions"},
+	{"dot3StatsExcessiveCollisions"},
+	{"dot3OutPauseFrames"},
+	{"dot1dBasePortDelayExceededDiscards"},
+	{"dot1dTpPortInDiscards"},
+	{"ifOutUcastPkts"},
+	{"ifOutMulticastPkts"},
+	{"ifOutBrocastPkts"},
+	{"outOampduPkts"},
+	{"inOampduPkts"},
+	{"pktgenPkts"},
+	{"inMldChecksumError"},
+	{"inIgmpChecksumError"},
+	{"inMldSpecificQuery"},
+	{"inMldGeneralQuery"},
+	{"inIgmpSpecificQuery"},
+	{"inIgmpGeneralQuery"},
+	{"inMldLeaves"},
+	{"inIgmpLeaves"},
+	{"inIgmpJoinsSuccess"},
+	{"inIgmpJoinsFail"},
+	{"inMldJoinsSuccess"},
+	{"inMldJoinsFail"},
+	{"inReportSuppressionDrop"},
+	{"inLeaveSuppressionDrop"},
+	{"outIgmpReports"},
+	{"outIgmpLeaves"},
+	{"outIgmpGeneralQuery"},
+	{"outIgmpSpecificQuery"},
+	{"outMldReports"},
+	{"outMldLeaves"},
+	{"outMldGeneralQuery"},
+	{"outMldSpecificQuery"},
+	{"inKnownMulticastPkts"},
+	{"ifInMulticastPkts"},
+	{"ifInBroadcastPkts"},
+	{"ifOutDiscards"}
+};
+
+/*rtl8367c  proprietary switch API wrapper */
+static inline unsigned int rtl8367c_sw_to_phy_port(int port)
+{
+	return rtl8367c_port_id[port];
+}
+
+static inline unsigned int rtl8367c_portmask_phy_to_sw(rtk_portmask_t phy_portmask)
+{
+	int i;
+	for (i = 0; i < RTL8367C_NUM_PORTS; i++) {
+		if(RTK_PORTMASK_IS_PORT_SET(phy_portmask,rtl8367c_sw_to_phy_port(i))) {
+			RTK_PORTMASK_PORT_CLEAR(phy_portmask,rtl8367c_sw_to_phy_port(i));
+			RTK_PORTMASK_PORT_SET(phy_portmask,i);
+		}		
+
+	}
+	return (unsigned int)phy_portmask.bits[0];
+}
+
+static int rtl8367c_reset_mibs(void)
+{
+	return rtk_stat_global_reset();
+}
+
+static int rtl8367c_reset_port_mibs(int port)
+{
+
+	return rtk_stat_port_reset(rtl8367c_sw_to_phy_port(port));
+}
+
+static int rtl8367c_get_mibs_num(void)
+{
+	return ARRAY_SIZE(rtl8367c_mib_counters);
+}
+
+static const char *rtl8367c_get_mib_name(int idx)
+{
+	
+	return rtl8367c_mib_counters[idx].name;
+}
+
+static int rtl8367c_get_port_mib_counter(int idx, int port, unsigned long long *counter)
+{
+	return rtk_stat_port_get(rtl8367c_sw_to_phy_port(port), idx, counter);
+}
+
+static int rtl8367c_is_vlan_valid(unsigned int vlan)
+{
+	unsigned max = RTL8367C_NUM_VIDS;	
+
+	if (vlan == 0 || vlan >= max)
+		return 0;
+
+	return 1;
+}
+
+static int rtl8367c_get_vlan( unsigned short vid, struct rtl8367_vlan_info *vlan)
+{	
+	rtk_vlan_cfg_t vlan_cfg;
+
+	memset(vlan, '\0', sizeof(struct rtl8367_vlan_info));
+
+	if (vid >= RTL8367C_NUM_VIDS)
+		return -EINVAL;	
+
+	if(rtk_vlan_get(vid,&vlan_cfg))
+       	return -EINVAL;		
+	
+	vlan->vid = vid;
+	vlan->member = rtl8367c_portmask_phy_to_sw(vlan_cfg.mbr);	
+	vlan->untag = rtl8367c_portmask_phy_to_sw(vlan_cfg.untag);	
+	vlan->fid = vlan_cfg.fid_msti;
+
+	return 0;
+}
+
+static int rtl8367c_set_vlan( unsigned short vid, u32 mbr, u32 untag, u8 fid)
+{	
+	rtk_vlan_cfg_t vlan_cfg;
+	int i;
+
+	memset(&vlan_cfg, 0x00, sizeof(rtk_vlan_cfg_t));	
+
+	for (i = 0; i < RTL8367C_NUM_PORTS; i++) {
+		if (mbr & (1 << i)) {
+			RTK_PORTMASK_PORT_SET(vlan_cfg.mbr, rtl8367c_sw_to_phy_port(i));
+			if(untag & (1 << i))
+				RTK_PORTMASK_PORT_SET(vlan_cfg.untag, rtl8367c_sw_to_phy_port(i));			
+		}
+	}
+	vlan_cfg.fid_msti=fid;
+	
+	return rtk_vlan_set(vid, &vlan_cfg);
+}
+
+
+static int rtl8367c_get_pvid( int port, int *pvid)
+{
+	u32 prio=0;
+	
+	if (port >= RTL8367C_NUM_PORTS)
+		return -EINVAL;		
+
+	return rtk_vlan_portPvid_get(rtl8367c_sw_to_phy_port(port),pvid,&prio);
+}
+
+
+static int rtl8367c_set_pvid( int port, int pvid)
+{
+	u32 prio=0;
+	
+	if (port >= RTL8367C_NUM_PORTS)
+		return -EINVAL;		
+
+	return rtk_vlan_portPvid_set(rtl8367c_sw_to_phy_port(port),pvid,prio);
+}
+
+static int rtl8367c_get_port_link(int port, int *link, int *speed, int *duplex)
+{
+	
+	if(rtk_port_phyStatus_get(rtl8367c_sw_to_phy_port(port),(rtk_port_linkStatus_t *)link,
+					(rtk_port_speed_t *)speed,(rtk_port_duplex_t *)duplex))
+		return -EINVAL;
+
+	return 0;
+}
+
+/*common rtl8367 swconfig entry API*/
+
+static int
+rtl8367_sw_set_vlan_enable(struct switch_dev *dev,
+			   const struct switch_attr *attr,
+			   struct switch_val *val)
+{
+	struct rtl8367_priv *priv = container_of(dev, struct rtl8367_priv, swdev);	
+
+	priv->global_vlan_enable = val->value.i ;
+
+	return 0;
+}
+
+static int
+rtl8367_sw_get_vlan_enable(struct switch_dev *dev,
+			   const struct switch_attr *attr,
+			   struct switch_val *val)
+{
+	struct rtl8367_priv *priv = container_of(dev, struct rtl8367_priv, swdev);
+
+	val->value.i = priv->global_vlan_enable;
+
+	return 0;
+}
+
+static int rtl8367_sw_reset_mibs(struct switch_dev *dev,
+				  const struct switch_attr *attr,
+				  struct switch_val *val)
+{
+	return rtl8367c_reset_mibs();
+}
+
+
+static int rtl8367_sw_reset_port_mibs(struct switch_dev *dev,
+				       const struct switch_attr *attr,
+				       struct switch_val *val)
+{
+	int port;
+
+	port = val->port_vlan;
+	if (port >= RTL8367C_NUM_PORTS)
+		return -EINVAL;
+
+	return rtl8367c_reset_port_mibs(port);
+}
+
+static int rtl8367_sw_get_port_mib(struct switch_dev *dev,
+			    const struct switch_attr *attr,
+			    struct switch_val *val)
+{	
+	int i, len = 0;
+	unsigned long long counter = 0;
+	static char mib_buf[4096];
+
+	if (val->port_vlan >= RTL8367C_NUM_PORTS)
+		return -EINVAL;
+
+	len += snprintf(mib_buf + len, sizeof(mib_buf) - len,
+			"Port %d MIB counters\n",
+			val->port_vlan);	
+
+	for (i = 0; i <rtl8367c_get_mibs_num(); ++i) {
+		len += snprintf(mib_buf + len, sizeof(mib_buf) - len,
+				"%-36s: ",rtl8367c_get_mib_name(i));
+		if (!rtl8367c_get_port_mib_counter(i, val->port_vlan,
+					       &counter))
+			len += snprintf(mib_buf + len, sizeof(mib_buf) - len,
+					"%llu\n", counter);
+		else
+			len += snprintf(mib_buf + len, sizeof(mib_buf) - len,
+					"%s\n", "N/A");
+	}
+
+	val->value.s = mib_buf;
+	val->len = len;
+	return 0;
+}
+
+
+static int rtl8367_sw_get_vlan_info(struct switch_dev *dev,
+			     const struct switch_attr *attr,
+			     struct switch_val *val)
+{	
+	int i;
+	u32 len = 0;
+	struct rtl8367_vlan_info vlan;
+	static char vlan_buf[256];
+	int err;
+
+	if (!rtl8367c_is_vlan_valid(val->port_vlan))
+		return -EINVAL;
+
+	memset(vlan_buf, '\0', sizeof(vlan_buf));
+
+	err = rtl8367c_get_vlan(val->port_vlan, &vlan);
+	if (err)
+		return err;
+
+	len += snprintf(vlan_buf + len, sizeof(vlan_buf) - len,
+			"VLAN %d: Ports: '", vlan.vid);
+
+	for (i = 0; i <RTL8367C_NUM_PORTS; i++) {
+		if (!(vlan.member & (1 << i)))
+			continue;
+
+		len += snprintf(vlan_buf + len, sizeof(vlan_buf) - len, "%d%s", i,
+				(vlan.untag & (1 << i)) ? "" : "t");
+	}
+
+	len += snprintf(vlan_buf + len, sizeof(vlan_buf) - len,
+			"', members=%04x, untag=%04x, fid=%u",
+			vlan.member, vlan.untag, vlan.fid);
+
+	val->value.s = vlan_buf;
+	val->len = len;
+
+	return 0;
+}
+
+
+static int rtl8367_sw_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct switch_port *port;
+	struct rtl8367_vlan_info vlan;
+	int i;	
+	
+	if (!rtl8367c_is_vlan_valid(val->port_vlan))
+		return -EINVAL;
+
+	if(rtl8367c_get_vlan(val->port_vlan, &vlan))
+		return -EINVAL;
+
+	port = &val->value.ports[0];
+	val->len = 0;
+	for (i = 0; i <RTL8367C_NUM_PORTS ; i++) {
+		if (!(vlan.member & BIT(i)))
+			continue;
+
+		port->id = i;
+		port->flags = (vlan.untag & BIT(i)) ?
+					0 : BIT(SWITCH_PORT_FLAG_TAGGED);
+		val->len++;
+		port++;
+	}
+	return 0;
+}
+
+
+static int rtl8367_sw_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct switch_port *port;
+	u32 member = 0;
+	u32 untag = 0;
+	u8 fid=0;
+	int err;
+	int i;	
+	
+	if (!rtl8367c_is_vlan_valid(val->port_vlan))
+		return -EINVAL;
+
+	port = &val->value.ports[0];
+	for (i = 0; i < val->len; i++, port++) {
+		int pvid = 0;
+		member |= BIT(port->id);
+
+		if (!(port->flags & BIT(SWITCH_PORT_FLAG_TAGGED)))
+			untag |= BIT(port->id);
+
+		/*
+		 * To ensure that we have a valid MC entry for this VLAN,
+		 * initialize the port VLAN ID here.
+		 */
+		err = rtl8367c_get_pvid(port->id, &pvid);
+		if (err < 0)
+			return err;
+		if (pvid == 0) {
+			err = rtl8367c_set_pvid(port->id, val->port_vlan);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	//pr_info("[%s] vid=%d , mem=%x,untag=%x,fid=%d \n",__func__,val->port_vlan,member,untag,fid);
+
+	return rtl8367c_set_vlan(val->port_vlan, member, untag, fid);	
+
+}
+
+
+static int rtl8367_sw_get_port_pvid(struct switch_dev *dev, int port, int *val)
+{
+	return rtl8367c_get_pvid(port, val);
+}
+
+
+static int rtl8367_sw_set_port_pvid(struct switch_dev *dev, int port, int val)
+{	
+	return rtl8367c_set_pvid(port, val);
+}
+
+
+static int rtl8367_sw_reset_switch(struct switch_dev *dev)
+{
+	if(rtl8367_switch_reset_func)
+		(*rtl8367_switch_reset_func)();
+	else
+		printk("rest switch is not supported\n");
+
+	return 0;
+}
+
+static int rtl8367_sw_get_port_link(struct switch_dev *dev, int port,
+				    struct switch_port_link *link)
+{	
+	int speed;
+
+	if (port >= RTL8367C_NUM_PORTS)
+		return -EINVAL;
+
+	if(rtl8367c_get_port_link(port,(int *)&link->link,(int *)&speed,(int *)&link->duplex))
+		return -EINVAL;		
+
+	if (!link->link)
+		return 0;	
+
+	switch (speed) {
+	case 0:
+		link->speed = SWITCH_PORT_SPEED_10;
+		break;
+	case 1:
+		link->speed = SWITCH_PORT_SPEED_100;
+		break;
+	case 2:
+		link->speed = SWITCH_PORT_SPEED_1000;
+		break;
+	default:
+		link->speed = SWITCH_PORT_SPEED_UNKNOWN;
+		break;
+	}
+
+	return 0;
+}
+
+
+static struct switch_attr rtl8367_globals[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "Enable VLAN mode",
+		.set = rtl8367_sw_set_vlan_enable,
+		.get = rtl8367_sw_get_vlan_enable,
+		.max = 1,		
+	}, {		
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset_mibs",
+		.description = "Reset all MIB counters",
+		.set = rtl8367_sw_reset_mibs,
+	}
+};
+
+static struct switch_attr rtl8367_port[] = {
+	{
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset_mib",
+		.description = "Reset single port MIB counters",
+		.set = rtl8367_sw_reset_port_mibs,
+	}, {
+		.type = SWITCH_TYPE_STRING,
+		.name = "mib",
+		.description = "Get MIB counters for port",
+		//.max = 33,
+		.set = NULL,
+		.get = rtl8367_sw_get_port_mib,
+	},
+};
+
+static struct switch_attr rtl8367_vlan[] = {
+	{
+		.type = SWITCH_TYPE_STRING,
+		.name = "info",
+		.description = "Get vlan information",
+		.max = 1,
+		.set = NULL,
+		.get = rtl8367_sw_get_vlan_info,
+	},
+};
+
+static const struct switch_dev_ops rtl8367_sw_ops = {
+	.attr_global = {
+		.attr = rtl8367_globals,
+		.n_attr = ARRAY_SIZE(rtl8367_globals),
+	},
+	.attr_port = {
+		.attr = rtl8367_port,
+		.n_attr = ARRAY_SIZE(rtl8367_port),
+	},
+	.attr_vlan = {
+		.attr = rtl8367_vlan,
+		.n_attr = ARRAY_SIZE(rtl8367_vlan),
+	},
+
+	.get_vlan_ports = rtl8367_sw_get_vlan_ports,
+	.set_vlan_ports = rtl8367_sw_set_vlan_ports,
+	.get_port_pvid = rtl8367_sw_get_port_pvid,
+	.set_port_pvid = rtl8367_sw_set_port_pvid,
+	.reset_switch = rtl8367_sw_reset_switch,
+	.get_port_link = rtl8367_sw_get_port_link,
+};
+
+int rtl8367s_swconfig_init(void (*reset_func)(void))
+{
+	struct rtl8367_priv  *priv = &rtl8367_priv_data;
+	struct switch_dev *dev=&priv->swdev;
+	int err=0;
+
+	rtl8367_switch_reset_func = reset_func ;
+	
+	memset(priv, 0, sizeof(struct rtl8367_priv));	
+	priv->global_vlan_enable =0;
+
+	dev->name = "RTL8367C";
+	dev->cpu_port = RTL8367C_SW_CPU_PORT;
+	dev->ports = RTL8367C_NUM_PORTS;
+	dev->vlans = RTL8367C_NUM_VIDS;
+	dev->ops = &rtl8367_sw_ops;
+	dev->alias = "RTL8367C";		
+	err = register_switch(dev, NULL);
+
+	pr_info("[%s]\n",__func__);
+
+	return err;
+}
diff --git a/drivers/net/phy/rtk/rtl8367s_dbg.c b/drivers/net/phy/rtk/rtl8367s_dbg.c
new file mode 100755
index 0000000000000..8ee7fd7fc7d4f
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367s_dbg.c
@@ -0,0 +1,196 @@
+#include <linux/trace_seq.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/u64_stats_sync.h>
+
+#include  "./rtl8367c/include/rtk_switch.h"
+#include  "./rtl8367c/include/port.h"
+#include  "./rtl8367c/include/vlan.h"
+#include  "./rtl8367c/include/rtl8367c_asicdrv_port.h"
+#include  "./rtl8367c/include/stat.h"
+
+static struct proc_dir_entry *proc_reg_dir;
+static struct proc_dir_entry *proc_esw_cnt;
+static struct proc_dir_entry *proc_vlan_cnt;
+
+#define PROCREG_ESW_CNT         "esw_cnt"
+#define PROCREG_VLAN            "vlan"
+#define PROCREG_DIR             "rtk_gsw"
+
+#define RTK_SW_VID_RANGE        16
+
+static void rtk_dump_mib_type(rtk_stat_port_type_t cntr_idx)
+{
+	rtk_port_t port;
+	rtk_stat_counter_t Cntr;
+
+	for (port = UTP_PORT0; port < (UTP_PORT0 + 5); port++) {
+		rtk_stat_port_get(port, cntr_idx, &Cntr);
+		printk("%8llu", Cntr);
+	}
+
+	for (port = EXT_PORT0; port < (EXT_PORT0 + 2); port++) {
+		rtk_stat_port_get(port, cntr_idx, &Cntr);
+		printk("%8llu", Cntr);
+	}
+	
+	printk("\n");
+}
+static void rtk_hal_dump_mib(void)
+{
+
+	printk("==================%8s%8s%8s%8s%8s%8s%8s\n", "Port0", "Port1",
+	       "Port2", "Port3", "Port4", "Port16", "Port17");
+	/* Get TX Unicast Pkts */
+	printk("TX Unicast Pkts  :");
+	rtk_dump_mib_type(STAT_IfOutUcastPkts);
+	/* Get TX Multicast Pkts */
+	printk("TX Multicast Pkts:");
+	rtk_dump_mib_type(STAT_IfOutMulticastPkts);
+	/* Get TX BroadCast Pkts */
+	printk("TX BroadCast Pkts:");
+	rtk_dump_mib_type(STAT_IfOutBroadcastPkts);
+	/* Get TX Collisions */
+	/* Get TX Puase Frames */
+	printk("TX Pause Frames  :");
+	rtk_dump_mib_type(STAT_Dot3OutPauseFrames);
+	/* Get TX Drop Events */
+	/* Get RX Unicast Pkts */
+	printk("RX Unicast Pkts  :");
+	rtk_dump_mib_type(STAT_IfInUcastPkts);
+	/* Get RX Multicast Pkts */
+	printk("RX Multicast Pkts:");
+	rtk_dump_mib_type(STAT_IfInMulticastPkts);
+	/* Get RX Broadcast Pkts */
+	printk("RX Broadcast Pkts:");
+	rtk_dump_mib_type(STAT_IfInBroadcastPkts);
+	/* Get RX FCS Erros */
+	printk("RX FCS Errors    :");
+	rtk_dump_mib_type(STAT_Dot3StatsFCSErrors);
+	/* Get RX Undersize Pkts */
+	printk("RX Undersize Pkts:");
+	rtk_dump_mib_type(STAT_EtherStatsUnderSizePkts);
+	/* Get RX Discard Pkts */
+	printk("RX Discard Pkts  :");
+	rtk_dump_mib_type(STAT_Dot1dTpPortInDiscards);
+	/* Get RX Fragments */
+	printk("RX Fragments     :");
+	rtk_dump_mib_type(STAT_EtherStatsFragments);
+	/* Get RX Oversize Pkts */
+	printk("RX Oversize Pkts :");
+	rtk_dump_mib_type(STAT_EtherOversizeStats);
+	/* Get RX Jabbers */
+	printk("RX Jabbers       :");
+	rtk_dump_mib_type(STAT_EtherStatsJabbers);
+	/* Get RX Pause Frames */
+	printk("RX Pause Frames  :");
+	rtk_dump_mib_type(STAT_Dot3InPauseFrames);
+	/* clear MIB */
+	rtk_stat_global_reset();
+	
+}
+
+static int rtk_hal_dump_vlan(void)
+{
+	rtk_vlan_cfg_t vlan;
+	int i;
+
+	printk("vid    portmap\n");
+	for (i = 0; i < RTK_SW_VID_RANGE; i++) {
+		rtk_vlan_get(i, &vlan);
+		printk("%3d    ", i);
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+	                                UTP_PORT0) ? '1' : '-');
+		printk("%c",
+	       	RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+	                                UTP_PORT1) ? '1' : '-');
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+	                                UTP_PORT2) ? '1' : '-');
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+	                                UTP_PORT3) ? '1' : '-');
+		printk("%c",
+	       	RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+	                                UTP_PORT4) ? '1' : '-');
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+	                                EXT_PORT0) ? '1' : '-');
+		printk("%c",
+		       RTK_PORTMASK_IS_PORT_SET(vlan.mbr,
+	                                EXT_PORT1) ? '1' : '-');
+		printk("\n");
+	}
+	
+	return 0;
+}
+
+
+static int esw_cnt_read(struct seq_file *seq, void *v)
+{
+	rtk_hal_dump_mib();
+	return 0;
+}
+
+static int vlan_read(struct seq_file *seq, void *v)
+{
+	rtk_hal_dump_vlan();
+	return 0;
+}
+
+static int switch_count_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, esw_cnt_read, 0);
+}
+
+static int switch_vlan_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, vlan_read, 0);
+}
+
+static const struct file_operations switch_count_fops = {
+	.owner = THIS_MODULE,
+	.open = switch_count_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release
+};
+
+static const struct file_operations switch_vlan_fops = {
+	.owner = THIS_MODULE,
+	.open = switch_vlan_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release
+};
+
+
+int gsw_debug_proc_init(void)
+{
+
+	if (!proc_reg_dir)
+		proc_reg_dir = proc_mkdir(PROCREG_DIR, NULL);
+
+	proc_esw_cnt =
+	proc_create(PROCREG_ESW_CNT, 0, proc_reg_dir, &switch_count_fops);
+
+	if (!proc_esw_cnt)
+		pr_err("!! FAIL to create %s PROC !!\n", PROCREG_ESW_CNT);
+
+	proc_vlan_cnt =
+	proc_create(PROCREG_VLAN, 0, proc_reg_dir, &switch_vlan_fops);
+
+	if (!proc_vlan_cnt)
+		pr_err("!! FAIL to create %s PROC !!\n", PROCREG_VLAN);
+
+	return 0;
+}
+
+void gsw_debug_proc_exit(void)
+{
+	if (proc_esw_cnt)
+		remove_proc_entry(PROCREG_ESW_CNT, proc_reg_dir);
+}
+
+
diff --git a/drivers/net/phy/rtk/rtl8367s_mdio.c b/drivers/net/phy/rtk/rtl8367s_mdio.c
new file mode 100755
index 0000000000000..a56ef25b3533b
--- /dev/null
+++ b/drivers/net/phy/rtk/rtl8367s_mdio.c
@@ -0,0 +1,312 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+ 
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/of_mdio.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+
+
+#include  "./rtl8367c/include/rtk_switch.h"
+#include  "./rtl8367c/include/port.h"
+#include  "./rtl8367c/include/vlan.h"
+#include  "./rtl8367c/include/rtl8367c_asicdrv_port.h"
+
+struct rtk_gsw {
+ 	struct device           *dev;
+ 	struct mii_bus          *bus;
+	int reset_pin;
+};
+
+static struct rtk_gsw *_gsw;
+
+extern int gsw_debug_proc_init(void);
+extern void gsw_debug_proc_exit(void);
+
+#ifdef CONFIG_SWCONFIG
+extern int rtl8367s_swconfig_init( void (*reset_func)(void) );
+#endif
+
+/*mii_mgr_read/mii_mgr_write is the callback API for rtl8367 driver*/
+unsigned int mii_mgr_read(unsigned int phy_addr,unsigned int phy_register,unsigned int *read_data)
+{
+	struct mii_bus *bus = _gsw->bus;
+
+	mutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);
+
+	*read_data = bus->read(bus, phy_addr, phy_register);
+
+	mutex_unlock(&bus->mdio_lock);
+
+	return 0;
+}
+
+unsigned int mii_mgr_write(unsigned int phy_addr,unsigned int phy_register,unsigned int write_data)
+{
+	struct mii_bus *bus =  _gsw->bus;
+
+	mutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);
+
+	bus->write(bus, phy_addr, phy_register, write_data);
+
+	mutex_unlock(&bus->mdio_lock);
+	
+	return 0;
+}
+
+static int rtl8367s_hw_reset(void)
+{
+	struct rtk_gsw *gsw = _gsw;
+	int ret;
+
+	ret = devm_gpio_request(gsw->dev, gsw->reset_pin, "mediatek,reset-pin");
+
+	if (ret)
+                printk("fail to devm_gpio_request\n");
+
+	gpio_direction_output(gsw->reset_pin, 0);
+
+	usleep_range(1000, 1100);
+
+	gpio_set_value(gsw->reset_pin, 1);
+
+	mdelay(500);
+
+	devm_gpio_free(gsw->dev, gsw->reset_pin);
+
+	return 0;
+	
+}
+
+static int rtl8367s_vlan_config(int want_at_p0)
+{
+	rtk_vlan_cfg_t vlan1, vlan2;
+	
+	/* Set LAN/WAN VLAN partition */
+	memset(&vlan1, 0x00, sizeof(rtk_vlan_cfg_t));
+
+	RTK_PORTMASK_PORT_SET(vlan1.mbr, EXT_PORT0);
+	RTK_PORTMASK_PORT_SET(vlan1.mbr, UTP_PORT1);
+	RTK_PORTMASK_PORT_SET(vlan1.mbr, UTP_PORT2);
+	RTK_PORTMASK_PORT_SET(vlan1.mbr, UTP_PORT3);
+	RTK_PORTMASK_PORT_SET(vlan1.untag, EXT_PORT0);
+	RTK_PORTMASK_PORT_SET(vlan1.untag, UTP_PORT1);
+	RTK_PORTMASK_PORT_SET(vlan1.untag, UTP_PORT2);
+	RTK_PORTMASK_PORT_SET(vlan1.untag, UTP_PORT3);
+  
+	 if (want_at_p0) {
+		RTK_PORTMASK_PORT_SET(vlan1.mbr, UTP_PORT4);
+		RTK_PORTMASK_PORT_SET(vlan1.untag, UTP_PORT4);
+        } else {
+		RTK_PORTMASK_PORT_SET(vlan1.mbr, UTP_PORT0);
+		RTK_PORTMASK_PORT_SET(vlan1.untag, UTP_PORT0);
+        }
+
+	vlan1.ivl_en = 1;
+	
+	rtk_vlan_set(1, &vlan1);
+	
+	memset(&vlan2, 0x00, sizeof(rtk_vlan_cfg_t));
+	
+	RTK_PORTMASK_PORT_SET(vlan2.mbr, EXT_PORT1);
+	RTK_PORTMASK_PORT_SET(vlan2.untag, EXT_PORT1);
+
+	if (want_at_p0) {
+		RTK_PORTMASK_PORT_SET(vlan2.mbr, UTP_PORT0);
+		RTK_PORTMASK_PORT_SET(vlan2.untag, UTP_PORT0);
+	} else {
+		RTK_PORTMASK_PORT_SET(vlan2.mbr, UTP_PORT4);
+		RTK_PORTMASK_PORT_SET(vlan2.untag, UTP_PORT4);
+	}
+
+	vlan2.ivl_en = 1;
+	rtk_vlan_set(2, &vlan2);
+
+	rtk_vlan_portPvid_set(EXT_PORT0, 1, 0);
+	rtk_vlan_portPvid_set(UTP_PORT1, 1, 0);
+	rtk_vlan_portPvid_set(UTP_PORT2, 1, 0);
+	rtk_vlan_portPvid_set(UTP_PORT3, 1, 0);
+	rtk_vlan_portPvid_set(EXT_PORT1, 2, 0);
+
+	if (want_at_p0) {
+		rtk_vlan_portPvid_set(UTP_PORT0, 2, 0);
+		rtk_vlan_portPvid_set(UTP_PORT4, 1, 0);
+	} else {
+		rtk_vlan_portPvid_set(UTP_PORT0, 1, 0);
+		rtk_vlan_portPvid_set(UTP_PORT4, 2, 0);
+	}
+
+	return 0;	
+}
+
+static int rtl8367s_hw_init(void)
+{
+
+	rtl8367s_hw_reset();
+
+	if(rtk_switch_init())
+	        return -1;
+
+	mdelay(500);
+
+	if (rtk_vlan_reset())
+	        return -1;
+
+	if (rtk_vlan_init())
+	        return -1;
+
+	return 0;
+}
+
+static void set_rtl8367s_sgmii(void)
+{
+	rtk_port_mac_ability_t mac_cfg;
+	rtk_mode_ext_t mode;
+
+	mode = MODE_EXT_HSGMII;
+	mac_cfg.forcemode = MAC_FORCE;
+	mac_cfg.speed = PORT_SPEED_2500M;
+	mac_cfg.duplex = PORT_FULL_DUPLEX;
+	mac_cfg.link = PORT_LINKUP;
+	mac_cfg.nway = DISABLED;
+	mac_cfg.txpause = ENABLED;
+	mac_cfg.rxpause = ENABLED;
+	rtk_port_macForceLinkExt_set(EXT_PORT0, mode, &mac_cfg);
+	rtk_port_sgmiiNway_set(EXT_PORT0, DISABLED);
+	rtk_port_phyEnableAll_set(ENABLED);
+
+}
+
+static void set_rtl8367s_rgmii(void)
+{
+	rtk_port_mac_ability_t mac_cfg;
+	rtk_mode_ext_t mode;
+
+	mode = MODE_EXT_RGMII;
+	mac_cfg.forcemode = MAC_FORCE;
+	mac_cfg.speed = PORT_SPEED_1000M;
+	mac_cfg.duplex = PORT_FULL_DUPLEX;
+	mac_cfg.link = PORT_LINKUP;
+	mac_cfg.nway = DISABLED;
+	mac_cfg.txpause = ENABLED;
+	mac_cfg.rxpause = ENABLED;
+	rtk_port_macForceLinkExt_set(EXT_PORT1, mode, &mac_cfg);
+	rtk_port_rgmiiDelayExt_set(EXT_PORT1, 1, 3);
+	rtk_port_phyEnableAll_set(ENABLED);
+	
+}
+
+void init_gsw(void)
+{
+	rtl8367s_hw_init();
+	set_rtl8367s_sgmii();
+	set_rtl8367s_rgmii();
+}
+
+// bleow are platform driver
+static const struct of_device_id rtk_gsw_match[] = {
+	{ .compatible = "mediatek,rtk-gsw" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rtk_gsw_match);
+
+static int rtk_gsw_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *mdio;
+	struct mii_bus *mdio_bus;
+	struct rtk_gsw *gsw;
+	const char *pm;
+
+	mdio = of_parse_phandle(np, "mediatek,mdio", 0);
+
+	if (!mdio)
+		return -EINVAL;
+
+	mdio_bus = of_mdio_find_bus(mdio);
+
+	if (!mdio_bus)
+		return -EPROBE_DEFER;
+
+	gsw = devm_kzalloc(&pdev->dev, sizeof(struct rtk_gsw), GFP_KERNEL);
+	
+	if (!gsw)
+		return -ENOMEM;	
+
+	gsw->dev = &pdev->dev;
+
+	gsw->bus = mdio_bus;
+
+	gsw->reset_pin = of_get_named_gpio(np, "mediatek,reset-pin", 0);
+
+	if (gsw->reset_pin < 0)
+		return -1;
+
+	_gsw = gsw;
+
+	init_gsw();
+
+	//init default vlan or init swocnfig
+	if(!of_property_read_string(pdev->dev.of_node,
+						"mediatek,port_map", &pm)) {
+
+		if (!strcasecmp(pm, "wllll"))
+			rtl8367s_vlan_config(1); 
+		else
+			rtl8367s_vlan_config(0);
+		
+		} else {
+#ifdef CONFIG_SWCONFIG		
+		rtl8367s_swconfig_init(&init_gsw);
+#else
+		rtl8367s_vlan_config(0);
+#endif
+	}
+
+	gsw_debug_proc_init();
+
+	platform_set_drvdata(pdev, gsw);
+
+	return 0;
+	
+}
+
+static int rtk_gsw_remove(struct platform_device *pdev)
+{
+	platform_set_drvdata(pdev, NULL);
+	gsw_debug_proc_exit();
+
+	return 0;
+}
+
+static struct platform_driver gsw_driver = {
+	.probe = rtk_gsw_probe,
+	.remove = rtk_gsw_remove,
+	.driver = {
+		.name = "rtk-gsw",
+		.owner = THIS_MODULE,
+		.of_match_table = rtk_gsw_match,
+	},
+};
+
+module_platform_driver(gsw_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mark Lee <marklee0201@gmail.com>");
+MODULE_DESCRIPTION("rtl8367c switch driver for MT7622");
+
